- en: Spring Microservices on Cloud Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云平台上的Spring微服务
- en: Pivotal defines Spring Cloud as a framework that accelerates cloud-native application
    development. Today, when we talk about cloud-native applications, the first thing that
    comes to mind is the ability to deliver software quickly. To meet these demands,
    we should be able to quickly build new applications and design architectures that
    are scalable, portable, and prepared to be frequently updated. The tools that
    provide the mechanisms for containerization and orchestration help us in setting
    up and maintaining such an architecture. In fact, tools such as Docker or Kubernetes,
    which we have looked at in previous chapters, allow us to create our own private
    cloud and run Spring Cloud microservices on it. Although an application does not
    have to be deployed on a public cloud, it contains all of the most important characteristics
    of cloud software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal将Spring Cloud定义为一个加速云原生应用程序开发的框架。今天，当我们谈论云原生应用程序时，首先想到的是快速交付软件的能力。为了满足这些需求，我们应该能够快速构建新的应用程序并设计可扩展、可移植且准备频繁更新的架构。提供容器化和编排机制的工具帮助我们设置和维护此类架构。实际上，像Docker或Kubernetes这样的工具，我们在之前的章节中已经探讨过，允许我们创建自己的私有云并在其上运行Spring
    Cloud微服务。尽管应用程序不必部署在公共云上，但它包含了云软件最重要的特性。
- en: Deploying your Spring application on a public cloud is just a possibility, not
    a necessity. However, there are some really interesting cloud platforms that allow
    you to easily run microservices and expose them on the web in just a few minutes.
    One of those platforms is **Pivotal Cloud Foundry** (**PCF**); its advantage over
    other platforms is its native support for Spring Cloud services, including discovery
    with Eureka, Config Server, and circuit breaker with Hystrix. You can also easily
    set up a full microservices environment just by enabling brokered services provided
    by Pivotal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云上部署您的Spring应用程序只是一个可能性，而不是必需的。然而，确实有一些非常有趣的云平台，可以让您在几分钟内轻松运行微服务并将它们暴露在网络上。其中一个平台是**Pivotal
    Cloud Foundry**（**PCF**）；它与其他平台相比的优势在于其对Spring Cloud服务的原生支持，包括使用Eureka的发现、Config
    Server以及使用Hystrix的断路器。您还可以通过启用Pivotal提供的托管服务轻松设置完整的微服务环境。
- en: Another cloud platform that we should mention is Heroku. In contrast to PCF,
    it does not favor any programming framework. Heroku is a fully-managed, multi-language
    platform that allows you to quickly deliver software. It can build and run applications
    automatically once you have pushed changes in the source code stored on the GitHub
    repository. It also offers many add-on services that can be provisioned and scaled
    with a single command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提到的另一个云平台是Heroku。与PCF相比，它不偏爱任何编程框架。Heroku是一个全托管的、多语言平台，可以让您快速交付软件。一旦您将存储在GitHub仓库中的源代码更改推送到Heroku，它就可以自动构建和运行应用程序。它还提供许多可以单命令部署和扩展的附加服务。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Introduction to Pivotal Web Services platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal Web Services平台简介
- en: Deploying and managing applications on Pivotal Cloud Foundry using CLI, the
    Maven plugin, and the UI dashboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI、Maven插件和UI仪表板在Pivotal Cloud Foundry上部署和管理应用程序
- en: Using Spring Cloud Foundry libraries to prepare an application to work properly
    on the platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Foundry库准备应用程序以在平台上正确运行
- en: Deploying Spring Cloud microservices on the Heroku platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku平台上部署Spring Cloud微服务
- en: Managing brokered services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理托管服务
- en: Pivotal Cloud Foundry
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry
- en: 'Although the Pivotal platform can run applications written in many languages,
    including Java, .NET, Ruby, JavaScript, Python, PHP, and Go, it has the best support
    for Spring Cloud Services and Netflix OSS tools. It makes perfect sense because
    they are the ones who developed Spring Cloud. Take a look at the following diagram,
    which is also available on Pivotal''s official website. The following diagram
    illustrates the microservices-based architecture provided by the Pivotal Cloud
    platform. You can use Spring Cloud on Cloud Foundry to quickly leverage common
    microservice patterns, including distributed configuration management, service
    discovery, dynamic routing, load balancing, and fault tolerance:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Pivotal平台可以运行用多种语言编写的应用程序，包括Java、.NET、Ruby、JavaScript、Python、PHP和Go，但它对Spring
    Cloud Services和Netflix OSS工具的支持最为出色。这是有道理的，因为它们是开发Spring Cloud的人。看看下面的图表，也可在Pivotal的官方网站上找到。下面的图表说明了Pivotal
    Cloud平台提供的基于微服务的架构。你可以在Cloud Foundry上使用Spring Cloud快速利用常见的微服务模式，包括分布式配置管理、服务发现、动态路由、负载均衡和容错：
- en: '![](img/5b400ae4-44d3-4476-9425-dfe2194be84e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b400ae4-44d3-4476-9425-dfe2194be84e.png)'
- en: Usage models
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型
- en: 'You can use the Pivotal platform in three different models. Models are distinguished
    based on the host, which is where the applications are deployed. The following
    is a list of the available solutions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以三种不同的模型使用Pivotal平台。模型是根据宿主区分，这是应用程序被部署的地方。以下是可用的解决方案列表：
- en: '**PCF Dev**: This instance of the Pivotal platform can be run locally on a
    single virtual machine. It is designed for experimental and developmental needs.
    It does not offer all possible features and services. For example, there are only
    some built-in services, such as Redis, MySQL, and RabbitMQ. However, PCF Dev also
    supports **Spring Cloud Services** (**SCS**), as well as all the languages supported
    in the full version of PCF. It is worth noting that if you want to run PCF Dev
    locally with SCS, you need more than 6 GB of RAM available.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PCF Dev**: 这个Pivotal平台的实例可以在单个虚拟机上本地运行。它旨在满足实验和开发的需求。它并不提供所有可能的特性和服务。例如，它只有一些内置服务，如Redis、MySQL和RabbitMQ。然而，PCF
    Dev也支持**Spring Cloud Services**（**SCS**），以及PCF完整版本中支持的所有语言。需要注意的是，如果你想本地运行带有SCS的PCF
    Dev，你需要有超过6GB的可用RAM。'
- en: '**Pivotal Web Services**: This is a cloud-native platform available online
    at  [https://run.pivotal.io/](https://run.pivotal.io/).  It''s like Pivotal Cloud
    Foundry with hosted, pay-by-the-hour pricing. It does not offer all the features
    and services available in Pivotal Cloud Foundry. For example, we may only enable
    services offered by SaaS partners of Pivotal. Pivotal Web Services is best suited
    for startups or individual teams. We will use this model of Pivotal platform hosting
    for presentation purposes in upcoming sections of this chapter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pivotal Web Services**: 这是一个在线的云原生平台，网址为[https://run.pivotal.io/](https://run.pivotal.io/)。它就像Pivotal
    Cloud Foundry，但有由SaaS合作伙伴提供的服务，以及按小时计费的托管服务。它并不提供Pivotal Cloud Foundry中可用的所有特性和服务。Pivotal
    Web Services最适合初创公司或个人团队。在本书接下来的部分，我们将使用这个Pivotal平台托管模型进行展示。'
- en: '**Pivotal Cloud Foundry**: This is a full-featured cloud-native platform that
    runs on any major public IaaS, including AWS, Azure, and Google Cloud Platform,
    or on a private cloud based on OpenStack or VMware vSphere. It''s a commercial
    solution for large enterprise environments.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pivotal Cloud Foundry**：这是一个功能全面的云原生平台，可以在任何主要的公共IaaS上运行，包括AWS、Azure和Google
    Cloud Platform，或者基于OpenStack或VMware vSphere的私有云上运行。这是一个针对大型企业环境的商业解决方案。'
- en: Preparing the application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: 'Since Pivotal Web Services has native support for Spring Cloud applications,
    the deployment process is very straightforward. However, it does require specific
    dependencies and configuration on the application side—especially if your microservices
    have to integrate with built-in services provided by Pivotal platforms such as
    Service Registry, Config Server, or Circuit Breaker. Besides standard dependency
    management for Spring Cloud, we should also include `spring-cloud-services-dependencies`
    in `pom.xml` with the newest version working with the `Edgware.SR2` release train,
    shown as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pivotal Web Services对Spring Cloud应用有本地支持，所以部署过程非常简单。但是，它需要在应用程序方面指定特定的依赖项和配置—特别是如果你的微服务必须与Pivotal平台提供的内置服务（如服务注册表、配置服务器或断路器）集成。除了Spring
    Cloud的标准依赖管理外，我们还应该在`pom.xml`中包括`spring-cloud-services-dependencies`，并且是与`Edgware.SR2`发布列车一起工作的最新版本，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Depending on the chosen services for integration you may want to include the
    following artifacts in your project. We decided to use all of the Spring Cloud
    features provided by the Pivotal platform, so our microservices fetch properties
    for a configuration server, register themselves in Eureka, and wrap inter-service
    communication with Hystrix commands. Here are the dependencies required for enabling
    discovery client, config client, and circuit breaker for an application deployed
    on the Pivotal platform:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所选的集成服务，您可能希望将以下工件包括在您的项目中。我们决定使用Pivotal平台提供的所有Spring Cloud功能，因此我们的微服务从配置服务器获取属性，在Eureka中注册自己，并将服务间通信封装在Hystrix命令中。以下是为在Pivotal平台上部署的应用程序启用发现客户端、配置客户端和断路器所需的依赖项：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will provide one more integration for our sample microservices. All of them
    will store data in MongoDB, which is also available as a service on the Pivotal
    platform. To achieve it, we should first include starter `spring-boot-starter-data-mongodb`
    in the project dependencies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的示例微服务提供另一个集成。它们都将将数据存储在MongoDB中，该MongoDB也作为Pivotal平台上的服务提供。为了实现这一点，我们首先应该在项目依赖项中包括启动器`spring-boot-starter-data-mongodb`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A MongoDB address should be provided in configuration settings using the `spring.data.mongodb.uri`
    property. In order to allow an application to connect with MongoDB, we have to
    create a Pivotal''s service mLab and then bind it to the application. By default,
    metadata related to the bound services are exposed to the application as the environment
    variable `$VCAP_SERVICES`. The main motivation for such an approach is that Cloud
    Foundry has been designed to be a polyglot, meaning that any language and platform
    can be supported as a buildpack. All Cloud Foundry properties may be injected
    using the `vcap` prefix. If you would like to access Pivotal''s service, you should
    use the `vcap.services` prefix and then pass the service''s name shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置设置中应使用`spring.data.mongodb.uri`属性提供MongoDB地址。为了允许应用程序与MongoDB连接，我们必须创建一个Pivotal的服务mLab，然后将其绑定到应用程序。默认情况下，与绑定服务相关的元数据作为环境变量`$VCAP_SERVICES`暴露给应用程序。这种方法的主要动机是，Cloud
    Foundry被设计为多语言的，这意味着任何语言和平台都可以作为构建包支持。所有Cloud Foundry属性都可以使用`vcap`前缀注入。如果您想访问Pivotal的服务，您应该使用`vcap.services`前缀，然后传递如下所示的服务名称：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In fact, this is all that needs to be done on the application side to make
    them work properly with the components created on the Pivotal platform. Now we
    just have to enable Spring Cloud features in the same way as we did for a standard
    microservice written in Spring, as shown in the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，应用程序方面需要做的就是与在Pivotal平台上创建的组件正确配合。现在我们只需要像对用Spring编写的标准微服务一样启用Spring Cloud功能，如下例所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Deploying the application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Applications can be managed on the **Pivotal Web Service** (**PWS**) platform
    in three different ways. The first is through a web console available at [https://console.run.pivotal.io](https://console.run.pivotal.io).
    We may monitor, scale, restart deployed applications, enable and disable services,
    define new quotas, and change account settings in this way. However, it is not
    possible to do this using a web console—in other words, an initial application
    deployment. It may be performed using a **CLI** (**command-line interface**).
    You can download the required installer from the [pivotal.io](https://pivotal.io) website.
    After installation, you should be able to invoke the Cloud Foundry CLI on your
    machine by typing `cf`, for example, `cf help`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过三种不同的方式在**Pivotal Web Service**（**PWS**）平台上进行管理。第一种是通过位于[https://console.run.pivotal.io](https://console.run.pivotal.io)的web控制台。我们可以通过这种方式监控、扩展、重新启动部署的应用程序，启用和禁用服务，定义新的配额，更改账户设置。然而，使用web控制台无法完成这项工作——也就是说，初始应用程序部署。这可以通过**CLI**（**命令行界面**）完成。您可以从[pivotal.io](https://pivotal.io)网站下载所需的安装程序。安装后，您应该能够在您的机器上通过输入`cf`来调用Cloud
    Foundry CLI，例如，`cf help`。
- en: Using CLI
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI
- en: 'CLI provides a set of commands that allows you to manage your applications,
    brokered services, spaces, domains, and other components on Cloud Foundry. Let
    me show you the most important commands you should know to be able to run your
    application on PWS:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CLI提供了一组命令，允许您管理在Cloud Foundry上的应用程序、有偿服务、空间、域和其他组件。让我向您展示一些最重要的命令，您需要了解这些命令才能在PWS上运行您的应用程序：
- en: 'In order to deploy the application, you must first navigate to its directory.
    You should then sign in to PWS using the `cf login` command as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署应用程序，你首先必须导航到其目录。然后使用以下`cf login`命令登录PWS：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to push the application to PWS with the `cf push` command,
    passing the service''s name:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`cf push`命令将应用程序推送到PWS，并传递服务的名称：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can provide `manifest.yml` in the application''s root directory
    with all the required deployment settings. In that case, all you need is to run
    the `cf push` command without any additional parameters, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，你可以在应用程序的根目录下提供`manifest.yml`文件，其中包含所有必需的部署设置。在这种情况下，你只需要运行没有任何额外参数的`cf push`命令，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Deployment with the configuration settings provided in `manifest.yml` as shown
    in the preceding example will fail. To see why, run the command `cf logs`. The
    reason is an insufficient memory limit for heap:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`manifest.yml`中提供的配置设置部署将失败。要了解原因，请运行命令`cf logs`。原因是堆内存限制不足：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, the platform allocates 240 MB for the code cache, 140 MB for metaspace,
    and 1 MB for every thread, with an assumption that there is a maximum of 200 threads
    for the Tomcat connector. It is easy to calculate that, with these settings, every
    application needs around 650 MB of allocated memory. We may change these settings
    by calling the `cf set-env` command and passing the `JAVA_OPTS` parameter, as
    you can see in the following sample. Such a memory limit would not be enough in
    production mode but would be okay for testing purposes. To ensure that these changes
    take affect, use the `cf restage` command as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，平台为代码缓存分配了240 MB，为元空间分配了140 MB，并为每个线程分配了1 MB，假设Tomcat连接器最多有200个线程。很容易计算出，根据这些设置，每个应用程序需要大约650
    MB的分配内存。我们可以通过调用`cf set-env`命令并传递`JAVA_OPTS`参数来更改这些设置，如您在以下示例中看到的。这样的内存限制在生产模式中是不够的，但在测试目的上应该是可以的。为确保这些更改生效，使用以下`cf
    restage`命令：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Allocated memory is important, especially if there is only 2 GB RAM available
    for a free account. With the default memory settings applied, we can only deploy
    two applications on the Pivotal platform, as each of them takes up 1 GB of RAM.
    Although we have fixed the problems described previously, our application still
    does not work properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的内存很重要，特别是如果只有2 GB RAM可供免费账户使用。应用默认的内存设置，我们只能在Pivotal平台上部署两个应用程序，因为每个应用程序都会占用1
    GB的RAM。尽管我们解决了前面描述的问题，但我们的应用程序仍然无法正常工作。
- en: Binding to services
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定服务
- en: 'During boot, the applications were not able to connect with the required services.
    The problem occurs because services are not bound by default to the applications.
    You can display all of the services created in your space by running the command
    `cf services`, and bind each of them to a given microservice by invoking the command
    `cf bind-service`. In the following example command''s executions, we have bound
    Eureka, configuration server, and MongoDB to `account-service`. Finally, we can
    run `cf restage` once more and everything should work fine, shown as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，应用程序无法与所需服务连接。问题发生是因为服务默认情况下不会绑定到应用程序。你可以通过运行命令`cf services`来显示你在你的空间中创建的所有服务，并通过调用命令`cf
    bind-service`将每个服务绑定到给定的微服务。在以下命令执行示例中，我们将Eureka、配置服务器和MongoDB绑定到`account-service`。最后，我们再次运行`cf
    restage`，一切应该都能正常工作，如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the Maven plugin
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven插件
- en: As we have mentioned before, CLI and the web console are not the only ways to
    manage your application on the Pivotal platform. The Cloud Foundry team has implemented
    the Maven plugin in order to facilitate and speed up application deployment. What's
    interesting is that the same plugin can be used to manage pushes and updates to
    any Cloud Foundry instance, not only those provided by Pivotal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，CLI和Web控制台并不是在Pivotal平台上管理应用程序的唯一方式。Cloud Foundry团队已经实现了Maven插件，以促进和加快应用程序的部署。有趣的是，同一个插件可以用来管理任何Cloud
    Foundry实例的推送和更新，不仅仅是由Pivotal提供的实例。
- en: 'When using Cloud Foundry''s Maven plugin you can easily integrate cloud deployments
    into their Maven projects'' life cycles. This allows you to push, remove, and
    update projects in Cloud Foundry. If you would like to push your project together
    with Maven, just run the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Cloud Foundry的Maven插件时，你可以轻松地将云部署集成到他们的Maven项目的生命周期中。这允许你在Cloud Foundry中推送、删除和更新项目。如果你想要与Maven一起推送你的项目，只需运行以下命令：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Generally, the commands provided by the Maven plugin are pretty similar to
    the commands offered by CLI. For example, you can display a list of applications
    by executing the command `mvn cf:apps`. In order to delete an application, run
    the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Maven插件提供的命令与CLI提供的命令非常相似。例如，你可以通过执行命令`mvn cf:apps`来显示应用程序列表。要删除一个应用程序，请运行以下命令：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you would like to upload some changes to the existing application, use the `cf:update`
    command as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要上传一些更改到现有应用程序，请使用以下`cf:update`命令：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before running any commands, we have to configure the plugin properly. First,
    it is required to pass Cloud Foundry login credentials. It is recommended to store
    them separately in Maven''s `settings.xml`. A typical entry inside a server tag
    might look like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何命令之前，我们必须正确配置插件。首先，需要传递Cloud Foundry登录凭据。建议将它们单独存储在Maven的`settings.xml`中。服务器标签内的典型条目可能如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the Maven plugin instead of CLI commands has one important advantage:
    you can configure all the necessary configuration settings in one place and can
    apply them using a single command during application build. The full configuration
    of the plugin is shown in the following snippet. Besides some basic settings including
    space, memory, and a number of instances, it''s also possible to change memory
    limits with the `JAVA_OPTS` environment variable and by binding the required services
    to the application. After running the `cf:push` command, `product-service` is
    ready to use at the address `https://product-service-piomin.cfapps.io/`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven插件而不是CLI命令有一个重要的优势：你可以在一个地方配置所有必要的配置设置，并在应用构建时使用一个命令应用它们。插件的完整配置如下所示。除了包括空间、内存和实例数量等一些基本设置外，还可以通过`JAVA_OPTS`环境变量和将所需服务绑定到应用程序来改变内存限制。在运行`cf:push`命令后，`product-service`可以在`https://product-service-piomin.cfapps.io/`地址上使用：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Maintenance
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护
- en: Assuming all of the applications forming our example microservices-based system
    have been successfully deployed, we can easily manage and monitor them using the
    Pivotal Web Services dashboard, or even just CLI commands. The free trial provided
    by the Pivotal platform gives us a lot of possibilities and tools for maintaining
    applications, so let's discover some of its most interesting features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功部署了构成我们示例微服务系统的所有应用程序，我们可以使用Pivotal Web Services仪表板轻松地管理和监控它们，甚至只需使用CLI命令。Pivotal平台提供的免费试用为我们维护应用程序提供了许多可能性和工具，所以让我们探索它的一些最有趣的功能。
- en: Accessing deployment details
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问部署详情
- en: 'We can list all of the deployed applications by running the command `cf apps`
    or by navigating to the main site of our space in the web console. You can see
    that list in the following screenshot. Each row of the table represents a single
    application. Besides its name, there is also information about its status, the
    number of instances, allocated memory, deployment time, and a URL at which a service
    is available outside the platform. If you didn''t specify a URL address during
    application deployment, it is automatically generated:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`cf apps`命令或通过在Web控制台中导航到我们空间的主页来列出所有已部署的应用程序。你可以在下面的屏幕截图中看到这个列表。表格的每一行代表一个单独的应用程序。除了它的名称外，还有关于其状态、实例数量、分配的内存、部署时间和平台外可访问服务的外部URL的信息。如果你在应用部署时没有指定一个URL地址，它会自动生成：
- en: '![](img/d7008b6a-1a4a-48f7-ae30-e023ba2cdea5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7008b6a-1a4a-48f7-ae30-e023ba2cdea5.png)'
- en: 'You can click each row in order to discover details about the application.
    Similar information can be accessed using the CLI commands `cf app <app-name> `or  `cf
    app order-service`. The following screenshot shows the main panel of an application''s
    detailed view that contains the history of events, summary, as well as memory,
    disk, and CPU usage of every instance. In this panel, you may scale an application
    by clicking the Scale button. There are also several other tabs available. By
    switching to one of them, you can check out all bounded services (Services), external
    URLs assigned (Rules), display logs (Logs), and incoming requests history (Trace):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击每一行以发现有关应用程序的详细信息。使用CLI命令`cf app <app-name>`或`cf app order-service`也可以获取类似的信息。下面的屏幕截图显示了一个应用程序详细视图的主要面板，其中包含事件历史、摘要以及每个实例的内存、磁盘和CPU使用情况。在这个面板中，你可以通过点击缩放按钮来扩展应用程序。还有几个其他标签可用。通过切换到其中一个，你可以查看所有绑定服务（服务）、分配的外部URL（规则）、显示日志（日志）和传入请求历史（追踪）：
- en: '![](img/c7138419-e97b-4074-ba2a-8d63462ee396.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7138419-e97b-4074-ba2a-8d63462ee396.png)'
- en: 'Of course, you can always use the CLI to collect the same details as shown
    in the previous example. If you execute the command `cf logs <app-name>`, you
    would be attached to `stdout` , which is generated by the application. You can
    also display the list of activated Pivotal managed services with the list of bound
    applications, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以使用CLI来收集前例中显示的相同细节。如果你执行命令`cf logs <app-name>`，你会附加到由应用程序生成的`stdout`。你还可以显示已激活的Pivotal管理服务的列表，以及绑定应用程序的列表，如下面的截图所示：
- en: '![](img/49fb545e-aaf7-4097-ac10-3b696d072ac7.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49fb545e-aaf7-4097-ac10-3b696d072ac7.png)'
- en: Managing application life cycles
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序生命周期
- en: 'Another really helpful feature provided by Pivotal Web Services is the ability
    to manage an application''s life cycle. In other words, we can easily stop, start,
    and restart an application with just one click. Before executing the requested
    command, you will be prompted for confirmation, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal Web Services提供的另一个非常有用的功能是管理应用程序生命周期的能力。换句话说，我们只需点击一次就可以轻松地停止、启动和重新启动一个应用程序。在执行请求的命令之前，你会被提示确认，如下面的截图所示：
- en: '![](img/39623686-56f6-4fc7-896d-fdea0b62651c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39623686-56f6-4fc7-896d-fdea0b62651c.png)'
- en: 'The same result can be achieved by running one of the following CLI commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任一CLI命令运行可以达到相同的效果：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scaling
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'One of the most important reasons for using cloud solutions is the ability
    to scale your applications easily. The Pivotal platform deals with these issues
    in a very intuitive way. Firstly, you may decide how many instances of an application
    are started at each stage of deployment. For example, if you decided to use `manifest.yml`
    and deploy it with the `cf push` command, the number of created instances will
    be determined by field instances, as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云解决方案最重要的原因之一是能够轻松扩展应用程序。Pivotal平台以非常直观的方式处理这些问题。首先，你可能决定在每个部署阶段启动应用程序的实例数量。例如，如果你决定使用`manifest.yml`并使用`cf
    push`命令部署它，创建的实例数量将由字段实例决定，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The number of running instances, as well as memory and CPU limits, can be modified
    on the started application. In fact, there are two available approaches to scaling.
    You can either manually set how many instances should be launched or enable autoscaling,
    where you only need to define a criteria based on a selected metric''s thresholds.
    Autoscaling on the Pivotal platform is realized by a tool called **PCF App Autoscaler**.
    We can choose from the following five available rules, and they are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行实例的数量，以及内存和CPU的限制，可以在启动的应用程序中进行修改。实际上，有两种可用的扩展方法。你可以手动设置应该启动多少实例，或者启用自动扩展，你只需要基于选定指标的阈值定义一个标准。Pivotal平台上的自动扩展是通过一个名为**PCF
    App Autoscaler**的工具实现的。我们可以从以下五个可用的规则中选择，如下所示：
- en: CPU utilization
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU利用率
- en: Memory utilization
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存利用率
- en: HTTP latency
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP延迟
- en: HTTP throughput
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP吞吐量
- en: RabbitMQ depth
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ深度
- en: 'You can define more than one active rule. Each of these rules has a minimum
    value per every single metric for scaling down and a maximum value for scaling
    up. Autoscale settings for `customer-service` are shown in the following screenshot.
    Here, we decided to apply HTTP throughput and HTTP latency rules. If latency for
    99% of traffic is lower than `20` ms, one instance of an application should be
    disabled in case there is more than one instance. Analogously, if a latency is
    greater than `200` ms, the platform should attach one more instance:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义多个活跃规则。每个这些规则都有每个单一指标缩放 down 的最小值和缩放 up 的最大值。`customer-service`的自动扩展设置如下面的截图所示。在这里，我们决定应用HTTP吞吐量和HTTP延迟规则。如果99%的流量延迟低于`20`毫秒，应该禁用一个应用程序实例，以防有多个实例。类似地，如果延迟超过`200`毫秒，平台应该附加一个更多的实例：
- en: '![](img/f2434974-9f83-409d-a93e-9c1aec8cc445.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2434974-9f83-409d-a93e-9c1aec8cc445.png)'
- en: 'We can also control the number of running instances manually. Autoscaling has
    many advantages but a manual approach gives you more control over that process.
    Thanks to limited memory for each application, there is still space for other
    instances. The most overloaded application in our example system is `account-service`,
    because it is called during an order''s creation as well as order''s confirmation.
    So, let''s add one more instance of that microservice. To do so, go to the `account-service`
    details panel and click on Scale under Processes and Instances. You should then
    increase the number of instances and apply the necessary changes; you should then
    see two instances of `account-service` available, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以手动控制运行实例的数量。自动扩展有很多优点，但手动方法能让你对这个过程有更多的控制权。由于每个应用程序的内存有限，仍有多余的空间用于其他实例。我们示例系统中压力最大的应用程序是`account-service`，因为它在订单创建以及订单确认时都会被调用。所以，让我们为这个微服务添加一个实例。为此，请前往`account-service`详情面板，点击进程和实例下的扩展。然后，你应该增加实例数量并应用必要的更改；你应该会看到`account-service`有两个实例可用，如下面的屏幕截图所示：
- en: '![](img/869909e6-33a2-4151-84d1-ecfae35dad37.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/869909e6-33a2-4151-84d1-ecfae35dad37.png)'
- en: Provisioning brokered services
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管服务的部署
- en: We have already looked at how to bind an application to a service using the `cf
    bind-service` command and the Maven plugin. However, we should now look at how
    to enable and configure our service. You can easily display a list of all the
    available services and then enable them using Pivotal's dashboard; this can be
    found under Marketplace.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了如何使用`cf bind-service`命令和Maven插件将应用程序绑定到服务。然而，我们现在应该看看如何启用和配置我们的服务。你可以轻松显示所有可用服务的列表，然后使用Pivotal的仪表板启用它们；这可以在市场下找到。
- en: 'The provisioning of a brokered service with Pivotal Web Services is very easy.
    After installation, some services are already available to use without any additional
    configuration. All we have to do is to bind them to selected applications and
    properly pass their network addresses in the application''s settings. Every application
    can be easily bound to a service using the UI dashboard. First, navigate to the
    main page of the service. There, you will see a list of the currently bound applications.
    You can bind a new application to the service by clicking BIND APP and then choosing
    one from the list displayed, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pivotal Web Services提供的托管服务非常简单。安装后，一些服务无需任何额外配置即可使用。我们只需要将它们绑定到选定的应用程序，并在应用程序的设置中正确传递它们的网络地址。每个应用程序都可以通过UI仪表板轻松绑定到服务。首先，导航到服务的主页面。在那里，你会看到当前已绑定应用程序的列表。你可以通过点击绑定应用并从显示的列表中选择一个来将新应用程序绑定到服务，如下面的屏幕截图所示：
- en: '![](img/035ead31-9dd9-40a4-9da5-ba408e11c627.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/035ead31-9dd9-40a4-9da5-ba408e11c627.png)'
- en: 'You don''t have to do anything more than enable the registry service in the
    marketplace and bind it to the application in order to enable the discovery feature
    on Pivotal Web Services. Of course, you can override some configuration settings
    on the client-side if needed. A full list of registered applications can be displayed
    in the Eureka dashboard under Manage in the main configuration panel of the service.
    There are two running instances of `account-service` because we scaled it up in
    the previous section; the other microservices however have only one running instance,
    shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在市场上下启用注册表服务并将其绑定到应用程序，就可以在Pivotal Web Services上启用发现功能。当然，如果需要，你可以在客户端覆盖一些配置设置。可以在服务的主要配置面板下的管理中显示注册的所有应用程序的完整列表。由于我们在上一节中扩展了它，`account-service`有两个运行实例；其他微服务只有一个运行实例，如下所示：
- en: '![](img/ef76969f-c91d-408d-806f-f8a65b90e841.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef76969f-c91d-408d-806f-f8a65b90e841.png)'
- en: 'In contrast to a discovery service, a configuration server needs to include
    additional settings. As before, you should navigate to its main panel and then
    select Manage. Here, you will be redirected to the configuration form. The configuration
    parameters have to be provided there as a JSON object. The `count` parameter specifies
    the number of nodes needed for provision, upgrade options if an instance can be
    upgraded, and `force` forces that upgrade even if the instance is already the
    latest available version. Other configuration parameters are dependent on a type
    of backend used to store property sources. As you may remember from [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*, the most popular solution for Spring
    Cloud Config Server is based on the Git repository. We have created an example
    repository on GitHub, where all the required sources have been committed. The
    following are the parameters in a JSON format that should be provided for a Config
    Server on Pivotal Web Services:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与发现服务相比，配置服务器需要包括额外的设置。像以前一样，你应该导航到它的主面板，然后选择“管理”。在这里，你会被重定向到配置表单。配置参数必须以JSON对象的形式提供在那里。`count`参数指定了需要预配的节点的数量，如果实例可以升级的升级选项，以及`force`即使实例已经是可用的最新版本也强制升级。其他配置参数取决于用于存储属性源的后端类型。正如您可能还记得[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)，*使用Spring
    Cloud Config进行分布式配置*，Spring Cloud Config Server最受欢迎的解决方案是基于Git仓库的。我们在GitHub上创建了一个示例仓库，其中提交了所有所需的源代码。以下是在Pivotal
    Web Services上为Config Server提供的JSON格式的参数：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last brokered service used by the example application provided hosted an
    instance of MongoDB. After navigating to Manage on the main panel of that service,
    you should be redirected to [https://mlab.com/home](https://mlab.com/home) , where
    you will be able to use the database's node.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序使用的最后一个代理服务托管了一个MongoDB实例。在服务的管理主面板中导航到“管理”，你应该会被重定向到[https://mlab.com/home](https://mlab.com/home)，在那里你可以使用数据库节点。
- en: The Heroku platform
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku平台
- en: Heroku is one of the oldest cloud platforms created using the **PaaS** (**Platform
    as a Service**) model. In comparison to Pivotal Cloud Foundry, Heroku doesn't
    have built-in support for Spring Cloud applications. It complicates our model
    a little because we can't use a platform's services to enable typical microservices
    components, including service discovery, a configuration server, or a circuit
    breaker. In spite of this, Heroku contains some really interesting features that
    are not provided by Pivotal Web Services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是使用**PaaS**（**平台即服务**）模型创建的最古老的云平台之一。与Pivotal Cloud Foundry相比，Heroku没有内置的对Spring
    Cloud应用程序的支持。这使我们的模型稍微复杂了一些，因为我们不能使用平台的服务的典型微服务组件，包括服务发现、配置服务器或断路器。尽管如此，Heroku包含了一些Pivotal
    Web Services没有的非常有趣的功能。
- en: Deployment methods
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署方法
- en: We can manage our application using the CLI, web console or a dedicated Maven
    plugin. Deploying Heroku is pretty similar to deploying the Pivotal platform,
    however, the methods are slightly different. The main approach assumes that you
    deploy the application by building it from the source code stored in your local
    Git repository or on GitHub. The build is executed by the Heroku platform automatically
    after you have pushed some changes in a branch to a repository, or on demand from
    the newest version of the code in the selected branch. Another interesting way
    to deploy an application is by pushing your Docker image to Heroku's container
    registry.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CLI、网络控制台或专用的Maven插件来管理我们的应用程序。在Heroku上部署应用程序与在Pivotal平台上部署非常相似，但方法有些不同。主要方法假设你是通过从本地Git仓库或GitHub存储的源代码构建应用程序的。构建完成后，Heroku平台会自动执行，当你向仓库的分支推送了一些更改，或者从选定分支的最新版本中按需执行。部署应用程序的另一种有趣方式是将你的Docker镜像推送到Heroku的容器注册表。
- en: Using the CLI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI
- en: 'You can begin by installing **Heroku Command Line Interface** (**CLI**) available
    at [https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe](https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe) (for
    Windows). In order to deploy and run your application on Heroku using CLI you
    have to perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe](https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe)下载**Heroku命令行界面**（**CLI**），这是为Windows用户提供的（对于Windows用户）。为了使用CLI在Heroku上部署和运行你的应用程序，你必须按照以下步骤进行：
- en: 'After installation, you can use the command `Heroku` from your shell. First,
    log in to Heroku using your credentials, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，你可以在shell中使用`Heroku`命令。首先，使用你的凭据登录到Heroku，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, navigate to the application''s `root` directory and create an application
    on Heroku. After running the following command, not only will the application
    be created, but a Git remote called `heroku` will as well. This is associated
    with your local Git repository, shown as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到应用的`root`目录并在Heroku上创建一个应用。在运行以下命令后，不仅会创建应用，还会创建一个名为`heroku`的Git远程。这与你本地的Git仓库相关联，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now you can deploy your application by pushing the code to Heroku''s Git remote.
    Heroku will then do all the work for you, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以通过将代码推送到Heroku的Git远程来部署你的应用。Heroku会为你完成所有工作，具体如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the application is started successfully, you will be able to manage it using
    some basic commands. In accordance with the order presented as follows, you can
    display logs, change the number of running dynos (in other words, scale the application),
    assign new add-ons, and list all of the enabled add-ons:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用启动成功，你将能够使用一些基本命令来管理它。根据以下顺序，你可以显示日志、更改运行中的dyno数量（换句话说，扩展应用）、分配新的附加组件，以及列出所有启用的附加组件：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Connecting to the GitHub repository
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到GitHub仓库
- en: 'Personally, I prefer to deploy my applications to Heroku by connecting to the
    projects using the GitHub repository. There are two possible approaches related
    to this deployment method: manual and automatic. You can choose either by navigating
    to the **Deploy** tab on the application''s details panel and then connect it
    to the specified GitHub repository, as you can see in the following screenshot.
    If you click the Deploy Branch button, the building of and the deployment to Heroku
    would immediately start on the given Git branch. Alternatively, you can also enable
    automatic deploys on the chosen branch by clicking **Enable Automatic Deploys**.
    Additionally, you can configure Heroku to wait for a Continuous Integration build
    result if it is enabled for your GitHub repository; this is a really helpful feature
    because it allows you to run automated tests on your project and ensure they have
    passed before it is pushed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢通过连接到项目的GitHub仓库来将我的应用部署到Heroku。关于这种部署方法有两种可能的方法：手动和自动。你可以通过导航到应用详情面板上的**部署**标签，然后将其连接到指定的GitHub仓库，如以下屏幕截图所示。如果你点击“部署分支”按钮，将在给定的Git分支上立即开始构建和部署。另外，你也可以通过点击**启用自动部署**来在选定的分支上启用自动部署。此外，如果你为你的GitHub仓库启用了持续集成，你还可以配置Heroku等待持续集成构建结果；这是一个非常有用的功能，因为它允许你在推送之前运行项目的自动化测试：
- en: '![](img/af757b79-ef60-441e-8b89-735019c51cf2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af757b79-ef60-441e-8b89-735019c51cf2.png)'
- en: Docker Container Registry
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器注册表
- en: 'Following the newest trends, Heroku allows you to deploy a containerized application
    using Docker. In order to be able to do that, you should have Docker and the Heroku
    CLI installed on your local machine:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟最新趋势，Heroku允许你使用Docker部署容器化应用。为了做到这一点，你应该在你的本地机器上安装Docker和Heroku CLI：
- en: 'First, log in to Heroku Cloud by running the command `heroku login`. The next
    step is to log in to the Container Registry:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过运行命令`heroku login`登录到Heroku云。下一步是登录到容器注册表：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, make sure that your current directory contains `Dockerfile`. If present,
    you can proceed to building and pushing the image to Heroku''s Container Registry
    by executing the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保你的当前目录包含`Dockerfile`。如果存在，你可以通过执行以下命令来构建并在Heroku容器注册表中推送镜像：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you have an existing built image, you may only be interested in tagging
    and pushing it to Heroku. In order to do that, you need to use Docker''s command
    line by executing the following commands (assuming your application''s name is `piomin-order-service`):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个现有的构建镜像，你可能只对给镜像打标签并推送到Heroku感兴趣。为了做到这一点，你需要使用Docker的命令行，通过执行以下命令来实现（假设你的应用名称是`piomin-order-service`）：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the image has been successfully pushed, the new application should be
    visible in the Heroku dashboard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 成功推送镜像后，新应用应该在Heroku仪表板上可见。
- en: Preparing an application
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用
- en: 'When deploying an application based on Spring Cloud components to Heroku, we
    no longer have to perform any extra changes in its source code or add any additional
    libraries, which we do when running it locally. The only difference here is in
    the configuration settings, where we should set an address in order to integrate
    the application with service discovery, databases, or any other add-on that can
    be enabled for your microservice. The current example, which is the same as the
    examples provided for Pivotal''s deployment, is to store data in MongoDB that
    is assigned to the application as an mLab service. Additionally, here, each client
    registers itself on the Eureka server, which is deployed as `piomin-discovery-service`.
    The following screenshot displays a list of the applications deployed on Heroku
    for our examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当将基于Spring Cloud组件的应用程序部署到Heroku时，我们不再需要对其源代码进行任何额外的更改或添加任何额外的库，这是我们本地在本地运行它时所需要做的。这里唯一的不同在于配置设置，我们需要设置一个地址以便将应用程序与服务发现、数据库或任何其他可以为您微服务启用的附加组件集成。当前的示例，与Pivotal的部署示例相同，是将数据存储在分配给应用程序作为mLab服务的MongoDB中。另外，在这里，每个客户端都会在作为`piomin-discovery-service`部署的Eureka服务器上注册自己。下面的屏幕截图显示了部署在Heroku上的我们示例中的应用程序列表：
- en: '![](img/1493f39a-d047-4aea-82b9-a8f65138f866.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1493f39a-d047-4aea-82b9-a8f65138f866.png)'
- en: I deployed the previous applications on Heroku by connecting them with the GitHub
    repository. This, in turn, requires you to create a separate repository per microservice.
    For example, the repository of `order-service` is available at [https://github.com/piomin/sample-heroku-order-service.git;](https://clicktime.symantec.com/a/1/T35T4GHVxyO3_yEnmgYJzEOMwTYVoyfmLx2ONL0JOmM=?d=Em-4WZBG8KjUF8i64GiOj94xj1zxN6a1uB0eVZ0nPiAMBASzKXYmiNLpRNEcgxEQ7bHQ6AzvMbnrWHqhusJvYyZqTNMHlShDuReFC57yByy3O9bujQaWuS_jFkuW-GXlbAc9l9L2CmOU0k0c7iCbz4TP6gxYzTpi3F2ZhiR4yOGU_aIfM0-ImE4VjE3Zwu5hcRLW6fRjQIpA00TbvIfq03qKyXpN4rOeSy-uW8xOD3AifhkEun4HB33yo6UpNlLAVK45YxrUxZn2iT_VdnO336VCgrUe4QGzCEoQEtzN_eTC5eSH0FHDXyXwW0Aj4Px9YTY5asaj9oWluYR6xuKHwLEyHqyAWSKmRhRVXDNsi3pF13hLo94F&u=https%3A%2F%2Fgithub.com%2Fpiomin%2Fsample-heroku-order-service.git)
    other microservices may be at under similar addresses. You can easily fork these
    microservices and deploy them on your Heroku account in order to perform tests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我将前面的应用程序通过连接GitHub仓库部署到Heroku。这要求你为每个微服务创建一个单独的仓库。例如，`order-service`的仓库可在[https://github.com/piomin/sample-heroku-order-service.git;](https://clicktime.symantec.com/a/1/T35T4GHVxyO3_yEnmgYJzEOMwTYVoyfmLx2ONL0JOmM=?d=Em-4WZBG8KjUF8i64GiOj94xj1zxN6a1uB0eVZ0nPiAMBASzKXYmiNLpRNEcgxEQ7bHQ6AzvMbnrWHqhusJvYyZqTNMHlShDuReFC57yByy3O9bujQaWuS_jFkuW-GXlbAc9l9L2CmOU0k0c7iCbz4TP6gxYzTpi3F2ZhiR4yOGU_aIfM0-ImE4VjE3Zwu5hcRLW6fRjQIpA00TbvIfq03qKyXpN4rOeSy-uW8xOD3AifhkEun4HB33yo6UpNlLAVK45YxrUxZn2iT_VdnO336VCgrUe4QGzCEoQEtzN_eTC5eSH0FHDXyXwW0Aj4Px9YTY5asaj9oWluYR6xuKHwLEyHqyAWSKmRhRVXDNsi3pF13hLo94F&u=https%3A%2F%2Fgithub.com%2Fpiomin%2Fsample-heroku-order-service.git)进行测试。
- en: 'Now let''s take a look at the configuration settings provided for one of our
    example applications: `account-service`. First, we have to override the auto-configured
    address of MongoDB using the `MONGODB_URI` environment variable provided by the
    Heroku platform. There is also a necessity to provide the correct address of a
    Eureka server, as well as override the hostname and port sent by a discovery client
    during registration. This is required because, by default, each application will
    try to register using an internal address that is not available for other applications.
    Without overriding these values, inter-service communication with the Feign client
    would be unsuccessful:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看为其中一个示例应用程序提供的配置设置：`account-service`。首先，我们必须覆盖MongoDB的自动配置地址，使用Heroku平台提供的`MONGODB_URI`环境变量。还必须提供正确的Eureka服务器地址，以及覆盖注册时发现客户端发送的主机名和端口。这是因为默认情况下，每个应用程序都会尝试使用对其他应用程序不可用的内部地址进行注册。如果不覆盖这些值，使用Feign客户端的服务间通信将失败：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice that the environment variable `HEROKU_APP_NAME` is the name of the current
    application deployed on Heroku, as seen in the preceding snippet. This is not
    available by default. To enable a variable for your application, for example,
    `customer-service`, run the following command with the experimental add-on `runtime-dyno-metadata`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，环境变量`HEROKU_APP_NAME`是部署在Heroku上的当前应用程序的名称，如前面的片段中所见。这并非默认可用。要为您的应用程序启用变量，例如`customer-service`，请运行以下命令并使用实验性附加组件`runtime-dyno-metadata`：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Testing deployments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部署
- en: 'After deployment, every application is available at an address made up of its
    name and a platform''s domain name, for example, [http://piomin-order-service.herokuapp.com](http://piomin-order-service.herokuapp.com).
    You are able to call the Eureka dashboard exposes using the URL, [http://piomin-discovery-service.herokuapp.com/](http://piomin-discovery-service.herokuapp.com/),
    which will allow you to check whether our example microservices have been registered.
    If everything worked correctly, you should see something similar to the following
    screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '-   部署后，每个应用程序都可以在其名称和平台域名组成的地址上访问，例如，[http://piomin-order-service.herokuapp.com](http://piomin-order-service.herokuapp.com)。您可以使用URL调用Eureka仪表板，即 [http://piomin-discovery-service.herokuapp.com/](http://piomin-discovery-service.herokuapp.com/)，这将允许您检查我们的示例微服务是否已注册。如果一切工作正常，您应该会看到类似于以下屏幕截图的东西：'
- en: '![](img/bb34151b-5ecb-4d64-a7da-81f5952e4964.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](img/bb34151b-5ecb-4d64-a7da-81f5952e4964.png)'
- en: 'Each microservice exposes API documentation automatically generated by Swagger2,
    so you can easily test every endpoint by calling it from the Swagger UI dashboard,
    available on `/swagger-ui.html`; for example, [http://piomin-order-service.herokuapp.com/swagger-ui.html](http://piomin-order-service.herokuapp.com/swagger-ui.html).
    The HTTP API visualization for `order-service` is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '-   每个微服务都暴露了由Swagger2自动生成的API文档，所以你可以通过从`/swagger-ui.html`获取的Swagger UI仪表板轻松地测试每个端点；例如，[http://piomin-order-service.herokuapp.com/swagger-ui.html](http://piomin-order-service.herokuapp.com/swagger-ui.html)。`order-service`的HTTP
    API视图如下：'
- en: '![](img/60d46f83-d38c-463b-ba49-0b43c99810e9.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](img/60d46f83-d38c-463b-ba49-0b43c99810e9.png)'
- en: 'Each microservice stores data in MongoDB. This database can be enabled for
    your project by adding add-ons provided by Heroku, for example, mLab. As you may
    remember, we have already used an example of the same service for storing data
    in applications deployed on the Pivotal platform. Add-ons can be enabled for an
    application by provisioning it with the selected plan in the Resources tab of
    every application''s details panel. Once done, you can manage every plugin by
    simply clicking on it. For mLab, you will be redirected to the mLab ([mlab.com](https://mlab.com/))
    site, where you are able to see a list of all the collections, users, and generated
    statistics. The following screenshot illustrates the mLab dashboard for our examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '-   每个微服务都在MongoDB中存储数据。这个数据库可以通过向Heroku项目添加插件来启用，例如mLab。正如您可能记得的，我们已经在Pivotal平台上部署的应用程序中使用过相同服务的示例来存储数据。插件可以通过在应用程序的详细信息面板的资源标签中为其选择计划来为应用程序启用。完成后，您可以简单地点击它来管理每个插件。对于mLab，您将被重定向到mLab网站([mlab.com](https://mlab.com/))，在那里您可以查看所有集合、用户和生成的统计信息的列表。以下屏幕截图说明了我们的示例的mLab仪表板：'
- en: '![](img/d791eac0-4a61-4ca2-a7a2-016a446821af.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d791eac0-4a61-4ca2-a7a2-016a446821af.png)'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   总结'
- en: We have reached the end of our Spring Cloud microservices journey! Our exercises
    began with simple deployments on the local machine, but in the last chapter we
    deployed our microservices in an environment fully-managed by the cloud vendor,
    which also automatically built, started, and exposed HTTP APIs on specified domains.
    I personally think that it is amazing how easily we can run, scale, and expose
    data outside an application using any of the most popular programming languages
    or third-party tools, such as a database or a message broker. In fact, each one
    of us can now implement and launch a production-ready application to the web within
    a few hours without worrying about the software that has to be installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '-   我们的Spring Cloud微服务之旅已经结束！我们的练习始于在本地机器上的简单部署，但在上一章中，我们的微服务部署在完全由云供应商管理的环境中，该环境还自动构建、启动并在指定域名上暴露HTTP
    API。我个人认为，我们能够如此轻松地使用任何一种流行的编程语言或第三方工具（如数据库或消息代理）运行、扩展和将数据暴露于应用程序之外，这是非常惊人的。事实上，我们中的每一个人现在都可以在几小时内实施并将一个生产就绪的应用程序部署到网上，而无需担心必须安装的软件。'
- en: This chapter has shown you how easily you can run Spring Cloud microservices
    on different platforms. The given examples illustrate the real power of cloud-native
    applications. No matter whether you launch an application locally on your laptop,
    inside a Docker Container, using Kubernetes, or on an online cloud platform such
    as Heroku or Pivotal Web Services, you don't have to change anything in the application's
    source code; the modifications have to be performed only in its properties. (Assuming
    you use Config Server in your architecture, these changes are not invasive.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你们展示了如何在不同的平台上轻松运行Spring Cloud微服务。所给示例说明了云原生应用的真正力量。无论你是在自己的笔记本电脑上本地启动应用，还是在Docker容器内，使用Kubernetes，或是在如Heroku或Pivotal
    Web Services这样的在线云平台上启动应用，你都不需要在应用的源代码中做任何更改；修改只需要在其属性中进行。（假设你在你的架构中使用Config Server，这些更改是非侵入性的。）
- en: In the last two chapters, we looked at some of the most recent trends seen in
    the IT world. Such topics as CI and CD, containerization with Docker, orchestration
    using Kubernetes, and cloud platforms are increasingly used by many organizations.
    In fact, these solutions are partly responsible for the increasing popularity
    of microservices. Currently, there is one leader in this area of programming—Spring
    Cloud. There is no other Java framework with as many features, or that can implement
    so many patterns related to microservices, as Spring Cloud. I hope this book will
    help you to use this framework effectively when building and honing your microservice-based
    enterprise system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们探讨了IT世界中的一些最新趋势。如持续集成和持续部署（CI和CD）、使用Docker的容器化、使用Kubernetes的编成以及云平台等主题正被越来越多的组织所使用。实际上，这些解决方案在微服务的日益普及中起到了部分作用。目前，在这个编程领域有一个领导者——Spring
    Cloud。没有其他Java框架有如此多的功能，或者能够实现与微服务相关的如此多的模式，如Spring Cloud。我希望这本书能帮助你在构建和精炼你的基于微服务的企业系统时有效地使用这个框架。
