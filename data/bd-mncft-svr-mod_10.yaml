- en: Chapter 10. The Bukkit Scheduler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. Bukkit 调度器
- en: 'The Bukkit scheduler is a very powerful tool, and it is easy to learn how to
    use it. It allows you to create repetitive tasks such as saving data. It also
    allows you to delay how long until a block of code is executed. The Bukkit scheduler
    can also be used to asynchronously compute lengthy tasks. This means that a task
    such as writing data to a file or downloading a file to the server can be scheduled
    to run on a separate thread to prevent the main thread, and thus the game, from
    lagging. In this chapter, you will learn how to do each of these by continuing
    to work on the `Warper` teleportation plugin, as well as creating a new plugin
    called `AlwaysDay`. This new plugin will ensure that it is always daytime on the
    server by repeatedly setting the time to noon. This chapter will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit 调度器是一个非常强大的工具，学习如何使用它也很容易。它允许你创建重复的任务，例如保存数据。它还允许你延迟执行代码块的时间。Bukkit 调度器还可以用于异步计算长时间的任务。这意味着像将数据写入文件或下载文件到服务器这样的任务可以调度在单独的线程上运行，以防止主线程，从而防止游戏卡顿。在本章中，你将通过继续在
    `Warper` 传送插件上工作，以及创建一个名为 `AlwaysDay` 的新插件来学习如何完成这些任务。这个新插件将通过反复将时间设置为中午来确保服务器始终是白天。本章将涵盖以下主题：
- en: Creating a `BukkitRunnable` class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `BukkitRunnable` 类
- en: Understanding synchronous and asynchronous tasks and when they should be used
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步和异步任务及其使用时机
- en: Running a task from a `BukkitRunnable` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `BukkitRunnable` 类运行任务
- en: Scheduling a delayed task from a `BukkitRunnable` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `BukkitRunnable` 类调度延迟任务
- en: Scheduling a repeating task from a `BukkitRunnable` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `BukkitRunnable` 类调度重复任务
- en: Writing a plugin called `AlwaysDay` that uses a repeating task
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `AlwaysDay` 的插件，该插件使用重复任务
- en: Adding a delayed task to the `Warper` plugin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将延迟任务添加到 `Warper` 插件中
- en: Asynchronously executing code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步执行代码
- en: Creating a BukkitRunnable class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 BukkitRunnable 类
- en: 'We will start by creating the `AlwaysDay` plugin. The code that we will write
    for this plugin will be put inside the `onEnable` method. The first step to creating
    a scheduled task is to create a `BukkitRunnable` class. This class will comprise
    very few lines of code. Therefore, it is not necessary to create a whole new Java
    file for it. For this reason, we will create a class within the `onEnable` method.
    This can be done using the following line of code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建 `AlwaysDay` 插件。我们将为这个插件编写的代码将放在 `onEnable` 方法中。创建调度任务的第一步是创建一个 `BukkitRunnable`
    类。这个类将包含非常少的代码行。因此，没有必要为它创建一个全新的 Java 文件。因此，我们将在 `onEnable` 方法中创建一个类。这可以通过以下代码行完成：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Normally, this code would be valid since you are constructing a new instance
    of a class. However, `BukkitRunnable` is an **abstract class**, which means that
    it cannot be instantiated. The purpose of an **abstract class** is to provide
    some base code that other classes can **extend** and build on top of. An example
    of this is the `JavaPlugin` class. For each plugin that you created, you started
    with a class that extends `JavaPlugin`. This allows you to override methods, such
    as `onEnable`, while keeping the current code of other methods, such as `getConfig`.
    This is similar to implementing an Interface, such as Listener. The difference
    between an abstract class and an interface is its purpose. As mentioned earlier,
    an abstract class is a base for other classes to extend. An interface is more
    of an outline within which classes can implement. Interfaces do not include code
    within any of their methods and therefore, all methods within an interface must
    have an implementation. For an abstract class, only the methods defined as `abstract`
    must be overridden because they do not include code within them. Therefore, because
    `BukkitRunnable` is an abstract class, you will be given a warning that will ask
    you to implement all the abstract methods. NetBeans can automatically add the
    needed methods for you. The new method that is added for you is `run`. This method
    will be called when the scheduler runs your task. For the new `AlwaysDay` plugin,
    we want the task to set each world''s time to noon, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这段代码是有效的，因为你正在构造一个新类的实例。然而，`BukkitRunnable`是一个**抽象类**，这意味着它不能被实例化。抽象类的目的是提供一些基础代码，其他类可以**扩展**并在此基础上构建。一个例子是`JavaPlugin`类。对于你创建的每个插件，你都是从扩展`JavaPlugin`的类开始的。这允许你覆盖方法，例如`onEnable`，同时保留其他方法，如`getConfig`的当前代码。这与实现接口，如Listener类似。抽象类和接口之间的区别在于其目的。如前所述，抽象类是其他类扩展的基础。接口更像是一个框架，类可以在其中实现。接口不包含任何方法中的代码，因此，接口中的所有方法都必须有实现。对于抽象类，只有定义为`abstract`的方法必须被覆盖，因为它们不包含代码。因此，因为`BukkitRunnable`是一个抽象类，你会收到一个警告，要求你实现所有抽象方法。NetBeans可以自动为你添加所需的方法。为你添加的新方法是`run`。当调度器运行你的任务时，将调用此方法。对于新的`AlwaysDay`插件，我们希望任务将每个世界的时间设置为中午，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that time on a Minecraft server is measured in ticks. 20 ticks is
    equivalent to 1 second. The measurement of ticks is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在Minecraft服务器上，时间是以tick来衡量的。20 tick等于1秒。tick的测量方法如下：
- en: '0 ticks: Dawn'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '0 ticks: 黎明'
- en: '6,000 ticks: Noon'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '6,000 ticks: 中午'
- en: '12,000 ticks: Dusk'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '12,000 ticks: 黄昏'
- en: '18,000 ticks: Midnight'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '18,000 ticks: 午夜'
- en: 'Take a look at the API documentation for the `BukkitRunnable` class at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html).
    Note that there are six ways to run this task, which are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于`BukkitRunnable`类的API文档[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html)。注意，有六种运行此任务的方法，如下所示：
- en: runTask
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTask
- en: runTaskAsynchronously
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTaskAsynchronously
- en: runTaskLater
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTaskLater
- en: runTaskLaterAsynchronously
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTaskLaterAsynchronously
- en: runTaskTimer
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTaskTimer
- en: runTaskTimerAsynchronously
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTaskTimerAsynchronously
- en: Synchronous versus asynchronous tasks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步任务与异步任务
- en: A task can be run either synchronously or asynchronously. Simply put, when a
    synchronous task is executed, it must be completed before the server can continue
    running normally. An asynchronous task can run in the background while the server
    continues to function. If a task accesses the Bukkit API in any way, then it should
    be run synchronously. For this reason, you will rarely run a task asynchronously.
    An advantage that an asynchronous task gives is that it can be completed without
    causing your server to lag. For example, writing data to a save file can be done
    asynchronously. Later in this chapter, we will modify the `Warper` plugin to save
    its data asynchronously. As for the `AlwaysDay` plugin, we must run the task synchronously
    because it accesses the Minecraft server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务可以是同步执行或异步执行。简单来说，当一个同步任务执行时，它必须在服务器继续正常运行之前完成。异步任务可以在服务器继续运行的同时在后台运行。如果一个任务以任何方式访问Bukkit
    API，那么它应该以同步方式运行。因此，你很少会以异步方式运行任务。异步任务的一个优点是它可以在不导致服务器卡顿的情况下完成。例如，将数据写入保存文件可以异步执行。在本章的后面，我们将修改`Warper`插件以异步保存其数据。至于`AlwaysDay`插件，我们必须以同步方式运行任务，因为它访问了Minecraft服务器。
- en: Running a task from a BukkitRunnable class
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`BukkitRunnable`类运行任务
- en: Calling `runTask` or `runTaskAsynchronously` on a `BukkitRunnable` class will
    cause the task to run immediately. The only time you are likely to use this is
    to run a synchronous task from an asynchronous context or vice versa.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BukkitRunnable`类上调用`runTask`或`runTaskAsynchronously`会导致任务立即运行。你可能会使用这种情况是在从异步上下文运行同步任务或反之亦然。
- en: Running a task later from a BukkitRunnable class
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`BukkitRunnable`类稍后运行任务
- en: Calling `runTaskLater` or `runTaskLaterAsynchronously` on a `BukkitRunnable`
    class will delay the task from being executed for a specific amount of time. The
    amount of time is measured in ticks. Remember that there are 20 ticks in every
    second. In the `Warper` plugin, we will add a warp delay so that the player is
    teleported 5 seconds after running the warp command. We will accomplish this by
    running the task later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BukkitRunnable`类上调用`runTaskLater`或`runTaskLaterAsynchronously`将延迟任务执行特定的时间。这个时间是以刻度为单位的。记住，每秒有20个刻度。在`Warper`插件中，我们将添加一个传送延迟，使玩家在运行传送命令后5秒被传送。我们将通过稍后运行任务来实现这一点。
- en: Running a task timer from a BukkitRunnable class
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`BukkitRunnable`类运行任务计时器
- en: Calling `runTaskTimer` or `runTaskTimerAsynchronously` on a `BukkitRunnable`
    class will repeat the task every specified number of ticks. The task will repeat
    until it is canceled. Task timers can also be delayed to offset the initial run
    of the task. A task timer can be used to periodically save data, but for now,
    we will use this type of repeating task to complete the `AlwaysDay` plugin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BukkitRunnable`类上调用`runTaskTimer`或`runTaskTimerAsynchronously`会使任务每隔指定的时间间隔重复执行。任务会一直重复，直到被取消。任务计时器也可以延迟启动，以调整任务的初始运行。任务计时器可以用来定期保存数据，但到目前为止，我们将使用这种重复任务来完成`AlwaysDay`插件。
- en: Writing a repeating task for a plugin
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为插件编写重复任务
- en: 'We already have a `BukkitRunnable` class. Therefore, in order to run a task
    timer, we just need to determine the delay and the period by which the task is
    delayed. We want the delay to be 0\. That way, if it is night when the plugin
    is enabled, the time will be set to noon right away. As for the period, we can
    repeat the task every second if we want to keep the sun always directly above.
    The task only contains one simple line of code. Repeating it often will not cause
    the server to lag. However, repeating the task every minute will still prevent
    the world from ever growing dark and will be less of a strain on the computer.
    Therefore, we will delay the task by 0 ticks and repeat it every 1,200 ticks.
    This results in the following line of code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了`BukkitRunnable`类。因此，为了运行任务计时器，我们只需要确定任务的延迟和延迟周期。我们希望延迟为0。这样，如果插件启用时是夜晚，时间会立即设置为中午。至于周期，如果我们想保持太阳始终在正上方，我们可以每秒重复任务。任务只包含一行简单的代码。频繁重复它不会导致服务器卡顿。然而，每分钟重复任务仍然可以防止世界永远变暗，并且对计算机的压力会更小。因此，我们将任务延迟0个刻度，并每1,200个刻度重复一次。这导致以下代码行：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this, we started a repeating task. It is good practice to cancel repeating
    tasks when the plugin is disabled. To accomplish this, we will store the `BukkitTask`
    as a class variable so that we can access it later to disable it. Once you have
    canceled the task within the `onDisable` method, the entire `AlwaysDay` plugin
    is given in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们启动了一个重复任务。当插件禁用时取消重复任务是良好的实践。为了完成这个任务，我们将`BukkitTask`存储为类变量，这样我们就可以稍后访问它来禁用它。一旦你在`onDisable`方法中取消了任务，以下代码给出了整个`AlwaysDay`插件：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding a delayed task to a plugin
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向插件中添加延迟任务
- en: We will now add a warp delay to the `Warper` plugin. This will require players
    to stand still after running the warp or home commands. If they move too much,
    the warp task will be canceled and they will not be teleported. This will prevent
    players from teleporting when someone is attacking them or they are falling to
    their death.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向`Warper`插件添加一个延迟。这将要求玩家在运行传送或回家命令后保持静止。如果他们移动太多，传送任务将被取消，他们不会传送。这将防止玩家在有人攻击他们或他们正在坠落时传送。
- en: 'If you haven''t already, add a variable of `warpDelay` in the `main` class.
    This is given in the following line of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有做，请在`main`类中添加一个`warpDelay`变量。这将在以下代码行中给出：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time will be in seconds. We will multiply it by 20 later in the code to
    calculate the number of ticks by which we wish to delay the task.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时间将以秒为单位。我们将在代码中稍后将其乘以20，以计算我们希望延迟任务的刻度数。
- en: 'We will also need to keep track of the player who is in the process of warping
    so that we can check whether they are moving. Add another variable of the current
    `warpers`. This will be a `HashMap` so that we can keep track of which players
    are warping and the tasks that will be run to teleport them. That way, if a specific
    player moves, we can get their task and cancel it. This is shown in the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要跟踪正在传送过程中的玩家，以便我们可以检查他们是否在移动。为当前的`warpers`添加另一个变量。这将是一个`HashMap`，这样我们就可以跟踪哪些玩家正在传送以及将要运行的传送任务。这样，如果特定玩家移动，我们可以获取他们的任务并取消它。这可以在以下代码中看到：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code contains three new methods, which must be added to the `main` class
    in order to schedule the warp task, check whether a player has a warp task, and
    cancel a player''s warp task. The code is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含三个新方法，必须将它们添加到`main`类中，以便安排传送任务、检查玩家是否有传送任务以及取消玩家的传送任务。代码如下：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `scheduleTeleportation` method, note that both the `player` and `loc`
    variables are `final`. This is required to use the variables within the `BukkitRunnable`
    class. This must be done to ensure that the values will not change before the
    task is run. Also, note that the `runTaskLater` method call returns a `BukkitTask`,
    which is what we save inside the `HashMap`. You can see why it is saved by looking
    at the `cancelWarp` method, which removes the `BukkitTask` of the given player
    and then invokes the `cancel` method on it before it is executed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scheduleTeleportation`方法中，请注意`player`和`loc`变量都是`final`的。这是在`BukkitRunnable`类中使用变量所必需的。这样做是为了确保在任务运行之前，值不会改变。此外，请注意`runTaskLater`方法调用返回一个`BukkitTask`，这是我们保存在`HashMap`中的内容。你可以通过查看`cancelWarp`方法来了解原因，该方法在执行之前移除指定玩家的`BukkitTask`并对其调用`cancel`方法。
- en: 'In both the `WarpCommand` and `HomeCommand` classes, we teleport a player.
    We want to remove that line and replace it with a method call to `scheduleTeleportation`.
    The feature addition is nearing completion. All that is left to do is calling
    the `cancelWarp` method when a `warper` moves. For this, add an event listener
    to listen for the `player move` event. This can be seen in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WarpCommand`和`HomeCommand`类中，我们都会传送玩家。我们希望移除那行代码，并用对`scheduleTeleportation`方法的调用来替换它。功能添加即将完成。剩下要做的就是当`warper`移动时调用`cancelWarp`方法。为此，添加一个事件监听器来监听`player
    move`事件。这可以在以下代码中看到：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do not forget to register the event within the `onEnable` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`onEnable`方法中注册事件。
- en: Executing code asynchronously
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步执行代码
- en: We can improve the `Warper` plugin by writing its data to a file asynchronously.
    This will help keep the main thread of the server running smoothly with no lag.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过异步将数据写入文件来改进`Warper`插件。这将有助于保持服务器主线程的流畅运行，不会出现延迟。
- en: 'Take a look at the current `save` method. We will add the data to a `YamlConfiguration`
    file and then write the configuration to the file. This entire method cannot be
    run asynchronously. Adding the data to the configuration must be done synchronously
    to ensure that it is not modified while it is being added. However, the `save`
    method call on the configuration can be called asynchronously. We will place the
    entire `try/catch` block within a new `BukkitRunnable class`. We will then run
    it asynchronously as a task. This task will be stored as a static variable in
    the `Warper` class. This is shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下当前的`save`方法。我们将数据添加到`YamlConfiguration`文件中，然后将配置写入文件。整个方法不能异步运行。将数据添加到配置必须同步进行，以确保在添加过程中不会被修改。然而，对配置的`save`方法调用可以是异步的。我们将整个`try/catch`块放在一个新的`BukkitRunnable`类中。然后我们将它作为一个任务异步运行。这个任务将被保存在`Warper`类的静态变量中。这可以在以下代码中看到：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the rest of the server can continue running while the data is being saved.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在数据保存期间，服务器的其余部分可以继续运行。
- en: 'However, what if we try to save the file again when the previous write is not
    yet finished? In this case, we do not care about the previous task, because it
    is now saving outdated data. We will first cancel the task before starting a new
    one. This will be done using the following code before creating the `BukkitRunnable`
    class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在之前的写入尚未完成时再次保存文件怎么办？在这种情况下，我们不在乎之前的任务，因为它现在正在保存过时的数据。我们将在创建`BukkitRunnable`类之前首先取消任务，然后开始一个新的任务。这将在以下代码中完成：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This completes this version of `Warper`. As mentioned in [Chapter 9](part0069_split_000.html#21PMQ1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 9. Saving Your Data"), *Saving Your Data*, this plugin has a lot of potential
    for feature additions. You now have the required knowledge to add these additions
    on your own.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`Warper`的此版本。如[第9章](part0069_split_000.html#21PMQ1-b66e70deee6e4ed481db4b113e303f23
    "第9章。保存你的数据")中提到的，*保存你的数据*，这个插件有很多功能添加的潜力。你现在有了添加这些功能所需的知识。
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You are now familiar with most of the complicated aspects of the Bukkit API.
    With this knowledge, you can program almost any type of Bukkit plugin. Try putting
    this knowledge to use by creating a new plugin. You can perhaps try to write an
    announcement plugin that will rotate through a list of messages that need to be
    broadcast on a server. Think about all the Bukkit API concepts and how you can
    use them to add new features to the plugin. For example, with an announcement
    plugin, you can do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在熟悉了Bukkit API的大部分复杂方面。有了这些知识，你可以编写几乎任何类型的Bukkit插件。尝试通过创建一个新的插件来应用这些知识。你可能尝试编写一个公告插件，该插件将在服务器上循环播放需要广播的消息列表。考虑所有Bukkit
    API概念以及你如何使用它们来为插件添加新功能。例如，使用公告插件，你可以做以下事情：
- en: Add commands to allow an administrator to add messages that need to be announced
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加命令，允许管理员添加需要宣布的消息
- en: Add permissions to control who can add messages and even who can see the messages
    that are announced
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加权限来控制谁可以添加消息，甚至谁可以看到宣布的消息
- en: Add an `EventHandler` method to listen for when players log in so that a message
    can be sent to them
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`EventHandler`方法来监听玩家登录时，以便可以向他们发送消息
- en: Add a `config.yml` file to set how often messages should be announced
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`config.yml`文件来设置消息应宣布的频率
- en: Add a save file to save and load all the messages that will be announced
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个保存文件来保存和加载将要宣布的所有消息
- en: Use the Bukkit scheduler to repeatedly broadcast the messages while the server
    is running
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bukkit调度器在服务器运行时重复广播消息
- en: For any plugin that you make, think of each segment of the Bukkit API to figure
    out some way to improve the plugin by adding more features. This will surely make
    your plugin and server stand out.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你制作的任何插件，考虑Bukkit API的每个部分，以找出通过添加更多功能来改进插件的方法。这无疑会使你的插件和服务器脱颖而出。
- en: There are some topics that were not discussed in this book, but they are simple
    enough; you can learn how to use them on your own by reading the API documentation.
    Some interesting features that can spruce up a Bukkit plugin are the `playSound`
    and `playEffect` methods, which can be found inside the `World` and `Player` classes.
    I encourage you to read about them and try to use them yourself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有讨论一些主题，但它们足够简单；你可以通过阅读API文档自学如何使用它们。一些可以美化Bukkit插件的有趣功能是`playSound`和`playEffect`方法，它们位于`World`和`Player`类中。我鼓励你阅读它们并尝试自己使用。
- en: You know how to program plugin commands, player permissions, event listeners,
    configuration files, the saving and loading of data, and scheduled tasks. All
    that remains is imagining how to use these newfound skills to create a great and
    unique plugin for the Bukkit server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何编写插件命令、玩家权限、事件监听器、配置文件、数据的保存和加载以及计划任务。剩下的事情就是想象如何使用这些新技能为Bukkit服务器创建一个伟大且独特的插件。
