- en: Securing Java EE Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Java EE应用程序
- en: Java EE 8 introduces a new security API that standardizes application security
    across all Java EE 8 compliant application servers. The API includes standardized
    access to identity stores, which allow a uniform way of retrieving user credentials
    from a relational or LDAP database, as well as allowing us to implement access
    to custom identity stores. The new Java EE 8 API includes support for authentication
    mechanisms, allowing us to authenticate users in a standard way. Several authentication
    mechanisms are supported such as basic HTTP authentication, client certificates,
    HTML forms, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8引入了一个新的安全API，该API标准化了所有Java EE 8兼容应用程序服务器的应用程序安全。该API包括对身份存储的标准化访问，允许以统一的方式从关系或LDAP数据库检索用户凭证，并允许我们实现自定义身份存储的访问。新的Java
    EE 8 API包括对认证机制的支持，允许我们以标准方式验证用户。支持多种认证机制，例如基本HTTP认证、客户端证书、HTML表单等。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Identity stores
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份存储
- en: Authentication mechanisms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证机制
- en: Identity stores
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份存储
- en: Identity stores provide access to a persistence storage system, such as a relational
    or **LDAP** (**Lightweight Directory Access Protocol**) database, where user credentials
    are stored. The Java EE Security API supports relational and LDAP databases directly,
    and it allows us to integrate with custom identity stores, if necessary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 身份存储提供对持久化存储系统的访问，例如关系数据库或**LDAP**（轻量级目录访问协议）数据库，其中存储用户凭证。Java EE安全API直接支持关系和LDAP数据库，并且允许我们在必要时与自定义身份存储集成。
- en: Setting up an identity store stored in a relational database
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在关系数据库中设置存储的身份存储
- en: To authenticate a secured resource, such as a Servlet or JAX-RS RESTful web
    service, against credentials stored in a relational database, we need to annotate
    an application-scoped CDI bean with the `@DatabaseIdentityStoreDefinition` annotation,
    as illustrated in the following example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要对存储在关系数据库中的凭证进行身份验证，例如Servlet或JAX-RS RESTful Web服务，我们需要在应用程序范围的CDI bean上使用`@DatabaseIdentityStoreDefinition`注解，如下面的示例所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our example, the JNDI name for the JDBC connection for the relational database
    containing user credentials is `jdbc/userAuth`, which is the value we provided
    to the `dataSourceLookup` attribute of the `@DatabaseIdentityStoreDefinition`
    annotation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，包含用户凭证的关系数据库的JNDI名称为`jdbc/userAuth`，这是我们提供给`@DatabaseIdentityStoreDefinition`注解的`dataSourceLookup`属性的值。
- en: The `callerQuery` parameter of `@DatabaseIdentityStoreDefinition` is used to
    specify the SQL query used to retrieve the username and password for the user
    we are authenticating. The values retrieved from the database must match the values
    provided by the user (via an authentication mechanism, covered later in this chapter).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DatabaseIdentityStoreDefinition`的`callerQuery`参数用于指定用于检索我们正在验证的用户的用户名和密码的SQL查询。从数据库检索的值必须与用户提供的值匹配（通过稍后在本章中介绍的认证机制）。'
- en: Most secured applications have different types of users separated into roles,
    for example, an application could have "regular" users plus administrators. Administrators
    would be allowed to perform certain actions that regular users would not. For
    example, administrators could be able to reset user passwords and add or remove
    users from the system. The `groupsQuery` attribute of `@DatabaseIdentityStoreDefinition`
    allows us to retrieve all roles for the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数受保护的应用程序都有不同类型的用户，这些用户被分为不同的角色，例如，一个应用程序可能有“普通”用户和管理员。管理员将能够执行普通用户无法执行的操作。例如，管理员可以重置用户密码并从系统中添加或删除用户。`@DatabaseIdentityStoreDefinition`的`groupsQuery`属性允许我们检索用户的全部角色。
- en: Setting up an identity store stored in an LDAP database
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在LDAP数据库中设置存储的身份存储
- en: 'To secure resources against credentials stored in an LDAP database, we need
    to annotate the resource to be secured (such as a servlet or JAX-RS RESTful web
    service) with the `@LdapIdentityStoreDefinition` annotation, the following example
    illustrates how to do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护存储在LDAP数据库中的凭证的资源，我们需要使用`@LdapIdentityStoreDefinition`注解来注解要保护的资源（例如servlet或JAX-RS
    RESTful Web服务），以下示例说明了如何进行此操作：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `url` attribute of `@LdapIdentityStoreDefinition` is used to specify the
    URL of the LDAP server containing user credentials for our application, its `callerBaseDn`
    attribute is used to specify the LDAP base-distinguished name to verify user credentials
    supplied by the user. Finally, its `groupSearchBase` attribute is used to retrieve
    the roles for the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`@LdapIdentityStoreDefinition`的`url`属性用于指定包含我们应用程序用户凭据的LDAP服务器的URL，其`callerBaseDn`属性用于指定用于验证用户提供的用户凭据的LDAP基本区分名称。最后，其`groupSearchBase`属性用于检索用户的角色。'
- en: Custom identity stores
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义身份存储
- en: In some cases, we may need to integrate our application security with an identity
    store not directly supported by the security API, for example, we may have a requirement
    to integrate with an existing commercial security product. For cases like this,
    the Java EE security API allows us to roll our own identity store definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要将我们的应用程序安全性与安全API未直接支持的身份存储进行集成，例如，我们可能需要集成现有的商业安全产品。对于此类情况，Java
    EE安全API允许我们自定义身份存储定义。
- en: 'To handle custom identity stores, we need to create an application-scoped CDI
    bean; the bean must implement the `IdentityStore` interface, as illustrated in
    the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理自定义身份存储，我们需要创建一个应用程序范围的CDI Bean；该Bean必须实现`IdentityStore`接口，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `validate()` method is defined in the `IdentityStore` interface provided
    by the security API; in our example, we implement this method so that we can implement
    custom validation for our application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`方法是在安全API提供的`IdentityStore`接口中定义的；在我们的示例中，我们实现此方法以便我们可以为我们的应用程序实现自定义验证。'
- en: In our example, we are hardcoding valid credentials into the code, do not do
    this for real applications!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将有效的凭据硬编码到代码中，但请勿在实际应用程序中这样做！
- en: The `validate()` method defined in the `IdentityStore` interface accepts an
    instance of a class implementing the `Credential` interface as its sole argument.
    In the body of our method, we cast it down to `UserNamePasswordCredential`, then
    we invoke its `compareTo()` method, passing the expected username and password.
    If the provided credentials match either one of the expected sets of credentials,
    then we allow the user to successfully log in; we do this by returning an instance
    of `CredentialValidationResult` containing the username and a `Set` containing
    all the roles that the user has in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IdentityStore`接口中定义的`validate()`方法接受一个实现`Credential`接口的类的实例作为其唯一参数。在我们的方法体中，我们将其向下转换为`UserNamePasswordCredential`，然后调用其`compareTo()`方法，传递预期的用户名和密码。如果提供的凭据与预期的任何一组凭据匹配，则允许用户成功登录；我们通过返回一个包含用户名和一个包含用户在我们应用程序中所有角色的`Set`的`CredentialValidationResult`实例来完成此操作。
- en: If the supplied credentials don't match either of the expected credentials,
    then we prevent the user from logging in by returning `CredentialValidationResult.INVALID_RESULT`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的凭据与预期的任何凭据都不匹配，则通过返回`CredentialValidationResult.INVALID_RESULT`来阻止用户登录。
- en: Authentication mechanisms
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证机制
- en: Authentication mechanisms provide a way for the user to provide their credentials
    so that they can be authenticated against an identity store.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证机制为用户提供了一种提供其凭据的方式，以便它们可以与身份存储进行身份验证。
- en: The Java EE 8 Security API provides support for basic HTTP authentication, a
    standard authentication mechanism supported by most web browsers, as well as form
    authentication, where users provide their credentials via an HTML form. Form authentication,
    by default, submits a form to a security servlet provided by the Java EE implementation.
    If we need more flexibility or to better align with other Java EE technologies,
    the security API provides custom form authentication as well, which allows us,
    as application developers, to have more control over how to authenticate users
    attempting to access our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8安全API提供了对基本HTTP身份验证的支持，这是大多数网络浏览器支持的标准身份验证机制，以及表单身份验证，其中用户通过HTML表单提供他们的凭据。默认情况下，表单身份验证将表单提交给Java
    EE实现提供的安全servlet。如果我们需要更多的灵活性或更好地与其他Java EE技术对齐，安全API还提供了自定义表单身份验证，这允许我们作为应用程序开发者，对尝试访问我们应用程序的用户如何进行身份验证有更多的控制。
- en: Basic authentication mechanism
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证机制
- en: 'Basic authentication mechanisms can be achieved by annotating the resource
    to secure (that is, a servlet or JAX-RS RESTful web service) with the `@BasicAuthenticationMechanismDefinition`
    annotation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `@BasicAuthenticationMechanismDefinition` 注解来注解要安全化的资源（即，一个servlet或JAX-RS
    RESTful Web服务），可以实现基本身份验证机制：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value of the `realmName` attribute of the `@BasicAuthenticationMechanismDefinition`
    annotation will be sent to the browser in the `WWW-Authenticate` response header.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BasicAuthenticationMechanismDefinition` 注解的 `realmName` 属性值将发送到浏览器的 `WWW-Authenticate`
    响应头中。'
- en: 'Using basic authentication will cause the browser to pop up a window asking
    for a User Name and a Password:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本身份验证会导致浏览器弹出一个窗口，要求输入用户名和密码：
- en: '![](img/730b4861-a2d8-4f02-8ee3-24755e5695f9.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/730b4861-a2d8-4f02-8ee3-24755e5695f9.png)'
- en: 'Once the user enters the correct credentials, then access is granted to the
    protected resource:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入正确的凭据，则允许访问受保护的资源：
- en: '![](img/ac27f484-9430-4bb0-9ae6-e6a27e7e4704.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac27f484-9430-4bb0-9ae6-e6a27e7e4704.png)'
- en: Form authentication mechanism
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单身份验证机制
- en: 'Another way we can authenticate our users is to develop an HTML form to collect
    the user''s credentials, then delegate authentication to the Java EE Security
    API. The first step when following this approach is to develop an HTML page where
    the user can log in to the application, as illustrated in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来验证用户的一种方法是开发一个HTML表单来收集用户的凭据，然后将身份验证委托给Java EE安全API。采用这种方法的第一步是开发一个HTML页面，用户可以在其中登录到应用程序，如下例所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the example, the HTML form used for logging in must submit an HTTP
    POST request, the value for its `action` attribute must be `j_security_check`.
    `j_security_check` maps to a servlet provided by the Java EE Security API, we
    don't need to develop any validation logic ourselves. The form must have a couple
    of input fields, one for the username and one for the password, names for these
    fields must be `j_username` and `j_password`, respectively; the security servlet
    provided by the Java EE API will retrieve these values and authenticate the user
    automatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，用于登录的HTML表单必须提交一个HTTP POST请求，其 `action` 属性的值必须是 `j_security_check`。`j_security_check`
    映射到Java EE安全API提供的servlet，我们不需要自己开发任何验证逻辑。表单必须包含几个输入字段，一个用于用户名，一个用于密码，这些字段的名称必须分别是
    `j_username` 和 `j_password`；Java EE API提供的安全servlet将检索这些值并自动验证用户。
- en: 'Additionally, we need to provide an HTML page where the user will be redirected
    if login fails. The page can have any valid HTML markup; in our example, we simply
    provide an error message and a link to direct the user back to the login page
    so that they can try to log in again:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要提供一个HTML页面，如果登录失败，用户将被重定向到该页面。该页面可以有任何有效的HTML标记；在我们的示例中，我们只是提供了一个错误消息和一个链接，将用户重定向回登录页面，以便他们可以再次尝试登录：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the server side, all we need to do is annotate the secured resource with
    the `@FormAuthenticationMechanismDefinition` annotation, which will let the Java
    EE Security API know we are using form-based authentication, and what HTML pages
    to use to log in or to display when logging in fails:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们所需做的就是使用 `@FormAuthenticationMechanismDefinition` 注解注解受保护的资源，这将让Java
    EE安全API知道我们正在使用基于表单的身份验证，以及要使用的登录或登录失败时显示的HTML页面：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `@FormAuthenticationMechanismDefinition` annotation has a required `loginToContinue`
    attribute; the value of this attribute must be an instance of the `@LoginToContinue`
    annotation. `@LoginToContinue` has two required attributes, `loginPage` and `errorPage`;
    the value of these attributes must indicate the path for the login page, and the
    path of the page to display in case of authentication failure, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FormAuthenticationMechanismDefinition` 注解有一个必需的 `loginToContinue` 属性；此属性的值必须是
    `@LoginToContinue` 注解的一个实例。`@LoginToContinue` 有两个必需的属性，`loginPage` 和 `errorPage`；这些属性的值必须分别指示登录页面的路径和在身份验证失败时显示的页面的路径。'
- en: 'After building and deploying our code, then attempting to access a protected
    resource, the user is automatically redirected to our login page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和部署我们的代码后，尝试访问受保护的资源，用户将被自动重定向到我们的登录页面：
- en: '![](img/04353674-1648-445d-99d7-59a4a19ac00b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04353674-1648-445d-99d7-59a4a19ac00b.png)'
- en: 'If the user enters the correct credentials, then access to the protected resource
    is granted:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入正确的凭据，则允许访问受保护的资源：
- en: '![](img/02ee8247-c7ed-4b3e-a7f3-314b8b4dbb17.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02ee8247-c7ed-4b3e-a7f3-314b8b4dbb17.png)'
- en: 'If invalid credentials are entered, then the user is directed to our error
    page:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入了无效的凭证，则用户将被重定向到我们的错误页面：
- en: '![](img/08c05df8-e57d-4a10-94c7-9b3d0a243295.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08c05df8-e57d-4a10-94c7-9b3d0a243295.png)'
- en: Custom form authentication mechanism
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义表单认证机制
- en: Another way we can authenticate users in our application is to use a custom
    form authentication mechanism; this type of authentication mechanism is useful
    when we want to integrate our application with a web framework, such as JSF. In
    our next example, we will illustrate how to do just that, integrating the Java
    EE Security API with JSF, via custom form authentication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们还可以通过使用自定义表单认证机制来验证用户；当我们需要将应用程序与一个Web框架，如JSF集成时，这种认证机制非常有用。在接下来的示例中，我们将展示如何做到这一点，通过自定义表单认证将Java
    EE安全API与JSF集成。
- en: 'To use custom form authentication in our applications, we need to use the aptly
    named `@CustomFormAuthenticationMechanismDefinition` annotation, as illustrated
    in the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用自定义表单认证，我们需要使用名为`@CustomFormAuthenticationMechanismDefinition`的注解，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like the `@FormAuthenticationMechanismDefinition` annotation we saw previously,
    the `@CustomFormAuthenticationMechanismDefinition` annotation has a `loginToContinue`
    attribute that takes an instance of the `@LoginToContinue` annotation as its value.
    In this case, since we are integrating with JSF, the value of the `loginPage`
    attribute of `@LoginToContinue` must point to the path of a Facelets page used
    for the user to log in. When using JSF to authenticate the user, it is expected
    that the login page will display an error message if authentication fails, therefore
    we need to leave the `errorPage` attribute of `@LoginToContinue` blank.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前看到的`@FormAuthenticationMechanismDefinition`注解一样，`@CustomFormAuthenticationMechanismDefinition`注解有一个`loginToContinue`属性，它接受一个`@LoginToContinue`注解的实例作为其值。在这种情况下，由于我们正在与JSF集成，`@LoginToContinue`的`loginPage`属性值必须指向用户登录所使用的Facelets页面的路径。当使用JSF进行用户认证时，预期登录页面会在认证失败时显示错误消息，因此我们需要将`@LoginToContinue`的`errorPage`属性留空。
- en: 'Our login page is a standard Facelets page that collects user credentials and
    redirects to a CDI bean that acts as a controller:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录页面是一个标准的Facelets页面，它收集用户凭证并将重定向到一个充当控制器的CDI bean：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our login page has input fields for username and password; it stores those
    values into a CDI named bean (not shown as it is trivial) via value-binding expressions.
    When the user clicks on the Login button, controls go to a `LoginController` CDI
    named bean that performs the actual authentication:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录页面有用户名和密码的输入字段；它通过值绑定表达式将这些值存储到一个CDI命名bean中（未显示，因为它很 trivial）。当用户点击登录按钮时，控制权转移到执行实际认证的`LoginController`
    CDI命名bean：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our `LoginController` class, we need to inject an instance of `javax.security.enterprise.SecurityContext`,
    since we will need it for authentication. Our `login()` method is where we implement
    the authentication logic. The first thing we need to do is create an instance
    of `UsernamePasswordCredential`, passing the user-entered username and password
    as parameters to its constructor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`LoginController`类中，我们需要注入一个`javax.security.enterprise.SecurityContext`的实例，因为我们将在认证时需要它。我们的`login()`方法是实现认证逻辑的地方。首先我们需要做的是创建一个`UsernamePasswordCredential`的实例，将用户输入的用户名和密码作为参数传递给其构造函数。
- en: We then create an instance of `javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters`,
    by invoking the static `withParams()` method on `AuthenticationParameters`, then
    invoking the `credential()` method on the resulting instance of `AuthenticationParameters`.
    We then pass the instance of `UserNamePasswordCredential` we just created as a
    parameter; this returns yet another instance of `AuthenticationParameters`, which
    we can use to actually validate the user-entered credentials.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`AuthenticationParameters`上调用静态的`withParams()`方法，然后在该`AuthenticationParameters`的实例上调用`credential()`方法，创建一个`javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters`的实例。然后，我们将刚刚创建的`UserNamePasswordCredential`实例作为参数传递；这会返回另一个`AuthenticationParameters`的实例，我们可以使用它来实际验证用户输入的凭证。
- en: We validate user-entered credentials by invoking the `authenticate()` method
    on our `SecurityContext` instance, passing the HTTP Request and Response objects
    as parameters, as well as the instance of `AuthenticationParameters` containing
    the user-entered credentials. This method invocation will return an instance of
    `AuthenticationStatus`, we need to check the returned instance to determine whether
    the user entered valid credentials.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`SecurityContext`实例上调用`authenticate()`方法来验证用户输入的凭据，将HTTP请求和响应对象作为参数传递，以及包含用户输入凭据的`AuthenticationParameters`实例。这个方法调用将返回一个`AuthenticationStatus`实例，我们需要检查返回的实例以确定用户是否输入了有效的凭据。
- en: If `SecurityContext.authenticate()` returns `AuthenticationStatus.SEND_CONTINUE`,
    then the user-entered credentials were valid and we can allow the user to access
    the requested resource. If, instead, the method returns `AuthenticationStatus.SEND_FAILURE`,
    then the user-entered credentials were invalid, and we need to prevent the user
    from accessing the protected resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SecurityContext.authenticate()`返回`AuthenticationStatus.SEND_CONTINUE`，则用户输入的凭据是有效的，我们可以允许用户访问请求的资源。如果该方法返回`AuthenticationStatus.SEND_FAILURE`，则用户输入的凭据是无效的，我们需要阻止用户访问受保护的资源。
- en: 'After deploying and running our application, when a user attempts to access
    a protected resource, they are automatically redirected to a login page, which
    in this case, since we are using custom form authentication, is implemented using
    JSF:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署和运行我们的应用程序后，当用户尝试访问受保护的资源时，他们将被自动重定向到登录页面，在这种情况下，由于我们使用自定义表单认证，它是通过JSF实现的：
- en: '![](img/70475373-3017-48be-8e98-12bb223766ea.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70475373-3017-48be-8e98-12bb223766ea.png)'
- en: 'Entering correct credentials will direct the user to the protected resource
    (not shown) while entering incorrect credentials directs the user back to the
    login page, which should show an appropriate error message:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输入正确的凭据将直接将用户导向受保护的资源（未显示），而输入错误的凭据则将用户重定向回登录页面，该页面应显示适当的错误消息：
- en: '![](img/60911cf2-0330-4be3-a9dc-f9a22e70de44.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60911cf2-0330-4be3-a9dc-f9a22e70de44.png)'
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the new Security API introduced in Java EE 8\. We
    covered how we can access different types of identity stores to retrieve user
    credentials, such as relational databases or LDAP databases. We also covered how
    the security API provides the ability to integrate with custom identity stores,
    in case we need to access one that is not directly supported.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java EE 8中引入的新安全API。我们介绍了如何访问不同类型的身份存储来检索用户凭据，例如关系数据库或LDAP数据库。我们还介绍了安全API如何提供与自定义身份存储集成的能力，以防我们需要访问一个直接不支持的身份存储。
- en: Additionally, we saw how we can use different authentication mechanisms to allow
    access to our secured Java EE applications. This included how to implement the
    basic authentication mechanism provided by all web browsers, as well as how to
    implement form-based authentication mechanisms, where we provide custom HTML pages
    used for authentication. Additionally, we saw how we can use the custom form authentication
    mechanism provided by the security API so that we can integrate our application
    security with a web framework such as JSF.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们看到了如何使用不同的认证机制来允许访问我们的受保护Java EE应用程序。这包括如何实现所有网络浏览器提供的基本认证机制，以及如何实现基于表单的认证机制，其中我们提供用于认证的自定义HTML页面。此外，我们还看到了如何使用安全API提供的自定义表单认证机制，以便我们可以将我们的应用程序安全性与JSF等网络框架集成。
