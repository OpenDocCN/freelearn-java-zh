- en: Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'In the last chapter, we learned how to create a web application that uses a
    database. In this chapter, we will learn how to write and execute unit tests in
    Eclipse for JEE applications. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建使用数据库的Web应用程序。在本章中，我们将学习如何在Eclipse中为JEE应用程序编写和执行单元测试。本章将涵盖以下主题：
- en: Creating and executing unit tests using Eclipse JEE
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse JEE创建和执行单元测试
- en: Executing unit tests from Eclipse IDE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Eclipse IDE执行单元测试
- en: Mocking external dependencies for unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单元测试模拟外部依赖
- en: Calculating unit test coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单元测试覆盖率
- en: Testing the software that you develop is a very important part of the overall
    software development cycle. There are many types of testing; each one has a specific
    purpose, and each one varies in scope. Some examples of testing are functional
    testing, integration testing, scenario testing, and unit testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你开发的软件是整个软件开发周期中非常重要的一个部分。测试的类型有很多；每一种都有其特定的目的，并且范围各不相同。测试的例子包括功能测试、集成测试、场景测试和单元测试。
- en: 'Of all these types, unit tests are the narrowest in scope and are typically
    coded and executed by developers. Each unit test is meant to test a specific and
    small piece of functionality (typically, a method in a class), and is expected
    to execute without any external dependencies. Here are some of the reasons why
    you should write efficient unit tests:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些类型中，单元测试的范围最窄，通常由开发者编码和执行。每个单元测试旨在测试特定的、小块的功能（通常是一个类中的方法），并且预期在没有外部依赖的情况下执行。以下是你应该编写高效单元测试的一些原因：
- en: To catch bugs early. If you find a bug in functional or integration testing,
    which have a much wider scope of testing, then it might be difficult to isolate
    the code that caused the bug. It is much easier to catch and fix bugs in unit
    testing, because unit tests, by definition, work in a narrower scope, and if a
    test fails, you will find out exactly where to go to fix the issue.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了尽早捕捉到错误。如果在功能或集成测试中发现错误，这些测试的范围要广泛得多，那么可能很难隔离导致错误的代码。在单元测试中捕捉和修复错误要容易得多，因为单元测试，按照定义，在一个更窄的范围内工作，如果测试失败，你将确切知道去哪里修复问题。
- en: Unit tests can help you catch any regression that you might have introduced
    when editing the code. There are good tools and libraries available for automating
    the execution of unit tests. For example, using build tools such as Ant and Maven,
    you can execute unit tests at the end of a successful build, so that you will
    immediately find out if the changes you have made have broken any previously working
    code.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试可以帮助你捕捉到在编辑代码时可能引入的任何回归。有很好的工具和库可用于自动化单元测试的执行。例如，使用构建工具如Ant和Maven，你可以在构建成功后执行单元测试，这样你就可以立即发现你所做的更改是否破坏了之前正常工作的代码。
- en: As mentioned previously, writing unit tests and executing them is typically
    the responsibility of the developer. Therefore, most IDEs have good built-in support
    for writing and executing unit tests. Eclipse JEE is no exception. It has built-in
    support for JUnit, which is a popular unit testing framework for Java.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写单元测试并执行它们通常是开发者的责任。因此，大多数IDE都提供了良好的内置支持来编写和执行单元测试。Eclipse JEE也不例外。它内置了对JUnit的支持，JUnit是一个流行的Java单元测试框架。
- en: In this chapter, we will see how to write and execute JUnit tests for the *Course
    Management* web application that we built in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, first, here is a quick introduction
    to JUnit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何为我们在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中构建的*课程管理*网络应用程序编写和执行JUnit测试，*创建JEE数据库应用程序*。然而，首先，这里有一个JUnit的快速介绍。
- en: Introducing JUnit
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍JUnit
- en: JUnit test classes are Java classes separate from the classes you want to test.
    Each test class can contain many test cases, which are just methods marked to
    be executed when JUnit tests are executed. A test suite is a collection of test
    classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit测试类是与你要测试的类分开的Java类。每个测试类可以包含许多测试用例，这些测试用例只是标记为在执行JUnit测试时执行的方法。测试套件是一组测试类。
- en: The convention is to assign the test class the same name as that of the class
    you want to test, and append `Test` to that name. For example, if you wanted to
    test the `Course` class from the previous chapter, then you would create a JUnit
    test class and name it `CourseTest`. Test case (method) names start with `test`,
    followed by the name of the method in the class that you want to test; for example,
    if you wanted to test the `validate` method in the `Course` class, then you would
    create the `testValidate` method in the `CourseTest` class. Test classes are also
    created in the same package as the package in which the classes to be tested are
    present. In Maven projects, test classes are typically created under the `src/test/java`
    folder. The convention is to create the same package structure in the `test` folder
    as in the `src/main/java` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，将测试类命名为你想要测试的类的相同名称，并在该名称后附加 `Test`。例如，如果你想要测试上一章中的 `Course` 类，那么你会创建一个
    JUnit 测试类，并将其命名为 `CourseTest`。测试用例（方法）名称以 `test` 开头，后跟你要测试的类中的方法名称；例如，如果你想要测试
    `Course` 类中的 `validate` 方法，那么你会在 `CourseTest` 类中创建 `testValidate` 方法。测试类也创建在与要测试的类所在的包相同的包中。在
    Maven 项目中，测试类通常位于 `src/test/java` 文件夹下。习惯上，在 `test` 文件夹中创建与 `src/main/java` 文件夹相同的包结构。
- en: 'JUnit supports annotations to mark unit tests and test suites. Here is a simple
    test case for the `Course` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 支持使用注解标记单元测试和测试套件。以下是对 `Course` 类的简单测试用例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's assume that the `validate` method checks that the course `name` is not
    null and that `credits` is greater than zero.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `validate` 方法检查课程 `name` 是否为非空，以及 `credits` 是否大于零。
- en: The preceding test case is marked with the `@Test` annotation. It creates an
    instance of the `Course` class, and then calls the `Assert.assertFalse` method
    to make sure that the `validate` method returns `false`, because `name` and `credits`
    are not set, and they will have their default values, which are `null` and `0`,
    respectively. `Assert` is a class provided by the JUnit library, and has many
    assert methods to test many conditions (see [http://junit.sourceforge.net/javadoc/org/junit/Assert.html](http://junit.sourceforge.net/javadoc/org/junit/Assert.html)
    for more information).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试用例被标记为 `@Test` 注解。它创建了一个 `Course` 类的实例，然后调用 `Assert.assertFalse` 方法来确保
    `validate` 方法返回 `false`，因为 `name` 和 `credits` 没有设置，它们将具有默认值，分别是 `null` 和 `0`。`Assert`
    是由 JUnit 库提供的一个类，它有许多断言方法来测试多种条件（更多信息请参见 [http://junit.sourceforge.net/javadoc/org/junit/Assert.html](http://junit.sourceforge.net/javadoc/org/junit/Assert.html)）。
- en: The test case, then, only sets the name, and does the same validation again,
    expecting the `validate` method to return `false`, because the credits are still
    zero. Finally, the test case sets both the name and credits, and calls the `Assert.assertTrue`
    method to ensure that `course.validate()` returns `true`. If any of the assertions
    fail, then the test case fails.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试用例仅设置名称，并再次执行相同的验证，期望 `validate` 方法返回 `false`，因为学分仍然是零。最后，测试用例设置名称和学分，并调用
    `Assert.assertTrue` 方法来确保 `course.validate()` 返回 `true`。如果任何断言失败，则测试用例失败。
- en: 'Other than `@Test`, you can use the following annotations provided by JUnit:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `@Test`，你还可以使用 JUnit 提供的以下注解：
- en: '`@Before` and `@After`: Methods annotated with these annotations are executed
    before and after each test. You may want to initialize resources in `@Before`
    and free them in `@After`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before` 和 `@After`：带有这些注解的方法在每个测试前后执行。你可能想在 `@Before` 中初始化资源，并在 `@After`
    中释放它们。'
- en: '`@BeforeClass` and `@AfterClass`: Similar to `@Before` and `@After`, but instead
    of being called per test, these methods are called once per test class. A method
    with the `@BeforeClass` annotation is called before any of the test cases in that
    class are executed, and one with `@AfterClass` is called after all the test cases
    are executed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeClass` 和 `@AfterClass`：与 `@Before` 和 `@After` 类似，但它们不是针对每个测试调用，而是在每个测试类中只调用一次。带有
    `@BeforeClass` 注解的方法在该类中的任何测试用例执行之前被调用，而带有 `@AfterClass` 注解的方法在所有测试用例执行之后被调用。'
- en: You can find more annotations for JUnit at [https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html](https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html](https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html)
    找到更多关于 JUnit 的注解。
- en: Creating and executing unit tests using Eclipse JEE
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Eclipse JEE 创建和执行单元测试
- en: 'To understand how to write unit tests, let''s take the JDBC version of the
    *Course Management* application that we developed in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. Let''s start with a simple test case for
    validating a course. The following is the source code of `Course.java`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何编写单元测试，让我们以我们在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建JEE数据库应用程序”中开发的*课程管理*应用程序的JDBC版本为例。让我们从一个简单的测试用例开始，用于验证课程。以下是`Course.java`的源代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating unit test cases
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试用例
- en: 'Maven projects follow certain conventions; the entire application source in
    a Maven project is in the `src/main/java` folder, and unit tests are expected
    to be in the `src/test/java` folder. In fact, when you create a Maven project
    in Eclipse, it creates the `src/test/java` folder for you. We are going to create
    our test cases in this folder. We are going to create the same package structure
    for the test classes as that for the application source; that is, to test the `packt.book.jee.eclipse.ch5.bean.Course`
    class, we will create the `packt.book.jee.eclipse.ch5.bean` package under the `src/test/java`
    folder and then create a JUnit test class called `CourseTest`, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Maven项目遵循某些约定；Maven项目的整个应用程序源代码位于`src/main/java`文件夹中，单元测试预期位于`src/test/java`文件夹中。实际上，当你使用Eclipse创建Maven项目时，它会为你创建`src/test/java`文件夹。我们将在该文件夹中创建我们的测试用例。我们将为测试类创建与应用程序源相同的包结构；也就是说，为了测试`packt.book.jee.eclipse.ch5.bean.Course`类，我们将在`src/test/java`文件夹下创建`packt.book.jee.eclipse.ch5.bean`包，然后创建一个名为`CourseTest`的JUnit测试类，如下所示：
- en: Right-click on the `src/test/java` folder in Package Explorer in Eclipse and
    select New | JUnit Test Case (if you do not find this option in the menu, select
    New | Other, and type `junit` into the Filter textbox. Then, select the JUnit
    Test Case option).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse的包资源管理器中，右键单击`src/test/java`文件夹，选择新建 | JUnit测试用例（如果你在菜单中找不到此选项，请选择新建
    | 其他，并在过滤器文本框中输入`junit`。然后，选择JUnit测试用例选项）。
- en: Enter the package name as `packt.book.jee.eclipse.ch5.bean` and the class name
    as `CourseTest`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入包名为`packt.book.jee.eclipse.ch5.bean`，类名为`CourseTest`。
- en: Click on the Browse... button next to the Class under test textbox. Type `course`
    into the Filter textbox and select the `Course` class:![](img/00127.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“测试用例下的类”旁边的浏览...按钮。在过滤器文本框中输入`course`，并选择`Course`类：![图片3](img/00127.jpeg)
- en: 'Figure 5.1: JUnit test case wizard'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.1：JUnit测试用例向导
- en: Click Next. The page shows methods in the class (`Course`) for which we want
    to create the test cases. Select the methods that you want to create test cases
    for.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步。页面显示我们想要为它们创建测试用例的类（`Course`）中的方法。选择你想要为它们创建测试用例的方法。
- en: 'We don''t want to test getters and setters because they are simple methods
    and don''t do much other than just getting or setting member variables. Presently,
    we will create a test case for only one method: `isValidTestCase`. Select the
    checkbox for this method:![](img/00128.jpeg)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不想测试getter和setter，因为它们是简单的方法，除了获取或设置成员变量之外，没有做太多其他的事情。目前，我们将只创建一个方法的测试用例：`isValidTestCase`。选择此方法的复选框：![图片2](img/00128.jpeg)
- en: 'Figure 5.2: Select methods for test cases'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.2：选择测试用例的方法
- en: Click Finish. Eclipse checks whether JUnit libraries are included in your project,
    and if not, prompts you to include them:![](img/00129.jpeg)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。Eclipse会检查JUnit库是否包含在你的项目中，如果没有，会提示你包含它们：![图片1](img/00129.jpeg)
- en: 'Figure 5.3: Include JUnit libraries in project'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.3：在项目中包含JUnit库
- en: Click OK. Eclipse creates the package and the test class with one method/test
    case called `testIsValidCourse`. Note that the method is annotated with `@Test`,
    indicating that it is a JUnit test case.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定。Eclipse创建包和测试类，包含一个名为`testIsValidCourse`的方法/测试用例。请注意，该方法使用`@Test`注解，表示它是一个JUnit测试用例。
- en: 'How do we test whether `isValidCourse` works as expected? We create an instance
    of the `Course` class, set some values that we know are valid/invalid, call the `isValidateCourse`
    method, and compare the results with the expected results. JUnit provides many
    methods in the `Assert` class to compare the actual results obtained by calling
    test methods with the expected results. So, let''s add the test code to the `testIsValidCourse`
    method:'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何测试`isValidCourse`是否按预期工作？我们创建一个`Course`类的实例，设置一些我们知道是有效/无效的值，调用`isValidateCourse`方法，并将结果与预期结果进行比较。JUnit在`Assert`类中提供了许多方法，用于比较通过调用测试方法获得的实际结果与预期结果。因此，让我们将测试代码添加到`testIsValidCourse`方法中：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first create an instance of the `Course` class, and without setting any of
    its values, call the `isValidCourse` method. We know that it is not a valid course
    because the name and credits are the required fields in a valid course. So, we
    check whether the returned value of `isValidCourse` is false by calling the `Assert.assertFalse`
    method. We then set the name and check again, expecting the instance to be an
    invalid course. Then, we set a `0` credits value for `Course`, and, finally, we
    set `4` credits for `Course`. Now, `isValidCourse` is expected to return `true`
    because both the name and credits are valid. We verify this by calling `Assert.assertTrue`.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先创建 `Course` 类的一个实例，并且不设置其任何值，然后调用 `isValidCourse` 方法。我们知道它不是一个有效课程，因为名称和学分是有效课程中必需的字段。因此，我们通过调用
    `Assert.assertFalse` 方法来检查 `isValidCourse` 返回的值是否为 `false`。然后我们设置名称并再次检查，预期实例是一个无效课程。然后，我们为
    `Course` 设置 `0` 学分值，最后，我们为 `Course` 设置 `4` 学分。现在，`isValidCourse` 预期返回 `true`，因为名称和学分都是有效的。我们通过调用
    `Assert.assertTrue` 来验证这一点。
- en: Running unit test cases
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元测试用例
- en: 'Let''s run this test case in Eclipse. Right-click on the file, or anywhere
    in the project in Package Explorer, and select the Run As | JUnit Test menu. Eclipse
    finds all unit tests in the project, executes them, and shows the results in the
    JUnit view:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在 Eclipse 中运行这个测试用例。在文件上右键单击，或在包资源管理器中的项目中的任何位置，然后选择 Run As | JUnit Test
    菜单。Eclipse 会找到项目中的所有单元测试，执行它们，并在 JUnit 视图中显示结果：
- en: '![](img/00130.jpeg)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/00130.jpeg)'
- en: 'Figure 5.4: JUnit results view'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4：JUnit 结果视图
- en: This view shows a summary of the test cases run. In this case, it has run one
    test case, which was successful. The green bar shows that all test cases were
    executed successfully.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此视图显示了运行测试用例的摘要。在这种情况下，它已运行了一个测试用例，并且是成功的。绿色条表示所有测试用例都成功执行。
- en: 'Now, let''s add one more check into the method:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们在方法中添加一个额外的检查：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, run the test case again:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，再次运行测试用例：
- en: '![](img/00131.jpeg)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/00131.jpeg)'
- en: 'Figure 5.5: JUnit results view showing the failed test'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.5：显示失败测试的 JUnit 结果视图
- en: 'The test case failed because `course.isValidCourse()` returned `true` when
    the course name was set to an empty string, while the test case expected the instance
    to be an invalid course. So, we need to modify the `isValidCourse` method of the `Course`
    class to fix this failure:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试用例失败是因为当课程名称设置为空字符串时，`course.isValidCourse()` 返回了 `true`，而测试用例预期实例应该是一个无效课程。因此，我们需要修改
    `Course` 类的 `isValidCourse` 方法以修复这个失败：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added the condition to check the length of the `name` field. This should
    fix the test case failure. You can run the test case again to verify.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经添加了检查 `name` 字段长度的条件。这应该可以修复测试用例失败。你可以再次运行测试用例以验证。
- en: Running unit test cases using Maven
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 运行单元测试用例
- en: You can run unit test cases using Maven, too. In fact, the install target of
    Maven also runs unit tests. However, it is possible to run only unit tests. To
    do this, right-click on the project in Package Explorer and select Run As | Maven test.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以使用 Maven 运行单元测试。事实上，Maven 的 install 目标也会运行单元测试。然而，你可以只运行单元测试。为此，在包资源管理器中右键单击项目，然后选择
    Run As | Maven test。
- en: 'You might see the following error in the console:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能在控制台看到以下错误：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason for this error is that we haven''t added a dependency on JUnit for
    our Maven project. Add the following dependency in `pom.xml`:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个错误的原因是我们没有为我们的 Maven 项目添加 JUnit 依赖。在 `pom.xml` 中添加以下依赖项：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Refer to the *Using Maven for project management* section in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, to learn how to add dependencies to a
    Maven project.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考第 2 章 *使用 Maven 进行项目管理* 中的 *创建简单的 JEE Web 应用程序* 部分，了解如何向 Maven 项目添加依赖项。
- en: Run the Maven test again; this time, the test should pass.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行 Maven 测试；这次测试应该会通过。
- en: Mocking external dependencies for unit tests
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元测试模拟外部依赖
- en: Unit tests are meant to execute without any external dependencies. We can certainly
    write methods at a granular level, such that the core business logic methods are
    totally separate from methods that have external dependencies. However, sometimes
    this is not practical, and we may have to write unit tests for code that are closely
    dependent on methods that access external systems.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元测试旨在在没有任何外部依赖的情况下执行。我们当然可以编写细粒度的方法，使得核心业务逻辑方法与具有外部依赖的方法完全分离。然而，有时这并不实际，我们可能不得不为紧密依赖于访问外部系统的方法的代码编写单元测试。
- en: 'For example, let''s assume that we have to add a method in our `Course` bean
    to add students to the course. We will also mandate that the course has an upper
    limit on the number of students that it can enroll, and once this limit is reached,
    no more students can be enrolled. Let''s add the following method to our `Course`
    bean:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设我们必须在`Course`对象中添加一个方法来添加学生到课程中。我们还将强制规定课程对学生数量的上限，一旦达到这个上限，就不能再添加更多学生。让我们向我们的`Course`对象添加以下方法：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `addStudent` method first finds the current enrollment in the course. For
    this, it queries the database using the `CourseDAO` class. It then checks whether
    the current enrollment is less than the maximum enrollment. Then, it calls the `enrollStudentInCourse`
    method of `CourseDAO`.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addStudent`方法首先找到课程当前的学生注册人数。为此，它使用`CourseDAO`类查询数据库。然后，它检查当前注册人数是否小于最大注册人数。然后，它调用`CourseDAO`的`enrollStudentInCourse`方法。'
- en: 'The `addStudent` method has an external dependency. It depends on successful
    access to an external database. We can write a unit test for this function as
    follows:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addStudent`方法有一个外部依赖。它依赖于成功访问外部数据库。我们可以为这个函数编写以下单元测试：'
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `testAddStudent` method is meant to check whether  `addStudent` method works
    fine when all external dependencies are satisfied; in this case, it means that
    a database connection is established, the database server is up and running, and
    the tables are configured properly. If we want to verify that the functionality
    to enroll a student on a course works by taking into account all dependencies,
    then we should write a functional test. Unit tests only need to check whether
    code that does not depend on external dependencies works fine; in this case, it
    is a trivial check to verify that the total enrollment is less than the maximum
    allowed enrollment. This is a simple example, but in real applications you might
    have a lot more complex code to test.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`testAddStudent`方法旨在检查当所有外部依赖都满足时，`addStudent`方法是否运行正常；在这种情况下，这意味着数据库连接已建立，数据库服务器正在运行，并且表已正确配置。如果我们想通过考虑所有依赖项来验证在课程上注册学生的功能是否正常工作，那么我们应该编写一个功能测试。单元测试只需要检查不依赖于外部依赖的代码是否运行正常；在这种情况下，这是一个简单的检查，以验证总注册人数是否小于最大允许注册人数。这是一个简单的例子，但在实际应用中，你可能需要测试更多复杂的代码。'
- en: The problem with the previous unit test is that we may have false failures,
    from the perspective of unit testing, because the database could be down or might
    not be configured correctly. One solution is to mock external dependencies; we
    can mock calls to the database (in this case, calls to `CourseDAO`). Instead of
    making real calls to the database, we can create stubs that will return some mock
    data or perform a mock operation. For example, we can write a mock function that
    returns some hardcoded value for the `getNumStudentsInCourse` method of `CourseDAO`.
    However, we don't want to modify the application source code to add mock methods.
    Fortunately, there are open source frameworks that let us mock dependencies in
    unit tests. Next, we will see how to mock dependencies using a popular framework
    called Mockito ([http://mockito.org/](http://mockito.org/)).
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前单元测试的问题是我们可能会出现假失败，从单元测试的角度来看，因为数据库可能已关闭或可能没有正确配置。一个解决方案是模拟外部依赖；我们可以模拟对数据库的调用（在这种情况下，对`CourseDAO`的调用）。我们不需要对数据库进行实际调用，而是可以创建返回一些模拟数据或执行模拟操作的存根。例如，我们可以编写一个模拟函数，为`CourseDAO`的`getNumStudentsInCourse`方法返回一些硬编码的值。然而，我们不想修改应用程序源代码来添加模拟方法。幸运的是，有一些开源框架允许我们在单元测试中模拟依赖项。接下来，我们将看到如何使用名为Mockito的流行框架来模拟依赖项（[http://mockito.org/](http://mockito.org/))。
- en: Using Mockito
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mockito
- en: 'At a very high level, we can use Mockito to do two things:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在非常高的层面上，我们可以使用Mockito做两件事：
- en: Provide wrapper implementations over dependent methods in the application class
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序类中提供依赖方法的包装器实现
- en: Verify that these wrapper implementations are called
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证这些包装器实现是否被调用
- en: 'We specify the wrapper implementation using a static method of Mockito:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Mockito的静态方法指定包装器实现：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Further, we verify whether the wrapper method was called by calling another
    static method of Mockito:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们通过调用Mockito的另一个静态方法来验证包装器方法是否被调用：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use Mockito in our project, we need to add a dependency on it in our `pom.xml`:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用Mockito，我们需要在`pom.xml`中添加对其的依赖：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we start writing a unit test case using Mockito, we will make a small
    change in the `Course` class. Currently, `CourseDAO` in the `Course` class is
    private and there are no setters for it. Add the setter method (`setCourseDAO`)
    in the `Course` class:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们开始使用Mockito编写单元测试用例之前，我们将在`Course`类中进行一些小的修改。目前，`Course`类中的`CourseDAO`是私有的，并且没有为其提供setter方法。在`Course`类中添加setter方法（`setCourseDAO`）：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's rewrite our test case using Mockito.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们使用Mockito重写我们的测试用例。
- en: 'First, we need to tell Mockito which method calls we want to mock and what
    action should be taken in the mocked function (for example, return a specific
    value). In our example, we would like to mock the methods in `CourseDAO` that
    are called from the `Course.addStudent` method, because methods in `CourseDAO`
    access the database, and we want our unit tests to be independent of the data
    access code. Therefore, we create a mocked (wrapper) instance of `CourseDAO` using
    Mockito:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉Mockito我们想要模拟哪些方法调用以及模拟函数中应该采取什么操作（例如，返回特定值）。在我们的例子中，我们希望模拟从`Course.addStudent`方法中调用的`CourseDAO`中的方法，因为`CourseDAO`中的方法访问数据库，而我们希望我们的单元测试独立于数据访问代码。因此，我们使用Mockito创建了一个模拟的（包装）`CourseDAO`实例：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we tell Mockito which specific methods in this object to mock. We want
    to mock `getNumStudentsInCourse` and `getNumStudentsInCourse`as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们告诉Mockito在这个对象中要模拟哪些具体方法。我们想要模拟`getNumStudentsInCourse`和`getNumStudentsInCourse`如下：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code is in a `try...catch` block because the `getNumStudentsInCourse` and
    `getNumStudentsInCourse` methods throw `SQLException`. This will not happen when
    we mock the method because the mocked method will not call any SQL code. However,
    since the signature of these methods indicates that `SQLException` can be thrown
    from these methods, we have to call them in `try...catch` to avoid compiler errors.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码位于`try...catch`块中，因为`getNumStudentsInCourse`和`getNumStudentsInCourse`方法会抛出`SQLException`。由于模拟的方法不会调用任何SQL代码，所以这不会发生。然而，由于这些方法的签名表明`SQLException`可以从这些方法中抛出，我们必须在`try...catch`中调用它们以避免编译器错误。
- en: The first statement in the `try` block tells Mockito that when the `getNumStudentsInCourse`
    method is called on the `courseDAO` object with the parameter `1` (course ID),
    it should return `60` from the mocked method.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`try`块中的第一个语句告诉Mockito，当在`courseDAO`对象上调用`getNumStudentsInCourse`方法，并传递参数`1`（课程ID）时，它应该从模拟的方法中返回`60`。'
- en: The second statement tells Mockito that when `enrollStudentInCourse` is called
    on the `courseDAO` object with the arguments `1` (course ID) and `1` (student
    ID), it should do nothing. We don't really want to insert any record into the
    database from the unit test code.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个语句告诉Mockito，当在`courseDAO`对象上调用`enrollStudentInCourse`方法，并传递参数`1`（课程ID）和`1`（学生ID）时，它应该不执行任何操作。我们并不想在单元测试代码中真正地将任何记录插入到数据库中。
- en: 'We will now create the `Course` and `Student` objects and call the `addStudent`
    method of `Course`. This code is similar to the one we wrote in the preceding
    test case:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将创建`Course`和`Student`对象，并调用`Course`的`addStudent`方法。这段代码与我们在前面的测试用例中写的类似：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the course ID and student ID that we used when creating the `Course`
    and `Student` objects, respectively, should match the arguments we passed to `getNumStudentsInCourse`
    and `enrollStudentInCourse` when mocking the methods.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在创建`Course`和`Student`对象时使用的课程ID和学生ID应该与我们模拟方法时传递给`getNumStudentsInCourse`和`enrollStudentInCourse`的参数相匹配。
- en: We have set that the maximum number of students to be allowed in this course
    to `60`. When mocking `getNumStudentsInCourse`, we asked Mockito to also return
    `60`. Therefore, the `addStudent` method should throw an exception because the
    course is full. We will verify this by adding the `@Test` annotation later.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经将允许在这个课程中学习的最大学生人数设置为`60`。当模拟`getNumStudentsInCourse`时，我们要求Mockito也返回`60`。因此，`addStudent`方法应该抛出一个异常，因为课程已满。我们将在稍后添加`@Test`注解来验证这一点。
- en: 'At the end of the test, we want to verify that the mocked method was actually
    called:'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试结束时，我们想要验证模拟的方法实际上被调用了：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code verifies that `getNumStudentsInCourse` of `courseDAO` was
    called at least once by Mockito, when running this test.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码验证了当运行这个测试时，Mockito至少调用了一次`courseDAO`的`getNumStudentsInCourse`方法。
- en: 'Here is the complete test case, including the `@Test` annotation attribute,
    to make sure that the function throws an exception:'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是完整的测试用例，包括`@Test`注解属性，以确保函数抛出异常：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, run the unit tests. All tests should pass.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，运行单元测试。所有测试都应该通过。
- en: 'Here is a similar test case that makes Mockito return the current enrollment
    number of `59`, and makes sure that the student is enrolled successfully:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个类似的测试用例，它使Mockito返回当前的注册人数为`59`，并确保学生成功注册：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this test case does not expect any exceptions to be thrown (if an
    exception is thrown, then the test case fails). We can also verify that the mocked
    `enrollStudentInCourse` method is called. We did not verify this in the previous
    test case because an exception was thrown before calling this method in the `Course.addStudent`
    method.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个测试用例不期望抛出任何异常（如果抛出异常，则测试用例失败）。我们还可以验证被模拟的`enrollStudentInCourse`方法是否被调用。我们之前没有验证这一点，因为在`Course.addStudent`方法调用此方法之前抛出了异常。
- en: 'There are many topics of JUnit that we have not covered in this section. You
    are encouraged to read the JUnit documentation at [https://github.com/junit-team/junit4/wiki](https://github.com/junit-team/junit4/wiki).
    In particular, the following topics might be of interest to you:'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们还没有涵盖JUnit的许多主题。我们鼓励您阅读JUnit文档[https://github.com/junit-team/junit4/wiki](https://github.com/junit-team/junit4/wiki)。特别是，以下主题可能对您感兴趣：
- en: JUnit test suites. You can aggregate test cases from different test classes
    in a suite. Find more information about test suites at [https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites](https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites).
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 测试套件。您可以在一个套件中聚合来自不同测试类的测试用例。有关测试套件的更多信息，请参阅[https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites](https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites)。
- en: Parameterized test cases; find information at [https://github.com/junit-team/junit4/wiki/Parameterized-tests](https://github.com/junit-team/junit4/wiki/Parameterized-tests).
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化测试用例；更多信息请参阅[https://github.com/junit-team/junit4/wiki/Parameterized-tests](https://github.com/junit-team/junit4/wiki/Parameterized-tests)。
- en: If you are using Apache Ant for building your project, then take a look at the
    JUnit Ant task at [https://ant.apache.org/manual/Tasks/junit.html](https://ant.apache.org/manual/Tasks/junit.html).
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用Apache Ant构建项目，那么请查看JUnit Ant任务[https://ant.apache.org/manual/Tasks/junit.html](https://ant.apache.org/manual/Tasks/junit.html)。
- en: Calculating unit test coverage
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算单元测试覆盖率
- en: 'Unit tests tell you whether your application code behaves as expected. Unit
    tests are important to maintain code quality and catch errors early in the development
    cycle. However, this goal is at risk if you do not write enough unit tests to
    test your application code, or if you have not tested all possible input conditions
    in the test cases and the exception paths. To measure the quality and adequacy
    of your test cases, you need to calculate the coverage of your test cases. In
    simple terms, coverage tells you what percentage of your application code was
    touched by running your unit tests. There are different measures to calculate
    coverage:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元测试可以告诉您您的应用程序代码是否按预期行为。单元测试对于维护代码质量和在开发周期早期捕获错误非常重要。然而，如果您没有编写足够的单元测试来测试您的应用程序代码，或者测试用例中没有测试所有可能的输入条件以及异常路径，那么这个目标就处于风险之中。为了衡量测试用例的质量和充分性，您需要计算测试用例的覆盖率。简单来说，覆盖率告诉您在运行单元测试时，您的应用程序代码中有多少百分比被触及。有不同方法来计算覆盖率：
- en: Number of lines covered
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖的行数
- en: Number of branches covered (created using the `if`, `else`, `elseif`, `switch`,
    and `try`/`catch` statements)
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖的分支数量（使用`if`、`else`、`elseif`、`switch`和`try`/`catch`语句创建）
- en: Number of functions covered
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖的函数数量
- en: Together, these three measures give a fair measurement of the quality of your
    unit tests. There are many code coverage tools for Java. In this chapter, we will
    take a look at an open source code coverage tool called JaCoCo ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)).
    JaCoCo also has an Eclipse plugin ([http://www.eclemma.org/](http://www.eclemma.org/)),
    and we can measure code coverage from right within Eclipse.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这三个指标共同为您单元测试的质量提供了一个公正的衡量。Java有许多代码覆盖率工具。在本章中，我们将探讨一个名为JaCoCo的开源代码覆盖率工具[http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)。JaCoCo还有一个Eclipse插件[http://www.eclemma.org/](http://www.eclemma.org/)，我们可以在Eclipse中直接测量代码覆盖率。
- en: 'You can install the JaCoCo plugin using the update URL ([http://update.eclemma.org/](http://update.eclemma.org/))
    or from Eclipse Marketplace. To install it using the update site, select the Help
    | Install New Software... menu. Click on the Add button and enter the name of
    the update site (you can give any name) and the update URL:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用更新URL（[http://update.eclemma.org/](http://update.eclemma.org/））或从Eclipse
    Marketplace安装JaCoCo插件。要使用更新站点安装它，选择帮助 | 安装新软件...菜单。点击添加按钮并输入更新站点的名称（您可以给出任何名称）和更新URL：
- en: '![](img/00132.jpeg)'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00132.jpeg)'
- en: 'Figure 5.6: Add an update site for JaCoCo'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.6：为JaCoCo添加更新站点
- en: Then, follow the instructions to install the plugin.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，按照说明安装插件。
- en: 'Alternatively, you can install it from the marketplace. Select the Help | Eclipse
    Marketplace... menu. Type `EclEmma` into the Find textbox, and click the Go button:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您也可以从市场安装它。选择帮助 | Eclipse Marketplace...菜单。在查找文本框中输入`EclEmma`，然后点击Go按钮：
- en: '![](img/00133.jpeg)'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00133.jpeg)'
- en: 'Figure 5.7: Install EclEmma code coverage plugin from Eclipse Marketplace'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：从Eclipse Marketplace安装EclEmma代码覆盖率插件
- en: Click the Install button and follow the instructions.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击安装按钮并按照说明操作。
- en: To verify that the plugin is installed properly, open Window | Show View | Other.
    Type `coverage` into the Filter textbox and make sure that the Coverage (under
    the Java category) view is available. Open the view.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要验证插件是否正确安装，打开窗口 | 显示视图 | 其他。在过滤器文本框中输入`coverage`并确保在Java类别下的覆盖率（Coverage）视图可用。打开该视图。
- en: 'To run a unit test with coverage, right-click on the project in Package Explorer
    and select Coverage As | JUnit Test. After the tests have run, the coverage information
    is displayed in the Coverage view:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要运行带有覆盖率单元测试，在包资源管理器中右键单击项目并选择覆盖率作为 | JUnit Test。测试运行后，覆盖率信息将在覆盖率视图中显示：
- en: '![](img/00134.jpeg)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: 'Figure 5.8: Coverage results'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.8：覆盖率结果
- en: How can you interpret these results? Overall, at the project level the coverage
    is 24.2%. This means that out of all the code that we have written in this application,
    our unit test case has touched only 24.2%. Then, there is the coverage percentage
    at the package level and at the class level.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您如何解释这些结果？总体而言，在项目级别，覆盖率是24.2%。这意味着在我们为这个应用程序编写的所有代码中，我们的单元测试用例只接触了24.2%。然后，还有包级别和类级别的覆盖率百分比。
- en: 'Double-click on `Course.java` in the Coverage view to see which lines are covered
    in this file. The following screenshot shows a part of the file where the red
    lines indicate the code that is not covered, and the green lines indicate the
    code that is covered:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在覆盖率视图中双击`Course.java`以查看此文件中哪些行被覆盖。以下截图显示了文件的一部分，其中红色行表示未覆盖的代码，绿色行表示覆盖的代码：
- en: '![](img/00135.jpeg)'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: 'Figure 5.9: Line coverage details'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.9：行覆盖率详情
- en: We have written unit tests for `addStudent`, and the coverage of this class
    is 100%, which is good. We haven't used all getters and setters in our unit tests,
    so some of them are not covered.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为`addStudent`编写了单元测试，这个类的覆盖率是100%，这是好的。我们没有在我们的单元测试中使用所有的`getters`和`setters`，因此其中一些没有被覆盖。
- en: As you can see, the coverage results help you understand places in your code
    for which unit tests are not written, or which are partially covered by the unit
    tests. Based on this data, you can add unit tests for the code that is not covered.
    Of course, you may not want all lines to be covered if the code is very simple,
    such as the getters and setters in the preceding class, if the code is very simple.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，覆盖率结果可以帮助您了解代码中未编写单元测试或部分被单元测试覆盖的地方。基于这些数据，您可以添加未覆盖的代码的单元测试。当然，如果代码非常简单，例如前面类中的获取器和设置器，您可能不希望所有行都被覆盖。
- en: 'In *Figure 5.8*, observe that the coverage tool has analyzed the test classes
    too. Typically, we don''t want to measure coverage on test classes; we want to
    measure the coverage of the application code by running the test classes. To exclude
    the test classes from this analysis, right-click on the project and select Coverage
    As | Coverage Configurations.... Click on the Coverage tab and select only CourseManagementJDBC
    - src/main/java:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*图5.8*中，观察一下覆盖率工具也分析了测试类。通常，我们不想对测试类进行覆盖率测量；我们希望通过运行测试类来测量应用程序代码的覆盖率。要排除测试类从这次分析中，在项目上右键单击并选择覆盖率作为
    | 覆盖率配置...。点击覆盖率选项卡并仅选择CourseManagementJDBC - src/main/java：
- en: '![](img/00136.jpeg)'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: 'Figure 5.10: Coverage configurations'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.10：覆盖率配置
- en: Click Coverage to run coverage with the new settings. You will see in the Coverage
    view that the test classes do not appear in the report, and that the overall test
    coverage on the project has also dropped.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击覆盖率以使用新设置运行覆盖率。您将在覆盖率视图中看到测试类没有出现在报告中，并且项目的整体测试覆盖率也有所下降。
- en: If you want to run coverage using Maven, then refer to [http://www.eclemma.org/jacoco/trunk/doc/maven.html](http://www.eclemma.org/jacoco/trunk/doc/maven.html).
    Specifically, take a look at `pom.xml` ([http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml](http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml)),
    which creates reports for JUnit and JaCoCo coverage.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想使用Maven运行覆盖率，请参阅[http://www.eclemma.org/jacoco/trunk/doc/maven.html](http://www.eclemma.org/jacoco/trunk/doc/maven.html)。具体来说，查看`pom.xml`([http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml](http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml))，它为JUnit和JaCoCo覆盖率创建报告。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing unit tests is an important part of the application development process.
    Unit tests help you catch bugs in your application at very early stages; they
    also help you catch any regression because of subsequent code changes. JUnit and
    Eclipse provide an easy way to integrate unit tests into your development workflow.
    Eclipse also creates a nice report in the JUnit view, which makes it easy to identify
    the failed tests and jump to the line in the code where the test failed.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写单元测试是应用程序开发过程中的重要部分。单元测试帮助您在非常早期阶段捕捉到应用程序中的错误；它们还帮助您捕捉到由于后续代码更改而引起的任何回归。JUnit和Eclipse提供了一种简单的方法将单元测试集成到您的开发工作流程中。Eclipse还在JUnit视图中创建了一个漂亮的报告，这使得识别失败的测试和跳转到测试失败的代码行变得容易。
- en: Unit tests are meant to be executed without any external dependencies. Libraries
    such as Mockito help you to mock any external dependencies.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元测试旨在在没有任何外部依赖的情况下执行。Mockito等库可以帮助您模拟任何外部依赖。
- en: Use coverage tools such as JaCoCo to find out the quality of the unit tests
    that you have written. Coverage tools tell you the percentage of the application
    code that is covered by your unit tests. You can also see in each class which
    lines are covered by your unit tests and which are not. Such a report can help
    you to decide whether you need to write more unit test cases or modify the existing
    unit test cases to cover important code that your unit tests have not tested.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用JaCoCo等覆盖率工具来检查您所编写的单元测试的质量。覆盖率工具会告诉您应用程序代码中有多少百分比被单元测试覆盖。您还可以查看每个类中哪些行被单元测试覆盖，哪些没有被覆盖。这样的报告可以帮助您决定是否需要编写更多的单元测试用例，或者修改现有的单元测试用例以覆盖单元测试未测试的重要代码。
- en: In the next chapter, we will see how to debug Java applications from Eclipse.
    The chapter will also explain how to connect to a remote JEE server for debugging.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何从Eclipse调试Java应用程序。这一章还将解释如何连接到远程JEE服务器进行调试。
