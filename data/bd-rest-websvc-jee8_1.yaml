- en: Getting Started with Java EE 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Java EE 8
- en: In this first chapter, you will learn why Java EE is a great platform for building
    lightweight state-of-the-art microservices. You will learn the latest advances
    in the different APIs of Java EE 8, with a focus on the more microservice-relevant
    APIs. You will then learn how to develop, build, run, and package your first microservice
    powered by Java EE 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你将了解为什么Java EE是一个构建轻量级、最前沿微服务的优秀平台。你将学习Java EE 8的不同API的最新进展，重点关注与微服务更相关的API。然后，你将学习如何使用Java
    EE 8开发、构建、运行和打包你的第一个微服务。
- en: 'This chapter includes the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下部分：
- en: Why is Java EE a good platform for microservices?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Java EE是微服务的良好平台？
- en: What's new in Java EE 8?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE 8的新特性是什么？
- en: Getting started with Java EE 8 microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Java EE 8微服务
- en: Containerizing Java EE 8 microservices using Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器化Java EE 8微服务
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You need basic programming skills and some Java knowledge. Along with that,
    you need a computer with a modern operating system, such as Windows 10, macOS,
    or Linux. We'll be using Maven 3.5 as our build tool and Payara Server as our
    application server. For the Java 8 application server, you need Docker for Windows,
    Mac or Linux, an IDE with Java EE 8 support, such as IntelliJ, and a REST client,
    such as Postman or SoapUI.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要基本的编程技能和一些Java知识。除此之外，你还需要一台装有现代操作系统的计算机，例如Windows 10、macOS或Linux。我们将使用Maven
    3.5作为我们的构建工具，并使用Payara Server作为我们的应用服务器。对于Java 8应用服务器，你需要Docker for Windows、Mac或Linux，一个支持Java
    EE 8的IDE，例如IntelliJ，以及一个REST客户端，例如Postman或SoapUI。
- en: Why is Java EE a good platform for microservices?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Java EE是微服务的良好平台？
- en: 'Well, this is the question, why? And the short answer is simple: because Java
    EE 8 is the most lightweight enterprise framework currently out there. Let me
    give you a few more details. First up, Java EE is an industry standard. It''s
    been developed by a vendor-neutral committee and there is widespread knowledge
    out there because Java EE has been available for a couple of years already. Java
    EE consists of several specifications, and these specifications have very tight
    integration. Also, Java EE applies a convention of a configuration programming
    model, which means that you don''t need cumbersome XML descriptors anymore; just
    throw in a couple of annotations and you''re done. For most of the services you''re
    going to develop, you will not need any external dependencies, and this leads
    to thin deployment artifacts. And finally, you have the availability of modern
    application servers that suit the cloud era.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是问题所在，为什么？简短的答案是简单的：因为Java EE 8是目前最轻量级的企业框架。让我给你提供一些更多细节。首先，Java EE是一个行业标准。它由一个供应商中立的委员会开发，由于Java
    EE已经存在几年了，所以广泛的知识已经存在。Java EE由几个规范组成，这些规范有非常紧密的集成。此外，Java EE采用了一种约定配置编程模型，这意味着你不再需要繁琐的XML描述符；只需添加几个注解即可完成。对于你将要开发的大多数服务，你将不需要任何外部依赖项，这导致部署工件很薄。最后，你还有现代应用服务器的可用性，这些服务器适合云时代。
- en: Java EE version history
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE版本历史
- en: 'If you have a look at the Java EE version history, which you can find at [https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition](https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition),
    you''ll see we''ve come a long way since J2EE 1.2 was first released on December
    12, 1999\. If you look on the far-right side in the following diagram, you can
    see Java EE 8 was released on September 21, 2017, which means we have 18 years
    of experience and 18 years of community-built knowledge. Therefore it''s definitely
    a very mature and stable API that''s been continually improved:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Java EE版本历史，你可以在[https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition](https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition)找到它，你会发现自从1999年12月12日J2EE
    1.2首次发布以来，我们已经走了很长的路。如果你查看以下图表的右侧，你可以看到Java EE 8于2017年9月21日发布，这意味着我们有18年的经验和18年的社区构建的知识。因此，它肯定是一个非常成熟且稳定的API，一直在持续改进：
- en: '![](img/214aa66c-f49b-4dd4-bfdd-9c8c99f7dd83.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/214aa66c-f49b-4dd4-bfdd-9c8c99f7dd83.png)'
- en: Java EE version history
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE版本历史
- en: Overview of Java EE 8
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 8概述
- en: 'In the following diagram, you can see an overview of Java EE 8 in its current
    state, you have loads of APIs here that you can program against, and it should
    meet most of the needs of any enterprise''s web-service development. You''ve got
    JPA for persistence, JMS for messaging, good JAX-WS for web services in structure,
    JAX-RS for REST services, and many more APIs you can use for your modern enterprise''s
    application development:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以查看当前状态的 Java EE 8 概览，这里有大量的 API 可以编程使用，应该能满足任何企业级 Web 服务开发的绝大多数需求。您有
    JPA 用于持久化，JMS 用于消息传递，结构良好的 JAX-WS 用于 Web 服务，JAX-RS 用于 REST 服务，以及许多其他可用于您现代企业级应用开发的
    API：
- en: '![](img/c37711d0-1ac4-47bd-bcd9-97c41e463bd2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c37711d0-1ac4-47bd-bcd9-97c41e463bd2.png)'
- en: Overview of Java EE 8
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8 概述
- en: 'And all you need is the following code, which is the only dependency required;
    this is the Maven dependency for the Java EE 8 API and leads to no external dependencies.
    All you need is Java EE 8 and Java 8; this results in very thin artifacts which
    speeds up your daily development and your deployment cycles, and because you have
    those thin WAR files, this is very Docker-friendly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您所需的所有代码如下，这是唯一的依赖项；这是 Java EE 8 API 的 Maven 依赖项，并且没有外部依赖项。您只需要 Java EE 8 和
    Java 8；这导致生成的工件非常薄，从而加快了您的日常开发和部署周期，并且因为您有这些薄的 WAR 文件，这使得它非常适合 Docker：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now there are people out there who say that Java EE 8, especially the application
    service, should not go in a Docker container, but those heavy times are over;
    modern application servers are really lightweight, have a look at Payara server
    or WildFly Swarm, or maybe Open Liberty or Apache TomEE, along with the various
    other application servers. These servers are very lightweight and are definitely
    suitable to be run in a Docker container. I hope by now you're convinced that
    Java EE 8 is indeed the most lightweight enterprise framework currently available.
    In the next section, we're going to have a look what's new in Java EE 8.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有些人说 Java EE 8，特别是应用服务，不应该放入 Docker 容器中，但那些沉重的时代已经过去了；现代应用服务器非常轻量级，看看 Payara
    服务器或 WildFly Swarm，或者可能是 Open Liberty 或 Apache TomEE，以及其他各种应用服务器。这些服务器非常轻量级，并且肯定适合在
    Docker 容器中运行。我希望到现在您已经相信 Java EE 8 确实是目前最轻量级的企业级框架。在下一节中，我们将查看 Java EE 8 的新特性。
- en: What's new in Java EE 8?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 8 的新特性是什么？
- en: In this section, we're going to take a look at the different APIs of Java EE
    8 and the latest advances, with a focus on the more microservice-relevant APIs.
    We're going to look at JSR 370, which is JAX-RS 2.1; JSR 367, which is the JSON
    Binding; and also JSR 374, which is the Java API for JSON Processing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Java EE 8 的不同 API 和最新进展，重点关注与微服务相关的 API。我们将查看 JSR 370，即 JAX-RS 2.1；JSR
    367，即 JSON 绑定；以及 JSR 374，即 JSON 处理的 Java API。
- en: We saw the different APIs in Java EE 8 in the *Overview of Java EE 8* section.
    The ones in blue are the ones that have been added or revamped. We see that CDI
    is been bumped to version 2.0, mainly focusing on asynchronous events, and the
    Servlet API has been bumped to version 4.0, adding HTTP2 support. JSF 2.3, which
    is an API to build server-side UIs, the old JSF bean-managed model, has been removed
    and it's fully integrated with CDI. On the right-hand side of the figure in the
    previous section, you see the Bean Validation API, which has been bumped to version
    2.0\. It's tightly integrated with CDI and has been revamped to fully support
    Java 8 features such as streams and lambdas. There's also a totally new Security
    API for cloud security and past security in adding standardized authorization,
    authentication mechanisms, and APIs. Here, we want to focus on JAX-RS 2.1, JSON-P
    1.1, and JSON-B 1.0.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“Java EE 8 概述”部分看到了 Java EE 8 中的不同 API。蓝色的是新增或改进的 API。我们看到 CDI 已升级到 2.0 版本，主要关注异步事件，Servlet
    API 已升级到 4.0 版本，增加了 HTTP2 支持。JSF 2.3，这是一个用于构建服务器端 UI 的 API，旧的 JSF 实例管理模型已被移除，并且已完全集成到
    CDI 中。在上一个章节的图例右侧，您可以看到 Bean Validation API，它已升级到 2.0 版本。它与 CDI 紧密集成，并已重新设计以完全支持
    Java 8 特性，如流和 lambda 表达式。还有一个全新的安全 API 用于云安全和过去的安全，增加了标准化的授权、认证机制和 API。在这里，我们想关注
    JAX-RS 2.1、JSON-P 1.1 和 JSON-B 1.0。
- en: Let's get started with JAX-RS 2.1\. First, it improved the integration with
    CDI, so all your resource beans are properly CDI-managed. It's also been tightly
    integrated with JSON-B for JSON marshalling and JSON-P for JSON Processing. Also, server-sent
    events have been added to implement push notifications. They support non-blocking
    I/O and all the providers, such as filters and interceptors for JAX-RS. There's
    also been an improved JAX-RS, which is a synchronous client API supporting a completion
    stage. If you have a look at the Java API for JSON Processing, it's been updated
    to version 1.1 to support JSON Pointer and JSON Patch. It allows you to edit and
    transform operations for your JSON object model, and the API has been updated
    to work with Java SE 8 features, such as lambdas and streams.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用JAX-RS 2.1。首先，它改善了与CDI的集成，因此所有的资源bean都得到了适当的CDI管理。它还与JSON-B紧密集成，用于JSON序列化，以及与JSON-P集成，用于JSON处理。此外，还添加了服务器端事件以实现推送通知。它们支持非阻塞I/O，以及所有提供者，例如JAX-RS的过滤器拦截器。还有一个改进的JAX-RS，它是一个支持完成阶段的同步客户端API。如果您查看Java
    API for JSON Processing，它已更新到版本1.1以支持JSON Pointer和JSON Patch。它允许您编辑和转换您的JSON对象模型中的操作，并且API已更新以与Java
    SE 8功能一起工作，例如lambda和流。
- en: The new kid on the block is JSON-B, the JSON Binding 1.0 API. It's the new standard
    way to convert JSON into Java objects and vice-versa. For a long time, we've had
    JSON-B to do the same for XML, and JSON-B is the API to do that for JSON. JSON-B
    leverages JSON-P and provides a conversion layer above it. It provides a default
    mapping algorithm for converting existing Java classes to JSON. The mapping is
    highly customizable through the use of Java annotations, and you can plug in different
    JSON-B runtimes to convert Java objects to and from JSON, such as Jackson. Those
    are the most relevant Java EE 8 APIs with respect to web-service development.
    In the next section, we're getting started with Java EE 8 microservices development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴的JSON-B，即JSON绑定1.0 API，是转换JSON到Java对象以及反向转换的新标准方法。长期以来，我们已有JSON-B来执行同样的XML转换，而JSON-B就是用于JSON转换的API。JSON-B利用JSON-P并提供在其之上的转换层。它为将现有的Java类转换为JSON提供了默认的映射算法。通过使用Java注解，映射可以高度自定义，并且你可以插入不同的JSON-B运行时来将Java对象转换为JSON以及从JSON转换回来，例如Jackson。这些都是与Java
    EE 8相关的最相关的API，尤其是在开发Web服务方面。在下一节中，我们将开始学习Java EE 8微服务开发。
- en: Getting started with Java EE 8 microservices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Java EE 8微服务
- en: 'In this section, we''re going to take a look at the following things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看以下内容：
- en: How to develop, build, and run your first Java-EE-8-powered microservice
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开发、构建和运行您的第一个Java-EE-8驱动的微服务
- en: Required Java EE 8 dependencies for basic web-service development
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Web服务开发所需的Java EE 8依赖项
- en: Basic components of any JAX-RS-based web service
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何基于JAX-RS的Web服务的基本组件
- en: Deployment of a thin WAR artifact using Payara Server 5
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Payara Server 5部署瘦WAR工件
- en: 'Let''s get started and dive into the code. I''ve prepared my IDE and a raw
    skeleton Maven project. What you see here is a very basic POM file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并深入代码。我已经准备好了我的IDE和一个原始的Maven项目框架。您在这里看到的是一个非常基础的POM文件：
- en: '![](img/35f6a339-c833-4dd2-95f1-0f576e24fa48.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35f6a339-c833-4dd2-95f1-0f576e24fa48.png)'
- en: 'There''s one thing missing though; first, we need to define the required dependency
    for the Java EE 8 API. Let''s do that:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些事情需要补充；首先，我们需要定义Java EE 8 API所需的依赖项。让我们来做这件事：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We specify `version` as `8.0`. We should also define the proper `scope` for
    this, which is `provided` in this case because the Java EE 8 API will later be
    provided by our application server and we are done with our dependency. Next,
    we should add a `beans.xml` descriptor to the `WEB-INF` directory of our web application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`version`为`8.0`。我们还应该为这个定义适当的`scope`，在这种情况下是`provided`，因为Java EE 8 API将在以后由我们的应用服务器提供，并且我们已经完成了我们的依赖项。接下来，我们应该将一个`beans.xml`描述符添加到我们的Web应用的`WEB-INF`目录中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We do this and we''re done, what''s next? Well, next we should bootstrap our
    JAX-RS application. Now let''s create a class called `JAXRSConfiguration`. The
    name really doesn''t matter. What''s important is that this class extends from
    the `Application` base class. Bear in mind the `javax.ws.rs.core` package while
    selecting the `Application`. It''s also important that you specify the `@ApplicationPath`
    annotation. This will be the base path our REST API will be accessible under,
    thus we call that `"api"`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做就完成了，接下来是什么？嗯，接下来我们应该启动我们的 JAX-RS 应用程序。现在让我们创建一个名为 `JAXRSConfiguration`
    的类。名字实际上并不重要。重要的是这个类从 `Application` 基类扩展。记住在选择 `Application` 时 `javax.ws.rs.core`
    包。同样重要的是您需要指定 `@ApplicationPath` 注解。这将是我们 REST API 可以访问的基础路径，因此我们称之为 `"api"`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we''ve bootstrapped JAX-RS, what''s missing is a proper REST resource.
    Let''s create a class called `HelloWorldResouce`. We used the `@Path` annotation,
    which will be the path this resource will be accessible under. We''ll call that
    `"hello"`. Next up, we create a method that will produce the proper response once
    called, we call that `helloWorld`. We use the proper `Response` here. We annotate
    this using the `@GET` annotation because we will be issuing `GET` requests later
    on, and we''ll say that it produces `MediaType.APPLICATION_JSON`. Then we return
    `Response.ok`, where `ok` is HTTP status 200 of a response when we call the `build`.
    So, what should be used as the response? We''ll be using `Map<String, String>`
    as our response and will return `singletonMap` with the `message` key and the
    `Hello World` value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了 JAX-RS，缺少的就是一个合适的 REST 资源。让我们创建一个名为 `HelloWorldResouce` 的类。我们使用了 `@Path`
    注解，这将是我们可以在其下访问的资源路径。我们将称之为 `"hello"`。接下来，我们创建一个方法，一旦调用，将产生适当的响应，我们称之为 `helloWorld`。我们在这里使用适当的
    `Response`。我们使用 `@GET` 注解来注释它，因为我们稍后将会发出 `GET` 请求，并且我们说它产生 `MediaType.APPLICATION_JSON`。然后我们返回
    `Response.ok`，其中 `ok` 是当我们调用 `build` 时的 HTTP 响应状态 200。那么应该使用什么作为响应呢？我们将使用 `Map<String,
    String>` 作为我们的响应，并返回带有 `message` 键和 `Hello World` 值的 `singletonMap`：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We should already have a very simple working microservice. Now let's deploy
    this onto our Payara Server 5 and run it. We're going to deploy the WAR file,
    it's been built; you can see that it's already been deployed and the deployment
    took 5.1 milliseconds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经有一个非常简单的运行中的微服务。现在让我们将其部署到我们的 Payara Server 5 并运行它。我们将部署 WAR 文件，它已经被构建；您可以看到它已经被部署，部署耗时
    5.1 毫秒。
- en: 'Let''s check our browser. You should see the "Hello World." message, as shown
    in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的浏览器。您应该看到 "Hello World." 消息，如下面的截图所示：
- en: '![](img/c3f47211-7ef1-4113-86a0-1d927c6c4475.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3f47211-7ef1-4113-86a0-1d927c6c4475.png)'
- en: 'If you don''t trust me, let''s just modify the value here to `"Building Web
    Services with Java EE 8."` value. We deploy this once more and update our artifact.
    The new version has been deployed. Let''s go back to our browser to check that
    we have the proper response message, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不相信我，让我们只需将这里的值修改为 `"Building Web Services with Java EE 8."`。我们再次部署并更新我们的工件。新版本已经部署。让我们回到我们的浏览器中检查我们是否得到了适当的响应消息，如下面的截图所示：
- en: '![](img/9868e14b-2e6d-413e-80ed-ace1bb19f5c8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9868e14b-2e6d-413e-80ed-ace1bb19f5c8.png)'
- en: That's all for this section; in the next section, I'm going to show you how
    to containerize your Java EE 8 microservice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容到此结束；在下一节中，我将向您展示如何将您的 Java EE 8 微服务容器化。
- en: Containerizing Java EE 8 microservices
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化 Java EE 8 微服务
- en: In this section, we're going to take a look at how to containerize and run our
    Java EE 8 microservice using Docker. We'll learn how to write a basic Docker file,
    and we'll also see how to build and run the Docker image using Payara Server full
    and Payara Server micro edition. Let's open our IDE again to the microservice
    project from the previous section; all that's missing here is `Dockerfile`, therefore
    let's create one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 Docker 容器化和运行我们的 Java EE 8 微服务。我们将学习如何编写基本的 Dockerfile，我们还将看到如何使用
    Payara Server 完整版和 Payara Server 微版构建和运行 Docker 镜像。让我们再次打开我们的 IDE，回到上一节中的微服务项目；这里缺少的是
    `Dockerfile`，因此让我们创建一个。
- en: 'Now the question is: what base image should we use? We have two basic options
    when using Payara: you can either use the server-full image or the Payara micro
    edition. Let''s use the full version of Payara first. `Dockerfile` will be as
    follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：我们应该使用什么基础镜像？在使用 Payara 时，我们有两个基本选项：您可以使用完整的服务器镜像或 Payara 微版。让我们首先使用
    Payara 的完整版本。`Dockerfile` 将如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding `Dockerfile`, we mentioned that we''re using `payara/server-full`.
    We need to use the correct version of it, in our case this is version `5-SNAPSHOT`,
    and then copy the `hello-javaee8.war` file of our microservice into the correct
    location of the produced image. We need to issue a `COPY` command from `target/hello-javaee8.war`
    and then copy this into the deployment directory, that should be it, let''s see
    whether is worked. We open a console, making sure that we''re in the right directory.
    We check that everything is packaged nicely, and to do this we call `mvn package`
    just to make sure the WAR file is in the correct state. If it is, you''ll see
    my things running while compiling, an absence of tests, and the WAR file is up
    to date:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Dockerfile` 中，我们提到我们正在使用 `payara/server-full`。我们需要使用正确的版本，在我们的例子中这是版本
    `5-SNAPSHOT`，然后将我们的微服务的 `hello-javaee8.war` 文件复制到生成的镜像的正确位置。我们需要从 `target/hello-javaee8.war`
    发出 `COPY` 命令，然后将其复制到部署目录，应该就是这样，让我们看看是否成功。我们打开控制台，确保我们处于正确的目录。我们检查一切是否打包得很好，为此我们调用
    `mvn package` 以确保 WAR 文件处于正确的状态。如果是这样，你将看到我的东西在编译时运行，没有测试，WAR 文件是最新的：
- en: '![](img/4ba70a79-9a24-4690-9dc8-634f29b29dc6.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ba70a79-9a24-4690-9dc8-634f29b29dc6.png)'
- en: 'We build Docker using `-t`, which specifies the tag we want to use, we do that
    by calling `hello-javaee8` and we give it a version number, `1.0`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-t` 构建 Docker，它指定了我们想要使用的标签，我们通过调用 `hello-javaee8` 并给它一个版本号，`1.0` 来做这件事：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the following command, let''s see whether our server starts up:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，让我们看看服务器是否启动：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We mapped port `8080` from the container onto our Docker host. You''ll see
    that the Payara GlassFish Server is starting up in the console—it should only
    take a couple of seconds—and in a second we should see that our application is
    deployed. To check that we can reach our web service hit the IP address as shown
    in the following screenshot. This is the IP address of my Docker host port `8080`
    and we can access our service, which was successful:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将容器的端口 `8080` 映射到我们的 Docker 主机。你将看到 Payara GlassFish 服务器正在控制台中启动——这应该只需要几秒钟——然后我们应该看到我们的应用程序已部署。为了检查我们可以访问我们的
    Web 服务，点击以下截图所示的 IP 地址。这是我的 Docker 主机端口 `8080` 的 IP 地址，我们可以访问我们的服务，这是成功的：
- en: '![](img/be19bd06-103e-4496-9257-9fc59c736297.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be19bd06-103e-4496-9257-9fc59c736297.png)'
- en: 'Now let''s stop that and delete the contents of this `Dockerfile`. I want to
    show you how to use the Payara micro edition instead. First, we need to change `FROM`.
    To do this we use a different base tag for this image (`payara/micro:5-SNAPSHOT`),
    and then copy the `hello-javaee8.war` file into the proper location for this base
    image. Next we copy our WAR file in the `target` directory and we call it to our
    `/opt/payara/deployments`. This is the default `deployments` directory for the
    micro edition base container. The `Dockerfile` should look as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们停止它并删除此 `Dockerfile` 的内容。我想向你展示如何使用 Payara micro 版本。首先，我们需要更改 `FROM`。为此，我们使用这个镜像的不同基础标签（`payara/micro:5-SNAPSHOT`），然后将
    `hello-javaee8.war` 文件复制到这个基础镜像的正确位置。接下来，我们将我们的 WAR 文件复制到 `target` 目录，并将其放置到 `/opt/payara/deployments`。这是
    micro 版本基础容器的默认 `deployments` 目录。`Dockerfile` 应该如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Switch back to the console and issue the Docker build command again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回控制台并再次运行 Docker 构建命令：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fire up the container again:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动容器：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see that the output in the console changes and we''re using the Payara
    micro runtime this time. This takes a couple of seconds to spin up our web service,
    and in a few seconds it should be done. We can see that our `REST Endpoints` are
    available. Let''s check again. We go to our management console and we can see
    that we have a running container. Try calling the web service from the browser,
    as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到控制台输出已改变，这次我们使用的是 Payara micro 运行时。这需要几秒钟来启动我们的 Web 服务，几秒钟后应该就完成了。我们可以看到我们的
    `REST 端点` 可用。让我们再次检查。我们进入我们的管理控制台，可以看到我们有一个正在运行的容器。尝试从浏览器调用 Web 服务，如下面的截图所示：
- en: '![](img/e9b000fe-aafe-4432-94b8-df51a594af84.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9b000fe-aafe-4432-94b8-df51a594af84.png)'
- en: We can see that everything's working fine and we have a running Dockerized version
    of our web service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一切运行正常，并且我们已经有一个正在运行的 Docker 化的 Web 服务版本。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about Java EE and the fact that it's a great platform
    for building modern and lightweight web services. We had a look at the different
    APIs of Java EE 8 and the latest advances, with a focus on the more microservice-relevant
    APIs, such as JAX-RS, JSON-B, and JSON-P. We then developed, built, and ran our
    Java-EE-8-powered microservice and deployed it locally to the Payara Server. In
    the final section, we containerized and ran our Java EE 8 microservice using Docker.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Java EE以及它是一个构建现代和轻量级Web服务的优秀平台的事实。我们查看了一下Java EE 8的不同API以及最新的进展，重点关注与微服务更相关的API，例如JAX-RS、JSON-B和JSON-P。然后我们开发了、构建并运行了我们的Java
    EE 8微服务，并将其本地部署到Payara服务器上。在最后一节中，我们使用Docker容器化和运行了我们的Java EE 8微服务。
- en: In the next chapter, we'll do a deep dive into building synchronous web services
    and clients using the relevant JAX-RS APIs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用相关的JAX-RS API构建同步Web服务和客户端。
