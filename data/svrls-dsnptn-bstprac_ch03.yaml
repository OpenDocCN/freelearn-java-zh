- en: A Three-Tier Web Application Pattern with GraphQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于GraphQL的三层Web应用程序模式
- en: In [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A* *Three**-Tier Web Application
    Using REST*,  we walked through the entire process of authoring a REST API on
    top of a serverless system with accompanying hosted services for the data and
    presentation layers. Our serverless logic layer was implemented with AWS Lambda
    and API Gateway, which provide many advantages regarding deployment, iteration
    speed, and scalability. REST APIs are well understood among the web development
    community and a safe choice when building a new web-based API. However, emerging
    tools and protocols are taking shape and providing us with alternatives to REST.
    GraphQL is arguably one of the most popular alternatives to REST APIs lately,
    evidenced by AWS and other platforms releasing hosted GraphQL services. You don't
    need to look very deep to find the uptick in GraphQL's popularity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](svrls-dsnptn-bstprac_ch02.html)“使用REST的三层Web应用程序”，我们介绍了在无服务器系统上编写REST
    API的整个过程，包括数据层和表示层的配套托管服务。我们的无服务器逻辑层使用AWS Lambda和API Gateway实现，这为部署、迭代速度和可扩展性提供了许多优势。REST
    API在Web开发社区中得到了很好的理解，并且在构建新的基于Web的API时是一个安全的选择。然而，新兴的工具和协议正在形成，为我们提供了REST的替代方案。GraphQL可以说是最近最流行的REST
    API替代方案之一，这从AWS和其他平台发布托管GraphQL服务中可以看出。你不需要深入挖掘就能发现GraphQL的受欢迎程度正在上升。
- en: In this chapter, we'll walk through the process of updating the three-tier example
    API to use a GraphQL interface rather than a REST interface. These changes will
    focus on only the logic layer, as the data layer will not change at all. We will
    learn how to set up and author a single GraphQL serverless endpoint as opposed
    to multiple endpoints as in the REST-based design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍将三层示例API更新为使用GraphQL接口而不是REST接口的过程。这些更改将仅关注逻辑层，因为数据层将完全不变。我们将学习如何设置和编写一个单一的GraphQL无服务器端点，而不是像基于REST的设计那样多个端点。
- en: 'In this chapter, we will look into and discuss the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨和讨论以下内容：
- en: How to author a GraphQL API using AWS Lambda and Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 AWS Lambda 和 Python 编写 GraphQL API
- en: The differences in function layout between GraphQL and REST serverless applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 与 REST 无服务器应用程序之间功能布局的差异
- en: How to query our GraphQL endpoint as a client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何作为客户端查询我们的 GraphQL 端点
- en: Introduction to GraphQL
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL 简介
- en: REST has been around for nearly 20 years and remains a popular choice for web
    APIs, both internal and public. As popular as REST is, it does have its flaws
    and is more of an idea as opposed to a specification. Anyone who has designed
    or worked with third-party APIs knows that there is often little overlap in implementation
    and design choices from one API to another. At best, this makes using or designing
    REST APIs challenging. When approaching a new REST API, there is always the work
    of exploring the various API endpoints, hunting for the data you'll need, understanding
    the different resource types and how they relate, and so on. Of course, when working
    with a new API, there will always be some level of investment and discovery to
    learn the data with which you'll be working.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: REST 已经存在了近20年，并且仍然是内部和公共Web API的一个流行选择。尽管REST如此受欢迎，但它确实有其缺陷，更多的是一个理念，而不是一个规范。任何设计或与第三方API合作过的人都知道，从一种API到另一种API在实现和设计选择上往往重叠很少。这最多使得使用或设计REST
    API具有挑战性。在接触新的REST API时，总是需要探索各种API端点，寻找所需的数据，理解不同的资源类型及其相互关系，等等。当然，当与新的API一起工作时，总会有一段时间的投资和发现，以学习将要工作的数据。
- en: Facebook designed GraphQL internally in 2012 and released it to the public in
    2015\. GraphQL is the new kid on the block and is picking up substantial traction
    as an alternative to REST. While the end goal is the same as REST (to get data
    from a client to the server), the implementation and mechanisms for doing so are
    drastically different. Perhaps most different from REST, GraphQL is an actual
    specification that client and server implementations can reference and agree on.
    In contrast, REST is a set of principles and ideas that are subject to interpretation.
    GraphQL defines a new query language and allows clients to ask for the data they
    need consistently. With REST, the addition, removal, or permutation of return
    values usually requires server-side code changes. With GraphQL, clients are able
    to define the structure of the return payload in an ad hoc fashion on a query-by-query
    basis. For clients, the boundaries in a REST API are the endpoints provided at
    a given point in time and their return values, whereas the limits in a GraphQL
    API are the full domain of the API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook于2012年在内部设计了GraphQL，并于2015年向公众发布。GraphQL是新生事物，作为REST的替代品正在获得大量关注。虽然最终目标与REST相同（从客户端获取数据到服务器），但实现和机制却截然不同。也许与REST最不同的是，GraphQL是一个客户端和服务器实现可以参考并达成一致的规范。相比之下，REST是一套原则和思想，容易受到解释的影响。GraphQL定义了一种新的查询语言，并允许客户端一致地请求所需的数据。在REST中，返回值的添加、删除或排列通常需要服务器端代码更改。在GraphQL中，客户端能够根据查询逐个定义返回负载的结构。对于客户端来说，REST
    API的边界是在特定时间点提供的端点和它们的返回值，而在GraphQL API中的限制是API的全域。
- en: GraphQL is a big and complex topic. It's still relatively new, especially when
    comparing it to REST and other web technologies. Because GraphQL digests so many
    of the complexities of a web API, any conversation about GraphQL quickly becomes
    a discussion about the intricacies of GraphQL itself. In this chapter, I attempt
    to give just the right amount of detail on GraphQL to demonstrate the underlying
    serverless pattern. If you find yourself wanting a deeper understanding of GraphQL
    during reading or at the end of this chapter, I encourage you to read the many
    articles and blog posts that exist on this topic. The following introduction from
    Facebook is a great place to start: [https://reactjs.org/blog/2015/05/01/graphql-introduction.html](https://reactjs.org/blog/2015/05/01/graphql-introduction.html).[](https://reactjs.org/blog/2015/05/01/graphql-introduction.html)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一个庞大且复杂的话题。它相对较新，尤其是与REST和其他Web技术相比。由于GraphQL消化了Web API的许多复杂性，关于GraphQL的任何对话很快就会变成关于GraphQL本身的细节讨论。在本章中，我试图提供足够的GraphQL细节来展示底层无服务器模式。如果你在阅读过程中或本章结束时想要更深入地了解GraphQL，我鼓励你阅读许多关于这个主题的文章和博客文章。以下是从Facebook开始的极好介绍：[https://reactjs.org/blog/2015/05/01/graphql-introduction.html](https://reactjs.org/blog/2015/05/01/graphql-introduction.html)。[https://reactjs.org/blog/2015/05/01/graphql-introduction.html](https://reactjs.org/blog/2015/05/01/graphql-introduction.html)
- en: In short, clients working with a GraphQL API can fetch precisely the data they
    need, no more, no less. Over-fetching (getting more data than the client needs)
    and under-fetching (needing to make multiple API calls to get the data the client
    needs) issues disappear when working with GraphQL, which arguably was a significant
    driver in Facebook's design of GraphQL and provides many benefits for clients.
    Another exciting and powerful attribute of GraphQL is that it isn't an HTTP-only
    specification. While HTTP is currently the primary use case, GraphQL isn't tied
    directly to HTTP and may be used with other transport protocols.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，与GraphQL API一起工作的客户端可以获取他们确切需要的数据，不多也不少。当使用GraphQL时，过度获取（获取比客户端需要的更多数据）和不足获取（需要多次API调用才能获取客户端需要的数据）的问题消失了，这在Facebook设计GraphQL时是一个重要的推动因素，并为客户端提供了许多好处。GraphQL另一个令人兴奋且强大的特性是它不是一个仅限HTTP的规范。虽然HTTP目前是主要用例，但GraphQL并没有直接绑定到HTTP，并且可以与其他传输协议一起使用。
- en: System architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统架构
- en: 'Our system architecture, at a high level, will be the same as in the REST API
    version of our sample application. Requests from the web will hit the CloudFront
    CDN, which is backed by S3\. Our JavaScript code from the served-up HTML files
    will query the serverless API, which itself will communicate with the RDS-backed
    data layer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统架构在高级别上将与我们的示例应用的REST API版本相同。来自网络的请求将击中由S3支持的CloudFront CDN，我们的JavaScript代码将从提供的HTML文件中查询无服务器API，该API本身将与由RDS支持的数据层进行通信：
- en: '![](img/7738859c-3d36-405c-8272-da1f262788bd.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7738859c-3d36-405c-8272-da1f262788bd.jpg)'
- en: 'Thinking through this application from a top-down approach, the steps in fetching
    data will be the same regardless of how the logic layer is implemented:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从自上而下的角度思考这个应用程序，获取数据的步骤将取决于逻辑层的实现方式：
- en: End-user requests a website
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户请求网站
- en: Static assets are served to the user from CloudFront and S3
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态资源通过CloudFront和S3提供给用户
- en: Static assets request data via logic layer/web APIs (GraphQL in this case)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态资源通过逻辑层/网络API（在这种情况下是GraphQL）请求数据
- en: Logic layer fetches/writes data from/to Postgres database in the data layer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑层从数据层中的Postgres数据库获取/写入数据
- en: Moving our example web application from a REST design to GraphQL means focusing
    on the **logic layer**, as the presentation and data layers won't change much,
    if at all. Of course, any changes to our API mean that our presentation layer
    (that is, the client) will need to change; however, as that is not our primary
    area of focus, we won't delve too deeply into the client-side changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的示例Web应用程序从REST设计迁移到GraphQL意味着关注**逻辑层**，因为表示层和数据层不会改变太多，如果有的话。当然，对我们API的任何更改都意味着我们的表示层（即客户端）需要更改；然而，由于这并不是我们的主要关注点，我们不会深入探讨客户端方面的更改。
- en: 'You can find all of the code in this chapter in the following repository:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节的以下仓库中找到所有代码：
- en: '[https://github.com/brianz/serverless-design-patterns/tree/master/ch3](https://github.com/brianz/serverless-design-patterns/tree/master/ch3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/brianz/serverless-design-patterns/tree/master/ch3](https://github.com/brianz/serverless-design-patterns/tree/master/ch3)'
- en: Logic layer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑层
- en: GraphQL simplifies life for clients because there is a single HTTP endpoint.
    In some ways, this makes the pattern for a serverless GraphQL API extremely simple
    and in some ways quite dull.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL简化了客户端的生活，因为它有一个单一的HTTP端点。在某种程度上，这使得无服务器GraphQL API的模式极其简单，在某种程度上又相当单调。
- en: If we were starting this GraphQL web application from scratch, there would be
    plenty of decisions to make and material to cover to make our application code
    modular, easy to test, and well designed. Since we're porting the example REST
    web application, we have already implemented the vast majority of the needed functionality
    and software layers. These sections may seem terser than expected, especially
    if you have skipped [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A Three-Tier
    Web Application using REST*. Any gaps in code organization or layout, configuration
    strategy, deployments, and so on can be filled by reviewing [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A **Three-Tier Web Application using REST*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从零开始构建这个GraphQL Web应用程序，将会有很多决策要做，有很多材料要覆盖，以使我们的应用程序代码模块化、易于测试和设计良好。由于我们正在移植示例REST
    Web应用程序，我们已经实现了大部分所需的功能和软件层。这些部分可能看起来比预期的要简短，尤其是如果你跳过了[第2章](svrls-dsnptn-bstprac_ch02.html)，*使用REST的分层Web应用程序*。任何代码组织或布局、配置策略、部署等方面的空白都可以通过回顾[第2章](svrls-dsnptn-bstprac_ch02.html)，*使用REST的分层Web应用程序*来填补。
- en: Organization of the Lambda functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数的组织
- en: 'REST APIs are built around resources that each own their own URI, in part to
    give clients a well-known or predictable way to interact. GraphQL takes a different
    approach. Note that the *QL* in GraphQL stands for *query language*. Data-fetching
    logic is moved into the query language itself, rather than being distributed among
    different API endpoints as in the case of REST. Clients no longer need to work
    through the process of the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是围绕资源构建的，每个资源都有自己的URI，部分原因是为了给客户端提供一个已知或可预测的交互方式。GraphQL采取了不同的方法。请注意，GraphQL中的*QL*代表*查询语言*。数据获取逻辑被移动到查询语言本身，而不是像REST那样分散在不同的API端点。客户端不再需要经历以下过程：
- en: Determining what resource they need and where it lives on the list of URLs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定他们需要什么资源以及它在URL列表中的位置
- en: Looking up documentation to determine the input parameters and output data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文档以确定输入参数和输出数据
- en: If applicable, reading the documentation on pagination or limiting of returned
    data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，阅读有关分页或返回数据限制的文档
- en: A formal specification currently found at [http://facebook.github.io/graphql/October2016/](http://facebook.github.io/graphql/October2016/)
    defines GraphQL in absolute terms. As with any specification, any framework or
    library that aims at providing GraphQL functionality to users must abide by this
    formal contract. Both clients and servers work within the bounds of this specification
    so that there is a single way to handle common bits of functionality. To keep
    these points in context, the logic for this functionality is implemented in a
    single endpoint and hence Lambda function, regardless of the resource or any other
    data being requested.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当前可在[http://facebook.github.io/graphql/October2016/](http://facebook.github.io/graphql/October2016/)找到的正式规范从绝对角度定义了GraphQL。与任何规范一样，任何旨在向用户提供GraphQL功能的框架或库都必须遵守这一正式合同。客户端和服务器都在这一规范的范围内工作，以确保处理常见功能的方式是统一的。为了保持这些点的上下文，这一功能的逻辑是在单个端点中实现的，因此是Lambda函数，无论请求的资源或任何其他数据。
- en: 'The following diagram shows what the move from a REST API to GraphQL looks
    like regarding supported URLs and backing functions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了从REST API迁移到GraphQL在支持的URL和后端函数方面的样子：
- en: '![](img/fdc3b768-7432-47ac-8f03-d5e3153d9b70.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdc3b768-7432-47ac-8f03-d5e3153d9b70.jpg)'
- en: As we saw in  [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A **Three-Tier Web
    Application using REST*, a REST API in a serverless system is or may be composed
    of a serverless function (AWS Lambda or the like) for one or more API endpoints.
    As the API grows, so too does the number of serverless functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](svrls-dsnptn-bstprac_ch02.html)，*使用REST的**三层Web应用**中看到的那样，在无服务器系统中，REST
    API是由一个或多个API端点的无服务器函数（AWS Lambda或类似）组成的。随着API的增长，无服务器函数的数量也会增加。
- en: GraphQL, on the other hand, contains all of the logic for an entire API, including
    creation, reading, and updating of data. It should be clear from the preceding
    diagram that regardless of how a system changes, there are no changes required
    to the serverless functions backing the GraphQL API. Any changes in business logic
    or application logic are wrapped up in application code, in contrast to requiring changes
    in URL structure and hence serverless functions or layout.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，GraphQL包含了整个API的所有逻辑，包括数据的创建、读取和更新。从前面的图中可以看出，无论系统如何变化，支持GraphQL API的后端无服务器函数都不需要做出任何更改。业务逻辑或应用逻辑的任何更改都封装在应用代码中，而不是需要更改URL结构，从而更改无服务器函数或布局。
- en: For this chapter, we will be working on a single AWS Lambda function and HTTP
    endpoint that will handle all GraphQL requests. Do note, however, that GraphQL
    clients may make requests over both `GET` and `POST`, so our Lambda function will
    be set up to handle both request types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将专注于一个AWS Lambda函数和一个HTTP端点，该端点将处理所有GraphQL请求。请注意，然而，GraphQL客户端可以通过`GET`和`POST`两种方式发出请求，因此我们的Lambda函数将配置为处理这两种请求类型。
- en: You can find more details on serving GraphQL over HTTP in the official documentation
    at [http://graphql.org/learn/serving-over-http/](http://graphql.org/learn/serving-over-http/).[](http://graphql.org/learn/serving-over-http/)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到更多关于通过HTTP提供GraphQL的详细信息，文档地址为[http://graphql.org/learn/serving-over-http/](http://graphql.org/learn/serving-over-http/)。[http://graphql.org/learn/serving-over-http/](http://graphql.org/learn/serving-over-http/)
- en: Organization of the application code
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用代码的组织结构
- en: As noted previously, organizing serverless functions and application code is
    not exactly the same thing. With a GraphQL system, our lives as developers are
    slightly more comfortable since there is only a single endpoint to support.  The
    overall organization of application code isn't changing at all from our REST API.
    The only real changes are that there will be much *less* application code to manage,
    but the overall layout, structure, and routing strategy will not change in any
    way. For details, readers may review [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A **Three-Tier Web Application using REST*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组织无服务器函数和应用代码并不完全相同。在GraphQL系统中，作为开发者的我们生活稍微舒适一些，因为只有一个端点需要支持。我们的应用代码的整体组织结构并没有从REST
    API中改变。唯一真正的变化是，将会有更少的**应用代码**需要管理，但整体布局、结构和路由策略将不会发生任何变化。有关详细信息，读者可以查阅[第2章](svrls-dsnptn-bstprac_ch02.html)，*使用REST的**三层Web应用**。
- en: 'Other parts of our API that will remain constant in the GraphQL implementation
    are the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL实现中保持不变的API的其他部分如下：
- en: Configuration strategy via environment variables
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过环境变量进行配置策略
- en: Overall code structure and layout
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体代码结构和布局
- en: Function layout
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数布局
- en: 'Our GraphQL endpoint will be handled by a single AWS Lambda function, via either
    the `GET` or `POST` HTTP method. For completeness, the diagram of the AWS API
    Gateway request to the AWS Lambda function looks like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GraphQL 端点将由单个 AWS Lambda 函数处理，通过 `GET` 或 `POST` HTTP 方法。为了完整性，AWS API Gateway
    请求到 AWS Lambda 函数的图如下：
- en: '![](img/304a0f02-d5d0-4c95-b8a4-4cfc93ee9171.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/304a0f02-d5d0-4c95-b8a4-4cfc93ee9171.png)'
- en: While it may seem a bit pedantic to review this, I think it's important to stress
    the simplicity of this pattern and the advantages gained by adopting GraphQL.
    Of course, there are always trade-offs, and GraphQL is no different. Since so
    much functionality is pushed down into the logic layers, most of your time will
    likely be spent in application code, ensuring your API provides the same functionality
    as before and learning the details of GraphQL itself. Not being a GraphQL expert
    myself, and because GraphQL isn't the main topic of this book, we won't be covering
    all of the possible scenarios and functionality of a GraphQL API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然审查这一点可能显得有些繁琐，但我认为强调这种模式的简单性和采用 GraphQL 所获得的优点很重要。当然，总是有权衡，GraphQL 也不例外。由于大量功能被推到逻辑层，你大部分的时间可能都会花在应用程序代码上，确保你的
    API 提供与之前相同的功能，并学习 GraphQL 的细节。由于我不是 GraphQL 专家，并且 GraphQL 不是本书的主要主题，我们不会涵盖所有可能的
    GraphQL API 场景和功能。
- en: Presentation layer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示层
- en: In  [Chapter 2](https://cdp.packtpub.com/serverless_design_patterns_and_best_practices/wp-admin/post.php?post=50&action=edit#post_27),
    *A* *Three-Tier Web Application using REST*, our React application was making
    API calls to our REST endpoints. This REST API that we built returns JSON, which
    our frontend code easily digests and feeds into our React code for rendering UI
    elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](https://cdp.packtpub.com/serverless_design_patterns_and_best_practices/wp-admin/post.php?post=50&action=edit#post_27)，*使用
    REST 的三层 Web 应用程序*中，我们的 React 应用程序正在向我们的 REST 端点发起 API 调用。我们构建的这个 REST API 返回
    JSON，我们的前端代码可以轻松消化并将其输入到我们的 React 代码中，用于渲染 UI 元素。
- en: With a change to a GraphQL-based API, our frontend code will need to change
    somewhat drastically for the data-fetching sections. GraphQL behaves very differently
    than REST, and there is no corollary between a REST endpoint, which returns a
    known set of data, and GraphQL. Each GraphQL query is unique in that the client
    is responsible for asking for a specific set of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 API 更改为基于 GraphQL 之后，我们的前端代码在数据获取部分需要做相当大的改变。GraphQL 与 REST 的行为非常不同，REST
    端点（返回已知数据集）与 GraphQL 之间没有对应关系。每个 GraphQL 查询都是独特的，因为客户端负责请求特定的数据集。
- en: We won't review the changes to the frontend code. At the time of writing, popular
    choices for GraphQL for the frontend are Apollo and Relay. Apollo comes out of
    the Meteor Development Group and Facebook is behind Relay. Both are open source
    and popular in the GraphQL community. There are many resources on both topics
    all over the internet and readers are encouraged to learn more on their own. For
    this chapter, we'll interact with our GraphQL backend using an API client.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会回顾前端代码的更改。在撰写本文时，Apollo 和 Relay 是前端 GraphQL 的流行选择。Apollo 来自 Meteor 开发组，而
    Relay 背后有 Facebook。两者都是开源的，在 GraphQL 社区中很受欢迎。互联网上到处都是这两个主题的资源，鼓励读者自行学习更多。对于本章，我们将使用
    API 客户端与我们的 GraphQL 后端进行交互。
- en: Writing the logic layer
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写逻辑层
- en: 'Adding this GraphQL endpoint will consist of the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此 GraphQL 端点将包括以下内容：
- en: Adding a new entry point to handle the new Lambda function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的入口点以处理新的 Lambda 函数
- en: Passing the HTTP payload (which is a GraphQL query or mutation) to a function
    that will execute GraphQL code
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 有效负载（即 GraphQL 查询或突变）传递给一个将执行 GraphQL 代码的函数
- en: Admittedly, GraphQL is new enough that libraries and the ecosystem are not entirely
    polished or rich with documentation, at least in my experience. Still, it's possible
    to make quick progress, and once the basics are solved, GraphQL by its nature
    enables a vast range of functionality.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，GraphQL 还相对较新，库和生态系统在我的经验中还没有完全完善或丰富文档。尽管如此，仍然可以快速取得进展，一旦基础知识解决，GraphQL 本身就允许实现广泛的功能。
- en: Since the coffee cupping example application is implemented using Python, we
    will continue down that path and augment it with some additional libraries for
    GraphQL. At the time of writing, Graphene is the de facto library for working
    with GraphQL from Python. Along with the base library, there are several other
    libraries that make working with various data stores easier. Luckily for us, one
    of the add-on libraries is Graphene-SQLAlchemy, which will work with our own SQLAlchemy
    code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于咖啡杯测示例应用程序是使用Python实现的，我们将继续沿着这条路径前进，并使用一些额外的库来增强GraphQL。在撰写本文时，Graphene是Python中处理GraphQL的事实上的库。除了基本库之外，还有其他几个库可以简化与各种数据存储库的工作。幸运的是，对于我们来说，其中一个附加库是Graphene-SQLAlchemy，它将与我们自己的SQLAlchemy代码一起工作。
- en: You can learn more about Graphene and its related integrations at [http://graphene-python.org](http://graphene-python.org).[](http://graphene-python.org)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://graphene-python.org](http://graphene-python.org)了解更多关于Graphene及其相关集成信息。[http://graphene-python.org](http://graphene-python.org)
- en: Implementing the entry point
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现入口点
- en: 'With the addition of a new Lambda function that will respond to requests at
    the `/graphql` endpoint, we need one new entry in our existing `handler.py` file.
    For consistency with the other handlers in this file, the function will do the
    following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新增的一个Lambda函数，该函数将响应`/graphql`端点的请求，我们需要在我们的现有`handler.py`文件中添加一个新条目。为了与文件中的其他处理程序保持一致性，该函数将执行以下操作：
- en: Extract the HTTP method and payload from the request
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从请求中提取HTTP方法和有效载荷
- en: Hand the HTTP method and payload to another function for processing
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTTP方法和有效载荷传递给另一个函数进行处理
- en: 'Construct and return the final response to API Gateway:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并返回最终的响应给API网关：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There isn't much to do in this function and one can see that the bulk of the
    logic is in the `handle_graphql` function, which we import at the top of the file
    and that lives in `cupping/handlers/graphql.py`. Using this pattern is extremely
    helpful since all of our path setups has already been completed and other standard
    code, such as the `cors` headers, is complete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中没有什么太多的事情要做，可以看到大部分的逻辑都在`handle_graphql`函数中，我们在文件顶部导入了这个函数，它位于`cupping/handlers/graphql.py`。使用这种模式非常有帮助，因为我们的所有路径设置已经完成，其他标准代码，例如`cors`头，也已经完成。
- en: Implementing GraphQL queries
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GraphQL查询
- en: With the boilerplate out of the way, it's time to focus on our actual GraphQL
    implementation. Many software layers that powered the REST API will also power
    the GraphQL API, specifically the model/validation layer and persistence/SQLAlchemy
    layer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除了样板代码之后，现在是时候专注于我们的实际GraphQL实现了。许多为REST API提供动力的软件层也将为GraphQL API提供动力，特别是模型/验证层和持久化/SQLAlchemy层。
- en: 'If you are new to GraphQL, know there are two types of operations, which GraphQL
    treats differently and which require slightly different code, at least when using
    Python and Graphene. Those two actions are queries and mutations, or reads and
    writes, respectively. In this section, we will cover queries. This code provides
    all of the functionality for every query interaction in our example API. Details
    of each part of this code will be discussed in later. The main entry point is
    this handler code is the `handle_graphql` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触GraphQL，了解有两种类型的操作，GraphQL会以不同的方式处理它们，并且需要稍微不同的代码，至少当使用Python和Graphene时是这样。这两个动作是查询和突变，或者说是读取和写入。在本节中，我们将介绍查询。此代码提供了我们示例API中每个查询交互的所有功能。此代码每个部分的详细信息将在后续章节中讨论。主要入口点是此处理程序的`handle_graphql`函数：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code implements the same functionality as our REST API's `GET`
    endpoints, getting a listing of all cupping sessions and individual cupping sessions.
    Following on from the top-level `handler.py`, the `handle_graphql` function accepts
    an HTTP method, which isn't even used, along with a JSON-encoded payload from
    the request. From there, it's handed off to a small helper function that decodes
    the JSON payload via a decorator we authored earlier. Some light error handling
    ensures that errors come back in the right format. This function ultimately returns
    a Python dictionary with either errors or the result of the GraphQL execution.
     Ultimately, this dictionary is JSON-encoded and returned to the client, as we
    saw in `handler.py`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码实现了与我们的REST API的 `GET` 端点相同的功能，获取所有 `cupping` 会话和单个 `cupping` 会话的列表。从顶层的
    `handler.py` 开始，`handle_graphql` 函数接受一个HTTP方法，这个方法甚至没有被使用，以及来自请求的JSON编码的有效负载。从那里，它被传递给一个小型的辅助函数，该函数通过我们之前编写的装饰器解码JSON有效负载。一些轻量级的错误处理确保错误以正确的格式返回。这个函数最终返回一个包含错误或GraphQL执行结果的Python字典。最终，这个字典被JSON编码并返回给客户端，正如我们在
    `handler.py` 中所看到的。
- en: 'The `Query` class is the central place where most, if not all, of the functionality,
    will occur for fetching data from our backend. Our API has two main resources,
    `Session` and `Cupping`.  Since we are making this API have functional parity
    with our REST API, two class attributes will give us the ability to respond to
    queries for either `cuppings` or `sessions`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query` 类是大多数（如果不是所有）功能发生的地方，用于从我们的后端获取数据。我们的API有两个主要资源，`Session` 和 `Cupping`。由于我们使这个API与我们的REST
    API具有功能一致性，两个类属性将使我们能够响应对 `cuppings` 或 `sessions` 的查询：'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Taking `sessions` as an example, we define the `sessions` attribute to be a
    list of GraphQL objects, where each item in the list is a `SessionObject`. Fortunately,
    `SessionObject` is trivial to implement since we can take advantage of Graphene-SQLAlchemy
    and map the Session SQLAlchemy model to a Graphene-compatible object type. In
    reality, we could have performed this entirely on our own, but it would have required
    manually constructing an object that maps SQLAlchemy fields to Graphene fields
    and writing more code. Graphene-SQLAlchemy handles all of this work automatically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `sessions` 为例，我们将 `sessions` 属性定义为GraphQL对象的列表，其中列表中的每个项目都是一个 `SessionObject`。幸运的是，`SessionObject`
    的实现非常简单，因为我们可以利用 Graphene-SQLAlchemy 将 Session SQLAlchemy 模型映射到兼容的Graphene对象类型。实际上，我们完全可以自己完成这项工作，但这将需要手动构建一个将
    SQLAlchemy 字段映射到 Graphene 字段的对象，并编写更多的代码。Graphene-SQLAlchemy 自动处理所有这些工作。
- en: Two additional keyword arguments are passed into `graphene.List`, `id`, and
    `account_id`. Attributes that we want to use to query need to be explicitly defined
    when building `Query` items. The addition of `id` and `account_id` mean the API
    can now accept either or both fields from clients and use them to filter results.
     Do note that we have surpassed the REST API in functionality, albeit only slightly.
    By adding `account_id` as a query field, we've given our API new functionality
    that didn't exist in the REST version.  Also, this GraphQL API can return a list
    of cupping resources, which wasn't possible in the REST API. If you think through
    the steps of adding this functionality to the REST API, we'd need to add a new
    endpoint to return the new cupping resources by themselves and either come up
    with an entirely new API endpoint or shoehorn in some query parameters as `GET`
    arguments to filter `Sessions` by account. While either approach can work, it
    should be clear that this speaks to some of the inconsistencies and areas for
    interpretation with REST APIs. Here, there is one, and only one, way to add query
    parameters to a GraphQL query.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `graphene.List` 传递了两个额外的关键字参数，`id` 和 `account_id`。当我们构建 `Query` 项目时，需要明确定义我们想要用于查询的属性。添加
    `id` 和 `account_id` 意味着API现在可以接受来自客户端的任一或两个字段，并使用它们来过滤结果。请注意，尽管只有细微的改进，但我们已经超越了REST
    API的功能。通过添加 `account_id` 作为查询字段，我们为我们的API提供了REST版本中不存在的新功能。此外，这个GraphQL API可以返回一个包含
    `cupping` 资源的列表，这在REST API中是不可能的。如果你考虑将此功能添加到REST API的步骤，我们需要添加一个新的端点来返回单独的新 `cupping`
    资源，或者提出一个全新的API端点，或者将一些查询参数作为 `GET` 参数来过滤 `Sessions`。虽然两种方法都可以工作，但应该清楚，这反映了REST
    API中的一些不一致性和解释区域。在这里，添加查询参数到GraphQL查询的方式只有一个，且仅有一个。
- en: Now that we have defined the return values, there is still the work of actually
    fetching the data. Graphene makes this quite simple by requiring a method prepended
    with `resolve_` in order to fetch whichever resource we've implemented. The preceding
    code for both resolve functions, `resolve_sessions`, and `resolve_cuppings`, makes
    calls to our SQLAlchemy query functions and also passes through any filters that
    arrive via the extra keyword arguments defined on the `graphene.List` attributes
    previously described. Both resolve functions will return lists of SQLAlchemy objects;
    however, because the attributes that are requesting the data are themselves defined
    as  `SQLAlchemyObjectType`, the SQLAlchemy return values are transformed to the
    correct data types to fulfill the GraphQL queries.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了返回值，但仍需实际获取数据。Graphene通过要求一个以`resolve_`开头的方法来获取我们已实现的任何资源，使得这个过程变得非常简单。前面代码中的`resolve_sessions`和`resolve_cuppings`两个解析函数调用了我们的SQLAlchemy查询函数，并且还传递了通过之前描述的`graphene.List`属性上定义的额外关键字参数到达的任何过滤器。这两个解析函数都将返回SQLAlchemy对象的列表；然而，因为请求数据的属性本身被定义为`SQLAlchemyObjectType`，所以SQLAlchemy的返回值被转换成正确的数据类型以满足GraphQL查询。
- en: A couple of example queries later in this chapter may help solidify the flow
    of data and the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面的几个示例查询可能有助于巩固数据流和代码。
- en: Implementing GraphQL mutations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GraphQL突变
- en: 'After querying comes mutation, which is an operation which writes or otherwise
    transforms data. In our API, we''ll be implementing a single mutation that will
    create new `Session` records, which themselves have accompanying cupping records.
    Again, we''re able to reuse helper functions and code to perform some of this
    work and can focus on the GraphQL code. The following additions to the `handlers/graphql.py`
    code implements creating new `Session` records. There is a slight change to the
    creation of the `schema` object, where we pass in a reference to our `Mutation`
    class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询之后是突变，这是一种写入或以其他方式转换数据的操作。在我们的API中，我们将实现一个突变，该突变将创建新的`Session`记录，这些记录本身有伴随的cupping记录。同样，我们能够重用辅助函数和代码来执行一些这项工作，并专注于GraphQL代码。以下是对`handlers/graphql.py`代码的以下添加，实现了创建新的`Session`记录。在创建`schema`对象时，我们传入了对我们的`Mutation`类的引用：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, notice that the `Mutation` class is the wrapper around all mutations
    that need to be defined and passed into our `Schema`. Just like the `Query` class,
    the `Mutation` class will specify one or more mutation types, which themselves
    subclass `graphene.Mutation`. The entry point for a `Mutation` class is the `mutate`
    method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，`Mutation`类是所有需要定义并传递给我们的`Schema`的突变的包装器。就像`Query`类一样，`Mutation`类将指定一个或多个突变类型，这些类型本身是`graphene.Mutation`的子类。`Mutation`类的入口点是`mutate`方法。
- en: Before the `mutate` method can be invoked, the class needs to define a set of
    input attributes that will accept the actual input data used to create new data.
    In this case, we need to identify the input data types manually using the raw
    `graphene` type. Look at the `Arguments` class and you should be able to see the
    one-to-one correspondence with the SQLAlchemy models. GraphQL objects can be nested
    arbitrarily deep, that can be seen previously, where the `cuppings` attribute
    is a list of `CuppingInput` objects, itself a custom input type specific to our
    API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`mutate`方法之前，类需要定义一组输入属性，这些属性将接受用于创建新数据的实际输入数据。在这种情况下，我们需要手动使用原始的`graphene`类型来识别输入数据类型。查看`Arguments`类，你应该能够看到它与SQLAlchemy模型之间的一对一对应关系。GraphQL对象可以嵌套任意深度，这可以从之前的例子中看到，其中`cuppings`属性是一个`CuppingInput`对象的列表，它本身是我们API的特定自定义输入类型。
- en: As in the `resolve_` functions in a `Query` attribute, the `mutate` method delegates
    the creation of records to an existing SQLAlchemy function ultimately. All of
    the input data from a client's GraphQL mutation arrive as `kwargs` to `mutate`.
    Those key-value pairs in the form of a Python dictionary are used to create a
    model, validate, and finally write a new record to the database. At this point,
    any validation errors are handled by our model layer and error bubble up to the
    client.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在`Query`属性的`resolve_`函数中一样，`mutate`方法最终将记录的创建委托给一个现有的SQLAlchemy函数。客户端的GraphQL突变中所有输入数据都以`kwargs`的形式传递给`mutate`。这些以Python字典形式存在的键值对用于创建模型、验证，并最终将新记录写入数据库。在这个阶段，任何验证错误都由我们的模型层处理，并将错误向上冒泡到客户端。
- en: Deployment
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'With a new Lambda function comes the need to deploy our code, which requires
    a full deployment via `sls deploy`. As a reminder, any time you add, remove, or
    otherwise update an AWS resource, a complete `CloudFormation` update is needed.
    We need to add a couple of new entries in the `serverless.yml` file, which will
    call the new `graphql` handler functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的 Lambda 函数的出现，我们需要部署我们的代码，这需要通过 `sls deploy` 进行完整部署。作为提醒，每次你添加、删除或以其他方式更新
    AWS 资源时，都需要完整的 `CloudFormation` 更新。我们需要在 `serverless.yml` 文件中添加几个新条目，这将调用新的 `graphql`
    处理程序函数：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GraphQL will accept both `GET` and `POST` requests, so we'll wire methods to
    the same `/graphql` endpoint and make sure we enable CORS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 将接受 `GET` 和 `POST` 请求，因此我们将方法连接到相同的 `/graphql` 端点并确保我们启用了 CORS。
- en: 'Since we''re using new libraries, Graphene and Graphene-SQLAlchemy, we''ll
    need to update our requirements file and rebuild our supporting libraries. I''ve
    added the following library to a specific commit to the `requirements.txt` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用新的库，Graphene 和 Graphene-SQLAlchemy，我们需要更新我们的需求文件并重新构建我们的支持库。我已经将以下库添加到
    `requirements.txt` 文件的特定提交中：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Graphene is a requirement for Graphene-SQLAlchemy, so we get both libraries
    with this single requirement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Graphene 是 Graphene-SQLAlchemy 的一个要求，所以我们通过这个单一的要求获取这两个库。
- en: 'We use our Docker container as a build tool:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的 Docker 容器作为构建工具：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, it''s safe to do the full deployment, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以安全地进行完整部署，如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that, we have a new `/graphql` endpoint, which accepts both `GET` and `POST`
    requests. Next, it's time to test out some GraphQL queries on our serverless endpoint.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个新的 `/graphql` 端点，它接受 `GET` 和 `POST` 请求。接下来，是时候在我们的无服务器端点上测试一些 GraphQL
    查询了。
- en: Astute readers may notice the root URL changing between example deployments.
    During development, this is a frequent occurrence, as you'll often be deploying
    new stacks and then tearing them down when no longer needed. For each deployment,
    a unique base URL will be created by API Gateway via CloudFormation. Of course,
    if this were a production API, you wouldn't be tearing down your serverless stack
    every evening and rebuilding it in the morning.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会注意到示例部署之间根 URL 的变化。在开发过程中，这种情况经常发生，因为你经常会部署新的堆栈，然后在不再需要时将其拆除。对于每次部署，API
    Gateway 通过 CloudFormation 创建一个唯一的基 URL。当然，如果这是一个生产 API，你不会每晚拆除你的无服务器堆栈并在早上重建它。
- en: Viewing the deployed application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看已部署的应用程序
- en: Learning the GraphQL language is a topic in and of itself. In this section,
    I'll show some queries and mutations using the Insomnia client on macOS. Insomnia
    is a client application that can be used to make standard REST API requests and
    also has a lovely GraphQL interface when working with GraphQL endpoints.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 GraphQL 语言本身就是一个主题。在本节中，我将展示在 macOS 上的 Insomnia 客户端使用的一些查询和突变。Insomnia 是一个客户端应用程序，可以用来发送标准的
    REST API 请求，并且在与 GraphQL 端点一起工作时还有一个漂亮的 GraphQL 界面。
- en: 'A simple query to get a list of cupping sessions, returning only the ID and
    name of the `Sessions`, looks like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的查询以获取拔罐疗程列表，只返回 `Sessions` 的 ID 和名称，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you think back to the implementation of the `Query` class, you might recall
    the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你回想起 `Query` 类的实现时，你可能会记得以下内容：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Hopefully, things are becoming clearer now. The preceding query is named `allSessions`,
    and inside it''s explicitly asking for `sessions`. Our GraphQL code responds in
    kind by noticing that the query is for sessions and invoking the `resolve_sessions`
    function. The following screenshot shows an `allSessions` query using the Insomnia
    client:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在事情变得清晰起来。前面的查询被命名为 `allSessions`，在其中明确请求 `sessions`。我们的 GraphQL 代码相应地通过注意到查询是关于
    sessions 的并调用 `resolve_sessions` 函数来响应。以下截图显示了使用 Insomnia 客户端的 `allSessions` 查询：
- en: '![](img/2707983c-782c-49bb-98b3-1a5b9e989d46.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2707983c-782c-49bb-98b3-1a5b9e989d46.png)'
- en: 'This is great, and the return data may suffice for a client who has a listing
    of all `Sessions`. But what happens when we want more data? In GraphQL, we merely
    ask for the data we need. Assume our client application now wants a listing of
    `Sessions`, but with a few more fields present, including the related `cupping`
    objects for each `Session.` To accomplish this, we update the query schema that
    we''ll send to the `/graphql` endpoint. Rather than just asking for `id` and `name`,
    I''ll add in `formName`, along with two attributes of the related `cuppings` items:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，返回的数据可能足以满足拥有所有`Sessions`列表的客户端。但当我们想要更多数据时会发生什么？在GraphQL中，我们只需请求我们所需的数据。假设我们的客户端应用程序现在想要一个`Sessions`的列表，但包含一些额外的字段，包括每个`Session`相关的`cupping`对象。为了完成这个任务，我们更新要发送到`/graphql`端点的查询模式。而不是只请求`id`和`name`，我会添加`formName`，以及相关`cuppings`项的两个属性：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows this query along with the response in the Insomnia
    client:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Insomnia客户端中的此查询及其响应：
- en: '![](img/eeb5cf2c-4dfb-4bc7-a072-344055faf230.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eeb5cf2c-4dfb-4bc7-a072-344055faf230.png)'
- en: 'I have to admit, I was quite excited to see how easy it is to control the output
    when I got this working. So what if we need to filter some data? Remember the
    API that didn''t exist in our REST API but now does? Let''s fetch all of the `cupping`
    objects that are related to a single `Session`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，当我看到这个功能有多容易控制输出时，我非常兴奋。那么如果我们需要过滤一些数据怎么办？记得我们REST API中不存在的API现在有了？让我们获取与单个`Session`相关的所有`cupping`对象：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, let''s tie this back to our application code and remember what the `cuppings`
    attribute was in our `Query`, class.  Inside `Query` we have the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们将这一点与我们应用程序代码联系起来，并记住我们的`Query`类中的`cuppings`属性。在`Query`内部，我们有以下内容：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Graphene does include some magic for auto *CamelCase* input and output data.
    Even though the `cuppings` attribute specifies `session_id` as an input filter,
    the client uses `SessionId`. The end result is that the Python code receives `session_id`
    as a keyword argument that is passed to the SQLAlchemy query. The end result is
    that SQLAlchemy performs a query analogous to the following SQL statement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Graphene确实包含一些自动将输入和输出数据转换为*CamelCase*的魔法。尽管`cuppings`属性指定`session_id`作为输入过滤器，但客户端使用`SessionId`。最终结果是Python代码接收`session_id`作为关键字参数传递给SQLAlchemy查询。结果是SQLAlchemy执行类似于以下SQL语句的查询：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows a GraphQL query that will fetch a single `Session`
    based on a numeric ID from our GraphQL API:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个GraphQL查询，该查询将根据我们的GraphQL API中的数字ID获取单个`Session`：
- en: '![](img/168b60ec-30bf-4fe4-9bbe-b0976ae6d17e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/168b60ec-30bf-4fe4-9bbe-b0976ae6d17e.png)'
- en: 'Finally, let''s take a look at the mutation portion of our code and create
    some new data. You might expect this to be fairly simple, and it is for the most
    part. One slight complication is that the cupping scores field in the database
    is a PostgreSQL JSONB type, which allows for maximum flexibility. Inputting JSON
    requires escaping this field, which is the reason for all of the backslashes in
    the mutation request. The following code snippet is a GraphQL mutation that creates
    a new `Session` record:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们的代码中的变异部分，并创建一些新的数据。你可能期望这会相当简单，大部分确实是这样的。有一点小复杂的是，数据库中的杯测分数字段是PostgreSQL
    JSONB类型，这提供了最大的灵活性。输入JSON需要转义这个字段，这也是变异请求中所有反斜杠的原因。以下是一个创建新`Session`记录的GraphQL变异代码片段：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I won''t go through all of the application code, but at a high level, our request
    sends in a `createSession` mutation to the application. This input payload maps
    directly to our `create_session` attribute on the `Mutation` class thanks to the
    auto *CamelCasing* from Graphene:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细说明所有应用程序代码，但总的来说，我们的请求向应用程序发送一个`createSession`变异。这个输入负载直接映射到`Mutation`类上的`create_session`属性，这得益于Graphene的自动*CamelCasing*：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The input data in the preceding mutation is reasonably small. What is more verbose
    is the section for the return values. Our mutation returns an `ok` attribute,
    which is a Boolean, along with the newly created `Session` resource. Because of
    that, our mutation can request precisely what it needs from the newly created
    resource.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的变异中，输入数据相对较小。更详细的是返回值的部分。我们的变异返回一个`ok`属性，它是一个布尔值，以及新创建的`Session`资源。正因为如此，我们的变异可以精确地请求新创建的资源所需的内容。
- en: 'The following screenshot shows the input and output when creating a new `Session`
    record in the Insomnia client:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Insomnia客户端中创建新`Session`记录时的输入和输出：
- en: '![](img/3bebb18e-c720-4159-8023-071114ad13d8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bebb18e-c720-4159-8023-071114ad13d8.png)'
- en: GraphQL has much more to offer, and I only wish there was more time to cover
    it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL有很多东西可以提供，我只希望有更多的时间来介绍它。
- en: Iteration and deployment
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和部署
- en: 'While developing this code using the existing repository, I repeatedly needed
    to update just the GraphQL portion of the stack. Using the Serverless Framework
    and its ability to update a single Lambda function made this very easy. With the
    shortcut in the `Makefile`, deploying a single function looks like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用现有仓库开发此代码时，我反复需要只更新堆栈中的GraphQL部分。使用Serverless Framework及其更新单个Lambda函数的能力使得这个过程变得非常简单。通过`Makefile`中的快捷方式，部署单个函数看起来如下：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's hard to give exact numbers, but deployments like this after iteration on
    code take in the order of two-five seconds. Deployment speed will mostly depend
    on your upload speeds and the final size of the application package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 给出精确数字比较困难，但经过代码迭代后的部署大约需要两到五秒。部署速度主要取决于你的上传速度和应用程序包的最终大小。
- en: Of course, iterating and adding new code means writing more tests. Serverless
    applications can be slightly tricky since it's possible to write a rich set of
    unit tests, only to see the deployed application fail due to missing or presumptuous
    tests higher up in the stack. My advice is to write the right mix of unit tests,
    without being academic about it, along with a very rich set of integration tests
    as the highest level of code that is practical.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，迭代和添加新代码意味着需要编写更多的测试。无服务器应用程序可能有点棘手，因为你可以编写一套丰富的单元测试，但最终部署的应用程序可能会因为堆栈中更高层次的缺失或假设性测试而失败。我的建议是编写合适的单元测试组合，不要过于学术化，同时编写一套非常丰富的集成测试，作为最高级别的实际代码。
- en: Using a concrete example, this GraphQL query and mutation code above is 100%
    tested, as is the `cupping.handlers.graphql.handle_graphql` function. This strategy
    ensures that all of the error handling, JSON decoding of the payload, and other
    utility code is behaving as expected, in addition to testing the GraphQL business
    logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具体的例子，上面的GraphQL查询和突变代码是100%经过测试的，`cupping.handlers.graphql.handle_graphql`函数也是如此。这种策略确保了所有的错误处理、有效载荷的JSON解码和其他实用代码都按预期运行，除了测试GraphQL业务逻辑。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the entire process of creating a three-tier
    web application with a serverless architecture using a GraphQL interface. The
    vast majority of this application is similar to the REST version of the same application.
    We learned the changes needed to migrate from a REST interface and design to a
    GraphQL design, both from the perspective of application code and serverless functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用GraphQL接口创建三层无服务器架构的Web应用程序的整个过程。这个应用程序的大部分内容与相同应用程序的REST版本相似。我们学习了从REST接口和设计迁移到GraphQL设计所需的变化，这既包括应用程序代码的视角，也包括无服务器函数的视角。
- en: Readers should now have a high-level understanding of the advantages of employing
    a GraphQL interface in a serverless architecture and have enough knowledge to
    begin implementation of their own serverless GraphQL application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该对在无服务器架构中采用GraphQL接口的优势有一个高层次的理解，并且拥有足够的知识来开始实现他们自己的无服务器GraphQL应用程序。
- en: In [Chapter 4](svrls-dsnptn-bstprac_ch04.html), *Integrating Legacy APIs with
    the Proxy Pattern*, we will work through yet another web application pattern for
    proxying API requests from clients through a serverless application to a legacy
    API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](svrls-dsnptn-bstprac_ch04.html)，“使用代理模式集成遗留API”，我们将探讨另一种代理客户端通过无服务器应用程序向遗留API发送API请求的Web应用程序模式。
