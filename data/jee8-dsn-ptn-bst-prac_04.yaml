- en: Integration Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成模式
- en: 'In this chapter, we are going to explain some integration patterns and look
    at how they work on the integration tier of Java EE. After reading this chapter,
    you will be able to implement these patterns and use them to solve integration problems
    between resources or systems. You will also be able to work on the integration
    tier and become familiar with the concepts associated with integration patterns.
    The topics in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释一些集成模式，并查看它们在Java EE的集成层上的工作方式。阅读本章后，您将能够实现这些模式，并使用它们来解决资源或系统之间的集成问题。您还将能够在集成层上工作，并熟悉与集成模式相关的概念。本章的主题如下：
- en: Explaining the concept of the integration tier
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释集成层的理念
- en: Explaining the concept of the data-access object pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释数据访问对象模式的理念
- en: Implementing the data-access object pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据访问对象模式
- en: Explaining the concept of the domain-store pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释领域存储模式的理念
- en: Implementing the domain-store pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现领域存储模式
- en: Explaining the concept of the service-activator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释服务激活模式的理念
- en: Implementing the service-activator pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务激活模式
- en: Explaining the concept of the integration tier
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释集成层的理念
- en: As discussed in previous chapters, Java EE is divided into three well-known
    tiers—the presentation tier, the business tier, and the integration tier. These
    tiers work together to promote solutions with a high level of decoupling.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Java EE分为三个著名的层——表示层、业务层和集成层。这些层共同工作，以促进高度解耦的解决方案。
- en: In a business environment, software development is very difficult as we need
    to think about the whole ecosystem of the enterprise. An ecosystem includes its
    data source, software, data politics, security, and devices. Consequently, the
    developer needs to think about how to read and write data in these data sources,
    how the software communicates between with each other, how the data policies are
    implemented on the systems, how the security works on the business environment,
    and so on. In this case, it would be beneficial to create a tier to resolve all
    integration and communication problems, because their solutions will be decoupled
    from business logic. This is the thought process that gave birth to the integration
    tier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，软件开发非常困难，因为我们需要考虑企业的整个生态系统。一个生态系统包括其数据源、软件、数据政策、安全和设备。因此，开发者需要考虑如何在这些数据源中读取和写入数据，软件之间如何相互通信，数据政策如何在系统中实施，商业环境中的安全机制如何运作，等等。在这种情况下，创建一个层来解决所有集成和通信问题将是有益的，因为它们的解决方案将与业务逻辑解耦。这就是产生集成层的思维过程。
- en: The integration tier is the tier responsible for decoupling the business logic
    from the integration logic throughout the whole application. This tier has the
    logic of communication with an external resource or system, and this stays separate
    from the business logic. This tier will make it possible to read and write data
    from external sources, making communication between applications and components
    of the business ecosystem feasible. Furthermore, this tier will hide all communication
    complexity from the business tier. The business tier will then receive the data
    without knowing the complexity of the communication between the components and
    how they are structured.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 集成层是负责在整个应用程序中将业务逻辑与集成逻辑解耦的层。这个层具有与外部资源或系统通信的逻辑，并且与业务逻辑保持分离。这个层将使得从外部源读取和写入数据成为可能，使得应用程序和商业生态系统组件之间的通信变得可行。此外，这个层将隐藏所有通信复杂性，使业务层接收数据时无需了解组件之间的通信复杂性和它们的结构。
- en: Nowadays, it is extremely rare to develop an application with integration but
    without some kind of integration with an external resource. This is because the
    application always needs to read data from a source, and this source is generally outside
    of the application in databases or filesystems. If the application has an external
    data source as its dependency, then this application needs to be integrated to
    access the data from the external data source. The simpler application will then
    have an integration tier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发一个没有与外部资源集成但具有某种集成功能的程序极为罕见。这是因为应用程序总是需要从源读取数据，而这个源通常位于应用程序之外，如数据库或文件系统中。如果应用程序依赖外部数据源，那么这个应用程序需要集成以从外部数据源访问数据。因此，更简单的应用程序将需要一个集成层。
- en: Over time, the complexity of integration between resources or systems grew,
    because more and more business logic needs to be integrated to promote a good
    response to businesses. With this, there emerged a necessity to create a common
    solution to integration problems that occur over and over, and with this, the
    integration patterns were created.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，资源或系统之间集成的复杂性增加，因为越来越多的业务逻辑需要集成以促进对业务的良好响应。因此，有必要创建一个通用的解决方案来解决反复出现的集成问题，并且因此产生了集成模式。
- en: Explaining the concept of the data-access object pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释数据访问对象模式的概念
- en: In the business world, the application always needs to be integrated with the
    data source in order to read, write, delete, or update data. This data source
    could be a relational database, NoSQL database, **LDAP** (**Lightweight Directory
    Access Protocol**), or filesystem, for example. Each type of data source has its
    structure and has a complexity to connect to, read, and write data. These complexities
    shouldn't be exposed to business logic and instead should be decoupled from it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业世界中，应用程序总是需要与数据源集成，以便读取、写入、删除或更新数据。这个数据源可以是关系数据库、NoSQL数据库、**LDAP**（**轻量级目录访问协议**）或文件系统，例如。每种类型的数据源都有其结构，并且连接、读取和写入数据都有其复杂性。这些复杂性不应该暴露给业务逻辑，而应该与之解耦。
- en: 'The data-access object pattern is a pattern used to abstract and hides all
    access to data sources from the business tier. This pattern encapsulates all data-source
    access logic and its complexities from the business tier, decoupling all data-source
    access logic from it. If we then want to substitute the data source with another,
    we will only need to modify the code of the data-access object pattern, and this
    modification will not be visible on the business tier. The following diagram displays
    the data-access object pattern model:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问对象模式是一种用于从业务层抽象和隐藏所有数据源访问的模式。该模式封装了所有数据源访问逻辑及其复杂性，从业务层解耦所有数据源访问逻辑。如果我们想用另一个数据源替换它，我们只需要修改数据访问对象模式的代码，这种修改在业务层是不可见的。以下图显示了数据访问对象模式模型：
- en: '![](img/2ca072fb-cb1b-463e-9c5c-661952bda28a.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ca072fb-cb1b-463e-9c5c-661952bda28a.png)'
- en: In the preceding diagram, we have **BusinessObject**, which has the business
    logic; DAO, which has the data access logic; **TransferObject**, which is the
    object used to transfer; and data source, which is the external local where the
    data resides. When **BusinessObject** needs to access the data, it requests data
    from DAO. The DAO accesses the data source and reads the data, then returns the
    data to **BusinessObject** as **TransferObject**. Some developers and professionals
    think this pattern is only supposed to be used with relational databases and `NoSql`,
    but when our data source is a filesystem or another type of data persistence,
    we should also use DAO in order to promote the decoupling between business logic
    and persistence logic as well as to organize our code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到了**BusinessObject**，它包含业务逻辑；DAO，它包含数据访问逻辑；**TransferObject**，它是用于传输的对象；以及数据源，它是数据存储的外部本地。当**BusinessObject**需要访问数据时，它会从DAO请求数据。DAO访问数据源并读取数据，然后将数据作为**TransferObject**返回给**BusinessObject**。一些开发人员和专业人士认为这种模式仅应与关系数据库和`NoSql`一起使用，但当我们数据源是文件系统或其他类型的数据持久化时，我们也应该使用DAO，以促进业务逻辑和持久化逻辑之间的解耦，以及组织我们的代码。
- en: Implementing the data-access object pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据访问对象模式
- en: To implement this pattern using the best practices of Java EE 8, we will use
    a relational database and implement the data read and write using a JPA specification.
    In this example, we will have one table named *employee*, which contains the employee
    data. We will also create a class called `EmployeeDao` which will have four methods –
    `save(employee)`, `findByName(name)`, `findAll()`, and `delete(employee)`. The
    `save` method will receive one employee and save them on the database, `findByName`
    will receive the name as a parameter and will find the employee by name on the
    database, and `delete` will receive an employee and delete them from the database.
    Also, we are going to create a transfer object called `Employee`, a class that
    is a JPA entity and has the mapping to a database table.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Java EE 8 的最佳实践来实现此模式，我们将使用关系型数据库，并通过 JPA 规范实现数据的读取和写入。在这个例子中，我们将有一个名为 *employee*
    的表，其中包含员工数据。我们还将创建一个名为 `EmployeeDao` 的类，它将包含四个方法 —— `save(employee)`、`findByName(name)`、`findAll()`
    和 `delete(employee)`。`save` 方法将接收一个员工对象并将其保存到数据库中，`findByName` 将接收一个参数作为名称，并在数据库中按名称查找员工，`delete`
    将接收一个员工对象并将其从数据库中删除。此外，我们还将创建一个名为 `Employee` 的传输对象，这是一个 JPA 实体类，它具有与数据库表的映射。
- en: Implementing the entity with JPA
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JPA 实现实体
- en: The JPA entity is a class that represents some table or view of a database.
    The entity needs to have an attribute that identifies only one entity, needs to
    have a constructor with non-arguments and each object of a class that is a JPA
    entity identify only one row of table or view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 实体是一个表示数据库中的某个表或视图的类。实体需要一个属性来唯一标识一个实体，需要有一个无参构造函数，并且 JPA 实体的每个对象都只标识表或视图中的一行。
- en: 'In the following code, we have an interface, called `Entity`, that all JPA
    entities will implement according to the following method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有一个名为 `Entity` 的接口，所有 JPA 实体都将根据以下方法实现：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following code, we have the transfer object, called `Employee`, which
    is a JPA entity. This class has the mapping table, called `Employee`, as well
    as its column used by applications. The business tier only needs to know the transfer
    objects, the DAOs, and the parameters to send to the DAOs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有一个名为 `Employee` 的传输对象，它是一个 JPA 实体。这个类有一个名为 `Employee` 的映射表，以及应用程序使用的列。业务层只需要知道传输对象、DAO
    和发送给 DAO 的参数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implementing DAO
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 DAO
- en: 'In order to reuse a lot of code and promote best practices to implement DAO,
    we will create an abstract DAO, called `AbstractDao`, which is the superclass
    of all DAOs, that has methods with the generic logic that can be used by all DAOs:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用大量代码并推广实现 DAO 的最佳实践，我们将创建一个抽象 DAO，称为 `AbstractDao`，它是所有 DAO 的超类，具有所有 DAO
    都可以使用的通用逻辑方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To prevent the user from instantiating `AbstractDao`, we created the class
    in the preceding code as an abstract class. Another `AbstractDao` characteristic
    is the return of methods, which only return `Entity` or a list of `Entity`. This
    is a good practice, because we know the object type that is returned by this method
    and it organizes our code, because we know what type of value our method could
    return:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户实例化 `AbstractDao`，我们在前面的代码中将该类创建为一个抽象类。另一个 `AbstractDao` 的特点是方法的返回值，它只返回
    `Entity` 或 `Entity` 的列表。这是一个好的实践，因为我们知道这个方法返回的对象类型，并且它组织了我们的代码，因为我们知道我们的方法可能返回什么类型的值：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see that we have the `EmployeeDao` class, which is the DAO that reads
    and writes data about `Employee`. This class is an EJB, meaning that it can control
    all transactions with the JTA specification—assuming that transactions are managed
    by the Java EE container—and make the transaction control transparent to the application.
    To read employee data, we can call the `findAll`, `findByName`, and `findById`
    methods; to write employee data, we can call the `persist` and `update` methods;
    and to remove (delete) employee data, we can call the `delete` method. Note that
    the business class—a class that acts on the business tier—doesn''t know about
    the process of reading and writing data; it only knows the parameters of the method
    to call as well as its returns. Therefore, we can substitute the data source without
    impacting the business logic. We have `EmployeeBusiness` using the DAO to read
    and write data, which we will see here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`EmployeeDao`类，这是读取和写入`Employee`数据的DAO。这个类是一个EJB，这意味着它可以控制所有由JTA规范定义的事务——假设事务由Java
    EE容器管理——并使事务控制对应用程序透明。为了读取员工数据，我们可以调用`findAll`、`findByName`和`findById`方法；为了写入员工数据，我们可以调用`persist`和`update`方法；为了删除（删除）员工数据，我们可以调用`delete`方法。请注意，业务类——一个在业务层上执行操作的类——不知道读取和写入数据的过程；它只知道要调用的方法的参数以及它的返回值。因此，我们可以替换数据源而不影响业务逻辑。我们有`EmployeeBusiness`使用DAO来读取和写入数据，我们将在下面看到：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a good pattern; its use is very broad and most applications implement
    it. When implementing this pattern, be careful not to expose data-source characteristics,
    for example, by sending a SQL query as a parameter to DAO's execution or by sending
    a path of the file system as a parameter to DAO's execution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的模式；它的应用非常广泛，大多数应用程序都实现了它。在实现这个模式时，请注意不要暴露数据源特性，例如，通过将SQL查询作为参数发送给DAO的执行，或者通过将文件系统的路径作为参数发送给DAO的执行。
- en: Explaining the concept of the domain-store pattern
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释领域存储模式的概念
- en: We covered the data-access object pattern in the previous section and looked
    at how this pattern makes an abstraction of the data access logic from the business
    tier. However, the data-access object pattern is a stateless pattern that does
    not save states and intelligence inside them. Some problems have a complex relationship
    between data, and the data persistence needs to be done through an intelligent
    process. To promote this feature, the data-access object pattern does not attend.
    This is because DAO shouldn't maintain states, shouldn't contain any intelligent
    processes, and need only contain a process for saving or updating. To solve this
    problem, the domain-store pattern was created—a pattern that can add functionalities
    to DAO.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了数据访问对象模式，并探讨了该模式如何从业务层抽象数据访问逻辑。然而，数据访问对象模式是一个无状态模式，它不保存状态和智能过程。一些问题中数据之间存在复杂的关系，数据持久化需要通过智能过程来完成。为了促进这一特性，数据访问对象模式不参与。这是因为DAO不应该维护状态，不应该包含任何智能过程，只需要包含保存或更新的过程。为了解决这个问题，领域存储模式被创建——这是一个可以为DAO添加功能的模式。
- en: 'The domain-store pattern is a pattern that makes the object-model persistence
    transparent, separating the persistence logic from the object model, making it
    possible for the application to select the persistence logic according to the
    object state. Inside this pattern exists a DAO, designed to communicate and manipulate
    data with the data source, but this DAO is hidden from the application. This pattern
    is rarely implemented by developers because JPA already works as a domain-store
    pattern. This is because the JPA implements some intelligent processes to define
    when and how to save the data and its intelligent processes are oriented by the
    mapping made on JPA entities. However, when we decide to implement persistence
    in another type of data source, we may want to implement this pattern and use
    it in our application. In the following diagram, we can see the domain-store pattern model:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 领域存储模式是一种使对象模型持久化透明化的模式，将持久化逻辑与对象模型分离，使得应用程序可以根据对象状态选择持久化逻辑。在这个模式中存在一个DAO，它被设计用来与数据源进行通信和操作数据，但这个DAO对应用程序是隐藏的。由于JPA已经作为一个领域存储模式工作，因此开发者很少实现这种模式。这是因为JPA实现了一些智能过程来定义何时以及如何保存数据，并且这些智能过程是以JPA实体上的映射为导向的。然而，当我们决定在另一种类型的数据源中实现持久化时，我们可能希望实现这种模式并在我们的应用程序中使用它。在下面的图中，我们可以看到领域存储模式模型：
- en: '![](img/4e624879-dbda-4431-a000-abb42017c613.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![领域存储模式概念解释](img/4e624879-dbda-4431-a000-abb42017c613.png)'
- en: Many developers believe that the DAO is dead after JPA. This is because the
    JPA works with the domain store pattern and already has an internal DAO. However,
    to us, the DAO is a good pattern to use on Java EE projects. This is because JPA
    has a stronger relationship with relational databases, and if we substitute the
    relational database for another type of data source, we will possibly need to
    remove the JPA and use another mechanism instead. If all JPA calls are inside
    DAO, the application will only see DAO, and the JPA implementation will be hidden from
    the application. This makes the business tier more decoupled from the integration
    tier and the persistence logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为在JPA之后DAO已经过时。这是因为JPA与领域存储模式一起工作，并且已经有一个内置的DAO。然而，对我们来说，DAO是Java EE项目上使用的好模式。这是因为JPA与关系数据库有更强的关系，如果我们用另一种类型的数据源替换关系数据库，我们可能需要移除JPA并使用另一种机制。如果所有JPA调用都在DAO内部，应用程序将只看到DAO，JPA实现将隐藏于应用程序之外。这使得业务层与集成层和持久化逻辑解耦。
- en: Implementing the domain-store pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现领域存储模式
- en: 'This is a very long pattern. To implement and facilitate this implementation,
    we will save all the data on HashMap. This is an important step, because the focus
    of this subsection is to demonstrate how to implement domain-store patterns. To
    facilitate our understanding, we will look at the same scenario covered in the *Implementing
    the data-access object pattern* subsection. Here, we have the transfer object,
    called `Employee`, and we will also read and write data on the data source. However,
    persistence will be oriented by object state and will have an intelligence in
    its logic.. In this implementation, we have the following classes, interfaces,
    and annotations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常长的模式。为了实现和促进这种实现，我们将所有数据保存在HashMap中。这是一个重要的步骤，因为本小节的重点是展示如何实现领域存储模式。为了便于理解，我们将查看在*实现数据访问对象模式*小节中涵盖的相同场景。在这里，我们有传输对象，称为`Employee`，我们还将对数据源进行读写操作。然而，持久化将面向对象状态，并在其逻辑中具有智能。在这个实现中，我们有以下类、接口和注解：
- en: '`PersistenceManagerFactory`: This works as a factory pattern and is responsible
    for creating instances of the `PersistenceManager` class. `PersistenceManagerFactory`
    is a singleton and has only one instance on the entire application.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistenceManagerFactory`: 这作为一个工厂模式工作，负责创建`PersistenceManager`类的实例。`PersistenceManagerFactory`是一个单例，在整个应用程序中只有一个实例。'
- en: '`PersistenceManager`: This manages the persistence and queries the data. This
    data is an object model that works as a *Unit of Work. *'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistenceManager`: 这管理持久化和查询数据。这些数据是一个作为*工作单元*的对象模型。'
- en: '`Persistence`: This is an annotation used as the *qualify* of CDI. This qualify
    is used to define a method of `PersistenceManagerFactory`, which is responsible
    for creating a `PersistenceManager` instance.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Persistence`: 这是一个用作CDI*资格*的注解。这个资格用于定义`PersistenceManagerFactory`的方法，它负责创建`PersistenceManager`实例。'
- en: '`EmployeeStoreManager`: This works as a **Data-Access Object** (**DAO**), interacting
    with the data source and encapsulating all the data source complexity. DAO is
    responsible for reading and writing employee data on the data source.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmployeeStoreManager`: 这作为一个**数据访问对象**（**DAO**）工作，与数据源交互并封装所有数据源复杂性。DAO负责在数据源上读取和写入员工数据。'
- en: '`StageManager`: This is an interface used to create all the `StageManager`
    implementations.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StageManager`: 这是一个用于创建所有`StageManager`实现的接口。'
- en: '`EmployeeStageManager`: This coordinates the read and writes operations of
    data according to its states and rules.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmployeeStageManager`: 这根据其状态和规则协调数据的读写操作。'
- en: '`TransactionFactory`**:** This works as a factory pattern and is responsible
    for creating `Transaction` instances. `TransactionFactory` is a singleton and
    has only one instance in the entire application.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionFactory`**:** 这作为一个工厂模式工作，负责创建`Transaction`实例。`TransactionFactory`是一个单例，在整个应用程序中只有一个实例。'
- en: '`Transaction`**:** This is used to create transaction-oriented policies. This
    class controls the life cycle of transactions and defines the transaction limits.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transaction`**:** 这用于创建面向事务的策略。此类控制事务的生命周期并定义事务限制。'
- en: '`Transaction` (annotation): Annotation used as the *q**ualify* of CDI. This
    *qualify* is used to define a method of `TransactionFactory` that is responsible
    for creating a `Transaction` instance.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transaction`（注解）：用作CDI*资格*的注解。这个资格用于定义`TransactionFactory`的方法，它负责创建`Transaction`实例。'
- en: To implement this pattern, we will begin with the `PesistenceManagerFactory`
    class, which is a factory of `PersistenceManager`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个模式，我们将从`PersistenceManagerFactory`类开始，这是一个`PersistenceManager`的工厂。
- en: Implementing the PersistenceManagerFactory class
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现PersistenceManagerFactory类
- en: 'In the following code, we have the qualify used to inject the `PersistenceManager`
    class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有用于注入`PersistenceManager`类的限定符：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looking at the following code, we can see that we have the `PersistenceManagerFactory` class,
    which is responsible for creating new instances of `PersistenceManager`. This
    class uses the `@Singleton` annotation, which is an EJB annotation used to create
    a singleton pattern with the Java EE mechanism. The `getPersistenceManager` method has
    the `@Produces` annotation, which is used to define a method responsible for creating
    a new instance. It also has the `@Persistence` annotation, which is used as a *qualify*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码，我们可以看到我们有一个`PersistenceManagerFactory`类，该类负责创建`PersistenceManager`的新实例。这个类使用了`@Singleton`注解，这是一个用于通过Java
    EE机制创建单例模式的EJB注解。`getPersistenceManager`方法有`@Produces`注解，它用于定义一个负责创建新实例的方法。它还包含`@Persistence`注解，它用作一个*限定符*：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementing the PersistenceManager class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现PersistenceManager类
- en: We need to manage all processes of persistence and query data. For this, we
    need to create a class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要管理所有持久化和查询数据的过程。为此，我们需要创建一个类。
- en: 'The `PersistenceManager` class is responsible for managing all persistence
    processes and query processes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistenceManager`类负责管理所有的持久化和查询过程：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have the `PersistenceManager` class. This class has
    the `stateManagers` attribute, which is a set of `StateManager` used to control
    the read and write of each object model. It also has the `Transaction` attribute,
    which is used to control the transaction lifecycle. This class also has the `persist`
    method, which is used to write the data represented by the object model; the `begin`
    method, used to begin the transaction; the `load` method, used to read an object
    model's data; the `commit` method, used to commit the transaction; and finally,
    the `rollback` method, which is used to roll back the transaction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`PersistenceManager`类。这个类有一个`stateManagers`属性，它是一组`StateManager`，用于控制每个对象模型的读写。它还有一个`Transaction`属性，用于控制事务的生命周期。这个类还有一个`persist`方法，用于写入由对象模型表示的数据；`begin`方法，用于开始事务；`load`方法，用于读取对象模型的数据；`commit`方法，用于提交事务；最后，`rollback`方法，用于回滚事务。
- en: Implementing the EmployeeStoreManager class
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现EmployeeStoreManager类
- en: 'The `EmployeeStoreManager` class is responsible for connecting with the data
    source as well as reading and writing employee data:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeStoreManager`类负责与数据源连接以及读取和写入员工数据：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code block, we have the `EmployeeStoreManager` class, which
    is responsible for connecting with the data source and reading and writing employee
    data. This class works as a DAO and encapsulates all the data source complexity.
    It also has the `dataSource` attribute, which is a map that represents a data
    source. Furthermore, this class has the `storeNew` method, which is used to write
    new employee data represented by the object model. It also has the `update` method,
    used to write existing employee data represented by an object model. This method
    is used to update stored data. The `delete` method is also used to delete existing
    employee data, and the load method is used to read employee data in an object
    model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有`EmployeeStoreManager`类，该类负责与数据源连接以及读取和写入员工数据。这个类作为一个DAO工作，封装了所有的数据源复杂性。它还有一个`dataSource`属性，这是一个表示数据源的映射。此外，这个类有`storeNew`方法，用于写入由对象模型表示的新员工数据。它还有一个`update`方法，用于写入由对象模型表示的现有员工数据。此方法用于更新存储的数据。`delete`方法也用于删除现有员工数据，而`load`方法用于以对象模型读取员工数据。
- en: Implementing the StageManager interface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现StageManager接口
- en: '`StageManager` is an interface that is implemented by `EmployeeStageManager`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageManager`是一个接口，由`EmployeeStageManager`实现：'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code block, we have the `StageManager` interface. This interface
    is implemented by `EmployeeStageManager`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有`StageManager`接口。这个接口由`EmployeeStageManager`实现：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code block, we have the `isNew` attribute, which is used to
    define whether or not the object model is a new write (new data will be created
    on data source). The code also contains the `employee` attribute, which is the
    object model used to represent employee data. We can also see the `flush` method,
    used to execute the process for writing data on the data source; the `load` method,
    used to read data from the data source; the `updateEmployee` method, which is
    the private method used to update the `employee` attribute; and the `getEntity`
    method, which is used to return the `employee` attribute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们看到了`isNew`属性，用于定义对象模型是否为新的写入（将在数据源上创建新数据）。代码还包含`employee`属性，这是用于表示员工数据的对象模型。我们还可以看到`flush`方法，用于执行在数据源上写入数据的过程；`load`方法，用于从数据源读取数据；`updateEmployee`方法，这是一个私有方法，用于更新`employee`属性；以及`getEntity`方法，用于返回`employee`属性。
- en: Implementing the TransactionFactory class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现TransactionFactory类
- en: 'In the following code, we have the `Transactional` annotation, which is a `Qualifier` used
    to inject the `Transaction` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们看到了`Transactional`注解，这是一个`Qualifier`，用于注入`Transaction`类：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code block, we have the `TransactionFactory` class, which
    is responsible for creating new instances of the `Transaction` class. This class
    uses the `@Singleton` annotation, which is an EJB annotation used to create a
    singleton pattern with the Java EE mechanism. The `getTransaction` method has
    the `@Produces` annotation, used to define a method responsible for creating a
    new instance, and the `@Transactional` annotation, used as a qualify:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们看到了`TransactionFactory`类，该类负责创建`Transaction`类的新实例。这个类使用了`@Singleton`注解，这是一个用于通过Java
    EE机制创建单例模式的EJB注解。`getTransaction`方法有`@Produces`注解，用于定义一个负责创建新实例的方法，以及`@Transactional`注解，用作限定符：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing the Transaction class
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Transaction类
- en: 'The `Transaction` class is responsible for controlling the transaction lifecycle
    and defining the transaction delimit:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transaction`类负责控制事务生命周期和定义事务界限：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code block, we have the `Transaction` class, which is responsible
    for controlling the transaction lifecycle and defining the transaction delimit.
    This class has the `init()` method, annotated with `@PostConstruct`, which configures
    this method to be called after the constructor is executed. Furthermore, this
    class has the `commit` method, which is used when the user needs to confirm the
    transaction; the `rollback` method, used to undo all transactions; the `begin` method, used
    to open a transaction; and the `isOpened` method, which is used to verify whether
    a transaction is open or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们看到了`Transaction`类，该类负责控制事务生命周期和定义事务界限。这个类有`init()`方法，被`@PostConstruct`注解，配置该方法在构造函数执行后调用。此外，这个类还有`commit`方法，用于用户需要确认事务时；`rollback`方法，用于撤销所有事务；`begin`方法，用于开启事务；以及`isOpened`方法，用于验证事务是否开启。
- en: The transaction is closed if the `begin` method was not called or if the `commit`
    or `rollback` methods were called and a new call to the `begin` method was not
    made.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调用`begin`方法，或者调用了`commit`或`rollback`方法但没有再次调用`begin`方法，则事务将关闭。
- en: Implementing the EmployeeBusiness class
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现EmployeeBusiness类
- en: 'The `EmployeeBusiness` class has the employee business logic:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeBusiness`类包含员工业务逻辑：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code block, we have the `EmployeeBusiness` class, which has
    the employee business logic. This class has the `save(Employee)` method, which
    is used to save employee data, and `findById(Employee )`, which is used to find
    an employee according to their ID. Note that, on the `save` method, we call the
    `begin()` method as well as `commit()` from the `PersistenceManager` class. These
    calls define the delimiting of a transaction and only the data is saved at the
    data source when the `commit()` method is called.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们看到了`EmployeeBusiness`类，该类包含员工业务逻辑。这个类有`save(Employee)`方法，用于保存员工数据，以及`findById(Employee
    )`方法，用于根据ID查找员工。请注意，在`save`方法中，我们同时调用了`PersistenceManager`类的`begin()`和`commit()`方法。这些调用定义了事务的界限，并且只有在调用`commit()`方法时，数据才会被保存在数据源中。
- en: Explaining the concept of the service-activator pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释服务激活器模式的概念
- en: Suppose a client needs to request a business service, which is a process that
    takes a long time. In this case, the client should not wait in a synchronous way
    until the end of the process. Instead, there must be a way to make an asynchronous
    service call that does not block the client or user. This service can then be
    activated at some point in the future. There may be several reasons for the delay
    of a process. For example, there may be a database query that consumes a lot of
    time, or an access to a legacy system that is beyond the control of the current
    application. The pattern of asynchronously performing the required task is known
    as the service activator.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个客户端需要请求一个业务服务，这是一个耗时较长的过程。在这种情况下，客户端不应该以同步的方式等待过程结束。相反，必须有一种方法来进行异步服务调用，这样就不会阻塞客户端或用户。这个服务可以在未来的某个时刻被激活。过程延迟可能有几个原因。例如，可能有一个消耗大量时间的数据库查询，或者对当前应用程序控制之外的遗留系统的访问。异步执行所需任务的模式被称为服务激活器。
- en: So, the service activator pattern is always used when the client needs to call
    a service asynchronously. This means that the client makes the request and does
    not wait for the response.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当客户端需要异步调用服务时，总是使用服务激活器模式。这意味着客户端发出请求，并不等待响应。
- en: We can imagine some alternative solutions to this problem. One method would
    be to send the request to a queue, while another service would read the request
    from this queue and execute the task within it. Alternatively, when the client
    requests a service, this service could be placed in a database, and there could
    be a listener or a job that would check the tasks that had not yet been performed.
    If a task had not yet been performed, it would be executed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一些替代的解决方案来解决这个问题。一种方法是将请求发送到队列，而另一个服务将从这个队列中读取请求并在其中执行任务。或者，当客户端请求一个服务时，这个服务可以被放置在数据库中，并且可能有一个监听器或作业来检查尚未执行的任务。如果任务尚未执行，它将被执行。
- en: 'In fact, the JEE specification gives us very good solutions that are used to
    implement the service-activator pattern. These solutions are described as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，JEE规范为我们提供了非常好的解决方案，用于实现服务激活器模式。以下是对这些解决方案的描述：
- en: '**Java Message Service** (**JMS**)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java消息服务**（**JMS**）'
- en: EJB asynchronous methods
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB异步方法
- en: 'Asynchronous events: producers and observers'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步事件：生产者和观察者
- en: These three solutions were offered in the given order within the evolution of
    the JEE specification. We'll look at each of these solutions in more detail in
    the following sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个解决方案是在JEE规范演化的过程中按顺序提出的。在接下来的章节中，我们将更详细地探讨每个解决方案。
- en: Java Message Service (JMS)
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java消息服务（JMS）
- en: A **message-driven middleware** (**MOM**) is an architecture that uses message
    exchanges, which refers to sending and receiving messages, between the modules
    of an application or between distributed systems. The MOM provides some good services,
    such as message persistence or message-delivery guarantees. A message broker is
    based on a MOM, for instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息驱动中间件**（**MOM**）是一种使用消息交换的架构，这指的是在应用程序的模块之间或分布式系统之间发送和接收消息。MOM提供了一些良好的服务，例如消息持久性或消息投递保证。例如，消息代理基于MOM。'
- en: 'Java Message Service (JMS) is an application programming interface (API) that provides
    a MOM interface for clients who want an asynchronous process. JMS became part
    of the EJB technology in the EJB 2.0 specification and a new session bean was
    then introduced: the message-driven bean (MDB).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Java消息服务（JMS）是一个应用程序编程接口（API），为希望进行异步处理的客户端提供了一个消息中间件（MOM）接口。JMS成为EJB 2.0规范的一部分，并引入了一个新的会话Bean：消息驱动Bean（MDB）。
- en: An MDB bean is a stateless session bean that is used to listen to requests or
    objects arriving in a JMS queue. It is important to note that an MDB can implement
    any type of message, but it is more commonly used to handle JMS messages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MDB Bean是一个无状态的会话Bean，用于监听到达JMS队列的请求或对象。需要注意的是，MDB可以实现任何类型的消息，但它更常用于处理JMS消息。
- en: A message-driven bean listens to messages that have been sent to a queue or
    to a topic. However, we will only see the example of messages sent to a queue.
    Messages can be sent by any JEE component or by another application outside the
    JEE context.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动Bean监听发送到队列或主题的消息。然而，我们只将看到发送到队列的消息示例。消息可以由任何JEE组件或JEE上下文之外的应用程序发送。
- en: 'The following diagram shows the trajectory of a message, from being sent to
    being received by an MDB:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了消息的轨迹，从发送到由MDB接收：
- en: '![](img/9efb5305-626c-4b53-bc16-2c914ac468b4.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9efb5305-626c-4b53-bc16-2c914ac468b4.png)'
- en: 'Later in this chapter, we''ll see an example of the implementation of message
    producers and a message receiver. The receiver of the message will be implemented
    with an MDB. For now, we will quote some important items about the MDB. The MDB
    implementation has the following structure:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到一个消息生产者和消息接收器的实现示例。消息接收器将通过MDB实现。现在，我们将引用一些关于MDB的重要事项。MDB实现具有以下结构：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@MessageDriven` annotation sets the bean to be message-driven. In addition,
    the bean class must be public but cannot be abstract or final, and the class must
    contain a public constructor with no arguments.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`@MessageDriven`注解将bean设置为消息驱动的。此外，bean类必须是公共的，但不能是抽象的或最终的，并且类必须包含一个无参数的公共构造函数。'
- en: The `mappedName` attribute specifies the JNDI name of the JMS that will receive
    the message to be consumed. There are other attributes in the `@MessageDriven`
    annotation that are used to configure the bean. For example, the `activationConfig` attribute
    may contain an `@ActivationConfigProperty` annotation array that contains a key/value
    pair used to improve the bean's configuration.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`mappedName`属性指定了将接收要消费的消息的JMS的JNDI名称。`@MessageDriven`注解中还有其他属性用于配置bean。例如，`activationConfig`属性可能包含一个`@ActivationConfigProperty`注解数组，该数组包含一个键/值对，用于改进bean的配置。'
- en: The bean must implement the `MessageListener` interface, which has only one
    method, known as `onMessage`. This method is called by the container whenever
    the message is consumed by the MDB.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该bean必须实现`MessageListener`接口，该接口只有一个方法，称为`onMessage`。当消息被MDB消费时，容器会调用此方法。
- en: 'We can identify the following characteristics of an MDB:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别以下MDB的特征：
- en: It is not in the same transaction context as the message sender
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不在与消息发送者相同的事务上下文中
- en: It is not called directly by another session bean
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是由另一个会话bean直接调用的
- en: It can invoke other session beans
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以调用其他会话bean
- en: It can send JMS messages
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以发送JMS消息
- en: It does not have remote or local interfaces related to client access
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有与客户端访问相关的远程或本地接口
- en: EJB asynchronous methods
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB异步方法
- en: The EJB 3.1 specification incorporated asynchronous methods to session beans
    with the use of an `@javax.ejb.Asynchronous` annotation. Consequently, we can
    have asynchronous processing from a simple call to an EJB method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 3.1规范通过使用`@javax.ejb.Asynchronous`注解将异步方法纳入会话bean。因此，我们可以从对EJB方法的简单调用中获得异步处理。
- en: 'The `@javax.ejb.Asynchronous` annotation can be applied to a class of a session
    bean or applied to individual methods of this class. If applied to the entire
    class, all business methods of this bean are called asynchronously. Otherwise,
    only the methods with the annotation will be called asynchronously:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`@javax.ejb.Asynchronous`注解可以应用于会话bean的类或应用于此类中的单个方法。如果应用于整个类，则此bean的所有业务方法都将异步调用。否则，只有带有注解的方法才会异步调用：'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The second method returns an instance of `java.util.concurrent.Future`. With
    this object, the client can check whether the result has already arrived, or can
    even abort the task. However, the method returns immediately to the client thread
    and does not block the process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法返回一个`java.util.concurrent.Future`实例。通过此对象，客户端可以检查结果是否已经到达，甚至可以中止任务。然而，该方法会立即返回给客户端线程，并不会阻塞进程。
- en: Asynchronous events – producers and observers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步事件 - 生产者和观察者
- en: Another alternative that appeared on the evolutionary scale of the JEE platform
    was the event mechanism that is a part of the CDI specification. The mechanism
    is composed of producers and consumers of events, meaning that one component fires
    an event and another component of the application receives the event, acting as
    a listener or observer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在JEE平台演化的尺度上出现的另一个替代方案是CDI规范的一部分事件机制。该机制由事件的生产者和消费者组成，这意味着一个组件触发事件，而另一个应用组件接收事件，充当监听器或观察者。
- en: Up to the JEE8 specification, this event mechanism was done synchronously. With
    the introduction of CDI 2.0 in the JEE8 specification, the events API included
    improvements such as asynchronous use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在JEE8规范之前，此事件机制是同步执行的。随着JEE8规范中CDI 2.0的引入，事件API包括了异步使用等改进。
- en: 'The following diagram shows the asynchronous mechanism for sending and receiving
    events:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了发送和接收事件的异步机制：
- en: '![](img/d21d7a33-a943-4dbe-8ff5-11dd5852efde.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d21d7a33-a943-4dbe-8ff5-11dd5852efde.png)'
- en: 'Now, we will see the basics of how to implement the codes of a *producer* and
    an *observer* of an asynchronous event:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何实现异步事件的 *生产者* 和 *观察者* 代码的基本方法：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `someEvent` event is injected into the `SomeProducer` class, and the `Event.fireAsync()`
    method is responsible for the asynchronous event-firing. After some time, observers also receive
    the event asynchronously. The observer methods have parameters annotated with
    `@ObservesAsync`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`someEvent` 事件被注入到 `SomeProducer` 类中，`Event.fireAsync()` 方法负责异步事件触发。经过一段时间后，观察者也会异步地接收到事件。观察者方法具有带有
    `@ObservesAsync` 注解的参数。'
- en: Asynchronous observers are called in a new transaction context. However, they
    belong to the same security context as the invocation of `Event.fireAsync`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 异步观察者是在新的事务上下文中被调用的。然而，它们属于与 `Event.fireAsync` 调用相同的上下文安全。
- en: Implementing the service-activator pattern
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 service-activator 模式
- en: We are now going to show code examples of the three solutions offered by the
    Java EE platform.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示 Java EE 平台提供的三个解决方案的代码示例。
- en: Implementing sending and receiving messages with JMS
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JMS 发送和接收消息
- en: 'The following is an example of a JMS message sender. This is a CDI bean that
    is responsible for sending messages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 JMS 消息发送者的示例。这是一个负责发送消息的 CDI Bean：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `@JMSConnectionFactory` annotation indicates which `ConnectionFactory`
    should be used to create the `JMSContext`. The following code block shows an MDB
    that receives the message generated by the producer described earlier:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JMSConnectionFactory` 注解指示应该使用哪个 `ConnectionFactory` 来创建 `JMSContext`。以下代码块展示了一个接收前面描述的生产者生成的消息的
    MDB：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As previously mentioned, the `@MessageDriven` annotation converts a simple
    bean into an MDB. This annotation has many activation configuration properties,
    defined by the JMS specification. The two important properties shown in the example
    are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`@MessageDriven` 注解将一个简单的 Bean 转换为一个消息驱动 Bean (MDB)。此注解具有许多由 JMS 规范定义的激活配置属性。示例中显示的两个重要属性如下：
- en: '`destinationLookup`: The JNDI lookup name of the queue or topic'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationLookup`：队列或主题的 JNDI 查询名称'
- en: '`destinationType`: The queue type, `javax.jms.Queue` or `javax.jms.Topic`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationType`：队列类型，`javax.jms.Queue` 或 `javax.jms.Topic`'
- en: Similar to a stateless session bean, the container can make an instance pool
    to handle multiple messages. The `onMessage` method belongs to a single transaction
    context, and this context is propagated to the other methods invoked within `onMessage`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与无状态会话 Bean 类似，容器可以创建一个实例池来处理多个消息。`onMessage` 方法属于单个事务上下文，并且这个上下文会传播到 `onMessage`
    内部调用的其他方法。
- en: A `MessageDrivenContext` object can be injected into an MDB. This object provides
    access to the MDB context at runtime. We can, for example, roll back a transaction
    using the `setRollbackOnly()` method shown in the earlier mentioned example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `MessageDrivenContext` 对象注入到 MDB 中。此对象在运行时提供对 MDB 上下文的访问。例如，我们可以使用前面提到的示例中的
    `setRollbackOnly()` 方法回滚事务。
- en: Implementing the EJB asynchronous methods
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 EJB 异步方法
- en: 'The following code shows an example of a stateless EJB asynchronous method.
    Suppose there is a method responsible for approving and scheduling student test
    reviews and we want to call this method in an asynchronous way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了无状态 EJB 异步方法的示例。假设有一个负责批准和安排学生测试审查的方法，我们希望以异步方式调用此方法：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will look at a bean client that requests a test review service, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个 Bean 客户端，该客户端请求测试审查服务，如下所示：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Asynchronous methods can return `void`, or as an instance of `java.util.concurrent.Future
    <T>`. In the preceding example, the return is an instance of `Future <TestReview>`.
    The result of invoking the asynchronous method is returned immediately and there
    is no lock on the client thread. However, the client can consult this instance
    of `Future` at any time in order to check the result. The `TestReview` object
    contains information such as the Boolean type, whether or not the test review
    was approved, and the test review schedule date.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法可以返回 `void` 或 `java.util.concurrent.Future <T>` 的实例。在先前的示例中，返回的是一个 `Future
    <TestReview>` 的实例。异步方法的调用结果会立即返回，并且客户端线程没有锁。然而，客户端可以随时查询这个 `Future` 实例以检查结果。`TestReview`
    对象包含诸如布尔类型、测试审查是否被批准以及测试审查的日程日期等信息。
- en: Implementing asynchronous events – producers and observers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步事件 - 生产者和观察者
- en: 'Suppose a client wants to send emails to college students, inviting them to
    a science and technology seminar. And suppose that the emails that were sent generate
    statistical information for later analysis. In this case, the client does not
    need to wait for the answer immediately. We can make an event producer and two
    event observers: an observer responsible for sending the email itself and an observer
    responsible for statistical control. The two processes are independent of each
    other. The following code shows the producer and the two observers.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个客户想要向大学生发送电子邮件，邀请他们参加一个科技研讨会。并且假设发送的电子邮件会生成用于后续分析的统计数据。在这种情况下，客户不需要立即等待回复。我们可以创建一个事件生产者和两个事件观察者：一个负责发送电子邮件本身的观察者，另一个负责统计控制。这两个过程是相互独立的。以下代码展示了生产者和两个观察者。
- en: 'This is the `SeminarProducer` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SeminarProducer`类：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These are the two observers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个观察者：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the integration tier, as well as integration
    patterns and how they are implemented. The integration patterns that we learned
    about included the data-access object pattern, the domain-store pattern, and the
    service-activator pattern. We also learned about the implementations of these
    patterns. Furthermore, we learned about the concept of the data-access object
    pattern, as well as when and how to implement it using the best practices of Java
    EE 8\. We also learned about domain-store pattern concepts, the differences between
    the domain-store pattern and the data-access object pattern, and when and how
    to implement domain-store patterns. Finally, we learned about service-activator
    pattern concepts and when and how to implement this using JMS, EJB asynchronous
    methods, asynchronous event mechanisms, and the best practices of Java EE 8.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了集成层，以及集成模式和它们的实现方式。我们学习到的集成模式包括数据访问对象模式、领域存储模式和业务激活者模式。我们还学习了这些模式的实现。此外，我们学习了数据访问对象模式的概念，以及如何使用Java
    EE 8的最佳实践来实现它。我们还学习了领域存储模式的概念，领域存储模式与数据访问对象模式之间的区别，以及何时以及如何实现领域存储模式。最后，我们学习了业务激活者模式的概念，以及如何使用JMS、EJB异步方法、异步事件机制和Java
    EE 8的最佳实践来实现它。
- en: In the next chapter, we will cover reactive patterns, focusing on when to use
    them and how to implement them using best practices of Java EE 8.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍反应式模式，重点关注何时使用它们以及如何使用Java EE 8的最佳实践来实现它们。
