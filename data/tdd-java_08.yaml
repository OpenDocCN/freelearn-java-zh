- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Test Doubles – Stubs and Mocks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身——存根和模拟
- en: In this chapter, we’re going to solve a common testing challenge. How do you
    test an object that depends on another object? What do we do if that collaborator
    is difficult to set up with test data? Several techniques are available to help
    us with this and they build on the SOLID principles we learned previously. We
    can use the idea of dependency injection to enable us to replace collaborating
    objects with ones specially written to help us write our test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决一个常见的测试挑战。如何测试依赖于另一个对象的对象？如果那个协作者难以设置测试数据，我们该怎么办？有几种技术可以帮助我们做到这一点，并且它们建立在之前学到的SOLID原则之上。我们可以使用依赖注入的概念，使我们能够用专门编写来帮助我们编写测试的对象替换协作对象。
- en: These new objects are called test doubles, and we will learn about two important
    kinds of test double in this chapter. We will learn when to apply each kind of
    test double and then learn two ways of creating them in Java – both by writing
    the code ourselves and by using the popular library Mockito. By the end of the
    chapter, we will have techniques that allow us to write tests for objects where
    it is difficult or impossible to test them with the real collaborating objects
    in place. This allows us to use TDD with complex systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新对象被称为测试替身，在本章中我们将了解两种重要的测试替身。我们将学习何时应用每种类型的测试替身，然后学习两种在Java中创建它们的方法——既可以通过自己编写代码，也可以使用流行的库Mockito。到本章结束时，我们将拥有允许我们为难以或无法使用真实协作对象进行测试的对象编写测试的技术。这使我们能够在复杂系统中使用TDD。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The problems of testing collaborators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试协作者的问题
- en: The purpose of test doubles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试替身的目的
- en: Using stubs for pre-canned results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根来获取预定义的结果
- en: Using mocks to verify interactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟来验证交互
- en: Understanding when test doubles are appropriate
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用测试替身是合适的
- en: Working with Mockito – a popular mocking library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mockito——一个流行的模拟库
- en: Driving error handling code using stubs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根驱动错误处理代码
- en: Testing an error condition in Wordz
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wordz中测试错误条件
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter08](B18384_08.xhtml#_idTextAnchor177).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter08](B18384_08.xhtml#_idTextAnchor177)找到。
- en: The problems collaborators present for testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作者提出的测试问题
- en: In this section, we will understand the challenges that arise as we grow our
    software into a larger code base. We will review what is meant by a collaborating
    object, then we will take a look at two examples of collaborations that are challenging
    to test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解随着我们的软件发展成为更大的代码库时出现的挑战。我们将回顾协作对象的意义，然后我们将探讨两个具有挑战性的测试合作示例。
- en: As we grow our software system, we will soon outgrow what can go in a single
    class (or function, for that matter). We will split our code into multiple parts.
    If we pick a single object as our subject under test, any other object that it
    depends on is a collaborator. Our TDD tests must account for the presence of these
    collaborators. Sometimes, this is straightforward, as we’ve seen in earlier chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的软件系统的发展，我们很快就会超出单个类（或者函数）所能容纳的内容。我们将把代码分成多个部分。如果我们选择一个对象作为测试对象，那么它所依赖的任何其他对象都是协作者。我们的TDD测试必须考虑到这些协作者的存在。有时，这很简单，就像我们在前面的章节中看到的那样。
- en: Unfortunately, things aren’t always that simple. Some collaborations make tests
    difficult – or impossible – to write. These kinds of collaborators introduce either
    unrepeatable behaviors that we must contend with or present errors that are difficult
    to trigger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情并不总是那么简单。有些协作使测试变得困难——或者不可能——编写。这类协作者引入了我们必须应对的不可重复行为，或者呈现难以触发的错误。
- en: 'Let’s review these challenges with some short examples. We’ll start with a
    common problem: a collaborator that exhibits unrepeatable behavior.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些简短的例子来回顾这些挑战。我们将从一个常见问题开始：一个表现出不可重复行为的协作者。
- en: The challenges of testing unrepeatable behavior
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试不可重复行为的挑战
- en: We’ve learned that the basic steps of a TDD test are Arrange, Act, and Assert.
    We ask the object to act and then assert that an expected outcome happens. But
    what happens when that outcome is unpredictable?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到TDD测试的基本步骤是安排（Arrange）、行动（Act）和断言（Assert）。我们要求对象执行操作，然后断言预期的结果发生。但是，当结果不可预测时会发生什么呢？
- en: 'To illustrate, let’s review a class that rolls a die and presents a text string
    to say what we rolled:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们回顾一个掷骰子并显示文本字符串来说明我们掷了什么数字的类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is simple enough code, with only a handful of executable lines in it. Sadly,
    *simple to write is not always simple to test*. How would we write a test for
    this? Specifically – how would we write the assert? In previous tests, we’ve always
    known exactly what to expect in the assertion. Here, the assertion will be some
    fixed text plus a random number. We don’t know in advance what that random number
    will be.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单，只有几行可执行代码。遗憾的是，*编写简单并不意味着测试简单*。我们该如何为这个编写测试？具体来说——我们该如何编写断言？在之前的测试中，我们总是确切地知道在断言中期望什么。在这里，断言将是一些固定文本加上一个随机数。我们事先不知道那个随机数会是什么。
- en: The challenges of testing error handling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试错误处理的挑战
- en: Testing code that handles error conditions is another challenge. The difficulty
    here lies not in asserting that the error was handled, but rather the challenge
    is how to trigger that error to happen inside the collaborating object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试处理错误条件的代码是另一个挑战。这里的困难不在于断言错误已被处理，而挑战在于如何在协作对象内部触发该错误发生。
- en: 'To illustrate, let’s imagine a code to warn us when the battery in our portable
    device is getting low:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们想象一段代码，当我们的便携式设备中的电池电量低时，会提醒我们：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code in `BatteryMonitor` features a `DeviceApi` class, which
    is a library class that lets us read how much battery we have left on our phone.
    It provides a static method to do this, called `getBatteryPercentage()`. This
    will return an integer in the range *0* to *100* percent. The code that we want
    to write a TDD test for calls `getBatteryPercentage()` and will display a warning
    message if it is less than *10* percent. But there’s a problem writing this test:
    how can we force the `getBatteryPercentage()` method to return a number less than
    10 as part of our Arrange step? Would we discharge the battery somehow? How would
    we do this?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryMonitor`中的前一段代码包含一个`DeviceApi`类，这是一个库类，它允许我们读取手机上剩余的电量。它提供了一个静态方法来完成这个操作，称为`getBatteryPercentage()`。这将返回一个介于*0*到*100*百分比的整数。我们想要为编写TDD测试的代码调用`getBatteryPercentage()`，如果它小于*10*百分比，将显示警告信息。但编写这个测试有一个问题：我们如何在我们的安排步骤中强制`getBatteryPercentage()`方法返回一个小于10的数字？我们会以某种方式放电电池吗？我们该如何做？'
- en: '`BatteryMonitor` provides an example of code that collaborates with another
    object, where it is impossible to force a known response from that collaborator.
    We have no way to change the value that `getBatteryPercentage()` will return.
    We would literally have to wait until the battery had discharged before this test
    could pass. That’s not what TDD is about.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryMonitor`提供了一个例子，展示了与另一个对象协作的代码，其中我们无法强制该协作者给出已知响应。我们没有方法改变`getBatteryPercentage()`将返回的值。我们实际上必须等到电池放电后，这个测试才能通过。这并不是TDD的宗旨。'
- en: Understanding why these collaborations are challenging
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么这些协作具有挑战性
- en: When doing TDD, we want *fast* and *repeatable* tests. Any scenario that involves
    unpredictable behavior or requires us to control a situation that we have no control
    over clearly causes problems for TDD.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行TDD（测试驱动开发）时，我们希望测试是*快速*和*可重复*的。任何涉及不可预测行为或需要我们控制我们无法控制的情况的场景，都会给TDD带来明显的问题。
- en: The best way to write tests in these cases is by eliminating the cause of the
    difficulty. Fortunately, a simple solution exists. We can apply the *Dependency
    Injection Principle* we learned about in the previous chapter, along with one
    new idea – the *test double*. We will review test doubles in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下编写测试的最佳方式是消除困难的根源。幸运的是，有一个简单的解决方案。我们可以应用我们在上一章中学到的*依赖注入原则*，以及一个新想法——*测试替身*。我们将在下一节中回顾测试替身。
- en: The purpose of test doubles
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身的目的
- en: In this section, we’re going to learn techniques that allow us to test these
    challenging collaborations. We will introduce the idea of test doubles. We will
    learn how to apply the SOLID principles to design code flexible enough to use
    these test doubles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习允许我们测试这些具有挑战性的协作的技术。我们将介绍测试替身的概念。我们将学习如何将SOLID原则应用于设计足够灵活的代码，以便使用这些测试替身。
- en: The challenges of the previous section are solved by using **test doubles**.
    A test double replaces one of the collaborating objects in our test. By design,
    this test double avoids the difficulties of the replaced object. Think of them
    as the stunt doubles in movies, replacing the real actors to help safely get an
    action shot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**测试替身**解决了上一节中的挑战。测试替身替换了我们测试中的协作对象之一。按照设计，这个测试替身避免了被替换对象的困难。想想电影中的替身，他们取代了真正的演员，以帮助安全地拍摄动作镜头。
- en: A software test double is an object we have written specifically to be easy
    to use in our unit test. In the test, we inject our test double into the SUT in
    the Arrange step. In production code, we inject in the production object that
    our test double had replaced.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试替身是我们专门编写的一个对象，以便在单元测试中易于使用。在测试中，我们在安排步骤中将我们的测试替身注入到SUT中。在生产代码中，我们注入了测试替身所取代的生产对象。
- en: Let’s reconsider our `DiceRoll` example earlier. How would we refactor that
    code to make it easier to test?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新考虑之前的`DiceRoll`示例。我们将如何重构这段代码以使其更容易测试？
- en: 'Create an interface that abstracts the source of random numbers:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个抽象随机数来源的接口：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apply the *Dependency Inversion Principle* to `class DiceRoll` to make use
    of this abstraction:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*依赖倒置原则*应用于`class DiceRoll`以利用这个抽象：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have inverted the dependency on the random number generator by replacing
    it with the `RandomNumbers` interface. We added a constructor that allows a suitable
    `RandomNumbers` implementation to be injected. We assign that to the `rnd` field.
    The `asText()` method now calls the `nextInt()` method on whatever object we passed
    to the constructor.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过用`RandomNumbers`接口替换随机数生成器来反转了对随机数生成器的依赖。我们添加了一个构造函数，允许注入合适的`RandomNumbers`实现。我们将其分配给`rnd`字段。`asText()`方法现在调用我们传递给构造函数的任何对象的`nextInt()`方法。
- en: 'Write a test, using a test double to replace the `RandomNumbers` source:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用测试替身替换`RandomNumbers`来源的测试：
- en: '[PRE19]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We see the usual Arrange, Act, and Assert sections in this test. The new idea
    here is `class StubRandomNumbers`. Let’s look at the stub code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个测试中看到了常见的安排、行动和断言部分。这里的新想法是`class StubRandomNumbers`。让我们看看这个存根代码：
- en: '[PRE32]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are a few things to notice about this stub. Firstly, it implements our
    `RandomNumbers` interface, making it an LSP-compliant substitute for that interface.
    This allows us to inject it into the constructor of `DiceRoll`, our SUT. The second
    most important aspect is that every call to `nextInt()` will *return the* *same
    number*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个存根有一些需要注意的事情。首先，它实现了我们的`RandomNumbers`接口，使其成为该接口的LSP兼容替身。这允许我们将它注入到`DiceRoll`的构造函数中，我们的SUT。第二个最重要的方面是，每次对`nextInt()`的调用都将*返回相同的数字*。
- en: By replacing the real `RandomNumbers` source with a stub that delivers a known
    value, we have made our test assertion easy to write. The stub eliminates the
    problem of unrepeatable values from the random generator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用提供已知值的存根替换真实的`RandomNumbers`来源，我们已经使测试断言变得容易编写。存根消除了随机生成器不可重复值的问题。
- en: We can now see how the `DiceRollTest` works. We supply a test double to our
    SUT. The test double always returns the same value. As a result, we can assert
    against a known outcome.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到`DiceRollTest`是如何工作的。我们向我们的SUT提供一个测试替身。测试替身总是返回相同的值。因此，我们可以对已知结果进行断言。
- en: Making the production version of the code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作代码的生产版本
- en: 'To make `class DiceRoll` work properly in production, we would need to inject
    a genuine source of random numbers. A suitable class would be the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`class DiceRoll`在生产中正常工作，我们需要注入一个真正的随机数来源。一个合适的类可能是以下内容：
- en: '[PRE33]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There isn’t much work to do here – the preceding code simply implements the
    `nextInt()` method using the `RandomGenerator` library class built into Java.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多工作要做——前面的代码只是简单地使用内置在Java中的`RandomGenerator`库类实现了`nextInt()`方法。
- en: We can now use this to create our production version of the code. We already
    changed our `DiceRoll` class to allow us to inject in any suitable implementation
    of the `RandomNumbers` interface. For our test code, we injected in a test double
    – an instance of the `StubRandomNumbers` class. For our production code, we will
    instead inject in an instance of the `RandomlyGeneratedNumbers` class. The production
    code will use that object to create real random numbers – and there will be no
    code changes inside the `DiceRoll` class. We have used the Dependency Inversion
    Principle to make `class DiceRoll` configurable by dependency injection. This
    means that `class DiceRoll` now follows the Open/Closed Principle – it is *open*
    to new kinds of random number generation behavior but *closed* to code changes
    inside the class itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个方法来创建我们的代码生产版本。我们已经将我们的`DiceRoll`类修改为允许我们注入任何适合的`RandomNumbers`接口的实现。对于我们的测试代码，我们注入了一个测试替身——`StubRandomNumbers`类的实例。对于我们的生产代码，我们将注入`RandomlyGeneratedNumbers`类的实例。生产代码将使用该对象来创建真实的随机数——并且`DiceRoll`类内部将不会有任何代码更改。我们已经使用了依赖倒置原则，通过依赖注入使`DiceRoll`类可配置。这意味着`DiceRoll`类现在遵循开放/封闭原则——它对新类型的随机数生成行为是开放的，但对类内部的代码更改是封闭的。
- en: Dependency inversion, dependency injection, and inversion of control
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置、依赖注入和控制反转
- en: The preceding example shows these three ideas in action. *Dependency inversion*
    is the design technique where we create an abstraction in our code. *Dependency
    injection* is the runtime technique where we supply an implementation of that
    abstraction to code that depends on it. Together, these ideas are often termed
    **Inversion of Control** (**IoC**). Frameworks such as Spring are sometimes called
    IoC containers because they provide tools to help you manage creating and injecting
    dependencies in an application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了这三个想法的实际应用。*依赖倒置*是一种设计技术，我们在代码中创建一个抽象。*依赖注入*是一种运行时技术，我们向依赖于它的代码提供该抽象的实现。这两个想法通常被称为**控制反转**（**IoC**）。例如，Spring这样的框架有时被称为IoC容器，因为它们提供了帮助您管理在应用程序中创建和注入依赖项的工具。
- en: 'The following code is an example of how we would use `DiceRoll` and `RandomlyGeneratedNumbers`
    in production:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们在生产环境中使用`DiceRoll`和`RandomlyGeneratedNumbers`的示例：
- en: '[PRE34]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see in the previous code that we inject an instance of the production-version
    `RandomlyGeneratedNumbers` class into the `DiceRoll` class. This process of creating
    and injecting objects is often termed **object wiring**. Frameworks such as *Spring*
    ([https://spring.io/](B18384_08.xhtml#_idTextAnchor175)), *Google Guice* ([https://github.com/google/guice](B18384_08.xhtml#_idTextAnchor172)),
    and the built-in *Java CDI* ([https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html](B18384_08.xhtml#_idTextAnchor171))
    provide ways to minimize the boilerplate of creating dependencies and wiring them
    up, using annotations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从之前的代码中看到，我们将生产版本的`RandomlyGeneratedNumbers`类的实例注入到`DiceRoll`类中。创建和注入对象的过程通常被称为**对象配置**。例如，*Spring*（[https://spring.io/](B18384_08.xhtml#_idTextAnchor175)）、*Google
    Guice*（[https://github.com/google/guice](B18384_08.xhtml#_idTextAnchor172)）和内置的*Java
    CDI*（[https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html](B18384_08.xhtml#_idTextAnchor171)）等框架提供了使用注解来最小化创建依赖项和配置它们所需样板代码的方法。
- en: Using DIP to swap a production object for a test double is a very powerful technique.
    This test double is an example of a kind of double known as a stub. We’ll cover
    what a stub is along with when to use one in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖倒置原则来交换生产对象和测试替身是一个非常强大的技术。这个测试替身是一种称为存根的双面实例。在下一节中，我们将介绍存根是什么以及何时使用它。
- en: Using stubs for pre-canned results
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根进行预定义结果
- en: The previous section explained that test doubles were a kind of object that
    could stand in for a production object so that we could write a test more easily.
    In this section, we will take a closer look at that test double and generalize
    it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节解释了测试替身是一种可以替代生产对象的物体，这样我们就可以更容易地编写测试。在本节中，我们将更详细地研究这个测试替身并对其进行泛化。
- en: In the preceding `DiceRoll` example, the test was simpler to write because we
    replaced the random number generation with a known, fixed value. Our genuine random
    number generator made it difficult to write an assertion, as we were never sure
    what the expected random number should be. Our test double was an object that
    instead supplied a well-known value. We can then work out the expected value for
    our assertion, making our test easy to write.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `DiceRoll` 示例中，测试编写起来更简单，因为我们用已知、固定的值替换了随机数生成。我们的真实随机数生成器使得编写断言变得困难，因为我们从未确定预期的随机数应该是什么。我们的测试替身是一个提供已知值的对象。然后我们可以计算出断言的预期值，使测试易于编写。
- en: 'A test double that supplies values like this is called a **stub**. Stubs always
    replace an object that we cannot control with a test-only version that we can
    control. They always produce known data values for our code under test to consume.
    Graphically, a stub looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提供此类值的测试替身被称为 **存根**。存根总是用我们可以控制的测试版本替换我们无法控制的对象。它们总是为我们的测试代码提供已知的数据值。图形上，存根看起来像这样：
- en: '![Figure 8.1 – Replacing a collaborator with a stub](img/Figure_8.1_B18384.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 用存根替换协作者](img/Figure_8.1_B18384.jpg)'
- en: Figure 8.1 – Replacing a collaborator with a stub
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 用存根替换协作者
- en: In the diagram, our test class is responsible for wiring up our SUT to an appropriate
    stub object in the Arrange step. When the Act step asks our SUT to execute the
    code we want to test, that code will pull the known data values from the stub.
    The Assert step can be written based on the expected behavior that these known
    data values will cause.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们的测试类负责在 Arrange 步骤中将我们的系统单元（SUT）连接到适当的存根对象。当 Act 步骤要求我们的 SUT 执行我们想要测试的代码时，该代码将从存根中拉取已知的数据值。Assert
    步骤可以根据这些已知数据值将导致的行为来编写。
- en: It is important to note why this works. One objection to this arrangement is
    that we are not testing the real system. Our SUT is wired up to some object that
    will never be part of our production system. That is true. But this works because
    our test is only testing the logic within the SUT. This test is *not* testing
    the behavior of the dependencies themselves. Indeed, it must not attempt to do
    that. Testing the test double is a classic anti-pattern for unit tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意为什么这行得通。对这个安排的反对意见之一是我们没有测试真实的系统。我们的 SUT 连接到一些永远不会成为我们生产系统一部分的对象。这是真的。但这是因为我们的测试只测试
    SUT 内部的逻辑。这个测试**不是**测试依赖项的行为。实际上，它必须不尝试这样做。测试测试替身是单元测试的一个经典反模式。
- en: Our SUT has used the Dependency Inversion Principle to fully isolate itself
    from the object the stub is standing in for. It makes no difference to the SUT
    how it gets its data from its collaborator. That’s why this testing approach is
    valid.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SUT 已经使用依赖倒置原则完全隔离了自己，从存根所代表的对象中。对于 SUT 来说，它如何从其协作者那里获取数据没有区别。这就是为什么这种测试方法有效的原因。
- en: When to use stub objects
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用存根对象
- en: 'Stubs are useful whenever our SUT uses a *pull model* of collaborating with
    a dependency. Some examples of when using stubs makes sense are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 SUT 使用与依赖项协作的 *拉模型* 时，存根是有用的。以下是一些使用存根有意义的例子：
- en: '**Stubbing a repository interface/database**: Using a stub instead of calling
    to a real database for data access code'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根存储库接口/数据库**：使用存根而不是调用真实数据库进行数据访问代码'
- en: '**Stubbing reference data sources**: Replacing properties files or web services
    containing reference data with stub data'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根参考数据源**：用存根数据替换包含参考数据的属性文件或网络服务'
- en: '**Providing application objects to code that converts to HTML or JSON formats**:
    When testing code that converts to HTML or JSON, supply input data with a stub'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为将代码转换为 HTML 或 JSON 格式的代码提供应用程序对象**：当测试将代码转换为 HTML 或 JSON 时，用存根提供输入数据'
- en: '**Stubbing the system clock to test time-dependent behavior**: To get repeatable
    behavior out of a time call, stub the call with known times'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根系统时钟以测试时间依赖行为**：为了从时间调用中获得可重复的行为，用已知的时间存根调用'
- en: '**Stubbing random number generators to create predictability**: Replace a call
    to a random number generator with a call to a stub'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根随机数生成器以创建可预测性**：用一个存根的调用替换对随机数生成器的调用'
- en: '**Stubbing authentication systems to always allow a test user to log in**:
    Replace calls to authentication systems with simple “login succeeded” stubs'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根认证系统以始终允许测试用户登录**：用简单的“登录成功”存根替换对认证系统的调用'
- en: '**Stubbing responses from a third-party web service such as a payment provider**:
    Replace real calls to third-party services with calls to a stub'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从第三方网络服务（如支付提供者）中模拟响应**：将调用第三方服务的真实调用替换为对模拟的调用'
- en: '**Stubbing a call to an operating system command**: Replace a call to the OS
    to, for example, list a directory with pre-canned stub data'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟对操作系统命令的调用**：用预制的模拟数据替换对操作系统调用，例如列出目录'
- en: In this section, we have seen how using stubs allows us to control data that
    gets supplied to an SUT. It supports a *pull model* of fetching objects from elsewhere.
    But that’s not the only mechanism by which objects can collaborate. Some objects
    use a *push model*. In this case, when we call a method on our SUT, we expect
    it to call another method on some other object. Our test must confirm that this
    method call actually took place. This is something that stubs cannot help with
    and needs a different approach. We will cover this approach in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用存根来控制提供给SUT的数据。它支持从其他地方获取对象的*拉模型*。但这并不是唯一一种对象协作的机制。有些对象使用*推模型*。在这种情况下，当我们调用SUT上的方法时，我们期望它调用另一个对象上的方法。我们的测试必须确认这个方法调用确实发生了。这是存根无法帮助解决的问题，需要不同的方法。我们将在下一节中介绍这种方法。
- en: Using mocks to verify interactions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟来验证交互
- en: 'In this section, we’ll take a look at another important kind of test double:
    the mock object. Mock objects solve a slightly different problem than stub objects
    do, as we shall see in this section.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一种重要的测试替身：模拟对象。模拟对象解决的问题与存根对象略有不同，正如我们将在本节中看到的那样。
- en: '**Mock objects** are a kind of test double that *record interactions*. Unlike
    stubs, which supply well-known objects to the SUT, a mock will simply record interactions
    that the SUT has with the mock. It is the perfect tool to answer the question,
    “*Did the SUT call the method correctly?*” This solves the problem of *push model*
    interactions between the SUT and its collaborator. The SUT commands the collaborator
    to do something rather than requesting something from it. A mock provides a way
    to verify that it issued that command, along with any necessary parameters.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟对象**是一种测试替身，它能够*记录交互*。与提供已知对象给SUT的存根不同，模拟对象将简单地记录SUT与模拟对象之间的交互。这是回答“*SUT是否正确调用了方法？*”这一问题的完美工具。这解决了SUT与其协作者之间的*推送模型*交互问题。SUT命令协作者做某事，而不是从它那里请求某物。模拟提供了一种验证它是否发出了该命令以及任何必要参数的方法。'
- en: 'The following UML object diagram shows the general arrangement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的UML对象图显示了一般的安排：
- en: '![Figure 8.2 – Replace collaborator with mock](img/Figure_8.2_B18384.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 用模拟替换协作者](img/Figure_8.2_B18384.jpg)'
- en: Figure 8.2 – Replace collaborator with mock
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 用模拟替换协作者
- en: We see our test code wiring up a mock object to the SUT. The Act step will make
    the SUT execute code that we expect to interact with its collaborator. We have
    swapped out that collaborator for a mock, which will record the fact that a certain
    method was called on it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到测试代码将一个模拟对象连接到SUT。执行步骤将使SUT执行我们期望与它的协作者交互的代码。我们已经用模拟对象替换了那个协作者，该模拟对象将记录某个方法被调用的事实。
- en: 'Let’s look at a concrete example to make this easier to understand. Suppose
    our SUT is expected to send an email to a user. Once again, we will use the Dependency
    Inversion Principle to create an abstraction of our mail server as an interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来使这个问题更容易理解。假设我们的SUT预期向用户发送电子邮件。再次使用依赖倒置原则，将我们的邮件服务器抽象为一个接口：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code shows a simplified interface only suitable for sending a
    short text email. It is good enough for our purposes. To test the SUT that called
    the `sendEmail()` method on this interface, we would write a `MockMailServer`
    class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了一个简化的接口，仅适用于发送简短的文本电子邮件。对于我们的目的来说已经足够好了。为了测试调用此接口上的`sendEmail()`方法的SUT，我们将编写一个`MockMailServer`类：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding `MockMailServer` class implements the `MailServer` interface.
    It has a single responsibility – to record the fact that the `sendEmail()` method
    was called and to capture the actual parameter values sent to that method. It
    exposes these as simple fields with package-public visibility. Our test code can
    use these fields to form the assertion. Our test simply has to wire up this mock
    object to the SUT, cause the SUT to execute code that we expect to call the `sendEmail()`
    method, and then check that it did do that:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `MockMailServer` 类实现了 `MailServer` 接口。它只有一个职责——记录 `sendEmail()` 方法被调用的事实，并捕获发送给该方法的实际参数值。它将这些值以包公共可见性的简单字段形式暴露出来。我们的测试代码可以使用这些字段来形成断言。我们的测试只需将这个模拟对象连接到系统单元（SUT），让系统单元执行我们期望调用
    `sendEmail()` 方法的代码，然后检查它是否真的那样做了：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see that this test wires up the mock to our SUT, then causes the SUT
    to execute the `welcomeNewUser()` method. We expect this method to call the `sendEmail()`
    method on the `MailServer` object. Then, we need to write assertions to confirm
    that call was made with the correct parameter values passed. We’re using the idea
    of four assert statements logically here and testing one idea – effectively a
    single assert.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个测试将模拟对象连接到我们的系统单元（SUT），然后让系统单元执行 `welcomeNewUser()` 方法。我们期望这个方法在 `MailServer`
    对象上调用 `sendEmail()` 方法。然后，我们需要编写断言来确认调用确实使用了正确的参数值。我们在这里逻辑上使用了四个断言语句，测试了一个想法——实际上是一个单独的断言。
- en: The power of mock objects is that we can *record interactions* with objects
    that are difficult to control. In the case of a mail server, such as the one seen
    in the preceding code block, we would not want to be sending actual emails to
    anybody. We also would not want to write a test that waited around monitoring
    the mailbox of a test user. Not only is this slow and can be unreliable, but it
    is also not what we intend to test. The SUT only has the responsibility of making
    the call to `sendEmail()` – what happens after that is out of the scope of the
    SUT. It is, therefore, out of scope for this test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象的力量在于我们可以记录与难以控制的对象的交互。在邮件服务器的例子中，比如前面代码块中看到的，我们不想向任何人发送实际邮件。我们也不希望编写一个等待监控测试用户邮箱的测试。这不仅速度慢且可能不可靠，而且这也不是我们想要测试的内容。系统单元只负责调用
    `sendEmail()` 方法——之后发生的事情超出了系统单元的职责范围。因此，这也超出了这个测试的范围。
- en: As in the previous examples with other test doubles, the fact that we have used
    the `MailServer` that uses the SMTP protocol to talk to a real mail server. We
    would most likely search for a library class that does that for us already, then
    we would need to make a very simple adapter object that binds that library code
    to our interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前其他测试替身的例子一样，我们使用了使用 SMTP 协议与真实邮件服务器通信的 `MailServer`。我们很可能会寻找一个库类来为我们完成这项工作，然后我们需要创建一个非常简单的适配器对象，将库代码绑定到我们的接口上。
- en: This section has covered two common kinds of test double, stubs, and mocks.
    But test doubles are not always appropriate to use. In the next section, we’ll
    discuss some issues to be aware of when using test doubles.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已涵盖两种常见的测试替身类型，即存根和模拟。但测试替身并不总是适合使用。在下一节中，我们将讨论使用测试替身时应注意的一些问题。
- en: Understanding when test doubles are appropriate
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用测试替身是合适的
- en: Mock objects are a useful kind of test double, as we have seen. But they are
    not always the right approach. There are some situations where we should actively
    avoid using mocks. These situations include over-using mocks, using mocks for
    code you don’t own, and mocking value objects. We’ll look at these situations
    next. Then, we’ll recap with general advice for where mocks are typically useful.
    Let’s start by considering the problems caused when we overuse mock objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，模拟对象是一种有用的测试替身。但它们并不总是正确的做法。有些情况下，我们应该积极避免使用模拟。这些情况包括过度使用模拟、使用不属于你的代码的模拟，以及模拟值对象。我们将在下一节中探讨这些情况。然后，我们将总结一般性的建议，说明模拟通常在哪些情况下有用。让我们首先考虑过度使用模拟对象所引起的问题。
- en: Avoiding the overuse of mock objects
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免过度使用模拟对象
- en: At a first glance, using mock objects seems to solve a number of problems for
    us. Yet if used without care, we can end up with very poor-quality tests. To understand
    why, let’s go back to our basic definition of a TDD test. It is a test that verifies
    *behaviors* and is independent of *implementations*. If we use a mock object to
    stand in for a genuine abstraction, then we are complying with that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，使用模拟对象似乎能为我们解决许多问题。然而，如果不加注意地使用，我们可能会得到质量很差的测试。为了理解原因，让我们回顾一下TDD测试的基本定义。它是一种验证*行为*且与*实现*无关的测试。如果我们使用模拟对象来代替一个真正的抽象，那么我们就遵守了这一点。
- en: The potential problem happens because it is all too easy to create a mock object
    for an implementation detail, not an abstraction. If we do this, we end up locking
    our code into a specific implementation and structure. Once a test is coupled
    to a specific implementation detail, then changing that implementation requires
    a change to the test. If the new implementation has the same outcomes as the old
    one, the test really should still pass. Tests that depend on specific implementation
    details or code structures actively impede refactoring and adding new features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的问题发生是因为创建一个模拟对象来代替实现细节，而不是抽象，实在太容易了。如果我们这样做，我们最终会将我们的代码锁定在特定的实现和结构上。一旦测试与特定的实现细节耦合，那么更改该实现就需要更改测试。如果新的实现与旧的一个有相同的结果，那么测试实际上应该仍然通过。依赖于特定实现细节或代码结构的测试会积极阻碍重构和添加新功能。
- en: Don’t mock code you don’t own
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要模拟你拥有的代码
- en: Another area where mocks should not be used is as a stand-in for a concrete
    class written outside of your team. Suppose we are using a class called `PdfGenerator`
    from a library to create a PDF document. Our code would call methods on the `PdfGenerator`
    class. We might think it would be easy to test our code if we use a mock object
    to stand in for the `PdfGenerator` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不应该使用模拟的地方是作为你团队外部编写的具体类的替代品。假设我们正在使用一个名为`PdfGenerator`的库中的类来创建PDF文档。我们的代码会在`PdfGenerator`类上调用方法。我们可能会认为，如果我们使用模拟对象来代替`PdfGenerator`类，测试我们的代码会很容易。
- en: This approach has a problem that will only arise in the future. The class in
    the external library will quite likely change. Let’s say that the `PdfGenerator`
    class removes one of the methods our code is calling. We will be forced to update
    the library version at some point as part of our security policy if nothing else.
    When we pull in the new version, our code will no longer compile against this
    changed class – *but our tests will still pass because the mock object still has
    the old method in it*. This is a subtle trap that we have laid for future maintainers
    of the code. It is best avoided. A reasonable approach is to wrap the third-party
    library, and ideally place it behind an interface to invert the dependency on
    it, isolating it fully.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个问题，这个问题可能只会出现在未来。外部库中的类很可能发生变化。比如说，`PdfGenerator`类移除了我们代码中调用的一种方法。如果我们不更新库版本，那么根据我们的安全策略，我们最终被迫更新库版本。当我们引入新版本时，我们的代码将无法编译这个已更改的类——*但我们的测试仍然会通过，因为模拟对象中仍然有旧方法*。这是我们为代码的未来维护者设置的微妙陷阱。最好避免这种情况。一个合理的方法是包装第三方库，理想情况下将其放在接口后面，以反转对它的依赖，完全隔离它。
- en: Don’t mock value objects
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要模拟值对象
- en: A **value object** is an object that has no specific identity, it is defined
    only by the data it contains. Some examples would include an integer or a string
    object. We consider two strings to be the same if they contain the same text.
    They might be two separate string objects in memory, but if they hold the same
    value, we consider them to be equal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象**是一个没有特定身份的对象，它只由包含的数据定义。一些例子包括整数或字符串对象。我们认为两个字符串相同，如果它们包含相同的文本。它们可能在内存中是两个不同的字符串对象，但如果它们持有相同的值，我们认为它们是相等的。'
- en: The clue that something is a value object in Java is the presence of a customized
    `equals()` and `hashCode()` method. By default, Java compares the equality of
    two objects using their identity – it checks that two object references are referring
    to the same object instance in memory. We must override the `equals()` and `hashCode()`
    methods to provide the correct behavior for value objects, based on their content.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个对象是值对象的线索是存在自定义的`equals()`和`hashCode()`方法。默认情况下，Java使用对象的身份来比较两个对象的相等性——它检查两个对象引用是否指向内存中的相同对象实例。我们必须重写`equals()`和`hashCode()`方法，以根据其内容为值对象提供正确的行为。
- en: A value object is a simple thing. It may have some complex behaviors inside
    its methods but, in principle, value objects should be easy to create. There is
    no benefit in creating a mock object to stand in for one of these value objects.
    Instead, create the value object and use it in your test.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是一个简单的东西。它可能在方法内部有一些复杂的行为，但原则上，值对象应该很容易创建。创建一个模拟对象来代替这些值对象没有任何好处。相反，创建值对象并在测试中使用它。
- en: You can’t mock without dependency injection
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有依赖注入就无法模拟
- en: 'Test doubles can only be used where we can inject them. This is not always
    possible. If the code we want to test creates a concrete class using the `new`
    keyword, then we cannot replace it with a double:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身只能在我们可以注入它们的地方使用。这并不总是可能的。如果我们想要测试的代码使用`new`关键字创建了一个具体的类，那么我们就不能用它来替换一个替身：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We see that the `profiles` field has been initialized using a concrete class
    `UserProfilesPostgres()`. There is no direct way to inject a test double with
    this design. We could attempt to get around this, using Java Reflection, but it
    is best to consider this as TDD feedback on a limitation of our design. The solution
    is to allow the dependency to be injected, as we have seen in previous examples.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`profiles`字段已经使用具体的类`UserProfilesPostgres()`初始化。没有直接的方法可以注入测试替身。我们可以尝试使用Java反射来解决这个问题，但最好将其视为TDD对我们设计局限性的反馈。解决方案是允许依赖注入，正如我们在之前的例子中所看到的。
- en: This is often a problem with **legacy code**, which is simply code that has
    been written before we work on it. If this code has created concrete objects –
    and the code cannot be changed – then we cannot apply a test double.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是**遗留代码**的问题，这种代码是在我们工作之前编写的。如果这段代码创建了具体的对象——而且代码无法更改——那么我们就不能应用测试替身。
- en: Don’t test the mock
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要测试模拟
- en: '*Testing the mock* is a phrase used to describe a test with too many assumptions
    built into a test double. Suppose we write a stub that stands in for some database
    access, but that stub contains hundreds of lines of code to emulate detailed specific
    queries to that database. When we write the test assertions, they will all be
    based on those detailed queries that we emulated in the stub.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试模拟*是一个用来描述测试中在测试替身中构建了太多假设的短语。假设我们编写了一个存根来代替某些数据库访问，但这个存根包含数百行代码来模拟对数据库的详细特定查询。当我们编写测试断言时，它们都将基于我们在存根中模拟的这些详细查询。'
- en: That approach will prove that the SUT logic responds to those queries. But our
    stub now assumes a great deal about how the real data access code will work. The
    stub code and the real data access code can quickly get out of step. This results
    in an invalid unit test that passes but with stubbed responses that can no longer
    happen in reality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那种方法将证明SUT逻辑对这些查询有响应。但我们的存根现在对真实数据访问代码的工作方式做出了很多假设。存根代码和真实数据访问代码可能会很快失去同步。这会导致一个无效的单元测试通过，但带有存根响应，这些响应在现实中已不再可能发生。
- en: When to use mock objects
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用模拟对象
- en: 'Mocks are useful whenever our SUT is using a push model and requesting an action
    from some other component, where there is no obvious response such as the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的SUT使用推送模型并从其他组件请求操作时，其中没有明显的响应，模拟就很有用：
- en: Requesting an action from a remote service, such as sending an email to a mail
    server
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程服务请求操作，例如向邮件服务器发送电子邮件
- en: Inserting or deleting data from a database
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中插入或删除数据
- en: Sending a command over a TCP socket or serial interface
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TCP套接字或串行接口发送命令
- en: Invalidating a cache
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使缓存失效
- en: Writing logging information either to a log file or distributing logging endpoint
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志信息写入日志文件或分发日志端点
- en: We’ve learned some techniques in this section that allow us to verify that an
    action was requested. We have seen how we can use the Dependency Inversion Principle
    once again to allow us to inject a test double which we can query. We’ve also
    seen an example of hand-written code to do this. But must we always write test
    doubles by hand? In the next section, we will cover a very useful library that
    does most of the work for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些技术，这些技术允许我们验证是否请求了某个操作。我们看到了如何再次使用依赖倒置原则来允许我们注入一个可以查询的测试替身。我们还看到了一个手动编写代码的例子。但我们是否必须总是手动编写测试替身？在下一节中，我们将介绍一个非常有用的库，它可以为我们做大部分工作。
- en: Working with Mockito – a popular mocking library
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mockito – 一个流行的模拟库
- en: The previous sections have shown examples of using stubs and mocks to test code.
    We have been writing these test doubles by hand. It’s obviously quite repetitive
    and time-consuming to do this. It begs the question of if this repetitive boilerplate
    code can be automated away. Thankfully for us, it can. This section will review
    the help available in the popular Mockito library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节展示了使用存根和模拟来测试代码的示例。我们一直手动编写这些测试双胞胎。显然，这样做非常重复且耗时。这引发了一个问题：这种重复的样板代码是否可以自动化？幸运的是，它可以。本节将回顾在流行的
    Mockito 库中可用的帮助。
- en: Mockito is a free-of-charge open source library under the MIT license. This
    license means we can use this for commercial development work, subject to agreement
    by those we work for. Mockito provides a large range of features aimed at creating
    test doubles with very little code. The Mockito website can be found at [https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 是一个免费的开源库，遵循 MIT 许可证。这个许可证意味着我们可以在商业开发工作中使用它，前提是我们工作的人同意。Mockito 提供了大量的功能，旨在用很少的代码创建测试双胞胎。Mockito
    网站可在 [https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174) 找到。
- en: Getting started with Mockito
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Mockito
- en: Getting started with Mockito is straightforward. We pull in the `Mockito` library
    and an extension library in our Gradle file. The extension library allows `Mockito`
    to integrate closely with *JUnit5*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Mockito 很简单。我们在 Gradle 文件中引入 `Mockito` 库和一个扩展库。扩展库允许 `Mockito` 与 *JUnit5*
    紧密集成。
- en: 'The excerpt of `build.gradle` looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.gradle` 的摘录看起来像这样：'
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Writing a stub with Mockito
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mockito 编写存根
- en: Let’s see how Mockito helps us create a stub object. We’ll use TDD to create
    a `UserGreeting` class that delivers a personalized greeting, after fetching our
    nickname from `interface UserProfiles`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Mockito 如何帮助我们创建存根对象。我们将使用 TDD 来创建一个 `UserGreeting` 类，该类在从 `interface
    UserProfiles` 获取昵称后提供个性化的问候。
- en: 'Let’s write this using small steps, to see how TDD and Mockito work together:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分小步骤来写，看看 TDD 和 Mockito 如何协同工作：
- en: 'Write the basic JUnit5 test class and integrate it with Mockito:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写基本的 JUnit5 测试类并将其与 Mockito 集成：
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`@ExtendWith(MockitoExtension.class)` marks this test as using Mockito. When
    we run this JUnit5 test, the annotation ensures that the Mockito library code
    is run.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ExtendWith(MockitoExtension.class)` 标记这个测试使用 Mockito。当我们运行这个 JUnit5 测试时，该注解确保运行
    Mockito 库代码。'
- en: 'Add a test confirming the expected behavior. We will capture this in an assertion:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试来确认预期的行为。我们将通过断言来捕捉这一点：
- en: '[PRE46]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is standard usage of the *JUnit* and *AssertJ* frameworks as we have seen
    before. If we run the test now, it will fail.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看到的标准使用 *JUnit* 和 *AssertJ* 框架的方法。如果我们现在运行这个测试，它将会失败。
- en: 'Drive out our SUT – the class we want to write – with an Act step:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Act 步骤驱动我们的 SUT（我们想要编写的类）：
- en: '[PRE60]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This step drives out the two new production code classes, as shown in the following
    steps.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的步骤展示了如何驱动出两个新的生产代码类。
- en: 'Add a `class` `UserGreeting` skeleton:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `UserGreeting` 类的骨架：
- en: '[PRE78]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As usual, we add no code beyond what is required to make our test compile. The
    design decision captured here shows that our behavior is provided by a `formatGreeting()`method,
    which identifies a user by a `UserId` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们只添加必要的代码来使测试编译。这里捕捉到的设计决策显示，我们的行为是由一个 `formatGreeting()` 方法提供的，该方法通过
    `UserId` 类识别用户。
- en: 'Add a `class` `UserId` skeleton:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `UserId` 类的骨架：
- en: '[PRE84]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Again, we get an empty shell just to get the test to compile. Then, we run
    the test and it still fails:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只添加了使测试编译的空壳。然后，我们运行测试，它仍然会失败：
- en: '![Figure 8.3 – Test failure](img/Figure_8.3_B18384.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 测试失败](img/Figure_8.3_B18384.jpg)'
- en: Figure 8.3 – Test failure
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 测试失败
- en: 'Another design decision to capture is that the `UserGreeting` class will depend
    on a `UserProfiles` interface. We need to create a field, create the interface
    skeleton, and inject the field in a new constructor for the SUT:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个需要捕捉的设计决策是，`UserGreeting` 类将依赖于 `UserProfiles` 接口。我们需要创建一个字段，创建接口骨架，并在 SUT
    的新构造函数中注入该字段：
- en: '[PRE89]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We continue by adding the bare minimum code to get the test to compile. If
    we run the test, it will still fail. But we’ve progressed further so the failure
    is now an `UnsupportedOperationException` error. This confirms that `formatGreeting()`
    has been called:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续添加最少的代码来使测试编译。如果我们运行测试，它仍然会失败。但我们已经取得了进一步进展，所以现在的失败是一个 `UnsupportedOperationException`
    错误。这证实了 `formatGreeting()` 已经被调用：
- en: '![Figure 8.4 – Failure confirms method call](img/Figure_8.4_B18384.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 方法调用失败确认](img/Figure_8.4_B18384.jpg)'
- en: Figure 8.4 – Failure confirms method call
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 失败确认方法调用
- en: 'Add behavior to the `formatGreeting()` method:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`formatGreeting()`方法添加行为：
- en: '[PRE109]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Add `fetchNicknameFor()` to the `UserProfiles` interface:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fetchNicknameFor()`添加到`UserProfiles`接口中：
- en: '[PRE120]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the test. It will fail with a null exception:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。它将因空指针异常而失败：
- en: '![Figure 8.5 – Null exception failure](img/Figure_8.5_B18384.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 空指针异常失败](img/Figure_8.5_B18384.jpg)'
- en: Figure 8.5 – Null exception failure
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 空指针异常失败
- en: The test fails because we passed the `profiles` field as a dependency into our
    SUT, but that field has never been initialized. This is where Mockito comes into
    play (finally).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为我们将`profiles`字段作为依赖传递给了我们的系统单元(SUT)，但该字段从未被初始化。这就是Mockito发挥作用的地方（终于）。
- en: 'Add the `@Mock` annotation to the `profiles` field:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@Mock`注解添加到`profiles`字段：
- en: '[PRE124]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Running the test now produces a different failure, as we have not yet configured
    the Mockito mock:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试会产生不同的失败，因为我们还没有配置Mockito的mock：
- en: '![Figure 8.6 – Added mock, not configured](img/Figure_8.6_B18384.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 添加了mock，但未配置](img/Figure_8.6_B18384.jpg)'
- en: Figure 8.6 – Added mock, not configured
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 添加了mock，但未配置
- en: 'Configure `@Mock` to return the correct stub data for our test:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`@Mock`以返回正确的存根数据供测试使用：
- en: '[PRE144]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If you run the test again, it will fail due to a mistake in the greeting text.
    Fix this and then re-run the test, and it will pass:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次运行测试，它将因问候文本中的错误而失败。修复这个问题然后重新运行测试，它将通过：
- en: '![Figure 8.7 – Test pass](img/Figure_8.7_B18384.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 测试通过](img/Figure_8.7_B18384.jpg)'
- en: Figure 8.7 – Test pass
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 测试通过
- en: We’ve just created `class UserGreeting`, which accesses some stored nicknames
    for the user, via `interface UserProfiles`. That interface used DIP to isolate
    `UserGreeting` from any implementation details of that store. We used a stub implementation
    to write the test. We’ve followed TDD and leveraged Mockito to write that stub
    for us.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了`class UserGreeting`，它通过`interface UserProfiles`访问用户的某些存储昵称。该接口使用了DIP（依赖倒置原则）来隔离`UserGreeting`与存储实现的任何具体细节。我们使用存根实现来编写测试。我们遵循了TDD（测试驱动开发）并利用Mockito为我们编写了这个存根。
- en: You’ll also notice that the test failed in the final step. I expected that step
    to pass. It didn’t because I had typed the greeting message incorrectly. Once
    again, TDD came to my rescue.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到在最后一步测试失败了。我预期这一步应该通过。它没有通过是因为我错误地输入了问候信息。再次，TDD救了我。
- en: Writing a mock with Mockito
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mockito编写mock
- en: Mockito can create mock objects just as easily as stubs. We can still use the
    `@Mock` annotation on a field we wish to become a mock – perhaps making sense
    of the annotation, at last. We use the Mockito `verify()` method to check that
    our SUT called an expected method on a collaborator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito可以像创建存根一样轻松地创建mock对象。我们仍然可以在希望成为mock的字段上使用`@Mock`注解——也许最后终于理解了这个注解。我们使用Mockito的`verify()`方法来检查我们的SUT是否正确地调用了一个协作者的预期方法。
- en: 'Let’s look at how a mock is used. We’ll write a test for some SUT code that
    we expect to send an email via `MailServer`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用mock。我们将为一些预期通过`MailServer`发送电子邮件的SUT代码编写一个测试：
- en: '[PRE168]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In this test, we see the `@ExtendWith(MockitoExtension.class)` annotation to
    initialize Mockito, and the familiar Arrange, Act and Assert format of our test
    method. The new idea here is in the assertion. We use the `verify()` method from
    the Mockito library to check that the `sendEmail()` method was called correctly
    by our SUT. The check also verifies that it was called with the correct parameter
    values.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们看到`@ExtendWith(MockitoExtension.class)`注解用于初始化Mockito，以及我们测试方法中熟悉的安排（Arrange）、行动（Act）和断言（Assert）格式。这里的新想法在于断言。我们使用Mockito库中的`verify()`方法来检查我们的SUT是否正确地调用了`sendEmail()`方法。检查还验证了它是否使用了正确的参数值。
- en: Mockito uses code generation to achieve all this. It wraps the interface we
    labeled with the `@Mock` annotation and intercepts each and every call. It stores
    parameter values for each call. When we come to using the `verify()` method to
    confirm that the method was called correctly, Mockito has all the data it needs
    to do this.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito使用代码生成来实现所有这些。它包装了我们用`@Mock`注解标记的接口，并拦截每个调用。它为每个调用存储参数值。当我们使用`verify()`方法来确认方法是否正确调用时，Mockito拥有完成这项工作所需的所有数据。
- en: Beware Mockito’s when() and verify() syntax!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕Mockito的when()和verify()语法！
- en: 'Mockito has subtly different syntax for `when()` and `verify()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito对`when()`和`verify()`的语法有细微的差别：
- en: '* `when(``).thenReturn(expected value);`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '* `when().thenReturn(expected value);`'
- en: '* `verify(``).method();`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '* `verify().method();`'
- en: Blurring the distinction between stubs and mocks
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊存根和mock之间的区别
- en: One thing to note about Mockito terminology is that it blurs the distinction
    between a stub and a mock object. In Mockito, we create test doubles that are
    labeled as mock objects. But in our test, we can use these doubles as either a
    stub, a mock, or even a mixture of both.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Mockito术语的一个需要注意的事项是，它模糊了存根和模拟对象之间的区别。在Mockito中，我们创建被标记为模拟对象的测试替身。但在我们的测试中，我们可以将这些替身用作存根、模拟，甚至两者的混合体。
- en: Setting up a test double to be both a stub and a mock is a test code smell.
    It’s not wrong, but it’s worth a pause for thought. We should consider if the
    collaborator that we are both mocking and stubbing has mixed up some responsibilities.
    It may be beneficial to split that object up.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试替身配置为既是存根又是模拟是一种测试代码的坏味道。这并不错，但值得停下来思考。我们应该考虑我们既模拟又存根的协作者是否混淆了一些职责。将那个对象拆分出来可能是有益的。
- en: Argument matchers – customizing behavior of test doubles
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数匹配器 - 定制测试替身的行为
- en: So far, we have configured Mockito test doubles to respond to very specific
    inputs to the methods they replace. The previous MailServer example checked for
    three specific parameter values being passed to the `sendEmail()` method call.
    But we sometimes want more flexibility in our test doubles.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了Mockito测试替身来响应它们所替代的方法的非常具体的输入。之前的MailServer示例检查了三个特定的参数值是否传递给了`sendEmail()`方法调用。但有时我们希望在测试替身中拥有更多的灵活性。
- en: Mockito provides library methods called argument matchers. These are static
    methods that are used inside `when()` and `verify()` statements. Argument matchers
    are used to instruct Mockito to respond to a range of parameter values – including
    nulls and unknown values – that might get passed into a method under test.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito提供了一些称为参数匹配器的库方法。这些是在`when()`和`verify()`语句内部使用的静态方法。参数匹配器用于指示Mockito对可能传递给被测试方法的参数值范围（包括null和未知值）做出响应。
- en: 'The following test uses an argument matcher that accepts any value of `UserId`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试使用了一个接受任何`UserId`值的参数匹配器：
- en: '[PRE169]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: We’ve added an `any()` argument matcher to the stubbing of the `fetchNicknameFor()`
    method. This instructs Mockito to return the expected value `Alan` no matter what
    parameter value is passed into `fetchNicknameFor()`. This is useful when writing
    tests to guide our readers and help them to understand what is important and what
    is not for a particular test.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`any()`参数匹配器添加到了`fetchNicknameFor()`方法的存根中。这指示Mockito无论传递给`fetchNicknameFor()`的参数值是什么，都返回预期的值`Alan`。这在编写测试以引导读者并帮助他们理解特定测试中什么重要、什么不重要时非常有用。
- en: Mockito offers a number of argument matchers, described in the Mockito official
    documentation. These argument matchers are especially useful when creating a stub
    to simulate an error condition. This is the subject of the next section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito提供了一系列参数匹配器，这些匹配器在Mockito官方文档中有描述。这些参数匹配器在创建用于模拟错误条件的存根时特别有用。这是下一节的主题。
- en: Driving error handling code with tests
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试驱动错误处理代码
- en: In this section, we’re going to look into a great use of stub objects, which
    is their role in testing error conditions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨存根对象的一个很好的用途，即它们在测试错误条件中的作用。
- en: As we create our code, we need to ensure that it handles error conditions well.
    Some error conditions are easy to test. An example might be a user input validator.
    To test that it handles the error caused by invalid data, we simply write a test
    that feeds it invalid data and then write an assertion to check it successfully
    reported the data was invalid. But what about the code that uses it?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写代码的过程中，我们需要确保它能够很好地处理错误条件。一些错误条件很容易测试。一个例子可能是一个用户输入验证器。为了测试它处理无效数据引起的错误，我们只需编写一个测试，向它提供无效数据，然后编写一个断言来检查它是否成功报告了数据无效。但使用它的代码怎么办呢？
- en: If our SUT is code that responds to an error condition raised by one of its
    collaborators, we need to test that error response. How we test it depends on
    the mechanism we chose to report that error. We may be using a simple status code,
    in which case returning that error code from a stub will work very well.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的系统单元（SUT）是响应其协作者引发的错误条件的代码，我们需要测试那个错误响应。我们如何测试它取决于我们选择报告错误的方式。我们可能使用一个简单的状态码，在这种情况下，从存根返回那个错误代码将非常有效。
- en: We may also have chosen to use Java exceptions to report this error. Exceptions
    are controversial. If misused, they can lead to very unclear control flow in your
    code. We need to know how to test them, however, as they appear in several Java
    libraries and in-house coding styles. Fortunately, there’s nothing difficult about
    writing the test for exception-handling code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能选择使用 Java 异常来报告这个错误。异常是有争议的。如果误用，它们可能导致代码中的控制流非常不清楚。然而，我们需要知道如何测试它们，因为它们出现在几个
    Java 库和内部编码风格中。幸运的是，编写异常处理代码的测试并不困难。
- en: 'We start with creating a stub, using any of the approaches covered in this
    chapter. We then need to arrange for the stub to throw the appropriate exception
    when we call a method. Mockito has a nice feature to do this, so let’s see an
    example Mockito test that uses exceptions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个存根开始，可以使用本章中介绍的任何方法。然后我们需要安排存根在调用方法时抛出适当的异常。Mockito 有一个很好的功能可以实现这一点，所以让我们看看一个使用异常的示例
    Mockito 测试：
- en: '[PRE170]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: At the start of this test, we use Mockito `doThrow()` to configure our mock
    object. This configures the Mockito mock object `mailServer` to throw `IllegalArgumentException`
    whenever we call `sendEmail()`, no matter what parameter values we send. This
    reflects a design decision to make `sendEmail()` throw that exception as a mechanism
    to report that the email address was not valid. When our SUT calls `mailServer.sendEmail()`,
    that method will throw `IllegalArgumentExeption`. We can exercise the code that
    handles this.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试的开始阶段，我们使用 Mockito 的 `doThrow()` 方法来配置我们的模拟对象。这会将 Mockito 模拟对象 `mailServer`
    配置为在调用 `sendEmail()` 方法时抛出 `IllegalArgumentException` 异常，无论我们发送什么参数值。这反映了设计决策，即通过抛出该异常作为报告电子邮件地址无效的机制。当我们的系统单元测试（SUT）调用
    `mailServer.sendEmail()` 方法时，该方法将抛出 `IllegalArgumentExeption` 异常。我们可以练习处理这个异常的代码。
- en: For this example, we decided to make the SUT wrap and rethrow `IllegalArgumentException`.
    We choose to create a new exception that relates to the responsibility of user
    notifications. We will call it `NotificationFailureException`. The assertion step
    of the test then uses the AssertJ library feature `assertThatExceptionOfType()`.
    This performs the Act and Assert steps together. We call our SUT `welcomeNewUser()`
    method and assert that it throws our `NotificationFailureException` error.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们决定让 SUT 包装并重新抛出 `IllegalArgumentException`。我们选择创建一个与用户通知责任相关的新异常。我们将称之为
    `NotificationFailureException`。测试的断言步骤使用 AssertJ 库的特性 `assertThatExceptionOfType()`。这同时执行了
    Act 和 Assert 步骤。我们调用我们的 SUT `welcomeNewUser()` 方法，并断言它抛出了我们的 `NotificationFailureException`
    错误。
- en: We can see how this is enough to trigger the exception-handling response in
    our SUT code. This means we can write our test and then drive out the required
    code. The code we write will include a catch handler for `InvalidArgumentException`.
    In this case, all the new code has to do is throw a `NotificationFailureException`
    error. This is a new class that we will create that extends `RuntimeException`.
    We do this to report that something went wrong by sending a notification. As part
    of normal system layering considerations, we want to replace the original exception
    with a more general one, which is better suited to this layer of code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这足以触发我们的 SUT 代码中的异常处理响应。这意味着我们可以先编写测试，然后驱动出所需的代码。我们编写的代码将包括一个用于处理 `InvalidArgumentException`
    的捕获处理程序。在这种情况下，所有新的代码必须做的就是抛出一个 `NotificationFailureException` 错误。这是一个我们将创建的新类，它继承自
    `RuntimeException`。我们这样做是为了通过发送通知来报告出错了。作为正常系统分层考虑的一部分，我们希望用更通用的异常替换原始异常，这对于这一层代码来说更为合适。
- en: This section has examined features of Mockito and AssertJ libraries that help
    us use TDD to drive out exception-handling behavior. In the next section, let’s
    apply this to an error in our Wordz application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了 Mockito 和 AssertJ 库的特性，这些特性帮助我们使用 TDD 来驱动异常处理行为。在下一节中，我们将将这些内容应用到 Wordz
    应用程序中的错误处理上。
- en: Testing an error condition in Wordz
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Wordz 中的错误条件
- en: In this section, we will apply what we’ve learned by writing a test for a class
    that will choose a random word for the player to guess, from a stored set of words.
    We will create an interface called `WordRepository` to access stored words. We
    will do this through a `fetchWordByNumber(wordNumber)` method, where `wordNumber`
    identifies a word. The design decision here is that every word is stored with
    a sequential number starting from *1* to help us pick one at random.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过编写一个测试来应用我们所学的知识，该测试将为玩家选择一个随机单词进行猜测，从存储的单词集中。我们将创建一个名为`WordRepository`的接口来访问存储的单词。我们将通过一个`fetchWordByNumber(wordNumber)`方法来实现，其中`wordNumber`标识一个单词。在这里的设计决策是，每个单词都存储了一个从*1*开始的顺序号，以帮助我们随机选择一个。
- en: We will be writing a `WordSelection` class, which is responsible for picking
    a random number and using that to fetch a word from storage that is tagged with
    that number. We will be using our `RandomNumbers` interface from earlier. For
    this example, our test will cover the case where we attempt to fetch a word from
    the `WordRepository` interface, but for some reason, it isn’t there.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个`WordSelection`类，该类负责选择一个随机数，并使用该数从存储中检索带有该数字的单词。我们将使用之前提到的`RandomNumbers`接口。对于这个例子，我们的测试将覆盖尝试从`WordRepository`接口中检索单词，但出于某种原因，它不在那里的情况。
- en: 'We can write the test as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式编写测试：
- en: '[PRE171]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The test captures a few more design decisions relating to how we intend `WordRepository`
    and `WordSelection` to work. Our `fetchWordByNumber(wordNumber)` repository method
    will throw `WordRepositoryException` if there are any problems retrieving the
    word. Our intention is to make `WordSelection` throw its own custom exception
    to report that it cannot complete the `getRandomWord()` request.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 测试捕捉了更多与如何设计`WordRepository`和`WordSelection`工作相关的决策。我们的`fetchWordByNumber(wordNumber)`存储库方法在检索单词时遇到任何问题都会抛出`WordRepositoryException`。我们的意图是让`WordSelection`抛出它自己的自定义异常来报告它无法完成`getRandomWord()`请求。
- en: To set this situation up in the test, we first arrange for the repository to
    throw. This is done using the Mockito `doThrow()` feature. Whenever the `fetchWordByNumber()`
    method is called, whatever parameter we pass into it Mockito will throw the exception
    we asked it to throw, which is `WordRepositoryException`. This allows us to drive
    out the code that handles this error condition.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试中设置这种情况，我们首先安排存储库抛出异常。这是通过使用Mockito的`doThrow()`功能来完成的。每当调用`fetchWordByNumber()`方法时，Mockito都会抛出我们请求它抛出的异常，即`WordRepositoryException`。这允许我们驱动出处理这种错误条件的代码。
- en: 'Our Arrange step is completed by creating the `WordSelection` SUT class. We
    pass in two collaborators to the constructor: the `WordRepository` instance and
    a `RandomNumbers` instance. We have asked Mockito to create stubs for both interfaces
    by adding the `@Mock` annotation to test double the `repository` and `random`
    fields.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“安排”步骤是通过创建`WordSelection` SUT类来完成的。我们将两个协作者传递给构造函数：`WordRepository`实例和一个`RandomNumbers`实例。我们已经要求Mockito通过在测试双重的`repository`和`random`字段上添加`@Mock`注解来为这两个接口创建存根。
- en: With the SUT now properly constructed, we are ready to write the Act and Assert
    steps of the test. We are testing that an exception is thrown, so we need to use
    the `assertThatExceptionOfType()` AssertJ facility to do this. We can pass in
    the class of the exception that we are expecting to be thrown, which is `WordSelectionException`.
    We chain the `isThrownBy()` method to perform the Act step and make our SUT code
    run. This is provided as a Java lambda function as a parameter to the `isThrownBy()`
    method. This will call the `getRandomWord()` method, which we intend to fail and
    throw an exception. The assertion will confirm that this has happened and that
    the expected kind of exception class has been thrown. We will run the test, see
    it fail, and then add the necessary logic to make the test pass.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在SUT已经正确构建，我们准备编写测试的“执行”和“断言”步骤。我们正在测试是否抛出异常，因此我们需要使用`assertThatExceptionOfType()`
    AssertJ功能来完成。我们可以传递我们期望抛出的异常的类，即`WordSelectionException`。我们将`isThrownBy()`方法链接到执行步骤并运行SUT代码。这作为Java
    lambda函数的参数传递给`isThrownBy()`方法。这将调用`getRandomWord()`方法，我们希望它失败并抛出异常。断言将确认这已经发生，并且已经抛出了预期的异常类。我们将运行测试，看到它失败，然后添加必要的逻辑使测试通过。
- en: The test code shows us that we can use test doubles and verification of error
    conditions with test-first TDD. It also shows that tests can become easily coupled
    to a specific implementation of a solution. There are a lot of design decisions
    in this test about which exceptions happen and where they are used. These decisions
    even include the fact that exceptions are being used at all to report errors.
    All that said, this is still a reasonable way to split responsibilities and define
    contracts between components. It is all captured in the test.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码向我们展示了我们可以使用测试双倍和错误条件验证与测试驱动开发（TDD）相结合。它还表明，测试可以轻易地与解决方案的特定实现耦合。在这个测试中有很多设计决策，包括哪些异常会发生以及它们在哪里被使用。这些决策甚至包括使用异常来报告错误的事实。尽管如此，这仍然是一种合理的方式来划分责任和定义组件之间的契约。所有这些都包含在测试中。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve looked at how to solve the problem of testing problematic
    collaborators. We have learned how to use stand-in objects for collaborators called
    test doubles. We’ve learned that this gives us simple control over what those
    collaborators do inside our test code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何解决测试有问题的协作者的问题。我们学习了如何使用称为测试双倍的替代对象来测试协作者。我们了解到，这使我们能够简单地控制那些协作者在测试代码中的行为。
- en: 'Two kinds of test double are especially useful to us: the stub and the mock.
    Stubs return data. Mocks verify that methods were called. We’ve learned how to
    use the Mockito library to create stubs and mocks for us.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 两种测试双倍（test double）对我们特别有用：存根（stub）和模拟（mock）。存根返回数据。模拟验证方法是否被调用。我们已经学会了如何使用Mockito库为我们创建存根和模拟。
- en: We’ve used AssertJ to verify the SUT behaved correctly under the various conditions
    of our test doubles. We’ve learned how to test error conditions that throw exceptions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用AssertJ验证了SUT在各种测试双倍条件下的行为是否正确。我们已经学会了如何测试抛出异常的错误条件。
- en: These techniques have expanded our toolkit for writing tests.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术扩展了我们的测试工具集。
- en: In the next chapter, we are going to cover a very useful system design technique
    that allows us to get most of our code under FIRST unit test, and at the same
    time avoid the problems of testing collaborations with external systems that we
    cannot control.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个非常有用的系统设计技术，它允许我们在FIRST单元测试中获取大部分代码，同时避免测试外部系统协作时无法控制的问题。
- en: Questions and answers
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Are the terms stub and mock used interchangeably?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存根和模拟这两个术语可以互换使用吗？
- en: Yes, even though they have different meanings. In normal conversation, we tend
    to trade precision for fluency, and that’s okay. It’s important to understand
    the different uses that each kind of test double has. When speaking, it’s usually
    better to not be pedantic whenever a group of people knows what is meant. So long
    as we stay aware that a test double is the proper general term and that the specific
    types of doubles have different roles, all will be well.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，尽管它们有不同的含义。在正常对话中，我们倾向于为了流畅性而牺牲精确性，这是可以接受的。了解每种测试双倍的不同用途很重要。在说话时，通常最好是在一群人知道意思的情况下不要过于拘泥于细节。只要我们意识到测试双倍是正确的通用术语，并且具体的双倍类型有不同的角色，一切都会顺利。
- en: What is the problem known as “testing the mock”?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “测试模拟”这个问题是什么？
- en: This happens when the SUT has no real logic in it, yet we try to write a unit
    test anyway. We wire up a test double to the SUT and write the test. What we will
    find is that the assertions only check that the test double-returned the right
    data. It’s an indication that we have tested at the wrong level. This kind of
    error can be driven by setting unwise code coverage targets or forcing an equally
    unwise test-per-method rule. This test adds no value and should be removed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在SUT（系统单元）中没有实际逻辑，但我们仍然尝试编写单元测试的情况下。我们将测试双倍连接到SUT并编写测试。我们将发现，断言只检查测试双倍返回了正确的数据。这表明我们测试的水平不正确。这种错误可能是由设置不明智的代码覆盖率目标或强制执行一个同样不明智的按方法测试规则所驱动的。这个测试没有增加任何价值，应该被移除。
- en: Can test doubles be used anywhere?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试双倍可以在任何地方使用吗？
- en: No. This only works if you have designed your code using the Dependency Inversion
    Principle so that a test double can be swapped in place of a production object.
    Using TDD certainly forces us to think about this kind of design issue early.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这只有在您使用依赖倒置原则设计代码，以便测试双倍可以替换生产对象的情况下才有效。使用TDD确实迫使我们早期考虑这类设计问题。
- en: Writing tests later is made more difficult if there is insufficient access to
    inject test doubles where they are needed. Legacy code is particularly difficult
    in this respect, and I recommend reading the book *Working Effectively with Legacy
    Code* by Michael Feathers for techniques to aid in adding tests to code that lacks
    the necessary test access points. (See the *Further* *reading* list.)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法在需要的地方注入测试替身，那么后续编写测试将变得更加困难。在这一点上，遗留代码尤其困难，我建议阅读迈克尔·费瑟斯的书籍《与遗留代码有效工作》，以获取帮助添加测试到缺乏必要测试访问点的代码的技术。（参见*进一步阅读*列表。）
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174)'
- en: Mockito library home page
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 库主页
- en: '*Working Effectively with Legacy Code, Michael C. Feathers* *ISBN 978-0131177055*'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《与遗留代码有效工作》，迈克尔·C·费瑟斯* *ISBN 978-0131177055*'
- en: This book explains how you can work with legacy code written without Dependency
    Inversion access points for test doubles. It shows a range of techniques to safely
    rework the legacy code so that test doubles can be introduced.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书解释了如何处理没有为测试替身提供依赖倒置访问点的遗留代码。它展示了一系列技术，以安全地重构遗留代码，从而可以引入测试替身。
