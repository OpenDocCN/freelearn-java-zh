- en: Getting Started with Scala Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 编程入门
- en: '"When you don''t create things, you become defined by your own tastes rather
    than ability, your tastes only narrow and exclude people. So create."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “当你不创造东西时，你被自己的品味而不是能力所定义，你的品味只会变得狭隘并排斥他人。所以，创造吧。”
- en: '- Why the Lucky Stiff'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Why the Lucky Stiff'
- en: Scala is easy to get into but too deep to get a grip on. As the name suggests,
    Scala means *A Scalable Language*, a programming language that grows with your
    programming abilities. This chapter introduces you to this very popular language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 容易入门，但太深奥了，难以掌握。正如其名所示，Scala 意味着 *一种可扩展的语言*，一种随着你的编程能力增长而增长的编程语言。本章将向您介绍这种非常流行的语言。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Scala
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 简介
- en: Scala advantages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 优势
- en: Working with Scala
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scala
- en: Running our first program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的第一个程序
- en: Introduction to Scala
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 简介
- en: 'Consider a scenario where you get a paragraph and a word and you are asked
    to get the number of occurrences for that word. You''re lucky enough to know a
    language such as Java. Your solution might look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你得到一个段落和一个单词，并被要求计算该单词出现的次数。你很幸运地知道一种语言，比如 Java。你的解决方案可能看起来像这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That was easy, wasn''t it? Now our Scalable language has a simple way of accomplishing
    this. Let''s take a look at that:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那很简单，不是吗？现在我们的 Scalable 语言有简单的方法来完成这个任务。让我们看看它是如何做到的：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it, a one-liner solution for the same problem. The code may not look
    familiar right now, but gradually you'll have command over it. By the end of this
    chapter, we'll understand everything that's needed to run a Scala program, not
    just a `Hello World` program, but one that does something.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，对同一个问题的单行解决方案。代码现在可能看起来不熟悉，但渐渐地你会掌握它。到本章结束时，我们将了解运行 Scala 程序所需的一切，而不仅仅是
    `Hello World` 程序，还包括做些事情的程序。
- en: 'Scala''s no different. It runs on **Java** **Virtual** **Machine** (**JVM**),
    so Java folks must have an idea about it. If not, JVM is defined as an abstract
    computing machine that operates on a set of instructions (Java Bytecode). It enables
    a machine to run a Java program. So here''s the conclusion: when we write Scala
    programs and compile them, they are converted into Java Bytecode and then run
    on JVM. Scala interoperates with all Java libraries. It''s easier and, of course,
    possible to write our own Scala code and also incorporate library functions written
    in Java.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 与其他语言并无不同。它运行在 **Java** **虚拟** **机**（**JVM**）上，因此熟悉 Java 的人肯定对其有所了解。如果不熟悉，JVM
    可以定义为一种抽象计算机，它执行一系列指令（Java 字节码）。它使机器能够运行 Java 程序。因此，结论是：当我们编写 Scala 程序并编译它们时，它们会被转换成
    Java 字节码，然后在 JVM 上运行。Scala 与所有 Java 库兼容。编写我们自己的 Scala 代码并集成用 Java 编写的库函数既容易又当然可行。
- en: Scala is a multi-paradigm language; it's a mixture of object-oriented and functional
    programming. But what good is it to us?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种多范式语言；它是面向对象和函数式编程的混合体。但它对我们有什么好处呢？
- en: A programming paradigm
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程范式
- en: 'A paradigm is simply a way of doing something. So a programming paradigm means
    a way of programming or a certain pattern of writing programs. There are a number
    of programming paradigms in existence, but four of them have gained popularity:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 范式只是做某事的一种方式。因此，编程范式意味着编程的方式或编写程序的一定模式。存在许多编程范式，但其中四种已经获得了流行：
- en: '**Imperative Paradigm**: First do this and then do that'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令式范式**：先做这个，再做那个'
- en: '**Functional Paradigm**: Evaluate and use'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式范式**：评估和使用'
- en: '**Logical Paradigm**: Answer through solution'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑范式**：通过解决方案来回答'
- en: '**Object-Oriented Paradigm**: Send messages between objects to simulate temporal
    evolution of a set of real-world phenomena'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向对象范式**：通过对象间发送消息来模拟一组现实世界现象的时间演化'
- en: Object-oriented versus functional paradigms
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象与函数式范式
- en: With its roots in the mathematics discipline, the functional programming paradigm
    is simple. It works on the theory of functions which produce values that are immutable.
    Immutable values mean they can't be modified later on directly. In the functional
    paradigm, all computations are performed by calling self/other functions. Functions
    are first-class citizens in the functional world. This opens up a new world of
    possibilities where all computations are driven by a certain need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式起源于数学学科，非常简单。它基于函数理论，这些函数产生不可变值。不可变值意味着它们不能直接在之后被修改。在函数式范式下，所有计算都是通过调用自我/其他函数来执行的。函数是函数式世界中的第一公民。这开启了一个新的可能性世界，其中所有计算都由某种需求驱动。
- en: The object-oriented planet revolves around encapsulation and abstractions. The
    logical grouping of components makes maintenance of larger and complex programs
    easier. Data and models are encapsulated in objects. Information hiding is effective
    for containing an object's properties. Inheritance hierarchies, the concept of
    classes, and messaging between objects makes the whole model/pattern of object-oriented
    programming a partial success.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的星球围绕着封装和抽象旋转。组件的逻辑分组使得维护更大和更复杂的程序变得容易。数据和模型封装在对象中。信息隐藏对于包含对象属性是有效的。继承层次、类的概念以及对象之间的消息传递使得面向对象编程的整个模型/模式部分成功。
- en: Scala is multi-paradigm
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala是多范式的
- en: Scala, being a multi-paradigm language, supports both paradigms. As we're learning
    Scala, we have the power of both of these paradigms. We can create functions as
    we need them, and also have objects talking to other objects. We can have class
    hierarchies and abstractions. With this, dominance over a particular paradigm
    will not affect another.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Scala作为一种多范式语言，支持两种范式。在我们学习Scala的过程中，我们拥有这两种范式的力量。我们可以根据需要创建函数，也可以让对象相互通信。我们可以有类层次和抽象。有了这些，对特定范式的控制不会影响另一个。
- en: Today the need for concurrency, immutability, heterogeneity, reactiveness, and
    fault tolerant architectures with ever-shrinking development life cycles has drastically
    increased. In this era, languages such as Scala do more than they need to with
    their support for functional as well as object-oriented programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，对于并发、不可变性、异构性、反应性和容错架构的需求急剧增加，而开发周期却越来越短。在这个时代，像Scala这样的语言在支持函数式编程以及面向对象编程方面做得更多。
- en: For a programmer like us, a language is a tool to create something meaningful.
    We tend to reuse and manipulate other tools as well, in our case let's say other
    libraries. Now, we would like to work with a language which provides us extensibility
    and flexibility in terms of its use. Scala does this. This powerful language lets
    you mix in newly created traits (you may not have heard about this, but you can
    compare it to Java's interfaces). There are a number of ways we can make our code
    more meaningful and of course concise. If used smartly, you can create your own
    custom constructs with native language features. So this language is as exciting
    as you are!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这样的程序员来说，一种语言是一个创造有意义事物的工具。我们倾向于重用和操作其他工具，在我们的例子中，让我们假设是其他库。现在，我们希望与一种提供使用扩展性和灵活性的语言一起工作。Scala就是这样做的。这种强大的语言让你可以混合使用新创建的`trait`（你可能没有听说过，但你可以将其与Java的接口进行比较）。我们有多种方法可以使我们的代码更有意义，当然也更简洁。如果使用得当，你可以使用本地语言特性创建自己的自定义结构。所以这种语言就像你一样令人兴奋！
- en: 'This is one of the reasons to learn it. There are other reasons behind why
    we would choose Scala over any other languages, and there''s quite a few. Let''s
    take them one by one. But first let''s get confused:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是学习它的一个原因。选择Scala而不是其他语言的原因还有很多，而且相当多。让我们逐一来看。但首先让我们感到困惑：
- en: '"Scala is a functional language, supports multiple paradigms, and every function
    in Scala is an object."'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '"Scala是一种函数式语言，支持多种范式，Scala中的每个函数都是一个对象。"'
- en: Great! Now you know three main characteristics of this language. But it's hard
    to swallow. It's a functional language, and every function is an object. Really?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你已经知道了这种语言的主要三个特点。但这很难接受。它是一种函数式语言，每个函数都是一个对象。真的吗？
- en: The following is an example of a `trait` defined in Scala, called `Function1`*:*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在Scala中定义的`trait`示例，称为`Function1`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are more of these, from `Function0` to `Function22`. There''s a certain
    way of using these. We''ll be using them many times in this book. We also refer
    to these as *A => B* (we call it, `A` to `B`). It means this function takes a
    parameter of type `A`, does some operation as defined, and returns a value of
    type `B`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些还有很多，从`Function0`到`Function22`。使用它们有一定的方法。在这本书中，我们会多次使用它们。我们也将它们称为*A => B*（我们称之为，`A`到`B`）。这意味着这个函数接受一个类型为`A`的参数，按照定义执行一些操作，并返回一个类型为`B`的值：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This feels a bit too much to start with but getting familiar with these constructs
    is a good idea. `val` is a keyword used to declare a value type. It means, once
    declared and instantiated, you can''t change it further. This `answer = (x: Int)
    => x * 2` becomes a function literal that can be passed to another function. We
    get to this point because we were able to instantiate an object of our `Function1`
    trait (we''ll see how this works in [Chapter 7](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84),
    *Next Steps in Object-Oriented Scala*).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来有点多，但熟悉这些结构是个好主意。`val` 是一个关键字，用于声明值类型。这意味着一旦声明和实例化，就不能再进一步更改它。这个 `answer
    = (x: Int) => x * 2` 成为一个函数字面量，可以被传递给另一个函数。我们之所以能达到这个点，是因为我们能够实例化我们的 `Function1`
    特质的对象（我们将在第 7 章[part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84]，*面向对象的
    Scala 的下一步*中看到这是如何工作的）。'
- en: Think of any two lucky numbers, now represent how you can add them. Suppose
    your numbers were 42 + 61\. Here, your numbers 42 and 61 are objects of type `Int`
    and `+` is a method on type `Int`. This is the way you and Scala are going to
    treat entities. We'll treat entities as objects and operations performed on them
    as methods. And this is what makes this language scalable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 想想任何两个幸运数字，现在代表你如何将它们相加。假设你的数字是 42 + 61\. 在这里，你的数字 42 和 61 是 `Int` 类型的对象，而 `+`
    是 `Int` 类型上的一个方法。这就是你和 Scala 处理实体的方式。我们将实体视为对象，并在它们上执行的操作视为方法。这正是使这种语言可扩展的原因。
- en: 'We can perform functional operations where inputs are transformed to outputs
    rather than changing data/state of them. With this in mind, most of our operations
    (almost all) will not depend on state change; means functions are not going to
    have side effects. One example could be a function which takes your date of birth
    and returns your age in terms of the number of years and months:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行函数式操作，其中输入被转换成输出，而不是改变它们的数据/状态。考虑到这一点，我们的大部分操作（几乎全部）将不会依赖于状态变化；这意味着函数不会产生副作用。一个例子可以是这样一个函数，它接收你的出生日期，并以年数和月数的形式返回你的年龄：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a pure function because it does not manipulate the input. It takes input,
    transforms, and gives output. Case class is just to help us here define the age
    in a certain manner. With this, we can introduce more terminology called **referentially
    transparent methods***.* Our `age` method can be called *referentially transparent.*
    These method calls can be replaced by the result without changing any meaning/semantics
    of your program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个纯函数，因为它不操作输入。它接收输入，转换，并给出输出。Case 类只是帮助我们以某种方式定义年龄。有了这个，我们可以引入更多术语，称为**引用透明方法**.*
    我们的 `age` 方法可以被称作*引用透明*。这些方法调用可以被结果替换，而不会改变你程序中的任何意义/语义。
- en: Pure functions, the concept of immutability, and referential transparency are
    here only to make this language more powerful. There are more reasons to choose
    this language as a tool for your next application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数、不可变性的概念和引用透明性都只是为了使这种语言更强大。有更多理由选择这种语言作为你下一个应用程序的工具。
- en: Scala advantages
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 优势
- en: We're smart programmers. We've already set expectations on the choice of our
    language. Our language should be extensive and flexible enough. It should be friendly,
    support libraries written in languages such as Java, be easy to work with, have
    good online support, and a whole lot more. And guess what! Scala gives you the
    complete package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是聪明的程序员。我们已经对我们的语言选择设定了期望。我们的语言应该足够广泛和灵活。它应该是友好的，支持用 Java 等语言编写的库，易于使用，有良好的在线支持，还有很多其他优点。而且你知道吗！Scala
    给你提供了完整的包。
- en: Runs on JVM
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JVM 上运行
- en: Consider efficiency and optimization as factors for a language to be well performant.
    Scala utilizes JVM for this. JVM uses **Just in Time** (**JIT**) compilation,
    adaptive optimization techniques for improved performance. Running on JVM makes
    Scala interoperable with Java. You've multitudinous libraries available as tools
    for reuse.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑效率优化作为衡量一种语言是否表现良好的因素。Scala 利用 JVM 来实现这一点。JVM 使用**即时编译**（**JIT**）和自适应优化技术来提高性能。在
    JVM 上运行使 Scala 与 Java 兼容。你有很多库可用作为重用工具。
- en: If anywhere in your mind you're comparing Java and Scala's performance, let's
    get it clear. Both Java and Scala programs are compiled into bytecode. JVM understands
    bytecode and runs it for you. So it mostly depends on the way you write a program.
    Scala blends in some syntax sugar, compiler logic that can cause your program
    to be more/less performant than Java. Mix-ins using traits can be an asset to
    your program architecture but may affect your program's performance. But alternatives
    in Java may cost the same or more. So it is more about your core understanding
    of constructs and how your code is going to compile and perform. It takes some
    time and effort to understand so the choice is yours; as a smart programmer, you
    may go for a syntactically powerful language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在心中比较Java和Scala的性能，让我们澄清一下。Java和Scala程序都是编译成字节码。JVM理解字节码并为你运行它。所以这主要取决于你编写程序的方式。Scala融合了一些语法糖，编译器逻辑，这可能导致你的程序比Java更/更少高效。使用特质进行混入可能对你的程序架构有益，但可能会影响你的程序性能。但在Java中的替代方案可能成本相同或更高。所以这更多关于你对结构的核心理解以及你的代码将如何编译和执行。这需要一些时间和努力去理解，所以选择权在你；作为一个聪明的程序员，你可能会选择一个语法强大的语言。
- en: Super smart syntax
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超智能语法
- en: 'You are going to write succinct code with Scala. There are a lot of examples
    we can look at to see Scala''s syntax conciseness. Let''s take an example from
    Scala''s rich collections and create a `Map`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你将用Scala编写简洁的代码。我们可以查看很多示例来了解Scala语法的简洁性。让我们从Scala丰富的集合中取一个例子来创建一个`Map`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is creating a map of words and their meaning. Only `Map ("Wisdom"
    -> "state of being wise")` is the amount of code we have to write to make it possible.
    No need to add semicolons. We did not even mention the type of our value and the
    Scala compiler was able to infer it. **Type inference** is a characteristic of
    this language. Because of Type inference*,* a lot of times we omit type declaration
    and use a value directly. This way, using only a minimal set of words/tokens you
    can express the logic to implement them. Constructs like case classes and pattern
    matching take away the extra effort one might have to make and makes writing code
    joyful. It also helps you reduce written code by a good margin.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码正在创建一个单词及其含义的映射。只需`Map ("Wisdom" -> "state of being wise")`这一行代码，我们就能实现这一功能。无需添加分号。我们甚至没有提及我们值的类型，而Scala编译器却能推断出来。**类型推断**是这种语言的特点。由于**类型推断**，很多时候我们省略了类型声明，直接使用值。这样，仅使用最小的一组单词/标记，你就可以表达实现它们的逻辑。像case类和模式匹配这样的结构可以减少你可能需要做的额外工作，并使编写代码变得愉快。它还有助于你大幅减少代码量。
- en: Best of both worlds
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两者之最佳结合
- en: 'Scala is a mixture of functional and object-oriented worlds. It gives two benefits.
    First, you can leverage the power of functional constructs: higher-order functions,
    nested functions, pure functions, and closures. You get to work with more available
    (and recommended) immutable data structures. Working with immutable code helps
    in eliminating code that can introduce side effects or state change. This also
    makes this language suitable for concurrent programming. This is just another
    advantage Scala provides. Second, you''ve all the object-oriented goodies available.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是函数式和面向对象世界的混合体。它提供了两个好处。首先，你可以利用函数式结构的强大功能：高阶函数、嵌套函数、纯函数和闭包。你可以使用更多可用（且推荐）的不可变数据结构。使用不可变代码有助于消除可能引入副作用或状态变化的代码。这也使得这种语言适合并发编程。这只是Scala提供的另一个优势。其次，你拥有所有面向对象的优点。
- en: You can define traits, mix them in with classes or objects, and achieve inheritance.
    The creation of objects, defining abstracts, and sub-classing is also possible
    in Scala.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义特质，将它们与类或对象混合，从而实现继承。在Scala中，创建对象、定义抽象类和子类也是可能的。
- en: Type is the core
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型是核心
- en: 'In the early days (great, if even in the present) you may have come across
    this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期（即使现在也很棒）你可能遇到过这种情况：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the mathematical representation of a function. This is how we denote
    any function *f's* domain and co-domains. In this case a function, `f` maps values
    from a set of *real numbers* to a set of *natural numbers.* With this deep abstraction
    level, you can think of Scala's rich type system. Some of the numerous types available
    are parameterized, structural, compound, existential, path-dependent, higher-kinded,
    and yes, we are discussing abstract types. An explanation of all these is beyond
    the scope of this book. But if you're curious, you may refer to Scala documentation
    at [https://www.scala-lang.org/documentation/](https://www.scala-lang.org/documentation/).
    Knowledge of these helps a lot when designing frameworks or libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数的数学表示。这就是我们表示任何函数 *f* 的定义域和陪域的方式。在这种情况下，函数 `f` 将实数集的值映射到自然数集。在这个深层次的抽象级别上，你可以思考
    Scala 丰富的类型系统。其中一些可用的类型是参数化的、结构化的、复合的、存在性的、路径依赖的、高阶的，是的，我们正在讨论抽象类型。对这些类型的解释超出了本书的范围。但如果你好奇，你可以参考
    Scala 文档在 [https://www.scala-lang.org/documentation/](https://www.scala-lang.org/documentation/)。了解这些对于设计框架或库非常有帮助。
- en: Concurrency made easy
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发编程变得简单
- en: Scala recommends the use of immutable data structures, immutable collections,
    use of value types, functional compositions, and transformations. Along with these,
    the use of actors and other concurrent constructs have made it so easy to write
    concurrent programs. Mostly, programmers do not have to deal with the complication
    of thread life cycle management, because of modern constructs such as actors and
    reactors available in the form of native support and through libraries. Akka is
    one of these toolkits available, written in Scala. Also, the use of futures and
    promises enables writing asynchronous code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 推荐使用不可变数据结构、不可变集合、使用值类型、函数组合和转换。除此之外，使用演员和其他并发结构使得编写并发程序变得非常容易。大多数情况下，程序员不需要处理线程生命周期管理的复杂性，因为现代结构如演员和反应器以原生支持和库的形式提供。Akka
    就是这些工具包之一，它是用 Scala 编写的。此外，使用未来和承诺使得编写异步代码成为可能。
- en: Asynchronous code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步代码
- en: Simply defined, asynchronous code is where your program control returns immediately
    after calling a block of instruction (that is a function), having started some
    parallel/ background effort to complete your request. This means your program
    flow will not stop because of a certain function taking time to complete.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，异步代码是在调用一个指令块（即函数）并启动一些并行/后台任务以完成请求后，程序控制立即返回的地方。这意味着程序流程不会因为某个函数需要时间完成而停止。
- en: Asynchronous versus parallel versus concurrent programming
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程与并行编程和并发编程的比较
- en: Asynchronous programming involves some calculations time-intensive tasks, which
    on the one hand are engaging a thread in the background but do not affect the
    normal flow of the program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程涉及一些计算密集型任务，这些任务一方面在后台占用一个线程，但不会影响程序的正常流程。
- en: Parallel programming incorporates several threads to perform a task faster and
    so does concurrent programming. But there's a subtle difference between these
    two. The program flow in parallel programming is deterministic whereas in concurrent
    programming it's not. For example, a scenario where you send multiple requests
    to perform and return responses regardless of response order is said to be concurrent
    programming. But where you break down your task into multiple sub-tasks to achieve
    parallelism can be defined as the core idea of parallel programming.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程通过结合多个线程来更快地完成任务，并发编程也是如此。但这两者之间有一个细微的差别。并行编程中的程序流程是确定的，而在并发编程中则不是。例如，发送多个请求执行并返回响应，而不考虑响应顺序的场景被称为并发编程。但将任务分解成多个子任务以实现并行性的地方可以定义为并行编程的核心思想。
- en: Now available for the frontend
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在可用于前端
- en: '**Scala.js** is specifically designed for the frontend and helps you avoid
    type-based mistakes as Scala.js is able to infer to types. You can leverage performance
    optimization and interoperability with some already available JavaScript frameworks
    such as Angular and React. Then added to that, you have macros available that
    help you extend the language.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala.js** 是专门为前端设计的，它可以帮助你避免基于类型的错误，因为 Scala.js 能够推断类型。你可以利用性能优化和与一些现有的
    JavaScript 框架（如 Angular 和 React）的互操作性。然后，再加上可用的宏，这些宏可以帮助你扩展语言。'
- en: Smart IDEs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能集成开发环境
- en: There are many options available to make your programming journey easier. Scala
    IDE provides numerous editing and debugging options for development of Scala-based
    applications. The Scala IDE is built on top of a known Eclipse IDE. There are
    also plugins available to write Scala applications. We'll take a look at how to
    install and use IDE for Scala development in the coming sections.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以使您的编程之旅更加轻松。Scala IDE 为基于 Scala 的应用程序的开发提供了许多编辑和调试选项。Scala IDE 是建立在知名
    Eclipse IDE 之上的。还有可用于编写 Scala 应用程序的插件。我们将在接下来的章节中探讨如何安装和使用 IDE 进行 Scala 开发。
- en: Extensive language
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广泛的语言
- en: 'Scala is very deep. Rich type abstractions, reflection, and macros all help
    you build some really powerful libraries and frameworks. Scala documentation explains
    everything to you: from parameterized types to reflection components. Understanding
    compile-time reflection (macros) and runtime reflection are essential for writing
    frameworks using Scala. And it''s fun.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 非常深入。丰富的类型抽象、反射和宏都有助于您构建一些真正强大的库和框架。Scala 文档为您解释了一切：从参数化类型到反射组件。理解编译时反射（宏）和运行时反射对于使用
    Scala 编写框架是必不可少的。而且这很有趣。
- en: Online support
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线支持
- en: One of the biggest reasons for the growth of Scala as a programming language
    and its success is the vast online support available. The Scala team has put in
    a good amount of work and have come up with rich documentation. You can find documentation
    at [http://docs.scala-lang.org](http://docs.scala-lang.org)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 作为编程语言的增长及其成功的一个最大原因是可用的广泛在线支持。Scala 团队投入了大量工作，并提供了丰富的文档。您可以在[http://docs.scala-lang.org](http://docs.scala-lang.org)找到文档。
- en: Learning Scala is challenging but fun. It brings out the best in you as a programmer.
    Isn't it fun to think and write shorter and smarter syntax with almost the same
    performance capabilities?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Scala 具有挑战性但很有趣。它激发了你作为程序员的最佳表现。用几乎相同的性能能力思考和编写更短、更智能的语法不是很有趣吗？
- en: Working with Scala
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scala
- en: In this book, we're using Scala version 2.12.2\. Scala 2.12 requires your system
    to have Java version 8 installed. Older Scala versions support Java version 6
    and above. Support for Java version 9 is still a topic of discussion for the Scala
    2.13 roadmap.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用 Scala 版本 2.12.2。Scala 2.12 要求您的系统已安装 Java 8。较老的 Scala 版本支持 Java 6
    及以上版本。对 Java 9 的支持仍然是 Scala 2.13 路线图讨论的主题。
- en: Scala 2.12 was a step up from previous versions, mainly for support of Java
    and Scala lambda interoperability. Traits and functions are compiled directly
    to their Java 8 equivalents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.12 相比之前的版本是一个进步，主要是为了支持 Java 和 Scala 的 lambda 互操作性。特性和函数被直接编译到它们的 Java
    8 等价物。
- en: Java installation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 安装
- en: Do the needful. If Java is not already installed on your machine, you may refer
    to Oracle's website at [https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html)
    for instructions on how to install Java for your operating system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 做必要的事情。如果您的机器上尚未安装 Java，您可以参考 Oracle 的网站[https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html)，了解如何为您的操作系统安装
    Java。
- en: SBT installation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT 安装
- en: SBT, as the name suggests, is a **Simple Build Tool**. From managing all source
    files to their compiled target versions to downloading all dependencies, SBT helps
    you create a Scala application with ease. You can configure how your test cases
    run. SBT comes with various commands for such tasks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，SBT 是一个**简单构建工具**。从管理所有源文件到它们的编译目标版本，再到下载所有依赖项，SBT 都可以帮助您轻松创建 Scala 应用程序。您可以配置测试用例的运行方式。SBT
    提供了各种命令来执行此类任务。
- en: 'To install SBT on your machine, perform the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的机器上安装 SBT，请执行以下操作：
- en: Go to [http://www.scala-sbt.org/download.html](http://www.scala-sbt.org/download.html).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://www.scala-sbt.org/download.html](http://www.scala-sbt.org/download.html)。
- en: You may choose from the available options suitable for your operating system.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从适合您操作系统的可用选项中进行选择。
- en: 'After installation, you may check the version, so open a command prompt/terminal
    and type this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以检查版本，因此请打开命令提示符/终端并输入以下内容：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should get the corresponding version number.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到相应的版本号。
- en: Scala REPL
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala REPL
- en: 'There is more than one way of interacting with Scala. One of them is using
    Scala Interpreter (REPL). To run Scala REPL using SBT, just give the following
    command in the command prompt/terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Scala 交互的方式不止一种。其中之一是使用 Scala 解释器（REPL）。要使用 SBT 运行 Scala REPL，只需在命令提示符/终端中输入以下命令：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will run Scala REPL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行Scala REPL。
- en: 'To run Scala REPL using Scala binary, perform the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Scala二进制文件运行Scala REPL，请执行以下操作：
- en: Go to [https://www.scala-lang.org/download/](https://www.scala-lang.org/download/).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://www.scala-lang.org/download/](https://www.scala-lang.org/download/)。
- en: Download the latest Scala archive.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新的Scala存档。
- en: Extract the archive to any directory.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存档提取到任何目录。
- en: Set the directory path as environment variables as shown in [https://www.scala-lang.org/download/install.html](https://www.scala-lang.org/download/install.html).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录路径设置为环境变量，如[https://www.scala-lang.org/download/install.html](https://www.scala-lang.org/download/install.html)所示。
- en: 'Try running the `scala` command, it should look something like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行`scala`命令，它应该看起来像这样：
- en: '![](img/00005.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: If so, congrats. You've done it. Now it's asking you to type any expression.
    You may try typing any expression. Try anything, like 1 + 2 or 1 + "2". REPL is
    your playground to learn Scala.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，恭喜你。你已经做到了。现在它要求你输入任何表达式。你可以尝试输入任何表达式。尝试任何东西，比如1 + 2或1 + "2"。REPL是你的学习Scala的游乐场。
- en: Scala IDEs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala IDEs
- en: 'After getting familiar with Scala REPL, now is the time to install IDE (Integrated
    Development Environment). There are options available to work with Scala in IDE.
    Choose what fits the best for you. Eclipse lovers can go for Scala IDE. To download:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了Scala REPL之后，现在是时候安装IDE（集成开发环境）了。有选项可以在IDE中与Scala一起工作。选择最适合你的选项。Eclipse爱好者可以选择Scala
    IDE。下载：
- en: Go to [http://scala-ide.org/download/sdk.html](http://scala-ide.org/download/sdk.html).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://scala-ide.org/download/sdk.html](http://scala-ide.org/download/sdk.html)。
- en: You may choose from the available options suitable for your operating system.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从适合你操作系统的可用选项中选择。
- en: 'If you''re accustomed to IntelliJ IDE, you may go for the plugin download for
    SBT. This will enable you to create Scala applications. To get started with Scala
    development on IntelliJ IDE:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于IntelliJ IDE，你可以下载SBT插件。这将使你能够创建Scala应用程序。要在IntelliJ IDE上开始Scala开发：
- en: Go to [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)。
- en: You may choose from the available options suitable for your operating system.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从适合你操作系统的可用选项中选择。
- en: After installation, go to File | IntelliJ IDEA | Preferences | Plugins and search
    for `Scala`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，转到文件 | IntelliJ IDEA | 首选项 | 插件，并搜索`Scala`。
- en: Click on Install | Apply.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击安装 | 应用。
- en: With this, you're ready to work with Scala on IntelliJ IDE. If you're IDE neutral,
    you may choose whichever suits the best. We'll use IntelliJ IDE (Community Edition)
    version 2017.1 with SBT version 0.13.15 and Scala 2.12.2 version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以在IntelliJ IDE上使用Scala了。如果你对IDE没有偏好，你可以选择最适合你的。我们将使用IntelliJ IDE（社区版）2017.1版本、SBT版本0.13.15和Scala
    2.12.2版本。
- en: Running our first program
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个程序
- en: Time to do some real work. The recommended way of getting started with a Scala
    project is to use an `activator/gitor8` seed template. For `gitor8`, you require
    SBT version 0.13.13 and above. Using SBT, give the command `sbt new` providing
    the name of the template. A list of templates can be found at [https://github.com/foundweekends/giter8/wiki/giter8-templates/30ac1007438f6f7727ea98c19db1f82ea8f00ac8](https://github.com/foundweekends/giter8/wiki/giter8-templates/30ac1007438f6f7727ea98c19db1f82ea8f00ac8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候做一些实际工作了。开始Scala项目的推荐方式是使用`activator/gitor8`种子模板。对于`gitor8`，你需要SBT版本0.13.13及以上。使用SBT，输入命令`sbt
    new`并提供模板名称。模板列表可以在[https://github.com/foundweekends/giter8/wiki/giter8-templates/30ac1007438f6f7727ea98c19db1f82ea8f00ac8](https://github.com/foundweekends/giter8/wiki/giter8-templates/30ac1007438f6f7727ea98c19db1f82ea8f00ac8)找到。
- en: 'For learning purposes, you may directly create a project in IntelliJ. For that,
    you may first start the IDE and start with a new project:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习目的，你可以在IntelliJ中直接创建一个项目。为此，你首先可以启动IDE并创建一个新的项目：
- en: 'Click on the Create New Project function:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建新项目”功能：
- en: '![](img/00006.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: 'Select the Scala | IDEA option and click Next:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Scala | IDEA选项并点击下一步：
- en: '![](img/00007.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: 'Give Project name, Project location, select/locate Scala SDK, and Finish:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称、项目位置，选择/定位Scala SDK，然后完成：
- en: '![](img/00008.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: You're ready to write your first program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编写你的第一个程序了。
- en: 'Let''s write some code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding program does nothing but print doubles of numbers ranging from
    1 to 10\. Let's go through the code. First, we gave the package declaration with
    a name `lsp`*.* In the next line, we created an `object` named `First`***.***
    An object in Scala is a singleton container of code which cannot take any parameters.
    You are not allowed to create instances of an `object`. Next, we used the `def`
    keyword to define the `main` method that works as an entry point to our application.
    The `main` method takes an array of String as parameters and returns `Unit`*.*
    In Scala terminology, `Unit` is the same as the `void`, it does not represent
    any type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序所做的只是打印出从1到10的数字的双倍值。让我们来分析一下代码。首先，我们给出了名为`lsp`的包声明*.* 在下一行中，我们创建了一个名为`First`的对象***。***
    在Scala中，对象是一个代码的单例容器，不能接受任何参数。不允许创建对象的实例。接下来，我们使用`def`关键字定义了作为应用程序入口点的`main`方法。`main`方法接受一个字符串数组作为参数并返回`Unit`*.*
    在Scala术语中，`Unit`与`void`相同，它不表示任何类型。
- en: 'In the definition of this method, we defined a function literal and used it.
    A value named `double` is a function literal (also called **anonymous function**)
    of type `Int => Int` pronounced Integer to Integer. It means this anonymous function
    will take an integer parameter and return an integer response. An anonymous function
    is defined as `_ * 2`. Here `_` (that is an underscore) is sort of syntactic sugar
    that infers any expected value, in our case, it''s going to be an integer. This
    is inferred as an integer value because of the signature (`Int => Int`) Int to
    Int. This function literal applied on a range of integer values 1 to 10, represented
    by `(1 to 10)`, gives back doubled values for each integer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法的定义中，我们定义了一个函数字面量并使用了它。一个名为`double`的值是一个类型为`Int => Int`的函数字面量（也称为**匿名函数**），读作整数到整数。这意味着这个匿名函数将接受一个整数参数并返回一个整数响应。匿名函数被定义为`_
    * 2`。这里的`_`（即下划线）是一种语法糖，它推断出任何预期的值，在我们的例子中，它将是一个整数。由于签名（`Int => Int`）是整数到整数，这个函数字面量被推断为整数值。这个函数字面量应用于整数范围1到10，表示为`(1
    to 10)`，为每个整数返回双倍值：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This line contains a few tokens. Let''s take them one by one. First is `(1
    to 10)`, which in Scala is a way to represent a range. It''s immutable, so once
    produced it can''t be changed. Next, `foreach` is used to traverse through the
    range. Subsequently, `double` is applied on each element from the range. After
    application of the anonymous function `andThen`, it composes the result of `double`
    and prints it. With this example, you successfully wrote and understood your first
    Scala program. Even though the code was concise, there''s a bit of overhead that
    can be avoided. For example, the `main` method declaration. The code can be written
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行包含了一些标记。让我们逐个来看。首先是`(1 to 10)`，在Scala中这是一种表示范围的方式。它是不可变的，所以一旦生成就不能改变。接下来，使用`foreach`遍历这个范围。随后，对范围中的每个元素应用`double`。在应用匿名函数`andThen`之后，它组合了`double`的结果并打印出来。通过这个例子，你成功编写并理解了你的第一个Scala程序。尽管代码简洁，但还有一些开销是可以避免的。例如，`main`方法的声明。代码可以写成如下所示：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the same code is written in an object that extends the `App` trait. By
    extending the `App` trait available, you don't have to explicitly write the `main`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，相同的代码被写在一个扩展了`App`特质的对象中。通过扩展可用的`App`特质，你不必显式地编写`main`方法。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was an introduction to Scala for us. We started learning about
    programming paradigms. After that, we discussed Scala's advantages over other
    available languages. Then we got our development environment ready. Finally, we
    wrote our first Scala program.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对我们来说是Scala的入门。我们开始学习编程范式。之后，我们讨论了Scala相较于其他可用语言的优点。然后我们准备好了我们的开发环境。最后，我们编写了我们的第一个Scala程序。
- en: In the next chapter, we'll take our Scala journey ahead and learn about literals,
    data types, and the basic building blocks of Scala.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的Scala之旅，学习字面量、数据类型和Scala的基本构建块。
