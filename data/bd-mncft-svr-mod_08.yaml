- en: Chapter 8. Making Your Plugin Configurable
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 使你的插件可配置
- en: A configurable plugin can be very powerful. A single plugin will be able to
    function in different ways, depending on user preferences. Essentially, your plugin's
    configuration file will be similar to the `bukkit.yml` file for your server. It
    will allow you to change settings for the plugin without modifying the Java code.
    This means that you need not rebuild the plugin JAR file every time you wish to
    change a small detail. If your plugin is public or used by someone else, adding
    a `config` file may reduce the time spent on modifying code in the future. The
    users of your plugin can change the settings that are in the `config` file by
    themselves and do not require any additional assistance from you as a developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可配置的插件可以非常强大。一个插件将能够根据用户偏好以不同的方式运行。本质上，你的插件配置文件将类似于你的服务器的 `bukkit.yml` 文件。它将允许你更改插件设置而不修改
    Java 代码。这意味着你不需要每次想要更改细节时都重新构建插件 JAR 文件。如果你的插件是公开的或被其他人使用，添加一个 `config` 文件可能会减少未来修改代码所需的时间。你的插件用户可以自己更改
    `config` 文件中的设置，而无需开发者提供任何额外帮助。
- en: To fully understand why we would want a variable to be configurable, let's look
    at one of the plugins that we previously talked about. In `MobEnhancer`, we set
    the health of zombies to `40` instead of `20`. Someone else may wish to use your
    plugin, but they want to set the zombies' health to `60`. You can create two versions
    of the plugin, which may become very confusing, or you can have one version that
    is configurable. In the `config` file on your server, you will have the health
    of zombies set to `40`. But on another server, the health will be set to `60`.
    Even if your plugin will be used on only one server, configuration will allow
    for a quick and easy method of changing the amount of health.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解我们为什么想要一个变量可配置，让我们看看我们之前讨论过的插件之一。在 `MobEnhancer` 中，我们将僵尸的生命值设置为 `40` 而不是
    `20`。其他人可能希望使用你的插件，但他们希望将僵尸的生命值设置为 `60`。你可以创建两个版本的插件，这可能会变得非常混乱，或者你可以有一个可配置的版本。在你的服务器上的
    `config` 文件中，僵尸的生命值将被设置为 `40`。但在另一个服务器上，生命值将被设置为 `60`。即使你的插件只在一个服务器上使用，配置也将允许快速轻松地更改生命值。
- en: 'There are five steps to making your plugin configurable, which are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的插件可配置有五个步骤，如下所示：
- en: Decide exactly which aspects of your plugin will be configurable
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你的插件哪些方面将是可配置的
- en: Create a `config.yml` file that includes each setting and its default value
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含每个设置及其默认值的 `config.yml` 文件
- en: Add code to save the default `config` file as well as load/reload the file
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码以保存默认的 `config` 文件以及加载/重新加载文件
- en: Read the configured values and store them in your plugin as class variables
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取配置的值并将它们存储在你的插件中的类变量中
- en: Ensure that your code references the class variables that the configuration
    settings are loaded into
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的代码引用了配置设置加载到的类变量
- en: 'The steps need not be performed in this order, but we will discuss them in
    the following order in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤不需要按此顺序执行，但我们将按以下顺序在本章中讨论：
- en: Configurable data types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置数据类型
- en: Writing a `config.yml` file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `config.yml` 文件
- en: Saving, loading, and reloading your plugin's configuration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存、加载和重新加载你的插件配置
- en: Reading values from the configuration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置中读取值
- en: Using the configured settings in your plugin
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的插件中使用配置设置
- en: Writing an `ItemStack` value in the YAML format
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 YAML 格式中写入 `ItemStack` 值
- en: Understanding the YAML structure and hierarchy
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 YAML 结构和层次结构
- en: Storing configuration values locally
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储配置值
- en: Splitting one class into multiple classes and accessing variables and methods
    from another class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个类拆分为多个类并从另一个类访问变量和方法
- en: Configurable data types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可配置数据类型
- en: 'You can easily make most variables in your plugin configurable. The following
    table comprises various data types and examples of why you may want them to be
    configurable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地将插件中的大多数变量设置为可配置。以下表格包含了各种数据类型及其可配置的原因示例：
- en: '| Data Type | How It Can Be Used |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 它如何被使用 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int` | To define the number of times an event should occur |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 用于定义事件应发生的次数 |'
- en: '| `double` | To set the health of a mob when it spawns |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 用于设置怪物出生时的生命值 |'
- en: '| `boolean` | To turn a specific feature on or off |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 用于开启或关闭特定功能 |'
- en: '| `String` | To change a message that is sent to a player |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 用于更改发送给玩家的消息 |'
- en: '| `ItemStack` | To make a customized item appear |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `ItemStack` | 使自定义物品出现 |'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Adding an `ItemStack` value to a configuration file is complicated, but this
    will be explained towards the end of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ItemStack` 值添加到配置文件中比较复杂，但这将在本章的末尾进行解释。
- en: We are going to make `MobEnhancer` configurable. We want to give the players
    a choice of setting the value of the zombies' health. This will simply be one
    `double` value. Let's expand the plugin to support additional creature types.
    We will create the `config` file first and then adapt the program to be able to
    modify different types of mobs. Therefore, we have decided that the `config` file
    will include a single `double` data type value for each type of mob. This `double`
    value will be the mob's health.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使 `MobEnhancer` 可配置。我们希望玩家可以选择设置僵尸的生命值。这只是一个 `double` 类型的值。让我们扩展插件以支持额外的生物类型。我们首先创建
    `config` 文件，然后调整程序以能够修改不同类型的怪物。因此，我们决定 `config` 文件将为每种怪物类型包含一个 `double` 数据类型的值。这个
    `double` 值将是怪物的生命值。
- en: Writing a config.yml file
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 `config.yml` 文件
- en: 'Now, it is time to start writing the `config.yml` file. Create a new `YAML`
    file in the default package of `MobEnhancer`. The name of this file must be `config.yml`
    in order for it to be properly loaded by Spigot. The following is an example of
    how the `config` file for `MobEnhancer` will appear. Note the comments in the
    example indicated by the `#` character. Remember to always include comments so
    that users know exactly what each setting is for:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写 `config.yml` 文件了。在 `MobEnhancer` 的默认包中创建一个新的 `YAML` 文件。为了使 Spigot
    正确加载，此文件的名称必须是 `config.yml`。以下是一个 `MobEnhancer` 的配置文件示例。注意示例中由 `#` 字符表示的注释。请记住，始终包含注释，以便用户确切知道每个设置的用途：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Only a few mobs are included in this `config` file, but the names of all the
    mob types can be found in the API documentation for the `EntityType` class at
    [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `config` 文件中只包含了一些怪物，但所有怪物类型的名称都可以在 `EntityType` 类的 API 文档中找到，网址为 [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html)。
- en: This is a simple `YAML` file because it does not contain nested keys. Most of
    your configurations will be this simple, but we will go over some complicated
    ones later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `YAML` 文件，因为它不包含嵌套键。大多数配置都将像这样简单，但我们将在本章的后面讨论一些复杂的配置。
- en: Saving, loading, and reloading the config file
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存、加载和重新加载配置文件
- en: 'Now that we have the `config.yml` file and it is located in the default package
    of the plugin, we need to be able to save it to a user''s server. Once the file
    is saved, the user will be able to edit it as they please. Saving the `config`
    file is as simple as adding the following method call to the `onEnable` method,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `config.yml` 文件，并且它位于插件的默认包中，我们需要能够将其保存到用户的服务器上。一旦文件保存，用户就可以随意编辑它。保存
    `config` 文件就像在 `onEnable` 方法中添加以下方法调用一样简单，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will copy `config.yml` to `plugins/MobEnhancer/config.yml`. If the file
    already exists, then this line of code will do nothing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `config.yml` 复制到 `plugins/MobEnhancer/config.yml`。如果文件已经存在，则此行代码将不会执行任何操作。
- en: The loading of the `config` file is done automatically by Spigot, and there
    is no need for you to do anything in addition to this in your plugin besides using
    `getConfig` when you actually want to access the configuration file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spigot 会自动加载 `config` 文件，因此除了在需要实际访问配置文件时使用 `getConfig` 之外，你不需要在插件中做任何额外的事情。
- en: 'Reloading `config.yml` is fairly simple to include; we will add it in the form
    of a command, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载 `config.yml` 相对简单，我们将以命令的形式添加，如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will put this method inside the `main` class for now. Ensure that the class
    also implements `CommandExecutor`. Do not forget to register the command with
    the following line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将此方法放在 `main` 类中。确保该类也实现了 `CommandExecutor` 接口。不要忘记使用以下行注册命令：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The command should also be added to `plugin.yml`, as always. It is a good idea
    to add a permission node at this point too. The new `plugin.yml file` looks like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 命令也应该添加到 `plugin.yml` 中，就像往常一样。现在添加一个权限节点也是一个好主意。新的 `plugin.yml` 文件如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, your plugin will have a `reload` command. This means that when you edit
    `config.yml`, you can reload the plugin rather than restarting the entire server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的插件将有一个`reload`命令。这意味着当你编辑`config.yml`时，你可以重新加载插件而不是重启整个服务器。
- en: Reading and storing the configured values
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和存储配置的值
- en: 'Once your configuration file is loaded, you must be able to access the file
    and read the values that are set. The `JavaPlugin` class, which is extended by
    the main class, has a `getConfig` method, which returns `FileConfiguration`. This
    `FileConfiguration` class is what we will use to get the values that we are looking
    for. You will see that the `FileConfiguration` class has methods such as `getInt`,
    `getDouble`, `getString`, and `getBoolean`; all of these methods take a string
    as a parameter. The `string` parameter is the path to the value. To fully understand
    the path, we need to look at a YAML configuration that contains nested keys. An
    example of this is the `plugin.yml` file that we were just working with. If we
    want to get the `MobEnhancer` string from the configuration, then the path will
    be `name`. If we want to retrieve the description of the `mobenhancerreload` command,
    then the path will be `commands.mobenhancerreload.description`. Therefore, the
    Java code needed to retrieve this value will be `getString("commands.mobenhancerreload.description");`.
    The `config.yml` file for `MobEnhancer` is quite simple. In order to get one of
    the double values, we can use the `getDouble()` method with the name of the mob
    as the path. For example, to get the value that is set for the `ZOMBIE Entity`,
    we will use the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了配置文件，你必须能够访问该文件并读取已设置的值。扩展主类的`JavaPlugin`类有一个`getConfig`方法，它返回`FileConfiguration`。这个`FileConfiguration`类就是我们用来获取我们正在寻找的值的。你会看到`FileConfiguration`类有`getInt`、`getDouble`、`getString`和`getBoolean`等方法；所有这些方法都接受一个字符串作为参数。`string`参数是值的路径。为了完全理解路径，我们需要查看一个包含嵌套键的YAML配置。一个例子是我们刚刚工作的`plugin.yml`文件。如果我们想从配置中获取`MobEnhancer`字符串，那么路径将是`name`。如果我们想检索`mobenhancerreload`命令的描述，那么路径将是`commands.mobenhancerreload.description`。因此，检索此值的Java代码将是`getString("commands.mobenhancerreload.description");`。`MobEnhancer`的`config.yml`文件相当简单。为了获取一个双精度值，我们可以使用`getDouble()`方法，路径为生物的名字。例如，要获取为`ZOMBIE`实体设置的值，我们将使用以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will return a `double` value from one of the following three sources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从以下三个来源之一返回一个`double`值：
- en: The `FileConfiguration` that has been loaded from `plugins/MobEnhance/config.yml`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`plugins/MobEnhance/config.yml`加载的`FileConfiguration`
- en: The default `FileConfiguration`, which is the `config.yml` file that is located
    within the default package of the `MobEnhancer` JAR file
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的`FileConfiguration`，这是位于`MobEnhancer` JAR文件默认包中的`config.yml`文件
- en: The default value of the data type (`0` for a `double/integer` data type, `false`
    for a Boolean value, and `null` for a String/`ItemStack`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的默认值（对于`double/integer`数据类型为`0`，对于布尔值为`false`，对于字符串/`ItemStack`为`null`）
- en: The first result that doesn't fail will be returned. A result will fail due
    to an invalid path or an invalid value. In the previous statement, an invalid
    path will occur if the `ZOMBIE` path is not within `config.yml`. An invalid value
    will mean that the value of the given path is not a `double data type`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回第一个未失败的结果。一个结果会因路径无效或值无效而失败。在前面的声明中，如果`ZOMBIE`路径不在`config.yml`中，则会出现无效路径。无效值意味着给定路径的值不是`double`数据类型。
- en: Now that we understand how to read the configured data, let's modify the plugin
    to use these customized values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何读取配置的数据，让我们修改插件以使用这些自定义值。
- en: Using configured settings within your plugin
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的插件中使用配置设置
- en: 'The current `EventHandler method` of the `MobEnhancer` plugin sets the health
    of zombies to `40`, where the number 40 is **hardcoded**. This means that the
    value of `40` is a part of the code itself, and this cannot be changed after the
    code is compiled. We wish to make this value **softcoded**, that is, we want to
    retrieve the value from an external source, which is `config.yml` in our case:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`MobEnhancer`插件的当前`EventHandler`方法将僵尸的生命值设置为`40`，其中数字40是**硬编码**的。这意味着`40`的值是代码本身的一部分，并且在代码编译后无法更改。我们希望将此值**软编码**，也就是说，我们希望从外部源获取该值，在我们的例子中是`config.yml`：'
- en: 'Currently, the `onMobSpawn` method is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`onMobSpawn`方法如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will work from this existing code. The `if` statement is no longer needed,
    because we don''t want to limit the plugin to zombies only. As discussed earlier,
    we also want to replace the hardcoded `40 value` with a `double` value, which
    will be read from the `config` file. Therefore, `40` should be replaced with `getConfig().getDouble(type)`.
    You will also have to change the variable type from `int` to `double`. The `Type`
    in this statement will be a string of the `Entity` type. Some examples of this
    are `ZOMBIE`, `SKELETON`, or any of the other entity types that are listed in
    `config.yml`. We already know that we can get the type of the entity that was
    spawned by using `event.getEntityType()`. However, this gives us `EntityType`
    in the `enum` form, and we require it in the `string` form. The `EntityType` page
    of the Bukkit API documentation informs us that we can call the `getname` method
    to return the string that we are looking for. The new `onMobSpawn` method is as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个现有代码开始工作。不再需要`if`语句，因为我们不想将插件限制为仅适用于僵尸。如前所述，我们还想将硬编码的`40值`替换为`double`值，该值将从`config`文件中读取。因此，`40`应替换为`getConfig().getDouble(type)`。您还必须将变量类型从`int`更改为`double`。此语句中的`Type`将是`Entity`类型的字符串。以下是一些示例，如`ZOMBIE`、`SKELETON`或`config.yml`中列出的任何其他实体类型。我们已经知道，我们可以使用`event.getEntityType()`获取由事件生成的实体的类型。然而，这给我们的是`enum`形式的`EntityType`，而我们需要的却是字符串形式。Bukkit
    API文档的`EntityType`页面告诉我们，我们可以调用`getName`方法来返回我们想要的字符串。新的`onMobSpawn`方法如下：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `EventHandler method` is nearly complete. We are allowing other people
    to set the `health` value. We want to ensure that they are entering a valid number.
    We don''t want the plugin to crash because it is being misused. We know that we
    are receiving a `double` value because even if the user sets a non-numeric value,
    we will be given the default value of `0` instead. However, not every valid double
    value will be useable in our situation. For example, we cannot set the health
    of an entity to a negative value. We also do not want to set the health to `0`,
    because this will instantly kill the entity. Therefore, we should only modify
    the health if the new health is set to a positive number. This can be done with
    a simple `if` statement, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`EventHandler方法`几乎完成了。我们允许其他人设置`health`值。我们想确保他们输入的是有效数字。我们不希望插件因为误用而崩溃。我们知道我们接收的是一个`double`值，因为即使用户设置了一个非数字值，我们也会得到默认值`0`。然而，并非每个有效的双精度值都适用于我们的情况。例如，我们不能将实体的健康值设置为负数。我们也不希望将健康值设置为`0`，因为这会立即杀死实体。因此，我们只应在新的健康值设置为正数时修改健康值。这可以通过一个简单的`if`语句来完成，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `MobEnhancer` plugin is now configurable and supports any type of creature.
    It is no longer limited to just zombies. The finished code will be similar to
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`MobEnhancer`插件现在可配置并支持任何类型的生物。它不再仅限于僵尸。完成的代码将类似于以下内容：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ItemStack within a configuration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置中的物品堆叠
- en: 'Next, we will expand the `MobEnhancer` plugin even further by allowing the
    option of giving armor and weapons to zombies and skeletons. In order to do this,
    we must first learn how to add an `ItemStack` object as an option in a configuration
    file. An `ItemStack` method is more complicated than a simple integer or double.
    It is an object that has many nested values. It may also include a **meta** value,
    which will have more nested values. **Meta** contains additional information for
    the item, such as a custom display name or lines of text that make up the lore
    of the item. The following is a sample of an `ItemStack` method in a `YAML` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过允许给僵尸和骷髅提供盔甲和武器的选项来进一步扩展`MobEnhancer`插件。为了做到这一点，我们首先必须学习如何在配置文件中将`ItemStack`对象作为选项添加。`ItemStack`方法比简单的整数或双精度值更复杂。它是一个具有许多嵌套值的对象。它也可能包括一个**元数据**值，该值将具有更多嵌套值。**元数据**包含关于物品的附加信息，例如自定义显示名称或构成物品附文的文本行。以下是一个`YAML`文件中的`ItemStack`方法示例：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once loaded, the item in the results is shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，结果中的项目将在以下屏幕截图显示：
- en: '![ItemStack within a configuration](img/00039.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![配置中的物品堆叠](img/00039.jpeg)'
- en: Only the **type** field is required. You can omit any other segment. The **type**
    refers to the type of material. These materials can be found in the API documentation
    under `org.bukkit.Material`, which can be viewed by visiting [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html).
    The **damage** is used to indicate how much damage an item has taken. For items
    such as `wool`, this will set the color of the wool. The **amount** will set the
    stack size. For example, I may have one sword or twenty logs. The **meta** includes
    additional information such as the color and pattern of a banner or the author
    and number of pages of a book. Given the path, `getConfig().getItemStack("SampleItem");`
    will retrieve the item.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要**类型**字段。你可以省略任何其他部分。**类型**指的是材料的类型。这些材料可以在API文档的`org.bukkit.Material`下找到，可以通过访问[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html)来查看。**损坏程度**用于表示物品受到了多少损坏。对于像羊毛这样的物品，这将设置羊毛的颜色。**数量**将设置堆叠大小。例如，我可能有一把剑或二十根木头。**元数据**包括额外的信息，如旗帜的颜色和图案，或书籍的作者和页数。给定路径`getConfig().getItemStack("SampleItem");`将检索该物品。
- en: YAML configuration hierarchy
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML配置层次结构
- en: Note the hierarchy when working with `ItemStack` in YAML. This is similar to
    how commands and permissions have nested values in the `plugin.yml` files. We
    can utilize a hierarchy within the `config` file to make it easier to use and
    understand.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用YAML中的`ItemStack`时，请注意层次结构。这与`plugin.yml`文件中命令和权限的嵌套值类似。我们可以在`config`文件中使用层次结构，使其更容易使用和理解。
- en: 'We want to give items to two types of mobs, namely `Zombie` and `Skeleton`.
    Each type will have a unique armor and weapon. This means that we will need 10
    different `ItemStack` classes. We can name them `ZombieHolding`, `SkeletonHolding`,
    `ZombieHelmet`, `SkeletonHelmet`, and so on. However, a hierarchy will be much
    more efficient. We will have a `Zombie` key and a `Skeleton` key. Within each
    zombie and skeleton, we will have a key for each item. The following is a sample
    of the hierarchy of the mob armor segment of the `config` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望给两种类型的怪物分配物品，即`Zombie`和`Skeleton`。每种类型将有一个独特的盔甲和武器。这意味着我们需要10个不同的`ItemStack`类。我们可以将它们命名为`ZombieHolding`、`SkeletonHolding`、`ZombieHelmet`、`SkeletonHelmet`等等。然而，层次结构将更加高效。我们将有一个`Zombie`键和一个`Skeleton`键。在每个僵尸和骷髅内部，我们将为每个物品有一个键。以下是一个`config`文件中怪物盔甲段落的层次结构示例：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The rest of the armor pieces can be added in the same way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的盔甲部件可以以相同的方式添加。
- en: 'If we want to retrieve the `ItemStack` method for the boots of a skeleton,
    we will use `getConfig().getItemStack("Skeleton.boots");`. Remember that the hierarchy
    is conveyed using a period. Here is a section that will be appended to `config.yml`,
    which includes mob armor, as discussed. We also have a `GiveArmorToMobs` Boolean
    value, which will be included to easily disable the mob armor feature:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取骷髅靴子的`ItemStack`方法，我们将使用`getConfig().getItemStack("Skeleton.boots");`。记住，层次结构是通过点来表示的。以下是一个将要附加到`config.yml`的段落，其中包含怪物盔甲，如前所述。我们还有一个`GiveArmorToMobs`布尔值，它将被包含以方便地禁用怪物盔甲功能：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Storing configuration values as variables
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置值存储为变量
- en: 'Retrieving a value from your plugin''s `config` file requires more time and
    resources than is required to access a local variable. Therefore, if you will
    be accessing a specific value very often, it is best to store it as a variable.
    We will want to do just this with the `GiveArmorToMobs` Boolean value. It is also
    a good idea to store the `ItemStack` armor locally to prevent creating a new one
    every time it is used. Let''s add the following variables above the methods of
    the main class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的插件`config`文件中检索值比访问本地变量所需的时间和资源更多。因此，如果你将非常频繁地访问特定的值，最好将其存储为变量。我们希望用`GiveArmorToMobs`布尔值做这件事。将`ItemStack`盔甲本地存储也是一个好主意，以防止每次使用时都创建一个新的盔甲。让我们在主类的方法上方添加以下变量：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will only write the code to set the item that a zombie or skeleton is holding.
    You can add the rest of the armor yourself, as it will be done the same way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只编写代码来设置僵尸或骷髅所持有的物品。其余的盔甲你可以自己添加，因为它们将以相同的方式进行。
- en: 'We want these values to be automatically stored whenever the `config` file
    is reloaded. Note that when the `config` file is initially loaded, it is actually
    being reloaded. To ensure that our data is saved every time the `config` file
    is reloaded, we will add additional code to the `reloadConfig` method of the plugin.
    This is the method that we call to execute the `/merl` command. The `reloadConfig`
    method is already included in every Java plugin, but we will modify it by overriding
    it. This is a lot like how we override the `onEnable` method. Overriding a method
    will prevent the existing code from being executed. This is not an issue for `onEnable`,
    because the method has no prior existing code. However, `reloadConfig` has the
    code that we still wish to execute. Therefore, we will use the following line
    of code to execute the existing code that we are overriding:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这些值在`config`文件重新加载时自动存储。请注意，当`config`文件最初加载时，它实际上正在被重新加载。为了确保我们的数据在每次`config`文件重新加载时都得到保存，我们将在插件的`reloadConfig`方法中添加额外的代码。这是我们调用以执行`/merl`命令的方法。`reloadConfig`方法已经包含在每一个Java插件中，但我们将通过重写它来修改它。这就像我们重写`onEnable`方法一样。重写一个方法将阻止现有代码的执行。对于`onEnable`来说这不是问题，因为该方法没有先前的现有代码。然而，`reloadConfig`有我们仍然希望执行的代码。因此，我们将使用以下代码行来执行我们正在重写的现有代码：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This line of code is very important. Once we have it, we can add our own code
    before or after it. In our case, we want to store the values after the `config`
    file has been reloaded. Therefore, the additional code should be placed after
    the preceding line of code. The completed overridden `reloadConfig` method looks
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码非常重要。一旦我们有了它，我们就可以在它之前或之后添加自己的代码。在我们的例子中，我们希望在`config`文件重新加载后存储这些值。因此，额外的代码应该放在前面代码的后面。修改后的`reloadConfig`方法看起来是这样的：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last code that we must write is to give armor to specific mobs. We will
    add this to the end of the `onMobSpawn` method. We only want to do this if `giveArmorToMobs`
    is set to `true`. Therefore, the block of code will be placed inside an `if` statement,
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写的最后一行代码是为特定的怪物提供护甲。我们将把这个添加到`onMobSpawn`方法的末尾。我们只想在`giveArmorToMobs`设置为`true`时这样做。因此，代码块将被放置在一个`if`语句中，如下所示：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can retrieve the entity''s armor using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码检索实体的护甲：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This gives us their equipment slots even though they may not include anything
    in them at the moment. To know more about this object and what you can do with
    it, visit its API documentation at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html).
    Now that we have `EntityEquipment`, setting the pieces of armor is simple.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这即使它们目前可能没有任何东西，也能给我们它们的装备槽位。要了解更多关于这个对象以及你可以用它做什么的信息，请访问其API文档[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html)。现在我们有了`EntityEquipment`，设置护甲件就简单了。
- en: 'We have two distinct sets of armor. Therefore, we must first check whether
    the entity is either a zombie, or a skeleton. We can do this by using an `if/else`
    statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的护甲集合。因此，我们首先需要检查实体是否是僵尸或骷髅。我们可以通过使用一个`if/else`语句来完成这个操作：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, using a `switch/case` block will be more efficient. Using `switch/case`
    in this scenario will look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`switch/case`块将更有效率。在这种情况下使用`switch/case`将看起来像这样：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `If/else` statements are used to check multiple conditions (*Is the entity
    a zombie?* or *Is the entity a skeleton?*). A `switch/case statement` saves time
    by asking a single question (*Which of the following is the type of the entity?*).
    The code within the correct `case` condition will then be executed. When a `break`
    condition is fulfilled, the `switch` statement is exited. If you do not end the
    case with `break`, then you will fall through to the next case and begin executing
    that code. In some circumstances, that is a good thing, but we do not want that
    to happen here. The default case, that is, if none of the other cases match, does
    not need to be included because there is no code in it. However, it does make
    the statement more conclusive, and the Java coding standards released by Oracle
    state that the default case should always be included.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`If/else`语句用于检查多个条件（*实体是僵尸吗？* 或 *实体是骨架吗？*）。`switch/case`语句通过询问单个问题（*以下哪个是实体的类型？*）来节省时间。然后，将执行正确的`case`条件内的代码。当满足`break`条件时，`switch`语句将退出。如果你不在`case`结束时使用`break`，那么你将进入下一个`case`并开始执行那段代码。在某些情况下，这是好事，但我们不希望在这里发生这种情况。默认情况，即如果没有其他情况匹配，不需要包含它，因为没有代码在其中。然而，它确实使语句更加明确，并且Oracle发布的Java编码标准指出，默认情况应该始终包含。'
- en: Within each of these cases, we will want to equip the correct set of armor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况中的每一个，我们都希望装备正确的盔甲套装。
- en: 'We should check each piece of armor to ensure that it is not `null` before
    applying it using the following code. This will prevent the plugin from crashing
    due to an invalid configuration:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用以下代码之前，我们应该检查每一件盔甲以确保它不是`null`。这将防止插件由于无效配置而崩溃：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We used the `clone` method here on the `ItemStack`. We don't want to hand out
    a single `ItemStack class` to every mob. Instead, we will create its clones so
    that each mob can have its own copy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`ItemStack`上的`clone`方法。我们不想给每个怪物分发单个`ItemStack`类。相反，我们将创建它的副本，以便每个怪物都可以有自己的副本。
- en: 'Equipping the remaining armor and equipping an armor to a skeleton is very
    similar. The overall block of code will look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 装备剩余的盔甲和将盔甲装备到骨架上非常相似。整体代码块将看起来像这样：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `clone` method should be called on each `ItemStack` class so that the original
    items remain undamaged.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在每个`ItemStack`类上调用`clone`方法，以确保原始物品不受损坏。
- en: With this, the `MobEnhancer` plugin now supports giving armor to mobs. Try it
    out on your server to see how it works. We only discussed giving armor to zombies
    and skeletons because most mobs, including creepers, spiders, and cows, cannot
    wear armor. If you want, try adding armor and items to other mobs to see what
    happens. Also, try giving mobs unique items. For example, skeletons can be given
    a sword or zombies can be given a bow. There is also a skull item that comes in
    different looks; you can make a mob wear it as a mask.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，`MobEnhancer`插件现在支持给怪物装备盔甲。在你的服务器上试用一下，看看它是如何工作的。我们只讨论了给僵尸和骨架装备盔甲，因为大多数怪物，包括爬行者、蜘蛛和牛，都不能穿盔甲。如果你想，尝试给其他怪物添加盔甲和物品，看看会发生什么。还可以尝试给怪物提供独特的物品。例如，骨架可以给一把剑，僵尸可以给一把弓。还有一个外观不同的头骨物品；你可以让怪物戴上它作为面具。
- en: 'You can even create skulls that represent a specific player, such as Notch,
    as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以创建代表特定玩家（如Notch）的头骨，如下面的截图所示：
- en: '![Storing configuration values as variables](img/00040.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![将配置值存储为变量](img/00040.jpeg)'
- en: 'The meta for the `NotchSkull` item is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotchSkull`物品的元数据如下：'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Play around with your new plugin to see what crazy items you can give to zombies
    and other mobs. The following screenshot illustrates an example of what you can
    accomplish by modifying the configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新插件上玩玩，看看你可以给僵尸和其他怪物提供什么疯狂物品。以下截图展示了通过修改配置可以实现的一个例子：
- en: '![Storing configuration values as variables](img/00041.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![将配置值存储为变量](img/00041.jpeg)'
- en: Accessing variables from another class
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个类访问变量
- en: The `MobEnhancer` class is growing in size. There is no need to place all the
    code within a single class. This class is currently extending the `JavaPlugin`
    class as well as implementing both the `Listener` and `CommandExecutor` interfaces.
    The program will be easier to understand if we split these into three unique classes.
    This process is known as **refactoring**. Throughout the process of developing
    software, you will come across code that may be outdated or inefficient and needs
    to be updated. Changing the code in this way is referred to as **refactoring**.
    Don't be discouraged if you need to refactor your code in the future; it is a
    common occurrence in software development, and there are many reasons for it to
    happen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`MobEnhancer` 类正在不断增长。没有必要将所有代码都放在一个类中。这个类目前正扩展 `JavaPlugin` 类，同时实现 `Listener`
    和 `CommandExecutor` 接口。如果我们将这些功能拆分为三个独特的类，程序将更容易理解。这个过程被称为 **重构**。在整个软件开发过程中，你可能会遇到可能过时或低效的代码，需要更新。以这种方式更改代码被称为
    **重构**。如果你未来需要重构代码，不要气馁；这在软件开发中是常见现象，并且有许多原因会导致这种情况发生。'
- en: You learned how to write more efficient code
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学会了如何编写更高效的代码
- en: API changes or new features require/allow code changes
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 变更或新功能需要/允许代码更改
- en: The existing code is difficult to read or debug
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的代码难以阅读或调试
- en: A method/class has grown too large to manage
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法/类变得太大，难以管理
- en: The purpose of the code has changed and it should now do something it was not
    originally intended to do
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的目的已经改变，现在它应该执行它最初并未打算执行的任务
- en: We will refactor `MobEnhancer` to split the code into three more manageable
    classes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构 `MobEnhancer`，将代码拆分为三个更易于管理的类。
- en: 'Create two new classes named `MobSpawnListener` and `MobEnhancerReloadCommand`.
    `MobEnhancer` will still be your main class. Therefore, it will still extend `JavaPlugin`.
    However, the two new classes will implement `Listener` and `CommandExecutor` respectively.
    Move the appropriate methods to their new classes, that is, `onMobSpawn` is an
    event handler and hence it belongs to the `Listener` class, and `onCommand` belongs
    to the `CommandExecutor` class. When moving the methods, you will see that several
    errors are introduced. This is because your methods no longer have access to the
    necessary methods and variables. Let''s first address the `MobEnhancerReloadCommand`
    class, as it has only one error. This error occurs at the following line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个新的类，分别命名为 `MobSpawnListener` 和 `MobEnhancerReloadCommand`。`MobEnhancer`
    仍然是你的主类。因此，它仍然会扩展 `JavaPlugin` 类。然而，这两个新类将分别实现 `Listener` 和 `CommandExecutor`
    接口。将适当的方法移动到它们的新类中，也就是说，`onMobSpawn` 是一个事件处理器，因此它属于 `Listener` 类，而 `onCommand`
    属于 `CommandExecutor` 类。在移动方法时，你会看到引入了几个错误。这是因为你的方法不再能够访问必要的方法和变量。让我们首先解决 `MobEnhancerReloadCommand`
    类，因为它只有一个错误。这个错误发生在以下行：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `reloadConfig` method is in the `JavaPlugin` class, which is no longer merged
    with the `CommandExector` class. We need to access the `JavaPlugin` object from
    this separate class. The easiest way to do this is by using a static variable.
    If a variable or method is static, then it does not change across different instances
    of the class. This allows us to refer to the variable from a static context. You
    have done this before when using the `Bukkit` class. The methods that you called
    were static. Therefore, you could access them using the `Bukkit` class and not
    a unique `Bukkit` object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`reloadConfig` 方法位于 `JavaPlugin` 类中，它不再与 `CommandExecutor` 类合并。我们需要从这个独立的类中访问
    `JavaPlugin` 对象。最简单的方法是使用静态变量。如果一个变量或方法是静态的，那么它不会在不同类的实例之间改变。这允许我们从静态上下文中引用变量。你之前在使用
    `Bukkit` 类时已经这样做过了。你调用的方法是静态的。因此，你可以使用 `Bukkit` 类而不是一个独特的 `Bukkit` 对象来访问它们。'
- en: To explain this better, let's imagine that you have a plugin that gives Minecraft
    players bank accounts. Therefore, you will have a class to represent a player's
    bank account. This class can be called `PlayerAccount`. You will have numerous
    `PlayerAccount` objects, one for each player on the server. Within this class,
    you may have a variable that defines a limit of how much money the account can
    hold. Let's name this variable `accountLimit`. If we want each account to have
    a maximum amount of money of `1000`, then the `accountLimit` should be static.
    If we wish to increase the limit to `2000`, then we set `accountLimit` to `2000`
    by using `PlayerAccount.accountLimit = 2000;`. Then, all the players now have
    an account limit of `2000`. If we want some players to have a limit of `1000`
    and others to have a limit of `2000`, then we should not use a static variable.
    Without `accountLimit` being static, if we set `accountLimit` to `2000` for instance
    A of `PlayerAccount`, it would still be `1000` for instance B of `PlayerAccount`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们想象你有一个插件，它为 Minecraft 玩家提供银行账户。因此，你将有一个类来表示玩家的银行账户。这个类可以称为 `PlayerAccount`。你将有许多
    `PlayerAccount` 对象，每个服务器上的玩家一个。在这个类中，你可能有一个变量定义了账户可以持有的金额上限。让我们称这个变量为 `accountLimit`。如果我们想每个账户的最大金额为
    `1000`，那么 `accountLimit` 应该是静态的。如果我们想将限制提高到 `2000`，那么我们可以通过 `PlayerAccount.accountLimit
    = 2000;` 将 `accountLimit` 设置为 `2000`。然后，所有玩家现在都有 `2000` 的账户限制。如果我们想让一些玩家的限制为 `1000`，而其他玩家的限制为
    `2000`，那么我们不应该使用静态变量。如果没有将 `accountLimit` 设置为静态，那么如果我们为 `PlayerAccount` 的实例 A
    设置 `accountLimit` 为 `2000`，实例 B 的 `accountLimit` 仍然是 `1000`。
- en: 'Storing the plugin as a static variable within the main class will benefit
    us. Above your current variables, add a `static` `JavaPlugin` variable named `plugin`,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在主类中将插件存储为静态变量将对我们有益。在你的当前变量上方，添加一个名为 `plugin` 的 `static` `JavaPlugin` 变量，如下所示：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We must also instantiate this variable within the `onEnable` method. This can
    simply be done using `plugin = this;`. Now, we can access the plugin instance
    by using `MobEnhancer.plugin`. Therefore, where we previously had `reloadConfig();`,
    we will now have `MobEnhancer.plugin.reloadConfig()`. This will fix the errors
    in `MobEnhancerReloadCommand`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `onEnable` 方法中实例化这个变量。这可以通过 `plugin = this;` 简单完成。现在，我们可以通过使用 `MobEnhancer.plugin`
    来访问插件实例。因此，我们之前有 `reloadConfig();`，现在我们将有 `MobEnhancer.plugin.reloadConfig()`。这将修复
    `MobEnhancerReloadCommand` 中的错误：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MobSpawnListener` requires a similar modification, as the plugin object is
    needed to call the `getConfig` method.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`MobSpawnListener` 需要进行类似的修改，因为需要插件对象来调用 `getConfig` 方法。'
- en: 'You will continue seeing errors in `MobSpawnListener`. It is attempting to
    access variables that are still in the main class. Let''s move the mob armor variables
    to the `Listener` class, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将继续在 `MobSpawnListener` 中看到错误。它正在尝试访问仍然在主类中的变量。让我们将怪物护甲变量移动到 `Listener` 类中，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We must also modify the `reload` method within `MobEnhancer.java` to match
    the new location of the variables. For example, instead of `giveArmorToMobs`,
    we should now have `MobSpawnListener.giveArmorToMobs`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改 `MobEnhancer.java` 中的 `reload` 方法，以匹配变量的新位置。例如，我们不应该使用 `giveArmorToMobs`，而应该使用
    `MobSpawnListener.giveArmorToMobs`：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Even with this change, we will still be given an error, which reads `giveArmorToMobs`
    **has private access in** `MobSpawnListener`. Each variable is `private`, which
    means that they cannot be accessed from another class. We wish to be able to access
    them from the other classes. Hence, we will remove the private modifier. After
    doing so, we will be given yet another error. This new error reads **non-static
    variable** `giveArmorToMobs` **cannot be referenced from a static context**. This
    happens because the variables are not defined as static variables. Before you
    simply change these variables so that they can be static, ensure that it makes
    sense for them to be static. Refer to the earlier discussion about when static
    variables should be used. In this situation, we will only have one value of each
    of these variables. Hence, we do want to make them static, as shown in the following
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这个更改，我们仍然会收到一个错误，错误信息为 `giveArmorToMobs` 在 `MobSpawnListener` 中**具有私有访问权限**。每个变量都是
    `private` 的，这意味着它们不能从另一个类中访问。我们希望能够从其他类中访问它们。因此，我们将移除私有修饰符。这样做之后，我们还会收到另一个错误。这个新的错误信息为
    **非静态变量** `giveArmorToMobs` **不能从静态上下文中引用**。这是因为变量没有被定义为静态变量。在你简单地将这些变量改为静态变量之前，请确保这样做是有意义的。参考之前关于何时应该使用静态变量的讨论。在这种情况下，我们只想为每个变量设置一个值。因此，我们确实希望将它们设置为静态，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are only two lines remaining in the code that require our attention.
    These two lines are used to register the event listener and command executor.
    When calling the `registerEvents` method, two parameters are required. The first
    parameter is `Listener`, and the second one is `Plugin`. The `this` keyword references
    the plugin. Therefore, it is fine as the second parameter. However, for the first
    parameter, you must pass an instance of the `Listener` class. We have done this
    in [Chapter 7](part0051_split_000.html#1GKCM1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 7. The Bukkit Event System"), *The Bukkit Event System*, when creating
    the `NoRain` plugin. The same applies to the command executor. We must pass an
    instance of the `MobEnhancerReloadCommand` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码中只有两行需要我们注意。这两行用于注册事件监听器和命令执行器。在调用`registerEvents`方法时，需要两个参数。第一个参数是`Listener`，第二个参数是`Plugin`。`this`关键字引用插件。因此，作为第二个参数是合适的。然而，对于第一个参数，你必须传递`Listener`类的实例。我们在[第7章](part0051_split_000.html#1GKCM1-b66e70deee6e4ed481db4b113e303f23
    "第7章。Bukkit事件系统")中这样做过，即创建`NoRain`插件时，*Bukkit事件系统*。同样适用于命令执行器。我们必须传递`MobEnhancerReloadCommand`类的实例：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This gets rid of all the errors that resulted from splitting the project into
    multiple classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了由于将项目拆分为多个类而产生的所有错误。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You are now familiar with using a `YAML` configuration file. You can load custom
    values from a `config.yml` file and use them within the plugin. Doing so will
    greatly expand your ability to create unique projects that will be beneficial
    to multiple server administrators. Try adding configurable options to some of
    your previous projects. For instance, if you created the plugin that sends a message
    when a creeper is about to explode, add a configuration file to set the area within
    which the players must be in order to see the message. Now that you are introduced
    to `FileConfiguration` which can be used with the Bukkit API, in the next chapter,
    we will save the plugin's data using the same `FileConfiguration` method so that
    we can load it the next time the plugin is enabled.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经熟悉了如何使用`YAML`配置文件。你可以从`config.yml`文件中加载自定义值并在插件中使用它们。这样做将大大扩展你创建对多个服务器管理员有益的独特项目的能力。尝试将可配置选项添加到你的某些先前项目中。例如，如果你创建了一个当爬行者即将爆炸时发送消息的插件，添加一个配置文件来设置玩家必须位于其中的区域，以便看到消息。现在你已经了解了可以与Bukkit
    API一起使用的`FileConfiguration`，在下一章中，我们将使用相同的`FileConfiguration`方法保存插件的数据，以便我们可以在插件下次启用时加载它。
