- en: 'Chapter 12: Cross-Cutting Concerns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章：横切关注点
- en: Throughout the previous chapters, we have explored many different aspects of
    Java application development. Starting from the beginning of the development life
    cycle (including requirements collection and architecture design), we've focused
    on many different technological aspects, including frameworks and middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经探讨了Java应用开发的许多不同方面。从开发生命周期的开始（包括需求收集和架构设计），我们关注了许多不同的技术方面，包括框架和中间件。
- en: 'At this point, several cross-cutting concerns need to be examined, regardless
    of the kind of application we are building and the architectural style we choose.
    In this chapter, we are going to look at a few of these aspects, as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，需要检查几个横切关注点，无论我们正在构建什么类型的应用以及我们选择什么类型的架构风格。在本章中，我们将探讨这些方面的几个方面，如下所示：
- en: Identity management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份管理
- en: Security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Resiliency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: The cross-cutting concerns discussed in this chapter provide some very useful
    information about topics that are crucial for a project's success. Indeed, implementing
    identity management, security, and resiliency in the right way can be beneficial
    to the success of our application, both from an architectural point of view (by
    providing elegant, scalable, and reusable solutions) and a functional point of
    view (by avoiding reinventing the wheel and approaching these issues in a standardized
    way).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的横切关注点提供了一些关于对项目成功至关重要的主题的非常有用的信息。确实，以正确的方式实现身份管理、安全和弹性对我们的应用的成功有益，无论是从架构的角度（通过提供优雅、可扩展和可重用的解决方案）还是从功能的角度（通过避免重复造轮子和以标准化的方式处理这些问题）。
- en: 'With that said, let''s get started with a classic issue in application development:
    identity management.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们从应用开发中的一个经典问题开始：身份管理。
- en: Identity management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份管理
- en: '**Identity management** is a broad concept that deals with many different aspects
    and involves interaction with many different systems.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份管理**是一个广泛的概念，涉及许多不同的方面，并涉及与许多不同系统的交互。'
- en: This concept is indeed related to identifying a user (that is, who is asking
    for a particular resource or functionality) and checking the associated permissions
    (whether they are allowed to do so and so, or not). So, it's easy to see how this
    is a core concept, common in many applications and many components inside the
    application. If we have different functionalities provided by different components
    (as in a microservices application), then obviously each of them will need to
    perform the same kind of checks, to be sure about the user's identity and act
    accordingly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念确实与识别用户（即，谁在请求特定的资源或功能）以及检查相关的权限（他们是否被允许这样做，或者不被允许）有关。因此，很容易看出这是一个核心概念，在许多应用和许多应用组件中都很常见。如果我们有不同的组件提供不同的功能（如微服务应用），那么显然每个组件都需要执行相同类型的检查，以确保用户的身份并相应地行动。
- en: However, having an ad hoc identity management infrastructure for each application
    can be considered an *antipattern*, especially in a complex enterprise environment,
    since each application (or component) has the same goal of identifying the user
    and its permissions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个应用都有一个定制的身份管理基础设施可以被认为是一种*反模式*，尤其是在复杂的企业环境中，因为每个应用（或组件）都有相同的目标：识别用户及其权限。
- en: For this reason, a common approach is to define a company-wide identity management
    strategy and adopt it in all of the applications, including the off-premises and
    microservices architectures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常见的做法是定义一个公司范围内的身份管理策略，并在所有应用中采用，包括离场和微服务架构。
- en: 'Now, to come back to the fundamentals, identity management is basically about
    two main concepts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到基本概念，身份管理基本上涉及两个主要概念：
- en: '**Authentication**: This is a way of ensuring, with the maximum possible degree
    of certainty, that the person asking for access to a resource (or to perform an
    action) is the person that they claim to be. Here is a diagram of the username
    and password authentication method:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：这是一种确保以最大可能程度的确定性，请求访问资源（或执行操作）的人就是他们所声称的人的方法。以下是一个用户名和密码认证方法的图示：'
- en: '![Figure 12.1 – Authentication'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 认证'
- en: '](img/Figure_12.1_B16354.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16354.jpg)'
- en: Figure 12.1 – Authentication
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 认证
- en: '**Authorization**: This is a way of declaring who can access each resource
    and perform a specific action, as shown in the following diagram. This may involve
    authenticated and non-authenticated entities (sometimes referred to as anonymous
    access).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是一种声明谁可以访问每个资源并执行特定操作的方式，如下面的图所示。这可能涉及已验证和未验证的实体（有时称为匿名访问）。'
- en: '![Figure 12.2 – Authorization'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 授权'
- en: '](img/Figure_12.2_B16354.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B16354.jpg)'
- en: Figure 12.2 – Authorization
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 授权
- en: 'Both authentication and authorization include two main scenarios:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权包括两个主要场景：
- en: '**Machine to machine**: This is when the entity requesting access is an application,
    for example, in batch calculations or other processes that do not directly involve
    the interaction of a human user. This is also called **server to server**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器到机器**：这种情况是指请求访问的实体是一个应用程序，例如在批量计算或其他不直接涉及人类用户交互的过程中。这也被称为**服务器到服务器**。'
- en: '**Interactive** or **use**: This is the other scenario, with a human operator
    interacting directly with the resource, hence requesting authentication and authorization.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式**或**使用**：这是另一种场景，其中人类操作员直接与资源交互，因此请求身份验证和授权。'
- en: Now that we have the hang of some basic concepts, let's learn a bit more about
    authentication and authorization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了某些基本概念，让我们进一步了解身份验证和授权。
- en: Authentication
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'As stated, **authentication** is about verifying that the entity performing
    a request (be it a human or a machine) is who they claim to be. There are many
    different ways to perform this verification. The main differentiator is what the
    user presents (and needs to be checked). It falls into one of the following three
    categories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，**身份验证**是验证执行请求的实体（无论是人类还是机器）是否是他们所声称的那样。有许多不同的验证方式。主要区别在于用户呈现的内容（以及需要检查的内容）。它属于以下三个类别之一：
- en: '**Something that the user knows**: This refers to secrets, such as passwords,
    pins, or similar things, like the sequence to unlock a mobile phone.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户知道的东西**：这指的是秘密，例如密码、PIN码或类似的东西，比如解锁手机的序列。'
- en: '**Something that the user has**: This refers to physical devices (such as badges
    or hardware tokens) or software artifacts (such as certificates and software tokens).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户拥有的东西**：这指的是物理设备（如徽章或硬件令牌）或软件工件（如证书和软件令牌）。'
- en: '**Something that the user is**: In this case, authentication is linked to biometric
    factors (such as a fingerprint or face identification), or similar things like
    a signature.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户是的东西**：在这种情况下，身份验证与生物识别因素（如指纹或面部识别）或类似的东西（如签名）相关联。'
- en: 'There are several things to consider here, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要考虑的事项，如下所述：
- en: The first is that a piece of public information, such as a username, may be
    associated with the authentication factor. In this case, multiple users can share
    the same factor (such as a password or a badge) and we can tell them apart by
    using the username. The unintentional occurrence of this pattern (such as two
    users choosing the same password by accident) may be harmless, whereas intentional
    implementations (multiple users using the same badge) can be a security issue.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是，一些公开信息，如用户名，可能与身份验证因素相关联。在这种情况下，多个用户可以共享相同的因素（如密码或徽章），我们可以通过使用用户名来区分他们。这种模式的无意发生（如两个用户意外选择相同的密码）可能无害，而有意实施（多个用户使用相同的徽章）可能是一个安全问题。
- en: You also have to consider that a combination of more than one authentication
    factor is considered a best practice and is encouraged for stronger security implementations.
    This is called **multi-factor authentication** (**MFA**). Moreover, in some specific
    environments (such as banking) this may be mandated by specific regulations. Strong
    authentication is often one of those specifics and refers to an authentication
    process leveraging at least two different factors, belonging to different groups
    (for example, *something that a user knows*, plus *something that a user has*).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还必须考虑，超过一个身份验证因素的组合被认为是最佳实践，并且鼓励用于更强的安全实现。这被称为**多因素身份验证**（**MFA**）。此外，在某些特定环境（如银行）中，这可能是由特定法规规定的。强身份验证通常是这些具体要求之一，它指的是利用至少两个不同因素的身份验证过程，这些因素属于不同的组（例如，*用户知道的东西*，加上*用户拥有的东西*）。
- en: Some authentication factors may be subject to policies. The most common examples
    are password rules (length, complexity) or expiration policies (forcing a user
    to change a factor after a certain time where possible).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些认证因素可能受到策略的限制。最常见的例子是密码规则（长度、复杂性）或过期策略（在可能的情况下，强制用户在一段时间后更改因素）。
- en: Of course, an immediate concern that comes to mind is how and where to store
    the information relevant for implementing authentication – in other words, where
    to save our usernames and passwords (and/or the other kinds of secrets used for
    authentication).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个立即浮现的问题是如何以及在哪里存储与实现认证相关的信息——换句话说，在哪里保存我们的用户名和密码（以及/或用于认证的其他类型的秘密）。
- en: The most common technology used for this goal is **LDAP**, which is short for
    **Lightweight Directory Access Protocol**. LDAP is a protocol for storing user
    information. An LDAP server can be seen as a standard way to store information
    about users, including things such as usernames, emails, phone numbers, and, of
    course, passwords. Being quite an old standard, around since the 1990s, it's widely
    adopted and compatible with a lot of other technology.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的最常见的技术是**LDAP**，即**轻量级目录访问协议**。LDAP是存储用户信息的协议。LDAP服务器可以被视为存储用户信息（包括用户名、电子邮件、电话号码等）的标准方式。作为一个相当古老的标准，自1990年代以来一直存在，它被广泛采用并且与许多其他技术兼容。
- en: Without going into too much detail, we can look at it as just another datastore,
    which we can connect to using a connection URL. Then, we can query the datastore
    by passing specific attributes to search for specific entries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，我们可以将其视为只是一个数据存储库，我们可以通过连接URL来连接它。然后，我们可以通过传递特定的属性来查询数据存储库，以搜索特定的条目。
- en: The authentication operation against an LDAP server is called **Bind**. LDAP
    can typically encrypt the passwords in various ways. One very famous implementation
    of an LDAP server (technically, an extension of it, providing more services than
    just the standard) is **Microsoft Active Directory**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对LDAP服务器的认证操作称为**绑定**。LDAP通常可以以各种方式加密密码。一个非常著名的LDAP服务器实现（技术上，是其扩展，提供比标准更多的服务）是**微软活动目录**。
- en: LDAP is not the only way to store user information (including passwords) but
    is likely the only widely adopted standard. Indeed, it is common to store user
    information in relational databases, but this is almost exclusively done in a
    custom way, meaning that there is no standard naming nor formats for tables and
    columns storing usernames, passwords, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP不是存储用户信息（包括密码）的唯一方式，但可能是唯一广泛采用的标准。实际上，用户信息通常存储在关系数据库中，但这几乎完全是自定义的，这意味着没有标准命名也没有表格和列的格式，用于存储用户名、密码等。
- en: One other way to store user information is to use files, but this is an approach
    that's not scalable nor efficient. It works mostly for a small set of users or
    testing purposes. A common file format used to store user information is `.htpasswd`,
    which is simply a flat file storing a username and password, in a definition originally
    used by the Apache httpd server for authentication purposes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存储用户信息的另一种方式是使用文件，但这不是一个可扩展或高效的方法。它主要用于一小组用户或测试目的。用于存储用户信息的常见文件格式是`.htpasswd`，它只是一个简单的平面文件，存储用户名和密码，最初由Apache
    httpd服务器用于认证目的。
- en: 'It is a commonly accepted best practice to store passwords in an encrypted
    form whenever possible. This is a crucial point. Whatever the user store technology
    (such as LDAP or a database), it is crucial that the passwords are not stored
    in cleartext. The reason is simple and quite obvious: if our server gets compromised
    in some way, the attacker should not be able to access the stored passwords.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，以加密形式存储密码是一种普遍接受的最佳实践。这是一个关键点。无论用户存储技术（如LDAP或数据库）如何，密码都不应以明文形式存储。原因简单且明显：如果我们的服务器以某种方式被入侵，攻击者不应能够访问存储的密码。
- en: I have used the word *encryption* generically. A solution, indeed, can be to
    encrypt the passwords with a symmetrical algorithm, such as AES. Symmetrical encryption
    implies that by using a specific secret key, I can make the password unusable.
    Then, I can again decrypt the password using the same key.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了“加密”这个词来泛指。一个解决方案确实可以是使用对称算法，如AES来加密密码。对称加密意味着通过使用一个特定的密钥，我可以使密码不可用。然后，我可以用同样的密钥再次解密密码。
- en: This approach is useful, but we will still need to store the key securely since
    an attacker with the encrypted password and the key can access the original password
    as cleartext. Hence, a more secure way is to store the hashed password.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很有用，但我们仍然需要安全地存储密钥，因为攻击者如果拥有加密的密码和密钥，就可以以明文形式访问原始密码。因此，更安全的方法是存储散列密码。
- en: By hashing a password, you transform it into an encrypted string. The great
    thing, compared to the previous approach, is that we are implementing asymmetrical
    encryption. There is no way (if we are using a proper algorithm) to reverse the
    encrypted string to the original one in a reasonable amount of time. In this way,
    we can store the encrypted passwords without requiring any key. To validate the
    passwords provided by the clients, we simply apply the same hashing algorithm
    used for saving it initially and compare the results. Even if an attacker gains
    access to our user information store, the stolen encrypted passwords will be more
    or less useless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过散列密码，你将其转换为一个加密字符串。与之前的方法相比，好处在于我们正在实施非对称加密。如果我们使用的是合适的算法，那么在合理的时间内将加密字符串反转回原始字符串是不可能的。这样，我们可以在不要求任何密钥的情况下存储加密密码。为了验证客户端提供的密码，我们只需应用最初保存时使用的相同散列算法，并比较结果。即使攻击者获得了我们的用户信息存储库的访问权限，窃取的加密密码也将基本上无用。
- en: Important Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It's certainly better to encrypt a password rather than store it in cleartext;
    even the encrypted ones are not 100% secure. Indeed, even if it is impossible,
    in theory, to reconstruct the original password from a hashed value, some techniques
    attempt to do so. In particular, it is possible to try to run a brute-force attack,
    which basically tries a lot of passwords (from a dictionary, or simply random
    strings), hashes them, and compares the output with a known actual hash. A more
    efficient alternative is to use **rainbow tables**, which are basically tables
    of passwords and their pre-computed hashes. Defenses against these kinds of techniques
    are possible, however, by using longer and more complex passwords and using salting,
    which is a way to add some more randomness to hashed passwords.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，加密密码比以明文形式存储密码要好；即使是加密的密码也不是100%安全的。实际上，即使理论上从散列值中重建原始密码是不可能的，一些技术也试图这样做。特别是，可以尝试进行暴力攻击，这基本上是尝试大量的密码（来自字典或简单的随机字符串），对它们进行散列，并将输出与已知的实际散列值进行比较。一个更有效的方法是使用**彩虹表**，这基本上是密码及其预先计算的散列值的表。然而，通过使用更长和更复杂的密码以及使用盐值（一种向散列密码添加更多随机性的方法），可以对这些技术进行防御。
- en: Authorization
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: User **authorization** is complementary to authentication. Once we are sure
    that a user is who they claim to be (using authentication), we have to understand
    what they are allowed to do. This means which resources and which operations they
    are permitted to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户**授权**是身份验证的补充。一旦我们确信用户是他们所声称的人（使用身份验证），我们就必须了解他们被允许做什么。这意味着他们被允许使用哪些资源和哪些操作。
- en: The most basic form of authorization is no authorization. In simple systems,
    you can allow an authenticated user to do everything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的授权形式是没有授权。在简单的系统中，你可以允许经过身份验证的用户做任何事情。
- en: A better approach, in real-world applications, is to grant granular permissions,
    differentiated for different kinds of users. This is basically the concept of
    roles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，一个更好的方法是授予粒度化的权限，针对不同类型的用户进行区分。这基本上是角色的概念。
- en: A **role** can be considered a link between a set of users and a set of permissions.
    It is usually mapped to a job function or a department and is defined by a list
    of permissions, in terms of resources that can be accessed and functionalities
    that can be used. Each user can be associated with a role, and with this, they
    inherit the permissions associated with that role.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色**可以被视为一组用户和一组权限之间的链接。它通常映射到一个工作职能或一个部门，并且通过可以访问的资源列表和可以使用的功能来定义。每个用户都可以与一个角色相关联，并且因此继承该角色相关的权限。'
- en: This kind of authorization methodology is called **Role-Based Access Control**
    (**RBAC**). Based on the kind of RBAC implementation, each user can be assigned
    to more than one role, with different kinds of compositions. Normally, policies
    are additive, meaning that a user belonging to more than one role gets all the
    permissions from both roles. However, this may be subject to slight changes, especially
    if the permissions conflict, up to the point that there may be implementations
    denying the possibility of having more than one role associated with each user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种授权方法被称为**基于角色的访问控制**（**RBAC**）。基于RBAC实现，每个用户可以分配给多个角色，具有不同的组合。通常，策略是累加的，这意味着属于多个角色的用户从这两个角色中获得所有权限。然而，这可能会略有变化，特别是如果权限冲突，甚至可能存在拒绝每个用户关联多个角色的实现。
- en: Another aspect of RBAC implementations concerns role inheritance. Some RBAC
    implementations employ the concept of a hierarchy of roles, meaning that a role
    can inherit the set of permissions associated with its parent role. This allows
    for a modular system. In the Java Enterprise world, **JAAS** (short for **Java
    Authentication and Authorization Service**) is the implementation standard for
    authentication and authorization. It can be regarded as a reference implementation
    of an RBAC-based security system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC实现的一个方面是角色继承。一些RBAC实现采用角色层次结构的概念，这意味着一个角色可以继承与其父角色关联的权限集。这允许构建模块化系统。在Java企业领域，**JAAS**（即**Java
    Authentication and Authorization Service**）是身份验证和授权的实现标准。它可以被视为基于RBAC的安全系统的参考实现。
- en: An alternative to RBAC is `if then` statement, where more than one attribute
    can be combined with `AND`, `OR`, and other logic operators. The attributes can
    be simply related to the user (such as checking whether a user belongs to a particular
    group), or to other conditions (such as the time of the day, the source IP, and
    the geographical location).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC（基于角色的访问控制）的替代方案是`if then`语句，其中可以结合多个属性使用`AND`、`OR`和其他逻辑运算符。这些属性可以简单地与用户相关（例如检查用户是否属于特定组），或者与其他条件相关（例如一天中的时间、源IP地址和地理位置）。
- en: '`SELinux`, which is a security module underlying some **Linux** OS variants
    (including **Android**) is a common implementation of PBAC.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELinux`是一种安全模块，它是某些**Linux**操作系统变体（包括**Android**）的底层安全模块，是PBAC（基于属性的访问控制）的常见实现。'
- en: Identity and Access Management
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份和访问管理
- en: '**Identity and Access Management** (**IAM**) is a term usually associated with
    systems that provide authentication, authorization, and other identity security
    services to client applications. The function of an IAM system is to implement
    such features in a unified way, so each application can directly use it and benefit
    from an adequate level of security. Other than what we have seen here in terms
    of authentication and authorization, an IAM system also provides the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份和访问管理**（**IAM**）是一个通常与提供身份验证、授权和其他身份安全服务的系统相关的术语。IAM系统的功能是以统一的方式实现这些功能，以便每个应用程序可以直接使用它并从中受益于适当的安全级别。除了我们在身份验证和授权方面看到的内容之外，IAM系统还提供以下功能：'
- en: '**Decoupling the user store**: This means that usernames, passwords, and other
    information can be stored in the technology of choice (such as LDAP or a database),
    and the client application does not need to know the implementation details. An
    IAM can also usually unify multiple storage systems in a unique view. And of course,
    if the user storage system needs to change (such as being moved from LDAP to a
    database), or we have to add a new one, we don''t need to make any changes to
    the client applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦用户存储**：这意味着用户名、密码和其他信息可以存储在所选技术中（如LDAP或数据库），客户端应用程序不需要知道实现细节。IAM通常还可以在统一视图中统一多个存储系统。当然，如果用户存储系统需要更改（例如从LDAP迁移到数据库），或者我们必须添加一个新的系统，我们不需要对客户端应用程序进行任何更改。'
- en: '**Federating other authentication systems (such as more IAM systems)**: This
    can be particularly useful in shared systems where access is required from more
    than one organization. Most of us have experienced something like this when accessing
    a service through a third-party login using **Google** or **Facebook**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦其他认证系统（如更多的IAM系统）**：这在需要从多个组织访问共享系统的场景中尤其有用。我们大多数人都有过通过第三方登录（如使用**Google**或**Facebook**）访问服务的类似经历。'
- en: '**Single sign-on** (**SSO**): This means that we only need to log in (and log
    out) once, and then we can directly access the set of applications configured
    in the IAM.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录**（**SSO**）：这意味着我们只需要登录（和注销）一次，然后就可以直接访问 IAM 中配置的应用程序集。'
- en: 'There are many different ways (and standards) to implement such features, depending
    on each specific IAM product used. Such standards often boil down to some key
    concepts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类功能（和标准）的方式（和标准）有很多，这取决于所使用的每个特定 IAM 产品。这些标准通常归结为一些关键概念：
- en: '**Provisioning and connecting each application managed by the IAM**: This usually
    means configuring each application to point to the IAM. In the Java world, a common
    way to achieve this is to configure a servlet filter to intercept all requests.
    Other alternatives are agent software or reverse proxies that implement the same
    functionality of intercepting all the requests coming to our application.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为 IAM 管理的每个应用程序提供和连接**：这通常意味着配置每个应用程序以指向 IAM。在 Java 世界中，实现这一点的常见方法是为所有请求配置一个
    servlet 过滤器。其他替代方案是代理软件或反向代理，它们实现了拦截所有进入我们应用程序的请求的相同功能。'
- en: '**Checking each request coming to each application**: In case a request needs
    to be authenticated (because it is trying to access a protected resource or perform
    a limited action), check whether the client is already authenticated. If not,
    redirect to an authentication system (such as a login form).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查每个应用程序收到的每个请求**：如果请求需要认证（因为它试图访问受保护的资源或执行有限的操作），则需要检查客户端是否已经认证。如果没有，则重定向到认证系统（例如登录表单）。'
- en: '**Identifying the user**: Once the client provides a valid authentication credential
    (such as a username and password), it must be provided with a unique identifier,
    which is regarded as the *ID card* of the user, used to recognize it across different
    requests (and potentially log in to other applications in an SSO scenario). To
    do so, the client is often provided with a session token, which may then be stored
    by the client application (as in a cookie) and usually has a limited lifespan.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别用户**：一旦客户端提供了有效的认证凭证（如用户名和密码），它必须提供一个唯一的标识符，这被视为用户的*身份证*，用于在不同请求中识别它（以及在单点登录场景中登录到其他应用程序）。为此，客户端通常会提供一个会话令牌，然后客户端应用程序（如
    cookie）可能会存储该令牌，并且通常具有有限的生命周期。'
- en: A standard way to implement this kind of scenario is the **OAuth protocol**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类场景的标准方式是**OAuth 协议**。
- en: However, IAM is not the only security aspect that we need to take care of in
    a cloud-native architecture. Indeed, the topic of security in an application (especially
    in a cloud-native one) includes many more considerations. We are going to discuss
    some of them in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IAM 并不是我们需要在云原生架构中关注的唯一安全方面。实际上，应用程序（尤其是在云原生应用程序中）的安全问题包括许多更多的考虑因素。我们将在下一节中讨论其中的一些。
- en: Security
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: '**Security** is a very complex aspect, as well as a foundational and crucial
    one. Unless security is your main focus (which is unlikely if you are in charge
    of defining the whole architecture of a cloud-native application), chances are
    that you will have some experts to work with. Nevertheless, it''s important to
    take care of some simple security implications right from the outset of software
    implementation (including requirement collection, design, and development), to
    avoid going through a security check after you have completed architecture and
    development, only to realize that you have to make a lot of changes to implement
    security (thereby incurring costs and delays).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**是一个非常复杂且基础且关键的一个方面。除非安全是你的主要关注点（如果你负责定义云原生应用程序的整体架构，这种情况不太可能），否则你很可能会与一些专家合作。尽管如此，从软件实施的开始（包括需求收集、设计和开发）就关注一些简单的安全影响是很重要的，以避免在完成架构和开发后进行安全检查，结果发现你需要进行大量的更改来实现安全（从而产生成本和延误）。'
- en: This approach is often referred to as **shift-left security**, and it's a common
    practice in **DevOps** teams.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常被称为**左移安全**，并且在**DevOps**团队中是一种常见的做法。
- en: Intrinsic software security
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内在软件安全
- en: The first aspect to take care of is **intrinsic software security**. Indeed,
    software code can be subject to security vulnerabilities, often due to bugs or
    poor software testing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要关注的是**内在软件安全**。确实，软件代码可能会受到安全漏洞的影响，这通常是由于错误或软件测试不佳造成的。
- en: 'The main scenario is software behaving unexpectedly as a result of a malformed
    or maliciously crafted input. Some common security issues of this kind are the
    following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主要场景是软件由于格式错误或恶意构造的输入而表现出意外行为。这类常见的安全问题如下：
- en: '**SQL injection**: A malicious parameter is passed to the application and is
    attached to a SQL string. The application then performs a special SQL operation
    that is different from the expected operation and can allow the attacker access
    to unauthorized data (or even to damage existing data).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL注入**：一个恶意参数被传递给应用程序，并附加到一个SQL字符串上。然后应用程序执行一个特殊的SQL操作，这与预期的操作不同，可能允许攻击者访问未经授权的数据（甚至可能损坏现有数据）。'
- en: '**Unsafe memory handling**: A purposely wrong parameter is passed to the application
    and is copied to a special portion of memory, which the server interprets as executable
    code. Hence, unauthorized instructions can be executed. A well-known instance
    of this kind of bug is the *buffer overflow*.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的内存处理**：将一个故意错误的参数传递给应用程序，并将其复制到内存的特殊部分，服务器将其解释为可执行代码。因此，可以执行未经授权的指令。这种类型错误的常见实例是*缓冲区溢出*。'
- en: '**Cross-site scripting**: This is a specific security issue in web applications
    where an attacker can inject client-server code (such as JavaScript) that is then
    executed and the attacker can use it to steal data or perform unauthorized operations.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本**：这是网络应用中的一种特定安全漏洞，攻击者可以注入客户端-服务器代码（如JavaScript），然后执行这些代码，攻击者可以利用它窃取数据或执行未经授权的操作。'
- en: 'There are several techniques for avoiding or mitigating these issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 避免或减轻这些问题的技术有几种：
- en: '**Input sanitizing**: Every input should be checked for special characters
    and anything unnecessary. Checking the format and the length is also important.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入清理**：每个输入都应该检查特殊字符和任何不必要的部分。检查格式和长度也很重要。'
- en: '**Running as a user with limited permissions on the local machine (the fewer
    permissions, the better)**: If there''s an unexpected security exception, the
    impact may be limited.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以具有有限权限的用户身份在本地机器上运行（权限越少越好）**：如果出现意外的安全异常，影响可能会有限。'
- en: '**Sandboxing**: In this case, the application will run within a limited and
    constrained environment. It is kind of an extension of the previous approach.
    There are various techniques for doing this, depending on the specific application
    technology. The JVM itself is kind of a sandbox. Containers are another way to
    implement sandboxing.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙箱**：在这种情况下，应用程序将在一个有限和受约束的环境中运行。这可以看作是之前方法的扩展。根据具体的应用技术，有各种实现沙箱的技术。JVM本身也是一种沙箱。容器是另一种实现沙箱的方式。'
- en: The preceding topics are a quick list of common issues (and advice to mitigate
    them) with regard to software development. However, these approaches, while crucial,
    are not exhaustive, and it's important to take a look at the overall security
    of our applications and systems, which will involve some other considerations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述主题是关于软件开发中常见问题（以及缓解这些问题的建议）的快速列表。然而，尽管这些方法至关重要，但并不全面，因此重要的是要考虑我们应用程序和系统的整体安全性，这将涉及一些其他考虑因素。
- en: Overall application security
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总体应用程序安全
- en: 'Good overall security starts with the way we write our application but doesn''t
    end there. There are several other security techniques that may involve different
    IT departments, such as network administrators. Let''s look at some of them here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的整体安全性始于我们编写应用程序的方式，但并不止于此。还有其他几种安全技术可能涉及不同的IT部门，例如网络管理员。以下是一些例子：
- en: '**Network firewalls**: They are an integral piece of the enterprise security
    strategy and are very often completely transparent to developers and architects
    (at least until you find that some of the connections you want to make are failing
    due to a missing network rule). The primary duty of firewalls is to block all
    the network connections unless they are explicitly allowed. This includes rules
    on ports, protocols, IP addresses, and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络防火墙**：它们是企业安全策略的一个基本组成部分，并且通常对开发人员和架构师来说非常透明（至少直到你发现你想要建立的某些连接由于缺少网络规则而失败）。防火墙的主要职责是阻止所有网络连接，除非它们被明确允许。这包括端口、协议、IP地址等方面的规则。'
- en: Nowadays, however, firewalls are way more sophisticated than they used to be.
    They are now capable of inspecting the application-level protocols and are often
    not only deployed at the forefront of the infrastructure but also between each
    component, to monitor and limit unauthorized accesses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，防火墙比过去要复杂得多。它们现在能够检查应用层协议，并且通常不仅部署在基础设施的前端，还部署在每个组件之间，以监控和限制未经授权的访问。
- en: For the same reason, some orchestrator tools (such as **Kubernetes**, but also
    the public cloud providers) offer the possibility to implement the so-called *network
    policies*, which are essentially **Access Control Lists** (**ACLs**) acting as
    a network firewall, hence not allowing (or dropping) unwanted network connections.
    Firewalls can be hardware appliances (with major vendors including **Cisco** and
    **Check Point**, among others), or even software distributions (such as **PFSense**
    and **Zeroshell**).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，一些编排工具（如 **Kubernetes**，以及公共云提供商）提供了实现所谓的 *网络策略* 的可能性，这些策略本质上是在充当网络防火墙的**访问控制列表**（**ACLs**），因此不允许（或丢弃）不受欢迎的网络连接。防火墙可以是硬件设备（包括
    **Cisco** 和 **Check Point** 等主要供应商），甚至是软件发行版（如 **PFSense** 和 **Zeroshell**）。
- en: '**Intrusion Protection Systems** (**IPSes**) (similar to **Intrusion Detection
    Systems**, with a slight difference in the implementation): These are an extension
    to firewalls. An IPS, like a firewall, is capable of inspecting network connections.
    But instead of just identifying authorized and unauthorized routes, an IPS is
    also capable of inspecting the packages to identify signatures (recurrent patterns)
    of well-known attacks (such as SQL injections or similar behaviors).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入侵保护系统**（**IPSes**）（类似于**入侵检测系统**，但在实现上略有不同）：这些是防火墙的扩展。IPS，就像防火墙一样，能够检查网络连接。但除了仅识别授权和不授权的路径外，IPS
    还能够检查数据包以识别已知攻击（如 SQL 注入或类似行为）的签名（重复模式）。'
- en: Moreover, an IPS can inspect other aspects of an application beyond just its
    network connections. Typically, an IPS can access application logs or even inspect
    the application behavior at runtime, with the same goal of identifying and blocking
    malevolent behavior. In this context, IPSes are similar to antivirus software
    running on workstations. Two common IPS implementations are **Snort** and **Suricata**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IPS 还可以检查应用程序的其他方面，而不仅仅是其网络连接。通常，IPS 可以访问应用程序日志或甚至在运行时检查应用程序的行为，以达到识别和阻止恶意行为的目标。在这种情况下，IPS
    与在工作站上运行的防病毒软件类似。两种常见的 IPS 实现是 **Snort** 和 **Suricata**。
- en: '**Source code inspection**: This is focused on analyzing the code for well-known
    bugs. While this is a general-purpose technique, it can be focused on security
    issues. In most cases, this kind of analysis is integrated into the software delivery
    cycle as a standard step for each release. This kind of test is also named **static
    software analysis** because it refers to inspecting the software when it is not
    being executed (hence, looking at the source code).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码检查**：这是专注于分析代码中的已知错误。虽然这是一种通用技术，但它可以专注于安全问题。在大多数情况下，这种分析作为每个发布的标准步骤集成到软件交付周期中。这种测试也被称为**静态软件分析**，因为它指的是在软件未执行时检查软件（因此，查看源代码）。'
- en: A technique similar to the previous point is checking the versions of dependencies
    in an application. This may refer to libraries, such as Maven dependencies. Such
    modules are checked against databases for known vulnerabilities linked to the
    specific version. This is part of following the general recommendation of keeping
    the software constantly patched and upgraded.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一点类似的技术是检查应用程序中依赖项的版本。这可能指的是库，例如 Maven 依赖项。这些模块会与数据库中的已知漏洞进行比对，这些漏洞与特定版本相关联。这是遵循保持软件持续打补丁和升级的一般建议的一部分。
- en: All of the aspects seen so far are relevant best practices that can be partially
    or completely adopted in your project. However, there are contexts where security
    checks and considerations must be applied in a standardized and well-defined way,
    which we will see next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看到的所有方面都是相关的最佳实践，可以在项目中部分或全部采用。然而，在某些情况下，必须以标准化和明确的方式应用安全检查和考虑因素，我们将在下一部分看到。
- en: Security standards and regulations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全标准和法规
- en: '**Security** is a core concept in applications, especially in some specific
    industries, such as financial services, defense, healthcare, and the public sector.
    But it''s really a cross-concept that cannot be ignored in any context. For this
    reason, there are sets of regulations, sometimes mandated by law or industry standards
    (for example, banking associations), that mandate and standardize some security
    practices. These include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性**是应用程序的核心概念，尤其是在某些特定行业，如金融服务、国防、医疗保健和公共部门。但它实际上是一个跨概念，在任何情况下都不能忽视。因此，存在一些法规，有时由法律或行业标准（例如，银行协会）强制执行，这些法规和标准强制并标准化了一些安全实践。以下是一些包括的内容：'
- en: '**Payment Card Industry Data Security Standard** (**PCI DSS**): This is a very
    widespread standard for implementing and maintaining IT systems that provide credit
    card payments. The goal is to reduce fraud and establish the maximum level of
    trust and safety for credit card users. PCI DSS mandates a set of rules not only
    on the system itself (such as access control and network security) but also in
    the way IT staff should handle such systems (by defining roles and responsibilities).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付卡行业数据安全标准**（**PCI DSS**）：这是一个广泛实施的IT系统标准，用于提供信用卡支付服务。目标是减少欺诈并建立对信用卡用户的最大信任和安全水平。PCI
    DSS不仅对系统本身（如访问控制和网络安全）规定了规则，还规定了IT人员处理此类系统的方式（通过定义角色和责任）。'
- en: '**Common Criteria** (**CC**): This is an international standard (under the
    denomination ISO/IEC 15408) that certifies a set of tests for checking the security
    of an IT system. Such certification is conducted by authorized entities, and the
    certified systems are registered on an official list.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用标准**（**CC**）：这是一个国际标准（在ISO/IEC 15408的名称下），用于认证一组检查IT系统安全性的测试。这种认证由授权实体进行，认证的系统将登记在官方名单上。'
- en: '**Open Web Application Security Project** (**OWASP**): This approach is a bit
    different from what we have seen so far. Instead of being a centralized testing
    institution providing a certification, OWASP is an open and distributed initiative
    that provides a set of tools, tests, and best practices for application security
    (especially focused on web application security). OWASP also shares and maintains
    a list of well-known security issues. The association distributes the **Dependency-Check**
    tool ([https://owasp.org/www-project-dependency-check](https://owasp.org/www-project-dependency-check)),
    which helps in identifying vulnerable software dependencies, and the Dependency-Track
    tool monitors and checks dependency usage.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放式网络应用安全项目**（**OWASP**）：这种方法与我们迄今为止所看到的不同。它不是一个提供认证的集中式测试机构，而是一个开放和分布式的倡议，提供了一套用于应用程序安全（特别是关注Web应用程序安全）的工具、测试和最佳实践。OWASP还共享和维护了一个知名安全问题的列表。该协会分发**依赖性检查**工具（[https://owasp.org/www-project-dependency-check](https://owasp.org/www-project-dependency-check)），该工具有助于识别有漏洞的软件依赖项，而**依赖性跟踪**工具则监控和检查依赖项的使用。'
- en: As we explained, security is a crucial topic that must be considered important
    in all project phases (from design to implementation to testing) and across all
    different teams (from developers to testers to sysadmins). This is the reason
    why we decided to consider it a cross-cutting concern (and why we discussed it
    in this chapter). To establish and maintain security in our applications, best
    practices must be taken into account at every step of a development project, including
    coding. But to maintain a safe system, we should also consider other potential
    sources of disruption and data loss, and ways to avoid or mitigate them, which
    we will look at in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们解释的那样，安全性是一个至关重要的主题，必须在所有项目阶段（从设计到实施到测试）以及所有不同的团队（从开发者到测试者到系统管理员）中给予重视。这就是我们决定将其视为一个跨领域关注点（以及为什么我们在本章中讨论它）的原因。为了在我们的应用程序中建立和维护安全性，必须在开发项目的每个步骤中都考虑最佳实践，包括编码。但为了保持系统的安全，我们还应考虑其他潜在的干扰和数据丢失来源，以及避免或减轻这些干扰的方法，我们将在下一节中探讨。
- en: Resiliency
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Security is about preventing fraudulent activities, the theft of data, and other
    improper behavior that could lead to service disruptions. However, our application
    can go down or provide degraded service for several other reasons. This could
    be due to a traffic spike causing an overload, a software bug, or a hardware failure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性关乎防止欺诈活动、数据盗窃以及其他可能导致服务中断的不当行为。然而，我们的应用程序可能因多种原因而崩溃或提供降级服务。这可能是由于流量激增导致过载、软件错误或硬件故障。
- en: The core concept (sometimes underestimated) behind the resiliency of a system
    is the **Service Level Agreement** (**SLA**).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 系统弹性的核心概念（有时被低估）是**服务等级协议**（**SLA**）。
- en: An SLA is an attempt to quantify (and usually enforce with a contract) some
    core metrics that our service should respect.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务等级协议（SLA）是尝试量化（通常通过合同强制执行）我们服务应遵守的一些核心指标。
- en: Uptime
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时间
- en: The most widely used SLA is **uptime**, measuring the availability of the system.
    It is a basic metric, and it's commonly very meaningful for services providing
    essential components, such as connectivity or access to storage. However, if we
    consider more complex systems (such as an entire application, or a set of different
    applications, as in microservices architectures), it becomes more complex to define.
    Indeed, our application may still be available, but responding with the wrong
    content, or simply showing static pages (such as a so-called *courtesy page*,
    explaining that the system is currently unavailable).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的SLA是**运行时间**，衡量系统的可用性。这是一个基本指标，对于提供基本组件（如连接性或存储访问）的服务来说，通常非常有意义。然而，如果我们考虑更复杂的系统（例如整个应用程序，或一组不同的应用程序，如微服务架构），定义就变得更加复杂。确实，我们的应用程序可能仍然可用，但会返回错误的内容，或者简单地显示静态页面（如所谓的*礼貌页面*，解释系统当前不可用）。
- en: So, the uptime should be defined carefully in complex systems, by restricting
    it to specific features and defining their expected behaviors (such as the data
    that these features should provide).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在复杂系统中，应该仔细定义运行时间，通过限制到特定的功能并定义它们的预期行为（例如，这些功能应该提供的数据）。
- en: Uptime is usually measured as a percentage over a defined period, such as 99.9%
    per year.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间通常按一定时期内的百分比来衡量，例如每年99.9%。
- en: 'When considering the uptime, it''s useful to define the two possible types
    of outages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑系统运行时间时，定义两种可能的故障类型是有用的：
- en: '**Planned downtime**: This refers to service disruption occurring due to maintenance
    or other predictable operations, such as deployments. To reduce planned downtime,
    one technique is to reduce the number of releases. However, this kind of technique
    may be impractical for modern systems because it will reduce agility and increase
    time to market. So, an alternative approach is to implement rolling releases or
    similar techniques to continue to provide services (eventually in a degraded mode)
    while performing releases or other maintenance activities.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划外停机时间**：这指的是由于维护或其他可预测操作（如部署）导致的服务中断。为了减少计划外停机时间，一种技术是减少发布次数。然而，这种技术在现代系统中可能不切实际，因为它会降低敏捷性并增加上市时间。因此，一种替代方法是实施滚动发布或其他类似技术，在执行发布或其他维护活动的同时继续提供服务（最终以降级模式提供服务）。'
- en: '**Unplanned downtime**: This is, of course, linked to unpredictable events,
    such as system crashes or hardware failures. As we will see in this section, there
    are several techniques available for increasing uptime, especially in cloud-native
    architectures.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划外停机时间**：这当然与不可预测的事件有关，如系统崩溃或硬件故障。正如我们将在本节中看到的，有几种技术可以提高运行时间，尤其是在云原生架构中。'
- en: 'With regard to unplanned downtime, there are several further metrics (I would
    say *sub-metrics*) that measure certain specific aspects that are useful for further
    monitoring of the service levels of a system:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计划外停机时间，还有几个进一步的指标（我可以说*子指标*），它们衡量某些特定方面，这些方面对于进一步监控系统服务级别是有用的：
- en: '**Mean time between failures**: This measures the average time between two
    services outages (as said before, an outage can be defined in many ways, ranging
    from being completely down to services answering incorrectly). A system with a
    short mean time between failures, even if still respecting the overall uptime
    SLA, should be considered unstable and probably fixed or strengthened.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均故障间隔时间**：这衡量了两次服务中断之间的平均时间（如前所述，中断可以定义为多种方式，从完全关闭到服务回答错误）。即使系统仍然遵守整体运行时间服务等级协议（SLA），平均故障间隔时间短的系统应被视为不稳定，可能需要修复或加强。'
- en: '**Mean time to recovery**: This measures the average time to restore a system
    to operation following a period of downtime. This includes any kind of workaround
    or manual fix to resolve an issue. These kinds of fixes are considered temporary.
    A system with a high mean time to recovery might need some supporting tools or
    better training for the team operating it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均恢复时间**：这衡量的是在一段停机时间后恢复系统操作的平均时间。这包括任何类型的临时解决方案或手动修复来解决问题。这些修复被认为是临时的。具有高平均恢复时间的系统可能需要一些支持工具或更好的团队培训。'
- en: '**Mean time to repair**: This is similar to the previous metric but measures
    the complete resolution of an issue definitively. The difference between this
    metric and the previous one is subtle and subjective. A high mean time to repair
    can signify a poorly designed system or the lack of good troubleshooting tools.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均修复时间**：这与之前的指标类似，但衡量的是问题的完全解决。这个指标与之前的区别是微妙且主观的。高的平均修复时间可能表明系统设计不佳或缺乏良好的故障排除工具。'
- en: Uptime is not the only SLA to consider when monitoring a system with regard
    to resiliency. Several other metrics can be measured, such as the response time
    of an API (which can be measured with something such as *90% of the calls should
    respond in under 1 millisecond*), the error rate (the percentage of successful
    calls per day), or other related metrics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控系统以考虑弹性时，正常运行时间并不是唯一需要考虑的服务级别协议。可以测量其他几个指标，例如API的响应时间（可以使用类似*90%的调用应在1毫秒内响应*的东西来衡量），每日成功调用的错误率（百分比），或其他相关指标。
- en: But as we said, there are several techniques to achieve these SLAs and increase
    system reliability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们所说的，有几种技术可以实现这些服务级别协议并提高系统可靠性。
- en: Increasing system resiliency
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高系统弹性
- en: The most commonly used (sometimes overused) technique for increasing system
    resiliency is **clustering**. A **cluster** is a set of components working concurrently
    in a mirrored way. In a cluster, there is a way to constantly share the system
    status between two or more instances. In this way, we can keep the services running
    in case downtime (planned or unplanned) occurs in one of the systems belonging
    to the cluster itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的（有时过度使用）提高系统弹性的技术是**集群**。**集群**是一组以镜像方式并发工作的组件。在集群中，有一种方法可以在两个或多个实例之间持续共享系统状态。这样，我们可以在集群所属的某个系统发生停机（计划内或计划外）时保持服务运行。
- en: Moreover, a cluster may involve a redundant implementation of every subsystem
    (including network, storage, and so on) to further improve resiliency in the event
    of the failure of supporting infrastructure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个集群可能包含每个子系统（包括网络、存储等）的冗余实现，以进一步提高在支持基础设施故障情况下的弹性。
- en: Clusters are usually complex to set up and there is a price to pay for the increase
    in reliability, usually a performance impact due to the replication of the state.
    Moreover, depending on the specific application, there are several restrictions
    for implementing a cluster, such as network latency and the number of servers
    (nodes).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 集群通常设置复杂，并且为了提高可靠性，通常需要付出性能影响的代价，这通常是由于状态的复制所导致的。此外，根据具体的应用，实现集群有一些限制，例如网络延迟和服务器（节点）的数量。
- en: We discussed a related topic in [*Chapter 11*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271)*,*
    *Dealing with Data*, when talking about **NoSQL** repositories and the **CAP**
    theorem. Since the data inside a cluster can be considered distributed storage,
    it must obey the CAP theorem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271)*,* *处理数据*中讨论了相关主题，当时我们谈论了**NoSQL**存储库和**CAP**定理。由于集群内部的数据可以被认为是分布式存储，它必须遵守CAP定理。
- en: A cluster often relies on a networking device, such as a network load balancer,
    that points to every node of the cluster and re-establishes full system operativity
    in case of a failure, by redirecting all the requests to a node that is still
    alive.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 集群通常依赖于一个网络设备，例如网络负载均衡器，该设备指向集群中的每个节点，并在发生故障时通过将所有请求重定向到仍然存活的一个节点来重新建立整个系统的操作性。
- en: To communicate with each other, the cluster nodes use specific protocols, commonly
    known as a **heartbeat** protocol, which usually involves the exchange of special
    messages over the network or filesystem. A widely used library for implementing
    heartbeat and leader election in Java is **JGroups**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了相互通信，集群节点使用特定的协议，通常称为**心跳**协议，这通常涉及在网络或文件系统中交换特殊消息。在Java中实现心跳和领导者选举的一个广泛使用的库是**JGroups**。
- en: One common issue with clusters is the **split-brain** problem. In a split-brain
    situation, the cluster is divided into two or more subsets, which are unable to
    reach each other via the heartbeat. This usually occurs because of a network interruption
    between the two system subsets, caused by a physical disconnection, a misconfiguration,
    or something else. In this situation, one part of the cluster is unaware if the
    other part is still up and running (but cannot be seen using the heartbeat) or
    is down. To maintain data consistency (as seen in the CAP theorem in [*Chapter
    11*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271), *Dealing with Data*) in
    the case of split-brain, the cluster may decide to stop operating (or at least
    stop writing functionalities) to avoid processing conflicting operations in two
    parts of the cluster that are not communicating with each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的一个常见问题是**脑裂**问题。在脑裂情况下，集群被分成两个或更多个子集，这些子集无法通过心跳相互通信。这通常是由于两个系统子集之间的网络中断造成的，可能是由于物理断开、配置错误或其他原因。在这种情况下，集群的一部分可能不知道另一部分是否仍在运行（但无法通过心跳看到）或已关闭。为了在脑裂的情况下保持数据一致性（如CAP定理中在[*第11章*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271)，*处理数据*)，集群可能决定停止运行（或者至少停止写操作）以避免在两个不相互通信的集群部分中处理冲突操作。
- en: To address these scenarios, clusters may invoke the concept of a quorum. A **quorum**
    is the number of nodes in a cluster required for the cluster to operate properly.
    A quorum is commonly fixed to *half of the cluster nodes + 1*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些场景，集群可能会调用法定人数的概念。**法定人数**是集群正常运行所需的节点数量。法定人数通常固定为*集群节点数的一半加一*。
- en: While the details may vary with the type of specific cluster implementation,
    a quorum is usually necessary to elect a cluster leader. The leader may be the
    only member of the cluster running, or, more commonly, having other duties related
    to cluster coordination (such as declaring a cluster fully functional or not).
    To properly handle split-brain situations, a cluster is usually composed of an
    odd number of nodes, so if there's a split between two subsets, one of the two
    will be in the majority and continue to operate, while the other will be the minority
    and will shut down (or at least deny write operations).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具体细节可能因特定集群实现类型的不同而有所差异，但通常需要一个法定人数来选举集群领导者。领导者可能是集群中唯一正在运行的成员，或者更常见的是，承担与集群协调相关的其他职责（例如宣布集群完全功能或非功能）。为了正确处理脑裂情况，集群通常由奇数个节点组成，因此如果两个子集之间发生分裂，其中之一将处于多数，继续运行，而另一个将处于少数并关闭（或者至少拒绝写操作）。
- en: An alternative to the use of a quorum is the technique of **witnesses**. A cluster
    may be implemented with an even number of nodes, and then have a special node
    (usually dislocated in the cloud or a remote location) that acts as a witness.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 法定人数使用的替代方法是**见证者**技术。集群可以由偶数个节点实现，然后有一个特殊的节点（通常位于云中或远程位置）作为见证者。
- en: If there's a cluster split, the witness node can reach every subset of the cluster
    and decide which one should continue to operate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生集群分裂，见证节点可以到达集群的每一个子集并决定哪一个应该继续运行。
- en: As we have said, clustering can be expensive and has lots of requirements. Moreover,
    in modern architectures (such as **microservices**), there are alternative approaches
    for operating in the case of a failure in distributed setups. One common consideration
    is about the eventual consistency, discussed in the previous chapter, under the
    *Exploring NoSQL repositories* section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，集群可能成本高昂且有很多要求。此外，在现代架构（如**微服务**）中，在分布式设置中发生故障的情况下，有其他替代方法进行操作。一个常见的考虑因素是关于最终一致性，在上一章的*探索NoSQL存储库*部分进行了讨论。
- en: For all these reasons, there are other approaches to improving system availability,
    which can be used as an alternative or a complement to clustering.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，存在其他提高系统可用性的方法，这些方法可以作为集群的替代方案或补充。
- en: Further techniques for improving reliability
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步提高可靠性的技术
- en: An alternative approach to clustering used to improve reliability is **High
    Availability** (**HA**). An HA system is similar to a clustered system. The main
    difference is that in normal conditions, not all nodes are serving requests. Conversely,
    in this kind of setup, there is usually one (or a limited number of) primary nodes
    running and serving requests, and one or more failover nodes, which are ready
    to take over in the case of a failure of the primary node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用于提高可靠性的集群的替代方法是**高可用性**（**HA**）。HA系统类似于集群系统。主要区别在于，在正常条件下，并非所有节点都在处理请求。相反，在这种配置中，通常有一个（或有限数量的）主节点运行并处理请求，以及一个或多个备用节点，它们在主节点失败的情况下准备接管。
- en: The time for restoring the system may vary depending on the implementation of
    the systems and the amount of data to restore. The system taking over can already
    be up and running (and more or less aligned with the primary). In this scenario,
    it's called a **Hot Standby**. An alternative scenario is when the failover servers
    are usually shut down and lack data. In this case, the system is called **Cold
    Standby** and may take some time to become fully operational.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复系统的时间可能因系统和要恢复的数据量而异。接管系统的系统可能已经启动并运行（并且与主节点或多或少对齐）。在这种情况下，它被称为**热备站**。另一种情况是，故障转移服务器通常关闭且缺乏数据。在这种情况下，该系统被称为**冷备站**，可能需要一些时间才能完全运行。
- en: An extreme case of Cold Standby is **Disaster Recovery** (**DR**). This kind
    of system, often mandated by law, is dislocated in a remote geographical location,
    and aligned periodically. How remote it should be and how often it is aligned
    are parameters that will vary depending on how critical the system is and how
    much budget is available. A DR system, as the name implies, is useful when recovering
    from the complete disruption of a data center (due to things such as a fire, an
    earthquake, or flooding). Those events, even if unlikely, are crucial to consider
    because being unprepared means losing a lot of money or being unable to re-establish
    a system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 冷备站的极端情况是**灾难恢复**（**DR**）。这种系统通常由法律强制规定，位于远程地理位置，并定期对齐。它应该有多远以及多久对齐一次，这些参数将根据系统的关键性和可用的预算而有所不同。正如其名称所暗示的，DR系统在从数据中心完全中断中恢复（例如火灾、地震或洪水）时非常有用。这些事件，即使不太可能发生，也是至关重要的，因为未做好准备意味着会损失大量资金或无法重新建立系统。
- en: DR is also linked to the concept of **Backup and Restore**. Constantly backing
    up data (and configurations) is crucial to re-establishing system operation in
    the case of a disaster or unforeseen data loss (think about a human error or a
    bug). Backed-up data should also be periodically tested for restore to check the
    completeness of data, especially if (as is advised) the data is encrypted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DR（灾难恢复）也与**备份和恢复**的概念相关。在灾难或意外数据丢失（例如人为错误或错误）的情况下，定期备份数据（和配置）对于重新建立系统操作至关重要。备份的数据还应定期进行恢复测试，以检查数据的完整性，尤其是如果（如建议的那样）数据已加密。
- en: 'Whether you are planning to use clustering, HA, or DR, two special metrics
    are commonly used to measure the effectiveness and the goals of this kind of configuration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您计划使用集群、高可用性（HA）还是DR，通常使用两个特殊指标来衡量这种配置的有效性和目标：
- en: '**Recovery time objective** (**RTO**): This is the time needed for a failover
    node to take over after the primary node fails. This time can be 0 (or very limited)
    in the case of clustering, as every node is already up and running, or can be
    very high in the case of DR (which may be acceptable as the occurrence of a disaster
    is usually very unlikely).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复时间目标**（**RTO**）：这是主节点失败后备用节点接管所需的时间。在集群的情况下，这个时间可以是0（或非常有限），因为每个节点都已经启动并运行，或者在高可用性（DR）的情况下可以非常高（这可能是可以接受的，因为灾难的发生通常非常不可能）。'
- en: '**Recovery point objective** (**RPO**): This is the amount of data that it
    is acceptable to lose. This may be measured in terms of time (such as the number
    of minutes, hours, or days since the last sync), the number of records, or something
    similar. An RPO can be 0 (or very limited) in a clustered system, while it can
    be reasonably high (such as 24 hours) in the case of DR.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复点目标**（**RPO**）：这是可以接受的丢失数据的量。这可以按时间（例如自上次同步以来的分钟数、小时数或天数）、记录数或类似的方式进行衡量。在集群系统中，RPO可以是0（或非常有限），而在DR的情况下，它可以相对较高（例如24小时）。'
- en: A last important topic is the **physical location** of the application. Indeed,
    all of the approaches that we have seen so far (clustering, HA, and DR, with all
    the related metrics and measurements, such as RPO and RTO) can be implemented
    in various physical setups, greatly varying the final effect (and the implementation
    costs).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的话题是应用程序的**物理位置**。确实，我们迄今为止看到的所有方法（集群、高可用性和灾难恢复，以及所有相关的指标和测量，如RPO和RTO）都可以在各种物理设置中实施，这极大地影响了最终效果（和实施成本）。
- en: One core concept is the **data center**. Indeed, each node (or portion) of a
    cluster (or of an HA or DR setup) can be running on a physically different data
    center in a specific geographical location.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个核心概念是**数据中心**。确实，集群（或高可用性或灾难恢复设置）的每个节点（或部分）都可以在特定地理位置的物理不同的数据中心运行。
- en: Running servers in different data centers usually provides the maximum level
    of resiliency, especially if the data centers are far away from each other. On
    the other hand, the connection between applications running in different data
    centers can be expensive and subject to high latency. Cloud providers often call
    the different data centers **availability zones**, further grouping them by geographical
    area, to provide information about the distance between them and the users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的数据中心运行服务器通常提供最大程度的弹性，尤其是如果数据中心彼此相距很远。另一方面，运行在不同数据中心的应用程序之间的连接可能很昂贵，并且具有高延迟。云服务提供商通常将不同的数据中心称为**可用区**，并根据地理位置进一步分组，以提供它们之间的距离和用户的信息。
- en: However, even if an application is running in just one data center, there are
    techniques to improve resilience to failures and disasters. A good option is running
    the application copies in different rooms in a data center. The rooms of a data
    center, even if belonging to the same building, can be greatly independent of
    each other. These data centers may apply specific techniques to enforce such independence
    (such as dedicated power lines, different networking equipment, and specific air
    conditioning systems). However, it's easy to understand that major disasters such
    as earthquakes, floods, and fires will be disruptive for all the rooms in the
    same way. However, hosting in separate rooms is usually cheaper than in separate
    data centers, and rooms have quite good connectivity with each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使应用程序仅在一个数据中心运行，也有技术可以提高对故障和灾难的弹性。一个好的选择是在数据中心的不同房间中运行应用程序副本。数据中心的不同房间，即使属于同一建筑，也可能彼此非常独立。这些数据中心可能应用特定的技术来强制这种独立性（例如专用电源线、不同的网络设备以及特定的空调系统）。然而，很容易理解，地震、洪水和火灾等重大灾难将以相同的方式影响同一建筑中的所有房间。然而，在单独的房间中托管通常比在单独的数据中心中更便宜，而且房间之间有相当好的连通性。
- en: A lower degree of isolation can be obtained by running different copies of our
    application (different nodes of a cluster) on different racks. A **rack** is a
    grouping of servers, often all running in the same room (or close to each other,
    at least). In this sense, two applications running on different racks may be unaffected
    by minor issues impacting just one rack, such as a local network hardware failure
    or power adapter disruption, as these physical devices are commonly specific to
    each rack.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在不同的机架上运行我们应用程序的不同副本（集群的不同节点），可以获得较低的隔离度。**机架**是一组服务器的集合，通常所有服务器都在同一个房间（或者至少彼此很近）运行。从这个意义上说，运行在不同机架上的两个应用程序可能不会受到仅影响一个机架的轻微问题的干扰，例如本地网络硬件故障或电源适配器中断，因为这些物理设备通常特定于每个机架。
- en: Of course, a blackout or a defect in the air conditioning system will almost
    certainly impact all the instances of our cluster, even if running on different
    racks. For all of these reasons, different racks are cheaper than the other implementations
    seen so far, but can be pretty poor in offering resilience to major disasters,
    and are completely unsuitable for implementing proper DR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，停电或空调系统故障几乎肯定会影响我们集群的所有实例，即使它们运行在不同的机架上。出于所有这些原因，不同的机架比迄今为止看到的其他实现更便宜，但在提供对主要灾难的弹性方面可能相当差，并且完全不适用于实施适当的灾难恢复。
- en: A closer alternative to different racks is running our application in the same
    rack but on different machines. Here, the only redundancy available is against
    local hardware failures, such as a disk, memory, or CPU malfunctioning. Every
    other physical issue, including minor ones (such as a power adapter failing),
    will almost certainly impact the cluster availability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与不同机架相比的更接近的替代方案是在同一机架的不同机器上运行我们的应用程序。在这里，唯一可用的冗余是针对本地硬件故障，例如磁盘、内存或CPU故障。其他所有物理问题，包括较小的（如电源适配器故障），几乎肯定会影响集群的可用性。
- en: Last but not least, it is possible to have the instances of a cluster running
    on the same physical machine thanks to containers or server virtualization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，由于容器或服务器虚拟化，集群的实例可以在同一台物理机上运行。
- en: Needless to say, this technique, while very easy and cheap to implement, will
    not provide any protection against hardware failures. The only available reliability
    improvement is against software crashes, as the different nodes will be isolated
    to some degree.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这种技术虽然实施起来非常简单且成本低廉，但不会提供任何针对硬件故障的保护。唯一可用的可靠性改进是针对软件崩溃，因为不同的节点将在一定程度上被隔离。
- en: All of the approaches that we have seen so far offer ways to improve the overall
    application availability and were available long before cloud-native applications.
    However, some modern evolutions of such techniques (such as the **saga pattern**,
    seen in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing
    Cloud-Native Architectures*) happen to better suit modern applications (such as
    microservices-based ones).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的所有方法都提供了提高整体应用程序可用性的方法，并且这些方法在云原生应用程序出现之前就已经可用。然而，这些技术的某些现代演变（如[第9章](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中提到的**saga模式**，*设计云原生架构*）恰好更适合现代应用程序（如基于微服务的应用程序）。
- en: A topic that is worth highlighting is **reliability**. In the past, reliability
    was treated exclusively at the infrastructure level, with highly available hardware
    and redundant network connections. However, nowadays, it is more common to design
    application architectures that are aware of where they run, or of how many instances
    are running concurrently. In other words, applications that take reliability and
    high availability into consideration have become common. In this way, it is possible
    to implement mixed approaches that provide degraded functionalities if failure
    is detected in other nodes of the cluster. So, our application will still be partially
    available (for example in read-only mode), thereby reducing the total outage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的一个主题是**可靠性**。在过去，可靠性仅从基础设施层面进行管理，使用高度可用的硬件和冗余的网络连接。然而，如今，设计了解它们运行位置或同时运行多少实例的应用程序架构更为常见。换句话说，考虑可靠性和高可用性的应用程序已经变得很普遍。这样，当检测到集群中其他节点的故障时，可以实现混合方法，提供降级功能。因此，我们的应用程序仍然部分可用（例如，只读模式），从而减少总的停机时间。
- en: Another technique is to apply **tiering** to functionalities (for example, to
    different microservices). To do so, it's possible to label each specific functionality
    according to the severity and the SLA needed. Hence, some functionalities can
    be deployed on highly resilient, expensive, and geographically distributed systems,
    while other functionalities can be considered disposable (or less important) and
    then deployed on cheaper infrastructure, taking into account that they will be
    impacted by outages in some situations (but this is accepted, as the functionalities
    provided are not considered core).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是将**分层**应用于功能（例如，不同的微服务）。为此，可以根据严重性和所需的SLA对每个特定功能进行标记。因此，一些功能可以部署在高度弹性的、昂贵的、地理上分布的系统上，而其他功能则可以被视为可丢弃的（或不太重要）的，然后部署在更便宜的基础设施上，考虑到它们在某些情况下可能会受到故障的影响（但这是可以接受的，因为提供的功能不被视为核心）。
- en: All of these last considerations are to say that even if you will never have
    the job of completely designing the availability options of a full data center
    (or of more than one data center) in your role as a software architect, you will
    still benefit from knowing the basics of application availability so that you
    can design applications properly (especially the cloud-native, microservices-based
    ones), thereby greatly improving the overall availability of the system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些最后的考虑都是为了说明，即使你作为软件架构师的角色中永远不会负责完全设计完整数据中心（或多个数据中心）的可用性选项，你仍然会从了解应用程序可用性的基础知识中受益，这样你就可以正确地设计应用程序（特别是云原生、基于微服务的那些），从而大大提高系统的整体可用性。
- en: With this section, we have completed our overview of cross-cutting concerns
    in software architectures.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节，我们完成了对软件架构中横切关注点的概述。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen an overview of the different cross-cutting concerns
    that affect software architecture. This also included some solutions and supporting
    systems and tools.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了影响软件架构的不同横切关注点的概述。这还包括了一些解决方案和支持系统以及工具。
- en: We have learned the different ways of managing identity inside our application
    (especially when it involves several different components, such as in a microservice
    architecture).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了管理我们应用程序内身份的不同方式（尤其是在涉及多个不同组件的情况下，如微服务架构）。
- en: We had an overview of the security considerations to be made when designing
    and implementing an application (such as intrinsic software security and overall
    software security), which are crucial in a shift-left approach, which is the way
    security is managed in DevOps scenarios.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了在设计实施应用程序时需要考虑的安全因素（例如内在软件安全和整体软件安全），这在左移方法中至关重要，这是DevOps场景中管理安全的方式。
- en: Last but not least, we had a complete overview of application resiliency, discussing
    what a cluster is, what the implications of using clustering are, and what other
    alternatives (such as HA and DR) can be implemented.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们对应用程序的弹性有了全面的了解，讨论了什么是集群，使用集群的含义，以及可以实施的其他替代方案（如高可用性和灾难恢复）。
- en: In the next chapter, we are going to explore the tooling supporting the software
    life cycle, with a particular focus on continuous integration and continuous delivery.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨支持软件生命周期的工具，特别关注持续集成和持续交付。
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Neil Daswani, Christoph Kern, and Anita Kesavan: *Foundations of Security:
    What Every Programmer Needs to Know*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尼尔·达斯瓦尼，克里斯托夫·科尔，以及阿尼塔·凯萨万：*安全基础：每个程序员都需要知道的内容*
- en: 'The Keycloak community: *The Keycloak OpenSource IDM* ([https://www.keycloak.org](https://www.keycloak.org))'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keycloak社区：*Keycloak开源身份管理系统* ([https://www.keycloak.org](https://www.keycloak.org))
- en: 'Evan Marcus and Hal Stern: *Blueprints for High Availability: Timely, Practical,
    Reliable*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 埃文·马库斯和哈尔·斯特恩：*高可用性蓝图：及时、实用、可靠*
