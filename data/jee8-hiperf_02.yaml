- en: Looking Under the Cover – What is This EE Thing?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看底层 – 这个 EE 东西是什么？
- en: Java EE can appear as a magic tool for deployment. However, it is actually just
    Java code. This chapter intends to look under the cover of the server and ensure
    that you understand what implications you should expect from the performance of
    your application. Since covering the entire Java EE space is quite impossible,
    this chapter will deal with the most common patterns and main specifications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 可以看起来像是一个部署的魔法工具。然而，实际上它只是 Java 代码。本章旨在揭开服务器的面纱，确保您了解您应该从应用程序的性能中期待哪些影响。由于涵盖整个
    Java EE 领域相当不可能，本章将处理最常见的模式和主要规范。
- en: 'In this chapter, we will go through some commonly used specifications, and
    check out what their role is and what you should expect in terms of the impact
    on your runtime. In the end, you should be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些常用的规范，并检查它们的作用以及您应该期待对运行时的哪些影响。最后，您应该能够做到以下几件事情：
- en: Know the services that you can expect from your container and the high-level associated overhead
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您可以从容器中期望的服务以及与之相关的高级开销
- en: Evaluate whether a code pattern can impact the performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估代码模式是否会影响性能
- en: Judge whether your runtime (Java EE) overhead is normal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断您的运行时（Java EE）开销是否正常
- en: Context and Dependency Injection – what did you do to my beans?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文和依赖注入 – 你对我的 beans 做了什么？
- en: '**Context and Dependency Injection** (**CDI**) is the central specification
    of Java EE. Its role is to *manage* the beans you define. It is directly linked
    to the pattern called **Inversion of Control** (**IoC**), which provides a way
    to obtain loose coupling between your classes. The goal is to be flexible on the
    way so that the current instances are linked together. It also controls the life
    cycle and the instantiation of instances.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文和依赖注入**（**CDI**）是 Java EE 的核心规范。其作用是 *管理* 您定义的 bean。它与称为 **控制反转**（**IoC**）的模式直接相关，它提供了一种在您的类之间实现松耦合的方法。目标是使方式灵活，以便当前实例相互链接。它还控制实例的生命周期和实例化。'
- en: IoC – a pretty simple example
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IoC – 一个相当简单的例子
- en: Before exploring the CDI, let's use a very simple example (I would say, a *handmade
    example*) to illustrate what a bean container is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 CDI 之前，让我们用一个非常简单的例子（我会说，一个 *手工制作的例子*）来说明什么是 bean 容器。
- en: We will use an application that has `TimeService`, which simply provides a `now()`
    method returning the current `LocalDateTime`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个具有 `TimeService` 的应用程序，它简单地提供了一个返回当前 `LocalDateTime` 的 `now()` 方法。
- en: 'Here is what it can look like in terms of code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它在代码中的样子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A trivial implementation will rely on the native `now()` implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平凡的实现将依赖于本地的 `now()` 实现：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But you may also need to be able to switch to a mock (for tests or another
    customer, for instance):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能还需要能够切换到模拟（例如，用于测试或另一个客户）：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In terms of code, you will likely implement the switch with a plain old factory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，您可能会使用普通的工厂模式实现 switch：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you need to use the factory everywhere in the callers, which is quite
    impacting, especially when you need to add a parameter to the `create()` method. To
    solve this issue, you can put all your application instances in a single place,
    which we will call `Container`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在调用者处到处使用工厂，这影响很大，尤其是在您需要向 `create()` 方法添加参数时。为了解决这个问题，您可以将所有应用程序实例放在一个地方，我们将称之为
    `Container`：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a very minimal and trivial implementation. But once it is done, you
    can just register all your application beans in your bootstrap class, and all
    the code will rely on `Container` to retrieve the instance. In other words, the
    lookup of the classes is centralized. This also means that the updates are simpler:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单且平凡的实现。但一旦完成，您只需在启动类中注册所有应用程序的 bean，所有代码都将依赖于 `Container` 来检索实例。换句话说，类的查找是集中的。这也意味着更新更简单：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As the last thing before starting to deal with the CDI itself, you can add
    services on top of the container, since the instances are created by `Container`.
    For instance, if you want to log any call to the method of a registered API, you
    can change the `get(Class<?>)` method in the following way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理 CDI 之前，您可以在容器之上添加服务，因为实例是由 `Container` 创建的。例如，如果您想记录对已注册 API 方法的任何调用，您可以按以下方式更改
    `get(Class<?>)` 方法：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The entire logic will be implemented in `LoggingHandler`, which will fully
    decorate the registered instance logic with logging invocations. In other words,
    each method invocation on the proxy instance will be forwarded to the handler:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 整个逻辑将在`LoggingHandler`中实现，它将完全用日志调用装饰已注册实例的逻辑。换句话说，对代理实例的每次方法调用都将转发到处理程序：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if you call `TimeService.now()`, you will be able to observe the corresponding
    output. With the default logging setup, it looks something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你调用`TimeService.now()`，你将能够观察到相应的输出。使用默认的日志设置，它看起来像这样：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By itself, it is not that useful, but if you add some metrics (timing), parameter
    logging, and so on, it can become really neat. Also, keep in mind that you can
    chain the handlers you add on top of the proxy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，它并不那么有用，但如果你添加一些度量（计时）、参数日志记录等，它可以变得非常整洁。此外，请记住，你可以将添加到代理上的处理程序链接起来。
- en: What does this mean, regarding the performance? Well, it means that a simple
    call to a method we fully control (user method) can do really different things
    from the user code; it will be slow due to the `Container` class and not due to
    the user code. If you doubt it, take a case where the user method implementation
    is empty and the handler pauses for some minutes. Of course, the EE implementation
    doesn't do it, but it adds some complexity on top of the end user code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这对性能意味着什么？嗯，这意味着我们对完全控制的方法（用户方法）的简单调用可以执行真正不同的操作；它将由于`Container`类而变慢，而不是由于用户代码。如果你对此表示怀疑，请考虑用户方法实现为空且处理程序暂停几分钟的情况。当然，EE实现不会这样做，但它会在最终用户代码之上添加一些复杂性。
- en: The main features of CDI
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI的主要功能
- en: CDI is quite a complete specification with a lot of features compared with our
    small container. However, the CDI works in a manner similar to the container,
    except that it scans the `classloader` application to find beans at startup instead
    of requiring a manual registration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的小型容器相比，CDI是一个非常完整的规范，具有许多特性。然而，CDI的工作方式与容器类似，只是它在启动时扫描`classloader`应用程序以查找bean，而不是需要手动注册。
- en: To understand how the CDI can impact the performance of your application, we
    will detail a few major features of the CDI, explaining the work the server has
    to do to provide them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解CDI如何影响您应用程序的性能，我们将详细说明CDI的一些主要功能，解释服务器必须执行的工作以提供它们。
- en: Injections
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入
- en: 'If you take a look at our quote manager application, you may have noticed that
    `QuoteService` was injected in `QuoteResource` or `DirectQuoteSocket`. We are
    exactly in the IoC area of the CDI container. Here, the algorithm globally looks
    as follows (in pseudo-code):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们的报价管理应用程序，你可能已经注意到`QuoteService`被注入到`QuoteResource`或`DirectQuoteSocket`中。我们正好处于CDI容器的IoC区域。在这里，算法全局看起来如下（伪代码）：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To fulfill its role, the CDI will need to instantiate an instance and initialize
    it. To do so, it proceeds with the following steps which leads to provide you
    a ready to use instance:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了履行其角色，CDI需要实例化一个实例并初始化它。为此，它按照以下步骤进行，从而为您提供现成的实例：
- en: The CDI allows injections from the constructor parameters, through field injections,
    or through setter injections. Therefore, before instantiating an instance, the
    CDI needs to resolve the required parameters and get one instance for each of
    them.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CDI允许从构造函数参数、通过字段注入或通过设置器注入进行注入。因此，在实例化实例之前，CDI需要解决所需的参数并为每个参数获取一个实例。
- en: Now, the container can provide constructor parameters; it just creates a current
    instance from the bean constructor.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，容器可以提供构造函数参数；它只是从bean构造函数创建当前实例。
- en: Now that the container has an instance, it populates its field/setter injections.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在容器有一个实例，它会填充其字段/设置器注入。
- en: If needed, the instance is wrapped in a proxy, adding the required services/handlers
    (interceptors/decorators in CDI semantic).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，实例将被包装在一个代理中，添加所需的服务/处理程序（CDI语义中的拦截器/装饰器）。
- en: 'In terms of the performance, this kind of logic has some consequences for us
    and the way we can rely on the CDI in high-performance environments and applications. 
    A simple bean instantiation now requires operations which look simple but can
    be expensive to execute all the time due to the actual work they have to do, like
    allocating memory or using meta programmation, or because of the complexity they
    hide:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，这种逻辑对我们以及我们可以在高性能环境和应用程序中依赖CDI的方式有一些影响。现在简单的bean实例化需要看起来简单但实际上可能很昂贵的操作，这可能是由于它们必须执行的实际工作，如分配内存或使用元编程，或者由于它们隐藏的复杂性：
- en: Most of the steps imply some reflection (that is, Java reflection) and, therefore,
    the container must cache all it can to avoid wasting time in retrieving the reflection
    data again and again.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数步骤都涉及到一些反射（即Java反射），因此容器必须缓存所有内容以避免在反复检索反射数据时浪费时间。
- en: '*Step 1* and *step 3* can imply calling back `createInstance()` for other instances,
    which means that if the complexity to create an instance without any injection
    is 1, the complexity to create an instance with N injections will be *1+N*. It
    will be *1+NxM* if the N injections have M injections.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤 1* 和 *步骤 3* 可以意味着为其他实例调用`createInstance()`，这意味着如果没有注入创建实例的复杂度为1，那么带有N个注入的实例创建复杂度将是*1+N*。如果N个注入有M个注入，那么将是*1+NxM*。'
- en: Scopes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: A very neat feature of the CDI is to handle the scope life cycle for you. Concretely,
    you decorate your beans with `@ApplicationScoped` and `@RequestScoped`, and the
    life of the bean is either bound to the application (it is a singleton) or the
    request duration (which means you can have as many different instances as you
    have concurrent requests).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的一个非常整洁的特性是为你处理范围生命周期。具体来说，你使用`@ApplicationScoped`和`@RequestScoped`装饰你的bean，bean的生命周期要么绑定到应用程序（它是一个单例），要么绑定到请求持续时间（这意味着你可以有与并发请求一样多的不同实例）。
- en: The scope implementation is called *context*, and the context is mainly responsible
    for looking up in the right contextual instance or creating it. An application
    scoped instance will be looked up in a single map shared by the entire application.
    However, a request scoped instance will also be looked up in `ThreadLocal` associated
    with the request life cycle through `ServletRequestListener`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 范围实现被称为*上下文*，上下文主要负责查找正确的上下文实例或创建它。应用程序范围的实例将在整个应用程序共享的单个映射中查找。然而，请求范围的实例也将通过`ServletRequestListener`与请求生命周期关联的`ThreadLocal`中查找。
- en: 'The implications on the performance are quite immediate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对性能的影响是相当直接的：
- en: The context setup can be pricey (depending on the scope) and can add some overhead
    that you may not require. In fact, if you have no `@RequestScoped` bean, you don't
    need the `ServletRequestListener` instance (even if not very expensive).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文设置可能很昂贵（取决于范围）并可能添加一些你可能不需要的开销。实际上，如果你没有`@RequestScoped` bean，你不需要`ServletRequestListener`实例（即使它不是很昂贵）。
- en: Recreating your bean every time the context needs it will trigger the process
    we saw in the previous part and the life cycle hooks of the bean (`@PostConstruct`
    and `@PreDestroy`).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次上下文需要时重新创建你的bean将触发我们在上一部分看到的进程，以及bean的生命周期钩子（`@PostConstruct`和`@PreDestroy`）。
- en: Interceptors/decorators
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截器/装饰器
- en: 'Interceptors are the CDI way of adding custom handlers on top of a bean. For
    instance, our logging handler will be this interceptor in CDI:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是CDI在bean之上添加自定义处理器的途径。例如，我们的日志处理器在CDI中将是这个拦截器：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Decorators do the same job but they are applied automatically based on the interface(s)
    they implement and get the current implementation injected. They don't require
    a binding (such as `@Log` to put on a method to activate `LoggingInterceptor`),
    but they are more specific to a set of types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器做同样的工作，但它们会根据它们实现的接口自动应用，并注入当前实现。它们不需要绑定（例如，使用`@Log`将方法放在上面以激活`LoggingInterceptor`），但它们更具体于一组类型。
- en: 'In terms of the performance, an interceptor/decorator will obviously add some
    logic and, therefore, some execution time. But it also adds a more vicious overhead:
    the context creation. This part depends on the implementation of the CDI your
    server uses (Weld, OpenWebBeans, CanDI, and so on). However, if you don''t have
    any interceptor, the container doesn''t need to create a context and, therefore,
    to populate it. Most of the context creation is cheap but the `getParameter()`
    method, which represents the parameters of the method, can be expensive, since
    it requires converting a stack call into an array.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，拦截器/装饰器显然会增加一些逻辑，因此会增加一些执行时间。但它还增加了一个更恶性的开销：上下文创建。这部分取决于你的服务器使用的CDI实现（Weld、OpenWebBeans、CanDI等）。然而，如果你没有拦截器，容器不需要创建上下文，因此也不需要填充它。大多数上下文创建都很便宜，但`getParameter()`方法，它代表方法的参数，可能很昂贵，因为它需要将堆栈调用转换为数组。
- en: 'CDI implementations have multiple choices here and we will not go through all
    of them. What is important to keep in mind here is the following equation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CDI实现在这里有多个选择，我们不会逐一介绍。这里需要记住的重要方程是以下内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you only have interceptors that don't do much, you can often assume that
    the container makes it as right as possible. If you compare this with a framework
    where you do it all manually, you will probably see this overhead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有不做什么的拦截器，你通常可以假设容器尽可能正确地处理它。如果你将它与一个你需要手动完成所有工作的框架进行比较，你可能会看到这个开销。
- en: By itself, the associated overhead is still acceptable, not big enough to not
    use interceptors in your code regarding the maintenance/complexity versus the
    performance trade-off. However, when you start adding a lot of interceptors, you
    need to ensure that they are well implemented too. What does this mean? To understand,
    we need to step back and see how interceptors are used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就其本身而言，相关的开销仍然是可接受的，并不大，以至于在维护/复杂性 versus 性能权衡中，你不需要在你的代码中使用拦截器。然而，当你开始添加大量的拦截器时，你需要确保它们也得到了良好的实现。这意味着什么？为了理解，我们需要退后一步看看拦截器是如何使用的。
- en: To link an interceptor and an implementation, you need to use what we call an interceptor
    binding, which is the marker annotation of your interceptor (decorated with `@InterceptorBinding`).
    No big issues until here, but this binding often holds some configuration, making
    the interceptor behavior configurable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要将拦截器与实现链接起来，你需要使用我们所说的拦截器绑定，这是你的拦截器的标记注解（用 `@InterceptorBinding` 装饰）。到目前为止没有大问题，但这个绑定通常包含一些配置，使得拦截器行为可配置。
- en: 'If we use back our logging interceptor, the logger name is configurable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用我们的日志拦截器，日志名称是可配置的：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, `LoggingInterceptor` needs to get back the value, which will be passed
    to the logger factory to get the logger instance that our interceptor will use
    to decorate the actual bean invocation. This means that we can just modify our
    previous implementation, as shown in the following snippet, to respect the logger
    configuration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`LoggingInterceptor` 需要获取回值，这个值将被传递给日志工厂以获取我们的拦截器将用于装饰实际豆调用（bean invocation）的日志实例。这意味着我们只需修改之前的实现，如下面的代码片段所示，以尊重日志配置：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All the tricky part is in `getLoggerName()`. A bad and fragile - because it
    relies on plain reflection and not CDI metamodel - but common implementation is
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有棘手的部分都在 `getLoggerName()`。一个坏的和脆弱的实现——因为它依赖于简单的反射而不是 CDI 元模型——但常见的实现如下：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Why is it fragile? Because there is no guarantee that the class handling works,
    as you can get a proxy instance and ignore the stereotype usage. It is bad because
    it utilizes reflection at every invocation and the JVM is not really optimized
    for such usage. The implementer should call `getAnnotation` only once.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它脆弱？因为没有保证类处理（class handling）是有效的，因为你可以得到一个代理实例并忽略类型使用（stereotype usage）。这很糟糕，因为它在每次调用时都使用反射，而
    JVM 并没有针对这种使用进行优化。实现者应该只调用一次 `getAnnotation`。
- en: 'Regarding the performances, a better implementation will be to ensure that
    we don''t use reflection every time there is an invocation call, but only once,
    since the Java model (the `Class` metadata) doesn''t change at runtime in general.
    To do it, we can use `ConcurrentMap` which will hold the already computed names
    in memory and avoid to do it again and again when the same method is called:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能，更好的实现是确保我们不在每次调用时都使用反射，而只使用一次，因为 Java 模型（`Class` 元数据）在一般情况下在运行时不会改变。为了做到这一点，我们可以使用
    `ConcurrentMap`，它将在内存中保存已经计算过的名称，并避免在调用相同方法时重复计算：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It simply caches the logger name per method and computes it once. This way,
    no reflection after the first call is involved; instead, we rely on the cache.
    `ConcurrentHashMap` is a good candidate for it and its overhead is negligible
    compared to a *synchronized* structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是为每个方法缓存日志记录器名称并一次性计算。这样，在第一次调用之后不再涉及反射；相反，我们依赖于缓存。`ConcurrentHashMap` 是一个很好的候选者，并且与同步结构相比，其开销是可以忽略不计的。
- en: To be fast, do we just need to ensure that the interceptors are caching metadata?
    Actually, it is not enough. Remember that the interceptors are beans with an enforced
    scope: `@Dependent`. This scope means *create every time you need*. In the context
    of an interceptor, it means *create an instance of the interceptor every time
    you create an intercepted bean*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速执行，我们是否只需要确保拦截器缓存元数据？实际上，这还不够。记住，拦截器是具有强制作用域的豆（beans）：`@Dependent`。这个作用域意味着
    *每次需要时创建*。在拦截器的上下文中，这意味着 *每次创建被拦截的豆时都创建拦截器的一个实例*。
- en: If you think of a `@RequestScoped` bean, then its interceptors will be created
    for every request and the cache, which totally defeats the purpose.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一个 `@RequestScoped` 豆，那么它的拦截器将为每个请求创建，这将完全违背其目的。
- en: 'To solve it, do not cache in the interceptor but in an `@ApplicationScoped`
    bean, which is injected into the interceptor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，不要在拦截器中缓存，而是在一个`@ApplicationScoped`的豆中缓存，该豆被注入到拦截器中：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This simple trick ensures that our cache is `@ApplicationScoped` itself and,
    therefore, computed only once per application. If you want to make sure you don't
    compute it at runtime at all, you can even enforce it to be initialized through
    a CDI extension in an observer of the `AfterDeploymentValidation` event (but this
    is less impacting on the performance).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的技巧确保我们的缓存本身是`@ApplicationScoped`的，因此每个应用程序只计算一次。如果您想确保在运行时根本不计算它，甚至可以强制通过`AfterDeploymentValidation`事件的观察者中的CDI扩展来初始化它（但这会对性能产生较小的影响）。
- en: To conclude this part, note that the specifications now rely on interceptors
    to provide their features and integrate together (Security API, JTA, JSF, JAX-RS,
    and so on). The EJB specification was providing the JTA integration until Java
    EE 7 (replaced by `@Transactional`) and the security API until Java EE 8 (replaced
    by Security API). It was an ad-hoc implementation of these integrations (such
    as our `Container` at the beginning of this chapter), but it is strictly equivalent
    to the interceptor functional use. And in terms of the performance, both implementations
    (EJB and CDI based) are often very close.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这部分，请注意，现在的规范现在依赖于拦截器来提供其功能和集成（安全API、JTA、JSF、JAX-RS等）。EJB规范在Java EE 7之前提供JTA集成（由`@Transactional`取代）和安全API直到Java
    EE 8（由安全API取代）。这是一个临时的实现这些集成的实现（如本章开头提到的我们的`Container`），但它严格等同于拦截器功能的使用。至于性能，这两种实现（EJB和基于CDI的）通常非常接近。
- en: Events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'CDI events globally provide an event BUS inside the application. They can be
    synchronous or asynchronous. To let you have an idea, here is what the code can
    look like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CDI事件在应用程序中全局提供事件总线。它们可以是同步的或异步的。为了让您有一个概念，以下是一个可能的代码示例：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As both types of invocations are exclusive, what we can note here is that these
    snippets call `fire()` and `fireAsync()`*.* To be able to target all the observers,
    you need to invoke both. This means that the associated logic will be twice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两种类型的调用都是互斥的，我们可以在这里注意的是，这些片段调用`fire()`和`fireAsync()`*.* 要能够针对所有观察者，您需要调用两者。这意味着相关的逻辑将是两倍。
- en: 'Without entering into the details that do not impact our performance, both
    cases share the same resolution mechanism:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入到不影响我们性能的细节，这两种情况具有相同的解析机制：
- en: Resolve the observers based on the event type.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据事件类型解决观察者。
- en: Remove the observers not matching the fire type (asynchronous or synchronous).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除与火灾类型（异步或同步）不匹配的观察者。
- en: Sort the observers by priority.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按优先级排序观察者。
- en: Handle the invocations.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理调用。
- en: The difference between synchronous and asynchronous cases is *point 4*. In the
    synchronous case, it just means, *invoke the observers*, whereas in the asynchronous
    case, it means, *call asynchronously and return* `CompletionStage` *representing
    all the invocation results*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 同步和异步案例之间的区别是*第4点*。在同步情况下，这意味着*调用观察者*，而在异步情况下，这意味着*异步调用并返回*代表所有调用结果的`CompletionStage`。
- en: The parts impacting the performance are the resolution of the observers and
    the invocation, which can require some bean resolution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 影响性能的部分是观察者和调用的解析，这可能需要一些豆类解析。
- en: We already saw bean resolution, so let's dig into the observer resolution here.
    Indeed, the implementation is specific to the vendor you are using. But, as it
    is impossible to use static analysis to implement this part, the resolution is
    done at runtime with a cache per event type. Note that the caching depends a lot
    on the implementation. Most will only cache raw type events.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了豆类解析，所以让我们深入探讨观察者解析。实际上，实现是特定于您所使用的供应商。但是，由于无法使用静态分析来实现这部分，解析是在运行时通过每个事件类型的缓存来完成的。请注意，缓存在很大程度上取决于实现。大多数只会缓存原始类型事件。
- en: 'This concretely means that the invocation without generics, as shown in the
    following code, will be way faster than the invocation that implements generics
    and enforces the CDI container to do some more resolution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这具体意味着，如下所示的无泛型调用，将比实现泛型并强制CDI容器进行更多解析的调用要快得多：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In terms of the code, and to let you compare it with the previous example,
    the code with generics would be exactly the same except the event would be parameterized:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，为了让您与前面的示例进行比较，具有泛型的代码将完全相同，只是事件将是参数化的：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, once you have the potential set of observers, you need to reduce the set
    based on the qualifiers that the caller configures for the event. This also implies
    some reflection, more or less cached, depending on the implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦你有了潜在的观察者集，你需要根据调用者为事件配置的限定符来减少这个集合。这也意味着需要一些反射，多多少少是缓存的，具体取决于实现。
- en: Finally, some runtime checks are enforced by the set of tests that the vendors
    have to pass so that we can claim to be compliant with the specifications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些运行时检查是通过供应商必须通过的测试集强制执行的，这样我们就可以声称符合规范。
- en: All these steps are more or less optimized by vendors depending on the cases
    they may have received complaints about. But in all of them, you can end up on
    code paths where everything is done at runtime for the firing of each event, which
    can be a pain in terms of the performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都由供应商根据他们可能收到的投诉进行不同程度的优化。但在所有这些中，你可能会遇到在运行时为每个事件的触发执行所有操作的代码路径，这在性能方面可能会成为一个痛点。
- en: Dynamic lookups
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态查找
- en: Another great feature of the CDI is to be able to control a lazy instantiation
    or resolution of a bean. This is done with the `Provider<?>` and `Instance<?>`
    APIs. *Instance* is a *Provider* allowing you to resolve a bean at runtime. *Provider*
    is an instance wrapper allowing you to decide when to instantiate the underlying
    instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的另一个重要特性是能够控制Bean的懒加载或解析。这是通过`Provider<?>`和`Instance<?>` API实现的。*Instance*是一个*Provider*，允许你在运行时解析一个Bean。*Provider*是一个实例包装器，允许你决定何时实例化底层实例。
- en: 'Take a look at the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at the underlying mechanism of the preceding code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面代码片段的底层机制：
- en: Calling `Provider.get()` will trigger the creation of an underlying instance
    (`MyService` here). It delays the instantiation of the injection or makes the
    instantiation conditional. Note that it depends on the scope of the bean and that
    a normal scoped bean won't benefit much from this use.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Provider.get()`将触发底层实例（这里为`MyService`）的创建。它延迟了注入或实例化的实例化，使其条件化。请注意，这取决于Bean的作用域，并且一个正常作用域的Bean不会从这种使用中获得太多好处。
- en: Calling `Instance.select(...)` will make the bean definition more specific based
    on the injection point. In this case, we start from a bean type (`MyService`*)*
    with the implicit `@Default` qualifier and replace the implicit qualifier with
    the one passed as the parameter. Then, we resolve the bean and get its instance.
    This is useful for switching the implementation dynamically and conditionally.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Instance.select(...)`将使Bean定义根据注入点变得更加具体。在这种情况下，我们从一个具有隐式`@Default`限定符的Bean类型（`MyService`*）开始，并用作为参数传递的限定符替换隐式限定符。然后，我们解析Bean并获取其实例。这对于动态和条件性地切换实现是有用的。
- en: Since an *Instance* is a *Provider*, the implementations share the same code
    for both. This means their performances will be the same.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*Instance*是一个*Provider*，它们的实现共享相同的代码，这意味着它们的性能将是相同的。
- en: 'Now the question is, what is the cost of using a programmatic lookup versus
    a plain injection? Is it more expensive or not? In terms of implementation, the
    code is quite comparable, it has to resolve the bean to instantiate and then instantiate
    it so that we are very close to an injection. We will ignore the small differences
    that do not impact the performance much. One issue here is its use: if you get
    a *Provider* injected and resolve it for each use, you will then increase a lot
    of the time spent on *resolving and instantiating* versus *just using an already
    resolved and created instance*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，使用程序化查找与直接注入相比的成本是什么？是更贵还是不贵？从实现的角度来看，代码相当相似，它必须解析Bean以进行实例化，然后实例化它，这样我们就可以非常接近注入。我们将忽略那些对性能影响不大的小差异。这里有一个问题是它的使用：如果你注入了一个*Provider*并为其每次使用进行解析，那么你将大大增加在*解析和实例化*与*仅使用已解析和创建的实例*之间花费的时间。
- en: JAX-RS – the servlet router
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS – servlet路由器
- en: Even if JAX-RS is not fully bound to HTTP and is usable over JMS, WebSockets,
    and so on, we will just consider the HTTP case here and, more particularly, the
    case it runs on top of the servlet specification (which is the most common one).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使JAX-RS并非完全绑定到HTTP，并且可以在JMS、WebSockets等上使用，我们在这里只考虑HTTP的情况，尤其是它运行在servlet规范之上（这是最常见的情况）。
- en: The goal of JAX-RS is to provide a command pattern based on the API to implement
    the HTTP communications. In other words, it abstracts the I/O with Java modeling.
    You can see it as a HTTP Java object binding solution. This is what `QuoteResource`
    uses.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS的目标是提供基于API的命令模式以实现HTTP通信。换句话说，它通过Java模型抽象I/O。你可以将其视为一个HTTP Java对象绑定解决方案。这就是`QuoteResource`所使用的。
- en: 'The role of JAX-RS is to provide all the necessary tooling to make servlet
    abstraction directly usable for most cases. For this purpose, it provides the
    following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS的作用是提供所有必要的工具，使servlet抽象在大多数情况下可以直接使用。为此，它提供了以下功能：
- en: A routing layer letting developers directly map the request based on its path
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个路由层，允许开发者直接根据请求的路径映射请求
- en: A serialization layer allowing the conversion of Java objects into HTTP models
    and streams
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列化层，允许将Java对象转换为HTTP模型和流
- en: An exception handling layer enabling the mapping of an exception to an HTTP
    response
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个异常处理层，可以将异常映射到HTTP响应
- en: The router
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: 'JAX-RS is command-oriented. It means that a request must be bound to a Java
    method. To do so, the matching takes multiple parameters of the request into account:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS是面向命令的。这意味着请求必须绑定到一个Java方法。为此，匹配会考虑请求的多个参数：
- en: The patch
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁
- en: The Accept header
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Accept头
- en: The Content-Type header
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Type头
- en: 'Here is the simplified algorithm for routing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是路由的简化算法：
- en: Find the class matching the request based on the path (this is a regex-like
    logic).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据路径找到匹配请求的类（这是一个类似于正则表达式的逻辑）。
- en: From the class found in *step 1*, find the method matching the request based
    on the path. (This is close to *step 1* but applied to methods with subresource
    handling.)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤 1*中找到的类中，根据路径找到匹配请求的方法。（这类似于*步骤 1*，但应用于具有子资源处理的方法。）
- en: From the methods found in *step 2*, find the one that will handle the request
    based on mime types (Accept/Content-Type headers). This level parses the media
    types to handle the quality of service options (q, qs, and so on) of the header.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤 2*中找到的方法，根据MIME类型（Accept/Content-Type头）来处理请求。这一级别解析媒体类型以处理头部的服务质量选项（q、qs等）。
- en: This is not a complicated algorithm, but it is quite dynamic and depends on
    the incoming requests. So most of the time, it is done at runtime by the providers
    and can add a small overhead, which you can notice during benchmarks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个复杂的算法，但它相当动态，并且取决于传入的请求。因此，大多数情况下，它由提供者在运行时完成，可能会增加一点开销，这在基准测试中可以注意到。
- en: Marshalling
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marshalling
- en: (Un)Marshalling is what will (read/)write a Java object to a communication format.
    It is commonly the part converting an object to a XML or JSON payload but can
    really be any format, including binary formats.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （反）序列化是将Java对象写入通信格式的过程。它通常是将对象转换为XML或JSON有效负载的部分，但实际上可以是任何格式，包括二进制格式。
- en: This conversion is normally synchronous in the implementation and can be costly
    depending on the model you use and the serializer that is activated. Compared
    with the servlet API, where you yourself serialize the payload you want to read/return,
    here, the task is done by the framework and is, therefore, a bit hidden.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换在实现中通常是同步的，并且根据你使用的模型和激活的序列化器，可能会很昂贵。与你自己序列化想要读取/返回的有效负载的servlet API相比，这里任务由框架完成，因此有点隐藏。
- en: A crucial point at this stage is to make sure that the manipulated object has
    almost no logic and is fast to initialize/read. If you don't respect this point,
    you may end up holding the HTTP stream for too long which would badly impact your
    scalability and on a more general practice, you would risk to have some lazy loading
    of data with JPA which can fail or imply an unexpected connection usage depending
    the JPA provider and configuration. Another bad case would be to start writing
    and, then, compute some costly value before continuing to write and therefore
    force the marshalling process to pause and delay the write after having started
    it. This not only has a direct impact on the request thread pool but also on the
    HTTP I/O.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段的一个关键点是确保被操作的对象几乎没有逻辑，并且初始化/读取速度快。如果你不遵守这个点，你可能会长时间保持HTTP流，这会严重影响你的可伸缩性。在更普遍的做法中，你可能会面临一些JPA的懒加载数据，这可能会失败或根据JPA提供程序和配置导致意外的连接使用。另一个坏情况是在开始写入之前，先计算一些昂贵的值，然后再继续写入，因此迫使序列化过程暂停并延迟写入。这不仅对请求线程池有直接影响，也对HTTP
    I/O有影响。
- en: In the same spirit as the algorithm used to match a method to invoke (see the
    previous part), the JAX-RS runtime must resolve the provider to use (`MessageBodyReader`
    or `MessageBodyWriter` depending on whether you read or write) in order to make
    the link with the Java model. Here again, this resolution depends on the incoming
    request (or the response being built) and media type headers and is not as flat
    as expected even if it is cacheable and generally fast.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于匹配要调用的方法（参见上一部分）的算法精神相同，JAX-RS运行时必须解析要使用的提供者（根据您是读取还是写入，使用`MessageBodyReader`或`MessageBodyWriter`），以便与Java模型建立联系。在这里，这种解析同样依赖于传入的请求（或正在构建的响应）和媒体类型头，即使它是可缓存的并且通常很快，但也不像预期的那样平坦。
- en: Filter and interceptors
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器和拦截器
- en: JAX-RS 2.0 added `ContainerRequestFilter` and`ContainerResponseFilter` to modify
    the request context. It is executed around the method invocation but has already
    passed the method resolution. On a high level, it can be seen as a CDI interceptor
    but only at the HTTP layer. These filters do not impact significantly the performance
    until they do a lot of logic, and there are a few cases where it is a good place
    to put some logic. One very common example is to validate a security token or
    log in a user based on the HTTP headers. Don't be surprised to see this kind of
    component while investigating what your application is doing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0添加了`ContainerRequestFilter`和`ContainerResponseFilter`来修改请求上下文。它在方法调用周围执行，但已经通过了方法解析。从高层次来看，它可以被视为CDI拦截器，但仅限于HTTP层。这些过滤器在执行大量逻辑之前不会显著影响性能，而且有几个地方是放置逻辑的好位置。一个非常常见的例子是根据HTTP头验证安全令牌或登录用户。在调查应用程序正在做什么时，不要对看到这种组件感到惊讶。
- en: In the same spirit, `ReaderInterceptor` and `WriterInterceptor` intercept `MessageBodyReader` or `MessageBodyWriter`*.*
    They are intended to wrap the input/output streams to add some support such as
    GZIP compression. However, since we are close to the current I/O, we need to take
    care to not add too much logic here if the payloads are huge or if the algorithm
    is complex. In fact, since the stream operations are called very often, a badly
    implemented wrapper can affect the performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`ReaderInterceptor`和`WriterInterceptor`拦截`MessageBodyReader`或`MessageBodyWriter`*.*
    它们的目的是封装输入/输出流以添加一些支持，例如GZIP压缩。然而，由于我们接近当前的I/O，如果负载很大或算法复杂，我们需要注意不要在这里添加太多逻辑。实际上，由于流操作被频繁调用，一个实现不当的包装器可能会影响性能。
- en: '@Suspended or asynchronous operation'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Suspended或异步操作'
- en: 'JAX-RS 2.1 got a brand new reactive API to integrate with Java 8 CompletionStage
    but the server also has a nice integration to be reactive: `@Suspended`. For instance,
    the `findAll`method of `QuoteResource`could look like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.1获得了一个全新的反应式API来与Java 8 CompletionStage集成，但服务器也有一个很好的集成来变得反应式：`@Suspended`。例如，`QuoteResource`的`findAll`方法可能看起来如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the synchronous flavor of a JAX-RS method, the returned instance is the
    response payload. However, when going asynchronous, the returned instance is no
    more used as the payload in JAX-RS 2.0; the only option is to use the `AsyncResponse`
    JAX-RS API to let the container be notified of the state of processing of the
    request. Since JAX-RS 2.1 (Java EE 8), you can also return a Java 8 CompletionStage
    instance, which gives you the same hooks, and the server can integrate with it
    to be notified of the success or failure of the invocation. In any case, both
    kinds of APIs imply the same kind of logic:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在JAX-RS方法的同步版本中，返回的实例是响应负载。然而，当变为异步时，返回的实例在JAX-RS 2.0中不再用作负载；唯一的选择是使用`AsyncResponse`
    JAX-RS API来让容器通知请求处理的状况。自从JAX-RS 2.1（Java EE 8）以来，你也可以返回一个Java 8 CompletionStage实例，这为你提供了相同的钩子，服务器可以与之集成以通知调用的成功或失败。在任何情况下，这两种API都隐含了相同类型的逻辑：
- en: The `@Suspended` annotation marks a parameter of the `AsyncResponse` type to
    be injected. This is the callback holder you use to notify JAX-RS that you have
    finished the execution and have made JAX-RS resume the HTTP request. If you use
    the `CompletionStage` API flavor, you don't need this parameter and can directly
    use your `CompletionStage` instance almost the same way.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Suspended`注解标记了一个`AsyncResponse`类型的参数以供注入。这是您用来通知JAX-RS您已完成执行并让JAX-RS恢复HTTP请求的回调持有者。如果您使用`CompletionStage`
    API版本，您不需要此参数，可以直接几乎以相同的方式使用您的`CompletionStage`实例。'
- en: This  asynchronous API makes sense when the computation of the response is asynchronous.
    So, we need to submit the task in a thread pool. In EE 8 the best way to do it
    correctly is to rely on the EE concurrency utility API and, therefore, `ManagedExecutorService`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当响应的计算是异步的时候，这种异步 API 是有意义的。因此，我们需要在线程池中提交任务。在 EE 8 中，正确完成这个任务的最佳方式是依赖于 EE 并发实用工具
    API，因此使用 `ManagedExecutorService`。
- en: Once the computation is finished, `resume()` is used to send back the response
    (normal payload or `throwable`), which will use `ExceptionMappers` to be translated
    in payload.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦计算完成，使用 `resume()` 发送响应（正常有效载荷或 `throwable`），这将使用 `ExceptionMappers` 将其转换为有效载荷。
- en: With this pattern, you need to take into account the fact that there is another
    thread pool apart from the HTTP one. It will impact at different levels, which
    we will deal with later, but an important point is that increasing the number
    of threads doesn't mean improving the performance in all cases, and for fast execution,
    you can even decrease your performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，你需要考虑到除了 HTTP 线程池之外，还有一个其他的线程池。它将在不同层面上产生影响，我们将在稍后处理，但一个重要的观点是，增加线程数量并不一定意味着在所有情况下都能提高性能，对于快速执行，你甚至可以降低性能。
- en: JPA – the database link
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA – 数据库链接
- en: The **Java Persistence API** (**JPA**) is the link to the database (MySQL for
    our quote application we created in chapter 1). Its goal is to enable an application
    to map the database model to Java objects. The gain is that we can use the database
    as any object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 持久化 API**（**JPA**）是数据库的链接（对于我们在第 1 章中创建的报价应用，是 MySQL）。它的目标是使应用程序能够将数据库模型映射到
    Java 对象。好处是我们可以像使用任何对象一样使用数据库。'
- en: 'For instance, consider the following table, which matches our quote representation
    in the database:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下表格，它与我们在第 1 章中创建的报价应用在数据库中的表示相匹配：
- en: '![](img/6326f8c9-058d-4daa-9bed-16f9bc5d2a25.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6326f8c9-058d-4daa-9bed-16f9bc5d2a25.png)'
- en: 'The preceding table can be converted into the following object in Java, thanks
    to JPA annotations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格可以通过 JPA 注解转换为以下 Java 对象：
- en: '![](img/7a04b4ed-93e3-4530-8c26-d5d8d01c843a.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a04b4ed-93e3-4530-8c26-d5d8d01c843a.png)'
- en: 'While the tables are *flat*, mapping them in JPA is pretty straightforward,
    but the more the model complexity will increase, the more you will realize the
    two opposed worlds: building a great Java model can lead to an awful database
    model or the opposite. Why? Because both don''t share exactly the same philosophy
    and can lead to some anti-patterns.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表是 *扁平的*，但在 JPA 中映射它们相当直接，但随着模型复杂性的增加，你会越来越多地意识到两个对立的世界：构建一个优秀的 Java 模型可能会导致一个糟糕的数据库模型，或者相反。为什么？因为它们并不完全共享相同的哲学，可能会导致一些反模式。
- en: 'For instance, in our model, we linked our *Quote* to *Customer* mapping. Since
    a customer can have multiple quotes (and the opposite as well), we used a `@ManyToMany`
    relationship. If you check the database generated by JPA, you will be surprised
    to see one table that is not modelized:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的模型中，我们将 *Quote* 与 *Customer* 映射链接起来。由于一个客户可以有多个报价（反之亦然），我们使用了 `@ManyToMany`
    关系。如果你检查由 JPA 生成的数据库，你可能会惊讶地看到一个没有模型化的表：
- en: '![](img/a15a59f1-1b14-4e20-9ea1-376376ec403a.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15a59f1-1b14-4e20-9ea1-376376ec403a.png)'
- en: 'The **QUOTE_CUSTOMER** table model is pretty simple if you open it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 **QUOTE_CUSTOMER** 表模型，它相当简单：
- en: '![](img/8f11dc14-5cdd-45fd-a643-0810c69e08a7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f11dc14-5cdd-45fd-a643-0810c69e08a7.png)'
- en: As you can see, it just makes a link between the **QUOTE** and **CUSTOMER**
    tables. This is what we would manually do on the database side, except that we
    would modelize this table (it wouldn't be implicit) and potentially add some attributes
    owned by the relationship (something we can't do with our current Java model).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它只是在 *QUOTE* 和 *CUSTOMER* 表之间建立了一个链接。这是我们会在数据库端手动做的，除了我们会模型化这个表（它不会是隐式的）并且可能添加一些由关系拥有的属性（这是我们当前
    Java 模型无法做到的）。
- en: Of course, you can always modelize this join table and link it to *Quote* and *Customer *with `@ManyToOne`
    relationships if you need more flexibility or want to be closer to the database
    model.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以模型化这个连接表，并通过 `@ManyToOne` 关系将其链接到 *Quote* 和 *Customer*，如果你需要更多的灵活性或者更接近数据库模型的话。
- en: 'This example is interesting at two levels:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在两个层面上都很有趣：
- en: What will the JPA provider do to fetch the quotes of a customer, since there
    is this join table in the middle?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于中间存在这个连接表，JPA 提供商会如何获取客户的报价呢？
- en: 'The model is symmetric: a customer can get the quotes he can access, and we
    can access the allowed customers from a quote. In Java, it will just be translated
    by `quote.getCustomers()` and `customer.getQuotes()`. Are both doing the same
    thing? Are they similar in terms of performance? In Java, they really look the
    same, right?'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型是对称的：客户可以获取他们可以访问的报价，我们可以从报价中访问允许的客户。在Java中，它将通过`quote.getCustomers()`和`customer.getQuotes()`来翻译。它们是否做的是同一件事？在性能方面它们是否相似？在Java中，它们看起来真的很相似，对吧？
- en: To dig into the role of the provider, we must start by checking how by using
    some object-related code and query language the provider can actually make it
    work on the database-side, which uses a different paradigm. To do so, we will
    first investigate how our Java code is converted to native SQL and, then, check
    how the modeling can impact the performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解提供者的作用，我们必须首先检查提供者如何使用一些与对象相关的代码和查询语言在数据库端实际工作，而数据库端使用的是不同的范式。为此，我们将首先研究我们的Java代码是如何转换为原生SQL的，然后检查建模如何影响性能。
- en: From JPA to the database
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JPA到数据库
- en: JPA let's you represent your database in plain Java. Said otherwise it let's
    you represent the relational model as an object model. It is very common for the
    development and maintenance but at some point, and in particular when you will
    validate your performances, you will need to check what the mapper (JPA implementation)
    is doing and how it does translate your object code/model to the relational one
    (SQL).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JPA让您用纯Java表示您的数据库。换句话说，它让您将关系模型表示为对象模型。这在开发和维护中非常常见，但在某个时候，尤其是在您将验证性能时，您将需要检查映射器（JPA实现）正在做什么，以及它是如何将对象代码/模型转换为关系模型的（SQL）。
- en: 'When you check the JPA caller code, you often have something like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查JPA调用代码时，您通常会有以下内容：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For more complex queries, it is like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的查询，它看起来像以下这样：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I will not deal with named queries versus this kind of query in this part, but
    what is important here is that the model is object/Java-based. Even the JPQL query
    is related to an object and not plain SQL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本部分讨论命名查询与这种查询之间的区别，但重要的是，该模型是基于对象/Java的。即使是JPQL查询也是与对象相关，而不是纯SQL。
- en: 'This leads to the main role of the JPA provider: translating all the code from
    the object/Java model to the relational/SQL model.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了JPA提供者的主要作用：将所有代码从对象/Java模型转换为关系/SQL模型。
- en: 'To understand this, we will configure the JPA provider of our server to log
    what it does. Since we are using GlassFish, we need to configure EclipseLink,
    which is the JPA provider. To do so, we just add the following properties in the
    persistence unit:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，我们将配置我们的服务器上的JPA提供者以记录它所做的工作。由于我们使用GlassFish，我们需要配置Eclipselink，它是JPA提供者。为此，我们只需在持久化单元中添加以下属性：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This configuration will activate Eclipselink to log at `FINEST` level of the
    logger a lot of information. To see these information, we need to ensure the `FINEST` log
    level is written somewhere and not skipped as it is done by default. To do that,
    you need to configure the EclipseLink logger level to `FINEST` as well. This way
    Eclipselink would log with a level the logger would output. You can do it in GlassFish
    add this line to your `logging.properties`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将激活Eclipselink在日志记录器的`FINEST`级别记录大量信息。要查看这些信息，我们需要确保`FINEST`日志级别被记录在某处，而不是默认跳过。为此，您需要将Eclipselink日志记录器级别配置为`FINEST`。这样，Eclipselink将以日志记录器输出的级别进行记录。您可以在GlassFish中这样做，将以下行添加到您的`logging.properties`文件中：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that if we use the maven plugin that we set up in [Chapter 1](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml),
    *Money – The Quote Manager Application* to run GlassFish, it will fallback on
    JVM `logging.properties` and you will need to either modify it from `$JAVA_HOME/jre/lib/logging.properties`
    or set another one when launching the server. Here is the potential content to
    activate logging in the console:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们使用在[第1章](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml)中设置的maven插件*Money
    – The Quote Manager Application*来运行GlassFish，它将回退到JVM的`logging.properties`，您需要修改`$JAVA_HOME/jre/lib/logging.properties`或启动服务器时设置另一个配置。以下是激活控制台日志记录的潜在内容：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, to use this file when launching the server, simply set the system
    property, `java.util.logging.config.file` (assuming you put the file in `src/main/glassfish/conf/logging.properties`),
    as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在启动服务器时使用此文件，只需设置系统属性`java.util.logging.config.file`（假设您将文件放在`src/main/glassfish/conf/logging.properties`），如下所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The logger name uses this pattern:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器名称使用以下模式：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if you start the server, you have a few more lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动服务器，您将看到更多几行：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These lines are generated by our JPA provider (EclipseLink here) every time
    a query is issued to the database. The queries use bound parameters. This is interesting
    at two levels. The first one is about the security and intends to prevent SQL
    injections - note that for security reasons as well, the values are not logged
    by default `eclipselink.logging.parameters` can be set to true in your persistence
    unit properties if you want to see them instead of the number of bound parameters
    only. The second interesting consequence is directly linked to the performance
    and the fact that the provider can use prepared statements instead of creating
    a statement every time it creates a query. Combined with a datasource pool which
    can most of the time cache these prepared statements, it makes pretty cheap to
    execute statement compared to an implementation which would create them each time
    it is needed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行是由我们的 JPA 提供商（此处为 EclipseLink）在每次向数据库发出查询时生成的。这些查询使用绑定参数。这在两个层面上都很有趣。第一个层面是关于安全性的，旨在防止
    SQL 注入 - 注意出于安全原因，默认情况下不会记录值。如果要将它们记录为绑定参数的数量，可以在持久化单元属性中设置 `eclipselink.logging.parameters`
    为 true。第二个有趣的后果是直接与性能相关，并且提供者可以使用预编译语句而不是每次创建查询时都创建语句。结合可以缓存这些预编译语句的数据源池，与每次需要时才创建它们的实现相比，执行语句的成本非常低。
- en: Depending on your JPA provider, you need to change the properties to activate
    the query logging. Hibernate and OpenJPA use other properties and logger names,
    for instance. Alternatively, some containers or JDBC drivers will let you configure
    it at another level. For instance, in Apache TomEE you can set `LogSQL=true` in
    your `DataSource` resource directly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的 JPA 提供商，您需要更改属性以激活查询日志。例如，Hibernate 和 OpenJPA 使用其他属性和记录器名称。或者，某些容器或 JDBC
    驱动程序允许您在另一个级别进行配置。例如，在 Apache TomEE 中，您可以直接在 `DataSource` 资源中设置 `LogSQL=true`。
- en: What is interesting to see is the effect of what we write in Java on the SQL
    side.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是看到我们在 Java 中编写的内容对 SQL 侧面的影响。
- en: 'The `INSERT` case is straightforward and directly converts the JPA model to
    the corresponding SQL statement to insert all the values into the corresponding
    database:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT` 情况很简单，直接将 JPA 模型转换为相应的 SQL 语句，将所有值插入到相应的数据库中：'
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`SELECT` is a direct binding too, which selects all the columns with a clause
    on the idenfitier of the entity:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 也是一个直接绑定，它通过实体的标识符上的子句选择所有列：'
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, the role of the JPA provider is quite obvious; it makes the link to SQL,
    which means the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，JPA 提供者的作用非常明显；它将 Java 与 SQL 链接起来，这意味着以下内容：
- en: Convert the JPA API and JPQL to the current SQL. Note that in all the JPA providers,
    there is a notion of database SQL language so that they can handle the database
    specifics (such as the column types or the pagination). EclipseLink calls it *platform*,
    Hibernate, *dialect *and OpenJPA, *dictionary*.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JPA API 和 JPQL 转换为当前的 SQL。请注意，在所有 JPA 提供商中，都有一个数据库 SQL 语言的概念，以便它们可以处理数据库的特定细节（例如列类型或分页）。EclipseLink
    称之为 *platform*，Hibernate 称之为 *dialect*，OpenJPA 称之为 *dictionary*。
- en: 'Handle Java to database mapping: database column names are converted to field
    names, table names to class names, and so on.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Java 到数据库的映射：数据库列名转换为字段名，表名转换为类名，等等。
- en: 'However, if you look closer to the logs when you query a quote through the
    JAX-RS endpoint, you may be surprised:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在通过 JAX-RS 端点查询报价时仔细查看日志，可能会感到惊讶：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Where does it come from? If you investigate a bit, you will quickly identify
    this line in the JAX-RS layer:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它从哪里来？如果您稍作调查，您会很快在 JAX-RS 层中识别出这一行：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What does it do? It just sets the number of customers linked to *Quote*. Which
    part triggers this additional query? A simple call on the relationship collection
    triggers it. In our case, it is `size()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了什么？它只是设置了与 *Quote* 链接的客户数量。触发这个附加查询的部分是什么？对关系集合的简单调用触发了它。在我们的例子中，它是 `size()`：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since the relationship between *Quote* and *Customer* is lazy, this simple line
    will trigger an additional query with EclipseLink. What is interesting is that
    if you check the JAX-RS resource, it is not `@Transactional` and this query may
    fail depending on the JPA provider, as lazy handling must be done in a transaction.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Quote` 和 `Customer` 之间的关系是延迟加载的，这条简单的语句将触发 EclipseLink 的附加查询。有趣的是，如果您检查
    JAX-RS 资源，它不是 `@Transactional`，并且这个查询可能会根据 JPA 提供商而失败，因为延迟处理必须在事务中进行。
- en: The provider is clever enough to not trigger any query and just call `getCustomers()`*.* But
    it will do when calling any method of the returned collection such as `size()` here.
    Depending on the provider, null may or may not be possible, which is why the original
    code assumes it can be null.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者足够聪明，不会触发任何查询，只是调用 `getCustomers()`*.* 但在调用返回集合的任何方法，如这里的 `size()` 时，它会这样做。根据提供者，null
    可能是可能的，也可能不是，这就是为什么原始代码假设它可以返回 null。
- en: We will discuss about modelling in another chapter but the obvious solution
    to make the relationship eager is not a real solution, since you will slowly load
    all your object graphs everywhere, doing which can lead to performance issues
    and even memory issues. So try to resist this temptation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在另一章中讨论建模，但使关系 *eager* 的明显解决方案并不是真正的解决方案，因为你会慢慢地加载所有对象图，这样做可能会导致性能问题，甚至内存问题。所以尽量抵制这种诱惑。
- en: 'While you are playing with the JPA and SQL, I recommend that you disable EclipseLink''s
    default shared cache, which easily hides queries (later on, we will discuss why
    to disable it even in production). This can be done with the following property
    added to your persistence unit:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在玩 JPA 和 SQL 时，我建议你禁用 EclipseLink 的默认共享缓存，因为它很容易隐藏查询（稍后我们将讨论为什么即使在生产中也要禁用它）。这可以通过添加以下属性到你的持久化单元中来实现：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Model and implications
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和影响
- en: This section does not intend to go through all the cases; other books centered
    on JPA do it very well. In order to avoid doing things that can have a negative
    impact on the performances, this part will show you that the abstraction JPA does
    need some attention.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节并不打算讨论所有情况；其他专注于 JPA 的书籍做得很好。为了避免做可能对性能产生负面影响的事情，这部分将向你展示 JPA 所做的抽象确实需要一些关注。
- en: 'To illustrate this statement, we will reuse the **Customer***/***Quote** relationship.
    As it is *@ManyToMany,* it relies on a join table. Here is a representation of
    the model:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个说法，我们将重用 **Customer***/***Quote** 关系。由于它是一个 *ManyToMany*，它依赖于一个连接表。以下是模型的表示：
- en: '![](img/5b51832e-7f3f-457e-80f0-6ea74effb9b2.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b51832e-7f3f-457e-80f0-6ea74effb9b2.png)'
- en: The use case is when you want to access the other side of the relationship: *Quotes*
    from a *Customer* (`getQuotes()`) or the opposite (`getCustomers().size()`)*.*
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是当你想要访问关系的另一侧时：来自 *客户* (`getQuotes()`) 的 *引用* 或相反 (`getCustomers().size()`)*.*
- en: Here, the provider will find all the entities that have the current entity identifier
    in the join table.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提供者将找到所有在连接表中具有当前实体标识符的实体。
- en: 'This sounds perfectly fine but how can it affect the performance? If you check
    the structure of the join table in MySQL, you will immediately see a minor difference:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来非常合理，但它如何影响性能呢？如果你检查 MySQL 中连接表的结构，你将立即看到一些细微的差异：
- en: '![](img/15b333a4-70b2-420b-86b3-b3a8c8aded64.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15b333a4-70b2-420b-86b3-b3a8c8aded64.png)'
- en: The `quotes_ID` column has an index, whereas the `customers_ID` column does
    not. Do not be fooled by the picture and the fact that both the columns have a
    yellow key. The primary key is the composed key of both the columns, so the index
    is not useless and allows us to select fast rows from `quotes_ID`. Why does `quotes_ID`
    have an index and `customers_ID`hasn't? Because the *Quote* entity is the owner
    of the relationship. However, it will always be faster to select columns by the *Quote*
    identifier rather than by the *Customer* identifier.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`quotes_ID` 列有一个索引，而 `customers_ID` 列则没有。不要被图片和事实所欺骗，即两个列都有黄色的键。主键是两个列的组合键，因此索引不是无用的，它允许我们快速从
    `quotes_ID` 中选择行。为什么 `quotes_ID` 有索引而 `customers_ID` 没有？因为 *Quote* 实体是关系的所有者。然而，通过
    *Quote* 标识符选择列总是比通过 *Customer* 标识符选择列要快。'
- en: 'Now the interesting part is to compare both the calls:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有趣的部分是比较这两个调用：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first call will load the customers from an already loaded quote whereas
    the second call will load the quotes related to an already loaded customer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用将从已加载的引用中加载客户，而第二次调用将加载与已加载客户相关的引用。
- en: 'Now let''s see what the corresponding generated SQL will be. The first invocation
    will be converted to the following statement:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看相应的生成的 SQL 将会是什么。第一次调用将被转换为以下语句：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second invocation (`customer.getQuotes()`) will be converted to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用 (`customer.getQuotes()`) 将被转换为以下内容：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A join is done with the known sides of the relationship, which means the entity
    containing the relationship (set of entities). Yet, we saw that only one of the
    two columns of the join table has an index. This means that one side will be slower
    than the other side. If you use bi-directional relationships, you should ensure
    that you make the owner of the relationship either of the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是通过关系的已知侧面进行的，这意味着包含关系的实体（实体集）。然而，我们看到了连接表的两个列中只有一个有索引。这意味着一个侧面将比另一个侧面慢。如果您使用双向关系，您应该确保关系的所有者要么是以下之一：
- en: The one that is way more used than the other one (if there is a huge difference)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个比另一个使用得多的选项（如果存在巨大差异）
- en: The one that will bring back a smaller set of entities than the other one
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个将返回比另一个更小实体集的选项
- en: This is just an example of how a very fast model can impact the performance.
    This is a general statement that is valid for any modeling. Anyway, since JPA
    makes modeling very easy and not as much database-related, it is easier to make
    it wrong.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，说明了一个非常快的模型如何影响性能。这是一个适用于任何建模的一般性陈述。无论如何，由于JPA使建模变得非常简单，并且与数据库相关的程度不高，因此更容易出错。
- en: The Java Transaction API
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java事务API
- en: The **Java Transaction API** (**JTA**) is the element responsible for providing
    the API responsible for ensuring the consistency of your data in the widest sense.
    In our quote manager, it is only applied to the database data but it can be applied
    to JMS messages, potentially files if you use connectors, and so on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java事务API**（**JTA**）是负责提供确保您数据在广泛意义上一致性的API的元素。在我们的报价管理器中，它仅应用于数据库数据，但可以应用于JMS消息，如果使用连接器，则可能应用于文件等。'
- en: Without going through the details and protocol, the idea is to ensure, across
    multiple systems, that either all commits or all rollbacks but not something in
    between are done ensuring the consistency of the system (which is one common issue
    mixing NoSQL systems).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节和协议，其想法是在多个系统之间确保要么所有提交要么所有回滚，而不是介于两者之间，以确保系统的致性（这是混合NoSQL系统的一个常见问题）。
- en: 'To do that, JTA uses what we call a *two phases commit protocol*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，JTA使用我们所说的*两阶段提交协议*：
- en: Ask all systems to prepare the commit which means the system must verify and
    ensure it will be able to commit in next phase
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求所有系统准备提交，这意味着系统必须验证并确保它将在下一阶段能够提交
- en: Ask all systems to actually do the commit
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求所有系统实际进行提交
- en: A lot of transaction manager or servers are optimized for the case of a single
    resource to limit all the associated overhead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事务管理器或服务器针对单个资源进行了优化，以限制所有相关的开销。
- en: In our quote manager application we only have a database, so we should benefit
    from these optimizations in most servers. Nonetheless, we still use JTA backbone
    and don't fallback on JPA transaction management (*RESOURCE_LOCAL*) which is faster.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的报价管理器应用程序中，我们只有一个数据库，因此我们应该从大多数服务器中受益于这些优化。尽管如此，我们仍然使用JTA骨干，不回退到JPA事务管理（*RESOURCE_LOCAL*），后者更快。
- en: What is important to know with JTA is that a transaction is bound to a thread.
    Each resource has its representation and identifier, a complete lifecycle (see
    *XAResource*). There is a transaction bound registry to store the data (a bit
    like a *@TransactionScoped* bean) and the listeners to integrate with the transaction
    lifecycle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在JTA中需要了解的重要信息是，事务绑定到一个线程上。每个资源都有其表示和标识符，一个完整的生命周期（参见*XAResource*）。有一个事务绑定注册表来存储数据（有点像*a@TransactionScoped*豆）以及与事务生命周期集成的监听器。
- en: All of that is not true in terms of memory and CPU cycles but can be justified
    if you need it, either because you have multiple systems or because you use your
    server JTA monitoring (you rarely have monitoring with *RESOURCE_LOCAL i*n administration
    UI).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在内存和CPU周期方面都不成立，但如果需要，可以证明它是合理的，要么因为您有多个系统，要么因为您使用服务器JTA监控（您很少使用带有*RESOURCE_LOCAL*
    i*n管理UI的监控）。
- en: Server resources
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器资源
- en: 'At several layers, the server provides your application with some resources.
    In our quote manager we have our datasource injected into the persistence unit
    through its JNDI name:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个层级上，服务器为您的应用程序提供了一些资源。在我们的报价管理器中，我们通过其JNDI名称将数据源注入到持久化单元中：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This datasource can also be injected anywhere else in the code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据源也可以在代码的任何其他地方注入：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But the server manages way more resources. Resources are important because they
    are provided and handled by the server but used from the application. In other
    words it is a way to control how the application behaves from the outside of it.
    It enables you to develop without having to care about the configuration and to
    tune it later or to adapt it depending on the environment you deploy your application
    to. The next table lists a subset of the most useful JavaEE resource types which
    can impact your performances and you can need to watch out if your application
    uses some of them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但服务器管理的资源更多。资源很重要，因为它们由服务器提供和处理，但由应用程序使用。换句话说，这是一种从应用程序外部控制应用程序行为的方式。它使你能够在不关心配置的情况下开发，并在以后调整它或根据部署应用程序的环境对其进行调整。下表列出了最有用的JavaEE资源类型子集，这些类型可能会影响你的性能，如果你的应用程序使用其中一些，你可能需要留意。
- en: '| **Resource Type** | **Description** | **Example** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **资源类型** | **描述** | **示例** |'
- en: '| `ManagedExecutorService` | An EE *ExecutorService* which is used to ensure
    you inherit the EE context in custom asynchronous tasks. Very useful to link to
    JAX-RS *@Suspended* or third party libraries for instance. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `ManagedExecutorService` | 一个EE *ExecutorService*，用于确保在自定义异步任务中继承EE上下文。对于链接到JAX-RS
    *@Suspended* 或第三方库等非常有用。 |'
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ManagedScheduledExecutorService` | Close to the `ManagedExecutorService`,
    it reuses the `ScheduledExecutorService` API adding the EE integration. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `ManagedScheduledExecutorService` | 接近`ManagedExecutorService`，它重用`ScheduledExecutorService`
    API并添加EE集成。 |'
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `DataSource` | As seen before it allows to connect to a database providing
    a `DataSource` instance. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `DataSource` | 如前所述，它允许通过提供`DataSource`实例来连接到数据库。 |'
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `XADataSource` | Same as `DataSource` but supporting two phases commit. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `XADataSource` | 与`DataSource`相同，但支持两阶段提交。 |'
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Queue` | JMS *Queue*, it defines a destination of type queue. In term of
    configuration, its name can be interesting to distinguish the logical name (application)
    and real name (deployment). |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `Queue` | JMS *队列*，它定义了一个队列类型的目的地。在配置方面，其名称可以区分逻辑名称（应用程序）和实际名称（部署）。 |'
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Topic` | Same as `Queue` but for a destination of type `topic`. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Topic` | 与`Queue`相同，但用于类型为`topic`的目的地。 |'
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ConnectionFactory` | Defines the way to integrate with JMS and get *Connections*
    (or *JMSContext* since Java EE 7). |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionFactory` | 定义了与JMS集成的方式以及获取 *连接*（或Java EE 7以来的 *JMSContext*）。
    |'
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: There are other types of resources, but those are the main ones linked to the
    outside of the application and with performance related configuration, like pooling
    configuration.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 存在其他类型的资源，但这些都是与应用程序外部链接的主要资源，以及与性能相关的配置，如池配置。
- en: DataSource configuration
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据源配置
- en: 'To illustrate the configuration let''s use the one we rely on in the quote
    manager: the datasource. As shown in [Chapter 1](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml), *Money
    – The Quote Manager Application* you can define the datasource this way:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明配置，让我们使用在报价管理器中依赖的配置：数据源。如[第1章](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml)中所示，*货币
    - 报价管理器应用程序*，你可以这样定义数据源：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This XML configuration defines the datasource our JPA provider will use thanks
    to two declarations allowing the container to create the datasource instance and
    allowing the JPA provider to find this datasource:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此XML配置定义了JPA提供者将使用的数据源，这得益于两个声明：允许容器创建数据源实例，并允许JPA提供者找到此数据源：
- en: The pool definition which defines how the database connections will be created,
    cached and validated
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 池定义了如何创建、缓存和验证数据库连接。
- en: The link between the pool and the application through its JNDI name to let the
    application use it - this is how JPA will look up the instance
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其JNDI名称将池与应用程序之间的链接，以便应用程序可以使用它——这就是JPA如何查找实例的方式
- en: The properties are the datasource instance (based on the configured class) configuration
    but the `jdbc-connection-pool` attributes are mostly the pool configuration.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是数据源实例（基于配置的类）的配置，但`jdbc-connection-pool`属性主要是池配置。
- en: 'It is very important to note that the configuration depends on the server.
    As an example, in Wildly, you would use this kind of declaration:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，配置取决于服务器。例如，在Wildly中，你会使用这种类型的声明：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here again we find a property part and a pool part. Still, it is no more in
    attributes but with plain tags.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次发现了一个属性部分和一个池部分。然而，它不再包含属性，而是使用纯标签。
- en: 'In Apache TomEE the same resource declaration looks like:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache TomEE中，相同的资源声明看起来像：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here the configuration is not fully XML but it is mixed with properties (as
    `java.util.Properties`) that contains the pool configuration and connection information
    which will be passed either to tomcat-jdbc or commons-dbcp2 pooling library.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，配置不是完全基于XML，但它与属性（如`java.util.Properties`）混合，这些属性包含池配置和连接信息，这些信息将被传递给tomcat-jdbc或commons-dbcp2连接池库。
- en: 'What is interesting to note is the overall idea. Most of the servers share
    the same kind of configuration and here are the crucial configuration entries
    you need to care about:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是整体思路。大多数服务器共享相同的配置类型，以下是您需要关注的关键配置条目：
- en: '| **Configuration type** | **Description** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **配置类型** | **描述** |'
- en: '| Max pool size | How many connections can be created by the pool. This is
    a key configuration which must be set consistently with the scalability you need
    across your deployments and the database max connection configuration. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 最大池大小 | 池可以创建的连接数。这是一个关键的配置，必须与您在部署和数据库最大连接配置中需要的可扩展性保持一致。|'
- en: '| Max wait | The time a caller can wait before getting a timeout from the pool.
    For performances it is not bad to deactivate it (0) to ensure you identify a too
    small pool. If you set 10 seconds for instance, the benchmark can be slow because
    all callers are waiting for a connection. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 最大等待时间 | 调用者等待多长时间才能从池中获得超时。对于性能来说，不激活它（0）并不坏，以确保您能够识别出池太小。例如，如果您设置为10秒，基准测试可能会变慢，因为所有调用者都在等待连接。|'
- en: '| Idle timeout | How many times a connection is kept if idle. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 空闲超时 | 连接空闲时可以保持多少次。|'
- en: '| Validation | How connections are validated, this is very important to ensure
    connections are valid when kept in the pool and not corrupted. For instance MySQL
    will close each connection after 8h by default and therefore if your pool doesn''t
    renew the connection you will get errors. The validation type is important because
    it can generally be done by a background thread from time to time or actively
    when borrowing or releasing a connection. All have impacts on consistency and/or
    performances so it is a trade off choice and if you can rely on your database
    it is generally better to have a background evictor than an active one. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 验证 | 连接如何验证，这对于确保连接在池中保持有效且未损坏非常重要。例如，MySQL默认情况下会在8小时后关闭每个连接，因此如果您的池不更新连接，您将遇到错误。验证类型很重要，因为它通常可以通过后台线程定期执行或在借用或释放连接时主动执行。所有这些都会对一致性和/或性能产生影响，因此这是一个权衡选择，如果您可以依赖您的数据库，那么通常有一个后台驱逐器比一个主动的驱逐器更好。|'
- en: '| Min (or steady) pool size | The size the pool should enforce as a minimum.
    The goal is to ensure that when the application is idle and get a new request
    it doesn''t have to create a connection at that moment and can just reuse an existing
    one because creating a connection is an expensive operation. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 最小（或稳定）池大小 | 池应强制执行的最低大小。目标是确保当应用程序空闲并接收到新请求时，它不需要在那个时刻创建连接，而可以重用现有的一个，因为创建连接是一个昂贵的操作。|'
- en: '| Initial (or steady) pool size | The number of connections to create when
    creating the resource (at startup generally). In GlassFish this is merged with
    the minimum pool size (*steady-pool-size*). |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 初始（或稳定）池大小 | 创建资源时创建的连接数（通常在启动时）。在GlassFish中，这合并了最小池大小（*steady-pool-size*）。|'
- en: 'Last note about resources is that most servers allow multiple ways to configure
    them:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 关于资源的最后一点是，大多数服务器允许以多种方式配置它们：
- en: Plain configuration files (often XML based).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纯配置文件（通常基于XML）。
- en: A command line interface.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个命令行界面。
- en: A REST API.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个REST API。
- en: 'A UI. For instance, here is a screenshot of Glassfish JDBC pool configuration
    where you will find all the parameters we talked about:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用户界面。例如，这里是一个Glassfish JDBC池配置的截图，您将找到我们讨论的所有参数：
- en: '![](img/50962771-bbca-430e-bb43-60238d85dfd6.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50962771-bbca-430e-bb43-60238d85dfd6.png)'
- en: Java EE and performances
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE和性能
- en: As a reminder, this book is not about Java EE role, so we can't go through all
    the specifications and detail them all but it is important to understand what
    Java EE is and what its role is to be able to start working on Java EE performances
    serenely.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这本书不是关于Java EE角色的，所以我们不能详细说明所有规范，但了解Java EE是什么以及它的角色对于能够平静地开始工作在Java EE性能方面是非常重要的。
- en: 'Very often, a small annotation or line of code can hide a lot of logic. The
    entity manager is a good example: most of the methods are hiding some SQL generation
    and execution which is not a trivial operation.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，一行小的注释或代码可以隐藏很多逻辑。实体管理器就是一个很好的例子：大部分的方法都隐藏了一些SQL生成和执行，这不是一个简单的操作。
- en: 'With the standardization of CDI in applications, a simple call to a method
    with a simple complexity can imply to:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CDI在应用程序中的标准化，对具有简单复杂性的方法的简单调用可能意味着：
- en: Validate the call (BeanValidation) which can be impacting if the object graph
    is huge
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证调用（BeanValidation），如果对象图很大，可能会产生影响
- en: Validate the logged in user and its permissions (Security API) which can sometimes
    contact external systems depending on the configuration and implementations
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证已登录用户及其权限（安全API），这有时会根据配置和实现与外部系统进行通信
- en: An integration of multiple external systems (JTA), and so on
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成多个外部系统（JTA）等
- en: All these features can be done with CDI interceptors and are additional logic
    virtually added to a method.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都可以使用CDI拦截器完成，并且是向方法中虚拟添加的额外逻辑。
- en: Ensure you know the server
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保您了解服务器
- en: When you will start to investigate your application performances, before or
    during profiling, it is therefore important to understand what the server does
    to know what you should expect in terms of performances. At runtime, the server
    is part of your application. This means that if the server has a bug (it is still
    a software like anyone, so it can have bugs or issues even if widely tested),
    or a performance bottleneck, you will directly be impacted.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在您开始调查应用程序性能之前或在进行性能分析时，了解服务器做了什么对于了解您应该期望的性能至关重要。在运行时，服务器是您应用程序的一部分。这意味着如果服务器有错误（它仍然是一个软件，所以即使经过广泛测试也可能有错误或问题），或者有性能瓶颈，您将直接受到影响。
- en: Some servers can be embedded with your application, and some can't. Yet, in
    any case, you will need to ensure you validate your application as well (as your
    server) to fully understand your runtime and be able to have an impact on it if
    needed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器可以嵌入到您的应用程序中，而另一些则不行。然而，在任何情况下，您都需要确保验证您的应用程序（以及您的服务器）以全面了解您的运行时，并在需要时能够对其产生影响。
- en: 'Here the choice of your server will be very impacting. You may need to ask
    yourself what to do in case the server has a bug or a performance bottleneck.
    In the following, you will find some criteria you can investigate before the benchmark
    or when starting the development:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您服务器的选择将非常关键。您可能需要问自己，如果服务器出现错误或性能瓶颈，您将如何应对。以下是一些您在基准测试之前或开始开发时可以调查的标准：
- en: '| **Criteria** | **Comment** |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **标准** | **注释** |'
- en: '| Is the server Open Source? | If the server is Open Source, you will be able
    to check issues you identify against the source code and validate them. You will
    also be able to recompile it with patches and potentially don''t wait for the
    server team to fix the issue but fix it yourself, which can be very interesting
    during benchmarks if it has some associated cost (like locating servers or dedicated
    locals). |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 服务器是否开源？ | 如果服务器是开源的，您将能够检查您识别的问题与源代码，并对其进行验证。您还可以使用补丁重新编译它，并且可能不需要等待服务器团队修复问题，而是自己修复它，这在基准测试中如果有一些相关成本（如定位服务器或专用场地）可能非常有意义。|'
- en: '| Is the server supported? | Having a company you pay for fixing performance
    issues (or bugs) can be important too. However, mind that some servers will answer
    quite slowly if you don''t pay enough, and this doesn''t help a lot during benchmarks.
    If you go with this solution, make sure to have appropriated SLA or go rather
    for the Open Source solution. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 服务器是否受支持？ | 拥有一个您支付以修复性能问题（或错误）的公司可能也很重要。然而，请注意，如果您支付不足，一些服务器可能会非常慢地响应，这在基准测试期间帮助不大。如果您选择这种解决方案，请确保有适当的SLA或选择开源解决方案。|'
- en: '| Is the application portable? | If the application is portable, you would
    be able to compare servers and use the fastest one. This is not a trivial work
    to do even if since Java EE 6 it is easier and you will need to ensure it is the
    case during development. But this can be worthy if one version of a server has
    a performance issue. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序是否可移植？ | 如果应用程序是可移植的，您将能够比较服务器并使用最快的那个。即使自从Java EE 6以来这变得更容易，您也需要确保在开发过程中是这种情况。但如果一个服务器版本有性能问题，这可能是值得的。|'
- en: Until recently, Java EE philosophy was to host applications. This is where was
    coming the *application server* name. The intent, which is still valid today,
    was to ensure the server is managed by another team than the application (typically,
    operation team and development team).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，Java EE的哲学是托管应用程序。这就是*应用服务器*名称的由来。这种意图至今仍然有效，即确保服务器由不同于应用程序的团队管理（通常是运营团队和开发团队）。
- en: Yet, with Docker and embeddable containers (Apache TomEE, Wildfly Swarm, Payara
    micro, and so on), the operation responsability started being reconsidered and
    developers have more and more control over the server. This means that you will
    then ask yourself the same question (how can I easily patch my server?), but also
    that you will need an expert developer either from your development team or from
    a computer support company.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Docker和可嵌入容器（Apache TomEE、Wildfly Swarm、Payara micro等）的出现，运营责任开始被重新考虑，开发者对服务器的控制越来越多。这意味着您将问自己同样的问题（我如何轻松地修补我的服务器？），但也意味着您需要一位专家开发者，无论是来自您的开发团队还是来自计算机支持公司。
- en: Ensure you know your application
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保您了解您的应用程序
- en: In case it was not explicit enough before, it is crucial to know what the server
    does for your application. It is already key in development, but when you start
    working on performances, it is a must. This means that you need to know the application
    good enough to know which part of the server it will use and which implication
    it will have on your performances.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前不够明确，了解服务器为您的应用程序做了什么至关重要。在开发阶段这已经很重要，但当您开始关注性能时，这更是必须的。这意味着您需要足够了解应用程序，以便知道它将使用服务器中的哪部分以及这对您的性能有何影响。
- en: In other words, you will need to fully understand the use case of your application
    but also what technology was used to implement it. A simple example is if your
    application used *RESOURCE_LOCAL* mode for JPA but you see a lot of JTA use, then
    you will need to identify why. If you don't have this kind of insight, you will
    just think the application uses JTA and that it is ok. Yet, this kind of fact
    can mean *something is not well configured*, which can not only impact the application's
    behavior, but also its raw performances and even its scalability.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，您不仅需要完全理解您应用程序的使用案例，还需要了解实现它所使用的技术。一个简单的例子是，如果您的应用程序使用了JPA的*RESOURCE_LOCAL*模式，但您看到很多JTA的使用，那么您需要找出原因。如果您没有这种洞察力，您可能会认为应用程序使用了JTA，并且这是可以的。然而，这种事实可能意味着*某些配置不当*，这不仅可能影响应用程序的行为，还可能影响其原始性能甚至可扩展性。
- en: 'It is also very important to know what part of the specifications is used.
    To illustrate it we''ll use JPA again here. JPA is integrated with Bean Validation.
    This means that each time you will persist/merge an entity, the entity will be
    validated to ensure it passes the model constraints. This is a great feature but
    if you validate your model on the outbounds of your application (JAX-RS for instance)
    then you rarely (never in theory, if the application is done correctly) need to
    revalidate it internally (JPA). This means that the Bean Validation layer is useless
    here and can be disabled. This particular example is done by updating the `persistence.xml`
    and adding the `validation-mode` tag in the right persistence unit:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 了解使用了哪些规范部分也非常重要。为了说明这一点，我们再次使用JPA。JPA与Bean Validation集成。这意味着每次您持久化/合并一个实体时，该实体都会被验证以确保它通过了模型约束。这是一个很好的特性，但如果您在应用程序的外部（例如JAX-RS）验证模型，那么您很少（在理论上，如果应用程序做得正确，永远不会）需要在内部重新验证它（JPA）。这意味着Bean
    Validation层在这里是无用的，可以禁用。这个特定的例子是通过更新`persistence.xml`并在正确的持久化单元中添加`validation-mode`标签来完成的：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Ensure you know your resources
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保您了解您的资源
- en: 'It is crucial to properly tune the resources (databases, thread pools, and
    so on). Since Java EE 6, some resources can be defined in the application. For
    instance, a `DataSource` can be defined with:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正确调整资源（数据库、线程池等）至关重要。自Java EE 6以来，一些资源可以在应用程序中定义。例如，可以使用以下方式定义`DataSource`：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is often a bad idea since you can't externally configure it (it is hardcoded).
    Thus, you often end up configuring the resources in server specific files or UI.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不是一个好主意，因为您无法外部配置它（它是硬编码的）。因此，您通常会结束于在服务器特定的文件或UI中配置资源。
- en: 'This is a good practise to avoid in the application. But outside the application,
    Java EE doesn''t define any way or standard to configure the server. Everything
    is vendor specific. However, you will need to tune it! For that reason, it is
    crucial to ensure you know:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在应用程序中应该避免的良好实践。但是，在应用程序之外，Java EE没有定义任何方式或标准来配置服务器。一切都是供应商特定的。然而，你需要调整它！因此，确保你知道这一点至关重要：
- en: What kind of resources your application needs
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序需要哪些资源
- en: How to create them and configure them in your server
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在服务器中创建它们并配置它们
- en: This is a great start for the application side but resources are generally linked
    to an *external* side like a database. Here again, it will be very important to
    know the resource itself, how it is configured and potentially how to tune it
    if needed. A very simple example is the number of connections you can use on a
    database. If you can only use 20 connections, no need to configure 100 in the
    application, this would generate a lot of errors and slow down the application,
    or just make it fail depending on how the pool is configured.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于应用程序来说是一个很好的开始，但资源通常与一个*外部*方面（如数据库）相关联。在这里，了解资源本身、它的配置以及如果需要的话如何调整它，将非常重要。一个非常简单的例子是数据库上你可以使用的连接数。如果你只能使用20个连接，就没有必要在应用程序中配置100个，这会生成大量错误并减慢应用程序的速度，或者根据池的配置，甚至可能导致它失败。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you understood that the Java EE server's role is to make the
    development of the application easier and faster, providing out-of-the-box services
    and implementations. We browsed through some common examples, detailed their implications
    in terms of the code, and, therefore, the performance. We saw that the JPA handles
    statement creation automatically, securely, and correctly and that your code can
    imply some unoptimized queries if not designed close enough of the data. This
    is a good example showing that Java EE is here to enable you to build the best
    application as easily as possible even though you need to take care of some points
    (often related to design) in order to ensure you meet your performance requirements.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到Java EE服务器的角色是使应用程序的开发更加容易和快速，提供即插即用的服务和实现。我们浏览了一些常见示例，详细说明了它们在代码和性能方面的含义。我们看到了JPA自动、安全、正确地处理语句创建，如果你的代码没有足够接近数据设计，可能会暗示一些未优化的查询。这是一个很好的例子，说明Java
    EE旨在让你尽可能容易地构建最佳应用程序，尽管你需要注意一些点（通常与设计相关），以确保你满足性能要求。
- en: At this point, we have an application ([Chapter 1](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml),
    *Money – The Quote Manager Application*), we know what it does, and how the Java
    EE server helps it (this chapter). So, before working on the performance, we need
    to be able to measure it. This is what our next chapter will be about.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个应用程序（[第1章](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml)，*货币 - 引用管理器应用程序*），我们知道它做什么，以及Java
    EE服务器如何帮助它（本章）。因此，在着手性能之前，我们需要能够对其进行测量。这正是我们下一章将要讨论的内容。
