- en: Chapter 3. Routing and Processors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 路由和处理程序
- en: In the previous chapter, we saw the core concepts of implementing the messaging
    and routing system provided by Camel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Camel提供消息和路由系统实现的核心概念。
- en: In this chapter we will cover routing—one of the most important features of
    Camel. Without the routing, Camel would be a simple *connectivity* framework.
    Routing is a key function of Camel, it means we can apply all the transformations
    to a message. It can modify the content of the message itself or the destination
    of the message, all on the fly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍路由——Camel最重要的功能之一。没有路由，Camel将只是一个简单的**连接**框架。路由是Camel的关键功能，这意味着我们可以将所有转换应用于消息。它可以修改消息的内容或消息的目的地，所有这些都是在运行时完成的。
- en: 'This chapter introduces:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了：
- en: How to use a processor to change an exchange
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用处理器来改变交换
- en: A complete example of a route containing a processor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含处理器的完整路由示例
- en: What is a processor?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是处理器？
- en: A consumer endpoint receives an event from the environment and wraps it as an
    **Exchange**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端点从环境中接收一个事件，并将其封装为一个**交换**。
- en: The routing engine transports this Exchange from the endpoint to a processor,
    which is possible from one processor to another processor, up to a final endpoint
    via a **Channel**. The route can end at a processor returning the Exchange to
    the consumer endpoint if the MEP is `InOut` (and using the out message), or stop
    with a producer endpoint, sending the message to the environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路由引擎将这个交换从端点传输到处理器，这可以从一个处理器传输到另一个处理器，直到通过**通道**到达最终的端点。如果消息交换模式（MEP）是`InOut`（并使用输出消息），则路由可以在返回消费者端点的处理器处结束，或者通过生产者端点停止，将消息发送到环境。
- en: This means that a processor acts as an Exchange modifier—it consumes an Exchange,
    and eventually updates it. We can see the processor as a message translator. Actually,
    all Camel **Exchange Integration Patterns** (**EIPs**) are implemented using processors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着处理器充当交换修改器——它消费一个交换，并最终更新它。我们可以将处理器视为消息翻译器。实际上，所有Camel**交换集成模式**（**EIP**）都是使用处理器实现的。
- en: 'A processor is described by the `org.apache.camel.Processor` interface. This
    interface provides only one method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器通过`org.apache.camel.Processor`接口进行描述。此接口仅提供一种方法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the processor directly receives an Exchange, it has access to all the data
    contained in the Exchange:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理器直接接收交换，它可以访问交换中包含的所有数据：
- en: The message exchange pattern
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息交换模式
- en: The `in` message
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入消息
- en: The `out` message
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出消息
- en: The `exchange` exception
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换异常
- en: An example of Camel routes containing processors
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含处理器的Camel路由示例
- en: 'Here we will illustrate the use of processors in an example. This example will
    create an **OSGi** bundle, which will create two Camel contexts with one route
    in each; they are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过一个示例来说明处理器在其中的使用。这个示例将创建一个**OSGi**包，该包将创建两个Camel上下文，每个上下文有一个路由；它们如下所示：
- en: One route using the Camel Java DSL
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Camel Java DSL的一个路由
- en: One route using the Camel Blueprint DSL
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Camel Blueprint DSL的一个路由
- en: 'First, we create the Maven project `pom.xml` for our bundle:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的包创建Maven项目`pom.xml`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this `pom.xml`, we can see:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`pom.xml`文件中，我们可以看到：
- en: That we depend on camel-core (in the version of our choice; here it's 2.12.3)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们依赖于camel-core（我们选择的版本；这里为2.12.3）
- en: We also depend to osgi-core as we create an OSGi bundle
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也依赖于osgi-core，因为我们创建了一个OSGi包
- en: We use the maven-bundle plugin to create the OSGi bundle (especially the MANIFEST
    containing the OSGi headers). Here, we provide a bundle Activator (`com.pack.camel.chapter3.Activator`),
    the details of which we will see later in this chapter.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用maven-bundle插件创建OSGi包（特别是包含OSGi头部的MANIFEST）。在这里，我们提供了一个包激活器（`com.pack.camel.chapter3.Activator`），其详细信息我们将在本章后面看到。
- en: Prefixer processor
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prefixer处理器
- en: We are now ready to create a Prefixer processor. This processor will get the
    incoming Exchange, extract the `in` message body, and prefix this body with *Prefixed.*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个Prefixer处理器。这个处理器将获取传入的交换，提取`in`消息体，并在该体前加上*Prefixed*。
- en: The processor is a simple class implementing the Camel processor interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是一个简单的类，实现了Camel处理器接口。
- en: 'We create `PrefixerProcessor` as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`PrefixerProcessor`如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see how the processor acts as a message translator; it transforms
    the `in` message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到处理器如何作为消息翻译器；它转换`in`消息。
- en: Creating a route using Java DSL
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Java DSL创建路由
- en: It's now time to create the first route using the Camel Java DSL, using the
    `PrefixerProcessor`. In order to use the Camel Java DSL, we create a class extending
    the Camel `RouteBuilder` class (`org.apache.camel.RouteBuilder`). This class describes
    the route in a `configure()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 Camel Java DSL 创建第一条路由了，使用 `PrefixerProcessor`。为了使用 Camel Java DSL，我们创建一个扩展
    Camel `RouteBuilder` 类（`org.apache.camel.RouteBuilder`）的类。这个类在 `configure()` 方法中描述了路由。
- en: 'We create a `MyRouteBuilder` class which is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `MyRouteBuilder` 类，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This route starts with a timer. The timer creates an empty Exchange every 5
    seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由以计时器开始。计时器每5秒创建一个空的 Exchange。
- en: We define the body of the `in` message (of this Exchange) using the `.setBody()`
    method, containing the `Hello Chapter3` constant String.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.setBody()` 方法定义了 `in` 消息（此 Exchange 的）体，包含 `Hello Chapter3` 常量字符串。
- en: We call `PrefixerProcessor` using the `.process()` method. As expected, the
    `PrefixerProcessor` appends `Prefixed` to the body of the `in` message, resulting
    to `Prefixed Hello Chapter3`. We can see that `PrefixerProcesser` has been correctly
    called using a log endpoint just after (`.to("log:MyRoute")`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.process()` 方法调用 `PrefixerProcessor`。正如预期的那样，`PrefixerProcessor` 将 `Prefixed`
    追加到 `in` 消息的体中，结果为 `Prefixed Hello Chapter3`。我们可以看到 `PrefixerProcesser` 已经在（`.to("log:MyRoute")`）之后的日志端点正确调用。
- en: Instead of creating a dedicated class for a processor, it's also possible to
    create a processor inline. It's what we do using `.process(new Processor(){…})`.
    We implement an inline processor that removes the prefix appended by `PrefixerProcessor`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建一个用于处理器的专用类之外，还可以创建一个内联处理器。这就是我们使用 `.process(new Processor(){…})` 所做的。我们实现了一个内联处理器，该处理器移除了
    `PrefixerProcessor` 追加的前缀。
- en: Finally, we can see that we are back to the original message in the latest log
    endpoint (`.to("log:MyRoute")`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到在最新的日志端点（`.to("log:MyRoute")`）中我们又回到了原始的消息。
- en: The `MyRouteBuilder` class is the route builder. A route has to be embedded
    in the `CamelContext`. It's the purpose of our bundle Activator; the Activator
    creates the `CamelContext`, builds the route, and registers the route in this
    `CamelContext`. For convenience, we also register the `CamelContext` as an OSGi
    service (it allows us to see the `CamelContext` and the route using the `camel:*
    Karaf` commands).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyRouteBuilder` 类是路由构建器。一个路由必须嵌入到 `CamelContext` 中。这是我们的包激活器的目的；激活器创建 `CamelContext`，构建路由，并在该
    `CamelContext` 中注册路由。为了方便，我们还注册了 `CamelContext` 作为 OSGi 服务（它允许我们使用 `camel:* Karaf`
    命令查看 `CamelContext` 和路由）。'
- en: 'The `Activator` is a class implementing the `BundleActivator` interface (`org.osgi.framework.BundleActivator`):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activator` 是一个实现 `BundleActivator` 接口（`org.osgi.framework.BundleActivator`）的类：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the bundle starts, the `start()` method of the `Activator` is called by
    the OSGi framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当包启动时，OSGi 框架会调用 `Activator` 的 `start()` 方法。
- en: At startup, we create the `CamelContext` using `new DefaultCamelContext()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，我们使用 `new DefaultCamelContext()` 创建 `CamelContext`。
- en: We create and register our route in this `CamelContext` using `camelContext.addRoutes(new
    MyRouteBuilder())`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `camelContext.addRoutes(new MyRouteBuilder())` 在这个 `CamelContext` 中创建和注册我们的路由。
- en: For convenience, we register the `CamelContext` as an OSGi service using `bundleContext.registerService(CamelContext.class,
    camelContext, null)`. Thanks to this service registration, our `CamelContext`
    and route will be visible for the Camel:`*` commands that we have in the Apache
    Karaf OSGi container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们使用 `bundleContext.registerService(CamelContext.class, camelContext, null)`
    注册 `CamelContext` 作为 OSGi 服务。多亏了这项服务注册，我们的 `CamelContext` 和路由将对我们 Apache Karaf
    OSGi 容器中的 Camel:`*` 命令可见。
- en: Finally, we start the Camel Context (and the route) using `camelContext.start()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `camelContext.start()` 启动 Camel Context（以及路由）。
- en: On the other hand, when we stop the bundle, the OSGi framework will call the
    `stop()` method of the Activator.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们停止包时，OSGi 框架将调用激活器的 `stop()` 方法。
- en: In the `stop()` method, we unregister the Camel Context OSGi service (using
    `serviceRegistration.unregister()`) and we stop the Camel Context (using `camelContext.stop()`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `stop()` 方法中，我们注销 Camel Context OSGi 服务（使用 `serviceRegistration.unregister()`），并停止
    Camel Context（使用 `camelContext.stop()`）。
- en: Route using Camel Blueprint DSL
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Camel Blueprint DSL 的路由
- en: In the same bundle, we can create another Camel Context and design another route,
    but this time using the Camel Blueprint DSL (OSGi specific). When using the Camel
    Blueprint DSL, we don't have to write all the plumbing code as we do for the first
    Camel Context. The Camel Context is implicitly created by Camel, and we declare
    the route in the Camel Context using the XML description.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个包中，我们可以创建另一个 Camel 上下文并设计另一个路由，但这次使用 Camel Blueprint DSL（OSGi 特定）。当使用 Camel
    Blueprint DSL 时，我们不需要编写像第一个 Camel 上下文那样所有的管道代码。Camel 上下文由 Camel 隐式创建，我们使用 XML
    描述在 Camel 上下文中声明路由。
- en: 'In the `OSGI-INF/blueprint` folder of our bundle, we create `route.xml`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的包的 `OSGI-INF/blueprint` 文件夹中，我们创建 `route.xml`：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this Blueprint descriptor, we first create the `prefixerProcessor` bean.
    The Blueprint container will create the processor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Blueprint 描述符中，我们首先创建 `prefixerProcessor` bean。Blueprint 容器将创建处理器。
- en: The Camel Blueprint DSL provides the `<camelContext/>` element. Camel will create
    the Camel Context for us and register the route that we describe. The `<route/>`
    element allows us to describe the route.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Camel Blueprint DSL 提供了 `<camelContext/>` 元素。Camel 将为我们创建 Camel 上下文并注册我们描述的路由。`<route/>`
    元素允许我们描述路由。
- en: 'Basically, the route is very close to the previous one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，路由与上一个非常相似：
- en: It starts with a timer, creating an empty Exchange every 5 seconds.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从一个定时器开始，每 5 秒创建一个空的 Exchange。
- en: It sets the body to `Hello Chapter3`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将正文设置为 `Hello Chapter3`。
- en: It calls the `prefixerProcessor`. In this case, we use the reference to the
    registered bean. The `ref="prefixerProcessor"` corresponds to the `id="prefixerProcessor"`
    of the `PrefixerProcessor` bean.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `prefixerProcessor`。在这种情况下，我们使用已注册的 bean 的引用。`ref="prefixerProcessor"` 对应于
    `PrefixerProcessor` bean 的 `id="prefixerProcessor"`。
- en: We also call a log endpoint.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还调用一个日志端点。
- en: 'It''s important to understand that even if we use the same class, we have two
    different instances of `PrefixerProcessor`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，即使我们使用相同的类，我们也有两个不同的 `PrefixerProcessor` 实例：
- en: A first instance is created in the bundle `Activator` and used in the route
    described using the Camel Java DSL
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个实例在 `Activator` 包中创建，并用于使用 Camel Java DSL 描述的路由
- en: A second instance is created in the `blueprint` container and used in the route
    described using the Camel Blueprint DSL
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实例在 `blueprint` 容器中创建，并用于使用 Camel Blueprint DSL 描述的路由
- en: Building and deploying our bundle, we are now ready to build our bundle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署我们的包后，我们现在准备好构建我们的包。
- en: 'Using Maven, we just run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Maven，我们只需运行以下命令：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our bundle is now available in our local Maven repository (by default, in the
    `.m2/repository` folder of the `home` directory).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可执行包现在可在我们的本地 Maven 仓库中可用（默认情况下，位于 `home` 目录的 `.m2/repository` 文件夹中）。
- en: We are ready to deploy the bundle in the Karaf OSGi container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以部署 Karaf OSGi 容器中的包。
- en: After having started Karaf (using `bin/karaf` for instance, providing the Karaf
    shell console), we first have to install the Camel support. For this, we register
    the camel features repository and install the `camel-blueprint` feature.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Karaf（例如使用 `bin/karaf`，提供 Karaf 命令行控制台）后，我们首先必须安装 Camel 支持。为此，我们注册 camel
    特性仓库并安装 `camel-blueprint` 功能。
- en: The `camel-blueprint` feature provides support for Camel core (so the Camel
    Java DSL, and all core classes such as `CamelContext`, `Processor`, and so on),
    and Camel Blueprint DSL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`camel-blueprint` 功能为 Camel 核心（因此是 Camel Java DSL，以及所有核心类，如 `CamelContext`、`Processor`
    等）和 Camel Blueprint DSL 提供支持。'
- en: 'To register the Camel features repository, we use the Karaf `feature:repo-add`
    command specifying the Camel version we want to use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册 Camel 特性仓库，我们使用 Karaf 的 `feature:repo-add` 命令指定我们想要使用的 Camel 版本：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We install the `camel-blueprint` feature using the `feature:install` command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `feature:install` 命令安装 `camel-blueprint` 功能：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now ready to install and start our bundle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好安装和启动我们的包。
- en: 'For the installation, we use the `bundle:install` command with the Maven location
    defined in the `pom.xml`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安装，我们使用 `bundle:install` 命令与在 `pom.xml` 中定义的 Maven 位置：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start the bundle using the `bundle:start` command using the `Bundle ID`
    given by the previous command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `bundle:start` 命令并使用前一个命令给出的 `Bundle ID` 启动包：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The log messages shows that our routes are running (using the `log:display`
    command):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息显示我们的路由正在运行（使用 `log:display` 命令）：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Camel features also provide Karaf commands that we can use to see the running
    Camel Contexts and routes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 特性还提供了 Karaf 命令，我们可以使用这些命令查看正在运行的 Camel 上下文和路由。
- en: 'For instance, the `camel:context-list` command shows the available Camel Contexts,
    which are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`camel:context-list`命令显示了可用的Camel Contexts，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see the two Camel Contexts that we create in our bundle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在我们的bundle中创建的两个Camel Contexts。
- en: 'We can have details on each Camel Context using the `camel:context-info` command,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`camel:context-info`命令来获取每个Camel Context的详细信息，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that the `camel-1` context contains one route named `route1`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`camel-1`上下文包含一个名为`route1`的路由。
- en: Actually, `camel-1` is the Camel Context that we created in the Activator, and
    `route1` is the route using the Camel Java DSL. Here, we are able to see `CamelContext`,
    thanks to the OSGi service registration that we perform in the Activator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`camel-1`是我们之前在Activator中创建的Camel Context，而`route1`是使用Camel Java DSL的路由。在这里，我们能够看到`CamelContext`，这得益于我们在Activator中执行的服务注册。
- en: 'On the other hand, we have another Camel Context named `87-camel-4`, which
    is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们还有一个名为`87-camel-4`的另一个Camel Context，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this Camel Context (the one created by Camel as declared in the Blueprint
    descriptor), we can see `route2` corresponding to the route described using the
    Camel Blueprint DSL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Camel Context（由Camel在Blueprint描述符中声明创建的）中，我们可以看到使用Camel Blueprint DSL描述的`route2`。
- en: 'We can also obtain details about the routes using the `camel:route-info` command
    (the `camel:route-list` command displays the list of all routes for all Camel
    Contexts):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`camel:route-info`命令来获取路由的详细信息（`camel:route-list`命令显示所有Camel Contexts的所有路由列表）：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can take a look at the details for `route1` in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中查看`route1`的详细信息：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that the route has been executed 382 times without errors. We can
    also see a dump of the route with the two processors, coming from `MyRouteBuilder`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该路由已成功执行382次，没有错误。我们还可以看到来自`MyRouteBuilder`的两个处理器的路由转储。
- en: 'We can also see the details of `route2` corresponding to the routing described
    using the Camel Blueprint DSL:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到与使用Camel Blueprint DSL描述的路由对应的`route2`的详细信息：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Processor is one of the most important components of Camel. It's like a Swiss
    knife. You can use processor to implement message translation and transformation,
    and any kind of EIPs. All Camel EIPs are implemented using processor to implement
    the Camel component using `ProcessorEndpoint`. We will see later that processors
    are also useful for error handling or for unit tests. To make it even easier,
    you can also use existing beans, acting as processors. Camel can directly use
    your existing beans thanks to an extended bean support, as we will see in the
    next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是Camel中最重要组件之一。它就像瑞士军刀。您可以使用处理器来实现消息翻译和转换，以及任何类型的EIPs。所有Camel EIPs都是通过使用`ProcessorEndpoint`实现Camel组件的处理器来实现的。我们稍后将会看到，处理器在错误处理或单元测试中也非常有用。为了使其更加简单，您还可以使用现有的bean作为处理器。由于扩展了bean支持，Camel可以直接使用您现有的bean，这一点我们将在下一章中看到。
