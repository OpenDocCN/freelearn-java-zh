- en: Functional Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: Programming largely deals with data manipulation. Different styles of programming will
    treat data structures, and data itself, differently. For example, imperative programming
    treats data as mutable information stored in memory. We will see how the treatment
    of functional programming differs from that of imperative programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程在很大程度上处理数据操作。不同的编程风格会以不同的方式处理数据结构和数据本身。例如，命令式编程将数据视为存储在内存中的可变信息。我们将看到函数式编程的处理方式与命令式编程有何不同。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Collections framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合框架
- en: The algebraic approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数方法
- en: Effect types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果类型
- en: Data structures in different programming languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同编程语言中的数据结构
- en: Collections framework
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合框架
- en: When discussing data structures, it is only natural to start with collections.
    Collections are data structures that abstract away multiplicity. This means that
    whenever you have more than one item of a particular kind, and you want to run
    a number of operations on this data, you will need a proper abstraction—an abstraction
    that will establish the rules of the game you play when you encounter multiplicity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论数据结构时，自然要从集合开始。集合是一种抽象掉多重性的数据结构。这意味着，无论何时你有多于一个特定种类的项目，并且想要对这个数据进行一系列操作，你都需要一个适当的抽象——一个在你遇到多重性时建立游戏规则的抽象。
- en: 'It transpires that you will need to deal with abstraction of this nature in
    nearly every programming project. When you are dealing with strings, you frequently
    need to represent them as a collection of characters. Whenever you have a database
    application, and you have some queries in relation to this database, you need
    to present multiple results of these queries as collections. Whenever you are
    dealing with a text file, you may want to represent it as a list of lines. This
    happens rather frequently, for example, when dealing with configuration files.
    We specify our configuration entries as strings on separate lines. For example, the
    following is how we may represent a server connection configuration:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，你几乎在每一个编程项目中都需要处理这种类型的抽象。当你处理字符串时，你经常需要将它们表示为字符的集合。每当你有数据库应用程序，并且你对这个数据库有一些查询时，你需要将这些查询的多个结果作为集合来展示。每当你在处理文本文件时，你可能想要将其表示为行列表。这种情况相当常见，例如，处理配置文件时。我们将在单独的行上指定我们的配置条目。例如，以下是我们可能表示服务器连接配置的方式：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Or, for example, you may want to communicate data with a web API. Most modern
    web APIs communicate data in the form of JSON or XML. These are structured ways
    of representing data and, if you observe them closely, you will notice that they
    follow a pattern; for example, an XML file is composed of a tree of multiple nodes,
    and a JSON object may contain more than one entry.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，例如，你可能想要通过Web API进行数据通信。大多数现代Web API以JSON或XML的形式通信数据。这些都是表示数据的有结构方式，如果你仔细观察，你会注意到它们遵循一个模式；例如，一个XML文件由多个节点组成的树构成，一个JSON对象可能包含多个条目。
- en: So, whenever you are working on a programming project, it is very likely that
    you will need to deal with some kind of abstraction over multiplicity. You require
    a collections framework. Because collections are so ubiquitous, it is only natural
    that modern programming languages include a collection framework in their core
    library. This is why looking at a language's collections framework is an easy
    way to see the philosophy of the language and its approach to programming in general.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你在进行编程项目时，你很可能都需要处理某种多重性的抽象。你需要一个集合框架。因为集合如此普遍，现代编程语言在它们的内核库中包含一个集合框架是很自然的。这就是为什么查看一个语言的集合框架是了解该语言哲学及其一般编程方法的一种简单方式。
- en: In this section, we will compare the collection frameworks of Java and Scala.
    Java represents a traditional, imperative approach to programming, and, hence,
    its collection framework also reflects this approach. On the other hand, Scala
    represents a functional, declarative approach to programming. Its collection framework
    is built and structured according to the philosophy of functional and declarative
    programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较Java和Scala的集合框架。Java代表了一种传统的、命令式的编程方法，因此其集合框架也反映了这种方法。另一方面，Scala代表了一种函数式、声明式的编程方法。其集合框架是根据函数式和声明式编程的哲学构建和组织的。
- en: Imperative collections
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式集合
- en: Let's have a look at how collections are understood within the framework of
    an imperative programming language, while also looking at Java's abstraction of
    a list. Its API documentation is available at [https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html.).
    This interface only has a limited number of methods defined. The first thing that
    we need to pay attention to here is mutability. Immediately, we see methods such
    as `add` and `remove`. This implies that this interface is supposed to be implemented
    by a mutable collection that is supposed to implement the operations that add
    or remove data from it. You should be aware that methods can throw an `UnsupportedOperationException`,
    which means that certain collections may implement this interface; however, they
    will not implement these two operations. Later in the book, we will see that functional
    programming does not welcome exceptions of this kind as they are a type of side
    effect and here, it is especially obvious why. One of the essential principles
    of object-oriented programming is polymorphism, which means that you can place
    an interface on top of a class and, from there, you are able to interact with
    this class according to this interface, without caring about the internal implementation.
    An interface is supposed to be a protocol of interaction with an object; it is
    supposed to specify which behavior it supports, and throwing an exception if a
    behavior is not supported is a rather clumsy move on the part of Java, since you
    need to bear in mind that certain behavior is not supported, even though the interface
    declares that it is. This further taxes the programmer's mind and, hence, it can
    lead to bugs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在命令式编程语言的框架内，集合是如何被理解的，同时看看Java对列表的抽象。它的API文档可在[https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)找到。这个接口只定义了有限数量的方法。在这里，我们需要注意的第一件事是可变性。立即，我们看到像`add`和`remove`这样的方法。这表明这个接口应该被一个可变集合实现，该集合应该实现添加或从其中移除数据的功能。你应该知道，方法可能会抛出`UnsupportedOperationException`，这意味着某些集合可能会实现这个接口；然而，它们将不会实现这两个操作。在本书的后面部分，我们将看到函数式编程并不欢迎这类异常，因为它们是一种副作用，在这里，这一点尤其明显。面向对象编程的一个基本原则是多态性，这意味着你可以在一个类之上放置一个接口，然后，你就可以根据这个接口与这个类进行交互，而不必关心其内部实现。接口应该是一个与对象交互的协议；它应该指定它支持哪些行为，如果某个行为不受支持，抛出异常是Java的一个相当笨拙的做法，因为即使接口声明了支持，你也需要记住某些行为是不支持的。这进一步增加了程序员的心理负担，因此，它可能导致错误。
- en: Another peculiarity we should observe is that other methods defined here are
    quite low level. You have the ability to add to the collection and to remove from
    the collection. It is assumed that whatever you need to do with the collection,
    you will be able to do so with the help of these and other low-level methods that
    the interface provides. This is realized by writing an imperative algorithm that
    specifies how exactly to perform a necessary operation given the low-level primitives
    provided by the language. This, in turn, means that you must be skilled with algorithms
    to write effective Java programs, because the use of algorithms is the only option
    open to you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意的另一个特性是，这里定义的其他方法相当低级。你有能力向集合中添加内容，也能从集合中移除内容。假设你需要对集合进行任何操作，你都将能够借助这些以及其他接口提供的低级方法来完成。这是通过编写一个命令式算法来实现的，该算法指定了如何使用语言提供的低级原语来执行必要的操作。这反过来意味着，你必须精通算法才能编写有效的Java程序，因为算法的使用是你唯一的选择。
- en: In fact, it has long been a tradition in computer science and programming to
    focus extensively on algorithms. The data has been perceived as some kind of mutable
    information written in a certain medium, and the task of the programmer is to
    specify a sequence of steps to modify this data as per requirements. Hence, one
    of the first things people learn in computer science is sorting algorithms such
    as Bubble Sort.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在计算机科学和编程中，长期以来一直有一个传统，那就是高度重视算法。数据被看作是某种可变信息，以某种特定媒介书写。程序员的任务是指定一系列步骤来根据需求修改这些数据。因此，在计算机科学中，人们首先学习的就是像冒泡排序这样的排序算法。
- en: Algorithms are certainly necessary. Under the hood of any computer program,
    algorithms are precisely what do the job. However, they are not the best way for
    humans to read, understand, and write programs. They are not the best way for
    humans to design programs since, due to their counter-intuitiveness, they can
    be error-prone.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 算法当然是必要的。在任何计算机程序的背后，算法正是完成工作的东西。然而，它们并不是人类阅读、理解和编写程序的最佳方式。由于它们的反直觉性，它们可能会出错。
- en: Now, let's have a look at functional collections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看函数式集合。
- en: Functional collections
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式集合
- en: It's quite a different picture in functional languages. Let's have a look at
    the same abstraction, the List, in Scala's library. Its API documentation is available
    at [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html).
    It contains many more methods than can be found in Java's List. In contrast to
    the Java List interface, Scala's List abstraction is immutable. This means that
    once you have created a list, you are not able to modify it. All the modifications
    to the list can be implemented by just creating a modified copy of the list. This
    concept is referred to as structural sharing. This means that the objects that
    are members of the list are not copied, just that the structure of the list is
    recreated. Therefore, you do not need to worry about memory leaks because only
    the structure is newly created. The objects that are the members of the list are
    not recreated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，情况完全不同。让我们来看看 Scala 库中的相同抽象，即 List。它的 API 文档可在 [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html)
    找到。它包含比 Java 的 List 更多的方法。与 Java 的 List 接口相比，Scala 的 List 抽象是不可变的。这意味着一旦你创建了一个列表，你就无法修改它。所有对列表的修改都可以通过仅创建列表的修改副本来实现。这个概念被称为结构共享。这意味着列表的成员对象没有被复制，只是列表的结构被重新创建。因此，你不必担心内存泄漏，因为只有结构是新生成的。列表的成员对象不会被重新创建。
- en: There is also an abundance of declarative methods – high-level primitives, for
    example, `filter`, `map`, and `flatMap`. In contrast to Java, these methods specify
    fairly high-level operations. In the previous chapter, we saw how it can be pretty
    tedious to define a filter operation in Java. In contrast, in Scala, it is sufficient
    to specify the name of the operation that you need to perform, and you don't need
    to worry about how this operation is implemented. This seems like the right moment
    to draw parallels with the `goto` statement. It is a remarkable property of modern
    programming languages; the programs that you can express with `goto` can also
    be expressed with the help of several control structures. In the same way, all
    collection programs can be expressed using around a dozen declarative high-level
    methods. You don't need to specify how to create a loop with `goto` every time
    you need a loop. Similarly, it is not necessary to specify collection operations
    such as `filter` if they can be named and implemented in a language's core library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也存在大量的声明式方法——例如，`filter`、`map` 和 `flatMap` 的高级原语。与 Java 相比，这些方法指定了相当高级的操作。在上一章中，我们看到了在
    Java 中定义过滤操作是多么的繁琐。相比之下，在 Scala 中，只需指定需要执行的操作的名称，你就不必担心这个操作是如何实现的。这似乎是时候将 `goto`
    语句与之进行比较了。这是现代编程语言的显著特性之一；你可以用 `goto` 表达的程序也可以用几个控制结构来表达。同样，所有集合程序都可以使用大约十几个声明式高级方法来表达。你不必每次需要循环时都指定如何使用
    `goto`。同样，如果可以在语言的核心库中命名和实现，就不必指定如 `filter` 这样的集合操作。
- en: While Java and imperative languages focus on algorithmic reasoning, functional
    languages, such as Scala, focus on algebraic reasoning. This means they view data
    transformations as algebraic expressions. Data can be viewed as operands of some
    algebra, and it can be combined with other data and transformed to get new data
    with the help of high-level operators. Hence, programs are no longer defined algorithmically,
    but in terms of mathematical expressions; expressions that compute some value
    based on their input.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 和命令式语言侧重于算法推理，但函数式语言，例如 Scala，侧重于代数推理。这意味着它们将数据转换视为代数表达式。数据可以被视为某些代数的操作数，并且可以通过高级运算符与其他数据结合并转换，以获得新的数据。因此，程序不再是算法定义的，而是用数学表达式来定义的；这些表达式根据它们的输入计算某些值。
- en: When programming in a declarative language, it is no longer necessary to be
    an expert in algorithms, as was the case with imperative languages such as Java.
    This is the case because all the algorithms that you may need are already implemented
    in the language's core library. Of course, when you call a declarative method,
    such as `filter`, on a Scala collection, an algorithm is executed under the hood.
    The beauty of this approach is that you do not need to be aware of this at all.
    You're provided with a high-level building block, and you need to express your
    program in terms of these building blocks. You do not need to worry about how
    the blocks are created.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在声明式语言中编程时，你不再需要像在Java这样的命令式语言中那样成为算法专家。这是因为你可能需要的所有算法都已经实现在了语言的核心库中。当然，当你对一个Scala集合调用如`filter`这样的声明式方法时，底层会执行一个算法。这种方法的优点在于你根本不需要意识到这一点。你得到了一个高级构建块，你需要用这些构建块来表达你的程序。你不需要担心这些块是如何创建的。
- en: There are a number of benefits compared to the imperative approach. You do not
    need to deal with algorithms that are hard to read and prone to bugs. Everything
    you need is already implemented on a language level. This means that the implementation
    is used in a number of projects based on that language. Therefore, you can be
    sure that what you are using is tested extensively, thereby greatly reducing your
    chances of writing bug-prone code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式方法相比，有诸多好处。你无需处理难以阅读且容易出错的算法。你所需要的一切已经在语言层面上实现。这意味着该语言的多个项目都会使用这种实现。因此，你可以确信你所使用的是经过广泛测试的，从而大大降低了你编写出有缺陷代码的可能性。
- en: Instead of focusing on low-level operations, you can focus on describing your
    program in high-level terms. Consider the example of filtering that we saw in
    [Chapter 1](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml), The *Declarative Programming
    Style*. It is much easier to read the declarative code because you see the word
    `filter` at once, and this single word means an entire operation. In the case
    of Java, we have a loop and manipulation over two collections to get the same
    job done, and it is not at all obvious what the code stands for. This is why declarative
    programs are much better to read for humans.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与关注底层操作不同，你可以专注于用高级术语描述你的程序。考虑我们在[第1章](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml)中看到的过滤示例，*声明式编程风格*。阅读声明式代码要容易得多，因为你一眼就能看到“filter”这个词，而这个单词代表了一个完整的操作。在Java的情况下，我们需要一个循环和两个集合的操作来完成同样的任务，代码的含义并不明显。这就是为什么声明式程序对人类来说更容易阅读。
- en: Let's have a look at another example – mapping. Mapping is a process of transforming
    a collection element-wise. This means that you take a collection as an input and
    generate another collection by transforming every element of the original collection
    in some way. For example, if you have a list of integers, you can map this list
    by a function that squares each individual number. If you have the numbers `1`,
    `2`, and `3` in the collection, you will get a new collection with the numbers
    `1`, `4`, and `9`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子——映射。映射是一个逐个转换集合元素的过程。这意味着你接受一个集合作为输入，通过以某种方式转换原始集合的每个元素来生成另一个集合。例如，如果你有一个整数列表，你可以通过一个函数将这个列表映射为每个数字平方。如果你在集合中有数字`1`、`2`和`3`，你将得到一个新的集合，包含数字`1`、`4`和`9`。
- en: 'Let''s do this operation in Java in an imperative way. First, let''s define
    the collections we are going to map:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以命令式方式在Java中执行这个操作。首先，让我们定义我们将要映射的集合：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will create a new collection we are going to write our results to.
    Then, we will iterate over every element of the original collection, we will apply
    the required function to these, and then add them to the result collection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的集合，我们将把结果写入这个集合。然后，我们将遍历原始集合的每个元素，对这些元素应用所需的函数，然后将它们添加到结果集合中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s look at how this is done with Scala:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这是如何用Scala完成的：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Scala, we simply call the built-in primitive method `map` on the collection
    we need to map. Here, we can also see the role that is played by the lambda functions
    here. We are able to specify that mapping function as a lambda function, as an
    argument to the `map` method. In Java, lambda functions are only supported starting
    from version 8, hence, this style would have been impossible in that language
    until recently. The general pattern here is that we often need to abstract away
    an entire computation. We need to embed one computation in another. This can be
    done with a lambda function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，我们只需在需要映射的集合上调用内置的原始方法 `map`。在这里，我们也可以看到 lambda 函数在这里扮演的角色。我们可以将映射函数指定为
    lambda 函数，作为 `map` 方法的参数。在 Java 中，lambda 函数从版本 8 开始才被支持，因此，这种风格在最近之前在该语言中是不可能的。这里的通用模式是我们通常需要抽象出整个计算。我们需要将一个计算嵌入到另一个计算中。这可以通过
    lambda 函数来实现。
- en: Algebraic approach
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数方法
- en: 'Functional and declarative programming can also be very well conceptualized
    as an algebraic style.  For our purposes, an algebraic approach can be regarded
    as a certain language of mathematical expressions—a language that consists of
    two major elements: operators and operands. Operands can be taken to mean data,
    the information that you want to manipulate, while operators can be taken to mean
    their behavior as an how this data is utilized.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式和声明式编程也可以很好地理解为代数风格。就我们的目的而言，代数方法可以被视为一种数学表达式的语言——一种由两个主要元素组成的语言：运算符和操作数。操作数可以理解为数据，是你想要操作的信息，而运算符可以理解为它们的行为以及如何利用这些数据。
- en: Consider the expression `1 + 2`. Here, numbers `1` and `2` are operands. They
    represent some numeric data. The `+` symbol is an operator that binds them together.
    It has certain semantics associated with it, that of adding one number to another.
    But it is important to remember that the symbolic structure of the expression
    and its semantics are two separate things. You can take the expression as specified
    previously and assign a different meaning to the numbers `1` and `*2*` and to
    the symbol `+`, and the semantics of the expression will be entirely different.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式 `1 + 2`。在这里，数字 `1` 和 `2` 是操作数。它们代表一些数值数据。`+` 符号是一个将它们结合在一起的运算符。它具有与之相关的某些语义，即把一个数加到另一个数上。但重要的是要记住，表达式的符号结构和它的语义是两回事。你可以按照前面指定的方式取这个表达式，并给数字
    `1` 和 `*2*` 以及符号 `+` 赋予不同的意义，这样表达式的语义就会完全不同。
- en: 'This line of reasoning can be applied to declarative programs. For example,
    consider the following snippet in Scala:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理方法可以应用于声明式程序。例如，考虑以下 Scala 中的片段：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It can be rewritten with the Scala infix notation as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Scala 的中缀表示法重写如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is because Scala supports a syntactic sugar that is allowed to call Scala
    methods as infix operators. The point here is that you can read the `map` function
    as an operator. The operator that binds its operands together specifies what to
    do with them. The first operand is the collection we are mapping, while the second
    operand is the lambda function you are mapping it with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Scala 支持一种语法糖，允许以中缀运算符的方式调用 Scala 方法。这里的要点是你可以把 `map` 函数读作一个运算符。将它的操作数结合在一起的运算符指定了要对它们做什么。第一个操作数是我们映射的集合，而第二个操作数是你用来映射它的
    lambda 函数。
- en: The behavior of the program is expressed here as operators that bind their operands
    together, while the execution of the program is taken to mean a computation of
    some value, and not an execution of an algorithm.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的行为在这里用将它们的操作数结合在一起的运算符来表示，而程序的执行则被理解为计算某个值，而不是算法的执行。
- en: 'One advantage here is the absence of the notion of change. In algebra, time
    is effectively removed from the equation. Consider the implementation of map functionality
    in Java. It is algorithmic, which means that you explain about it in time, as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个优点是缺乏变化的概念。在代数中，时间实际上被从方程中移除了。考虑 Java 中 map 功能的实现。它是算法性的，这意味着你可以在时间上解释它，如下所示：
- en: Take the first element of the collection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取集合的第一个元素。
- en: Then, apply a function to this element.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对此元素应用一个函数。
- en: Then, insert it into the resulting collection.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其插入到结果集合中。
- en: Repeat the same process with the second element, and then the third, and so
    on.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用相同的过程处理第二个元素，然后是第三个，依此类推。
- en: Notice the presence of time in the preceding description. You clearly have a
    notion of what happens first and what happens after that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前述描述中时间的存在。你清楚地有一个关于先发生什么和之后发生什么的观念。
- en: Let's have a look at the Scala implementation of that functionality. In Scala,
    you specify what you need the program to do as an algebraic expression, as a binding
    of two operators, the collection and the lambda function, by the operator `map`.
    This expression no longer has a time dimension associated with it. You simply
    write down a mathematical expression and leave it to your language to assign some
    semantics to it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看该功能的 Scala 实现。在 Scala 中，你通过算术表达式指定程序需要做什么，作为两个操作符的绑定，即集合和 lambda 函数，通过
    `map` 操作符。这个表达式不再与它相关联的时间维度。你只需写下一个数学表达式，然后让你的语言为其分配一些语义。
- en: Be aware that the `map` function in Scala is implemented with the help of algorithms
    and that it probably works just like it does in Java. However, for all intents
    and purposes, you can forget about this in most of the programs you will be writing.
    You can think of this program as a different paradigm, a paradigm of symbolically
    expressing what you want to do.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Scala 中的 `map` 函数是通过算法实现的，并且它可能的工作方式与 Java 中的一样。然而，从所有目的和用途来看，在大多数你将要编写的程序中，你可以忘记这一点。你可以将这个程序视为一种不同的范式，一种象征性地表达你想要做什么的范式。
- en: This paradigm separates the semantics from the structure of your program. When
    I say structure, I mean the symbols involved in describing the program; the symbols
    as in the collection you are mapping, the lambda function you are mapping it by,
    and the map as an operator. All of these entities are referred to with the help
    of symbols you write. By semantics, I mean the actions performed by the computer
    when it processes this expression, how it understands this expression, and how
    it runs this expression.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种范式将语义与你的程序结构分开。当我提到结构时，我指的是描述程序所涉及的符号；就像你在映射的集合中的符号，你通过映射的 lambda 函数，以及作为操作符的
    map。所有这些实体都是通过你写的符号来引用的。至于语义，我指的是计算机在处理这个表达式时执行的动作，它是如何理解这个表达式的，以及它是如何运行这个表达式的。
- en: Thinking about programs this way allows you to treat them as mathematical expressions
    and work with them as with data structures—the symbolic structures of the expressions.
    This is in contrast to the algorithmic approach, which is so popular in traditional
    imperative programming, as we have seen with the example involving Java.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考程序允许你将它们视为数学表达式，并以与数据结构相同的方式处理它们——表达式的符号结构。这与传统的命令式编程中流行的算法方法形成对比，正如我们通过涉及
    Java 的例子所看到的。
- en: The advantage here is that it is easier to use symbolic logic to explain programs
    that are expressed as mathematical expressions and not algorithms. Second, in
    a proper declarative program, there is no dimension of time, which removes a whole
    class of bugs. Of course, you should remember all of this is an abstraction. You
    can fairly say that it is an illusion. Under the hood, algorithms still matter;
    time still exists. However, in the declarative style, you leverage the principle
    of abstraction. You abstract away the time and the algorithms. This is comparable
    to how, when your program operates with a high-level language such as Java, you
    do not need to think about the byte code or the low-level processor instructions
    it compiles to. This low-level code still exists, it still matters, but, to all
    intents and purposes, you can forget about it. The same thing happens with algorithms
    being abstracted away with the declarative and algebraic styles.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处是，使用符号逻辑来解释以数学表达式而不是算法表达的程序更容易。其次，在适当的声明性程序中，没有时间维度，这消除了整个类别的错误。当然，你应该记住所有这些都是一种抽象。你可以说这几乎是一种错觉。在底层，算法仍然很重要；时间仍然存在。然而，在声明性风格中，你利用了抽象的原则。你抽象出时间和算法。这类似于当你用像
    Java 这样的高级语言编写程序时，你不需要考虑编译成字节码或低级处理器指令。这种低级代码仍然存在，它仍然很重要，但就所有目的和用途而言，你可以忘记它。同样的事情发生在声明性和代数风格中抽象出算法的情况下。
- en: Treating programs as mathematical expressions is facilitated by techniques that
    abstract away side effects. These rely on data structures specific to purely functional
    programming. Let's now have look at such data structures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序视为数学表达式是通过抽象掉副作用的技术来实现的。这些技术依赖于纯函数式编程中特定的数据结构。现在让我们看看这样的数据结构。
- en: Effect types
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果类型
- en: Previously, we discussed collections as an example of imperative and declarative
    data structures. However, the functional and declarative styles also contain some
    data structures specific to them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们以集合为例讨论了命令式和声明式数据结构。然而，函数式和声明式风格也包含一些特定的数据结构。
- en: Collections abstract away multiplicity. Functional languages such as Scala,
    Haskell, and others bring in some other data structures that abstract away side
    effects. We can refer to them as effect types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 集合抽象了多重性。像 Scala、Haskell 这样的函数式语言引入了一些其他数据结构，它们抽象了副作用。我们可以将它们称为效果类型。
- en: We have argued that pure algebraic and declarative approaches remove time from
    the equation. This is advantageous because time taxes the programmer's mind. Functional
    programming takes this idea further by removing side effects from your programs.
    They also burden the mind as you also need to take them into account and handle
    them properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经论证了纯代数和声明式方法从等式中移除了时间。这是有利的，因为时间会消耗程序员的思维。函数式编程通过从你的程序中移除副作用来进一步发展这个想法。它们也给思维带来了负担，因为你也需要考虑它们并正确处理它们。
- en: Previously, we discussed an example of how a Java list interface throws exceptions.
    We argued that it is pretty bad because it increases the mental load on a programmer's
    mind, since they need to constantly keep in mind that there are cases in which
    an exception can be thrown and they should account for these cases. In functional
    programming, this is not acceptable. Functional programming aspires to remove
    all side effects from the equation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了一个 Java 列表接口抛出异常的例子。我们争论说这很糟糕，因为它增加了程序员的认知负担，因为他们需要不断记住可能会抛出异常的情况，并且应该考虑到这些情况。在函数式编程中，这是不可接受的。函数式编程追求从等式中消除所有副作用。
- en: We will see in detail later in the book how this is done but, for now, let's
    have a look at the `Try` structure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面详细讨论如何做到这一点，但现在，让我们看看 `Try` 结构。
- en: Try
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Try
- en: The `Try` data structure is present in one form or another in many programming
    languages. It may contain one of two values. One possibility is an arbitrary type
    of value `A`, while the second is an exception. This data structure can be returned
    as the result of a computation that can result in an error. This way, you no longer
    need to throw an exception. You can just return `Try[A]` when your method may
    result in an error. In Scala, the square bracket after the type name stands for
    type parameters, so `Try[A]` means the type `Try` with the type parameter `A`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try` 数据结构以某种形式存在于许多编程语言中。它可能包含两个值之一。一种可能性是任意类型的值 `A`，而另一种是异常。这种数据结构可以作为可能产生错误的计算的结果返回。这样，你就不需要再抛出异常了。当你的方法可能产生错误时，你只需返回
    `Try[A]`。在 Scala 中，类型名称后面的方括号表示类型参数，因此 `Try[A]` 表示具有类型参数 `A` 的 `Try` 类型。'
- en: 'For instance, consider an example where we have a function that divides one
    number by another. However, in the event that the second number is zero, we throw
    an exception:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个函数，它将一个数字除以另一个数字。然而，如果第二个数字为零，我们会抛出异常：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we call the method, in certain cases it may result in an exception – a
    side effect we may not be aware of or have forgotten:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用方法时，在某些情况下它可能导致异常——这是我们可能没有意识到或忘记的副作用：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The program will crash at this point. However, if we wrap it in `Try`, we can
    prevent the program from crashing:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将在这一点崩溃。然而，如果我们用 `Try` 包装它，我们可以防止程序崩溃：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because the return type clearly specifies the possibility of an error, this
    possibility no longer needs to be kept in mind. Since an error is now represented
    as a data structure, it does not disrupt the program when it happens. Here, we
    can see a representation of phenomena as data. Representing phenomena as data
    is called **reification**, and we will see later in the book how important this
    concept is in pure functional programming.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为返回类型清楚地指定了错误的可能性，所以不再需要记住这一点。由于错误现在表示为数据结构，它不会在发生时破坏程序。在这里，我们可以看到将现象表示为数据。将现象表示为数据称为
    **具体化**，我们将在本书的后面看到这个概念在纯函数式编程中的重要性。
- en: Option
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option
- en: Another example of a data structure that is characteristic of functional languages
    is an `Option`. An `Option` can either contain a value or be empty. You can think
    of it as an abstraction of the notion of the null pointer in Java or C++. The
    advantage here is that the programmer no longer needs to remember that some methods
    return a null. The methods that may, or may not, result in a value will return
    an `Option[A]` to signify this possibility, just as in the case of `Try`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性语言中具有代表性的数据结构示例之一是`Option`。`Option`可以包含一个值或者为空。你可以将其视为Java或C++中空指针概念的抽象。这里的优势是程序员不再需要记住某些方法返回null。可能或可能不返回值的方法将返回`Option[A]`来表示这种可能性，就像在`Try`的情况下一样。
- en: 'For example, consider a method that returns the name of the user by their ID.
    Some IDs won''t map to a user. Hence, we can model the scenario where we can''t
    return a user that does not exist as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个通过ID返回用户名字的方法。有些ID不会映射到用户。因此，我们可以模拟以下场景：我们无法返回一个不存在的用户。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That is, if the user ID is `1`, `2` or `3`, we surmise that the user is present
    in the database, otherwise they are not. We explicitly include the information
    about whether the user is present as the `Option` type. That is, we don't just
    return the user's name, but also the information about whether they are present
    or not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 即，如果用户ID是`1`、`2`或`3`，我们推测该用户存在于数据库中，否则他们不存在。我们明确地将用户是否存在的信息作为`Option`类型包含在内。也就是说，我们不仅返回用户的名字，还返回他们是否存在的信息。
- en: 'The advantage here is that you won''t be able to access the user''s name without
    first checking whether they were found or not:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势是，你无法在不检查他们是否被找到的情况下访问用户的名字：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the result of `getUserName`is not a raw `String` but a `String `wrapped
    in an `Option`. So, we first analyze the `Option` with the pattern matching statement
    before obtaining the result.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getUserName`的结果不是一个原始的`String`，而是一个被`Option`包裹的`String`。因此，我们在获取结果之前，首先使用模式匹配语句分析`Option`。
- en: 'The preceding example outputs `User-1` to the console. However, this example
    outputs `User not found`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将`User-1`输出到控制台。然而，这个例子输出`User not found`：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Data structures in different programming languages
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同编程语言中的数据结构
- en: From the preceding discussion, you may conclude that there is a substantial
    difference between a functional and comparative approach to programming. While
    imperative programming is focused on algorithms, declarative programming is focused
    on the phenomena produced by these algorithms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的讨论中，你可能得出结论，函数式编程和比较式编程之间存在实质性的差异。虽然命令式编程关注算法，但声明式编程关注这些算法产生的现象。
- en: Imperative programming allows you to produce phenomena with the help of algorithms.
    Declarative programming names the phenomena you may need and then allows you to
    call them by name. This abstracts away all the details of the inner workings of
    the phenomena.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程允许你通过算法产生现象。声明式编程命名了你可能需要的现象，然后允许你通过名称调用它们。这抽象掉了现象内部工作细节的所有细节。
- en: This is reflected in the separation between the approaches to data structures
    in different languages. Imperative programming languages, such as C++ or Java,
    will have their data structures, specifically, collections, implemented in a low-level
    manner. Typically, they will be mutable and will have some very basic primitive
    methods defined therein. Whatever you want to express, you will need to express
    it algorithmically with the help of these primitives.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这在不同语言的数据结构方法中得到了体现。命令式编程语言，如C++或Java，将具有它们自己的数据结构，特别是集合，以低级方式实现。通常，它们将是可变的，并在其中定义一些非常基本的原始方法。无论你想表达什么，你都需要借助这些原始方法以算法的方式表达出来。
- en: Functional programming languages, such as Scala or Haskell, will usually have
    immutable data structures. They focus on the phenomena and the high-level behavior
    you need to get things done. Examples of high-level behavior include mapping values
    of a certain type onto values of another type, and filtering certain values out
    of a collection of values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言，如Scala或Haskell，通常会有不可变的数据结构。它们关注现象和完成工作所需的高级行为。高级行为示例包括将某种类型的值映射到另一种类型的值，以及从值集合中过滤出某些值。
- en: In general, it is much easier to program with purely functional and declarative
    programming collections. They provide you with lots of building blocks with which
    to build your programs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用纯函数式和声明式编程集合进行编程要容易得多。它们为你提供了大量的构建块，用于构建你的程序。
- en: However, in certain circumstances, it may be desirable for you to use imperative
    data structures. Lower-level programming styles may be desirable if you want to
    craft your algorithms instead of relying on off-the-shelf implementations. The
    circumstances in question may be high-performance operations, for example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能希望使用命令式数据结构。如果你想要自己设计算法而不是依赖现成的实现，那么低级编程风格可能是可取的。所讨论的情况可能包括高性能操作，例如。
- en: In the gaming industry, if you are designing a performance-demanding game, it
    may be possible in certain sections of the game that you will need to write your
    operations yourself in order to meet performance requirements. Also, it is possible
    that you may need to employ such low-level approaches in the case of micro-controller
    programming or situations where you have limited computational resources and you
    need to take full advantage of what you have.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，如果你正在设计一个性能要求高的游戏，那么在游戏的某些部分，你可能需要自己编写操作以满足性能要求。此外，在微控制器编程或计算资源有限且需要充分利用现有资源的情况下，你可能需要采用这样的低级方法。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we had a look at how different programming styles define data
    structures and their approach to building programs using these data structures.
    We have seen how imperative programming relies heavily on algorithms and low-level
    operations. You have learned about basic mutable data structures and basic operations
    to mutate the data structures, as well as how to compose algorithms in your programming
    language of choice with the help of these data structures.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了不同的编程风格如何定义数据结构以及它们使用这些数据结构构建程序的方法。我们看到了命令式编程如何高度依赖算法和底层操作。你已经了解了基本可变数据结构和用于修改数据结构的基本操作，以及如何借助这些数据结构在你的编程语言中选择性地组合算法。
- en: In contrast, in the declarative style, the focus shifts from algorithms to mathematical
    expressions. The collections data structures are usually immutable. You have a
    lot of high-level operations defined on these data structures. You use these operations
    in order to express the program, not with algorithms, but as a set of algebraic
    expressions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在声明式风格中，焦点从算法转移到数学表达式。集合数据结构通常是不可变的。在这些数据结构上定义了许多高级操作。你使用这些操作来表达程序，而不是使用算法，而是作为一组代数表达式。
- en: Collections are one of the main aspects of almost any program. Hence, most of
    the modern programming languages support them out of the box, and, looking at
    the collections framework, it is possible to say what approach and philosophy
    that programming language follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 集合几乎是任何程序的主要方面之一。因此，大多数现代编程语言都默认支持它们，并且从集合框架来看，可以说出该编程语言遵循的方法和哲学。
- en: In addition to collections, there are other data structures that are specific
    to functional programming. These data structures will be covered in detail in
    the later chapters of this book. For now, it is worth observing that data structures
    such as `Try` or `Option` are needed to abstract away side effects that may occur
    in your program.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合之外，还有一些特定于函数式编程的数据结构。这些数据结构将在本书的后续章节中详细讨论。目前，值得注意的是，例如`Try`或`Option`这样的数据结构是必要的，以抽象出程序中可能发生的副作用。
- en: Some of these functional programming-specific data structures aim at bringing
    side effects into the purely functional paradigm. With these structures, you can
    work with side effects while maintaining referential transparency. In the next
    chapter, we will have a look at the problem of side effects in details.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些函数式编程特定的数据结构旨在将副作用引入纯函数式范式。使用这些结构，你可以在保持引用透明性的同时处理副作用。在下一章中，我们将详细探讨副作用的问题。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the general approach you take when writing an imperative collections-based
    application?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编写一个基于命令式集合的应用程序时，你通常采取什么通用方法？
- en: What is the general approach you take when writing a functional collections-based
    application?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编写一个基于功能集合的应用程序时，你通常采取什么通用方法？
- en: Why is it not necessary to be trained in algorithm reasoning when dealing with
    functional data structures (in the majority of cases)?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理功能数据结构（在大多数情况下）时，为什么不需要训练算法推理？
- en: What is the algebraic approach to programming?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程的代数方法是什么？
- en: What are the benefits of adopting an algebraic style?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用代数风格的优点是什么？
- en: What is the purpose of effect types such as `Option` or `Try` ?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于 `Option` 或 `Try` 这样的效果类型有什么作用？
- en: Further reading
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Scala Programming* by Vikash Sharma and the section entitled *Getting
    familiar with Scala collections* ([https://www.packtpub.com/application-development/learning-scala-programming](https://www.packtpub.com/application-development/learning-scala-programming)).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Vikash Sharma 的《*学习 Scala 编程*》以及名为 *熟悉 Scala 集合* 的章节（[https://www.packtpub.com/application-development/learning-scala-programming](https://www.packtpub.com/application-development/learning-scala-programming)）。
