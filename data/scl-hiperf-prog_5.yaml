- en: Chapter 5. Lazy Collections and Event Sourcing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。懒惰集合和事件溯源
- en: 'In the last chapter, we explored a number of Scala collections that readily
    perform evaluations eagerly. The Scala standard library provides two collections
    that operate lazily: views and streams. To motivate an exploration of these collections,
    we will tackle another performance dilemma at MVT revolving around performance
    reports that are generated for clients. In this chapter, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探索了许多可以立即进行贪婪评估的Scala集合。Scala标准库提供了两个操作懒惰的集合：视图和流。为了激发对这些集合的探索，我们将解决MVT围绕为客户端生成性能报告的性能困境。在本章中，我们将涵盖以下主题：
- en: Views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Stream processing with two real-world applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个真实世界应用的流处理
- en: Event sourcing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源
- en: Markov chain generation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马尔可夫链生成
- en: Improving the client report generation speed
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高客户报告生成速度
- en: Wanting to learn more about the customers of MVT, you decide to attend the weekly
    client status meeting. As you look around, you see that you are the only engineer
    here and everyone else is from the sales team. Johnny, the head of the MVT client
    management team, runs through a list of newly-signed on clients. Each time he
    reads off a name, a loud bell is rung. It seems like a strange custom to you,
    but the sales team is excitedly cheering each time the bell rings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于MVT客户的信息，你决定参加每周的客户状态会议。当你环顾四周时，你看到自己是这里唯一的工程师，其他人都是销售团队的人。MVT客户管理团队的负责人约翰尼列出了新签约的客户名单。每次他读出一个名字，就会响起一声响亮的铃声。这对你来说似乎是一种奇怪的习俗，但每当铃声响起，销售团队都会兴奋地欢呼。
- en: After the new client listing ends and the ringing in your ears stops, one of
    the sales team members asks Johnny, "When will the performance reports be generated
    faster? Clients are calling me everyday complaining about the inability to see
    their positions and profits and losses during the trading day. It's embarrassing
    that we do not have this kind of transparency, and we will lose business because
    of this." You realize that the report in question is a PDF that can be downloaded
    via the private web portal that is exposed by MVT to clients. Unless a client
    is sophisticated enough to set up his or her own reporting using MVT's performance
    API, then the client is dependent upon the portal to inspect recent trading performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在新客户名单公布结束，耳边铃声停止后，销售团队中的一名成员问约翰尼：“性能报告何时能生成得更快？客户每天都在打电话给我，抱怨他们无法在交易日看到自己的持仓和盈亏情况。我们没有这种透明度，这很尴尬，我们可能会因此失去业务。”你意识到这个问题报告是一个可以通过MVT向客户公开的私有网络门户下载的PDF文件。除非客户足够熟练，能够使用MVT的性能API设置自己的报告，否则客户将依赖于门户来检查最近的交易表现。
- en: Realizing that this is an opportunity to better understand the issue, you ask,
    "Hi, I'm from the engineering team. I thought I would sit in today to learn more
    about our clients. Can you share more about the reporting performance problem?
    I'd like to help address the concern." Through conversation with the sales team,
    you learn that the PDF report is a first step towards a real-time streaming web
    app. The PDF report allows MVT to quickly give trading performance insight to
    clients. Each time the client clicks **View Performance**, a report is generated
    that summarizes the performance trend by displaying whether or not the client
    has realized a profit or a loss in the last hour, day, and seven days. Particularly
    when the market is volatile, you learn that clients are more likely to generate
    reports. The sales team thinks this exacerbates the issue because reports generate
    even slower when everyone is trying to see recent trading performance. In some
    of the worst cases, the performance report takes about a dozen minutes to generate,
    which is totally unacceptable to clients that expect near real-time results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到这是一个更好地理解问题的机会，你问道：“嗨，我是工程团队的一员。我想今天来了解一下我们的客户。你能分享更多关于报告性能问题的情况吗？我想帮助解决这个问题。”通过与销售团队的交谈，你了解到PDF报告是向实时流式Web应用迈出的第一步。PDF报告允许MVT快速向客户提供交易表现洞察。每次客户点击“查看表现”时，都会生成一份报告，通过显示客户在过去一小时、一天和七天内是否实现了盈利或亏损来总结表现趋势。尤其是在市场波动时，你了解到客户更有可能生成报告。销售团队认为这加剧了问题，因为当每个人都试图查看最近的交易表现时，报告生成速度会变得更慢。在一些最糟糕的情况下，性能报告需要大约十几分钟才能生成，这对期望近乎实时结果的客户来说是完全不能接受的。
- en: Diving into the reporting code
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入报告代码
- en: 'Eager to dig into the problem, you find the repository that is responsible
    for working with reporting data. You explore the domain model to understand the
    concerns represented in this scope:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 急于深入探究问题，你找到了负责处理报告数据的存储库。你探索领域模型以了解此范围内表示的关注点：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the reporting context, linking orders to executions is important to build
    the performance trend report because this association allows MVT to identify the
    profit or loss realized from the trade. `ClientId` is a concept that you have
    not worked with before when working on the order book or performing data analysis.
    The client ID is used to identify an MVT client's account. As trades are executed
    on behalf of clients, the client ID allows us to link an executed order to a client
    account.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告的上下文中，将订单与执行关联起来对于构建性能趋势报告非常重要，因为这种关联使得MVT能够识别出从交易中实现的利润或损失。`ClientId`是一个你在处理订单簿或执行数据分析时未曾接触过的概念。客户ID用于识别MVT客户的账户。由于交易是代表客户执行的，因此客户ID使我们能够将已执行的订单与客户账户关联起来。
- en: 'Scanning the code base, you spot the representation of a performance trend
    report before it is converted into PDF format:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描代码库时，你发现了性能趋势报告在转换为PDF格式之前的表示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **profit and loss** (**PnL**) trend is represented by distinct ADTs for
    each supported time period: the last hour, last day, and last seven days. For
    each stock ticker, these three time periods are included in`TradingPerformanceTrend`.
    Across multiple tickers, you infer a client can identify whether or not MVT is
    generating a profit or a loss over time. Inspecting the signature of the `trend`
    method which is responsible for computing `TradingPerformanceTrend`, you confirm
    your thinking:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**利润和损失**（**PnL**）趋势由每个支持的时间段对应的不同的ADT表示：最后一个小时、最后一天和最后七天。对于每个股票代码，这三个时间段都包含在`TradingPerformanceTrend`中。在多个股票代码中，你可以推断出客户可以确定MVT是否在一段时间内产生利润或损失。检查负责计算`TradingPerformanceTrend`的`trend`方法的签名，你可以证实你的想法：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Computing the performance trend requires a way to determine the current time
    in order to determine how far to look back to compute each time period''s trend.
    The `findOrders` and `findExecutions` arguments are functions that query the reporting
    data store for orders and executions that were created within a time interval
    for a particular ticker. The final argument contains the client''s ID and the
    tickers to report on. Each period''s trend is computed by a generalized inner-method
    named `periodPnL`, which looks like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算性能趋势需要一种确定当前时间的方法，以便确定需要回溯多远来计算每个时间段的趋势。`findOrders`和`findExecutions`参数是查询特定股票代码在特定时间间隔内创建的订单和执行的函数。最后一个参数包含客户的ID和要报告的股票代码。每个时间段的趋势是通过一个名为`periodPnL`的通用内部方法计算的，其形式如下：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `periodPnL` method is an involved method that contains several logical steps.
    For each client-provided ticker, the associated orders and executions for the
    provided time period are retrieved. In order to correlate orders with executions,
    a map of `OrderId` to `Execution` is built by using `groupBy`. To simplify later
    calculations, the average execution price of each executed order is computed to
    reduce multiple executions for a single order to a single value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`periodPnL`方法是一个包含多个逻辑步骤的复杂方法。对于每个客户提供的股票代码，检索提供的时间段内的相关订单和执行。为了关联订单与执行，使用`groupBy`构建一个`OrderId`到`Execution`的映射。为了简化后续的计算，计算每个已执行订单的平均执行价格，将单个订单的多个执行减少到一个值。'
- en: 'With the `idToExecPrice` lookup table built, the next logical step is to filter
    out orders for other clients. Once only the client''s orders remain, `idToExecution`
    is used to identify the orders that executed. The final two steps compute the
    performance trend by tabulating the client''s absolute return (that is, profit
    and loss). The steps involve two additions to the domain model, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了`idToExecPrice`查找表之后，下一步的逻辑步骤是过滤掉其他客户的订单。一旦只剩下客户的订单，`idToExecution`用于识别已执行的订单。最后两个步骤通过编制客户的绝对回报（即利润和损失）来计算性能趋势。这些步骤涉及领域模型的两个添加，如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PnL` value is a value class that is used to represent the client's dollar
    return. `PeriodPnL` is analogous to the previously introduced ADT that can be
    applied to any time period of data. This allows `PeriodPnL` to be reused for the
    last hour, last day, and last seven days trend computations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`PnL`值是一个用于表示客户美元回报的价值类。`PeriodPnL`类似于之前引入的ADT，可以应用于任何时间段的数据。这使得`PeriodPnL`可以重复用于最后一个小时、最后一天和最后七天的趋势计算。'
- en: When the trade represents a buy, the execution price is negated because the
    transaction represents cash being exchanged for stock. When the trade represents
    a sell, the execution price remains positive because the transaction represents
    exchanging stock for cash. After computing the performance trend for each ticker,
    the `List` of the `Ticker` and `PeriodPnL` tuples is converted to a `Map`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当交易代表买入时，执行价格会被取反，因为交易代表的是现金交换股票。当交易代表卖出时，执行价格保持正值，因为交易代表的是用股票交换现金。在计算每个股票的性能趋势后，`Ticker`和`PeriodPnL`元组的`List`被转换为`Map`。
- en: Digesting this implementation, you can start to imagine why generating this
    PDF is time-consuming. There is no sign of caching results, which means that the
    trend report is recomputed each time a client makes a request. As the number of
    clients requesting reports increases, there is an increased wait time while reports
    are computed. Re-architecting the reporting infrastructure to cache reports is
    too large a near-term change. Instead, you try to identify incremental changes
    that can improve report generation performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个实现的过程，你可以开始想象生成这个PDF为什么耗时。没有缓存结果的迹象，这意味着每次客户端发起请求时，趋势报告都会重新计算。随着请求报告的客户数量增加，计算报告时的等待时间也会增加。重新架构报告基础设施以缓存报告是一个过于庞大的短期改变。相反，你尝试识别可以改进报告生成性能的增量变化。
- en: Using views to speed up report generation time
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图加快报告生成时间
- en: When working on the order book, we learned that `List` eagerly evaluates results.
    This property means that, in `periodPnL`, the de-sugared for-comprehension `filter`
    and `map` operations performed on `orders` produce new lists. That is, each transformation
    produces a new collection. For customers with large order counts, it can be costly
    in terms of CPU time to iterate over an order set three times, in addition to
    incurring garbage collection costs due to repeated `List` creation. To ameliorate
    this concern, Scala provides a way to defer transforming elements until an element
    is needed by a downstream computation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在订单簿上工作时，我们了解到`List`会急切地评估结果。这个特性意味着在`periodPnL`中，对`orders`执行的脱糖for-comprehension
    `filter`和`map`操作会产生新的列表。也就是说，每个转换都会产生一个新的集合。对于订单数量大的客户来说，迭代订单集三次可能会在CPU时间上造成成本，并且由于重复创建`List`而产生垃圾收集成本。为了缓解这个问题，Scala提供了一种方法，可以在下游计算需要元素时才延迟转换元素。
- en: 'Conceptually, this is done by adding a view on top of the eagerly evaluated
    collection that allows transformations to be defined with deferred evaluation
    semantics. A lazily evaluated view of a collection can be constructed from any
    Scala collection by invoking `view`. For example, this snippet creates a view
    from a `List` of integers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这是通过在急切评估的集合之上添加一个视图来完成的，该视图允许使用延迟评估语义定义转换。可以通过调用`view`从任何Scala集合构建集合的懒加载视图。例如，以下片段从一个整数`List`创建了一个视图：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From this snippet, we learn that Scala represents a view into a collection
    with a different `SeqView` type that is parameterized by two types: the collection
    element, and the collection type. Seeing a view in use makes it easier to understand
    its runtime differences with an eagerly evaluated collection. Consider the following
    snippet performing the same operations on a `List` and a view over a `List`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个片段中，我们了解到Scala使用一个不同的`SeqView`类型来表示集合的视图，该类型由两种类型参数化：集合元素和集合类型。看到视图的使用使得更容易理解它与急切评估集合的运行时差异。考虑以下片段，它在`List`及其`List`视图上执行相同的操作：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This snippet performs simple arithmetic and then filters to find the even elements.
    For the sake of deepening our understanding, the snippet breaks the functional
    paradigm by adding the `println` side effect. The output of the list evaluation
    is as expected:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段执行简单的算术运算，然后过滤以找到偶数元素。为了加深我们的理解，这个片段通过添加`println`副作用打破了函数式范式。列表评估的输出符合预期：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With eager evaluation, each transformation is applied to each element before
    moving to the next transformation. Now, consider the following output from view
    evaluation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在急切评估中，每个转换在移动到下一个转换之前都会应用于每个元素。现在，考虑以下来自视图评估的输出：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we discussed earlier, with lazy evaluation no transformations are applied
    until an element is needed. In this example, this means that the addition and
    filtering do not occur until the invocation of `toList`. The absence of output
    after "view evaluation" is evidence that zero transformations occurred. Curiously,
    we also see that only the first four of six elements are evaluated. When a view
    applies transformations, it applies all transformations to each element rather
    than applying each transformation to all elements. By applying all transformations
    in one step, the view is able to return the first two elements without evaluating
    the entire collection. Here, we see the potential performance gains from view
    usage due to lazy evaluation. Before applying the concept of views to the performance
    trend report, let's take a deeper look at view implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，使用惰性评估时，只有在需要元素时才会应用转换。在这个例子中，这意味着加法和过滤操作不会在调用`toList`之前发生。在“视图评估”之后没有输出，这表明没有发生任何转换。有趣的是，我们还看到只有六个元素中的前四个被评估。当一个视图应用转换时，它将对每个元素应用所有转换，而不是对每个元素应用每个转换。通过一步应用所有转换，视图能够返回前两个元素，而无需评估整个集合。在这里，我们看到了由于惰性评估而使用视图的潜在性能提升。在将视图的概念应用到性能趋势报告之前，让我们更深入地了解一下视图的实现。
- en: Constructing a custom view
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建自定义视图
- en: 'Views are able to defer evaluation by returning a data structure that composes
    the previous transformation state with the next transformation. The Scala implementation
    of views is admittedly complicated to digest because it provides a large number
    of capabilities while retaining support for all Scala collections. To build an
    intuition for how views are implemented, let''s construct our own lazily evaluated
    view that works only for `List` and only supports `map` operations. To begin,
    we define the operations that are supported by our implementation of a `PseudoView`
    view:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 视图能够通过返回一个组合了先前转换状态和下一个转换的数据结构来延迟评估。Scala视图的实现确实复杂，因为它提供了大量的功能，同时仍然支持所有Scala集合。为了构建对视图实现的理解，让我们构建我们自己的仅适用于`List`且仅支持`map`操作的惰性评估视图。首先，我们定义我们的`PseudoView`视图实现所支持的运算：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `PseudoView` is defined as a trait that supports lazy application of a
    transformation from `A` to `B` and also supports evaluating all transformations
    to return a `List`. Next, we define two view types of view to support the initial
    case when zero transformations have been applied and to support applying a transformation
    to a previously transformed view. The signatures are shown in the following snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`PseudoView`被定义为一种特质，它支持从`A`到`B`的转换的惰性应用，同时也支持评估所有转换以返回一个`List`。接下来，我们定义两种视图类型，以支持零转换已应用时的初始情况，以及支持将转换应用到先前转换过的视图。签名在以下代码片段中显示：'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In both scenarios, the original `List` must be carried through to support eventually
    applying the transformations. In the `InitialView` base case, there are zero transformations,
    which is why there is no additional state. `ComposedView` supports chaining computations
    by carrying the state of the previous `fa` transformation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，原始的`List`必须保留以支持最终应用转换。在`InitialView`的基本情况下，没有转换，这就是为什么没有额外的状态。`ComposedView`通过携带先前`fa`转换的状态来支持链式计算。
- en: 'Implementing `InitialView` is a straightforward delegation to `ComposedView`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`InitialView`是一个简单的委托给`ComposedView`：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `List` implementation shows how transformations are chained together using
    function composition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`实现展示了如何使用函数组合将转换链在一起：'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s construct a `PseudoView` companion object that provides view construction,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个`PseudoView`伴生对象，它提供视图构建，如下所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now exercise `PseudoView` with a simple program to demonstrate that
    it defers evaluation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过一个简单的程序来练习`PseudoView`，以证明它延迟了评估：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this program, we see output equivalent to usage of Scala''s view implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序，我们看到输出与Scala视图实现的用法相当：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`PseudoView` helps build an intuition about how Scala implements views. From
    here, you can begin considering how to support other operations. For example,
    how can `filter` be implemented? The `filter` is interesting to consider because
    it constrains the original collection. As defined, `PseudoView` is ill-equipped
    to support the `filter` operations, which is one illustration of the complexity
    that is handled by Scala views. Scala views tackles this challenge by defining
    a trait named `Transformed`. The `Transformed` trait is the base trait for all
    view operations. A partial definition is shown, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`PseudoView`有助于建立对Scala如何实现视图的直觉。从这里，你可以开始考虑如何支持其他操作。例如，如何实现`filter`？`filter`很有趣，因为它限制了原始集合。如定义，`PseudoView`不适合支持`filter`操作，这是Scala视图处理复杂性的一个例子。Scala视图通过定义一个名为`Transformed`的特质来应对这一挑战。`Transformed`特质是所有视图操作的基础特质。部分定义如下：'
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `underlying` lazy value is how the originally wrapped collection is accessed.
    This is analogous to how `PseudoView` passed the `List` state into `ComposedView`.
    `Transformed` defines a side-effecting `foreach` operation to support collection
    operations in a lazy manner. Using `foreach` allows implementations of this trait
    to modify the underlying collection. This is how `filter` is implemented:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`underlying`懒值是原始包装集合的访问方式。这与`PseudoView`将`List`状态传递到`ComposedView`的方式类似。`Transformed`定义了一个副作用`foreach`操作来以懒加载方式支持集合操作。使用`foreach`允许实现此特质的实例修改底层集合。这就是`filter`是如何实现的：'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Transformed` is used within the view API to maintain the state of necessary
    operations, while the external API supports interacting with `SeqView`. Following
    another pattern that is commonly found in Scala collections, `SeqView` inherits
    a number of operations by mixing in other traits. `SeqView` indirectly mixes in `TraversableViewLike`,
    which provides access to the `Transformed` operations.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图API中，`Transformed`用于维护必要操作的状态，而外部API支持与`SeqView`交互。遵循在Scala集合中常见的另一种模式，`SeqView`通过混合其他特质继承了一组操作。`SeqView`间接混合了`TraversableViewLike`，这提供了对`Transformed`操作的访问。
- en: Applying views to improve report generation performance
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用视图来提高报告生成性能
- en: With our newly-developed intuition for views, we may view (no pun intended!)
    the construction of performance trend reports differently. Scala's implementation
    of views makes it trivial to switch from eagerly evaluated collections to a lazily
    evaluated version. If you recall, once the order ID to the average execution price
    lookup table is constructed, a series of transformations are applied to the orders
    that are retrieved for the duration and ticker. By converting `orders` to a view,
    there is an opportunity to avoid unnecessary transformations and improve the speed
    of the performance trend report.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们新开发的视图直觉，我们可能（无意中！）以不同的方式看待性能趋势报告的构建。Scala对视图的实现使得从急切评估的集合切换到懒加载版本变得非常简单。如果你还记得，一旦构建了订单ID到平均执行价格查找表，就会对在特定时间段和股票代码下检索到的订单应用一系列转换。通过将`orders`转换为视图，就有机会避免不必要的转换并提高性能趋势报告的速度。
- en: 'While it is trivial to convert to a view, it is less trivial to identify under
    which conditions lazy evaluation out-performs eager evaluation. As a good performance
    engineer, you want to benchmark your proposed change, but you do not have access
    to historical order and execution data to build a benchmark. Instead, you write
    a microbenchmark that simulates the problem that you are modeling. The question
    that you are trying to answer is, "For what size collection and what number of
    operations does it make sense to use a view over a `List`?" There is a cost to
    constructing a view because it involves retaining information about the deferred
    transformation, which implies it will not always be the most performant solution.
    You come up with the following scenarios to help answer your question:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然转换为视图很简单，但确定在哪些条件下懒加载评估优于急切评估则不那么简单。作为一名优秀的性能工程师，你希望对你的提议进行基准测试，但你没有访问历史订单和执行数据来构建基准。相反，你编写了一个微基准测试来模拟你正在建模的问题。你试图回答的问题是：“对于什么大小的集合和多少操作，使用视图而不是`List`是有意义的？”构建视图是有成本的，因为它涉及到保留关于延迟转换的信息，这意味着它不总是性能最佳解决方案。你提出了以下场景来帮助你回答问题：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For each collection type, a `List`, and a view over a `Vector`, you define
    three tests that exercise an increasing number of transformations. `Vector` is
    used instead of `List` because `toList` on a view is not specialized for `List`.
    As we have previously seen, `List` operations are written to take advantage of
    constant time and prepend performance. The `toList` performs linear time append
    operations, which gives the false impression that views deliver lower performance.
    Switching to `Vector` provides effectively constant time append operations. The
    state for this benchmark looks like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种集合类型，一个`List`和一个`Vector`上的视图，你定义了三个测试，以练习不断增加的转换数量。`Vector`被用来代替`List`，因为视图上的`toList`没有针对`List`进行优化。正如我们之前看到的，`List`操作被编写为利用常数时间和预加性能。`toList`执行线性时间追加操作，这给人一种视图提供较低性能的错觉。切换到`Vector`提供了有效的常数时间追加操作。此基准的状态如下所示：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ViewState` sweeps different collection sizes to help identify how sensitive
    view performance is to collection size. The benchmark is invoked via the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewState`通过遍历不同的集合大小来帮助识别视图性能对集合大小的敏感性。基准通过以下方式调用：'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This invocation produces the following results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用产生以下结果：
- en: '| **Benchmark** | **Collection size** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **集合大小** | **吞吐量（每秒操作数）** | **吞吐量误差百分比** |'
- en: '| `singleTransformList` | 10 | 15,171,067.61 | ± 2.46 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformList` | 10 | 15,171,067.61 | ± 2.46 |'
- en: '| `singleTransformView` | 10 | 3,175,242.06 | ± 1.37 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformView` | 10 | 3,175,242.06 | ± 1.37 |'
- en: '| `singleTransformList` | 1,000 | 133,818.44 | ± 1.58 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformList` | 1,000 | 133,818.44 | ± 1.58 |'
- en: '| `singleTransformView` | 1,000 | 52,688.80 | ± 1.11 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformView` | 1,000 | 52,688.80 | ± 1.11 |'
- en: '| `singleTransformList` | 1,000,000 | 30.40 | ± 2.72 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformList` | 1,000,000 | 30.40 | ± 2.72 |'
- en: '| `singleTransformView` | 1,000,000 | 86.54 | ± 1.17 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `singleTransformView` | 1,000,000 | 86.54 | ± 1.17 |'
- en: '| `twoTransformsList` | 10 | 5,008,830.88 | ± 1.12 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsList` | 10 | 5,008,830.88 | ± 1.12 |'
- en: '| `twoTransformsView` | 10 | 4,564,726.04 | ± 1.05 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsView` | 10 | 4,564,726.04 | ± 1.05 |'
- en: '| `twoTransformsList` | 1,000 | 44,252.83 | ± 1.08 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsList` | 1,000 | 44,252.83 | ± 1.08 |'
- en: '| `twoTransformsView` | 1,000 | 80,674.76 | ± 1.12 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsView` | 1,000 | 80,674.76 | ± 1.12 |'
- en: '| `twoTransformsList` | 1,000,000 | 22.85 | ± 3.78 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsList` | 1,000,000 | 22.85 | ± 3.78 |'
- en: '| `twoTransformsView` | 1,000,000 | 77.59 | ± 1.46 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `twoTransformsView` | 1,000,000 | 77.59 | ± 1.46 |'
- en: '| `threeTransformsList` | 10 | 3,360,399.58 | ± 1.11 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsList` | 10 | 3,360,399.58 | ± 1.11 |'
- en: '| `threeTransformsView` | 10 | 3,438,977.91 | ± 1.27 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsView` | 10 | 3,438,977.91 | ± 1.27 |'
- en: '| `threeTransformsList` | 1,000 | 36,226.87 | ± 1.65 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsList` | 1,000 | 36,226.87 | ± 1.65 |'
- en: '| `threeTransformsView` | 1,000 | 58,981.24 | ± 1.80 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsView` | 1,000 | 58,981.24 | ± 1.80 |'
- en: '| `threeTransformsList` | 1,000,000 | 10.33 | ± 3.58 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsList` | 1,000,000 | 10.33 | ± 3.58 |'
- en: '| `threeTransformsView` | 1,000,000 | 49.01 | ± 1.36 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `threeTransformsView` | 1,000,000 | 49.01 | ± 1.36 |'
- en: The results give us an interesting insight into the cases where using a view
    yields better performance. For a small collection, such as 10 elements in our
    benchmark, a `List` performs better, regardless of the amount of operations, although
    this gap closes at 1,000,000 elements. When transforming a large collection, 1,000,000
    elements in our benchmark, a view is more efficient with an increasing differential
    as the number of transformations increases. For example, with 1,000,000 elements
    and two transformations, views deliver approximately triple the throughput of `List`.
    In the case of a medium size collection, such as 1,000 elements in this example,
    this is not as clear-cut. When performing a single transformation, an eager `List`
    performs better, while a view delivers better throughput when applying more than
    one transformation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果为我们提供了对使用视图产生更好性能的案例的有趣见解。对于小集合，例如我们基准中的10个元素，`List`的表现更好，无论操作量如何，尽管这个差距在1,000,000个元素时缩小。当我们转换一个大集合时，例如我们基准中的1,000,000个元素，随着转换数量的增加，视图变得更加高效，差异也在增加。例如，对于1,000,000个元素和两次转换，视图提供的吞吐量大约是`List`的三倍。在中等大小集合的情况下，例如本例中的1,000个元素，这并不那么明显。在执行单个转换时，急切的`List`表现更好，而在应用多个转换时，视图提供的吞吐量更高。
- en: As the volume of your data and the transformation count increase, it becomes
    more likely that a view offers better performance. Here, you see the tangible
    benefit of avoiding intermediate collections. A second axis of performance to
    consider is the nature of the transformation. Transformations that benefit from
    early termination (for example, `find`), benefit strongly from lazy evaluation.
    This benchmark illustrates that it is important to understand the size of your
    data and the transformations that you intend to perform.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据量和转换次数的增加，视图提供更好的性能的可能性也更大。在这里，你可以看到避免中间集合的实质性好处。考虑性能的第二个方面是转换的性质。从早期终止中受益的转换（例如，`find`），从懒加载中受益很大。这个基准测试说明，了解你的数据大小和打算执行的转换非常重要。
- en: View caveats
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图注意事项
- en: Views offer a simple way to improve performance with minimally invasive changes
    to your system. The ease of use is part of the allure of views, which may tempt
    you to use them more frequently than you otherwise would. As our benchmarking
    in the previous section shows, there is a nontrivial overhead to using views,
    which means defaulting to views is a suboptimal choice. Looking past the pure
    performance perspective, there are other reasons to tread carefully when using
    views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 视图提供了一种简单的方法，通过最小侵入性更改系统来提高性能。易用性是视图吸引力的部分，可能会诱使你比平时更频繁地使用它们。正如我们上一节中的基准测试所显示的，使用视图存在非微不足道的开销，这意味着默认使用视图是一个次优选择。从纯粹的性能角度来看，使用视图时还有其他需要谨慎的理由。
- en: SeqView extends Seq
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SeqView 扩展了 Seq
- en: As views mirror the collection API, it can be a challenge to identify when transformations
    are being applied lazily. For this reason, we recommend setting well-defined boundaries
    for view usage. When working on client reporting, we limited view usage to a single
    inner-function and used a `List` eager collection type as the return type. Minimizing
    the area of a system performing a lazy evaluation can reduce cognitive load when
    building a runtime execution mental model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图反映了集合 API，识别何时应用懒加载的转换可能是一个挑战。因此，我们建议为视图的使用设定明确的边界。在处理客户端报告时，我们将视图的使用限制在一个内部函数中，并使用
    `List` 急加载集合类型作为返回类型。最小化系统执行懒加载的区域可以减少构建运行时执行心理模型时的认知负荷。
- en: 'On a related note, we feel that it is important to be cautious about how a
    view is transformed into an eagerly evaluated collection type. We showed conversion
    by invoking `toList`, which makes the intent explicit. `SeqView` also provides
    a `force` method to force evaluation. As a general rule, we avoid using `force`
    because it typically returns `scala.collection.immutable.Seq`. `SeqView` retains
    the collection type as its second generic parameter, which allows `force` to return
    the original collection type when there is enough evidence. However, certain operations,
    such as `map`, cause the view to lose evidence of the original collection type.
    When this happens, `force` returns the more general `Seq` collection type. `Seq`
    is a trait that is a super-type to all sequences in the collection library, including
    views and another lazy data structure that we will discuss later, named `scala.collection.immutable.Stream`.
    This inheritance scheme allows the following three statements to compile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关方面，我们认为谨慎地处理视图如何转换为急加载的集合类型非常重要。我们通过调用 `toList` 来展示转换，这使得意图变得明确。`SeqView`
    还提供了一个 `force` 方法来强制评估。作为一般规则，我们避免使用 `force`，因为它通常返回 `scala.collection.immutable.Seq`。`SeqView`
    保留集合类型作为其第二个泛型参数，这使得在有足够证据的情况下，`force` 可以返回原始集合类型。然而，某些操作，如 `map`，会导致视图失去原始集合类型的证据。当这种情况发生时，`force`
    返回更通用的 `Seq` 集合类型。`Seq` 是一个特质，它是集合库中所有序列的超类型，包括视图和我们将要讨论的另一个懒加载数据结构，名为 `scala.collection.immutable.Stream`。这种继承方案允许以下三个语句编译：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We believe this is undesirable because the `Seq` data type hides critical information
    about the underlying implementation. It represents both lazy and eagerly evaluated
    collections with the same type. Consider the following snippet example to understand
    why this is undesirable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这是不可取的，因为 `Seq` 数据类型隐藏了关于底层实现的临界信息。它使用相同的类型表示懒加载和急加载的集合。考虑以下代码片段示例，以了解为什么这是不可取的：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this manufactured example, imagine that `shouldGenerateOrder` is invoked
    with a `Vector`, but then later the `Vector` is swapped out for `SeqView`. With `Vector`,
    identifying collection length is a constant time operation. With `SeqView`, you
    cannot reason with certainty about the runtime of the operation, except to say
    that it is definitely more expensive than `Vector.size`. `Seq` usage, and, therefore,
    the usage of `force`, should be avoided because it is difficult to reason about
    runtime behavior, and this can lead to unexpected side-effects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个人为的例子中，想象一下`shouldGenerateOrder`方法被一个`Vector`对象调用，但后来`Vector`被`SeqView`替换。使用`Vector`时，识别集合长度是一个常数时间操作。使用`SeqView`时，你无法确定操作的运行时间，只能说它肯定比`Vector.size`更昂贵。由于难以推理运行时行为，因此应避免使用`Seq`，以及因此导致的`force`的使用，因为这可能导致意外的副作用。
- en: In a typical software system, areas of responsibility are separated into discrete
    modules. Using the performance trend reporting example, you can imagine a separate
    module containing the translation from `List[TradingPerformanceTrend]` to a PDF
    report. You may be tempted to expose the view to other modules to extend the benefit
    of lazy transformations. If benchmarks justify making this type of change, then
    we encourage you to choose one of these options. Our preferred choice in this
    scenario is to use `Stream`, which is a lazily evaluated version of `List`. We
    explore `Stream` later in this chapter. Alternatively, if `Stream` cannot be used,
    be strict in your use of the `SeqView` datatype to clearly demarcate that the
    collection is lazily evaluated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的软件系统中，责任区域被划分为离散的模块。使用性能趋势报告的例子，你可以想象一个独立的模块，它包含将`List[TradingPerformanceTrend]`转换为PDF报告的转换。你可能想将视图暴露给其他模块以扩展延迟转换的好处。如果基准测试证明进行此类更改是合理的，那么我们鼓励你选择这些选项之一。在这种情况下，我们首选的选择是使用`Stream`，它是`List`的延迟评估版本。我们将在本章后面探讨`Stream`。如果无法使用`Stream`，请在使用`SeqView`数据类型时保持严格，以清楚地界定集合是延迟评估的。
- en: Views are not memoizers
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图不是记忆化器
- en: 'One additional consideration when using views is to be cognizant of when transformations
    are repeatedly applied. For example consider this manufactured example that focuses
    on a use case where a view is used as a base for multiple computations:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图时，还需要考虑的一点是要意识到何时重复应用转换。例如，考虑以下人为的例子，它关注一个视图作为多个计算基础的用例：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, `xs` is a view on a list of integers. A `map` transformation
    is lazily applied to multiply these integers by 2\. The view is then used to create
    two `List` instances, one containing even elements, the other containing odd elements.
    We observe that the transformation is applied to the view twice, each time we
    turn the view into a list. This shows that the transformation is lazily applied,
    but the results of the computation are not cached. This is a characteristic of
    views to keep in mind, as expensive transformations applied several times can
    cause significant slowdowns. This is also the reason why side-effects should be
    avoided in transformations applied to views. If, for some reason, referential
    transparency is not upheld, the combination of side-effects and multiple evaluations
    due to view usage can lead to exceptionally difficult to maintain software.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`xs`是一个整数列表的视图。一个`map`转换被延迟应用于将这些整数乘以2。然后，视图被用来创建两个`List`实例，一个包含偶数元素，另一个包含奇数元素。我们观察到转换被应用于视图两次，每次我们将视图转换为列表时。这表明转换是延迟应用的，但计算的结果没有被缓存。这是视图的一个需要注意的特性，因为多次应用昂贵的转换可能会导致显著的性能下降。这也是为什么在应用于视图的转换中应避免副作用的原因。如果由于某种原因，引用透明性没有得到保持，由于视图的使用导致的副作用和多次评估的组合可能会导致难以维护的软件。
- en: 'This example is straightforward, and the misuse of views is easy to spot. However,
    even methods that are provided by the standard library can lead to undesirable
    results when used with views. Consider this snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，视图的误用很容易被发现。然而，即使是标准库提供的方法，在与视图一起使用时也可能导致不希望的结果。考虑以下片段：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example achieves the same results as the previous sample, but we rely on
    the built-in `partition` method to split the original list into two distinct collections
    each operating on the original view. Again, we see the `map` transformation applied
    twice to the original view. This is due to the underlying implementation of `partition`
    in `TraversableViewLike`. The main takeaway is that views and lazy evaluation
    can help yield better performance, but they should be used carefully. It is a
    good idea to experiment and try your algorithm in the REPL to confirm that you
    are using views correctly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子实现了与上一个示例相同的结果，但我们依赖于内置的 `partition` 方法将原始列表分割成两个独立的集合，每个集合都操作原始视图。再次，我们看到
    `map` 转换被两次应用于原始视图。这是由于 `TraversableViewLike` 中 `partition` 的底层实现。主要的启示是视图和懒加载可以帮助提高性能，但它们应该谨慎使用。在
    REPL 中实验并尝试你的算法是一个好主意，以确认你正确地使用了视图。
- en: 'In our running example on reporting on trading performance trends, we saw an
    easy-to-miss example of lazy evaluation when operating on a `Map`. Recall that
    there was a lookup table built using the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的关于报告交易性能趋势的运行示例中，我们看到了一个容易忽视的懒加载示例，当在 `Map` 上操作时。回想一下，有一个使用以下代码构建的查找表：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The return type of `mapValues` is `Map[A, B]`, which does not suggest any difference
    in evaluation strategy. Let''s run a simple example in the REPL:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapValues` 的返回类型是 `Map[A, B]`，这并不暗示任何评估策略上的差异。让我们在 REPL 中运行一个简单的例子：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how, each time we call `get` on `m_prime` to retrieve a value, we can
    observe the transformation being applied, even when using the same key. The `mapValues`
    is a lazily-evaluated transformation of each value in the map akin to a view operating
    on the keys of a map. The types that are involved do not provide any insight,
    and unless you inspect the implementation of `Map` or carefully read the documentation
    that is associated with `mapValues`, you will likely miss this important detail.
    Consider the caveats of views when working with `mapValues`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每次我们在 `m_prime` 上调用 `get` 来检索一个值时，我们都可以观察到转换的应用，即使使用相同的键。`mapValues` 是对映射中每个值进行懒加载转换，类似于在映射的键上操作的视图。涉及到的类型并不提供任何见解，除非你检查
    `Map` 的实现或仔细阅读与 `mapValues` 相关的文档，否则你可能会错过这个重要的细节。在处理 `mapValues` 时，考虑视图的注意事项。
- en: Zipping up report generation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告生成中的压缩
- en: 'While investigating the implementation of `TradingPerformanceTrend`, we took
    a deep dive into views and found how they can improve performance. We now return
    to the implementation of `trend` to complete the generation of the `List[radingPerformanceTrend]`.
    The following snippet shows `trend` with the implementation of `periodPnL` hidden
    because we thoroughly reviewed it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查 `TradingPerformanceTrend` 的实现时，我们深入研究了视图，并发现了它们如何提高性能。现在我们回到 `trend` 的实现，以完成
    `List[TradingPerformanceTrend]` 的生成。以下片段显示了 `trend`，其中 `periodPnL` 的实现被隐藏，因为我们已经彻底审查了它：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This method focuses on marshaling the translation of PnL for a time period
    to the appropriate time period''s performance trend. The final expression involving
    two invocations of `zip` makes the transformation from three maps with keys of `Ticker`
    and corresponding period PnL trend values to `List[TradingPerformanceTrend]` elegant.
    `zip` iterates over two collections to yield a tuple for each index of both collections.
    Here is a simple snippet to illustrate `zip` usage:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法专注于将某个时间段的 PnL 转换到相应时间段的性能趋势。涉及两个 `zip` 调用的最终表达式使从具有 `Ticker` 键和相应时间段 PnL
    趋势值的三个映射转换到 `List[TradingPerformanceTrend]` 变得优雅。`zip` 遍历两个集合，为每个集合的每个索引生成一个元组。以下是一个简单的片段，用于说明
    `zip` 的用法：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This yields the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result is that corresponding indexes are "zipped" together. For example,
    at index one, the first list's value is three and the second list's value is four,
    yielding the tuple, `(3, 4)`. The first list has four elements while the second
    list only has three elements; this is silently omitted from the resulting collection.
    This behavior is well-documented, but it might be unexpected at first glance.
    In our reporting use case, we are certain that each key (that is, each `Ticker`),
    appears in all three maps. In this use case, we are certain that all three maps
    are of equal length.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相应的索引被“压缩”在一起。例如，在索引一，第一个列表的值是三，第二个列表的值是四，得到元组 `(3, 4)`。第一个列表有四个元素，而第二个列表只有三个元素；这在结果集合中被默默地省略了。这种行为有很好的文档记录，但一开始可能会让人感到意外。在我们的报告用例中，我们确信每个键（即每个`Ticker`）都出现在所有三个映射中。在这个用例中，我们确信所有三个映射的长度相等。
- en: However, there is a subtle bug in our usage of `zip`. The `zip` uses a collection's
    iterator to iterate over elements, which implies that usage of `zip` is sensitive
    to ordering. Each of the three maps is constructed by invoking `toMap`, which
    indirectly delegates to a `scala.collection.immutable.HashMap` implementation
    of `Map`. Similar to `Set`, Scala provides several handwritten implementations
    of `Map` (for example, `Map2`) for small collection sizes before constructing
    a `HashMap`. By now, you may realize the flaw, `HashMap` does not guarantee ordering.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的`zip`使用中存在一个微妙的错误。`zip`使用集合的迭代器来遍历元素，这意味着`zip`的使用对排序敏感。这三个映射中的每一个都是通过调用`toMap`构建的，这间接地委托给`scala.collection.immutable.HashMap`的`Map`实现。与`Set`类似，Scala为小集合大小提供了几个手写的`Map`实现（例如，`Map2`），在构建`HashMap`之前。到现在，你可能已经意识到缺陷，`HashMap`不保证排序。
- en: To fix this bug and retain usage of `zip`, we can leverage our earlier discovery
    of `SortedMap`, the trait backed by `TreeMap` with sorted keys. Swapping out `Map`
    for `SortedMap` and making appropriate changes to define an `Ordering` for `Ticker`,
    we now have a bug-free, elegant solution to generating trading performance trend
    reports. With a judicious usage of views, we found a way to deliver iterative
    performance improvements with minimally invasive changes. This will give the sales
    team something to ring the bell about! This gives us additional time to consider
    other approaches to generating reports.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误并保留`zip`的使用，我们可以利用我们之前发现的`SortedMap`，它是基于`TreeMap`并具有排序键的特质。用`SortedMap`替换`Map`，并对`Ticker`定义适当的`Ordering`，我们现在有一个无错误的、优雅的解决方案来生成交易性能趋势报告。通过审慎地使用视图，我们发现了一种通过最小侵入性更改实现迭代性能改进的方法。这将给销售团队带来一些值得庆祝的事情！这也给我们提供了更多时间来考虑其他生成报告的方法。
- en: Rethinking reporting architecture
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新思考报告架构
- en: After deploying a new version of the web portal that generates the performance
    report containing your view changes, you begin wondering what else can be done
    to improve report generation performance. It strikes you that, for a particular
    time interval, the report is immutable. The computed PnL trend for a particular
    hour never changes once computed. Although the report is immutable, it is needlessly
    being recomputed each time a client requests the report. Given this line of thinking,
    you wonder how difficult it is to generate a new report each hour as new execution
    data becomes available. On-the-fly, order and execution events can be transformed
    as they are created into the inputs that are required for the client performance
    trend report. With a pregenerated report, the web portal performance issues should
    completely disappear because the responsibility of report generation no longer
    belongs to the web portal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署了一个包含您视图更改的性能报告的新版本网站门户之后，您开始思考还能做些什么来提高报告生成性能。您突然想到，对于特定的时间间隔，报告是不可变的。对于特定小时的计算PnL趋势一旦计算出来就永远不会改变。尽管报告是不可变的，但它每次客户端请求报告时都会被无谓地重新计算。根据这种思考方式，您想知道当新的执行数据可用时，每小时生成一份新报告有多困难。在创建时，订单和执行事件可以即时转换为客户端性能趋势报告所需的输入。有了预先生成的报告，网站门户的性能问题应该完全消失，因为报告生成的责任不再属于网站门户。
- en: 'This new report generation strategy leads us to explore a new design paradigm,
    called event sourcing. Event sourcing describes an architectural approach to designing
    systems that relies on processing events over time instead of relying on a model
    of the current state to answer different questions. The reporting system that
    we worked on performs significant work to identify the subset of orders that executed
    because current state rather than events is stored. Imagine that, instead of working
    with data, such as `Order` and `Execution`, we instead worked with events that
    represent things that happened in the system over time. One relevant event to
    report could be the `OrderExecuted` event that can be modeled, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的报告生成策略引导我们探索一个新的设计范式，称为事件源。事件源描述了一种设计系统的架构方法，它依赖于处理随时间推移的事件，而不是依赖于当前状态模型来回答不同的问题。我们工作的报告系统为了识别执行订单的子集而进行了大量工作，因为当前状态而不是事件被存储。想象一下，如果我们不是与数据，如`Order`和`Execution`，而是与代表系统随时间发生的事情的事件一起工作。一个相关的报告事件可以是`OrderExecuted`事件，可以按以下方式建模：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This event describes something that happened instead of representing a snapshot
    of current state. To extend this example, imagine if `Order` also included an
    optional `Price` to denote execution price:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件描述了发生的事情，而不是表示当前状态的快照。为了扩展这个例子，想象一下如果`Order`还包括一个可选的`Price`来表示执行价格：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If this data model is mapped to a relational database, `executionPrice` would
    be a nullable database value that is overwritten when an execution occurs. When
    the domain model only reflects the current state, then immutability is lost. As
    a functional programmer, this statement should concern you because you understand
    the reasoning capabilities that immutability provides. Storing only the current
    state of data may also lead to excessively large objects that are difficult to
    program with. For example, how would you represent that an `Order` was canceled?
    With the current approach, the most expedient method is to add a Boolean flag
    named `isCanceled`. Over time, as your system's requirements become more complicated,
    the `Order` object will grow and you will track more characteristics about the
    current state. This means that loading a set of `Order` objects into memory from
    a database will grow more unwieldy due to growing memory requirements. This is
    a dilemma that you likely have experienced if you have extensive **Object Relational
    Mapping** (**ORM**) experience.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将此数据模型映射到关系数据库，`executionPrice`将是一个可空数据库值，在执行发生时被覆盖。当领域模型仅反映当前状态时，不可变性就会丢失。作为一个函数式程序员，这个声明应该让你感到担忧，因为你理解不可变性提供的推理能力。仅存储数据的当前状态也可能导致过大的对象，难以编程。例如，你将如何表示一个`Order`被取消？按照当前的方法，最快捷的方法是添加一个名为`isCanceled`的布尔标志。随着时间的推移，随着你系统需求的变得更加复杂，`Order`对象将增长，你将跟踪更多关于当前状态的特征。这意味着从数据库中加载一系列`Order`对象到内存中将会变得更加难以控制，因为内存需求不断增长。如果你有丰富的**对象关系映射**（**ORM**）经验，你很可能已经经历过这种困境。
- en: To avoid bloating `Order`, you may try to deconstruct the concept of an order
    to support multiple use cases. For example, if you are only interested in executed
    orders, the model may change the `executionPrice` datatype from `Option[Price]`
    to `Price`, and you may no longer require the canceled Boolean flag because, by
    definition, an executed order could not have been canceled.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`Order`膨胀，你可能尝试分解订单的概念以支持多个用例。例如，如果你只对已执行的订单感兴趣，模型可能会将`executionPrice`数据类型从`Option[Price]`改为`Price`，你可能也不再需要取消的布尔标志，因为根据定义，已执行的订单不可能被取消。
- en: 'Identifying multiple definitions or representations for what you once thought
    was a single concept is an important step toward addressing the shortcomings that
    we walked through. Extending this approach, we come back to the topic of event
    sourcing. We can replay a set of events to build `OrderExecuted`. Let''s slightly
    modify the events emitted from the order book to look like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出曾经认为是一个单一概念的多重定义或表示，是解决我们所经历的不足的重要步骤。扩展这一方法，我们回到了事件源的话题。我们可以回放一系列事件来构建`OrderExecuted`。让我们稍微修改订单簿发出的以下事件：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If all `OrderBookEvents` were persisted (for example, to disk), it is then possible
    to write a program that reads all the events and constructs a set of `ExecutedOrders` by
    correlating `BuyOrderSubmitted` and `SellOrderSubmitted` events with `OrderExecuted`
    events. An advantage that we see with this approach is that, over time, we are
    able to ask new questions about what happened in our system and then easily answer
    them by reading the events. In contrast, if a model built on the current state
    did not include executions when it was first designed, it is impossible to retroactively
    answer the question, "Which orders executed last week?"
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有`OrderBookEvents`都被持久化（例如，存储到磁盘），那么就可以编写一个程序来读取所有事件，并通过将`BuyOrderSubmitted`和`SellOrderSubmitted`事件与`OrderExecuted`事件相关联来构建一组`ExecutedOrders`。我们注意到这种方法的一个优点是，随着时间的推移，我们能够提出关于系统发生的新问题，然后通过读取事件轻松回答它们。相比之下，如果一个基于当前状态的模型在最初设计时没有包括执行，那么就
    impossible to retroactively answer the question, "Which orders executed last week?"（无法事后回答“上周哪些订单被执行了？”）。
- en: Our new idea is exciting, and it has the potential to yield great improvements.
    However, it comes with a set of challenges. The main difference with the previous
    section is that our new use case does not load the `Order` and `Execution` collections
    in memory from a data store. Instead, we are planning to process the incoming `OrderBookEvent`
    as it is generated by the order book. Conceptually, this approach still involves
    processing a sequence of data. However, with the previous approach, the entire
    data set existed prior to beginning any transformations. Processing events on-the-fly
    requires designing software that handles data that has not yet been generated.
    Clearly, neither eager collections nor views are a good tool for our new system.
    Luckily, the standard Scala library provides us with the right abstraction: `Stream`.
    Let's take a closer look at this new collection type to better understand how `Stream`
    can help us implement an event sourcing approach to the client performance reporting
    architecture.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新想法令人兴奋，并且有可能带来巨大的改进。然而，它也带来了一系列挑战。与上一节的主要区别在于，我们新的用例不是从数据存储中加载`Order`和`Execution`集合到内存中。相反，我们计划处理由订单簿生成的`OrderBookEvent`。从概念上讲，这种方法仍然涉及处理数据序列。然而，在先前的方法中，整个数据集在开始任何转换之前就已经存在。即时处理事件需要设计处理尚未生成的数据的软件。显然，无论是急切集合还是视图都不是我们新系统的理想工具。幸运的是，标准的Scala库为我们提供了正确的抽象：`Stream`。让我们更仔细地看看这种新的集合类型，以更好地理解`Stream`如何帮助我们实现客户端性能报告架构的事件源方法。
- en: An overview of Stream
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stream概述
- en: A stream can be seen as a mix between a list and a view. Like a view, it is
    lazily evaluated and transformations are applied only when its elements are accessed
    or collected. Like a `List`, the elements of a `Stream` are only evaluated once.
    A `Stream` is sometimes described as an unrealized `List`, meaning that it is
    essentially a `List` that has not yet been fully evaluated, or realized.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Stream可以看作是列表和视图的混合体。像视图一样，它是延迟评估的，并且只有在访问或收集其元素时才应用转换。像`List`一样，`Stream`的元素只被评估一次。`Stream`有时被描述为未实现的`List`，这意味着它本质上是一个尚未完全评估或实现的`List`。
- en: 'Where a `List` can be constructed with the cons (`::`) operator, a `Stream`
    can be similarly constructed with its own operator:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`可以用cons（`::`）运算符构建，`Stream`也可以用其自己的运算符类似地构建：'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The syntax to create a `Stream` is close to the one to create a `List`. One
    difference is the returned value. Where a `List` is immediately evaluated, a `Stream`
    is not. Only the first element (`"January"`) is computed; the remaining values
    are still unknown (and denoted by a`?` character).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Stream`的语法与创建`List`的语法相似。一个区别是返回值。`List`是立即评估的，而`Stream`不是。只有第一个元素（`"January"`）被计算；其余的值仍然是未知的（用`?`字符表示）。
- en: 'Let''s observe what happens when we access part of the stream:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察当我们访问流的一部分时会发生什么：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We forced the evaluation of the first two elements of the `Stream` by turning
    it into a `List` (see the following sidebar). The first two months are printed.
    We then display the value of `months` to discover that the second element (`"February"`)
    is now computed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将其转换为`List`（见下文侧边栏）来强制评估`Stream`的前两个元素。前两个月的数据被打印出来。然后我们显示`months`的值，发现第二个元素（`"February"`）现在已经被计算。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the preceding example, `toList` is the call that forces the evaluation of
    the `Stream`. `take(2)` is a lazily applied transformer that also returns an unevaluated `Stream`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`toList` 是强制评估 `Stream` 的调用。`take(2)` 是一个惰性应用的转换器，它也返回一个未评估的 `Stream`：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To highlight the evaluation characteristics of a `Stream`, we look at another
    example of creating a `Stream`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出 `Stream` 的评估特性，我们来看另一个创建 `Stream` 的示例：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This short snippet defines a function that creates a `Stream` of powers of
    2\. It is an infinite `Stream` initialized with the first value 1 and the tail
    is defined as another `Stream`. We added a `println` statement to allow us to
    study the evaluation of the elements:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的代码定义了一个函数，它创建一个包含 2 的幂的 `Stream`。它是一个无限 `Stream`，以第一个值 1 初始化，尾部定义为另一个 `Stream`。我们添加了一个
    `println` 语句，以便我们可以研究元素的评估：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how the first eight elements are only evaluated when we perform the first
    conversion to a `List`. In the second call, only elements 9 and 10 are computed;
    the first eight are already realized and are part of the `Stream`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前八个元素只有在我们将它们转换为 `List` 的第一次转换时才会被评估。在第二次调用中，只有第 9 和第 10 个元素被计算；前八个已经实现，并且是
    `Stream` 的一部分。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Based on the previous example, you may wonder if a `Stream` is an immutable
    data structure. Its fully qualified name is `scala.collection.immutable.Stream`,
    so this should give you a good hint. It is true that accessing the `Stream` and
    realizing some of its elements causes a modification of the `Stream`. However,
    the data structure is still considered immutable. The values it contains never
    change once assigned; even before being evaluated, the values exist and have a
    definition in the `Stream`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的示例，你可能想知道 `Stream` 是否是一个不可变的数据结构。它的完全限定名是 `scala.collection.immutable.Stream`，所以这应该给你一个很好的提示。确实，访问
    `Stream` 和实现其一些元素会导致 `Stream` 的修改。然而，这个数据结构仍然被认为是不可变的。它包含的值一旦分配就不会改变；甚至在评估之前，这些值就存在，并在
    `Stream` 中有定义。
- en: 'The previous example shows an interesting property of `Stream`: it is possible
    to create a virtually infinite `Stream`. The `Stream` that is created by `powerOf2`
    is unbounded and it is always possible to create one more element thanks to our `next`
    method. Another useful technique is the creation of recursive streams. A recursive `Stream`
    refers to itself in its definition. Let''s adapt our previous example. Instead
    of returning the complete sequence of powers of 2, we will allow the caller to
    set a starting value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了 `Stream` 的一个有趣特性：可以创建一个几乎无限的 `Stream`。由 `powerOf2` 创建的 `Stream` 是无界的，并且由于我们的
    `next` 方法，总是可以创建一个额外的元素。另一种有用的技术是递归流的创建。递归 `Stream` 在其定义中引用自身。让我们调整我们之前的示例。我们不会返回完整的
    2 的幂序列，而是允许调用者设置一个起始值：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `math.pow` is used to compute *2^n*. Note that we calculate the first value
    and define the rest of the `Stream` as `powerOf2(n+1)`, that is, the next power
    of 2:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `math.pow` 来计算 `2^n`。注意，我们计算第一个值，并将其余的 `Stream` 定义为 `powerOf2(n+1)`，即下一个
    2 的幂：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The companion object of `Stream` provides several factory methods to instantiate
    a `Stream`. Let''s look at a few of them:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 的伴随对象提供了几个工厂方法来实例化一个 `Stream`。让我们看看其中的一些：'
- en: '`Stream.apply`: This allows us to create a `Stream` for a finite sequence of
    values:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.apply`: 这允许我们为有限序列的值创建一个 `Stream`：'
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Stream.fill[A](n: Int)(a: => A)`: This produces a `Stream` containing the
    element `a`, `n` times:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.fill[A](n: Int)(a: => A)`: 这会产生一个包含元素 `a`，重复 `n` 次的 `Stream`：'
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Stream.from(start: Int)`: This creates an increasing sequence of integers
    beginning with `start`:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.from(start: Int)`: 这创建了一个以 `start` 开始的递增整数序列：'
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We invite you to look at the other methods that are available on the companion
    object. Note that a `Stream` can also be constructed from a `List` directly, as
    follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们邀请您查看伴随对象上可用的其他方法。注意，`Stream` 也可以直接从 `List` 构建，如下所示：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The previous code may be misleading. Turning a `List` into a `Stream` does not
    spare the price of evaluating the whole `List` in memory. Similarly, if we were
    to apply transformations (such as `map` or `filter`) to the `List` before the
    call to `toStream`, we would be performing these computations on the entire `List`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可能具有误导性。将 `List` 转换为 `Stream` 并不会节省在内存中评估整个 `List` 的代价。同样，如果我们要在调用 `toStream`
    之前对 `List` 应用转换（如 `map` 或 `filter`），我们将在整个 `List` 上执行这些计算。
- en: 'Just like a `List`, you can pattern match on a `Stream`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `List` 一样，你可以在 `Stream` 上进行模式匹配，如下所示：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This pattern matching extracts the third element from the `s` stream. Pattern
    matching on a stream forces the realization of the elements required to evaluate
    the match expression. In the preceding case, the first three items are calculated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式匹配从`s`流中提取第三个元素。在流上执行模式匹配会强制实现评估匹配表达式所需的元素。在前面的例子中，前三个项目被计算。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To pattern match on an empty stream, you can use the `Stream.Empty` object.
    It is a singleton instance to represent an empty `Stream`. It works similarly
    to `Nil` for `List`. Note that the object `Stream` contains an `empty` method
    returning this singleton; however, pattern matching requires a stable identifier,
    and it cannot use calls to a method as a valid `case`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要在空流上进行模式匹配，你可以使用`Stream.Empty`对象。它是一个单例实例，用于表示空的`Stream`。它的工作方式与`List`中的`Nil`类似。请注意，`Stream`对象包含一个返回此单例的`empty`方法；然而，模式匹配需要一个稳定的标识符，并且不能使用方法调用作为有效的`case`。
- en: Transforming events
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件转换
- en: 'Returning to the reporting system, how can we apply the principles of event
    sourcing and leverage `Stream` to change how reports are generated? To compute
    `TradingPerformanceTrend` for a client, we need to compute PnL trend values for
    three time periods: each hour, each day, and each seven days. We can write a method
    with the following signature that gets us closer to identifying the PnL for each
    trend:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 回到报告系统，我们如何应用事件源原则并利用`Stream`来改变报告的生成方式？为了计算客户的`TradingPerformanceTrend`，我们需要计算三个时间段的PnL趋势值：每小时、每天和每七天。我们可以编写一个具有以下签名的函数，这使我们更接近于识别每个趋势的PnL：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The signature of `processPnl` accepts an `OrderBookEvent` and state in the
    form of `TradeState` to produce a new `TradeState` and, optionally, a `PnlEvent`.
    Let''s first inspect `PnlEvent` to understand the end result of this method before
    inspecting `TradeState`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`processPnl`的签名接受一个`OrderBookEvent`和以`TradeState`形式的状态，以生成一个新的`TradeState`和可选的`PnlEvent`。让我们首先检查`PnlEvent`，以了解此方法的结果，然后再检查`TradeState`：'
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We see that `PnlEvent` models an ADT that expresses when a client''s PnL increased
    or decreased. Using the past tense to name the event (for example, increased)
    makes it clear that this is a fact or a record of something that has completed.
    We have not yet looked at how `TradeState` is defined or the implementation of `processPnl`,
    but we can already infer the behavior by studying the emitted events. We display
    the definition of `TradeState`, which is needed to correlate submitted orders
    with executions, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`PnlEvent`模型了一个ADT，它表达了客户的PnL何时增加或减少。使用过去时来命名事件（例如，增加了）清楚地表明这是一个事实或已完成某事的记录。我们尚未查看`TradeState`的定义或`processPnl`的实现，但我们可以通过研究发出的事件来推断行为。我们显示`TradeState`的定义，这是将提交的订单与执行相关联所需的，如下所示：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we inspect the implementation of `processPnl` to view how `PnlEvents`
    are created, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`processPnl`的实现，以查看`PnlEvents`是如何创建的，如下所示：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This implementation shows that the `PnlEvent` is pattern matched to determine
    the event type, and this is handled accordingly. When an order is submitted, `TradeState`
    is updated to reflect that there is a new pending order that will be either canceled
    or executed. When an order is canceled, the pending order is removed from `TradeState`.
    When an execution occurs, the pending order is removed and, additionally, a `PnlEvent`
    is emitted after computing the trade PnL. The trade PnL compares the execution
    price to the pending order's original price.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现表明`PnlEvent`被模式匹配以确定事件类型，并相应地处理。当提交订单时，`TradeState`被更新以反映存在一个新挂起的订单，该订单将被取消或执行。当订单被取消时，挂起的订单从`TradeState`中移除。当发生执行时，挂起的订单被移除，并且，在计算交易PnL后，还会发出一个`PnlEvent`。交易PnL将执行价格与挂起订单的原始价格进行比较。
- en: '`PnlEvent` provides enough information to compute PnL trend performance for
    all three time periods (hour, day, and seven days) required by `TradingPerformanceTrend`.
    The transformation from `OrderBookEvent` to `PnlEvent` is side-effect-free, and
    the creation of a new event, instead of replacing current state, leads to an immutable
    model. In the light of these characteristics, `processPnl` is easily unit-testable
    and makes the intent explicit. By making the intent explicit, it is possible to
    communicate with less technical stakeholders about how the system works.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`PnlEvent` 提供了足够的信息来计算 `TradingPerformanceTrend` 所需的所有三个时间段（小时、天和七天）的盈亏趋势。从
    `OrderBookEvent` 到 `PnlEvent` 的转换是无副作用的，创建新事件而不是替换当前状态，导致不可变模型。鉴于这些特性，`processPnl`
    很容易进行单元测试，并使意图明确。通过使意图明确，可以与技术利益相关者之外的人沟通系统的工作方式。'
- en: 'Using `PnlEvent` as an input to a method that follows the analogous `(State,
    InputEvent) => (State, Option[OutputEvent])` signature, we can now compute hourly
    PnL trend, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PnlEvent` 作为遵循类似 `(State, InputEvent) => (State, Option[OutputEvent])` 签名的方法的输入，我们现在可以计算小时的盈亏趋势，如下所示：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This signature shows that, by maintaining state in `HourlyState`, it is possible
    to emit the `HourlyPnlTrendCalculated` event. The emitted event is defined, as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此签名表明，通过在 `HourlyState` 中维护状态，可以发出 `HourlyPnlTrendCalculated` 事件。发出的事件定义如下：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For a particular hour, client ID, and ticker, `HourlyPnlTrendCalculated` is
    a record of whether the last hour PnL is positive or negative. The `HourInstant` class
    is a value class with a companion object method that transforms an instant to
    the start of the hour:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的小时、客户端ID和股票代码，`HourlyPnlTrendCalculated` 记录了上一小时的盈亏（PnL）是正数还是负数。`HourInstant`
    类是一个值类，它有一个伴随对象方法，可以将一个瞬间转换为小时的开始：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s have a look at how `HourlyState` is defined to better understand the
    state that is needed to yield `HourlyPnlTrendCalculated`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `HourlyState` 的定义，以便更好地理解产生 `HourlyPnlTrendCalculated` 所需的状态：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For a `ClientId` and a `Ticker`, the PnL for the current hour is stored in `HourlyState`.
    Accumulating the PnL allows `processHourlyPnl` to determine the PnL trend at the
    end of an hour. We now inspect the implementation of `processHourlyPnl` to see
    how `PnlEvent` is transformed into `HourlyPnlTrendCalculated`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ClientId` 和 `Ticker`，当前小时的盈亏存储在 `HourlyState` 中。累积盈亏允许 `processHourlyPnl`
    在小时结束时确定盈亏趋势。我们现在检查 `processHourlyPnl` 的实现，以了解 `PnlEvent` 如何转换为 `HourlyPnlTrendCalculated`：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Handling an increased and decreased PnL follows the same flow. The inner-method
    named `processChange` handles the identical processing steps. The `processChange`
    determines whether or not to emit `HourlyPnlTrendCalculated` by comparing the `HourInstant`
    value that is added when an entry is first added to the state with the hour of
    the timestamp provided by the event. When the comparison shows the hour has changed,
    then the hourly PnL trend has been computed because the hour is completed. When
    the hour is unchanged, the provided PnL is added to the state's PnL to continue
    accumulating the hour's PnL.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 处理盈亏的增加和减少遵循相同的流程。内部方法 `processChange` 处理相同的处理步骤。`processChange` 通过比较首次添加到状态时的
    `HourInstant` 值和事件提供的时间戳的小时来决定是否发出 `HourlyPnlTrendCalculated`。当比较显示小时已更改时，则表示已计算了小时的盈亏趋势，因为小时已完成。当小时未更改时，提供的盈亏将添加到状态中的盈亏以继续累积小时的盈亏。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An obvious shortcoming of this approach is that, when a client or a ticker
    does not have any executed orders, it will not be possible to determine that the
    hour is completed. For simplicity, we are not treating time as a first-class event.
    However, you can imagine how it is possible to model the passing of time as an
    event that is a second input to `processHourlyPnl`. For example, the event might
    be the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显缺点是，当客户端或股票代码没有任何已执行订单时，将无法确定小时是否完成。为了简化，我们没有将时间视为一等事件。然而，你可以想象如何将时间的流逝建模为一个事件，它是
    `processHourlyPnl` 的第二个输入。例如，该事件可能是以下内容：
- en: '`case class HourElapsed(hour: HourInstant)`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`case class HourElapsed(hour: HourInstant)`'
- en: To use this event, we could change the signature of `processHourlyPnl` to receive
    an event argument that is of the `Either[HourElapsed, PnlEvent]` type. Scheduling `HourElapsed`
    on a timer enables us to modify the implementation of `processHourlyPnl` to emit
    `HourlyPnlTrendCalculated` as soon as the hour elapses instead of when a trade
    occurs in the next hour. This simple example shows how you can model time as an
    explicit part of the domain when you consider your system from an event sourcing
    point of view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此事件，我们可以将`processHourlyPnl`的签名更改为接收一个`Either[HourElapsed, PnlEvent]`类型的参数。在计时器上安排`HourElapsed`使我们能够修改`processHourlyPnl`的实现，以便在小时结束时立即发出`HourlyPnlTrendCalculated`，而不是在下一个小时内发生交易时发出。这个简单的例子展示了当你从事件源的角度考虑系统时，如何将时间作为域的显式部分进行建模。
- en: It is straightforward to imagine writing analogous methods that emit events
    for the daily and seven day PnL trend events, and then a method that awaits all
    three PnL trend events to produce the `TradingPerformanceTrendGenerated` event.
    The final step is to write a side-effecting method that persists `TradingPerformanceTrend`
    so that it can be read by the web portal. At this point, we have a collection
    of methods that performs transformations on events, but they are not yet wired
    together cohesively. Next, we take a look at how to create a pipeline to transform
    events.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 想象编写类似的方法来发出每日和七日PnL趋势事件，然后编写一个等待所有三个PnL趋势事件以产生`TradingPerformanceTrendGenerated`事件的函数。最后一步是编写一个产生副作用的方法，将`TradingPerformanceTrend`持久化，以便它可以被网络门户读取。到此为止，我们有一系列执行事件转换的方法，但它们还没有紧密地连接在一起。接下来，我们将探讨如何创建一个转换事件的管道。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, in this case study, we do not actually calculate a PnL. Performing
    a real PnL calculation would involve more complicated algorithms and would force
    us to introduce more domain concepts. We opted for a simpler approach with a report
    that is closer to an exposure report. This allows us to focus on the code and
    the programming practices that we want to illustrate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本案例研究中，我们实际上并没有计算PnL。进行真实的PnL计算将涉及更复杂的算法，并迫使我们引入更多的领域概念。我们选择了更简单的方法，使用一个更接近敞口报告的报告。这使我们能够专注于我们想要展示的代码和编程实践。
- en: Building the event sourcing pipeline
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建事件源管道
- en: We use the term pipeline to refer to an arranged set of transformations that
    may require multiple steps to yield a desired end result. This term brings to
    mind an image of a set of pipes spanning multiple directions with twists and turns
    along the way. Our goal is to write a program that receives `PnlEvents` traits
    and prints the `HourlyPnlTrendCalculated` events to a standard output. In a true
    production environment, you can imagine replacing printing to standard output
    with writing to a persistent data store. In either case, we are building a pipeline
    that performs a set of referentially transparent transformations and concludes
    with a side-effect.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“pipeline”一词来指代一组经过安排的转换，这些转换可能需要多个步骤才能产生期望的最终结果。这个术语让人联想到一组管道，它们跨越多个方向，途中还有转弯。我们的目标是编写一个程序，该程序接收`PnlEvents`特性并将`HourlyPnlTrendCalculated`事件打印到标准输出。在一个真正的生产环境中，你可以想象用写入持久数据存储来替换打印到标准输出。在两种情况下，我们都在构建一个执行一系列引用透明转换并最终产生副作用的管道。
- en: 'The pipeline must accumulate the intermediate state of each transformation
    as new events are processed. In the functional programming paradigm, accumulation
    is often associated with a `foldLeft` operation. Let''s look at a toy example
    that sums a list of integers to better understand accumulation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 管道必须累积每个转换的中间状态，因为处理新事件。在函数式编程范式中，累积通常与`foldLeft`操作相关联。让我们看看一个玩具示例，该示例将整数列表相加，以更好地理解累积：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we see `foldLeft` applied to compute the sum of a list of integers by
    providing an initial sum value of zero and currying a function to add the current
    element to the accumulated sum. The `acc` value is an often used shorthand for
    'accumulator'. In this example, the accumulator and the list elements share the
    same data type, integer. This is merely a coincidence and is not a requirement
    for `foldLeft` operations. This implies that the accumulator can be a different
    type than the collection element.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`foldLeft`被应用于通过提供一个初始总和为零并currying一个函数来添加当前元素到累积总和来计算整数列表的总和。`acc`值是“累积器”的常用缩写。在这个例子中，累积器和列表元素具有相同的数据类型，整数。这只是一个巧合，并不是`foldLeft`操作的要求。这意味着累积器可以与集合元素具有不同的类型。
- en: 'We can use `foldLeft` as the basis of our event sourcing pipeline to support
    processing a list of `OrderBookEvents` while accumulating intermediate state.
    From the implementation of the two processing methods, we saw the need to maintain `TradeState`
    and `HourlyState`. We define `PipelineState` to encapsulate the required state,
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `foldLeft` 作为事件源管道的基础，以支持在累积中间状态的同时处理 `OrderBookEvents` 列表。从两个处理方法的实现中，我们看到了维护
    `TradeState` 和 `HourlyState` 的需求。我们定义 `PipelineState` 来封装所需的状态，如下所示：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`PipelineState` serves as the accumulator when folding over the `OrderBookEvent`,
    allowing us to store the intermediate state for both of the transformation methods.
    Now, we are ready to define the signature of our pipeline:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`PipelineState` 在折叠 `OrderBookEvent` 时作为累加器使用，使我们能够存储两种转换方法的中间状态。现在，我们准备定义管道的签名：'
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `pipeline` accepts the initial state, a side-effecting function to be invoked
    when an `HourlyPnlTrendCalculated` event is generated, and a set of `OrderBookEvents` to
    source. The return value of the pipeline is the state of the pipeline once the
    events are processed. Let''s look at how we can leverage `foldLeft` to implement `pipeline`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline` 接受初始状态，一个在生成 `HourlyPnlTrendCalculated` 事件时被调用的副作用函数，以及一组 `OrderBookEvents`
    作为数据源。管道的返回值是事件处理后的管道状态。让我们看看我们如何利用 `foldLeft` 来实现 `pipeline`：'
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The implementation of `pipeline` is based on folding over the provided events
    using the provided `PipelineState` as a starting point for accumulation. The curried
    function provided to `foldLeft` is where the wiring of transformations takes place.
    Stitching together the two transformation methods and the side-effecting event
    handler requires handling several different scenarios. Let's walk through each
    of the possible cases to better understand how the pipeline works. The `processPnl`
    is invoked to produce a new `TradeState` and optionally yield a `PnlEvent`. If
    no `PnlEvent` is generated, then `processHourlyPnl` is not invoked and the previous `HourlyState`
    is returned.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline` 的实现基于使用提供的 `PipelineState` 作为累加起始点的提供事件折叠。提供给 `foldLeft` 的柯里化函数是转换连接的地方。将两个转换方法和副作用事件处理器拼接在一起需要处理几个不同的场景。让我们逐一分析每种可能的案例，以更好地理解管道的工作原理。`processPnl`
    被调用以生成新的 `TradeState` 并可选地产生一个 `PnlEvent`。如果没有生成 `PnlEvent`，则不调用 `processHourlyPnl`
    并返回之前的 `HourlyState`。'
- en: If a `PnlEvent` is generated, then `processHourlyPnl` is evaluated to determine
    whether an `HourlyPnlTrendCalculated` is created. When `HourlyPnlTrendCalculated`
    is generated, then the side-effecting `HourlyPnlTrendCalculated` event handler
    is invoked and the new `HourlyState` is returned. If no `HourlyPnlTrendCalculated`
    is generated, then the existing `HourlyState` is returned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成了一个 `PnlEvent`，则 `processHourlyPnl` 被评估以确定是否创建了 `HourlyPnlTrendCalculated`。当
    `HourlyPnlTrendCalculated` 被生成时，则调用副作用 `HourlyPnlTrendCalculated` 事件处理器并返回新的 `HourlyState`。如果没有生成
    `HourlyPnlTrendCalculated`，则返回现有的 `HourlyState`。
- en: 'We construct a simple example to prove that the pipeline works as intended,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建一个简单的示例来证明管道按预期工作，如下所示：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the start of the hour, a buy order is submitted for the stock, FOO. Within
    the hour, the buy order is executed at a price lower than the buying price, indicating
    the trade was profitable. As we know, the current implementation relies on executions
    in the subsequent hour in order to produce `HourlyPnlTrendCalculated`.  To create
    this event, a second buy order is submitted at the start of the second hour. Running
    this snippet produces a single `HourlyPnlTrendCalculated` event that is written
    to standard output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在小时的开始，提交了一个针对股票 FOO 的买入订单。在小时内，以低于买入价的价格执行了买入订单，这表明交易是盈利的。正如我们所知，当前实现依赖于下一小时的执行来生成
    `HourlyPnlTrendCalculated`。为了创建此事件，在第二小时的开始提交了第二个买入订单。运行此代码片段会产生一个写入标准输出的单个 `HourlyPnlTrendCalculated`
    事件：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Although the wiring together of transformations is somewhat involved, we managed
    to build a simple event sourcing pipeline using only the Scala standard library
    and our existing knowledge of Scala collections. This example demonstrated the
    power of `foldLeft` to help build an event sourcing pipeline. Using this implementation,
    we can write a fully-featured program that is able to write a pregenerated version
    of the performance report to a persistent data store that can be read by the web
    portal. This new design allows us to shift the burden of report generation outside
    the web portal's responsibilities, allowing the web portal to provide a responsive
    user experience. Another benefit of this new approach is how it puts a domain-oriented
    language at the center of the design. All our events use business terms and focus
    on modeling domain concepts, making it easier for developers and stakeholders
    to communicate with each other.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将转换连接起来有些复杂，但我们设法仅使用Scala标准库和我们对Scala集合的现有知识构建了一个简单的事件源管道。这个例子展示了`foldLeft`在构建事件源管道方面的强大功能。使用此实现，我们可以编写一个功能齐全的程序，能够将预先生成的性能报告写入可以被网络门户读取的持久数据存储。这种新的设计允许我们将报告生成的负担从网络门户的责任中移除，从而使网络门户能够提供响应式的用户体验。这种新方法的好处之一是它将面向领域的语言置于设计的中心。我们所有的事件都使用业务术语，并专注于建模领域概念，这使得开发者和利益相关者之间的沟通更加容易。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be wondering about a data structure that shares some characteristics
    of `Stream` that we did not yet mention: `Iterator`. As the name implies, `Iterator`
    provides facilities to iterate over a sequence of data. Its simplified definition
    boils down to the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一个具有`Stream`的一些特征但我们尚未提到的数据结构：`Iterator`。正如其名所示，`Iterator`提供了遍历数据序列的设施。其简化的定义可以归结为以下内容：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Like `Stream`, an `Iterator` is able to avoid loading an entire dataset into
    memory, which enables programs to be written with constant memory usage. Unlike `Stream`,
    an `Iterator` is mutable and intended for only a single iteration over a collection
    (it extends the `TraversableOnce` trait). It should be noted that, according to
    the standard library documentation, one should never use an iterator after calling
    a method on it. For example, calling `size` on an `Iterator` returns the size
    of the sequence, but it also consumes the entire sequence and renders the instance
    of `Iterator` useless. The only exceptions to this rule are `next` and `hasNext`.
    These properties lead to software that is difficult to reason with, which is the
    antithesis of what we strive for as functional programmers. For this reason, we
    omit an in-depth discussion about `Iterator`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Stream`类似，`Iterator`能够避免将整个数据集加载到内存中，这使得程序可以以恒定的内存使用量编写。与`Stream`不同，`Iterator`是可变的，并且仅用于对集合进行单次迭代（它扩展了`TraversableOnce`特质）。需要注意的是，根据标准库文档，在调用其方法后不应再使用迭代器。例如，对`Iterator`调用`size`会返回序列的大小，但它也会消耗整个序列，使`Iterator`实例变得无用。此规则的唯一例外是`next`和`hasNext`。这些属性导致软件难以推理，这与我们作为函数式程序员所追求的目标相反。因此，我们省略了对`Iterator`的深入讨论。
- en: We encourage you to further explore event sourcing by reading the documentation
    of the Event Store database at [http://docs.geteventstore.com/introduction/event-sourcing-basics/](http://docs.geteventstore.com/introduction/event-sourcing-basics/).
    Event Store is a database that is developed around the concept of event sourcing.
    Event Store was created by Greg Young, a notable writer on the topic of event
    sourcing. While enriching your understanding about event sourcing, reflect on
    when you believe it is appropriate to apply the event sourcing technique. For
    CRUD applications that have simple behavior, event sourcing may not be a worthwhile
    time investment. When you model more complex behaviors or consider scenarios involving
    strict performance and scaling requirements, the time investment for event sourcing
    may become justified. For example, like we saw with performance trend reporting,
    considering the performance challenges from the event sourcing paradigm exposed
    an entirely different way of approaching the design.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您通过阅读[Event Store数据库的文档](http://docs.geteventstore.com/introduction/event-sourcing-basics/)来进一步探索事件溯源。Event
    Store是一个围绕事件溯源概念开发的数据库。Event Store是由事件溯源领域的知名作家Greg Young创建的。在丰富您对事件溯源的理解的同时，思考一下您认为何时应用事件溯源技术是合适的。对于具有简单行为的CRUD应用程序，事件溯源可能不是值得投入时间的。当您建模更复杂的行为或考虑涉及严格性能和扩展要求的场景时，事件溯源的时间投入可能变得合理。例如，就像我们在性能趋势报告中看到的那样，从事件溯源范式暴露的性能挑战揭示了一种完全不同的设计方法。
- en: 'As you continue exploring the world of stream processing, you will discover
    that you wish to construct more complex transformations than our event sourcing
    pipeline example. To continue digging deeper into the the topic of stream processing,
    we suggest researching two relevant libraries: `akka streams` and `functional
    streams` (formerly, `scalaz-stream`). These libraries provide tools to build more
    sophisticated transformation pipelines using different abstractions than `Stream`.
    In combination with learning about Event Store, you will deepen your understanding
    of how event sourcing ties in with stream processing.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当您继续探索流处理的世界时，您会发现您希望构建比我们的事件溯源管道示例更复杂的转换。为了继续深入研究流处理的话题，我们建议研究两个相关的库：`akka
    streams`和`functional streams`（以前称为`scalaz-stream`）。这些库提供了使用不同于`Stream`的不同抽象构建更复杂转换管道的工具。结合学习Event
    Store，您将更深入地了解事件溯源如何与流处理相结合。
- en: Streaming Markov chains
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式马尔可夫链
- en: With the simple program at the end of the previous section, we demonstrated
    that we can wire together a pipeline of transformations operating on events. As
    a well-intentioned engineer, you wish to develop automated tests that prove the
    pipeline works as intended. One approach is to add a sample of historical production
    data into the repository to build tests. This is often a good choice, but you
    are concerned that the sample is not large enough to represent a broad number
    of scenarios. Another option is to write a generator of events that can create
    production-like data. This approach requires more up-front effort, but it yields
    a more dynamic way to exercise the pipeline.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的末尾的简单程序中，我们展示了我们可以将操作事件的转换管道连接起来。作为一个有良好意图的工程师，您希望开发自动测试来证明管道按预期工作。一种方法是将历史生产数据样本添加到存储库中构建测试。这通常是一个不错的选择，但您担心样本不足以代表广泛的场景。另一种选择是编写一个可以创建类似生产数据的生成器。这种方法需要更多的前期努力，但它提供了一种更动态的方式来测试管道。
- en: A recent lunchtime conversation with Dave about Markov chains sparked the thought
    about testing the event sourcing pipeline with generated data. Dave described
    how a Markov chain is a statistical model of state transitions that only relies
    on the current state to determine the next state. Dave is representing the states
    of the stock market as a Markov chain, allowing him to build trading strategies
    based on whether or not he perceives the stock market to be in an upswing, downswing,
    or steady state. After reading through the Markov chain Wikipedia page, you envision
    writing an event generator based on a Markov chain.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与Dave关于马尔可夫链的最近午餐时间对话激发了对使用生成数据进行事件溯源管道测试的想法。Dave描述了马尔可夫链是一个仅依赖于当前状态来确定下一个状态的统计状态转换模型。Dave将股票市场的状态表示为马尔可夫链，使他能够根据他是否认为股票市场处于上升趋势、下降趋势或稳定状态来构建交易策略。在阅读了马尔可夫链的维基百科页面后，您设想编写一个基于马尔可夫链的事件生成器。
- en: 'Our end goal is to be able to generate an infinite number of `OrderBookEvent`s that
    follows production-like patterns. For example, we know from previous experience
    that proportionally there are often more cancelations than executions, particularly
    during volatile markets. The event generator should be able to represent different
    probabilities of events occurring. As a Markov chain only depends on its current
    state to identify its next state, a `Stream` is a natural fit because we only
    need to inspect the current element to determine the next element. For our representation
    of a Markov chain, we need to identify the chance of transitioning from the current
    state to any of the other possible states. The following table illustrates one
    possible set of probabilities:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是能够生成无限数量的遵循生产模式样式的`OrderBookEvent`。例如，根据以往的经验，取消订单通常比执行订单多，尤其是在波动较大的市场中。事件生成器应该能够表示事件发生的不同概率。由于马尔可夫链只依赖于其当前状态来识别其下一个状态，因此`Stream`是一个自然的选择，因为我们只需要检查当前元素来确定下一个元素。对于我们对马尔可夫链的表示，我们需要确定从当前状态转换到任何其他可能状态的几率。以下表格展示了一组可能的概率集：
- en: '| **Current state** | **Chance of buy** | **Chance of sell** | **Chance of
    execution** | **Chance of cancel** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **当前状态** | **购买几率** | **销售几率** | **执行几率** | **取消几率** |'
- en: '| `BuyOrderSubmitted` | 10% | 15% | 40% | 40% |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `BuyOrderSubmitted` | 10% | 15% | 40% | 40% |'
- en: '| `SellOrderSubmitted` | 25% | 10% | 35% | 25% |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `SellOrderSubmitted` | 25% | 10% | 35% | 25% |'
- en: '| `OrderCanceled` | 60% | 50% | 40% | 10% |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `OrderCanceled` | 60% | 50% | 40% | 10% |'
- en: '| `OrderExecuted` | 30% | 30% | 55% | 30% |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `OrderExecuted` | 30% | 30% | 55% | 30% |'
- en: This table defines the likelihood of receiving an `OrderBookEvent` given the
    current `OrderBookEvent`. For example, given that a sell order was submitted,
    there is a 10% chance of seeing a second sell order next and a 35% chance that
    an execution occurs next. We can develop state transition probabilities according
    to the market conditions that we wish to simulate in the pipeline.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格定义了在当前`OrderBookEvent`的情况下接收`OrderBookEvent`的可能性。例如，给定一个销售订单已提交，下一个出现第二个销售订单的概率为10%，下一个发生执行的概率为35%。我们可以根据我们希望在管道中模拟的市场条件开发状态转换概率。
- en: 'We can model the transitions using the following domain:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下领域来模拟转换：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this domain, `Step` is an ADT that models the possible states. For a given `Step`,
    we will associate `StepTransitionWeights` to define the probability of transitioning
    to different states based on provided weightings. `GeneratedWeight` is a value
    class that defines the weight generated for the current `Step`. We will use `GeneratedWeight`
    to drive the transition from one `Step` to the next `Step`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域内，`Step`是一个ADT，它模拟了可能的状态。对于给定的`Step`，我们将关联`StepTransitionWeights`来定义基于提供的权重转换到不同状态的概率。`GeneratedWeight`是一个值类，它定义了当前`Step`生成的权重。我们将使用`GeneratedWeight`来驱动从`Step`到下一个`Step`的转换。
- en: 'Our next step, so-to-speak, is to make use of our domain to generate events
    according to probabilities that we define. To make use of `Step`, we define a
    representation of the Markov chain state that is required, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要做的是利用我们的领域，根据我们定义的概率生成事件。为了使用`Step`，我们定义了所需的马尔可夫链状态的表示，如下所示：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The Markov chain requires knowledge of the current state, which is represented
    by `step`. Additionally, we put a twist on the Markov chain by maintaining the
    set of orders that are submitted that are neither canceled nor executed in `pendingOrders`.
    This additional state is needed for two reasons. First, generating cancel and
    execution events requires linking to a known order ID. Second, we constrain our
    representation of a Markov chain by requiring at least one pending order to exist
    before creating a cancel or an execution. If there are no pending orders, it is
    invalid to transition to a state that generates either `OrderCanceled` or `OrderExecuted`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链需要了解当前状态，这由`step`表示。此外，我们对马尔可夫链进行了一些调整，通过维护在`pendingOrders`中提交的既未取消也未执行的订单集合。这个额外的状态有两个原因。首先，生成取消和执行事件需要链接到一个已知的订单ID。其次，我们通过要求在创建取消或执行之前至少存在一个挂起的订单来限制我们对马尔可夫链的表示。如果没有挂起的订单，转换到生成`OrderCanceled`或`OrderExecuted`的状态是不合法的。
- en: 'Using `State`, we can write a method with the following signature to manage
    transitions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`State`，我们可以编写一个具有以下签名的方法来管理转换：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Given a way to generate a weight from the current `StepTransitionWeights`, a
    mapping of `Step` to `StepTransitionWeights`, and the current `State`, we are
    able to produce a new `State` and an `OrderBookEvent`. For brevity, we omit the
    implementation of `nextState` because we want to focus most intently on stream
    processing. From the signature, we have enough insight to apply the method, but
    we encourage you to inspect the repository to fill in any blanks in your understanding.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 给定从当前`StepTransitionWeights`生成权重的方法、`Step`到`StepTransitionWeights`的映射以及当前`State`，我们能够生成一个新的`State`和一个`OrderBookEvent`。为了简洁，我们省略了`nextState`的实现，因为我们想最专注地关注流处理。从签名中，我们有足够的洞察力来应用该方法，但我们鼓励你检查存储库以填补你理解中的任何空白。
- en: 'The `nextState` method is the driver of state transitions in our Markov chain
    representation. We can now generate an infinite `Stream` of `OrderBookEvent`s based
    on transition probabilities using the convenience `Stream` method, `iterate`.
    From the Scala documentation, `iterate` produces an infinite stream by repeatedly
    applying a function to the start value. Let''s see how we can use `iterate`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextState`方法是我们在马尔可夫链表示中状态转换的驱动程序。现在我们可以使用便利的`Stream`方法`iterate`根据转换概率生成无限`Stream`的`OrderBookEvent`。根据Scala文档，`iterate`通过重复应用函数到起始值来产生无限流。让我们看看我们如何使用`iterate`：'
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This snippet creates a Markov chain to generate various `OrderBookEvent`s by
    providing a mapping of `Step` to `StepTransitionWeights` as the basis to invoke `State.nextState`.
    `State.nextState` is partially applied, leaving the current state unapplied. The `next`
    function has the `State => (State, OrderBookEvent)` signature. With the necessary
    scaffolding in place, `Stream.iterate` is used to generate an infinite sequence
    of multiple `OrderBookEvent`s by invoking `next`. Similar to `foldLeft`, we provide
    an initial value to begin the `initialBuy` iteration, which is defined as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段创建了一个马尔可夫链，通过提供`Step`到`StepTransitionWeights`的映射作为调用`State.nextState`的基础来生成各种`OrderBookEvent`。`State.nextState`是部分应用的，当前状态未被应用。`next`函数具有`State
    => (State, OrderBookEvent)`签名。在必要的框架到位后，使用`Stream.iterate`通过调用`next`生成无限序列的多个`OrderBookEvent`。类似于`foldLeft`，我们提供一个初始值以开始`initialBuy`迭代，定义如下：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running this snippet produces output that is similar to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此片段会产生类似于以下内容的输出：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Of course, each invocation differs depending upon the random values that are
    created for `GeneratedWeight`, which is used to probabilistically select the next
    transition. This snippet provides a base to compose larger-scale tests for the
    reporting infrastructure. Through this example, we see an interesting application
    of Markov chains to support generating representative events from various market
    conditions without requiring access to volumes of production data. We are now
    able to write tests to confirm whether or not the reporting infrastructure correctly
    computes PnL trends in different market conditions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次调用都取决于为`GeneratedWeight`创建的随机值，它用于概率性地选择下一个转换。这个片段提供了一个基础来编写更大规模的测试，用于报告基础设施。通过这个例子，我们看到马尔可夫链的一个有趣应用，它支持从各种市场条件生成代表性事件，而无需访问大量生产数据。我们现在能够编写测试来确认报告基础设施是否正确计算了不同市场条件下的PnL趋势。
- en: Stream caveats
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流注意事项
- en: For all their goodness, `Stream` should be used with caution. In this section,
    we mention a few of the main caveats of `Stream`, and how to avoid them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们很好，但使用`Stream`时应谨慎。在本节中，我们提到了`Stream`的一些主要注意事项以及如何避免它们。
- en: Streams are memoizers
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流是记忆化器
- en: While views do not cache the result of a computation and, therefore, recalculate
    and realize each element each time it is accessed, `Stream` does save the final
    form of its elements. An element is only ever realized once, the first time it
    is accessed. While this is a great characteristic to avoid computing the same
    result several times, it can also lead to a large consumption of memory, to the
    point where your program may eventually run out of memory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`views`不会缓存计算结果，因此每次访问时都会重新计算并实现每个元素，但`Stream`会保存其元素的最后形式。一个元素只会在第一次访问时实现。虽然这是一个避免多次计算相同结果的优秀特性，但它也可能导致大量内存消耗，以至于你的程序最终可能耗尽内存。
- en: To avoid `Stream` memoization, it is good practice to avoid storing a `Stream`
    in a `val`. Using a `val` creates a permanent reference to the head of the `Stream`,
    ensuring that every element that is realized will be cached. If a `Stream` is
    defined as a `def`, it can be garbage collected as soon as it is no longer needed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`Stream`记忆化，一个好的做法是避免将`Stream`存储在`val`中。使用`val`会创建对`Stream`头部的永久引用，确保每个被实例化的元素都会被缓存。如果将`Stream`定义为`def`，它可以在不再需要时立即被垃圾回收。
- en: 'Memoization can happen when calling certain methods that are defined on `Stream`.
    For example, `drop` or `dropWhile` will evaluate and memoize all the intermediate
    elements to be dropped. The elements are memoized as the methods are defined on
    an instance of `Stream` (and `Stream` has a reference on its own head). We can
    implement our own `drop` function to avoid caching the intermediate elements in
    memory:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用定义在`Stream`上的某些方法时，可能会发生记忆化。例如，`drop`或`dropWhile`将评估并记忆化所有要删除的中间元素。这些元素在`Stream`实例（`Stream`有自己的头部引用）上定义方法时被记忆化。我们可以实现自己的`drop`函数来避免在内存中缓存中间元素：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We pattern match on the value of `count` to know whether we can return the given `Stream`
    or need to perform a recursive call on the tail. Our method is tail-recursive.
    This makes sure that we do not keep a reference to the head of the `Stream`, since
    a tail-recursive function recycles its reference each time that it loops. Our `s`
    reference will only point to the remaining part of the `Stream`, not the head.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过匹配`count`的值来判断是否可以返回给定的`Stream`，或者需要在尾部进行递归调用。我们的方法是尾递归的。这确保了我们不会保留`Stream`头部的引用，因为尾递归函数每次循环时都会回收其引用。我们的`s`引用将仅指向`Stream`的剩余部分，而不是头部。
- en: 'Another example of a problematic method is `max`. Calling `max` will memoize
    all the elements of the `Stream` to determine which one is the greatest. Let''s
    implement a safe version of `max`, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有问题的方法示例是`max`。调用`max`将记忆化`Stream`的所有元素以确定哪个是最大的。让我们实现一个安全的`max`版本，如下所示：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This time, we used an internal tail recursive function to be able to expose
    a friendly API. We represent the current max value as an `Option[Int]` to handle
    the case where the method is called with an empty `Stream`. Note that `max` accepts `s`
    as a by-name parameter. This is important because, otherwise, we would be keeping
    a reference to the head of the `Stream` before calling the internal tail-recursive
    `loop` method. Another possible implementation is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用了一个内部尾递归函数来能够提供一个友好的API。我们使用`Option[Int]`来表示当前的最大值，以处理方法在空`Stream`上被调用的情况。请注意，`max`接受`s`作为按名参数。这很重要，因为否则我们会在调用内部尾递归`loop`方法之前保留对`Stream`头部的引用。另一个可能的实现如下：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This implementation is arguably simpler. We check in the `max` function whether
    the `Stream` is empty or not; this allows us to either return right away (with `None`),
    or call `loop` with a valid default value (the first element in the `Stream`).
    The `loop` does not have to deal with `Option[Int]` anymore. However, this example
    does not achieve the goal of avoiding memoization. The pattern matching will cause `rest`
    to keep a reference on the entire tail of the original `Stream`, which will prevent
    garbage collection of the intermediate elements. A good practice is to only pattern
    match on a `Stream` inside a consuming, tail-recursive method.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可以说是更简单。我们在`max`函数中检查`Stream`是否为空；这允许我们立即返回（使用`None`），或者调用`loop`并传递一个有效的默认值（`Stream`中的第一个元素）。`loop`不再需要处理`Option[Int]`。然而，这个例子并没有达到避免记忆化的目标。模式匹配将导致`rest`保留对原始`Stream`整个尾部的引用，这将阻止中间元素的垃圾回收。一个好的做法是在消耗性、尾递归方法内部仅对`Stream`进行模式匹配。
- en: Stream can be infinite
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Stream`可以是无限的'
- en: 'We saw during our overview that it is possible to define an infinite `Stream`.
    However, you need to be careful when working with an infinite `Stream`. Some methods
    may cause the evaluation of the entire `Stream`, leading to `OutOfMemoryError`.
    Some are obvious, such as `toList`, which will try to store the entire `Stream`
    into a `List`, causing the realization of all the elements. Others are more subtle.
    For example, `Stream` has a `size` method that is similar to the one defined on `List`.
    Calling `size` on an infinite `Stream` will cause the program to run out of memory.
    Similarly, `max` and `sum` will attempt to realize the entire sequence and crash
    your system. This behavior is particularly dangerous as `Stream` extends `Seq`,
    the base trait for sequences. Consider the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的概述中，我们看到了定义一个无限`Stream`的可能性。然而，当你与无限`Stream`一起工作时，你需要小心。某些方法可能会导致整个`Stream`的评估，从而导致`OutOfMemoryError`。其中一些很明显，例如`toList`，它将尝试将整个`Stream`存储到一个`List`中，从而导致所有元素的实现。其他的一些则更为微妙。例如，`Stream`有一个`size`方法，它与`List`上定义的方法类似。在无限`Stream`上调用`size`会导致程序耗尽内存。同样，`max`和`sum`将尝试实现整个序列并使你的系统崩溃。这种行为尤其危险，因为`Stream`扩展了`Seq`，这是序列的基本特质。考虑以下代码：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This short method takes a `Seq[Int]` as single parameter, and returns its range,
    that is, the difference between the greatest and lowest elements. As `Stream`
    extends `Seq` the following call is valid:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的方法接受一个`Seq[Int]`作为单个参数，并返回其范围，即最大和最小元素之间的差值。由于`Stream`扩展了`Seq`，以下调用是有效的：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The compiler will happily and promptly generate the bytecode for this snippet.
    However, `s` could be defined as an infinite `Stream`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会愉快且迅速地为这个片段生成字节码。然而，`s`可以被定义为一个无限的`Stream`：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The call to `range` never returns due to the implementation of `max` and `min`.
    This example illustrates a good practice that we mentioned earlier in this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`max`和`min`的实现，`range`的调用永远不会返回。这个例子说明了我们在本章前面提到的一个良好实践。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Throughout this chapter, we explored two lazily evaluated collections that
    are provided by the standard Scala library: views and streams. We explored their
    characteristics and implementation details, as well as the limitations to bear
    in mind when using these abstractions. Leveraging your newly-acquired knowledge,
    you addressed a critical performance problem affecting MVT clients trying to view
    their performance trend.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Scala标准库提供的两个懒加载集合：视图和流。我们探讨了它们的特性和实现细节，以及在使用这些抽象时需要注意的限制。利用你新获得的知识，你解决了一个影响MVT客户端试图查看其性能趋势的关键性能问题。
- en: In the *Stream* sections, we took the opportunity to tie the concept of stream
    processing to event sourcing. We briefly explored the event sourcing paradigm
    and introduced a simple event-driven transformation pipeline to improve the architecture
    of the reporting system and to define a stronger domain model. Lastly, we built
    a Markov chain event generator to exercise our new approach to generating reports.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Stream*部分，我们有机会将流处理的概念与事件源结合。我们简要探讨了事件源范式，并介绍了一个简单的基于事件的转换管道，以改进报告系统的架构并定义一个更强的领域模型。最后，我们构建了一个马尔可夫链事件生成器来练习我们生成报告的新方法。
- en: By exploring both eager and lazy collections, you now possess a strong working
    knowledge of the collections that are provided by the Scala standard library.
    In the next chapter, we will continue our exploration of Scala concepts viewed
    through the functional paradigm by diving into concurrency.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索急切和懒加载集合，你现在对Scala标准库提供的集合有了坚实的实际知识。在下一章中，我们将继续通过函数式范式探索Scala概念，深入探讨并发性。
