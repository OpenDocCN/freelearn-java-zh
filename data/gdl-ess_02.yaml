- en: Chapter 2. Building Java Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。构建 Java 项目
- en: In the previous chapter, we saw a very basic build script, which just printed
    the customary `Hello World` on the console. Now that we are comfortable with the
    Gradle command line interface, it's a perfect time for us to jump-start our journey
    with a simple Java project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一个非常基础的构建脚本，它只是在控制台上打印了传统的`Hello World`。现在我们已经熟悉了 Gradle 命令行界面，这正是我们开始简单
    Java 项目的完美时机。
- en: In this chapter, we will see how to build and test simple Java projects with
    Gradle, how external dependencies are added to the classpath, and how building
    distributable binaries work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用 Gradle 构建、测试简单的 Java 项目，如何将外部依赖项添加到类路径中，以及如何构建可分发二进制文件。
- en: We will try to keep the Java code as minimal as possible so that we can focus
    more on the build of the project. Along the way, we will learn some best practices
    that a Gradle-based project should follow. It's okay if we are not able to comprehend
    all the build script syntax in this chapter because we are going to see that in
    detail in [Chapter 4](part0028_split_000.html#QMFO2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 4. Demystifying Build Scripts"), *Demystifying Build Scripts*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量使 Java 代码尽可能简洁，以便我们能够更多地关注项目的构建。在这个过程中，我们将学习一些基于 Gradle 的项目应该遵循的最佳实践。如果我们无法完全理解本章中所有构建脚本语法，那也是可以的，因为我们将详细地在[第
    4 章](part0028_split_000.html#QMFO2-e78ecbb3ac0544f19c59f96d594821c0 "第 4 章。揭秘构建脚本")*揭秘构建脚本*中看到。
- en: Building a simple Java project
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Java 项目
- en: To demonstrate the Java project's build with Gradle, let's create a very simple
    Java application that will greet a user. Just a tad bit more than a `hello world`
    in terms of application logic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示使用 Gradle 构建Java项目的示例，让我们创建一个非常简单的 Java 应用程序，它将问候用户。在应用程序逻辑方面，这比简单的`hello
    world`要稍微复杂一点。
- en: Firstly, create a directory called `hello-java`. This is our project directory.
    For the following steps, feel free to choose an IDE/text editor of your choice
    for editing the files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`hello-java`的目录。这是我们项目目录。对于以下步骤，请随意选择您喜欢的 IDE/文本编辑器来编辑文件。
- en: Creating a build file
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建文件
- en: 'In the root of the project directory, let''s create the `build.gradle` file
    and add the following code line to it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录的根目录下，让我们创建`build.gradle`文件，并将其中的以下代码行添加到其中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yes, that's all that goes into the build file for now, a single line. We will
    soon see what it means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是目前构建文件中所有需要的内容，只有一行。我们很快就会看到它的含义。
- en: Adding source files
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加源文件
- en: By default, like Maven, the Java source files are read from the `src/main/java`
    directory of the project. We can configure this, of course, but let's save that
    for later. Let's create this directory structure in our project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，就像 Maven 一样，Java 源文件是从项目的`src/main/java`目录中读取的。当然，我们可以配置它，但让我们留到以后再说。让我们在我们的项目中创建这个目录结构。
- en: 'Now, we need to create a Java class that would generate the greeting message.
    Also, we would create a `Main` class with a `main` method so that an app can be
    run from a command line. The Java files should be kept in a source root directory
    under a proper package structure. We will use the `com.packtpub.ge.hello` package
    for this example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 Java 类来生成问候信息。同时，我们还会创建一个包含`main`方法的`Main`类，以便可以从命令行运行应用程序。Java
    文件应该保存在一个源根目录下的适当包结构中。我们将使用`com.packtpub.ge.hello`包作为此示例：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the preceding structure, we have created the package structure
    under the `src/main/java` source root.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以从前面的结构中看到的那样，我们在`src/main/java`源根下创建了包结构。
- en: 'Let''s create the `GreetingService.java` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`GreetingService.java`文件：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class exposes just one method called `greet`, which we can use to generate
    a greeting message.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类仅公开一个名为`greet`的方法，我们可以使用它来生成问候信息。
- en: 'Here is how our `Main.java` looks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Main.java`文件看起来像这样：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class has a `main` method, which will be invoked when a program is run.
    It instantiates the `GreetingService` and prints the output of the `greet` method
    on a console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个`main`方法，当程序运行时将被调用。它实例化`GreetingService`并打印`greet`方法在控制台上的输出。
- en: Building the project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'After adding the Java files, we now want to compile the project and produce
    the class files. It can be simply done by calling the following task from a command
    line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 Java 文件后，我们现在想要编译项目并生成类文件。这可以通过从命令行调用以下任务来完成：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiled classes go into `build/classes/main` relative to the project root.
    You can confirm by checking the project tree again. We will ignore other files
    and directories for now:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的类文件会存放在项目根目录下的`build/classes/main`。你可以通过再次检查项目树来确认。现在我们将忽略其他文件和目录：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we can directly run the class, but let''s ask for more and generate
    the `.jar` file for our application. Let''s run the following task:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以直接运行这个类，但让我们要求更多，并为我们的应用程序生成`.jar`文件。让我们运行以下任务：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It produces a Jar for our project in the `build/libs` directory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`build/libs`目录下为我们的项目生成一个Jar文件：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s test if the Jar works as expected. To run the Jar, issue the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试Jar是否按预期工作。要运行Jar，请发出以下命令：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are passing the `Reader` as an argument to our java `Main` class ''s `main`
    method. This will produce the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Reader`作为参数传递给我们的java `Main`类的`main`方法。这将产生以下输出：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we run the `build` task, Gradle also invokes the `compileJava` and other
    dependent tasks before actually executing the build task. So, we don't need to
    explicitly call `compileJava` here to compile classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`build`任务时，Gradle也会在执行构建任务之前调用`compileJava`和其他依赖任务。因此，我们在这里不需要显式调用`compileJava`来编译类。
- en: 'The name of the `.jar` file is the same as that of the project. This can be
    configured by setting the `archivesBaseName` property in the `build.gradle` file.
    For example, to generate the Jar named `my-app.jar`, add the following code line
    to the build file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`.jar`文件的名称与项目名称相同。这可以通过在`build.gradle`文件中设置`archivesBaseName`属性来配置。例如，要生成名为`my-app.jar`的Jar文件，请将以下代码行添加到构建文件中：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s fire:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also, check the directory tree again. No surprise, it's cleaned keeping the
    source files intact.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，再次检查目录树。不出所料，它已经清理完毕，源文件保持完整。
- en: We know from our experiences with Ant that, even for the project of this size,
    we would have to define at least a handful of targets and this would be quite
    a few lines of XML. While Maven would have worked by convention, still the Maven's
    `pom.xml` needs some ceremony before it's even a valid `pom.xml` file. So, a minimal
    `pom.xml` file would still look like five to six lines of XML.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们使用Ant的经验来看，即使是这个规模的项目，我们也必须定义至少几个目标，这将需要很多行XML。虽然Maven可以通过约定工作，但Maven的`pom.xml`文件在成为有效的`pom.xml`文件之前仍需要一些仪式。因此，一个最小的`pom.xml`文件仍然看起来像五到六行XML。
- en: Compare that with the simplicity and carefully chosen sensible defaults by Gradle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与Gradle精心选择和默认的简单性相比。
- en: 'This is a good point where we should see what all tasks were brought into our
    build by the `java` plugin:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的地方，我们应该看看`java`插件为我们构建引入了哪些所有任务：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is interesting to see so many useful tasks available on our build by merely
    applying the `java` plugin. Clearly, Gradle employs a very powerful plugin mechanism
    that can be leveraged to apply the **don't repeat yourself** (**DRY**) principle
    on build logic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们的构建中通过仅应用`java`插件就有这么多有用的任务，这很有趣。显然，Gradle使用了一个非常强大的插件机制，可以利用它来在构建逻辑上应用**不要重复自己**（**DRY**）原则。
- en: A brief introduction to plugins
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件简介
- en: Gradle by itself is nothing more than a task runner. It does not know how to
    compile a Java file or where to read the source files. It means that these tasks
    are not there by default. As we saw in the last chapter, a Gradle build file,
    without any plugin applied, contained very few tasks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle本身不过是一个任务运行器。它不知道如何编译Java文件或在哪里读取源文件。这意味着这些任务不是默认存在的。正如我们在上一章中看到的，没有应用任何插件的Gradle构建文件包含非常少的任务。
- en: A plugin adds relevant tasks and conventions to a Gradle build. In our current
    example, all the tasks such as `compileJava`, `build`, `clean`, and many more
    are essentially brought in by the `java` plugin that we applied to our build.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 插件为Gradle构建添加相关的任务和约定。在我们的当前示例中，所有如`compileJava`、`build`、`clean`等任务实际上都是由我们应用于构建的`java`插件引入的。
- en: This means, Gradle does not force us to use a particular way to compile a Java
    project. It's completely up to us to choose the `java` plugin for our build. We
    can configure it to suite our needs. If we still don't like the way it works,
    we are free to add our own tasks directly to the build or through a custom plugin
    that will work the way we want.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Gradle不会强迫我们使用特定的方式来编译Java项目。完全取决于我们选择为构建使用`java`插件。我们可以根据需要配置它。如果我们仍然不喜欢它的工作方式，我们可以自由地直接在构建中添加自己的任务，或者通过一个自定义插件来实现我们想要的方式。
- en: There are number of plugins that come out of the box with Gradle. The `java`
    plugin is one such plugin. Throughout the course of this book, we will see many
    such plugins, which will bring in a lot of interesting functionality to our build.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle自带了许多插件。`java`插件就是其中之一。在本书的整个过程中，我们将看到许多这样的插件，它们将为我们的构建带来许多有趣的功能。
- en: Unit testing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is an indispensable aspect of software development. Testing gives
    us confidence that our code works fine and provides us a safety net when refactoring.
    Fortunately, Gradle's Java plugin makes it simple and easy to unit test your code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是软件开发不可或缺的方面。测试让我们对我们的代码正常工作充满信心，并在重构时提供安全网。幸运的是，Gradle的Java插件使得单元测试代码变得简单且容易。
- en: We will write a simple test for the same example app we created above. We will
    create our first unit test now using JUnit (v4.12) library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为上面创建的相同示例应用程序编写一个简单的测试。我们现在将使用JUnit（v4.12）库创建我们的第一个单元测试。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about JUnit can be found at [http://junit.org](http://junit.org).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于JUnit的信息可以在[http://junit.org](http://junit.org)找到。
- en: Adding a unit test source
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加单元测试源
- en: Again, like Maven, Java test sources are kept in the `src/test/java` directory
    relative to the project root. We will create this directory and, as a good practice,
    the test package structure will reflect the same hierarchy as the source packages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，像Maven一样，Java测试源代码保存在项目根目录相对的`src/test/java`目录中。我们将创建这个目录，并且作为一个好的实践，测试包结构将反映与源包相同的层次结构。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will add test for the `GreetingService`. By convention, the name of test
    will be `GreetingServiceTest.java`. The following is the code of this file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`GreetingService`添加测试。按照惯例，测试的名称将是`GreetingServiceTest.java`。以下是这个文件的代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The test sets up an instance of **System Under Test** (**SUT**), which is `GreetingService`,
    and the `testGreet` method checks the equality of the SUT's `greet` methods output
    to get the expected message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置了一个**系统测试对象**（**SUT**）的实例，即`GreetingService`，`testGreet`方法检查SUT的`greet`方法输出与预期消息的相等性。
- en: Now, take a moment and try to compile tests by using the `compileTestJava` task,
    which is exactly the same as `compileJava`, but compiles the test source files.
    Did it compile just fine? If not, can we take a guess as to what could have gone
    wrong?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，花点时间尝试使用`compileTestJava`任务编译测试，它与`compileJava`完全相同，但编译测试源文件。它编译得很好吗？如果不是，我们能猜测一下可能出了什么问题吗？
- en: The task should have failed with a bunch of compilation errors because JUnit,
    which is an external library, was not on the classpath to compile the files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任务应该因为JUnit（一个外部库）不在类路径上编译文件而失败，并出现大量编译错误。
- en: Adding the JUnit to the classpath
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将JUnit添加到类路径
- en: 'To compile and run this test case, we need JUnit library on the classpath.
    It is important to remember that this dependency is only required while compiling
    and running the tests. Our application does not depend on JUnit for its compilation
    or on runtime. We also need to tell where to search for this artifact so that
    Gradle can download it if there is a need. To do this, we need to update the `build.gradle`
    file as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行这个测试用例，我们需要JUnit库在类路径上。重要的是要记住，这个依赖项仅在编译和运行测试时需要。我们的应用程序在编译或运行时不需要JUnit。我们还需要告诉Gradle在哪里搜索这个工件，以便在需要时下载它。为此，我们需要更新`build.gradle`文件，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are two additions to this build file, from what we already know.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们已知的内容来看，这个构建文件有两个新增内容。
- en: In the `dependencies` section, we list down all the dependencies of the project
    along with their scope. We declared JUnit to be made available in the `testCompile`
    scope.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dependencies`部分，我们列出了项目的所有依赖项及其作用域。我们声明JUnit在`testCompile`作用域内可用。
- en: In the `repositories` section, we configure the type and location of the repository
    where external dependencies will be found. In this example, we tell Gradle to
    get the dependencies from the Maven central repository. Since Maven central is
    a very commonly used repo, Gradle provides a shortcut to configure it thorough
    the `mavenCentral()` method call.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`repositories`部分，我们配置了外部依赖项将找到的仓库的类型和位置。在这个例子中，我们告诉Gradle从Maven中央仓库获取依赖项。由于Maven中央是一个非常常用的仓库，Gradle提供了一个通过`mavenCentral()`方法调用来配置它的快捷方式。
- en: We will cover both the sections in greater depth in the next chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更深入地介绍这两个部分。
- en: Running the test
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'We are interested in running the tests to check whether everything is working
    as expected. Let''s run the `test` task, which will also sequentially run all
    the tasks that the `test` task depends on. We can also verify this by looking
    at the output that lists all the tasks that have been run as part of this build:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对运行测试以检查一切是否按预期工作感兴趣。让我们运行`test`任务，这将按顺序运行`test`任务依赖的所有任务。我们也可以通过查看列出作为此构建一部分运行的所有任务的输出来验证这一点：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It looks like the tests passed. To see how Gradle tells us when a test fails,
    let''s intentionally change the expected value in assertion to `Test Hello` so
    that the assertion fails:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来测试通过了。为了了解Gradle如何告诉我们测试失败，让我们故意将断言中的预期值更改为`Test Hello`，以便断言失败：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then run the command again to see the result when the test fails:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行命令，以查看测试失败的结果：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, so the test failed and the output tells you about the file and the line
    number as well. Also, it points you to the report file, which includes more details
    of the test failure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，所以测试失败了，输出告诉你关于文件和行号的信息。此外，它还指向包含测试失败更多详细信息的报告文件。
- en: Viewing test reports
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看测试报告
- en: Whether the test passes or not, a nice HTML report is created with details of
    all the tests that are run. By default, this report is located at `build/reports/tests/index.html`
    relative to the project root. You can open this file in a browser.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无论测试是否通过，都会创建一个包含所有运行测试详细信息的漂亮的HTML报告。默认情况下，此报告位于项目根目录相对于`build/reports/tests/index.html`。您可以在浏览器中打开此文件。
- en: 'For the above failure, the report looks something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述失败，报告看起来大致如此：
- en: '![Viewing test reports](img/00004.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![查看测试报告](img/00004.jpeg)'
- en: 'If we click on the failed test, we get to see the details of the failure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击失败的测试，我们可以看到失败的详细信息：
- en: '![Viewing test reports](img/00005.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![查看测试报告](img/00005.jpeg)'
- en: 'We can see `org.junit.ComparisonFailure: expected:<[Test Hello]> but was:<[Hello
    Test]>` in the first line of the stack trace.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以在堆栈跟踪的第一行看到`org.junit.ComparisonFailure: expected:<[Test Hello]> but was:<[Hello
    Test]>`。'
- en: Fitting tests in the workflow
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程中的拟合测试
- en: Now that we have tests in place, it makes sense to build our project binaries
    (`.jar`) only if the tests pass. For that, we need to define some kind of flow
    between the tasks such that, if a task fails, the pipeline is broken there and
    the subsequent tasks are not executed. So, in our examples, the build's execution
    should depend on the test's success.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了测试，只有在测试通过的情况下，才合理地构建我们的项目二进制文件（`.jar`）。为此，我们需要在任务之间定义某种类型的流程，以便如果任务失败，管道将在那里中断，后续的任务将不会执行。因此，在我们的示例中，构建的执行应取决于测试的成功。
- en: Guess what, it has already been taken care by the `java` plugin for us. We just
    need to call the last task in the flow, and all the tasks that the called tasks
    depend on will be called sequentially and the build will not succeed if any of
    the tasks fails.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看，这已经由我们的`java`插件为我们处理了。我们只需要调用流程中的最后一个任务，并且如果任何任务失败，构建将不会成功，所有依赖的任务将按顺序调用。
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also, we don't need to call all the tasks that the build depends on explicitly
    because they will be called anyway.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不需要明确调用构建所依赖的所有任务，因为它们无论如何都会被调用。
- en: 'Now let''s fix the test and see the Jar getting created again:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修复测试，看看Jar文件是否再次被创建：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yay! So the tests have passed and we can build binaries of our app again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！所以测试通过了，我们再次可以构建我们应用程序的二进制文件。
- en: Notice how intelligently Gradle figures out that, if only tests were changed,
    it compiled only the tests. In the preceding output, `compileJava` shows `UP-TO-DATE`,
    means nothing was changed and, hence, Gradle didn't unnecessarily compile the
    source files again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Gradle如何智能地确定，如果只有测试被更改，它只编译了测试。在前面的输出中，`compileJava`显示`UP-TO-DATE`，这意味着没有变化，因此Gradle没有必要再次编译源文件。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we need to force run task actions even if nothing has changed between the
    two runs, we can pass the `--rerun-tasks` flag on the command line so that all
    task actions can run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要强制运行任务操作，即使两次运行之间没有任何变化，我们可以在命令行上传递`--rerun-tasks`标志，以便所有任务操作都可以运行。
- en: 'If we see the test reports again, they will look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看测试报告，它们将看起来如下：
- en: '![Fitting tests in the workflow](img/00006.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![工作流程中的拟合测试](img/00006.jpeg)'
- en: 'And the **Test Summary** will look something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试摘要**将看起来大致如此：'
- en: '![Fitting tests in the workflow](img/00007.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![工作流程中的拟合测试](img/00007.jpeg)'
- en: Bundling an application distributable
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包应用程序可分发文件
- en: In the first example, we ran our application by using the `java` command directly
    from the command line. Usually, such command-line applications are shipped with
    scripts to run the application so that the end user need not always write the
    whole command by hand. Also, while developing, we repeatedly need to run the app.
    It would be nicer if we could write a task in our build file such that an app
    can be run in one Gradle invocation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们直接从命令行使用`java`命令运行我们的应用程序。通常，这样的命令行应用程序会附带脚本以运行应用程序，这样最终用户就不必总是手动编写整个命令。此外，在开发过程中，我们反复需要运行应用程序。如果我们可以在我们的构建文件中编写一个任务，以便在单个Gradle调用中运行应用程序，那就更好了。
- en: 'The good news is that there already exists such a plugin called `application`,
    shipped with Gradle, which can do both for us. For this example, we will copy
    over the `hello-test` project as `hello-app`. Let''s make simple modifications
    to our `build.gradle` as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，已经存在一个名为`application`的插件，它是与Gradle一起提供的，可以为我们完成这两项任务。在这个例子中，我们将`hello-test`项目复制为`hello-app`。让我们对我们的`build.gradle`文件进行以下简单修改：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second line applies the `application` plugin to our build. To make this
    plugin work, we need to configure Gradle to use our `Main` entry point class,
    which has the static `main` method that needs to run when our application is run.
    We specified that on line `#4` by setting the `mainClassName` property that is
    added to the build by the `application` plugin. Finally, when we want to run the
    app using Gradle (that is, while developing), we need to provide some command-line
    arguments to our app. The `application` plugin adds the `run` task to our build.
    As we said earlier, tasks are objects and they have properties and methods just
    like any regular object. On line `#5`, we set the `args` property of the `run`
    task to a list with one element `Reader`, so whenever we execute the run task,
    `Reader` will be passed as a command-line argument to our main method. Those who
    have used IDEs to set **Run Configuration** can easily relate to this. The rest
    of the file is the same as the last example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将`application`插件应用于我们的构建。为了使此插件正常工作，我们需要配置Gradle以使用我们的`Main`入口点类，该类具有需要在应用程序运行时运行的静态`main`方法。我们在第`#4`行通过设置由`application`插件添加到构建的`mainClassName`属性来指定这一点。最后，当我们想要使用Gradle（即在开发过程中）运行应用程序时，我们需要向我们的应用程序提供一些命令行参数。`application`插件将`run`任务添加到我们的构建中。正如我们之前所说的，任务就像任何常规对象一样，是对象，并且具有属性和方法。在第`#5`行，我们将`run`任务的`args`属性设置为包含一个元素`Reader`的列表，因此每次我们执行运行任务时，`Reader`都将作为命令行参数传递给我们的主方法。那些使用IDE设置**运行配置**的人可以很容易地理解这一点。文件的其他部分与上一个例子相同。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding example, as we are applying the `application` plugin, it is
    not necessary to explicitly apply the `java` plugin as an `application` plugin
    implicitly applies the `java` plugin to our build.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由于我们正在应用`application`插件，因此没有必要显式地应用`java`插件，因为`application`插件隐式地将`java`插件应用于我们的构建。
- en: It also implicitly applies the `distribution` plugin so that we get the tasks
    to package the application as a ZIP or TAR archive and also gets the task to install
    the application distribution locally.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它还隐式地应用了`distribution`插件，因此我们得到了将应用程序打包为ZIP或TAR存档的任务，同时也得到了安装应用程序分发的本地任务。
- en: More information on the `application` plugin can be found at [https://docs.gradle.org/current/userguide/distribution_plugin.html](https://docs.gradle.org/current/userguide/distribution_plugin.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`application`插件的信息可以在[https://docs.gradle.org/current/userguide/distribution_plugin.html](https://docs.gradle.org/current/userguide/distribution_plugin.html)找到。
- en: 'Now, if we check the tasks that are available in our build, we see a few additions
    under the `Application tasks` and `Distribution tasks` groups:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们检查我们的构建中可用的任务，我们会在`Application tasks`和`Distribution tasks`组下看到一些新增的任务：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Running the application with Gradle
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gradle运行应用程序
- en: 'Let''s first look at the `run` task. We will call this task with the `–q` flag
    to suppress other messages by Gradle:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看`run`任务。我们将使用`–q`标志调用此任务以抑制Gradle的其他消息：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As expected, we see the output on a console. This task really shines when we
    make changes and can run our app in one command as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们在控制台上看到了输出。当我们需要更改并可以一键运行我们的应用程序时，这项任务表现得尤为出色：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We changed our `GreetingService` for a moment to return "`Hola`" instead of
    "`Hello`" and see if run reflects the changes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时将`GreetingService`更改回返回"`Hola`"而不是"`Hello`"，看看运行任务是否反映了这些更改：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Yes, it did.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它确实如此。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'One might wonder how to pass command-line arguments to run a task from the
    command line itself, instead of the build file, which is something as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想知道如何从命令行本身传递命令行参数来运行任务，而不是从构建文件中，这就像以下这样：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, it doesn''t work this way. As Gradle can accept multiple task names
    from a command line, there is no way for Gradle to know whether `Reader` was an
    argument that needs to be passed to run a task, or it''s a task name itself. For
    example, the following command calls two tasks:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方式并不奏效。因为Gradle可以从命令行接受多个任务名称，所以Gradle无法知道`Reader`是传递给运行任务需要传递的参数，还是它本身就是一个任务名称。例如，以下命令调用了两个任务：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are, of course, some workarounds if you really need to pass the command
    line to the program at every invocation of a run task. One such way is to use
    the `–Pproperty=value` command-line option and then extract the property's value
    in the `run` task to send it as `args` to the program. The `–P` adds properties
    to the Gradle `Project`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要在每次运行任务时将命令行传递给程序，当然也有一些解决方案。其中一种方法是通过使用`–Pproperty=value`命令行选项，然后在`run`任务中提取属性值，将其作为`args`传递给程序。`–P`将属性添加到Gradle
    `Project`中。
- en: 'To achieve this, update the `run.args` in `build.gradle` as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请按照以下方式更新`build.gradle`中的`run.args`：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, then from command line provide the property value by calling:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以从命令行通过调用以下方式提供属性值：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we provided the value of a property at the time of
    calling the `gradle` command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在调用`gradle`命令时提供了属性的值。
- en: Alternatively, we could create a `gradle.properties` in project’s root parallel
    to the `build.gradle` file. In that case, for this example it would contain just
    `runArgs=world`. But it can declare more properties, which would be available
    in the build as properties on project object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在项目根目录中与`build.gradle`文件平行的位置创建一个`gradle.properties`文件。在这种情况下，对于这个例子，它将只包含`runArgs=world`。但它可以声明更多的属性，这些属性将在构建中作为项目对象上的属性可用。
- en: There are other ways to declare properties as well, which can be found at [https://docs.gradle.org/current/userguide/build_environment.html](https://docs.gradle.org/current/userguide/build_environment.html).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他声明属性的方法，可以在[https://docs.gradle.org/current/userguide/build_environment.html](https://docs.gradle.org/current/userguide/build_environment.html)中找到。
- en: Building the distribution archive
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建分发存档
- en: 'Another interesting task is `distZip`, which packages the application along
    with OS-specific start scripts:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的任务是`distZip`，它将应用程序与特定于操作系统的启动脚本一起打包：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It would have generated the application distribution in ZIP format in the `build/distributions`
    relative to the project root. The name of the ZIP defaults to the project name.
    In this case, it would be `hello-app.zip`. This can be changed, if required, using
    the following property in `build.gradle`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它会在项目根目录的`build/distributions`中生成ZIP格式的应用程序分发。ZIP的名称默认为项目名称。在这种情况下，它将是`hello-app.zip`。如果需要，可以使用以下属性在`build.gradle`中更改它：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s unzip the archive to see its contents:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解压缩存档以查看其内容：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We see a pretty standard directory structure inside the ZIP. It contains a shell
    script and windows BAT script to run our app. Also, it contains the JAR file of
    our application. The `lib` directory also contains the application's runtime dependencies.
    We can configure the `distribution` plugin to add more files in our distributions
    such as Javadoc, README, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在ZIP文件内部看到了一个非常标准的目录结构。它包含一个shell脚本和一个Windows批处理脚本，用于运行我们的应用程序。它还包含我们的应用程序的JAR文件。`lib`目录也包含应用程序的运行时依赖项。我们可以配置`distribution`插件，在我们的分发中添加更多文件，如Javadoc、README等。
- en: We can run the script to verify that it works. Using command prompt, we can
    execute this command in Windows. For that use the `cd` command, and change the
    directory to the `bin` directory of the extracted ZIP file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行脚本以验证它是否工作。使用命令提示符，我们可以在Windows上执行此命令。为此，使用`cd`命令，并将目录更改为解压缩ZIP文件的`bin`目录。
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On Mac OS X/Linux, execute the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X/Linux上，执行以下命令：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Generating IDE project files
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成IDE项目文件
- en: IDEs are an integral part of a Java developer's tool chain and workflow. However,
    manually setting up an IDE to correctly identify the project structure and dependencies
    for any moderately sized project is not an easy task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是Java开发者工具链和工作流程的一个基本组成部分。然而，手动设置IDE以正确识别任何中等规模项目的项目结构和依赖关系并不是一件容易的事情。
- en: Checking-in IDE-specific files or directories such as `.classpath`, `.project`,
    `.ipr`, `.iws`, `.nbproject`, `.idea`, `.settings`, `.iml`, is not a good idea.
    We know that some still do it because it's hard to generate the IDE file manually
    every time someone checks the project out of the version control system. However,
    checking in such files creates problems as they eventually go out of sync from
    the main build file. Also, this forces the whole team to use the same IDE and
    manually update the IDE files whenever there is a change in the build.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检入特定于IDE的文件或目录，如`.classpath`、`.project`、`.ipr`、`.iws`、`.nbproject`、`.idea`、`.settings`、`.iml`不是一个好主意。我们知道有些人仍然这样做，因为每次有人从版本控制系统中检出项目时，手动生成IDE文件都很困难。然而，检入此类文件会引发问题，因为它们最终会与主构建文件不同步。此外，这迫使整个团队使用相同的IDE，并在构建有变化时手动更新IDE文件。
- en: 'How nice would it be if we could just check-in only those files that are necessary
    for a project to be built independent of IDE and let our build system generate
    a file specific to our favorite IDE? Our wish is granted. Also, here is the best
    part. The number of lines that you need to modify in your Gradle build file is
    only one. Gradle sports very nice plugins that can generate IDE-specific project
    files. Both IntelliJ IDEA and Eclipse are covered by their respective plugins.
    Depending on which IDE you want to support, you will either include `apply plugin:
    ''idea''` or `apply plugin: ''eclipse''`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们只需检入那些使项目能够独立于IDE构建所必需的文件，让我们的构建系统生成针对我们最喜欢的IDE的特定文件，那会多么美好？我们的愿望实现了。而且，这里还有最好的部分。你需要在Gradle构建文件中修改的行数只有一行。Gradle自带了许多有趣的插件，可以生成特定于IDE的项目文件。IntelliJ
    IDEA和Eclipse都由它们各自的插件支持。根据你想要支持哪个IDE，你将包含`apply plugin: ''idea''`或`apply plugin:
    ''eclipse''`。'
- en: In fact, there is no harm in including both.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，包含两者都没有害处。
- en: 'Now, from the command line, execute the following for Eclipse and IntelliJ
    IDEA, respectively:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从命令行分别执行以下操作以使用Eclipse和IntelliJ IDEA：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It should generate IDE-specific files for you and now you can directly open
    a project in either of the IDEs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该为你生成特定于IDE的文件，现在你可以直接在任何IDE中打开项目。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Make sure you ignore IDE-specific files in version control. For example, if
    you are using Git, consider adding the following entries in your `.gitignore`
    file to prevent someone from accidentally committing the IDE-specific files:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在版本控制中忽略特定于IDE的文件。例如，如果你使用Git，考虑在你的`.gitignore`文件中添加以下条目，以防止意外提交特定于IDE的文件：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started off this chapter by building a very simple Java project. We saw how
    the intelligent conventions of the `java` plugin helped us keep the build file
    concise. Then, we added unit tests to this project and included the JUnit library
    from the Maven central repository. We made the tests fail and checked the reports
    to see the explanation. Then, we saw how the application's distribution can be
    created using the `application` plugin. Finally, we saw the `idea` and `eclipse`
    plugins that help us generate the IDE-specific files for our project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时构建了一个非常简单的Java项目。我们看到了`java`插件的智能约定如何帮助我们使构建文件简洁。然后，我们向该项目添加了单元测试，并从Maven中央仓库中包含了JUnit库。我们使测试失败，并检查报告以查看解释。然后，我们看到了如何使用`application`插件创建应用程序的发行版。最后，我们看到了`idea`和`eclipse`插件，它们帮助我们为项目生成特定于IDE的文件。
- en: Overall, we realized how powerful the plugin system in Gradle is. Gradle, out-of-the-box,
    ships with many interesting plugins, but we are not forced to use any of them.
    We will build a web application in the next chapter and also learn how configurations
    and dependency management works..
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们意识到Gradle的插件系统是多么强大。Gradle自带了许多有趣的插件，但我们并不被迫使用它们。我们将在下一章构建一个Web应用程序，并学习配置和依赖管理是如何工作的。
