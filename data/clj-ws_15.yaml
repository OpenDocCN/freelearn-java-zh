- en: '15\. The Frontend: A ClojureScript UI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 前端：ClojureScript UI
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will go over the basics of React's virtual DOM and lifecycle
    and then provide the tools necessary to build a rich user interface for the data
    application outlined in the previous chapters. We will see how to call JavaScript
    code from ClojureScript and how to convert between JavaScript and ClojureScript
    objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍React的虚拟DOM和生命周期的基本知识，然后提供构建前几章中概述的数据应用程序所需丰富用户界面的工具。我们将了解如何从ClojureScript中调用JavaScript代码以及如何在JavaScript和ClojureScript对象之间进行转换。
- en: By the end of this chapter, you will be able to build a rich user interface
    for a data application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够为数据应用程序构建一个丰富的用户界面。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Clojure is a hosted language, which means that it runs on top of another language.
    In the same way that Clojure runs on top of the JVM, ClojureScript runs on top
    of JavaScript. More precisely, a ClojureScript program is transpiled into a JavaScript
    program that can run in the browser, on the server side, and in any environment
    where JavaScript is supported. For example, consider Node.js, an open source JavaScript
    server environment that allows us to execute JavaScript programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种托管语言，这意味着它在另一种语言之上运行。与Clojure在JVM之上运行的方式相同，ClojureScript在JavaScript之上运行。更精确地说，一个ClojureScript程序被转换成一个可以在浏览器、服务器端以及任何支持JavaScript的环境中运行的JavaScript程序。例如，考虑Node.js，这是一个开源的JavaScript服务器环境，它允许我们执行JavaScript程序。
- en: In this chapter, we will learn the basics of ClojureScript and how to create
    a ClojureScript program that runs in the browser. We will build a small frontend
    application on top of the Reagent framework that connects to an HTTP endpoint
    and displays **User Interface** (**UI**) components that the user can interact
    with. We will use Hiccup as a markup language for the UI components and discover
    how to execute JavaScript code from ClojureScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习ClojureScript的基础知识以及如何创建一个在浏览器中运行的ClojureScript程序。我们将在Reagent框架之上构建一个小型的前端应用程序，该应用程序连接到HTTP端点并显示用户可以与之交互的用户界面（UI）组件。我们将使用Hiccup作为UI组件的标记语言，并了解如何从ClojureScript中执行JavaScript代码。
- en: We will build an application using Figwheel, which supports hot code reloading.
    When your application is up, you will modify it either by changing its code or
    by evaluating code in the REPL. Your application will be magically updated without
    ever needing to refresh the page.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用支持热代码重载的Figwheel构建一个应用程序。当你的应用程序运行时，你可以通过更改代码或评估REPL中的代码来修改它。你的应用程序将神奇地更新，而无需刷新页面。
- en: 'We will learn how to organize the different components of a Reagent application:
    the CSS, the HTML, and the `cljs` files. We will build several Reagent components
    that access and modify the state of the app and fetch data from the network.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何组织Reagent应用程序的不同组件：CSS、HTML和`cljs`文件。我们将构建几个Reagent组件，这些组件可以访问和修改应用程序的状态，并从网络中获取数据。
- en: Hiccup instead of HTML
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiccup而不是HTML
- en: 'Hiccup is a library for representing HTML in Clojure. In *Activity 6.01*, *Generating
    HTML from Clojure Vectors*, you implemented a simplified version of Hiccup. As
    you''ll remember, Hiccup uses:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Hiccup是一个用于在Clojure中表示HTML的库。在*活动6.01*，*从Clojure向量生成HTML*中，你实现了Hiccup的简化版本。正如你所记得的，Hiccup使用：
- en: Vectors to represent elements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量表示元素
- en: Maps to represent an element's attributes (including styles)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射表示元素的属性（包括样式）
- en: 'In a Hiccup vector, the first element is a keyword that specifies the corresponding
    HTML element:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hiccup向量中，第一个元素是一个关键字，它指定了相应的HTML元素：
- en: '`:div` for a `<div>` tag'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:div`代表`<div>`标签'
- en: '`:span` for a `<span>` tag'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:span`代表`<span>`标签'
- en: '`:img` for a `<img>` tag'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:img`代表`<img>`标签'
- en: In Hiccup, an empty `<div>` is represented by `[:div]`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hiccup中，一个空的`<div>`由`[:div]`表示。
- en: 'The second element is an optional map that represents the element''s attributes
    where the names of the attributes follow the kebab-case convention: we separate
    the words with one underscore character (`on-click` instead of `onClick`).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是一个可选的映射，它表示元素的属性，其中属性的名称遵循kebab-case约定：我们用一个下划线字符分隔单词（`on-click`而不是`onClick`）。
- en: For example, `[:div {:class "myDiv"}]` represents `<div class="myDiv"></div>`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`[:div {:class "myDiv"}]`代表`<div class="myDiv"></div>`。
- en: 'Notice that in HTML, the `style` attribute is a string while in Hiccup it is
    a map where the keys follow the kebab-case convention. For example, consider the
    following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在HTML中，`style`属性是一个字符串，而在Hiccup中它是一个遵循kebab-case约定的键值对映射。例如，考虑以下示例：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This represents the following in HTML:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这在HTML中表示如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, color: white denotes that the color of the `Hello Hiccup` text and `background-color`
    will be blue within the `div` tag.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，`color: white`表示`Hello Hiccup`文本和`background-color`在`div`标签内的颜色将是蓝色。'
- en: 'Following the optional map of attributes, we have the children—as many as we
    want. For example, consider the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选的属性映射之后，我们有子元素——我们想要的任意数量。例如，考虑以下内容：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It represents the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表了以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can nest Hiccup elements as children of Hiccup elements. For instance, consider
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Hiccup元素嵌套为Hiccup元素的子元素。例如，考虑以下内容：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This represents the following HTML code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了以下HTML代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In Hiccup, we can specify the class of an element in two ways:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hiccup中，我们可以以两种方式指定元素的类：
- en: 'Specifying an element''s attributes:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定元素属性：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using Hiccup shorthand, by appending a dot and the name of the class:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hiccup缩写，通过附加一个点和类的名称：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compared to HTML, Hiccup is more compact and more readable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML相比，Hiccup更加紧凑且易于阅读。
- en: In addition, we can blend code and data in Hiccup to generate UI components
    dynamically without requiring an additional template language, like we usually
    do in JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在Hiccup中将代码和数据混合在一起，以动态生成UI组件，而无需使用额外的模板语言，就像我们通常在JavaScript中做的那样。
- en: 'For instance, let''s say we want to create a list of 10 `todo` items. We would
    usually write them down manually as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要创建一个包含10个`todo`项的列表。我们通常会手动写下如下内容：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, we can generate the exact same Hiccup element with `map` and `into`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用`map`和`into`生成完全相同的Hiccup元素：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Getting Started with Reagent
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reagent入门
- en: Reagent is a minimalistic ClojureScript wrapper for React.js. React.js is a
    JavaScript library for building a UI.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Reagent是React.js的极简ClojureScript包装器。React.js是一个用于构建UI的JavaScript库。
- en: A Reagent component is similar to a Hiccup component except that the first element
    can be either a keyword or a function. When it's a keyword, it is a Hiccup component
    and when it's a function, Reagent calls the function in order to render the component
    and passes to the function the remaining parts of the vector.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Reagent组件与Hiccup组件类似，除了第一个元素可以是关键字或函数。当它是关键字时，它是一个Hiccup组件；当它是函数时，Reagent会调用该函数以渲染组件，并将向函数传递向量中的剩余部分。
- en: 'A Reagent app is made of three parts: the ClojureScript code, the HTML page,
    and the CSS rules.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Reagent应用程序由三部分组成：ClojureScript代码、HTML页面和CSS规则。
- en: 'In Reagent, like in React, the HTML page is minimalistic: it is mainly a `<div>`
    element with an ID, usually `<div id="app">`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reagent中，就像在React中一样，HTML页面是极简的：它主要是一个带有ID的`<div>`元素，通常是`<div id="app">`。
- en: The CSS rules work the same as in any JavaScript application. The ClojureScript
    code usually starts at the core.cljs file, which renders the main component of
    the application. In the exercises and the activities of this chapter, the app
    will be made of a single namespace, but in a production application, the application
    is split into several namespaces, like in Clojure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规则在JavaScript应用程序中工作方式相同。ClojureScript代码通常从`core.cljs`文件开始，该文件渲染应用程序的主要组件。在本章的练习和活动中，应用程序将是一个单独的命名空间，但在生产应用程序中，应用程序被分割成几个命名空间，就像在Clojure中一样。
- en: In Reagent, the state of the application is stored in a ratom (shorthand for
    reagent/atom), which has the same interface as regular Clojure atoms. The difference
    between a ratom and a Clojure atom is that when a ratom changes, the UI is rerendered.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reagent中，应用程序的状态存储在一个ratom（reagent/atom的缩写）中，它具有与常规Clojure原子相同的接口。ratom与Clojure原子的区别在于，当ratom发生变化时，UI会重新渲染。
- en: React.js embraces the functional programming approach and encourages the developer
    to build their frontend application from components that manipulate data structures.
    The data structures are rendered by React in the browser's **Document Object Model**
    (**DOM**) in a very efficient way. React keeps the developer's mind free from
    having to deal with the DOM at a low level, enabling them to focus on the business
    logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React.js采用了函数式编程方法，并鼓励开发者从操作数据结构的组件构建他们的前端应用程序。React以非常高效的方式在浏览器中的**文档对象模型**（**DOM**）中渲染数据结构。React使开发者免于处理DOM的低级操作，从而让他们能够专注于业务逻辑。
- en: Clojure's data-oriented approach, its immutable data structures, and the way
    it manages changes via atoms make React and ClojureScript a powerful combination.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的数据驱动方法、不可变数据结构以及通过原子管理变化的方式，使得React和ClojureScript成为了一个强大的组合。
- en: The Virtual DOM and Component Lifecycle
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM和组件生命周期
- en: When we build an application in React.js, we don't deal directly with the DOM,
    which is the browser's rendering mechanism and object model. Instead, React exposes
    a virtual DOM to the developer and keeps the implementation details hidden from
    them. This is what makes React so powerful. In a nutshell, when developing a React
    application, the developer writes React components that return data structures
    and the React frameworks automatically update the DOM and render the component
    on the UI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在React.js中构建应用程序时，我们并不直接与DOM打交道，DOM是浏览器的渲染机制和对象模型。相反，React向开发者提供了一个虚拟DOM，并隐藏了实现细节。这就是React如此强大的原因。简而言之，当开发React应用程序时，开发者编写返回数据结构的React组件，React框架会自动更新DOM并在UI上渲染组件。
- en: Moreover, React is smart enough to calculate the smallest amount of DOM changes
    that are required in order to update the state of the UI, which makes React applications
    highly performant.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React足够智能，可以计算出更新UI状态所需的最小DOM更改量，这使得React应用程序性能极高。
- en: If a complex component's behavior is required by the application, such as doing
    something special as soon as the component is mounted or just before the component
    is updated, React provides lifecycle methods that the component can interact with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要复杂组件的行为，例如组件挂载时或组件更新前执行特殊操作，React提供了组件可以与之交互的生命周期方法。
- en: 'Exercise 15.01: Creating a Reagent Application'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.01：创建Reagent应用程序
- en: 'In this exercise, we''re going to create a very simple Hiccup component in
    Reagent: an image with a couple of CSS properties. The CSS properties that we
    are going to use through the chapter are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个非常简单的Reagent组件：一个带有几个CSS属性的图片。我们将在本章中使用以下CSS属性：
- en: 'Padding: 7px; // the inner padding'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内边距：7px；// 内部填充
- en: 'Cursor: pointer; // the type of cursor'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光标：指针；// 光标的类型
- en: 'Margin-left: 10px; // horizontal spacing between elements'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外边距左：10px；// 元素之间的水平间距
- en: 'Margin-bottom: 10px; // vertical spacing between elements'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外边距下：10px；// 元素之间的垂直间距
- en: 'Border: 1px solid gray; // a 1px solid border of color gray'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边框：1px实线灰色；// 1px实线边框，颜色为灰色
- en: 'Border-radius: 10px; // the radius of the corners'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边框半径：10px；// 角落的半径
- en: 'Color: gray; // the text color'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色：灰色；// 文本颜色
- en: 'Font-size: 15px; // the size of the font'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小：15px；// 字体的大小
- en: 'Float: left; horizontal alignment instead of the default vertical alignment'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动：左；水平对齐代替默认的垂直对齐
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行提示符下，使用以下Leiningen命令创建一个新的Figwheel项目：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Change folder to the `packt-clj.reagent-sandbox/` directory and type the following
    command to launch the application:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件夹切换到`packt-clj.reagent-sandbox/`目录，并输入以下命令来启动应用程序：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒后，你的浏览器应该会打开默认的Figwheel页面：
- en: '![Figure 15.1: A fresh ClojureScript project waiting for your code'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.1：一个等待你编写代码的新ClojureScript项目'
- en: '](img/B14502_15_01.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_01.jpg)'
- en: 'Figure 15.1: A fresh ClojureScript project waiting for your code'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.1：一个等待你编写代码的新ClojureScript项目
- en: 'Under the current folder, open the `src/packt_clj/reagent_sandbox/core.cljs`
    file in your preferred editor and take a look at the following expression:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前文件夹下，使用你喜欢的编辑器打开`src/packt_clj/reagent_sandbox/core.cljs`文件，查看以下表达式：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code renders the UI by calling the `reagent/render-component` function
    with two arguments. The first is the Reagent component to render `[hello-world]`
    and the HTML element where the component is going to be rendered – in our case,
    the element whose ID is `app`.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码通过调用`reagent/render-component`函数并传入两个参数来渲染UI。第一个参数是要渲染的Reagent组件`[hello-world]`，第二个参数是组件将要渲染的HTML元素
    – 在我们的例子中，是ID为`app`的元素。
- en: 'Let''s look now at the `hello-world` function that renders the main component
    of the application:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看渲染应用程序主要组件的`hello-world`函数：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`hello-world` returns a vector, a Hiccup component of type `:div`, with two
    children. The first child is `[:h1 (:text @app-state)]`, which is an `:h1` component
    with text that comes from the `:text` value of the dereferencing of the `app-state`
    atom (see *Chapter 12*, *Concurrency*, about atoms). The second child is `[:h3
    "Edit this and watch it change!"]`, which is an `:h3` component with fixed text.
    Let''s see that in action!'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hello-world`返回一个向量，一个类型为`:div`的Hiccup组件，有两个子组件。第一个子组件是`[:h1 (:text @app-state)]`，这是一个`:h1`组件，其文本来自对`app-state`原子解引用的`:text`值（参见*第12章*，*并发*，关于原子的内容）。第二个子组件是`[:h3
    "Edit this and watch it change!"]`，这是一个`:h3`组件，具有固定文本。让我们看看它是如何工作的！'
- en: 'Go back to the Terminal window where you ran lein figwheel. You are in a Figwheel
    REPL. You should see a prompt like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你运行lein figwheel的终端窗口。你在一个Figwheel REPL中。你应该看到一个像这样的提示符：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s switch to the packt-clj.reagent-sandbox.core namespace by typing
    the following in the REPL:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在REPL中输入以下内容来切换到packt-clj.reagent-sandbox.core命名空间：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s inspect the state of our app:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们应用的状态：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And let''s modify the value of `:text` in the atom:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们修改atom中的`:text`值：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The application immediately updates with the new text:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序立即更新为新的文本：
- en: '![Figure 15.2: Printing the updated text'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.2：打印更新后的文本'
- en: '](img/B14502_15_02.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_02.jpg)'
- en: 'Figure 15.2: Printing the updated text'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：打印更新后的文本
- en: As we mentioned before, `app-state` is a ratom; therefore, when it changes,
    Reagent rerenders the UI.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`app-state`是一个ratom；因此，当它发生变化时，Reagent会重新渲染UI。
- en: 'Exercise 15.02: Displaying an Image with Style'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02：以样式显示图像
- en: 'Let''s render an image with a couple of CSS properties:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用几个CSS属性渲染一个图像：
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/packt_clj/reagent_sandbox/core.cljs`：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first part creates an image component and the second part includes an instance
    of the image component as part of the main component of the app. The moment you
    save the file, your app should look like this:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一部分创建了一个图像组件，第二部分将图像组件的实例作为应用主组件的一部分。当你保存文件时，你的应用应该看起来像这样：
- en: '![Figure 15.3: Rendering the image'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.3：渲染图像'
- en: '](img/B14502_15_03.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_03.jpg)'
- en: 'Figure 15.3: Rendering the image'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：渲染图像
- en: 'This is what we call hot code reloading: you change the code and the app updates
    immediately without refreshing the page.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的热代码重新加载：你更改代码，应用会立即更新，而无需刷新页面。
- en: Managing Component State
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理组件状态
- en: 'In Reagent, the behavior of a component depends on the state of the component.
    The state is stored in two places:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reagent中，组件的行为取决于组件的状态。状态存储在两个地方：
- en: The arguments passed to the component when the component is instantiated
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件实例化时传递给组件的参数
- en: A ratom
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ratom
- en: Arguments passed to the component cannot be modified by the component but a
    ratom can be modified. This is useful when we want to allow a component to change
    the state of itself (or of another component) upon user interaction (for example,
    a click).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给组件的参数不能被组件修改，但ratom可以被修改。当我们想要允许组件在用户交互（例如，点击）时更改其状态（或另一个组件的状态）时，这很有用。
- en: To build real-life production applications with complex application state, we
    use a framework on top of Reagent, for instance, Reframe, a popular framework
    for writing single-page applications on top of Reagent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建具有复杂应用状态的现实生活生产应用程序，我们在Reagent之上使用一个框架，例如，Reframe，这是一个在Reagent之上编写单页应用的流行框架。
- en: 'Exercise 15.03: A Button that Modifies Its Text'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.03：一个修改其文本的按钮
- en: 'Let''s create a toggle button whose initial text is "ON" and that changes its
    text to "OFF" when we click on it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个初始文本为"ON"的切换按钮，当我们点击它时，它会将其文本更改为"OFF"：
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`. We add to the `app-state` ratom
    information about whether the button is on or off by including a :`button-on?`
    key whose initial value is `true`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/packt_clj/reagent_sandbox/core.cljs`。我们向`app-state` ratom添加有关按钮是否开启的信息，通过包括一个初始值为`true`的`:button-on?`键：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we create the `button` component with the text of the button depending
    on the value of `:button-on?` and the click handler toggles the value of `:button-on?`.
    Notice that the click handler is referenced by `:on-click` (while in plain HTML,
    it''s `onClick`):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个`button`组件，按钮的文本取决于`:button-on?`的值，点击处理程序切换`:button-on?`的值。注意，点击处理程序通过`:on-click`引用（而在纯HTML中，它是`onClick`）：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we instantiate the button as part of our app:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将按钮实例化为我们应用的一部分：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Switch to your browser window, **refresh the page**, click on the button, and
    see how the text modifies itself. In this case, we have to refresh the page because
    we have changed the initial state of the app.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 切换到你的浏览器窗口，**刷新页面**，点击按钮，看看文本是如何修改的。在这种情况下，我们必须刷新页面，因为我们已经改变了应用程序的初始状态。
- en: 'You can also change the state of the button via the REPL:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以通过 REPL 更改按钮的状态：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The UI is updated immediately. We don't need to refresh the page due to hot
    reload. Clicking on the button or swapping the ratom are two equivalent ways to
    update the state of the app.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UI 立即更新。我们不需要刷新页面，因为热重载。点击按钮或交换 ratom 是更新应用程序状态的两种等效方式。
- en: Components with Children Components
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有子组件的组件
- en: As we saw when we introduced Hiccup, we can programmatically generate child
    components inside a Reagent component. For instance, we can start from an array
    of image URLs and convert each URL into an image component. This way, we are able
    to programmatically generate a grid of images.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍 Hiccup 时所看到的，我们可以在 Reagent 组件内部程序化地生成子组件。例如，我们可以从一个图像 URL 数组开始，将每个 URL
    转换为图像组件。这样，我们就能程序化地生成一个图像网格。
- en: 'Exercise 15.04: Creating a Grid of Images'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.04：创建图像网格
- en: 'Let''s create a component that renders a collection of images in a grid:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个组件，该组件以网格的形式渲染一系列图像：
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`. First, we create an `image-with-width`
    component that receives the image width as an argument:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/packt_clj/reagent_sandbox/core.cljs`。首先，我们创建一个 `image-with-width` 组件，该组件接收图像宽度作为参数：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a grid component as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建一个网格组件：
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we create a vector of image URLs:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个图像 URL 向量：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we instantiate the image grid with `my-images`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `my-images` 实例化图像网格：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, when we switch to the browser window, we see the following:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当我们切换到浏览器窗口时，我们看到以下内容：
- en: '![Figure 15.4: The image grid'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 15.4：图像网格'
- en: '](img/B14502_15_04.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_15_04.jpg]'
- en: 'Figure 15.4: The image grid'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.4：图像网格
- en: 'In order to get a better understanding of `image-grid`, let''s inspect the
    `Hiccup` vector returned by the `image-grid` function in the REPL when we pass
    to it the first three elements of `my-images`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地理解 `image-grid`，让我们检查在 REPL 中通过传递 `my-images` 的前三个元素给 `image-grid` 函数时返回的
    `Hiccup` 向量：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will return the following:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's a `:div` component with three children, where each child is a `:div` element
    with a `style` map and a nested `image-with-width-component`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有三个子组件的 `:div` 组件，其中每个子组件都是一个具有 `style` 映射和嵌套 `image-with-width-component`
    的 `:div` 元素。
- en: Hot Reload
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热重载
- en: Have you noticed that `app-state` is defined via `defonce` and not via `def`,
    like we usually define vars in Clojure?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到 `app-state` 是通过 `defonce` 而不是通过 `def` 定义的，就像我们通常在 Clojure 中定义变量一样？
- en: The difference between `defonce` and `def` is that when `defonce` is called
    twice, the second call has no effect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`defonce` 和 `def` 之间的区别在于，当 `defonce` 被调用两次时，第二次调用没有效果。'
- en: 'Let''s take a look at a simple example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The value of `a` is now `1`. In the context of hot reloading, defonce is crucial.
    The reason is that with hot code reloading, we want:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 的值现在是 `1`。在热重载的上下文中，`defonce` 是至关重要的。原因是，在热代码重载的情况下，我们希望：'
- en: The code to be reloaded
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重新加载的代码
- en: The state of the app to remain the same
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` 的状态保持不变'
- en: Those two desires seem contradictory because the initial state of the `app`
    is defined in the code. As a consequence, reloading the code seems to imply re-initializing
    the state of the `app`. Here, `defonce` comes to the rescue. The code that sets
    the initial state of the `app` is called only once!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个愿望似乎相互矛盾，因为 `app` 的初始状态是在代码中定义的。因此，重新加载代码似乎意味着重新初始化 `app` 的状态。在这里，`defonce`
    来拯救我们。设置 `app` 初始状态的代码只调用一次！
- en: If you are curious, you can, just for the sake of understanding the difference
    between `defonce` and `def`, replace `defonce` with `def` in the code of the app
    you built and see how the app comes back to its initial state each time we save
    a code change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，你可以在理解 `defonce` 和 `def` 之间的区别的目的是，在你的应用程序代码中将 `defonce` 替换为 `def`，并看看每次我们保存代码更改时应用程序如何回到其初始状态。
- en: JavaScript Interop
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 互操作
- en: 'Now it''s time to learn how in ClojureScript, we can interop with the underlying
    JavaScript language. By interop, we mean mainly:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习在 ClojureScript 中如何与底层 JavaScript 语言进行互操作了。通过互操作，我们主要指的是：
- en: Accessing the window global object from ClojureScript
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 ClojureScript 访问窗口全局对象
- en: Calling a JavaScript function from ClojureScript code
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 ClojureScript 代码中调用 JavaScript 函数
- en: Converting between JavaScript and ClojureScript objects
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript和ClojureScript对象之间进行转换
- en: 'In order to access the window scope, we use the `js/` prefix. For instance,
    `js/document` represents the document object and `js/Math.abs` represents the
    `abs` function in the `Math` scope. In order to call a method on a JavaScript
    object, we use dot notation, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问窗口作用域，我们使用`js/`前缀。例如，`js/document`代表文档对象，`js/Math.abs`代表`Math`作用域中的`abs`函数。为了在JavaScript对象上调用方法，我们使用点符号，如下所示：
- en: '`(. js/Math abs -3)` is equivalent to `Math/abs(3)`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(. js/Math abs -3)`等同于`Math.abs(3)`。'
- en: '`(. js/document (getElementById "app"))` corresponds to `document. getElementById("app")`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(. js/document (getElementById "app"))`对应于`document.getElementById("app")`。'
- en: 'Now, you can fully understand the expression in `src/packt_clj/reagent_sandbox/core.cljs`
    that renders the UI:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以完全理解`src/packt_clj/reagent_sandbox/core.cljs`中的表达式，该表达式渲染UI：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we want to convert between JavaScript and ClojureScript objects, we use
    the js->clj and clj->js functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在JavaScript和ClojureScript对象之间进行转换时，我们使用`js->clj`和`clj->js`函数。
- en: 'Consider the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This returns the JavaScript object {total: 42}, represented in the REPL as
    #js {:total 42}.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这返回了JavaScript对象`{total: 42}`，在REPL中表示为`#js {:total 42}`。'
- en: 'Notice that ClojureScript keywords are converted into strings:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意ClojureScript关键词被转换为字符串：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This returns the JavaScript object `{total: 42}`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '这返回了JavaScript对象`{total: 42}`。'
- en: '`clj->js` works recursively, which means that nested objects are also converted
    to JavaScript objects. Consider the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`clj->js`是递归的，这意味着嵌套对象也被转换为JavaScript对象。考虑以下示例：'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will return the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also use the `#js` notation to generate a JavaScript object, but note
    that it is not recursive. `#js {:total 42}` in ClojureScript generates `{total:
    42}` in JavaScript.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以使用`#js`表示法来生成JavaScript对象，但请注意它不是递归的。ClojureScript中的`#js {:total 42}`在JavaScript中生成`{total:
    42}`。'
- en: 'What about the other direction, from JavaScript to ClojureScript? You use the
    `js->clj` function. `(js->clj #js {"total" 42})` returns the ClojureScript object
    `{"total" 42}`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '那么从JavaScript到ClojureScript的方向呢？你使用`js->clj`函数。`(js->clj #js {"total" 42})`返回ClojureScript对象`{"total"
    42}`。'
- en: 'If you want JavaScript strings to be converted to ClojureScript keywords, you
    need to keywordize the keys by passing extra args to `js->clj`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将JavaScript字符串转换为ClojureScript关键词，你需要通过传递额外的参数到`js->clj`来对键进行关键词化：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This returns the ClojureScript object `{:total 42}`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回ClojureScript对象`{:total 42}`。
- en: 'Exercise 15.05: Fetching Data from an HTTP Endpoint'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.05：从HTTP端点获取数据
- en: 'Let''s use our JavaScript interop knowledge to fetch data from an HTTP endpoint
    that returns JSON, namely [https://packt.live/2RURzar](https://packt.live/2RURzar).
    This endpoint returns a JSON array made of three objects with data about images:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的JavaScript互操作知识从返回JSON的HTTP端点获取数据，即[https://packt.live/2RURzar](https://packt.live/2RURzar)。此端点返回一个由三个对象组成的JSON数组，包含有关图片的数据：
- en: 'In JavaScript, we would fetch the JSON by using the JavaScript `fetch` function
    and two promises to convert the server response into a JSON object:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们会使用JavaScript的`fetch`函数和两个承诺将服务器响应转换为JSON对象：
- en: '[PRE36]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In ClojureScript, the preceding code translates to the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ClojureScript中，前面的代码翻译成以下内容：
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It prints a ClojureScript vector to the console with three ClojureScript objects:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将三个ClojureScript对象打印到控制台上的ClojureScript向量中：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All the pieces are now in place to build a small frontend application that displays
    a grid of images from the internet.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有部件现在都已就绪，可以构建一个小的前端应用程序，该应用程序显示来自互联网的图像网格。
- en: 'Activity 15.01: Displaying a Grid of Images from the Internet'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.01：从互联网显示图像网格
- en: 'You are asked to write a frontend application for a freelancer graphics editor
    that displays a grid of six images from and two buttons:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求为一名自由职业图形编辑器编写一个前端应用程序，该应用程序显示来自互联网的六张图片和两个按钮：
- en: A button that clears the images
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个清除图片的按钮
- en: A button that hides the authors' names
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个隐藏作者名字的按钮
- en: This button can be used by the graphics editor to see the author names to add
    to the images.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮可以被图形编辑器用来查看添加到图片中的作者名字。
- en: 'These steps will help you complete the activity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Create a new Figwheel project.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Figwheel项目。
- en: Create two buttons; one will clear images and the other will hide author names.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个按钮；一个将清除图片，另一个将隐藏作者名字。
- en: Add the images.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加图片。
- en: 'Upon completing the activity, you should be able to see something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动后，你应该能看到类似以下的内容：
- en: '![Figure 15.5: Expected outcome'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.5：预期结果'
- en: '](img/B14502_15_05.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_15_05.jpg)'
- en: 'Figure 15.5: Expected outcome'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：预期结果
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 758.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第758页找到。
- en: 'Activity 15.02: Tennis Players with Ranking'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.02：排名的网球运动员
- en: Let's wrap up this chapter by combining the knowledge gained from it with the
    material we covered in *Chapter 14*, *HTTP with Ring*. In the activity of *Chapter
    14*, *HTTP with Ring*, we built an HTTP API server that returned data about tennis
    players. In the current activity, you are asked to build a frontend for this HTTP
    server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过结合从本章获得的知识和我们在*第14章*中讨论的材料来结束本章。在第14章的*使用Ring的HTTP*活动中，我们构建了一个返回网球运动员数据的HTTP
    API服务器。在当前活动中，你被要求为这个HTTP服务器构建一个前端。
- en: 'You have to build a web app that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须构建一个Web应用，它：
- en: Displays the names of all the tennis players
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有网球运动员的名字
- en: Displays the ranking of any tennis player when the user clicks on their name
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击他们的名字时，显示任何网球运动员的排名
- en: Before starting, you need to perform the activity from *Chapter 14*, *HTTP with
    Ring*, with a slight change in the code of the server to support API requests
    from the web app we are going to build. The current activity is going to request
    data from this server. By default, web servers don't allow requests that come
    from another host. In our case, the API server runs on port `8080` while the frontend
    server runs on port `3449`. In order to allow requests that come from the frontend
    app to be served by the API server, we need to configure the API server so that
    it allows **Cross-Origin Resource Sharing** (**CORS**).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要执行*第14章*，*使用Ring的HTTP*的活动，对服务器的代码进行轻微修改以支持我们将要构建的Web应用的API请求。当前活动将从该服务器请求数据。默认情况下，Web服务器不允许来自另一个主机的请求。在我们的情况下，API服务器运行在端口`8080`，而前端服务器运行在端口`3449`。为了允许前端应用发出的请求由API服务器提供服务，我们需要配置API服务器，使其允许**跨源资源共享**（**CORS**）。
- en: 'Before starting the activity, you''ll need to make the following changes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始活动之前，你需要进行以下更改：
- en: Open the folder that contains the code of *Activity 14.01*, *Exposing Historic
    Tennis Results and ELO Calculations via REST*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包含*活动 14.01*，*通过REST公开历史网球结果和ELO计算*代码的文件夹。
- en: 'Add the following dependency to the `deps.edn` file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到`deps.edn`文件中：
- en: '[PRE39]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open the `packt-clj/src/packt_clj/tennis/api.clj` file and add the following
    line in the `require` expression at the top of the file:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`packt-clj/src/packt_clj/tennis/api.clj`文件，并在文件顶部的`require`表达式中添加以下行：
- en: '[PRE40]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Open the `packt-clj/src/packt_clj/tennis/api.clj` file and add the following
    two lines in the definition of the `run` function at the end of the file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`packt-clj/src/packt_clj/tennis/api.clj`文件，并在文件末尾`run`函数的定义中添加以下两行：
- en: '[PRE41]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `run` function should now look like this:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`run`函数现在应该看起来像这样：'
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, run the server as explained in *Activity 14.01*, Exposing Historic Tennis
    Results and ELO Calculations via REST.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照*活动 14.01*，通过REST公开历史网球结果和ELO计算的解释来运行服务器。
- en: 'Follow these steps to complete this activity:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Set up a new Figwheel project that uses Reagent.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个新的Figwheel项目，使用Reagent。
- en: Write code that fetches tennis player data from the server from *Chapter 14*,
    HTTP with Ring, and inserts it into the application state of your new ClojureScript
    app. You'll also want a field in the application state for the current player
    when a player has been selected.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，从*第14章*，使用Ring的HTTP，从服务器获取网球运动员数据，并将其插入你新的ClojureScript应用的应用状态中。你还需要在应用状态中为所选的运动员提供一个当前运动员的字段。
- en: Write views for displaying the list of players and for displaying a single player
    with their data.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写用于显示玩家列表和用于显示单个玩家及其数据的视图。
- en: Incorporate handlers for the links that select the player to view, and for the
    buttons that load and clear the list of players.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成处理选择要查看的运动员的链接和加载和清除玩家列表的按钮的处理程序。
- en: 'Upon completing the current activity, you should see something like this in
    your browser:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成当前活动后，你应该在浏览器中看到如下内容：
- en: '![Figure 15.6: List of players'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 15.6：玩家列表'
- en: '](img/B14502_15_06.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_06.jpg)'
- en: 'Figure 15.6: List of players'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6：玩家列表
- en: 'And when the user clicks on Michael Stich, the app looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击Michael Stich时，应用看起来像这样：
- en: '![Figure 15.7: The rating of a player'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.7：运动员的评级'
- en: '](img/B14502_15_07.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_15_07.jpg)'
- en: 'Figure 15.7: The rating of a player'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7：运动员的评级
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 762.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第762页找到。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the basics of how to build a frontend application
    in ClojureScript using Reagent, a wrapper around React.js.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Reagent（React.js的包装器）在ClojureScript中构建前端应用程序的基础知识。
- en: We built a couple of Reagent components using the Hiccup markup language, which
    uses Clojure collections to define the HTML structure and properties. The state
    of the application is stored in a Reagent atom that you interacted with through
    the REPL.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Hiccup标记语言构建了几个Reagent组件，该语言使用Clojure集合来定义HTML结构和属性。应用程序的状态存储在一个Reagent原子中，您通过REPL与之交互。
- en: We saw how to call JavaScript code from ClojureScript and how to convert between
    JavaScript and ClojureScript objects. You used these interop features to fetch
    image data from an HTTP server and convert the data into a ClojureScript object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何从ClojureScript调用JavaScript代码，以及如何在不同对象之间进行转换。您使用这些互操作功能从HTTP服务器获取图像数据，并将数据转换为ClojureScript对象。
- en: We've reached the end of the book. You've seen a lot of new things since the
    first pages of *Chapter 1*, *Hello REPL!*. Beyond the syntactic basics, you've
    learned a lot about functional programming and, even more importantly, how to
    think in a functional way. It's one thing to know what immutability is and something
    else entirely to know how to accomplish tasks using immutable data. By focusing
    intensively on collections, we were able to show you some of Clojure's most distinctive
    features, such as lazy sequences, while building up your mental library of useful
    patterns for solving problems. Clojure is often considered a data-centric language,
    so collections are a key part of that. Programming is more than just mastering
    language features.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书的结尾。从*第一章*的首页开始，您已经看到了很多新事物，*Hello REPL!*。除了语法基础之外，您还学到了很多关于函数式编程的知识，更重要的是，您学会了如何以函数式的方式思考。知道不可变性是什么是一回事，而知道如何使用不可变数据完成任务则是另一回事。通过专注于集合，我们能够向您展示Clojure的一些最独特特性，如惰性序列，同时构建您解决问题的思维模式库。Clojure通常被认为是一种以数据为中心的语言，因此集合是其关键部分。编程不仅仅是掌握语言特性。
- en: 'Our other focus has been on getting things done with Clojure, and that means
    knowing how to navigate in the Clojure tooling ecosystem. You''ve learned how
    to set up projects, how to use Leiningen for both Clojure and ClojureScript projects,
    and how to organize your namespaces. Platforms and interop are an important part
    of that picture too: you know the basics of using Java or JavaScript features
    in your Clojure(Script). Testing is another necessary skill for any real-world
    project. You know about that too now. You''ve also seen enough of macros and Clojure''s
    concurrency tools that you will know where to start the first time you need them
    to solve a complex problem.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的另一个重点是使用Clojure完成任务，这意味着您需要了解如何在Clojure工具生态系统中进行导航。您已经学会了如何设置项目，如何为Clojure和ClojureScript项目使用Leiningen，以及如何组织命名空间。平台和互操作性也是这幅画面的重要组成部分：您已经了解了如何在Clojure(Script)中使用Java或JavaScript功能。测试对于任何真实世界的项目来说也是一项必要的技能。您现在也已经了解了这一点。您还看到了足够多的宏和Clojure的并发工具，以至于您将知道在需要解决复杂问题时从哪里开始。
- en: Finally, you've worked with databases and web servers. On just about any software
    project, at least one of those two technologies will be present. Often, both will
    be. These are both vast topics in their own right, of course, but by now you have
    an idea of how to approach them in a Clojure way—and in a ClojureScript way, as
    you've done in this chapter. And beyond the details, we hope that your first steps
    in Clojure have opened your eyes to new ways of thinking about programming. That
    way, you'll be able to learn whatever you need down the road.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您已经处理过数据库和Web服务器。在几乎任何软件项目中，至少会有这两种技术中的之一存在。通常，两者都会存在。当然，这两个主题本身都非常广泛，但到目前为止，您已经了解了如何以Clojure的方式——正如您在本章中所做的那样——以及以ClojureScript的方式接近它们。而且，除了细节之外，我们希望您在Clojure中的第一步已经让您对编程的新思维方式有了认识。这样，您将能够学习未来需要的任何东西。
