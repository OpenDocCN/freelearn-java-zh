- en: Chapter 13. Testing Your Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。测试你的应用程序
- en: 'In previous chapters, we covered the most important technologies of the Java
    EE platform. However, every professional developer knows that software development
    should begin from writing tests. At first, it does not sound easy to be able to
    verify the correctness of the execution of EJBs, database-related code, or, for
    example, REST services but it appears really straightforward when using the right
    tools! In this chapter, we will present the fundamental testing framework used
    for Java EE applications testing: the Arquillian. Additionally, we will take a
    look at its extensions and related libraries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了 Java EE 平台最重要的技术。然而，每个专业开发者都知道，软件开发应该从编写测试开始。起初，能够验证 EJBs、数据库相关代码或
    REST 服务等的执行正确性似乎并不容易，但使用正确的工具时，这看起来非常直接！在本章中，我们将介绍用于 Java EE 应用程序测试的基本测试框架：Arquillian。此外，我们还将探讨其扩展和相关库。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: An introduction to enterprise testing, from mock objects to the Arquillian framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模拟对象到 Arquillian 框架的企业级测试简介
- en: How to integrate an Arquillian test case for our ticket machine application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Arquillian 测试用例集成到我们的票务机应用程序中
- en: How to use the Eclipse IDE and Maven shell to run Arquillian tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Eclipse IDE 和 Maven shell 运行 Arquillian 测试
- en: The most important Arquillian extensions and how to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的 Arquillian 扩展及其使用方法
- en: Test types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: The word *tests* can be interpreted in multiple ways. Most often, tests perform
    the validation and verification of the application requirements. Tests can be
    performed on multiple levels, covering single methods to whole business features.
    Tests can also cover nonfunctional aspects such as security or performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “测试”这个词可以有多种解释。最常见的是，测试执行应用程序需求的验证和验证。测试可以在多个级别上执行，从单个方法到整个业务功能。测试还可以涵盖非功能性方面，如安全或性能。
- en: 'First, let''s introduce categories of tests that validate the functional requirements.
    Mike Cohn has introduced a concept of the test pyramid, which is shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍验证功能性需求的测试类别。Mike Cohn 提出了一个测试金字塔的概念，如下所示：
- en: '![Test types](img/00102.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![测试类型](img/00102.jpeg)'
- en: As you can see, the majority of tests in an application are usually tests that
    cover units of code. A unit can be a single method, the most basic feature. Because
    of this scope, these type of tests are called **unit tests**. They can be defined
    as tests written by a programmer to verify that a relatively small piece of functionality
    is doing what it is intended to do. Because the unit is rather small, the number
    of these tests increases rapidly, so they become the fundament of application
    testing appearing on the lowest level of the pyramid.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，应用程序中的大多数测试通常是覆盖代码单元的测试。一个单元可以是一个单独的方法，这是最基本的功能。正因为这个范围，这类测试被称为**单元测试**。它们可以被定义为程序员编写的测试，以验证相对较小的功能是否按预期工作。由于单元相对较小，这些测试的数量会迅速增加，因此它们成为金字塔最低层的应用测试基础。
- en: The next type of tests concerns bigger areas of code. They cover whole services
    or business features. This means they cover multiple units of code and concern
    different modules and libraries. The number of such tests would be lower than
    the number of unit tests. This type of test is often called an **integration test**.
    Integration tests are done to demonstrate that different pieces of the system
    work together; since they cover entire applications, they require much more effort
    to be put together. For example, they usually require resources such as database
    instances and hardware to be allocated for them. Integration tests do a more convincing
    job of demonstrating how the system works (especially to nonprogrammers); at least
    to the extent that the integration test environment resembles the production environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种类型的测试关注更大的代码区域。它们覆盖整个服务或业务功能。这意味着它们覆盖多个代码单元，涉及不同的模块和库。这种测试的数量将低于单元测试的数量。这种类型的测试通常被称为**集成测试**。集成测试的目的是证明系统的不同部分可以协同工作；由于它们覆盖整个应用程序，因此需要投入更多的努力来构建。例如，它们通常需要为它们分配数据库实例和硬件等资源。集成测试在证明系统如何工作方面做得更有说服力（尤其是对非程序员来说）；至少在集成测试环境与生产环境相似的程度内。
- en: The last type of tests are UI tests, which can also be called acceptance tests.
    Their number is the smallest in the project; they are usually the most troublesome
    to write to simulate the user interacting with the application. They cover whole
    requirements and features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种测试类型是UI测试，也可以称为验收测试。它们在项目中的数量最少；它们通常是最难编写的，以模拟用户与应用程序的交互。它们覆盖整个需求和功能。
- en: Let's leave the topic of nonfunctional tests. For now, you have to only remember
    that they can cover topics related to performance, security, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放下非功能性测试的话题。目前，你只需要记住它们可以涵盖与性能、安全等相关的话题。
- en: Instruments used for testing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于测试的仪器
- en: As you can imagine, each kind of testing uses a different approach and often
    requires different testing libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，每种测试类型都使用不同的方法，通常需要不同的测试库。
- en: When you're writing unit tests, you have to just provide some method input parameters,
    and validate if their outcome covers the expectations. To do this in Java, you
    probably already use **JUnit**, **TestNG**, or **Spock**. When you're moving from
    bigger parts of code to testing whole services, some problems may appear. It's
    often hard to separate the code you'd like to test, to make it testable without
    running all the other services. You usually create some mock objects that simulate
    behavior of modules you don't want to include in your test. If you have an object
    whose methods you want to test, and if these methods depend on another object,
    you can create a mock of the dependency rather than an actual instance of that
    dependency. This allows you to test your object in isolation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写单元测试时，你只需提供一些方法输入参数，并验证它们的输出是否符合预期。在Java中，你可能已经使用了**JUnit**、**TestNG**或**Spock**。当你从更大的代码部分转向测试整个服务时，可能会出现一些问题。通常很难分离你想要测试的代码，使其可测试而不需要运行所有其他服务。你通常会创建一些模拟对象来模拟你不想包含在测试中的模块的行为。如果你有一个你想要测试的对象，并且如果这些方法依赖于另一个对象，你可以创建一个依赖项的模拟而不是依赖项的实际实例。这允许你在隔离的情况下测试你的对象。
- en: As an example, one common use case might be in database applications, where
    you would like to test, for example, the user registration process but you don't
    want to run the whole database (which means that you will set its schema, some
    initial data, and finally clean its state manually after the test is complete).
    You can mock just the database interaction and define the behavior of some methods
    execution, for example, your stub will always return four users, which will be
    hardcoded in your test code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个常见的用例可能是在数据库应用程序中，你想要测试，例如，用户注册过程，但你不想运行整个数据库（这意味着你将设置其模式，一些初始数据，并在测试完成后手动清理其状态）。你可以模拟数据库交互并定义某些方法执行的行为，例如，你的存根将始终返回四个用户，这些用户将被硬编码在你的测试代码中。
- en: This kind of approach, although very immediate to understand and put into practice,
    has several limitations. Firstly, it relegates you into an artificial environment,
    where you will often make invalid assumptions about the behavior and stability
    of that environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然很容易理解并付诸实践，但有几个局限性。首先，它让你陷入一个人工环境，你经常会对该环境的行為和稳定性做出无效的假设。
- en: Secondly, you will end up with a hard-to-maintain mock code, which will allow
    your tests to pass and give you the warm feeling of having done a great job.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可能会得到一段难以维护的模拟代码，这会让你的测试通过，并给你一种完成了出色工作的温暖感觉。
- en: Thirdly, sometimes it's very hard to isolate a service you'd like to test, and
    code mocking all its interactions can be larger than the code of the meaningful
    tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，有时很难隔离你想要测试的服务，并且模拟所有交互的代码可能比有意义的测试代码还要长。
- en: So, even if mock objects may still provide some benefits to start systems, where
    you don't have full implementations of a particular subsystem, it might be good
    to stay as close as possible to the target environment that the code is supposed
    to run in. At some point, The No Mock Movement (**Not Only Mocks Movement**) was
    launched pointing out that mocking often takes too much time, and makes you focus
    on writing mocks instead of writing tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使模拟对象可能对启动系统提供一些好处，尤其是在你没有某个特定子系统的完整实现时，最好尽可能接近代码预期运行的靶环境。在某个时刻，无模拟运动（**非仅模拟运动**）被发起，指出模拟通常花费太多时间，并让你专注于编写模拟而不是编写测试。
- en: '**Arquillian** tries to solve these problems. It is a platform that simplifies
    integration testing for Java middleware. It deals with all the plumbing of container
    management, deployment, and framework initialization so that you can focus on
    the task of writing your tests—real tests. Arquillian minimizes the burden on
    you—for the developer—by covering aspects surrounding test execution; some of
    these aspects are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arquillian**试图解决这些问题。它是一个简化Java中间件集成测试的平台。它处理所有容器管理、部署和框架初始化的底层工作，这样你就可以专注于编写测试任务——真正的测试。Arquillian通过覆盖测试执行周围的方面来最小化对开发者的负担；以下是一些方面：'
- en: Managing the life cycle of the container (start/stop)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器的生命周期（启动/停止）
- en: Bundling the test class with the dependent classes and resources into a deployable
    archive
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试类及其依赖的类和资源捆绑成一个可部署的存档
- en: Enhancing the test class (for example, resolving the `@Inject`, `@EJB`, and
    `@Resource` injections)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强测试类（例如，解决`@Inject`、`@EJB`和`@Resource`注入）
- en: Deploying the archive to test applications (deploy/undeploy), and capturing
    results and failures
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存档部署到测试应用程序（部署/卸载），并捕获结果和失败
- en: Arquillian also has extensions that enhance its features, for example, allowing
    it to perform UI tests or some nonfunctional tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian还有扩展，可以增强其功能，例如，允许它执行UI测试或一些非功能性测试。
- en: In the next section, we will discuss which instruments are required to run your
    integration tests using Arquillian.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论运行你的集成测试所需的仪器。
- en: Getting started with Arquillian
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Arquillian
- en: Although Arquillian does not depend on a specific build tool, it is commonly
    used with Maven; it offers dependency management and thus simplifies the task
    of including the Arquillian libraries in the application since they are distributed
    in the Central Maven repository.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Arquillian不依赖于特定的构建工具，但它通常与Maven一起使用；它提供依赖管理，因此简化了将Arquillian库包含到应用程序中的任务，因为它们分布在Maven中央仓库中。
- en: 'Depending on the type of archetype you used for generation, you might have
    a different folder structure in your project; this is not an issue. What is really
    important is that you provide the following structure under your `src` folder:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你用于生成的存档类型，你的项目可能会有不同的文件夹结构；这不是问题。真正重要的是，你需要在你的`src`文件夹下提供以下结构：
- en: '`main/java/`: Place all application Java source files here (under the Java
    package)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main/java/`: 将所有应用程序Java源文件放在这里（在Java包下）'
- en: '`main/resources/`: Place all application configuration files here'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main/resources/`: 将所有应用程序配置文件放在这里'
- en: '`test/java/`: Place all test Java source files here (under the Java package)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test/java/`: 将所有测试Java源文件放在这里（在Java包下）'
- en: '`test/resources/`: Place all test configuration files here (for example, `persistence.xml`)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test/resources/`: 将所有测试配置文件放在这里（例如，`persistence.xml`）'
- en: So by now, we will be working under `test/java`, which is where we will place
    our first Arquillian test class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们将在`test/java`下工作，这是我们放置第一个Arquillian测试类的地方。
- en: Writing an Arquillian test
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Arquillian测试
- en: If you have been working with JUnit ([http://www.junit.org](http://www.junit.org)),
    you will find a similar Arquillian test, with some extra spice in it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用JUnit ([http://www.junit.org](http://www.junit.org))，你将找到一个类似的Arquillian测试，其中包含一些额外的特色。
- en: In order to do this, we will use Eclipse and Maven, just as we have done so
    far. If you are about to add test classes to your project, there is obviously
    no need to create a new project for this purpose. However, for learning purposes,
    we delivered this example in a separate project so that you can see exactly what
    to add in order to run Arquillian tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用Eclipse和Maven，就像我们迄今为止所做的那样。如果你即将向你的项目添加测试类，显然没有必要为此创建一个新的项目。然而，为了学习目的，我们在这个单独的项目中提供了这个示例，这样你可以确切地看到为了运行Arquillian测试需要添加什么。
- en: In order to avoid recreating the whole project from scratch, you could simply
    clone the `ticket-agency-jpa` project and name it `ticket-agency-test`, moving
    the root package from `com.packtpub.wflydevelopment.chapter5` to `com.packtpub.wflydevelopment.chapter13`.
    If this still seems like too much work, you could simply import the `Chapter13`
    project from the book sample.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免从头开始重新创建整个项目，你可以简单地克隆`ticket-agency-jpa`项目并将其命名为`ticket-agency-test`，将根包从`com.packtpub.wflydevelopment.chapter5`移动到`com.packtpub.wflydevelopment.chapter13`。如果这仍然看起来工作量太大，你可以直接从书中的示例导入`Chapter13`项目。
- en: Configuring the pom.xml file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置pom.xml文件
- en: 'The first thing that is necessary to include in order to run an Arquillian
    test is the `junit` dependency, which is required to run our unit tests:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Arquillian测试所必需的第一件事是包含`junit`依赖项，这是运行我们的单元测试所必需的：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In earlier chapters, we introduced the term **Bill of Materials** (**BOM**).
    Now, we will use the Arquillian BOM in order to import versions of all Arquillian-related
    dependencies:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了术语**物料清单**（**BOM**）。现在，我们将使用Arquillian BOM来导入所有与Arquillian相关的依赖项的版本：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re using Arquillian with JUnit (like mentioned before other possibilities
    are `TestNG`, `Spock`, `JBehave`, and `Cucumber`) so we need to include the appropriate
    dependency:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Arquillian与JUnit（如前所述，其他可能性有`TestNG`、`Spock`、`JBehave`和`Cucumber`），因此我们需要包含适当的依赖项：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After being done with the basic dependencies, we now have to specify the container
    against which the tests will be run. Container adapters are available for the
    more important Java EE Application Servers (WildFly, Glassfish, WebLogic, and
    WebSphere), as well as for some servlet containers such as Tomcat or Jetty. Here,
    we want to use WildFly so we will use an appropriate container adapter. However,
    we have a few possible choices. Container adapters can be divided into three basic
    groups:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成基本依赖项之后，我们现在必须指定测试将运行的容器。对于更重要的Java EE应用程序服务器（WildFly、Glassfish、WebLogic和WebSphere）以及一些Servlet容器（如Tomcat或Jetty），都提供了容器适配器。在这里，我们想使用WildFly，因此我们将使用适当的容器适配器。然而，我们有几种可能的选择。容器适配器可以分为三个基本组：
- en: '**Embedded**: This is the mode in which a container is run on the same JVM
    instance the tests are running. Often, a container run in this mode is not an
    original one, but packed to a single JAR limited version.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式**：这是在测试运行的同一JVM实例上运行容器的模式。通常，在这种模式下运行的容器不是原始的，而是打包到一个单一的JAR文件中，具有有限的版本。'
- en: '**Managed**: In this mode, the real application server is run on a separate
    JVM. As the name implies, it''s possible to manage the state of the container,
    run it, stop it, and so on. By default, when you run the test, the server is started,
    tests are run against it, and then it is stopped. However, it is possible to configure
    Arquillian to run tests on the already running instance.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管**：在这种模式下，真实的应用程序服务器在单独的JVM上运行。正如其名所示，可以管理容器状态，启动它，停止它等。默认情况下，当你运行测试时，服务器启动，测试针对它运行，然后停止。然而，可以配置Arquillian在已运行的实例上运行测试。'
- en: '**Remote**: In this mode, we just connect to some existing server instance
    and run tests against it.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程**：在这种模式下，我们只是连接到某个现有的服务器实例并对其运行测试。'
- en: 'The most universal choice to run tests is the managed container. Tests are
    run on the real server, same as on the production environment, and additionally,
    it is possible to manage its state, allowing for some more advanced tests such
    as testing features related to high-availability or communication between two
    applications that run on different instances. Now, we need to add the appropriate
    container adapter to our `pom.xml` file. To do this, we will create a Maven profile:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的最通用选择是托管容器。测试在真实服务器上运行，与生产环境相同，此外，还可以管理其状态，允许进行一些更高级的测试，例如测试与高可用性或运行在不同实例上的两个应用程序之间的通信相关的功能。现在，我们需要将适当的容器适配器添加到我们的`pom.xml`文件中。为此，我们将创建一个Maven配置文件：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There might be situations in which you'd like to run tests against different
    application servers. It's possible to just define a few Maven profiles and run
    tests a few times, each time activating other profiles. Keep in mind that some
    application servers don't provide all types of the adapters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，你希望针对不同的应用程序服务器运行测试。你可以定义几个Maven配置文件，并多次运行测试，每次激活其他配置文件。记住，一些应用程序服务器不提供所有类型的适配器。
- en: 'There is one more container-related topic. Our Arquillian tests use a protocol
    to communicate with the micro deployment on the application server. If we don''t
    specify the protocol, the container will choose the default one. In order to specify
    it manually, we will need to add the `org.jboss.arquillian.protocol` dependency
    (named so as it''s compatible with Servlet 3.0 specifications):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个与容器相关的话题。我们的Arquillian测试使用一个协议与应用程序服务器上的微部署进行通信。如果我们不指定协议，容器将选择默认的协议。为了手动指定它，我们需要添加`org.jboss.arquillian.protocol`依赖项（这样命名是为了与Servlet
    3.0规范兼容）：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Writing your first Arquillian test
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个Arquillian测试
- en: 'Once the configuration is complete, we will finally code our test. So, create
    a Java class named `TicketTest` under the package `com.packtpub.wflydevelopment.chapter13.test`.
    The first thing that you will add to this class is the following annotation that
    tells JUnit to use Arquillian as the test controller:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，我们最终将编写我们的测试代码。因此，在包`com.packtpub.wflydevelopment.chapter13.test`下创建一个名为`TicketTest`的Java类。你将首先添加到这个类的以下注解，告诉JUnit使用Arquillian作为测试控制器：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Arquillian then looks for a static method with the `@Deployment` annotation;
    it creates a micro deployment including all the specified classes and resources
    (instead of deploying the whole application), allowing to test only part of the
    system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian随后会寻找一个带有`@Deployment`注解的静态方法；它创建一个包含所有指定类和资源的微部署（而不是部署整个应用程序），允许只测试系统的一部分：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fluent API provided by the **ShrinkWrap** project ([http://www.jboss.org/shrinkwrap](http://www.jboss.org/shrinkwrap))
    makes this technique possible using the `create` method, which accepts the type
    of deployment unit (`WebArchive`) as the argument and all the resources are included
    in this archive. In our case, instead of including all the single classes, we
    use the `addPackage` utility method that adds all the classes that are contained
    in a class package (for example, by adding the `SeatType.class.getPackage()` method,
    we will include all the classes that are in the same package as the `SeatType`
    class). Our project uses the JPA, so we also add persistence configuration; here,
    we specify a path to the `.xml` file, so we can point, for example, to some other
    test configuration using some other non-production database. And, of course, we
    also have to add the empty `beans.xml` file in order to enable the CDI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShrinkWrap**项目提供的流畅API（[http://www.jboss.org/shrinkwrap](http://www.jboss.org/shrinkwrap)）使得使用`create`方法实现这种技术成为可能，该方法接受部署单元的类型（`WebArchive`）作为参数，并将所有资源包含在这个归档中。在我们的例子中，我们不是包含所有单个类，而是使用`addPackage`实用方法添加包含在类包中的所有类（例如，通过添加`SeatType.class.getPackage()`方法，我们将包括与`SeatType`类在同一包中的所有类）。我们的项目使用JPA，所以我们还添加了持久化配置；在这里，我们指定`.xml`文件的路径，这样我们就可以指向使用其他非生产数据库的某些其他测试配置。当然，我们还需要添加空的`beans.xml`文件以启用CDI。'
- en: 'Finally, we inject the service we would like to test (yes, it''s possible to
    inject services to test classes) and add one test method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注入我们想要测试的服务（是的，可以将服务注入到测试类中）并添加一个测试方法：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `shouldCreateSeatType` method will create a new `SeatType` attribute
    using the `createSeatType` method from the `TicketService` class. Note how we
    inject `TicketService` just as we would if we were running this code on the server
    side.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`shouldCreateSeatType`方法将使用`TicketService`类的`createSeatType`方法创建一个新的`SeatType`属性。注意我们如何像在服务器端运行此代码一样注入`TicketService`。
- en: 'Our first test case is now ready. We will just need to add an Arquillian configuration
    file named `arquillian.xml` in our project, under `src/test/resources`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试用例现在准备好了。我们只需要在我们的项目`src/test/resources`下添加一个名为`arquillian.xml`的Arquillian配置文件：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You have to configure the container adapter. In this example, we assume that
    you have set the `JBOSS_HOME` environment variable to the WildFly main directory.
    In this case, no more configurations are required. However, if you want to run
    something non-standard, for example, connect to a remote container with altered
    management ports, then this file is the appropriate place to modify this. When
    you don''t specify `JBOSS_HOME`, you can set the WildFly location using `property`
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须配置容器适配器。在这个例子中，我们假设你已经将`JBOSS_HOME`环境变量设置为WildFly主目录。在这种情况下，不需要更多的配置。然而，如果你想运行非标准的东西，例如连接到具有更改的管理端口的远程容器，那么这个文件是修改这个设置的适当位置。当你没有指定`JBOSS_HOME`时，你可以使用`property`如下设置WildFly的位置：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, this method may be hard to maintain when more than one person is working
    on the project. In order to avoid problems, you can use the system property resolution,
    for instance, `${jbossHome}`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当有多个人在项目上工作时，这个方法可能很难维护。为了避免问题，你可以使用系统属性解析，例如`${jbossHome}`。
- en: 'If you configure the remote container, the configuration would look just like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你配置了远程容器，配置看起来就像这样：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running Arquillian TicketTest
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Arquillian TicketTest
- en: 'It''s possible to run Arquillian tests both from Maven and your IDE. You have
    to remember that we declared the container adapter in the Maven profile, so in
    order to run the full build, you have to run the following command line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Maven 和你的 IDE 中运行 Arquillian 测试。你必须记住我们在 Maven 配置文件中声明了容器适配器，因此为了运行完整的构建，你必须运行以下命令行：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to run the test from Eclipse, you have to navigate to the project
    properties and select the **Maven** property. In the **Active Maven Profiles**
    field, enter `arquillian-wildfly-managed` (as shown in the following screenshot),
    which we declared earlier in the `pom.xml` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从 Eclipse 运行测试，你必须导航到项目属性并选择 **Maven** 属性。在 **活动 Maven 配置文件** 字段中，输入 `arquillian-wildfly-managed`（如以下截图所示），这是我们之前在
    `pom.xml` 文件中声明的：
- en: '![Running Arquillian TicketTest](img/00103.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![运行 Arquillian TicketTest](img/00103.jpeg)'
- en: Now all you have to do is right-click on your `TicketServiceTest` class and
    select **Run As JUnit Test**. The Arquillian engine will start, producing the
    outcome of the test in the JUnit view (you can make it visible by navigating to
    **Menu** | **Window** | **Show View** | **JUnit**).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要右键单击你的 `TicketServiceTest` 类并选择 **运行 As JUnit Test**。Arquillian 引擎将启动，在
    JUnit 视图中产生测试结果（你可以通过导航到 **菜单** | **窗口** | **显示视图** | **JUnit**）来使其可见）。
- en: Congratulations! The JUnit console accounts for the first test that was run
    successfully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！JUnit 控制台记录了第一个成功运行的测试。
- en: 'If you want to use only one container in your test, then a good idea would
    be to set the default Maven profile, by adding the following lines to it in the
    `pom.xml` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在测试中使用一个容器，那么在 `pom.xml` 文件中添加以下行以设置默认 Maven 配置文件是一个好主意：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running Arquillian tests using Spock
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spock 运行 Arquillian 测试
- en: Arquillian is not limited to only JUnit. As we mentioned earlier, there are
    already containers, for example, TestNG and Spock; let's focus on the second one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 不仅限于仅使用 JUnit。正如我们之前提到的，已经有容器，例如 TestNG 和 Spock；让我们专注于第二个。
- en: '**Spock** is a modern testing framework written in Groovy and uses some of
    the Groovy language features to make your tests more readable and easier to write.
    Spock''s primary goal is to test the Groovy code but it is perfect to write all
    kinds of tests for the Java code. Spock introduces a few additional semantics
    with its **Domain Specific Language** (**DSL**) in order to make testing even
    more easier and developer friendly.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spock** 是一个用 Groovy 编写的现代测试框架，它使用了一些 Groovy 语言特性来使你的测试更易于阅读和编写。Spock 的主要目标是测试
    Groovy 代码，但它非常适合编写各种 Java 代码的测试。Spock 通过其 **领域特定语言** (**DSL**) 引入了一些额外的语义，以便使测试更加简单和开发者友好。'
- en: 'Let''s rewrite our previous test example using Spock:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Spock 重新编写之前的测试示例：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can notice a few differences. First of all, it's really Groovy! Secondly,
    the test uses a different runner, `ArquillianSputnik`. What's more, you can already
    notice some Spock DSL here, such as the **given**, **when**, and **then** constructions,
    which come from **behavior-driven development** (**BDD**). The **given** construction
    is expected to put the system in a specific state, **when** describes an action,
    and **then** contains assertions that verify the outcome of an action performed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到一些差异。首先，它确实是 Groovy！其次，测试使用了一个不同的运行器，`ArquillianSputnik`。更重要的是，你在这里已经可以看到一些
    Spock DSL，例如来自 **行为驱动开发** (**BDD**) 的 **given**、**when** 和 **then** 构造。**given**
    构造预期将系统置于特定状态，**when** 描述一个动作，而 **then** 包含验证动作结果的断言。
- en: This fully working Spock example with the complete `pom.xml` configuration can
    be found in this chapter's example project `named ticket-agency-spock`. More information
    concerning the Arquillian Spock test runner, its features, and usage instructions
    can be found on GitHub at [https://github.com/arquillian/arquillian-testrunner-spock](https://github.com/arquillian/arquillian-testrunner-spock).
    More information concerning Spock can also be found on GitHub at [https://github.com/spockframework/spock](https://github.com/spockframework/spock).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的 Spock 示例，包括完整的 `pom.xml` 配置，可以在本章的示例项目 `ticket-agency-spock` 中找到。有关 Arquillian
    Spock 测试运行器、其功能和用法说明的更多信息，可以在 GitHub 上找到：[https://github.com/arquillian/arquillian-testrunner-spock](https://github.com/arquillian/arquillian-testrunner-spock)。有关
    Spock 的更多信息也可以在 GitHub 上找到：[https://github.com/spockframework/spock](https://github.com/spockframework/spock)。
- en: ShrinkWrap Resolver
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShrinkWrap 解析器
- en: In almost every Arquillian test, you will probably use ShrinkWrap to create
    micro deployments. After working with it for a bit, you will probably notice some
    shortcomings. You might be wondering what happens when you've got a test that
    relies on some external library; do you need to add all packages from that library?
    The answer is no. **ShrinkWrap Resolver** offers integration with Maven and basic
    Gradle support is also available. You can just write in your test what dependency
    you'd like to include in the archive and it will be deployed with the micro deployment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在每一个Arquillian测试中，你可能会使用ShrinkWrap来创建微部署。在使用它一段时间后，你可能会注意到一些不足之处。你可能想知道当你有一个依赖于某些外部库的测试时会发生什么；你是否需要添加该库的所有包？答案是：不需要。**ShrinkWrap解析器**提供了与Maven的集成，并且基本Gradle支持也是可用的。你只需在测试中写下你想要包含在存档中的依赖项，它将与微部署一起部署。
- en: 'Let''s look at the basic example of the ShrinkWrap Resolver Maven integration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ShrinkWrap解析器Maven集成的基本示例：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding line means that we want to resolve an artifact with the given
    group ID, artifact ID, and version (Maven coordinates in canonical form) from
    Maven's central repository with all its dependencies, and convert it to a list
    of files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行意味着我们想要从Maven的中心仓库中解析具有给定组ID、工件ID和版本（规范形式的Maven坐标）的工件，包括所有依赖项，并将其转换为文件列表。
- en: 'However, with this example, you have to maintain the artifact version both
    in the test code and build file. You can improve this! Just import some dependencies
    data from your `pom.xml` file, so that ShrinkWrap Resolver resolves artifacts
    of the same versions the main project is using:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，你必须同时在测试代码和构建文件中维护工件版本。你可以改进这一点！只需从你的`pom.xml`文件中导入一些依赖项数据，这样ShrinkWrap解析器就可以解析与主项目使用相同版本的工件：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So now, first of all, the `pom.xml` data is loaded, including all depending
    management sections and artifacts versions. Also, the artifact coordinates do
    not have to include the version.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，加载`pom.xml`数据，包括所有依赖管理部分和工件版本。此外，工件坐标不必包含版本。
- en: These are the most basic features. You can fully configure the resolver manually,
    the repositories you want to use, Maven profiles to be applied, and much more.
    Let's now grab an example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最基本的功能。你可以手动完全配置解析器，你想要使用的存储库，要应用Maven配置文件，以及更多。现在让我们抓取一个例子。
- en: 'Let''s say you''re testing your project using JUnit and some fancy assertion
    library. **AssertJ** (successor of **FEST** assertions) is a fluent assertions
    library that allows you to write your project in a more human-readable form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用JUnit和一些花哨的断言库来测试你的项目。**AssertJ**（**FEST**断言的继任者）是一个流畅的断言库，它允许你以更易于阅读的形式编写你的项目：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using such a library in every test means you have to include it in every micro
    deployment. There is another thing you will always need: the `beans.xml` file.
    So let''s create some utility classes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中使用这样的库意味着你必须将它包含在每个微部署中。还有另一件事你总是需要的：`beans.xml`文件。所以让我们创建一些实用类：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, now in each test case, you''d have just to write the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在在每一个测试用例中，你只需编写以下代码：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At some point, you might want to do one more thing; instead of adding all your
    libraries manually, you can import them on runtime dependencies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能还想做另一件事；而不是手动添加所有库，你可以在运行时依赖项中导入它们：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are some unfortunate cases in which isolation of a part of the project
    for the micro deployment is not possible. You just add more and more classes to
    it and there is no end. This means that your project might have a poor design,
    but let''s say you want to introduce Arquillian in some existing legacy project
    and you had no influence on its structure. In that case, you might want to import
    not just some classes or packages, but the whole project to your integration test.
    Some people do tricks; they just use the basic ShrinkWrap and import a `.jar`
    or `.war` file using the `ZipImporter` ShrinkWrap:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不幸的情况，其中无法将项目的一部分隔离以进行微部署。你只是不断地向其中添加更多和更多的类，而且没有尽头。这意味着你的项目可能设计得不好，但假设你想要在某个现有的遗留项目中引入Arquillian，而你对其结构没有影响力。在这种情况下，你可能希望将整个项目导入到集成测试中。有些人会玩一些小把戏；他们只是使用基本的ShrinkWrap，并使用`ZipImporter`
    ShrinkWrap导入`.jar`或`.war`文件：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The problem is what is really in this archive? You probably import an archive
    created during the previous build since it is created after finishing the tests!
    What''s more, it cannot even exist when you''re just working from the IDE and
    not running the full Maven build! It''s the place where you can use the `MavenImporter`
    class. Refer to the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个存档中到底有什么？你很可能导入了在之前的构建过程中创建的存档，因为它是测试完成后创建的！更重要的是，当你只是从 IDE 中工作而不运行完整的
    Maven 构建时，它甚至可能不存在！这是你可以使用 `MavenImporter` 类的地方。请参考以下代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it! Internally, it runs the simplified build, gathering compiled classes
    and resources and packing it to the archive. It does not run inside the complete
    Maven build using some embedded instance, since that would be much too slow. You
    might want to add such a method to your test utilities:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！内部运行简化构建，收集编译后的类和资源，并将其打包到存档中。它不会在完整的 Maven 构建中使用某个嵌入实例运行，因为那样会慢得多。你可能想将此类方法添加到你的测试工具中：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There exists a similar feature for the Gradle project included since ShrinkWrap
    Resolver 2.2.0-alpha-1\. However, it uses the Gradle Tooling API internally:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自 ShrinkWrap Resolver 2.2.0-alpha-1 以来，Gradle 项目也存在一个类似的功能。然而，它内部使用 Gradle 工具
    API：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At some point, you might be surprised that this last example did not work.
    The reason might be that `arquillian-bom` does not include this ShrinkWrap Resolver
    version. However, it is possible to override the BOM imported versions with another
    BOM. It''s pretty easy; just insert the more important BOM first:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能会惊讶地发现最后一个例子没有工作。原因可能是 `arquillian-bom` 没有包含这个 ShrinkWrap 解析器版本。然而，可以通过另一个
    BOM 覆盖 BOM 导入的版本。这很简单；只需首先插入更重要的 BOM：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: More info about ShinkWrap Resolver can be found on its GitHub repository at
    [https://github.com/shrinkwrap/resolver](https://github.com/shrinkwrap/resolver).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 ShinkWrap 解析器的信息可以在其 GitHub 仓库[https://github.com/shrinkwrap/resolver](https://github.com/shrinkwrap/resolver)中找到。
- en: ShrinkWrap Descriptors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShrinkWrap 描述符
- en: There is one more ShrinkWrap family project. A little less popular and not known
    by many people, it is called **ShrinkWrap Descriptors**. Its goal is to provide
    a fluent API for the creation of descriptor resources you usually create and insert
    inside your micro deployments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ShrinkWrap 家族还有一个项目。它相对不太受欢迎，很多人都不了解，它被称为 **ShrinkWrap 描述符**。它的目标是提供一个流畅的 API，用于创建你通常创建并插入到你的微部署中的描述符资源。
- en: 'Let''s start with an example. Let''s say you''re writing a persistence framework
    extension. While doing this, you use an incredible amount of `persistence.xml`
    files such as the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。假设你正在编写一个持久化框架扩展。在这样做的时候，你使用了大量的 `persistence.xml` 文件，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With ShrinkWrap Descriptors, instead of putting all these files in `src/test/resources`
    and then referencing them from particular tests, you can just put some code in
    the test itself:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ShrinkWrap 描述符，你不必将这些文件全部放在 `src/test/resources` 中，然后再从特定的测试中引用它们，你只需在测试本身中放入一些代码：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Such a `PersistenceDescriptor` class can be exported as `String` or just be
    added to the `ShrinkWrap` archive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 `PersistenceDescriptor` 类可以导出为 `String`，或者直接添加到 `ShrinkWrap` 存档中。
- en: By default, the project contains descriptors ready for all the most important
    `.xml` of Java EE platform. However, it also allows for code generation using
    XSD and DTD files. Be cautious, it's still in alpha stage. It is stable, but the
    API might already be changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目包含适用于 Java EE 平台所有最重要的 `.xml` 文件的描述符。然而，它还允许使用 XSD 和 DTD 文件进行代码生成。请注意，它仍处于
    alpha 阶段。它是稳定的，但 API 可能已经更改。
- en: Persistence testing
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化测试
- en: Real challenges start when you have to include other systems in your testing
    process. Troubles might be caused even by the necessity of testing interactions
    with a relational database. In [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*, we introduced the JPA.
    Now it's time to describe how you can test your interactions with it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的挑战开始于你必须将其他系统包含到测试过程中时。即使只是测试与关系型数据库的交互，也可能引发问题。在[第 5 章](part0030_split_000.html#page
    "第 5 章。将持久化与 CDI 结合")中，*将持久化与 CDI 结合*，我们介绍了 JPA。现在，是时候描述如何测试与它的交互了。
- en: 'There are a few issues that have to be considered when testing database-related
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试数据库相关代码时，必须考虑以下几个问题：
- en: How to verify that data was really inserted to the database?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证数据是否真的被插入到数据库中？
- en: How to maintain the database state between tests and how to automatically clean
    it?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在测试之间维护数据库状态，以及如何自动清理它？
- en: 'Arquillian persistence extension allows you to test both these things. Before
    running a test, you can seed your database from `.xml`, `.xls`, `.yaml`, `.json`,
    or custom SQL scripts. It''s done by just annotating the test case using the `@UsingDataSet("path-to-seeding-file")`
    annotation. After the test execution, you can compare the database state against
    another file, this time using the `@ShouldMatchDataSet("path-to-dataset")` annotation.
    Let''s look at an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian持久性扩展允许您测试这两件事。在运行测试之前，您可以从`.xml`、`.xls`、`.yaml`、`.json`或自定义SQL脚本中为数据库播种。这是通过仅使用`@UsingDataSet("path-to-seeding-file")`注解来注解测试用例来完成的。在测试执行后，您可以使用`@ShouldMatchDataSet("path-to-dataset")`注解将数据库状态与另一个文件进行比较。让我们看一个例子：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `seats.yml` and `expected-seats.xml` files are just simple YAMLs placed
    in `/src/test/resources/datasets`. The first file contains `SeatType`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`seats.yml`和`expected-seats.xml`文件只是简单的YAML文件，放置在`/src/test/resources/datasets`中。第一个文件包含`SeatType`：'
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second file contains:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件包含：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we're executing a cleanup. Note that the names and values used here are
    the SQL names, not the JPA names.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在执行清理。请注意，这里使用的名称和值是SQL名称，而不是JPA名称。
- en: JPA allows you to use a second-level cache in order to improve the operations
    performance. With this, not all of the operations are instantly reflected on the
    database state. During the tests running, you might be interested in the `@JpaCacheEviction`
    annotation, which makes a cache to evict after every test run. Each test is also
    wrapped in a separate transaction so that it won't influence the execution of
    other tests
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JPA允许您使用二级缓存来提高操作性能。有了这个，并非所有操作都会立即反映在数据库状态上。在测试运行期间，您可能对`@JpaCacheEviction`注解感兴趣，该注解在每次测试运行后使缓存失效。每个测试也被封装在一个单独的事务中，这样它就不会影响其他测试的执行
- en: 'Of course, there are some dependencies you need to make this extension work.
    There are exactly three of them as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要一些依赖项才能使此扩展正常工作。恰好有三个，如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Arquillian in 1.1.4.Final version has a bug that passes all persistence tests
    even when they should not. The 1.1.5.Final version works correctly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 1.1.4.Final版本有一个bug，即使不应该通过所有持久性测试，它也会通过。1.1.5.Final版本工作正常。
- en: A fully configured example project for this chapter is named `ticket-agency-test-ape`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整配置示例项目命名为`ticket-agency-test-ape`。
- en: The Arquillian Persistence Extension manual is available on GitHub at [https://github.com/arquillian/arquillian-extension-persistence](https://github.com/arquillian/arquillian-extension-persistence).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Persistence Extension的手册可在GitHub上找到：[https://github.com/arquillian/arquillian-extension-persistence](https://github.com/arquillian/arquillian-extension-persistence)。
- en: Arquillian Warp
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arquillian Warp
- en: The last Arquillian extension that we will discuss here is **Warp**. Authors
    say that it allows you to write client-side tests that assert server-side logic.
    To be more descriptive, it allows for execution of client side requests, and then
    to execute server side tests. This fills the gap between client-side and server-side
    testing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的最后一个Arquillian扩展是**Warp**。作者表示，它允许您编写断言服务器端逻辑的客户端测试。更具体地说，它允许执行客户端请求，然后执行服务器端测试。这填补了客户端和服务器端测试之间的空白。
- en: 'In order to fully understand the Warp, we have to introduce the `@RunAsClient`
    annotation. It can be placed on a test class or test method and it mentions that
    tests will be executed on the client side and not on the server side. The second
    important annotation is `@Deployment`, which you have already met on method creating
    the archives. However, it can take some parameters that are Boolean value testable.
    If a testable is `false`, it is also executes on the client side, not repacking
    the deployment and so on. However, Warp mixes these two modes and requires `@Deployment(testable=true)`
    and `@RunAsClient` annotations. The test class has to be annotated additionally
    with `@WarpTest`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面理解Warp，我们必须引入`@RunAsClient`注解。它可以放置在测试类或测试方法上，并指出测试将在客户端执行，而不是在服务器端执行。第二个重要的注解是`@Deployment`，您已经在创建存档的方法中遇到过它。然而，它可以接受一些布尔值可测试的参数。如果可测试的值为`false`，它也会在客户端执行，而不是重新打包部署等等。然而，Warp混合了这两种模式，并需要`@Deployment(testable=true)`和`@RunAsClient`注解。测试类必须额外注解为`@WarpTest`：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Every Warp test uses the following construction:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Warp测试都使用以下结构：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An activity is the client part that makes the requests. Inspection is a server-side
    assertion. It''s also possible to filter some requests by additional specification
    of the Observer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 活动是客户端部分，它发起请求。检查是服务器端断言。也可以通过观察者的额外指定来过滤一些请求：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: An Observer can, for example, filter HTTP addresses.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，观察者可以过滤HTTP地址。
- en: 'Let''s take a look at something more concrete. Arquillian Warp also has some
    extensions. Currently, all of them are HTTP oriented; however, it is possible
    to extend Warp to cover non-HTTP use cases. The extensions add some special classes
    for testing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更具体的内容。Arquillian Warp也有一些扩展。目前，所有这些扩展都是面向HTTP的；然而，可以将Warp扩展以覆盖非HTTP用例。这些扩展为测试添加了一些特殊类：
- en: JSF
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF
- en: JAX-RS
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS
- en: Spring MVC
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC
- en: 'Now we''re going to look at the JAX-RS part. To do this, we will use the code
    from [Chapter 7](part0038_split_000.html#page "Chapter 7. Adding Web Services
    to Your Applications"), *Adding Web Services to Your Applications*. We want to
    test our REST service. First of all, we need to add all the standard Arquillian-related
    dependencies and the `arquillian.xml` file. For the Warp itself, we will need
    the following dependency:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看JAX-RS部分。为此，我们将使用来自[第7章](part0038_split_000.html#page "第7章。将Web服务添加到您的应用程序")，*将Web服务添加到您的应用程序*的代码。我们想要测试我们的REST服务。首先，我们需要添加所有标准Arquillian相关依赖项和`arquillian.xml`文件。对于Warp本身，我们需要以下依赖项：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For the JAX-RS extension, we will need the following dependency:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JAX-RS扩展，我们需要以下依赖项：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Additionally, we will use the JAX-RS client:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用JAX-RS客户端：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our test will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将如下所示：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First of all, you can see all the annotations mentioned earlier. We use the
    `ShrinkWrap Resolver MavenImporter` class here to get the whole project in the
    deployment. The `[1]` object is the injection of the application URL. In `[2]`,
    we execute a client request to get the seats and in `[3]`, we do some basic client-side
    assertion. In `[4]`, we test the server side, to check if the appropriate HTTP
    code was returned and so on. In more complex scenarios, we can execute some beans
    logic to confirm that the appropriate state change was performed on the server
    side. This last thing distinguishes the Arquillian Warp from running tests in
    the client mode (a `@RunAsClient` annotation) and doing assertions with `ResteasyWebTarget`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以看到之前提到的所有注解。在这里，我们使用`ShrinkWrap Resolver MavenImporter`类来获取整个部署项目。`[1]`对象是应用程序URL的注入。在`[2]`中，我们执行一个客户端请求以获取座位，在`[3]`中，我们进行一些基本的客户端断言。在`[4]`中，我们测试服务器端，以检查是否返回了适当的HTTP代码等。在更复杂的场景中，我们可以执行一些bean逻辑以确认服务器端执行了适当的状态更改。这一点将Arquillian
    Warp与客户端模式（`@RunAsClient`注解）运行测试以及使用`ResteasyWebTarget`进行断言区分开来。
- en: Some more information concerning this extension can be found at [https://github.com/arquillian/arquillian-extension-warp](https://github.com/arquillian/arquillian-extension-warp).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个扩展的更多信息可以在[https://github.com/arquillian/arquillian-extension-warp](https://github.com/arquillian/arquillian-extension-warp)找到。
- en: WebSockets testing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket测试
- en: 'We introduced the topic of WebSockets in the earlier chapters. Now let''s see
    how we can test them. To do this in plain Java, we will need a WebSocket client
    implementation; be sure to add **Tyrus** to your `pom.xml` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中介绍了WebSocket的话题。现在让我们看看如何测试它们。要在纯Java中完成这个任务，我们需要一个WebSocket客户端实现；请确保将**Tyrus**添加到您的`pom.xml`文件中：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For this example, we will use Tyrus as a base code from [Chapter 8](part0042_split_000.html#page
    "Chapter 8. Adding WebSockets"), *Adding WebSockets*. Our test realizes a simple
    scenario. Using the REST API, we reserve a seat, and as a WebSocket client, we
    wait for a message broadcasting information concerning new reservations. Let''s
    look at the code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用来自[第8章](part0042_split_000.html#page "第8章。添加WebSocket")，*添加WebSocket*的Tyrus作为基础代码。我们的测试实现了一个简单场景。使用REST
    API，我们预订一个座位，作为WebSocket客户端，我们等待广播有关新预订的信息的消息。让我们看看代码：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The test is run as described in this chapter''s client mode and uses Tyrus:
    the WebSocket client reference implementation under the hood. The perfect deployment
    for this test is our whole application, so we are going to use `MavenImporter
    [1]`. In the test, we declared a concurrent deque to gather a received messaged
    `[2]` and a latch `[3]`, which we will use to wait in `[7]`. In order to handle
    WebSockets on the client side, we have to declare a handler `[4]`, which specifies
    the behavior on receiving the message. Here, we just add a message to our deque
    and perform a latch countdown. In `[5]`, we have to register the handler so that
    it will be used for an open session. The REST call is executed using a rest-assured
    library, which provides a fluent API to test REST APIs. Finally, in `[8]`, we
    perform some basic assertions concerning the received messages.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 测试按照本章描述的客户端模式运行，并使用Tyrus：底层的WebSocket客户端参考实现。对于这个测试来说，完美的部署是我们的整个应用程序，因此我们将使用`MavenImporter
    [1]`。在测试中，我们声明了一个并发双端队列来收集接收到的消息`[2]`和一个门闩`[3]`，我们将使用它们在`[7]`中等待。为了处理客户端的WebSocket，我们必须声明一个处理器`[4]`，它指定了接收消息时的行为。在这里，我们只是将消息添加到我们的双端队列中，并执行门闩倒计时。在`[5]`中，我们必须注册处理器，以便它将在一个打开的会话中使用。REST调用使用rest-assured库执行，它提供了一个流畅的API来测试REST
    API。最后，在`[8]`中，我们执行一些关于接收到的消息的基本断言。
- en: The fully configured `pom.xml` file and a whole working project can be found
    under `ticket-agency-test-websockets`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完全配置的`pom.xml`文件和整个工作项目可以在`ticket-agency-test-websockets`下找到。
- en: Enhancing your Arquillian test
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高你的Arquillian测试
- en: You might have noticed that we, on purpose, created just a part of the integration
    tests we needed. We did not reach the last mile, that is, creating seats and reserving
    one. As a matter of fact, if you remember, our ticket application uses `ConversationScope`
    to track the user's navigation. Thus, we need to bind `ConversationScope` into
    our test as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们故意只创建了所需的集成测试的一部分。我们没有达到最后一英里，也就是说，创建座位并预定一个。实际上，如果你记得的话，我们的票务应用程序使用`ConversationScope`来跟踪用户的导航。因此，我们需要将`ConversationScope`绑定到我们的测试中。
- en: 'Luckily, the `Weld` container provides all that you need with `org.jboss.weld.context.bound.BoundConversationContext`,
    which needs to be injected into your test class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Weld`容器通过`org.jboss.weld.context.bound.BoundConversationContext`提供了你所需要的一切，它需要注入到你的测试类中：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `@Before` annotation is invoked before each test method and after
    injections have occurred. In our case, it is used to associate `conversationContext`
    with `MutableBoundRequest` before being activated by `conversationContext.activate`.
    This is needed to mimic the conversation behavior from within the Arquillian test
    bed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@Before`注解在每个测试方法之前和注入发生之后被调用。在我们的情况下，它用于在`conversationContext.activate`激活之前将`conversationContext`与`MutableBoundRequest`关联。这是在Arquillian测试环境中模拟会话行为所必需的。
- en: Just for completeness, you must be aware that `BoundRequest` interfaces are
    defined in the Weld API to hold a conversation that spans multiple requests, but
    are shorter than a session.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，你必须知道`BoundRequest`接口是在Weld API中定义的，用于保持跨越多个请求的会话，但比会话短。
- en: 'So here''s the full `TicketTest` class, which contains a theatre creation and
    booking seat reservation in the `testTicketAgency` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的`TicketTest`类，它包含在`testTicketAgency`方法中的剧院创建和座位预订：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Additional information
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他信息
- en: The Arquillian project is an evolving framework with many other interesting
    topics. Describing all its extensions, however, is out of the scope of this book.
    However, the other interesting areas to look into are **Drone** and **Graphene**,
    which bring the **WebDriver** and **Page Object** patterns to Arquillian testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian项目是一个不断发展的框架，有许多其他有趣的主题。然而，描述所有其扩展超出了本书的范围。然而，其他值得关注的领域是**Drone**和**Graphene**，它们将**WebDriver**和**Page
    Object**模式引入Arquillian测试。
- en: At some point, you may find yourself creating separate deployment methods in
    each test case. You can change this behavior by the usage of **Arquillian Suite
    Extension**, which allows specifying a deployment for a set of test cases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能会发现自己在每个测试用例中创建单独的部署方法。你可以通过使用**Arquillian Suite Extension**来改变这种行为，它允许为一系列测试用例指定部署。
- en: Arquillian is fully open source, so you can learn more about it from the online
    documentation that is available at [http://arquillian.org/](http://arquillian.org/).
    When you need some help, or you have an awesome idea for a new feature, you can
    contact the Arquillian community on forums or IRC ([http://arquillian.org/community/](http://arquillian.org/community/)).
    Remember that if you find a bug, don't complain; just file an issue on JBoss JIRA
    at [https://issues.jboss.org](https://issues.jboss.org).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian是完全开源的，因此您可以从[http://arquillian.org/](http://arquillian.org/)提供的在线文档中了解更多关于它的信息。当您需要帮助或有关于新特性的绝佳想法时，您可以在论坛或IRC上联系Arquillian社区([http://arquillian.org/community/](http://arquillian.org/community/))。记住，如果您发现了一个bug，不要抱怨；只需在JBoss
    JIRA上提交一个问题[https://issues.jboss.org](https://issues.jboss.org)。
- en: One of the Arquillian contributors John D. Ament has already published a book
    on this topic called *Arquillian Testing Guide*, *Packt Publishing*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian的贡献者之一John D. Ament已经出版了一本关于这个主题的书，名为《Arquillian测试指南》，由Packt Publishing出版。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through a critical part of enterprise systems: integration
    testing. Historically, one main downside of Java EE is its testability, but Arquillian
    has really solved this issue to a great extent.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了企业系统的一个关键部分：集成测试。从历史上看，Java EE的一个主要缺点是其可测试性，但Arquillian确实在很大程度上解决了这个问题。
- en: Used as an extension to the JUnit framework, Arquillian excels in checking the
    integration layer that exposes the business logic in an enterprise Java application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JUnit框架的扩展，Arquillian在检查暴露在企业Java应用程序中的业务逻辑的集成层方面表现出色。
- en: Arquillian hooks into your testing framework to manage the container's life
    cycle. It also bundles the `test` class into a deployable archive with dependent
    classes and resources.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian挂钩到您的测试框架中，以管理容器的生命周期。它还将`test`类捆绑到一个可部署的归档中，其中包含依赖的类和资源。
- en: This is the last chapter covering basic Java EE and WildFly features. We started
    with a few session beans, and ended up with web sockets, an asynchronous messaging
    system, RESTful API, and even a little bit of JavaScript. During the course of
    this book, we saw how the newest edition of Java EE provided us with tools to
    create modern and scalable applications. The platform's goal is to help the developer
    to focus on the business logic. This means removing the boilerplate code through
    the whole application stack from the backend to the view layer. In most areas,
    we only covered the most important features of the multiple technologies provided
    by Java EE. There is still plenty to explore!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章，涵盖了基本的Java EE和WildFly特性。我们从一个会话Bean开始，最终到达了web sockets、异步消息系统、RESTful
    API，甚至还有一点JavaScript。在本书的整个过程中，我们看到了Java EE的最新版本为我们提供了创建现代和可扩展应用程序的工具。该平台的目标是帮助开发者专注于业务逻辑。这意味着通过整个应用程序堆栈从后端到视图层移除样板代码。在大多数领域，我们只涵盖了Java
    EE提供的多种技术的最重要的特性。还有很多东西可以探索！
- en: In the appendix, we will learn a few things about the JBoss Forge tool, which
    can greatly increase the productivity when working with Java EE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录中，我们将了解一些关于JBoss Forge工具的知识，该工具可以极大地提高使用Java EE进行工作时的工作效率。
- en: Appendix A. Rapid Development Using JBoss Forge
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 使用JBoss Forge快速开发
- en: In the appendix of this book, we will give you an overview of JBoss Forge, which
    is a powerful, rapid application development (aimed at Java EE ) and project comprehension
    tool. With Forge, you can start a new project from scratch and generate the skeleton
    for your application just with a few commands. However, it can also be used for
    incremental enhancements for your existing projects using extra plugins.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的附录中，我们将为您概述JBoss Forge，这是一个强大的、快速的应用程序开发（针对Java EE）和项目理解工具。使用Forge，您可以通过几个命令从头开始启动一个新项目并生成您应用程序的骨架。然而，它也可以通过额外的插件对现有项目进行增量增强。
- en: Installing Forge
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Forge
- en: 'In order to install Forge, you need to perform the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装Forge，您需要执行以下步骤：
- en: Download and unzip Forge from [http://forge.jboss.org/](http://forge.jboss.org/)
    into a folder on your hard disk; this folder will be your `FORGE_HOME`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://forge.jboss.org/](http://forge.jboss.org/)下载并解压Forge到您的硬盘上的一个文件夹中；这个文件夹将是您的`FORGE_HOME`。
- en: Add `FORGE_HOME/bin` to your path (Windows, Linux, and Mac OS X).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FORGE_HOME/bin`添加到您的路径中（Windows、Linux和Mac OS X）。
- en: 'In Unix-based operating systems, this typically means editing your `~/.bashrc`
    or `~/`.profile; you will need to enter the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的操作系统上，这通常意味着编辑您的`~/.bashrc`或`~/`.profile；您需要输入以下代码片段：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In Windows systems, you will need to open the **Control Panel** window, then
    navigate to **System Properties** | **Advanced** | **Environment Variables**,
    and add these two entries visually. It is recommended to set user variables for
    Forge, unless you have placed the unzipped distribution in a folder where all
    users can access it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统中，您需要打开**控制面板**窗口，然后导航到**系统属性** | **高级** | **环境变量**，并可视地添加这两个条目。建议为
    Forge 设置用户变量，除非您已将未压缩的发行版放置在所有用户都可以访问的文件夹中。
- en: In case of any problem, check out the online installation guide available at
    [http://forge.jboss.org/document/installation](http://forge.jboss.org/document/installation).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，请查看可在线获取的安装指南，链接为 [http://forge.jboss.org/document/installation](http://forge.jboss.org/document/installation)。
- en: Starting Forge
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 Forge
- en: 'In order to start Forge, there is a script named `forge.bat` (or the equivalent
    Forge for Unix). Run the following script:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动 Forge，有一个名为 `forge.bat`（或等效的 Unix Forge）的脚本。运行以下脚本：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will launch the Forge console, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 Forge 控制台，如下面的截图所示：
- en: '![Starting Forge](img/00104.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![启动 Forge](img/00104.jpeg)'
- en: The console accepts a large set of commands, such as commands to navigate and
    manipulate the filesystems, to create new projects, to operate on the Forge environment
    and UI generation, and scaffolding commands. It also offers the autocomplete feature.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台接受大量命令，例如用于导航和操作文件系统、创建新项目、操作 Forge 环境和 UI 生成以及脚手架命令的命令。它还提供了自动完成功能。
- en: 'In order to learn the following available commands in current context, press
    the *Tab* key twice:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习当前上下文中可用的以下命令，请按 *Tab* 键两次：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Besides the standard commands, it is possible to enrich the syntax of the Forge
    command line with add-ons, which adds superior capabilities to your project creation.
    On [http://forge.jboss.org/addons](http://forge.jboss.org/addons), you can find
    a list of available plugins. For example, we are going to use the `angular-js`
    plugin in order to create a GUI for our application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准命令外，您还可以通过附加组件来丰富 Forge 命令行的语法，这为您的项目创建增加了高级功能。您可以在 [http://forge.jboss.org/addons](http://forge.jboss.org/addons)
    上找到可用的插件列表。例如，我们将使用 `angular-js` 插件来为我们的应用程序创建一个图形用户界面。
- en: In the following section, we will demonstrate how to use some of the available
    commands in order to create a Java EE 7 application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用一些可用的命令来创建一个 Java EE 7 应用程序。
- en: Creating your first Java EE 7 application with JBoss Forge
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JBoss Forge 创建您的第一个 Java EE 7 应用程序
- en: 'So, Forge installation is quite easy; however, creating your first Java EE
    7 application will be even faster! Although, we can create rather advanced applications
    with Forge, for the purpose of learning, we will just use a simple schema that
    contains a user table, which can be built using the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Forge 安装相当简单；然而，创建您的第一个 Java EE 7 应用程序将会更快！尽管我们可以使用 Forge 创建相当高级的应用程序，但为了学习的目的，我们只会使用一个包含用户表的简单模式，该模式可以使用以下命令构建：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first thing that we need to do is to create a new project using the `project-new`
    command. Execute the following commands from within the `Forge` shell:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是使用 `project-new` 命令创建一个新的项目。请在 `Forge` shell 中执行以下命令：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, you have a new Forge project, which is based on a Maven project structure.
    Arguably, generating a new project isn't Forge's greatest value—the same can be
    achieved with Maven archetypes. The sweet part of Forge is that now you have the
    luxury of defining your own application skeleton interactively after it has already
    been generated. This means that you can create the project using the Maven archetype
    first and then extend it using Forge's intuitive suggestions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个新的 Forge 项目，它基于 Maven 项目结构。可以说，生成新项目并不是 Forge 的最大价值所在——这同样可以通过 Maven
    架构师实现。Forge 的美妙之处在于，现在您可以在项目生成后交互式地定义自己的应用程序骨架。这意味着您可以使用 Maven 架构师首先创建项目，然后使用
    Forge 的直观建议进行扩展。
- en: 'When the project is created, you can then enter command-list from the shell,
    as shown in the following screenshot, which enlists all the basic commands that
    you can use in Forge 2.12.1 Final:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目创建完成后，您可以从 shell 中进入命令列表，如下面的截图所示，其中列出了您可以在 Forge 2.12.1 Final 中使用的所有基本命令：
- en: '![Creating your first Java EE 7 application with JBoss Forge](img/00105.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JBoss Forge 创建您的第一个 Java EE 7 应用程序](img/00105.jpeg)'
- en: 'If you want to learn more about the single commands, you can use `man` followed
    by the command name, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于单个命令的信息，可以使用 `man` 后跟命令名称，如下面的屏幕截图所示：
- en: '![Creating your first Java EE 7 application with JBoss Forge](img/00106.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JBoss Forge 创建您的第一个 Java EE 7 应用程序](img/00106.jpeg)'
- en: When you have learned how to get help using Forge, let's get back to our application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您学会了如何使用 Forge 获取帮助后，让我们回到我们的应用程序。
- en: 'In the first step, we need to specify what Java and Java EE version we want
    to use:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步，我们需要指定我们想要使用的 Java 和 Java EE 版本：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, our project already contains Java EE 7 API dependency. Now,
    since we will need to reverse-engineer our database table into Java entities,
    the next step will be to configure the **Java Persistence API** (**JPA**) layer
    for your application. This application will be based on WildFly JPA implementation,
    which is based on the Hibernate provider, referencing a database named Forge.
    This database is reachable at the **Java Naming and Directory Interface** (**JNDI**)
    named `java:jboss/datasources/PostgreSqlDS`. This is shown in the following command
    line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的项目已经包含了 Java EE 7 API 依赖项。现在，由于我们需要将数据库表反向工程到 Java 实体中，下一步将是为您的应用程序配置
    **Java 持久性 API**（**JPA**）层。此应用程序将基于基于 Hibernate 提供程序的 WildFly JPA 实现，引用名为 Forge
    的数据库。此数据库可通过名为 `java:jboss/datasources/PostgreSqlDS` 的 **Java 命名和目录接口**（**JNDI**）访问。如下所示：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `persistence.xml` file was generated, and currently the console indicates
    that we are editing it. We can check its content by using the `cat` command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`persistence.xml` 文件已生成，当前控制台指示我们正在编辑它。我们可以使用 `cat` 命令来检查其内容：'
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will use the `jpa-generate-entities-from-tables` command in order
    to generate your `Entity` class. You will need to provide the following **Java
    Database Connectivity** (**JDBC)** connection information:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `jpa-generate-entities-from-tables` 命令来生成您的 `Entity` 类。您需要提供以下 **Java
    数据库连接**（**JDBC**）连接信息：
- en: The JDBC URL
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC URL
- en: The username and password
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名和密码
- en: The SQL dialect
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 方言
- en: The JDBC driver class name
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC 驱动程序类名
- en: The path in the filesystem where the JDBC driver is located
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC 驱动程序在文件系统中的路径
- en: The package where the entities will be generated
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成实体的包
- en: 'You can specify all the parameters in a one-line command or complete it interactively.
    The final command would look like this (line breaks added for readability):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一行命令中指定所有参数，或者通过交互式完成。最终的命令将看起来像这样（添加换行以提高可读性）：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After completing the persistence layer, we will now create the GUI application
    using the `scaffold` command, which can be associated with several providers such
    as the AngularJS one. First, let''s install the add-on using the following shell
    command (note that it should be executed in your system''s shell, not in the Forge
    CLI):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成持久层之后，我们现在将使用 `scaffold` 命令创建 GUI 应用程序，该命令可以与多个提供程序相关联，例如 AngularJS。首先，让我们使用以下
    shell 命令安装插件（请注意，它应该在您的系统 shell 中执行，而不是在 Forge CLI 中）：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the installation is complete, we need to issue three more commands. First,
    we will prepare the scaffolding framework:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要发出三个更多命令。首先，我们将准备脚手架框架：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our application now is a web app with AngularJS libraries. Next, we will define
    that we would like to generate a UI for the `Users` entity:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在是一个带有 AngularJS 库的 Web 应用程序。接下来，我们将定义我们想要为 `Users` 实体生成 UI：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we create an `JAX-RS` endpoint:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `JAX-RS` 端点：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And we are done! The application is now a complete Java EE application with
    REST endpoints, JPA, and an AngularJS UI.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！应用程序现在是一个完整的 Java EE 应用程序，具有 REST 端点、JPA 和 AngularJS UI。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When these samples were written, JBoss Forge did not fully support all Java
    EE 7 dependencies. This can be fixed by manually modifying the `pom.xml` file
    of the generated project. You should just remove all the dependencies besides
    the one shown in the following code snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些示例被编写时，JBoss Forge 并未完全支持所有 Java EE 7 依赖项。这可以通过手动修改生成的项目的 `pom.xml` 文件来修复。您只需删除以下代码片段中显示的所有依赖项之外的所有依赖项：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Additionally, if your `Users` entity doesn''t have an `@javax.persistence.GeneratedValue`
    annotation in its ID field, make sure you add it manually (there is currently
    a bug in the JPA add-on):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的 `Users` 实体在其 ID 字段中没有 `@javax.persistence.GeneratedValue` 注解，请确保您手动添加它（JPA
    插件中目前存在一个错误）：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Building and deploying the application
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和部署应用程序
- en: 'Now, it is time to build your application using the `build` command, which
    will compile and package your application in a web application archive (`forge-demo.war`):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用`build`命令构建您的应用程序了，这个命令将会编译并打包您的应用程序为一个网络应用程序归档（`forge-demo.war`）：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Maven build` command has created an artifact `forge-demo-1.0.0-SNAPSHOT.war`
    in the `target` folder of your project. You can now either manually copy the archive
    into the `deployments` folder of your application server or use the `management`
    interfaces.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maven构建`命令在您的项目`target`文件夹中创建了一个名为`forge-demo-1.0.0-SNAPSHOT.war`的归档。现在，您可以选择手动将归档复制到应用程序服务器的`deployments`文件夹，或者使用`management`接口。'
- en: Remember that the server should have the `java:jboss/datasources/PostgreSqlDS`
    data source defined!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 记住服务器应该定义了`java:jboss/datasources/PostgreSqlDS`数据源！
- en: Your Forge-demo application in action
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Forge-demo应用程序运行中的截图
- en: You can access your application at the default URL, `http://localhost:8080/
    forge-demo-1.0.0-SNAPSHOT/`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在默认URL `http://localhost:8080/ forge-demo-1.0.0-SNAPSHOT/` 访问您的应用程序。
- en: 'The main application screen will contain the list of entities on the left menu.
    If you choose the **Users** position, then you should see a list of users that
    have been added, a **Search** button which can be used to filter across the users,
    and a **Create** button, which obviously will insert some data. This is shown
    in the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 主要应用程序屏幕将包含左侧菜单中的实体列表。如果您选择**用户**选项，那么您应该看到已添加的用户列表，一个**搜索**按钮，可以用来过滤用户，以及一个**创建**按钮，显然它将插入一些数据。这将在以下屏幕截图中显示：
- en: '![Your Forge-demo application in action](img/00107.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![您的Forge-demo应用程序运行中的截图](img/00107.jpeg)'
- en: 'By clicking on the **Create** button, you will be taken to the screen that
    allows the insertion of a new user to the database (remember that we have configured
    this application to run against a `PostgreSQL` database). This is shown in the
    following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建**按钮，您将被带到允许向数据库插入新用户的屏幕（记住我们已经配置了这个应用程序以针对`PostgreSQL`数据库运行）。这将在以下屏幕截图中显示：
- en: '![Your Forge-demo application in action](img/00108.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![您的Forge-demo应用程序运行中的截图](img/00108.jpeg)'
- en: In this way, we have created a basic AngularJS app based on Java EE. It can
    be used as a foundation for your project or just a sandbox in which you can try
    out new ideas. Be sure to check out other available add-ons, and remember that
    you will always have the possibility to create your own ones!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个基于Java EE的基本AngularJS应用程序。它可以作为您项目的基石，或者只是一个沙盒，您可以在其中尝试新想法。请确保查看其他可用的插件，并记住您始终有创建自己的插件的可能性！
