- en: Chapter 7. Performance Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 性能优化
- en: 'Performance optimization is additive by nature, as in it works by adding performance
    tuning to the knowledge of how the underlying system works, and to the result
    of performance measurement. This chapter builds on the previous ones that covered
    "how the underlying system works" and "performance measurement". Though you will
    notice some recipe-like sections in this chapter, you already know the pre-requisite
    in order to exploit those well. Performance tuning is an iterative process of
    measuring performance, determining bottlenecks, applying knowledge in order to
    experiment with tuning the code, and repeating it all until performance improves.
    In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化本质上具有累加性，因为它通过将性能调优添加到对底层系统如何工作的了解以及性能测量结果中来实现。本章建立在之前涵盖“底层系统如何工作”和“性能测量”的章节之上。尽管你会在本章中注意到一些类似食谱的部分，但你已经知道了利用这些部分所需的前提条件。性能调优是一个测量性能、确定瓶颈、应用知识以尝试调整代码，并重复这一过程直到性能提高的迭代过程。在本章中，我们将涵盖：
- en: Setting up projects for better performance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为提高性能设置项目
- en: Identifying performance bottlenecks in the code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中的性能瓶颈
- en: Profiling code with VisualVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VisualVM分析代码
- en: Performance tuning of Clojure code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure代码的性能调优
- en: JVM performance tuning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM性能调优
- en: Project setup
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: While finding bottlenecks is essential to fixing performance problems in the
    code, there are several things one can do right from the start to ensure better
    performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然找到瓶颈对于修复代码中的性能问题是至关重要的，但有一些事情可以在一开始就做，以确保更好的性能。
- en: Software versions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件版本
- en: 'Usually, new software versions include bug fixes, new features, and performance
    improvements. Unless advised to the contrary, it is better to use newer versions.
    For development with Clojure, consider the following software versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，新的软件版本包括错误修复、新功能和性能改进。除非有相反的建议，最好使用较新版本。对于使用Clojure的开发，考虑以下软件版本：
- en: '**JVM version**: As of this writing, Java 8 (Oracle JDK, OpenJDK, Zulu) has
    been released as the latest stable production-ready version. It is not only stable,
    it also has better performance in several areas (especially concurrency) than
    the earlier versions. If you have a choice, choose Java 8 over the older versions
    of Java.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM版本**：截至本文撰写时，Java 8（Oracle JDK，OpenJDK，Zulu）已发布为最新稳定的生产就绪版本。它不仅稳定，而且在多个领域（特别是并发）的性能优于早期版本。如果你有选择，请选择Java
    8而不是Java的旧版本。'
- en: '**Clojure version**: As of this writing, Clojure 1.7.0 is the latest stable
    version that has several performance improvements over the older versions. There
    are also new features (transducers, volatile) that can make your code perform
    better. Choose Clojure 1.7 over the older versions unless you have no choice.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clojure版本**：截至本文撰写时，Clojure 1.7.0是最新稳定的版本，它在性能上比旧版本有多个改进。还有一些新功能（transducers，volatile）可以使你的代码性能更好。除非没有选择，否则请选择Clojure
    1.7而不是旧版本。'
- en: Leiningen project.clj configuration
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Leiningen project.clj配置
- en: As of version 2.5.1, the default Leiningen template (`lein new foo`, `lein new
    app foo`) needs few tweaks to make the project amenable to performance. Ensure
    your Leiningen `project.clj` file has the following entries, as appropriate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2.5.1版本，默认的Leiningen模板（`lein new foo`，`lein new app foo`）需要一些调整才能使项目适应性能。确保你的Leiningen
    `project.clj`文件有适当的以下条目。
- en: Enable reflection warning
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用反射警告
- en: 'One of the most common pitfalls in Clojure programming is to inadvertently
    let the code resort to reflection. Recall that we discussed this in [Chapter 3](ch03.html
    "Chapter 3. Leaning on Java"), *Leaning on Java. Enabling*, reflection warning
    is quite easy, let''s fix it by adding the following entry to `project.clj`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure编程中最常见的陷阱之一是无意中让代码退回到反射。回想一下，我们在[第3章](ch03.html "第3章。依赖Java")中讨论了这一点，*依赖Java。启用*，启用反射警告非常简单，让我们通过向`project.clj`添加以下条目来修复它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous configuration, the first setting `*unchecked-math* :warn-on-boxed`
    works only in Clojure 1.7—it emits numeric boxing warnings. The second setting
    `*warn-on-reflection* true` works on earlier Clojure versions as well as Clojure
    1.7, and emits reflection warning messages in the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，第一个设置`*unchecked-math* :warn-on-boxed`仅在Clojure 1.7中有效——它会发出数字装箱警告。第二个设置`*warn-on-reflection*
    true`在更早的Clojure版本以及Clojure 1.7中也能工作，并在代码中发出反射警告信息。
- en: However, including these settings in `project.clj` may not be enough. Reflection
    warnings are emitted only when a namespace is loaded. You need to ensure that
    all namespaces are loaded in order to search for reflection warnings throughout
    the project. This can be done by writing tests that refer to all namespaces, or
    via scripts that do so.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将这些设置包含在 `project.clj` 中可能不够。只有当命名空间被加载时才会发出反射警告。你需要确保所有命名空间都被加载，以便在整个项目中搜索反射警告。这可以通过编写引用所有命名空间的测试或通过执行此类操作的脚本来实现。
- en: Enable optimized JVM options when benchmarking
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在基准测试时启用优化 JVM 选项
- en: 'In [Chapter 4](ch04.html "Chapter 4. Host Performance"), *Host Performance*
    we discussed that Leiningen enables tiered compilation by default, which provides
    low startup time at the cost of poor JIT compiler optimization. The default setting
    is quite misleading for performance benchmarking, so you should enable JVM options
    that are representative of what you would use in production:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。主机性能") 中，我们讨论了 Leiningen 默认启用分层编译，这以牺牲 JIT 编译器的优化为代价提供了较短的启动时间。默认设置对于性能基准测试来说非常具有误导性，因此你应该启用代表你在生产中使用的
    JVM 选项：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, the previous setting defines a Leiningen profile that overrides
    the default JVM options to configure a `server` Java runtime with 2 GB of fixed-size
    heap space. It also sets test paths to a directory `perf-test`. Now you can run
    performance tests as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的设置定义了一个 Leiningen 配置文件，它覆盖了默认 JVM 选项，以配置一个具有 2 GB 固定大小堆空间的 `server` Java
    运行时。它还将测试路径设置为目录 `perf-test`。现在你可以按照以下方式运行性能测试：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If your project has performance test suites that require different JVM options,
    you should define multiple profiles for running tests, as appropriate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目有需要不同 JVM 选项的性能测试套件，你应该根据需要定义多个配置文件来运行测试。
- en: Distinguish between initialization and runtime
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分初始化和运行时
- en: Most non-trivial projects need a lot of context to be set up before they can
    function. Examples of such contexts could be app configuration, in-memory state,
    I/O resources, thread pools, caches, and so on. While many projects start with
    ad hoc configuration and initialization, eventually projects need to isolate the
    initialization phase from runtime. The purpose of this distinction is not only
    to sanitize the organization of code, but also to pre-compute as much as possible
    once before the runtime can take over to repeatedly respond to demands. This distinction
    also allows the initialization phase to easily (and conditionally, based on configuration)
    instrument the initialized code for performance logging and monitoring.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数非平凡项目在能够运行之前需要设置很多上下文。这些上下文的例子可能包括应用程序配置、内存状态、I/O 资源、线程池、缓存等等。虽然许多项目从临时的配置和初始化开始，但最终项目需要将初始化阶段与运行时分离。这种区分的目的不仅是为了净化代码的组织，而且是为了在运行时接管之前尽可能多地预先计算。这种区分还允许初始化阶段（根据配置条件）轻松地对初始化代码进行性能日志记录和监控。
- en: Non-trivial programs are usually divided into layers, such as business logic,
    caching, messaging, database access, and so on. Each layer has a dependency relationship
    with one or more of the other layers. It is feasible to carry out the isolation
    of the initialization phase by writing code using first principles, and many projects
    actually do that. However, there are a few libraries that simplify this process
    by letting you declare the dependency relationship between layers. **Component**
    ([https://github.com/stuartsierra/component](https://github.com/stuartsierra/component))
    and **Prismatic Graph** ([https://github.com/Prismatic/plumbing](https://github.com/Prismatic/plumbing))
    are notable examples of such libraries.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 非平凡程序通常分为多个层次，例如业务逻辑、缓存、消息传递、数据库访问等等。每个层次都与一个或多个其他层次有依赖关系。通过使用第一性原理编写代码，可以执行初始化阶段的隔离，许多项目实际上就是这样做的。然而，有一些库通过允许你声明层次之间的依赖关系来简化这个过程。**组件**
    ([https://github.com/stuartsierra/component](https://github.com/stuartsierra/component))
    和 **Prismatic 图** ([https://github.com/Prismatic/plumbing](https://github.com/Prismatic/plumbing))
    是此类库的显著例子。
- en: 'The Component library is well documented. It may not be easily apparent how
    to use Prismatic Graph for dependency resolution; following is a contrived example
    for illustration:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Component 库有很好的文档。可能不容易明显地看出如何使用 Prismatic 图进行依赖解析；以下是一个虚构的例子来说明：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example merely shows the construction of a layer dependency graph, but
    often you may need different construction scope and order for testing. In that
    case you may define different graphs and resolve them, as and when appropriate.
    If you need teardown logic for testing, you can add extra `fnk` entries for each
    teardown step and use those for teardown.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子仅仅展示了层依赖图的构建，但在测试中，你可能需要不同的构建范围和顺序。在这种情况下，你可以定义不同的图并在适当的时候解决它们。如果你需要为测试添加拆解逻辑，你可以在每个拆解步骤中添加额外的`fnk`条目，并用于拆解。
- en: Identifying performance bottlenecks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别性能瓶颈
- en: We discussed in previous chapters that random performance tuning of code rarely
    works, because we may not be tuning in the right place. It is crucial to find
    the performance bottlenecks before we can tune those areas in the code. Upon finding
    the bottleneck, we can experiment with alternate solutions around it. In this
    section we will look into finding the bottlenecks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了代码的随机性能调整很少有效，因为我们可能没有在正确的位置进行调整。在我们可以调整代码中的这些区域之前，找到性能瓶颈至关重要。找到瓶颈后，我们可以围绕它进行替代解决方案的实验。在本节中，我们将探讨如何找到瓶颈。
- en: Latency bottlenecks in Clojure code
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure代码中的延迟瓶颈
- en: Latency is the starting, and the most obvious, metric to drill-down in order
    to find bottlenecks. For Clojure code, we observed in [Chapter 6](ch06.html "Chapter 6. Measuring
    Performance"), *Measuring Performance* that code profiling tools can help us find
    the areas of bottleneck. Profilers are, of course, very useful. Once you discover
    hotspots via profilers, you may find ways to tune those for latency to a certain
    extent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是寻找瓶颈的起点，也是最明显的度量指标。对于Clojure代码，我们在[第6章](ch06.html "第6章。测量性能")中观察到，代码分析工具可以帮助我们找到瓶颈区域。当然，分析器非常有用。一旦通过分析器发现热点，你可能会找到一些方法来在一定程度上调整这些热点的延迟。
- en: 'Most profilers work on aggregates, a batch of runs, ranking the hotspots in
    code by resources consumed. However, often the opportunity to tune latency lies
    in the long tail that may not be highlighted by the profilers. In such circumstances,
    we may employ a direct drill-down technique. Let''s see how to carry out such
    drill-down using **Espejito** ([https://github.com/kumarshantanu/espejito](https://github.com/kumarshantanu/espejito)),
    a Clojure library for measuring latency (as of version 0.1.0) across measurement
    points in single-threaded execution paths. There are two parts of using **Espejito**,
    both requiring change to your code—one to wrap the code being measured, and the
    other to report the collected measurement data. The following code illustrates
    a contrived E-commerce use case of adding an item to a cart:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数分析器在聚合上工作，一批运行，按资源消耗对代码中的热点进行排名。然而，调整延迟的机会往往在于分析器可能没有突出的长尾。在这种情况下，我们可能需要采用直接钻取技术。让我们看看如何使用**Espejito**
    ([https://github.com/kumarshantanu/espejito](https://github.com/kumarshantanu/espejito))进行这样的钻取，这是一个用于在单线程执行路径中的测量点测量延迟的Clojure库（截至版本0.1.0）。使用**Espejito**有两个部分，都需要修改你的代码——一个用于包装要测量的代码，另一个用于报告收集到的测量数据。以下代码演示了一个虚构的电子商务用例，即向购物车添加商品：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Reporting a call is required to be made only once at the outermost (top-level)
    layer of the code. Measurement calls can be made at any number of places in the
    call path. Be careful not to put measurement calls inside tight loops, which may
    shoot memory consumption up. When this execution path is triggered, the functionality
    works as usual, while the latencies are measured and recorded alongside transparently
    in memory. The `e/report` call prints a table of recorded metrics. An example
    output (edited to fit) would be:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在代码的最外层（顶级）层报告一次调用。测量调用可以在调用路径中的任何位置进行。请注意不要在紧密循环中放置测量调用，这可能会使内存消耗增加。当此执行路径被触发时，功能按常规工作，同时延迟被透明地测量和记录在内存中。`e/report`调用打印出记录的指标表。一个示例输出（编辑以适应）可能如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we can observe that the database call is the most expensive (individual
    latency), followed by the web layer. Our tuning preference may be guided by the
    order of expensiveness of the measurement points.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到数据库调用是最昂贵的（单个延迟），其次是网络层。我们的调整偏好可能会根据测量点的昂贵程度来指导。
- en: Measure only when it is hot
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只在热点时进行测量
- en: 'One important aspect we did not cover in the drill-down measurement is whether
    the environment is ready for measurement. The `e/report` call is invoked unconditionally
    every time, which would not only have its own overhead (table printing), but the
    JVM may not be warmed up and the JIT compiler may not have kicked in to correctly
    report the latencies. To ensure that we report only meaningful latencies, let''s
    trigger the `e/report` call on an example condition:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入测量中我们没有涵盖的一个重要方面是环境是否已准备好进行测量。`e/report`调用每次都是无条件调用的，这不仅会有自己的开销（表格打印），而且JVM可能尚未预热，JIT编译器可能尚未启动以正确报告延迟。为了确保我们只报告有意义的延迟，让我们在以下示例条件下触发`e/report`调用：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s assume it is a **Ring**-based ([https://github.com/ring-clojure/ring](https://github.com/ring-clojure/ring))
    web app and you want to trigger the reporting only when the web request contains
    a parameter `report` with a value `true`. In that case, your call might look like
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设它是一个基于**Ring**（[https://github.com/ring-clojure/ring](https://github.com/ring-clojure/ring)）的Web应用程序，并且你希望在Web请求包含参数`report`且其值为`true`时才触发报告。在这种情况下，你的调用可能如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Condition-based invocation expects the JVM to be up across several calls, so
    it may not work with command-line apps.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基于条件的调用期望JVM在多次调用之间保持运行，因此它可能不适用于命令行应用程序。
- en: This technique can also be used in performance tests, where non-reporting calls
    may be made during a certain warm-up period, followed by a reporting call that
    provides its own reporter function instead of `e/print-table`. You may even write
    a sampling reporter function that aggregates the samples over a duration and finally
    reports the latency metrics. Not only for performance testing, you can use this
    for latency monitoring where the reporter function logs the metrics instead of
    printing a table, or sends the latency breakup to a metrics aggregation system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以用于性能测试，在某个预热期间可能进行非报告调用，然后通过提供自己的报告函数而不是`e/print-table`来进行报告调用。你甚至可以编写一个采样报告函数，它会在一段时间内汇总样本，并最终报告延迟指标。不仅限于性能测试，你还可以使用它进行延迟监控，其中报告函数记录指标而不是打印表格，或将延迟分解发送到指标聚合系统。
- en: Garbage collection bottlenecks
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收瓶颈
- en: 'Since Clojure runs on the JVM, one has to be aware of the GC behavior in the
    application. You can print out the GC details at runtime by specifying the respective
    JVM options in `project.clj` or on the Java command-line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Clojure运行在JVM上，因此必须了解应用程序中的GC行为。你可以在`project.clj`或Java命令行中指定相应的JVM选项来在运行时打印GC详细信息：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This causes a detailed summary of GC events to be printed as the application
    runs. To capture the output in a file, you can specify the following parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致在应用程序运行时打印出GC事件的详细摘要。为了将输出捕获到文件中，你可以指定以下参数：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also useful to see the time between and during full GC events:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要查看完全垃圾回收（GC）事件之间的时间以及事件期间的时间：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The other useful options to troubleshoot GC are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他有用的选项，用于调试GC：
- en: '`-XX:+HeapDumpOnOutOfMemoryError`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+HeapDumpOnOutOfMemoryError`'
- en: '`-XX:+PrintTenuringDistribution`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+PrintTenuringDistribution`'
- en: '`-XX:+PrintHeapAtGC`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+PrintHeapAtGC`'
- en: The output of the previous options may help you identify GC bottlenecks that
    you can try to fix by choosing the right garbage collector, other generational
    heap options, and code changes. For easy viewing of GC logs, you may like to use
    GUI tools such as **GCViewer** ([https://github.com/chewiebug/GCViewer](https://github.com/chewiebug/GCViewer))
    for this purpose.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前选项的输出可以帮助你识别可以尝试通过选择合适的垃圾回收器、其他代际堆选项和代码更改来修复的GC瓶颈。为了方便查看GC日志，你可能喜欢使用GUI工具，如**GCViewer**（[https://github.com/chewiebug/GCViewer](https://github.com/chewiebug/GCViewer)）来完成此目的。
- en: Threads waiting at GC safepoint
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待在GC安全点的线程
- en: 'When there is a long tight loop (without any I/O operation) in the code, the
    thread executing it cannot be brought to safepoint if GC happens when the loop
    ends or goes out of memory (for example, fails to allocate). This may have a disastrous
    effect of stalling other critical threads during GC. You can identify this category
    of bottleneck by enabling safepoint logs using the following JVM option:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码中存在一个长时间紧循环（没有任何I/O操作）时，如果在循环结束时或内存不足（例如，无法分配）时发生GC，则执行该循环的线程无法被带到安全点。这可能会在GC期间对其他关键线程产生灾难性的影响。你可以通过启用以下JVM选项来识别这类瓶颈：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The safepoint logs emitted by the previous option may help you identify the
    impact of a tight-loop thread on other threads during GC.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前选项生成的safepoint日志可能有助于您在GC期间识别紧循环线程对其他线程的影响。
- en: Using jstat to probe GC details
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用jstat检查GC细节
- en: 'The Oracle JDK (also OpenJDK, Azul''s Zulu) comes with a utility called `jstat`
    that can be handy to inspect GC details. You can find details on this utility
    at [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html)
    —the following examples show how to use it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle JDK（也称为OpenJDK、Azul的Zulu）附带了一个名为`jstat`的实用工具，可以用来检查GC细节。您可以在[https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html)找到有关此实用工具的详细信息——以下示例展示了如何使用它：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first command mentioned previously monitors object allocations and freeing
    in various heap generations, together with other GC statistics, one in every 10
    seconds. The second command also prints the reason for GC, along with other details.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的第一个命令每10秒监控一次各种堆代中的对象分配和释放，以及其他GC统计信息。第二个命令还打印出GC的原因以及其他详细信息。
- en: Inspecting generated bytecode for Clojure source
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Clojure源代码生成的字节码
- en: We discussed in [Chapter 3](ch03.html "Chapter 3. Leaning on Java"), *Leaning
    on Java* how to see the generated equivalent Java code for any Clojure code. Sometimes,
    there may not be a direct correlation between the generated bytecode and Java,
    which is when inspecting the generated bytecode is very useful. Of course, it
    requires the reader to know at least a bit about the JVM instruction set ([http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html](http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)).
    This tool can allow you to very effectively analyze the cost of the generated
    bytecode instructions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。依赖Java")*依赖Java*中讨论了如何查看任何Clojure代码生成的等效Java代码。有时，生成的字节码与Java之间可能没有直接关联，这时检查生成的字节码非常有用。当然，这要求读者至少对JVM指令集有一些了解（[http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html](http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)）。这个工具可以让你非常有效地分析生成字节码指令的成本。
- en: 'The project **no.disassemble** ([https://github.com/gtrak/no.disassemble](https://github.com/gtrak/no.disassemble))
    is a very useful tool to discover the generated bytecode. Include it in your `project.clj`
    file as a Leiningen plugin:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 项目**no.disassemble**（[https://github.com/gtrak/no.disassemble](https://github.com/gtrak/no.disassemble)）是一个非常实用的工具，用于发现生成的字节码。将其包含在您的`project.clj`文件中作为Leiningen插件：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, at the REPL, you can inspect the generated bytecodes one by one:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在REPL中，您可以逐个检查生成的字节码：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous snippet prints out the bytecode of the Clojure expression entered
    there.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段打印出了在那里输入的Clojure表达式的字节码。
- en: Throughput bottlenecks
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吞吐量瓶颈
- en: The throughput bottlenecks usually arise from shared resources, which could
    be CPU, cache, memory, mutexes and locks, GC, disk, and other I/O devices. Each
    of these resources has a different way to find utilization, saturation, and load
    level. This also heavily depends on the operating system in use, as it manages
    the resources. Delving into the OS-specific ways of determining those factors
    is beyond the scope of this text. However, we will look at profiling some of these
    for bottlenecks in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量瓶颈通常源于共享资源，这些资源可能是CPU、缓存、内存、互斥锁、GC、磁盘和其他I/O设备。每种资源都有不同的方法来查找利用率、饱和度和负载水平。这也很大程度上取决于所使用的操作系统，因为它管理这些资源。深入探讨特定于操作系统的确定这些因素的方法超出了本文的范围。然而，我们将在下一节中查看一些这些资源的分析以确定瓶颈。
- en: The net effect of throughput shows up as an inverse relationship with latency.
    This is natural as per Little's law—as we will see in the next chapter. We covered
    throughput testing and latency testing under concurrency in [Chapter 6](ch06.html
    "Chapter 6. Measuring Performance"), *Measuring Performance*. This should be roughly
    a good indicator of the throughput trend.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量的净效应表现为与延迟的倒数关系。根据Little定律，这是自然的——我们将在下一章中看到。在[第6章](ch06.html "第6章。测量性能")*测量性能*中，我们讨论了并发下的吞吐量测试和延迟测试。这应该大致是吞吐量趋势的良好指标。
- en: Profiling code with VisualVM
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VisualVM分析代码
- en: 'The Oracle JDK (also OpenJDK) comes with a powerful profiler called **VisualVM**;
    the distribution that comes with the JDK is known as Java VisualVM and can be
    invoked using the binary executable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle JDK（也称为OpenJDK）附带了一个名为**VisualVM**的强大分析器；与JDK一起提供的发行版被称为Java VisualVM，可以通过二进制可执行文件来调用：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This launches the GUI profiler app where you can connect to running instances
    of the JVM. The profiler has powerful features ([https://visualvm.java.net/features.html](https://visualvm.java.net/features.html))
    that can be useful for finding various bottlenecks in code. Besides analyzing
    heap dump and thread dump, VisualVM can interactively graph CPU and heap consumption,
    and thread status in near real time. It also has sampling and tracing profilers
    for both CPU and memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动GUI分析器应用程序，您可以通过它连接到正在运行的JVM实例。分析器具有强大的功能([https://visualvm.java.net/features.html](https://visualvm.java.net/features.html))，这些功能对于查找代码中的各种瓶颈非常有用。除了分析堆转储和线程转储外，VisualVM还可以实时交互式地绘制CPU和堆消耗，以及线程状态。它还具有针对CPU和内存的采样和跟踪分析器。
- en: The Monitor tab
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视器选项卡
- en: 'The **Monitor** tab has a graphical overview of the runtime, including CPU,
    heap, threads and loaded classes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**监视器**选项卡提供了运行时的图形概述，包括CPU、堆、线程和加载的类：'
- en: '![The Monitor tab](img/3642_07_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![监视器选项卡](img/3642_07_01.jpg)'
- en: This tab is useful for "at a glance" information, leaving further drill-down
    for other tabs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡用于快速查看信息，将更深入的挖掘留给其他选项卡。
- en: The Threads tab
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程选项卡
- en: 'In the following screenshot, the **Threads** tab shows the status of all threads:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，**线程**选项卡显示了所有线程的状态：
- en: '![The Threads tab](img/3642_07_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![线程选项卡](img/3642_07_02.jpg)'
- en: 'It is very useful to find out if any threads are undergoing contention, entering
    deadlock, are underutilized, or they are taking up more CPU. Especially in concurrent
    apps with in-memory state, and in apps that use limited I/O resources (such as
    connection pools, or network calls to other hosts) shared by threads, this feature
    provides a great insight if you set the thread names:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查找是否有任何线程正在竞争、进入死锁、利用率低或占用更多CPU是非常有用的。特别是在具有内存状态的并发应用程序中，以及在由线程共享的有限I/O资源（如连接池或对其他主机的网络调用）的应用程序中，如果您设置了线程名称，此功能提供了深入了解。
- en: 'Notice the threads named **citius-RollingStore-store-1** through **citius-RollingStore-store
    - 4**. In an ideal no-contention scenario, those threads would have a green **Running**
    status. See the legend at the bottom right of the image, which explains thread
    state:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名为**citius-RollingStore-store-1**到**citius-RollingStore-store-4**的线程。在理想的无竞争场景中，这些线程将具有绿色的**运行**状态。请看图像右下角的图例，它解释了线程状态：
- en: '**Running**: A thread is running, which is the ideal condition.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：一个线程正在运行，这是理想的状态。'
- en: '**Sleeping**: A thread has yielded control temporarily.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠**：一个线程暂时放弃了控制权。'
- en: '**Wait**: A thread is waiting for notification in a critical section. `Object.wait()`
    was called, and is now waiting for `Object.notify()` or `Object.notifyAll()` to
    wake it up.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待**：一个线程正在临界区等待通知。调用了`Object.wait()`，现在正在等待`Object.notify()`或`Object.notifyAll()`将其唤醒。'
- en: '**Park**: A thread is parked on a permit (binary semaphore) waiting for some
    condition. Usually seen with concurrent blocking calls in the `java.util.concurrent`
    API.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：一个线程在许可（二进制信号量）上挂起，等待某些条件。通常与`java.util.concurrent` API中的并发阻塞调用一起出现。'
- en: '**Monitor**: A thread has reached object monitor waiting for some lock, perhaps
    waiting to enter or exit a critical section.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**：一个线程已达到对象监视器，等待某些锁，可能是等待进入或退出临界区。'
- en: You can install the *Threads Inspector* plugin for details on threads of interest.
    To inspect thread dumps from the command line you can use the `jstack` or `kill
    -3` commands.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为感兴趣的线程安装*线程检查器*插件以获取详细信息。要检查命令行中的线程转储，您可以使用`jstack`或`kill -3`命令。
- en: The Sampler tab
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样器选项卡
- en: The **Sampler** tab is the lightweight sampling profiler tab that can sample
    both CPU and memory consumption. You can easily find hotspots in code that may
    benefit from tuning. However, sampler profiling is limited by sampling period
    and frequency, inability to detect inlined code, and so on. It is a good general
    indicator of the bottlenecks and looks similar to the screenshots we saw in [Chapter
    6](ch06.html "Chapter 6. Measuring Performance"), *Measuring Performance*. You
    can profile either CPU or memory at a time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样器**选项卡是轻量级的采样分析器选项卡，可以采样CPU和内存消耗。您可以轻松地找到代码中的热点，这些热点可能从调整中受益。然而，采样分析受采样周期和频率的限制，无法检测内联代码等。它是瓶颈的良好一般指标，看起来与我们[第6章](ch06.html
    "第6章。测量性能")中看到的截图相似，*测量性能*。您一次可以分析CPU或内存。'
- en: The **CPU** tab displays both the overall CPU time distribution and per-thread
    CPU consumption. You can take a thread dump while sampling is in progress and
    analyze the dump. There are several VisualVM plugins available for more analysis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU**选项卡显示整体CPU时间分布和每个线程的CPU消耗。在采样进行时，您可以获取线程转储并分析转储。有多个VisualVM插件可用于更深入的分析。'
- en: The **Memory** tab displays heap histogram metrics with distribution and instance
    count of objects. It also shows a PermGen histogram and per thread allocation
    data. It is a very good idea and highly recommended to set thread names in your
    project so that it is easy to locate those names in such tools. In this tab, you
    can force a GC, take a heap dump for analysis, and view memory metrics data in
    several ways.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存**选项卡显示堆直方图指标，包括对象的分布和实例计数。它还显示PermGen直方图和每个线程的分配数据。在项目中设置线程名称是一个非常好的主意，并且强烈推荐这样做，这样在工具中就可以轻松定位这些名称。在此选项卡中，您可以强制进行垃圾回收，为分析获取堆转储，并以多种方式查看内存指标数据。'
- en: Setting the thread name
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置线程名称
- en: 'Setting a thread name in Clojure is quite straightforward using Java interop:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中设置线程名称使用Java互操作非常简单：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, since threads often transcend several contexts, in most cases you
    should do so in a limited scope as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于线程通常跨越多个上下文，在大多数情况下，您应该像以下那样在有限的范围内进行操作：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now you can use this macro to execute any body of code with a specified thread
    name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用这个宏来执行任何具有指定线程名称的代码块：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This style of setting a thread name makes sure that the original name is restored
    before leaving the thread-local scope. If your code has various sections and you
    are setting a different thread name for each section, you can detect which code
    sections are causing contention by looking at the name when any contention appears
    on profiling and monitoring tools.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置线程名称的方式确保在离开线程局部作用域之前恢复原始名称。如果您的代码有多个部分，并且您为每个部分设置不同的线程名称，您可以通过查看在分析和监控工具上出现的任何竞争时的名称来检测哪些代码部分导致竞争。
- en: The Profiler tab
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**分析器**选项卡'
- en: The **Profiler** tab lets you instrument the running code in the JVM, and profile
    both CPU and memory consumption. This option adds a larger overhead than the **Sampler**
    tab, and poses a different trade off in terms of JIT compilation, inlining, and
    accuracy. This tab does not have as much diversity in visualization as the **Sampler**
    tab. The main difference this tab has with the **Sampler** tab is it changes the
    bytecode of the running code for accurate measurement. When you choose CPU profiling,
    it starts instrumenting the code for CPU profiling. If you switch from CPU to
    memory profiling, it re-instruments the running code for memory profiling, and
    re-instruments every time you want a different profiling. One downside of such
    instrumentation is that it may massively slow down everything if your code is
    deployed in application containers, such as Tomcat.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**选项卡允许您在JVM中分析运行中的代码，并分析CPU和内存消耗。此选项比**采样器**选项卡具有更大的开销，并且在JIT编译、内联和准确性方面提出了不同的权衡。此选项卡在可视化方面的多样性不如**采样器**选项卡。此选项卡与**采样器**选项卡的主要区别在于它更改运行代码的字节码以进行准确测量。当您选择CPU分析时，它开始对代码进行CPU分析。如果您从CPU切换到内存分析，它将重新对运行代码进行内存分析，并且每次您想要不同的分析时都会重新进行仪器分析。这种仪器分析的一个缺点是，如果您的代码部署在应用程序容器中，如Tomcat，它可能会大幅减慢一切。'
- en: While you can get most of the common CPU bottleneck information from **Sampler**,
    you may need the **Profiler** to investigate hotspots already discovered by **Sampler**
    and other profiling techniques. You can selectively profile and drill-down only
    the known bottlenecks using the instrumenting profiler, thereby restricting its
    ill-effects to only small parts of the code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以从**采样器**中获得大多数常见的CPU瓶颈信息，但您可能需要**分析器**来调查**采样器**和其他分析技术已发现的瓶颈。您可以使用仪器分析器有选择地分析并深入已知瓶颈，从而将其不良影响限制在代码的小部分。
- en: The Visual GC tab
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Visual GC**选项卡'
- en: The **Visual GC** is a VisualVM plugin that visually depicts the GC status in
    near real time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual GC**是一个VisualVM插件，可以实时地直观显示GC状态。'
- en: '![The Visual GC tab](img/3642_07_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![The Visual GC tab](img/3642_07_03.jpg)'
- en: If your application uses a lot of memory and potentially has GC bottlenecks,
    this plugin may be very useful for various troubleshooting purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序使用大量内存并且可能存在GC瓶颈，此插件可能对各种故障排除目的非常有用。
- en: The Alternate profilers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代分析器
- en: 'Besides VisualVM, there are several third-party profilers and performance-monitoring
    tools for the Java platform. Among open source tools, Prometheus ([http://prometheus.io/](http://prometheus.io/))
    and Moskito ([http://www.moskito.org/](http://www.moskito.org/)) are relatively
    popular. A non-exhaustive list of Open Source performance tools is here: [http://java-source.net/open-source/profilers](http://java-source.net/open-source/profilers)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 VisualVM 之外，还有几个针对 Java 平台的第三方性能分析器和性能监控工具。在开源工具中，Prometheus ([http://prometheus.io/](http://prometheus.io/))
    和 Moskito ([http://www.moskito.org/](http://www.moskito.org/)) 相对流行。开源性能工具的非详尽列表在这里：[http://java-source.net/open-source/profilers](http://java-source.net/open-source/profilers)
- en: There are several commercial proprietary profilers that you may want to know
    about. The YourKit ([https://www.yourkit.com/](https://www.yourkit.com/)) Java
    profiler is probably the most notable profiler that many people have found much
    success with for profiling Clojure code. There are also other profiling tools
    for the JVM, such as JProfiler ([https://www.ej-technologies.com/products/jprofiler/overview.html](https://www.ej-technologies.com/products/jprofiler/overview.html)),
    which is a desktop-based profiler and web-based hosted solutions such as New Relic
    ([http://newrelic.com/](http://newrelic.com/)) and AppDynamics ([https://www.appdynamics.com/](https://www.appdynamics.com/)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个商业专有性能分析器你可能想了解一下。YourKit ([https://www.yourkit.com/](https://www.yourkit.com/))
    的 Java 性能分析器可能是许多人用来分析 Clojure 代码的最著名性能分析器，他们从中获得了很大的成功。还有其他针对 JVM 的性能分析工具，例如
    JProfiler ([https://www.ej-technologies.com/products/jprofiler/overview.html](https://www.ej-technologies.com/products/jprofiler/overview.html))，这是一个基于桌面的性能分析器，以及基于网络的托管解决方案，如
    New Relic ([http://newrelic.com/](http://newrelic.com/)) 和 AppDynamics ([https://www.appdynamics.com/](https://www.appdynamics.com/))。
- en: Performance tuning
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能调优
- en: Once we get insight into the code via testing and profiling results, we need
    to analyze the bottlenecks worth considering for optimization. A better approach
    is to find the most under-performing portion and optimize it, thereby eliminating
    the weakest link. We discussed performance aspects of hardware and JVM/Clojure
    in previous chapters. Optimization and tuning requires rethinking the design and
    code in light of those aspects, and then refactoring for performance objectives.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过测试和性能分析结果对代码有了深入理解，我们就需要分析值得考虑优化的瓶颈。更好的方法是找到表现最差的片段并对其进行优化，从而消除最薄弱的环节。我们在前几章讨论了硬件和
    JVM/Clojure 的性能方面。优化和调整需要根据这些方面重新思考设计和代码，然后根据性能目标进行重构。
- en: Once we establish the performance bottlenecks, we have to pinpoint the root
    cause and experiment with improvisations, one step at a time, to see what works.
    Tuning for performance is an iterative process that is backed by measurement,
    monitoring and experimentation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了性能瓶颈，我们必须找出根本原因，并逐步尝试改进，看看什么有效。性能调优是一个基于测量、监控和实验的迭代过程。
- en: Tuning Clojure code
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调优 Clojure 代码
- en: Identifying the nature of the performance bottleneck helps a lot in order to
    experiment with the right aspects of the code. The key is to determine the origin
    of cost and whether the cost is reasonable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 识别性能瓶颈的本质对于实验代码的正确方面非常有帮助。关键是确定成本的来源以及成本是否合理。
- en: CPU/cache bound
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU/缓存绑定
- en: As we noted in the beginning of this chapter, setting up a project with the
    right JVM options and project settings informs us of reflection and boxing, the
    common sources of CPU-bound performance issues after poor design and algorithm
    choice. As a general rule, we have to see whether we are doing unnecessary or
    suboptimal operations, especially inside loops. For example, transducers are amenable
    to better performance than lazy sequences in CPU-bound operations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所指出的，设置具有正确 JVM 选项和项目设置的项目会让我们了解反射和装箱，这是在糟糕的设计和算法选择之后常见的 CPU 绑定性能问题的来源。一般来说，我们必须看看我们是否在进行不必要的或次优的操作，尤其是在循环内部。例如，transducers
    在 CPU 绑定操作中比懒序列更适合更好的性能。
- en: While public functions are recommended to work with immutable data structures,
    the implementation details can afford to use transients and arrays when performance
    is necessary. Records are a great alternative to maps, where appropriate, due
    to type hints and tight field layout in the former. Operations on primitive data
    types is faster (hence recommended) than their boxed equivalents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管建议公共函数使用不可变数据结构，但在性能必要时，实现细节可以使用瞬态和数组。在适当的情况下，记录是映射的一个很好的替代品，因为前者有类型提示和紧密的字段布局。对原始数据类型的操作比它们的包装类型更快（因此推荐）。
- en: In tight loops, besides transients and arrays you may prefer loop-recur with
    unchecked math for performance. You may also like to avoid using multi-methods
    and dynamic vars in tight loops, rather than pass arguments around. Using Java
    and macros may be the last resort, but still an option if there is such a need
    for performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧密循环中，除了transients和arrays，您可能更喜欢使用带有未检查数学的loop-recur以提高性能。您也可能喜欢避免在紧密循环中使用多方法和动态变量，而不是传递参数。使用Java和宏可能是最后的手段，但如果有这样的性能需求，仍然是一个选项。
- en: Memory bound
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存受限
- en: Allocating less memory in code is always going to reduce memory-related performance
    issues. Optimization of memory-bound code is not only about reducing memory consumption,
    but it is also about memory layout and utilizing the CPU and cache well. We have
    to see whether we are using the data types that fit well in CPU registers and
    cache lines. For cache and memory-bound code, we have to know whether there are
    cache misses and the reason—often the data might be too large to fit in a cache
    line. For memory-bound code we have to care about data locality, whether the code
    is hitting the interconnect too often, and whether memory representation of data
    can be slimmed down.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中分配更少的内存总是可以减少与内存相关的性能问题。优化内存受限代码不仅关乎减少内存消耗，还关乎内存布局以及如何有效地利用CPU和缓存。我们必须检查我们是否使用了适合CPU寄存器和缓存行的数据类型。对于缓存和内存受限代码，我们必须了解是否存在缓存未命中以及原因——通常数据可能太大，无法适应缓存行。对于内存受限代码，我们必须关注数据局部性，代码是否过于频繁地访问互连，以及数据在内存中的表示是否可以简化。
- en: Multi-threaded
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程
- en: Shared resources with side effects are the main source of contention and performance
    bottlenecks in multi-threaded code. As we saw in the *Profiling VisualVM code*
    section in this chapter, profiling the threads better informs us about the bottlenecks.
    The best way to improve performance of multi-threaded code is to reduce contention.
    The easy way to reduce contention is to increase the resources and reduce concurrency,
    though only optimal levels of resources and concurrency would be good for performance.
    While designing for concurrency, append only, single writer, and shared nothing
    approaches work well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 带有副作用共享资源是多线程代码中竞争和性能瓶颈的主要来源。正如我们在本章的 *VisualVM代码分析* 部分所看到的，更好地分析线程可以更好地了解瓶颈。提高多线程代码性能的最佳方法是减少竞争。减少竞争的简单方法是增加资源并减少并发性，尽管只有最优的资源水平和并发性对性能才是有益的。在设计并发时，仅追加、单写者和无共享方法都工作得很好。
- en: Another way to reduce contention may be to exploit thread-local queueing of
    data until resources are available. This technique is similar to what Clojure
    agents use, though it is an involved technique. [Chapter 5](ch05.html "Chapter 5. Concurrency"),
    *Concurrency* covers agents in some detail. I would encourage you to study the
    agents source code for better understanding. When using CPU-bound resources (for
    example `java.util.concurrent.atomic.AtomicLong`) you may use the contention-striping
    technique used by some Java 8 classes (such as `java.util.concurrent.atomic.LongAdder`,
    which also balances between memory consumption and contention striping across
    processors.) This technique is also quite involved and generic contention-striping
    solutions may have to trade off read consistency to allow fast updates.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少竞争的方法可能是利用线程局部队列直到资源可用。这种技术与Clojure代理所使用的技术类似，尽管它是一个复杂的技术。[第五章](ch05.html
    "第五章。并发") *并发* 对代理进行了详细说明。我鼓励您研究代理源代码以更好地理解。当使用CPU受限资源（例如 `java.util.concurrent.atomic.AtomicLong`）时，您可以使用一些Java
    8类（如 `java.util.concurrent.atomic.LongAdder`，它也在处理器之间平衡内存消耗和竞争条带化）使用的竞争条带化技术。这种技术也很复杂，通用的竞争条带化解决方案可能需要牺牲读一致性以允许快速更新。
- en: I/O bound
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O受限
- en: I/O-bound tasks could be limited by bandwidth or IOPS/latency. Any I/O bottleneck
    usually manifests in chatty I/O calls or unconstrained data serialization. Restricting
    I/O to only minimum required data is a common opportunity to minimize serialization
    and reduce latency. I/O operations can often be batched for higher throughput,
    for example *SpyMemcached* library employs an asynchronous batched operation for
    high throughput.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: I/O受限任务可能受到带宽或IOPS/延迟的限制。任何I/O瓶颈通常表现为频繁的I/O调用或未受约束的数据序列化。将I/O限制在仅所需的最小数据上是一种常见的减少序列化和降低延迟的机会。I/O操作通常可以批量处理以提高吞吐量，例如
    *SpyMemcached* 库使用异步批量操作以实现高吞吐量。
- en: I/O-bound bottlenecks are often coupled with multi-threaded scenarios. When
    the I/O calls are synchronous (for example, the JDBC API), one naturally has to
    depend upon multiple threads working on a bounded resource pool. Asynchronous
    I/O can relieve our threads from blocking, letting the threads do other useful
    work until the I/O response arrives. In synchronous I/O, we pay the cost of having
    threads (each allocated with memory) block on I/O calls while the kernel schedules
    them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 密集型瓶颈通常与多线程场景相关。当 I/O 调用是同步的（例如，JDBC API），自然需要依赖多个线程在有限资源池上工作。异步 I/O 可以减轻线程的阻塞，让线程在
    I/O 响应到达之前做其他有用的工作。在同步 I/O 中，我们付出了线程（每个分配了内存）在 I/O 调用上阻塞的成本，而内核则安排它们。
- en: JVM tuning
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM 调优
- en: Often Clojure applications might inherit bloat from Clojure/Java libraries or
    frameworks, which cause poor performance. Hunting down unnecessary abstractions
    and unnecessary layers of code may bring decent performance gains. Reasoning about
    the performance of dependency libraries/frameworks before inclusion in a project
    is a good approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 经常Clojure应用程序可能会从Clojure/Java库或框架中继承冗余，这会导致性能不佳。追踪不必要的抽象和不必要的代码层可能会带来可观的性能提升。在将依赖库/框架包含到项目中之前，考虑其性能是一个好的方法。
- en: The JIT compiler, garbage collector and safepoint (in Oracle HotSpot JVM) have
    a significant impact on the performance of applications. We discussed the JIT
    compiler and garbage collector in [Chapter 4](ch04.html "Chapter 4. Host Performance"),
    *Host Performance*. When the HotSpot JVM reaches a point when it cannot carry
    out concurrent, incremental GC anymore, it needs to suspend the JVM safely in
    order to carry out a full GC. It is also called the stop-the-world GC pause that
    may run up to several minutes while the JVM appears frozen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译器、垃圾收集器和安全点（在 Oracle HotSpot JVM 中）对应用程序的性能有重大影响。我们在第 4 章“主机性能”中讨论了 JIT
    编译器和垃圾收集器。当 HotSpot JVM 达到无法再执行并发增量 GC 的点时，它需要安全地挂起 JVM 以执行完全 GC。这也被称为“停止世界”GC
    暂停，可能持续几分钟，而 JVM 看起来是冻结的。
- en: The Oracle and OpenJDK JVMs accept many command-line options when invoked, to
    tune and monitor the way components in the JVM behave. Tuning GC is common among
    people who want to extract optimum performance from the JVM.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 和 OpenJDK JVM 在被调用时接受许多命令行选项，以调整和监控 JVM 中组件的行为方式。对于想要从 JVM 中提取最佳性能的人来说，调整
    GC 是常见的做法。
- en: 'You may like to experiment with the following JVM options (Oracle JVM or OpenJDK)
    for performance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想尝试以下 JVM 选项（Oracle JVM 或 OpenJDK）以提升性能：
- en: '| JVM option | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| JVM 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-XX:+AggressiveOpts` | Aggressive options that enable compressed heap pointers
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `-XX:+AggressiveOpts` | 侵略性选项，启用压缩堆指针 |'
- en: '| `-server` | Server class JIT thresholds (use -client for GUI apps) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `-server` | 服务器类 JIT 阈值（用于 GUI 应用程序请使用 -client） |'
- en: '| `-XX:+UseParNewGC` | Use Parallel GC |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `-XX:+UseParNewGC` | 使用并行 GC |'
- en: '| `-Xms3g` | Specify min heap size (keep it less on desktop apps) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `-Xms3g` | 指定最小堆大小（在桌面应用程序上保持较小） |'
- en: '| `-Xmx3g` | Specify max heap size (keep min/max same on servers) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `-Xmx3g` | 指定最大堆大小（在服务器上保持最小/最大相同） |'
- en: '| `-XX:+UseLargePages` | Reduce Translation-Lookaside Buffer misses (if OS
    supports), see [http://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html](http://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html)
    for details |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `-XX:+UseLargePages` | 减少（如果操作系统支持）转换查找缓冲区丢失，详情请见 [http://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html](http://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html)
    |'
- en: 'On the Java 6 HotSpot JVM, the **Concurrent Mark and Sweep** (**CMS**) garbage
    collector is well regarded for its GC performance. On the Java 7 and Java 8 HotSpot
    JVM, the default GC is a parallel collector (for better throughput), whereas at
    the time of writing this, there is a proposal to use the G1 collector (for lower
    pauses) by default in the upcoming Java 9\. Note that the JVM GC can be tuned
    for different objectives, hence the same exact configuration for one application
    may not work well for another. Refer to the documents Oracle published for tuning
    the JVM at the following links:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 6 HotSpot JVM 上，**并发标记清除**（CMS）垃圾收集器因其 GC 性能而受到好评。在 Java 7 和 Java 8 HotSpot
    JVM 上，默认的 GC 是并行收集器（以提高吞吐量），而撰写本文时，有一个提议在即将到来的 Java 9 中默认使用 G1 收集器（以降低暂停时间）。请注意，JVM
    GC 可以根据不同的目标进行调整，因此同一配置可能对不同的应用程序效果不佳。请参考 Oracle 发布的以下链接中关于调整 JVM 的文档：
- en: '[http://www.oracle.com/technetwork/java/tuning-139912.html](http://www.oracle.com/technetwork/java/tuning-139912.html)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.oracle.com/technetwork/java/tuning-139912.html](http://www.oracle.com/technetwork/java/tuning-139912.html)'
- en: '[https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)'
- en: Back pressure
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背压
- en: It is not uncommon to see applications behaving poorly under load. Typically,
    the application server simply appears unresponsive, which is often a combined
    result of high resource utilization, GC pressure, more threads that lead to busier
    thread scheduling, and cache misses. If the capacity of a system is known, the
    solution is to apply **back pressure** by denying services after the capacity
    is reached. Note that back pressure cannot be applied optimally until the system
    is load-tested for optimum capacity. The capacity threshold that triggers back
    pressure may or may not be directly associated with individual services, but rather
    can be defined as load criteria.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载下看到应用程序表现不佳并不罕见。通常，应用程序服务器简单地看起来无响应，这通常是高资源利用率、GC 压力、更多线程导致更繁忙的线程调度和缓存未命中等多种因素的综合结果。如果已知系统的容量，解决方案是在达到容量后拒绝服务以应用**背压**。请注意，只有在系统经过负载测试以确定最佳容量后，才能最优地应用背压。触发背压的容量阈值可能与单个服务直接相关，也可能不直接相关，而是可以定义为负载标准。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It is worth reiterating that performance optimization begins with learning about
    how the underlying system works, and measuring the performance of systems we build
    under representative hardware and load. The chief component of performance optimization
    is identifying the bottlenecks using various kinds of measurements and profiling.
    Thereafter, we can apply experiments to tune the performance of code and measure/profile
    once again to verify. The tuning mechanism varies depending on the type of bottleneck.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申的是，性能优化始于了解底层系统的工作原理，以及在我们构建的系统上代表硬件和负载的性能测量。性能优化的主要组成部分是使用各种类型的测量和剖析来识别瓶颈。之后，我们可以应用实验来调整代码的性能，并再次进行测量/剖析以验证。调整机制取决于瓶颈的类型。
- en: In the next chapter, we will see how to address performance concerns when building
    applications. Our focus will be on the several common patterns that impact performance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到在构建应用程序时如何解决性能问题。我们的重点将放在影响性能的几个常见模式上。
