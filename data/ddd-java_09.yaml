- en: '*Chapter 7*: Implementing Queries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：实现查询'
- en: The best view comes after the hardest climb.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最美的风景总是在最艰难的攀登之后。
- en: – Anonymous
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 匿名
- en: In the section *Command Query Responsibility Segregation (CQRS)* from [*Chapter
    3*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054), *Understanding the Domain,*
    we described how DDD and CQRS complement each other and how the query side (read
    models) can be used to create one or more representations of the underlying data.
    In this chapter, we will dive deeper into how we can construct read-optimized
    representations of the data by listening to domain events. We will also look at
    persistence options for these read models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054)“理解领域”的*命令查询责任分离（CQRS）*部分，我们描述了领域驱动设计（DDD）和CQRS如何相互补充，以及查询端（读取模型）如何用于创建底层数据的单一或多个表示。在本章中，我们将深入探讨如何通过监听领域事件来构建数据的高效读取表示。我们还将探讨这些读取模型的持久化选项。
- en: 'When working with query models, we construct models by listening to events
    as they happen. We will examine how to deal with the following situations:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当与查询模型一起工作时，我们通过监听事件的发生来构建模型。我们将探讨如何处理以下情况：
- en: New requirements evolving over a period of time, requiring us to build new query
    models.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，新需求不断演变，需要我们构建新的查询模型。
- en: We discover a bug in our query model that requires us to recreate the model
    from scratch.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的查询模型中发现了一个需要我们从零开始重新创建模型的bug。
- en: 'To do that, the agenda of the chapter includes the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，本章的议程包括以下主题：
- en: Continuing our design journey
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: Implementing the query side
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现查询端
- en: Historic event replays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史事件回放
- en: By the end of this chapter, you will learn to appreciate how to build query
    models by listening to domain events. You will also learn how to purpose-build
    new query models to suit specific read requirements as opposed to being restricted
    by the data model that was chosen to service commands. You will finally look at
    how historic event replays work and how you can use them to create new query models
    to service new requirements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会欣赏如何通过监听领域事件来构建查询模型。你还将学会如何专门构建新的查询模型以满足特定的读取需求，而不是受限于为服务命令而选择的数据库模型。你最终将了解历史事件回放的工作原理以及如何使用它们来创建新的查询模型以满足新的需求。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples in this chapter, you will need access to the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的示例，你需要访问以下内容：
- en: JDK 1.8+ (we have used Java 17 to compile sample sources)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+（我们使用Java 17编译示例源代码）
- en: Spring Boot 2.4.x
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.4.x
- en: Axon Framework 4.5.3
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axon Framework 4.5.3
- en: JUnit 5.7.x (included with Spring Boot)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5.7.x（包含在Spring Boot中）
- en: OpenJFX Monocle (for headless UI testing)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJFX Monocle（用于无头UI测试）
- en: Project Lombok (to reduce verbosity)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Lombok（用于减少冗余）
- en: Maven 3.x
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.x
- en: Please refer to the `Chapter07` directory of the book’s accompanying source
    code repository at [https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07)
    for complete working examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考书籍配套源代码仓库中的`Chapter07`目录，以获取完整的示例代码。[https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07)
- en: Continuing our design journey
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'In [*Chapter 4*](B16716_04_Final_NM_ePub.xhtml#_idTextAnchor065), *Domain Analysis
    and Modeling*, we discussed eventstorming as a lightweight method to clarify business
    flows. As a reminder, this is the output produced from our eventstorming session:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16716_04_Final_NM_ePub.xhtml#_idTextAnchor065)“领域分析和建模”中，我们讨论了事件风暴作为一种轻量级方法来阐明业务流程。作为提醒，这是我们事件风暴会议的输出：
- en: '![Figure 7.1 – Recap of the eventstorming session'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 事件风暴会议回顾'
- en: '](img/B16716_Figure_7.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 事件风暴会议回顾](img/B16716_Figure_7.1.jpg)'
- en: Figure 7.1 – Recap of the eventstorming session
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 事件风暴会议回顾
- en: As mentioned previously, we are making use of the CQRS architecture pattern
    to create the solution. For a detailed explanation on why this is a sound method
    to employ, you can revisit the *When to use CQRS* section in [*Chapter 3*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054),
    *Understanding the Domain,* where we’ve already covered this. In the preceding
    diagram, the green stickies represent read/query models. These query models are
    required when validating a command (for example, a list of valid product identifiers
    when processing the `ValidateProduct` command) or if the information is simply
    required to be presented to the user (for example, a list of LCs created by an
    applicant). Let’s look at what it means to apply CQRS in practical terms for the
    query side.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在使用CQRS架构模式来创建解决方案。关于为什么这是一个值得采用的方法的详细解释，您可以回顾[*第3章*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054)中的*何时使用CQRS*部分，*理解领域*，我们已经对此进行了讨论。在前面的图中，绿色的便利贴代表读取/查询模型。当验证一个命令（例如，处理`ValidateProduct`命令时的有效产品标识符列表）或信息需要简单地展示给用户时（例如，申请人创建的LC列表），这些查询模型是必需的。让我们看看在实际应用中如何将CQRS应用于查询端。
- en: Implementing the query side
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现查询端
- en: 'In [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*, we examined how to publish events when a command is successfully
    processed. Now, let’s look at how we can construct a query model by listening
    to these domain events. Logically, this will look something like the following
    diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中，*实现领域逻辑*，我们探讨了在命令成功处理时如何发布事件。现在，让我们看看我们如何通过监听这些领域事件来构建查询模型。从逻辑上讲，这看起来像以下图示：
- en: '![Figure 7.2 – The CQRS application – the query side'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – CQRS应用 – 查询端'
- en: '](img/B16716_Figure_7.2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_7.2.jpg)'
- en: Figure 7.2 – The CQRS application – the query side
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – CQRS应用 – 查询端
- en: For a detailed explanation of how the command side is implemented, please refer
    to the *Implementing the command side* section in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命令端是如何实现的详细解释，请参阅[*第5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中的*实现领域逻辑*部分。
- en: 'The high-level sequence on the query side is described here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 查询端的高级序列在此描述：
- en: An event listening component listens to these domain events published on the
    event bus.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个事件监听组件监听在事件总线上发布的这些领域事件。
- en: It constructs a purpose-built query model to satisfy a specific query use case.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它构建一个专门用于满足特定查询用例的查询模型。
- en: This query model is persisted in a datastore optimized for read operations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此查询模型持久化在针对读取操作优化的数据存储中。
- en: This query model is then exposed in the form of an API.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将此查询模型以API的形式公开。
- en: Note how there can exist more than one query side component for handling respective
    scenarios.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以存在多个查询端组件来处理相应的场景。
- en: Let’s implement each of these steps to see how this works for our LC issuance
    application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一实施这些步骤，看看这对我们的LC发行申请是如何工作的。
- en: Tooling choices
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具选择
- en: In a CQRS application, there is a separation between the command and query sides.
    At this time, this separation is logical in our application because both the command
    and query sides are running as components within the same application process.
    To illustrate the concepts, we will use conveniences provided by Axon Framework
    to implement the query side in this chapter. In [*Chapter 10*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150),
    *Beginning the Decomposition Journey*, we will look at how it may not be necessary
    to use a specialized framework (such as Axon) to implement the query side.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS应用中，命令端和查询端之间存在分离。目前，这种分离在我们的应用中是逻辑上的，因为命令端和查询端都在同一个应用进程中作为组件运行。为了说明这些概念，我们将使用Axon框架提供的便利性来实现本章的查询端。在[*第10章*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150)中，*开始分解之旅*，我们将探讨是否有必要使用专门的框架（如Axon）来实现查询端。
- en: 'When implementing the query side, we have two concerns to address, as depicted
    in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现查询端时，我们有两个关注点需要解决，如下面的图示所示：
- en: '![Figure 7.3 – The query side dissected'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 查询端剖析'
- en: '](img/B16716_Figure_7.3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_7.3.jpg)'
- en: Figure 7.3 – The query side dissected
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 查询端剖析
- en: 'These concerns are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关注点如下：
- en: Consuming domain events and persisting one or more query models
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费领域事件和持久化一个或多个查询模型
- en: Exposing the query model as an API
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将查询模型公开为API
- en: Before we start implementing these concerns, let’s identify the queries we need
    to implement for our LC issuance application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现这些关注点之前，让我们确定我们需要为我们的 LC 发放应用程序实现的查询。
- en: Identifying queries
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别查询
- en: 'From the eventstorming session, we have the following queries to start with:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件风暴会议中，我们开始有以下查询：
- en: '![Figure 7.4 – Identified queries'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 识别到的查询'
- en: '](img/B16716_Figure_7.4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_7.4.jpg)'
- en: Figure 7.4 – Identified queries
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 识别到的查询
- en: 'The queries marked in green (in the output from the eventstorming session from
    *Figure 7.1*) all require us to expose a collection of LCs in various states.
    To represent this, we can create an `LCView` class, an extremely simple object
    devoid of any logic, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件风暴会议的输出（如图 7.1 所示）中用绿色标记的查询都需要我们暴露各种状态的 LC 集合。为了表示这一点，我们可以创建一个 `LCView` 类，这是一个没有任何逻辑的极其简单的对象，如下所示：
- en: '![](img/ch7-1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch7-1.jpg)'
- en: These query models are an absolute necessity to implement basic functionality
    dictated by business requirements. But it is possible and very likely that we
    will need additional query models as the system requirements evolve. We will enhance
    our application to support these queries as and when the need arises.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询模型是实现由业务需求决定的基本功能的绝对必要条件。但是，随着系统需求的发展，我们很可能还需要额外的查询模型。我们将根据需要增强我们的应用程序以支持这些查询。
- en: Creating the query model
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建查询模型
- en: 'As seen in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*, when starting a new LC application, the importer sends `StartNewLCApplicationCommand`,
    which results in `LCApplicationStartedEvent` being emitted, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第 5 章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中所述，*实现领域逻辑*，当启动一个新的
    LC 应用程序时，导入器发送 `StartNewLCApplicationCommand`，这将导致 `LCApplicationStartedEvent`
    被触发，如下所示：
- en: '![](img/ch7-2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch7-2.jpg)'
- en: Let’s write an event-processing component that will listen to this event and
    construct a query model. When working with Axon Framework, we have a convenient
    way to do this by annotating the event-listening method with the `@EventHandler`
    annotation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个事件处理组件，它将监听此事件并构建查询模型。在处理 Axon 框架时，我们可以通过用 `@EventHandler` 注解标注事件监听方法来方便地完成这项工作。
- en: 'To make any method an event listener, we annotate it with the `@EventHandler`
    annotation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使任何方法成为事件监听器，我们需要用 `@EventHandler` 注解来标注它：
- en: '![](img/ch7-3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch7-3.jpg)'
- en: To make any method an event listener, we annotate it with the `@EventHandler`
    annotation.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使任何方法成为事件监听器，我们需要用 `@EventHandler` 注解来标注它。
- en: The handler method needs to specify the event that we intend to listen to. There
    are other arguments that are supported by event handlers. Please refer to the
    Axon Framework documentation for more information.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理方法需要指定我们打算监听的事件。事件处理器还支持其他一些参数。请参阅 Axon 框架文档以获取更多信息。
- en: We finally save the query model in an appropriate query store. When persisting
    this data, we should consider storing it in a form that is optimized for data
    access. In other words, we want to reduce as much complexity and cognitive load
    when querying this data.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终将查询模型保存在合适的查询存储中。在持久化这些数据时，我们应该考虑以优化数据访问的形式存储。换句话说，我们希望在查询这些数据时尽可能减少复杂性和认知负荷。
- en: The `@EventHandler` annotation should not be confused with the `@EventSourcingHandler`
    annotation that we looked at in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*. The `@EventSourcingHandler` annotation is used to
    replay events and restore aggregate state when loading event-sourced aggregates
    on the command side, whereas the `@EventHandler` annotation is used to listen
    to events outside the context of the aggregate. In other words, the `@EventSourcingHandler`
    annotation is used exclusively within aggregates, whereas the `@EventHandler`
    annotation can be used anywhere there is a need to consume domain events. In this
    case, we are using it to construct a query model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EventHandler` 注解不应与我们在[*第 5 章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中查看的
    `@EventSourcingHandler` 注解混淆，*实现领域逻辑*。`@EventSourcingHandler` 注解用于在命令端加载事件源聚合时重放事件并恢复聚合状态，而
    `@EventHandler` 注解用于在聚合上下文之外监听事件。换句话说，`@EventSourcingHandler` 注解仅用于聚合内部，而 `@EventHandler`
    注解可以在需要消费领域事件的地方使用。在这种情况下，我们正在使用它来构建查询模型。'
- en: Query-side persistence choices
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询端持久化选择
- en: Segregating the query side this way enables us to choose the persistence technology
    most appropriate for the problem being solved on the query side. For example,
    if extreme performance and simple filtering criteria are important, it may be
    prudent to choose an in-memory store such as Redis or Memcached. If complex search/analytics
    requirements and large datasets are to be supported, then we may want to consider
    something like Elasticsearch. Or we may even simply choose to stick with just
    a relational database. The point we would like to emphasize is that employing
    CQRS affords a level of flexibility that was previously not available to us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式隔离查询端使我们能够选择最适合在查询端解决问题的持久化技术。例如，如果极端性能和简单的过滤标准很重要，那么选择一个内存存储如Redis或Memcached可能是明智的。如果需要支持复杂的搜索/分析要求和大数据集，那么我们可能想考虑像Elasticsearch这样的东西。或者，我们甚至可以简单地选择坚持使用关系数据库。我们想强调的是，采用CQRS提供了一种以前我们没有的灵活性级别。
- en: Exposing a query API
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露查询API
- en: 'Applicants like to view the LCs they created, specifically those in the draft
    state. Let’s look at how we can implement this functionality. Let’s start by defining
    a simple object to capture the query criteria:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 申请者喜欢查看他们创建的LC，特别是处于草稿状态的LC。让我们看看我们如何实现此功能。让我们首先定义一个简单的对象来捕获查询标准：
- en: '![](img/ch7-4.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch7-4.jpg)'
- en: 'Let’s implement the query using Spring’s repository pattern to retrieve the
    results for these criteria:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring的仓库模式来实现查询，以检索这些标准的结果：
- en: '![](img/ch7-5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch7-5.jpg)'
- en: This is the dynamic Spring data finder method we will use to query the database.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们将用于查询数据库的动态Spring数据查找方法。
- en: The `@QueryHandler` annotation provided by Axon Framework routes query requests
    to the respective handler.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Axon框架提供的`@QueryHandler`注解将查询请求路由到相应的处理器。
- en: Finally, we invoke the finder method to return results.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用查找方法以返回结果。
- en: In the preceding example, we have implemented the `QueryHandler` method within
    the repository itself for brevity. `QueryHandler` can be placed elsewhere as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，为了简洁起见，我们在仓库本身中实现了`QueryHandler`方法。`QueryHandler`也可以放在其他地方。
- en: 'To connect this to the UI, we add a new method in `BackendService` (originally
    introduced in [*Chapter 6*](B16716_06_Final_NM_ePub.xhtml#_idTextAnchor097), *Implementing
    the User Interface - Task-Based*) to invoke the query, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此与UI连接，我们在`BackendService`中添加了一个新方法（最初在[*第6章*](B16716_06_Final_NM_ePub.xhtml#_idTextAnchor097)，*实现用户界面
    - 基于任务的实现）中介绍）来调用查询，如下所示：
- en: '![](img/ch7-6.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch7-6.jpg)'
- en: Axon Framework provides the `QueryGateway` convenience that allows us to invoke
    the query. For more details on how to use `QueryGateway`, please refer to the
    Axon Framework documentation.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Axon框架提供了`QueryGateway`便利性，允许我们调用查询。有关如何使用`QueryGateway`的更多详细信息，请参阅Axon框架文档。
- en: We execute the query using the `MyDraftLCsQuery` object to return results.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`MyDraftLCsQuery`对象执行查询以返回结果。
- en: What we looked at previously is an example of a very simple query implementation
    where we have a single `@QueryHandler` annotation to service the query results.
    This implementation returns results as a one-time fetch. Let’s look at more complex
    query scenarios.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前查看的是一个非常简单的查询实现示例，其中我们有一个单个`@QueryHandler`注解来服务查询结果。此实现作为一次性检索返回结果。让我们看看更复杂的查询场景。
- en: Advanced query scenarios
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级查询场景
- en: Our focus currently is on active LC applications. Maintaining issued LCs happens
    in a different bounded context of the system. Consider a scenario where we need
    to provide a consolidated view of currently active LC applications and issued
    LCs. In such a scenario, it is necessary to obtain this information by querying
    two distinct sources (ideally in parallel) – commonly referred to as the *scatter-gather*
    pattern. Please refer to the section on scatter-gather queries in the Axon Framework
    documentation for more details.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前关注的重点是活跃的LC应用。已签发的LC维护发生在系统的不同边界上下文中。考虑一个场景，我们需要提供当前活跃的LC应用和已签发的LC的统一视图。在这种情况下，有必要通过查询两个不同的来源（理想情况下并行）来获取这些信息，通常称为*散点-聚合*模式。请参阅Axon框架文档中关于散点-聚合查询的部分以获取更多详细信息。
- en: In other cases, we may want to remain up to date on dynamically changing data.
    For example, consider a real-time stock-ticker application tracking price changes.
    One way to implement this is by polling for price changes. A more efficient way
    to do this is to push price changes as and when they occur – commonly referred
    to as the *publish-subscribe* pattern. Please refer to the section on subscription
    queries in the Axon Framework documentation for more details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能希望保持对动态变化数据的最新状态。例如，考虑一个实时股票行情应用跟踪价格变化。实现这一点的 一种方式是通过轮询价格变化。一个更有效的方法是在价格变化发生时推送价格变化——通常被称为*发布-订阅*模式。有关详细信息，请参阅Axon框架文档中的订阅查询部分。
- en: Historic event replays
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史事件重放
- en: The example we have looked at thus far allows us to listen to events as they
    occur. Consider a scenario where we need to build a new query from historic events
    to satisfy an unanticipated new requirement. This new requirement may necessitate
    the need to create a new query model or, in a more extreme case, a completely
    new bounded context. Another scenario might be when we may need to correct a bug
    in the way we had built an existing query model and now need to recreate it from
    scratch. Given that we have a record of all events that have transpired in the
    event store, we can use replay events to enable us to construct both new and/or
    correct existing query models with relative ease.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的示例使我们能够监听事件的发生。考虑一个场景，我们需要从历史事件中构建一个新的查询来满足一个未预料到的新需求。这个新需求可能需要创建一个新的查询模型，或者在更极端的情况下，一个全新的边界上下文。另一种情况可能是当我们可能需要纠正我们构建现有查询模型的方式中的错误，现在需要从头开始重新创建它。鉴于我们在事件存储中记录了所有发生的事件，我们可以使用重放事件来使我们能够相对容易地构建新的和/或纠正现有的查询模型。
- en: Important Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have used the term *event replay* in the context of reconstituting the state
    of event-sourced aggregate instances (discussed in the *Event-sourced aggregates*
    section in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*). The event replay mentioned here, although similar in concept,
    is still very different. In the case of a domain object event replay, we work
    with a single aggregate root instance and only load events for that one instance.
    In this case, though, we will likely work with events that span more than one
    aggregate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在重新构建事件源聚合实例的状态的上下文中使用了术语*事件重放*（在[*第五章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)的*事件源聚合*部分讨论，*实现领域逻辑*）。这里提到的事件重放，尽管在概念上相似，但仍然非常不同。在领域对象事件重放的情况下，我们与单个聚合根实例一起工作，并且只为该实例加载事件。然而，在这种情况下，我们可能会处理跨越多个聚合的事件。
- en: Let’s look at the different types of replays and how we can use each of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同类型的事件重放以及我们如何使用每种类型。
- en: Types of replays
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重放类型
- en: 'When replaying events, there are at least two types of replays, depending on
    the requirements we need to meet. Let’s look at each type in turn:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在重放事件时，根据我们需要满足的要求，至少有两种类型的事件重放。让我们依次查看每种类型：
- en: '**Full event replay**: This is where we replay all the events in the event
    store. This can be used in a scenario where we need to support a completely new
    bounded context that is dependent on this subdomain. This can also be used in
    cases where we need to support a completely new query model or reconstruct an
    existing, erroneously built query model. Depending on the number of events in
    the event store, this can be a fairly long and complex process.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整事件重放**：这是指我们在事件存储中重放所有事件。这可以在我们需要支持一个完全新的、依赖于此子域的边界上下文的情况下使用。这也可以用于我们需要支持一个全新的查询模型或重建一个现有、错误构建的查询模型的情况。根据事件存储中的事件数量，这可能是一个相当长且复杂的过程。'
- en: '**Partial/ad hoc event replay**: This is where we need to replay all the events
    on a subset of aggregate instances or a subset of events on all aggregate instances,
    or a combination of both. When working with partial event replays, we will need
    to specify filtering criteria to select subsets of aggregate instances and events.
    This means that the event store needs to have the flexibility to support these
    use cases. Using specialized event store solutions (such as Axon Server and EventStoreDB,
    to name a couple) can be extremely beneficial.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分/临时事件回放**：这是我们需要在聚合实例的子集或所有聚合实例的事件子集上回放所有事件，或者两者的组合。当处理部分事件回放时，我们需要指定过滤标准来选择聚合实例和事件的子集。这意味着事件存储需要具有灵活性来支持这些用例。使用专业的事件存储解决方案（例如Axon
    Server和EventStoreDB，仅举两例）可以非常有益。'
- en: Event replay considerations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件回放考虑事项
- en: The ability to replay events and create new query models can be invaluable.
    However, like everything else, there are considerations that we need to keep in
    mind when working with replays. Let’s examine some of these in more detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 能够回放事件和创建新的查询模型可能非常有价值。然而，就像其他所有事情一样，在处理回放时，我们需要注意一些考虑因素。让我们更详细地探讨其中的一些。
- en: Event store design
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件存储设计
- en: 'As mentioned in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, when working with event-sourced aggregates, we persist
    immutable events in the persistence store. The primary use cases that we need
    to support are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第五章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中所述，*实现领域逻辑*，当与事件源聚合一起工作时，我们在持久化存储中持久化不可变事件。我们需要支持的主要用例如下：
- en: Provide consistent and predictable **write** performance when acting as an append-only
    store.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当作为只读存储时，提供一致且可预测的**写入**性能。
- en: Provide consistent and predictable **read** performance when querying for events
    using the aggregate identifier.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用聚合标识符查询事件时，提供一致且可预测的**读取**性能。
- en: 'However, replays (especially partial/ad hoc) require the event store to support
    much richer querying capabilities. Consider a scenario where we found an issue
    where the amount is incorrectly reported for LCs that were approved during a certain
    time period and only for a certain currency. To fix this issue, we need to do
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回放（尤其是部分/临时）需要事件存储支持更丰富的查询能力。考虑这样一个场景，我们发现了一个问题，即在某些时间段内仅对某些货币的已批准LC报告了错误的金额。为了修复这个问题，我们需要做以下几步：
- en: Identify affected LCs from the event store.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件存储中识别受影响的LC（逻辑组件）。
- en: Fix the issue in the application.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复应用程序中的问题。
- en: Reset the query store for these affected aggregates.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置受影响聚合的查询存储。
- en: Do a replay of a subset of events for the affected aggregates and reconstruct
    the query model.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对受影响聚合的子集事件进行回放并重建查询模型。
- en: Identifying affected aggregates from the event store can be tricky if we don’t
    support querying capabilities that allow us to introspect the event payload. Even
    if this kind of ad hoc querying were to be supported, these queries can adversely
    impact the command-handling performance of the event store. One of the primary
    reasons to employ CQRS was to make use of query-side stores for such complex read
    scenarios.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不支持允许我们内省事件负载的查询能力，从事件存储中识别受影响的聚合可能会很棘手。即使这种临时的查询能力得到支持，这些查询也可能对事件存储的命令处理性能产生不利影响。采用CQRS的主要原因之一就是利用查询端存储来解决这种复杂的读取场景。
- en: 'Event replays seem to introduce a chicken and egg problem where the query store
    has an issue that can only be corrected by querying the event store. A few options
    to mitigate this issue are discussed here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 事件回放似乎引入了一个“先有鸡还是先有蛋”的问题，即查询存储有一个问题，只能通过查询事件存储来纠正。这里讨论了一些缓解此问题的选项：
- en: '**General purpose store**: Choose an event store that offers predictable performance
    for both scenarios (command handling and replay querying).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用存储**：选择一个提供两种场景（命令处理和回放查询）可预测性能的事件存储。'
- en: '**Built-in datastore replication**: Make use of read replicas for event replay
    querying.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置数据存储复制**：利用读取副本进行事件回放查询。'
- en: '**Distinct datastores**: Make use of two distinct datastores to solve each
    problem on its own (for example, use a relational database/key-value store for
    command handling and a search-optimized document store for event replay querying).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的数据存储**：使用两个不同的数据存储来解决每个问题（例如，使用关系数据库/键值存储来处理命令，以及用于事件回放查询的搜索优化文档存储）。'
- en: Important Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Do note that the distinct datastores approach for replays is used to satisfy
    an operational problem as opposed to query-side business use cases discussed earlier
    in this chapter. Arguably, it is more complex because the technology team on the
    command side has to be equipped to maintain more than one database technology.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于回放的独立数据存储方法是为了满足操作问题，而不是本章前面讨论的查询端业务用例。可以说，它更复杂，因为命令端的技术团队必须配备维护多个数据库技术的能力。
- en: Event design
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件设计
- en: 'Event replays are required to reconstitute the state from an event stream.
    In this article on what it means to be event-driven ([https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)),
    Martin Fowler talks about three different styles of events. If we employ the event-carried
    state-transfer approach (in Martin’s article) to reconstitute state, it might
    require us to only replay the latest event for a given aggregate, as opposed to
    replaying all the events for that aggregate in order of occurrence. While this
    may seem convenient, it also has its downsides:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事件回放是必需的，以便从事件流中重建状态。在这篇文章《什么是事件驱动》（[https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)）中，马丁·福勒讨论了三种不同的事件风格。如果我们采用马丁文章中提到的事件携带状态转移方法来重建状态，那么可能只需要回放给定聚合的最新事件，而不是按发生顺序回放该聚合的所有事件。虽然这看起来很方便，但它也有其缺点：
- en: All events may now require carrying a lot of additional information that may
    not be relevant to that event. Assembling all this information when publishing
    the event can add to the cognitive complexity on the command side.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事件现在可能都需要携带大量可能对该事件不相关的附加信息。在发布事件时组装所有这些信息可能会增加命令端的认知复杂性。
- en: The amount of data that needs to be stored and flow through the wire can increase
    drastically.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要存储和通过网络传输的数据量可能会急剧增加。
- en: On the query side, it can increase cognitive complexity when understanding the
    structure of the event and processing it.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询方面，当理解事件结构和处理它时，可能会增加认知复杂性。
- en: In a lot of ways, this leads back to the CRUD-based versus task-based approach
    for APIs discussed in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*. Our general preference is to design events with as
    lean a payload as possible. However, your experiences may be different, depending
    on your specific problem or situation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，这回到了在第 [*5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077) 《实现领域逻辑》中讨论的基于
    CRUD 与基于任务的 API 接口方法。我们的总体偏好是尽可能设计出负载最轻的事件。然而，你的经验可能因具体问题或情况而异。
- en: Application availability
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序可用性
- en: 'In an event-driven system, it is common to accumulate an extremely large number
    of events over a period of time, even in a relatively simple application. Replaying
    a large number of events can be time-consuming. Let’s look at the mechanics of
    how replays typically work:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动系统中，随着时间的推移，即使在相对简单的应用程序中，也可能会积累大量的事件。回放大量事件可能会很耗时。让我们看看回放通常是如何工作的机制：
- en: We suspend listening to new events in preparation for a replay.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们暂停收听新事件，为回放做准备。
- en: Clear the query store for impacted aggregates.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除受影响聚合的查询存储。
- en: Start an event replay for impacted aggregates.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为受影响聚合启动事件回放。
- en: Resume listening to new events after the replay is complete.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回放完成后，继续收听新事件。
- en: Based on the preceding list, while the replay is running (*step 3*), we may
    not be able to provide reliable answers to queries that are impacted by the replay.
    This obviously has an impact on application availability. When using event replays,
    care needs to be taken to ensure that **Service Level Objectives** (**SLOs**)
    continue to be met.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述列表，在回放运行时（*步骤 3*），我们可能无法提供受回放影响查询的可靠答案。这显然会影响应用程序的可用性。在使用事件回放时，需要小心确保**服务级别目标**（**SLOs**）继续得到满足。
- en: Event handlers with side effects
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有副作用的事件处理器
- en: 'When replaying events, we re-trigger event handlers either to fix logic that
    was previously erroneous or to support new functionality. Invoking most (if not
    all) event handlers usually results in some sort of side effect (for example,
    updating a query store). This means that some event handlers may not be running
    for the first time. To prevent unwanted side effects, it is important to undo
    the effects of having invoked these event handlers previously or code event handlers
    in an idempotent manner (for example, by using an `upsert` command instead of
    a simple `insert` command or an `update` command). The effect of some event handlers
    can be hard (if not impossible) to undo (for example, invoking a command, sending
    an email, or SMS). In such cases, it might be required to mark such event handlers
    as being ineligible to run during the replay. When using Axon Framework, this
    is fairly simple to do:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在回放事件时，我们重新触发事件处理器，要么是为了修复之前错误的逻辑，要么是为了支持新的功能。调用大多数（如果不是所有）事件处理器通常会导致某种副作用（例如，更新查询存储）。这意味着某些事件处理器可能不是第一次运行。为了防止不希望的副作用，重要的是要撤销之前调用这些事件处理器的效果，或者以幂等的方式编写事件处理器（例如，使用`upsert`命令而不是简单的`insert`命令或`update`命令）。某些事件处理器的效果可能难以（如果不可能）撤销（例如，调用命令、发送电子邮件或短信）。在这种情况下，可能需要将这些事件处理器标记为在回放期间不可运行。在使用Axon框架时，这相当简单：
- en: '![](img/ch7-7.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch7-7.jpg)'
- en: '`@DisallowReplay` (or its counterpart `@AllowReplay`) can be used to explicitly
    mark event handlers ineligible to run during the replay.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@DisallowReplay`（或其对应项`@AllowReplay`）来明确标记事件处理器在回放期间不可运行。
- en: Events as an API
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件作为API
- en: 'In an event-sourced system where events are persisted instead of domain state,
    it is natural for the structure of events to evolve over a period of time. Consider
    an example of `BeneficiaryInformationChangedEvent`, which has evolved over a period
    of time, as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个事件源系统中，事件被持久化而不是领域状态，事件结构随时间演变是很自然的。考虑一个`BeneficiaryInformationChangedEvent`的例子，它在一段时间内发生了演变，如下所示：
- en: '![Figure 7.5 – Event evolution'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 事件演变'
- en: '](img/B16716_Figure_7.5.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_7.5.jpg)'
- en: Figure 7.5 – Event evolution
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 事件演变
- en: 'Given that the event store is immutable, it is conceivable that we may have
    one or more combinations of these event versions for a given LC. This can present
    a number of decisions we will need to make when performing an event replay:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件存储是不可变的，我们可以设想对于给定的LC，我们可能有一组或多个这些事件版本。这可能会在我们执行事件回放时带来一系列需要做出的决策：
- en: The producer can simply provide the historic event as it exists in the event
    store and allow consumers to deal with older versions of the event.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者可以简单地提供事件存储中存在的历史事件，并允许消费者处理事件的旧版本。
- en: The producer can upgrade older versions of events to the latest version before
    exposing them to the consumer.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者可以在将事件暴露给消费者之前将旧版本的事件升级到最新版本。
- en: Allow the consumer to specify an explicit version of the event that they are
    able to work with and upgrade it to that version before exposing it to the consumer.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许消费者指定他们能够处理的事件的显式版本，并在将其暴露给消费者之前将其升级到该版本。
- en: Migrate the events in the event store to the latest version as evolutions occur.
    This may not be feasible, given the immutable promise of events in the event store.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着演变的进行，将事件存储中的事件迁移到最新版本。考虑到事件存储中事件的不可变性承诺，这可能不可行。
- en: Which approach you choose really depends on your specific context and the maturity
    of the producer/consumer ecosystem. Axon Framework makes provisions for a process
    they call event upcasting that allows events to be upgraded just in time before
    they are consumed. Please refer to the Axon Framework documentation for more details.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种方法完全取决于你的具体环境和生产者/消费者生态系统的成熟度。Axon框架为它们称为事件上溯的过程提供了规定，允许事件在消费前即时升级。请参阅Axon框架文档以获取更多详细信息。
- en: In an event-driven system, events are your API. This means that you will need
    to apply the same rigor that you apply to APIs when making life cycle management
    decisions (for example, versioning, deprecation, and backward compatibility).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动系统中，事件是你的API。这意味着在做出生命周期管理决策（例如，版本控制、弃用和向后兼容性）时，你需要应用与API相同的严谨性。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined how to implement the query side of a CQRS-based
    system. We looked at how domain events can be consumed in real time to construct
    materialized views that can be used to service query APIs. We looked at the different
    query types that can be used to efficiently access the underlying query models.
    We rounded off by looking at persistence options for the query side.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了如何实现基于CQRS的系统的查询端。我们探讨了如何实时消费领域事件来构建可用来服务查询API的物化视图。我们研究了可以用来高效访问底层查询模型的不同查询类型。最后，我们探讨了查询端的持久化选项。
- en: Finally, we looked at historic event replays and how they can be used to correct
    errors or introduce new functionality in an event-driven system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了历史事件回放及其如何被用于在事件驱动系统中纠正错误或引入新功能。
- en: This chapter should give you a good idea of how to build and evolve the query
    side of a CQRS-based system to meet changing business requirements while retaining
    all the business logic on the command side.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应使您对如何构建和演进基于CQRS的系统查询端以满足不断变化的企业需求，同时保留命令端的所有业务逻辑有一个良好的理解。
- en: In this chapter, we looked at how to consume events in a stateless manner (where
    no two event handlers have knowledge of each other’s existence). In the next chapter,
    we will continue to look at how to consume events, but this time in a stateful
    manner, in the form of long-running user transactions (also known as sagas).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何以无状态的方式消费事件（即没有两个事件处理器知道彼此的存在）。在下一章中，我们将继续探讨如何消费事件，但这次是以有状态的方式进行，即通过长时间运行的用户事务（也称为叙事）。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_07_Table_01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_07_Table_01.jpg)'
