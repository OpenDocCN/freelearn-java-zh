- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building an Application Using TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TDD 构建应用程序
- en: We’re going to learn the practical side of TDD by building the application test
    first. We are also going to use an approach known as **agile software development**
    as we build. Being agile means building our software in small, self-contained
    iterations instead of building it all at once. These small steps allow us to learn
    more about the software design as we go. We adapt and refine the design over time,
    as we become more certain of how a good design might look. We can offer working
    functionality to early test users and receive their feedback long before the application
    is complete. This is valuable. As we have seen in earlier chapters, TDD is an
    excellent approach for providing rapid feedback on self-contained pieces of software.
    It is the perfect complement to agile development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过构建应用程序测试来学习 TDD 的实践方面。在构建过程中，我们还将使用一种称为 **敏捷软件开发** 的方法。敏捷意味着我们将以小而自包含的迭代方式构建软件，而不是一次性构建所有内容。这些小步骤使我们能够在进行中更多地了解软件设计。随着时间的推移，我们会根据对良好设计的信心进行设计调整和优化。我们可以在应用程序完成之前向早期测试用户提供可工作的功能，并在此期间收到他们的反馈。这是非常有价值的。正如我们在前面的章节中看到的，TDD
    是提供对自包含软件组件快速反馈的绝佳方法。它是敏捷开发的完美补充。
- en: To help us build in this way, this chapter will introduce the technique of **user
    stories**, which is a way of capturing requirements that fits an agile approach
    well. We will prepare our Java development environment ready for test-first development
    before describing what our application will do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们以这种方式构建，本章将介绍 **用户故事** 技巧，这是一种适合敏捷方法的捕获需求的方式。在描述我们的应用程序将做什么之前，我们将准备我们的
    Java 开发环境，以便进行测试优先开发。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Wordz application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Wordz 应用程序
- en: Exploring agile methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索敏捷方法
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The final code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter04](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在 [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter04](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter04)
    找到。
- en: To code along – which I highly recommend – we need to set up our development
    environment first. This will use the excellent JetBrains IntelliJ Java **Integrated
    Development Environment** (**IDE**), a free-of-charge Java SDK from Amazon, and
    some libraries to help us with writing our tests and including the libraries in
    our Java project. We will assemble all our development tools in the next section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要一起编码——我强烈推荐这样做——我们首先需要设置我们的开发环境。这将使用优秀的 JetBrains IntelliJ Java **集成开发环境**（**IDE**），来自
    Amazon 的免费 Java SDK 以及一些库来帮助我们编写测试并将库包含在我们的 Java 项目中。我们将在下一节中组装所有开发工具。
- en: Preparing our development environment
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备我们的开发环境
- en: 'For this project, we will be using the following tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用以下工具：
- en: IntelliJ IDEA IDE 2022.1.3 (Community Edition) or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE 2022.1.3（社区版）或更高版本
- en: Amazon Corretto Java 17 JDK
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Corretto Java 17 JDK
- en: The JUnit 5 unit test framework
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5 单元测试框架
- en: The AssertJ fluent assertions framework
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AssertJ 流畅断言框架
- en: The Gradle dependency management system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 依赖关系管理系统
- en: We will begin by installing our Java IDE, the JetBrains IntelliJ IDE Community
    Edition, before adding the rest of the tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装我们的 Java IDE，即 JetBrains IntelliJ IDE 社区版，然后再添加其余的工具。
- en: Installing the IntelliJ IDE
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 IntelliJ IDE
- en: To help us work with Java source code, we will use the JetBrains IntelliJ Java
    IDE, using its free-of-charge Community Edition. This is a popular IDE used in
    the software industry – and for good reason. It combines an excellent Java editor
    with auto-completion and code suggestions, together with a debugger, automated
    refactoring support, Git source control tools, and excellent integration for running
    tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们与 Java 源代码一起工作，我们将使用 JetBrains IntelliJ Java IDE，使用其免费的社区版。这是一个在软件行业中流行的
    IDE——而且有很好的理由。它将出色的 Java 编辑器与自动完成和代码建议相结合，以及调试器、自动重构支持、Git 源代码控制工具和出色的测试运行集成。
- en: 'To install IntelliJ, see the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 IntelliJ，请参阅以下步骤：
- en: Go to [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)。
- en: Click on the tab for your operating system.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您操作系统的标签页。
- en: Scroll down to the **Community** section.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 **社区** 部分。
- en: Follow the installation instructions for your operating system.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照您操作系统的安装说明进行操作。
- en: Once complete, the IntelliJ IDE should be installed on your computer. The next
    step is to create an empty Java project, using the Gradle package management system,
    and then set up whichever version of Java we wish to use. The installations for
    Mac, Windows, and Linux are usually straightforward.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，IntelliJ IDE应已安装在您的计算机上。下一步是创建一个空白的Java项目，使用Gradle包管理系统，然后设置我们希望使用的Java版本。Mac、Windows和Linux的安装通常很简单。
- en: Setting up the Java project and libraries
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Java项目和库
- en: Once IntelliJ is installed, we can import the starter project provided in the
    accompanying GitHub repository. This will set up a Java project that uses the
    Amazon Corretto 17 **Java Development Kit** (**JDK**), the JUnit 5 unit test runner,
    the Gradle build management system, and the AssertJ fluent assertions library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了IntelliJ，我们就可以导入随附GitHub仓库中提供的起始项目。这将设置一个使用Amazon Corretto 17 **Java开发工具包**（**JDK**）、JUnit
    5单元测试运行器、Gradle构建管理系统和AssertJ流畅断言库的Java项目。
- en: 'To do this, see the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请参阅以下步骤：
- en: In your web browser, go to [https://github.com/PacktPublishing/Test-Driven-Development-with-Java](https://github.com/PacktPublishing/Test-Driven-Development-with-Java).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中，访问[https://github.com/PacktPublishing/Test-Driven-Development-with-Java](https://github.com/PacktPublishing/Test-Driven-Development-with-Java)。
- en: 'Use your preferred `git` tool to clone the whole repository on your computer.
    If you use the `git` command-line tool, this will be as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的`git`工具在你的计算机上克隆整个仓库。如果你使用`git`命令行工具，这将如下所示：
- en: '`git clone https://github.com/PacktPublishing/Test-Driven-Development-with-Java.git`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/PacktPublishing/Test-Driven-Development-with-Java.git`'
- en: 'Launch IntelliJ. You should see the welcome screen:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动IntelliJ。你应该看到欢迎屏幕：
- en: '![Figure 4.1 – IntelliJ welcome screen](img/Figure_4.1_B18384.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – IntelliJ欢迎屏幕](img/Figure_4.1_B18384.jpg)'
- en: Figure 4.1 – IntelliJ welcome screen
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – IntelliJ欢迎屏幕
- en: 'Click `chapter04` folder of the repository that we just cloned. Click to highlight
    it:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚克隆的仓库中的`chapter04`文件夹。点击以突出显示它：
- en: "![Figure 4.2 – \uFEFFSelect the code folder](img/Figure_4.2_B18384.jpg)"
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 选择代码文件夹](img/Figure_4.2_B18384.jpg)'
- en: Figure 4.2 – Select the code folder
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 选择代码文件夹
- en: Click the **Open** button.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**按钮。
- en: 'Wait for IntelliJ to import the files. You should see this workspace open:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待IntelliJ导入文件。你应该看到以下工作空间已打开：
- en: '![Figure 4.3 – IntelliJ workspace view](img/Figure_4.3_B18384.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – IntelliJ工作空间视图](img/Figure_4.3_B18384.jpg)'
- en: Figure 4.3 – IntelliJ workspace view
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – IntelliJ工作空间视图
- en: We now have the IDE set up with a skeleton project containing everything we
    need to make a start. In the next section, we will describe the main features
    of the application we are going to build, which we will start to do in the next
    chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了IDE，包含了我们开始所需的所有内容的骨架项目。在下一节中，我们将描述我们将要构建的应用程序的主要功能，我们将在下一章开始构建它。
- en: Introducing the Wordz application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Wordz应用程序
- en: In this section, we will describe the application that we are going to build
    at a high level, before going on to look at the agile process we will use to build
    it. The application is called Wordz and it is based on a popular word guessing
    game. Players try to guess a five-letter word. Points are scored based on how
    quickly a player guesses the word. The player gets feedback on each guess to steer
    them towards the right answer. We are going to build the server-side components
    of this application throughout the remainder of this book using various TDD techniques.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在查看我们将要使用的敏捷过程之前，从高层次上描述我们将要构建的应用程序。该应用程序称为Wordz，它基于一个流行的猜词游戏。玩家试图猜测一个五字母单词。根据玩家猜测单词的速度来计分。玩家会收到每次猜测的反馈，以引导他们找到正确答案。我们将使用各种TDD技术在本书的剩余部分构建该应用程序的服务器端组件。
- en: Describing the rules of Wordz
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述Wordz的规则
- en: 'To play Wordz, a player will have up to six attempts to guess a five-letter
    word. After each attempt, letters in the word are highlighted as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要玩Wordz，玩家将有最多六次机会猜测一个五字母单词。每次尝试后，单词中的字母将按以下方式突出显示：
- en: The correct letter in the correct position has a black background
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确位置的正确字母具有黑色背景
- en: The correct letter in the wrong position has a gray background
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误位置的正确字母具有灰色背景
- en: Incorrect letters not present in the word have a white background
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不在单词中出现的错误字母具有白色背景
- en: The player can use this feedback to make a better next guess. Once a player
    guesses the word correctly, they score some points. They get six points for a
    correct guess on the first attempt, five points for a correct guess on the second
    attempt, and one point for a correct guess on the sixth and final attempt. Players
    compete against each other in various rounds to gain the highest score. Wordz
    is a fun game as well as a gentle brain workout.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以利用这个反馈来做出更好的下一个猜测。一旦玩家正确猜出单词，他们就能获得一些分数。第一次正确猜测得6分，第二次正确猜测得5分，第六次和最后一次正确猜测得1分。玩家在各个回合中相互竞争，以获得最高分。Wordz是一款既有趣又能温和锻炼大脑的游戏。
- en: 'Whilst building a user interface is outside the scope of this book, it is very
    helpful to see a possible example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构建用户界面超出了本书的范围，但看到一个可能的示例非常有帮助：
- en: '![Figure 4.4 – The Wordz game](img/Figure_4.4_B18384.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – Wordz游戏](img/Figure_4.4_B18384.jpg)'
- en: Figure 4.4 – The Wordz game
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – Wordz游戏
- en: Technically, we are going to create the backend web service component for this
    game. It will expose an **Application Programming Interface** (**API**) so that
    a user interface can use the service and will keep track of the game state in
    a database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们将为这个游戏创建后端Web服务组件。它将公开一个**应用程序编程接口**（**API**），以便用户界面可以使用该服务，并在数据库中跟踪游戏状态。
- en: To focus on the techniques of TDD, we will leave certain things out of our scope,
    such as user authentication and the user interface. A production version would,
    of course, include these aspects. But to implement these features, we don’t need
    any new TDD techniques.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于TDD的技术，我们将某些内容排除在我们的范围之外，例如用户身份验证和用户界面。当然，生产版本将包括这些方面。但为了实现这些功能，我们不需要任何新的TDD技术。
- en: This simple design will allow us to fully explore TDD through all the layers
    of a typical web application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的设计将使我们能够通过典型Web应用的各个层次全面探索TDD。
- en: Now that we’ve defined what we’re going to build, the next section will introduce
    the development approach we will use to build it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了我们要构建的内容，下一节将介绍我们将用于构建它的开发方法。
- en: Exploring agile methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索敏捷方法
- en: As we build Wordz, we are going to use an iterative approach, where we build
    the application as a series of features that our users can work with. This is
    known as **agile development**. It is effective as it allows us to ship features
    to users earlier and on a regular schedule. It allows us as developers to learn
    more about the problems we are solving and how a good software design looks as
    we go. This section will compare the benefits of agile development to waterfall
    approaches, then introduce an agile requirements gathering tool called user stories.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Wordz的过程中，我们将采用迭代方法，将应用程序构建为一系列用户可以使用的功能。这被称为**敏捷开发**。它非常有效，因为它允许我们更早、更规律地发布功能给用户。它允许我们作为开发者，在过程中更多地了解我们正在解决的问题以及良好的软件设计的外观。本节将比较敏捷开发与瀑布方法的优点，然后介绍一个名为用户故事的敏捷需求收集工具。
- en: The predecessor to agile is called **waterfall development**. It is called this
    because the project stages flow as a waterfall does, each one is fully completed
    before the next one is begun.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发的前身被称为**瀑布式开发**。之所以这样称呼，是因为项目阶段像瀑布一样流动，每个阶段都完全完成之后才会开始下一个阶段。
- en: 'In a waterfall project, we split development into sequential stages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在瀑布式项目中，我们将开发分为一系列连续的阶段：
- en: Collecting requirements
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集需求
- en: Performing an analysis of requirements
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行需求分析
- en: Creating a complete software design
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完整的软件设计
- en: Writing all the code
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写所有代码
- en: Testing the code
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试代码
- en: In theory, every stage is perfectly executed, everything works, and there are
    no problems. In reality, there are always problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，每个阶段都完美执行，一切正常，没有问题。实际上，总是会有问题。
- en: We discover certain requirements we had missed. We find that the design documents
    cannot be coded exactly as they were written. We find missing parts of the design.
    The coding itself can run into difficulties. The worst part is that the end user
    never sees any working software until the very end. If what they see is not what
    they had in mind, we have a very expensive set of changes and reworking to do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了一些遗漏的需求。我们发现设计文档不能完全按照它们所写的那样编码。我们发现设计中缺少部分。编码本身可能会遇到困难。最糟糕的是，最终用户直到最后都看不到任何可工作的软件。如果他们看到的东西不是他们所想的，我们就需要进行非常昂贵的更改和返工。
- en: The reason for this is that *humans have limited foresight*. Try as we might,
    we cannot predict the future with any accuracy. I can sit here with a hot cup
    of coffee and know accurately that it will go cold in twenty minutes. But I can’t
    tell you what the weather will be three months from now. Our ability to predict
    the future is limited to short time frames, for processes with clear-cut causes
    and effects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于*人类有有限的远见*。尽管我们尽力，但我们无法准确预测未来。我可以坐在这里，手里拿着一杯热咖啡，准确地知道它将在二十分钟后变凉。但我无法告诉你三个月后的天气。我们预测未来的能力局限于短期时间框架，对于有明确因果关系的流程。
- en: Waterfall development performs very poorly in the face of uncertainty and change.
    It is designed around the notion that all things can be known and planned in advance.
    A better approach is to *embrace* change and uncertainty, making it an active
    part of the development process. This is the basis of agile development. At its
    core lies an iterative approach, where we take one small feature that our users
    care about, then build that feature completely, allowing our users to try it out.
    If changes are needed, we do another iteration of development. The costs of change
    are much lower when our development process actively supports change.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布式开发在面对不确定性和变化时表现非常糟糕。它是围绕所有事物都可以提前知道和计划的概念设计的。更好的方法是*接受*变化和不确定性，使其成为开发过程的一个积极部分。这是敏捷开发的基础。其核心是一个迭代方法，其中我们选择一个用户关心的微小特性，然后完全构建该特性，让用户尝试。如果需要变更，我们进行另一轮开发迭代。当我们的开发过程积极支持变更时，变更的成本要低得多。
- en: Professional agile development processes rely on maintaining one single code
    base that is always tested and represents *the best version to date* of our software.
    This code is always ready to deploy to users. We grow this code base one feature
    at a time, continuously improving its design as we go.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 专业敏捷开发流程依赖于维护一个始终经过测试的单一代码库，它代表了我们软件到目前为至的*最佳版本*。这个代码库始终准备部署给用户。我们一次增加一个特性，在前进的过程中不断改进其设计。
- en: Techniques such as TDD play a major role in this, by ensuring our code is well
    designed and thoroughly tested. Every time we commit code to the main trunk, we
    already know it has passed many TDD tests. We know we are happy with its design.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如TDD（测试驱动开发）等技术在此中扮演着重要角色，通过确保我们的代码设计良好且经过彻底测试。每次我们将代码提交到主分支时，我们已经知道它已经通过了许多TDD测试。我们知道我们对它的设计感到满意。
- en: To better support iterative development, we choose an iterative technique for
    capturing requirements. This technique is called user stories, which we will describe
    in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地支持迭代开发，我们选择了一种迭代技术来捕捉需求。这种技术被称为用户故事，我们将在下一节中对其进行描述。
- en: Reading user stories – the building block of planning
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读用户故事——规划的基石
- en: As development is iterative and embraces refactoring and reworking, it makes
    sense that the old methods of specifying requirements won’t work. We are no longer
    served by thousands of pages of requirements set in stone up front. We are better
    served by taking one requirement at a time, building it, and learning from it.
    Over time, we can prioritize the features users want and learn more about how
    a *good design* will look.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发是迭代的，并接受重构和重做，因此旧的需求指定方法不再适用。我们不再被事先确定的大量需求文档所服务。我们更倾向于一次捕捉一个需求，构建它，并从中学习。随着时间的推移，我们可以优先考虑用户想要的功能，并更多地了解*良好设计*将如何呈现。
- en: Through agile techniques, we do not have to know the future in advance; we can
    discover it alongside our users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过敏捷技术，我们不需要提前知道未来；我们可以与用户一起发现它。
- en: 'Supporting this change is a new way to express requirements. Waterfall projects
    start with a complete requirements document, detailing every feature formally.
    The complete set of requirements – often thousands of them – were expressed in
    formal language such as “*The system shall…*” and then the details were explained
    in terms of changes to the software system. With agile development, we don’t want
    to capture requirements in that way. We want to capture them following two key
    principles:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这一变化的是一种新的需求表达方式。瀑布式项目从一份完整的需求文档开始，正式详细地描述每个特性。完整的需求集合——通常有数千个——使用如“*系统应…*”这样的正式语言表达，然后通过软件系统变更的细节进行解释。在敏捷开发中，我们不希望以这种方式捕捉需求。我们希望遵循两个关键原则来捕捉它们：
- en: Requirements are presented one at a time in isolation
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求一次一个地单独呈现
- en: We emphasize the value to the user, not the technical impact on the system
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们强调对用户的价值，而不是对系统技术影响
- en: 'The technique for doing this is called the user story. The first user story
    to tackle for Wordz looks as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一技术的被称为用户故事。Wordz 首个要解决的问题的用户故事如下所示：
- en: '![Figure 4.5 – The user story](img/Figure_4.5_B18384.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 用户故事](img/Figure_4.5_B18384.jpg)'
- en: Figure 4.5 – The user story
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 用户故事
- en: 'The format of a user story is always the same – it comprises three sections:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事的格式始终相同——它由三个部分组成：
- en: As a [person or machine that uses the software], …
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为[使用该软件的人或机器]，…
- en: I want [a specific outcome from that software] …
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想要[从这个软件中得到特定的结果]…
- en: … so that [a task that is important is achieved].
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …以便[完成一个重要的任务]。
- en: The three sections are written this way to emphasize that agile development
    centers around value delivered to the users of the system. These are not technical
    requirements. They do not (indeed, *must not*) specify a solution. They simply
    state which user of the system should get what valuable outcome out of it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分以这种方式编写是为了强调敏捷开发围绕着系统用户获得的价值。这些不是技术需求。它们不（实际上，*必须不*）指定解决方案。它们只是陈述系统哪个用户应该从中获得哪些有价值的成果。
- en: The first part always starts with “*As a …*.” It then names the user role that
    this story will improve. This can be any user – whether human or machine – of
    the system. The one thing it must never be is the system itself, as in, “*As a
    system*.” This is to enforce clear thinking in our user stories; they must always
    deliver some benefit to some user of the system. They are never an end in themselves.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分总是以“*作为…*”开始。然后命名这个故事将改进的用户角色。这可以是任何用户——无论是人类还是机器——的系统用户。唯一不能是的是系统本身，例如，“*作为系统*。”这是为了在我们的用户故事中强制清晰思考；它们必须始终为系统的某个用户提供一些好处。它们永远不是目的本身。
- en: 'To give an example from a photo-taking app, as developers, we might want a
    technical activity to optimize photo storage. We might write a story such as,
    “*As a system, I want to compact my image data to optimize storage*.” Instead
    of writing from a technical viewpoint, we can reframe this to highlight the benefit
    to the user: “*As a photographer, I want fast access to my stored photographs
    and to maximize space for new ones*.”'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个拍照应用为例，作为开发者，我们可能希望有一个技术活动来优化照片存储。我们可能会写一个故事，例如，“*作为一个系统，我想压缩我的图像数据以优化存储*。”而不是从技术角度出发，我们可以重新构架这个故事，以突出对用户的益处：“*作为一个摄影师，我想快速访问我的存储照片，并最大化新照片的空间*。”
- en: The “*I want…*” section describes the desired outcome the user wants. It is
    always described in user terminology, not technical terminology. Again, this helps
    us focus on what our users want our software to achieve for them. It is the purest
    form of capturing the requirements. There is no attempt made at this stage to
    suggest how anything will be implemented. We simply capture what it is that the
    user sets out to do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “*我想…*”部分描述了用户希望得到的结果。这部分总是使用用户术语来描述，而不是技术术语。再次强调，这有助于我们关注用户希望我们的软件为他们实现什么。这是捕捉需求最纯粹的形式。在这个阶段，我们并没有尝试提出任何实现方式。我们只是捕捉用户打算做什么。
- en: The final part, “*…so that…*”, provides context. The “*As a …*” section describes
    *who* benefits, the “*I want…*” section describes *how* they benefit, and the
    “*…so that…*” section describes *why* they need this feature. This forms the justification
    for the time and costs required for developing this feature. It can be used to
    prioritize which features to develop next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分，“*…以便…*”，提供了上下文。在“*作为…*”部分描述了*谁*受益，在“*我想…*”部分描述了*如何*受益，而在“*…以便…*”部分描述了*为什么*需要这个功能。这形成了开发此功能所需的时间和成本的理由。它可以用来确定下一个要开发的功能的优先级。
- en: This user story is where we start development. The heart of the Wordz application
    is its ability to evaluate and score the player’s current guess at a word. It’s
    worth looking at how this work will proceed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户故事是我们开始开发的地方。Wordz 应用程序的核心是其评估和评分玩家当前猜词的能力。看看这项工作将如何进行是值得的。
- en: Combining agile development with TDD
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将敏捷开发与 TDD 结合
- en: TDD is a perfect complement to agile development. As we learned in earlier chapters,
    TDD helps us improve our design and prove that our logic is correct. Everything
    we do is aimed at delivering working software to our users, without defects, as
    quickly as possible. TDD is a great way to achieve this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是敏捷开发的完美补充。正如我们在前面的章节中学到的，TDD 帮助我们改进设计并证明我们的逻辑是正确的。我们所做的一切都是为了尽快向用户提供无缺陷的软件，TDD
    是实现这一目标的好方法。
- en: 'The workflow we will use is typical for an agile TDD project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的流程对于敏捷 TDD 项目来说是典型的：
- en: Pick a user story prioritized for impact.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个优先级高的用户故事。
- en: Think a little about the design to aim for.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细考虑一下要实现的设计目标。
- en: Use TDD to write the application logic in the core.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TDD编写核心中的应用逻辑代码。
- en: Use TDD to write code to connect the core to a database.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TDD编写代码以将核心连接到数据库。
- en: Use TDD to write code to connect to an API endpoint.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TDD编写代码以连接到API端点。
- en: This process repeats. It forms the rhythm of writing the core application logic
    under a unit test, then growing the application outward, connecting it to API
    endpoints, user interfaces, databases, and external web services. Working this
    way, we retain a lot of flexibility within our code. We can also work quickly,
    concentrating upfront on the most important parts of our application code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会重复。它形成了在单元测试下编写核心应用程序逻辑的节奏，然后向外扩展应用程序，将其连接到API端点、用户界面、数据库和外部网络服务。以这种方式工作，我们在代码中保留了大量的灵活性。我们还可以快速工作，一开始就专注于应用程序代码最重要的部分。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve learned the key ideas that let us build an application iteratively, getting
    value at each step and avoiding a *big design up front* approach that often disappoints.
    We can read user stories, which will drive building our TDD application in small,
    well-defined steps. We now also know the process we will use to build our application
    – using TDD to get a thoroughly tested, central core of clean code, and then drive
    out connections to the real world.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了让我们能够迭代构建应用程序的关键思想，在每一步获得价值，并避免通常令人失望的“一开始就进行大量设计”的方法。我们可以阅读用户故事，这将驱动我们以小而明确的步骤构建我们的TDD应用程序。现在我们也知道了我们将用于构建应用程序的过程——使用TDD来获得彻底测试的、干净的代码中心，然后将其扩展到现实世界。
- en: In the next chapter, we’ll make a start on our application. We will learn the
    three key components of every TDD test by writing our first test and making sure
    it passes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始我们的应用程序。我们将通过编写第一个测试并确保它通过来学习每个TDD测试的三个关键组件。
- en: Questions and answers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Waterfall development sounds as though it should work well – why doesn’t it?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水晶球开发听起来应该能很好地工作——为什么它不呢？
- en: Waterfall development would work well if we knew about every missing requirement,
    every change request from the users, every bad design decision, and every coding
    error at the start of the project. But humans have limited foresight, and it is
    impossible to know these things in advance. So, waterfall projects never work
    smoothly. Expensive changes crop up at a later stage of the project – just when
    you don’t have the time to address them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在项目开始时就知道每个缺失的需求、每个用户变更请求、每个糟糕的设计决策以及每个编码错误，那么瀑布式开发会很好地工作。但人类的预见性有限，事先知道这些事情是不可能的。因此，瀑布项目永远不会顺利。在项目后期出现昂贵的变更——就在你没有时间处理它们的时候。
- en: Can we do agile development without TDD?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不使用TDD的情况下进行敏捷开发？
- en: Yes, although that way, we miss out on the advantages of TDD that we’ve covered
    in previous chapters. We also make our job harder. An important part of Agile
    development is always demonstrating the latest working code. Without TDD, we need
    to add a large manual test cycle into our process. This slows us down significantly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，尽管那样，我们会错过我们在前几章中涵盖的TDD的优势。我们还使我们的工作变得更难。敏捷开发的一个重要部分是始终展示最新的工作代码。没有TDD，我们需要在我们的流程中添加一个大的手动测试周期。这会显著减慢我们的进度。
- en: Further reading
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering React Test-Driven Development, ISBN 9781789133417*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通React测试驱动开发，ISBN 9781789133417*'
- en: If you would like to build a user interface for the Wordz application, using
    the popular React web UI framework is an excellent way to do it. This Packt book
    is one of my personal favorites. It shows how to apply the same kind of TDD techniques
    we are using server-side into frontend work. It also explains React development
    from the ground up in a highly readable way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为Wordz应用程序构建用户界面，使用流行的React网络UI框架是一个很好的方法。这本Packt书籍是我个人的最爱之一。它展示了如何将我们在服务器端使用的相同类型的TDD技术应用到前端工作中。它还以高度可读的方式解释了从零开始React开发。
- en: '*Agile Model-Based Systems Engineering Cookbook, ISBN 9781838985837*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*敏捷模型化系统工程食谱，ISBN 9781838985837*'
- en: This book provides further details on how to craft effective user stories and
    other useful techniques for capturing agile requirements, modeling, and analysis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了如何编写有效的用户故事以及捕捉敏捷需求、建模和分析的其他有用技术的进一步细节。
