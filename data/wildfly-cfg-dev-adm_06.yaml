- en: Chapter 6. Application Structure and Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 应用结构及部署
- en: Deployment is the process of uploading resources or applications on the application
    server. During the software development life cycle, it is the step that logically
    follows the development phase and can be performed either manually or in an automated
    fashion.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是将资源或应用程序上传到应用程序服务器的过程。在软件开发生命周期中，它是开发阶段之后的逻辑步骤，可以手动执行或以自动化的方式执行。
- en: In this chapter, we will explore both approaches using the tools that are provided
    by the server distribution. We will also cover how to deploy resources on the
    application server using the WildFly plugin for Eclipse. This is the preferred
    choice for Java developers due to the quick deployment time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用服务器发行版提供的工具来探索这两种方法。我们还将介绍如何使用WildFly插件为Eclipse部署资源。由于快速部署时间，这是Java开发者的首选选择。
- en: 'In the last part of this chapter, we cover the details of the WildFly classloader
    architecture. In short, our agenda for this chapter includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将介绍WildFly类加载器架构的细节。简而言之，本章的议程包括以下主题：
- en: The type of resources that can be deployed on WildFly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在WildFly上部署的资源类型
- en: Deploying applications on a WildFly standalone instance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WildFly独立实例上部署应用程序
- en: Deploying applications on a WildFly domain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WildFly域上部署应用程序
- en: Understanding WildFly's classloading architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WildFly的类加载架构
- en: Deploying resources on the application server
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序服务器上部署资源
- en: 'There are basically three file types that we work with in Java Enterprise applications,
    which are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java企业应用程序中，我们基本上处理三种文件类型，如下所示：
- en: '**JAR**: This is the most basic package, which can be used for both application
    and common resources'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAR**：这是最基本的包，可用于应用程序和通用资源'
- en: '**WAR**: This is used to package web applications'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WAR**：此文件用于打包Web应用程序'
- en: '**EAR**: This packages multiple WAR files or contains a set of modules'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EAR**：此文件打包多个WAR文件或包含一系列模块'
- en: 'Besides these, WildFly is able to process the following archives, which provide
    the application server with additional functionality:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，WildFly还能够处理以下存档，为应用程序服务器提供额外的功能：
- en: '**RAR**: This is the resource adapter file, which is used to define a resource
    adapter component (the resource adapter subsystem is provided by the `IronJacamar`
    project; for more information, visit [http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar))'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAR**：这是资源适配器文件，用于定义资源适配器组件（资源适配器子系统由`IronJacamar`项目提供；更多信息，请访问[http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar))'
- en: '**SAR**: This file enables the deployment of service archives containing the
    `MBean` services, as supported by previous versions of the application server'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAR**：此文件使服务存档的部署成为可能，其中包含`MBean`服务，这是由应用程序服务器的早期版本支持的'
- en: In this chapter, we will discuss the first three kinds of archives, all of which
    constitute the typical packaging solution for Java Enterprise applications. Before
    discussing application deployment, let's look at the single archives in a little
    more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论前三种类型的存档，它们构成了Java企业应用程序的典型打包解决方案。在讨论应用程序部署之前，让我们更详细地了解一下单一存档。
- en: The JAR file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JAR文件
- en: A **Java** **Archive** (**JAR**) file is used to package multiple files into
    a single archive. Its internal physical layout is similar to a ZIP file, and as
    a matter of fact, it uses the same algorithm as the zip utility for compressing
    files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java** **存档**（**JAR**）文件用于将多个文件打包成一个单一的存档。其内部物理布局类似于ZIP文件，实际上，它使用与zip实用程序相同的算法来压缩文件。'
- en: A JAR file is generally used to distribute Java classes and associated metadata.
    In Java EE applications, the JAR file often contains utility code, shared libraries,
    and Enterprise JavaBeans (EJBs).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JAR文件通常用于分发Java类和相关元数据。在Java EE应用程序中，JAR文件通常包含实用代码、共享库和企业JavaBeans（EJBs）。
- en: The WAR file
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WAR文件
- en: A **Web** **Application** **Archive** (**WAR**) file is essentially an archive
    used to encapsulate a web application. The web application usually includes a
    collection of web-related resources, such as **Java** **Server** **Pages** (**JSP**),
    servlets, XHTML/HTML files, and so on. It also includes Java class files, and
    possibly other file types, depending on the technology used. Since Java EE 6,
    EJBs can be packaged within a WAR archive using the same packaging guidelines
    that apply to web application classes. This means that you can place EJB classes,
    along with the other class files, under the `classes` directory under `WEB-INF`.
    Alternatively, you can package your EJBs within a JAR file and then place this
    JAR file in the `WEB-INF\lib` directory of WAR.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web** **应用程序** **存档** (**WAR**) 文件本质上是一个用于封装 Web 应用程序的存档。Web 应用程序通常包括一组与
    Web 相关的资源，例如 **Java** **服务器** **页面** (**JSP**)、servlets、XHTML/HTML 文件等。它还包括 Java
    类文件，以及可能的其他文件类型，具体取决于所使用的技术。自 Java EE 6 以来，可以使用适用于 Web 应用程序类的相同打包指南将 EJBs 打包到
    WAR 存档中。这意味着您可以将 EJB 类以及其他类文件放置在 `WEB-INF` 下的 `classes` 目录中。或者，您可以将 EJBs 打包到一个
    JAR 文件中，然后将此 JAR 文件放置在 WAR 的 `WEB-INF\lib` 目录中。'
- en: Because of this, it's more common for developers to use the WAR file to distribute
    Java EE applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发者更倾向于使用 WAR 文件来分发 Java EE 应用程序。
- en: The EAR file
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EAR 文件
- en: 'An **Enterprise** **Archive** (**EAR**) file represents an application archive,
    which acts as a container for a set of modules or WAR files. An EAR file can contain
    any of the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业** **存档** (**EAR**) 文件代表一个应用程序存档，它充当一组模块或 WAR 文件的容器。EAR 文件可以包含以下任何一种：'
- en: One or more web modules packaged in WAR files
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 WAR 文件中的一个或多个 Web 模块
- en: One or more EJB modules packaged in JAR files
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 JAR 文件中的一个或多个 EJB 模块
- en: One or more application client modules
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个应用程序客户端模块
- en: Any additional JAR files required by the application
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序所需的任何附加 JAR 文件
- en: JBoss-specific archives such as the SAR file
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JBoss 特定的存档，如 SAR 文件
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two distinct advantages of using an Enterprise Archive file. First,
    it helps to distribute all application components using a single archive instead
    of distributing every single module. Second, and most important, is the fact that
    applications within an EAR file are loaded by a single classloader. This means
    that each module has visibility on other modules packed within the same archive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用企业存档文件有两个明显的优势。首先，它有助于使用单个存档分发所有应用程序组件，而不是分发每个单独的模块。其次，也是最重要的，是事实上的情况，即 EAR
    文件中的应用程序由单个类加载器加载。这意味着每个模块都可以看到同一存档中打包的其他模块。
- en: 'The isolation level of application modules contained in the EAR file can be
    modified by adding the `ear-subdeployments-isolated` element to the main configuration
    file (`domain.xml` or `standalone.xml`). The default value is `false`, which means
    that the classes in the WAR file can access the classes in the `ejb.jar` file.
    Likewise, the classes in the `ejb.jar` file can access each other. If, for some
    reason, you do not want this behavior and want to restrict the visibility of your
    classes, add the following lines to your configuration file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向主配置文件（`domain.xml` 或 `standalone.xml`）中添加 `ear-subdeployments-isolated`
    元素来修改 EAR 文件中包含的应用程序模块的隔离级别。默认值是 `false`，这意味着 WAR 文件中的类可以访问 `ejb.jar` 文件中的类。同样，`ejb.jar`
    文件中的类可以相互访问。如果出于某种原因，您不希望这种行为并希望限制类的可见性，请将以下行添加到您的配置文件中：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the *Explaining WildFly classloading* section, we will discuss the application
    server classloading architecture in depth. We will also show you how to override
    this configuration setting at the application level.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *解释 WildFly 类加载* 部分，我们将深入讨论应用程序服务器类加载架构。我们还将向您展示如何在应用程序级别覆盖此配置设置。
- en: Deploying applications on a standalone WildFly server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在独立 WildFly 服务器上部署应用程序
- en: Deploying applications on JBoss has traditionally been a fairly simple task,
    so you might wonder why a full chapter has been dedicated to it. The answer to
    this is that deploying applications on WildFly can be achieved in several ways,
    each of which we are going to look at.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JBoss 上部署应用程序传统上是一个相当简单的任务，因此您可能会想知道为什么有一个完整的章节被专门用于它。这个答案在于，在 WildFly 上部署应用程序可以通过几种方式实现，每种方式我们都会查看。
- en: 'First of all, we are going to look at automatic deployment of applications
    via the `deployments` folder, but before we do this, we need to explain the two
    modes available when deploying applications:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看通过 `deployments` 文件夹自动部署应用程序，但在这样做之前，我们需要解释在部署应用程序时可以使用的两种模式：
- en: '**Automatic** **deployment mode**: This mode is triggered by the deployment
    scanner when a resource within the `deployments` folder is modified'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动** **部署模式**：此模式由部署扫描器在`deployments`文件夹中的资源被修改时触发'
- en: '**Manual deployment mode**: This mode does not rely on the deployment scanner
    to trigger a deployment, but rather on a set of marker files to decide if the
    application needs to be deployed/redeployed'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动部署模式**：此模式不依赖于部署扫描器来触发部署，而是依赖于一组标记文件来决定应用程序是否需要部署/重新部署'
- en: Automatic application deployment
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动应用部署
- en: 'Automatic application deployment consists of placing your application in the
    `deployments` folder, which is located at the following path:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动应用部署包括将您的应用程序放置在`deployments`文件夹中，该文件夹位于以下路径：
- en: '`JBOSS_HOME\standalone\deployments`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`JBOSS_HOME\standalone\deployments`'
- en: 'By default, every application archive (WAR, JAR, EAR, and SAR) that is placed
    in this folder is automatically deployed on the server, as shown in the following
    screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，放置在此文件夹中的每个应用程序归档（WAR、JAR、EAR和SAR）都会在服务器上自动部署，如下面的截图所示：
- en: '![Automatic application deployment](img/6232OS_06_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![自动应用部署](img/6232OS_06_01.jpg)'
- en: 'The service that scans for deployed resources is called the **deployment scanner**,
    and it is configured within the `standalone.xml` configuration file. You can find
    it by searching for the `deployment-scanner` domain. The following snippet shows
    the default deployment scanner configuration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描已部署资源的服务称为**部署扫描器**，它配置在`standalone.xml`配置文件中。您可以通过搜索`deployment-scanner`域来找到它。以下代码片段显示了默认部署扫描器配置：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, by default, the server scans in the `deployments` folder every
    `5000` ms. This service can be customized in many ways. Next, we will look at
    how we can further configure the deployment scanner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，默认情况下，服务器每`5000`毫秒扫描一次`deployments`文件夹。此服务可以通过多种方式自定义。接下来，我们将探讨如何进一步配置部署扫描器。
- en: Deploying applications to a custom folder
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将应用程序部署到自定义文件夹
- en: 'If you want to change the location of the deployment folder, you need to modify
    the `relative-to` and `path` properties. If you provide both properties, the `deployments`
    folder is a sum of both properties. For example, considering that you have defined
    the `wildfly8deployments` path, you can later reference it as a relative path
    for your deployments, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改部署文件夹的位置，您需要修改`relative-to`和`path`属性。如果您提供了这两个属性，则`deployments`文件夹是这两个属性的叠加。例如，假设您已定义了`wildfly8deployments`路径，您可以在以后将其作为部署的相对路径引用，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this configuration, the deployment scanner looks for applications within
    the `deployments` folder under `/opt/applications`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，部署扫描器在`/opt/applications`下的`deployments`文件夹中查找应用程序。
- en: 'The same effect can be achieved using an absolute path for your deployments,
    leaving out the `relative-to` property and configuring the `path` element, as
    shown in the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用绝对路径来设置您的部署，省略`relative-to`属性并配置`path`元素，如下例所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Changing the behavior of the deployment scanner
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改部署扫描器的行为
- en: By default, every packaged archive that is placed in the `deployments` folder
    is automatically deployed. On the other hand, exploded applications need one more
    step to be deployed (see the *Manual application deployment* section).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，放置在`deployments`文件夹中的每个打包归档都会自动部署。另一方面，展开的应用程序需要额外一步才能部署（请参阅*手动应用部署*部分）。
- en: 'We can easily change this behavior of the deployment scanner. The properties
    that control the `auto-deploy` feature are `auto-deploy-zipped` and `auto-deploy-exploded`,
    respectively, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地改变部署扫描器的这种行为。控制`auto-deploy`功能的属性分别是`auto-deploy-zipped`和`auto-deploy-exploded`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can set the `auto-deploy-exploded` property to `true` to achieve automatic
    deployment of exploded archives, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`auto-deploy-exploded`属性设置为`true`以实现展开归档的自动部署，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Deployment rollback
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署回滚
- en: 'WildFly 8 introduces a new option to roll back a failed deployment. To do this,
    simply update the `runtime-failure-causes-rollback` property to `true`, as shown
    in the following code snippet. The default behavior is `false`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 8引入了一个新的选项，可以回滚失败的部署。为此，只需将`runtime-failure-causes-rollback`属性更新为`true`，如下面的代码片段所示。默认行为是`false`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the `failure-causes-rollback` property is set to `true`, a deployment failure
    also triggers the rollback of any other deployment that was processed as part
    of the same scan.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`failure-causes-rollback`属性设置为`true`，部署失败也会触发作为同一扫描部分处理的任何其他部署的回滚。
- en: Deploying an application using the CLI
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CLI部署应用程序
- en: Copying the application archives is often favored by many developers, as it
    can be performed automatically by the development environment. However, we lay
    stress on the advantages of using the CLI interface, which offers a wide choice
    of additional options when deploying and also allows you to deploy applications
    remotely.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 复制应用程序存档通常被许多开发者所青睐，因为它可以通过开发环境自动执行。然而，我们强调使用CLI界面（命令行界面）的优点，它提供了广泛的附加选项，在部署时使用，并允许你远程部署应用程序。
- en: 'All it takes to deploy an application archive is to log in to the CLI, either
    a local or remote instance, and issue the `deploy` command. When used without
    arguments, the `deploy` command prints a list of applications that are currently
    deployed. Take a look at the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序存档只需登录CLI，无论是本地还是远程实例，然后发出`deploy`命令。当不带参数使用时，`deploy`命令会打印出当前已部署的应用程序列表。看看以下命令：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To deploy your application to the standalone server, pass through the relative
    (or absolute) path of your archive. This path obviously relates to the client
    machine if you are connected to a remote server. This immediately deploys your
    application to the server. Take a look at the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的应用程序部署到独立服务器，传递存档的相对（或绝对）路径。显然，如果你连接到远程服务器，此路径与客户端机器相关。这立即将你的应用程序部署到服务器。看看以下截图：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you specify a relative path, it is relative to the location you started
    the CLI utility from. You can, however, use absolute paths when specifying the
    location of your archives. The CLI auto-complete functionality (using the *Tab*
    key) makes light work of this. Have a look at the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个相对路径时，它是相对于你启动CLI实用程序的位置而言的。然而，在指定存档位置时，你可以使用绝对路径。CLI自动完成功能（使用*Tab*键）可以轻松完成这项工作。看看以下命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By default, when you deploy via the CLI, the application is deployed and enabled
    so that the user can access it. If you want to just perform the deployment of
    the application and enable it at a later time, you can add the `--disabled` switch,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你通过CLI部署时，应用程序会被部署并启用，以便用户可以访问它。如果你想只执行应用程序的部署并在稍后启用它，你可以添加`--disabled`开关，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to enable the application, simply issue another `deploy` command without
    the `--disabled` switch, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用应用程序，只需发出另一个不带`--disabled`开关的`deploy`命令，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you notice the optional `--name` switch that has been added? When using
    this switch, you are able to use the **tab completion** feature so that you can
    automatically find the inactive deployment unit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到新增的可选`--name`开关了吗？使用此开关时，你可以使用**tab完成**功能，以便自动找到不活动的部署单元。
- en: 'Redeploying the application requires an additional flag to the `deploy` command.
    You will get an error if you try to deploy the same application twice without
    using this flag. The `–f` argument forces the redeployment of the application,
    as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重新部署应用程序需要向`deploy`命令添加一个额外的标志。如果你不使用此标志尝试两次部署相同的应用程序，将会得到错误。`–f`参数强制重新部署应用程序，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Undeploying the application can be done through the `undeploy` command, which
    takes the name of the deployment as an argument, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`undeploy`命令可以卸载应用程序，该命令将部署名称作为参数，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Upon checking the configuration file, `standalone.xml`, you notice that the
    `deployment` element for your application has been removed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查配置文件`standalone.xml`时，你会注意到你的应用程序的`deployment`元素已被删除。
- en: Deploying an application using the web admin console
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Web管理控制台部署应用程序
- en: 'Application deployment can also be completed using the web admin console:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署也可以通过Web管理控制台完成：
- en: Start the console hyperlink, `http://localhost:9990/console`, in your browser.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中启动控制台超链接，`http://localhost:9990/console`。
- en: You need to add at least one management user to access the web console. To add
    a new user, execute the `add-user.bat` or `add-user.sh` script within the `bin`
    folder of your WildFly installation, and enter the requested information. See
    [Chapter 10](ch10.html "Chapter 10. Securing WildFly"), *Securing WildFly*, for
    more details.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要添加至少一个管理用户以访问 Web 控制台。要添加新用户，请在您的 WildFly 安装目录的 `bin` 文件夹中执行 `add-user.bat`
    或 `add-user.sh` 脚本，并输入所需信息。有关更多详细信息，请参阅第 10 章 [Chapter 10. Securing WildFly]，*Securing
    WildFly*。
- en: Server deployment is managed by the application server by selecting **Runtime**
    in the top menu and then choosing the **Manage Deployments** option. If you want
    to add a new application to WildFly, just click on the **Add** button of your
    console, as shown in the following screenshot:![Deploying an application using
    the web admin console](img/6232OS_06_02.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器部署通过在顶部菜单中选择 **运行时** 并然后选择 **管理部署** 选项来管理。如果您想向 WildFly 添加新应用程序，只需单击控制台的
    **添加** 按钮即可，如下面的屏幕截图所示：![使用 Web 管理控制台部署应用程序](img/6232OS_06_02.jpg)
- en: 'An intuitive wizard guides you through selecting your application and providing
    a runtime name for it, as shown in the following screenshot:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个直观的向导将引导您选择应用程序并为它提供一个运行时名称，如下面的屏幕截图所示：
- en: '![Deploying an application using the web admin console](img/6232OS_06_03.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 Web 管理控制台部署应用程序](img/6232OS_06_03.jpg)'
- en: 'There are two properties shown in the wizard that may cause some confusion:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 向导中显示的两个属性可能会引起一些混淆：
- en: The **Name** property is the name by which the deployment should be known within
    a server's runtime, for example, `MyApp-1.0.0.war`. This is used as the basis
    for the module names and is usually the name of the archive.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称** 属性是部署在服务器运行时中应知的名称，例如，`MyApp-1.0.0.war`。这用作模块名称的基础，通常是存档的名称。'
- en: The **Runtime Name** is typically the same as the **Name**, but there may be
    instances where you wish to have two deployments with the same runtime name. For
    example, you may have `MyApp-1.0.0.war` and `MyApp-1.0.1.war` within the content
    repository but have the runtime name of `MyApp.war` for both archives. They cannot
    be deployed at the same time, and one of them would need to be disabled.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时名称** 通常与 **名称** 相同，但可能存在您希望具有相同运行时名称的两个部署的情况。例如，您可能在内容库中有 `MyApp-1.0.0.war`
    和 `MyApp-1.0.1.war`，但两个存档的运行时名称都是 `MyApp.war`。它们不能同时部署，其中一个需要被禁用。'
- en: 'The admin console, by default, deploys the application but does not enable
    it. By clicking on the **Enable** button, the application can now be accessed,
    as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，管理员控制台部署应用程序但不启用它。通过单击 **启用** 按钮，现在可以访问应用程序，如下面的屏幕截图所示：
- en: '![Deploying an application using the web admin console](img/6232OS_06_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Web 管理控制台部署应用程序](img/6232OS_06_04.jpg)'
- en: Deploying an application using the WildFly Eclipse plugin
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 WildFly Eclipse 插件部署应用程序
- en: Eclipse is the most widely used application development environment for Java
    developers, and it's also the favorite IDE for JBoss developers, as the JBoss
    Tools project ([http://www.jboss.org/tools](http://www.jboss.org/tools)) supports
    the Eclipse environment by providing a set of plugins for JBoss projects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 是 Java 开发者最广泛使用的应用程序开发环境，也是 JBoss 开发者的首选 IDE，因为 JBoss Tools 项目 ([http://www.jboss.org/tools](http://www.jboss.org/tools))
    通过提供一组插件来支持 Eclipse 环境。
- en: In the first chapter of this book, we outlined the installation steps for Eclipse,
    along with JBoss tools. We also set up the WildFly server adapter, which allows
    you to start, stop, debug, and deploy applications on WildFly using the standalone
    mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们概述了 Eclipse 和 JBoss 工具的安装步骤。我们还设置了 WildFly 服务器适配器，它允许您使用独立模式在 WildFly
    上启动、停止、调试和部署应用程序。
- en: 'Deploying applications to WildFly is easy once you have your WildFly Eclipse
    plugin installed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 WildFly Eclipse 插件，部署应用程序到 WildFly 就变得简单：
- en: Simply navigate to the **Server** tab, right-click on the **WildFly Runtime
    Server**, and select **Add and Remove**. You are presented with a window, as shown
    in the following screenshot:![Deploying an application using the WildFly Eclipse
    plugin](img/6232OS_06_05.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地导航到 **服务器** 选项卡，右键单击 **WildFly 运行时服务器**，然后选择 **添加和移除**。您将看到一个窗口，如下面的屏幕截图所示：![使用
    WildFly Eclipse 插件部署应用程序](img/6232OS_06_05.jpg)
- en: Next, click on your application, select **Add**, and then click on **Finish**.
    The project now publishes to the server. If you ever need to redeploy, click on
    the project you want to deploy, and choose **Full** **Publish**, as shown in the
    following screenshot:![Deploying an application using the WildFly Eclipse plugin](img/6232OS_06_06.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击你的应用程序，选择**添加**，然后点击**完成**。项目现在将发布到服务器。如果你需要重新部署，点击你想要部署的项目，并选择**完全**
    **发布**，如图所示：![使用WildFly Eclipse插件部署应用程序](img/6232OS_06_06.jpg)
- en: Configuring Eclipse deployments
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Eclipse部署
- en: 'By double-clicking on the WildFly Runtime, you have access to a tabbed menu,
    which contains two options: **Overview** and **Deployment**. The **Deployment**
    option is specific to JBoss tools and lets you choose the deployment location
    and packaging style of deployment. Take a look at the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击WildFly运行时，你可以访问一个带标签的菜单，其中包含两个选项：**概览**和**部署**。**部署**选项是针对JBoss工具的，允许你选择部署位置和部署打包风格。请查看以下截图：
- en: '![Configuring Eclipse deployments](img/6232OS_06_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![配置Eclipse部署](img/6232OS_06_07.jpg)'
- en: Upon checking the **Deploy projects as compressed archives** option, your application
    is compressed and packaged.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在勾选**将项目作为压缩存档部署**选项后，你的应用程序将被压缩并打包。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you choose to deploy your application as an exploded archive, Eclipse adds
    a `.dodeploy` marker file once the application has been copied to the `deployments`
    folder. This triggers immediate application deployment. See the next section for
    more information about marker files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择将应用程序作为展开的存档部署，一旦应用程序被复制到`deployments`文件夹，Eclipse就会添加一个`.dodeploy`标记文件。这会触发应用程序的即时部署。有关标记文件的更多信息，请参阅下一节。
- en: Manual application deployment
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动应用程序部署
- en: When using the manual application deployment approach, the deployment scanner
    does not automatically deploy the applications that are placed in the `deployments`
    folder. Rather, it uses a set of marker files, which are used to trigger application
    redeployment and capture the result of the operation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用手动应用程序部署方法时，部署扫描器不会自动部署放置在`deployments`文件夹中的应用程序。相反，它使用一组标记文件，这些文件用于触发应用程序重新部署并捕获操作的结果。
- en: You might wonder why marker files are used by the application server and why
    the default server configuration is set to use exploded deployments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道应用程序服务器为什么使用标记文件，以及为什么默认服务器配置设置为使用展开部署。
- en: Actually, there are several reasons for this choice, and all of them are related
    to how the operating system's filesystem works. Exploded archives involve moving/replacing
    files in your filesystem, which should be performed automatically. By atomic operation,
    we mean that a filesystem operation needs to be performed as a single operation.
    Unfortunately, some operating systems like Windows don't treat complex filesystem
    operations such as a file moving as atomic operations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个选择有几个原因，它们都与操作系统的文件系统工作方式有关。展开存档涉及在文件系统中移动/替换文件，这应该自动执行。通过原子操作，我们指的是文件系统操作需要作为一个单一操作执行。不幸的是，一些操作系统，如Windows，不会将复杂的文件系统操作，如文件移动，视为原子操作。
- en: Most Windows users often experience deployment issues on releases of WildFly
    prior to JBoss AS 7\. This is due to the JVM refusing to release a file handle
    to `META-INF/application.xml` or an EJB descriptor file. That's because Windows
    uses a mandatory file lock, which prevents any application from accessing the
    file. On the other hand, operating systems such as UNIX use an advisory file lock,
    which means that unless an application checks for a file lock, it is not prevented
    from accessing the file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Windows用户在JBoss AS 7之前的WildFly版本发布时经常遇到部署问题。这是因为JVM拒绝释放对`META-INF/application.xml`或EJB描述符文件的文件句柄。这是因为Windows使用强制文件锁定，这阻止任何应用程序访问该文件。另一方面，像UNIX这样的操作系统使用建议性文件锁定，这意味着除非应用程序检查文件锁定，否则不会阻止它访问文件。
- en: Also, using marker files, the application server is able to solve a common issue
    related to large deployment files. If you've ever tried to deploy a large package
    unit (especially over a network), you might have experienced deployment errors
    because the deployment scanner starts deploying before the copy operation is completed,
    resulting in partially-completed deployments. Marker files are used by default
    for exploded deployments. They consist of empty files with a suffix, which are
    added either by the user or by the container to indicate the outcome of an operation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用标记文件，应用程序服务器能够解决与大型部署文件相关的一个常见问题。如果你曾经尝试部署一个大型包单元（尤其是在网络上），你可能已经经历过部署错误，因为部署扫描器在复制操作完成之前就开始部署，导致部署不完整。默认情况下，标记文件用于展开部署。它们由用户或容器添加的空文件组成，带有后缀，用于指示操作的成果。
- en: 'The most relevant marker file is `.dodeploy`, which triggers application redeployment.
    As a matter of fact, when we add an exploded deployment and the `auto-deploy-exploded`
    attribute is `false` in the deployment scanner configuration, the logs in the
    console warn us that the application is still not deployed, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最相关的标记文件是 `.dodeploy`，它触发应用程序重新部署。实际上，当我们添加一个展开的部署，并且部署扫描器配置中的 `auto-deploy-exploded`
    属性为 `false` 时，控制台日志会警告我们应用程序尚未部署，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Both Windows and Unix users can trigger deployment by simply running the following
    command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 和 Unix 用户可以通过简单地运行以下命令来触发部署：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you have started the deployment process, the application server replies
    with two possible outcomes. A deployed marker file (for example, `MyApp.war.deployed`)
    is placed in the `deployments` directory by the deployment scanner service to
    indicate that the given content has been deployed to the server, and your logs
    should confirm the outcome, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始部署过程，应用程序服务器会回复两种可能的结果。部署扫描器服务将部署标记文件（例如，`MyApp.war.deployed`）放置在 `deployments`
    目录中，以指示给定内容已部署到服务器，并且你的日志应该确认结果，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you remove the `.deployed` file, the application is undeployed, and an `.undeployed`
    marker file is added to the `deployments` folder (for example, `MyApp.war.undeployed`).
    If you try to remove the `.undeployed` file, the application is deployed again.
    This is a useful shortcut to quickly undeploy (or redeploy) the application without
    deleting it on the filesystem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除了 `.deployed` 文件，应用程序将被卸载，并在 `deployments` 文件夹中添加一个 `.undeployed` 标记文件（例如，`MyApp.war.undeployed`）。如果你尝试删除
    `.undeployed` 文件，应用程序将再次部署。这是一个有用的快捷方式，可以快速卸载（或重新部署）应用程序，而无需在文件系统中删除它。
- en: The other possible outcome is a deployment failure, which is indicated by a
    `.failed` marker. The content of the file includes some information about the
    cause of the failure; however, you should check the server logs for more detailed
    information regarding the cause of the error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的结果是部署失败，这由一个 `.failed` 标记来指示。文件内容包含一些关于失败原因的信息；然而，你应该检查服务器日志以获取有关错误原因的更详细信息。
- en: When using the autodeploy mode, you can remove the `.failed` marker file, which
    redeploys the application when the folder is rescanned by the deployment scanner.
    Additionally, the user can place the `.skipdeploy` marker file (for example, `MyApp.war.skipdeploy`),
    which disables `auto-deploy` of the content for as long as this marker file is
    present. Use this if you rely on automatic deployment and want to ensure that
    no deploy is triggered when updates are still incomplete.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自动部署模式时，你可以删除 `.failed` 标记文件，当部署扫描器重新扫描文件夹时，它将重新部署应用程序。此外，用户可以放置 `.skipdeploy`
    标记文件（例如，`MyApp.war.skipdeploy`），这将禁用内容在标记文件存在期间进行 `auto-deploy`。如果你依赖自动部署并希望确保在更新尚未完成时不会触发任何部署，请使用此功能。
- en: 'Let''s see a sample script, which can be used to perform a safe redeployment
    of a web application named `MyApp.war`, when using the Linux operating system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例脚本，该脚本可以在使用 Linux 操作系统时，安全地重新部署名为 `MyApp.war` 的网络应用程序：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Windows equivalent is defined as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 的等效定义如下：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the application server provides some additional temporary marker files,
    such as `.isdeploying`, `.isundeploying`, or `.pending`, that are placed by the
    deployment scanner to indicate the transition to the deployment or undeployment
    of a resource. Full details of marker files are provided in the `README.txt` file
    placed in the `deployments` folder of the server distribution. The following table
    displays a short summary of the available marker files used by the application
    server:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序服务器提供了一些额外的临时标记文件，如`.isdeploying`、`.isundeploying`或`.pending`，这些文件由部署扫描器放置，以指示资源部署或卸载的转换。有关标记文件的完整详细信息，请参阅放置在服务器分发`deployments`文件夹中的`README.txt`文件。以下表格显示了应用程序服务器使用的可用标记文件的简要总结：
- en: '| Marker | Created by | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 标记 | 创建者 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.dodeploy` | User | Creating this file triggers application deployment.
    Touching this file causes application redeployment. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `.dodeploy` | 用户 | 创建此文件将触发应用程序部署。触摸此文件将导致应用程序重新部署。|'
- en: '| `.skipdeploy` | User | Application autodeployment is disabled as long as
    this file exists. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `.skipdeploy` | 用户 | 只要此文件存在，应用程序的自动部署就被禁用。|'
- en: '| `.deployed` | WildFly | The application is deployed. Removing it causes undeployment
    of the application. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `.deployed` | WildFly | 应用程序已部署。移除它将导致应用程序卸载。|'
- en: '| `.undeployed` | WildFly | The application has been undeployed. Removing it
    causes redeployment of the application. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `.undeployed` | WildFly | 应用程序已被卸载。移除它将导致应用程序重新部署。|'
- en: '| `.failed` | WildFly | The application deployment has failed. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `.failed` | WildFly | 应用程序部署失败。|'
- en: '| `.isdeploying` | WildFly | The application deployment is in progress. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `.isdeploying` | WildFly | 应用程序部署正在进行中。|'
- en: '| `.isundeploying` | WildFly | The application undeployment is in progress.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `.isundeploying` | WildFly | 应用程序卸载正在进行中。|'
- en: '| `.pending` | WildFly | One condition is preventing application deployment
    (for example, file copying in progress). |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `.pending` | WildFly | 有一个条件阻止应用程序部署（例如，文件正在复制中）。|'
- en: Deploying applications on a WildFly domain
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WildFly域上部署应用程序
- en: 'Deploying applications on a WildFly domain is not as simple as deploying to
    a standalone server. There is no predefined `deployments` folder in the domain
    installation. The reason for this is that in the `domain` mode, there can be many
    servers belonging to different server groups, each one running different profiles.
    In this situation, a single `deployments` folder raises the obvious question:
    which server groups will use that folder?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在WildFly域上部署应用程序并不像在独立服务器上部署那样简单。域安装中没有预定义的`deployments`文件夹。这是因为，在`domain`模式下，可以有属于不同服务器组的多个服务器，每个服务器运行不同的配置文件。在这种情况下，一个单独的`deployments`文件夹会引发一个明显的问题：哪个服务器组将使用该文件夹？
- en: 'Next, we are going to look at the options available when deploying applications
    to a WildFly domain. These two options are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在WildFly域上部署应用程序时可用的一些选项。这两个选项如下：
- en: The **command-line interface** (**CLI**)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行界面**（CLI）'
- en: The admin web interface
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员Web界面
- en: Deploying to a domain using the CLI
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CLI部署到域
- en: 'Let''s see how to deploy an application using the CLI. Start by launching the
    CLI, and connect to the domain controller, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用命令行界面（CLI）部署应用程序。首先启动CLI，然后连接到域控制器，如下所示：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you deploy an application using the domain mode, you have to specify to
    which server group the deployment is associated. The CLI lets you choose between
    the following two options:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用域模式部署应用程序时，您必须指定部署关联的服务器组。CLI允许您在以下两个选项之间进行选择：
- en: Deploy to all server groups
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到所有服务器组
- en: Deploy to a single server group
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到单个服务器组
- en: Deploying to all server groups
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到所有服务器组
- en: 'When choosing the option to deploy to all server groups, the application is
    deployed to all the available server groups. The `--all-server-groups` flag can
    be used to deploy to all the available server groups. For example, use the following
    command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择将应用程序部署到所有服务器组的选项时，应用程序将被部署到所有可用的服务器组。可以使用`--all-server-groups`标志将应用程序部署到所有可用的服务器组。例如，使用以下命令：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If, on the other hand, you want to undeploy an application from all server
    groups belonging to a domain, you have to issue the `undeploy` command, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从属于域的所有服务器组中卸载应用程序，您必须发出`undeploy`命令，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You might have noticed that the `undeploy` command uses `--all-relevant-server-groups`
    instead of `--all-server-groups`. The reason for this difference is that the deployment
    may not be enabled on all server groups, so by using this option, you actually
    undeploy it just from all those server groups in which the deployment is enabled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`undeploy`命令使用`--all-relevant-server-groups`而不是`--all-server-groups`。这种差异的原因是部署可能并未在所有服务器组上启用，因此使用此选项实际上只是从所有那些已启用部署的服务器组卸载它。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Deploying an application as `disabled` can be useful if you have some startup
    beans (which are activated when the application is enabled) and you want to load
    them, but don't want to trigger their execution, for example, if the database
    or any other enterprise information system is temporarily unavailable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序作为`disabled`部署可能很有用，如果您有一些启动豆（当应用程序启用时被激活）并且您想加载它们，但又不想触发它们的执行，例如，如果数据库或其他企业信息系统暂时不可用。
- en: Deploying to a single server group
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到单个服务器组
- en: 'The option of deploying to a single server group lets you perform a selective
    deployment of your application just on the server groups you have indicated, as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单独部署到单个服务器组的选项允许您仅对您指定的服务器组执行选择性部署，如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You are not limited to a single server group. To deploy to multiple server
    groups, separate them with a comma, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您不受单个服务器组的限制。要部署到多个服务器组，请用逗号分隔它们，如下所示：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember, you can use the autocomplete functionality (the *Tab* key) to display
    the list of available `--server-groups`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以使用自动完成功能（*Tab*键）显示可用的`--server-groups`列表。
- en: 'Now, suppose we want to undeploy the application from just one server group.
    There can be two possible outcomes. If the application is available just on that
    server group, you successfully complete the undeployment:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们只想从单个服务器组中卸载应用程序。可能会有两种可能的结果。如果应用程序仅在该服务器组上可用，您将成功完成卸载：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On the other hand, if your application is available on other server groups,
    the following error is returned by the CLI:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您的应用程序在其他服务器组上可用，CLI将返回以下错误：
- en: '![Deploying to a single server group](img/6232OS_06_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![部署到单个服务器组](img/6232OS_06_08.jpg)'
- en: This error occurs because when you are removing an application from a server
    group, the domain controller verifies that the application is not referenced by
    any other server group. If it is, the `undeploy` command fails.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误发生是因为当您从服务器组中删除应用程序时，域控制器会验证应用程序是否未被任何其他服务器组引用。如果是，则`undeploy`命令将失败。
- en: 'If you wish to remove your application from a single server group, you need
    to issue the `-keep-content` argument. This causes the domain controller to undeploy
    the application from the server group while retaining the content:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望从单个服务器组中删除应用程序，您需要指定`-keep-content`参数。这将导致域控制器从服务器组卸载应用程序，同时保留内容：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have covered many of the available options to deploy applications to a domain.
    Before moving to the admin console, let''s review the CLI deployment options,
    as shown in the following table:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多将应用程序部署到域的可用选项。在转到管理控制台之前，让我们回顾以下表格中显示的CLI部署选项：
- en: '| Command | Options | Effect |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 选项 | 影响 |'
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `deploy` | `--all-server-groups` | This deploys an application to all server
    groups. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `deploy` | `--all-server-groups` | 将应用程序部署到所有服务器组。 |'
- en: '| `undeploy` | `--server-groups` | This deploys an application to one or more
    server groups. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `undeploy` | `--server-groups` | 将应用程序部署到一个或多个服务器组。 |'
- en: '| `undeploy` | `--all-relevant-server-groups` | This undeploys and removes
    an application from all server groups. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `undeploy` | `--all-relevant-server-groups` | 从所有服务器组卸载并删除应用程序。 |'
- en: '| `undeploy` | `--server-groups` | This undeploys an application from one server
    group. This fails if it''s referenced in another server group. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `undeploy` | `--server-groups` | 从一个服务器组卸载应用程序。如果它在另一个服务器组中被引用，则此操作将失败。 |'
- en: '| `undeploy` | `--server-groups -keep-content` | This undeploys an application
    from one server group without deleting it. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `undeploy` | `--server-groups -keep-content` | 从一个服务器组卸载应用程序而不删除它。 |'
- en: Deploying to a domain using the Admin console
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用管理控制台部署到域
- en: 'Deploying applications using the **Admin** console is pretty intuitive and
    requires just a few simple steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**管理**控制台部署应用程序非常直观，只需要几个简单的步骤：
- en: Start by logging in to the web application via the default address, `http://localhost:9990`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过默认地址`http://localhost:9990`登录到Web应用程序。
- en: Then, select the **Runtime** tab in the top menu and select **Manage Deployments**
    in the left-hand side panel of the screen, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_09.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在顶部菜单中选择**Runtime**标签页，并在屏幕左侧面板中选择**Manage Deployments**，如图所示：![使用管理员控制台部署到域名](img/6232OS_06_09.jpg)
- en: Before you can deploy your application to a server group, you need to upload
    it to the server, where it is stored in a content repository. To do this, click
    on **CONTENT REPOSITORY,** and then click on **Add**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您可以将应用程序部署到服务器组之前，您需要将其上传到服务器，在那里它被存储在内容仓库中。为此，点击**CONTENT REPOSITORY**，然后点击**Add**。
- en: 'This displays the following dialog, which allows you to upload your application:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下对话框，允许您上传您的应用程序：
- en: '![Deploying to a domain using the Admin console](img/6232OS_06_10.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用管理员控制台部署到域名](img/6232OS_06_10.jpg)'
- en: Once you are finished with the upload wizard, the application is uploaded to
    the domain repository. In order to deploy/undeploy it to the single server groups,
    you need to select the **SERVER GROUPS** tab, and then click on the **View** button
    on the server group you wish to deploy to, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_11.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上传向导后，应用程序将被上传到域名仓库。为了将其部署/取消部署到单个服务器组，您需要选择**SERVER GROUPS**标签页，然后点击您希望部署到的服务器组上的**View**按钮，如图所示：![使用管理员控制台部署到域名](img/6232OS_06_11.jpg)
- en: The next screen shows you all the deployments for this server group. Now, click
    on the **Assign** button. This allows you to select from the applications that
    are currently stored within the content repository. Select the checkbox for your
    application and then click on **Save**, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_12.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏显示了此服务器组的所有部署。现在，点击**Assign**按钮。这允许您从内容仓库中当前存储的应用程序中选择。勾选您的应用程序的复选框，然后点击**Save**，如图所示：![使用管理员控制台部署到域名](img/6232OS_06_12.jpg)
- en: At this point, the application is deployed but still not enabled. Choose the
    **En/Disable** button to complete the deployment of the application, as shown
    in the following screenshot:![Deploying to a domain using the Admin console](img/6232OS_06_13.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，应用程序已部署但尚未启用。选择**En/Disable**按钮以完成应用程序的部署，如图所示：![使用管理员控制台部署到域名](img/6232OS_06_13.jpg)
- en: Clicking on the **Remove** button within the **SERVER GROUPS** tab removes the
    deployment from the server group selected, while the other **Remove** button within
    the **CONTENT** **REPOSITORY** tab actually deletes the deployment from the temporary
    domain repository where uploaded applications are bundled.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在**SERVER GROUPS**标签页中点击**Remove**按钮会从所选的服务器组中移除部署，而**CONTENT** **REPOSITORY**标签页中的另一个**Remove**按钮实际上会从临时域名仓库中删除部署，该仓库用于打包上传的应用程序。
- en: Explaining WildFly classloading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释WildFly类加载
- en: There are two approaches to managing dependencies, the first being the **Class-Path**
    approach and the second, the **Dependencies** approach. We will cover both of
    these topics in this section, but before we do, let's take a look at the history
    of classloading in WildFly in order to understand why classloading works the way
    it does. As mandated by the Java EE specification, an application server needs
    to provide an environment where any deployed application can access any class,
    or library of classes, of a particular version.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖关系有两种方法，第一种是**Class-Path**方法，第二种是**Dependencies**方法。在本节中，我们将介绍这两个主题，但在我们这样做之前，让我们看看WildFly中类加载的历史，以便了解为什么类加载以这种方式工作。根据Java
    EE规范的要求，应用程序服务器需要提供一个环境，其中任何已部署的应用程序都可以访问特定版本的任何类或类库。
- en: This is also known as **Class Namespace Isolation** (Java EE 5 specification,
    section EE.8.4). However, loading classes from different namespaces can raise
    some issues that are not easy to solve. For example, what happens if you pack
    a newer version of a utility library with your application, while an older version
    of the same library was loaded by the application server? Or, how do you simultaneously
    use two different versions of the same utility library within the same instance
    of the application server?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为**类命名空间隔离**（Java EE 5规范，第EE.8.4节）。然而，从不同的命名空间加载类可能会引发一些不易解决的问题。例如，如果你将一个实用库的新版本打包到你的应用程序中，而应用程序服务器已经加载了该库的旧版本，会发生什么？或者，你如何在同一个应用程序服务器的同一个实例中同时使用同一实用库的两个不同版本？
- en: The JBoss AS classloading strategy has changed sensibly through the years. The
    4.x releases of the application server used `UnifiedClassLoader`, which aimed
    to reduce communications overhead between running applications, as class data
    could be shared by reference or simple copies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss AS的类加载策略在多年中已经合理地发生了变化。应用程序服务器的4.x版本使用了`UnifiedClassLoader`，旨在减少运行应用程序之间的通信开销，因为类数据可以通过引用或简单的复制共享。
- en: One of the major issues not resolved with `UnifiedClassLoader` is **classloading
    dependencies**. The idea is that if one application (A) uses the classes of another
    application (B), the system should know how to redeploy A when B gets redeployed;
    otherwise, it references stale classes. There were actually two different attempts
    to try to make this work without the user having to configure anything. Neither
    attempt really worked and both were dropped.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UnifiedClassLoader`未能解决的问题之一是**类加载依赖**。其理念是，如果一个应用程序（A）使用了另一个应用程序（B）的类，当B被重新部署时，系统应该知道如何重新部署A；否则，它将引用过时的类。实际上，曾有两个不同的尝试试图在不让用户进行任何配置的情况下使这一机制工作。但这两个尝试都没有真正成功，并且都被放弃了。
- en: With JBoss AS 5.0, a new classloader was based on the new **Virtual File System**
    (**VFS**). The VFS was implemented to simplify and unify file handling within
    the application server. The new classloader, named the VFS classloader, uses VFS
    to locate JAR and class files. Even though this represented a significant change
    in how classes were loaded in JBoss AS 5.0, the resulting behavior is much the
    same as that of prior versions of JBoss AS.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在JBoss AS 5.0中，一个新的类加载器基于新的**虚拟文件系统**（**VFS**）。VFS被实现以简化并统一应用程序服务器内的文件处理。新的类加载器，命名为VFS类加载器，使用VFS来定位JAR和类文件。尽管这代表了JBoss
    AS 5.0中类加载方式的重大变化，但最终的行为与之前版本的JBoss AS非常相似。
- en: A common source of errors was including API classes in a deployment that was
    also provided by the container. This could result in multiple versions of the
    class being created and the deployment failing to deploy properly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误来源是将API类包含在由容器也提供的部署中。这可能导致创建多个版本的类，并且部署无法正确部署。
- en: Since JBoss AS 7, classloading marks a radical departure from previous attempts.
    Classloading is now based on the JBoss modules project, and any application that
    is deployed is, in effect, a module. This fact may raise some questions, such
    as what module name is to be assigned to a deployed application, and how dependencies
    between modules are handled by the application server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JBoss AS 7以来，类加载标志着与之前尝试的彻底转变。类加载现在基于JBoss模块项目，任何部署的应用程序实际上都是一个模块。这一事实可能会引发一些问题，例如，应该分配什么模块名称给部署的应用程序，以及应用程序服务器如何处理模块之间的依赖关系。
- en: These questions will be answered in the next few sections.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题将在接下来的几节中得到解答。
- en: Getting to know module names
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解模块名称
- en: Getting to know module names is not an academic exercise. We can even go so
    far as establishing dependencies between modules. So, in many cases, you need
    to know how module names are assigned to an application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 了解模块名称并非是一项学术练习。我们甚至可以进一步建立模块之间的依赖关系。因此，在许多情况下，你需要知道模块名称是如何分配给应用程序的。
- en: 'Applications that are packaged as top-level archives (such as WAR, JAR, and
    SAR) are assigned the following module name:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 被打包为顶级归档（如WAR、JAR和SAR）的应用程序被分配以下模块名称：
- en: '`deployment.[archive name]`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.[归档名称]`'
- en: 'For example, a web application named `WebExample1.war` is deployed with the
    following module name:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个名为`WebExample1.war`的Web应用程序使用以下模块名称进行部署：
- en: '`deployment.WebExample1.war`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.WebExample1.war`'
- en: 'On the other hand, for applications that contain nested modules (such as EAR),
    each archive is assigned a module name using the following convention:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于包含嵌套模块的应用程序（如 EAR），每个存档都使用以下约定分配一个模块名称：
- en: '`deployment.[ear archive name].[sub deployment archive name]`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.[ear archive name].[sub deployment archive name]`'
- en: 'So, for example, the preceding web archive, if contained in an EAR file called
    `EnterpriseApp.ear`, would be deployed with the following name:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，前面的 Web 归档，如果包含在名为 `EnterpriseApp.ear` 的 EAR 文件中，将使用以下名称进行部署：
- en: '`deployment.EnterpriseApp.ear.WebExample1.war`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.EnterpriseApp.ear.WebExample1.war`'
- en: Finding the isolation level
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找隔离级别
- en: A general rule in WildFly 8 is that every deployed application module is isolated
    from other modules, that is, by default, the application does not have visibility
    on the AS modules, nor do the AS modules have visibility on the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WildFly 8 中，一个通用规则是每个部署的应用程序模块都与其他模块隔离，也就是说，默认情况下，应用程序无法看到 AS 模块，AS 模块也无法看到应用程序。
- en: 'Using the application server modules is relatively easy and can be summarized
    in a single sentence: add a dependency to the required module and the AS will
    use it. Some dependencies are automatically added to the application server, while
    others need to be signaled by the user:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用服务器模块相对简单，可以总结为一句：向所需模块添加依赖项，AS 将会使用它。一些依赖项会自动添加到应用服务器中，而其他依赖项则需要用户进行标记：
- en: The core module libraries (namely, the `Enterprise` classes) are qualified as
    implicit dependencies, so they are automatically added to your application when
    the deployer detects their usage
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心模块库（即，`Enterprise` 类）被视为隐式依赖项，因此当部署者检测到它们的用法时，它们会自动添加到您的应用程序中
- en: Other module libraries need to be explicitly declared by the user in the application's
    `MANIFEST` file or in a custom JBoss deployment file named `jboss-deployment-structure.xml`
    (more about this file in the *Advanced deployment strategies* section)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模块库需要用户在应用程序的 `MANIFEST` 文件中或在一个名为 `jboss-deployment-structure.xml` 的自定义 JBoss
    部署文件中显式声明（关于此文件的更多信息，请参阅 *高级部署策略* 部分）
- en: Implicit dependencies
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式依赖项
- en: Repeatedly declaring commonly used dependencies for your enterprise application
    becomes very tedious. This is why the core modules are automatically added for
    you by the application server. Some of these core modules are only added when
    the application server detects annotations or configuration files for a particular
    technology. For example, adding a `beans.xml` file automatically triggers the
    **Weld** dependency (Weld is the Contexts and Dependency injection implementation
    used in WildFly).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重复声明企业应用程序中常用的依赖项变得非常繁琐。这就是为什么应用程序服务器会自动为您添加核心模块。其中一些核心模块仅在应用程序服务器检测到特定技术的注解或配置文件时才添加。例如，添加
    `beans.xml` 文件会自动触发 **Weld** 依赖项（Weld 是 WildFly 中使用的上下文和依赖注入实现）。
- en: 'The following table outlines the modules that are implicitly added to your
    application:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下表概述了自动添加到您的应用程序中的模块：
- en: '| Subsystem | Automatic dependencies | Triggered dependencies | Trigger condition
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 子系统 | 自动依赖项 | 触发依赖项 | 触发条件 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Core server | `javax.api``sun.jdk``org.jboss.vfs` |   |   |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 核心服务器 | `javax.api` `sun.jdk` `org.jboss.vfs` |   |   |'
- en: '| EE | `javaee.api` |   |   |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| EE | `javaee.api` |   |   |'
- en: '| EJB3 |   | `javaee.api` | Presence of `ejb-jar.xml` or EJB annotations |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| EJB3 |   | `javaee.api` | 存在 `ejb-jar.xml` 或 EJB 注解 |'
- en: '| JAX-RS | `javax.xml.bind.api` | `org.jboss.resteasy` | Presence of JAX-RS
    annotations |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| JAX-RS | `javax.xml.bind.api` | `org.jboss.resteasy` | 存在 JAX-RS 注解 |'
- en: '| JPA | `javax.persistence` | `javaee.api``org.jboss.as.jpa``org.hibernate`
    | Presence of `@PersistenceUnit` or `@PersistenceContext` or equivalent XML |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| JPA | `javax.persistence` | `javaee.api` `org.jboss.as.jpa` `org.hibernate`
    | 存在 `@PersistenceUnit` 或 `@PersistenceContext` 或等效 XML |'
- en: '| Logging | `org.jboss.logging``org.apache.commons.logging``org.apache.log4j``org.slf4j`
    |   |   |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 日志记录 | `org.jboss.logging` `org.apache.commons.logging` `org.apache.log4j`
    `org.slf4j` |   |   |'
- en: '| Security | `org.picketbox` |   |   |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | `org.picketbox` |   |   |'
- en: '| Web |   | `javaee.api``com.sun.jsf-impl``org.hibernate.validator``org.jboss.as.web``org.jboss.logging`
    | Deployment of WEB archive; JSF added if used |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Web |   | `javaee.api` `com.sun.jsf-impl` `org.hibernate.validator` `org.jboss.as.web`
    `org.jboss.logging` | 部署 WEB 归档；如果使用，则添加 JSF |'
- en: '| Web services | `org.jboss.ws.api``org.jboss.ws.spi` |   |   |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Web 服务 | `org.jboss.ws.api` `org.jboss.ws.spi` |   |   |'
- en: '| Weld |   | `javax.persistence.api``javaee.api``org.javassist``org.jboss.interceptor``org.jboss.as.weld``org.jboss.logging``org.jboss.weld.core``org.jboss.weld.api``org.jboss.weld.spi`
    | Presence of `beans.xml` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 焊接 |   | `javax.persistence.api` `javaee.api` `org.javassist` `org.jboss.interceptor`
    `org.jboss.as.weld` `org.jboss.logging` `org.jboss.weld.core` `org.jboss.weld.api`
    `org.jboss.weld.spi` | `beans.xml` 文件的存在 |'
- en: If your application uses any of the core modules indicated, then you don't need
    to specify its dependency, as the application server links the module automatically.
    If you are using Maven, then you can mark these dependencies as provided.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用了所指示的任何核心模块，那么你不需要指定其依赖项，因为应用程序服务器会自动链接该模块。如果你使用 Maven，则可以将这些依赖项标记为提供。
- en: Explicit dependencies
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式依赖项
- en: 'Modules that are not qualified as implicit dependencies need to be declared
    by the user. Let''s say you want to use the log4j library, which is bundled in
    the application server distribution. The simplest and recommended approach to
    achieve this is by including the `Dependencies: [module]` declaration within `META-INF/MANIFEST.MF`.
    The following example code for the chapter uses Maven to populate the `MANIFEST.MF`
    file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '需要由用户声明的模块不是隐式依赖项。假设你想使用打包在应用程序服务器发行版中的 log4j 库。实现这一点的最简单和推荐的方法是在 `META-INF/MANIFEST.MF`
    中包含 `Dependencies: [module]` 声明。本章的示例代码使用 Maven 来填充 `MANIFEST.MF` 文件：'
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This has the result of adding the following to your `MANIFEST.MF` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致在您的 `MANIFEST.MF` 文件中添加以下内容：
- en: '![Explicit dependencies](img/6232OS_06_14.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![显式依赖关系](img/6232OS_06_14.jpg)'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the module name does not always match the package name of the
    library. The actual module name is specified in the `module.xml` file by the `name`
    attribute of the `module` element.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模块名称不一定与库的包名称匹配。实际的模块名称由 `module.xml` 文件中 `module` 元素的 `name` 属性指定。
- en: 'You are not limited to a single dependency, as you can add multiple dependencies
    separated by a comma. For example, in order to add a dependency on both log4j
    and Apache Velocity API, use the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你不受单个依赖项的限制，因为你可以通过逗号分隔添加多个依赖项。例如，为了添加对 log4j 和 Apache Velocity API 的依赖项，请使用以下命令：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even export the dependencies used by one application module to other
    applications by adding the `export` keyword. For example, in addition to the earlier
    example, we''re now exporting the dependencies to other modules, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过添加 `export` 关键字将一个应用程序模块使用的依赖项导出到其他应用程序。例如，除了前面的示例之外，我们现在将依赖项导出到其他模块，如下所示：
- en: '![Explicit dependencies](img/6232OS_06_15.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![显式依赖关系](img/6232OS_06_15.jpg)'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `export` parameter can also be used to export a dependency to all subdeployments
    contained in the EAR. Consequently, if you export a dependency from the top-level
    of the EAR (or by a JAR in the `ear/lib` directory), then the dependency is also
    available to all subdeployment units.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `export` 参数将依赖项导出到 EAR 中包含的所有子部署。因此，如果你从 EAR 的顶层（或 `ear/lib` 目录中的 JAR）导出依赖项，则该依赖项也对所有子部署单元可用。
- en: 'Applications that are marked as dependent to the `deployment.WebApp1.war` module
    also have access to its dependencies:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为依赖于 `deployment.WebApp1.war` 模块的应用程序也可以访问其依赖项：
- en: '![Explicit dependencies](img/6232OS_06_16.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![显式依赖关系](img/6232OS_06_16.jpg)'
- en: Within `META-INF/MANIFEST.MF`, you can also specify additional commands that
    can modify the server deployer's behavior. For example, the `optional` attribute
    can be added to specify that the deployment does not fail if the module is not
    found at the deployment time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `META-INF/MANIFEST.MF` 中，你也可以指定可以修改服务器部署者行为的附加命令。例如，可以添加 `optional` 属性来指定如果模块在部署时未找到，则部署不会失败。
- en: Finally, when the `services` keyword is specified, the deployer tries to load
    services that are placed within the `META-INF/services` directory of the archive.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当指定 `services` 关键字时，部署者会尝试加载存放在存档的 `META-INF/services` 目录中的服务。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `service` API has become `public` in Java SE 6\. A **service** can be defined
    as a set of programming interfaces and classes that provide access to some specific
    application functionality or feature. A **Service Provider Interface** (**SPI**)
    is the set of `public` interfaces and `abstract` classes that a service defines.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java SE 6 中，`service` API 已变为 `public`。**服务**可以定义为一组编程接口和类，它们提供对某些特定应用程序功能或特性的访问。**服务提供者接口**（**SPI**）是服务定义的
    `public` 接口和 `abstract` 类的集合。
- en: You can define a service provider by implementing the service provider API.
    Usually, you create a JAR file to hold your provider. To register your provider,
    you must create a provider configuration file in the JAR file's `META-INF/services`
    directory. When adding the `services` attribute to your `META-INF/MANIFEST.MF`
    file, you are actually able to load the services contained in the `META-INF/services`
    directory.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实现服务提供者API来定义服务提供者。通常，您创建一个JAR文件来存放您的提供者。要注册您的提供者，您必须在JAR文件的`META-INF/services`目录中创建一个提供者配置文件。当您将`services`属性添加到您的`META-INF/MANIFEST.MF`文件中时，您实际上能够加载`META-INF/services`目录中包含的服务。
- en: One excellent introduction to the SPI API is available at [http://www.oracle.com/technetwork/articles/javase/extensible-137159.html](http://www.oracle.com/technetwork/articles/javase/extensible-137159.html).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于SPI API的优秀介绍可以在[这里](http://www.oracle.com/technetwork/articles/javase/extensible-137159.html)找到。
- en: Setting up global modules
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置全局模块
- en: Setting up global modules resembles the old AS approach to loading common libraries,
    where you used to place them in the `lib` folder under `JBOSS_HOME/common`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 设置全局模块类似于旧AS加载常用库的方法，您过去通常将它们放在`JBOSS_HOME/common`下的`lib`文件夹中。
- en: 'If you define a section named `global-modules` within `standalone.xml/domain.xml`,
    then you make the module accessible to other AS modules. For example, instead
    of declaring a dependency on log4j, you can alternatively use the following section:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`standalone.xml/domain.xml`中定义了一个名为`global-modules`的部分，那么您使该模块对其他AS模块可访问。例如，您可以使用以下部分而不是声明对log4j的依赖：[log4j依赖激活](https://wiki.example.org/log4j_dependency_activation)
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although this approach is not generally recommended, as it brings us back to
    the concept of a monolithic application server, it can still yield some benefits,
    for example, when you migrate some older applications, and also when you don't
    want or simply cannot specify dependencies to the archive.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法通常不推荐，因为它使我们回到了单体应用程序服务器的概念，但它仍然可以带来一些好处，例如在迁移一些较老的应用程序时，以及当您不想或无法指定存档的依赖项时。
- en: Advanced deployment strategies
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级部署策略
- en: 'The topics covered so far are sufficient for the vast majority of applications.
    If you are using a complex archive configuration, such as an EAR archive with
    several modules and dependencies, it might be useful to define your classloading
    strategy in a single file. The configuration file, `jboss-deployment-structure.xml`,
    does exactly this. Some of the advantages of using this file are outlined as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止涵盖的主题对于绝大多数应用程序来说已经足够了。如果您使用的是复杂的存档配置，例如包含多个模块和依赖项的EAR存档，那么在单个文件中定义您的类加载策略可能很有用。配置文件`jboss-deployment-structure.xml`正是这样做的。使用此文件的一些优点如下：
- en: You can define the dependencies of all application modules in a single file
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在单个文件中定义所有应用程序模块的依赖项
- en: You can load the module classes in a fine-grained manner by including/excluding
    all or some parts of modules
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过包含/排除所有或部分模块的所有部分以细粒度方式加载模块类
- en: You can define the classloading isolation policy for your applications packaged
    in an enterprise archive
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为打包在企业存档中的应用程序定义类加载隔离策略
- en: Let's see what `jboss-deployment-structure.xml` can do for you by taking a look
    at some practical examples.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些实际示例来看看`jboss-deployment-structure.xml`能为您做什么。
- en: Setting up a single module dependency
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置单个模块依赖
- en: We have already learned how to activate a `log4j` dependency using the `Dependencies`
    attribute in the archive's `MANIFEST` file. The same effect can be achieved using
    the `jboss-deployment-structure.xml` file. Let's recap the archive structure,
    which is basically made up of a web application named `WebApp.war`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用存档的`MANIFEST`文件中的`Dependencies`属性激活`log4j`依赖。使用`jboss-deployment-structure.xml`文件也可以达到相同的效果。让我们回顾一下存档结构，它基本上由一个名为`WebApp.war`的Web应用程序组成。
- en: 'As you can see in the following diagram, the `jboss-deployment-structure.xml`
    file needs to be placed within the `META-INF` folder of the EAR:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，`jboss-deployment-structure.xml`文件需要放置在EAR的`META-INF`文件夹中：
- en: '![Setting up a single module dependency](img/6232OS_06_17.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![设置单个模块依赖](img/6232OS_06_17.jpg)'
- en: 'The following is the content of `jboss-deployment-structure.xml`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`jboss-deployment-structure.xml`的内容：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `jboss-deployment-structure` file is not for the exclusive use of EARs and
    can be used within a WAR archive by placing it within the `WEB-INF` folder. It
    is, however, applicable only as a top-level archive. Thus, if a `jboss-deployment-structure.xml`
    file is placed in the WAR's `WEB-INF` folder and the WAR is packaged in an EAR
    file, then the `jboss-deployment-structure.xml` file is ignored. The relevant
    part of this file is the subdeployment element, which references the web application,
    including the `dependencies` element. The expected outcome is that the application
    server triggers the dependency to the Log4J API, which is, therefore, visible
    by our web application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`jboss-deployment-structure`文件不仅限于用于EAR，还可以通过将其放置在`WEB-INF`文件夹中来在WAR存档中使用。然而，它仅适用于顶级存档。因此，如果将`jboss-deployment-structure.xml`文件放置在WAR的`WEB-INF`文件夹中，并且WAR被打包在EAR文件中，那么`jboss-deployment-structure.xml`文件将被忽略。该文件的相关部分是子部署元素，它引用了Web应用程序，包括`dependencies`元素。预期的结果是应用程序服务器触发对Log4J
    API的依赖，因此它对我们Web应用程序是可见的。'
- en: Excluding the server's automatic dependencies
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排除服务器的自动依赖项
- en: Earlier in this chapter, we discussed how the application server can automatically
    trigger dependencies when certain conditions are met. For example, if you deploy
    a JSF application (containing the `faces-config.xml` file), then the JSF 2.2 API
    implementation is automatically added.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们讨论了当满足某些条件时，应用程序服务器可以自动触发依赖项。例如，如果你部署了一个JSF应用程序（包含`faces-config.xml`文件），那么JSF
    2.2 API实现将自动添加。
- en: 'This might not always be the desired option, as you may want to provide another
    release implementation for that module. You can easily achieve this using the
    `exclusion` element in the `jboss-deployment-structure.xml` file, as shown in
    the following code snippet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是始终是期望的选项，因为你可能希望为该模块提供另一个发布实现。你可以通过在`jboss-deployment-structure.xml`文件中使用`exclusion`元素轻松实现这一点，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that in the `dependencies` section, we added our alternate JSF 2.1 implementation,
    which is used by your application. You need to install these two modules shown
    in the preceding code, as explained in [Chapter 2](ch02.html "Chapter 2. Configuring
    the Core WildFly Subsystems"), *Configuring the Core WildFly Subsystems*. They
    can be placed alongside the implementations provided by WildFly by creating a
    folder named `2.1`. The new folder for the JSF 2.1 archive is highlighted in bold
    in the following command lines:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`dependencies`部分，我们添加了我们的替代JSF 2.1实现，这是由你的应用程序使用的。你需要安装前面代码中显示的这两个模块，如[第2章](ch02.html
    "第2章。配置WildFly核心子系统")中所述，*配置WildFly核心子系统*。它们可以通过创建一个名为`2.1`的文件夹与WildFly提供的实现并排放置。以下命令行中突出显示了JSF
    2.1存档的新文件夹，加粗显示：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You also need to add the `slot` attribute to the `module.xml` file, as highlighted
    in the following code snippet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将`slot`属性添加到`module.xml`文件中，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Isolating sub-deployments
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离子部署
- en: 'Considering that you have an EAR application that is made up of a web application,
    an EJB module, and a JAR file containing utility classes, all subdeployments are
    placed at the root of the archive so that they can see each other. However, let''s
    suppose your web application contains some implementations of the same EJB. That''s
    absolutely possible since Java EE allows your web application to include EJB classes
    within the `WEB-INF/classes` or `WEB-INF/lib` folder, as the following diagram
    depicts:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你有一个由Web应用程序、EJB模块和包含实用类JAR文件组成的EAR应用程序，所有子部署都放置在存档的根目录，以便它们可以相互看到。但是，假设你的Web应用程序包含一些相同的EJB实现。这是绝对可能的，因为Java
    EE允许你的Web应用程序在`WEB-INF/classes`或`WEB-INF/lib`文件夹中包含EJB类，如下面的图所示：
- en: '![Isolating sub-deployments](img/6232OS_06_18.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![隔离子部署](img/6232OS_06_18.jpg)'
- en: 'How does the classloader resolve this conflict? The application server classloader
    has a priority list when loading classes, thus reducing any conflict between loaded
    classes, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器是如何解决这个冲突的呢？应用程序服务器类加载器在加载类时有一个优先级列表，因此可以减少加载类之间的任何冲突，如下所示：
- en: The highest priority is automatically given to modules by the container, including
    the Java EE APIs. Libraries contained in the `modules` folder are included in
    this category.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器自动将最高优先级赋予模块，包括Java EE API。包含在`modules`文件夹中的库属于这一类别。
- en: The next priority goes to libraries that are indicated by the user within `MANIFEST.MF`
    of the packaged archive as dependencies (or in the `jboss-deployment-structure.xml`
    file).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个优先级是给那些在打包归档的 `MANIFEST.MF` 文件中指定为依赖项（或在 `jboss-deployment-structure.xml`
    文件中）的库。
- en: The penultimate priority is given to libraries that are packed within the application
    itself, such as classes contained in `WEB-INF/lib` or `WEB-INF/classes`.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一优先级是给那些打包在应用程序本身的库，例如 `WEB-INF/lib` 或 `WEB-INF/classes` 中包含的类。
- en: Finally, the last priority goes to libraries that are packed within the same
    EAR archive (in the EAR's `lib` folder).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最低优先级是给那些打包在同一 EAR 归档内的库（位于 EAR 的 `lib` 文件夹中）。
- en: 'So, in this example, the EJB libraries located in the `WEB-INF` folder hides
    the implementations of `EJB.jar` top-level deployment. If this is not the desired
    result, you can simply override it, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，位于 `WEB-INF` 文件夹中的 EJB 库隐藏了 `EJB.jar` 顶级部署的实现。如果这不是你想要的结果，你可以简单地覆盖它，如下所示：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, we added a dependency to the `EJB.jar` deployment,
    which is placed at the root of the EAR and which overrides the implementation
    packed within the web application.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了对 `EJB.jar` 部署的依赖，该部署位于 EAR 的根目录，并覆盖了在 Web 应用程序中打包的实现。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the `ear-subdeployments-isolated` element placed at the top of the file.
    By setting the EAR isolation level, you will be able to indicate if the subdeployment
    modules are visible to each other.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件顶部的 `ear-subdeployments-isolated` 元素。通过设置 EAR 隔离级别，你将能够指示子部署模块是否彼此可见。
- en: The default value of the `ear-subdeployments-isolated` element is `false`, which
    means that the subdeployment modules can see each other. If you are setting isolation
    to `true`, each module is then picked up by a different classloader, which means
    that the web application is unable to find the classes contained in the `EJB.jar`
    and `Utility.jar` libraries).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ear-subdeployments-isolated` 元素的默认值是 `false`，这意味着子部署模块可以彼此看到。如果你将隔离设置为 `true`，那么每个模块将由不同的类加载器加载，这意味着
    Web 应用程序将无法找到 `EJB.jar` 和 `Utility.jar` 库中包含的类）。'
- en: 'If you want to keep the deployment isolated but allow visibility between some
    of your dependencies, then you have two choices available:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要保持部署隔离但允许某些依赖项之间的可见性，那么你有两个选择可用：
- en: Move the library to the `EAR/lib` folder so that it is picked up as a separate
    module
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库移动到 `EAR/lib` 文件夹，以便它作为一个单独的模块被选中
- en: Specify a dependency using Dependencies or Class-Path in the `MANIFEST.MF` file
    of the calling application
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用应用的 `MANIFEST.MF` 文件中使用 Dependencies 或 Class-Path 指定依赖
- en: 'In the following diagram, you can see how to correctly set up your EAR, by
    placing common libraries in the `lib` folder and adding a dependency to the EJB
    classes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到如何正确设置你的 EAR，通过将公共库放在 `lib` 文件夹中，并添加对 EJB 类的依赖：
- en: '![Isolating sub-deployments](img/6232OS_06_19.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![隔离子部署](img/6232OS_06_19.jpg)'
- en: 'The following is the corresponding configuration required in `jboss-deployment-structure.xml`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `jboss-deployment-structure.xml` 中所需的相应配置：
- en: '[PRE34]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Packaging libraries in a shared library within your EAR is an option. With
    Java EE 5 onward, it has been possible to place these files in a shared library
    folder called `lib`. You can override this default folder name using the `library-directory`
    element in the `META-INF/application.xml` file. For example, suppose you want
    to use the `common` folder to hold your shared libraries, in which case you can
    add the following line to your `application.xml`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 EAR 中将库打包成共享库是一个选项。从 Java EE 5 开始，可以将这些文件放置在名为 `lib` 的共享库文件夹中。你可以使用 `META-INF/application.xml`
    文件中的 `library-directory` 元素来覆盖默认文件夹名称。例如，假设你想使用 `common` 文件夹来存放你的共享库，在这种情况下，你可以在你的
    `application.xml` 中添加以下行：
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As a side note, you should avoid placing component-declaring annotations (such
    as EJB3) in the shared folder, as it can have unintended consequences on the deployment
    process. For this reason, it is strongly recommended that you place your utility
    classes in the shared library folder.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，你应该避免在共享文件夹中放置组件声明注解（如 EJB3），因为它可能会对部署过程产生意外的后果。因此，强烈建议你将你的实用类放在共享库文件夹中。
- en: Using the Class-Path declaration to solve dependencies
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Class-Path 声明解决依赖
- en: Until now, we have configured dependencies between modules using the JBoss way,
    which is the recommended choice. Nevertheless, we should also account for Java's
    portable way to reference one or more libraries included in the EAR file. This
    can be achieved by adding the `Class-Path` attribute to the `MANIFEST.MF` file.
    This allows a module to reference another library that is not otherwise visible
    to the application (think back to the earlier example of a deployment unit with
    the isolation set to `true`).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用JBoss方式配置了模块之间的依赖关系，这是推荐的选择。尽管如此，我们也应该考虑到Java的可移植方式来引用包含在EAR文件中的一个或多个库。这可以通过向`MANIFEST.MF`文件添加`Class-Path`属性来实现。这允许一个模块引用另一个对应用程序不可见的库（回想一下之前示例中的部署单元，其隔离设置为`true`）。
- en: 'For example, considering that you need to reference the `Utility.jar` application
    from within your web application, you can simply add the following to your `META-INF/MANIFEST.MF`
    file directly inside your EAR:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑到你需要从你的Web应用程序中引用`Utility.jar`应用程序，你只需直接在你的EAR文件中的`META-INF/MANIFEST.MF`文件中添加以下内容即可：
- en: '[PRE36]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can actually include more than one library to the `Class-Path` attribute,
    separating them by a comma.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以将多个库包含到`Class-Path`属性中，通过逗号分隔它们。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike the `Dependencies` attribute, the `Class-Path` attribute points to the
    actual JAR filename (and not the module name) to reference the dependent libraries.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Dependencies`属性不同，`Class-Path`属性指向实际的JAR文件名（而不是模块名称），以引用依赖库。
- en: 'Choosing between the Class-Path approach and JBoss''s Dependencies approach
    depends on how your application is structured: using JBoss''s Dependencies approach
    buys you a richer set of options, in particular, the ability to export the dependencies
    to other deployments, as we have illustrated earlier. One more point in favor
    of JBoss''s Dependencies approach is the ability to reference modules that are
    not actually packaged within the application.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择类路径方法与JBoss依赖方法之间取决于你的应用程序结构：使用JBoss依赖方法为你提供更丰富的选项，特别是能够将依赖项导出到其他部署中，正如我们之前所展示的。支持JBoss依赖方法的一个额外点是能够引用实际上未打包在应用程序内的模块。
- en: On the other hand, the main advantage of the Class-Path approach relies on application
    portability. Thus, if a fully portable solution is a priority for you, you can
    consider switching to the `Class-Path` manifest attribute.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类路径方法的主要优势在于应用程序的可移植性。因此，如果你将完全可移植的解决方案作为优先考虑，你可以考虑切换到`Class-Path`清单属性。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a wide variety of functionalities related to the
    deployment of applications. Applications are deployed differently, depending on
    whether they are deployed to a standalone server or to a domain of servers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了与应用程序部署相关的各种功能。应用程序的部署方式不同，这取决于它们是部署到独立服务器还是服务器域。
- en: As far as standalone servers are concerned, an application can be deployed either
    automatically or manually. By default, packaged archives are deployed automatically.
    This means that all you need to do is place the archive within the `standalone`/`deployments`
    folder of the application server. Applications that are deployed manually (by
    default, exploded archives) need marker files to activate the deployment.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就独立服务器而言，应用程序可以自动或手动部署。默认情况下，打包的存档会自动部署。这意味着你所需做的只是将存档放置在应用程序服务器的`standalone`/`deployments`文件夹中。手动部署的应用程序（默认情况下为展开的存档）需要标记文件来激活部署。
- en: As far as domain servers are concerned, since the application server cannot
    determine which server group you want to target the deployment to, you need to
    specify this information when using either the command-line interface or the web
    admin interface.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 就域服务器而言，由于应用程序服务器无法确定你希望将部署指向哪个服务器组，因此在使用命令行界面或Web管理界面时，你需要指定此信息。
- en: One of the great advantages of using a domain of servers is the ability to deploy
    applications on single or multiple server groups, which can even be created and
    equipped at runtime.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器域的一个巨大优势是能够在单个或多个服务器组上部署应用程序，这些服务器组甚至可以在运行时创建和配置。
- en: In the later part of this chapter, we covered the classloading mechanism used
    by the application server. Every application deployed to WildFly is treated as
    a module, all of which are isolated from other modules contained in the application
    server distribution. Modules representing Java EE API classes are implicitly added
    to your application's classpath as dependencies, which means that you don't need
    any special configuration to deploy a Java EE application.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们介绍了应用服务器使用的类加载机制。部署到WildFly的每个应用都被视为一个模块，所有这些模块都与应用服务器分发中的其他模块隔离。代表Java
    EE API类的模块会隐式地添加到你的应用程序的类路径中作为依赖项，这意味着你不需要任何特殊的配置来部署Java EE应用程序。
- en: If you want to reference other modules contained in the application server,
    you simply need to add a `Dependencies` property within the `META-INF/MANIFEST.MF`
    file of the application. Enterprise archives can also specify dependencies on
    other modules by setting the `Class-Path` attribute within the `META-INF/MANIFEST.MF`
    file.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想引用应用服务器中包含的其他模块，你只需在应用的`META-INF/MANIFEST.MF`文件中添加一个`Dependencies`属性。企业存档也可以通过在`META-INF/MANIFEST.MF`文件中设置`Class-Path`属性来指定对其他模块的依赖。
- en: If you want to maintain all your dependencies in a single file, you can use
    the `jboss-deployment-structure.xml` file. This allows you to define all dependencies
    within an archive, including the ability to override the default EAR isolation
    level and filter in/out classes, which are part of the application server deployment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将所有依赖项维护在一个单独的文件中，你可以使用`jboss-deployment-structure.xml`文件。这允许你在存档内定义所有依赖项，包括覆盖默认的EAR隔离级别和过滤进/出类，这些类是应用服务器部署的一部分。
- en: In the next chapter, we will cover the management of the application server
    by taking a close look at the command-line interface and the web admin console.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过详细探讨命令行界面和Web管理控制台来介绍应用服务器的管理。
