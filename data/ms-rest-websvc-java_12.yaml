- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Monitoring and Observability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和可观察性
- en: '**Monitoring** and **observability** are fundamental to ensuring that RESTful
    services operate reliably, efficiently, and securely. In distributed systems,
    where requests often pass through multiple services and components, having proper
    observability practices in place is critical. Without them, diagnosing performance
    bottlenecks, identifying the root causes of errors, and optimizing service behavior
    becomes incredibly challenging.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**监控**和**可观察性**对于确保RESTful服务可靠、高效和安全地运行至关重要。在分布式系统中，请求通常需要通过多个服务和组件，因此实施适当的可观察性实践是至关重要的。没有这些实践，诊断性能瓶颈、识别错误的根本原因以及优化服务行为将变得极其困难。'
- en: In this chapter, we will guide you through the essential practices and tools
    needed to achieve effective observability for RESTful services. We will begin
    by discussing **logging** best practices, explaining how structured logging and
    correlation IDs can simplify troubleshooting. We will then delve into distributed
    tracing, demonstrating how trace information such as `traceId` , `spanId` , and
    `parentSpanId` helps map the lifecycle of a request as it flows across multiple
    services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将指导你了解实现RESTful服务有效可观察性的基本实践和工具。我们将从讨论**日志记录**最佳实践开始，解释结构化日志和关联ID如何简化故障排除。然后我们将深入探讨分布式追踪，展示`traceId`、`spanId`和`parentSpanId`等追踪信息如何帮助映射请求在多个服务间流动的生命周期。
- en: We will introduce **Micrometer Tracing** , a powerful observability framework
    integrated into Spring Boot 3.x, which automatically instruments applications
    to capture trace data. Additionally, we will explore OpenTelemetry, a vendor-neutral
    framework that extends observability by collecting and correlating logs, metrics,
    and traces for a holistic view of distributed systems. By the end of this chapter,
    you will understand how to implement logging and tracing effectively, configure
    Spring Boot applications for observability, and visualize your data in tools like
    Zipkin and Jaeger.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍**Micrometer追踪**，这是一个强大的可观察性框架，集成在Spring Boot 3.x中，它能够自动对应用程序进行仪器化以捕获追踪数据。此外，我们还将探索OpenTelemetry，这是一个供应商中立的框架，通过收集和关联日志、指标和追踪来扩展可观察性，以获得分布式系统的整体视图。到本章结束时，你将了解如何有效地实现日志记录和追踪，配置Spring
    Boot应用程序以实现可观察性，并在Zipkin和Jaeger等工具中可视化你的数据。
- en: This chapter provides practical examples, step-by-step guidance, and best practices
    to ensure you can successfully monitor and debug your RESTful services.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了实际示例、逐步指导和最佳实践，以确保你可以成功监控和调试你的RESTful服务。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importance of logging in REST APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在REST API中日志记录的重要性
- en: Logging best practices for API troubleshooting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API故障排除的日志记录最佳实践
- en: Logging basics with SLF4J
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SLF4J的日志记录基础
- en: Implementing a central logging filter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现中央日志过滤器
- en: Implementing service tracing in distributed systems
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式系统中实现服务追踪
- en: Implementing tracing using Micrometer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Micrometer实现追踪
- en: Metrics from tracing data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪数据的指标
- en: OpenTelemetry for monitoring and observability
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenTelemetry用于监控和可观察性
- en: Best practices for end-to-end observability
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端可观察性的最佳实践
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will enhance our existing APIs—the Product API and the
    Order Management API—to be able to trace requests between them. To be able to
    follow along and use the code examples as they are printed in the book, you should
    have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将增强现有的API——产品API和订单管理API，以便能够追踪它们之间的请求。为了能够跟随书中的示例代码进行操作，你应该具备以下条件：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Java语言和平台有中级了解
- en: At least a basic knowledge of Spring Boot or a similar framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少对Spring Boot或类似框架有基本了解
- en: Java 21 and Maven 3.9.0 installed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Java 21和Maven 3.9.0
- en: Docker 27.3.1 or higher installed
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Docker 27.3.1或更高版本
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter9](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter9)
    .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上访问本章的代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter9](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter9)。
- en: Importance of logging in REST AP Is
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在REST API中日志记录的重要性
- en: Logging is the foundational element of observability in any system. Logs are
    essentially records of events that happen while your application runs. They are
    the first source of information when trying to troubleshoot an issue in any environment,
    especially in production.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是任何系统中可观察性的基础元素。日志基本上是记录应用程序运行期间发生的事件的记录。它们是在任何环境中尝试解决任何问题时信息的第一来源，尤其是在生产环境中。
- en: Logs act as the system’s memory, providing insights into what went wrong or
    how certain processes behaved. For a REST API, logs can show the path of each
    request, which is crucial for understanding failures or slow performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 日志充当系统的记忆，提供有关发生错误或某些过程如何行为的见解。对于REST API，日志可以显示每个请求的路径，这对于理解失败或缓慢的性能至关重要。
- en: For instance, suppose your API returns a `500` `Internal Server Error` to a
    user. Without logs, you would have no way of knowing what caused the error. However,
    with logs, you could see that a database query failed because the server ran out
    of connections, helping you fix the problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您的API向用户返回了一个`500` `Internal Server Error`。没有日志，您将无法知道错误的原因。然而，有了日志，您可以看到数据库查询失败是因为服务器连接耗尽，这有助于您解决问题。
- en: In the next sections, we are going to cover an effective logging design that
    will empower our applications significantly when troubleshooting is needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一种有效的日志设计，当需要故障排除时，这将显著增强我们的应用程序。
- en: Common logging pitfalls
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见日志陷阱
- en: 'Despite the importance of logging, many developers struggle with using logs
    effectively. Common mistakes include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日志的重要性不言而喻，但许多开发者在使用日志方面都感到困难。常见的错误包括：
- en: '**Over-logging** : Logging too much information can make it hard to find key
    details.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度记录日志**：记录过多的信息可能会使得找到关键细节变得困难。'
- en: '**Under-logging** : Insufficient logging might leave out key data needed for
    troubleshooting.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录日志不足**：日志记录不足可能会遗漏故障排除所需的关键数据。'
- en: '**Logging sensitive information** : Mistakenly logging things like user passwords
    or credit card numbers, which should never happen due to security and compliance
    concerns (e.g., GDPR or PCI DSS).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录敏感信息**：错误地记录诸如用户密码或信用卡号码等信息，这些信息由于安全和合规性考虑（例如，GDPR或PCI DSS）绝不应该发生。'
- en: A balance needs to be struck between logging enough to troubleshoot issues and
    not overwhelming the system with unnecessary data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录足够的信息以进行故障排除和不过度占用系统的不必要数据之间需要找到平衡。
- en: Effective log design
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的日志设计
- en: 'Designing logs properly is crucial for them to be useful. Each log entry should
    include relevant metadata:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设计日志对于它们的有用性至关重要。每个日志条目都应该包含相关的元数据：
- en: '**Timestamp** : When the log entry was created.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**：日志条目创建的时间。'
- en: '**Log level** : Severity of the log ( `INFO` , `DEBUG` , `ERROR` ).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志级别**：日志的严重性（`INFO`，`DEBUG`，`ERROR`）。'
- en: '**Service name** : The name of the service generating the log.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务名称**：生成日志的服务名称。'
- en: '**Correlation ID** : A unique ID that allows you to track a request through
    multiple services (more on this below).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联ID**：一个唯一的ID，允许您跟踪通过多个服务（下面将详细介绍）的请求。'
- en: 'For example, a well-structured log entry in JSON might look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个结构良好的JSON日志条目可能看起来像这样：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Correlation IDs
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关联ID
- en: In microservices, a request might pass through multiple services. To track the
    entire request path, it is essential to attach a correlation ID to each request.
    The correlation ID is a unique identifier that stays with the request as it moves
    through the system. This allows you to correlate logs from different services
    to see how a single request was handled end to end. For example, a user request
    to retrieve profile information might go through an API gateway, then hit the
    authentication service, and finally query the user database. With a correlation
    ID, you can trace each step of the process across all services involved. Spring
    makes it easy to generate and propagate correlation IDs. You can generate a correlation
    ID at the start of a request and pass it along with HTTP headers between services.
    This will help you diagnose where issues occur in a chain of services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，一个请求可能会通过多个服务。为了跟踪整个请求路径，将关联ID附加到每个请求是必不可少的。关联ID是一个唯一标识符，它在请求通过系统时保持不变。这允许您关联来自不同服务的日志，以查看单个请求是如何从头到尾处理的。例如，用户请求检索个人资料信息可能通过API网关，然后击中身份验证服务，最后查询用户数据库。使用关联ID，您可以跟踪所有涉及服务中的每个步骤。Spring使生成和传播关联ID变得简单。您可以在请求开始时生成关联ID，并通过HTTP头在服务之间传递它。这将帮助您诊断服务链中出现问题的位置。
- en: Next, we will learn about the best logging practices, understand the different
    log levels and their structure, and what should and should not be logged to avoid
    security issues.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习最佳日志记录实践，了解不同的日志级别及其结构，以及应该和不应该记录的内容，以避免安全问题。
- en: Logging best practices for API troubleshooting
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API故障排除的日志最佳实践
- en: Effective logging is essential for troubleshooting, especially when working
    with distributed systems or cloud-native architectures. Here are some best practices
    to ensure your logging strategy is robust.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的日志记录对于故障排除至关重要，尤其是在与分布式系统或云原生架构一起工作时。以下是一些最佳实践，以确保您的日志策略稳健。
- en: Choosing the right log level
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的日志级别
- en: 'Logs should be written at the appropriate log level, which indicates the severity
    of the event:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应在适当的日志级别写入日志，这表示事件的严重性：
- en: '`TRACE` : Used for very fine-grained details, primarily for debugging low-level
    operations like recording the internal state of loops, method entry/exit points,
    or interactions between components in detail. Should be turned off in production
    due to the huge amount of logs that are generated at this level.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：用于非常细粒度的细节，主要用于调试低级操作，如记录循环的内部状态、方法入口/出口点或组件之间的详细交互。由于在此级别生成的日志量巨大，因此在生产环境中应关闭。'
- en: '`DEBUG` : Used for low-level information that helps in debugging issues, such
    as details of an HTTP request. Logs provide detailed information that helps during
    development or debugging, focusing on application-specific logic or operations.
    Also, this level should be turned off in production due to the huge amount of
    logs that are generated at this level.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`：用于帮助调试问题的低级信息，例如HTTP请求的详细信息。日志提供详细的信息，有助于开发或调试期间，专注于特定于应用程序的逻辑或操作。此外，由于在此级别生成的日志量巨大，因此应在生产环境中关闭此级别。'
- en: '`INFO` : Used for general application flow information, such as when a service
    starts up or shuts down. These logs are less verbose than `DEBUG` or `TRACE` and
    are typically enabled in production.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`：用于通用应用程序流程信息，例如当服务启动或关闭时。这些日志比`DEBUG`或`TRACE`更简洁，通常在生产环境中启用。'
- en: '`WARN` : Indicates something unusual but not necessarily an error. For example,
    a service might temporarily run out of resources but recover. These logs are a
    warning for potential future issues. For example:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARN`：表示某些不一定是错误的不寻常情况。例如，服务可能会暂时耗尽资源但恢复。这些日志是对潜在未来问题的警告。例如：'
- en: '`ERROR` : Used when something has gone wrong, like an exception being thrown
    or a critical failure in a database connection. These logs often indicate that
    the system requires attention or intervention.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`：用于出现问题时，如抛出异常或数据库连接中的关键故障。这些日志通常表明系统需要关注或干预。'
- en: '`FATAL` : Indicates a critical error that causes the application or service
    to crash or become unusable. These logs are extremely rare and signify the most
    severe issues that require immediate attention. Note that this level is not present
    universally in libraries like SLF4J or Logback and is often represented by the
    `ERROR` level; however, it is present in Log4J and Log4J2 logging libraries, which
    will not be covered by this chapter.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL`：表示导致应用程序或服务崩溃或变得不可用的关键错误。这些日志非常罕见，表明需要立即关注的严重问题。请注意，此级别并非在所有库（如SLF4J或Logback）中都存在，通常由`ERROR`级别表示；然而，它在Log4J和Log4J2日志库中存在，本章节不会涉及。'
- en: 'In a REST API, a failed user login attempt due to incorrect credentials might
    be logged at the `WARN` level:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API中，由于凭据错误而失败的登录尝试可能会记录在`WARN`级别：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Meanwhile, a database outage that causes the entire service to fail should
    be logged at the `ERROR` level or as `FATAL` if available:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，由于数据库故障导致整个服务失败的情况应该记录在`ERROR`级别，如果可用则记录为`FATAL`：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Choosing the right level ensures that you can quickly filter out non-critical
    logs when troubleshooting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的级别可以确保你在故障排除时能够快速过滤掉非关键日志。
- en: Structured logging
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化日志
- en: Structured logging refers to logging in a consistent, machine-readable format,
    such as JSON. This allows logs to be easily parsed and queried by logging tools
    (like ELK Stack or Splunk), making it easier to filter, aggregate, and analyze
    logs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志是指以一致、机器可读的格式进行日志记录，例如JSON。这使得日志可以轻松地被日志工具（如ELK Stack或Splunk）解析和查询，使得过滤、聚合和分析日志变得更加容易。
- en: 'Rather than logging a simple message like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是记录这样的简单消息：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should log the event in a structured format:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该以结构化格式记录事件：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, you can easily search for all login failures or group them by the `user`
    field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以轻松地搜索所有登录失败或按`user`字段分组。
- en: Avoiding sensitive data in logs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在日志中包含敏感数据
- en: Sensitive information such as passwords, credit card numbers, or personal identifiers
    should never be logged. If this data is accidentally exposed in logs, it can lead
    to serious security breaches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 像密码、信用卡号码或个人标识符这样的敏感信息绝不应该被记录。如果这些数据意外地在日志中暴露，可能会导致严重的安全漏洞。
- en: 'For example, if a login attempt fails, it is okay to log the username, but
    never log the password. A log message like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果登录尝试失败，记录用户名是可以的，但绝不能记录密码。这样的日志消息：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'is dangerous. Instead, log something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是危险的。相反，记录类似以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use Jackson’s `@JsonIgnore` or `@JsonProperty(access = Access.WRITE_ONLY)`
    annotations to prevent sensitive data from being serialized into logs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Jackson的`@JsonIgnore`或`@JsonProperty(access = Access.WRITE_ONLY)`注解来防止敏感数据被序列化到日志中。
- en: Jackson is a widely used Java library for processing JSON data. It provides
    powerful capabilities for serializing Java objects into JSON and deserializing
    JSON into Java objects, making it a crucial tool in RESTful web services where
    data is often exchanged in JSON format.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jackson是一个广泛使用的Java库，用于处理JSON数据。它提供了将Java对象序列化为JSON和将JSON反序列化为Java对象的功能，使其在数据通常以JSON格式交换的RESTful
    Web服务中成为一项关键工具。
- en: In a Spring Boot application, Jackson is the default JSON processor and is commonly
    used to automatically transform request and response payloads, making API interactions
    seamless.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序中，Jackson是默认的JSON处理器，通常用于自动转换请求和响应负载，使API交互无缝。
- en: It allows developers to customize JSON output using annotations like `@JsonIgnore`
    , `@JsonProperty` , and `@JsonInclude` , ensuring that only the necessary fields
    are exposed while sensitive or unnecessary data is excluded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许开发者使用`@JsonIgnore`、`@JsonProperty`和`@JsonInclude`等注解自定义JSON输出，确保只暴露必要的字段，同时排除敏感或不必要的数据。
- en: This is particularly useful when logging requests or response objects, as it
    ensures that sensitive information (like passwords or credit card details) does
    not get exposed in log entries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这在记录请求或响应对象时尤其有用，因为它确保敏感信息（如密码或信用卡详情）不会在日志条目中暴露。
- en: When to use each annotation?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用每个注解？
- en: '`@JsonIgnore` : Use when you want to prevent a field from ever being included
    in serialized output, such as responses and logs, and deserialized input from
    requests.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JsonIgnore`：当你想防止字段永远包含在序列化输出中，例如响应和日志，以及从请求中反序列化的输入时使用。'
- en: '`@JsonProperty(access = Access.WRITE_ONLY)` : Use when you need to accept the
    field as input but want to exclude it from all serialized output, making it suitable
    for fields that should remain private (e.g., passwords) during logging or API
    responses.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JsonProperty(access = Access.WRITE_ONLY)` 注解：当需要接受字段作为输入但希望将其排除在所有序列化输出之外时使用，这使得它适用于在日志记录或
    API 响应中应保持私有的字段（例如密码）。'
- en: Let us go through an example to demonstrate how to use these annotations in
    a RESTful service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示如何在 RESTful 服务中使用这些注解。
- en: Suppose you have a `User` class with fields like `username` , `email` , and
    `password` . When logging this `User` object, we want to ensure that the password
    field is not included in the serialized output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `User` 类，包含 `username`、`email` 和 `password` 等字段。当记录这个 `User` 对象时，我们希望确保密码字段不包含在序列化输出中。
- en: Completely exclude the field from serialization/deserialization
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全排除字段在序列化和反序列化过程中。
- en: The `@JsonIgnore` annotation completely omits a field from deserialization and
    serialization, meaning it will not be included in the input or the output JSON
    at all.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JsonIgnore` 注解完全排除一个字段在反序列化和序列化过程中，这意味着它将完全不会包含在输入或输出 JSON 中。'
- en: When you use `@JsonIgnore` on a field, it is completely ignored by Jackson both
    during serialization (when converting an object to JSON) and deserialization (when
    converting JSON to an object). This means that if you mark a field with `@JsonIgnore`
    , Jackson will neither include it in the output JSON nor allow it as an input
    in the JSON request body.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在字段上使用 `@JsonIgnore` 注解时，Jackson 在序列化（将对象转换为 JSON）和反序列化（将 JSON 转换为对象）过程中都会完全忽略该字段。这意味着如果你用
    `@JsonIgnore` 标记了一个字段，Jackson 将不会将其包含在输出 JSON 中，也不会允许它在 JSON 请求体中作为输入。
- en: This is useful when you want to ensure that sensitive information (e.g., passwords
    or tokens) is never exposed in any serialized output, including logs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想确保敏感信息（例如密码或令牌）在任何序列化输出中都不会暴露时，这很有用，包括日志。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this setup, if you log the User object using Jackson for serialization,
    the password field will be omitted:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，如果你使用 Jackson 对 User 对象进行序列化记录，密码字段将被省略：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Output log (password is excluded)** :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出日志（密码被排除）** :'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `password` field is completely omitted from the log output
    because of the `@JsonIgnore` annotation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于使用了 `@JsonIgnore` 注解，`password` 字段完全被省略在日志输出之外。
- en: Now that you know how to exclude fields from serialization and deserialization,
    let us see how to allow a field to be deserialized from JSON input but excluded
    from serialization, such as in logs or API responses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何排除字段在序列化和反序列化过程中的情况，让我们看看如何允许一个字段从 JSON 输入中反序列化，但排除在序列化之外，例如在日志或 API
    响应中。
- en: Allowing data input deserialization but excluding it from output serialization
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许数据输入反序列化，但排除输出序列化。
- en: 'The `@JsonProperty(access = Access.WRITE_ONLY)` annotation is useful when you
    want a field to be deserialized (e.g., when receiving input from a user) but not
    serialized (e.g., when logging or sending data as a response). This is common
    for fields like passwords in user registration forms:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想一个字段被反序列化（例如，当从用户接收输入时）但不想被序列化（例如，当记录或发送数据作为响应时）时，`@JsonProperty(access =
    Access.WRITE_ONLY)` 注解非常有用。这在用户注册表单中的密码字段等字段中很常见：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With `@JsonProperty(access = Access.WRITE_ONLY)` , you can still accept the
    `password` field in incoming JSON requests, but it will be excluded from any serialized
    output, including logs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@JsonProperty(access = Access.WRITE_ONLY)` 注解，你仍然可以接受入站 JSON 请求中的 `password`
    字段，但它将被排除在任何序列化输出之外，包括日志。
- en: '**Example usage:**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例用法** :'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a new user registration request comes in, the `password` field will be
    available for processing, but it will not be logged.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到新的用户注册请求时，`password` 字段将可用于处理，但不会被记录。
- en: '**Incoming request** :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**入站请求** :'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Output log (password is excluded from the log)** :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出日志（密码被排除）** :'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With `@JsonProperty(access = Access.WRITE_ONLY)` , the password is received
    by the application but is excluded from logs or other serialized JSON output,
    ensuring that sensitive data is protected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@JsonProperty(access = Access.WRITE_ONLY)` 注解，密码会被应用程序接收，但会从日志或其他序列化的 JSON
    输出中排除，从而确保敏感数据得到保护。
- en: By using these annotations strategically, you can control sensitive data exposure
    in logs, which is an essential part of security best practices for RESTful APIs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有策略地使用这些注解，你可以控制日志中的敏感数据暴露，这是 RESTful API 安全最佳实践的重要组成部分。
- en: Now, let’s get back to the last best practice for logging
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到日志记录的最佳实践。
- en: Capturing contextual information
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获上下文信息
- en: 'To make logs more useful, include contextual information about each request,
    such as:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使日志更有用，请包括每个请求的上下文信息，例如：
- en: HTTP method ( `GET` , `POST` , etc.)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法（`GET`，`POST`等）
- en: Endpoint (e.g., `/api/v1/users/123` )
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点（例如，`/api/v1/users/123`）
- en: Response status ( `200` , `404` , `500` , etc.)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应状态（`200`，`404`，`500`等）
- en: Request headers and payloads (but be careful to exclude sensitive data)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求头和有效负载（但请注意排除敏感数据）
- en: This information will allow you to better understand what happened during an
    API request.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息将帮助您更好地了解API请求期间发生的情况。
- en: 'For example, a request log might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个请求日志可能看起来像这样：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By capturing such details, you can correlate issues with specific requests and
    quickly pinpoint where things went wrong.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕获此类详细信息，您可以关联特定请求的问题，并快速确定问题出在哪里。
- en: Next, we will dive into one of the most famous logging libraries in the market,
    SLF4J, and how to create logs from our application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解市场上最著名的日志库之一，SLF4J，以及如何从我们的应用程序中创建日志。
- en: Logging basics with SLF4J
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SLF4J进行日志记录基础
- en: This section introduces how to add logging points into your own Java code using
    SLF4J. This is crucial since you need to add loggers throughout your entire application
    to be able to generate logs from its flow that will help you troubleshoot it when
    it is deployed, especially in production.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何使用SLF4J将日志记录点添加到自己的Java代码中。这对于您在整个应用程序中添加记录器以生成日志至关重要，这些日志可以帮助您在部署时调试它，尤其是在生产环境中。
- en: In Spring Boot, SLF4J (Simple Logging Facade for Java) is commonly used as a
    logging API that can work with different logging frameworks (such as Logback,
    Log4j2, etc.). Spring Boot uses SLF4J by default and integrates it seamlessly,
    so all we need to do is inject the logger and start logging messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot中，SLF4J（Java简单日志门面）通常用作可以与不同日志框架（如Logback、Log4j2等）一起工作的日志API。Spring
    Boot默认使用SLF4J并将其无缝集成，因此我们所需做的就是注入记录器并开始记录消息。
- en: Also, if you are not using Spring Boot, you can just add the SLF4J dependency
    to your Maven POM dependencies file or Gradle dependencies file to use it if the
    framework that you are using does not already include it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您不使用Spring Boot，您只需将SLF4J依赖项添加到您的Maven POM依赖项文件或Gradle依赖项文件中，以便在使用框架时如果尚未包含它，就可以使用它。
- en: 'Let us start with a simple example of how to log a Spring Boot application
    using SLF4J. Here is a User Creation service that uses SLF4J to log messages at
    different log levels ( `INFO` , `WARN` , `ERROR` ):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何使用SLF4J记录Spring Boot应用程序的简单示例开始。以下是一个使用SLF4J在不同日志级别（`INFO`，`WARN`，`ERROR`）记录消息的用户创建服务：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中：
- en: We log informational messages with `logger.info()` .
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`logger.info()`记录信息消息。
- en: We log an error with `logger.error()` , including the exception stack trace.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`logger.error()`记录错误，包括异常堆栈跟踪。
- en: The `LoggerFactory.getLogger(UserService.class)` creates a logger specifically
    for the `UserService` class.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggerFactory.getLogger(UserService.class)`为`UserService`类创建一个特定的记录器。'
- en: 'For successful user creation, we would have a log output like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的用户创建，日志输出将如下所示：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, for a failed user creation, for example, trying to create a null user,
    the output would be:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于失败的用户创建，例如尝试创建一个null用户，输出将是：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using SLF4J with different log levels helps organize and filter log messages,
    making it easier to troubleshoot and debug.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同日志级别的SLF4J有助于组织和过滤日志消息，使其更容易调试和调试。
- en: In the next section, let us look at how we can automate some of the logging
    in our application to reduce the burden of having tons of logging everywhere in
    your code, by implementing a central logging filter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看如何通过实现中央日志过滤器来自动化应用程序中的一些日志记录，以减少在代码中到处都有大量日志的负担。
- en: Implementing a central logging filter
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现中央日志过滤器
- en: To improve observability in a RESTful application, we can implement a central
    logging component that logs all incoming HTTP requests and responses. A filter
    is an effective choice for this as it allows you to intercept requests before
    they reach the controller layer, enabling you to log key requests and response
    details in one place.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高RESTful应用程序的可观察性，我们可以实现一个中央日志组件，记录所有传入的HTTP请求和响应。过滤器是一个有效的选择，因为它允许您在请求到达控制器层之前拦截请求，使您能够在一个地方记录关键请求和响应细节。
- en: 'In this example, we will implement a `RequestLoggingFilter` that logs incoming
    requests, following best practices such as structured logging, adding correlation
    IDs, and avoiding sensitive information. This filter will log essential request
    metadata, such as HTTP method, URL, status code, and processing time, in a structured
    JSON format:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将实现一个`RequestLoggingFilter`，该过滤器记录传入的请求，遵循最佳实践，如结构化日志记录、添加关联ID和避免敏感信息。此过滤器将以结构化的JSON格式记录必要请求元数据，例如HTTP方法、URL、状态码和处理时间：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, what is this filter doing?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个过滤器到底在做什么呢？
- en: '**Choosing the right log level** : The filter logs complete requests at the
    `INFO` level, which is appropriate for general application flow information. If
    a request encounters an error, it could be logged at `ERROR` in other components,
    such as exception handlers.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择合适的日志级别**：过滤器以`INFO`级别记录完整的请求，这对于一般应用程序流程信息是合适的。如果请求遇到错误，它可以在其他组件（如异常处理器）中以`ERROR`级别记录。'
- en: '**Structured logging** : The filter uses structured logging to log information
    in JSON format, including fields like `correlationId` , `method` , `url` , `status`
    , and `duration` . Structured logging allows for easier parsing, searching, and
    aggregating in centralized logging tools.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化日志记录**：过滤器使用结构化日志记录以JSON格式记录信息，包括`correlationId`、`method`、`url`、`status`和`duration`等字段。结构化日志记录使得在集中式日志工具中进行解析、搜索和聚合变得更加容易。'
- en: '**Avoiding sensitive data** : The filter avoids logging the request body directly,
    which could contain sensitive information like passwords. If needed, further filtering
    can exclude or mask sensitive data in headers or query parameters.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免敏感数据**：过滤器避免直接记录请求体，因为请求体可能包含敏感信息，如密码。如果需要，进一步的过滤可以排除或屏蔽头或查询参数中的敏感数据。'
- en: '**Capturing contextual information** : The filter captures relevant metadata
    for each request, including the HTTP method, URL, status code, and duration. This
    provides valuable context for debugging and performance analysis.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获上下文信息**：过滤器捕获每个请求的相关元数据，包括HTTP方法、URL、状态码和持续时间。这为调试和性能分析提供了有价值的上下文。'
- en: '**Using correlation IDs** : The filter generates a correlation ID (if one is
    not already present) and stores it in the **Mapped Diagnostic Context (MDC)**
    . This ensures that the correlation ID is added to all subsequent logs within
    the request’s lifecycle, enabling end-to-end tracking across services.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用关联ID**：过滤器生成一个关联ID（如果尚未存在）并将其存储在**映射诊断上下文（MDC）**中。这确保了关联ID被添加到请求生命周期内的所有后续日志中，从而实现了跨服务的端到端跟踪。'
- en: '![img](img/lightbulb1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/lightbulb1.png)'
- en: Mapped Diagnostic Context (MDC)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 映射诊断上下文（MDC）
- en: '**Mapped Diagnostic Context (MDC)** is a feature in logging frameworks like
    SLF4J (with Logback) and Log4j that allows developers to store and retrieve contextual
    information per thread. This context information is automatically included in
    log messages, making it easier to track related logs across different parts of
    an application.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射诊断上下文（MDC）**是SLF4J（与Logback）和Log4j等日志框架中的功能，允许开发者按线程存储和检索上下文信息。此上下文信息自动包含在日志消息中，使得跟踪应用程序不同部分的关联日志变得更加容易。'
- en: 'With this logging filter in place, here is an example of what a log entry might
    look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此日志过滤器设置到位后，以下是一个日志条目可能的样子：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But to have the `correlationId` spread to other services and enable the power
    of tracking the request across multiple services, we need to update the header
    with the proper newly generated value from `correlationId` , adding it before
    the request is sent. We will do it using `BeanPostProcessor` :'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了将`correlationId`传播到其他服务并启用跨多个服务的请求跟踪功能，我们需要在发送请求之前更新头信息，添加从`correlationId`生成的新值。我们将使用`BeanPostProcessor`来完成这项工作：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As an example, in the Order Management API, before calling the `productsApi`
    into the `ProductsQueryUseCaseImpl` implementation, we will make a call to the
    `beanPostProcessor` to have the `ApiClient` bean updated with the `correlationId`
    set in the header from the request.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在订单管理API中，在调用`productsApi`到`ProductsQueryUseCaseImpl`实现之前，我们将调用`beanPostProcessor`以将请求头中设置的`correlationId`更新到`ApiClient`
    bean中。
- en: 'The `ApiClient` is the REST client that was generated by the OpenAPI plugin
    using the Product API specification and will be used for every call to the Product
    API from the Order Management API. Here is the updated version of the class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiClient`是由OpenAPI插件使用产品API规范生成的REST客户端，并将用于从订单管理API对产品API的每次调用。以下是该类的更新版本：'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This ensures that the `correlationId` is propagated with every service request.
    The filter in the called service will read the `correlationId` and include it
    in the logs, enabling you to uniquely track requests across the services.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了`correlationId`与每个服务请求一起传播。被调用服务的过滤器将读取`correlationId`并将其包含在日志中，使您能够跨服务唯一跟踪请求。
- en: 'Additional functionality can be added to the filter to capture even more detailed
    logging information:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向过滤器添加更多功能，以捕获更详细的日志信息：
- en: '**Log-specific headers** : Capture headers like `User-Agent` or `Authorization`
    , but exclude or mask sensitive details.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录特定头信息**：捕获像`User-Agent`或`Authorization`这样的头信息，但排除或屏蔽敏感细节。'
- en: '**Conditional logging for error responses** : Modify the filter to log `4xx`
    and `5xx` responses at `WARN` or `ERROR` levels for easier error tracking.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件日志记录错误响应**：修改过滤器以在`WARN`或`ERROR`级别记录`4xx`和`5xx`响应，以便更容易地进行错误跟踪。'
- en: '**Error handling** : Combine this filter with a global exception handler to
    capture and log unhandled exceptions, leveraging the correlation ID to tie error
    logs to their originating requests.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：将此过滤器与全局异常处理器结合使用，以捕获和记录未处理的异常，利用关联ID将错误日志与其原始请求关联起来。'
- en: This logging filter implements best practices and creates consistent, structured
    logs across the application, making it easier to monitor, troubleshoot, and analyze
    incoming API requests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志过滤器实现了最佳实践，并在整个应用程序中创建了一致的、结构化的日志，这使得监控、故障排除和分析传入的API请求变得更加容易。
- en: And to effectively track requests across multiple services, implementing tracing
    is essential. It helps maintain a clear trace and simplifies troubleshooting in
    distributed systems. In the next section, we will explore how to achieve this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 而要有效地跨多个服务跟踪请求，实现追踪是必不可少的。它有助于保持清晰的追踪并简化分布式系统中的故障排除。在下一节中，我们将探讨如何实现这一点。
- en: Implementing service tracing in distributed systems
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分布式系统中实现服务追踪
- en: In distributed systems, where a request might span multiple services, **distributed
    tracing** provides visibility into how a request moves through various components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，一个请求可能跨越多个服务，**分布式追踪**提供了对请求如何通过各种组件的可见性。
- en: Let’s begin by understanding what we mean by distributed tracing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解我们所说的分布式追踪是什么意思。
- en: What is distributed tracing?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是分布式追踪？
- en: Distributed tracing allows you to follow the lifecycle of a request as it flows
    from one service to another. This helps you see where delays or errors occur.
    In tracing terminology, each step in the request’s journey is called a span, and
    a trace is the entire set of spans associated with a request.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪允许您跟踪请求的生命周期，从一项服务流向另一项服务。这有助于您看到延迟或错误发生的位置。在追踪术语中，请求旅程中的每一步称为一个跨度，而追踪是与请求相关联的所有跨度的集合。
- en: 'For example, imagine a request comes into your system to create a new user.
    This request might touch on the following services:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个请求进入您的系统以创建新用户。这个请求可能会影响到以下服务：
- en: API gateway
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关
- en: Authentication service
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证服务
- en: User service (to create the user in the database)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户服务（用于在数据库中创建用户）
- en: Notification service (to send a welcome email)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知服务（用于发送欢迎邮件）
- en: Each of these steps is a span, and all the spans together form a trace.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都是一个跨度，所有跨度共同构成一个追踪。
- en: Distributed tracing tools, such as Zipkin or Jaeger, can visualize the trace
    and highlight which services or steps are causing delays.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪工具，如Zipkin或Jaeger，可以可视化追踪并突出显示导致延迟的服务或步骤。
- en: Next, we will understand how each trace is identified uniquely by adding a trace
    ID to each request.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过为每个请求添加一个追踪ID来了解每个追踪是如何唯一标识的。
- en: Using trace IDs for end-to-end request tracking
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用追踪ID进行端到端请求跟踪
- en: Just like correlation IDs help in logs, trace IDs are unique identifiers attached
    to each request, allowing for end-to-end request tracking” you to track that request
    across multiple services. The difference is that trace IDs are automatically managed
    by tracing systems and include timing information.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像关联ID有助于日志一样，追踪ID是附加到每个请求的唯一标识符，允许进行端到端请求跟踪，您可以在多个服务中跟踪该请求。不同之处在于，追踪ID由追踪系统自动管理，并包括时间信息。
- en: In Spring, the Micrometer Tracing library automatically generates trace IDs
    for each request and propagates them across service boundaries. These IDs are
    included in the logs and tracing systems, allowing you to correlate logs and traces
    for detailed troubleshooting.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，Micrometer Tracing库为每个请求自动生成跟踪ID，并在服务边界之间传播它们。这些ID包含在日志和跟踪系统中，允许您关联日志和跟踪，以便进行详细的故障排除。
- en: 'In a Spring Boot application, Micrometer Tracing generates the following log
    message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序中，Micrometer Tracing生成以下日志消息：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`traceId` helps you connect this event to other related events across different
    services.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceId`帮助您将此事件与其他服务中的相关事件关联起来。'
- en: Now, let us learn how to implement the tracing feature with Micrometer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用Micrometer实现跟踪功能。
- en: Implementing tracing using Micrometer
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Micrometer实现跟踪
- en: With the release of Spring Boot 3.x, Spring Cloud Sleuth has been replaced by
    Micrometer Tracing for tracing support. Micrometer Tracing is fully compatible
    with Spring Boot 3.x and offers a more modern, flexible way to implement distributed
    tracing in your applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Spring Boot 3.x的发布，Spring Cloud Sleuth已被Micrometer跟踪替换以提供跟踪支持。Micrometer跟踪与Spring
    Boot 3.x完全兼容，并为在应用程序中实现分布式跟踪提供了一种更现代、更灵活的方法。
- en: In this section, we will walk through how to implement distributed tracing in
    a Spring Boot application using Micrometer Tracing, enabling you to track requests
    across services and get detailed insights into their performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用Micrometer跟踪在Spring Boot应用程序中实现分布式跟踪，使您能够跟踪跨服务请求，并深入了解其性能。
- en: Setting up Micrometer Tracing in Spring Boot
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Spring Boot中设置Micrometer跟踪
- en: 'To implement tracing in a Spring Boot application using Micrometer Tracing,
    follow these steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Micrometer跟踪在Spring Boot应用程序中实现跟踪，请按照以下步骤操作：
- en: '**Add Micrometer Tracing dependencies** :'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加微米级跟踪依赖** :'
- en: 'Micrometer Tracing is part of the Micrometer ecosystem, and it integrates easily
    with Spring Boot 3.x. To enable Micrometer Tracing in your project, add the necessary
    dependencies to your `pom.xml` (if using Maven):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer跟踪是Micrometer生态系统的一部分，并且与Spring Boot 3.x集成轻松。要在项目中启用Micrometer跟踪，请将必要的依赖项添加到您的`pom.xml`中（如果使用Maven）：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is what these dependencies are used for:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项的用途如下：
- en: '`micrometer-observation` : Provides the core Observation API that serves as
    a facade for metrics, logging, and tracing. It allows you to instrument code once
    and get multiple observability benefits, focusing on what you want to observe
    rather than how to implement it.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`micrometer-observation` : 提供核心Observation API，作为指标、日志和跟踪的代理。它允许您一次性仪表化代码，并获得多个可观察性好处，专注于您想要观察的内容，而不是如何实现它。'
- en: '`micrometer-tracing-bridge-brave` : Bridges the Micrometer Observation API
    to Brave, enabling distributed tracing capabilities. This dependency is responsible
    for creating and propagating trace and span IDs across service boundaries, which
    is what adds the trace context to your logs.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`micrometer-tracing-bridge-brave` : 将Micrometer Observation API桥接到Brave，启用分布式跟踪功能。此依赖项负责在服务边界之间创建和传播跟踪和跨度ID，这就是将跟踪上下文添加到您的日志中的原因。'
- en: '`spring-boot-starter-actuator` : Provides production-ready features to help
    monitor and manage your application. It includes endpoints for health checks,
    metrics, and other operational data. This starter automatically configures the
    observability infrastructure when combined with the Micrometer dependencies.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-actuator` : 提供了生产就绪功能，有助于监控和管理您的应用程序。它包括健康检查、指标和其他操作数据的端点。此启动器在结合Micrometer依赖项时自动配置可观察性基础设施。'
- en: Together, these dependencies enable comprehensive observability with metrics,
    tracing, and health monitoring in a Spring Boot microservices architecture.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项共同作用，在Spring Boot微服务架构中实现了全面的可观察性，包括指标、跟踪和健康监控。
- en: '**Configure Micrometer Tracing** :'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置Micrometer跟踪** :'
- en: Once you’ve added the dependencies, Micrometer Tracing is automatically configured
    in Spring Boot. By default, Micrometer will instrument your HTTP requests, generating
    trace IDs and span IDs for each incoming request. These IDs are propagated across
    service boundaries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些依赖项后，Micrometer Tracing将在Spring Boot中自动配置。默认情况下，Micrometer将对您的HTTP请求进行仪表化，为每个传入请求生成跟踪ID和跨度ID。这些ID将在服务边界之间传播。
- en: 'To enable tracing fully, you may need to configure how traces are exported.
    For example, to export traces to Zipkin, add the following configuration to your
    `application.yml` :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全启用跟踪，您可能需要配置跟踪的导出方式。例如，要将跟踪导出到Zipkin，请将以下配置添加到您的`application.yml`中：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this configuration, we have the following parameters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们有以下参数：
- en: '`management.tracing.enabled=true` : Enables tracing for the application.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management.tracing.enabled=true` : 启用应用程序的跟踪功能。'
- en: '`management.tracing.sampling.probability=1.0` : Ensures that all requests are
    traced (for production, you might want to adjust this for performance reasons).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management.tracing.sampling.probability=1.0` : 确保所有请求都被跟踪（对于生产环境，您可能需要根据性能原因调整此设置）。'
- en: '`management.tracing.zipkin.enabled=true` : Enables exporting traces to Zipkin.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management.tracing.zipkin.enabled=true` : 启用将跟踪导出到 Zipkin。'
- en: '`management.tracing.zipkin.endpoint` : Specifies the URL of your Zipkin server
    for trace collection.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management.tracing.zipkin.endpoint` : 指定用于跟踪收集的 Zipkin 服务器的 URL。'
- en: '`logging.pattern.level` : Specifies a pattern on which each log will be presented.
    Here, we are setting it to log as follows: application name, traceId, spanId.
    Note that the format for getting the values in the logs for the trace ID and the
    span Id can differ from library to library.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging.pattern.level` : 指定每个日志条目将展示的格式。在此，我们将其设置为以下日志格式：应用程序名称、traceId、spanId。请注意，获取跟踪
    ID 和 span Id 的日志值格式可能因库而异。'
- en: '**Configuring RestClient for tracing**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置 RestClient 以进行跟踪**'
- en: To guarantee that the generated trace is propagated through the called services,
    you need to configure your HTTP client to propagate the trace context. This is
    done by configuring `RestClient` to use the one that is created by Spring, using
    the dependencies and configurations done in steps 1 and 2.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证生成的跟踪在调用服务中传播，您需要配置您的 HTTP 客户端以传播跟踪上下文。这是通过配置 `RestClient` 使用由 Spring 创建的实例来完成的，使用步骤
    1 和 2 中完成的依赖项和配置。
- en: Since we are using `OpenAPI` in this book to generate the client that queries
    the Products API from the Order Management API, you need to override the generated
    `RestClient` from OpenAPI with the one from instantiated in Spring.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本书中使用 `OpenAPI` 生成从订单管理 API 查询产品 API 的客户端，因此您需要用 Spring 实例化的 `RestClient`
    覆盖 OpenAPI 生成的 `RestClient`。
- en: 'To do that, you need to properly set the beans in the configuration. In the
    Order Management API, these configurations are done on the `ProductsApiConfiguration`
    class, under the `adapter.outbound.rest` package:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您需要在配置中正确设置 Bean。在订单管理 API 中，这些配置是在 `ProductsApiConfiguration` 类的 `adapter.outbound.rest`
    包下完成的：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code configures the `RestClient` bean with a custom `ClientHttpRequestFactory`
    and an `ObservationRegistry` from the imported `micrometer-observation` dependency.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码配置了 `RestClient` 实例使用自定义的 `ClientHttpRequestFactory` 和来自导入的 `micrometer-observation`
    依赖项的 `ObservationRegistry`。
- en: Then, it adds the configured `RestClient` bean into the `ApiClient` bean, followed
    by the configured `ApiClient` bean into the `ProductsApi` bean. We use the `ProductsApi`
    bean to call the external Products API from the Order Management API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将配置的 `RestClient` 实例添加到 `ApiClient` 实例中，接着将配置的 `ApiClient` 实例添加到 `ProductsApi`
    实例中。我们使用 `ProductsApi` 实例从订单管理 API 调用外部产品 API。
- en: This is how we ensure that the `traceId` and `spanId` values are generated and
    that `traceId` is properly propagated over all the services that we call from
    the Order Management API.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是确保 `traceId` 和 `spanId` 值被生成，并且 `traceId` 正确传播到我们从订单管理 API 调用的所有服务中的方法。
- en: But also, after that, we are configuring a custom `SpanHandler` with a `LogSpanHandler`
    . That is used to log useful information from the trace context into the application
    logs. Information like the duration, the request origin, its timestamp, and the
    `traceId` give us various data to monitor and troubleshoot the application in
    production. In the next section, you will see a real example logged by this `SpanHandler`
    .
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，之后我们还配置了一个自定义的 `SpanHandler` 与 `LogSpanHandler` 。它用于将跟踪上下文中的有用信息记录到应用程序日志中。例如持续时间、请求来源、时间戳和
    `traceId` 等信息为我们提供了各种数据，用于监控和在生产环境中调试应用程序。在下一节中，您将看到由此 `SpanHandler` 记录的真实示例。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: What are beans?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Bean？
- en: In Spring, beans are simply Java objects that are created, managed, and configured
    by the Spring **IoC (Inversion of Control)** container. Think of them as the building
    blocks of your application. When you define a class as a bean, you’re telling
    Spring to take responsibility for instantiating it, handling its dependencies,
    and managing its lifecycle. You can define beans using annotations like `@Component`
    , `@Service` , or `@Bean` , or through XML configuration. Once registered, these
    beans can be automatically “wired” together, meaning Spring will inject dependencies
    between them without you having to manually create and connect objects. This approach
    makes your code more modular, easier to test, and less coupled.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 中，bean 是由 Spring **IoC（控制反转）** 容器创建、管理和配置的简单 Java 对象。把它们想象成您应用程序的构建块。当您将一个类定义为
    bean 时，您是在告诉 Spring 负责实例化它、处理其依赖关系以及管理其生命周期。您可以使用 `@Component`、`@Service` 或 `@Bean`
    等注解定义 bean，或通过 XML 配置。一旦注册，这些 bean 可以自动“连接”在一起，这意味着 Spring 将在它们之间注入依赖关系，而无需您手动创建和连接对象。这种方法使您的代码更加模块化，更容易测试，并且耦合度更低。
- en: Viewing trace data
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看跟踪数据
- en: Once your application is instrumented with Micrometer Tracing, you can view
    the trace data in a distributed tracing tool like Zipkin or Jaeger. These tools
    allow you to visualize traces and spans, helping you diagnose performance bottlenecks
    or failures across services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序使用 Micrometer Tracing 进行了配置，您就可以在分布式跟踪工具（如 Zipkin 或 Jaeger）中查看跟踪数据。这些工具允许您可视化跟踪和跨度，帮助您诊断跨服务的性能瓶颈或故障。
- en: 'Just to understand the difference between traces and spans:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了理解跟踪和跨度的区别：
- en: The trace would include multiple spans representing the various services and
    operations involved in a request.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪将包括多个跨度，代表请求中涉及的各个服务和操作。
- en: Each span includes timing data, enabling you to identify slow services or problematic
    operations.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个跨度都包含时间数据，使您能够识别慢速服务或问题操作。
- en: When Micrometer Tracing is implemented in a Spring Boot application, the logs
    will include additional fields such as `traceId` and `spanId` . These fields help
    you correlate logs across services in a distributed system. The `traceId` remains
    the same for the entire lifecycle of a request across different services, while
    each service or operation within a service gets its own `spanId` .
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Micrometer Tracing 在 Spring Boot 应用程序中实现时，日志将包括额外的字段，如 `traceId` 和 `spanId`。这些字段有助于您在分布式系统中关联跨服务的日志。`traceId`
    在跨不同服务的整个请求生命周期中保持不变，而每个服务或服务内的操作都获得自己的 `spanId`。
- en: 'Here is an example of how the logs will look with Micrometer Tracing enabled
    and properly configured, calling the Products API from the Order Management API.
    It follows the logging pattern that we defined in the `applications.yml` file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了启用并正确配置 Micrometer Tracing 后的日志外观，从订单管理 API 调用产品 API。它遵循我们在 `applications.yml`
    文件中定义的日志模式：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These are the elements contained in this log:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这条日志中包含以下元素：
- en: '`2025-03-19T16:45:39.207-03:00` : **Timestamp** – When this log entry was created'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2025-03-19T16:45:39.207-03:00` : **时间戳** – 此日志条目创建的时间'
- en: '`INFO` : **Log level** – Indicates an informational message (not an error)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO` : **日志级别** – 表示信息性消息（非错误）'
- en: '`[order-management-api,67db1edfd85f42d21368a69936519fd1,1368a69936519fd1]`
    : Defined pattern logging, containing:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[order-management-api,67db1edfd85f42d21368a69936519fd1,1368a69936519fd1]`
    : 定义了模式日志，包含：'
- en: '**Service name** – Identifies which microservice generated the log'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务名称** – 识别哪个微服务生成了日志'
- en: '**Trace Id** – Unique identifier tracking the request across all services'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trace Id** – 跨所有服务跟踪请求的唯一标识符'
- en: '**Span Id** – Identifies this specific operation within the trace'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Span Id** – 识别在跟踪中此特定操作'
- en: '`24477` : **Process ID** – The operating system’s identifier for this application
    instance'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`24477` : **进程 ID** – 操作系统为此应用程序实例的标识符'
- en: '`---` : **Separator** – Visual divider in the log format'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`---` : **分隔符** – 日志格式中的视觉分隔线'
- en: '`[order-management-api]` : **Application name** – Repeats the service name
    for readability'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[order-management-api]` : **应用程序名称** – 为了可读性重复服务名称'
- en: '`[nio-8090-exec-1]` : **Thread name** – The specific execution thread handling
    this request'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[nio-8090-exec-1]` : **线程名称** – 处理此请求的特定执行线程'
- en: '`[67db1edfd85f42d21368a69936519fd1-1368a69936519fd1]` : **Correlation ID**
    – Combined `traceId-spanId` for easy request tracking'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[67db1edfd85f42d21368a69936519fd1-1368a69936519fd1]` : **关联 ID** – 简化请求跟踪的
    `traceId-spanId` 组合'
- en: '`c.p.o.a.o.rest.ProductsQueryUseCaseImpl` : **Logger name** – The class that
    generated this log (shortened)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c.p.o.a.o.rest.ProductsQueryUseCaseImpl`：**记录器名称** – 生成此日志的类（已缩短）'
- en: '`Getting product with id AA00001` : **Log message** – Simple text description
    of the operation being performed, showing the product ID being requested'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`获取ID为AA00001的产品`：**日志消息** – 对正在执行的操作的简单文本描述，显示请求的产品ID'
- en: This is how Micrometer Tracing enables the logs in the application to make it
    possible to track requests between applications.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Micrometer Tracing如何使应用程序中的日志能够跟踪应用程序之间的请求。
- en: But if you want to have even more details in your logs, you will get them from
    the `LogSpanHandler` that we configured along with the beans in the configuration
    section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在日志中获取更多详细信息，你将可以从我们配置的`LogSpanHandler`以及配置部分中的bean中获取。
- en: 'Let us look at a specific log generated by the `LogSpanHandler` :'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看由`LogSpanHandler`生成的特定日志：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This specific log is the one generated by the `LogSpanHandler` configuration
    that adds all the information from the trace context.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这条特定的日志是由`LogSpanHandler`配置生成的，它添加了来自跟踪上下文的所有信息。
- en: The beginning of this log follows the same structure defined in the logging
    pattern shown previously, but what differs here is the information contained in
    its body, which is in JSON format.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这条日志的开头遵循之前显示的日志模式中定义的相同结构，但这里不同的是其体中的信息，它是以JSON格式表示的。
- en: 'Let us understand each of the elements inside of this JSON body generated by
    the `LogSpanHandler` and how they can help us in the observability of our applications:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解由`LogSpanHandler`生成的JSON体中的每个元素以及它们如何帮助我们观察应用程序：
- en: '`traceId` : **Distributed trace identifier** – Links all spans across services
    for this request'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceId`：**分布式跟踪标识符** – 将此请求的所有跨服务span链接起来'
- en: '`parentId` : **Parent span ID** – This field identifies the parent span from
    which the current span originated. If the current service or operation was triggered
    by another service, the parent span ID helps trace the hierarchy of calls between
    services.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parentId`：**父span ID** – 此字段标识了当前span起源的父span。如果当前服务或操作是由其他服务触发的，则父span ID有助于追踪服务之间的调用层次结构。'
- en: '`id` : **Span ID** – Unique identifier for this specific operation'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：**Span ID** – 此特定操作的唯一标识符'
- en: '`kind` : **Span type** – `"CLIENT"` means the outbound request to another service'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：**Span类型** – `"CLIENT"`表示对另一个服务的出站请求'
- en: '`name` : **Operation name** – Describes what action was performed'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：**操作名称** – 描述执行了什么动作'
- en: '`timestamp` : **Start time** – When this operation began (in microseconds)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`：**开始时间** – 此操作开始的时间（以微秒为单位）'
- en: '`duration` : **Execution time** – How long the operation took (6.246ms)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`：**执行时间** – 操作花费的时间（6.246ms）'
- en: '`localEndpoint` : **Service information** – Details about the originating service'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localEndpoint`：**服务信息** – 关于起源服务的详细信息'
- en: '`tags` : Contextual metadata containing'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：包含上下文元数据的'
- en: '**Application name** – Service identifier'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序名称** – 服务标识符'
- en: '**Client name** – Target server hostname'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端名称** – 目标服务器主机名'
- en: '**Exception** – Error status (none means successful)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常** – 错误状态（无表示成功）'
- en: '**HTTP URL** – Full URL that was called'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP URL** – 被调用的完整URL'
- en: '**Method** – HTTP verb used ( `GET` )'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法** – 使用的HTTP动词（`GET`）'
- en: '**Outcome** – Result category ( `SUCCESS` )'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果** – 结果类别（`SUCCESS`）'
- en: '**Status** – HTTP response code ( `200 = OK` )'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态** – HTTP响应代码（`200 = OK`）'
- en: '**URI** – Request path pattern with path variables'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI** – 带有路径变量的请求路径模式'
- en: If you noticed, we talked about `parentSpanId` in this example. Let us understand
    better how this relates to `spanId` and how this can be useful in monitoring the
    performance of distributed systems.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我们在本例中提到了`parentSpanId`。让我们更好地了解它与`spanId`之间的关系以及它在监控分布式系统性能中的有用性。
- en: Understanding parentSpanId and spanId
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解parentSpanId和spanId
- en: In distributed tracing, every request generates a trace, which consists of multiple
    spans. A span represents a single unit of work, such as a service call, database
    query, or a specific business process within a service. Each span includes a unique
    identifier, called the `spanId` , and a `parentSpanId` that links it to the span
    from which it originated. This parent-child relationship helps to visualize how
    requests pro pagate through different services in a distributed system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式跟踪中，每个请求都会生成一个跟踪，该跟踪由多个span组成。span代表单个工作单元，例如服务调用、数据库查询或服务内部的具体业务流程。每个span都包含一个唯一的标识符，称为`spanId`，以及一个`parentSpanId`，它将其链接到其起源的span。这种父子关系有助于可视化请求如何在分布式系统中的不同服务之间传播。
- en: In sum, a `spanId` is a unique identifier for the current operation or service,
    and `parentSpanId` is the `spanId` of the calling operation or service. This field
    links spans together, showing which service called another.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`spanId`是当前操作或服务的唯一标识符，而`parentSpanId`是调用操作或服务的`spanId`。此字段将span连接起来，显示哪个服务调用了另一个服务。
- en: Using these IDs, tracing tools like Zipkin or Jaeger can display a complete
    timeline of the trace, revealing the structure and timing of each request across
    services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些ID，像Zipkin或Jaeger这样的跟踪工具可以显示跟踪的完整时间线，揭示每个请求在服务之间的结构和时间。
- en: To visualize the relationship between `spanId` and `parentSpanId` , let’s walk
    through an example trace for a user registration request in an e-commerce application,
    where each service involved in the trace has its own `spanId` and, if applicable,
    a `parentSpanId` .
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化`spanId`和`parentSpanId`之间的关系，让我们通过一个电子商务应用中用户注册请求的示例跟踪来进行分析，其中每个参与跟踪的服务都有自己的`spanId`，如果适用，还有一个`parentSpanId`。
- en: An API gateway receives the initial request and generates a `traceId` and `spanId`
    .
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关接收初始请求并生成`traceId`和`spanId`。
- en: The `User` service handles the user registration, with a span linked to the
    API gateway’s `spanId` as its `parentSpanId` .
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户`服务处理用户注册，其span与API网关的`spanId`链接作为其`parentSpanId`。'
- en: A `Notification` service sends a welcome email to the user. This service’s span
    has the `spanId` of the `User` service as its `parentSpanId` .
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`通知`服务向用户发送欢迎邮件。此服务的span的`spanId`是`用户`服务的`parentSpanId`。'
- en: 'Below is a simplified visualization of what this trace might look like in a
    tool like Jaeger:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这种跟踪在Jaeger等工具中可能呈现的简化可视化：
- en: '| **Span Name** | **Service** | **spanId** | **parentSpanId** | **Start Time**
    | **Duration** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **Span名称** | **服务** | **spanId** | **parentSpanId** | **开始时间** | **持续时间**
    |'
- en: '| `register_user` | API Gateway | `span1` | - | 0ms | 15ms |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `register_user` | API网关 | `span1` | - | 0ms | 15ms |'
- en: '| `create_user_record` | User | `span2` | `span1` | 5ms | 40ms |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `create_user_record` | 用户 | `span2` | `span1` | 5ms | 40ms |'
- en: '| `send_email` | Notification | `span3` | `span2` | 25ms | 30ms |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `send_email` | 通知 | `span3` | `span2` | 25ms | 30ms |'
- en: 'In this visualization:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可视化中：
- en: The `register_user` span from the API gateway is the root of the trace. It has
    no `parentSpanId` because it starts the trace.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_user` span来自API网关是跟踪的根。它没有`parentSpanId`，因为它启动了跟踪。'
- en: The `User Service` span ( `create_user_record` ) is a child of the `API Gateway`
    span, so it references `span1` as its `parentSpanId` .
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户服务`span（`create_user_record`）是`API网关`span的子span，因此它引用`span1`作为其`parentSpanId`。'
- en: The `Notification` service span ( `send_email` ) is a child of the `User Service`
    span and has `span2` as its `parentSpanId` , indicating it was triggered by the
    user creation process.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通知`服务span（`send_email`）是`用户服务`span的子span，其`parentSpanId`为`span2`，表示它是由用户创建过程触发的。'
- en: 'The tracing tool displays the parent-child hierarchy as a timeline to visualize
    request propagation. Below is a diagram that matches this hierarchy, showing how
    each service relates in time:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪工具将父子层级显示为时间线，以可视化请求的传播。下面是匹配这一层级的图表，显示每个服务在时间上的关系：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a trace visualization tool:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪可视化工具中：
- en: The `API Gateway` span ( `span1` ) initiates the request.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API网关`的span（`span1`）启动请求。'
- en: '`User Service` ( `span2` ) begins shortly after `API Gateway` , and it takes
    more time as it performs operations like database insertion, for example.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户服务`（`span2`）在`API网关`之后不久开始，由于执行数据库插入等操作，它花费了更多时间。'
- en: '`Notification Service` ( `span3` ) starts after `User Service` completes the
    user creation. The duration of each span indicates how long each operation took.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通知服务`（`span3`）在`用户服务`完成用户创建后开始。每个span的持续时间表示每个操作花费了多长时间。'
- en: Parent-child hierarchy insights
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父子层级洞察
- en: 'This trace hierarchy is useful for:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种跟踪层次结构对于：
- en: '**Identifying bottlenecks** : If `User Service` took unusually long, it would
    appear as a longer bar in the timeline, prompting an investiga tion.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别瓶颈**：如果`用户服务`运行时间异常长，它会在时间线上显示为一个更长的条形，从而引发调查。'
- en: '**Tracing errors** : If an error occurred in `Notification Service` , you could
    see it in the trace and quickly trace it back to the originating request from
    `User Service` .'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追踪错误**：如果在`通知服务`中发生错误，你可以在跟踪中看到它，并快速将其追踪回来自`用户服务`的原始请求。'
- en: '**Understanding dependencies** : By looking at the parent-child structure,
    you can see how each service depends on others and the sequence of operations.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解依赖关系**：通过查看父子结构，你可以看到每个服务如何依赖于其他服务以及操作的顺序。'
- en: This visualization and the `spanId` and `parentSpanId` relationship allow software
    engineers, architects, and system analysts to understand the flow and timeline
    of each request across multiple services, helping optimize performance, troubleshoot
    issues, and gain insights into the system’s behavior.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化和`spanId`与`parentSpanId`的关系允许软件工程师、架构师和系统分析师理解多个服务之间每个请求的流程和时间线，有助于优化性能、调试问题和深入了解系统的行为。
- en: Logs across multiple services
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个服务之间的日志
- en: When a request flows through multiple services in a distributed system, each
    service logs its part of the request independently. By correlating these logs
    through unique identifiers like `traceId` and `spanId` , we can connect individual
    logs across services to form a complete picture of the request’s journey. This
    end-to-end visibility is crucial for understanding how services interact, identifying
    bottlenecks, and troubleshooting errors.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求在分布式系统中的多个服务之间流动时，每个服务都会独立地记录其请求的一部分。通过使用唯一的标识符，如`traceId`和`spanId`，我们可以将跨服务的单个日志关联起来，形成一个完整的请求旅程图。这种端到端的可见性对于理解服务之间的交互、识别瓶颈和调试错误至关重要。
- en: 'In this example, a User Registration request passes through three services:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户注册请求通过了三个服务：
- en: '**API Gateway** : Receives the initial request and routes it to the appropriate
    backend service.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**API网关**：接收初始请求并将其路由到适当的后端服务。'
- en: '**User Service** : Processes the registration by creating a user record in
    the database.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户服务**：通过在数据库中创建用户记录来处理注册。'
- en: '**Notification Service** : Sends a welcome email to the user upon successful
    registration.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通知服务**：在成功注册后向用户发送欢迎邮件。'
- en: Each service logs its part of the request using the same `traceId` to correlate
    logs. The `spanId` is unique within each service, while the `parentSpanId` links
    it back to the calling service.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务使用相同的`traceId`来关联其请求的一部分日志。`spanId`在每个服务内是唯一的，而`parentSpanId`将其链接回调用服务。
- en: 'The diagram below shows how the request moves through each service, with corresponding
    logs identified by numbers that correlate to the example logs below:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了请求如何通过每个服务，相应的日志通过编号标识，这些编号与下面的示例日志相关联：
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each log entry shown below is marked with a number corresponding to the steps
    in the diagram above. By following `traceId` , `spanId` , and `parentSpanId` ,
    we can see how each service is connected within the trace, enabling us to reconstruct
    the request’s journey.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的每个日志条目都标有与上图步骤相对应的编号。通过跟踪`traceId`、`spanId`和`parentSpanId`，我们可以看到每个服务在跟踪中的连接方式，使我们能够重建请求的旅程。
- en: Next, let us see examples of logs on each service this trace is going through.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个跟踪正在通过每个服务的日志示例。
- en: API Gateway log
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API网关日志
- en: When the API gateway receives the request, it generates a new `traceId` (A)
    and its own `spanId` (1).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当API网关接收到请求时，它会生成一个新的`traceId`（A）和它自己的`spanId`（1）。
- en: '[PRE30]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: User Service log
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户服务日志
- en: The User Service processes the registration, using the `traceId (A)` to connect
    it to the original request. The `User Service` log entry has a unique `spanId
    (2)` and references the API Gateway’s `spanId (1)` as its `parentSpanId` .
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 用户服务通过使用`traceId (A)`将其与原始请求连接起来来处理注册。`用户服务`的日志条目有一个唯一的`spanId (2)`，并将其作为`parentSpanId`引用API网关的`spanId
    (1)`。
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notification Service log
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知服务日志
- en: After the User Service completes the user creation, it triggers the Notification
    Service to send a welcome email. The `Notification Service` log entry includes
    the `traceId` (A) to maintain continuity, generates its own `spanId` (3), and
    uses the User Service’s `spanId` (2) as its `parentSpanId` .
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户服务完成用户创建后，它会触发通知服务发送欢迎邮件。`通知服务`的日志条目包括`traceId`（A）以保持连续性，生成它自己的`spanId`（3），并使用用户服务的`spanId`（2）作为其`parentSpanId`。
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, the `traceId` (A) remains the same across all services, linking
    the logs together to represent the entire request flow. Each log’s `spanId` and
    `parentSpanId` establish a parent-child relationship, showing how each service
    is connected in the sequence. Here’s how these logs work together:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`traceId`（A）在所有服务中保持不变，将日志链接在一起，以表示整个请求流程。每个日志的 `spanId` 和 `parentSpanId`
    建立了父子关系，显示了每个服务在序列中的连接方式。以下是这些日志如何协同工作：
- en: '**Log 1 (API Gateway)** : Initiates the request with `traceId` (A) and `spanId`
    (1).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志 1（API 网关）**：使用 `traceId`（A）和 `spanId`（1）启动请求。'
- en: '**Log 2 (User Service)** : Continues the request, referencing the API Gateway’s
    `spanId` (1) with its `parentSpanId` and creating a new `spanId` (2) for itself.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志 2（用户服务）**：继续请求，通过其 `parentSpanId` 引用 API 网关的 `spanId`（1），并为自身创建一个新的 `spanId`（2）。'
- en: '**Log 3 (Notification Service)** : Completes the flow by linking back to the
    User Service’s `spanId` (2) and creating its own `spanId` (3).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志 3（通知服务）**：通过链接回用户服务的 `spanId`（2）并创建自己的 `spanId`（3）来完成流程。'
- en: Using the combination of `traceId` , `spanId` , and `parentSpanId` , we can
    follow the lifecycle of the user registration request as it moves from service
    to service, providing a clear and structured view of the request’s journey.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `traceId`、`spanId` 和 `parentSpanId` 的组合，我们可以跟踪用户注册请求的生命周期，随着它从服务到服务的移动，提供请求旅程的清晰和结构化视图。
- en: 'The logs are useful in the following ways:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 日志在以下方面很有用：
- en: '**End-to-end traceability** : By searching for logs with the same `traceId`
    , you can trace a request across different services (API Gateway, User Service,
    and Notification Service) and see how the request was handled at each step.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端可追溯性**：通过搜索具有相同 `traceId` 的日志，您可以在不同的服务（API 网关、用户服务和通知服务）之间跟踪请求，并查看每个步骤如何处理请求。'
- en: '**Service dependencies** : The `parentSpanId` helps you understand how services
    are connected. In the example above, the Notification service was called by the
    User service, which was triggered by the API Gateway. The logs show the hierarchy
    of calls.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务依赖**：`parentSpanId` 帮助您理解服务之间的连接方式。在上面的示例中，通知服务被用户服务调用，而用户服务是由 API 网关触发的。日志显示了调用层次结构。'
- en: '**Performance insights** : Comparing the timestamps across spans can give you
    insights into performance bottlenecks. For instance, you can measure how much
    time each service took to handle the request by comparing the timestamps.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能洞察**：比较跨度之间的时间戳可以为您提供性能瓶颈的见解。例如，您可以通过比较时间戳来衡量每个服务处理请求所需的时间。'
- en: Micrometer Tracing enriches your logs with essential trace and span data that
    allows you to track requests across distributed systems. This traceability simplifies
    troubleshooting and helps you visualize the flow of requests, making it easier
    to detect performance issues or service failures. By integrating this data with
    tools like Zipkin or Jaeger, you can also visualize traces in real time, further
    enhancing your observability strategy.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer 跟踪通过添加必要的跟踪和跨度数据丰富您的日志，这些数据允许您跟踪分布式系统中的请求。这种可追溯性简化了故障排除，并帮助您可视化请求流程，使其更容易检测性能问题或服务故障。通过将此数据与
    Zipkin 或 Jaeger 等工具集成，您还可以实时可视化跟踪，进一步增强您的可观察性策略。
- en: Visualizing traces with Zipkin
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Zipkin 可视化跟踪
- en: 'To be able to run a local Zipkin instance on your machine, create the following
    `docker-compose.yml` file, which will automatically download and configure your
    local Zipkin instance with the following content:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的机器上运行本地 Zipkin 实例，创建以下 `docker-compose.yml` 文件，该文件将自动下载并配置您的本地 Zipkin 实例，内容如下：
- en: '[PRE33]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This file defines from where we are getting the Docker image and the version,
    that is the latest available. Also, we will run this at memory, using the default
    port `9411` .
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了我们从哪里获取 Docker 镜像及其版本，即最新可用的版本。我们还将使用默认端口 `9411` 在内存中运行此实例。
- en: 'To run this container, you need Docker installed on your system. Once it is
    installed, open a console in the same directory where this file is saved and run
    the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此容器，您需要在系统上安装 Docker。安装后，在保存此文件的同一目录中打开控制台，并运行以下命令：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the application is running, go to your local running Zipkin’s UI ( `http://localhost:9411`
    ) to view the traces. You should see a graphical representation of the trace,
    showing the `traceId` , `spanId` , and the parent-child relationships across services.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行后，前往您本地运行的 Zipkin 的 UI（`http://localhost:9411`）以查看跟踪信息。您应该看到一个跟踪的图形表示，显示
    `traceId`、`spanId` 以及服务之间的父子关系。
- en: '![Figure 9.1 – Complete trace journey in Zipkin dashboard with Micrometer](img/B21843_09_1.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 使用Micrometer在Zipkin仪表板中完成完整的追踪旅程](img/B21843_09_1.png)'
- en: Figure 9.1 – Complete trace journey in Zipkin dashboard with Micrometer
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 使用Micrometer在Zipkin仪表板中完成完整的追踪旅程
- en: Adding custom spans
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义跨度
- en: In addition to the automatic tracing of HTTP requests, you may want to create
    custom spans to trace specific operations within your services. For example, you
    can trace important business logic or database queries.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动追踪HTTP请求外，您可能还想创建自定义跨度来追踪服务内的特定操作。例如，您可以追踪重要的业务逻辑或数据库查询。
- en: 'To create custom spans, inject the `Tracer` into your service and use it to
    manually create and manage spans:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义跨度，将`Tracer`注入到您的服务中，并使用它手动创建和管理跨度：
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we use `Tracer` to create a custom span called `createUser`
    , which tracks the execution of the user creation process. The span is manually
    started with `start()` and completed with `end()` . We also ensure that any exceptions
    are captured in the span by calling `newUserSpan.error(e)` .
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用`Tracer`创建一个名为`createUser`的自定义跨度，该跨度跟踪用户创建过程的执行。跨度通过调用`start()`手动启动，并通过调用`end()`完成。我们还通过调用`newUserSpan.error(e)`确保任何异常都被捕获在跨度中。
- en: Next, let us understand how we can extract metrics from the tracing data and
    how this can help us monitor the whole application environment behavior.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解如何从追踪数据中提取指标以及这如何帮助我们监控整个应用程序环境的行为。
- en: Metrics from tracing data
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪数据的指标
- en: Metrics for RESTful web services are essential for evaluating and optimizing
    the performance of these services. These metrics provide insights into how efficiently
    APIs handle requests, process data, and deliver responses.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful网络服务，指标对于评估和优化这些服务的性能至关重要。这些指标提供了关于API如何高效处理请求、处理数据和提供响应的见解。
- en: This helps in ensuring that RESTful web services operate smoothly, providing
    a better user experience and meeting business objectives.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于确保RESTful网络服务平稳运行，提供更好的用户体验并满足业务目标。
- en: With Micrometer Tracing in place, you can extract meaningful metrics from your
    trace data. Metrics give you quantitative insights into your API’s performance
    and health.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在Micrometer追踪到位后，您可以从追踪数据中提取有意义的指标。指标为您提供了API性能和健康状况的定量洞察。
- en: Metrics like latency, throughput, and error rates are key to understanding how
    your REST API performs under load. These metrics help detect slow services, overloaded
    endpoints, or frequent errors that need to be addressed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 指标如延迟、吞吐量和错误率是理解您的REST API在负载下表现的关键。这些指标有助于检测缓慢的服务、过载的端点或需要解决的频繁错误。
- en: Types of metrics to monitor
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要监控的指标类型
- en: 'Some common metrics to track in REST APIs include:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API中跟踪的一些常见指标包括：
- en: '**Request duration** : How long does it take for the API to respond?'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求持续时间**：API响应需要多长时间？'
- en: '**Request count** : The number of requests served over a period.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求计数**：在一定时期内服务的请求数量。'
- en: '**Success/failure rate** : Percentage of successful vs. failed requests.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功/失败率**：成功请求与失败请求的百分比。'
- en: '**HTTP error codes** : Count of `4xx` and `5xx` responses.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP错误代码**：`4xx`和`5xx`响应的计数。'
- en: 'You can configure Micrometer to track these metrics automatically. For example,
    to track request duration, add the following configuration:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置Micrometer自动跟踪这些指标。例如，要跟踪请求持续时间，请添加以下配置：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Metrics examples** :'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标示例**：'
- en: '**Latency** : Average time it takes for a request to complete (e.g., 200ms).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：请求完成所需平均时间（例如，200ms）。'
- en: '**Throughput** : The system processes an average of 150 requests per second
    during peak hours.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：高峰时段系统平均每秒处理150个请求。'
- en: '**Error Rate** : Percentage of requests that fail (e.g., 5% of requests return
    a 500 error).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误率**：失败请求的百分比（例如，5%的请求返回500错误）。'
- en: Metrics can help identify performance bottlenecks. For instance, if one of your
    API endpoints consistently has a higher latency than others, it might indicate
    a need to optimize database queries, improve caching, or refactor code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 指标有助于识别性能瓶颈。例如，如果您的API端点之一始终比其他端点具有更高的延迟，这可能表明需要优化数据库查询、改进缓存或重构代码。
- en: For example, if the `/api/v1/users` endpoint shows an average response time
    of 500ms, but other endpoints respond in under 100ms, you can use tracing data
    to find out where the delay occurs (e.g., in a database query or a third-party
    API call).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`/api/v1/users`端点显示平均响应时间为500ms，而其他端点响应时间在100ms以下，您可以使用追踪数据找出延迟发生的位置（例如，在数据库查询或第三方API调用中）。
- en: Viewing metrics with Micrometer
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Micrometer查看指标
- en: Micrometer integrates with Prometheus and Grafana to visualize your metrics
    in real-time dashboards. This allows you to create custom views and alerts based
    on the performance of your API.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer与Prometheus和Grafana集成，以实时仪表板可视化您的指标。这允许您根据API的性能创建自定义视图和警报。
- en: For example, in Grafana, you can create a dashboard that visualizes the latency
    of your API endpoints over time using time series graphs. These graphs help you
    spot trends and optimize performance by highlighting periods of increased latency,
    which might indicate bottlenecks or resource constraints. For instance, you can
    use a line chart to display how the average response time of a specific endpoint
    changes over time, making it easier to identify patterns or anomalies.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Grafana中，您可以使用时间序列图创建一个仪表板，以可视化API端点随时间变化的延迟。这些图表有助于您发现趋势并通过突出显示延迟增加的时期来优化性能，这可能会表明瓶颈或资源限制。例如，您可以使用折线图显示特定端点的平均响应时间随时间的变化，从而更容易识别模式或异常。
- en: Additionally, Grafana supports a variety of other visualizations that can be
    used to display metrics such as request counts, success/failure rates, and HTTP
    error codes. For example, you can use bar charts to compare the number of successful
    versus failed requests over a given period, or pie charts to show the distribution
    of different HTTP status codes returned by your API.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Grafana还支持各种其他可视化，可用于显示指标，如请求数量、成功/失败率和HTTP错误代码。例如，您可以使用柱状图比较给定期间成功请求与失败请求的数量，或使用饼图显示API返回的不同HTTP状态代码的分布。
- en: '![Figure 9.2 – Metrics displayed in a Grafana dashboard](img/B21843_09_2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 在Grafana仪表板中显示的指标](img/B21843_09_2.png)'
- en: Figure 9.2 – Metrics displayed in a Grafana dashboard
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 在Grafana仪表板中显示的指标
- en: Now that we have mastered Micrometer, let us look at another option for monitoring
    and observability, which is also open source and widely used in the market, OpenTelemetry.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了Micrometer，让我们来看看另一个用于监控和可观察性的选项，它也是开源的，并在市场上广泛使用，那就是OpenTelemetry。
- en: OpenTelemetry for monitoring and observability
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenTelemetry用于监控和可观察性
- en: OpenTelemetry is an open-source, vendor-neutral observability framework that
    provides tools to collect telemetry data (logs, metrics, and traces) from your
    applications. It is a comprehensive standard designed to provide deep insights
    into distributed systems and is widely supported across languages and platforms.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry是一个开源、供应商中立的可观察性框架，它为您的应用程序提供收集遥测数据（日志、指标和跟踪）的工具。这是一个全面的标准化设计，旨在为分布式系统提供深入洞察，并且跨语言和平台得到广泛支持。
- en: OpenTelemetry unifies logs, metrics, and traces into one framework, providing
    a standardized way to instrument your services. It works with a variety of backends
    (like Prometheus, Jaeger, Zipkin, and Grafana) and supports distributed tracing
    across microservices.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry将日志、指标和跟踪统一到一个框架中，提供了一个标准化的方式来对你的服务进行仪表化。它与各种后端（如Prometheus、Jaeger、Zipkin和Grafana）协同工作，并支持跨微服务的分布式跟踪。
- en: OpenTelemetry helps you track the complete lifecycle of a request as it moves
    through multiple services, providing valuable insights into service performance,
    latency, and bottlenecks.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry帮助您跟踪请求在其通过多个服务移动时的完整生命周期，提供了关于服务性能、延迟和瓶颈的宝贵见解。
- en: 'OpenTelemetry consists of the following components:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry由以下组件组成：
- en: '**Traces** : Monitor the journey of requests across multiple services.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：监控请求在多个服务之间的旅程。'
- en: '**Metrics** : Collect quantitative data on service performance, such as response
    times and error rates.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**：收集关于服务性能的定量数据，如响应时间和错误率。'
- en: '**Logs** : Record discrete events within the system, such as errors or warnings.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：记录系统中的离散事件，例如错误或警告。'
- en: Using OpenTelemetry in Spring Boot
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Spring Boot中使用OpenTelemetry
- en: OpenTelemetry provides a standardized way to collect, process, and export telemetry
    data (logs, metrics, and traces) from your application. In a Spring Boot application,
    OpenTelemetry can be integrated to automatically capture tracing data across your
    services. Once integrated, this data can be exported to observability tools like
    Jaeger, Zipkin, or Grafana to visualize and monitor the flow of requests in real
    time.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry提供了一个标准化的方式来收集、处理和导出应用程序的遥测数据（日志、指标和跟踪）。在Spring Boot应用程序中，OpenTelemetry可以集成以自动捕获服务之间的跟踪数据。一旦集成，这些数据就可以导出到如Jaeger、Zipkin或Grafana等可观察性工具，以实时可视化并监控请求的流动。
- en: In this section, we’ll go through the steps to set up OpenTelemetry in a Spring
    Boot application, validate that tracing is working, and review sample logs showing
    the output after implementing OpenTelemetry.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Spring Boot应用程序中设置OpenTelemetry的步骤，验证跟踪是否正常工作，并查看实现OpenTelemetry后的示例日志输出。
- en: '**Add OpenTelemetry dependencies** : To integrate OpenTelemetry with Spring
    Boot, you’ll need the OpenTelemetry SDK along with specific instrumentation dependencies
    for Spring and HTTP clients. Add the following dependencies to your `pom.xml`
    :'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加OpenTelemetry依赖项**：要将OpenTelemetry与Spring Boot集成，您需要OpenTelemetry SDK以及针对Spring和HTTP客户端的特定仪表依赖项。请将以下依赖项添加到您的`pom.xml`中：'
- en: 'Under the dependency management tag:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项管理标签下：
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After that, proceed to add the following dependencies under the dependencies
    tag:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在依赖项标签下继续添加以下依赖项：
- en: '[PRE38]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let us understand what each of these dependencies are used for:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个这些依赖项的用途：
- en: '`opentelemetry-instrumentation-bom` :'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opentelemetry-instrumentation-bom`：'
- en: A Bill of Materials (BOM) that ensures version alignment across all OpenTelemetry
    dependencies.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个物料清单（BOM），确保所有OpenTelemetry依赖项的版本一致性。
- en: Helps manage compatible versions between OpenTelemetry components and their
    transitive dependencies.
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助管理OpenTelemetry组件及其传递依赖项之间的兼容版本。
- en: Must be imported before other BOMs (like spring-boot-dependencies) when using
    Maven like we are doing here.
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Maven（如我们在这里所做的那样）时，必须在其他BOM（如spring-boot-dependencies）之前导入。
- en: '`micrometer-tracing-bridge-otel` :'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`micrometer-tracing-bridge-otel`：'
- en: Bridges Micrometer’s Observation API to OpenTelemetry’s tracing system.
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Micrometer的Observation API桥接到OpenTelemetry的跟踪系统中。
- en: Facilitates the propagation of trace context and spans between Micrometer and
    OpenTelemetry.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进Micrometer和OpenTelemetry之间跟踪上下文和跨度之间的传播。
- en: Essential component for enabling distributed tracing with OpenTelemetry in Spring
    Boot applications.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序中启用分布式跟踪的OpenTelemetry的必要组件。
- en: '`opentelemetry-spring-boot-starter` :'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opentelemetry-spring-boot-starter`：'
- en: Provides auto-configuration for OpenTelemetry in Spring Boot applications
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Spring Boot应用程序提供OpenTelemetry的自动配置。
- en: Includes built-in instrumentation for many Spring Boot features
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含许多Spring Boot功能的内置仪表
- en: Simplifies the process of instrumenting a Spring Boot application with minimal
    configuration
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化了使用最少配置对Spring Boot应用程序进行仪表化的过程。
- en: Particularly useful for Spring Boot Native image applications or when seeking
    reduced startup overhead compared to the Java agent approach
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别适用于Spring Boot原生图像应用程序或与Java代理方法相比寻求减少启动开销的情况。
- en: '`opentelemetry-exporter-otlp` :'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opentelemetry-exporter-otlp`：'
- en: Implements the OpenTelemetry Protocol (OTLP) exporter for sending telemetry
    data
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现OpenTelemetry协议（OTLP）导出器以发送遥测数据。
- en: Allows applications to export collected tracing data to OpenTelemetry Collectors
    or other backends
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许应用程序将收集的跟踪数据导出到OpenTelemetry收集器或其他后端。
- en: Supports standardized telemetry data delivery between observability tools
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持标准化遥测数据在可观察性工具之间的交付。
- en: Can be configured to use either HTTP or gRPC transport protocols
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以配置为使用HTTP或gRPC传输协议。
- en: '`spring-boot-starter-actuator` :'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-actuator`：'
- en: Adds production-grade monitoring and management features to Spring Boot applications.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Spring Boot应用程序添加生产级监控和管理功能。
- en: Provides dependency management and auto-configuration for Micrometer (metrics
    and tracing)
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Micrometer（指标和跟踪）提供依赖项管理和自动配置。
- en: Required foundation for both metrics and tracing capabilities in Spring Boot.
    This is mandatory for any tracing, either only with Micrometer or along with OpenTelemetry
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot中指标和跟踪能力的必要基础。这对于任何跟踪都是强制性的，无论是仅使用Micrometer还是与OpenTelemetry一起使用。
- en: Exposes endpoints for application health, metrics, and other operational data
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供应用程序健康、指标和其他操作数据的端点。
- en: '**Configuring OpenTelemetry into the application** : Let us have the following
    properties in the `application.yml` .'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将OpenTelemetry配置到应用程序中**：让我们在`application.yml`中设置以下属性。'
- en: First, we are going to define the URL where OpenTelemetry will send the traces,
    and in this case, this is the path and exposed port from Jaeger that we are going
    to run from the `docker-compose` file that you will define next.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将定义OpenTelemetry将发送跟踪的URL，在这种情况下，这是我们将在您接下来定义的`docker-compose`文件中运行的Jaeger的路径和暴露的端口。
- en: '[PRE39]'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Under the `otel` tag, we are setting OpenTelemetry to not export logs or metrics,
    only traces. It will also work without these configurations but will throw multiple
    exceptions in the application log because Jaeger only reads traces, not logs or
    metrics.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`otel`标签下，我们将OpenTelemetry设置为不导出日志或指标，只导出跟踪。在没有这些配置的情况下它也将正常工作，但会在应用程序日志中抛出多个异常，因为Jaeger只读取跟踪，不读取日志或指标。
- en: If you are going to use another backend tool like Grafana that consumes the
    logs and the metrics, instead of setting it to none, you should add the proper
    configuration for the backend that you are going to use.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您打算使用像Grafana这样的其他后端工具来消费日志和指标，而不是将其设置为none，您应添加您将要使用的后端的正确配置。
- en: Since OpenTelemetry is compatible with a wide variety of backends, you should
    refer to the documentation to see how to configure it for the logs and metrics
    backend that you will be using.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于OpenTelemetry与多种后端兼容，您应参考文档了解如何配置它以适应您将要使用的日志和指标后端。
- en: '[PRE40]'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, under the management tag, you have the same configuration as shown in
    the Micrometer section. The configuration needs to contain tracing enabled and
    the sampling probability at 1.0 in order to generate as many traces as possible
    for our testing purposes. In production environments, you should configure that
    with a smaller value to avoid unneeded tracing.
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在管理标签下，您有与Micrometer部分相同的配置。配置需要包含启用跟踪和采样概率为1.0，以便为我们的测试目的生成尽可能多的跟踪。在生产环境中，您应配置一个较小的值以避免不必要的跟踪。
- en: '[PRE41]'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, be aware that the logging pattern with OpenTelemetry changes. Using
    pure Micrometer with Brave, as shown in the section Implementing tracing using
    Micrometer, registers the trace and the span as `traceId` and `spanId` in the
    MDC (Mapped Diagnostic Context), that is, from where the pattern gets its values.
    But OpenTelemetry registers them as `trace_id` and `span_id` . This is a slight
    change but if you do not take this into consideration, you will not see the tracing
    in your application logs.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，请注意，使用OpenTelemetry的日志模式会发生变化。在“使用Micrometer实现跟踪”部分所示，使用Brave与纯Micrometer一起注册跟踪和跨度为MDC（映射诊断上下文）中的`traceId`和`spanId`，即模式从中获取值的地方。但OpenTelemetry将它们注册为`trace_id`和`span_id`。这是一个细微的变化，但如果您不考虑这一点，您将无法在应用程序日志中看到跟踪。
- en: '[PRE42]'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Configuring OpenTelemetry exporter** : Create an OpenTelemetry configuration
    class in your Spring Boot application to export the traces to the defined tracing
    URL. This setup is generally handled automatically when using `opentelemetry-spring-boot-starter`
    , but you can add further customization to initialize it as a bean in Spring,
    like we are doing here.'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置OpenTelemetry导出器**：在您的Spring Boot应用程序中创建一个OpenTelemetry配置类，以将跟踪导出到定义的跟踪URL。当使用`opentelemetry-spring-boot-starter`时，此设置通常会被自动处理，但您可以在Spring中将其初始化为一个bean，就像我们在这里所做的那样。'
- en: 'This will export the traces directly to be collected by the backend, which
    in our example will be Jaeger this time. To achieve that, we are going to use
    the OtlpHttpSpanExporter class from the OpenTelemetry library imported earlier:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接导出跟踪以便由后端收集，在我们的例子中这次将是Jaeger。为了实现这一点，我们将使用之前导入的OpenTelemetry库中的`OtlpHttpSpanExporter`类：
- en: '[PRE43]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this configuration, the `OtlpHttpSpanExporter` will export the traces directly
    into the defined tracing URL from the `applications.yml` , so Jaeger can read
    our traces directly. By default, OpenTelemetry will automatically instrument HTTP
    and Spring MVC requests.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，`OtlpHttpSpanExporter`将直接从`applications.yml`将跟踪导出到定义的跟踪URL，因此Jaeger可以直接读取我们的跟踪。默认情况下，OpenTelemetry将自动检测HTTP和Spring
    MVC请求。
- en: '**Validate tracing in the application** : To validate that OpenTelemetry tracing
    is working, we can:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证应用程序中的跟踪**：为了验证OpenTelemetry跟踪是否正常工作，我们可以：'
- en: 'Check traces in the exported tool: Start your Spring Boot application and use
    Jaeger (or the chosen backend) to view the traces. Each incoming request should
    appear in the tracing tool as a new trace with a unique `traceId` .'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查导出工具中的跟踪：启动您的Spring Boot应用程序，并使用Jaeger（或选择的后端）查看跟踪。每个传入请求都应在跟踪工具中作为一个具有唯一`traceId`的新跟踪出现。
- en: 'Observe logs with trace and span IDs: After setting up OpenTelemetry, logs
    should contain `traceId` and `spanId` , allowing you to correlate log entries
    across services.'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察带有跟踪和跨度ID的日志：在设置OpenTelemetry之后，日志应包含`traceId`和`spanId`，这允许您在服务之间关联日志条目。
- en: '**Verify logs and trace visualization** : After implementing OpenTelemetry,
    you should see enhanced logs with traceId and spanId for each request. Additionally,
    the tracing backend (Zipkin, in this case) will provide a visual representation
    of the trace.'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证日志和跟踪可视化**：实施 OpenTelemetry 后，您应该看到带有 traceId 和 spanId 的增强日志，每个请求都有一个。此外，跟踪后端（在本例中为
    Zipkin）将提供跟踪的可视表示。'
- en: Logs with OpenTelemetry Tracing
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有 OpenTelemetry 跟踪的日志
- en: 'Below is an example log output from the `order-management-api` calling the
    `product-api` after implementing OpenTelemetry. Notice the `traceId` and `spanId`
    added to each log entry, following the defined logging pattern into the `application.yml`
    file:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实施 OpenTelemetry 后，`order-management-api` 调用 `product-api` 的示例日志输出。注意每个日志条目中添加的
    `traceId` 和 `spanId`，它们遵循定义的日志模式写入 `application.yml` 文件：
- en: '[PRE44]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It follows the same structure described in the section Viewing trace data, but
    here these traces and spans are being generated by OpenTelemetry.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循在“查看跟踪数据”部分中描述的相同结构，但在这里这些跟踪和跨度是由 OpenTelemetry 生成的。
- en: 'We can also see the logs on the `product-api` side, which receives the `traceId`
    from the `order-management-api` and generates its own `spanId` :'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `product-api` 端查看日志，该端从 `order-management-api` 接收 `traceId` 并生成自己的 `spanId`：
- en: '[PRE45]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With these IDs, each log entry can be correlated to a specific request and its
    journey across multiple services.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些 ID，每个日志条目都可以关联到特定的请求及其跨多个服务的旅程。
- en: Next, we will learn how to run a local Jaeger instance to see the whole tracing
    in action.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何运行本地 Jaeger 实例以查看整个跟踪的实际操作。
- en: Visualization example with Jaeger
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jaeger 的可视化示例
- en: 'To be able to run a local Jaeger instance on your machine, create the following
    `docker-compose.yml` file, which will automatically download and configure your
    local Jaeger instance with the following content:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的机器上运行本地 Jaeger 实例，创建以下 `docker-compose.yml` 文件，它将自动下载并配置您的本地 Jaeger 实例，内容如下：
- en: '[PRE46]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This file defines to get the latest Docker image for Jaeger. Also, here we are
    allocating port `4318` for tracing and `16686` for the Jaeger UI interface.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了获取 Jaeger 的最新 Docker 镜像。此外，在这里我们为跟踪分配端口 `4318`，为 Jaeger UI 界面分配端口 `16686`。
- en: The property `COLLECTOR_OTLP_ENABLED=true` is optional on Jaeger v2 since its
    default is always true and mandatory on Jaeger v1. At the time of this writing,
    you should get above v2 while running this `docker-compose.yml` file.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jaeger v2 中，属性 `COLLECTOR_OTLP_ENABLED=true` 是可选的，因为其默认值始终为 true，而在 Jaeger
    v1 中则是强制性的。在撰写本文时，您应该在运行此 `docker-compose.yml` 文件时获取上述 v2 版本。
- en: 'To run this container, you need Docker installed on your system. Once it is
    installed, open a console in the same directory as where this file is saved and
    run the following command:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此容器，您需要在您的系统上安装 Docker。一旦安装，请在此文件保存的同一目录中打开一个控制台，并运行以下命令：
- en: '[PRE47]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once the application is running, go to your local running Jaeger’s UI ( `http://localhost:16686`
    ) to view the traces. You should see a graphical representation of the trace,
    showing the `traceId` , `spanId` , and the parent-child relationships across services,
    and even showing deeper details like database `INSERT` and durations, giving a
    broad view of the trace.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行，请访问您本地运行的 Jaeger 的 UI（`http://localhost:16686`）以查看跟踪。您应该看到一个跟踪的图形表示，显示
    `traceId`、`spanId` 以及跨服务之间的父子关系，甚至显示更详细的数据库 `INSERT` 和持续时间，从而提供一个广泛的跟踪视图。
- en: '![Figure 9.3 – Complete trace journey in Jaeger dashboard with OpenTelemetry](img/B21843_09_3.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 使用 OpenTelemetry 在 Jaeger 仪表板中的完整跟踪旅程](img/B21843_09_3.png)'
- en: Figure 9.3 – Complete trace journey in Jaeger dashboard with OpenTelemetry
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 使用 OpenTelemetry 在 Jaeger 仪表板中的完整跟踪旅程
- en: 'In the case of any error, it will highlight what happened and where it happened:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何错误的情况下，它将突出显示发生的事情以及发生的位置：
- en: '![Figure 9.4 – Successful and error traces in Jaeger dashboard](img/B21843_09_4.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Jaeger 仪表板中的成功和错误跟踪](img/B21843_09_4.png)'
- en: Figure 9.4 – Successful and error traces in Jaeger dashboard
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Jaeger 仪表板中的成功和错误跟踪
- en: Feel free to refer to this chapter repository to get the working code version
    and replicate the same behavior on your local machine.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时参考本章的代码库以获取工作代码版本，并在您的本地机器上复制相同的行为。
- en: By examining both the logs in the application and the trace visualization in
    Jaeger, you can validate that OpenTelemetry is successfully capturing traces,
    correlating logs with tracing data, and providing a full view of the request’s
    journey through your distributed system. This setup not only helps troubleshoot
    issues but also provides insights into optimizing performance across services
    with the goal of monitoring distributed services.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查应用程序中的日志和在Jaeger中的跟踪可视化，你可以验证OpenTelemetry是否成功捕获了跟踪，将日志与跟踪数据相关联，并提供了请求通过你的分布式系统的完整视图。这种设置不仅有助于解决问题，还能提供优化服务性能的见解，以监控分布式服务为目标。
- en: Let us take a look at how to create custom spans with OpenTelemetry.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用OpenTelemetry创建自定义跨度。
- en: Creating custom spans
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义跨度
- en: 'While OpenTelemetry automatically instruments HTTP requests, you can also create
    custom spans to monitor specific operations. Here’s an example in which a span
    is manually created for a user registration process:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OpenTelemetry自动对HTTP请求进行仪表化，但你也可以创建自定义跨度来监控特定操作。以下是一个手动为用户注册过程创建跨度的示例：
- en: '[PRE48]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, a custom span named “ `UserService.registerUser` " is created,
    and a username attribute is added. The span is started with `.startSpan()` and
    ended with `.end()` .
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，创建了一个名为“ `UserService.registerUser` "的自定义跨度，并添加了一个用户名属性。跨度通过`.startSpan()`开始，通过`.end()`结束。
- en: Now that you have mastered the usage of OpenTelemetry as well, let us focus
    on some of the best practices for observability that you should be aware of.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了OpenTelemetry的使用，让我们来关注一些你应该知道的关于可观测性的最佳实践。
- en: Best practices for end-to-end observability
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端可观测性的最佳实践
- en: Observability is an ongoing process that involves logs, metrics, and traces
    working together to provide full visibility into your REST API’s performance and
    behavior.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性是一个持续的过程，涉及日志、指标和跟踪共同工作，以提供对REST API性能和行为的全面可见性。
- en: 'Preparing your environment to be completely covered by observability and monitoring
    is not an easy task, and you must consider the following topics:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 准备你的环境以完全由可观测性和监控覆盖不是一件容易的事情，你必须考虑以下主题：
- en: Combining logs, metrics, and traces
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志、指标和跟踪的结合
- en: 'Logs, metrics, and traces complement each other to give you a holistic view
    of your application:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 日志、指标和跟踪相互补充，为你提供应用程序的整体视图：
- en: '**Logs** : Provide detailed information about specific events.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：提供关于特定事件的详细信息。'
- en: '**Metrics** : Offer a quantitative summary of performance over time.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**：提供随时间推移的性能定量总结。'
- en: '**Traces** : Show the lifecycle of individual requests across services.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：显示单个请求在服务之间的生命周期。'
- en: By using these tools together, you can quickly diagnose issues and optimize
    performance. For example, you might use tracing to find a slow request, logs to
    determine why it’s slow, and metrics to track how often the issue occurs.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些工具一起，你可以快速诊断问题并优化性能。例如，你可能使用跟踪来找到慢请求，使用日志来确定为什么它慢，以及使用指标来跟踪问题发生的频率。
- en: Alarms and notifications
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警报和通知
- en: With observability tools in place, you can set up alarms to notify your team
    when something goes wrong. For example, you can configure Prometheus to send alerts
    when the error rate exceeds a certain threshold or when response times spike.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署了可观测性工具之后，你可以设置警报，当出现问题时通知你的团队。例如，你可以配置Prometheus在错误率超过某个阈值或响应时间激增时发送警报。
- en: In the context of RESTful microservices, AWS CloudWatch offers comprehensive
    monitoring capabilities that transform raw operational data into readable, near-real-time
    metrics stored for up to 15 months.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful微服务的情况下，AWS CloudWatch提供了全面的监控能力，将原始操作数据转换为可读的、近实时的指标，并存储长达15个月。
- en: For example, when implementing API Gateway as the front door to your microservices
    architecture, CloudWatch can monitor key performance indicators such as IntegrationLatency
    to measure backend responsiveness, overall latency to assess API call efficiency,
    and cache performance metrics to optimize resource utilization. API Gateway logging,
    which feeds into CloudWatch Logs, provides valuable visibility into consumer access
    behaviors, allowing teams to understand common customer locations, analyze request
    patterns that might impact database partitioning, identify abnormal behavior that
    could indicate security concerns, and optimize configurations by tracking errors,
    latency, and cache performance. This monitoring framework creates a secure, easily
    maintainable environment that scales with growing business needs while providing
    actionable intelligence to continuously improve service delivery.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当将API网关作为你的微服务架构的前门时，CloudWatch可以监控关键性能指标，如IntegrationLatency来衡量后端响应速度，整体延迟来评估API调用效率，以及缓存性能指标来优化资源利用率。API网关日志，它输入到CloudWatch日志中，提供了对消费者访问行为的宝贵可见性，使团队能够了解常见客户位置，分析可能影响数据库分区的请求模式，识别可能表明安全问题的异常行为，并通过跟踪错误、延迟和缓存性能来优化配置。这个监控框架创建了一个安全、易于维护的环境，随着业务需求的增长而扩展，同时提供可操作的智能，以持续改进服务交付。
- en: Continuous improvement
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续改进
- en: Observability is an ongoing process. As your system evolves, regularly review
    and refine your logging, tracing, and metrics collection to ensure you are capturing
    the most useful data. Use tools like Prometheus, Grafana, Zipkin, and OpenTelemetry
    to continually monitor and improve your system’s performance.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性是一个持续的过程。随着你的系统不断发展，定期审查和优化你的日志记录、跟踪和指标收集，以确保你捕获到最有用的数据。使用Prometheus、Grafana、Zipkin和OpenTelemetry等工具持续监控和改进你系统的性能。
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the core components and best practices for achieving
    effective monitoring and observability in RESTful services. Beginning with logging,
    we discussed the importance of structured logging for API troubleshooting, log
    levels to indicate severity, and correlation IDs to link requests across services.
    By implementing these logging practices centrally, such as with a filter in Spring
    Boot, we ensured consistent and secure logging across the application.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了实现RESTful服务有效监控和观测性的核心组件和最佳实践。从日志记录开始，我们讨论了结构化日志对于API故障排除的重要性，日志级别以指示严重性，以及关联ID以在服务之间链接请求。通过在Spring
    Boot中使用过滤器等中央实施这些日志记录实践，我们确保了应用程序中日志记录的一致性和安全性。
- en: We then introduced distributed tracing, explaining how `traceId` , `spanId`
    , and `parentSpanId` create a parent-child relationship among services, allowing
    developers to track the journey of requests through a system.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后介绍了分布式跟踪，解释了`traceId`、`spanId`和`parentSpanId`如何在服务之间创建父子关系，使开发者能够跟踪请求在系统中的旅程。
- en: Micrometer Tracing was covered as a key tool in Spring Boot 3.x for enabling
    and managing distributed tracing. It automatically instruments Spring Boot applications,
    capturing trace and span information for each request.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer Tracing在Spring Boot 3.x中被作为启用和管理分布式跟踪的关键工具进行了介绍。它自动为Spring Boot应用程序进行仪器化，捕获每个请求的跟踪和跨度信息。
- en: Micrometer Tracing integrates with multiple exporters, including Prometheus,
    Zipkin, and Jaeger, to send trace data to external observability platforms. With
    its configurable sampling and tagging, Micrometer Tracing provides granular visibility
    into each service, enabling efficient troubleshooting and performance optimization.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer Tracing与多个导出器集成，包括Prometheus、Zipkin和Jaeger，将跟踪数据发送到外部观测性平台。通过其可配置的采样和标记，Micrometer
    Tracing为每个服务提供了细粒度的可见性，使高效的故障排除和性能优化成为可能。
- en: Building on tracing, we explored OpenTelemetry as a vendor-neutral observability
    framework that collects and correlates traces, metrics, and logs in distributed
    systems.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪的基础上，我们探讨了OpenTelemetry作为一个供应商中立的观测性框架，它收集和关联分布式系统中的跟踪、指标和日志。
- en: OpenTelemetry integrates smoothly with Spring Boot to provide out-of-the-box
    tracing for HTTP and Spring MVC requests, with added flexibility to create custom
    spans. We covered how to configure OpenTelemetry, validate its functionality through
    logging and visualization in tools like Zipkin, and observe end-to-end traces
    across services.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry与Spring Boot无缝集成，为HTTP和Spring MVC请求提供开箱即用的跟踪，并增加了创建自定义跨度的灵活性。我们介绍了如何配置OpenTelemetry，通过在Zipkin等工具中的日志记录和可视化来验证其功能，并观察跨服务端到端的跟踪。
- en: By combining logging, tracing, and OpenTelemetry with tools like Zipkin or Jaeger
    for visualization, we can gain a comprehensive view of each request across services.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合日志记录、跟踪和OpenTelemetry，以及使用Zipkin或Jaeger等工具进行可视化，我们可以获得对每个服务间请求的全面视图。
- en: This chapter provided foundational strategies for implementing robust observability,
    allowing for effective monitoring, faster troubleshooting, and insights to optimize
    the performance of RESTful APIs in complex, distributed environments.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了实施稳健可观测性的基础策略，允许进行有效的监控、快速的问题排查，以及优化复杂、分布式环境中RESTful API性能的见解。
- en: In the next chapter, you will learn about scaling and performance optimization
    techniques, to be able to make the best out of your applications.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于扩展和性能优化技术，以便能够充分利用你的应用程序。
