- en: Behavioral Design Patterns – Part Two
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式 – 第二部分
- en: The group of behavioral design patterns is a relatively big one. In the previous
    chapter, we looked at the first part of behavioral design patterns and understood
    what their purpose is. As we already know, these patterns are used to deal with
    behavior and modeling object communication in computer programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式组相对较大。在前一章中，我们研究了行为设计模式的第一部分，并了解了它们的目的。正如我们已经知道的，这些模式用于处理计算机程序中的行为和对象通信的建模。
- en: 'In this chapter, we will continue going through the different behavioral design
    patterns as seen from the point of view of Scala. We will look at the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续从Scala的角度研究不同的行为设计模式。我们将探讨以下主题：
- en: Iterator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Template method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: The design patterns that we will cover in this chapter might not be as relevant
    to functional programming as some of the others we've seen earlier. They might
    look like Scala implementations of Java design patterns and this will actually
    be the case. However, this does not make them unnecessary and they are still important
    due to the hybrid nature of Scala.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要讨论的设计模式可能不像我们之前看到的一些模式那样与函数式编程相关。它们可能看起来像是Java设计模式的Scala实现，实际上也是如此。然而，这并不意味着它们是不必要的，由于Scala的混合特性，它们仍然很重要。
- en: As in the previous chapters, we will follow the same structure, give a pattern
    definition, show a class diagram and a code example, and talk about the pros and
    cons of the specific design pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章一样，我们将遵循相同的结构，给出模式定义，展示类图和代码示例，并讨论特定设计模式的优缺点。
- en: The iterator design pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器设计模式
- en: We use iterators in software projects all the time. When we traverse a list
    or go through the items of a set or a map, we use an **iterator**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在软件项目中经常使用迭代器。当我们遍历列表或遍历集合或映射的项目时，我们使用**迭代器**。
- en: The iterator design pattern provides a way to access the elements of an aggregate
    object (collection) in a sequential manner without exposing the underlying representation
    of the items.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式提供了一种以顺序方式访问聚合对象（集合）元素的方法，而不暴露项目底层的表示。
- en: When using the iterator design pattern, the developer doesn't need to know whether
    there is a linked list, array, tree, or a hash map underneath.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用迭代器设计模式时，开发者不需要知道底层是链表、数组、树还是哈希表。
- en: Example class diagram
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: Using the iterator design pattern, we can create our own objects that act as
    collections and we can use them in loops. In Java, there is an interface called
    `Iterator`, which we can implement for this purpose. In Scala, we can mix in the
    `Iterator` trait and implement its `hasNext` and `next` methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器设计模式，我们可以创建自己的对象，使其充当集合，并在循环中使用它们。在Java中，有一个名为`Iterator`的接口，我们可以为此目的实现它。在Scala中，我们可以混入`Iterator`特质并实现其`hasNext`和`next`方法。
- en: 'For the class diagram and the example, let''s have a **ClassRoom** class that
    will support a foreach loop running through all students. The following diagram
    shows our class diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图和示例，让我们有一个**ClassRoom**类，它将支持遍历所有学生的foreach循环。以下图表显示了我们的类图：
- en: '![](img/2c7a71c4-8afa-4b1a-8caf-e6f2ee9dd195.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c7a71c4-8afa-4b1a-8caf-e6f2ee9dd195.png)'
- en: We've decided on our **ClassRoom** class to implement **Iterable**, which should
    return an **Iterator** and then return a new instance of our iterator when the
    method is called. The iterator design pattern is represented by the right-hand
    side of the diagram. The rest of the diagram is something we've done to make working
    with our class easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定让我们的**ClassRoom**类实现**Iterable**，它应该返回一个**迭代器**，并在方法调用时返回迭代器的新实例。迭代器设计模式在图表的右侧表示。图表的其余部分是我们为了使与我们的类一起工作更简单而做的事情。
- en: Code example
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s see the code that implements the preceding diagram. First of all, the
    `Student` class is simply a case class that looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现前面图表的代码。首先，`Student`类只是一个看起来如下所示的case类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have implemented the standard Scala `Iterator` trait in the `StudentIterator`
    class. Here is the implementation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`StudentIterator`类中实现了标准的Scala `Iterator`特质。以下是实现代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One thing to know about iterators is that they work in only one direction and
    you cannot go back. That's why we simply use a `currentPos` variable to remember
    how far we are in an iteration. We have used a mutable variable here, which is
    against the Scala principles; however, this is just an example and it is not too
    critical. In practice, you would probably use the iterator design pattern in conjunction
    with data structures, rather than in this form. The reason we've chosen the underlying
    structure of the iterator to be an `Array` is that indexing access of arrays is
    constant and it will improve the performance of large collections and keep our
    implementation simple.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于迭代器，有一件事需要知道，它们只能单向工作，你不能回退。这就是为什么我们简单地使用一个`currentPos`变量来记住我们在迭代中的位置。在这里我们使用了一个可变变量，这与Scala的原则相悖；然而，这只是一个例子，并不太关键。在实践中，你可能会结合数据结构使用迭代器设计模式，而不是这种形式。我们选择迭代器的底层结构为`Array`的原因是数组的索引访问是常数，这将提高大型集合的性能并使我们的实现简单。
- en: 'The preceding code is really enough to show the iterator design pattern. The
    rest of the code is here to help us show how it can be used. Let''s have a look
    at the `ClassRoom` class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码足以展示迭代器设计模式。其余的代码在这里是为了帮助我们展示它如何被使用。让我们看看`ClassRoom`类：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We mix in the `Iterable` trait in the preceding code and implement its `iterator`
    method. We return our `StudentIterator`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们混入了`Iterable`特质并实现了它的`iterator`方法。我们返回我们的`StudentIterator`。
- en: We've created a custom iterator just as an example. However, in reality, you
    would just implement `Iterable` in the `ClassRoom` class and return the iterator
    of the underlying collection (students, in this case).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义迭代器仅作为一个例子。然而，在现实中，你只需在`ClassRoom`类中实现`Iterable`并返回底层集合（在这种情况下是学生）的迭代器。
- en: 'Let''s see an example that uses our `ClassRoom` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用我们的`ClassRoom`类的例子：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The fact that we have mixed in the `Iterable` trait allows us to use `foreach`,
    `map`, `flatMap`, and many others on an object of the `ClassRoom` type. The following
    screenshot shows the output of our example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们混入`Iterable`特质的事实使我们能够在`ClassRoom`类型的对象上使用`foreach`、`map`、`flatMap`等许多其他操作。以下截图显示了我们的示例输出：
- en: '![](img/2f0de080-e9ce-4cea-9d7a-39600bc53d73.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f0de080-e9ce-4cea-9d7a-39600bc53d73.png)'
- en: As you can see in this example, the user of our `ClassRoom` class has no idea
    about the underlying data structure that holds our `Student` objects. We could
    replace it at any time (we can even get the data of the students from a database)
    and the entire code will keep working as long as we still have the `Iterable`
    trait in our class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中可以看到的，我们的`ClassRoom`类的用户对持有我们的`Student`对象的数据结构一无所知。我们可以在任何时候替换它（我们甚至可以从数据库中获取学生的数据），只要我们的类中还有`Iterable`特质，整个代码就会继续工作。
- en: What it is good for
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处
- en: The iterator design pattern is used all the time in software engineering. It
    is probably one of the most often used design patterns and everyone knows about
    it. It is used with almost all collections one can think of, it is pretty simple,
    and allows us to hide the details of how a composite object is internally organized.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式在软件工程中经常被使用。它可能是最常用的设计模式之一，每个人都听说过它。它几乎与所有可以想到的集合一起使用，它很简单，并允许我们隐藏复合对象内部组织的细节。
- en: What it is not so good for
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么不好
- en: One obvious drawback of our implementation, which shows a possible problem with
    the iteration design pattern, is its use in parallel code. What would happen if
    another thread adds or removes objects to or from the original collection? Our
    iterator will not reflect that and it could lead to problems due to lack of synchronization.
    Making iterators capable of handling multithreaded environments is not a simple
    task.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的一个明显的缺点，这显示了迭代器设计模式可能存在的问题，是在并行代码中的使用。如果另一个线程向原始集合中添加或删除对象会发生什么？我们的迭代器将不会反映这一点，并且可能由于缺乏同步而导致问题。使迭代器能够处理多线程环境不是一个简单的任务。
- en: The mediator design pattern
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介设计模式
- en: Real-world software projects usually contain a large number of different classes.
    This helps to distribute complexity and logic so that each class does one specific
    thing, which is simple, rather than many complex tasks. This, however, requires
    classes to communicate with each other in some way in order to realize some specific
    functionality, but then keeping the loose coupling principle in place could become
    a challenge.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的软件项目通常包含大量不同的类。这有助于分配复杂性和逻辑，使得每个类只做一件特定的事情，简单而不是许多复杂任务。然而，这要求类以某种方式相互通信，以实现某些特定功能，但保持松散耦合原则可能成为一个挑战。
- en: The purpose of the mediator design pattern is to define an object that encapsulates
    how a set of other objects interact with each other in order to promote loose
    coupling and allow us to vary class interactions independently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 中介设计模式的目的在于定义一个对象，该对象封装了一组其他对象如何相互交互，以促进松散耦合，并允许我们独立地改变类交互。
- en: The mediator design pattern defines a specific object called **mediator** that
    enables other ones to communicate with each other instead of doing this directly.
    This reduces dependencies between them, which makes a program easy to change and
    maintain in the future as well as have it properly tested.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 中介设计模式定义了一个特定的对象，称为 **中介**，它使其他对象能够相互通信，而不是直接这样做。这减少了它们之间的依赖性，使得程序在未来易于更改和维护，并且可以正确地进行测试。
- en: Example class diagram
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: Let's imagine that we are building a system for a school where each student
    can take multiple classes and each class is taken by multiple students. We might
    want to have a functionality that notifies all the students of a specific class
    that it is canceled, or we might want to easily add or remove users from classes.
    We can impulsively start writing our code and have a list of classes as a part
    of the `student` class and a list of students in the `group` class. This way,
    however, our objects will become interconnected and not really reusable. This
    is a good use case for the mediator pattern.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在为学校构建一个系统，其中每个学生可以参加多个课程，每个课程由多个学生参加。我们可能希望有一个功能，可以通知特定课程的所有学生该课程已被取消，或者我们可能希望轻松地添加或从课程中删除用户。我们可以冲动地开始编写我们的代码，并将课程列表作为
    `student` 类的一部分，以及 `group` 类中的学生列表。然而，这样我们的对象将变得相互关联，并且实际上不可重用。这正是中介模式的好用例。
- en: 'Let''s take a look at our class diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的类图：
- en: '![](img/5b14b59f-2fc7-40fe-9160-bbf7c61ed3cb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b14b59f-2fc7-40fe-9160-bbf7c61ed3cb.png)'
- en: As you can see from the preceding diagram, the school is the mediator and it
    contains information about users to groups and groups to users. It manages the
    interaction between these entities and allows us to make our **Student** and **Group**
    classes reusable and independent from each other.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的图中可以看到，学校是中介，它包含有关用户到组和组到用户的信息。它管理这些实体之间的交互，并允许我们使我们的 **学生** 和 **组** 类可重用，并且彼此独立。
- en: We've given an example with students and classes; however, this could be easily
    applied to any many-to-many relationships—permission groups in software, taxi
    systems, air traffic control systems, and many more.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给出了学生和课程的示例；然而，这可以很容易地应用于任何多对多关系——软件中的权限组、出租车系统、空中交通管制系统等等。
- en: Code example
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now that we have presented our class diagram, let''s take a look at the source
    code for the example. First of all, let''s see the model classes we have:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了我们的类图，让我们来看看示例的源代码。首先，让我们看看我们有的模型类：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Notifiable` trait in the preceding code is not needed in the current example;
    however, for example, if we add teachers, then it would be useful in the cases
    where we want to send notifications to everyone in the same group. The classes
    in the previous code can have their own independent functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Notifiable` 特性在当前示例中不是必需的；然而，例如，如果我们添加教师，那么在需要向同一组中的所有人发送通知的情况下，它将是有用的。前一个代码中的类可以有自己的独立功能。
- en: 'Our `Mediator` trait has the following definition:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Mediator` 特性有以下定义：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the preceding code defines methods that allow interactions
    between students and groups. The implementation of these methods is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码定义了允许学生和组之间交互的方法。这些方法的实现如下：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `School` is the actual mediator that our application will be using. As
    you can see, it does exactly what the mediator design pattern is supposed to do—keeps
    the objects from directly referring to each other and internally defines their
    interactions. An application that uses our `School` class is shown in the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`School`是我们应用程序将使用的事实上的中介者。正如你所看到的，它确实做了中介者设计模式应该做的事情——防止对象直接相互引用，并在内部定义它们的交互。以下代码展示了使用我们的`School`类的应用程序：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding example application is really simple—it creates objects of the
    `Student` and `Group` types and uses the mediator object to wire them up and make
    it possible for them to interact. The output of the example is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例应用程序非常简单——它创建了`Student`和`Group`类型的对象，并使用中介者对象将它们连接起来，使它们能够交互。示例的输出如下：
- en: '![](img/901246e8-42dc-40cc-b003-72274b151a20.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/901246e8-42dc-40cc-b003-72274b151a20.png)'
- en: As the output shows, our code does exactly what is expected, and it managed
    to keep the concepts loosely coupled in the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，我们的代码确实做了预期的事情，并且成功地将应用程序中的概念保持为松散耦合。
- en: What it is good for
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的好处
- en: The mediator design pattern is good for keeping coupling between classes loose
    in an application. It helps to achieve simplicity and maintainability, while still
    allowing us to model complex interactions between objects in our applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者设计模式对于在应用程序中保持类之间的耦合松散很有用。它有助于实现简单性和可维护性，同时仍然允许我们模拟应用程序中对象之间的复杂交互。
- en: What it is not so good for
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不是那么好的地方
- en: A possible pitfall when using the mediator design pattern is to put a lot of
    different interaction functionalities in one class. Mediators tend to become more
    complex with time, and it will become hard to change or understand what our application
    can do at all. Moreover, if we actually have many more classes that have to interact
    with each other, it will imminently affect the mediator as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中介者设计模式时可能的一个陷阱是将许多不同的交互功能放在一个类中。随着时间的发展，中介者往往会变得更加复杂，这将使得改变或理解我们的应用程序能做什么变得很困难。此外，如果我们实际上有更多必须相互交互的类，这也会立即影响中介者。
- en: The memento design pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆体设计模式
- en: Depending on the software we are writing, we might have a requirement to be
    able to restore the state of an object back to its previous state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们正在编写的软件，我们可能需要能够将对象的状态恢复到其先前的状态。
- en: The purpose of the memento design pattern is to provide the ability to execute
    an undo action in order to restore an object to a previous state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆体设计模式的目的是为了提供执行撤销操作的能力，以便将对象恢复到先前的状态。
- en: 'The original memento design pattern is implemented with the help of three main
    objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的记忆体设计模式是通过三个主要对象实现的：
- en: '`Originator`: The object whose state we want to be able to restore'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Originator`: 我们希望能够恢复其状态的对象'
- en: '`Caretaker`: The object that triggers the changes to the `originator` object
    and uses the `memento` objects for rollback, if needed'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Caretaker`: 触发对`originator`对象进行更改的对象，并在需要时使用`memento`对象进行回滚'
- en: '`Memento`: The object that carries the actual state of the originator and can
    be used to restore to one of the previous states'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Memento`: 带有原始对象实际状态的对象，可以用来恢复到先前的某个状态'
- en: It is important to know that the `memento` object can be handled only by the
    originator. The caretaker and all other classes can just store it and nothing
    else.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，`memento`对象只能由原始对象处理。看护者和所有其他类只能存储它，不能做其他事情。
- en: Example class diagram
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: A classic example of the memento design pattern that comes to mind is text editors.
    We can always undo whatever we have changed. We will present something similar
    in our class diagram and example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆体设计模式的一个经典例子是文本编辑器。我们可以随时撤销所做的任何更改。我们将在类图和示例中展示类似的内容。
- en: 'The following is the class diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类图：
- en: '![](img/149ecc52-915e-4584-bbc3-aab6c184eafc.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/149ecc52-915e-4584-bbc3-aab6c184eafc.png)'
- en: As you can see in the preceding diagram, our caretaker is the **TextEditorManipulator**.
    It automatically saves the state in the states stack on every manipulation. The
    **TextEditor** implements the **Originator** and creates a `memento` object and
    restores from one. Finally, the **TextEditorMemento** is the concrete `memento`
    object that our text editor will be using to save the state. Our state is just
    the current string representation of the text in the editor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到，我们的保管者是**TextEditorManipulator**。它在每次操作时都会自动将状态保存在状态栈中。**TextEditor**实现了**Originator**，并创建了一个`memento`对象，并从其中恢复。最后，**TextEditorMemento**是我们文本编辑器将用来保存状态的具象`memento`对象。我们的状态只是编辑器中当前文本的字符串表示。
- en: Code example
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: In this subsection, we will go through the text editor code one step at a time
    and see how the memento design pattern could be implemented in Scala.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将逐行分析文本编辑器代码，并看看备忘录设计模式如何在Scala中实现。
- en: 'First of all, let''s see the `Caretaker`, `Memento`, and `Originator` traits:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`Caretaker`、`Memento`和`Originator`特质：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have used generics, and this allows us to reuse those traits multiple times
    when we want to implement the memento design pattern. Now, let''s take a look
    at the specific implementations of the traits that are necessary in our application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了泛型，这使得我们可以在需要实现备忘录设计模式时多次重用这些特质。现在，让我们看看我们应用中必要的特质的特定实现：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code shows the actual `Originator` implementation as well as the
    `Memento` one. It is common to create the memento class as being private to the
    object, which will be creating and restoring from the class, and that's why we
    have done the same. The reason for this is that the originator should be the only
    one who knows how to create and restore from a `memento` object and how to read
    its state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了实际的`Originator`实现以及`Memento`实现。通常，将备忘录类创建为私有于创建和从类中恢复的对象，这就是我们为什么这样做的原因。这样做的原因是，原始者应该是唯一知道如何创建和从`memento`对象中恢复，以及如何读取其状态的人。
- en: 'Finally, let''s take a look at the `Caretaker` implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`Caretaker`的实现：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our implementation, the caretaker exposes methods to manipulate the `originator`
    object. Before every manipulation, we save the state to the stack in order to
    be able to rollback if needed at a future point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，保管者公开了用于操作`originator`对象的方法。在每次操作之前，我们将状态保存到栈中，以便在将来需要时能够回滚。
- en: 'Now that we''ve seen all the code for our example, let''s see an application
    that uses it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们示例的所有代码，让我们看看一个使用它的应用：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we just manually added some text to our text editor,
    deleted some characters, and then did an undo of the deletions. The following
    screenshot shows the output of this example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是手动向我们的文本编辑器添加了一些文本，删除了一些字符，然后撤销了删除操作。下面的截图显示了此示例的输出：
- en: '![](img/6e153bbc-6ed5-4353-a2f8-c4d2bc73f28b.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e153bbc-6ed5-4353-a2f8-c4d2bc73f28b.png)'
- en: One possible issue with our application design that might need improvement is
    the `states` stack—we have absolutely no limit and if a lot of changes are made,
    it could grow too much. In real text editors, we cannot go back infinitely, and
    this stack is limited to a certain number of operations. Another performance issue
    could be the fact that we call `toString` on the internal `StringBuilder` on each
    operation. Passing the actual `StringBuilder`, however, could have undesired effects
    on the application, as changes will affect all of the builder's references.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序设计中可能需要改进的一个可能问题是`states`栈——我们没有绝对的限制，如果有很多更改，它可能会变得很大。在真实的文本编辑器中，我们不能无限回退，这个栈限制在一定的操作数内。另一个性能问题可能是我们在每次操作中都调用内部`StringBuilder`的`toString`方法。然而，传递实际的`StringBuilder`可能会对应用程序产生不良影响，因为更改将影响所有构建器的引用。
- en: What it is good for
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点
- en: The memento design pattern is useful for applications that want to support a
    revertable state. In our example, we used a stack of states; however, this is
    not necessary—some applications might need only the last operation to be saved.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录设计模式对于想要支持可撤销状态的应用程序非常有用。在我们的例子中，我们使用了一个状态栈；然而，这并不是必需的——某些应用程序可能只需要保存最后一次操作。
- en: What it is not so good for
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的缺点
- en: Developers should be careful when they use the memento design pattern. They
    should try to have the state saved in value objects if possible because if a mutable
    type is passed, it would be changed by reference and this will lead to unwanted
    results. Developers should also be careful about how far back in time they allow
    changes to be undoable because the more operations are saved in the stack, the
    more memory will be required. Finally, Scala is immutable and the memento design
    pattern does not always coincide with the language philosophy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在使用备忘录设计模式时应小心。如果可能，他们应该尝试将状态保存在值对象中，因为如果传递了一个可变类型，它将通过引用被更改，这会导致不希望的结果。开发者还应小心允许更改可撤销的时间跨度，因为保存的操作越多，所需的内存就越多。最后，Scala是不可变的，备忘录设计模式并不总是与语言哲学相一致。
- en: The observer design pattern
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: There are sometimes cases where some objects are interested in the state change
    of another object and want to perform some specific action when this happens.
    A common example could be whenever you click a button in an app; some other objects
    subscribe to the click event and perform some actions. The observer design pattern
    helps us to achieve this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些对象对另一个对象的状态变化感兴趣，并希望在发生这种情况时执行一些特定的操作。一个常见的例子是，每当你在应用程序中点击一个按钮时；其他对象订阅点击事件并执行一些操作。观察者设计模式帮助我们实现这一点。
- en: The purpose of the observer design pattern is to have an object (called **subject**)
    that automatically notifies all of its observers of any state change by calling
    one of their methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式的目的是有这样一个对象（称为**subject**），它通过调用它们的方法之一自动通知所有观察者任何状态变化。
- en: The observer design pattern is employed in most GUI toolkits. It is also part
    of the MVC architectural pattern where the view is an observer. Java even comes
    with the `Observable` class and the `Observer` interface.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式在大多数GUI工具包中都有应用。它也是MVC架构模式的一部分，其中视图是一个观察者。Java甚至自带了`Observable`类和`Observer`接口。
- en: Example class diagram
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'For the class diagram, let''s focus on the following example—we have a website
    with posts, and people can subscribe to get notifications whenever a new comment
    is added. The following diagram shows how something like this could be represented
    using the observer design pattern:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，让我们关注以下示例——我们有一个网站，有帖子，人们可以订阅以在添加新评论时收到通知。以下图表显示了如何使用观察者模式表示类似的东西：
- en: '![](img/8a5ebb64-ca4e-4f47-91c7-c15754f0b16f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a5ebb64-ca4e-4f47-91c7-c15754f0b16f.png)'
- en: The **Post** class is our observable, and it has observers of the **User** type
    that are notified whenever the post changes (in our case, when a comment is added).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Post**类是我们的可观察对象，它具有**User**类型的观察者，每当帖子发生变化时（在我们的例子中，当添加评论时）都会收到通知。'
- en: Note that the preceding scenario is just an example. In reality, subscriptions
    can be done in a database and people will receive an email notification. However,
    if we are talking about some kind of notification while you are on the site, then
    this example is valid.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的场景只是一个例子。在现实中，订阅可以在数据库中完成，人们会收到电子邮件通知。然而，如果我们谈论的是你在网站上的一些通知，那么这个例子是有效的。
- en: The observer pattern in the example could and probably should be replaced with
    reactive programming in Scala using Akka and actors. This way, we could achieve
    much better scalability and implement a proper asynchronous publish-subscribe
    system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，观察者模式可以被（并且可能应该被）Scala中使用Akka和actor的响应式编程所取代。这样，我们可以实现更好的可伸缩性，并实现一个适当的异步发布-订阅系统。
- en: In the following subsection, we will take a look at the code that represents
    the preceding diagram.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将查看代表前面图表的代码。
- en: Code example
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, let''s go through all the code that represents the preceding diagram.
    First, let''s see the `Observer` interface. We have decided to have it as a trait
    that can be mixed in any class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过所有代表前面图表的代码。首先，让我们看看`Observer`接口。我们决定将其作为一个可以混合到任何类中的特质：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is extremely simple. Next, we will take a look at the `Observable` class.
    It is a trait that can also be mixed in and can make classes observable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。接下来，我们将看看`Observable`类。它是一个可以混合使用的特质，可以使类变得可观察：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we have used a self-type in order to make sure that we
    limit how the `Observable` trait is mixed in. This makes sure that the parameterized
    type will be the same as that of the object we are mixing it into.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了自类型以确保我们限制`Observable`特质的混合方式。这确保了参数化类型将与我们要混合的对象的类型相同。
- en: 'Our implementation of the `Observer` interface will be our `User` class. It
    has the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Observer`接口的实现将是我们的`User`类。它有以下代码：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is as simple as implementing one method and doing something with the changed
    `Post` subject.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像实现一个方法并与更改的`Post`主题进行交互一样简单。
- en: 'The `Comment` class is just a simple model class that has nothing special about
    it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment`类只是一个简单的模型类，没有特别之处：'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Post` class will be `Observable`. On every comment that is added, this
    class will notify all the registered observers. The code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`类将是`Observable`。每当添加评论时，这个类将通知所有已注册的观察者。代码如下：'
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All the preceding code snippets implement our observer design pattern. It is
    interesting to see how this works in an example. The following block of code has
    an example of how our classes can be used together:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述代码片段实现了我们的观察者设计模式。在示例中看到它是如何工作的很有趣。以下代码块展示了我们的类如何一起使用：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of our application is shown as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的输出如下所示：
- en: '![](img/8da265bf-706e-4497-9c27-6814a9f64a41.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8da265bf-706e-4497-9c27-6814a9f64a41.png)'
- en: As you can see in the preceding screenshot, the observer design pattern is quite
    easy to implement. As we mentioned earlier, a better approach would be to use
    reactive programming in order to make things asynchronous and more scalable. It
    will be more functional as well. We will see an example of how this can be done
    with Akka in the future chapters of this book.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中看到的，观察者设计模式很容易实现。正如我们之前提到的，更好的方法是将响应式编程用于使事物异步和更具可扩展性。它也将更加函数式。我们将在本书的后续章节中看到一个如何使用Akka实现的例子。
- en: What it is good for
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: The observer design pattern is easy to implement and allows us to add new observers
    or remove old observers at runtime. It helps to decouple logic and communication,
    which makes for some good quality classes that have only one responsibility.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式易于实现，并允许我们在运行时添加新的观察者或删除旧的观察者。它有助于解耦逻辑和通信，从而产生一些只有一个责任的优秀类。
- en: What it is not so good for
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: In functional programming with Scala, one would possibly prefer using Akka and
    creating a publish-subscribe design instead. Moreover, in the observer design
    pattern, object references are held in the observer's collection of the subject,
    which could cause memory leaks or unnecessary allocations during the lifetime
    of the application or the subject object. Finally, as with any other design pattern,
    the observer design pattern should be used only where necessary. Otherwise, we
    might end up complicating our application for no good reason.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Scala的函数式编程中，人们可能会更倾向于使用Akka并创建一个发布-订阅设计。此外，在观察者设计模式中，对象引用被保存在主题的观察者集合中，这可能导致在应用程序或主题对象的生命周期中发生内存泄漏或不必要的分配。最后，就像任何其他设计模式一样，观察者设计模式应该仅在必要时使用。否则，我们可能会无端地使我们的应用程序变得复杂。
- en: The state design pattern
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: The state design pattern is really similar to the strategy design pattern that
    we looked at in the previous chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式实际上与我们之前章节中看到的策略设计模式非常相似。
- en: The purpose of the state design pattern is to allow us to choose a different
    behavior of an object based on the object's internal state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式的目的允许我们根据对象的内部状态选择不同的行为。
- en: 'Basically, the difference between the state design pattern and the strategy
    design pattern comes from the following two points:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，状态设计模式和策略设计模式之间的区别来自以下两个点：
- en: The strategy design pattern is about *how* an action is performed. It is usually
    an algorithm that produces the same results as other algorithms.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略设计模式是关于*如何*执行一个动作的。它通常是一个算法，它产生的结果与其他算法相同。
- en: The state design pattern is about *what* action is performed. Depending on the
    state, an object could be doing different things.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态设计模式是关于*什么*动作被执行的。根据状态的不同，一个对象可能执行不同的操作。
- en: Implementing the state design pattern also closely resembles the implementation
    of the strategy design pattern.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现状态设计模式也与策略设计模式的实现非常相似。
- en: Example class diagram
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: Imagine a media player. Most media players have a play button—when we activate
    it, it usually changes its appearance and becomes a pause button. Clicking the
    pause button now also does something different—it pauses the playback and reverts
    to a play button. This is a good candidate for the state design pattern, where
    depending on which state the player is in, a different action happens.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个媒体播放器。大多数媒体播放器都有一个播放按钮——当我们激活它时，它通常会改变其外观并变成暂停按钮。现在点击暂停按钮也会执行不同的操作——它暂停播放并恢复为播放按钮。这是一个很好的状态设计模式候选，其中根据播放器所处的状态，会发生不同的操作。
- en: 'The following class diagram shows the classes that are needed to implement
    this functionality for the play and pause buttons:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了实现播放和暂停按钮所需的功能的类：
- en: '![](img/d6e6c64d-73fd-4078-88fe-dd5b1a99e71d.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6e6c64d-73fd-4078-88fe-dd5b1a99e71d.png)'
- en: Our **Playing** and **Paused** implementations set the state to the opposite
    one and make our player functional. Using the state design pattern also makes
    our code much more elegant—we could, of course, use if statements and depending
    on the value, perform different actions. However, it could easily get out of control
    when there are many states.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**播放**和**暂停**实现将状态设置为相反的状态，并使我们的播放器功能正常。使用状态设计模式也使我们的代码更加优雅——我们当然可以使用if语句，并根据值执行不同的操作。然而，当有多个状态时，它很容易失控。
- en: Code example
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s have a look at the code for the class diagram that we showed previously.
    First of all, let''s see the `State` trait:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们之前展示的类图的代码。首先，让我们看看`State`特质：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is really simple and allows the extending classes to implement the `press`
    method. We have two implementations according to our class diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单，允许扩展类实现`press`方法。根据我们的类图，我们有两种实现：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have made them simple and they only print a relevant message and then change
    the current state to the opposite state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使它们变得简单，它们只打印一条相关消息，然后改变当前状态为相反的状态。
- en: 'Our model defines a `MediaPlayer` class, which looks as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`MediaPlayer`类，其外观如下：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This really is everything we need. Now, we can use our media player in the
    following application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是我们需要的所有东西。现在，我们可以在以下应用中使用我们的媒体播放器：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the preceding code, we will see the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们将看到以下输出：
- en: '![](img/a14359fd-0bc3-4a61-b240-a059bb6e8acd.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a14359fd-0bc3-4a61-b240-a059bb6e8acd.png)'
- en: As you can see in the example output, the state changes on every button press
    and it performs a different action, which we've illustrated using a different
    print message.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例输出所示，每次按钮按下时都会改变状态，并执行不同的操作，我们使用不同的打印消息来展示这一点。
- en: A possible improvement to our application would involve making the state objects
    singletons. As you can see, they are always the same, so there really is no need
    to create new ones every single time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们应用程序的一个可能的改进是使状态对象成为单例。正如你所看到的，它们总是相同的，所以实际上没有必要每次都创建新的。
- en: What it is good for
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: The state design pattern is really useful for making code readable and getting
    rid of conditional statements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式对于使代码可读和消除条件语句非常有用。
- en: What it is not so good for
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: The state design pattern has no major drawbacks. One thing that developers should
    be careful about is the side effects caused by the change of the state of objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式没有重大缺点。开发者应该注意的一点是对象状态变化引起的副作用。
- en: The template method design pattern
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法设计模式
- en: Sometimes when we implement some algorithm or a family of algorithms, we define
    a common skeleton. Then later, the different implementations deal with the specifics
    of each method in the skeleton. The template method design pattern allows us to
    achieve what we mentioned previously.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当我们实现一些算法或算法族时，我们定义一个共同的骨架。然后，不同的实现处理骨架中每个方法的特定细节。模板方法设计模式使我们能够实现我们之前提到的。
- en: The purpose of the template method design pattern is to defer algorithm steps
    to subclasses using template methods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法设计模式的目的是通过模板方法将算法步骤推迟到子类。
- en: The template method design pattern seems really natural to object-oriented programming.
    Whenever polymorphism is used, this actually represents the design pattern itself.
    Usually, the template method is implemented using abstract methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法设计模式在面向对象编程中似乎非常自然。每当使用多态时，这实际上代表了设计模式本身。通常，模板方法是通过抽象方法实现的。
- en: Example class diagram
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: The template method design pattern is suitable for implementing frameworks.
    A typical thing here is that algorithms usually perform the same set of steps,
    and then these steps are implemented differently by different clients. You can
    come up with various possible use cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法设计模式适合实现框架。这里典型的事情是算法通常执行相同的步骤集合，然后不同的客户端以不同的方式实现这些步骤。你可以想出各种可能的使用案例。
- en: 'For our example, let''s imagine that we want to write an application that will
    read some data from a data source, parse it, and find whether there is an object
    that satisfies some condition and returns it. If we think about it, we have the
    following main operations:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，让我们假设我们想要编写一个应用程序，该程序将从数据源读取一些数据，解析它，并查找是否存在满足某些条件的对象并返回它。如果我们仔细想想，我们有以下主要操作：
- en: Read the data
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取数据
- en: Parse the data
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析数据
- en: Search for items satisfying the condition
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索满足条件的项目
- en: Clean up any resources if needed
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，请清理任何资源
- en: 'The following diagram shows the class diagram of our code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们的代码的类图：
- en: '![](img/8daa82f0-913c-41f8-b80f-4de4a9c2e8a4.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8daa82f0-913c-41f8-b80f-4de4a9c2e8a4.png)'
- en: We have used an example that we've shown before—reading data about people from
    files. Here, however, we use it in order to find data of the person that satisfies
    a filtering function. Using the template method design pattern, we can have the
    list of the people read from files with different formats from a server, database,
    or anything that comes to mind, really. Using polymorphism, our application makes
    sure that the right methods are called and everything works correctly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个之前展示过的示例——从文件中读取关于人的数据。然而，这里我们使用它来查找满足过滤函数的人的数据。使用模板方法设计模式，我们可以从服务器、数据库或任何想到的地方读取不同格式的文件中的人的列表。通过多态，我们的应用程序确保调用正确的方法，并且一切运行正常。
- en: Code example
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s go through the code that represents the preceding diagram and take a
    look at what it does. First of all, our model `Person` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看代表前面图表的代码，并看看它做了什么。首先，我们的`Person`模型类：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is nothing special about it. Now, let''s move on to the interesting part—the
    `DataFinder` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有什么特别的。现在，让我们继续到有趣的部分——`DataFinder`类：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have used generics in order to make this class usable for various types.
    As you can see in the preceding code, three of the methods of the `DataFinder`
    class have no implementations, but they are still referred to in the `find` method.
    The latter is the actual template method, and the abstract methods will be implemented
    in the different classes that extend the `DataFinder`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了泛型，以便使这个类适用于各种类型。正如您在前面的代码中所看到的，`DataFinder`类的三个方法没有实现，但它们仍然在`find`方法中被引用。后者是实际的模板方法，而抽象方法将在扩展`DataFinder`的不同类中实现。
- en: 'For our example, we have provided two different implementations, one for JSON and
    one for the CSV files. The JSON finder looks as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们提供了两种不同的实现，一个是针对JSON的，另一个是针对CSV文件的。JSON查找器如下所示：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The CSV finder has the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CSV查找器有以下代码：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever we use it, depending on what specific instance we have, the `find`
    method will call the right implementations through polymorphism. It is possible
    to add new formats and data sources by extending the `DataFinder` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们使用它，根据我们拥有的特定实例，`find`方法将通过多态调用正确的实现。通过扩展`DataFinder`类，可以添加新的格式和数据源。
- en: 'Using our data finders is now straightforward:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的数据查找器现在很简单：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have provided some example data files. The CSV has the following contents:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一些示例数据文件。CSV文件的内容如下：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following data is for the JSON file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数据是针对JSON文件的：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the preceding example against these datasets will produce the following
    output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的示例运行在这些数据集上会产生以下输出：
- en: '![](img/b306141c-93fd-4717-8962-23606b69910f.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b306141c-93fd-4717-8962-23606b69910f.png)'
- en: The code in our example uses an abstract class. This makes it slightly limiting
    in the sense that we can only extend one class. However, it would be straightforward
    to change the abstract class to a trait and then mix it into classes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的代码使用了一个抽象类。这在某种程度上使其有些限制，因为我们只能扩展一个类。然而，将抽象类更改为特性和将其混合到类中是非常直接的。
- en: What it is good for
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: As you can see, whenever we have a use case where the structure of an algorithm
    is the same and we provide different implementations, we can use the template
    method design pattern. This is a really good fit for creating frameworks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每当我们在算法结构相同且提供不同实现的情况下，我们都可以使用模板方法设计模式。这对于创建框架来说是一个非常合适的匹配。
- en: What it is not so good for
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用的情况
- en: Whenever the frameworks we implement using the template method design pattern
    become large, it is harder to simply extend a huge class and implement a few of
    its methods. In cases like these, passing an interface to the constructor and
    using it in the skeleton might be a better idea (strategy design pattern).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用模板方法设计模式实现的框架变得很大时，简单地扩展一个巨大的类并实现其中的一些方法会变得更加困难。在这些情况下，将接口传递给构造函数并在骨架中使用它可能是一个更好的主意（策略设计模式）。
- en: The visitor design pattern
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: There are some applications out there where during design time, not all possible
    use cases are known. There might be new application features coming out from time
    to time, and in order to implement them, some refactoring has to be done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有些应用程序在设计时，并不是所有可能的使用案例都是已知的。可能会有新的应用程序功能时不时地出现，为了实现它们，可能需要进行一些重构。
- en: The visitor design pattern helps us add new operations to existing object structures
    without modifying them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者设计模式帮助我们在不修改现有对象结构的情况下添加新的操作。
- en: This helps us to design our structures separately and then use the visitor design
    pattern to add functionality on top.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们分别设计我们的结构，然后使用访问者设计模式在顶部添加功能。
- en: Another case where the visitor design pattern could be useful is if we are building
    a big object structure with many different types of nodes that support different
    operations. Instead of creating a base node that has all the operations and only
    a few of them are implemented by the concrete nodes or use type casting, we could
    create visitors that will add the functionality we need where we need it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以使用访问者模式的情况是，如果我们正在构建一个包含许多不同类型节点的大对象结构，这些节点支持不同的操作。而不是创建一个具有所有操作的基础节点，只有少数具体节点实现了这些操作，或者使用类型转换，我们可以创建访问者，在需要的地方添加我们需要的功能。
- en: Example class diagram
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: Initially, when a developer sees the visitor design pattern, it seems that it
    can be easily replaced using polymorphism and can rely on the dynamic types of
    the classes. However, what if we have a huge type hierarchy? In such a case, every
    single change will have to change an interface as well, which will lead to changing
    a whole bunch of classes, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，当开发者看到访问者设计模式时，似乎它可以很容易地通过多态来替换，并且可以依赖于类的动态类型。然而，如果我们有一个庞大的类型层次结构呢？在这种情况下，每一个变化都将不得不改变一个接口，这将导致一大堆类的改变，等等。
- en: 'For our class diagram and example, let''s imagine that we are writing a text
    editor and we have documents. We want to be able to save each document in at least
    two data formats, but new ones could come. The following diagram shows the class
    diagram for our application that uses the visitor design pattern:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的类图和示例，让我们假设我们正在编写一个文本编辑器，并且我们有文档。我们希望能够以至少两种数据格式保存每个文档，但可能会有新的格式出现。以下图显示了使用访问者设计模式的我们的应用程序的类图：
- en: '![](img/d50c3004-14aa-4773-913b-260d42cede9b.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d50c3004-14aa-4773-913b-260d42cede9b.png)'
- en: As you can see in the preceding diagram, we have two seemingly disconnected
    hierarchies. The one to the left represents our document—each document is simply
    a list of different elements. All of them subclass the **Element** abstract class,
    which has an `accept` method that accepts a **Visitor**. To the right, we have
    the visitor hierarchy—each of our visitors will mix in the `Visitor` trait, which
    contains the `visit` methods with overrides for each of our document elements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个图所示，我们有两个看似不相关的层次结构。左侧代表我们的文档——每个文档只是一个不同元素的列表。所有这些元素都是**Element**抽象类的子类，它有一个`accept`方法，用于接受一个**Visitor**。右侧，我们有访问者层次结构——我们的每个访问者都将混入`Visitor`特质，其中包含为我们的文档元素每个都重写的`visit`方法。
- en: The way the visitor pattern will work is that it will create an instance of
    `Visitor` depending on what needs to be done, and then it will be passed to the
    `Document accept` method. This way, we can add extra functionality really easily
    (different formats, in our case), and the extra functionality will not involve
    any changes to the model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式的工作方式是，根据需要执行的操作创建一个`Visitor`实例，然后将其传递给`Document`的`accept`方法。这样，我们可以非常容易地添加额外的功能（在我们的例子中是不同的格式），并且额外的功能不会涉及对模型的任何更改。
- en: Code example
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s take a step-by-step look at the code that implements the visitor design
    pattern for the previous example. First of all, we have our model of the document
    and all the elements that can build it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步查看实现前一个示例的访问者设计模式的代码。首先，我们有文档的模型以及所有可以构建它的元素：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There is nothing special about the preceding code, just a simple subclassing
    for the different document elements and a composition for the `Document` class
    and the elements it contains. The important method here is `accept`. It takes
    a visitor, and since the trait type is given, we can pass different visitor implementations.
    In all the cases, it calls the `visit` method of the visitor with the current
    instance passed as a parameter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码没有什么特别之处，只是对不同文档元素进行简单子类化，以及`Document`类及其包含的元素进行组合。这里的重要方法是`accept`。它接受一个访问者，由于特质的类型已知，我们可以传递不同的访问者实现。在所有情况下，它都会调用访问者的`visit`方法，并将当前实例作为参数传递。
- en: 'Now, let''s have a look on the other side—the `Visitor` trait and its implementations.
    The `Visitor` trait looks as simple as this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一边——`Visitor`特质及其实现。`Visitor`特质看起来就像这样简单：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, it has overloads of the visit method with different concrete element
    types. In the preceding code, the visitors and elements allow us to use **double
    dispatch** in order to determine which calls will be made.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它具有具有不同具体元素类型的`visit`方法的重载。在上述代码中，访问者和元素允许我们使用**双重分派**来确定哪些调用将被执行。
- en: 'Now, let''s have a look at the concrete `Visitor` implementations. The first
    one is the `HtmlExporterVisitor`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具体的`Visitor`实现。第一个是`HtmlExporterVisitor`：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It simply provides different implementations depending on what type of `Element`
    it gets. There are no conditional statements, just overloads.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地根据获取到的`Element`类型提供不同的实现。没有条件语句，只有重载。
- en: 'If we want to save the document we have in plain text, we can use the `PlainTextExporterVisitor`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以纯文本格式保存我们拥有的文档，我们可以使用`PlainTextExporterVisitor`：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After having the visitors and the document structure, wiring everything up
    is pretty straightforward:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了访问者和文档结构之后，将一切连接起来相当直接：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding example shows how to use both the visitors we implemented. The
    output of our program is shown in the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了如何使用我们实现的两个访问者。我们的程序输出如下截图所示：
- en: '![](img/8869ffc0-c488-49cd-90c5-aba15deaeb2e.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8869ffc0-c488-49cd-90c5-aba15deaeb2e.png)'
- en: As you can see, using the visitor is simple. Adding new visitors and new formats
    in our case is even easier. We just need to create a class that implements all
    the visitor methods and use it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用访问者很简单。在我们的例子中，添加新的访问者和新的格式甚至更容易。我们只需要创建一个实现了所有访问者方法的类，并使用它。
- en: The visitor design pattern the Scala way
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala风格的访问者设计模式
- en: As with many other design patterns we saw earlier, the visitor design pattern
    could be represented in a way that is less verbose and closer to Scala. The way
    things can be done in order to implement a visitor in Scala is the same as the
    strategy design pattern—pass functions to the `accept` method. Moreover, we can
    also use pattern matching instead of having multiple different `visit` methods
    in the `Visitor` trait.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的许多其他设计模式一样，访问者设计模式可以用一种更简洁、更接近Scala的方式表示。在Scala中实现访问者的方式与策略设计模式相同——将函数传递给`accept`方法。此外，我们还可以使用模式匹配而不是在`Visitor`特质中拥有多个不同的`visit`方法。
- en: In this subsection, we will show both the improvement steps. Let's start with
    the latter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将展示改进步骤。让我们从后者开始。
- en: 'First of all, we need to make the model classes case classes in order to be
    able to use them in pattern matching:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将模型类转换为case类，以便能够在模式匹配中使用它们：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we change our `Visitor` trait to the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的`Visitor`特质更改为以下内容：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since we will be using pattern matching, we will only need one method to implement
    it. Finally, we can have our visitor implementations as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用模式匹配，我们只需要一个方法来实现它。最后，我们可以将我们的访问者实现如下：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Pattern matching is similar to the `instanceOf` checks in Java; however, it
    is a powerful feature of Scala and it is quite commonly used. Our example, then,
    doesn't need to change at all and the output will be the same as before.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配类似于 Java 中的 `instanceOf` 检查；然而，它是 Scala 的一个强大特性，并且相当常用。因此，我们的示例无需任何更改，输出将与之前相同。
- en: 'Next, we will show how we can pass functions instead of visitor objects. The
    fact that we will be passing functions means that now, we can change our model
    to the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何我们可以传递函数而不是访问者对象。我们将传递函数的事实意味着现在，我们可以将我们的模型更改为以下形式：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We moved the `accept` method implementation to the base `Element` class (which
    can also be represented as a trait) and inside this, we simply called the function
    passed as parameter. Since we will be passing functions, we can get rid of the
    `Visitor` trait and its implementations. Everything we have now is the example,
    which looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `accept` 方法实现移至基类 `Element`（也可以表示为特质）中，并在其中简单地调用了作为参数传递的函数。由于我们将传递函数，我们可以去掉
    `Visitor` 特质及其实现。我们现在所拥有的就是以下示例：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have moved the visitor functionality inside the functions that are part of
    the `VisitorExample` object. In the initial examples, we had a `StringBuilder`
    as part of the visitor classes. We have used curried functions in order to be
    able to pass one here. Passing these functions to the `Document` structure is
    then straightforward. Again, the result here will be identical to the previous
    versions of the example. However, we can see how much code and boilerplate classes
    we have saved.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问者功能移至 `VisitorExample` 对象的组成部分中。在初始示例中，我们有一个 `StringBuilder` 作为访问者类的一部分。我们使用了柯里化函数以便能够在这里传递。将这些函数传递给
    `Document` 结构是直截了当的。再次强调，这里的输出将与示例的先前版本完全相同。然而，我们可以看到我们节省了多少代码和样板类。
- en: What it is good for
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它擅长什么
- en: The visitor design pattern is really good for applications that have large object
    hierarchies, where adding a new functionality will involve a lot of refactoring.
    Whenever we need to be able to do multiple different things with an object hierarchy
    and when changing the object classes could be problematic, the visitor design
    pattern is a useful alternative.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者设计模式非常适合具有大型对象层次结构的应用程序，其中添加新功能将涉及大量重构。每当我们需要能够对对象层次结构执行多种不同操作，并且更改对象类可能有问题时，访问者设计模式是一个有用的替代方案。
- en: What it is not so good for
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不擅长什么
- en: As you saw in the initial version of our example, the visitor design pattern
    could be bulky and include quite a lot of boilerplate code. Moreover, if some
    component is not designed to support the pattern, we cannot really use it if we
    are not allowed to change the original code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们示例的初始版本中所见，访问者设计模式可能会很庞大，包含相当多的样板代码。此外，如果某些组件未设计为支持该模式，如果我们不允许更改原始代码，我们实际上无法使用它。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the second group of behavioral design patterns.
    You are now familiar with iterators, mediators, memento, observer, state, template
    method, and the visitor design pattern. You might feel that these are purely object-oriented
    design patterns that don't have much to do with functional programming, and you
    would be correct. However, they are still relevant to Scala due to its hybrid
    nature and it is important to be aware of them and to know when to use them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了行为设计模式的第二组。你现在熟悉了迭代器、调解者、备忘录、观察者、状态、模板方法和访问者设计模式。你可能觉得这些纯粹是面向对象的设计模式，与函数式编程关系不大，你是对的。然而，由于
    Scala 的混合性质，它们仍然与 Scala 相关，了解它们以及何时使用它们是很重要的。
- en: Some of the design patterns in this chapter are quite commonly used and can
    be seen in many projects, while others are a bit more rare and specific to some
    use cases. These patterns, combined with all the other ones you learned about
    in the previous chapters, can be used together in order to build elegant and powerful
    solutions to real-world problems.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些设计模式相当常用，可以在许多项目中看到，而其他一些则相对较少见，且特定于某些用例。这些模式，结合你在前几章中学到的所有其他模式，可以一起使用，以构建优雅且强大的现实世界问题的解决方案。
- en: In the next chapter, we will dive deep into functional programming theory. We
    will cover some advanced concepts that will show us how powerful Scala and functional
    programming languages in general are.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨函数式编程理论。我们将介绍一些高级概念，这些概念将展示Scala以及一般函数式编程语言是多么强大。
