- en: Java CPU Profiling and Memory Tracking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java CPU分析器和内存跟踪
- en: In the previous chapter, we learned how to use the JMS (Java Messaging Service)
    APIs to write asynchronous applications. In this chapter, we will learn about
    some of the techniques and tools used to profile Java applications. Enterprise
    applications tend to be quite complex and big. There could be situations where
    the application does not perform as per your requirements or expectations. For
    example, some of the operations performed in the application might be taking too
    long or consuming more memory than you expected. Furthermore, debugging performance
    and memory issues can sometimes become very difficult.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用JMS（Java消息服务）API编写异步应用程序。在本章中，我们将了解一些用于分析Java应用程序的技术和工具。企业应用程序往往相当复杂且庞大。可能存在应用程序不符合你的要求或预期的情况。例如，应用程序中执行的一些操作可能花费的时间过长或消耗的内存比你预期的要多。此外，调试性能和内存问题有时可能变得非常困难。
- en: Fortunately, there are tools available, both in JDK and Eclipse, to help us
    debug these issues. JDK 6 (update 7) and above are bundled with the **jVisualVM**
    application that can connect to remote or local applications. You can find this
    tool in the `<JDK_HOME>/bin` folder. jVisualVM can help you profile memory and
    CPU usage. It can also be configured to launch from Eclipse when an application
    is run from Eclipse. We will learn how to use VisualVM to profile Java applications
    in this chapter. You can find detailed information about jVisualVM/VisualVM at [https://visualvm.github.io/](https://visualvm.github.io/).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JDK和Eclipse都提供了工具来帮助我们调试这些问题。JDK 6（更新7）及以上版本捆绑了**jVisualVM**应用程序，该程序可以连接到远程或本地应用程序。你可以在`<JDK_HOME>/bin`文件夹中找到这个工具。jVisualVM可以帮助你分析内存和CPU使用情况。它还可以配置为在从Eclipse运行应用程序时从Eclipse启动。我们将在本章中学习如何使用VisualVM来分析Java应用程序。你可以在[https://visualvm.github.io/](https://visualvm.github.io/)找到有关jVisualVM/VisualVM的详细信息。
- en: We will create a small standalone Java application to simulate performance and
    memory issues, and will see how to use VisualVM for troubleshooting. Although
    the real applications that you may want to troubleshoot will be a lot more complex,
    the techniques that we will learn in this chapter can be used for complex applications
    too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个独立的Java应用程序来模拟性能和内存问题，并了解如何使用VisualVM进行故障排除。虽然你可能想要调试的实际应用程序可能要复杂得多，但我们将在本章中学到的技术也可以用于复杂的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: CPU and memory profiling using VisualVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VisualVM进行CPU和内存分析
- en: Techniques to detect memory leaks and deadlocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测内存泄漏和死锁的技术
- en: Using the Eclipse Memory Analyzer to analyze heap dumps created from VisualVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse内存分析器分析由VisualVM创建的堆转储
- en: Creating a sample Java project for profiling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于性能分析的示例Java项目
- en: We will create a simple standalone Java application so that it is easy for you
    to learn how to profile using VisualVM. Although it will be a standalone application,
    we will create classes that are similar to those we created for the `CourseManagement`
    web application in some of the previous chapters, particularly `CourseDTO`, `CourseBean`
    (JSP bean), `CourseService` (service bean), and `CourseDAO` (for database access).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的独立Java应用程序，这样你就可以轻松学习如何使用VisualVM进行性能分析。虽然它将是一个独立的应用程序，但我们将创建一些类，这些类与我们在前几章中为`CourseManagement`
    Web应用程序创建的类相似，特别是`CourseDTO`、`CourseBean`（JSP Bean）、`CourseService`（服务Bean）和`CourseDAO`（用于数据库访问）。
- en: 'Create a standard Java project in Eclipse, named `CourseManagementStandalone`.
    Create the `CourseDTO` class in the `packt.jee.eclipse.profile.dto` package:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中创建一个名为`CourseManagementStandalone`的标准Java项目。在`packt.jee.eclipse.profile.dto`包中创建`CourseDTO`类：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `CourseDAO` class in the `packt.jee.eclopse.profile.dao` package:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclopse.profile.dao`包中创建`CourseDAO`类：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have simulated a long-running database operation in the `getCourses` method
    by making the thread sleep for a few seconds.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使线程休眠几秒钟来在`getCourses`方法中模拟了一个长时间运行的数据库操作。
- en: 'Create the `CourseService` class in the `packt.jee.eclipse.profile.service`
    package:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclipse.profile.service`包中创建`CourseService`类：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`CourseService.getCourses` delegates the call to `CourseDAO`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseService.getCourses`将调用委托给`CourseDAO`。'
- en: 'Create the `CourseBean` class in the `packt.jee.eclipse.profile.bean` package:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclipse.profile.bean`包中创建`CourseBean`类：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`CourseBean.getcourses` delegates to `CourseService`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseBean.getcourses`将调用委托给`CourseService`。'
- en: 'Finally, create the `CourseManagement` class in the `packt.jee.eclipse.profile`
    package. This class contains the `main` method and starts the loop to call the `getCourses`
    method repeatedly after reading any character from the standard input:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`packt.jee.eclipse.profile`包中创建`CourseManagement`类。此类包含`main`方法，并在读取标准输入的任何字符后重复调用`getCourses`方法：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the application (right-click on the file and select Run As | Java Application).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序（右键单击文件并选择运行方式 | Java应用程序）。
- en: In the console window, type any character and press *Enter*. You should see
    the Getting courses and Got courses messages.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在控制台窗口中，输入任何字符并按*Enter*。您应该看到“获取课程”和“获取课程”的消息。
- en: Profiling the Java application
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Java应用程序
- en: 'Run jvisualvm from the `<JDK_HOME>/bin` folder:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`<JDK_HOME>/bin`文件夹运行jvisualvm：
- en: '![](img/00210.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00210.jpeg)'
- en: 'Figure 11.1: Java VisualVM profiler'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：Java VisualVM分析器
- en: VisualVM lists all the Java processes that can be profiled by it on the local
    machine under the Local node. You can see VisualVM itself listed along with Eclipse.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM列出了本地节点下可以由它分析的本地所有Java进程。您可以看到VisualVM本身以及Eclipse被列出。
- en: 'Once you run the `CourseManagement` application, the process should also show
    up under Local:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行了`CourseManagement`应用程序，该进程也应该在本地显示：
- en: '![](img/00211.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00211.jpeg)'
- en: 'Figure 11.2: The CourseManagement application available for profiling'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：可用于分析的CourseManagement应用程序
- en: 'Double-click on the process (or right-click and select Open). Then, go to the
    Profile tab and click on the CPU button:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击进程（或右键单击并选择打开）。然后，转到Profile选项卡并单击CPU按钮：
- en: '![](img/00212.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00212.jpeg)'
- en: 'Figure 11.3: VisualVM Profiler tab'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：VisualVM分析器选项卡
- en: You should see the status set as profiling running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到状态设置为分析运行。
- en: After starting CPU profiling, if you get an error such as Redefinition failed
    with error 62, try running the application with the `-XVerify:none` parameter.
    In Eclipse, select the Run | Run Configurations menu and then select the CourseManagement
    application under the Java Application group. Go to the Arguments tab and add `-Xverify:none`
    to VM arguments. Run the application again.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始CPU分析后，如果您遇到错误，例如“重新定义失败，错误代码62”，请尝试使用`-XVerify:none`参数运行应用程序。在Eclipse中，选择Run
    | Run Configurations菜单，然后在Java Application组下选择CourseManagement应用程序。转到Arguments选项卡，并将`-Xverify:none`添加到VM
    arguments。再次运行应用程序。
- en: 'In the VisualVM Profiler page, click on the Settings checkbox to see the packages
    included for profiling. Note that VisualVM selects these packages automatically:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VisualVM分析器页面，单击设置复选框以查看用于分析的包。请注意，VisualVM会自动选择这些包：
- en: '![](img/00213.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00213.jpeg)'
- en: 'Figure 11.4: VisualVM Profiler settings'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：VisualVM分析器设置
- en: You must stop CPU profiling to edit the settings. However, we will retain the
    default settings. Uncheck the Settings box to hide the settings.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须停止CPU分析才能编辑设置。然而，我们将保留默认设置。取消选中设置框以隐藏设置。
- en: 'Click on the Monitor table for the overview of profiling activities:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Monitor表以查看分析活动的概述：
- en: '![](img/00214.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00214.jpeg)'
- en: 'Figure 11.5: Overview of profiling activities'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：分析活动概述
- en: 'Now, let''s execute the `getCourse` method in our application. Go to the console
    view of Eclipse in which our application is running, type a character (other than
    `q`), and hit *Enter*. Go to the Profiler tab of VisualVM to view the profiled
    data:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的应用程序中执行`getCourse`方法。转到Eclipse的控制台视图，其中我们的应用程序正在运行，输入一个字符（除了`q`），然后按*Enter*。转到VisualVM的Profiler选项卡以查看分析数据：
- en: '![](img/00215.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00215.jpeg)'
- en: 'Figure 11.6: CPU profiling of CourseManagement'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：CourseManagement的CPU分析
- en: Observe the Self time column. This indicates the CPU time or the elapsed time
    to execute the corresponding method, excluding the time taken to execute other
    methods called from this method. In our case, `CourseDAO.getCourses` took the
    maximum time, so it is at the top of the list. This report could help you identify
    the bottlenecks in your application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 观察Self time列。这表示CPU时间或执行相应方法所花费的流逝时间，不包括执行从该方法调用的其他方法的时间。在我们的案例中，`CourseDAO.getCourses`花费了最长时间，因此它位于列表的顶部。这份报告可以帮助您识别应用程序中的瓶颈。
- en: Identifying resource contention
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别资源竞争
- en: 'In a multithreaded application, it is typical for threads to lock or wait for
    a lock. The thread dump can be used for identifying resource contentions. Let''s
    simulate this scenario in our application by modifying the main method of the `CourseManagement`
    class to call `courseBean.getCourses` in separate threads:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，线程锁定或等待锁是很常见的。线程转储可用于识别资源竞争。让我们通过修改`CourseManagement`类的`main`方法来在我们的应用程序中模拟此场景，以在单独的线程中调用`courseBean.getCourses`：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we create a new `Thread` object in the `while` loop and call `courseBean.getCourses`
    in the `run` method of the thread. The `while` loop does not wait for `getCourses`
    to return results and can process the next user input immediately. This will allow
    us to simulate resource contention.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在`while`循环中创建一个新的`Thread`对象，并在线程的`run`方法中调用`courseBean.getCourses`。`while`循环不等待`getCourses`返回结果，可以立即处理下一个用户输入。这将允许我们模拟资源竞争。
- en: 'To actually cause resource contention, let''s synchronize `CourseService.getCourses`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '要实际引起资源竞争，让我们同步`CourseService.getCourses`:'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The synchronized `getCourses` method will result in only one thread executing
    this method in an instance of the `CourseService` class. We can now trigger multiple
    `getCourses` calls simultaneously by typing characters in the console without
    waiting for the previous calls to the `getCourse` method to return. To give us
    more time to get the thread dump, let''s increase the thread sleep time in `CourseDAO.getCourses`
    to, say, 30 seconds:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同步的`getCourses`方法将导致只有一个线程在`CourseService`类的实例中执行此方法。现在我们可以通过在控制台中输入字符来同时触发多个`getCourses`调用，而不必等待对`getCourse`方法的先前调用返回。为了给我们更多的时间获取线程转储，让我们将`CourseDAO.getCourses`中的线程睡眠时间增加到，比如说，30秒：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the application and let''s start monitoring this process in VisualVM. In
    the console window where the application is running in Eclipse, type a character
    and press *Enter*. Repeat this one more time. Now, two calls to `getCourses` will
    be triggered. In VisualVM, go to the Threads tab and click on the ThreadDump button.
    A new thread dump will be saved under the process node and will be displayed in
    a new tab. Look for threads starting with the `getCourseThread` prefix. Here is
    a sample thread dump of two `getCourseThreads`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并在VisualVM中开始监控此进程。在Eclipse中运行应用程序的控制台窗口中，输入一个字符并按*Enter*。重复一次。现在，将触发两个`getCourses`调用。在VisualVM中，转到线程选项卡并单击ThreadDump按钮。一个新的线程转储将保存在进程节点下，并在新选项卡中显示。查找以`getCourseThread`为前缀的线程。以下是两个`getCourseThreads`的示例线程转储：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding thread dumps, it is clear that `getCourseThread2` is waiting
    (`to lock <0x00000007aaf57a80>`) and that `getCourseThread1` is holding lock on
    the same object (`locked <0x00000007aaf57a80>`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的线程转储中可以看出，`getCourseThread2`正在等待（`to lock <0x00000007aaf57a80>`）而`getCourseThread1`正在持有对该对象的锁（`locked
    <0x00000007aaf57a80>`）。
- en: 'Using the same technique (of inspecting locks), you can also detect deadlocks
    in the application. In fact, VisualVM can detect deadlocks and explicitly point
    to threads that are deadlocked. Let''s modify the `main` method in the `CourseManagement`
    class to cause a deadlock. We will create two threads and make them lock two objects
    in the reverse order:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的技巧（检查锁），你还可以在应用程序中检测死锁。实际上，VisualVM可以检测死锁并明确指出死锁的线程。让我们修改`CourseManagement`类的`main`方法来引起死锁。我们将创建两个线程并使它们以相反的顺序锁定两个对象：
- en: Warning
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The following code will cause the application to hang. You will have to kill
    the process to exit.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将使应用程序挂起。你必须杀死进程才能退出。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`MyThread1` first locks `obj1` and then it tries to lock `obj2`, whereas `MyThread2`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyThread1`首先锁定`obj1`然后尝试锁定`obj2`，而`MyThread2`'
- en: 'locks `obj2` first and then tries to lock `obj1`. When you monitor this application
    using VisualVM and switch to the Threads tab, you will see the Deadlock detected!
    message:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先锁定`obj2`然后尝试锁定`obj1`。当你使用VisualVM监控此应用程序并切换到线程选项卡时，你会看到“检测到死锁！”的消息：
- en: '![](img/00216.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00216.jpeg)'
- en: 'Figure 11.7: Detecting deadlock with VisualVM'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：使用VisualVM检测死锁
- en: 'If you take the thread dump, it will specifically show you where the deadlock
    is caused:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你获取线程转储，它将特别显示死锁的原因：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Memory tracking
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存跟踪
- en: 'VisualVM can be used to monitor memory allocations and detect possible memory
    leaks. Let''s modify our application to simulate a large memory allocation that
    has not been released. We will modify the `CourseService` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM可以用来监控内存分配并检测可能的内存泄漏。让我们修改我们的应用程序来模拟一个未释放的大内存分配。我们将修改`CourseService`类：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `getCourses` method, we will create a large byte array and store it
    in a member variable. The memory allocated to the array will not be released until
    the instance of `CourseService` is not garbage collected. Now, let''s see how
    this memory allocation shows up in VisualVM. Start monitoring the process and
    go to the Profiler tab. Click on the Memory button to start monitoring memory.
    Now, go back to the console window in Eclipse and enter a character to trigger
    the `getCourses` method. Go to VisualVM to inspect the memory profiling report:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getCourses`方法中，我们将创建一个大的字节数组并将其存储在一个成员变量中。分配给数组的内存将不会释放，直到`CourseService`实例不被垃圾回收。现在，让我们看看这个内存分配如何在VisualVM中显示出来。开始监控进程并转到Profiler标签页。单击Memory按钮开始监控内存。现在，回到Eclipse的控制台窗口并输入一个字符以触发`getCourses`方法。转到VisualVM以检查内存分析报告：
- en: '![](img/00217.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00217.jpeg)'
- en: 'Figure 11.8: Memory monitoring with VisualVM'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：使用VisualVM进行内存监控
- en: 'This report shows the live status of the memory consumed by different objects
    in the application. However, if you want to analyze and find where exactly the
    allocation is made, then take a heap dump. Go to the Monitor tab and click on
    the Heap Dump button. The heap dump report is saved under the process node. Click
    on the Classes button in the heap dump report, and then click on the Size column
    to sort objects in descending order of the amount of memory consumed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此报告显示了应用程序中不同对象消耗的内存的实时状态。然而，如果您想分析和找到确切的分配位置，那么请进行堆转储。转到Monitor标签页并单击Heap Dump按钮。堆转储报告保存在进程节点下。在堆转储报告中单击Classes按钮，然后单击Size列按内存消耗量降序排序对象：
- en: '![](img/00218.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00218.jpeg)'
- en: 'Figure 11.9: Classes in the heap dump report'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：堆转储报告中的类
- en: 'According to the report, `byte[]` takes up the maximum memory in our application.
    To find where the memory is allocated, double-click on the row containing `byte[]`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据报告，`byte[]`在我们的应用程序中占用最大内存。要找到内存分配的位置，双击包含`byte[]`的行：
- en: '![](img/00219.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00219.jpeg)'
- en: 'Figure 11.10: Object instance report in heap dump'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：堆转储中的对象实例报告
- en: The references window at the bottom-right shows objects holding a reference
    to the selected instance in the top-left window. As you can see, a reference to
    `byte[]` is held by the `cachedData` field of `CourseServe`. Furthermore, a reference
    to `CourseService` is held by `CourseBean`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 右下角的引用窗口显示了在左上窗口中选中实例持有引用的对象。如图所示，`byte[]`的引用由`CourseServe`的`cachedData`字段持有。此外，`CourseService`的引用由`CourseBean`持有。
- en: Large memory allocation does not necessarily mean a memory leak. You may want
    to keep a reference to a large object in your application. However, the heap dump
    can help you find where the memory was allocated and if that instance is intended
    to be in the memory. If not, you could find where the memory was allocated and
    release it at the appropriate place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大量内存分配并不一定意味着内存泄漏。您可能想在应用程序中保留对大对象的引用。然而，堆转储可以帮助您找到内存分配的位置以及该实例是否打算保留在内存中。如果不是，您可以在适当的位置找到内存分配并释放它。
- en: The heap dump that we have taken will be lost if we restart VisualVM. Therefore,
    save it to the disk; to do so, right-click on the Heap Dump node and select Save
    As. We will use this heap dump in the Eclipse Memory Analyzer in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所取的堆转储如果重启VisualVM将会丢失。因此，请将其保存到磁盘上；为此，右键单击堆转储节点并选择另存为。我们将在下一节中使用这个堆转储在Eclipse内存分析器中。
- en: Eclipse plugins for profiling memory
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse内存分析插件
- en: The Eclipse Memory Analyzer ([https://eclipse.org/mat/](https://eclipse.org/mat/))
    can be used to analyze heap dumps created by VisualVM. It provides additional
    features such as auto memory leak detection. Furthermore, by using it as an Eclipse
    plugin, you can quickly jump to the source code from the heap dump reports. You
    can use this tool either as a standalone application or as an Eclipse plugin.
    We will see how to use it as an Eclipse plugin in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse内存分析器([https://eclipse.org/mat/](https://eclipse.org/mat/))可以用来分析VisualVM创建的堆转储。它提供了额外的功能，如自动内存泄漏检测。此外，通过将其作为Eclipse插件使用，您可以从堆转储报告中快速跳转到源代码。您可以使用此工具作为独立应用程序或作为Eclipse插件。我们将在本节中看到如何将其用作Eclipse插件。
- en: 'To install the Memory Analyzer plugin and analyze the memory dump, perform
    the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装内存分析器插件并分析内存转储，请执行以下步骤：
- en: 'Open Eclipse Marketplace (select the Help | Eclipse Marketplace menu). Search
    for `Memory Analyzer` and install the plugin:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse Marketplace（选择Help | Eclipse Marketplace菜单）。搜索“Memory Analyzer”并安装插件：
- en: '![](img/00220.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00220.jpeg)'
- en: 'Figure 11.11: Searching for the Memory Analyzer plugin in Eclipse Marketplace'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：在Eclipse Marketplace中搜索内存分析器插件
- en: 'Open the heap dump that you saved in the previous section. Select the File
    | Open File menu and select the `.hprof` file that has been saved by VisualVM.
    Memory Analyzer will prompt you to select a report type:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一节中保存的堆转储文件。选择“文件”|“打开文件”菜单，并选择由VisualVM保存的`.hprof`文件。内存分析器将提示您选择报告类型：
- en: '![](img/00221.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00221.jpeg)'
- en: 'Figure 11.12: Eclipse Memory Analyzer: Getting Started Wizard'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：Eclipse内存分析器：入门向导
- en: 'Select Leak Suspects Report and click on Finish. The Eclipse Memory Analyzer
    creates the Leak Suspects report with a couple of Problem Suspects:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“泄漏嫌疑报告”并点击“完成”。Eclipse内存分析器创建带有几个问题嫌疑人的泄漏嫌疑报告：
- en: '![](img/00222.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00222.jpeg)'
- en: 'Figure 11.13: Eclipse Memory Analyzer: Leak Suspect report'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：Eclipse内存分析器：泄漏嫌疑报告
- en: 'Click on the Details link in the first Problem Suspect:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个问题嫌疑人的“详细信息”链接上点击
- en: '![](img/00223.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00223.jpeg)'
- en: 'Figure 11.14: Eclipse Memory Analyzer: Details of Problem Suspect'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：Eclipse内存分析器：问题嫌疑详情
- en: The report clearly identifies `cachedData` in `CourseService` as a leak suspect.
    To open the source file, click on the node and select the Open Source File option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 报告清楚地将`CourseService`中的`cachedData`识别为泄漏嫌疑。要打开源文件，请点击节点并选择“打开源文件”选项。
- en: Memory Analyzer also provides many other useful reports. Refer to [http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html](http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html) for
    more details.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器还提供了许多其他有用的报告。有关更多详细信息，请参阅[http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html](http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html)。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The VisualVM tool that is shipped with JDK 6 and above is useful for detecting
    performance bottlenecks and memory leaks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随JDK 6及以上版本一起提供的VisualVM工具对于检测性能瓶颈和内存泄漏很有用。
- en: In this chapter, we learned how to use this tool in a simple Java application.
    However, the technique can be used in large applications too. The Eclipse Memory
    Analyzer can be used to quickly detect memory leaks from a heap dump. In the next
    chapter we will learn how to develop Microservices in JEE.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在简单的Java应用程序中使用此工具。然而，这项技术也可以用于大型应用程序。可以使用Eclipse内存分析器快速从堆转储中检测内存泄漏。在下一章中，我们将学习如何在JEE中开发微服务。
