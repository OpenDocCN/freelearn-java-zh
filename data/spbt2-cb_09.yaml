- en: Spring Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Getting started with Spring Cloud
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud入门
- en: Service discovery using Spring Cloud Consul
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Consul进行服务发现
- en: Using Spring Cloud Netflix—Feign
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Netflix—Feign
- en: Service discovery using Spring Cloud Netflix—Eureka
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Netflix—Eureka进行服务发现
- en: Using Spring Cloud Netflix—Hystrix
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Netflix—Hystrix
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Throughout this book, we have learned how to create an application, configure
    RESTful services, do testing, integrate metrics and other management components,
    and handle packaging and deployment, among other things. Now, the time has come
    to look at the world outside the application—the ubiquitous cloud environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们学习了如何创建应用程序、配置RESTful服务、进行测试、集成指标和其他管理组件，以及处理打包和部署等。现在，是时候看看应用程序之外的世界——无处不在的云环境了。
- en: In this chapter, we will look at how to make applications cloud-friendly, how
    to deal with the dynamic nature of the distributed applications running in the
    cloud, how to make our applications visible to the world, how to discover other
    service endpoints, how to call them, and how to handle various error conditions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使应用程序适合云环境，如何处理在云中运行的分布式应用程序的动态特性，如何使我们的应用程序对世界可见，如何发现其他服务端点，如何调用它们，以及如何处理各种错误条件。
- en: Getting started with Spring Cloud
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud入门
- en: The Spring Cloud family of projects provides integration extensions for Spring
    Boot of various frameworks, which offer functionality for distributed service
    discovery, configuration, routing, service invocation, and more. Through the use
    of uniform API, we can add these concepts to our applications and later have the
    flexibility to change the specific implementation if such a need arises without
    making deep-cutting changes to our codebase.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud项目家族为Spring Boot提供了各种框架的集成扩展，这些框架提供了分布式服务发现、配置、路由、服务调用等功能。通过使用统一的API，我们可以将这些概念添加到我们的应用程序中，并在需要时灵活地更改具体实现，而无需对代码库进行重大修改。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start by enhancing our `BookPub` project with base Spring Cloud modules
    by adding them to the main build configuration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过将它们添加到主构建配置中，增强我们的`BookPub`项目的基础Spring Cloud模块：
- en: 'Add the following content to the `build.gradle` file located at the root of
    the project:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到项目根目录下的`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`启动应用程序
- en: 'After the application has been started, even though it seems like nothing new
    has happened, if we open our browser at `http://localhost:8081/actuator/env` (the
    management endpoint for environment), we will see new property sources appear:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动后，即使看起来没有发生任何新的事情，如果我们打开浏览器到`http://localhost:8081/actuator/env`（环境的管理端点），我们将看到新的属性源出现：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a `bootstrap.properties` file under the `src/main/resources` directory
    from the root of our project with the following content (the same properties should
    be commented out inside `application.properties` at this point):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下的`src/main/resources`目录下创建一个`bootstrap.properties`文件，内容如下（此时应在`application.properties`文件中相应地注释掉相同的属性）：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`启动应用程序
- en: 'After the application has been started, open our browser at `http://localhost:8081/env`
    and we will see new property sources appear:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动后，打开我们的浏览器到`http://localhost:8081/env`，我们将看到新的属性源出现：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we dive under the hood of how things work, let''s review the changes
    that we have made to our project. The first step was to enhance the `build.gradle`
    build configuration by importing a **Bill of Material** (**BOM**) declaration
    for a Spring Cloud release train—`mavenBom ''org.springframework.cloud:spring-cloud-dependencies:
    Finchley.BUILD-SNAPSHOT''`. While we could have selectively imported explicitly-defined
    versions of the `spring-cloud-context` and `spring-cloud-commons` libraries, by
    relying on a packaged BOM, we are sure that we will be using the correct versions
    of different artifacts that have been tested for compatibility with each other.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们深入探讨事物的工作原理之前，让我们回顾一下我们对项目所做的更改。第一步是增强`build.gradle`构建配置，通过导入Spring Cloud发布列车的一个**物料清单**（**BOM**）声明——`mavenBom
    ''org.springframework.cloud:spring-cloud-dependencies: Finchley.BUILD-SNAPSHOT''`。虽然我们可以选择性地导入显式定义的`spring-cloud-context`和`spring-cloud-commons`库的版本，但通过依赖打包的BOM，我们可以确保我们将使用经过相互兼容性测试的不同组件的正确版本。'
- en: Specific versions of each Spring Cloud modules that are included in a particular
    Release Train can be seen at [http://cloud.spring.io/](http://cloud.spring.io/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定发布列车中包含的每个Spring Cloud模块的特定版本可以在[http://cloud.spring.io/](http://cloud.spring.io/)中查看。
- en: 'We start by adding dependencies on the `spring-cloud-context` and `spring-cloud-commons`
    libraries, to illustrate the basic common facilities Spring Cloud provides, before
    diving into a specific starter integration such as `spring-cloud-netflix` or `spring-cloud-consul`.
    Those basic libraries provide a foundation of interfaces and common functionality
    that is being used to build upon in all the different cloud-specific integrations.
    Here is what their purpose is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了对`spring-cloud-context`和`spring-cloud-commons`库的依赖，以展示Spring Cloud提供的基本通用设施，然后再深入到特定启动器集成，例如`spring-cloud-netflix`或`spring-cloud-consul`。这些基本库提供了一个接口和通用功能的基础，这些功能被用于构建所有不同的特定云集成。以下是它们的目的：
- en: '`spring-cloud-commons`: This provides a collection of shared common interfaces
    and base classes that define the notions of service discovery, service routing,
    load balancing, circuit breaking, feature capabilities, and some basic configuration.
    For example, this is the library that autoconfigures the environment with the `springCloudClientHostInfo`
    property source.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-commons`：这个库提供了一系列共享的通用接口和基类，定义了服务发现、服务路由、负载均衡、断路器、功能能力和一些基本配置的概念。例如，这就是自动配置环境为`springCloudClientHostInfo`属性源的库。'
- en: '`spring-cloud-context`: This is the base foundation that is responsible for
    bootstrapping and configuring the various integrations, such as a specific implementation
    of service discovery like Consul, or a specific implementation of circuit breaker
    like **Hystrix**. This is achieved by creating an isolated Bootstrap application
    context, which is responsible for loading and configuring all the components before
    the main application is started.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-context`：这是负责引导和配置各种集成的基础，例如特定的服务发现实现如Consul，或特定的断路器实现如**Hystrix**。这是通过创建一个隔离的引导应用程序上下文来实现的，该上下文负责在主应用程序启动之前加载和配置所有组件。'
- en: Bootstrap application context gets created early on in the application start
    cycle and it is configured by a separate file—`bootstrap.properties` (a YAML variant
    is also supported). Since it is very typical for an application running in the
    cloud to rely on many external sources of configuration, service lookup, and so
    on, the purpose of the Bootstrap context is to configure those functions and obtain
    all of the necessary configuration from outside.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引导应用程序上下文在应用程序启动周期早期创建，并且它由一个单独的文件配置——`bootstrap.properties`（也支持YAML变体）。由于在云中运行的应用程序通常依赖于许多外部配置源、服务查找等，引导上下文的目的就是配置这些功能并从外部获取所有必要的配置。
- en: To clearly separate application configuration from Bootstrap, we put things
    that describe the application, or configure external configs, or other environmental
    variants like where to call for service discovery, into `bootstrap.properties`
    instead of `application.properties`. In our example, we have placed `spring.application.name`
    config into `bootstrap.properties`, because that information will be needed during
    the Bootstrap phase; it could be used to look up configuration from a remote config
    store.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地将应用程序配置与Bootstrap分开，我们将描述应用程序的内容、配置外部配置或其他环境变量（如服务发现调用位置）放入`bootstrap.properties`而不是`application.properties`。在我们的示例中，我们将`spring.application.name`配置放入`bootstrap.properties`，因为该信息将在Bootstrap阶段需要；它可以用于从远程配置存储中查找配置。
- en: Since Bootstrap application context is indeed a real Spring application context,
    there exists a parent-child relationship between the two, where Bootstrap application
    context becomes the parent of the Spring Boot application context. This means
    that all the beans and the property sources defined in the Bootstrap context become
    available for consumption from within the application context as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Bootstrap应用程序上下文确实是一个真实的Spring应用程序上下文，因此两者之间存在父子关系，其中Bootstrap应用程序上下文成为Spring
    Boot应用程序上下文的父级。这意味着Bootstrap上下文中定义的所有bean和属性源都可以在应用程序上下文中使用。
- en: When Spring Cloud is added to the application, it automatically provides the
    integration framework for specific Spring Cloud modules, like Spring Cloud Consul,
    to be plugged in via the use of the by now well-known `spring.factories` configuration
    declarations. The annotations provided inside `spring-cloud-commons`, namely `@SpringCloudApplication`,
    `@EnableDiscoveryClient`, `@EnableCircuitBreaker`, and the `@BootstrapConfiguraion`
    and `PropertySourceLocator` interfaces provided by the `spring-cloud-context`
    library, are designed to define the integration points to be used to self-configure
    specific components such as discovery clients like Consul, circuit breakers like
    Hystrix, or remote configuration sources like **ZooKeeper**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Cloud添加到应用程序中时，它会自动提供特定Spring Cloud模块（如Spring Cloud Consul）的集成框架，通过现在众所周知的`spring.factories`配置声明进行插入。`spring-cloud-commons`内部提供的注解，即`@SpringCloudApplication`、`@EnableDiscoveryClient`、`@EnableCircuitBreaker`，以及由`spring-cloud-context`库提供的`@BootstrapConfiguraion`和`PropertySourceLocator`接口，旨在定义用于自配置特定组件（如Consul这样的发现客户端、Hystrix这样的断路器或ZooKeeper这样的远程配置源）的集成点。
- en: 'Let''s examine those in detail:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这些内容：
- en: '`@SpringCloudApplication`: This annotation is like `@SpringBootApplication`, meta-annotation
    in nature, except it also wraps the `@EnableDiscoveryClient` and `@EnableCircuitBreaker`
    annotations in addition to also being meta-annotated with `@SpringBootApplication`.
    It is a good idea to use this annotation when you want to enable both the discovery
    client and the circuit breaker functionality in your application.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringCloudApplication`: 这个注解类似于`@SpringBootApplication`，本质上是一个元注解，除了它还包装了`@EnableDiscoveryClient`和`@EnableCircuitBreaker`注解，并且还用`@SpringBootApplication`进行了元注解。当您想在应用程序中启用发现客户端和断路器功能时，使用此注解是一个好主意。'
- en: '`@EnableDiscoveryClient`: This annotation is used to indicate that Spring Cloud
    should initialize the provided discovery client for service registry, depending
    on the included integration library, such as Consul, Eureka, ZooKeeper, and so
    on.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableDiscoveryClient`: 这个注解用于指示Spring Cloud应该初始化提供的发现客户端以进行服务注册，具体取决于包含的集成库，例如Consul、Eureka、ZooKeeper等。'
- en: '`@EnableCircuitBreaker`: This annotation is used to indicate that Spring Cloud
    should initialize the circuit breaker capabilities, based on the specific dependency
    of the integration library, such as Hystrix.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableCircuitBreaker`: 这个注解用于指示Spring Cloud应该根据特定集成库的依赖初始化断路器功能，例如Hystrix。'
- en: '`PropertySourceLocator`: This is used by the integration libraries to implement
    specific functionality of how to extract remote configuration from the provided
    datastore. Each integration module, providing ability to load remote configuration,
    would register an implementing bean of this type that exposes an implementation
    of `PropertySource` that is backed by the integration.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropertySourceLocator`: 集成库使用此接口来实现从提供的数据存储中提取远程配置的特定功能。每个提供加载远程配置能力的集成模块都会注册一个实现此类型的bean，该bean公开一个由集成支持的`PropertySource`实现。'
- en: '`@BootstrapConfiguration`: This annotation is like the `@ManagementContextConfiguration`
    annotation, and is (mostly) a marker annotation geared to identify the key inside
    the `spring.factories` descriptor to indicate which configuration classes should
    be loaded during the Spring Cloud Bootstrap process and be part of the Bootstrap
    application context. Those configurations are read by `BootstrapApplicationListener`
    during startup and initialize the specified configurations. Typically, this is
    where the configuration classes, which define and expose `PropertySourceLocator`—implementing
    beans, are configured.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BootstrapConfiguration`: 这个注解类似于`@ManagementContextConfiguration`注解，并且（主要）是一个标记注解，旨在识别`spring.factories`描述符中的关键部分，以指示在Spring
    Cloud Bootstrap过程中应该加载哪些配置类，并使其成为Bootstrap应用程序上下文的一部分。这些配置在启动时由`BootstrapApplicationListener`读取并初始化指定的配置。通常，这就是配置类被配置的地方，这些类定义并暴露实现`PropertySourceLocator`的bean。'
- en: Service discovery using Spring Cloud Consul
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Consul进行服务发现
- en: In a world of distributed computing, it is very common for services to become
    a disposable commodity. The typical life cycle of a service could be measured
    in days, if not in hours, and it is not unheard of for an instance to just crash
    for whatever reason, only to have a new one come up automatically seconds later.
    When the state of applications is so ephemeral, it becomes really hard to maintain
    a statically-connected architecture, with services knowing where exactly their
    dependent services are located, as the topology is always changing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算的世界中，服务成为可丢弃的商品是非常常见的。服务的典型生命周期可能是几天，甚至可能只有几个小时，一个实例由于任何原因崩溃，然后几秒钟后自动启动一个新实例，这种情况并不罕见。当应用程序的状态如此短暂时，维护一个静态连接的架构就变得非常困难，因为服务知道它们依赖的服务确切位置，而拓扑结构总是在变化。
- en: To help with this problem, the service discovery layer comes into play, maintaining
    a centralized and distributed state of service registrations, ready to reply on
    demand with the most current information. Applications register themselves upon
    startup, providing information about their location and possibly about their capabilities,
    level of service, health check status, and even more.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，服务发现层就派上用场了，它维护着集中式和分布式的服务注册状态，随时准备根据需求提供最新的信息。应用程序在启动时会注册自己，提供有关其位置的信息，以及可能有关其能力、服务水平、健康检查状态等信息。
- en: Earlier in the book, in [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml),
    *Application Packaging and Deployment*, we were introduced to Consul, and used
    it for external application configuration consumption. In this recipe, we will
    continue to look further into the capabilities of Consul and will learn about
    how to use the `spring-cloud-consul` modules to automatically register our application
    with Consul.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分，在第6章[第6章](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml)，*应用程序打包和部署*中，我们介绍了Consul，并使用它进行外部应用程序配置消费。在本食谱中，我们将进一步探讨Consul的功能，并学习如何使用`spring-cloud-consul`模块自动将我们的应用程序注册到Consul中。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Take a look at the following steps to set up service discovery:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤以设置服务发现：
- en: 'Replace the `spring-cloud-commons` and `spring-cloud-context` modules with `spring-cloud-starter-consul-all`
    by modifying the `build.gradle` file located in the root of our project with the
    following content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改位于我们项目根目录下的`build.gradle`文件，将`spring-cloud-commons`和`spring-cloud-context`模块替换为`spring-cloud-starter-consul-all`，内容如下：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With Consul dependencies added, we will proceed with enabling our application
    to automatically register with the local agent upon startup by modifying the `BookPubApplication.java`
    file located under the `src/main/java/com/example/bookpub` directory from the
    root of our project with the following content:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了Consul依赖项后，我们将通过修改位于项目根目录下的`src/main/java/com/example/bookpub`目录中的`BookPubApplication.java`文件，使我们的应用程序在启动时自动注册到本地代理，内容如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given that Consul was successfully installed using the steps described in the *Setting
    up Consul* recipe in [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml),
    *Application Packaging and Deployment*, we should be able to start it by running
    `consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul` and our Terminal
    window should display the following output:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Consul已成功安装，如第6章[第6章](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml)中*设置Consul*食谱中所述的步骤，我们应该能够通过运行`consul
    agent -server -bootstrap-expect 1 -data-dir /tmp/consul`来启动它，并且我们的终端窗口应该显示以下输出：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the Consul agent is up and running successfully, we will proceed by starting
    our application by running `./gradlew clean bootRun`
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Consul 代理成功启动并运行后，我们将通过运行 `./gradlew clean bootRun` 来启动我们的应用程序。
- en: 'As we watch the startup logs scroll by, there are a couple of interesting entries
    that indicate the application is interacting with the agent, so watch for the
    following content in the logs:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们查看启动日志滚动时，有几个有趣的条目表明应用程序正在与代理交互，因此请关注日志中的以下内容：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just to verify that our application has registered and is in communication with
    the local Consul agent, let's open `http://localhost:8081/actuator/consul` in
    the browser to see the Consul agent information, as shown in the following screenshot:![](img/8cb7c381-b98e-44d9-b5c1-744a19fd90d9.png)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的应用程序已注册并且与本地 Consul 代理进行通信，请在浏览器中打开 `http://localhost:8081/actuator/consul`
    来查看 Consul 代理信息，如下面的截图所示：![](img/8cb7c381-b98e-44d9-b5c1-744a19fd90d9.png)
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we added `spring-cloud-starter-consul-all` as a build dependency, it automatically
    pulled all the necessary components to enable Consul functionality for our application.
    We automatically got the `spring-cloud-consul-binder`, `spring-cloud-consul-core`,
    `spring-cloud-consul-config`, and `spring-cloud-consul-discovery` artifacts added
    to our classpath. Let''s take a look at the them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `spring-cloud-starter-consul-all` 作为构建依赖项添加时，它会自动拉取所有必要的组件以启用应用程序的 Consul
    功能。我们自动获得了 `spring-cloud-consul-binder`、`spring-cloud-consul-core`、`spring-cloud-consul-config`
    和 `spring-cloud-consul-discovery` 工件添加到我们的类路径中。让我们来看看它们：
- en: '`spring-cloud-consul-core`: This artifact provides base autoconfiguration to
    expose generic `ConsulProperties`, as well as the `ConsulClient` initialization
    and setting of the `/consul` management endpoint, if the Spring Boot Actuator
    functionality is enabled.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-consul-core`: 此工件提供了基本的自动配置，以暴露通用的 `ConsulProperties`，以及如果启用了
    Spring Boot Actuator 功能，则初始化和设置 `/consul` 管理端点。'
- en: '`spring-cloud-consul-config`: This provides the `ConsulPropertySourceLocator`
    implementation, used during Bootstrap, to configure the `ConsulPropertySource`
    bean, which allows remote configuration consumption from the Consul key/value
    store. It also sets up a `ConfigWatch` change observer, which fires `RefreshEvent`
    to the application context, if a configuration key value changes in Consul key/value
    store while the application is running. This allows for a possible configuration
    properties reload without having to redeploy and restart the application.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-consul-config`: 这提供了 `ConsulPropertySourceLocator` 的实现，在引导过程中使用，以配置
    `ConsulPropertySource` bean，允许从 Consul 键值存储中消费远程配置。它还设置了一个 `ConfigWatch` 变更观察者，如果在应用程序运行时
    Consul 键值存储中的配置键值发生变化，则会触发 `RefreshEvent` 到应用程序上下文。这允许在无需重新部署和重启应用程序的情况下重新加载配置属性。'
- en: '`spring-cloud-consul-discovery`: This provides all the functionality and implementations
    needed for service discovery, service registration, and service invocation.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-consul-discovery`: 这提供了服务发现、服务注册和服务调用的所有功能和实现。'
- en: '`spring-cloud-consul-binder`: This provides integration of Consul event functionality
    with Spring Cloud Stream Framework, enabling it to send and receive events from
    Consul and respond to them within the application. While outside of the scope
    of this chapter, more information can be obtained from [http://cloud.spring.io/spring-cloud-stream/](http://cloud.spring.io/spring-cloud-stream/).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-consul-binder`: 这提供了 Consul 事件功能与 Spring Cloud Stream 框架的集成，使其能够从
    Consul 发送和接收事件，并在应用程序内对它们做出响应。虽然这超出了本章的范围，但可以从 [http://cloud.spring.io/spring-cloud-stream/](http://cloud.spring.io/spring-cloud-stream/)
    获取更多信息。'
- en: While addition of `spring-cloud-consul-config` to the classpath will automatically
    register `ConsulPropertySource`, it is not so for the `spring-cloud-consul-discovery`
    module. The service discovery functionality is more intrusive and thus requires
    an additional step of acknowledgement from the developers to indicate that it
    is indeed wanted. This is accomplished by adding the `@EnableDiscoveryClient`
    annotation to the main application class; in our case it is `BookPubApplication`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `spring-cloud-consul-config` 添加到类路径时，会自动注册 `ConsulPropertySource`，但对于 `spring-cloud-consul-discovery`
    模块则不是这样。服务发现功能更为侵入性，因此需要开发人员额外一步确认，以表明确实需要它。这是通过在主应用程序类中添加 `@EnableDiscoveryClient`
    注解来实现的；在我们的例子中是 `BookPubApplication`。
- en: 'Once the `@EnableDiscoveryClient` annotation is added, Spring Cloud (`EnableDiscoveryClientImportSelector`
    class from the `spring-cloud-commons` module, to be more precise) scans all `spring.factories`
    files for the presence of the `org.springframework.cloud.client.discovery.EnableDiscoveryClient`
    key, and loads all the associated configurations into the main application context.
    If we look inside the `spring.factories` file located in the `spring-cloud-consul-discovery` JAR
    under the `META-INF/` directory, we will see the following entry:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了`@EnableDiscoveryClient`注解，Spring Cloud（更确切地说，是来自`spring-cloud-commons`模块的`EnableDiscoveryClientImportSelector`类）将扫描所有`spring.factories`文件以查找`org.springframework.cloud.client.discovery.EnableDiscoveryClient`键的存在，并将所有相关配置加载到主应用程序上下文中。如果我们查看位于`spring-cloud-consul-discovery`
    JAR文件下的`META-INF/`目录中的`spring.factories`文件，我们将看到以下条目：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This tells us that when the discovery client is enabled, `ConsulDiscoveryClientConfiguration`
    will be consumed and all of its defining beans will be added to the application
    context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当启用发现客户端时，`ConsulDiscoveryClientConfiguration`将被消费，并且所有定义的bean都将添加到应用程序上下文中。
- en: A similar approach can be used if a custom service discovery mechanism is being
    used. One will need to create a custom configuration class, exposing a custom
    implementation of the `DiscoveryClient` interface, and configure it in the `spring.factories` file
    bundled within the archive. Once that JAR gets loaded, the configuration will
    be automatically consumed if discovery client functionality is enabled.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用自定义服务发现机制，可以使用类似的方法。需要创建一个自定义配置类，公开`DiscoveryClient`接口的自定义实现，并在存档中包含的`spring.factories`文件中进行配置。一旦加载该JAR，如果启用了发现客户端功能，配置将自动消费。
- en: Spring Cloud Consul libraries provide very fine-grained ability to configure
    and pick and choose the selected functions, if not all apply for a particular
    use-case. For detailed information about various configuration and usage options
    see [http://cloud.spring.io/spring-cloud-consul/](http://cloud.spring.io/spring-cloud-consul/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Consul 库提供了非常细粒度的配置和选择所需功能的能力，如果不是所有功能都适用于特定用例。有关各种配置和使用选项的详细信息，请参阅[http://cloud.spring.io/spring-cloud-consul/](http://cloud.spring.io/spring-cloud-consul/)。
- en: Using Spring Cloud Netflix – Feign
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Netflix – Feign
- en: In the previous recipe, we looked at how to enable service discovery capability
    for our application in order to be able to register our service with the world
    as well as to know what other services exist and where they are located. This
    recipe will help us better interact with that information and consume those services
    without having to explicitly code any logic to handle service discovery and all
    of the related concerns that come with it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们探讨了如何为我们的应用程序启用服务发现能力，以便能够将我们的服务注册到世界上，以及了解其他服务存在的地方。这个菜谱将帮助我们更好地与这些信息互动，并消费这些服务，而无需显式编写任何处理服务发现及其相关问题的逻辑。
- en: To achieve this goal, we will look at another Spring Cloud integration, provided
    by the Spring Cloud Netflix module family—Netflix Feign. Feign, which makes writing
    Java HTTP clients easier. Its purpose is to simplify the process of binding service
    API calls to their corresponding HTTP API counterparts. It provides automatic
    service mapping and discovery, ability to translate Java types to HTTP request
    URL paths, parameters and response payloads, as well as error handling.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们将查看另一个由Spring Cloud Netflix模块家族提供的Spring Cloud集成——Netflix Feign。Feign简化了将服务API调用绑定到相应的HTTP
    API对应方的过程。它提供了自动服务映射和发现，能够将Java类型转换为HTTP请求URL路径、参数和响应负载，以及错误处理。
- en: For the sake of simplicity, in this recipe, we will be creating a `Client` controller,
    which will act as an external client of our `BookPub` application service, calling
    our APIs via Feign-annotated Java service interfaces, relying on Consul to provide
    service discovery functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，在这个菜谱中，我们将创建一个`Client`控制器，它将充当我们的`BookPub`应用程序服务的客户端，通过Feign注解的Java服务接口调用我们的API，依赖Consul提供服务发现功能。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start by adding Netflix Feign module dependencies to our project. Let''s
    modify our `build.gradle` file located in the root of our project with the following
    content:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将Netflix Feign模块依赖项添加到我们的项目中。让我们修改位于我们项目根目录的`build.gradle`文件，内容如下：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the dependency added, our next step is to create a Java API interface describing
    how we want to define our interaction with the `BookPub` service. Let's create
    an `api` package under the `src/main/java/com/example/bookpub` directory from
    the root of our project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了依赖项后，我们的下一步是创建一个Java API接口，描述我们想要如何定义与 `BookPub` 服务的交互。让我们在项目根目录下的 `src/main/java/com/example/bookpub`
    目录中创建一个 `api` 包。
- en: 'Inside the newly-created `api` package, let''s create our API class file named
    `BookPubClient.java` with the following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的 `api` 包中，让我们创建一个名为 `BookPubClient.java` 的 API 类文件，其内容如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After we have defined the API, it is time to tell our application that we want
    to enable Feign support. We will do that by making a change to the `BookPubApplication.java`
    file located under the `src/main/java/com/example/bookpub directory` from the
    root of our project with the following content:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义了API之后，是时候告诉我们的应用程序我们想要启用Feign支持了。我们将通过修改项目根目录下的 `src/main/java/com/example/bookpub`
    目录中的 `BookPubApplication.java` 文件来实现这一点，其内容如下：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let''s create a client controller to invoke `BookPubClient` by making
    a new file named `ClientController.java` under the `src/main/java/com/example/bookpub/controllers`
    directory from the root of our project with the following content:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在项目根目录下的 `src/main/java/com/example/bookpub/controllers` 目录中创建一个名为 `ClientController.java`
    的新文件，以通过调用 `BookPubClient` 来创建客户端控制器，其内容如下：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With everything set and done, let's start the application by executing the `./gradlew
    clean bootRun` command.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切设置和完成后，让我们通过执行 `./gradlew clean bootRun` 命令来启动应用程序。
- en: Make sure that the Consul agent is also running in the background, otherwise
    service registration will fail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Consul代理也在后台运行，否则服务注册将失败。
- en: Once the application is up and running, let's open `http://localhost:8080/client/book/978-1-78528-415-1`
    in the browser to see the Consul agent information, as shown in the following
    screenshot:![](img/42791c29-c531-46b3-bcda-be2db8c760a9.png)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动并运行，让我们在浏览器中打开 `http://localhost:8080/client/book/978-1-78528-415-1`
    来查看Consul代理信息，如下所示：![](img/42791c29-c531-46b3-bcda-be2db8c760a9.png)
- en: 'If we look at the application console logs, we will also see entries indicating
    that our Feign client is initialized and functioning. You should see something
    similar to this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看应用程序控制台日志，我们还将看到表示我们的Feign客户端已初始化并正常工作的条目。你应该看到类似以下内容：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One last thing that we should do is to get our tests to work with all the newly
    added frameworks. Because Spring Cloud does not add itself to the test life cycle,
    we should explicitly disable any reliance on beans created by Spring Cloud libraries
    during tests. To do so let''s add to our `application.properties` file located
    under the `src/test/resources` directory from the root of the project of the following
    properties:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件我们应该做的事情是让我们的测试与所有新添加的框架一起工作。因为Spring Cloud不会将自己添加到测试生命周期中，所以我们应该明确禁用在测试期间对由Spring
    Cloud库创建的bean的任何依赖。为此，让我们向项目根目录下的 `src/test/resources` 目录中的 `application.properties`
    文件添加以下属性：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need to add a Mock dependency on `BookPubClient` into the `JpaAuthorRepositoryTests.java`
    and `WebMvcBookControllerTests.java` files located under the `src/test/java/com/example/bookpub`
    directory from the root of the project with the following content:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在 `src/test/java/com/example/bookpub` 目录下的 `JpaAuthorRepositoryTests.java`
    和 `WebMvcBookControllerTests.java` 文件中添加一个对 `BookPubClient` 的 Mock 依赖，其内容如下：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similar to what we saw in the previous recipe, the use of the `@EnableFeignClients`
    annotation on the main application class, `BookPubApplication`, explicitly tells
    Spring Cloud that it should scan for all the interfaces annotated with `@FeignClient`
    and create service client implementations based on their definitions. The `@EnableFeignClients`
    annotation is similar in nature to the `@ComponentScan` one, providing attributes
    to control which packages to scan for the `@FeignClient` annotated classes or
    explicitly list the API classes that should be used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方中看到的情况类似，在主应用程序类 `BookPubApplication` 上使用 `@EnableFeignClients` 注解，明确告诉Spring
    Cloud它应该扫描所有带有 `@FeignClient` 注解的接口，并根据它们的定义创建服务客户端实现。`@EnableFeignClients` 注解在本质上与
    `@ComponentScan` 注解相似，提供属性来控制要扫描哪些包以查找带有 `@FeignClient` 注解的类或显式列出应使用的API类。
- en: Out of the box, all Feign client implementations are configured using components
    defined in the `FeignClientsConfiguration` class, but one can provide alternative
    configuration classes using the `defaultConfiguration` attribute of the `@EnableFeignClients`
    annotation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有Feign客户端实现都是使用在`FeignClientsConfiguration`类中定义的组件进行配置的，但可以通过`@EnableFeignClients`注解的`defaultConfiguration`属性提供替代配置类。
- en: In a nutshell, every interface definition, annotated with `@FeignClient`, gets
    a service implementation consisting of a Java dynamic proxy object, which handles
    all the interface method calls (usually using `FeignInvocationHandler` to handle
    all the requests). The invocation handler is responsible for doing a few things.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每个带有`@FeignClient`注解的接口定义都会获得一个由Java动态代理对象组成的实现，该对象处理所有接口方法调用（通常使用`FeignInvocationHandler`来处理所有请求）。调用处理器负责做一些事情。
- en: Once any method is invoked, first the service instances are located using the
    provided discovery client (in our case it is `ConsulDiscoveryClient`) based on
    the `name` attribute of the `@FeignClient` annotation. In our example, we have
    declared the value of `name` attribute to be `http://BookPub-ch9`, so all the
    service instances from the registry which have their name set to `BookPub-ch9` will
    be returned as possible candidates. This name can be just a service name itself,
    or, as we did in our example, an optional protocol can be specified. This is a
    useful feature, as not all service discovery providers support ability to specify
    exactly how the service should be called, so if we want to make a secure call
    using HTTPS, we can explicitly specify the protocol to help Feign make the right
    call.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用任何方法，首先使用提供的发现客户端（在我们的例子中是`ConsulDiscoveryClient`）根据`@FeignClient`注解的`name`属性定位服务实例。在我们的例子中，我们已将`name`属性的值声明为`http://BookPub-ch9`，因此所有名称设置为`BookPub-ch9`的注册服务实例都将作为可能的候选返回。这个名称可以是服务名称本身，或者，正如我们在我们的例子中所做的那样，可以指定一个可选的协议。这是一个有用的功能，因为并非所有服务发现提供者都支持指定确切的服务调用方式，因此如果我们想使用HTTPS进行安全调用，我们可以明确指定协议以帮助Feign进行正确的调用。
- en: There are a number of other configuration attributes available on the annotation,
    for example, to tell Feign to make a direct call to a specified URL instead of
    doing a service lookup, there is a `url` attribute that can be configured.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注解上还有许多其他配置属性可用，例如，为了告诉Feign直接调用指定的URL而不是进行服务查找，有一个可以配置的`url`属性。
- en: To see a complete list of possible attributes and their use-cases, go to [https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可能的属性及其用例的完整列表，请访问[https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign)。
- en: The list of instances for a given service gets wrapped with an internal load
    balancer, provided by another Netflix library—Ribbon. It uses a specified algorithm
    to rotate between the instances of a service as well as to take the bad instances
    out of circulation if the discovery client says they are unhealthy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定服务的实例列表，会被另一个Netflix库——Ribbon提供的内部负载均衡器所包装。它使用指定的算法在服务实例之间进行轮询，并在发现客户端表示它们不健康时将不良实例从循环中移除。
- en: To see a complete list of possible configuration options for things like load
    balancing rules, and other settings, go to [https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有关负载均衡规则和其他设置的配置选项的完整列表，请访问[https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon)。
- en: When a specific instance has been determined, an HTTP request gets created,
    using the standard Spring `HttpMessageConverter` beans to transform the method
    arguments into HTTP request path variables and query parameters. After all that
    is done, the request gets sent using a configured HTTP client and the response
    gets converted into a return type declared on the API interface using the same
    converters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当确定特定的实例后，会创建一个HTTP请求，使用标准的Spring `HttpMessageConverter` bean将方法参数转换为HTTP请求路径变量和查询参数。完成所有这些后，请求通过配置的HTTP客户端发送，并将响应转换为API接口上声明的返回类型，使用相同的转换器进行转换。
- en: Now that we know what `@FeignClient` annotation is all about and what happens
    under the hood once an API-defined method gets invoked, let's take a look at how
    to annotate the interface methods that should be translated into remote service
    calls. Conveniently, and done so on purpose, we can use exactly the same annotations
    as we are already used to, when declaring controller mappings inside the `@Controller`
    annotated classes. Each method in our API interface, which we want to map to a
    remote service, should be annotated with the `@RequestMapping` annotation. The
    `path` attribute corresponds to a URL path of the remote service we want to invoke.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`@FeignClient`注解是什么以及一旦API定义的方法被调用，幕后会发生什么，让我们看看如何注解应该转换为远程服务调用的接口方法。方便的是，并且是有意为之，我们可以使用与我们在`@Controller`注解的类中声明控制器映射时相同的注解。我们想要映射到远程服务的API接口中的每个方法都应该用`@RequestMapping`注解。`path`属性对应于我们想要调用的远程服务的URL路径。
- en: In our example, we want to call our `BookController.getBook(...)` method, which
    translates to the `/books/{isbn}` URL path. This is exactly what we put as a value
    for the `path` attribute, and make sure we also annotate the `isbn` argument in
    our `findBookByIsbn(...)` method with `@PathVariable("isbn")` to link it to a
    `{isbn}` placeholder in the mapping template.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们想要调用`BookController.getBook(...)`方法，这对应于`/books/{isbn}`URL路径。这正是我们为`path`属性设置的值，并确保我们在`findBookByIsbn(...)`方法中用`@PathVariable("isbn")`注解`isbn`参数，以将其链接到映射模板中的`{isbn}`占位符。
- en: As a general rule of thumb, the `@RequestMapping` annotation functions exactly
    the same as if it were used in a controller, except the configuration relates
    to an outgoing request instead of an inbound one. It might be especially confusing
    when configuring the `consumes` attribute of the annotation, that is, `consumes
    = "application/json"`, because it indicates that it is a remote side that expects
    JSON as a content-type of the payload.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，`@RequestMapping`注解的功能与在控制器中使用时完全相同，只是配置与出站请求相关，而不是入站请求。当配置注解的`consumes`属性时，可能会特别令人困惑，即`consumes
    = "application/json"`，因为它表示远程端期望JSON作为负载的内容类型。
- en: Service discovery using Spring Cloud Netflix – Eureka
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Netflix进行服务发现 – Eureka
- en: We've already seen how to do service discovery using HashiCorp Consul and integrate
    it with our application. This recipe will go over an alternative, and a very popular
    service discovery framework from Netflix-Eureka. Eureka was developed by Netflix
    to help solve the problem of service discovery, health checking, and load balancing
    for their RESTful services in AWS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用HashiCorp Consul进行服务发现并将其集成到我们的应用程序中。这个配方将介绍一个替代方案，一个非常流行的来自Netflix的Eureka服务发现框架。Eureka是由Netflix开发的，旨在帮助解决他们在AWS中RESTful服务的服务发现、健康检查和负载平衡问题。
- en: Unlike Consul, Eureka is solely focused on the task of service discovery, and
    does not provide many additional functionalities, such as key/value store service
    or event delivery. It is, however, very good at what it does and should be considered
    a viable candidate for a service discovery solution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与Consul不同，Eureka专注于服务发现的任务，并不提供许多额外的功能，例如键值存储服务或事件传递。然而，它在所做的事情上非常出色，应该被视为一个可行的服务发现解决方案。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before we get to the steps to add Eureka to our application, we need to get
    the Eureka service itself up and running. Thankfully, the Spring Cloud folks have
    been awesome enough to provide a sample project that makes creating an instance
    of Eureka server and running it a breeze. Let''s take a look at the following
    steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加Eureka到我们的应用程序的步骤之前，我们需要启动并运行Eureka服务本身。幸运的是，Spring Cloud团队已经足够出色，提供了一个示例项目，使得创建Eureka服务器实例并运行它变得非常简单。让我们看看以下步骤：
- en: To get things up and running just go to [https://github.com/spring-cloud-samples/eureka](https://github.com/spring-cloud-samples/eureka)
    and git clone the `git@github.com:spring-cloud-samples/eureka.git` repository
    to your machine.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动并运行，请访问[https://github.com/spring-cloud-samples/eureka](https://github.com/spring-cloud-samples/eureka)并使用git
    clone命令`git@github.com:spring-cloud-samples/eureka.git`将仓库克隆到您的机器上。
- en: 'After that''s done, run `./gradlew clean bootRun` to start the server:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，运行`./gradlew clean bootRun`以启动服务器：
- en: 'Once the server is up and running, we need to add the following dependencies
    to the `build.gradle` file located at the root of our project:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务器启动并运行，我们需要将以下依赖项添加到位于我们项目根目录的`build.gradle`文件中：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ironically, that’s all we had to do, at this point, we just restart our application
    by executing the `./gradlew clean bootRun` command.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，我们此时只需执行 `./gradlew clean bootRun` 命令重新启动我们的应用程序。
- en: Make sure the Eureka server is running in the background, otherwise, though
    the application will start, the `BookPubClient` calls will fail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 Eureka 服务器在后台运行，否则，尽管应用程序会启动，但 `BookPubClient` 调用将会失败。
- en: Once the application is up and running, let's open `http://localhost:8080/client/book/978-1-78528-415-1` in
    the browser and we should see exactly the same response as in our previous recipe.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动并运行，让我们在浏览器中打开 `http://localhost:8080/client/book/978-1-78528-415-1`，我们应该看到与之前配方中完全相同的响应。
- en: 'Just to see that our application did indeed register with Eureka, we can open
    the browser at the `http://localhost:8761` URL and we should see our service listed
    under instances list:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只为了确认我们的应用程序确实已注册到 Eureka，我们可以在 `http://localhost:8761` URL 打开浏览器，我们应该在我们的服务列表下看到我们的服务：
- en: '![](img/7a596791-b096-4a3a-9a67-1ed2ea7f1a73.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a596791-b096-4a3a-9a67-1ed2ea7f1a73.png)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With a seemingly effortless change, we have switched one service discovery provider,
    Consul, for another, Eureka. What looked like not much of a change on the outside
    actually did quite a bit of work under the hood. The reason we were able to do
    it so easily is the common set of APIs provided by the `spring-cloud-commons`
    and `spring-cloud-context` foundational libraries. Automated module loading support
    via the `spring.factores` descriptor allowed for transparent substitution in the
    initialization of a different service discovery provider. As long as we retained
    the `@EnableDiscoveryClient` annotation on our `BookPubApplication` class, Spring
    Cloud did the heavy lifting, taking care of loading the appropriate autoconfiguration
    files and setting up all the right beans to get our application working with Eureka.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过看似无力的改变，我们已经将一个服务发现提供者，Consul，切换为另一个，Eureka。表面上看起来变化不大，但实际上在底层做了很多工作。我们之所以能够如此轻松地做到这一点，是因为
    `spring-cloud-commons` 和 `spring-cloud-context` 基础库提供的公共 API 集合。通过 `spring.factories`
    描述符提供的自动模块加载支持，允许在初始化不同的服务发现提供者时进行透明替换。只要我们在 `BookPubApplication` 类上保留 `@EnableDiscoveryClient`
    注解，Spring Cloud 就会承担繁重的工作，负责加载适当的自动配置文件并设置所有正确的豆（Beans）以使我们的应用程序能够与 Eureka 一起工作。
- en: We had to remove the Consul dependency from our classpath at the very first
    step of the recipe, and that had to be done in order to disambiguate the `DiscoveryClient`
    implementation. Without doing so, our application context would have ended up
    with two different implementations of the `DiscoveryClient` interface, which in
    itself would not be bad, except that Spring Cloud would have to disambiguate and
    choose one, and might not choose the one we want.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不在配方步骤的第一步就移除 Consul 依赖，这样做是为了消除 `DiscoveryClient` 实现的不确定性。如果不这样做，我们的应用程序上下文最终会包含
    `DiscoveryClient` 接口的不同实现，这本身并不是什么坏事，除非 Spring Cloud 需要消除歧义并选择一个，而且可能不会选择我们想要的那个。
- en: 'If we leave the `spring-cloud-starter-consul-all` dependency in our `build.gradle`
    file, and attempt to run the application, it will fail during startup and in the
    logs we will see the following entry:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `build.gradle` 文件中留下 `spring-cloud-starter-consul-all` 依赖，并尝试运行应用程序，它将在启动时失败，并在日志中看到以下条目：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see from the exception, Spring autowiring can't decide which one
    of the service registries should be used. This is because both Eureka and Consul
    automatically have created an instance of `Registration`, and the autowiring wants
    only one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从异常中可以看到，Spring 自动装配无法决定应该使用哪个服务注册表。这是因为 Eureka 和 Consul 都自动创建了一个 `Registration`
    实例，而自动装配只需要一个。
- en: Since there is a hard requirement for only having one registry, it is best not
    to configure multiple discovery client dependency libraries to avoid errors. If,
    for some reason, multiple libraries have to reside in the classpath, one should
    use configuration properties to explicitly enable/disable a specific client implementation.
    For example, both Consul and Eureka provide configuration to toggle the state.
    We can set `spring.cloud.consul.discovery.enabled=true` and `eureka.client.enabled=false`
    in `application.properties` if we prefer to use Consul to provide service discovery
    functionality.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个注册表是硬性要求，因此最好不要配置多个发现客户端依赖库以避免错误。如果由于某种原因，多个库必须存在于类路径中，则应使用配置属性显式启用/禁用特定的客户端实现。例如，Consul
    和 Eureka 都提供了配置来切换状态。如果我们更喜欢使用 Consul 提供服务发现功能，我们可以在 `application.properties`
    中设置 `spring.cloud.consul.discovery.enabled=true` 和 `eureka.client.enabled=false`。
- en: Using Spring Cloud Netflix – Hystrix
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Netflix – Hystrix
- en: Throughout this chapter we have looked at all the aspects that apply to having
    a successful microservice application running in the cloud environment. We have
    learned about how to integrate better into a dynamically changing ecosystem, consuming
    remote configuration properties, registering service, and discovering and calling
    other services. In this recipe, we will take a look at another very important
    aspect of operating in a distributed, highly-volatile cloud environment circuit
    breakers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了所有适用于在云环境中成功运行微服务应用的所有方面。我们学习了如何更好地集成到一个动态变化的生态系统，消费远程配置属性，注册服务，以及发现和调用其他服务。在本食谱中，我们将探讨在分布式、高度易变的云环境中操作的一个非常重要的方面——断路器。
- en: The particular implementation of circuit breaker functionality which we are
    going to look at is Netflix Hystrix. It provides a very powerful and convenient
    way to annotate our service calls and handle things like remote service failures,
    queue backups, overloads, timeouts, and so on. By having circuit breakers in an
    application, developers can ensure overall application stability if a particular
    service endpoint becomes overloaded by requests, or experiences an outage of any
    kind.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的断路器功能的具体实现是 Netflix Hystrix。它提供了一种非常强大且方便的方式来注释我们的服务调用，并处理诸如远程服务故障、队列备份、过载、超时等问题。通过在应用程序中实现断路器，开发人员可以确保如果特定的服务端点因请求过载或任何类型的故障而出现问题时，整体应用程序的稳定性。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To get started with Hystrix we need to add the `spring-cloud-starter-hystrix`
    library to our project. Let''s modify our `build.gradle` file located in the root
    of our project with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用 Hystrix，我们需要将 `spring-cloud-starter-hystrix` 库添加到我们的项目中。让我们修改位于项目根目录下的
    `build.gradle` 文件，内容如下：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After adding the Hystrix dependency, we need to enable Hystrix for our application.
    Similar to how we enabled service discovery, we will do that by making a change
    to the `BookPubApplication.java` file located under the `src/main/java/com/example/bookpub`
    directory from the root of our project with the following content:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加 Hystrix 依赖项后，我们需要为我们的应用程序启用 Hystrix。类似于我们启用服务发现的方式，我们将通过修改位于项目根目录下的 `src/main/java/com/example/bookpub`
    目录中的 `BookPubApplication.java` 文件来实现这一点。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s make a few changes to `BookController.java`, located under the `src/main/java/com/example/bookpub/controllers`
    directory from the root of our project, with the following content:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们对位于项目根目录下的 `src/main/java/com/example/bookpub/controllers` 目录中的 `BookController.java`
    文件进行一些修改：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Due to Hystrix internal functionality, we also need to modify our entity models
    to have them eager-load the relational associations. In the `Author.java`, `Book.java`,
    and `Publisher.java` files located under the `src/main/java/com/example/bookpub/entity`
    directory from the root of our project, let''s make the following changes:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Hystrix 的内部功能，我们还需要修改我们的实体模型，以便它们能够预加载关系关联。在项目根目录下的 `src/main/java/com/example/bookpub/entity`
    目录中的 `Author.java`、`Book.java` 和 `Publisher.java` 文件，让我们进行以下修改：
- en: 'In `Author.java`, make the following change:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Author.java` 文件中，进行以下修改：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `Book.java`, make the following change:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Book.java` 文件中，进行以下修改：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `Publisher.java`, make the following change:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Publisher.java` 文件中，进行以下修改：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we are ready to restart our application by executing the `./gradlew
    clean bootRun` command.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备好通过执行 `./gradlew clean bootRun` 命令来重新启动我们的应用程序。
- en: 'When the application has started, let''s open `http://localhost:8080/books`
    in the browser and we should see an empty JSON list as a result:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序启动后，让我们在浏览器中打开`http://localhost:8080/books`，我们应该看到一个空白的JSON列表作为结果：
- en: '![](img/5fbec377-9b90-4f43-a942-f7665ff8c7bd.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fbec377-9b90-4f43-a942-f7665ff8c7bd.png)'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe we have done three things after adding the Hystrix dependency
    library to our project. So, let''s take a look at each step in detail to learn
    what exactly happens:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们在将Hystrix依赖库添加到我们的项目后做了三件事。因此，让我们详细查看每个步骤，以了解确切发生了什么：
- en: The `@EnableCircuitBreaker` annotation, similar to `@EnableDiscoveryClient`,
    or `@EnableFeignClients`, which explicitly indicates that we want Spring Cloud
    to load appropriate configurations from `spring.factories` from all the libraries
    which have the `org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker`
    key defined.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableCircuitBreaker`注解与`@EnableDiscoveryClient`或`@EnableFeignClients`类似，它明确表示我们希望Spring
    Cloud从所有具有`org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker`键定义的库中加载适当的配置。'
- en: In the case of Hystrix, it will load `HystrixCircuitBreakerConfiguration`, which
    provides the necessary configuration to enable the Hystrix functionality within
    the application. One of the beans it creates, is the `HystrixCommandAspect` class.
    It's purpose is to detect all the methods which are annotated with the `@HystrixCommand`
    annotation and wrap them with a handler to detect errors, timeouts, and other
    ill-behaviors, and deal with them appropriately, based on configuration.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Hystrix的情况下，它会加载`HystrixCircuitBreakerConfiguration`，这为在应用程序内启用Hystrix功能提供了必要的配置。它创建的一个bean是`HystrixCommandAspect`类。它的目的是检测所有被`@HystrixCommand`注解的方法，并将它们包装在一个处理程序中，以检测错误、超时和其他不良行为，并根据配置适当地处理它们。
- en: This `@HystrixCommand` annotation, provided by the Hystrix library, is designed
    to mark methods which represent `Hystrix-guarded commands`, that is, methods which
    we want to protect using Hystrix against cascading failures and overloads. This
    annotation has a number of attributes and can be configured in a variety of different
    ways, depending on the desired behavior.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个由Hystrix库提供的`@HystrixCommand`注解旨在标记代表`Hystrix-guarded commands`的方法，即我们希望使用Hystrix来保护免受级联故障和过载的方法。这个注解有几个属性，可以根据期望的行为以多种不同的方式进行配置。
- en: In our example we have used the most typical attribute—`fallbackMethod`, which
    allows us to configure an alternative method, with matching signature, which can
    be automatically called if the real method fails the invocation for whatever reason.
    This is the prime use-case, and it provides the ability to specify graceful degradation
    of service, using sensible defaults, if possible, instead of blowing up exceptions
    up the stack.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了最典型的属性——`fallbackMethod`，它允许我们配置一个具有匹配签名的替代方法，如果实际方法由于任何原因失败，则可以自动调用它。这是主要用例，它提供了使用合理的默认值来指定服务优雅降级的可能性，而不是将异常向上抛出。
- en: We used it to direct failed calls to the `getEmptyBooksList()` method, which
    returns a static empty list. This way, when the real `getAllBooks()` method fails,
    we gracefully degrade and return an empty collection, which renders nicely as
    a response JSON. In the situations when we do indeed desire a particular type
    of exception to be propagated up the stack, we can configure those explicitly
    using the `ignoreExceptions` attribute and set it to the desired exception classes.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用它将失败的调用重定向到`getEmptyBooksList()`方法，该方法返回一个静态的空列表。这样，当实际的`getAllBooks()`方法失败时，我们可以优雅地降级并返回一个空集合，这作为响应JSON看起来很漂亮。在确实希望将特定类型的异常传播到堆栈上的情况下，我们可以使用`ignoreExceptions`属性显式配置这些，并将其设置为所需的异常类。
- en: To configure the circuit breaker behavior of a particular command, we can set
    a number of different options using the `commandProperties` or `threadPoolProperties`
    attributes. There we can set things like execution timeouts, size of backup queues,
    and many others.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要配置特定命令的断路器行为，我们可以使用`commandProperties`或`threadPoolProperties`属性设置多个不同的选项。在那里，我们可以设置诸如执行超时、备份队列大小等许多其他设置。
- en: For a complete list of available properties, see [https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration](https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的完整属性列表，请参阅[https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration](https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration)。
- en: 'One last thing to discuss is the modifications we made to our entity models
    to set the relational association annotations to use `fetch = FetchType.EAGER`.
    The reason we had to do so is due to the way Hibernate handles association loading.
    By default, those are loaded using the `FetchType.LAZY` setup, meaning that Hibernate
    is only going to establish the relationship, but the loading of the data will
    not happen until the getter methods are invoked. With Hystrix, by default, this
    could cause an error that looks something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要讨论的一件事是我们对实体模型所做的修改，将关系关联注解的`fetch`设置为`FetchType.EAGER`。我们之所以必须这样做，是因为Hibernate处理关联加载的方式。默认情况下，这些是使用`FetchType.LAZY`设置加载的，这意味着Hibernate只会建立关系，但数据的加载将不会发生在getter方法被调用之前。使用Hystrix时，默认情况下这可能会导致类似以下错误：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is due to the fact that Hystrix uses `ThreadPool` to execute method calls
    by default, and because the lazy-loaded data needs to access the datastore at
    the time of invocation, Hibernate requires an active session to be present in
    order to handle the request. Since Hibernate stores the session in `ThreadLocal`,
    it is obviously not present in the pooled executor thread that Hystrix is using
    during the invocation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Hystrix默认使用`ThreadPool`来执行方法调用，并且由于延迟加载的数据需要在调用时访问数据存储，Hibernate需要存在一个活跃的会话来处理请求。由于Hibernate将会话存储在`ThreadLocal`中，因此在Hystrix在调用期间使用的池化执行线程中显然不存在。
- en: 'Once we changed the fetching to be eager, all the data is loaded during the
    repository interaction in the original Hibernate thread. We could, alternatively,
    configure our `@HystrixCommand` annotation to use the same executing thread by
    using the following configuration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将获取方式改为懒加载，所有数据将在原始Hibernate线程中的仓库交互时加载。我们可以选择配置我们的`@HystrixCommand`注解以使用相同的执行线程，如下所示：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While Hystrix strongly recommends to use the default `THREAD` strategy, in situations
    when we absolutely need to be residing in the same caller thread, `SEMAPHORE`
    is there to help us.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Hystrix强烈建议使用默认的`THREAD`策略，但在我们绝对需要驻留在相同的调用线程的情况下，`SEMAPHORE`可以帮助我们。
- en: Alternatively, we can set the same configuration in our `application.properties`
    file using `hystrix.command.default.execution.isolation.strategy=SEMAPHORE`, or,
    if we want to be specific to only configure particular `@HystrixCommand`, we can
    use the value of the `commandKey` attribute, which is the name of the annotated
    method by default, instead of the default section of the property name. For our
    specific example from the `BookController` instrumented method, the configuration
    key would look like `hystrix.command.getAllBooks.execution.isolation.strategy=SEMAPHORE`.
    This is possible thanks to the Spring Cloud-Netflix Archaius bridge, which makes
    all Spring environment properties visible to the Archaius configuration manager,
    thus accessible by all of the Netflix components.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`application.properties`文件中使用`hystrix.command.default.execution.isolation.strategy=SEMAPHORE`设置相同的配置，或者如果我们只想为特定的`@HystrixCommand`进行配置，我们可以使用`commandKey`属性的值，默认情况下是该注解方法的名称，而不是属性名称的默认部分。对于我们的`BookController`方法的具体示例，配置键将看起来像`hystrix.command.getAllBooks.execution.isolation.strategy=SEMAPHORE`。这是由于Spring
    Cloud-Netflix Archaius桥的存在，它使得所有Spring环境属性对Archaius配置管理器可见，因此所有Netflix组件都可以访问。
- en: Spring Cloud Hystrix integration also provides a `/hystrix.stream` actuator
    endpoint, which can be consumed by the Hystrix dashboard for visualizing the state
    of all the circuit breakers in an application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Hystrix集成还提供了一个`/hystrix.stream`操作端点，该端点可以被Hystrix仪表板消费，用于可视化应用程序中所有断路器的状态。
- en: 'To get the dashboard running quickly, Spring Cloud provides a sample application
    which can be seen at [https://github.com/spring-cloud-samples/hystrix-dashboard](https://github.com/spring-cloud-samples/hystrix-dashboard):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速启动仪表板，Spring Cloud提供了一个示例应用程序，可以在[https://github.com/spring-cloud-samples/hystrix-dashboard](https://github.com/spring-cloud-samples/hystrix-dashboard)找到：
- en: '![](img/b47abbbb-d147-4ab5-b21d-bb38b8293a01.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b47abbbb-d147-4ab5-b21d-bb38b8293a01.png)'
- en: The same stream can also be fed into **Netflix Turbine Stream Aggregator**,
    downloadable at [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine),
    for data aggregation across multiple instances, which can later be visualized
    using the same dashboard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的流也可以输入到**Netflix Turbine Stream Aggregator**，可在[https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)下载，用于跨多个实例的数据聚合，之后可以使用相同的仪表板进行可视化。
- en: One can also use the `spring-cloud-starter-turbine` dependency library and the `@EnableTurbine`
    annotation on a basic Spring Boot application, similar to the Hystrix dashboard
    sample.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`spring-cloud-starter-turbine`依赖库和`@EnableTurbine`注解在一个基本的Spring Boot应用中，类似于Hystrix仪表板示例。
