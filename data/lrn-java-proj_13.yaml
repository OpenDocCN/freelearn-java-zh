- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Generics and Collections
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和集合
- en: Organizing data is another important software development topic. Java hands
    us collections to deal with various data structures. It also gives us generics
    to achieve type safety and avoid duplicate code in our applications. We cannot
    say we’re masters of Java without understanding how to use collections and generics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组织数据是另一个重要的软件开发主题。Java 为我们提供了集合来处理各种数据结构。它还提供了泛型来实现类型安全和避免在应用程序中重复代码。如果我们不了解如何使用集合和泛型，就不能说我们是
    Java 的专家。
- en: 'That’s why we devoted this chapter to the Java collections framework. In this
    chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们专门用这一章来介绍 Java 集合框架。在本章中，我们将涵盖以下主题：
- en: The collections framework and its interfaces – `List`, `Set`, `Map`, and `Queue`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合框架及其接口 – `List`、`Set`、`Map` 和 `Queue`
- en: Several implementations of each collection type and their basic operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种集合类型的不同实现及其基本操作
- en: Sorting collections using natural ordering and the `Comparable` and `Comparator`
    interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自然排序和 `Comparable` 以及 `Comparator` 接口对集合进行排序
- en: Working with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型
- en: Basic hashing concepts and their relevance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本哈希概念及其相关性
- en: By the end of this chapter, you will have a solid understanding of the Java
    collections framework and generics, and you’ll be ready to manage data and use
    collections in your programs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固地理解 Java 集合框架和泛型，并准备好在程序中管理数据和使用集合。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter (*Exercise* section) can be found on GitHub at: [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码（*练习*部分）可以在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises)。
- en: Getting to know collections
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解集合
- en: '**Collections** are worth getting to know. Collections are a much more elegant
    way of dealing with multiple values in one variable than arrays. A common example
    of a collection would be a list.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**值得了解。集合是一种处理一个变量中多个值比数组更优雅的方式。一个常见的集合例子就是列表。'
- en: Writing any proper Java application without collections would be very complicated.
    You’d probably start by creating some classes that will act like Java’s built-in
    collections. They play a vital role in software development as they provide a
    means to manage and organize data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用集合编写任何合适的 Java 应用程序都会非常复杂。你可能首先会创建一些将充当 Java 内置集合的类。它们在软件开发中扮演着至关重要的角色，因为它们提供了一种管理和组织数据的方法。
- en: 'There are many reasons why we need them, but let’s just list (collection pun)
    a few:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要它们的原因有很多，但让我们只列举（集合双关语）几个：
- en: '**Managing large amounts of data**: As applications grow in complexity, they
    often need to deal with large amounts of data. Collections help store and manage
    these datasets. They also come with helpful methods that make it easier to perform
    typical operations on data, such as searching and filtering.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理大量数据**：随着应用程序的复杂性增加，它们通常需要处理大量数据。集合帮助存储和管理这些数据集。它们还提供了一些有用的方法，使得对数据进行典型操作（如搜索和过滤）变得更加容易。'
- en: '**Storing and manipulating various data structures**: Different data structures
    have unique characteristics and are suited for specific tasks. Collections provide
    a diverse set of data structures. This way, we get to choose the most appropriate
    one for our requirements.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储和操作各种数据结构**：不同的数据结构具有独特的特性，适用于特定的任务。集合提供了一系列的数据结构。这样，我们可以根据需求选择最合适的一个。'
- en: '**Ensuring efficient data management and access**: Collections offer a wide
    range of functionality. This helps us optimize data management and data access
    in our applications.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保高效的数据管理和访问**：集合提供了一系列的功能。这有助于我们在应用程序中优化数据管理和数据访问。'
- en: Since there are different data structures, we also need to have different collection
    types. Let’s have a look at them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在不同的数据结构，我们还需要不同的集合类型。让我们来看看它们。
- en: Overview of different collection types
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同集合类型的概述
- en: The Java collections framework offers quite a few different collection types.
    This ensures that developers don’t go ahead and build custom data structure classes
    for all sorts of problems. This would make it very hard for different applications
    to communicate and there would be a lot of boilerplate code necessary for so many
    tasks. It’s a good thing Java comes with these built-in collection interfaces
    and implementations. Let’s have a look at the main interfaces first. You don’t
    need to understand the tiniest details of the coding examples; we’ll explain all
    of it in more detail after.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java 集合框架提供了相当多的不同集合类型。这确保了开发者不会为各种问题构建自定义数据结构类。这将使得不同应用程序之间的通信变得非常困难，并且需要大量样板代码来完成许多任务。Java
    内置了这些集合接口和实现是个好事。让我们首先看看主要接口。您不需要理解编码示例的每一个细节；我们将在之后更详细地解释所有内容。
- en: List
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: One of the most common data structures is the list. **Lists** are ordered and
    indexed collections that allow duplicate elements. They are useful when the order
    of elements is important, and you need to access elements based on their index.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的数据结构之一是列表。**列表**是有序且带索引的集合，允许重复元素。当元素的顺序很重要，并且需要根据索引访问元素时，它们非常有用。
- en: 'Here’s an example of a list where we are storing a sequence of student names
    in a class, where the order of names is significant. This is a list that only
    holds elements of the `String` type. As you can see, `List` is an interface. When
    we instantiate it, we need to choose a class that implements `List`. In this case,
    we’re choosing `ArrayList`. This is a very common choice, but there are other
    options as well, such as `LinkedList`. There are a few important differences,
    but we won’t dive into those here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个列表的例子，我们在这个班级中存储了一系列学生姓名，其中姓名的顺序很重要。这是一个只包含 `String` 类型元素的列表。如您所见，`List`
    是一个接口。当我们实例化它时，我们需要选择一个实现 `List` 的类。在这种情况下，我们选择了 `ArrayList`。这是一个非常常见的选项，但还有其他选项，例如
    `LinkedList`。有一些重要的区别，但在这里我们不会深入探讨：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With that, we have seen that `List` can hold strings, but collections can hold
    any type of object, including custom objects. Let’s say we have a `Person` object.
    This is what that may look like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到 `List` 可以存储字符串，但集合可以存储任何类型的对象，包括自定义对象。假设我们有一个 `Person` 对象。这可能看起来是这样的：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For simplicity, we’ll mostly use `String` for our examples but do keep in mind
    that this could be any object (and that includes other collections).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在示例中主要使用 `String`，但请记住，这可以是任何对象（包括其他集合）。
- en: There are unordered collections that don’t allow duplicates as well. These are
    of the `Set` type. Let’s have a look at them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样存在无序集合，不允许重复元素。这些是 `Set` 类型的。让我们来看看它们。
- en: Sets
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: '**Sets** are (commonly) unordered collections that do not allow duplicate elements.
    They are useful when you need to store unique elements but don’t need to care
    about their order.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**（通常）是无序集合，不允许重复元素。当您需要存储唯一元素但不需要关心它们的顺序时，它们非常有用。'
- en: 'Let’s say we need a data structure for all the email addresses we need to send
    a newsletter to. We don’t want to have any duplicates present because that would
    result in duplicate mail for the receiver:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个数据结构来存储所有需要发送时事通讯的电子邮件地址。我们不希望有任何重复项存在，因为这会导致接收者收到重复的邮件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You don’t need to worry about adding duplicates, nothing happens if you try
    to do that. You’ll see different implementations of `Set` later, including two
    types that maintain a particular order of their elements. But let’s have a look
    at another data structure first: maps.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需担心添加重复项，如果您尝试这样做，什么也不会发生。您将看到 `Set` 的不同实现，包括两种维护其元素特定顺序的类型。但让我们先看看另一种数据结构：映射。
- en: Maps
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: '**Maps** store key-value pairs and provide lookups based on the key. They are
    useful when you need to associate values with unique keys, such as storing user
    information based on their usernames:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**存储键值对，并基于键提供查找。当您需要将值与唯一键关联起来时，例如根据用户名存储用户信息时，它们非常有用：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, maps use different methods. Even though `Map` is part of the
    collections framework, it’s a bit of an odd one. `Map` is the only main interface
    that doesn’t extend the `Collection` interface. `List`, `Set`, and `Queue` do.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，映射使用不同的方法。尽管 `Map` 是集合框架的一部分，但它有点特别。`Map` 是唯一一个没有扩展 `Collection` 接口的主要接口。`List`、`Set`
    和 `Queue` 都扩展了。
- en: Sometimes, we need an ordered collection that only allows access to the beginning
    and/or the end of the collection. We can use queues for this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个只允许访问集合开始和/或结束的有序集合。我们可以使用队列来完成这项任务。
- en: Queues and deques
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列和双端队列
- en: '**Queues** allow you to add elements to the beginning of the queue and access
    elements at the ends. There’s a special queue that allows insertion and removal
    at both ends. This is known as a **deque**. Deque stands for double-ended queue.
    So, queues follow the **First-In, First-Out** (**FIFO**) principle, while deques
    can be used as both a queue (FIFO) and a stack, which follows the **Last-In, First-Out**
    (**LIFO**) principle.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**允许您将元素添加到队列的起始位置，并访问末尾的元素。有一个特殊的队列允许在两端进行插入和删除。这被称为**双端队列**。双端队列代表双端队列。因此，队列遵循**先进先出**（**FIFO**）原则，而双端队列可以用作队列（FIFO）和栈，后者遵循**后进先出**（**LIFO**）原则。'
- en: 'They are useful for tasks that require processing elements in a specific order,
    such as when implementing a task scheduler. Here’s an example of a print job queue
    where tasks are processed in the order they are received:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们对于需要按特定顺序处理元素的任务很有用，例如在实现任务调度器时。以下是一个打印作业队列的示例，其中任务按接收顺序进行处理：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s look at these interfaces in a bit more detail, starting again with `List`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些接口，再次从`List`开始。
- en: List
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: So, the `List` interface is a part of the Java collections framework and it
    is used to represent an ordered collection of elements. Elements in a `List` interface
    can be accessed by their position (index) and can include duplicates. Since `List`
    is an interface, it cannot be instantiated. Two commonly used implementations
    of the `List` interface are `ArrayList` and `LinkedList`. Since these are implementation
    classes, they can be instantiated. Let’s explore what they are.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`List`接口是Java集合框架的一部分，用于表示元素的有序集合。`List`接口中的元素可以通过其位置（索引）访问，并且可以包含重复项。由于`List`是一个接口，因此不能被实例化。`List`接口的两种常用实现是`ArrayList`和`LinkedList`。由于这些是实现类，因此可以实例化。让我们来探讨它们是什么。
- en: ArrayList
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接列表
- en: '`ArrayList` is a resizable array-backed implementation of the `List` interface.
    It provides fast random access to elements and is efficient for read-heavy operations.
    Random access means directly reaching any item using its index quickly.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`是`List`接口的可调整大小的数组实现。它提供了对元素的快速随机访问，并且对于读取密集型操作非常高效。随机访问意味着直接快速地使用其索引到达任何项目。'
- en: '`ArrayList` dynamically resizes itself when elements are added or removed.
    Adding and removing elements is somewhat slower. `LinkedList` is optimized for
    this.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`在添加或删除元素时动态调整自身大小。添加和删除元素的速度相对较慢。`LinkedList`对此进行了优化。'
- en: LinkedList
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接列表
- en: '`LinkedList` is an implementation of the `List` interface based on a doubly
    linked list data structure. Not only does it implement `List` but it also implements
    `Queue` and `Deque`. It provides fast insertion and deletion of elements at the
    beginning and end of the list, as well as efficient traversal in both directions.
    However, accessing elements by index can be slower in `LinkedList` compared to
    `ArrayList` as elements must be traversed from the head or tail of the list.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`是基于双链表数据结构的`List`接口实现。它不仅实现了`List`，还实现了`Queue`和`Deque`。它提供了在列表的开始和末尾快速插入和删除元素的功能，以及双向高效的遍历。然而，与`ArrayList`相比，在`LinkedList`中通过索引访问元素可能较慢，因为必须从列表的头部或尾部遍历元素。'
- en: The upcoming examples could be happening on both an `ArrayList` and a `LinkedList`
    in the same way. The difference is the performance (which is not a significant
    difference for the small amounts of data in these examples).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即将提供的示例可以在`ArrayList`和`LinkedList`上以相同的方式进行。区别在于性能（在这些示例中的小数据量中，这种差异并不显著）。
- en: Exploring the basic operations for lists
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索列表的基本操作
- en: We can add, remove, alter, and access items on lists. Let’s have a look at how
    to perform these everyday operations. There are a lot of other useful methods
    for lists, but we’ll stick to the must-haves and start with adding elements to
    a list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向列表中添加、删除、更改和访问项目。让我们看看如何执行这些日常操作。列表还有很多其他有用的方法，但我们将坚持使用必备的方法，并从向列表中添加元素开始。
- en: Adding elements to a list
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向列表中添加元素
- en: 'We can add elements to a `List` interface using the `add()` method. The `add()`
    method has two forms: `add(E element)` and `add(int index, E element`). The first
    one adds the element to the end of the list, while the second one adds the element
    at the specified index. This will shift all the other elements that follow one
    index up. Here, `E` is the placeholder for the actual type. If it’s a list of
    the `String` type, we can only add strings to the list.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add()` 方法向 `List` 接口中添加元素。`add()` 方法有两种形式：`add(E element)` 和 `add(int
    index, E element)`。第一种形式将元素添加到列表的末尾，而第二种形式将元素添加到指定的索引。这将使所有后续元素向上移动一个索引。这里的 `E`
    是实际类型的占位符。如果它是一个 `String` 类型的列表，我们只能向列表中添加字符串。
- en: 'Let’s have a look at a simple example that uses a list of names:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用名字列表的简单例子：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we create an instance of `ArrayList`. This is a list of the `String`
    type, as we can see by the word `String` between the angle (`<>`) brackets. We
    then go ahead and add `Julie` to the list. After that, we specify the position.
    Instead of adding `Janice` after `Julie`, we add `Janice` at index `0`. This makes
    `Julie` change from index `0` to index `1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `ArrayList` 的实例。这是一个 `String` 类型的列表，正如我们在尖括号 (`<>`) 之间的 `String`
    一词所看到的。然后我们继续将 `Julie` 添加到列表中。之后，我们指定位置。我们不是在 `Julie` 后面添加 `Janice`，而是在索引 `0`
    处添加 `Janice`。这使得 `Julie` 从索引 `0` 变为索引 `1`。
- en: After this, we have a list with two `String` elements in it. Let’s see how we
    can access these elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们有一个包含两个 `String` 元素的列表。让我们看看我们如何访问这些元素。
- en: Getting elements from a list
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中获取元素
- en: 'You can get elements from a `List` interface using the `get()` method, which
    takes an index as an argument. We’ll continue from our previous example. Here’s
    how to do it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `get()` 方法从 `List` 接口中获取元素，该方法需要一个索引作为参数。我们将继续使用我们之前的例子。下面是如何做到这一点：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will get the element at index `1`, which is `Julie`, and store it in a
    variable called `name`. We can also alter the elements in a list. This can be
    done with the `set()` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取索引 `1` 处的元素，即 `Julie`，并将其存储在一个名为 `name` 的变量中。我们还可以通过 `set()` 方法更改列表中的元素。
- en: Changing elements in a list
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改列表中的元素
- en: 'We can change elements in a `List` interface using the `set()` method, which
    takes an index and a new element as arguments. We’re going to alter the element
    at index `1` here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `set()` 方法更改 `List` 接口中的元素，该方法需要一个索引和一个新元素作为参数。在这里，我们将更改索引 `1` 处的元素：
- en: ames.set(1, "Monica");
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ames.set(1, "Monica");
- en: With that, we have updated the value of `Julie` to `Monica`. If we want, we
    can also remove elements from a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就更新了 `Julie` 的值为 `Monica`。如果我们想的话，我们也可以从列表中移除元素。
- en: Removing elements from a list
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中移除元素
- en: 'We can use the `remove()` method to remove elements. The `remove()` method
    has two forms: `remove(int index)` and `remove(Object o`). The first one removes
    an element at a certain position, while the second one removes an element with
    a certain value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `remove()` 方法来移除元素。`remove()` 方法有两种形式：`remove(int index)` 和 `remove(Object
    o)`。第一种形式移除特定位置的元素，而第二种形式移除具有特定值的元素：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, the list is empty again, because we’ve removed both elements.
    We removed `Monica` by using index `1` and we removed `Janice` by looking for
    an element with that value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，列表再次为空，因为我们已经移除了两个元素。我们通过索引 `1` 移除了 `Monica`，通过查找具有该值的元素移除了 `Janice`。
- en: Iterating through a list
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历列表
- en: There are different ways to iterate through a list. We’re going to have a look
    at the two most common ways of doing this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表有不同的方法。我们将查看两种最常见的方法。
- en: 'Firstly, we can use a regular `for` loop to iterate through a list. In this
    case, we’re iterating over the list names. Let’s assume we didn’t remove both
    elements just now and it still has `Janice` and `Monica` in there:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用一个普通的 `for` 循环来遍历一个列表。在这种情况下，我们正在遍历列表中的 `names`。假设我们刚才没有移除两个元素，列表中仍然包含
    `Janice` 和 `Monica`：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output will be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also achieve this same output by using a for-each loop:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 `for-each` 循环达到相同的效果：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The difference between the regular for and for-each loop is that we have access
    to the index with the regular for. The for-each loop makes it easier to access
    the elements since we don’t need to make sure we stay within the bounds, use the
    index, and update the index.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正规 `for` 循环和 `for-each` 循环之间的区别在于，我们可以在常规 `for` 循环中访问索引。`for-each` 循环使得访问元素更容易，因为我们不需要确保我们保持在界限内，使用索引，并更新索引。
- en: There are quite a few more methods available, but these are the most important
    ones to get you started. Now, let’s have a look at the `Set` interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有相当多的其他方法可用，但这些是您开始时最重要的方法。现在，让我们看一下`Set`接口。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about all the collection in the official documentation
    here:     [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关所有集合的更多信息：[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html)。
- en: Set
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Set`'
- en: The `Set` interface is part of the Java collections framework and represents
    a generally unordered collection of unique elements. This means that an element
    can only be in the set once. The commonly used implementations of the `Set` interface
    are `HashSet`, `TreeSet`, and `LinkedHashSet`. Let’s have a quick look at each.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口是Java集合框架的一部分，表示一个通常无序且唯一的元素集合。这意味着一个元素只能存在于集合中一次。`Set`接口的常用实现包括`HashSet`、`TreeSet`和`LinkedHashSet`。让我们快速看一下每个实现。'
- en: HashSet
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`HashSet`'
- en: 'Let’s look at the most popular set first: `HashSet`. This is a widely used
    implementation of the `Set` interface based on a hash table. A hash table stores
    data in key-value pairs, enabling fast lookup by computing an item’s key hash.
    It provides constant-time performance for basic operations such as `add`, `remove`,
    and `contains` (checking whether a `Set` interface contains a certain value).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看最流行的集合：`HashSet`。这是基于哈希表的`Set`接口的广泛实现。哈希表以键值对的形式存储数据，通过计算项的键哈希值来实现快速查找。它为基本的操作（如`add`、`remove`和`contains`——检查`Set`接口是否包含某个值）提供了常数时间性能。
- en: '*Constant-time complexity* means that the time it takes to perform these operations
    does not increase when the number of elements in the set grows, assuming that
    the hash function used to distribute the elements among the buckets does its job
    well. We’ll cover hashing and bucket distribution in more detail at the end of
    this chapter, but hashing is pretty much the process of turning a certain value
    into another value – for example, turning a string into a number.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*常数时间复杂度*意味着执行这些操作所需的时间不会随着集合中元素数量的增加而增加，前提是用于在桶之间分配元素哈希函数能够很好地完成其工作。我们将在本章末尾更详细地介绍哈希和桶分配，但哈希基本上是将某个值转换为另一个值的过程——例如，将字符串转换为数字。'
- en: Please note that hash-based data structures such as `HashSet` do not guarantee
    any specific order of the elements stored in them. This is because the elements
    are placed in the set based on their hash values, which might not be related to
    any meaningful order to humans such as ascending or chronological order.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，基于哈希的数据结构，如`HashSet`，并不能保证存储在其中的元素具有任何特定的顺序。这是因为元素是根据它们的哈希值放入集合中的，而这些哈希值可能与人对顺序的理解（如升序或时间顺序）无关。
- en: TreeSet
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TreeSet`'
- en: '`TreeSet` is an implementation of the `Set` interface based on a tree. It maintains
    elements in a sorted order according to their natural ordering or according to
    a custom comparator provided during instantiation. `TreeSet` provides logarithmic
    time performance for common operations such as `add`, `remove`, and `contains`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet`是基于树实现的`Set`接口。它根据元素的天然顺序或实例化时提供的自定义比较器来维护元素的排序顺序。`TreeSet`为常见的操作（如`add`、`remove`和`contains`）提供了对数时间性能。'
- en: '*Logarithmic time complexity* means that the time it takes to perform these
    operations increases logarithmically with the size of the input, making `TreeSet`
    an efficient choice for reasonably large datasets.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*对数时间复杂度*意味着执行这些操作所需的时间随着输入大小的增加而对数增长，这使得`TreeSet`成为处理合理大数据集时的有效选择。'
- en: As opposed to hash-based data structures such as `HashSet`, which do not maintain
    any specific order of elements, `TreeSets` are an excellent choice when you need
    a set that maintains elements in sorted order. This can be useful for tasks such
    as maintaining a list of unique items in sorted order, finding the smallest or
    largest element in a set quickly, or performing range queries on a set of data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与不维护元素特定顺序的基于哈希的数据结构（如`HashSet`）相比，`TreeSets`在需要维护元素排序顺序的集合时是一个极佳的选择。这可以用于诸如维护有序列表中的唯一项目、快速查找集合中的最小或最大元素或对数据集执行范围查询等任务。
- en: Tree explained
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 树的说明
- en: A *tree* in computer science is not something you’d have in your backyard. In
    computer science, a tree is a hierarchical data structure that represents relationships
    between different nodes. Each node is a data point. The first node, called the
    root, has no parents. Every other node descends (directly or indirectly) from
    the root along a single path. The nodes at the very ends of the paths, which have
    no children, are called *leaf nodes*. This structure is ideal for representing
    hierarchical relationships because each node has a parent (except for the root)
    and potentially many children, much like the branches and leaves of a natural
    tree.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的*树*并不是你在后院就能拥有的东西。在计算机科学中，树是一种表示不同节点之间关系的分层数据结构。每个节点都是一个数据点。第一个节点，称为根节点，没有父节点。每个其他节点（直接或间接地）沿着单一路径从根节点衍生出来。路径末端的节点，没有子节点，被称为*叶节点*。这种结构非常适合表示分层关系，因为每个节点都有一个父节点（除了根节点）和可能有很多子节点，就像自然树中的分支和叶子一样。
- en: In a tree, you can think of a path from the root to any node as a journey. Each
    step in the path represents a relationship between parent and child nodes. The
    *height* of a tree is the number of steps in the longest path from the root to
    a leaf. The *depth* of a node is the number of steps in the path from the root
    to that node. Trees with small heights relative to the number of nodes they contain
    are often efficient at finding nodes or adding and removing them. They are valuable
    for several use cases, such as organizing files in a filesystem or storing sorted
    data for efficient lookups, such as in `TreeSet`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中，你可以把从根节点到任何节点的路径看作是一次旅行。路径中的每一步代表父节点和子节点之间的关系。树的*高度*是从根节点到叶节点的最长路径中的步数。节点的*深度*是从根节点到该节点的路径中的步数。与包含的节点数量相比高度较小的树通常在查找节点或添加和删除节点时效率较高。它们对于几个用例很有价值，例如在文件系统中组织文件或存储用于高效查找的排序数据，例如在`TreeSet`中。
- en: LinkedHashSet
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedHashSet
- en: '`LinkedHashSet` is an implementation of the `Set` interface that maintains
    elements in the order they were inserted and it is backed by a combination of
    a hash table and a doubly-linked list. `LinkedHashSet` provides constant-time
    performance for basic operations while preserving insertion order.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashSet`是`Set`接口的一个实现，它按插入顺序维护元素，并由哈希表和双向链表的组合支持。`LinkedHashSet`为基本操作提供常数时间性能，同时保留插入顺序。'
- en: You would typically choose this implementation when the insertion order is important
    and the elements don’t need to be sorted. And, since it’s a `Set`, of course,
    the elements need to be unique (otherwise, `List` might be more logical). An example
    of a use case for `LinkedHashSet` would be maintaining a list of unique items
    in the order they were visited, such as web page browsing history or a playlist
    of unique songs in the order they were added. Another example is tracking events
    or user actions in an application in the order they occurred while ensuring that
    each event or action is processed only once.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入顺序很重要且元素不需要排序时，你通常会选择这种实现方式。而且，由于它是一个`Set`，当然，元素必须是唯一的（否则`List`可能更合理）。`LinkedHashSet`的一个用例示例是维护一个按访问顺序排列的唯一项目列表，例如网页浏览历史或按添加顺序排列的唯一歌曲播放列表。另一个示例是在应用程序中跟踪事件或用户操作，同时确保每个事件或操作只处理一次。
- en: To do all this, we do need to be able to perform some basic operations. So,
    let’s have a look at how to do this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成所有这些，我们确实需要能够执行一些基本操作。所以，让我们看看如何做到这一点。
- en: Performing basic operations on a set
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合上执行基本操作
- en: The operations on a `Set` interface are very similar to the operations on `List`.
    Of course, we don’t work with the index for the methods on `Set`. We’ll start
    by learning how to add to sets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口上的操作与`List`上的操作非常相似。当然，我们在`Set`的方法上不使用索引。我们将从学习如何向集合中添加元素开始。'
- en: Adding elements to a set
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向集合中添加元素
- en: 'Just like we did for `List`, we can add elements to a `Set` interface using
    the `add()` method. Here’s how to do it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`List`中做的那样，我们可以使用`add()`方法向`Set`接口添加元素。以下是这样做的方法：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sets cannot contain duplicate values. Adding the same value twice won’t give
    an error and won’t add the value another time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不能包含重复的值。添加相同的值两次不会产生错误，也不会再次添加该值。
- en: 'With the same ease, we could have created a `LinkedHashSet` class, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样容易，我们可以创建一个`LinkedHashSet`类，如下所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could have also created a `TreeSet` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个`TreeSet`类：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The operations on these sets would be the same.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合上的操作将是相同的。
- en: Changing the elements in a set
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改集合中的元素
- en: We cannot change elements in a `Set` directly. To modify an element, we must
    remove the old element and add the new one. So, let’s learn how to remove elements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接在 `Set` 中更改元素。要修改元素，我们必须删除旧元素并添加新元素。因此，让我们学习如何删除元素。
- en: Removing elements from a set
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从集合中删除元素
- en: 'We can remove elements from a `Set` interface using the `remove()` method.
    We cannot remove by index like we can for `List`, because the elements don’t have
    an index:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `remove()` 方法从 `Set` 接口中删除元素。我们不能像对 `List` 那样按索引删除，因为元素没有索引：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After this, the set will only have one value, namely `Elizabeth`. Since sets
    don’t have indexes, accessing the elements works a bit differently for them as
    well. We can access elements via iteration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，集合将只剩下一个值，即 `Elizabeth`。由于集合没有索引，访问元素的方式也略有不同。我们可以通过迭代来访问元素。
- en: Iterating through a set
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历集合
- en: We can iterate through a set using a `for-each` loop. We can’t use a regular
    `for` loop since we don’t have an index.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for-each` 循环遍历集合。我们不能使用常规的 `for` 循环，因为我们没有索引。
- en: 'Here’s an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After the removal, our `Set` interface only has one name left. So, this `for-each`
    loop will output the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除之后，我们的 `Set` 接口只剩下一个名称了。因此，这个 `for-each` 循环将输出以下内容：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And that’s it for `Set`. Now, let’s explore the `Map` data structure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Set` 来说，这就结束了。现在，让我们探索 `Map` 数据结构。
- en: Map
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: Another member of the collections framework is the `Map` interface. This interface
    represents a collection of key-value pairs. Keys are unique, while values can
    be duplicated. That’s why we use the key to add and access the key-value pairs
    in a map. The commonly used implementations of the `Map` interface that we’ll
    discuss are `HashMap` and `TreeMap`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架的另一个成员是 `Map` 接口。此接口表示一组键值对。键是唯一的，而值可以重复。这就是为什么我们使用键来添加和访问映射中的键值对。我们将讨论的
    `Map` 接口的常用实现是 `HashMap` 和 `TreeMap`。
- en: HashMap
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashMap
- en: Probably the most popular one is `HashMap`. This is a widely used implementation
    of the `Map` interface that’s based on a hash table. Just like `HashSet`, it provides
    constant-time performance for basic operations. However, it does not guarantee
    any specific order of the keys. `HashMap` is suitable for situations where you
    need fast lookups and modifications, such as storing configuration settings or
    counting word occurrences in a piece of text. When the order is important, we
    can use `TreeMap`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的可能就是 `HashMap`。这是一个基于哈希表的广泛使用的 `Map` 接口实现。就像 `HashSet` 一样，它为基本操作提供常数时间性能。然而，它不保证键的任何特定顺序。`HashMap`
    适用于需要快速查找和修改的情况，例如存储配置设置或统计文本中的单词出现次数。当顺序很重要时，我们可以使用 `TreeMap`。
- en: TreeMap
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TreeMap
- en: '`TreeMap` is an implementation of the `Map` interface that’s based on a tree.
    It maintains key-value pairs in a sorted order according to their natural ordering
    or a custom comparator provided during instantiation. We’ll look at custom comparators
    soon as well, but it’s pretty much a way of specifying the order in which it needs
    to be sorted.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap` 是基于树实现的 `Map` 接口。它根据其自然排序或实例化时提供的自定义比较器对键值对进行排序。我们很快就会看到自定义比较器，但这基本上是指定它需要按何种顺序排序的一种方式。'
- en: '`TreeMap` provides logarithmic time performance for common operations such
    as getting elements from the map and adding elements to the map. `TreeMap` is
    useful for scenarios where you need to maintain a sorted collection of key-value
    pairs, such as managing a leaderboard or tracking time-based events.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap` 为常见操作如从映射中获取元素和向映射中添加元素提供对数时间性能。`TreeMap` 适用于需要维护键值对排序集合的场景，例如管理排行榜或跟踪基于时间的事件。'
- en: LinkedHashMap
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedHashMap
- en: '`LinkedHashMap` is another implementation of the `Map` interface. It combines
    the strengths of `HashMap` and `TreeMap` by providing constant-time performance
    for basic operations, similar to `HashMap`, while also maintaining the insertion
    order of key-value pairs. This order is the sequence in which keys are added to
    the map.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashMap` 是 `Map` 接口的另一种实现。它通过提供类似于 `HashMap` 的常数时间性能来结合 `HashMap` 和
    `TreeMap` 的优点，同时保持键值对的插入顺序。这个顺序是键被添加到映射中的顺序。'
- en: '`LinkedHashMap` is essentially a `HashMap` implementation with an additional
    linked list that connects all entries, which allows it to remember the order of
    insertion. This is particularly useful in scenarios where the sequence of data
    matters, such as caching operations or maintaining a record of user activities.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashMap`本质上是一个带有附加链接列表的`HashMap`实现，该列表连接所有条目，这使得它可以记住插入顺序。这在数据序列很重要的情况下特别有用，例如缓存操作或维护用户活动记录。'
- en: Its usage is very similar to the other two implementations. We won’t be showing
    all the implementations here because the basic operations are the same for each
    implementation. The only difference is that they have a specific order when you
    iterate over them, but iterating over them is done in the same way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用与其他两个实现非常相似。我们不会在这里展示所有实现，因为每种实现的基本操作都是相同的。唯一的区别是，当你遍历它们时，它们有一个特定的顺序，但遍历的方式是相同的。
- en: Basic operations on maps
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射的基本操作
- en: '`Map` is quite different from the other collections. Let’s learn how to perform
    the basic operations on `Map`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`与其他集合有很大不同。让我们学习如何执行`Map`的基本操作。'
- en: Adding elements to a map
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向映射中添加元素
- en: 'There is no `add()` method for `Map`. We can add elements to a `Map` interface
    using the `put()` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`没有`add()`方法。我们可以使用`put()`方法向`Map`接口添加元素：'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This adds two key-value pairs to `Map`. Let’s see how we can get the values
    out again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这向`Map`添加了两个键值对。让我们看看我们如何再次获取值。
- en: Getting elements from a map
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从映射中获取元素
- en: 'We can get elements from a `Map` interface using the `get()` method. This is
    how we can get the `Integer` value associated with the `Ross` key:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`get()`方法从`Map`接口获取元素。这就是我们如何获取与`Ross`键关联的`Integer`值的方式：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can also use the key to modify the values of the map.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用键来修改映射的值。
- en: Changing the elements of a map
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改映射的元素
- en: 'We can change the elements in a `Map` interface using the `put()` method with
    an existing key:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有现有键的`put()`方法在`Map`接口中更改元素：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code changes the value of `8` to `9` for the `Chandler` key. We
    cannot change the key. If we need to do this, we need to remove the key-value
    pair and add a new one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`Chandler`键的值从`8`更改为`9`。我们不能更改键。如果我们需要这样做，我们需要删除键值对并添加一个新的。
- en: Removing elements from a map
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从映射中删除元素
- en: The key is also used for removing elements from a map. We can do this with the
    `remove()` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 键也用于从映射中删除元素。我们可以使用`remove()`方法来完成此操作。
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, our map only contains one key-value pair. We can iterate through
    a map as well. This is a bit different than what we did for `List` and `Set`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的映射只包含一个键值对。我们也可以遍历映射。这与我们对`List`和`Set`所做的不太一样。
- en: Iterating through a map
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历映射
- en: We can iterate through the key-value pairs, the values, and the keys with a
    for-each loop. We need to call different methods on our map object to achieve
    this. We can use the `entrySet()`, `keySet()`, and `values()` methods for this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for-each循环遍历键值对、值和键。我们需要在我们的映射对象上调用不同的方法来实现这一点。我们可以使用`entrySet()`、`keySet()`和`values()`方法来完成此操作。
- en: 'Let’s assume that we still have two key-value pairs in our map, with `Ross`
    and `Chandler` as keys. The following code snippet loops through the key-value
    pairs using the `entrySet()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们映射中仍然有两个键值对，以`Ross`和`Chandler`作为键。以下代码片段使用`entrySet()`方法遍历键值对：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`entrySet()` provides a set of `Map.Entry` objects. On this object, we can
    use the `getKey()` and `getValue()` methods to get the key and the value, respectively.
    This will output the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`entrySet()`提供了一组`Map.Entry`对象。在这个对象上，我们可以使用`getKey()`和`getValue()`方法分别获取键和值。这将输出以下内容：'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also loop through the keys:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以遍历键：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will output the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You might be surprised that this is the same output as the previous snippet
    and contains the values as well, but this is because we are using the key to obtain
    the value. This is not possible when we loop through the values. Here’s how we
    can do this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶，这与前面的代码片段相同，并且包含值，但这是因为我们正在使用键来获取值。当我们遍历值时，这是不可能的。以下是如何做到这一点的方法：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will output the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can only see the values, since that is what we’re looping through.
    Next, let’s have a look at the last main interface: `Queue`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只能看到值，因为我们正在遍历这些值。接下来，让我们看看最后一个主要接口：`Queue`。
- en: Queue
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: The last in line is the `Queue` interface. It’s part of the Java collections
    framework and allows FIFO data storage. The head of the queue is the oldest element,
    and the tail is the newest element. Queues are useful for processing tasks in
    the order they are received. There is also a sub-interface called `Deque`, which
    is a special type of queue that allows you to get elements from both the head
    and the tail of the queue. This is why it can also be used for LIFO systems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是 `Queue` 接口。它是 Java 集合框架的一部分，允许 FIFO 数据存储。队列的头部是最老的元素，而尾部是最新的元素。队列对于按接收顺序处理任务非常有用。还有一个名为
    `Deque` 的子接口，它是一种特殊的队列，允许从队列的头部和尾部获取元素。这就是为什么它也可以用于 LIFO 系统。
- en: We’ll only briefly deal with the different types of queues since this is the
    collection that’s typically least used in the wild.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只简要地处理不同类型的队列，因为这是在野外最不常用的集合。
- en: Queue implementations
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列实现
- en: The `Queue` interface extends the `Collection` interface. There are several
    implementations, with some of the most common ones being `PriorityQueue`, `LinkedList`,
    and `ArrayDeque`. The `Deque` interface, which extends the `Queue` interface,
    adds support for double-ended queues, allowing the insertion and removal of elements
    from both ends of the queue. `LinkedList` and `ArrayDeque` are `Deque` implementations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 接口扩展了 `Collection` 接口。有几种实现方式，其中一些最常见的是 `PriorityQueue`、`LinkedList`
    和 `ArrayDeque`。扩展了 `Queue` 接口的 `Deque` 接口增加了对双端队列的支持，允许从队列的两端插入和移除元素。`LinkedList`
    和 `ArrayDeque` 是 `Deque` 的实现。'
- en: Basic operations on the Queue interface
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列接口的基本操作
- en: The basic operations on the `Queue` interface are a bit special because the
    elements can only be accessed at the ends of the queue.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 接口的基本操作有点特殊，因为元素只能从队列的末端访问。'
- en: Adding elements to a queue
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向队列中添加元素
- en: We can add elements to a queue using the `add()` or `offer()` methods. If a
    queue is at its maximum capacity, the `add()` method throws an exception when
    it cannot add to the queue. `offer()` would return `false` if it cannot add the
    element to the queue. Looking at the verbs it seems logical; *offer* is without
    obligation and the queue can turn down the offer when it’s full, hence there is
    no exception if it’s full. It simply returns false if it cannot append it to the
    queue. Whereas *add* really intents to add, if it doesn’t work an exception will
    be thrown.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add()` 或 `offer()` 方法向队列中添加元素。如果队列达到最大容量，当 `add()` 方法无法向队列中添加元素时，会抛出异常。如果
    `offer()` 方法无法将元素添加到队列中，它会返回 `false`。从动词来看，这似乎是合理的；*offer* 没有义务，当队列满时，队列可以拒绝这个请求，因此当队列满时不会抛出异常。如果无法将其附加到队列中，它只会返回
    `false`。而 *add* 真正意图添加，如果它不起作用，则会抛出异常。
- en: 'Here’s how we can use both for `LinkedList`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用 `LinkedList` 的示例：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For objects of the `Deque` type, adding to the beginning of the queue works
    with different methods. `LinkedList` so happens to be of the `Deque` type. The
    `add` and `offer` methods add to the end of the queue, and so do the `Deque` type’s
    special methods, `addLast()` and `offerLast()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Deque` 类型的对象，可以使用不同的方法在队列的头部添加元素。`LinkedList` 正好是 `Deque` 类型。`add` 和 `offer`
    方法将元素添加到队列的末尾，`Deque` 类型的特殊方法 `addLast()` 和 `offerLast()` 也是如此：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s how to add to the beginning:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何向队列的头部添加元素的方法：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The order of the elements in the queue is now (from head to tail) *Task 4, Task
    3, Task 1,* *Task 2*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中元素的顺序现在是（从头部到尾部）*任务 4，任务 3，任务 1，* *任务 2*。
- en: Getting elements from a queue
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从队列中获取元素
- en: We can get the element at the head of a `Queue` interface using the `peek()`
    or `element()` method. They just return the value, without removing it from the
    queue.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `peek()` 或 `element()` 方法从 `Queue` 接口获取队列头部的元素。它们只是返回值，而不会从队列中移除它。
- en: 'Here’s how to get the head of the queue with the `peek()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `peek()` 方法获取队列头部的方法：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The value of `head` becomes *Task 4*. The `element()` method throws an exception
    when it cannot return a value, while the `peek()` method doesn’t. The `peek()`
    method returns `null` when the queue is empty.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`head` 的值变为 *任务 4*。当 `element()` 方法无法返回值时，会抛出异常，而 `peek()` 方法则不会。当队列空时，`peek()`
    方法返回 `null`。'
- en: For `Deque`, we can get elements at both the head and the tail. For the head,
    we can use `getFirst()` and `peekFirst()`. For the tail, we can use `getLast()`
    and `peekLast()`. Please note that `getFirst()` is the `Deque` equivalent of Queue’s
    `element()`, even though these differ in name quite a bit.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Deque`，我们可以在头部和尾部获取元素。对于头部，我们可以使用`getFirst()`和`peekFirst()`。对于尾部，我们可以使用`getLast()`和`peekLast()`。请注意，`getFirst()`是`Deque`的`Queue`的`element()`的等价物，尽管这些名称在相当大的程度上有所不同。
- en: You may wonder, why do we have two methods that do the same for all of these.
    They don’t do the same, there’s an important difference. The `getFirst()`, `getLast()`,
    and `element()` methods attempt to retrieve an end of the queue, but if the queue
    is empty, it throws a `NoSuchElementException`. In contrast, the `peek()`, `peekFirst()`,
    and `peekLast()` methods also retrieve the ends of the queue but return `null`
    if the queue is empty, thus they will not throw an exception.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么对于所有这些我们都有两个做同样事情的方法。它们并不完全一样，有一个重要的区别。`getFirst()`、`getLast()`和`element()`方法试图检索队列的端点，但如果队列是空的，它会抛出`NoSuchElementException`。相比之下，`peek()`、`peekFirst()`和`peekLast()`方法也检索队列的端点，但如果队列是空的，它们会返回`null`，因此它们不会抛出异常。
- en: Changing the elements in a queue
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改队列中的元素
- en: We cannot change elements in a `Queue` interface directly. To modify an element,
    we must remove the old element and add the new one. So, let’s see how to remove
    elements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接在`Queue`接口中更改元素。要修改元素，我们必须删除旧元素并添加新元素。所以，让我们看看如何删除元素。
- en: Removing elements from a queue
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从队列中删除元素
- en: 'We can remove elements from a queue using the `remove()` or `poll()` methods.
    These methods do two things:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`remove()`或`poll()`方法从队列中删除元素。这些方法做两件事：
- en: Return the head of the queue.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回队列的头部。
- en: Remove the head of the queue.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除队列的头部。
- en: 'Here’s an example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is going to store *Task 4* in `removedElement`. At this point, the values
    in the queue will be *Task 3*, *Task 1*, *Task 2*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`Task 4`存储在`removedElement`中。此时，队列中的值将是`Task 3`、`Task 1`、`Task 2`。
- en: This may not surprise you, but for `Deque`, we can remove elements from both
    ends. For the head, we use `removeFirst()` and `pollFirst()`. For the tail, we
    can use `removeLast()` and `pollLast()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会让你感到惊讶，但对于`Deque`，我们可以从两端删除元素。对于头部，我们使用`removeFirst()`和`pollFirst()`。对于尾部，我们可以使用`removeLast()`和`pollLast()`。
- en: 'Again, the difference is in how they deal with null values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，区别在于它们如何处理`null`值：
- en: '`remove()`, `removeFirst()`, and `removeLast()` throw a `NoSuchElementException`
    if the queue is empty.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`、`removeFirst()`和`removeLast()`如果队列是空的，会抛出`NoSuchElementException`。'
- en: '`poll()`, `pollFirst()`, and `pollLast()` return null without throwing an exception,
    signaling that the queue was empty.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`、`pollFirst()`和`pollLast()`在抛出异常的情况下返回`null`，表示队列是空的。'
- en: Now that we know how to remove elements, let’s learn how to iterate through
    a `Queue` interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何删除元素，让我们学习如何遍历`Queue`接口。
- en: Iterating through a queue or deque
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历队列或双端队列
- en: 'We can iterate through a queue or deque using a for-each loop. This doesn’t
    remove theiterating through” elements from the queue:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for-each循环遍历队列或双端队列。这不会从队列中移除“正在遍历”的元素：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will output the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The reason it’s not printing *Task 4* is that we removed it in the previous
    section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有打印出`Task 4`的原因是我们之前已经删除了它。
- en: We have now covered the basics of the four main interfaces and some of the most
    common implementations. We can do more with collections, such as sorting them.
    Let’s have a look at how to do that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了四个主要接口的基础知识以及一些最常见的实现。我们可以对集合做更多的事情，比如排序。让我们看看如何做到这一点。
- en: Sorting collections
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序集合
- en: So far, we’ve learned how to create collections and how to perform basic operations
    on them. They have a lot of useful built-in methods, and one of them helps us
    sort collections. The reason we are paying attention to this one is because it’s
    not as straightforward as some of the others.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建集合以及如何在它们上执行基本操作。它们有很多有用的内置方法，其中之一帮助我们排序集合。我们之所以关注这个方法，是因为它不像其他一些方法那么直接。
- en: Some types have a natural order, such as numbers. They can be easily sorted
    from small to large. The same goes for strings – we can sort them A-Z. But how
    do we sort a collection that contains custom objects of the `Task` type?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型具有自然顺序，例如数字。它们可以很容易地从大到小排序。字符串也是如此——我们可以按字母顺序排序。但如何对一个包含自定义`Task`类型对象的集合进行排序呢？
- en: Stick with me – soon, you’ll be able to do both natural ordering and custom
    ordering while using the `sort` method that’s built into collections.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着我——不久，你将能够在使用集合中内置的`sort`方法时同时进行自然排序和自定义排序。
- en: Natural ordering
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然排序
- en: 'When we talk about natural ordering, we mean the default sorting order for
    a particular data type. For example, numbers are sorted in ascending order, while
    strings are sorted lexicographically. But still, Java wouldn’t know this without
    us telling them that’s what we want. That’s why Java’s built-in classes, such
    as `Integer` and `String`, implement the `Comparable` interface. This is what
    tells Java what the natural order is. Two interfaces are relevant for ordering:
    `Comparable` and `Comparator`. We will cover these next.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论自然排序时，我们指的是特定数据类型的默认排序顺序。例如，数字按升序排序，而字符串按字典顺序排序。但是，如果没有我们告诉Java我们想要这样，Java就不会知道这一点。这就是为什么Java的内置类，如`Integer`和`String`，实现了`Comparable`接口。这就是告诉Java自然顺序是什么。与排序相关的两个接口是`Comparable`和`Comparator`。我们将在下一章中介绍这些。
- en: The Comparable and Comparator interfaces
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Comparable`和`Comparator`接口'
- en: 'When a class implements the `Comparable` interface, we need to implement the
    `compareTo()` method. Here’s an example of how a class would implement that interface:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现`Comparable`接口时，我们需要实现`compareTo()`方法。以下是一个类如何实现该接口的示例：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code is omitted, but as you can see it implements the interface. Now it
    needs to override the `compareTo` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被省略了，但正如你所见，它实现了接口。现在它需要重写`compareTo`方法。
- en: This method defines how to sort two objects of the same type. The `compareTo()`
    method takes another object of the same type as an argument and returns a negative,
    zero, or positive integer based on how the two objects compare.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法定义了如何对相同类型的两个对象进行排序。`compareTo()`方法接受另一个相同类型的对象作为参数，并根据两个对象比较的结果返回一个负数、零或正整数。
- en: 'This is what the outcomes mean:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是结果值的含义：
- en: 0 if the two objects are equal
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个对象相等，则返回0
- en: A positive value if the object is greater than the passed-in object
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象大于传入的对象，则返回正值
- en: A negative value if the object the method is called on is less than the passed-in
    object
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用方法的对象小于传入的对象，则返回负值
- en: The `Comparator` interface does something similar but is not meant to be implemented
    by a class. This interface is used for creating a custom `Comparator` on the fly
    and is typically implemented with a Lambda expression. We haven’t seen Lambda
    expressions yet, but we will in the next chapter. `Comparator` can be passed to
    the `sort` method, to tell the `sort` method how to sort the items.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`接口做的是类似的事情，但不建议由类实现。此接口用于动态创建自定义`Comparator`，通常使用Lambda表达式实现。我们还没有看到Lambda表达式，但将在下一章中介绍。`Comparator`可以传递给`sort`方法，以告诉`sort`方法如何排序项目。'
- en: '`Comparator` is not for natural sorting orders but for “one-off” sorting orders.
    It contains one method, `compare()`. This method takes two objects as arguments
    and returns a negative, zero, or positive integer based on the comparison. Here
    are what the values mean for the result of compare:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`不是用于自然排序顺序，而是用于“一次性”排序顺序。它包含一个方法，`compare()`。此方法接受两个对象作为参数，并根据比较结果返回一个负数、零或正整数。以下是比较结果值的含义：'
- en: 0 if the two objects are equal.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个对象相等，则返回0。
- en: A positive value if the first object is greater than the second (hence they
    are in the wrong order).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个对象大于第二个对象（因此它们顺序错误），则返回正值。
- en: A negative value if the first object is less than the second (hence they are
    in the right order).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个对象小于第二个对象（因此它们顺序正确），则返回负值。
- en: Alright, enough talking. Let’s see some implementations of `Comparable` and
    `Comparator`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，别再说了。让我们看看`Comparable`和`Comparator`的一些实现。
- en: Implementing compareTo()
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现`compareTo()`
- en: 'So, there are roughly two options when we want to sort our custom types:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们想要对自定义类型进行排序时，大约有两种选择：
- en: Give them a natural order by making them implement `Comparable.`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使它们实现`Comparable`来给它们一个自然顺序。
- en: Implement `Comparator` and pass this to the `sort` method.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Comparator`并将其传递给`sort`方法。
- en: 'Let’s start with the first one. We’re going to give our `Person` class a natural
    order. To implement the natural ordering for a custom class, we need to implement
    the `Comparable` interface and the `compareTo()` method. Here’s how to do that:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始。我们将给我们的`Person`类一个自然顺序。为了为自定义类实现自然排序，我们需要实现`Comparable`接口和`compareTo()`方法。下面是如何做到这一点：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the `Person` class is given a natural order by implementing the `Comparable`
    interface.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Person`类通过实现`Comparable`接口被赋予了一个自然顺序。
- en: The `Person` class now implements `Comparable<Person>`. This means that `Person`
    objects can now be compared to each other based on a natural ordering, which is
    determined by the `compareTo()` method. This method takes one input parameter.
    And it is always going to compare that one to the instance the `compareTo()` was
    called. It should return `0` if the objects are equal, a positive value if the
    object the method is called on is greater than the input parameter, and a negative
    value if the input parameter is bigger.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类现在实现了`Comparable<Person>`。这意味着`Person`对象现在可以根据自然顺序相互比较，这个顺序由`compareTo()`方法确定。此方法接受一个输入参数。它总是将此参数与`compareTo()`被调用的实例进行比较。如果对象相等，则应返回`0`；如果调用该方法的对象大于输入参数，则返回正值；如果输入参数大于，则返回负值。'
- en: 'The `Person` class has two attributes: `age` (an integer) and `name` (a string).
    The constructor initializes these attributes with the given values. The `compareTo()`
    method is defined to compare `Person` objects based on their age, but we could
    also have chosen the length of the name to just give an example. In this `compareTo()`
    method, we use the `Integer.compare()` method to perform the comparison. It takes
    two integer values as arguments and returns the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类有两个属性：`age`（一个整数）和`name`（一个字符串）。构造函数使用给定的值初始化这些属性。`compareTo()`方法被定义为根据年龄比较`Person`对象，但我们也可以选择名称长度来举例。在这个`compareTo()`方法中，我们使用`Integer.compare()`方法进行比较。它接受两个整数作为参数，并返回以下内容：'
- en: 0 if the two integers are equal
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个整数相等，则返回`0`。
- en: A positive value if the first integer is greater than the second
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个整数大于第二个整数，则返回正值。
- en: A negative value if the first integer is less than the second
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个整数小于第二个整数，则返回负值。
- en: 'In the context of the `compareTo()` method, this means the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compareTo()`方法的上下文中，这意味着以下内容：
- en: If two `Person` objects have the same age, the method will return `0.`
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个`Person`对象年龄相同，该方法将返回`0`。
- en: If the current `Person` object’s age is greater than the other object’s age,
    the method will return a positive value.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前`Person`对象的年龄大于另一个对象的年龄，则方法将返回正值。
- en: If the current `Person` object’s age is less than the other object’s age, the
    method will return a negative value.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前`Person`对象的年龄小于另一个对象的年龄，则方法将返回负值。
- en: 'These return values determine the natural ordering of the `Person` objects
    when they’re sorted. In this case, the objects will be sorted by their age. Let’s
    have a look at how to do this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些返回值决定了`Person`对象在排序时的自然顺序。在这种情况下，对象将按年龄排序。接下来，让我们看看如何实现这一点：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Before sorting, the elements have the order they were added in. After sorting,
    they are sorted from age low to high, so we get `Huub`, `Anne`, and `Joep`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序之前，元素按照它们被添加的顺序排列。在排序之后，它们按年龄从低到高排序，因此我们得到`Huub`、`Anne`和`Joep`。
- en: But again, since we wrote it, we could have chosen anything. And whatever we
    choose determines the natural order. Natural order is, for example, to sort strings
    A-Z and numbers 0-9\. What the natural order for your custom class is, is up to
    you. It depends on how you implement the `compareTo()` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，既然是我们写的，我们可以选择任何东西。我们选择的内容将决定自然顺序。自然顺序，例如，是按字母顺序排序字符串A-Z和数字0-9。你的自定义类的自然顺序取决于你。它取决于你如何实现`compareTo()`方法。
- en: Sometimes, we’ll need a different order than specified in the `compareTo()`
    method. For example, sorting strings by the length of the word. Luckily, we can
    also create an order that is not connected to the class. Let’s have a look at
    how to do custom sorting next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能需要比`compareTo()`方法中指定的顺序不同。例如，按单词长度对字符串进行排序。幸运的是，我们也可以创建一个与类无关的顺序。接下来，让我们看看如何进行自定义排序。
- en: Implementing compare()
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现compare()
- en: 'There are several ways to implement custom ordering using the `Comparator`
    interface:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使用`Comparator`接口实现自定义排序：
- en: Create a separate class (not typical)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单独的类（不典型）
- en: Use an anonymous inner class (better)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名内部类（更好）
- en: Implement it with a Lambda expression (most common)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda表达式实现（最常见）
- en: 'For example, to sort a list of `Person` objects by their names, we can create
    this anonymous class:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要按名称对`Person`对象列表进行排序，我们可以创建这个匿名类：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we created a new `Comparator` object called `nameComparator` that implements
    the `Comparator` interface. This custom comparator will be used to compare `Person`
    objects based on their names. The `compare()` method is implemented within the
    anonymous inner class. Inside the `compare()` method, we use the `compareTo()`
    method of the `String` class to perform a lexicographic comparison between the
    names of the two `Person` objects.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`Comparator`对象`nameComparator`，该对象实现了`Comparator`接口。这个自定义比较器将用于根据姓名比较`Person`对象。`compare()`方法在匿名内部类中实现。在`compare()`方法内部，我们使用`String`类的`compareTo()`方法对两个`Person`对象的姓名进行字典比较。
- en: 'The `compare()` method in the `Comparator` interface follows the same rules
    for return values as the `compareTo()` method in the `Comparable` interface:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`接口中的`compare()`方法遵循与`Comparable`接口中的`compareTo()`方法相同的返回值规则：'
- en: If the two objects being compared are equal, the method will return `0.`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被比较的两个对象相等，该方法将返回`0`。
- en: If the first object is greater than the second, the method will return a positive
    value.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个对象大于第二个对象，该方法将返回一个正值。
- en: If the first object is less than the second, the method will return a negative
    value.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个对象小于第二个对象，该方法将返回一个负值。
- en: 'To use the custom comparator to sort a list of `Person` objects, we can pass
    the `nameComparator` object as an argument to the `Collections.sort()` method,
    like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义比较器对`Person`对象列表进行排序，我们可以将`nameComparator`对象作为参数传递给`Collections.sort()`方法，如下所示：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, `personList` will be sorted according to the names of the `Person`
    objects in alphabetical order, as specified by `nameComparator`. If we don’t specify
    `nameComparator`, it will use the natural order and sort by age. Before sorting,
    the elements have the order they were added in. After sorting, they are sorted
    by name, A-Z, so we get `Anne`, `Huub`, and `Joep`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`personList`将根据`Person`对象的名称按字母顺序排序，正如`nameComparator`所指定的。如果我们没有指定`nameComparator`，它将使用自然顺序并按年龄排序。在排序之前，元素按照添加的顺序排列。排序后，它们按名称排序，A-Z，所以我们得到`Anne`、`Huub`和`Joep`。
- en: Implementing Comparator with a Lambda expression
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lambda表达式实现Comparator
- en: 'It is more common to use a Lambda expression to implement the `Comparator`
    interface. This way, we have a shorter syntax for creating a comparator without
    the need for an anonymous inner class. You don’t need to understand this yet,
    but here’s an example of using a Lambda expression to create a comparator that
    sorts Person objects by their names:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是使用Lambda表达式来实现`Comparator`接口。这样，我们就有了一个更短的语法来创建比较器，而不需要匿名内部类。你现在可能不需要理解这一点，但这里有一个使用Lambda表达式创建按姓名排序的`Person`对象比较器的例子：
- en: '`Comparator<Person> nameComparatorLambda = (p1,` `p2) ->`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator<Person> nameComparatorLambda = (p1,` `p2) ->`'
- en: '`p1.getName().compareTo(p2.getName());`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`p1.getName().compareTo(p2.getName());`'
- en: 'This works the same. We can pass it as an argument to the `Collections.sort()`
    method:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一样的。我们可以将其作为参数传递给`Collections.sort()`方法：
- en: '`Collections.sort(personList, nameComparatorLambda);`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.sort(personList, nameComparatorLambda);`'
- en: 'Since we now have custom comparators, we can create as many as we can think
    of. Here’s another example of sorting `Person` objects by the length of their
    names using a Lambda expression:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了自定义比较器，我们可以创建尽可能多的比较器。这里有一个使用Lambda表达式按姓名长度排序`Person`对象的另一个例子：
- en: '`Comparator<Person> nameLengthComparator = (p1,` `p2) ->`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator<Person> nameLengthComparator = (p1,` `p2) ->`'
- en: '`Integer.compare(p1.getName().length(),`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integer.compare(p1.getName().length(),`'
- en: '`p2.getName().length());`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`p2.getName().length());`'
- en: '`Collections.sort(personList, nameLengthComparator);`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.sort(personList, nameLengthComparator);`'
- en: Here, `nameLengthComparator` compares `Person` objects based on the length of
    their names. `personList` will be sorted in ascending order of the name lengths.
    Our names all have a length of four, and therefore they will remain in the order
    they were added.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nameLengthComparator`根据姓名长度比较`Person`对象。`personList`将按姓名长度的升序排序。我们的名字长度都是四个，因此它们将保持添加时的顺序。
- en: The advantage of using `Comparator` over the natural order defined by the `Comparable`
    interface is that you can define multiple custom orderings for the same class
    without modifying the class itself. In addition, we can easily change the ordering
    criteria at runtime by providing a different `Comparator` object to the `Collections.sort()`
    method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Comparator`而不是由`Comparable`接口定义的自然顺序的优势在于，你可以在不修改类本身的情况下为同一类定义多个自定义排序。此外，我们可以通过向`Collections.sort()`方法提供不同的`Comparator`对象来轻松地在运行时更改排序标准。
- en: Which option we choose depends on what we need. If we want to give our object
    a natural order, we have to implement the `Comparable` interface. If we don’t
    have access to the class directly, or we want to specify an order that should
    not be the natural order, we can use `Comparator`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择哪个选项取决于我们的需求。如果我们想给我们的对象一个自然顺序，我们必须实现 `Comparable` 接口。如果我们无法直接访问类，或者我们想要指定一个不是自然顺序的顺序，我们可以使用
    `Comparator`。
- en: We can also use comparators when we create `TreeSets` and `TreeMaps`. This will
    determine how the values in these collections are going to be sorted.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在创建 `TreeSet` 和 `TreeMap` 时使用比较器。这将确定这些集合中的值将如何排序。
- en: TreeSets and TreeMaps
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TreeSets 和 TreeMaps
- en: '`TreeSet` and `TreeMap` are sorted collections that use the natural order of
    their elements or a custom comparator for sorting. This is why we cannot create
    `TreeSets` or `TreeMaps` for objects that don’t have a natural order (they don’t
    implement the `Comparable` interface) without providing a custom comparator during
    the creation of `TreeSet` or `TreeMap`. Let’s see how to do this for each of them.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 和 `TreeMap` 是使用其元素的自然顺序或自定义比较器进行排序的有序集合。这就是为什么我们无法为没有自然顺序的对象（它们没有实现
    `Comparable` 接口）创建 `TreeSet` 或 `TreeMap`，除非在创建 `TreeSet` 或 `TreeMap` 时提供一个自定义比较器。让我们看看如何为每个实现这个操作。'
- en: The order of elements in TreeSet
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TreeSet` 中元素的顺序'
- en: As a quick reminder, `TreeSet` is a `Set` implementation that stores elements
    in sorted order. That’s why the elements in `TreeSet` must implement the `Comparable`
    interface or a custom comparator must be passed along during the construction
    of `TreeSet`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，`TreeSet` 是一个 `Set` 实现类，它以排序顺序存储元素。这就是为什么 `TreeSet` 中的元素必须实现 `Comparable`
    接口，或者必须在 `TreeSet` 的构造过程中传递一个自定义比较器。
- en: 'Here’s an example of creating a `TreeSet` class of `Person` objects using the
    natural order:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用自然顺序创建 `TreeSet` 类的 `Person` 对象的例子：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the `Person` class implements the `Comparable` interface, so
    `TreeSet` will use the natural order defined by the `compareTo()` method in the
    `Person` class (this was sorted by age).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Person` 类实现了 `Comparable` 接口，所以 `TreeSet` 将使用 `Person` 类中定义的 `compareTo()`
    方法所定义的自然顺序（这是按年龄排序的）。
- en: 'If you want to create a `TreeSet` class with a custom comparator, you can pass
    the comparator as an argument to the `TreeSet` constructor, like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个带有自定义比较器的 `TreeSet` 类，你可以将比较器作为参数传递给 `TreeSet` 构造函数，如下所示：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, `TreeSet` will be sorted by the names of the `Person` objects,
    as specified by `nameComparator`. We can do something similar for `TreeMap`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TreeSet` 将根据 `nameComparator` 指定的名称对 `Person` 对象进行排序。我们可以对 `TreeMap`
    做类似的事情。
- en: The order of elements in TreeMap
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TreeMap` 中元素的顺序'
- en: In case you’ve forgotten, `TreeMap` is a `Map` implementation that stores key-value
    pairs in a sorted order based on the keys. That’s why the keys in `TreeMap` must
    implement the `Comparable` interface or we should send in a custom comparator
    when we create `TreeMap`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了，`TreeMap` 是一个 `Map` 实现类，它根据键的排序顺序存储键值对。这就是为什么 `TreeMap` 中的键必须实现 `Comparable`
    接口，或者我们在创建 `TreeMap` 时应该提供一个自定义比较器。
- en: 'Let’s start with a `TreeMap` class of `Person` objects as keys and their ages
    as values using the natural order:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用自然顺序作为键的 `Person` 对象和它们的年龄作为值的 `TreeMap` 类开始：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, the `Person` class implements the `Comparable` interface, so
    `TreeMap` will use the natural order defined by the `compareTo()` method in the
    `Person` class.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Person` 类实现了 `Comparable` 接口，所以 `TreeMap` 将使用 `Person` 类中定义的 `compareTo()`
    方法所定义的自然顺序。
- en: 'If you want to create a `TreeMap` class with a custom comparator, you can pass
    the comparator as an argument to the `TreeMap` constructor, like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个带有自定义比较器的 `TreeMap` 类，你可以将比较器作为参数传递给 `TreeMap` 构造函数，如下所示：
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, this `TreeMap` will be sorted by the names of the `Person` objects, as
    specified by `nameComparator`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个 `TreeMap` 将根据 `nameComparator` 指定的名称对 `Person` 对象进行排序。
- en: So, `TreeSet` and `TreeMap` are sorted collections that use either the natural
    order of their elements or a custom comparator to sort their contents.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`TreeSet` 和 `TreeMap` 是使用其元素的自然顺序或自定义比较器来排序其内容的有序集合。
- en: By using the `Comparable` interface and custom comparators, you can define multiple
    orderings for your custom classes and easily control the sorting behavior of your
    collections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Comparable` 接口和自定义比较器，你可以为你的自定义类定义多个排序方式，并轻松控制集合的排序行为。
- en: Working with generics
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与泛型一起工作
- en: 'We have been working with generics in this chapter. Generics are flexible and
    used for (amongst others) collections. We were passing in values to these collections
    by the specified type between the angle brackets. We can create a collection with
    a type parameter like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中一直在使用泛型。泛型是灵活的，用于（包括）集合。我们通过在尖括号之间指定类型来将这些值传递给这些集合。我们可以创建一个具有类型参数的集合，如下所示：
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is because the `List` interface and the `ArrayList` class are created with
    a type parameter (generic). This makes the class a lot more flexible, while still
    ensuring type safety. Let’s have a look at how this was done before generics to
    understand why they are so great.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `List` 接口和 `ArrayList` 类都是使用类型参数（泛型）创建的。这使得类更加灵活，同时仍然确保类型安全。让我们看看在泛型之前是如何做到这一点的，以了解为什么它们如此出色。
- en: Life before generics – objects
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型之前的生活 – 对象
- en: 'When we didn’t have generics, all collections would have objects. You’d have
    to manually check to make sure the item in the list was of the type you hoped
    it was. And if it was, you’d have to cast it to this type to use this, much like
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们没有泛型之前，所有集合都会有对象。你必须手动检查列表中的项是否是你希望的类型。如果是，你必须将其转换为这个类型才能使用，就像这样：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we created a list without specifying any type. This creates
    a list of the `Object` type. And as you probably remember, all Java objects are
    of the `Object` type. Then, we added two strings and an integer to it. This is
    technically allowed since the list accepts objects of any type, but it can lead
    to logical errors in your code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个没有指定任何类型的列表。这创建了一个 `Object` 类型的列表。你可能还记得，所有Java对象都是 `Object`
    类型。然后，我们向其中添加了两个字符串和一个整数。这在技术上是被允许的，因为列表接受任何类型的对象，但它可能导致你的代码中出现逻辑错误。
- en: Later, when we iterate over the list, we must manually check the type of each
    item with `instanceof` before we can safely cast it to a string with `(String)
    item`. If we try to cast an item of the wrong type, the code will throw a `ClassCastException`
    error at runtime. This can be time-consuming and error-prone, which is one of
    the main reasons why generics were introduced.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，当我们遍历列表时，在安全地将每个项目转换为字符串 `(String) item` 之前，我们必须使用 `instanceof` 手动检查每个项目的类型。如果我们尝试将错误类型的项转换为字符串，代码将在运行时抛出
    `ClassCastException` 错误。这可能会很耗时且容易出错，这也是泛型被引入的主要原因之一。
- en: Let’s have a closer look at generics and see them outside of the collection
    use case. We’ll learn how to create a class with a generic and why we would do
    that.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看泛型，并看看它们在集合使用场景之外的应用。我们将学习如何创建一个泛型类，以及为什么我们会这样做。
- en: Use case of generics
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型的用例
- en: Let’s start by creating two types that we are going to be putting in a bag class.
    We’ll do this first without generics.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建两种类型，我们将把它们放入一个包类中。我们首先不使用泛型来做这件事。
- en: 'Here is a public `class` called `Laptop`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为 `Laptop` 的公共 `class`：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And here is a public `class` called `Book`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个名为 `Book` 的公共 `class`：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A book and a laptop are typical things to store in a bag. Let’s write the Java
    code to do this. Without generics, we would need two classes. The first will be
    for `Laptop`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 书和笔记本电脑是典型的可以存放在包里的东西。让我们编写Java代码来完成这个任务。在不使用泛型的情况下，我们需要两个类。第一个将是为 `Laptop`：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second will be for `Book`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个将是为 `Book`：
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we have two custom classes, `Laptop` and `Book`, and two bag classes,
    `LaptopBag` and `BookBag`, each holding a specific type of item. However, there
    is a lot of duplicate code in the `LaptopBag` and `BookBag` classes. We could
    solve this by, instead of making `Bag` specific for one type, allowing it to hold
    `Object` types, like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个自定义类 `Laptop` 和 `Book`，以及两个包类 `LaptopBag` 和 `BookBag`，每个包类都包含特定类型的项。然而，在
    `LaptopBag` 和 `BookBag` 类中有很多重复的代码。我们可以通过，而不是让 `Bag` 对一个类型特定化，允许它持有 `Object` 类型，来解决这个问题，如下所示：
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This class allows us to add a `Laptop`, `Book`, or `Person` class. Pretty much
    anything – it doesn’t care. But that comes with some disadvantages as well. Since
    the `ObjectBag` class can store any type of object, there is no way to ensure
    type safety at compile time. This can lead to runtime exceptions, such as `ClassCastException`,
    if we accidentally mix different types of objects in our code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们添加 `Laptop`、`Book` 或 `Person` 类。几乎可以是任何东西——它并不关心。但这也带来了一些缺点。由于 `ObjectBag`
    类可以存储任何类型的对象，因此在编译时无法确保类型安全。这可能会导致运行时异常，例如 `ClassCastException`，如果我们不小心在代码中混合了不同类型的对象。
- en: Very much related to this is the casting we need to do when retrieving an object
    from `ObjectBag`. To get access to all its methods and fields, we need to explicitly
    cast it back to its original type. This adds verbosity to our code and increases
    the chances of getting a `ClassCastException` error.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 非常相关的是，当我们从 `ObjectBag` 中检索对象时，我们需要进行的类型转换。为了访问所有方法和字段，我们需要显式地将它转换回其原始类型。这增加了代码的冗余，并增加了出现
    `ClassCastException` 错误的可能性。
- en: Luckily, generics come to the rescue! Generics offer a way to create flexible
    and type-safe classes that can handle different types without the disadvantages
    associated with using an `Object` type. So, let’s see how we can rewrite the `ObjectBag`
    class using generics.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，泛型出现了！泛型提供了一种创建灵活且类型安全的类的方法，可以处理不同类型，而不具有使用 `Object` 类型相关的缺点。那么，让我们看看我们如何使用泛型重写
    `ObjectBag` 类。
- en: Syntax generics
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型语法
- en: 'Generics are used by specifying a type parameter within angle brackets, such
    as `<T>`, where `T` represents a type. Here’s a generic solution that uses a single
    `Bag` class:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型通过在尖括号内指定类型参数来使用，例如 `<T>`，其中 `T` 代表一个类型。以下是一个使用单个 `Bag` 类的泛型解决方案：
- en: '[PRE50]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By using the generic type parameter, `<T>`, we can now create a more flexible
    `Bag` class that can hold any type of item, such as `Laptop` or `Book`. At the
    same time, we can ensure type safety and avoid the need for explicit casting.
    Here’s how we can use the `Bag` class:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型类型参数 `<T>`，我们现在可以创建一个更灵活的 `Bag` 类，它可以包含任何类型的项，例如 `Laptop` 或 `Book`。同时，我们可以确保类型安全并避免显式转换的需要。以下是使用
    `Bag` 类的方法：
- en: '[PRE51]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To conclude, generics add flexibility when you’re creating reusable classes,
    all while maintaining type safety. However, sometimes, we may want to restrict
    the types that can be used with a generic class. This is where bounded generics
    come into play. Let’s take a look.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，泛型在创建可重用类时增加了灵活性，同时保持了类型安全。然而，有时我们可能希望限制可以与泛型类一起使用的类型。这就是有界泛型发挥作用的地方。让我们看看。
- en: Bounded generics
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有界泛型
- en: Without bounded generics, we may run into situations where we need to call methods
    specific to a certain type or its subclasses within the generic class. We cannot
    do that directly as the generic class knows nothing about the specific methods
    of the types it handles. Here’s a short example to illustrate the need for bounded
    generics.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 没有有界泛型，我们可能会遇到需要在泛型类中调用特定类型或其子类的方法的情况。我们不能直接这样做，因为泛型类对其处理的类型的特定方法一无所知。以下是一个简短的例子来说明有界泛型的必要性。
- en: 'Let’s suppose we have an interface called `Measurable`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `Measurable` 的接口：
- en: '[PRE52]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We want to have a class that is a lot like `Bag`, but only accepts generics
    that implement the `Measurable` interface. That’s why we need to create a generic
    `MeasurementBag` class that can only hold objects that implement the `Measurable`
    interface. We can use bounded generics to achieve this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个类似于 `Bag` 的类，但只接受实现了 `Measurable` 接口的泛型。这就是为什么我们需要创建一个只能包含实现了 `Measurable`
    接口对象的泛型 `MeasurementBag` 类。我们可以使用有界泛型来实现这一点：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By using `<T extends Measurable>`, we specify that the generic type, `T`, must
    be a class that implements the `Measurable` interface. This ensures that only
    objects of types that implement `Measurable` can be used with the `MeasurementBag`
    class. That’s why we can safely call the `getMeasurement()` method within the
    `MeasurementBag` class – since we know that `T` is guaranteed to implement the
    `Measurable` interface.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `<T extends Measurable>`，我们指定泛型类型 `T` 必须是一个实现了 `Measurable` 接口类的实例。这确保了只有实现了
    `Measurable` 接口类型的对象才能与 `MeasurementBag` 类一起使用。这就是为什么我们可以在 `MeasurementBag` 类中安全地调用
    `getMeasurement()` 方法——因为我们知道 `T` 保证实现了 `Measurable` 接口。
- en: So, these bounded generics allow us to restrict the types that are used in the
    generic class and ensure that they share a common set of methods. That’s why it’s
    safe to call those methods within the generic class. Does this sound familiar
    to what collections do? For example, `Collections.sort()` requires a collection
    with objects that implement `Comparable` when we only pass in one argument (the
    collection). Generics and bounded type parameters are actually very common in
    Java’s own code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些有界泛型允许我们限制在泛型类中使用的类型，并确保它们共享一组公共方法。这就是为什么在泛型类中调用这些方法是安全的。这听起来像集合所做的那样吗？例如，当我们只传递一个参数（集合）时，`Collections.sort()`
    需要一个实现了 `Comparable` 接口的对象集合。泛型和有界类型参数在 Java 自身代码中实际上非常常见。
- en: We have now seen bounded generics that specify an upper bound (a superclass
    or interface) for the generic type. This ensures that only objects of that type
    or its subclasses can be used with the generic class. There are also lower bounds,
    but these are out of scope here. You may run into these in the Java source code,
    but it’s not very likely you’ll be working with these yourself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了限定泛型，它为泛型类型指定了一个上限（一个超类或接口）。这确保了只能使用该类型或其子类的对象与泛型类一起使用。也存在下限，但这里不涉及。你可能会在Java源代码中遇到这些，但你自己实际使用这些的可能性不大。
- en: Let’s dive into another concept that’s important for using custom objects with
    `HashMap` and `HashSet`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨另一个在使用自定义对象与`HashMap`和`HashSet`一起使用时很重要的概念。
- en: Hashing and overriding hashCode()
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希和重写`hashCode()`
- en: Hashing is an important concept in Java. It is used to efficiently store and
    retrieve data in various data structures, such as `HashMaps` and `HashSets`. It’s
    also a very interesting topic. You’ll get quite far without understanding what
    this does, but at some point, you may wonder about the horrible performance of
    your `HashMap` class. And understanding what is going on is not possible without
    understanding hashing. So, let’s discuss the basic concepts of hashing, the role
    of the `hashCode()` method in collections, and best practices for overriding the
    `hashCode()` method in your custom classes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是Java中的一个重要概念。它用于在诸如`HashMaps`和`HashSets`之类的各种数据结构中高效地存储和检索数据。它也是一个非常有趣的话题。即使不理解这个功能，你也能走得很远，但某个时候，你可能会对你的`HashMap`类的糟糕性能感到好奇。而要理解发生了什么，没有理解哈希是不可能的。所以，让我们讨论哈希的基本概念，`hashCode()`方法在集合中的作用，以及自定义类中重写`hashCode()`方法的最佳实践。
- en: Understanding basic hashing concepts
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本的哈希概念
- en: Hashing is a method that transforms data into a piece of code called a hash
    code. Think of it like taking a huge pile of books and assigning each book a unique
    number. A good hash function should give different books different numbers and
    spread them evenly. This makes it easy to find and organize the books. All objects
    in Java have a `hashCode()` method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种将数据转换成称为哈希码的代码片段的方法。想象一下，将一大堆书分配一个唯一的数字。一个好的哈希函数应该给不同的书分配不同的数字，并均匀分布。这使得查找和组织书籍变得容易。Java中的所有对象都有一个`hashCode()`方法。
- en: hashCode() and its role in collections
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`hashCode()`及其在集合中的作用'
- en: The `Object` class has the `hashCode()` method defined. Since all classes inherit
    from `Object` (indirectly), all the objects have the `hashCode()` method. This
    method returns an integer value. Two objects that are the same should have the
    same hash code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`类定义了`hashCode()`方法。由于所有类都从`Object`（间接地）继承，所有对象都有`hashCode()`方法。此方法返回一个整数值。两个相同的对象应该具有相同的哈希码。'
- en: When you use an object in a `HashMap` or `HashSet` class, its `hashCode()` is
    used to decide its position in the data structure. When we create custom classes,
    we sometimes need to override `hashCode()`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`HashMap`或`HashSet`类中使用一个对象时，它的`hashCode()`用于决定其在数据结构中的位置。当我们创建自定义类时，我们有时需要重写`hashCode()`。
- en: Overriding hashCode() and best practices
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写`hashCode()`和最佳实践
- en: When we create a custom class and plan to use it as a key in a `HashMap` class
    or an element in a `HashSet` class, we need to override the `hashCode()` method.
    This ensures that our class has a consistent and efficient hash function.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个自定义类并计划将其用作`HashMap`类中的键或`HashSet`类中的元素时，我们需要重写`hashCode()`方法。这确保了我们的类有一个一致且高效的哈希函数。
- en: 'Here are some best practices for overriding `hashCode()`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重写`hashCode()`的最佳实践：
- en: Include all fields that are used in the `equals()` method. This way, equal objects
    have the same hash code.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在`equals()`方法中使用到的所有字段。这样，相等的对象将具有相同的哈希码。
- en: Use a simple algorithm to combine the hash codes of individual fields, such
    as multiplying by a prime number and adding the hash codes of the fields.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个简单的算法来组合各个字段的哈希码，例如乘以一个素数并加上字段的哈希码。
- en: 'Here’s an example of `hashCode()` implemented in our `Person` class:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在我们的`Person`类中实现`hashCode()`的例子：
- en: '[PRE54]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, the `hashCode()` method has been added.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已经添加了`hashCode()`方法。
- en: Explaining hashCode() in more detail
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地解释`hashCode()`
- en: The numbers `17` and `31` are used as part of the hash code calculation for
    the `Person` class. These are both prime numbers and using prime numbers in hash
    code calculations helps to produce a better distribution of hash codes and reduces
    the likelihood of hashcode collisions. `17` is used as the initial value for the
    result variable. It’s an arbitrary prime number that helps ensure that the hash
    code calculation starts with a non-zero value.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`17`和`31`被用作`Person`类哈希码计算的一部分。这两个都是素数，在哈希码计算中使用素数有助于产生更好的哈希码分布，并减少哈希码冲突的可能性。`17`用作结果变量的初始值。这是一个任意的素数，有助于确保哈希码计算从非零值开始。
- en: By doing so, it reduces the likelihood of generating similar hash codes for
    different objects, which, in turn, helps minimize collisions. `31` is used as
    a multiplier in the hashcode calculation. Multiplying the current result by a
    prime number (`31`, in this case) before adding the next field’s hash code helps
    mix the hash codes of individual fields more effectively. This results in a better
    distribution of hash codes across the possible range. `31` is often chosen because
    it can be computed efficiently using bitwise operations (that is, `x * 31` is
    the same as `(x << 5) -` `x)`).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，它降低了生成不同对象相似哈希码的可能性，这反过来又有助于最小化冲突。`31`在哈希码计算中用作乘数。在添加下一个字段的哈希码之前，将当前结果乘以一个素数（在这种情况下是`31`）有助于更有效地混合各个字段的哈希码。这导致哈希码在可能范围内的更好分布。`31`通常被选择，因为它可以使用位运算（即`x
    * 31`与`(x << 5) - x)`相同）有效地计算。
- en: Using hashCode() in custom generic types
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在自定义泛型类型中使用hashCode()
- en: 'When creating custom generic classes, we may need to use the `hashCode()` method
    of the objects being stored. To do this, we can simply call the `hashCode()` method
    on the object or use the `Objects.hashCode()` utility method, which handles null
    values gracefully:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义泛型类时，我们可能需要使用存储对象的`hashCode()`方法。为此，我们可以在对象上简单地调用`hashCode()`方法或使用`Objects.hashCode()`实用方法，该方法可以优雅地处理空值：
- en: '[PRE55]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Understanding hashing and the `hashCode()` method is important when working
    with Java collections, especially when using custom classes combined with hashed
    collections. If we follow best practices for overriding `hashCode()` and using
    it in custom generic types, we can achieve better performance when adding and
    accessing elements in our collections.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Java集合工作时，理解哈希和`hashCode()`方法很重要，尤其是在使用自定义类与哈希集合结合时。如果我们遵循重写`hashCode()`和使用自定义泛型类型的最佳实践，我们可以在添加和访问集合中的元素时实现更好的性能。
- en: Exercises
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'You may not have noticed directly, but we’ve been longing for this! We can
    finally add collections and generics to the applications of our apps. Life will
    get easier. Let’s look at some exercises:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有直接注意到，但我们一直在期待这个！我们终于可以将集合和泛型添加到我们应用程序的应用中。生活将变得更加容易。让我们看看一些练习：
- en: Our park has an assortment of dinosaurs and their related data. Implement a
    `List` interface that stores a custom dinosaur class.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们公园里有各种恐龙及其相关数据。实现一个`List`接口来存储自定义的恐龙类。
- en: We need to ensure that the most dangerous dinosaurs are taken care of first.
    Write a `PriorityQueue` class that sorts dinosaurs based on a custom `Comparator`
    interface, such as their danger level.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保首先照顾到最危险的恐龙。编写一个`PriorityQueue`类，根据自定义的`Comparator`接口（例如，它们的危险级别）对恐龙进行排序。
- en: Generics can make our code more reusable. Create a class called `Crate` with
    a generic for the thing you’d like to store in there. This could be food or drinks
    for the restaurant, but also dinosaurs if we need to relocate them.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型可以使我们的代码更具可重用性。创建一个名为`Crate`的类，其中包含一个泛型，用于存储您想存储在该类中的内容。这可以是餐厅的食物或饮料，也可以是恐龙，如果我们需要重新安置它们。
- en: Create three instances of your `Crate` class with different classes in your
    program – for example, `Dinosaur`, `Jeep`, and `DinosaurFood`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的程序中创建三个`Crate`类的实例，使用不同的类 - 例如，`Dinosaur`、`Jeep`和`DinosaurFood`。
- en: Hashing is essential for efficient data handling. Override the `hashCode()`
    method in your dinosaur class.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希对于高效的数据处理至关重要。在你的恐龙类中重写`hashCode()`方法。
- en: 'Challenging: We have some issues with finding personnel for the restaurants.
    Let’s automate the ordering at the ice cream store in our park. Write a program
    that does the following:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：我们在寻找餐厅人员方面有一些问题。让我们自动化我们公园冰淇淋店的订购。编写一个程序来完成以下任务：
- en: Ask how many ice creams the guest would list.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问客人会列出多少冰淇淋。
- en: For every ice cream, ask what flavor they would like (come up with a few choices
    for flavors, make them dinosaur-themed if you dare) and how many scoops.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一款冰淇淋，询问他们想要什么口味（如果你敢的话，可以想出一些口味选择，并使其恐龙主题化）以及多少份。
- en: For simplicity, let’s assume that each guest can only order every flavor once.
    Add all the ice creams and their descriptions to a `List` interface that contains
    maps. These maps will represent the ice creams and the amount of scoops.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们假设每位客人只能订购每种口味一次。将所有冰淇淋及其描述添加到一个包含映射的`List`接口中。这些映射将代表冰淇淋和冰淇淋球的份量。
- en: 'Challenging: Elaborate on *Exercise 13.6*. Print the order (loop over the list!)
    and say it will be ready at the current time plus 10 minutes (you need to calculate
    this, not print that literally!)'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：详细阐述*练习13.6*。打印订单（遍历列表！）并说明它将在当前时间加10分钟后准备好（你需要计算这个时间，而不是直接打印出来！）
- en: Project – advanced dinosaur care system
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 高级恐龙养护系统
- en: As the number of dinosaurs in our park increases, the need for a more sophisticated
    data management system becomes apparent. Generics and collections to the rescue!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们公园中恐龙数量的增加，对更复杂的数据管理系统需求变得明显。泛型和集合来拯救！
- en: We will continue to build on the dinosaur care system. The system should handle
    collections of dinosaurs, allowing functionalities such as sorting dinosaurs based
    on various parameters, ensuring the uniqueness of dinosaurs, and so on.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建恐龙养护系统。该系统应能处理恐龙集合，允许根据各种参数对恐龙进行排序，确保恐龙的唯一性，等等。
- en: Here are the steps we’re going to take.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要采取的步骤。
- en: '**Step 1: Add additional** **Java classes**:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：添加额外的** **Java类**：'
- en: Create a new package named `collections`.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`collections`的新包。
- en: Inside this package, create a class named `DinosaurComparator`. This class should
    implement `Comparator<Dinosaur>`. Override the `compare()` method to sort dinosaurs
    based on various parameters, such as age, size, and so on.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个包内部，创建一个名为`DinosaurComparator`的类。这个类应该实现`Comparator<Dinosaur>`接口。重写`compare()`方法，根据年龄、大小等参数对恐龙进行排序。
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Normally you don’t create a class for comparator, but we don’t see lambdas until
    the next chapter.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不会为比较器创建一个类，但我们直到下一章才会看到lambda表达式。
- en: '**Step 2: Extend the dinosaur** **care system**:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：扩展恐龙** **养护系统**：'
- en: Change the `List` interface in the `DinosaurCareSystem` class that holds the
    `Dinosaur` objects to a `Set` interface. This will ensure the uniqueness of the
    dinosaurs.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`DinosaurCareSystem`类中持有`Dinosaur`对象的`List`接口更改为`Set`接口。这将确保恐龙的唯一性。
- en: Create a method called `sortDinosaurs()` that sorts the `Dinosaur` set using
    `DinosaurComparator`.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`sortDinosaurs()`的方法，使用`DinosaurComparator`对`Dinosaur`集合进行排序。
- en: 'Here is some sample code to get you started:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例代码供你开始：
- en: '[PRE56]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And here’s the `DinosaurComparator` class that you could use:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以使用的`DinosaurComparator`类：
- en: '[PRE57]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Step 3: Interact with** **the system**:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3：与** **系统** **交互**：'
- en: In your `main` class, you can interact with the `DinosaurCareSystem` object
    similar to what did in the previous steps, but now, add the functionality to sort
    the dinosaurs based on the parameters.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的`main`类中，你可以像之前步骤中那样与`DinosaurCareSystem`对象交互，但现在，添加根据参数对恐龙进行排序的功能。
- en: Do you want more? You can expand on this by adding more functionalities, such
    as sorting based on different parameters, searching for dinosaurs based on their
    properties, and more.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要更多吗？你可以通过添加更多功能来扩展这个项目，例如根据不同参数进行排序，根据恐龙的特性进行搜索等。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Alright, you’ve made your way through another tough chapter. In this chapter,
    we explored the fundamentals of collections and generics in Java. We began by
    discussing the need for collections in programming and provided an overview of
    the different collection types available in Java, including `List`, `Set`, `Map`,
    `Queue`, and `Deque`. We examined the specific implementations of each collection
    type, such as `ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, `HashMap`, `TreeMap`,
    and more, along with their differences and appropriate use cases. We also covered
    basic operations, such as adding, removing, and iterating through elements in
    each collection.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经通过了另一个艰难的章节。在本章中，我们探讨了Java中集合和泛型的基础知识。我们首先讨论了编程中集合的需求，并概述了Java中可用的不同集合类型，包括`List`、`Set`、`Map`、`Queue`和`Deque`。我们检查了每种集合类型的特定实现，例如`ArrayList`、`LinkedList`、`HashSet`、`TreeSet`、`HashMap`、`TreeMap`等，以及它们的区别和适当的使用场景。我们还涵盖了基本操作，如向集合中添加、删除和遍历元素。
- en: Then, we moved on to sorting collections. We made the distinction between natural
    ordering and custom ordering with the use of the `Comparable` and `Comparator`
    interfaces. We learned how to implement the `compareTo()` and `compare()` methods,
    as well as how to sort lists, sets, and maps using `Collections.sort()` and the
    `TreeSet` and `TreeMap` classes.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了集合排序的学习。我们通过使用`Comparable`和`Comparator`接口区分了自然排序和自定义排序。我们学习了如何实现`compareTo()`和`compare()`方法，以及如何使用`Collections.sort()`方法和`TreeSet`、`TreeMap`类对列表、集合和映射进行排序。
- en: We then delved into generics, explaining their importance in providing type
    safety. The syntax and basic usage of generics were demonstrated, including the
    use of the `extends` keyword in bounded generics.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们深入探讨了泛型，解释了它们在提供类型安全方面的重要性。我们演示了泛型的语法和基本用法，包括在有限泛型中使用`extends`关键字。
- en: Next, we proceeded to learn how to create custom generic types by defining generic
    classes. We also covered the implications of not having generics, and how to create
    instances of generic types.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续学习如何通过定义泛型类来创建自定义泛型类型。我们还讨论了没有泛型时的含义，以及如何创建泛型类型的实例。
- en: Lastly, we discussed basic hashing concepts and the role of the `hashCode()`
    method in collections. We provided guidelines for overriding `hashCode()` and
    best practices for its implementation, emphasizing its significance in custom
    generic types.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了基本哈希概念和在集合中`hashCode()`方法的作用。我们提供了重写`hashCode()`的指南和其实施的最佳实践，强调了它在自定义泛型类型中的重要性。
- en: 'At this point, you should have gained a solid understanding of the differences
    between `List`, `Set`, `Map`, and `Queue`, as well as have basic knowledge of
    working with generics and hashing. You are now ready for the next exciting topic:
    Lambda expressions.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对`List`、`Set`、`Map`和`Queue`之间的区别有了扎实的理解，并且对泛型和哈希的基本知识有所掌握。你现在可以准备学习下一个令人兴奋的主题：Lambda表达式。
