- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Object Relational Mapping with Jakarta Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jakarta Persistence进行对象关系映射
- en: Jakarta EE applications frequently need to persist data in a relational database.
    In this chapter, we will cover how to connect to a database and perform **Create,
    Read, Update, and Delete** (**CRUD**) **operations** via **Jakarta Persistence**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE应用程序通常需要在关系型数据库中持久化数据。在本章中，我们将介绍如何通过**Jakarta Persistence**连接到数据库并执行**创建、读取、更新和删除**（**CRUD**）**操作**。
- en: Jakarta Persistence is the standard Jakarta EE **Object Relational Mapping**
    (**ORM**) tool. We will discuss this API in detail in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence是Jakarta EE标准的**对象关系映射**（**ORM**）工具。我们将在本章中详细讨论此API。
- en: 'The following are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The CUSTOMERDB database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUSTOMERDB数据库
- en: Configuring Jakarta Persistence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Jakarta Persistence
- en: Persisting data with Jakarta Persistence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jakarta Persistence持久化数据
- en: Entity relationships
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体关系
- en: Composite primary keys
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合主键
- en: Jakarta Persistence Query Language
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta Persistence查询语言
- en: Criteria API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件API
- en: Bean Validation support
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean验证支持
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The source code used in this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src)。
- en: The CUSTOMERDB database
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUSTOMERDB数据库
- en: Our examples in this chapter use a database called `CUSTOMERDB`. This database
    contains tables to track customers and order information for a fictitious store.
    For simplicity, the database uses an in-memory H2 database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例使用一个名为`CUSTOMERDB`的数据库。这个数据库包含跟踪虚构商店客户和订单信息的表。为了简化，数据库使用内存中的H2数据库。
- en: 'A simple utility that automatically starts the database and populates all reference
    tables is included with this book’s example code. The utility can be found under
    `ch08_src/customerdb`. It is a Maven application. Therefore, it can be built from
    the command line via `mvn install`. It creates an executable JAR file with all
    dependencies included. The created JAR file can be found under the `target` directory,
    it can be run from the command line by issuing the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书示例代码中包含一个简单的实用程序，该实用程序可以自动启动数据库并填充所有参考表。该实用程序位于`ch08_src/customerdb`下。它是一个Maven应用程序。因此，可以通过命令行通过`mvn
    install`构建它。它创建了一个包含所有依赖项的可执行JAR文件。创建的JAR文件位于`target`目录下，可以通过以下命令在命令行中运行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The schema for the `CUSTOMERDB` database is depicted in *Figure 8**.1*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMERDB`数据库的模式如图*8**.1*所示。'
- en: '![Figure 8.1 – CUSTOMERDB database schema (The intend of this schema is to
    show the layout; the readability of the text in the boxes, under the headings,
    is not essential.)](img/B21231_8_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – CUSTOMERDB数据库模式（此模式的目的是展示布局；标题下方框中文字的可读性不是必需的。）](img/B21231_8_01.jpg)'
- en: Figure 8.1 – CUSTOMERDB database schema (The intent of this schema is to show
    the layout; the readability of the text in the boxes, under the headings, is not
    essential.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – CUSTOMERDB数据库模式（此模式的目的是展示布局；标题下方框中文字的可读性不是必需的。）
- en: As can be seen in the diagram, the database contains tables to store customer
    information including their names, addresses, and email addresses. It also contains
    tables to store order and item information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，数据库包含存储客户信息的表，包括他们的姓名、地址和电子邮件地址。它还包含存储订单和项目信息的表。
- en: The `ADDRESS_TYPES` table stores values such as “Home”, “Mailing” and “Shipping”,
    to distinguish the type of address in the `ADDRESSES` table; similarly, the `TELEPHONE_TYPES`
    table stores the values “Cell”, “Home”, and “Work”. These two tables are prepopulated
    when creating the database, as well as the `US_STATES` table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADDRESS_TYPES`表存储诸如“家庭”、“邮寄”和“运输”等值，以区分`ADDRESSES`表中的地址类型；同样，`TELEPHONE_TYPES`表存储“手机”、“家庭”和“工作”等值。这两个表在创建数据库时预先填充，以及`US_STATES`表。'
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, our database only deals with U.S. addresses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们的数据库仅处理美国地址。
- en: Configuring Jakarta Persistence
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Jakarta Persistence
- en: Jakarta Persistence requires a bit of configuration before our code can work
    properly. A data source needs to be defined. The data source specifies information
    on how to reach the **Relational Database Management System** (**RDBMS**) system
    we are connecting to (server, port, database user credentials, etc.). There are
    two ways it can be set up. It can be done via the Jakarta EE implementation configuration,
    but how to do this is dependent on the specific implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码能够正常工作之前，Jakarta Persistence需要一些配置。需要定义一个数据源。数据源指定了我们连接到的**关系数据库管理系统（RDBMS**）系统的信息（服务器、端口、数据库用户凭据等）。有两种设置方式。可以通过Jakarta
    EE实现配置来完成，但具体如何操作取决于特定的实现。
- en: It can also be done by annotating an application-scoped CDI bean via the @DataSourceDefinition
    annotation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过使用`@DataSourceDefinition`注解来注解一个应用范围的CDI bean来完成。
- en: There are advantages and disadvantages to each approach. Defining the data source
    as part of the Jakarta EE runtime configuration allows us to deploy our code to
    different environments (development, test, production) without having to make
    any modifications to our code. It also prevents adding any user credentials to
    our source. Using `@DataSourceDefinition` works across Jakarta EE implementations,
    and allows us to test and deploy our code without having to configure our Jakarta
    EE runtime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点。将数据源定义为Jakarta EE运行时配置的一部分，允许我们将代码部署到不同的环境（开发、测试、生产）而无需对代码进行任何修改。它还可以防止将任何用户凭据添加到我们的源中。使用`@DataSourceDefinition`可以在Jakarta
    EE实现之间工作，并允许我们在不配置Jakarta EE运行时的情况下测试和部署我们的代码。
- en: For simplicity, our examples use `@DataSourceDefinition`, but for production
    code, configuring the Jakarta EE implementation is probably a better idea.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的示例使用`@DataSourceDefinition`，但对于生产代码来说，配置Jakarta EE实现可能是一个更好的选择。
- en: 'Typically, we use `@DataSourceDefinition` in an application-scoped CDI bean,
    as illustrated in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在应用范围的CDI bean中使用`@DataSourceDefinition`，如下例所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value of the `name` attribute in `@DataSourceDefinition` defines the JNDI
    name or our data source. The value of the `url` attribute of `@DataSourceDefinition`
    defines the `user` and `password` attributes of `@DataSourceDefinition` define
    the user credentials needed to log in to our database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DataSourceDefinition`中`name`属性值定义了JNDI名称或我们的数据源。`@DataSourceDefinition`中`url`属性值定义了`user`和`password`属性，这些属性定义了登录到我们的数据库所需的用户凭据。'
- en: 'Once a data source has been defined, an XML configuration file named `persistence.xml`
    must be deployed in the WAR file containing the aforementioned bean. This file
    must be placed in the `WEB-INF/classes/META-INF/` directory inside the WAR file.
    An example `persistence.xml` configuration file is shown next:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据源后，必须在包含上述bean的WAR文件中部署一个名为`persistence.xml`的XML配置文件。此文件必须放置在WAR文件内的`WEB-INF/classes/META-INF/`目录中。下面是一个示例`persistence.xml`配置文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`persistence.xml` must contain at least one `<persistence-unit>` element. Each
    `<persistence-unit>` element must provide a value for its `name` attribute and
    must contain a `<jta-data-source>` child element whose value is the JNDI name
    of the data source to be used for the persistence unit.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`persistence.xml`必须至少包含一个`<persistence-unit>`元素。每个`<persistence-unit>`元素必须为其`name`属性提供一个值，并且必须包含一个`<jta-data-source>`子元素，其值是要用于持久化单元的数据源的JNDI名称。'
- en: The value of the `<jta-data-source>` tag must come from a data source configured
    in our Jakarta EE implementation. Notice that in our example, the value of the
    `<jta-data-source>` tag matches the value of the name attribute in the data source
    we defined using `@DataSourceDefinition`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`<jta-data-source>`标签的值必须来自我们在Jakarta EE实现中配置的数据源。注意，在我们的示例中，`<jta-data-source>`标签的值与使用`@DataSourceDefinition`定义的数据源中`name`属性值相匹配。'
- en: The value of the `<provider>` tag must be an implementation of the `jakarta.persistence.spi.PersistenceProvider`
    interface. The exact value depends on the Jakarta Persistence implementation being
    used. In our example, we are using GlassFish as our Jakarta EE implementation,
    which includes EclipseLink as its Jakarta Persistence implementation. Therefore,
    we use the EclipseLink-provided PersistenceProvider implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`<provider>`标签的值必须是`jakarta.persistence.spi.PersistenceProvider`接口的实现。确切的值取决于所使用的Jakarta
    Persistence实现。在我们的示例中，我们使用GlassFish作为我们的Jakarta EE实现，它包括EclipseLink作为其Jakarta
    Persistence实现。因此，我们使用EclipseLink提供的PersistenceProvider实现。'
- en: The reason more than one `<persistence-unit>` element is allowed is because
    an application may access more than one database. A `<persistence-unit>` element
    is required for each database the application will access. If the application
    defines more than one `<persistence-unit>` element, then the `@PersistenceContext`
    annotation used to inject `EntityManager` must provide a value for its `unitName`
    element. The value for this element must match the `name` attribute of the corresponding
    `<persistence-unit>` element in `persistence.xml`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 允许多个 `<persistence-unit>` 元素的原因是，一个应用程序可能需要访问多个数据库。对于应用程序将要访问的每个数据库，都需要一个 `<persistence-unit>`
    元素。如果应用程序定义了多个 `<persistence-unit>` 元素，那么用于注入 `EntityManager` 的 `@PersistenceContext`
    注解必须为其 `unitName` 元素提供一个值。此元素的值必须与 `persistence.xml` 中相应 `<persistence-unit>`
    元素的 `name` 属性匹配。
- en: If our `persistence.xml` configuration class defines more than one persistence
    unit, we need to list the Jakarta Persistence entities managed by that persistence
    unit via a `<class>` tag inside each `<persistence-unit>` tag. Listing each Jakarta
    EE entity inside `<persistence-unit>` is a tedious task, but thankfully, most
    projects define a single persistence unit. We can avoid listing each and every
    Jakarta Persistence entity by using the `<exclude-unlisted-classes>` tag with
    a value of `false`, as illustrated in our example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `persistence.xml` 配置类定义了多个持久化单元，我们需要通过在每个 `<persistence-unit>` 标签内使用 `<class>`
    标签列出该持久化单元管理的 Jakarta Persistence 实体。在 `<persistence-unit>` 内列出每个 Jakarta EE 实体是一个繁琐的任务，但幸运的是，大多数项目只定义了一个持久化单元。我们可以通过使用
    `<exclude-unlisted-classes>` 标签并设置值为 `false` 来避免列出每个 Jakarta Persistence 实体，如我们的示例所示。
- en: Persisting data with Jakarta Persistence
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jakarta Persistence 持久化数据
- en: 'Jakarta Persistence is used to persist data to an RDBMS. Jakarta Persistence
    Entities are regular Java classes; the Jakarta EE runtime knows these classes
    are Entities because they are decorated with the `@Entity` annotation. Let’s look
    at a Jakarta Persistence Entity mapping to the `CUSTOMER` table in the `CUSTOMERDB`
    database:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence 用于将数据持久化到 RDBMS。Jakarta Persistence 实体是常规的 Java 类；Jakarta
    EE 运行时知道这些类是实体，因为它们被 `@Entity` 注解装饰。让我们看看一个映射到 `CUSTOMERDB` 数据库中 `CUSTOMER` 表的
    Jakarta Persistence 实体映射示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our example code, the `@Entity` annotation lets any other Jakarta EE-compliant
    runtime know that this class is a Jakarta Persistence entity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，`@Entity` 注解让任何其他 Jakarta EE 兼容的运行时知道这个类是一个 Jakarta Persistence 实体。
- en: The `@Table(name = "CUSTOMERS")` annotation lets the application server know
    what table to map the entity to. The value of the name element contains the name
    of the database table that the entity maps to. This annotation is optional. If
    the name of the class maps the name of the database table (case insensitive),
    then it isn’t necessary to specify what table the entity maps to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table(name = "CUSTOMERS")` 注解让应用程序服务器知道将实体映射到哪个表。名称元素的值包含实体映射到的数据库表名称。此注解是可选的。如果类的名称映射到数据库表的名称（不区分大小写），则不需要指定实体映射到的表。'
- en: The `@Id` annotation indicates that the `customerId` field maps to the primary
    key.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id` 注解表示 `customerId` 字段映射到主键。'
- en: The `@Column` annotation maps each field to a column in the table. If the name
    of the field matches the name of the database column, then this annotation is
    not needed. This is the reason why the `email` field is not annotated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Column` 注解将每个字段映射到表中的列。如果字段的名称与数据库列的名称匹配，则不需要此注解。这就是为什么 `email` 字段没有被注解的原因。'
- en: 'The `EntityManager` interface is used to persist entities to a database. The
    following example illustrates its usage:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager` 接口用于将实体持久化到数据库。以下示例说明了其用法：'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our example CDI named bean obtains an instance of a class implementing the `jakarta.persistence.EntityManager`
    interface via dependency injection. This is done by decorating the `EntityManager`
    variable with the `@``PersistenceContext` annotation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例 CDI 命名豆通过依赖注入获取实现 `jakarta.persistence.EntityManager` 接口类的实例。这是通过使用 `@PersistenceContext`
    注解装饰 `EntityManager` 变量来完成的。
- en: An instance of a class implementing the `jakarta.transaction.UserTransaction`
    interface is then injected via the `@Resource` annotation. This object is necessary,
    as without it, invoking calls to persist Entities to the database the code would
    throw a `jakarta.persistence.TransactionRequiredException`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过 `@Resource` 注解注入实现 `jakarta.transaction.UserTransaction` 接口的一个实例。这个对象是必要的，因为没有它，代码在调用持久化实体到数据库时将抛出
    `jakarta.persistence.TransactionRequiredException`。
- en: '`EntityManager` instances perform many database-related tasks including finding
    entities in the database, updating them, and deleting them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`实例执行许多数据库相关任务，包括在数据库中查找实体、更新它们和删除它们。'
- en: Since Jakarta Persistence entities are **plain old Java objects** (**POJOs**),
    they can be instantiated via the new operator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jakarta Persistence实体是**普通的Java对象**（**POJOs**），它们可以通过new运算符进行实例化。
- en: Calls to the `persist()` method on `EntityManager` must be in a transaction,
    therefore it is necessary to start one by calling the `begin()` method on `UserTransaction`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EntityManager`上调用`persist()`方法必须在事务中进行，因此需要通过调用`UserTransaction`上的`begin()`方法来启动一个事务。
- en: We then insert two new rows into the `CUSTOMERS` table by calling the `persist()`
    method on `EntityManager` for the two instances of the `Customer` class we populated
    earlier in the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过在`EntityManager`上调用`persist()`方法，为之前在代码中填充的两个`Customer`类实例插入`CUSTOMERS`表中的两个新行。
- en: After persisting the data contained in the `customer` and `customer2` objects,
    we search the database for a row in the `CUSTOMERS` table with a primary key of
    4\. We do this by invoking the `find()` method on `EntityManager`. This method
    takes the class of `Entity` we are searching for as its first parameter, and the
    primary key of the row corresponding to the object we want to obtain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`customer`和`customer2`对象中的数据持久化后，我们在`CUSTOMERS`表中搜索具有键值4的行。我们通过在`EntityManager`上调用`find()`方法来完成此操作。此方法将我们要搜索的`Entity`类的类作为其第一个参数，以及我们想要获取的对象对应的行的键值。
- en: The primary key we set for the `customer2` object was 4, therefore what we have
    now is a copy of this object. The last name of this customer was misspelled when
    we originally inserted his data into the database, so we now correct Mr. Johnson’s
    last name by invoking the `setLastName()` method on `customer3`, then update the
    information in the database by invoking `entityManager.persist()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`customer2`对象设置的键是4，因此我们现在有一个该对象的副本。当我们将这位客户的数据最初插入数据库时，他的姓氏拼写错误，所以我们现在通过在`customer3`上调用`setLastName()`方法来纠正约翰逊先生的姓氏，然后通过调用`entityManager.persist()`来更新数据库中的信息。
- en: We then delete the information for the customer object by invoking `entityManager.remove()`
    and passing the `customer` object as a parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过调用`entityManager.remove()`并传递`customer`对象作为参数，我们删除客户对象的信息。
- en: Finally, we commit the changes to the database by invoking the `commit()` method
    on `userTransaction`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在`userTransaction`上调用`commit()`方法将更改提交到数据库。
- en: Cannot persist detached object exception
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无法持久化分离对象异常
- en: Frequently, an application will retrieve a Jakarta Persistence entity via the
    `EntityManager.find()` method, then pass this entity to a business or user interface
    layer, where it will potentially be modified, and later the database data corresponding
    to the entity will be updated. In cases like this, invoking `EntityManager.persist()`
    will result in an exception. In order to update Jakarta Persistence entities this
    way we need to invoke `EntityManager.merge()`. This method takes an instance of
    the Jakarta Persistence entity as its single argument and updates the corresponding
    row in the database with the data stored in it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序会通过`EntityManager.find()`方法检索Jakarta Persistence实体，然后将该实体传递到业务或用户界面层，在那里它可能会被修改，之后将更新与实体对应的数据库数据。在这种情况下，调用`EntityManager.persist()`将导致异常。为了以这种方式更新Jakarta
    Persistence实体，我们需要调用`EntityManager.merge()`。此方法接受一个Jakarta Persistence实体实例作为其唯一参数，并使用其中存储的数据更新数据库中的对应行。
- en: Now that we’ve seen how to handle single Jakarta Persistence entities, we’ll
    focus our attention on how to define entity relationships.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何处理单个Jakarta Persistence实体，我们将关注如何定义实体关系。
- en: Entity relationships
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体关系
- en: In the previous section, we saw how to retrieve, insert, update, and delete
    single entities from the database. Entities are rarely isolated – in the vast
    majority of cases, they are related to other entities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何从数据库中检索、插入、更新和删除单个实体。实体很少是孤立的 - 在绝大多数情况下，它们与其他实体相关联。
- en: Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以有一对一、一对多、多对一和多对多关系。
- en: In the CUSTOMERDB database, for example, there is a `LOGIN_INFO` and the `CUSTOMERS`
    tables. This means that each customer has exactly one corresponding row in the
    login info table. There is also a `CUSTOMERS` table and the `ORDERS` table. This
    is because a customer can place many orders, but each order belongs only to a
    single customer. There is also a `ORDERS` table and the `ITEMS` table. This is
    because an order can contain many items and an item can be in many orders.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在CUSTOMERDB数据库中，有一个`LOGIN_INFO`表和`CUSTOMERS`表。这意味着每个客户在登录信息表中恰好有一行对应。还有一个`CUSTOMERS`表和`ORDERS`表。这是因为一个客户可以下很多订单，但每个订单只属于一个客户。还有一个`ORDERS`表和`ITEMS`表。这是因为一个订单可以包含多个项目，而一个项目可以出现在多个订单中。
- en: In the next few sections, we discuss how to establish relationships between
    Jakarta Persistence entities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论如何建立Jakarta Persistence实体之间的关系。
- en: One-to-one relationships
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一关系
- en: One-to-one relationships occur when an instance of an entity can have zero or
    one corresponding instance of another entity.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实体的实例可以对应零个或一个另一个实体的实例时，就会发生一对一关系。
- en: One-to-one entity relationships can be bidirectional (each entity is aware of
    the relationship) or unidirectional (only one of the entities is aware of the
    relationship). In the CUSTOMERDB database, the one-to-one mapping between the
    `LOGIN_INFO` and the `CUSTOMERS` tables is unidirectional, since the `LOGIN_INFO`
    table has a foreign key to the `CUSTOMERS` table, but not the other way around.
    As we will soon see, this fact does not stop us from creating a bidirectional
    one-to-one relationship between the `Customer` entity and the `LoginInfo` entity.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一实体关系可以是双向的（每个实体都了解这种关系）或单向的（只有其中一个实体了解这种关系）。在CUSTOMERDB数据库中，`LOGIN_INFO`和`CUSTOMERS`表之间的一对一映射是单向的，因为`LOGIN_INFO`表有一个指向`CUSTOMERS`表的外键，但反过来没有。我们将很快看到，这个事实并不会阻止我们在这两个实体之间创建一个双向的一对一关系。
- en: 'The source code for the `LoginInfo` entity, which maps to the `LOGIN_INFO`
    table, is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到`LOGIN_INFO`表的`LoginInfo`实体的源代码如下：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code for this entity is very similar to the code for the `Customer` entity;
    it defines fields that map to database columns. Each field whose name does not
    match the database column name is annotated with `@Column`, in addition to that,
    the primary key is annotated with `@Id`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实体的代码与`Customer`实体的代码非常相似；它定义了映射到数据库列的字段。每个名称与数据库列名称不匹配的字段都带有`@Column`注解，除此之外，主键还带有`@Id`注解。
- en: Where the preceding code gets interesting is in the declaration of the `customer`
    field. As can be seen in the code, the `customer` field is annotated with `@OneToOne`,
    this lets the Jakarta EE runtime know that there is a one-to-one relationship
    between this entity and the `Customer` entity. The customer field is also annotated
    with `@JoinColumn`. This annotation lets the container know what column in the
    `LOGIN_INFO` table is the foreign key corresponding to the primary key on the
    `CUSTOMER` table. Since `LOGIN_INFO`, the table that the `LoginInfo` entity maps
    to, has a foreign key to the `CUSTOMER` table, the `LoginInfo` entity owns the
    relationship. If the relationship was unidirectional, we wouldn’t have to make
    any changes to the `Customer` entity. However, since we would like to have a bidirectional
    relationship between these two entities, we need to add a `LoginInfo` field to
    the `Customer` entity, along with the corresponding getter and setter methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码变得有趣的地方在于`customer`字段的声明。如代码所示，`customer`字段带有`@OneToOne`注解，这使Jakarta EE运行时知道这个实体与`Customer`实体之间存在一对一的关系。`customer`字段还带有`@JoinColumn`注解。这个注解让容器知道`LOGIN_INFO`表中的哪一列是`CUSTOMER`表上主键的外键。由于`LOGIN_INFO`表（`LoginInfo`实体映射到的表）有一个指向`CUSTOMER`表的外键，因此`LoginInfo`实体拥有这个关系。如果这个关系是单向的，我们就不必对`Customer`实体做任何修改。然而，由于我们希望这两个实体之间有一个双向关系，我们需要在`Customer`实体中添加一个`LoginInfo`字段，以及相应的getter和setter方法。
- en: 'As we mentioned before, in order to make the one-to-one relationship between
    the `Customer` and `LoginInfo` entities bidirectional, we need to make a few simple
    changes to the `Customer` entity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，为了使`Customer`和`LoginInfo`实体之间的一对一关系双向化，我们需要对`Customer`实体做一些简单的修改：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only change we need to make to the `Customer` entity to make the one-to-one
    relationship bidirectional is to add a `LoginInfo` field to it, along with the
    corresponding setter and getter methods. The `loginInfo` field is annotated with
    `@OneToOne`. Since the `Customer` entity does not own the relationship (the table
    it maps to does not have a foreign key to the corresponding table), the `mappedBy`
    element of the `@OneToOne` annotation needs to be added. This element specifies
    what field in the corresponding entity has the other end of the relationship.
    In this particular case, the `customer` field in the `LoginInfo` entity corresponds
    to the other end of this one-to-one relationship.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的唯一更改是将`LoginInfo`字段添加到`Customer`实体中，以及相应的setter和getter方法。`loginInfo`字段被注解为`@OneToOne`。由于`Customer`实体不拥有这个关系（它映射的表没有对应表的外键），因此需要添加`@OneToOne`注解的`mappedBy`元素。此元素指定对应实体中具有关系另一端字段是什么。在这种情况下，`LoginInfo`实体中的`customer`字段对应于这个一对一关系的另一端。
- en: 'The following Java class illustrates the use of the preceding entity:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java类说明了前面实体的使用：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we first create an instance of the `LoginInfo` entity and populate
    it with some data. We then obtain an instance of the `Customer` entity from the
    database by invoking the `find()` method of `EntityManager` (data for this entity
    was inserted into the `CUSTOMERS` table in one of the previous examples). We then
    invoke the `setCustomer()` method on the `LoginInfo` entity, passing the customer
    object as a parameter. Finally, we invoke the `EntityManager.persist()` method
    to save the data in the database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个`LoginInfo`实体的实例，并用一些数据填充它。然后，我们通过调用`EntityManager`的`find()`方法从数据库中获取一个`Customer`实体的实例（此实体的数据在之前的某个例子中已插入到`CUSTOMERS`表中）。然后，我们在`LoginInfo`实体上调用`setCustomer()`方法，将客户对象作为参数传递。最后，我们调用`EntityManager.persist()`方法将数据保存到数据库中。
- en: What happens behind the scenes is that the `CUSTOMER_ID` column of the `LOGIN_INFO`
    table gets populated with the primary key of the corresponding row in the `CUSTOMERS`
    table. This can be easily verified by querying the CUSTOMERDB database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后发生的事情是，`LOGIN_INFO`表的`CUSTOMER_ID`列被填充了`CUSTOMERS`表中相应行的主键。这可以通过查询CUSTOMERDB数据库来轻松验证。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the call to `EntityManager.find()` to obtain the customer entity
    is inside the same transaction where we call `EntityManager.persist()`. If this
    is not the case the database will not be updated successfully.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到调用`EntityManager.find()`以获取客户实体是在调用`EntityManager.persist()`的同一事务中进行的。如果不是这样，数据库将无法成功更新。
- en: One-to-many relationships
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多关系
- en: Jakarta Persistence one-to-many entity relationships can be *bidirectional*
    (i.e., one entity contains a many-to-one relationship and the corresponding entity
    contains an inverse one-to-many relationship) or *unidirectional* (one entity
    contains a many-to-one relationship to another entity, which does not have a corresponding
    one-to-many relationship defined).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence的一对多实体关系可以是双向的（即，一个实体包含一个多对一关系，相应的实体包含一个反向的一对多关系）或单向的（一个实体包含对另一个实体的多对一关系，而另一个实体没有定义相应的一对多关系）。
- en: With SQL, one-to-many relationships are defined by foreign keys in one of the
    tables. The “many” part of the relationship is the one containing a foreign key
    to the “one” part of the relationship. One-to-many relationships defined in an
    RDBMS are typically unidirectional, since making them bidirectional usually results
    in denormalized data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL，一对一关系通过一个表中的外键来定义。关系的“多”部分是包含对关系的“一”部分的外键的部分。在RDBMS中定义的一对多关系通常是单向的，因为使它们双向通常会导致数据非规范化。
- en: Just like when defining a unidirectional one-to-many relationship in an RDBMS,
    in Jakarta Persistence the “many” part of the relationship is the one that has
    a reference to the “one” part of the relationship, therefore the annotation used
    to define the relationship is `@ManyToOne`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在关系型数据库管理系统（RDBMS）中定义单向一对一关系一样，在Jakarta Persistence中，关系的“多”部分是指具有对关系的“一”部分的引用的部分，因此用于定义关系的注解是`@ManyToOne`。
- en: 'In the CUSTOMERDB database, there is a unidirectional one-to-many relationship
    between customers and orders. We define this relationship in the `Order` entity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在CUSTOMERDB数据库中，客户和订单之间存在单向一对一关系。我们在`Order`实体中定义此关系：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we were to define a unidirectional many-to-one relationship between the
    `Orders` entity and the `Customer` entity, we wouldn’t need to make any changes
    to the `Customer` entity. To define a bidirectional one-to-many relationship between
    the two entities, a new field decorated with the `@OneToMany` annotation needs
    to be added to the `Customer` entity, as illustrated in the next example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在`Orders`实体和`Customer`实体之间定义一个单向多对一关系，我们就不需要对`Customer`实体进行任何更改。为了在两个实体之间定义双向一对一关系，需要在`Customer`实体中添加一个用`@OneToMany`注解装饰的新字段，如下一个示例所示：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only difference between this version of the `Customer` entity and the previous
    one is the addition of the orders field and related getter and setter methods.
    Of special interest is the `@OneToMany` annotation decorating this field. The
    `mappedBy` attribute must match the name of the corresponding field in the entity
    corresponding to the “many” part of the relationship. In simple terms, the value
    of the `mappedBy` attribute must match the name of the field decorated with the
    `@ManyToOne` annotation in the bean at the other side of the relationship.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`Customer`实体版本相比，唯一的区别是添加了订单字段和相关 getter 和 setter 方法。特别值得注意的是装饰此字段的`@OneToMany`注解。`mappedBy`属性必须与对应实体中关系“多”部分的相应字段名称匹配。简单来说，`mappedBy`属性值必须与关系另一侧的bean中用`@ManyToOne`注解装饰的字段名称匹配。
- en: 'The following example code illustrates how to persist one-to-many relationships
    to the database:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码说明了如何将一对一关系持久化到数据库中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our example instantiates two instances of the `Order` entity, populates them
    with some data, then in a transaction, an instance of the `Customer` entity is
    located, and used as the parameter of the `setCustomer()` method of both instances
    of the `Order` entity. We then persist both `Order` entities by invoking `EntityManager.persist()`
    for each one of them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例创建了两个`Order`实体的实例，用一些数据填充它们，然后在事务中找到`Customer`实体的一个实例，并将其用作两个`Order`实体实例的`setCustomer()`方法的参数。然后我们通过为每个`Order`实体调用`EntityManager.persist()`来持久化这两个`Order`实体。
- en: Just like when dealing with one-to-one relationships, what happens behind the
    scenes is that the `CUSTOMER_ID` column of the `ORDERS` table in the CUSTOMERDB
    database is populated with the primary key corresponding to the related row in
    the `CUSTOMERS` table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理一对一关系时一样，幕后发生的事情是，CUSTOMERDB数据库中`ORDERS`表的`CUSTOMER_ID`列被填充了对应于`CUSTOMERS`表中相关行的主键。
- en: Since the relationship is bidirectional, we can obtain all orders related to
    a customer by invoking the `getOrders()` method on the `Customer` entity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关系是双向的，我们可以通过在`Customer`实体上调用`getOrders()`方法来获取与客户相关的所有订单。
- en: Many-to-many relationships
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多关系
- en: 'In the CUSTOMERDB database, there is a many-to-many relationship between the
    `ORDERS` table and the `ITEMS` table. We can map this relationship by adding a
    new `Collection<Item>` field to the `Order` entity and decorating it with the
    `@``ManyToMany` annotation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在CUSTOMERDB数据库中，`ORDERS`表和`ITEMS`表之间存在多对多关系。我们可以通过向`Order`实体添加一个新的`Collection<Item>`字段并使用`@ManyToMany`注解来映射这种关系：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see in the preceding code, in addition to being annotated with `@ManyToMany`,
    the `items` field is also annotated with `@JoinTable`. As its name suggests, this
    annotation lets the application server know what table is used as a join table
    to create the many-to-many relationship between the two entities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，除了被注解为`@ManyToMany`外，`items`字段还被注解为`@JoinTable`。正如其名称所暗示的，这个注解让应用服务器知道哪个表被用作连接表来在两个实体之间创建多对多关系。
- en: '`@JoinTable` has three relevant elements: the `name` element, which defines
    the name of the join table, and the `joinColumns` and `inverseJoinColumns` elements,
    which define the columns that serve as foreign keys in the join table pointing
    to the entities’ primary keys. Values for the `joinColumns` and `inverseJoinColumns`
    elements are yet another annotation, the `@JoinColumn` annotation. This annotation
    has two relevant elements, the `name` element, which defines the name of the column
    in the join table, and the `referencedColumnName` element, which defines the name
    of the column in the entity table.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JoinTable`有三个相关元素：`name`元素，它定义了连接表的名字；以及`joinColumns`和`inverseJoinColumns`元素，它们定义了在连接表中作为外键的列，这些列指向实体的主键。`joinColumns`和`inverseJoinColumns`元素的值是另一个注解，即`@JoinColumn`注解。这个注解有两个相关元素，`name`元素，它定义了连接表中的列名；以及`referencedColumnName`元素，它定义了实体表中的列名。'
- en: 'The `Item` entity is a simple entity mapping to the `ITEMS` table in the CUSTOMERDB
    database:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`实体是一个简单的实体，映射到CUSTOMERDB数据库中的`ITEMS`表：'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like one-to-one and one-to-many relationships, many-to-many relationships
    can be unidirectional or bidirectional. Since we would like the many-to-many relationship
    between the `Order` and `Item` entities to be bidirectional, we added a `Collection<Order>`
    field and decorated it with the `@ManyToMany` annotation. Since the corresponding
    field in the `Order` entity already has the join table defined, it is not necessary
    to do it again here. The entity containing the `@JoinTable` annotation is said
    to own the relationship, in a many-to-many relationship, either entity can own
    the relationship. In our example, the `Order` entity owns it, since its `Collection<Item>`
    field is decorated with the `@``JoinTable` annotation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一和多对一关系一样，多对多关系可以是单向的或双向的。由于我们希望`Order`和`Item`实体之间的多对多关系是双向的，所以我们添加了一个`Collection<Order>`字段，并用`@ManyToMany`注解装饰它。由于`Order`实体中相应的字段已经定义了连接表，因此在这里不需要再次定义。包含`@JoinTable`注解的实体被称为拥有关系，在多对多关系中，任一实体都可以拥有这个关系。在我们的例子中，`Order`实体拥有这个关系，因为它的`Collection<Item>`字段被`@JoinTable`注解装饰。
- en: Just like with the one-to-one and one-to-many relationships, the `@ManyToMany`
    annotation on the non-owning side of a bidirectional many-to-many relationship
    must contain a `mappedBy` element indicating what field in the owning entity defines
    the relationship.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一和多对一关系一样，双向多对多关系非拥有方上的`@ManyToMany`注解必须包含一个`mappedBy`元素，指明在拥有实体中定义关系的字段。
- en: 'Now that we have seen the changes necessary to establish a bidirectional many-to-many
    relationship between the `Order` and `Item` entities, we can see the relationship
    in action in the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在`Order`和`Item`实体之间建立双向多对多关系所需的更改，我们可以在下面的示例中看到这个关系在实际中的应用：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code creates two instances of the `Item` entity and populates
    them with some data. It then adds these two instances to a collection. A transaction
    is then started, the two `Item` instances are persisted in the database. Then
    an instance of the `Order` entity is retrieved from the database. The `setItems()`
    method of the `Order` entity instance is then invoked, passing the collection
    containing the two `Item` instances as a parameter. The `Customer` instance is
    then persisted into the database. At this point, two rows are created behind the
    scenes to the `ORDER_ITEMS` table, which is the join table between the `ORDERS`
    and `ITEMS` tables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了两个`Item`实体的实例，并填充了一些数据。然后，将这些实例添加到一个集合中。接着开始一个事务，将这两个`Item`实例持久化到数据库中。然后从数据库中检索`Order`实体的一个实例。随后调用`Order`实体实例的`setItems()`方法，并将包含两个`Item`实例的集合作为参数传递。然后，将`Customer`实例持久化到数据库中。此时，在`ORDER_ITEMS`表中创建了两个行，这是`ORDERS`和`ITEMS`表之间的连接表。
- en: Composite primary keys
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合主键
- en: Most tables in the CUSTOMERDB database have a column with the sole purpose of
    serving as a primary key (this type of primary key is sometimes referred to as
    a surrogate primary key or as an artificial primary key). However, some databases
    are not designed this way. Instead, a column in the database that is known to
    be unique across rows is used as the primary key. If there is no column whose
    value is not guaranteed to be unique across rows, then a combination of two or
    more columns is used as the table’s primary key. It is possible to map this kind
    of primary key to Jakarta Persistence entities by using a **primary** **key class**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在CUSTOMERDB数据库中的大多数表中，都有一个列的唯一目的是作为主键（这种类型的主键有时被称为代理主键或人工主键）。然而，一些数据库并不是这样设计的。相反，数据库中一个已知在行之间是唯一的列被用作主键。如果没有列的值在行之间不是保证唯一的，那么两个或更多列的组合被用作表的主键。可以通过使用**主键类**来将这种类型的主键映射到Jakarta
    Persistence实体。
- en: 'There is one table in the CUSTOMERDB database that does not have a surrogate
    primary key, this table is the `ORDER_ITEMS` table. This table serves as a join
    table between the `ORDERS` and `ITEMS` tables. In addition to having foreign keys
    for these two tables, this table has an additional column called `ITEM_QTY`, which
    stores the quantity of each item in an order. Since this table does not have a
    surrogate primary key, the Jakarta Persistence entity mapping to it must have
    a custom primary key class. In this table, the combination of the `ORDER_ID` and
    the `ITEM_ID` columns must be unique. Therefore, this is a good combination for
    a composite primary key, as illustrated in the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在CUSTOMERDB数据库中有一个表没有代理主键，这个表是`ORDER_ITEMS`表。这个表作为`ORDERS`和`ITEMS`表之间的连接表。除了为这两个表有外键之外，这个表还有一个额外的列叫做`ITEM_QTY`，用于存储订单中每个项目的数量。由于这个表没有代理主键，映射到它的Jakarta
    Persistence实体必须有一个自定义主键类。在这个表中，`ORDER_ID`和`ITEM_ID`列的组合必须是唯一的。因此，这是一个复合主键的好组合，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A custom primary key class must satisfy the following requirements:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自定义主键类必须满足以下要求：
- en: The class must be public
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须是公开的
- en: It must implement `java.io.Serializable`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须实现`java.io.Serializable`
- en: It must have a public constructor that takes no arguments
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有一个不接受任何参数的公开构造函数
- en: Its fields must be `public` or `protected`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的字段必须是`public`或`protected`
- en: Its field names and types must match those of the entity
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的字段名称和类型必须与实体的匹配
- en: It must override the default `hashCode()` and `equals()` methods defined in
    the `java.lang.Object` class
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须重写`java.lang.Object`类中定义的默认`hashCode()`和`equals()`方法
- en: The preceding `OrderPK` class meets all of these requirements. It also has a
    convenience constructor that takes two `Long` objects meant to initialize its
    `orderId` and `itemId` fields. This constructor was added for convenience; this
    is not a requirement for the class to be used as a primary key class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`OrderPK`类满足所有这些要求。它还有一个方便的构造函数，接受两个`Long`对象，用于初始化其`orderId`和`itemId`字段。这个构造函数是为了方便而添加的；这不是将类用作主键类的必要条件。
- en: 'When an entity uses a custom primary key class, it must be annotated with `@IdClass`.
    Since the `OrderItem` class uses `OrderItemPK` as its custom primary key class,
    it is annotated with said annotation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实体使用自定义主键类时，它必须注解了`@IdClass`。由于`OrderItem`类使用`OrderItemPK`作为其自定义主键类，因此它被注解了：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are two differences between the `OrderItem` entity and the previous entities
    we have seen. The first difference is that this entity is annotated with `@IdClass`,
    indicating the primary key class corresponding to it. The second difference is
    that `OrderItem` has more than one field annotated with `@Id`. Since this entity
    has a composite primary key, each field that is part of the primary key must be
    annotated with this annotation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderItem`实体与之前我们看到的实体有两个不同之处。第一个不同之处在于这个实体被注解了`@IdClass`，表示与它对应的主键类。第二个不同之处在于`OrderItem`有多个字段被注解了`@Id`。由于这个实体有一个复合主键，每个作为主键一部分的字段都必须注解这个注解。'
- en: 'Obtaining a reference of an entity with a composite primary key is not much
    different than obtaining a reference to an entity with a primary key consisting
    of a single field. The following example demonstrates how to do this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 获取具有复合主键的实体的引用与获取具有单字段主键的实体的引用没有太大区别。以下示例演示了如何做到这一点：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As can be seen in this example, the only difference between locating an entity
    with a composite primary key and an entity with a primary key consisting of a
    single field is that an instance of the custom primary key class must be passed
    as the second argument of the `EntityManager.find()` method; fields for this instance
    must be populated with the appropriate values for each field that is part of the
    primary key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，使用复合主键定位实体与使用单字段主键的实体之间的唯一区别是，必须将自定义主键类的实例作为`EntityManager.find()`方法的第二个参数传递；对于此实例的字段必须填充主键组成部分的每个字段适当的值。
- en: Jakarta Persistence Query Language
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Persistence Query Language
- en: All of our examples that obtain entities from the database so far have conveniently
    assumed that the primary key for the entity is known ahead of time. We all know
    that frequently this is not the case. Whenever we need to search for an entity
    by a field other than the entity’s primary key, we can use the **Jakarta Persistence
    Query** **Language** (**JPQL**).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的例子都方便地假设在事先知道实体的主键。我们都知道，这通常并不是情况。每当我们需要通过除实体主键之外的字段来搜索实体时，我们可以使用**Jakarta
    Persistence Query Language**（**JPQL**）。
- en: 'JPQL is an SQL-like language used for retrieving, updating, and deleting entities
    in a database. The following example illustrates how to use JPQL to retrieve a
    subset of states from the `US_STATES` table in the CUSTOMERDB database:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL是一种类似于SQL的语言，用于在数据库中检索、更新和删除实体。以下示例说明了如何使用JPQL从CUSTOMERDB数据库中的`US_STATES`表检索状态子集：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code invokes the `EntityManager.createQuery()` method, passing
    a `String` containing a JPQL query as a parameter. This method returns an instance
    of `jakarta.persistence.Query`. The query retrieves all `UsState` entities whose
    names start with the word “New”.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码调用了`EntityManager.createQuery()`方法，传递一个包含JPQL查询的`String`参数。此方法返回一个`jakarta.persistence.Query`实例。查询检索所有以单词“New”开头的`UsState`实体。
- en: 'As can be seen in the preceding code, JPQL is similar to SQL, however, there
    are some differences that may confuse readers with SQL knowledge. The equivalent
    SQL code for the query in the code is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，JPQL类似于SQL，然而，有一些差异可能会让有SQL知识的人感到困惑。代码中查询的等效SQL代码如下：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first difference between JPQL and SQL is that in JPQL, we always reference
    entity names, whereas in SQL table names are referenced. The `s` after the entity
    name in the JPQL query is an alias for the entity. Table aliases are optional
    in SQL, but entity aliases are required in JPQL. Keeping these differences in
    mind, the JPQL query should now be a lot less confusing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL与SQL之间的第一个区别在于，在JPQL中，我们总是引用实体名称，而在SQL中引用的是表名。JPQL查询中实体名称后面的`s`是实体的别名。在SQL中表别名是可选的，但在JPQL中实体别名是必需的。记住这些区别，JPQL查询现在应该会少一些令人困惑。
- en: The `:name` in the query is a `setParameter()` method in the instance of `jakarta.persistence.Query`
    returned by the call to `EntityManager.createQuery()`. A JPQL query can have multiple
    named parameters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中的`:name`是`EntityManager.createQuery()`调用返回的`jakarta.persistence.Query`实例中的`setParameter()`方法。JPQL查询可以有多个命名参数。
- en: To actually run the query and retrieve the entities from the database, we can
    invoke the `getResultList()` method on the instance of `jakarta.persistence.Query`
    obtained from `EntityManager.createQuery()`. This method returns an instance of
    a class implementing the `java.util.List` interface, this list contains the entities
    matching the query criteria. If no entities match the criteria, then an empty
    list is returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行查询并从数据库检索实体，我们可以在从`EntityManager.createQuery()`获得的`jakarta.persistence.Query`实例上调用`getResultList()`方法。此方法返回实现`java.util.List`接口的类的实例，该列表包含符合查询标准的实体。如果没有实体符合标准，则返回空列表。
- en: If we are certain that the query will return exactly one entity, then the `getSingleResult()`
    method may be alternatively called on `Query`, this method returns an `Object`
    that must be cast to the appropriate entity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定查询将返回恰好一个实体，那么可以在`Query`上调用`getSingleResult()`方法，这个方法返回一个`Object`，必须将其转换为适当的实体。
- en: The preceding example uses the `LIKE` operator to find entities whose name starts
    with the word “New”. This is accomplished by substituting the query’s named parameter
    with the value `New%`. The percent sign at the end of the parameter value means
    that any number of characters after the word “New” will match the expression.
    The percent sign can be used anywhere in the parameter value, for example, a value
    of `%Dakota` would match any entities whose names end in “Dakota”, while a value
    of `A%a` would match any states whose names start with a capital “A” and end with
    a lowercase “a”. There can be more than one percent sign in a parameter value.
    The underscore sign (`_`) can be used to match a single character, all the rules
    for the percent sign apply to the underscore as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了`LIKE`运算符来查找名称以“New”开头的实体。这是通过将查询的命名参数替换为值`New%`来实现的。参数值末尾的百分号表示“New”词之后的任意数量的字符都将与表达式匹配。百分号可以在参数值中的任何位置使用，例如，值为`%Dakota`将匹配任何以“Dakota”结尾的实体，而值为`A%a`将匹配任何以大写“A”开头并以小写“a”结尾的州。参数值中可以有多个百分号。下划线符号（`_`）可以用来匹配单个字符，所有关于百分号的规则也适用于下划线。
- en: 'In addition to the `LIKE` operator, there are other operators that can be used
    to retrieve entities from the database:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`LIKE`运算符之外，还有其他可以用来从数据库中检索实体的运算符：
- en: The `=` operator will retrieve entities whose field on the left of the operator
    exactly match the value to the right of the operator
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`运算符将检索运算符左侧的字段与运算符右侧的值完全匹配的实体'
- en: The `>` operator will retrieve entities whose field on the left of the operator
    is greater than the value to the right of the operator
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`运算符将检索运算符左侧的字段大于运算符右侧的值的实体'
- en: The `<` operator will retrieve entities whose field on the left of the operator
    is less than the value to the right of the operator
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`运算符将检索运算符左侧的字段小于运算符右侧的值的实体'
- en: The `>=` operator will retrieve entities whose field on the left of the operator
    is greater than or equal to the value to the right of the operator
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=`运算符将检索运算符左侧的字段大于或等于运算符右侧的值的实体'
- en: The `<=` operator will retrieve entities whose field on the left of the operator
    is less than or equal to the value to the right of the operator
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=`运算符将检索运算符左侧的字段小于或等于运算符右侧的值的实体'
- en: All of the preceding operators work the same way as the equivalent operators
    in SQL. Just like in SQL, these operators can be combined with the “AND” and “OR”
    operators. Conditions combined with the “AND” operator match if both conditions
    are true, while conditions combined with the “OR” operator match if at least one
    of the conditions is true.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述运算符与SQL中等效运算符的工作方式相同。就像在SQL中一样，这些运算符可以与“AND”和“OR”运算符结合使用。与“AND”运算符结合的条件如果两个条件都为真则匹配，而与“OR”运算符结合的条件如果至少有一个条件为真则匹配。
- en: If we intend to use a query many times, it can be stored in a `@NamedQuery`
    annotation. This annotation has two elements, a `name` element used to set the
    name of the query; and a `query` element defining the query itself. To execute
    a named query, the `createNamedQuery()` method must be invoked in an instance
    of `EntityManager`. This method takes a `String` containing the query name as
    its sole parameter, and returns an instance of `jakarta.persistence.Query`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算多次使用查询，它可以通过`@NamedQuery`注解来存储。这个注解有两个元素，一个`name`元素用于设置查询的名称；另一个`query`元素定义查询本身。要执行命名查询，必须在`EntityManager`的实例上调用`createNamedQuery()`方法。此方法接受一个包含查询名称的`String`作为其唯一参数，并返回一个`jakarta.persistence.Query`实例。
- en: In addition to retrieving entities, JPQL can be used to modify or delete entities.
    However, entity modification and deletion can be done programmatically via the
    `EntityManager` interface, doing so results in code that tends to be more readable
    than when using JPQL. Because of this, we will not cover entity modification and
    deletion via JPQL. Readers interested in writing JPQL queries to modify and delete
    entities, as well as readers wishing to know more about JPQL are encouraged to
    review the Jakarta Persistence 3.1 specification. This specification can be found
    at [https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检索实体之外，JPQL还可以用来修改或删除实体。然而，可以通过`EntityManager`接口以编程方式执行实体修改和删除，这样做产生的代码通常比使用JPQL时更易于阅读。因此，我们将不会介绍通过JPQL进行实体修改和删除的内容。对编写JPQL查询以修改和删除实体感兴趣的读者，以及对JPQL有更多了解愿望的读者，应查阅Jakarta
    Persistence 3.1规范。该规范可在[https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1)找到。
- en: In addition to JPQL, Jakarta Persistence provides an API we can use to create
    queries, named, appropriately enough, the Criteria API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JPQL之外，Jakarta Persistence提供了一个我们可以用来创建查询的API，恰当地命名为Criteria API。
- en: Criteria API
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Criteria API
- en: The Jakarta Persistence **Criteria API** is meant as a complement to JPQL. The
    Criteria API allows us to write Jakarta Persistence queries programmatically,
    without having to rely on JPQL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence的**Criteria API**旨在作为JPQL的补充。Criteria API允许我们以编程方式编写Jakarta
    Persistence查询，而无需依赖于JPQL。
- en: The Criteria API offers a few advantages over JPQL – for instance, JPQL queries
    are stored as Strings, and the compiler has no way of validating JPQL syntax.
    Additionally, JPQL is not type safe; we could write a JPQL query in which our
    `where` clause could have a string value for a numeric property, and our code
    would compile and deploy just fine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Criteria API相对于JPQL提供了一些优势——例如，JPQL查询被存储为字符串，编译器无法验证JPQL语法。此外，JPQL不是类型安全的；我们可能编写一个JPQL查询，其中`where`子句可能有一个字符串值用于数值属性，而我们的代码可以编译并顺利部署。
- en: 'The following code example illustrates how to use the Criteria API in our Jakarta
    EE applications:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何在我们的Jakarta EE应用程序中使用Criteria API：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding example is equivalent to the JPQL example we saw earlier in this
    chapter. This example, however, takes advantage of the Criteria API instead of
    relying on JPQL.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例与我们在本章前面看到的JPQL示例等效。然而，这个示例利用了Criteria API而不是依赖于JPQL。
- en: When writing code using the Criteria API, the first thing we need to do is to
    obtain an instance of a class implementing the `jakarta.persistence.criteria.CriteriaBuilder`
    interface. As we can see in the preceding example, we need to obtain said instance
    by invoking the `getCriteriaBuilder()` method on our `EntityManager`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Criteria API编写代码时，我们首先需要做的是获取一个实现`jakarta.persistence.criteria.CriteriaBuilder`接口的类的实例。正如我们可以在前面的示例中看到的那样，我们需要通过在`EntityManager`上调用`getCriteriaBuilder()`方法来获取这个实例。
- en: From our `CriteriaBuilder` implementation, we need to obtain an instance of
    a class implementing the `jakarta.persistence.criteria.CriteriaQuery` interface.
    We do this by invoking the `createQuery()` method in our `CriteriaBuilder` implementation.
    Notice that `CriteriaQuery` is generically typed. The generic type argument dictates
    the type of result that our `CriteriaQuery` implementation will return upon execution.
    By taking advantage of generics in this way, the Criteria API allows us to write
    type-safe code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`CriteriaBuilder`实现中，我们需要获取一个实现`jakarta.persistence.criteria.CriteriaQuery`接口的类的实例。我们通过在`CriteriaBuilder`实现中调用`createQuery()`方法来完成这个操作。请注意，`CriteriaQuery`是泛型类型的。泛型类型参数决定了我们的`CriteriaQuery`实现执行后将返回的结果类型。通过这种方式利用泛型，Criteria
    API允许我们编写类型安全的代码。
- en: Once we have obtained a `CriteriaQuery` implementation, from it we can obtain
    an instance of a class implementing the `jakarta.persistence.criteria.Root` interface.
    The Root implementation dictates what Jakarta Persistence entity we will be querying
    from. It is analogous to the `FROM` query in JPQL (and SQL).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了`CriteriaQuery`实现，我们可以从中获取一个实现`jakarta.persistence.criteria.Root`接口的类的实例。Root实现决定了我们将从哪个Jakarta
    Persistence实体进行查询。它与JPQL（和SQL）中的`FROM`查询类似。
- en: The next two lines in our example take advantage of another feature of the Jakarta
    Persistence specification, the `jakarta.persistence.metamodel.Metamodel` interface
    by invoking the `getMetamodel()` method on our `EntityManager`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中的下一行和下一行，我们利用了 Jakarta Persistence 规范的另一个特性，即通过在我们的 `EntityManager` 上调用
    `getMetamodel()` 方法来使用 `jakarta.persistence.metamodel.Metamodel` 接口。
- en: From our `Metamodel` implementation, we can obtain a generically typed instance
    of the `jakarta.persistence.metamodel.EntityType` interface. The generic type
    argument indicates the Jakarta Persistence entity our `EntityType` implementation
    corresponds to. `EntityType` allows us to browse the persistent attributes of
    our Jakarta Persistence entities at runtime. Which is exactly what we do in the
    next line in our example. In our case, we are getting an instance of `SingularAttribute`,
    which maps to a simple, singular attribute in our Jakarta Persistence entity.
    `EntityType` has methods to obtain attributes that map to collections, sets, lists,
    and maps. Obtaining these types of attributes is very similar to obtaining a `SingularAttribute`,
    therefore we won’t be covering those directly. Please refer to the Jakarta EE
    API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    for more information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `Metamodel` 实现中，我们可以获得一个泛型类型的 `jakarta.persistence.metamodel.EntityType`
    接口实例。泛型类型参数表示我们的 `EntityType` 实现对应的 Jakarta Persistence 实体。`EntityType` 允许我们在运行时浏览
    Jakarta Persistence 实体的持久属性。这正是我们在示例中的下一行所做的事情。在我们的情况下，我们正在获取一个 `SingularAttribute`
    的实例，它映射到我们的 Jakarta Persistence 实体中的一个简单、单一属性。`EntityType` 有方法可以获取映射到集合、集合、列表和映射的属性。获取这些类型的属性与获取
    `SingularAttribute` 非常相似，因此我们不会直接介绍这些。有关更多信息，请参阅 [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    上的 Jakarta EE API 文档。
- en: As we can see in our example, `SingularAttribute` contains two generic type
    arguments. The first argument dictates the Jakarta Persistence entity we are working
    with, and the second one indicates the type of the attribute. We obtain our `SingularAttribute`
    by invoking the `getDeclaredSingularAttribute()` method on our `EntityType` implementation,
    and passing the attribute name (as declared in our Jakarta Persistence entity)
    as a String.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们示例中所示，`SingularAttribute` 包含两个泛型类型参数。第一个参数指定了我们正在处理的 Jakarta Persistence
    实体，第二个参数表示属性的类型。我们通过在我们的 `EntityType` 实现上调用 `getDeclaredSingularAttribute()` 方法并传递属性名称（如在我们
    Jakarta Persistence 实体中声明的那样）作为字符串来获取我们的 `SingularAttribute`。
- en: Once we have obtained our `SingularAttribute` implementation, we need to obtain
    an import `jakarta.persistence.criteria.Path` implementation by invoking the `get()`
    method in our `Root` instance, and passing our `SingularAttribute` as a parameter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了我们的 `SingularAttribute` 实现，我们需要通过在我们的 `Root` 实例中调用 `get()` 方法来获取一个导入的
    `jakarta.persistence.criteria.Path` 实现，并将我们的 `SingularAttribute` 作为参数传递。
- en: In our example, we will get a list of all the “new” states in the United States
    (that is, all states whose names start with “New”). This, of course, is a job
    for a “like” condition. We can do this with the Criteria API by invoking the `like()`
    method on our `CriteriaBuilder` implementation. The `like()` method takes our
    `Path` implementation as its first parameter, and the value to search for as its
    second parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将获取美国所有“新”州（即所有以“New”开头的州）的列表。当然，这是一个“like”条件的任务。我们可以通过在 `CriteriaBuilder`
    实现上调用 `like()` 方法使用 Criteria API 来完成这项工作。`like()` 方法将我们的 `Path` 实现作为其第一个参数，将搜索值作为其第二个参数。
- en: '`CriteriaBuilder` has a number of methods that are analogous to SQL and JPQL
    clauses such as `equals(),` `greaterThan()`, `lessThan()`, `and()`, `or()`, and
    so on and so forth (for the complete list, refer to the online Jakarta EE documentation).
    These methods can be combined to create complex queries via the Criteria API.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CriteriaBuilder` 有许多类似于 SQL 和 JPQL 子句的方法，如 `equals()`, `greaterThan()`, `lessThan()`,
    `and()`, `or()` 等（完整列表请参阅在线 Jakarta EE 文档）。这些方法可以通过 Criteria API 组合起来创建复杂的查询。'
- en: The `like()` method in `CriteriaBuilder` returns an implementation of the `jakarta.persistence.criteria.Predicate`
    interface, which we need to pass to the `where()` method in our `CriteriaQuery`
    implementation. This method returns a new instance of `CriteriaBuilder`, which
    we assign to our `criteriaBuilder` variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`CriteriaBuilder` 中的 `like()` 方法返回一个 `jakarta.persistence.criteria.Predicate`
    接口的实现，我们需要将其传递给我们的 `CriteriaQuery` 实现中的 `where()` 方法。此方法返回一个新的 `CriteriaBuilder`
    实例，我们将其分配给我们的 `criteriaBuilder` 变量。'
- en: At this point, we are ready to build our query. When working with the Criteria
    API, we deal with the `jakarta.persistence.TypedQuery` interface, which can be
    thought of as a type-safe version of the `Query` interface we use with JPQL. We
    obtain an instance of `TypedQuery` by invoking the `createQuery()` method in `EntityManager`,
    and passing our `CriteriaQuery` implementation as a parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们已准备好构建我们的查询。当使用Criteria API时，我们处理的是`jakarta.persistence.TypedQuery`接口，这可以被认为是与JPQL一起使用的`Query`接口的一个类型安全的版本。我们通过在`EntityManager`中调用`createQuery()`方法并传递我们的`CriteriaQuery`实现作为参数来获取一个`TypedQuery`实例。
- en: To obtain our query results as a list, we simply invoke `getResultList()` on
    our `TypedQuery` implementation. It is worth reiterating that the Criteria API
    is type safe, therefore attempting to assign the results of `getResultList()`
    to a List of the wrong type would result in a compilation error.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的查询结果作为列表获取，我们只需在`TypedQuery`实现上调用`getResultList()`。值得注意的是，Criteria API是类型安全的，因此尝试将`getResultList()`的结果分配给错误类型的List会导致编译错误。
- en: Let’s look into how we can update data with the Criteria API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Criteria API来更新数据。
- en: Updating data with the Criteria API
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Criteria API更新数据
- en: 'We can update database data using the Criteria API using the `CriteriaUpdate`
    interface. The following example illustrates how to do so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`CriteriaUpdate`接口使用Criteria API来更新数据库数据。以下示例展示了如何做到这一点：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What this example is doing is finding all of the database rows with entries
    of a city called “New Yorc” (a typo), and replacing the value with the correct
    spelling of “New York”.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子所做的是找到所有包含名为“New Yorc”（一个拼写错误）的城市的数据库行，并将其值替换为正确的拼写“New York”。
- en: Just like in the previous example, we obtain an instance of a class implementing
    the `CriteriaBuilder` interface by invoking the `getCriteriaBuilder()` method
    on our `EntityManager` instance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个例子一样，我们通过在`EntityManager`实例上调用`getCriteriaBuilder()`方法来获取一个实现`CriteriaBuilder`接口的类的实例。
- en: We then obtain an instance of a class implementing `CriteriaUpdate` by invoking
    `createCriteriaUpdate()` on our `CriteriaBuilder` instance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过在`CriteriaBuilder`实例上调用`createCriteriaUpdate()`来获取一个实现`CriteriaUpdate`的类的实例。
- en: The next step is to obtain an instance of a class implementing `Root` by invoking
    the `from()` method on our `CriteriaUpdate` instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取一个实现`Root`的类的实例，这是通过在`CriteriaUpdate`实例上调用`from()`方法来完成的。
- en: We then invoke the `set()` method on `CriteriaUpdate` to specify the new values
    our rows will have after they have been updated. The first parameter of the `set()`
    method must be a `String` matching the property name in the Entity class, and
    the second parameter must be the new value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`CriteriaUpdate`上调用`set()`方法来指定更新后我们的行将具有的新值。`set()`方法的第一参数必须是一个与实体类中的属性名称匹配的`String`，第二个参数必须是新值。
- en: At this point, we build the where clause by invoking the `where()` method on
    `CriteriaUpdate`, and passing the `Predicate` returned by the `equal()` method
    invoked in `CriteriaBuilder`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们通过在`CriteriaUpdate`上调用`where()`方法并传递由`CriteriaBuilder`中调用的`equal()`方法返回的`Predicate`来构建`where`子句。
- en: Then we get a `Query` implementation by invoking `createQuery()` on `EntityManager`,
    and passing our `CriteriaUpdate` instance as a parameter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过在`EntityManager`上调用`createQuery()`并传递我们的`CriteriaUpdate`实例作为参数，来获取一个`Query`实现。
- en: Finally, we execute our query as usual by invoking `executeUpdate()` on our
    `Query` implementation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在`Query`实现上调用`executeUpdate()`来像往常一样执行我们的查询。
- en: Deleting data with the Criteria API
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Criteria API删除数据
- en: 'We can delete database data with the Jakarta Persistence Criteria API. This
    can be done with the `CriteriaDelete` interface. The following code snippet illustrates
    its usage:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Jakarta Persistence Criteria API来删除数据库数据。这可以通过`CriteriaDelete`接口来完成。以下代码片段展示了其用法：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To use `CriteriaDelete`, we first obtain an instance of `CriteriaBuilder` as
    usual, then invoke the `createCriteriaDelete()` method on our `CriteriaBuilder`
    instance to obtain an implementation of `CriteriaDelete`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`CriteriaDelete`，我们首先像往常一样获取一个`CriteriaBuilder`实例，然后在我们的`CriteriaBuilder`实例上调用`createCriteriaDelete()`方法来获取一个`CriteriaDelete`实现。
- en: Once we have an instance of `CriteriaDelete`, we build the `where` clause as
    it is usually done with the Criteria API.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`CriteriaDelete`的一个实例，我们就像通常使用Criteria API那样构建`where`子句。
- en: Once we have built our `where` clause, we obtain an implementation of the `Query`
    interface and invoke `executeUpdate()` on it as usual.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了`where`子句，我们就获得了一个`Query`接口的实现，并像往常一样在其上调用`executeUpdate()`。
- en: Now that we’ve seen how to insert and retrieve database data, we’ll turn our
    attention to data validation via Bean Validation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何插入和检索数据库数据，我们将转向通过Bean Validation进行数据验证。
- en: Bean Validation support
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean Validation支持
- en: Bean Validation is a Jakarta EE specification consisting of a number of annotations
    used to simplify data validation. Jakarta Persistence Bean Validation support
    allows us to annotate our entities with Bean Validation annotations. These annotations
    allow us to easily validate user input and perform data sanitation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation是Jakarta EE规范，由一系列用于简化数据验证的注解组成。Jakarta Persistence Bean Validation支持允许我们使用Bean
    Validation注解来注解我们的实体。这些注解使我们能够轻松验证用户输入并执行数据清理。
- en: Taking advantage of Bean Validation is very simple. All we need to do is annotate
    our Jakarta Persistence Entity fields or getter methods with any of the validation
    annotations defined in the `jakarta.validation.constraints` package. Once our
    fields are annotated as appropriate, `EntityManager` will prevent non-validating
    data from being persisted.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Bean Validation非常简单。我们只需要用`jakarta.validation.constraints`包中定义的任何验证注解来注解我们的Jakarta
    Persistence实体字段或getter方法。一旦我们的字段被适当地注解，`EntityManager`将阻止非验证数据被持久化。
- en: 'The following code example is a modified version of the `Customer` Jakarta
    Persistence entity we saw earlier in this chapter. It has been modified to take
    advantage of Bean Validation in some of its fields:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例是本章前面看到的`Customer` Jakarta Persistence实体的修改版本。它已被修改以利用其某些字段中的Bean Validation：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we used the `@NotNull` annotation to prevent the `firstName`
    and `lastName` of our entity from being persisted with `null` values. We also
    used the `@Size` annotation to restrict the minimum and maximum length of these
    fields.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`@NotNull`注解来防止我们的实体的`firstName`和`lastName`字段以`null`值被持久化。我们还使用了`@Size`注解来限制这些字段的最低和最高长度。
- en: That is all we need to do to take advantage of bean validation in Jakarta Persistence.
    If our code attempts to persist or update an instance of our entity that does
    not pass the declared validation, an exception of type `jakarta.validation.ConstraintViolationException`
    will be thrown, and the entity will not be persisted.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们利用Jakarta Persistence中的bean验证所需要做的全部。如果我们的代码尝试持久化或更新一个未通过声明的验证的实体实例，将抛出一个类型为`jakarta.validation.ConstraintViolationException`的异常，并且实体将不会被持久化。
- en: As we can see Bean Validation pretty much automates data validation, freeing
    us from having to manually write validation code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Bean Validation几乎自动化了数据验证，使我们免于手动编写验证代码。
- en: In addition to the two annotations discussed in the previous example, the `jakarta.validation.constraints`
    package contains several additional annotations we can use to automate validation
    on our Jakarta Persistence entities. Please refer to the online Jakarta EE 10
    API for the complete list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面示例中讨论的两个注解之外，`jakarta.validation.constraints`包还包含几个额外的注解，我们可以使用它们来自动化Jakarta
    Persistence实体的验证。请参阅在线Jakarta EE 10 API以获取完整列表。
- en: Final notes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的注意事项
- en: In the examples for this chapter, we demonstrated database access directly from
    CDI named beans serving as controllers. We did this to get the point across without
    bogging ourselves down with details; however, in general, this is not a good practice.
    Database access code should be encapsulated in **Data Access** **Objects** (**DAOs**).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们展示了从作为控制器的CDI命名豆直接访问数据库。我们这样做是为了清晰地传达观点，而不被细节所困扰；然而，在一般情况下，这并不是一个好的做法。数据库访问代码应该封装在**数据访问对象**（**DAOs**）中。
- en: DAO design pattern
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: DAO设计模式
- en: For more information on the DAO design pattern, see [http://www.oracle.com/technetwork/java/dao-138818.html](http://www.oracle.com/technetwork/java/dao-138818.html).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DAO设计模式的更多信息，请参阅[http://www.oracle.com/technetwork/java/dao-138818.html](http://www.oracle.com/technetwork/java/dao-138818.html)。
- en: Named beans typically assume the role of controllers and/or models when using
    the **Model-View-Controller** (**MVC**) design pattern, a practice so common that
    it has become a de-facto standard for Jakarta EE applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 命名豆类通常在采用**模型-视图-控制器**（**MVC**）设计模式时扮演控制器和/或模型的角色，这种做法非常普遍，以至于已经成为Jakarta EE应用程序的事实标准。
- en: MVC design pattern
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: For more information about the MVC design pattern, see [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MVC设计模式的更多信息，请参阅[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)。
- en: Additionally, we chose not to show any user interface code in our examples as
    it was irrelevant to the topic at hand. However, the code downloads for this chapter
    include Jakarta Faces pages that invoke the named beans in this chapter and display
    a confirmation page once the named-bean invocation finishes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们选择不在示例中展示任何用户界面代码，因为这与当前主题无关。然而，本章的代码下载包括调用本章中命名的 Bean 的 Jakarta Faces
    页面，并在命名 Bean 调用完成后显示确认页面。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered how to access data in a database via Jakarta Persistence,
    the standard object-relational mapping API of Jakarta EE.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何通过 Jakarta Persistence 访问数据库中的数据，Jakarta Persistence 是 Jakarta EE 的标准对象关系映射
    API。
- en: 'In this chapter, we covered the following topics:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下主题：
- en: How to mark a Java class as a Jakarta Persistence entity by decorating it with
    the `@Entity` annotation, and how to map it to a database table via the `@Table`
    annotation. We also covered how to map entity fields to database columns via the
    `@``Column` annotation.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用 `@Entity` 注解将 Java 类标记为 Jakarta Persistence 实体，以及如何通过 `@Table` 注解将其映射到数据库表。我们还介绍了如何通过
    `@Column` 注解将实体字段映射到数据库列。
- en: Using the `jakarta.persistence.EntityManager` interface to find, persist, and
    update Jakarta Persistence entities.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `jakarta.persistence.EntityManager` 接口查找、持久化和更新 Jakarta Persistence 实体。
- en: How to define unidirectional and bidirectional one-to-one, one-to-many, and
    many-to-many relationships between Jakarta Persistence entities.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Jakarta Persistence 实体之间定义单向和双向的一对一、一对多和多对多关系。
- en: How to use composite primary keys by developing custom primary key classes.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过开发自定义主键类来使用复合主键。
- en: How to retrieve entities from a database by using the **Jakarta Persistence
    Query Language** (**JPQL**) and the Criteria API.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **Jakarta Persistence 查询语言**（**JPQL**）和 Criteria API 从数据库中检索实体。
- en: Bean Validation, which allows us to easily validate input by simply annotating
    our Jakarta Persistence entity fields.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean Validation，它允许我们通过简单地注解 Jakarta Persistence 实体字段来轻松验证输入。
- en: Jakarta Persistence abstracts out database access code and allows us to code
    against Java objects as opposed to database tables. It also works with every popular
    RDBMS system, making our code easily portable across different relational database
    management systems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence 抽象了数据库访问代码，并允许我们针对 Java 对象进行编码，而不是数据库表。它还与每个流行的关系数据库管理系统（RDBMS）系统兼容，使得我们的代码可以轻松地在不同的关系数据库管理系统之间移植。
