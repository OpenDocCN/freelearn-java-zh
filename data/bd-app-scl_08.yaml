- en: Chapter 8. Developing a Chat with Akka
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：使用 Akka 开发聊天
- en: In the previous chapters, we persisted data into MySQL using Slick and wrote
    PDF reports using Jasper reports. Now we will add more features in our app using
    Akka.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Slick 将数据持久化到 MySQL，并使用 Jasper reports 编写 PDF 报告。现在，我们将使用 Akka
    在我们的应用程序中添加更多功能。
- en: In this chapter, you will learn how to create Actors using the Akka framework.
    We will use Actors in combination with the Play framework and WebSockets in order
    to have a chat capability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 Akka 框架创建 Actors。我们将结合使用 Play 框架和 WebSockets 来实现聊天功能。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Actor model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Actor 模型
- en: Actor systems, Actor routing, and dispatchers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor 系统、Actor 路由和调度器
- en: Mailboxes, Actor configuration, and persistence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱、Actor 配置和持久化
- en: Creating our Chat Application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的聊天应用程序
- en: Testing our Actors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的 Actors
- en: Adding the new UI introduction to Akka
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Akka 的新 UI 介绍
- en: 'Akka ([http://akka.io/](http://akka.io/)) is a framework to build concurrent,
    distributed, and resilient message-driven applications in Scala, Java, and .NET.
    Building applications with Akka has several advantages, which are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Akka ([http://akka.io/](http://akka.io/)) 是一个用于在 Scala、Java 和 .NET 中构建并发、分布式和弹性消息驱动应用程序的框架。使用
    Akka 构建应用程序具有以下优点：
- en: '**High performance**: Akka delivers up to 50 million messages per second on
    a commodity hardware having ~2.5 million Actors per GB of RAM.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：Akka 在具有 ~2.5 百万 Actors 每GB RAM 的通用硬件上，每秒可以处理高达 5000 万条消息。'
- en: '**Resilient by design**: Akka systems have self-healing properties for local
    and remote Actors.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计上的弹性**：Akka 系统具有本地和远程 Actors 的自我修复特性。'
- en: '**Distributed and elastic**: Akka has all the mechanisms to scale your application,
    such as cluster, load balancing, partitioning, and sharding. Akka lets you grow
    or shrink your Actors on demand.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式和弹性**：Akka 拥有所有扩展应用程序的机制，例如集群、负载均衡、分区和分片。Akka 允许您根据需求扩展或缩小 Actors。'
- en: The Akka framework provides good abstractions for concurrent, asynchronous,
    and distributed programming, such as Actors, Streams, and Futures. There are plenty
    of great success cases in production, such as BBC, Amazon, eBay, Cisco, The Guardian,
    Blizzard, Gilt, HP, HSBC, Netflix, and so many others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 框架为并发、异步和分布式编程提供了良好的抽象，例如 Actors、Streams 和 Futures。在生产环境中有许多成功的案例，例如 BBC、Amazon、eBay、Cisco、The
    Guardian、Blizzard、Gilt、HP、HSBC、Netflix 以及许多其他公司。
- en: Akka is a truly reactive framework because everything, in the sense of sending
    and receiving messages to Actors, is lockless, non-blocking IO, and asynchronous.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 是一个真正的反应式框架，因为从发送和接收消息到 Actors 的所有操作都是无锁的、非阻塞的 IO 和异步的。
- en: Introduction to the Actor model
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor 模型的介绍
- en: The key for concurrency programming is to avoid a shared mutable state. A shared
    state often requires locks and synchronization, which makes your code less concurrent
    and more complex. Actors share nothing; they have internal state, but they don't
    share their internal state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的关键是避免共享可变状态。共享状态通常需要锁和同步，这使得您的代码并发性降低，复杂性增加。Actors 不共享任何东西；它们有内部状态，但它们不共享它们的内部状态。
- en: Actors have location transparency; they can run in a local or remote system
    and a cluster. It's also possible to mix local and remote actors - this is great
    for scalability and fits perfectly into a cloud environment. Actors can run anywhere,
    from your local box, the cloud, bare-metal datacenter, and Linux containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Actors 具有位置透明性；它们可以在本地或远程系统以及集群中运行。混合本地和远程 Actors 也是可能的——这对于可扩展性来说非常好，并且非常适合云环境。Actors
    可以在任何地方运行，从您的本地设备、云、裸金属数据中心和 Linux 容器。
- en: What is an Actor?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Actor？
- en: Actors can be alternatives to threads, callback listeners, singleton services,
    **Enterprise Java Beans **(**EJB**), routers, load balancer or pool, and a **finite-state
    machine** (**FSM**). The Actor model concept is not new at all; it was created
    by Carl Hewitt in 1973\. The Actor model is heavily used in the telecom industry
    in rock-solid technologies such as Erlang. Erlang and the Actor model had immense
    success with companies such as Ericsson and Facebook.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Actors 可以作为线程、回调监听器、单例服务、**企业 JavaBeans (EJB**)、路由器、负载均衡器或池以及**有限状态机 (FSM**)的替代品。Actor
    模型概念并非全新；它是由 Carl Hewitt 在 1973 年创建的。Actor 模型在电信行业中得到了广泛的应用，例如在 Erlang 这样的坚固技术中。Erlang
    和 Actor 模型在 Ericsson 和 Facebook 等公司取得了巨大的成功。
- en: 'Actors have a simple way of working:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Actors 有一种简单的工作方式：
- en: 'Unit of code organization:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织单元：
- en: Processing
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理
- en: Storage
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Communication
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信
- en: They manage the internal states
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们管理内部状态
- en: They have a mailbox
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个邮箱
- en: They communicate with other actors using messages
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过消息与其他Actor进行通信
- en: They can change the behavior at runtime
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在运行时改变行为
- en: Message exchange and mailboxes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息交换和邮箱
- en: 'Actors talk with each other via messaging. There are two patterns: one is called
    ask and the other is called fire and forget. Both methods are asynchronous and
    non-blocking IO. When an Actor sends a message to another Actor, it does not send
    the message directly to the other Actor; it actually sends it to the Actor''s
    mailbox.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Actor通过消息相互交谈。有两种模式：一种称为ask，另一种称为fire and forget。两种方法都是异步和非阻塞IO。当一个Actor向另一个Actor发送消息时，它并不是直接发送给另一个Actor；实际上，它是发送到Actor的邮箱中。
- en: 'Messages are enqueued in the Actor mailbox in a time-ordered fashion. There
    are different mailboxes implementations in Akka. The default is **First In First
    Out** (**FIFO**) based. This is a good default; however, you might need a different
    algorithm, which is fine as you can change the mailbox if you need to. More details
    can be found in the official documentation ([http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala](http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala)).
    Actors live in an Actor system. You can have multiple Actor systems in a cluster:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 消息以时间顺序的方式入队到Actor邮箱中。Akka中有不同的邮箱实现。默认的是基于**先进先出**（**FIFO**）的。这是一个好的默认设置；然而，你可能需要一个不同的算法，这是可以的，因为如果你需要，你可以更改邮箱。更多详细信息可以在官方文档中找到（[http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala](http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala)）。Actor存在于Actor系统中。在一个集群中你可以有多个Actor系统：
- en: '![Message exchange and mailboxes](img/image00313.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![消息交换和邮箱](img/image00313.jpeg)'
- en: Akka encapsulates the actor state in mailbox and decouples it from the Actor
    behavior. The Actor behavior is the code you will have inside your Actor. You
    will need to see Actors and Akka as a protocol. So, basically, you will need to
    define how many Actors you will have and what each Actor will do in the sense
    of code, responsibility, and behavior. The Actor system has Actors and supervisors.
    Supervisors are one of the Akka mechanisms to deliver fault tolerance and resiliency.
    Supervisors take care of the Actor instances, and they can restart, kill, or create
    more Actors as needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Akka将actor状态封装在邮箱中，并将其与Actor行为解耦。Actor行为是你将在Actor内部拥有的代码。你需要将Actor和Akka视为一个协议。所以，基本上，你需要定义你将有多少个Actor，以及每个Actor在代码、责任和行为方面的作用。Actor系统有Actor和监督者。监督者是Akka机制之一，用于提供容错性和弹性。监督者负责Actor实例，并且可以根据需要重启、终止或创建更多的Actor。
- en: The Actor model is great for concurrency and scalability; however, like every
    single thing in computer science, there are tradeoffs and cons. For instance,
    Actors require a new mindset and a different way of thinking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Actor模型非常适合并发和可伸缩性；然而，就像计算机科学中的每一件事一样，都有权衡和缺点。例如，Actor需要新的思维方式和不同的思考方式。
- en: There is no silver bullet. Once you have your protocol, it might be hard to
    reuse your Actors outside your protocol. In general, Actors can be harder to compose,
    as compared to object-oriented classes or functions in Functional Programming,
    for instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有万能的解决方案。一旦你有了你的协议，可能很难在协议外部重用你的Actor。一般来说，与面向对象的类或函数式编程中的函数相比，Actor可能更难组合。
- en: Coding actors with Akka
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Akka编码Actor
- en: 'Let''s take a look at the following Actor code using the Akka framework and
    Scala:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下使用Akka框架和Scala编写的Actor代码：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run this Akka code on `sbt` in your console, you will see an output
    similar to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段Akka代码在你的控制台中的`sbt`上运行，你会看到类似以下的输出：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Coding actors with Akka](img/image00314.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用Akka编码Actor](img/image00314.jpeg)'
- en: Let's take a closer look at this Akka code we just wrote, in which we defined
    a Scala class called `HelloWorldActor`. In order for this class be an Actor, we
    will need to extend Actor. Actors are reactive by default, which means that they
    are waiting to receive messages to react to the messages. You will need to code
    your behavior in an event loop. In Akka, this is done by coding the `receive`
    function with a pattern matcher in Scala.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们刚刚编写的这段Akka代码，其中我们定义了一个名为`HelloWorldActor`的Scala类。为了使这个类成为Actor，我们需要扩展Actor。Actor默认是反应式的，这意味着它们正在等待接收消息以对消息做出反应。你需要在一个事件循环中编写你的行为。在Akka中，这是通过在Scala中用模式匹配器编写`receive`函数来完成的。
- en: The pattern matcher will define what the actor can do. You will need to code
    all the possible kinds of messages you want that actor to handle. As I mentioned
    earlier, you will need to have a protocol; so your protocol has a message called
    `HelloMessage`. It's a common practice in Akka to use Scala objects as messages.
    However, you can pass pretty much all types as messages. It's even possible to
    send case classes with parameters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配器将定义参与者可以做什么。你需要编写所有你希望该参与者处理的消息类型。正如我之前提到的，你需要有一个协议；所以你的协议有一个名为`HelloMessage`的消息。在Akka中，使用Scala对象作为消息是一种常见的做法。然而，你可以传递几乎所有类型作为消息。甚至可以发送带有参数的case类。
- en: Alright, we have our protocol, which is our Actors, and the messages they can
    exchange. Now we will need to create an Actor system and start our application.
    As you can see, we will use the `ActorSystem` object to create an Actor system.
    Actor systems need to have a name, which can be any string you like, as long as
    it contains any letter [a-z, A-Z, 0-9] and non-leading '-' or '_'.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有了我们的协议，即我们的参与者以及他们可以交换的消息。现在我们需要创建一个参与者系统并启动我们的应用程序。正如你所看到的，我们将使用`ActorSystem`对象来创建参与者系统。参与者系统需要有一个名称，可以是任何你喜欢的字符串，只要它包含任何字母[a-z,
    A-Z, 0-9]以及非开头的'-'或'_'。
- en: After creating the system, you can create Actors. The system has a function
    called `actorOf`, which can be used to create Actors. You will need to use a special
    object called `Props` and pass the `actor` class. Why do we need it this way?
    It's because Akka manages the Actor state. You should not try to manage the Actor
    instance by yourself. This is dangerous because you can break referential transparency
    and your code might not work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建系统之后，你可以创建参与者。系统有一个名为`actorOf`的函数，可以用来创建参与者。你需要使用一个特殊对象`Props`并传递`actor`类。为什么我们需要这样做呢？这是因为Akka管理参与者状态。你不应该尝试自己管理参与者实例。这是危险的，因为你可能会破坏引用透明性，你的代码可能不会工作。
- en: For this code, we are using the ask pattern. We will use this to send messages
    to the Actor, and we want to know what the Actor will return. Akka does everything
    in an async and non-blocking way , as mentioned previously. However, sometimes
    you want to get the answer now and then, unfortunately, you will need to block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码，我们使用的是ask模式。我们将使用它来向参与者发送消息，并想知道参与者将返回什么。正如之前提到的，Akka以异步和非阻塞的方式进行所有操作。然而，有时你想要立即得到答案，不幸的是，你将需要阻塞。
- en: In order to get the answer now, we will need to define a timeout and use the
    `Await` object. When you send a message to an Actor using `?` (the ask pattern),
    Akka will return a Future for you. Then, you can pass the Future with a timeout
    to `Await`, and if the answer comes back before the timeout, you will have the
    response from the Actor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了立即得到答案，我们需要定义一个超时并使用`Await`对象。当你使用`?`（ask模式）向参与者发送消息时，Akka会为你返回一个Future。然后，你可以将带有超时的Future传递给`Await`，如果答案在超时之前返回，你将得到参与者的响应。
- en: Again, we are blocking here because we want to get the answer now, and we are
    outside the Actor system. Keep in mind that when an Actor talks with another Actor
    inside the Actor system, it should not block ever. So be careful with the usage
    of `Await`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们在这里阻塞是因为我们想要立即得到答案，而且我们处于参与者系统之外。记住，当一个参与者在与参与者系统内的另一个参与者交谈时，它永远不应该阻塞。所以请小心使用`Await`。
- en: Another important thing in this code is that the `sender()` method inside of
    the Actor receives a function. This means that you want to get the reference of
    the Actor who sends the message to you. As we are performing `sender() !` method,
    we are sending an answer back to the caller. The `sender()` function is an Akka
    abstraction to deal with response messages to other Actors or function callers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，另一个重要的事情是参与者内部的`sender()`方法接收一个函数。这意味着你想要获取发送消息给你的参与者的引用。由于我们正在执行`sender()
    !`方法，我们正在将答案发送回调用者。`sender()`函数是Akka对处理其他参与者或函数调用者的响应消息的抽象。
- en: We also have another case, with `Any`, which means all other messages will be
    handled by that case code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个使用`Any`的情况，这意味着所有其他消息都将由该代码块处理。
- en: The ask pattern is one way to send messages to Actors. There is another pattern
    called `FireAndForget "!"`. Fire and forget will send a message and will not block
    and wait for the answer. So, there is no answer - in other words, Unit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ask模式是向参与者发送消息的一种方式。还有一种叫做`FireAndForget "!"`的模式。fire and forget将发送一个消息，不会阻塞并等待答案。所以，没有答案——换句话说，Unit。
- en: 'Let''s look at some code with the `FireAndForget` message exchange:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`FireAndForget`消息交换的一些代码：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this code with `$ sbt run`, you will see an output as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$ sbt run`运行此代码，你将看到以下输出：
- en: '![Coding actors with Akka](img/image00315.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用Akka编码Actor](img/image00315.jpeg)'
- en: Here, we have a `PrinterActor` method, which accepts pretty much anything and
    prints on the console. Then, we will create an Actor system and just send a message
    to our Actor with the fire and forget pattern, a.k.a "!", and as you can see,
    we will receive Unit; finally, we will await the shutdown of the Actor system
    using the `terminate` option.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`PrinterActor`方法，它几乎可以接受任何东西并在控制台上打印。然后，我们将创建一个Actor系统，并使用“fire and
    forget”模式（即“!”）向我们的Actor发送消息，正如你所看到的，我们将收到Unit；最后，我们将使用`terminate`选项等待Actor系统的关闭。
- en: Actor routing
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor路由
- en: Akka provides routing functionality. This is useful from a business point of
    view because you can route to the right Actor in the sense of business logic and
    behavior. For architecture, we can use this as load balancing and route messages
    to more Actors to achieve fault tolerance and scalability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了路由功能。从业务角度来看，这很有用，因为你可以根据业务逻辑和行为将消息路由到正确的Actor。对于架构，我们可以用它作为负载均衡，并将消息路由到更多的Actor以实现容错和可伸缩性。
- en: 'Akka has several options for routing, which are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了几种路由选项，如下所示：
- en: '**RoundRobin**: This is a random logic to every different Actor on the pool.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RoundRobin**：这是一个随机逻辑，将消息发送到池中的每个不同的Actor。'
- en: '**SmallestMailbox**: This sends the message to the Actor with fewer messages.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SmallestMailbox**：这会将消息发送到消息较少的Actor。'
- en: '**Consistent Hashing**: This partitions the Actors per hash ID.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consistent Hashing**：这根据哈希ID对Actor进行分区。'
- en: '**ScatterGather**: This sends message to all actors, and the first to reply
    wins.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ScatterGather**：这会将消息发送到所有Actor，第一个回复的获胜。'
- en: '**TailChopping**: This sends to a route randomly, and if a reply doesn''t come
    back in a second, it chooses a new route and sends again, and so on.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TailChopping**：这会将消息随机发送到路由，如果一秒内没有收到回复，它会选择新的路由并再次发送，依此类推。'
- en: 'Let''s see the following code in practice:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码的实际应用：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run this code in sbt doing `$ sbt run`, you will get an output as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`sbt`运行此代码，即使用`$ sbt run`，你将得到以下输出：
- en: '![Actor routing](img/image00316.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Actor路由](img/image00316.jpeg)'
- en: So, here we have an `ActorUppercasePrinter` function that prints whatever it
    receives and calls the `toString` function, and then `toUpperCase`. Finally, it
    also prints the `self.path` Actor, which will be the address of the Actor. Actors
    are structured in a hierarchical structure, similar to a file system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有一个`ActorUppercasePrinter`函数，它会打印接收到的任何内容，并调用`toString`函数，然后`toUpperCase`。最后，它还会打印`self.path`
    Actor，这将Actor的地址。Actor以类似于文件系统的层次结构组织。
- en: There are multiple ways to use Akka - Akka supports code or configuration (`application.conf`
    file). Here, we are creating a round-robin pool actor that has five routes. We
    are passing the target Actor to the router that will be our printer Actor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Akka有多种方式 - Akka支持代码或配置（`application.conf`文件）。在这里，我们创建了一个具有五个路由的循环池Actor。我们将目标Actor传递给路由器，它将成为我们的打印Actor。
- en: As you can see, when we send messages using the fire and forget pattern, every
    message is delivered to a different Actor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们使用“fire and forget”模式发送消息时，每个消息都会被发送到不同的Actor。
- en: Persistence
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化
- en: Akka works on memory. However, it is possible to use persistence. Persistence
    is still kind of experimental in Akka. However, it is stable. For production,
    you can use advanced persistence plugins, such as Apache Cassandra. For the sake
    of development and education, we will use Google leveldb in our file system. Akka
    has multiple persistence options, such as views and persistent Actors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Akka在内存上工作。然而，使用持久化是可能的。在Akka中，持久化仍然处于某种实验阶段。但是，它是稳定的。对于生产环境，你可以使用高级持久化插件，例如Apache
    Cassandra。为了开发和教育的目的，我们将在文件系统中使用Google leveldb。Akka提供了多种持久化选项，例如视图和持久化Actor。
- en: 'Let''s take a look at a persistent actor using the Google leveldb and file
    system:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Google leveldb和文件系统的持久化Actor的例子：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the `$ sbt run` command will give you the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`$ sbt run`命令将给出以下输出：
- en: '![Persistence](img/image00317.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![持久化](img/image00317.jpeg)'
- en: If you run this code with `$ sbt run`, and stop and run again, you will see
    the data is being stored and recovered every time you stop and start again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$ sbt run`运行此代码，然后停止并再次运行，你将看到每次停止和启动时都会存储和恢复数据。
- en: As you can see, your Actor needs to extend `PersistentActor` in order to have
    persistence support. You will also need to provide a `persistenceID`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你的Actor需要扩展`PersistentActor`以获得持久化支持。你还需要提供一个`persistenceID`。
- en: Here, you will need to implement two receive functions. One is for commands
    (also known as messages), and the other one is for recovery. The command's receive
    loop will be activated when this Actor receives messages, while the recover one
    will be activated when the Actor boots up and will read the persistent data from
    the database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要实现两个接收函数。一个是命令（也称为消息），另一个是恢复。当这个Actor接收消息时，将激活命令的接收循环，而当Actor启动时，将激活恢复循环并从数据库中读取持久化数据。
- en: So, this Actor here has a counter to count each message it receives, and prints
    every message it gets on the console. That's it; as you can see, it is pretty
    simple. In order to use this functionality, you will also need to configure your
    `application.conf`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个Actor有一个计数器来计算它接收到的每个消息，并在控制台上打印出它接收到的每个消息。就是这样；正如你所看到的，它非常简单。为了使用这个功能，你还需要配置你的`application.conf`。
- en: 'Your `application.conf` file should look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`application.conf`文件应该看起来像这样：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, here we are defining a simple Akka system (local mode), and we are configuring
    the persistence for Google leveldb. As you can see, we will need to provide a
    path for persistence, and this path must exist on the OS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里定义了一个简单的Akka系统（本地模式），并配置了Google leveldb的持久化。正如你所看到的，我们需要提供一个持久化的路径，并且这个路径必须在操作系统上存在。
- en: As we are using an additional functionality, we will also need to change `build.sbt`
    in order to import all jars that we will need in the sense of Akka, persistence,
    and leveldb.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了额外的功能，我们还需要更改`build.sbt`以导入我们需要的所有jar文件，包括Akka、持久化和leveldb。
- en: 'Your `build.sbt` file should look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`build.sbt`文件应该看起来像这样：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it. That's all we need to persist the Actor's state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这就是我们需要持久化Actor状态的所有内容。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Akka has way more functionalities. For more, check out the default documentation
    at [http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365](http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Akka有更多的功能。更多内容，请查看默认文档[http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365](http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365)。
- en: Creating our chat application
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的聊天应用程序
- en: Now that we know Akka better, we will continue to develop our application. Akka
    has a great integration with the Play framework. We will use Actors with the Akka
    and Play framework right now. Let's build a simple chat feature for our app. We
    will change the code to add a new UI and, using the Akka testkit, we will test
    out actors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Akka有了更好的了解，我们将继续开发我们的应用程序。Akka与Play框架有很好的集成。我们现在将使用Akka和Play框架中的Actors。让我们为我们的应用程序构建一个简单的聊天功能。我们将更改代码以添加新的UI，并使用Akka测试套件测试Actors。
- en: The Play framework already includes Akka on the classpath for us, so we don't
    need to worry about it. However, we will need to add the Akka testkit dependency
    to the `build.sbt` file in order to have the classes in our classpath.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架已经为我们包含了Akka在类路径中，所以我们不需要担心它。然而，我们需要将Akka测试套件依赖项添加到`build.sbt`文件中，以便在我们的类路径中有这些类。
- en: 'Your `build.sbt` should look something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`build.sbt`应该看起来像这样：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay, now you can go to the console and type `$ activator`, `$ reload`, and
    then `$ compile`. This will force sbt to download the new dependency.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你可以去控制台输入`$ activator`，`$ reload`，然后`$ compile`。这将强制sbt下载新的依赖项。
- en: Now we will need to create a package called Actors. This package needs to be
    located at `ReactiveWebStore/app/`. We will start creating an `ActorHelper` utility
    object in order to have a generic function for the ask pattern that we saw earlier.
    It is an Actor helper generic ask pattern utility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个名为Actors的包。这个包需要位于`ReactiveWebStore/app/`目录下。我们将开始创建一个`ActorHelper`实用对象，以便拥有一个通用的ask模式函数，这是我们之前看到的。这是一个Actor辅助的通用ask模式实用工具。
- en: 'Your `ActorHelper.scala` file should look something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`ActorHelper.scala`文件应该看起来像这样：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `ActorHelper` has just one function: `get`. This function will get an answer
    from any Actor given in any message. However, as you can see, we have a timeout
    of five seconds. If the result does not come back in this time, an exception will
    be raised.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorHelper`只有一个函数：`get`。这个函数将从任何消息中给出的任何Actor获取答案。然而，正如你所看到的，我们有一个五秒的超时。如果结果在这段时间内没有返回，将会抛出一个异常。'
- en: In this code, we are also mapping the Actor result to a String calling the `toString`
    function in the result future. This is not a lot of code; however, there are lots
    of imports, and it makes the code cleaner and we can get answers from Actors with
    less code and fewer imports.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们还将 Actor 结果映射到 String，通过在结果 future 中调用 `toString` 函数。这不是很多代码；然而，有很多导入，这使得代码更简洁，我们可以用更少的代码和更少的导入从
    Actors 获取答案。
- en: The chat protocol
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天协议
- en: 'Now we will need to define our protocol. For this functionality, we will need
    three Actors. The Actors that we create will be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们的协议。为此功能，我们需要三个 Actor。我们创建的 Actor 将如下所示：
- en: '**ChatRoom**: This will have a reference for all users in the chat room'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChatRoom**：这将包含聊天室中所有用户的引用。'
- en: '**ChatUser**: This will have one instance per user (active browser)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChatUser**：这将每个用户（活动浏览器）有一个实例。'
- en: '**ChatBotAdmin**: This simple Bot Admin will provide stats about the chat room'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChatBotAdmin**：这个简单的 Bot Admin 将提供关于聊天室的状态。'
- en: '`ChatUserActor` will need to join `JoinChatRoom` object in order to start chatting.
    `ChatUserActor` will also need to send messages to `ChatMessage` class to the
    `ChatRoomActor` that will broadcast messages to all users. The `ChatBotAdmin`
    will get a report from  `GetStats` object from `ChatRoomActor`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatUserActor` 需要加入 `JoinChatRoom` 对象以开始聊天。`ChatUserActor` 还需要向 `ChatMessage`
    类发送消息给 `ChatRoomActor`，该类将向所有用户广播消息。`ChatBotAdmin` 将从 `ChatRoomActor` 的 `GetStats`
    对象中获得报告。'
- en: 'Let''s start coding this protocol. First, we will need to define the messages
    that will be exchanged between these Actors, as shown in the following piece of
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写这个协议。首先，我们需要定义这些 Actor 之间交换的消息，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see here, we have a `ChatMessage` class with a name and a text. This
    will be the message each user will send on the chat. Then, we will have a stats
    class, which has a set of users--this will be all the users logged into the chat
    application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个名为 `ChatMessage` 的类，其中包含一个名称和文本。这将是在聊天中每个用户发送的消息。然后，我们将有一个统计类，其中包含一组用户--这将是在聊天应用程序中登录的所有用户。
- en: Finally, we have some action messages, such as `JoinChatRoom`, `Tick`, and `GetStats`.
    So, `JoinChatRoom` will be sent by `ChatUserActor` to `ChatRoomActor` in order
    to join the chat. `Tick` will be a scheduled message that will happen from time
    to time in order to make `ChatBotAdmin` send stats about the chat room to all
    logged users. `GetStats` is the message that `ChatBotAdminActor` will send to
    `ChatRoomActor` in order to get information about who is in the room.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一些动作消息，例如 `JoinChatRoom`、`Tick` 和 `GetStats`。所以，`JoinChatRoom` 将由 `ChatUserActor`
    发送到 `ChatRoomActor` 以加入聊天。`Tick` 将是一个定期发生的预定消息，以便 `ChatBotAdmin` 向所有已登录用户发送关于聊天室的状态。`GetStats`
    是 `ChatBotAdminActor` 发送到 `ChatRoomActor` 的消息，以获取关于谁在房间中的信息。
- en: Let's code our three actors now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写我们的三个演员。
- en: 'The `ChatRoomActor.scala` file should look something like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatRoomActor.scala` 文件应该看起来像这样：'
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ChatRoomActor` has a var called `users`, which is a set of `ActorRef`. `ActorRef`
    is a generic reference to any actor. We have the receive function with three cases:
    `ChatMessage`, `JoinChatRoom`, and `GetStats`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatRoomActor` 有一个名为 `users` 的变量，它是一个 `ActorRef` 的集合。`ActorRef` 是对任何演员的泛型引用。我们有一个接收函数，包含三个情况：`ChatMessage`、`JoinChatRoom`
    和 `GetStats`。'
- en: A `JoinChatRoom` will be sent by the `ChatUserActor` method in order to join
    the room. As you can see, we are getting the `ActorRef` method from the sender
    Actor using the `sender()`function, and we are adding this reference to the set
    of users. In this way, the set of `ActorRef` represents the online logged-in users
    in the chat room right now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatUserActor` 方法将发送一个 `JoinChatRoom` 来加入房间。如您所见，我们通过 `sender()` 函数从发送者 Actor
    获取 `ActorRef` 方法，并将此引用添加到用户集合中。这样，`ActorRef` 集合就代表了当前聊天室中在线登录的用户。'
- en: The other case is with the `ChatMessage` method. Basically, we will broadcast
    the message to all users in the chat. We do this because we have the reference
    for all actors in users. Then, we will call the `foreach` function in order to
    iterate all users one by one, and then we will send the message using `FireAndForget
    "!"` to each user Actor represented by the operator underscore `_`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个情况是与 `ChatMessage` 方法相关。基本上，我们将消息广播给聊天中的所有用户。我们这样做是因为我们有所有演员的引用。然后，我们将调用
    `foreach` 函数逐个迭代所有用户，然后我们将使用操作符下划线 `_` 表示的每个用户 Actor 发送消息，使用 `FireAndForget "!"`。
- en: The `GetStats` case creates a string with all chat room stats. For now, the
    stats are just the number of online users, which is computed by calling the size
    function on the users object. We are also showing all the hash codes that identify
    all Actors logged in, just for fun.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetStats` 案例创建了一个包含所有聊天室统计信息的字符串。目前，统计信息只是在线用户的数量，这是通过在用户对象上调用 size 函数计算出来的。我们还展示了所有标识已登录
    Actor 的哈希码，只是为了好玩。'
- en: That's our `ChatRoomActor` implementation. As you can see, it is hard to talk
    about one Actor without describing the other, as the protocol will always be kind
    of coupled. You might also be wondering why we have a companion object for the
    `ChatRoomActor` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `ChatRoomActor` 实现。正如你所见，不描述另一个 Actor 就很难谈论一个 Actor，因为协议总是有点耦合。你可能也会想知道为什么我们为
    `ChatRoomActor` 方法有一个伴随对象。
- en: This object is to provide an easy way to create Actor instances. We are creating
    a single room for our design; we don't want to have multiple chat rooms, so that's
    why we will need to control the creation of the room Actor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是为了提供一个创建 Actor 实例的简单方法。我们为我们的设计创建了一个单独的房间；我们不希望有多个聊天室，所以我们需要控制房间 Actor
    的创建。
- en: If the room is null, we will create a new room; otherwise, we will return the
    cached instance of the room that we already got in the memory. We will need an
    instance of the Actor system in order to create actors, so that's why we are receiving
    the system on the `apply` function. The `apply` function will be called when someone
    writes a code like `ChatRoomActor(mySystem)`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果房间为空，我们将创建一个新的房间；否则，我们将返回内存中已经获取的房间缓存的实例。我们需要一个 Actor 系统的实例来创建演员，这就是为什么我们在
    `apply` 函数中接收系统。当有人编写 `ChatRoomActor(mySystem)` 这样的代码时，`apply` 函数将被调用。
- en: Now, let's move to the ChatUserActor implementation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向 `ChatUserActor` 的实现。
- en: 'The `ChatUserActor.scala` file should look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatUserActor.scala` 文件应该看起来像这样：'
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This Actor is a little bit easier than the previous one. `ChatUserActor` receives,
    as a parameter, the room actor reference and also an out actor. The room will
    be an instance of the room that the user will use to communicate with other users.
    The `ActorRef` method called out is the Play framework Actor responsible for sending
    the answer back to the controllers and UI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演员比上一个稍微容易一些。`ChatUserActor` 接收一个参数，即房间演员引用和一个输出演员。房间将是一个用户将用来与其他用户通信的房间实例。被调用的
    `ActorRef` 方法是 Play 框架的 Actor，负责将答案发送回控制器和 UI。
- en: 'We pretty much just have two cases: one where we receive a `ChatMessage` and
    the other is the `ChatUserActors` method in the chat room. So, we will just need
    to send back to the UI using the out Actor. That''s why there is a fire and forget
    message for the out Actor with a result. Using a new Actor model can be dangerous,
    please read more at [http://doc.akka.io/docs/akka/current/scala/actors.html](http://doc.akka.io/docs/akka/current/scala/actors.html).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上只有两种情况：一种是我们接收一个 `ChatMessage`，另一种是聊天室中的 `ChatUserActors` 方法。所以，我们只需要通过输出演员发送回
    UI。这就是为什么有一个带有结果的 fire-and-forget 消息给输出 Actor。使用新的 Actor 模型可能会有危险，请参阅[http://doc.akka.io/docs/akka/current/scala/actors.html](http://doc.akka.io/docs/akka/current/scala/actors.html)
    了解更多。
- en: There is another case that just receives a string that will be the message from
    that Actor itself. Remember that each Actor represents a user and a browser full
    of duplex connections via WebSockets. Don't worry about WebSockets now; we will
    cover it in more detail later in this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是只接收一个字符串，这个字符串将是该 Actor 自身的消息。记住，每个 Actor 代表一个用户和一个通过 WebSocket 实现的全双工连接的浏览器。现在不用担心
    WebSocket；我们将在本章的后面更详细地介绍它。
- en: 'For this case function, we are sending the `ChatMessage` method to the room.
    We will split the messages in two parts: the username and the text, which is split
    by `:`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例函数，我们将 `ChatMessage` 方法发送到房间。我们将消息分成两部分：用户名和文本，它们通过 `:` 分隔。
- en: Here, we also have a companion object for the sake of good practice. So, you
    can call `ChatUserActor`, passing the Actor system and a curried parameter for
    the out actor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们也为了良好的实践而有一个伴随对象。所以，你可以调用 `ChatUserActor`，传递 Actor 系统和一个 curried 参数给输出演员。
- en: 'Now, we will move to the last Actor: the Bot Admin Actor, which should look
    something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向最后一个 Actor：Bot Admin Actor，它应该看起来像这样：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, this Actor receives the reference of the chat room as a parameter.
    Using the Actor system, it gets the reference of the chat room Actor. This Actor
    receives an `ActorSystem` message by now.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个Actor接收聊天室引用作为参数。使用Actor系统，它获取聊天室Actor的引用。这个Actor现在已经接收到了`ActorSystem`消息。
- en: Using the Actor system variable called system, we will also schedule a `Tick`
    for this Actor for every ten seconds. This time, the window interval will be the
    time in which the bot will notify the chat room about the current status.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为system的Actor系统变量，我们还将为这个Actor每十秒安排一个`Tick`。这次，窗口间隔将是机器人通知聊天室当前状态的时间。
- en: We will also override the `preStart` function. Akka will call this function
    when the Actor is created on the actor system. This implementation will send a
    message to the room, which is `JoinChatRoom`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重写`preStart`函数。Akka将在Actor在actor系统中创建时调用此函数。此实现将向房间发送一条消息，即`JoinChatRoom`。
- en: Like all Actors, there is the receive function implementation. First case with
    `ChatMessage` is returning Unit. If you want to make this bot respond to people,
    remove Unit and write the proper Scala code as you wish.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如同所有Actor一样，有接收函数的实现。第一个情况`ChatMessage`返回Unit。如果您想使这个机器人对人们做出响应，请移除Unit并编写您想要的适当的Scala代码。
- en: In the second case, we will have the String message that will be sent to the
    chat room. Finally, after this case, we will have the `Tick` method, which will
    appear every ten seconds. So, we will use the `ActorHelper` to get the stats from
    the room, and then we will send a string message with the information about the
    room. This will trigger the second case and broadcast the message to the whole
    room.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们将有一个要发送到聊天室的消息字符串。最后，在这个情况之后，我们将有一个每十秒出现的`Tick`方法。因此，我们将使用`ActorHelper`从房间获取统计数据，然后我们将发送一个包含房间信息的字符串消息。这将触发第二种情况并向整个房间广播消息。
- en: Finally, we have a companion object. We don't want to have two instances of
    the bot, which is why we will control this object creation by design. We're done
    with the actors implementations. Next, we will need to work a new controller for
    the chat actors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个伴生对象。我们不希望有两个机器人实例，这就是为什么我们将通过设计控制这个对象创建。我们已经完成了Actor的实现。接下来，我们需要为聊天Actor工作一个新的控制器。
- en: The chat controller
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天控制器
- en: We will need to create a new controller. This controller will be located at
    `ReactiveWebStore/app/controllers`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的控制器。这个控制器将位于`ReactiveWebStore/app/controllers`。
- en: Implementing the chat controller
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现聊天控制器
- en: '`ChatController.scala` should look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatController.scala`应类似于以下内容：'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ChatController` method will use Google Guice to get injected instances
    of Actor System and an Actor materializer instance. A materializer is needed because
    it will provide the instance of the out Actor for each user in the system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatController`方法将使用Google Guice来获取Actor System和Actor materializer实例的注入实例。需要一个materializer，因为它将为系统中的每个用户提供出Actor的实例。'
- en: 'As you can see, we will create an instance of the `ChatBotAdmin` method passing
    through the actor system, which Google Guice injected for us. For this controller,
    we will just have two functions: one function to render the chat UI, and the other
    one to serve the WebSocket.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将创建一个`ChatBotAdmin`方法的实例，通过actor系统传递Google Guice为我们注入的。对于这个控制器，我们只有一个函数：一个用于渲染聊天UI的函数，另一个用于服务WebSocket。
- en: The Play framework already provides built-in integration with Akka and WebSockets.
    So, we will just need to use the `ActorFlow` method using the `actorRef` function
    in order to obtain an out Actor.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架已经提供了与Akka和WebSockets的内置集成。因此，我们只需使用`actorRef`函数中的`ActorFlow`方法来获取出Actor即可。
- en: Here, we will call the `ChatUserActor` companion object and create a chat user
    for the websocket passing out the Actor system the controller has. As you can
    see, this returns `WebSocket.accept`, which is a full duplex connection between
    the web browser and the backend.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将调用`ChatUserActor`伴生对象，并为websocket创建一个聊天用户，传递控制器拥有的Actor系统。如您所见，这返回`WebSocket.accept`，这是浏览器和后端之间的全双工连接。
- en: Configuring the routes
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由
- en: 'Next, we will need to expose our controller functions to the UI. We will need
    to add more routes to the `ReactiveWebStore/conf/routes` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的控制器函数暴露给用户界面。我们需要向`ReactiveWebStore/conf/routes`文件中添加更多路由：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The routes are done now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 路由已完成。
- en: Working on the UI
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在处理用户界面
- en: Now, it is time to code on the UI on both the HTML layout and the WebSocket
    code in JavaScript. We will need to create a new file, located at `ReactiveWebStore/app/views`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在 UI 上编写代码了，包括 HTML 布局和 JavaScript 中的 WebSocket 代码。我们需要创建一个新文件，位于 `ReactiveWebStore/app/views`。
- en: 'Your `chat_index.scala.html` file should look something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `chat_index.scala.html` 文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The UI is very simple. There is an input text for you to put your name and there
    is another one for the text message itself, and a send button. As you can see
    in the JavaScript code, the first thing that we will do is open a WebSocket connection
    to the `ws://localhost:9000/chat/ws` URL. Then, we will register the `init` function
    to run once the browser is ready.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: UI 非常简单。有一个输入框供您输入您的名字，还有一个用于输入文本消息的输入框，以及一个发送按钮。正如您在 JavaScript 代码中所看到的，我们首先要做的事情是打开一个
    WebSocket 连接到 `ws://localhost:9000/chat/ws` URL。然后，我们将注册 `init` 函数，以便在浏览器准备好后运行。
- en: The `init` function in JavaScript will create two functions for our WebSocket.
    One function will run when any error occurs and the other function will run for
    each message emitted by the Akka backend.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 `init` 函数将为我们的 WebSocket 创建两个函数。一个函数会在发生任何错误时运行，另一个函数会在 Akka 后端发出每条消息时运行。
- en: We will have a `doSend` function in JavaScript in order to send a message to
    the WebSocket. This message will be delivered to the controller and then to the
    Akka actors. You can also see some JQuery and HTML code in order to create new
    elements on the UI. This is done in order to display the message in the chat room.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 JavaScript 中有一个 `doSend` 函数，用于向 WebSocket 发送消息。这条消息将被传递到控制器，然后到 Akka Actor。您还可以看到一些用于在
    UI 上创建新元素的 jQuery 和 HTML 代码。这是为了在聊天室中显示消息。
- en: OK, there is one more thing that we will need to do - add a reference to the
    chat UI on the main page of our application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，还有一件事我们需要做——在我们的应用程序主页上添加对聊天 UI 的引用。
- en: 'Your `Index.scala.html` should look something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `Index.scala.html` 应该看起来像这样：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also use the opportunity to improve a little bit of the UI design using
    Twitter Bootstrap column design. In the last row, you can see our link to the
    chat UI. Now, we can run the application and see our chat working. Run `$ activator
    run`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用这个机会稍微改进一下 UI 设计，使用 Twitter Bootstrap 列表设计。在最后一行，您可以看到我们链接到聊天 UI 的链接。现在，我们可以运行应用程序并看到我们的聊天功能正在工作。运行
    `$ activator run`：
- en: '![Working on the UI](img/image00318.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![正在处理 UI](img/image00318.jpeg)'
- en: 'As you can see, our new chat UI link is there. Now, let''s have fun with this
    new feature. Open four new browsers (simulate four different users), then go to
    the `http://localhost:9000/chat/index_socket` url and let''s have a little chat.
    You should see something similar to this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的新聊天 UI 链接在那里。现在，让我们享受这个新功能带来的乐趣。打开四个新的浏览器（模拟四个不同的用户），然后转到 `http://localhost:9000/chat/index_socket`
    URL，让我们聊一聊。您应该看到类似以下的内容：
- en: '![Working on the UI](img/image00319.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![正在处理 UI](img/image00319.jpeg)'
- en: Almost done. Our chat feature works; however, we will need to do more than just
    a functional black box test on the UI. We will need unit tests. Luckily for us,
    we have the Akka testkit, which allows us to easily test actors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完成了。我们的聊天功能已经工作；然而，我们不仅需要在 UI 上进行功能性的黑盒测试，还需要进行单元测试。幸运的是，我们有 Akka 测试套件，它允许我们轻松地测试
    Actor。
- en: Adding Akka tests
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Akka 测试
- en: 'We will create three more tests: one for each actor that we have. They are
    located at `ReactiveWebStore/test/`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另外三个测试：每个 Actor 一个。它们位于 `ReactiveWebStore/test/`。
- en: Scala test for Akka Actor
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Akka Actor 的 Scala 测试
- en: '`ChatUserActorSpec.scala` should look something like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatUserActorSpec.scala` 应该看起来像这样：'
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Akka testkit is very cool as it allows us to test actors with a very easy
    **Domain Specific Language** (**DSL**). It's possible to check the Actor mailbox,
    the Actor internal state, and so much more. There is one trick that we will need
    to do because we need to extend one class; in order to have Play working with
    the Scala test, we will need to use PlaySpec. However, we will also need to extend
    one class to make the Akka testkit work, which is `TestKit`. We can't extend both
    at the same time, but no worries, there is always a workaround.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 测试套件非常酷，因为它允许我们使用非常简单的**领域特定语言**（**DSL**）来测试 Actor。我们可以检查 Actor 的邮箱、Actor
    的内部状态以及更多。我们需要做的一个小技巧是因为我们需要扩展一个类；为了使 Play 与 Scala 测试一起工作，我们需要使用 PlaySpec。然而，我们还需要扩展一个类来使
    Akka 测试套件工作，这个类是 `TestKit`。我们不能同时扩展两个，但不用担心，总有解决方案。
- en: The workaround here is to create a case class, make that case class extend `TestKit`,
    and then use it in a spec context, that is, in a new `Actor {}`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是创建一个case类，让这个case类扩展`TestKit`，然后在spec上下文中使用它，即在新的`Actor {}`中。
- en: Here, we are checking if `ChatUserActor` can join the chat room properly. This
    is done by simply creating the Actor, as the Actor has a `preStart` method that
    will auto-join the room.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查`ChatUserActor`是否能正确加入聊天室。这是通过简单地创建演员来完成的，因为演员有一个`preStart`方法，它将自动加入房间。
- en: We will need to create a fake implementation of the out Actor here, which is
    why we have the `OutActor` implementation. We will create a probe to test the
    actor system, and we will also use a special function to test the Actors, called
    `TestActorRef`. This abstraction provides a way to access the Actor's state via
    `actorRef.underlyingActor`, and this is useful because you can check the Actor
    internal state to validate the code. The rest of the code is normal Akka and Scala
    test code. Let's move to the next test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里创建一个假的`OutActor`实现，这就是为什么我们有`OutActor`实现的原因。我们将创建一个探针来测试演员系统，并且我们还将使用一个特殊的功能来测试演员，称为`TestActorRef`。这个抽象提供了一种通过`actorRef.underlyingActor`访问演员状态的方法，这很有用，因为你可以检查演员的内部状态以验证代码。其余的代码是正常的Akka和Scala测试代码。让我们进行下一个测试。
- en: Chat room Actor test
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天室演员测试
- en: 'The `ChatRoonActorSpec.scala` file should look something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatRoonActorSpec.scala`文件应类似于以下内容：'
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, here we have the same concepts as the other test. However, we have more
    usage of the Akka testkit DSL. For instance, we are using `expectMsg` on the probe
    to check if an Actor received a specific message. We are also using `awaitCond`
    to check the Actor's internal state in an assertion.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有与其他测试相同的概念。然而，我们使用了更多的Akka测试kit DSL。例如，我们正在使用`expectMsg`在探针上检查演员是否接收到了特定的消息。我们还在断言中使用`awaitCond`来检查演员的内部状态。
- en: Now is the time to test the last Actor method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试最后一个演员方法的时候了。
- en: Chat Bot Admin Actor test
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天机器人管理员演员测试
- en: '`ChatBotAdminActorSpec.scala` file should look something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatBotAdminActorSpec.scala`文件应类似于以下内容：'
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this test, we will check if the actor context was not null, and also if
    the room was created and the scheduler was also not null. All good to go.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次测试，我们将检查演员上下文是否不为空，以及房间是否已创建，调度器也不为空。一切准备就绪。
- en: Alright, that's it! This is the last actor test. Now we are completely done.
    You can run this test with `$ activator test`, or, if you prefer the activator,
    then use `"test-only TESTCLASSNAME" -Dsbt.task.forcegc=false` to run a specific
    test case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就结束了！这是最后一个演员测试。现在我们已经全部完成。你可以使用`$ activator test`运行这个测试，或者，如果你更喜欢activator，那么使用`"test-only
    TESTCLASSNAME" -Dsbt.task.forcegc=false`来运行特定的测试用例。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with Akka actors and created a web
    chat using Akka, the Play framework, and WebSockets. Akka is a really powerful
    solution that can be used with or without the Play framework. Additionally, you
    learned about the Actor model, mailboxes, routing, persistence, Akka configuration,
    message patterns, and how to write code with actors in Scala and Play.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Akka演员，并使用Akka、Play框架和WebSockets创建了一个网络聊天。Akka是一个真正强大的解决方案，可以与或无需Play框架一起使用。此外，你还了解了演员模型、邮箱、路由、持久化、Akka配置、消息模式，以及如何在Scala和Play中使用演员编写代码。
- en: In the next chapter, you will learn more about REST, JSON, and how to model
    a REST API, as well as how to create a Scala client for your REST services.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于REST、JSON以及如何建模REST API的内容，以及如何为你的REST服务创建Scala客户端。
