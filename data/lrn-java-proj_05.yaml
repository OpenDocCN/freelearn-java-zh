- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Understanding Iteration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迭代
- en: In [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087), we learned about scope and
    conditional statements in Java. Scope determines the visibility of identifiers
    – in other words, where you can use them. Java uses block scope, which is defined
    by curly braces, `{}`. Scopes can be nested but not vice versa.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19793_04.xhtml#_idTextAnchor087) 中，我们学习了 Java 中的作用域和条件语句。作用域决定了标识符的可见性——换句话说，你可以在哪里使用它们。Java
    使用块作用域，由花括号 `{}` 定义。作用域可以嵌套，但不能反过来。
- en: We discussed variations of the `if` statement. Each of these statements evaluates
    a boolean condition, resulting in true or false. If true, then that branch is
    executed and no other branch is evaluated. If false, then the next branch is evaluated.
    Unless an else clause is present, it is possible that no branch at all will be
    executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 `if` 语句的变体。这些语句中的每一个都会评估一个布尔条件，结果为真或假。如果为真，则执行该分支，不评估其他分支。如果为假，则评估下一个分支。除非存在
    else 子句，否则可能根本不会执行任何分支。
- en: For complex `if` statements, Java supports the more elegant `switch` structure.
    We examined `switch` statements, with their *fall-through* behavior, and the use
    of the `break` statement. In addition, we discussed `switch` expressions, where
    a value can be returned, and their use of `yield`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的 `if` 语句，Java 支持更优雅的 `switch` 结构。我们考察了 `switch` 语句及其 *穿透* 行为，以及 `break`
    语句的使用。此外，我们还讨论了 `switch` 表达式，其中可以返回一个值，以及它们使用 `yield` 的方式。
- en: Now that we understand conditional logic, let us examine iteration (looping).
    Looping constructs enable us to repeat statements and/or blocks of code a finite
    number of times while a boolean condition is true or while there are more entries
    in the array/collection. By the end of this chapter, you will be able to use Java’s
    looping constructs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了条件逻辑，让我们来考察迭代（循环）。循环结构使我们能够重复执行语句和/或代码块有限次数，直到布尔条件为真或直到数组/集合中还有更多条目。到本章结束时，你将能够使用
    Java 的循环结构。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: '`while` loops'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`do-while` loops'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: '`for` loops'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: Enhanced `for` (`for-each`) loops
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强的 `for` (`for-each`) 循环
- en: '`break` and `continue` statements'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 语句'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5)。
- en: while loops
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: An important feature of any programming language is the ability to perform an
    action repeatedly. This is known as “looping”. We may want to repeat a piece of
    code a finite number of times or until some condition is met; for example, the
    user typing in a value that signifies that the loop should terminate. In most
    cases, a boolean expression can be used to determine whether the loop continues
    or not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的一个重要特性是能够重复执行一个动作。这被称为“循环”。我们可能想要有限次数地重复一段代码，或者直到满足某个条件；例如，用户输入一个值表示循环应该终止。在大多数情况下，可以使用布尔表达式来确定循环是否继续。
- en: A `while` loop is one such looping construct. It repeatedly executes a statement
    or a block of code as long as a boolean expression is true. As soon as the boolean
    expression is false, the loop exits, and the next statement after the `while`
    loop executes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是这样一种循环结构。只要布尔表达式为真，它就会重复执行一个语句或代码块。一旦布尔表达式为假，循环就会退出，然后执行 `while`
    循环之后的下一个语句。'
- en: '![Figure 5.1 – The while loop syntax](img/B19793_05_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – `while` 循环语法](img/B19793_05_1.jpg)'
- en: Figure 5.1 – The while loop syntax
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – `while` 循环语法
- en: 'In the preceding figure, we are assuming a block of code, hence the curly braces
    `{}`. You could, of course, omit the curly braces `{}` and the loop will just
    repeatedly execute one statement (which ends with a semi-colon). Interestingly,
    as the boolean expression could be false to begin with, the `while` loop may not
    execute at all. More formally, a `while` loop executes *zero* or more times. Let
    us look at some examples. *Figure 5**.2* presents a simple `while` loop:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们假设了一段代码块，因此有花括号 `{}`。当然，你可以省略花括号 `{}`，循环将只重复执行一个语句（以分号结束）。有趣的是，由于布尔表达式可能一开始就是假的，`while`
    循环可能根本不会执行。更正式地说，`while` 循环执行 *零* 次或多次。让我们看看一些例子。*图 5.2* 展示了一个简单的 `while` 循环：
- en: '![Figure 5.2 – A simple while loop](img/B19793_05_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 一个简单的while循环](img/B19793_05_2.jpg)'
- en: Figure 5.2 – A simple while loop
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 一个简单的while循环
- en: 'On line 9 in the preceding figure, a local variable, `x`, is initialized to
    `1`. Line 11 evaluates the boolean expression, `x <= 3`. As `x` is `1`, the boolean
    expression is true and the loop executes. Line 12 outputs `"Loop: 1"` and line
    13 increments `x` to `2`. The `}` symbol on line 14 is reached and the loop condition
    (on line 11) is automatically rechecked to see whether it still holds. As `x`
    is `2` and `2 <= 3`, the condition is true and we re-enter the loop. Line 12 outputs
    `"Loop: 2"` and line 13 increments `x` to `3`. The end of the block is reached
    on line 14, and again, the loop continuation expression is re-evaluated. As the
    expression `3 <= 3` is true, the loop is executed again. Line 12 outputs `"Loop:
    3"` and line 13 increments `x` to `4`. Once again, the end of the code block is
    reached and the loop continuation expression is re-evaluated. As `x` is now `4`
    and as `4 <= 3` is false, the loop exits. This is shown by line 15 outputting
    `"Final x value` `is: 4"`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '在前一个图中的第9行，局部变量`x`被初始化为`1`。第11行评估布尔表达式`x <= 3`。由于`x`是`1`，布尔表达式为true，循环执行。第12行输出`"Loop:
    1"`，第13行将`x`增加到`2`。第14行的`}`符号被到达，循环条件（第11行）会自动重新检查是否仍然成立。由于`x`现在是`2`且`2 <= 3`为true，条件为true，我们重新进入循环。第12行输出`"Loop:
    2"`，第13行将`x`增加到`3`。在第14行达到代码块的末尾，再次，循环继续表达式被重新评估。由于表达式`3 <= 3`为true，循环再次执行。第12行输出`"Loop:
    3"`，第13行将`x`增加到`4`。再次，达到代码块的末尾并重新评估循环继续表达式。由于`x`现在是`4`且`4 <= 3`为false，循环退出。这由第15行输出`"Final
    x value is: 4"`所示。'
- en: Note that if, on line 9, `x` had been initialized to `11` (as opposed to `1`),
    then the initial boolean expression on line 11 would have been evaluated to false
    and the loop would never have been executed at all.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果在第9行，`x`被初始化为`11`（而不是`1`），那么第11行的初始布尔表达式将被评估为false，循环将根本不会执行。
- en: A `while` loop can be very useful when you do *not* know how many times the
    loop is going to iterate. For example, the loop continuation expression may be
    predicated on user input. *Figure 5**.3* is one such loop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不知道循环将迭代多少次时，`while`循环非常有用。例如，循环继续表达式可能基于用户输入。*图5.3*就是这样一种循环。
- en: '![Figure 5.3 – A while loop that ends based on user input](img/B19793_05_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 基于用户输入结束的while循环](img/B19793_05_3.jpg)'
- en: Figure 5.3 – A while loop that ends based on user input
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 基于用户输入结束的while循环
- en: In the preceding figure, an algorithm for summing up a sequence of positive,
    user-inputted numbers is presented. The loop will keep going, totaling up the
    numbers entered by the user, until a negative number is entered. This negative
    number is naturally, not part of the total. Let us discuss it in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中，展示了一个求和算法，该算法用于累加用户输入的正数序列。循环将一直进行，累加用户输入的数字，直到输入一个负数。这个负数自然地，不是总和的一部分。让我们更详细地讨论一下。
- en: Line 19 declares a local `int` variable, `sum`, and initializes it to `0`. Line
    20 declares a local boolean variable, `keepGoing`, and sets it to true. The boolean
    expression on line 21 evaluates to true (due to line 20) and, as a result, the
    loop block executes. Line 22 declares our `Scanner` reference, `sc`, pointing
    at the keyboard. Line 23 prompts the user to enter a number while informing the
    user that any negative number terminates the loop. Line 24 uses the `Scanner`
    method, `nextInt()`, to get an integer (whole number) from the user. This number
    is stored in the local variable, `n`. Line 25 checks to see whether a negative
    number has been entered. If so, line 26 sets the `keepGoing` flag to false so
    that the loop will not execute again. If a non-negative integer was entered by
    the user, then the number entered, `n`, is added to the running total, `sum`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行声明了一个局部`int`变量`sum`并将其初始化为`0`。第20行声明了一个局部布尔变量`keepGoing`并将其设置为true。第21行的布尔表达式评估为true（由于第20行），因此循环块执行。第22行声明了我们的`Scanner`引用`sc`指向键盘。第23行提示用户输入一个数字，同时告知用户任何负数将终止循环。第24行使用`Scanner`方法`nextInt()`从用户那里获取一个整数（整数）。这个数字被存储在局部变量`n`中。第25行检查是否输入了一个负数。如果是这样，第26行将`keepGoing`标志设置为false，这样循环就不会再次执行。如果用户输入了一个非负整数，那么输入的数字`n`将被添加到运行总和`sum`中。
- en: 'Let us walk through an example. We will add the following numbers: `1`, `2`,
    and `3`, totaling 6\. This is what the screen output looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解一下。我们将添加以下数字：`1`、`2`和`3`，总共是6。这是屏幕输出的样子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let us examine what is happening in the code. The loop (line 21) is entered
    because the `keepGoing` boolean was set to true on line 20\. We are then prompted
    for our first number (line 23). We type in `1`, resulting in `n` being initialized
    to `1` on line 24\. As `n` is `1`, the `if` statement on line 25 is false and
    the `else` block (lines 27-29) is executed; setting `sum` to `1` (0 + 1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查代码中正在发生的事情。循环（第21行）被进入，因为第20行将`keepGoing`布尔值设置为true。然后我们被提示输入第一个数字（第23行）。我们输入`1`，导致第24行将`n`初始化为`1`。由于`n`是`1`，第25行的`if`语句为假，执行`else`块（第27-29行）；将`sum`设置为`1`（0
    + 1）。
- en: The loop block end is reached (line 30) and the loop continuation expression
    is automatically re-evaluated (line 21). As `keepGoing` is still true, the loop
    continues. We are prompted for our second number; we enter `2` and `sum` is changed
    to `3` (1 + 2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 达到循环块末尾（第30行），循环继续表达式自动重新评估（第21行）。由于`keepGoing`仍然为true，循环继续。我们被提示输入第二个数字；我们输入`2`，`sum`变为`3`（1
    + 2）。
- en: The loop block end is reached again and, as `keepGoing` is still true, the loop
    continues. We are prompted for our next number; we enter `3` and `sum` is changed
    to `6` (3 + 3).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次达到循环块末尾，并且由于`keepGoing`仍然为true，循环继续。我们被提示输入下一个数字；我们输入`3`，`sum`变为`6`（3 + 3）。
- en: Again, the loop block end is reached and, as `keepGoing` is still true, the
    loop continues. We are prompted for our next number. This time we enter `-1`.
    As `n` is now negative, the `if` statement on line 25 is true and `keepGoing`
    is set to false (line 26). Now, when the loop continuation expression is next
    evaluated, as `keepGoing` is false, the loop exits.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，达到循环块末尾，并且由于`keepGoing`仍然为true，循环继续。我们被提示输入下一个数字。这次我们输入`-1`。由于`n`现在是负数，第25行的`if`语句为真，`keepGoing`被设置为false（第26行）。现在，当下一次评估循环继续表达式时，由于`keepGoing`为false，循环退出。
- en: 'Lastly, line 31 outputs `"Sum of numbers` `is: 6"`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第31行输出`"数字之和是：6"`。
- en: Now that we have covered the `while` loop, let us examine its close relative,
    the `do-while` loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`while`循环，让我们来考察它的近亲，`do-while`循环。
- en: do-while loops
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do-while循环
- en: 'As we have seen with the `while` loop, the boolean loop continuation expression
    is at the start of the loop. Though similar to the `while` loop, the `do-while`
    loop is different in one critical aspect: in the `do-while` loop, the loop continuation
    expression is at the *end* of the loop. Thus, the `do-while` loop is executed
    at least *once*. More formally, a `do-while` loop executes *one* or more times.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`while`循环中看到的那样，布尔循环继续表达式位于循环的开始。尽管与`while`循环相似，但`do-while`循环在一点上有所不同：在`do-while`循环中，循环继续表达式位于循环的*末尾*。因此，`do-while`循环至少执行*一次*。更正式地说，`do-while`循环执行*一次或多次*。
- en: '*Figure 5**.4* presents the syntax of the `do-while` loop.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.4*展示了`do-while`循环的语法。'
- en: '![Figure 5.4 – The do-while loop syntax](img/B19793_05_4.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – do-while循环语法](img/B19793_05_4.jpg)'
- en: Figure 5.4 – The do-while loop syntax
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – do-while循环语法
- en: As can be seen in the preceding figure, the loop continuation expression is
    at the end of the loop, after one loop iteration. Also note the semi-colon, `;`
    after `)`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，循环继续表达式位于循环的末尾，在第一次循环迭代之后。注意在`)`之后有一个分号，`;`。
- en: '*Figure 5**.5* presents a `do-while` version of the `while` loop in *Figure
    5**.2*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.5*展示了*图5.2*的`do-while`版本。'
- en: '![Figure 5.5 – A do-while loop that ends based on user input](img/B19793_05_5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 基于用户输入结束的do-while循环](img/B19793_05_5.jpg)'
- en: Figure 5.5 – A do-while loop that ends based on user input
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 基于用户输入结束的do-while循环
- en: In the preceding figure, the only differences with *Figure 5**.2* are lines
    21 and 30\. On line 21, we simply enter the loop as, unlike in the `while` loop,
    there is no condition preventing us from doing so. Line 30 checks to see whether
    it is okay to re-enter the loop. The rest of the code is the same and the execution
    is the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，与*图5.2*相比，唯一的区别是第21行和第30行。在第21行，我们简单地进入循环，因为在`while`循环中，没有条件阻止我们这样做。第30行检查是否可以重新进入循环。其余的代码相同，执行也相同。
- en: While (pardon the pun) the two examples given have no material difference in
    the outcome, let us examine a situation where using a `while` loop as opposed
    to a `do-while` loop is preferable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然（请原谅这个双关语）给出的两个示例在结果上没有实质性的区别，但让我们考察一个使用`while`循环而不是`do-while`循环更可取的情况。
- en: while versus do-while
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while与do-while
- en: As already stated, a `do-while` loop executes at least once, whereas a `while`
    loop may not execute at all. This can be very useful in certain situations. Let
    us look at one such example. *Figure 5**.6* presents a `while` loop that checks
    to see whether a person is of the legal age to purchase alcohol (which is 18 in
    Ireland).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`do-while`循环至少执行一次，而`while`循环可能根本不执行。这在某些情况下非常有用。让我们看看这样一个例子。*图5.6*展示了一个检查一个人是否达到法定年龄购买酒精（在爱尔兰是18岁）的`while`循环。
- en: '![Figure 5.6 – A while loop to prevent underage purchasing of alcohol](img/B19793_05_6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 防止未成年购买酒精的`while`循环](img/B19793_05_6.jpg)'
- en: Figure 5.6 – A while loop to prevent underage purchasing of alcohol
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 防止未成年购买酒精的`while`循环
- en: In the preceding figure, line 49 declares the `Scanner` and points it at the
    keyboard so we can get user input. Line 50 prompts the user to enter their age.
    Line 51 takes in the user input and stores it in a local variable, namely `age`.
    Line 52 is important. The condition prevents the loop from being executed with
    an invalid `age`. The loop itself is trivial and simply outputs a message that
    includes the `age` so we can validate that the loop is executing properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第49行声明了`Scanner`并将其指向键盘，这样我们就可以获取用户输入。第50行提示用户输入他们的年龄。第51行接收用户输入并将其存储在局部变量`age`中。第52行很重要。该条件防止循环使用无效的`age`执行。循环本身很简单，只是输出包含`age`的消息，这样我们就可以验证循环是否正确执行。
- en: Lines 57 to 58 are very important in that they enable us to prompt and get a
    new `age` from the user. The code deliberately overwrites the `age` variable.
    If we did not, then `age` would remain as the first value entered by the user
    and we would have an infinite loop. So, the first age is entered before the `while`
    loop is entered and every other age is entered at the end of the loop. This is
    a common pattern in `while` loops. The condition on line 52 prevents any `age`
    inputthat is < 18, from entering the loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第57到58行非常重要，因为它们使我们能够提示并从用户那里获取一个新的`age`。代码故意覆盖了`age`变量。如果我们不这样做，那么`age`将保持为用户首次输入的值，我们将有一个无限循环。因此，第一个年龄是在进入`while`循环之前输入的，而其他每个年龄都是在循环的末尾输入的。这是`while`循环中的常见模式。第52行的条件防止任何小于18岁的`age`输入进入循环。
- en: 'Here is the first run of the code in *Figure 5**.6*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*图5.6*中代码的第一次运行：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first two lines: the prompt and user input, are before the `while` loop
    and, as 21 >= 18, we enter the loop. The message `As you are 21 years of age,
    you can purchase alcohol.` is perfectly correct. The last two lines: repeating
    the prompt and user input, are from the bottom of the loop. We have entered `12`,
    which causes the `while` loop to terminate.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行：提示和用户输入，在`while`循环之前，由于21岁大于等于18岁，我们进入了循环。消息`As you are 21 years of age,
    you can purchase alcohol.`是完全正确的。最后两行：重复提示和用户输入，来自循环的底部。我们输入了`12`，这导致`while`循环终止。
- en: 'The following is the output if, when prompted for the first age, we enter `12`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提示输入第一个年龄时我们输入`12`，以下是将显示的输出：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Importantly, the message about purchasing alcohol does *not* appear.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，关于购买酒精的消息**没有**出现。
- en: Now, let us look at the `do-while` version. *Figure 5**.7* presents the `do-while`
    version of the `while` loop in *Figure 5**.6*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`do-while`版本。*图5.7*展示了*图5.6*中`while`循环的`do-while`版本。
- en: '![Figure 5.7 – A do-while loop to prevent underage purchasing of alcohol](img/B19793_05_7.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 防止未成年购买酒精的`do-while`循环](img/B19793_05_7.jpg)'
- en: Figure 5.7 – A do-while loop to prevent underage purchasing of alcohol
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 防止未成年购买酒精的`do-while`循环
- en: 'In the interests of having as much of the code as similar as possible, lines
    49 to 51 are untouched. Lines 52 and 59 are all that have changed. The condition
    is now at the end of the loop, after one iteration of the loop. This has implications
    when we start with an age of `12`, as can be seen in the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码尽可能相似，第49到51行保持不变。第52和59行是唯一有所更改的地方。现在条件位于循环的末尾，循环迭代一次之后。当我们从`12`岁开始时，这会产生影响，如输出所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The third line in the output is the issue. Obviously, 12 is too young to buy
    alcohol but the `do-while` loop would require an `if` statement to protect its
    code, whereas the `while` loop provides that protection automatically. Therefore,
    in this example, there is a material advantage in using the `while` loop over
    the `do-while` loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第三行存在问题。显然，12岁太小，不能购买酒精，但`do-while`循环需要`if`语句来保护其代码，而`while`循环则自动提供这种保护。因此，在这个例子中，使用`while`循环而不是`do-while`循环具有实质性的优势。
- en: Now that we have covered `while` and `do-while` loops, let us now discuss `for`
    loops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`while`循环和`do-while`循环，让我们现在讨论`for`循环。
- en: for loops
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: 'The `for` loop comes in two styles: the *traditional* `for` loop and the *enhanced*
    `for` loop. The enhanced `for` loop is also known as the `for-each` loop and is
    specifically designed to work with arrays and collections. We will start by examining
    the traditional `for` loop.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环有两种风格：传统的`for`循环和增强的`for`循环。增强的`for`循环也被称为`for-each`循环，它专门设计用来与数组集合一起工作。我们将首先检查传统的`for`循环。'
- en: Traditional for loop
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统for循环
- en: This type of `for` loop is extremely useful when you know how many iterations
    you wish to perform beforehand. Its syntax is detailed in *Figure 5**.8*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的`for`循环在你事先知道要执行多少次迭代时非常有用。其语法在*图5**.8*中有详细说明。
- en: '![Figure 5.8 – The traditional for loop](img/B19793_05_8.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 传统的for循环](img/B19793_05_8.jpg)'
- en: Figure 5.8 – The traditional for loop
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 传统的for循环
- en: 'The code block in the preceding figure is optional. We could simply control
    one statement, such as `System.out.println("Looping");`, and omit `{}`. The `for`
    header is the section inside `()`. It consists of three parts, delimited by semi-colons:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个图中的代码块是可选的。我们可以简单地控制一个语句，例如`System.out.println("Looping");`，并省略`{}`。`for`头是`()`内的部分。它由三个部分组成，由分号分隔：
- en: '`i`, `j`, `k`, and so forth.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`、`j`、`k`等等。'
- en: '`while` loop and a traditional `for` loop are interchangeable.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环和传统的`for`循环可以互换使用。'
- en: '**Increment/decrement section**: This is where you increment/decrement your
    loop control variables (declared in the initialization section) so that the loop
    terminates.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量/减量部分**：这是你增加/减少循环控制变量（在初始化部分声明）的地方，以便循环终止。'
- en: We must understand the order of execution of the loop. In other words, which
    part is executed and when. *Figure 5**.9*, which presents a simple `for` loop,
    will help in this regard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须理解循环执行的顺序。换句话说，哪个部分被执行，何时执行。*图5**.9*，展示了一个简单的`for`循环，将有助于这一点。
- en: '![Figure 5.9 – A simple traditional for loop](img/B19793_05_9.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 一个简单的传统for循环](img/B19793_05_9.jpg)'
- en: Figure 5.9 – A simple traditional for loop
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 一个简单的传统for循环
- en: 'In this figure, the order of execution of the code is represented in numerical
    order as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，代码执行的顺序用数字顺序表示如下：
- en: '`i`, is declared and initialized to `1`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i`被声明并初始化为`1`。'
- en: '**Boolean expression**: Evaluate the boolean expression to see whether it is
    okay to execute the loop. As 1 <= 3, it is okay to enter the loop.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布尔表达式**：评估布尔表达式以确定是否可以执行循环。因为1 <= 3，所以可以进入循环。'
- en: '`1` to the screen.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示到屏幕上。
- en: '`i` is incremented (by 1) from `1` to `2` and then execution pops over to the
    boolean expression.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i`从`1`增加到`2`，然后执行跳转到布尔表达式。'
- en: '**Evaluate the boolean expression**: As 2 <= 3, the loop is executed.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估布尔表达式**：因为2 <= 3，所以循环被执行。'
- en: '`2` to the screen.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`2`显示到屏幕上。
- en: '**Increment i from 2 to 3**: and then pop over to the boolean expression.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从2增加到3增加i**：然后跳转到布尔表达式。'
- en: '**Evaluate the boolean expression**: As 3 <= 3, the loop is executed.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估布尔表达式**：因为3 <= 3，所以循环被执行。'
- en: '`3` to the screen.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`3`显示到屏幕上。
- en: '**Increment i from 3 to 4**: and then pop over to the boolean expression.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从3增加到4增加i**：然后跳转到布尔表达式。'
- en: '**Evaluate the boolean expression**: As 4 is not <= 3, the loop exits.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估布尔表达式**：因为4不是<= 3，所以循环退出。'
- en: In summary, the initialization section is executed only once, at the start of
    the loop. The boolean expression is evaluated and, assuming it is true, the loop
    body is executed, followed by the increment/decrement section. The boolean expression
    is again evaluated and, again, assuming it is true, the loop body is executed,
    followed by the increment/decrement section. This repetition of the execution
    of the loop body followed by the increment/decrement section continues until the
    boolean expression fails and the loop exits.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，初始化部分仅在循环开始时执行一次。布尔表达式被评估，并且假设它是真的，那么循环体将被执行，随后是增量/减量部分。布尔表达式再次被评估，并且再次假设它是真的，那么循环体将被执行，随后是增量/减量部分。这种循环体执行后跟增量/减量部分的重复执行会一直持续到布尔表达式失败，循环退出。
- en: '*Figure 5**.10* presents a `for` loop that goes from `3` down to `1` in decrements
    of 1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.10*展示了一个从`3`递减到`1`的`for`循环，每次递减1：'
- en: '![Figure 5.10 – A simple for loop that operates in descending order](img/B19793_05_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 一个简单的递减顺序for循环](img/B19793_05_10.jpg)'
- en: Figure 5.10 – A simple for loop that operates in descending order
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 一个按降序操作的简单 for 循环
- en: In the preceding figure, we initialize `i` to `3` and check the boolean expression.
    As 3 >= 1, we enter the loop and output `3`. We then decrement `i` by 1 to `2`
    and check the boolean expression again. As 2 >= 1, we output `2` and then decrement
    `i` to `1`. As the boolean expression is still true; we output `1` and `i` is
    decremented to `0`. At this point, as `i` is `0`, the boolean expression is false
    and the loop terminates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们将 `i` 初始化为 `3` 并检查布尔表达式。由于 `3 >= 1`，我们进入循环并输出 `3`。然后我们将 `i` 减少到 `2`
    并再次检查布尔表达式。由于 `2 >= 1`，我们输出 `2` 并将 `i` 减少到 `1`。由于布尔表达式仍然为真，我们输出 `1` 并将 `i` 减少到
    `0`。此时，由于 `i` 为 `0`，布尔表达式为假，循环终止。
- en: '*Figure 5**.11* presents some code samples enabling us to discuss this looping
    construct further.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5**.11* 展示了一些代码示例，使我们能够进一步讨论这个循环结构。'
- en: '![Figure 5.11 – Additional traditional for loops](img/B19793_05_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 附加的传统 for 循环](img/B19793_05_11.jpg)'
- en: Figure 5.11 – Additional traditional for loops
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 附加的传统 for 循环
- en: In the first loop of the preceding figure (lines 20-22), the important thing
    to notice is the `;` symbol, which is just after the `)` symbol of the `for` header.
    This loop controls an empty statement! Even though the indentation may suggest
    otherwise, the block of code that follows has nothing to do with the loop at all,
    and as a result, `"Looping"` appears only once in the output. In effect, the loop
    iterates three times, doing nothing each time. The block of code surrounding line
    21 is not predicated on any condition and just executes once (as normal).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图中的第一个循环（第 20-22 行）中，需要注意的重要事情是 `;` 符号，它位于 `for` 标头的 `)` 符号之后。这个循环控制一个空语句！尽管缩进可能暗示了其他情况，但随后的代码块与循环没有任何关系，因此输出中只出现一次
    `"Looping"`。实际上，循环迭代了三次，每次都没有做任何事情。第 21 行周围的代码块不基于任何条件，并且只执行一次（像正常一样）。
- en: 'In the second loop (lines 24-26), the loop control variable, `i`, starts out
    at `10` and goes up in increments of 10 until it reaches `60`, at which point
    the loop terminates. Each valid value of `i` is output to the screen – in other
    words, `10`, `20`, `30`, `40`, and `50`. Note that line 27 does *not* compile,
    as each of the `i` variables declared in the preceding loops only have the scope
    of their individual loop. For example, the `i` variable declared on line 20 is
    only available until line 22; similarly, the `i` variable declared on line 24
    is only available until line 26\. Note: obviously, line 27 must be commented out
    for the code to compile and run.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个循环（第 24-26 行）中，循环控制变量 `i` 从 `10` 开始，每次增加 10，直到达到 `60`，此时循环终止。每个有效的 `i` 值都会输出到屏幕上——换句话说，`10`、`20`、`30`、`40`
    和 `50`。请注意，第 27 行无法编译，因为前面循环中声明的每个 `i` 变量只在其各自的循环范围内有效。例如，第 20 行声明的 `i` 变量仅在直到第
    22 行可用；同样，第 24 行声明的 `i` 变量仅在直到第 26 行可用。注意：显然，为了使代码编译和运行，第 27 行必须被注释掉。
- en: The last loop (lines 29-31) shows that we can declare multiple loop control
    variables and use them throughout the loop. In this loop, we declare `i` and `j`
    and initialize them both to `0`. The boolean expression is true as both `i < 1`
    and `j < 1` are true (true && true == true). Thus, we execute the loop and output
    `0` and `0`. Both `i` and `j` are then incremented to `1`. The loop condition
    fails and the loop terminates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个循环（第 29-31 行）显示我们可以声明多个循环控制变量并在整个循环中使用它们。在这个循环中，我们声明了 `i` 和 `j` 并将它们都初始化为
    `0`。布尔表达式为真，因为 `i < 1` 和 `j < 1` 都为真（true && true == true）。因此，我们执行循环并输出 `0` 和
    `0`。然后 `i` 和 `j` 都增加到 `1`。循环条件失败，循环终止。
- en: While arrays will be discussed in detail in [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118),
    `for` loops are such a natural fit for arrays that we have inserted some examples
    here as well. Let us first examine how a traditional `for` loop can be used to
    process an array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `for` 循环将在 [*第 6 章*](B19793_06.xhtml#_idTextAnchor118) 中详细讨论，但由于 `for` 循环与数组如此自然地匹配，我们在此也插入了一些示例。让我们首先检查传统的
    `for` 循环如何用于处理数组。
- en: Processing an array
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理数组
- en: Any `for` loop is useful for iterating over an array. An array is simply an
    area of memory set aside and given an identifier name for ease of reference. An
    array consists of elements which are organized in consecutive memory locations
    – in other words, the array elements are right beside each other in memory. This
    makes it easy to process arrays using loops.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`for`循环都适用于遍历数组。数组简单地说是一个分配了内存并赋予标识符名称的区域，以便于引用。数组由元素组成，这些元素按连续的内存位置组织 – 换句话说，数组元素在内存中紧挨着。这使得使用循环处理数组变得容易。
- en: Each element in an array is accessed by an index. Crucially, array indices start
    at `0` and go up in steps of 1\. Therefore, the last valid index is the size of
    the array minus one. For example, an array of size `5` has valid indices of `0`,
    `1`, `2`, `3`, and `4`. *Figure 5**.12* is a loop processing an array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个元素都通过索引来访问。关键的是，数组索引从`0`开始，每次递增1。因此，最后一个有效的索引是数组大小减一。例如，大小为`5`的数组有有效的索引`0`、`1`、`2`、`3`和`4`。*图5.12*是一个处理数组的循环。
- en: '![Figure 5.12 – Processing an array using a traditional for loop](img/B19793_05_12.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 使用传统for循环处理数组](img/B19793_05_12.jpg)'
- en: Figure 5.12 – Processing an array using a traditional for loop
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 使用传统for循环处理数组
- en: In this figure, line 33 declares an `int` array containing the values `1`, `2`,
    and `3` in indices `0`, `1`, and `2`, respectively. The length of the array, accessible
    using the `length` property, is `3`. The `for` loop (lines 34-35) processes the
    array, outputting each location one by one. Thus, when `i` is `0`, `ia[0]` outputs
    `1` to the screen; when `i` is `1`, `ia[1]` outputs `2`, and when `i` is `2`,
    `ia[2]` outputs `3`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第33行声明了一个包含值`1`、`2`和`3`的`int`数组，分别位于索引`0`、`1`和`2`。数组的长度，可以通过`length`属性访问，是`3`。`for`循环（第34-35行）处理数组，逐个输出每个位置。因此，当`i`为`0`时，`ia[0]`将`1`输出到屏幕上；当`i`为`1`时，`ia[1]`输出`2`，当`i`为`2`时，`ia[2]`输出`3`。
- en: Now that we have covered the traditional `for` loop, let us examine the enhanced
    `for` loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了传统的`for`循环，让我们来考察增强型`for`循环。
- en: Enhanced for loop
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强型for循环
- en: As stated earlier, the enhanced `for` loop, also known as the `for-each` loop,
    is ideal for processing arrays and/or collections. We will discuss collections
    is detail in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317). For the moment,
    just imagine a collection as a *list* of items. The enhanced `for` loop enables
    you to iterate over the list one element at a time. The syntax of the enhanced
    `for` loop is outlined in *Figure 5**.13*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，增强型`for`循环，也称为`for-each`循环，非常适合处理数组以及/或者集合。我们将在[*第13章*](B19793_13.xhtml#_idTextAnchor317)中详细讨论集合。目前，只需想象一个集合是一个*列表*的项目。增强型`for`循环允许你逐个元素遍历列表。增强型`for`循环的语法在*图5.13*中概述。
- en: '![Figure 5.13 – Enhanced for loop syntax](img/B19793_05_13.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13 – 增强型for循环语法](img/B19793_05_13.jpg)'
- en: Figure 5.13 – Enhanced for loop syntax
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 增强型for循环语法
- en: In the preceding figure, we can see that a variable is declared. The variables
    type matches the type of array/collection. For example, if the array is an array
    of `String`, then `String` is the data type of the variable. The variable name
    is of course, up to us. Again, the code block is optional.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个变量的声明。变量的类型与数组/集合的类型相匹配。例如，如果数组是一个`String`数组，那么`String`就是变量的数据类型。变量名当然由我们决定。再次强调，代码块是可选的。
- en: Let us look at an example to help explain further. *Figure 5**.14* is an enhanced
    `for` loop version of the traditional `for` loop presented in *Figure 5**.12*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来进一步解释。*图5.14*是*图5.12*中展示的传统`for`循环的增强型`for`循环版本。
- en: '![Figure 5.14 – Processing an array using an enhanced for loop](img/B19793_05_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 使用增强型for循环处理数组](img/B19793_05_14.jpg)'
- en: Figure 5.14 – Processing an array using an enhanced for loop
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 使用增强型for循环处理数组
- en: 'In this figure, line 38 reads as follows: *for each int n in (the array) ia*.
    Thus, on the first iteration, `n` is `1`; on the second iteration, `n` is `2`,
    and on the last iteration, `n` is `3`. In the enhanced `for` loop, we do not have
    to keep track of a loop control variable ourselves. While this is useful, be aware
    that you are limited to starting at the beginning of the array/collection and
    progressing one element at a time, until you reach the end. With the traditional
    `for` loop, none of these restrictions apply.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第38行的内容如下：*对于数组（ia）中的每个int n*。因此，在第一次迭代中，`n`是`1`；在第二次迭代中，`n`是`2`；在最后一次迭代中，`n`是`3`。在增强的`for`循环中，我们不必自己跟踪循环控制变量。虽然这很有用，但请注意，你被限制从数组的开始处开始，逐个元素前进，直到达到末尾。使用传统的`for`循环，这些限制都不适用。
- en: However, with the traditional `for` loop, if you code the increment/decrement
    section incorrectly, you could end up in an infinite loop. This is not possible
    in the enhanced `for` version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用传统的`for`循环，如果你错误地编码了增量/减量部分，你可能会陷入无限循环。在增强的`for`版本中这是不可能的。
- en: Nested loops
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: Loops can, of course, be nested. In other words, loops can be coded within other
    loops. *Figure 5**.15* presents one such example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，循环可以嵌套。换句话说，循环可以编码在其他循环内。**图5.15**展示了这样一个例子。
- en: '![Figure 5.15 – Nested for loops](img/B19793_05_15.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![**图5.15** – 嵌套循环](img/B19793_05_15.jpg)'
- en: Figure 5.15 – Nested for loops
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.15** – 嵌套循环'
- en: 'The output from this program is presented in *Figure 5**.16*. In the preceding
    figure, we are representing an array of `int` values, namely `data`, as a histogram
    (represented as a row of stars). The array is declared on line 12\. Line 14 outputs
    a line of text so the output from the program is easier to interpret. The output
    has three columns: the current array index, the value in the `data` array at that
    index, and the histogram. Note that the output is tab-delimited. This is achieved
    by the use of the `\t` escape sequence.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的输出以**图5.16**展示。在前面的图中，我们表示一个`int`值数组，即`data`，为一个直方图（表示为一行星号）。数组在12行声明。第14行输出一行文本，以便程序输出更容易解释。输出有三个列：当前数组索引、该索引处`data`数组中的值，以及直方图。注意，输出是制表符分隔的。这是通过使用`\t`转义序列实现的。
- en: Escape sequences
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 转义序列
- en: 'An escape sequence is a character preceded by a backslash. For example, `\t`
    is a valid escape sequence. When the compiler sees `\`, it peeks ahead at the
    next character and checks to see whether the two characters together form a valid
    escape sequence. Popular escape sequences are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 转义序列是前面带有反斜杠的字符。例如，`\t`是一个有效的转义序列。当编译器看到`\`时，它会向前查看下一个字符，并检查这两个字符是否组成一个有效的转义序列。常见的转义序列如下：
- en: '`\t`: Insert a tab at this point in the text'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`\t`: 在文本此点插入制表符'
- en: '`\b`: Insert a backspace at this point in the text'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`\b`: 在文本此点插入退格符'
- en: '`\n`: Insert a newline at this point in the text'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`\n`: 在文本此点插入换行符'
- en: '`\"`: Insert a double quote at this point in the text'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`\"`: 在文本此点插入双引号'
- en: '`\\`: Insert a backslash at this point in the text'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`\\`: 在文本此点插入反斜杠'
- en: 'They can be very useful in certain situations. For example, if we wanted to
    output the text *My name is “Alan”* (including the double quotes) to the screen,
    we would say:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，它们非常有用。例如，如果我们想将文本*我的名字是“Alan”*（包括双引号）输出到屏幕上，我们会说：
- en: '`System.out.println("My name` `is \"Alan\"");`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println("My name` `is \"Alan\"");`'
- en: If we did not escape the double quote before the `A` in `Alan` (in other words,
    if we tried `System.out.println("My name is "Alan"");`), then the double quote
    before the `A` would have been matched with the first `"` at the start of the
    string. This would have resulted in a compiler error with the `A` in `Alan`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在`Alan`中的`A`之前转义双引号（换句话说，如果我们尝试`System.out.println("My name is "Alan");`），那么`Alan`前的双引号将与字符串开头的第一个`"`匹配。这将导致编译器错误，错误出现在`Alan`中的`A`。
- en: By escaping the double quote before the `A` in `Alan`, the compiler no longer
    treats that double quote as an end-of-string double quote and instead inserts
    `"` into the string to be output. The same happens to the double quote after the
    `n` in `Alan`–it is also escaped and therefore ignored as an end-of-string double
    quote and inserted into the string to be output. The double quote just before
    the `)` is not escaped however, and is used to match the opening double quote
    for the string, namely the one just after the `(`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Alan`中的`A`之前跳过双引号，编译器不再将那个双引号视为字符串结束的双引号，而是将`"`插入到要输出的字符串中。同样，在`Alan`中的`n`之后的双引号也是如此——它也被跳过，因此被视为字符串结束的双引号并插入到要输出的字符串中。然而，在`)`之前的双引号没有被跳过，它被用来匹配字符串的开头双引号，即`(`之后的那个。
- en: 'The outer loop (lines 15-21) loops through the `data` array. As the array has
    4 elements, the valid indices are `0`, `1`, `2`, and `3`. These are the values
    that the `i` loop control variable, declared on line 15, will represent. Line
    16 outputs two of the columns: the current array index and the value at that index
    in the `data` array. For example, when `i` is `0` , `data[0]` is `9`, so `"0\t9\t"`
    is output; when `i` is `1`, `data[1]` is `3`, so `"1\t3\t"` is output, and so
    forth.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环（第15-21行）遍历`data`数组。由于数组有4个元素，有效的索引是`0`、`1`、`2`和`3`。这些是第15行声明的`i`循环控制变量将表示的值。第16行输出了两列：当前数组索引和`data`数组中该索引的值。例如，当`i`为`0`时，`data[0]`是`9`，所以输出`"0\t9\t"`；当`i`为`1`时，`data[1]`是`3`，所以输出`"1\t3\t"`，依此类推。
- en: The inner loop (lines 17-19) outputs the actual histogram as a horizontal row
    of stars. The inner loop control variable, `j`, goes from `1` to the value of
    `data[i]`. So, for example, if `i` is `0`, `data[i]` is `9`; therefore, `j` goes
    from `1` to `9`, outputting a star each time. Note that the `print()` method is
    used as opposed to `println()` – this is because `println()` automatically brings
    you on to the next line, whereas `print()` does not. As we want the stars to output
    horizontally, `print()` is exactly what we need. When we have our row of stars
    output, we execute `System.out.println()` (line 20), which brings us on to the
    next line.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 内层循环（第17-19行）输出实际的直方图，作为一排水平的星号。内层循环控制变量`j`从`1`到`data[i]`的值。例如，如果`i`是`0`，`data[i]`是`9`；因此，`j`从`1`到`9`，每次输出一个星号。请注意，使用的是`print()`方法而不是`println()`——这是因为`println()`会自动将你带到下一行，而`print()`则不会。由于我们希望星号水平输出，`print()`正是我们需要的。当我们输出一排星号后，我们执行`System.out.println()`（第20行），这会将我们带到下一行。
- en: '*Figure 5**.16* represents the output from the code in *Figure 5**.15*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.16*表示了*图5.15*中的代码输出。'
- en: '![Figure 5.16 – Output from the code in Figure 5.15](img/B19793_05_16.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16 – 图5.15中的代码输出](img/B19793_05_16.jpg)'
- en: Figure 5.16 – Output from the code in Figure 5.15
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 – 图5.15中的代码输出
- en: In this figure, you can see that the first column is the array index. The second
    column is the value in the `data` array at that index, and the third column is
    the histogram of stars based on the second column. So, for example, when `i` is
    `2`, `data[2]` is `5`, and we output a histogram of `5` stars.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，你可以看到第一列是数组索引。第二列是`data`数组在该索引处的值，第三列是基于第二列的星号直方图。例如，当`i`为`2`时，`data[2]`是`5`，我们输出一个包含`5`个星号的直方图。
- en: Now that we understand loops, we will move on to two keywords that are particularly
    relevant to loops, namely `break` and `continue`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了循环，我们将继续讨论两个与循环特别相关的关键字，即`break`和`continue`。
- en: break and continue statements
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: break和continue语句
- en: Both the `break` and `continue` statements can be used in loops but with very
    different semantics. In the code examples presented, nested loops will be used
    to contrast the labeled versions with the non-labeled versions. We will start
    with the `break` statement.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句都可以用在循环中，但它们的语义非常不同。在提供的代码示例中，我们将使用嵌套循环来对比带标签的版本和不带标签的版本。我们将从`break`语句开始。'
- en: break statements
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break语句
- en: We have already encountered `break` in `switch` statements. When used in a loop,
    the loop exits immediately. *Figure 5**.17* presents nested `for` loops with a
    `break` in the inner loop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`switch`语句中遇到了`break`。当在循环中使用时，循环会立即退出。*图5.17*展示了嵌套的`for`循环，其中内层循环有一个`break`。
- en: '![Figure 5.17 – Showing break inside a loop](img/B19793_05_17.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图5.17 – 展示循环中的break](img/B19793_05_17.jpg)'
- en: Figure 5.17 – Showing break inside a loop
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 – 展示循环中的break
- en: In this figure, the outer loop, controlled by `i`, loops from `1` to `3` in
    steps of 1\. The inner loop, controlled by `j`, loops from `1` to `5` in steps
    of 1.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，外循环由`i`控制，从`1`开始循环到`3`，每次增加1。内循环由`j`控制，从`1`开始循环到`5`，每次增加1。
- en: 'The `if` statement on line 16 becomes true when `j` is `3`. At this point,
    the `break` statement on line 17 is executed. A `break` without a label exits
    the nearest enclosing loop. In other words, the `break` on line 17 refers to the
    loop on line 15 (controlled by `j`). As there is no code between the closing `}`
    of both loops (lines 20 and 21), when `break` is executed in this program, the
    next line of code executed is the `}` for the outer loop (line 21). Automatically,
    the next iteration of the outer loop, `i++` (line 14), starts. In effect, there
    is never any `j` value of `3` or higher in the output because, when `j` is `3`,
    we `break` out of the inner loop and start with the next value of `i`. The output
    reflects this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行的`if`语句在`j`为`3`时变为真。此时，执行第17行的`break`语句。没有标签的`break`语句退出最近的包围循环。换句话说，第17行的`break`指的是第15行（由`j`控制）的循环。由于两个循环的结束`}`之间没有代码（第20行和第21行），当在这个程序中执行`break`时，接下来执行的代码是外循环的`}`（第21行）。自动地，外循环的下一个迭代`i++`（第14行）开始。实际上，输出中永远不会出现`j`值为`3`或更高的值，因为当`j`为`3`时，我们跳出内循环并从`i`的下一个值开始。输出反映了这一点：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Without any break statement, in other words, if we had commented out lines
    16 to 18, the output would be as follows (note the values of `j` go from 1 to
    5):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何`break`语句，换句话说，如果我们注释掉第16到18行，输出将如下（注意`j`的值从1到5）：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we discuss the labeled `break`, we will quickly discuss the label itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论带标签的`break`之前，我们将简要讨论标签本身。
- en: Label
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: 'A label is a case-sensitive identifier followed by a colon that immediately
    precedes the loop being identified. For example, the following code defines a
    valid label, `OUTER`, for the loop controlled by `i`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一个区分大小写的标识符，后跟一个冒号，紧接在要标识的循环之前。例如，以下代码为`i`控制的循环定义了一个有效的标签`OUTER`：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let us look at the labeled `break` itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看带标签的`break`本身。
- en: Labeled break
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带标签的断点
- en: A `break` that uses a label exits the loop identified by that label. The labeled
    `break` statement must be in the scope of the loop identified. In other words,
    you cannot `break` to a loop somewhere else in the code, completely unrelated
    to the current scope. *Figure 5**.18* is closely related to the code in *Figure
    5**.17*, except this time, a label and a labeled `break` are used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签的`break`语句退出由该标签标识的循环。带标签的`break`语句必须在该循环的范围内。换句话说，你不能将`break`到代码中的其他地方，与当前作用域完全不相关。*图5**.18*与*图5**.17*中的代码密切相关，但这次使用了标签和带标签的`break`。
- en: '![Figure 5.18 – Labeled break](img/B19793_05_18.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图5.18 – 带标签的断点](img/B19793_05_18.jpg)'
- en: Figure 5.18 – Labeled break
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 带标签的断点
- en: In the preceding figure, we have labeled, on line 26, the outer loop as `OUTERLOOP`.
    Yes, it took a while to come up with that identifier! Note that it is a compiler
    error to have any code between the label and the loop. That is why line 25 precedes
    the label.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们在第26行将外循环标记为`OUTERLOOP`。是的，想出这个标识符花了一些时间！请注意，在标签和循环之间有任何代码都是编译错误。这就是为什么第25行在标签之前的原因。
- en: 'The loop control variables, `i` and `j`, behave as before; `i` goes from `1`
    to `3` in steps of 1, and within each step of `i`, `j` goes from `1` to `5` in
    steps of 1\. This time, however, when `j` is `3` in the inner loop, rather than
    breaking out of the inner loop, we are breaking out of the outer loop. After the
    labeled `break` (line 30) is executed, there are no more iterations of `i` and
    the next line executed is `System.out.println("here")` on line 35\. As a result,
    the output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制变量`i`和`j`的行为与之前相同；`i`从`1`开始，每次增加1，直到`3`；在`i`的每个步骤中，`j`从`1`开始，每次增加1，直到`5`。然而，这次当内循环中的`j`为`3`时，我们不是跳出内循环，而是跳出外循环。在执行带标签的`break`（第30行）之后，不再有`i`的迭代，接下来执行的是第35行的`System.out.println("here")`。因此，输出如下：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As can be seen, once `j` reaches `3`, the outer loop exits, and `here` is output.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，一旦`j`达到`3`，外循环就会退出，并输出`here`。
- en: Now, let us look at `continue` statements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`continue`语句。
- en: continue statements
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: continue语句
- en: A `continue` statement can only occur inside a loop. When executed, `continue`
    says “skip to the *next* iteration” of the loop. Any other statements remaining
    in the current iteration are bypassed. There is a labeled version also. We will
    examine the unlabeled version first. *Figure 5**.19* presents an example of `continue`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句只能出现在循环内部。当执行时，`continue`表示“跳转到循环的*下一个*迭代”。当前迭代中剩余的任何其他语句都将被跳过。还有一个带标签的版本。我们将首先检查无标签版本。*图5**.19*展示了`continue`的一个示例。'
- en: '![Figure 5.19 – A continue example](img/B19793_05_19.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图5.19 – `continue`示例](img/B19793_05_19.jpg)'
- en: Figure 5.19 – A continue example
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – `continue`示例
- en: 'In the preceding figure, the nested loops are the same as before – the outer
    loop iterates from `1` to `3`; within that, the inner loop iterates from `1` to
    `5`. On this occasion, when `j` is `3`, we execute `continue`. What that means
    is that we jump to the end of the loop and the next statement executed is `j++`.
    This means that as line 38 is skipped, j with a value of 3 will never be output.
    The output demonstrates this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，嵌套循环与之前相同 – 外部循环从`1`迭代到`3`；在其内部，内部循环从`1`迭代到`5`。这次，当`j`为`3`时，我们执行`continue`。这意味着我们会跳到循环的末尾，接下来要执行的语句是`j++`。这意味着第38行将被跳过，值为3的`j`将永远不会被输出。输出展示了这一点：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As can be seen, `j` with a value of `3` is never output. Now, let us examine
    the labeled `continue`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，值为`3`的`j`永远不会被输出。现在，让我们检查带标签的`continue`。
- en: labeled continue
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带标签的`continue`
- en: A `continue` that uses a label continues the next iteration of the loop identified
    by that label. All other statements are bypassed. As with the labeled `break`,
    the labeled `continue` must be in the scope of the loop identified. *Figure 5**.20*
    is closely related to the code in *Figure 5**.19*, except this time, a label and
    a labeled `continue` are used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签的`continue`语句会继续执行由该标签标识的循环的下一个迭代。所有其他语句都将被跳过。与带标签的`break`语句一样，带标签的`continue`语句必须位于标识的循环的作用域内。*图5**.20*与*图5**.19*中的代码密切相关，但这次使用了标签和带标签的`continue`语句。
- en: '![Figure 5.20 – A labeled continue example](img/B19793_05_20.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20 – 带标签的`continue`示例](img/B19793_05_20.jpg)'
- en: Figure 5.20 – A labeled continue example
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – 带标签的`continue`示例
- en: 'In this figure, line 29 gives the `OUTERLOOP` label to the outer loop starting
    on line 30\. Now, when `j` is `3` and `continue OUTERLOOP` executes, the next
    line to code to execute is `i++`. Thus, every time `j` reaches `3`, we start with
    the next value of `i`. So, there are no values of `j` greater than `2` output,
    as can be seen in the output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第29行将`OUTERLOOP`标签赋予从第30行开始的循环。现在，当`j`为`3`且执行`continue OUTERLOOP`时，接下来要执行的代码行是`i++`。因此，每次`j`达到`3`时，我们都会从`i`的下一个值开始。所以，没有大于`2`的`j`值被输出，如输出所示：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That completes our explanations on the various looping constructs and the `break`
    and `continue` statements used with them. Let us now put that knowledge into practice
    to reinforce the concepts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对各种循环结构和与它们一起使用的`break`和`continue`语句的解释。现在让我们将这些知识付诸实践，以巩固这些概念。
- en: Exercises
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that we can iterate, it’s time to do some similar tasks to the chapters
    before but iterate for multiple values!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够迭代了，是时候做一些与之前章节类似但迭代多个值的任务了！
- en: 'Be creative on how to implement these ones and add context where you need it.
    As always, there’s not one right answer:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些时要有创意，并在需要的地方添加上下文。就像往常一样，没有唯一正确的答案：
- en: 'All of our dinosaurs are unique. Okay, we cloned their DNA, but still. Let’s
    say they have unique personalities. That’s why the IDs of all our dinosaurs are
    unique too: they are called `dino1`, `dino2`, `dino3`, and so on. Write a `for`
    loop that prints out the IDs of the first 100 dinosaurs in the park.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所有的恐龙都是独一无二的。好吧，我们克隆了它们的DNA，但仍然如此。假设它们有独特的个性。这就是为什么我们所有恐龙的ID都是独一无二的：它们被称为`dino1`、`dino2`、`dino3`等等。编写一个`for`循环，打印出公园前100只恐龙的ID。
- en: Some of our dinosaurs have large appetites! Write a `do-while` loop that continues
    to feed a dinosaur until it is no longer hungry.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的一些恐龙食量很大！编写一个`do-while`循环，持续给恐龙喂食，直到它不再饿。
- en: We all love the thrill of waiting for the park to open. Use a `while` loop to
    print out a countdown to the park’s opening time.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们都喜欢等待公园开门的刺激感。使用`while`循环打印出公园开门时间的倒计时。
- en: For planning purposes, it’s essential to know the total weight of all dinosaurs
    in a specific enclosure. Write a `for` loop that calculates this.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了规划目的，知道特定围栏中所有恐龙的总重量是至关重要的。编写一个`for`循环来计算这个值。
- en: Ticket selling can get hectic during the peak season. Write a `while` loop that
    simulates the park’s ticket-selling process until tickets are sold out.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旺季，售票可能会变得非常繁忙。编写一个`while`循环来模拟公园的售票过程，直到票售罄。
- en: Security is our topmost priority. Use a `do-while` loop to simulate a security
    check process that continues until all security measures are met.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全是我们最优先考虑的事项。使用`do-while`循环来模拟一个安全检查过程，直到所有安全措施都得到满足。
- en: Project – Dino meal planner
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 恐龙餐食计划
- en: Dinosaurs are not easy animals to keep. This is very advanced pet ownership.
    The right nutrition is difficult to manage, but it’s vital to their health and
    well-being. Therefore, you are asked to create a system that can manage the feeding
    schedule of our various dinosaur residents.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 恐龙不是容易饲养的动物。这是一项非常高级的宠物饲养。正确的营养管理很困难，但对于它们的健康和福祉至关重要。因此，你需要创建一个系统来管理我们各种恐龙居民的喂食时间表。
- en: The project’s primary goal is to create a program that calculates the meal portions
    and feeding times for each dinosaur. Since we haven’t covered arrays yet, we’ll
    focus on a single dinosaur for now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的首要目标是创建一个程序，计算每种恐龙的餐食分量和喂食时间。由于我们还没有介绍数组，我们现在将专注于单个恐龙。
- en: 'Here’s how we can do it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何做到这一点：
- en: Start by declaring a variable to hold the current time; let’s say it’s an integer
    and it goes from `0` (midnight) to `23` (last hour of the day).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先声明一个变量来保存当前时间；假设它是一个整数，从`0`（午夜）到`23`（一天中的最后一个小时）。
- en: Define variables for each dinosaur species with different feeding times. For
    example, T-Rex could eat at 8 (morning), 14 (afternoon), and 20 (evening), while
    the Brachiosaurus could eat at 7 (morning), 11 (mid-morning), 15 (afternoon),
    and 19 (evening).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种恐龙定义不同的喂食时间变量。例如，霸王龙可以在早上8点、下午2点以及晚上8点进食，而长颈龙可以在早上7点、上午11点、下午3点以及晚上7点进食。
- en: Next, establish a conditional statement (such as an `if-else` block) to check
    whether it’s feeding time for each species, comparing the current time with their
    feeding times.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，建立一个条件语句（例如`if-else`块）来检查是否是每种动物的喂食时间，比较当前时间与它们的喂食时间。
- en: Now, let’s define the feeding portions for our dinosaurs. We can assume that
    each species requires a different amount of food, depending on their sizes. For
    instance, the T-Rex requires 100 kg of food per meal, while the Brachiosaurus
    requires 250 kg of food per meal.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义恐龙的喂食分量。我们可以假设每种动物需要的食物量不同，这取决于它们的体型。例如，霸王龙每餐需要100公斤的食物，而长颈龙每餐需要250公斤的食物。
- en: Similarly, using an `if-else` block, check which species you are dealing with
    and assign the food portions accordingly.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，使用`if-else`块，检查你正在处理哪种动物，并相应地分配食物分量。
- en: Finally, print the result. For instance, `"It's 8:00 - Feeding time for T-Rex
    with 100kg` `of food"`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印结果。例如，`"现在是8:00 - 给重达100kg的霸王龙喂食时间"`。
- en: Wrap all of the preceding information inside a loop that runs from `0` to `23`,
    simulating the 24 hours in a day.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有上述信息包裹在一个从`0`到`23`的循环中，模拟一天中的24小时。
- en: 'On behalf of the hungry dinosaurs in the park: thank you so much for putting
    your Java skills to use!'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 代表公园里饥饿的恐龙们：非常感谢您将您的Java技能付诸实践！
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed how Java implements iteration (looping). We started
    with the `while` loop, which, because the condition is at the start of the loop,
    will execute zero or more times. In contrast, the `do-while` loop, where the condition
    is at the end of the loop, will execute one or more times. The `while` and `do-while`
    loops are very useful when you do not know how many times a loop will iterate.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Java如何实现迭代（循环）。我们从`while`循环开始，由于条件在循环的开始处，它将执行零次或多次。相比之下，`do-while`循环的条件在循环的末尾，它将执行一次或多次。`while`和`do-while`循环在你不知道循环将迭代多少次时非常有用。
- en: 'In contrast, the traditional `for` loop is extremely useful when you do know
    how often you want a loop executed. The traditional `for` loop’s header consists
    of three parts: the initialization section, the boolean expression, and the increment/decrement
    section. Thus, we can iterate a discrete number of times. This makes the traditional
    `for` loop ideal for processing arrays.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当你知道循环需要执行的频率时，传统的`for`循环非常有用。传统的`for`循环的头部由三部分组成：初始化部分、布尔表达式和增量/减量部分。因此，我们可以迭代一个离散的次数。这使得传统的`for`循环非常适合处理数组。
- en: The enhanced `for` (`for-each`) loop is even more suitable for processing arrays
    (and collections), provided you are not interested in the current loop iteration
    index. Being concise, succinct, and easy to write, it is a more elegant `for`
    loop.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的`for`（`for-each`）循环在处理数组（和集合）方面更加合适，前提是你不关心当前循环的迭代索引。它简洁、简明且易于编写，是一个更优雅的`for`循环。
- en: In effect, if you need to loop a specific number of times, use the traditional
    `for` loop. If you need to process an array/collection from the beginning all
    the way through to the end, with no concern for the loop index, use the enhanced
    `for` version.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你需要循环特定次数，请使用传统的`for`循环。如果你需要从开始到结束处理数组/集合，而不关心循环索引，请使用增强的`for`版本。
- en: All loops can, of course, be nested, and we looked at one such example. We defined
    a label as a case-sensitive identifier followed by a colon that immediately precedes
    a loop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有循环都可以嵌套，我们查看了一个这样的例子。我们定义标签为一个区分大小写的标识符，后跟一个冒号，该冒号紧接在循环之前。
- en: Nested loops and labels prepared us for our discussion regarding the `break`
    and `continue` keywords. Where `break` can also be used in a `switch` statement,
    `continue` can only be used inside loops. There are labeled and non-labeled versions
    of both. Regarding `break`, the unlabeled version exits the current loop, whereas
    the labeled version exits the identified loop. With regard to `continue`, the
    unlabeled version continues with the next iteration of the current loop, whereas
    the labeled version continues with the next iteration of the identified loop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环和标签为我们讨论`break`和`continue`关键字做好了准备。`break`也可以在`switch`语句中使用，而`continue`只能用于循环内部。两者都有带标签和不带标签的版本。关于`break`，不带标签的版本会退出当前循环，而带标签的版本会退出指定的循环。至于`continue`，不带标签的版本会继续当前循环的下一个迭代，而带标签的版本会继续指定循环的下一个迭代。
- en: That completes our discussion on iteration. In this chapter, we touched upon
    arrays. Moving on to our next chapter, [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118),
    we will cover arrays in detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了对迭代的讨论。在本章中，我们简要提到了数组。接下来，我们将进入下一章，[*第6章*](B19793_06.xhtml#_idTextAnchor118)，我们将详细讲解数组。
