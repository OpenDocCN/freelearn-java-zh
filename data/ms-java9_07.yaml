- en: Leveraging the New Default G1 Garbage Collector
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用新的默认G1垃圾回收器
- en: In the previous chapter, we examined **Java Shell** (**JShell**), Java 9's new
    **read-eval-print loop** (**REPL**) command-line tool. We started with introductory
    information regarding the tool and looked closely at the read-eval-print loop
    concept. We spent considerable time reviewing JShell commands and command-line
    options. Our coverage included practical guides to feedback modes, asset listing,
    and editing in the shell. We also gained experience working with scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们考察了**Java Shell**（**JShell**），Java 9的新**读取-评估-打印循环**（**REPL**）命令行工具。我们从关于该工具的简介开始，并仔细研究了读取-评估-打印循环的概念。我们花费了大量时间回顾JShell命令和命令行选项。我们的内容涵盖了反馈模式、资产列出和壳中编辑的实际指南。我们还获得了使用脚本的经验。
- en: In this chapter, we will take an in-depth look at **garbage collection** and
    how it is handled in Java 9\. We will start with an overview of garbage collection,
    and then look at specifics in the pre-Java 9 realm. Armed with that foundational
    information, we will look at specific garbage collection changes in the Java 9
    platform. Lastly, we will look at some garbage collection issues that persist,
    even after Java 9.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨**垃圾回收**及其在Java 9中的处理方式。我们将从垃圾回收的概述开始，然后探讨Java 9之前的特定细节。在掌握这些基础知识后，我们将查看Java
    9平台中的具体垃圾回收更改。最后，我们将探讨一些即使在Java 9之后仍然存在的问题。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了以下主题：
- en: Overview of garbage collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收概述
- en: The pre-Java 9 garbage collection schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9之前的垃圾回收方案
- en: Collecting garbage with the new Java platform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的Java平台收集垃圾
- en: Persistent issues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续问题
- en: Overview of garbage collection
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收概述
- en: Garbage collection is the mechanism used in Java to deallocate unused memory.
    Essentially, when an object is created, memory space is allocated and dedicated
    to that object until it no longer has any references pointing to it. At that time,
    the system deallocates the memory. Java performs this garbage collection automatically
    for us, which can lead to a lack of attention to memory usage and poor programming
    practices in the area of memory management and system performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是Java中用来释放未使用内存的机制。本质上，当创建一个对象时，会分配内存空间并专门用于该对象，直到没有任何引用指向它。那时，系统会释放内存。Java会自动为我们执行垃圾回收，这可能导致对内存使用缺乏关注，以及内存管理和系统性能方面的不良编程实践。
- en: Java's garbage collection is considered an automatic memory management schema
    because programmers do not have to designate objects as ready to be deallocated.
    The garbage collection runs on a low-priority thread and, as you will read later
    in this chapter, has variable execution cycles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java的垃圾回收被认为是一种自动内存管理方案，因为程序员不需要指定对象为准备释放的对象。垃圾回收在低优先级线程上运行，正如你将在本章后面读到的，它有可变的执行周期。
- en: 'In our overview of garbage collection, we will look at the following concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于垃圾回收的概述中，我们将探讨以下概念：
- en: Object life cycle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: Garbage collection algorithms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收算法
- en: Garbage collection options
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收选项
- en: Java methods relevant to garbage collection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与垃圾回收相关的Java方法
- en: We will look at each of these concepts in the sections that follow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中逐一探讨这些概念。
- en: Object life cycle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: In order to fully understand Java's garbage collection, we need to look at the
    entire life cycle of an object. Because the core of garbage collection is automatic
    in Java, it is not uncommon to see the terms *garbage collection* and *memory
    management* as assumed components of the object life cycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解Java的垃圾回收，我们需要查看对象的整个生命周期。因为Java中垃圾回收的核心是自动的，所以将“垃圾回收”和“内存管理”视为对象生命周期的假设组件并不罕见。
- en: We will start our review of the object life cycle with object creation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始回顾对象生命周期，从对象创建开始。
- en: Object creation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象创建
- en: 'Objects are declared and created. When we write an object declaration, or declare
    an object, we are declaring a name or identifier so that we can refer to an object.
    For example, the following line of code declares `myObjectName` as the name of
    an object of type `CapuchinMonkey`. At this point, no object was created and no
    memory allocated for it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的声明和创建。当我们编写对象声明或声明对象时，我们是在声明一个名称或标识符，以便我们可以引用对象。例如，以下代码行声明`myObjectName`为类型`CapuchinMonkey`的对象名称。此时，没有创建对象，也没有为其分配内存：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the `new` keyword to create an object. The following example illustrates
    how to invoke the `new` operation to create an object. This operation results
    in:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`new`关键字创建对象。以下示例说明了如何调用`new`操作来创建对象。此操作的结果是：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, we can combine the declaration and creation statements together by
    using `CapuchinMonkey myObjectName = new CapuchinMonkey();` instead of `CapuchinMonkey
    myObjectName;` and `myObjectName = new CapuchinMonkey();`. They were separated
    in the preceding example for illustrative purposes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过使用`CapuchinMonkey myObjectName = new CapuchinMonkey();`而不是`CapuchinMonkey
    myObjectName;`和`myObjectName = new CapuchinMonkey();`来合并声明和创建语句。前面的示例是为了说明目的而分开的。
- en: When an object is created, a specific amount of memory is allocated for storing
    that object. The amount of memory allocated can differ based on architecture and
    JVM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建对象时，为存储该对象分配特定数量的内存。分配的内存量可能因架构和JVM而异。
- en: Next look at the mid-life of an object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来看看对象的中期。
- en: Object mid-life
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象中期
- en: Objects are created and Java allocates system memory for storing that object.
    If the object is not used, the memory allocated to it is considered wasted. This
    is something we want to avoid. Even with small applications, this type of wasted
    memory can lead to poor performance and even out-of-memory issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象被创建，Java为存储该对象分配系统内存。如果该对象未被使用，分配给它的内存被认为是浪费的。这是我们想要避免的事情。即使是小型应用程序，这种类型的浪费内存也可能导致性能下降，甚至出现内存不足的问题。
- en: Our goal is to deallocate or release the memory, any previously allocated memory
    that we no longer need. Fortunately, with Java, there is a mechanism for handling
    this issue. It is called garbage collection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是释放或释放我们不再需要的任何先前分配的内存。幸运的是，在Java中，有一个处理此问题的机制。它被称为垃圾回收。
- en: When an object, such as our `myObjectName` example, no longer has any references
    pointing to it, the system will reallocate the associated memory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象，例如我们的`myObjectName`示例，不再有任何引用指向它时，系统将重新分配相关的内存。
- en: Object destruction
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象销毁
- en: The idea of Java having a garbage collector running in the dark shadows of your
    code (usually a low-priority thread) and deallocating memory currently allocated
    to unreferenced objects, is appealing. So, how does this work? The garbage collection
    system monitors objects and, as feasible, counts the number of references to each
    object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一个垃圾回收器在代码的暗影中运行（通常是一个低优先级线程）并释放当前分配给未引用对象的内存的想法是吸引人的。那么，这是如何工作的呢？垃圾回收系统监控对象，并在可行的情况下，计算每个对象的引用数量。
- en: When there are no references to an object, there is no way to get to it with
    the currently running code, so it makes perfect sense to deallocate the associated
    memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象没有引用时，无法通过当前运行的代码访问它，因此释放相关的内存是合理的。
- en: The term **memory leak** refers to small memory chunks to be lost or improperly
    deallocated. These leaks are avoidable with Java's garbage collection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存泄漏**这个术语指的是丢失或不当释放的小内存块。这些泄漏可以通过Java的垃圾回收避免。'
- en: Garbage collection algorithms
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收算法
- en: 'There are several garbage collection algorithms, or types, for use by the Java
    virtual machine. In this section, we will cover the following garbage collection
    algorithms:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机可以使用几种垃圾回收算法或类型。在本节中，我们将介绍以下垃圾回收算法：
- en: Mark and sweep
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记和清除
- en: CMS garbage collection
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS垃圾回收
- en: Serial garbage collection
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列垃圾回收
- en: Parallel garbage collection
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行垃圾回收
- en: G1 garbage collection
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1垃圾回收
- en: Mark and sweep
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记和清除
- en: 'Java''s initial garbage collection algorithm, *mark and sweep*, used a simple
    two-step process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java的初始垃圾回收算法*标记和清除*使用了一个简单的两步过程：
- en: Java first step, mark, is to step through all objects that have accessible references,
    marking those objects as alive.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java的第一步，标记，是遍历所有具有可访问引用的对象，将这些对象标记为存活。
- en: The second step, sweep, involves scanning the sea for any object that is not
    marked.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步，清除，涉及扫描未标记的任何对象。
- en: As you can readily determine, the mark and sweep algorithm seems effective,
    but probably not very efficient due to the two-step nature of this approach. This
    eventually lead to a Java garbage collection system with vastly improved efficiencies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所容易确定的，标记和清除算法似乎有效，但由于这种方法的两步性质，可能不是非常高效。这最终导致Java垃圾回收系统效率大幅提高。
- en: Concurrent mark sweep (CMS) garbage collection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发标记清除（CMS）垃圾回收
- en: The **concurrent mark sweep** (**CMS**) algorithm for garbage collection scans
    heap memory using multiple threads. Similar to the mark and sweep method, it marks
    objects for removal and then makes a sweep to actually remove those objects. This
    method of garbage collection is essentially an upgraded mark and sweep method.
    It was modified to take advantage of faster systems and had performance enhancements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收的**并发标记清除**（**CMS**）算法使用多个线程扫描堆内存。类似于标记和清除方法，它标记要删除的对象，然后进行清除以实际删除这些对象。这种垃圾回收方法本质上是对标记和清除方法的升级。它被修改以利用更快的系统并提高了性能。
- en: 'To manually invoke the concurrent mark sweep garbage collection algorithm for
    your application, use the following command-line option:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动调用应用程序的并发标记清除垃圾回收算法，请使用以下命令行选项：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to use the concurrent mark sweep garbage collection algorithm and
    dictate the number of threads to use, you can use the following command-line option.
    In the following example, we are telling the Java platform to use the concurrent
    mark sweep garbage collection algorithm with eight threads:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用并发标记清除垃圾回收算法并指定要使用的线程数，你可以使用以下命令行选项。在以下示例中，我们正在告诉Java平台使用并发标记清除垃圾回收算法并使用八个线程：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Serial garbage collection
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行垃圾回收
- en: Java's serial garbage collection works on a single thread. When executing, it
    freezes all other threads until garbage collection operations have concluded.
    Due to the thread-freezing nature of serial garbage collection, it is only feasible
    for very small programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java的串行垃圾回收在单个线程上工作。在执行时，它会冻结所有其他线程，直到垃圾回收操作完成。由于串行垃圾回收的线程冻结特性，它仅适用于非常小的程序。
- en: 'To manually invoke the serial garbage collection algorithm for your application,
    use the following command-line option:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动调用应用程序的串行垃圾回收算法，请使用以下命令行选项：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Parallel garbage collection
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行垃圾回收
- en: Prior to Java 9, the parallel garbage collection algorithm was the default garbage
    collector. It uses multiple threads but freezes all non-garbage collection threads
    in the application until garbage collection functions have completed, just like
    the serial garbage collection algorithm.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，并行垃圾回收算法是默认的垃圾回收器。它使用多个线程，但在垃圾回收功能完成之前，应用程序中的所有非垃圾回收线程都会被冻结，就像串行垃圾回收算法一样。
- en: G1 garbage collection
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1垃圾回收
- en: The G1 garbage collection algorithm was created for use with large memory heaps.
    This approach involves segmenting the memory heap into regions. Garbage collection,
    using the G1 algorithm, takes place in parallel with each heap region.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收算法是为使用大内存堆而创建的。这种方法涉及将内存堆分割成区域。使用G1算法进行垃圾回收时，每个堆区域都并行进行。
- en: Another part of the G1 algorithm is that when memory is deallocated, the heap
    space is compacted. Unfortunately, the compacting operation takes place using
    the *Stop the World* approach.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: G1算法的另一部分是，当内存被释放时，堆空间会被压缩。不幸的是，压缩操作使用的是**停止世界**方法。
- en: The G1 garbage collection algorithm also prioritizes the regions based on those
    that have the most garbage to be collected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收算法也根据需要收集最多垃圾的区域进行优先级排序。
- en: The G1 name refers to Garbage First.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: G1名称指的是垃圾优先。
- en: 'To manually invoke the G1 garbage collection algorithm for your application,
    use the following command-line option:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动调用应用程序的G1垃圾回收算法，请使用以下命令行选项：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Garbage collection options
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收选项
- en: 'Here is a list of JVM sizing options:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JVM尺寸选项列表：
- en: '| **Sizing description** | **JVM option flag** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **尺寸描述** | **JVM选项标志** |'
- en: '| Sets the initial heap size (young space plus tenured space). | `-XX:InitialHeapSize=3g`
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 设置初始堆大小（年轻代空间加老年代空间）。 | `-XX:InitialHeapSize=3g` |'
- en: '| Sets the maximum heap size (young space plus tenured space). | `-XX:MaxHeapSize=3g`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 设置最大堆大小（年轻代空间加老年代空间）。 | `-XX:MaxHeapSize=3g` |'
- en: '| Sets the initial and maximum heap size (young space plus tenured space).
    | `-Xms2048m -Xmx3g` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 设置初始和最大堆大小（年轻代空间加老年代空间）。 | `-Xms2048m -Xmx3g` |'
- en: '| Sets the initial size of young space. | `-XX:NewSize=128m` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 设置年轻代空间初始大小。 | `-XX:NewSize=128m` |'
- en: '| Sets the maximum size of young space. | `-XX:MaxNewSize=128m` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 设置年轻代空间最大大小。 | `-XX:MaxNewSize=128m` |'
- en: '| Sets young space size. Uses ration of young verses tenured space. In the
    sample flag to the right, `3` means that young space will be three times smaller
    than tenured space. | `-XX:NewRation=3` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 设置年轻代大小。使用年轻代与老年代的比例。在右侧的示例标志中，`3` 表示年轻代将是老年代的三分之一。 | `-XX:NewRation=3` |'
- en: '| Sets the size of single survivor space as a portion of Eden space size. |
    `-XX:SurvivorRatio=15` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 设置单存活空间大小为 Eden 空间大小的百分比。 | `-XX:SurvivorRatio=15` |'
- en: '| Sets the initial size of the permanent space. | `-XX:PermSize=512m` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 设置永久空间的初始大小。 | `-XX:PermSize=512m` |'
- en: '| Sets the maximum size of the permanent space. | `-XX:MaxPermSize=512m` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 设置永久空间的最大大小。 | `-XX:MaxPermSize=512m` |'
- en: '| Sets the size of the stack area dedicated to each thread in bytes. | `-Xss512k`
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 设置每个线程专用的堆栈区域大小，以 bytes 为单位。 | `-Xss512k` |'
- en: '| Sets the size of the stack area dedicated to each thread in Kbytes. | `-XX:ThreadStackSize=512`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 设置每个线程专用的堆栈区域大小，以 Kbytes 为单位。 | `-XX:ThreadStackSize=512` |'
- en: '| Sets the maximum size of off-heap memory available to the JVM. | `-XX:MaxDirectMemorySize=3g`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 设置 JVM 可用的最大堆外内存大小。 | `-XX:MaxDirectMemorySize=3g` |'
- en: 'Here is a list of young garbage collection options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是年轻代垃圾收集选项列表：
- en: '| **Young garbage collection tuning option** | **Flag** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **年轻代垃圾收集调优选项** | **标志** |'
- en: '| Sets the initial value for the number of collections before an object will
    be promoted from young to tenured space. This is referred to as the **tenuring
    threshold**. | `-XX:Initial\TenuringThreshold=16` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 设置对象从年轻代晋升到老年代之前收集的初始次数。这被称为 **晋升阈值**。 | `-XX:Initial\TenuringThreshold=16`
    |'
- en: '| Sets the maximum value for tenuring threshold. | `-XX:Max\TenuringThreshold=30`
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 设置晋升阈值的最大值。 | `-XX:Max\TenuringThreshold=30` |'
- en: '| Sets the maximum object size allowed to be allocated in young space. If an
    object is larger than the maximum size it will be allocated to tenured space and
    bypass young space. | `-XX:Pretenure\SizeThreshold=3m` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 设置允许在年轻代分配的最大对象大小。如果一个对象大于最大大小，它将被分配到老年代，并绕过年轻代。 | `-XX:Pretenure\SizeThreshold=3m`
    |'
- en: '| This can be used to promote all young objects surviving the young collection
    to tenured space. | `-XX:+AlwaysTenure` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 可以用于将所有在年轻代收集中存活的年轻对象晋升到老年代。 | `-XX:+AlwaysTenure` |'
- en: '| With this tag, objects from young space never get promoted to tenured space
    as long as the survivor space has sufficient room for them. | `-XX:+NeverTenure`
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 使用此标记，只要存活空间有足够的空间，年轻代中的对象就不会晋升到老年代。 | `-XX:+NeverTenure` |'
- en: '| We can indicate that we want to use thread local allocation blocks in the
    young space. This is enabled by default. | `-XX:+UseTLAB` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 我们可以指示我们希望在年轻代中使用线程本地分配块。这是默认启用的。 | `-XX:+UseTLAB` |'
- en: '| Toggle this to allow the JVM to adaptively resize the **TLAB** (**Thread
    Local Allocation Blocks**) for threads. | `-XX:+ResizeTLAB` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 切换此选项以允许 JVM 适应性地调整线程的 **TLAB** (**Thread Local Allocation Blocks**) 的大小。
    | `-XX:+ResizeTLAB` |'
- en: '| Sets the initial size of TLAB for a thread. | `-XX:TLABSize=2m` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 设置线程的 TLAB 初始大小。 | `-XX:TLABSize=2m` |'
- en: '| Sets the minimum allowable size of TLAB. | `-XX:MinTLABSize=128k` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 设置 TLAB 的最小允许大小。 | `-XX:MinTLABSize=128k` |'
- en: 'Here is a list of **concurrent mark sweep** (**CMS**) tuning options:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 **并发标记清除** (**CMS**) 调优选项列表：
- en: '| **CMS tuning option** | **Flag** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **CMS 调优选项** | **标志** |'
- en: '| Indicates that you want to solely use occupancy as a criterion for starting
    a CMS collection operation. | `-XX:+UseCMSInitiating\OccupancyOnly` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 指示您只想使用占用率作为启动 CMS 收集操作的准则。 | `-XX:+UseCMSInitiating\OccupancyOnly` |'
- en: '| Sets the percentage CMS generation occupancy to start a CMS collection cycle.
    If you indicate a negative number, you are telling the JVM you want to use `CMSTriggerRatio`.
    | `-XX:CMSInitiating\OccupancyFraction=70` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 设置启动 CMS 收集周期时 CMS 生成占用的百分比。如果您指示一个负数，您是在告诉 JVM 您想使用 `CMSTriggerRatio`。 |
    `-XX:CMSInitiating\OccupancyFraction=70` |'
- en: '| Sets the percentage CMS generation occupancy that you want to initiate a
    CMS collection for bootstrapping collection statistics. | `-XX:CMSBootstrap\Occupancy=10`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 设置 CMS 生成占用百分比，您希望为此启动 CMS 收集以启动收集统计信息。 | `-XX:CMSBootstrap\Occupancy=10`
    |'
- en: '| This is the percentage of `MinHeapFreeRatio` in CMS generation that is allocated
    prior to a CMS cycle starts. | `-XX:CMSTriggerRatio=70` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 这是 CMS 生成中 `MinHeapFreeRatio` 百分比在 CMS 周期开始前分配的百分比。 | `-XX:CMSTriggerRatio=70`
    |'
- en: '| Sets the percentage of `MinHeapFreeRatio` in the CMS permanent generation
    that is allocated before starting a CMS collection cycle. | `-XX:CMSTriggerPermRatio=90`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 设置 CMS 永久生成中 `MinHeapFreeRatio` 百分比在启动 CMS 收集周期前分配的百分比。 | `-XX:CMSTriggerPermRatio=90`
    |'
- en: '| This is the wait duration after a CMS collection is triggered. Use the parameter
    to specify how long the CMS is allowed to wait for young collection. | `-XX:CMSWaitDuration=2000`
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: 这是触发CMS收集后的等待时间。使用此参数指定CMS允许等待年轻收集的时间长度。| `-XX:CMSWaitDuration=2000` |
- en: '| Enables parallel remark. | `-XX:+CMSParallel\RemarkEnabled` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: 启用并行remark。| `-XX:+CMSParallelRemarkEnabled` |
- en: '| Enables parallel remark of survivor space. | `-XX:+CMSParallel\SurvivorRemarkEnabled`
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: 启用并行remark的幸存空间。| `-XX:+CMSParallelSurvivorRemarkEnabled` |
- en: '| You can use this to force young collection before the remark phase. | `-XX:+CMSScavengeBeforeRemark`
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: 您可以使用此选项在remark阶段之前强制进行年轻收集。| `-XX:+CMSScavengeBeforeRemark` |
- en: '| Use this to prevent scheduling remark if Eden used is below the threshold
    value. | `-XX:+CMSScheduleRemark\EdenSizeThreshold` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: 使用此选项以防止在Eden使用量低于阈值时调度remark。| `-XX:+CMSScheduleRemarkEdenSizeThreshold` |
- en: '| Sets the Eden occupancy percentage that you want CMS to try and schedule
    a remark pause. | `-XX:CMSScheduleRemark\EdenPenetration=20` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: 设置您希望CMS尝试调度remark暂停的Eden占用百分比。| `-XX:CMSScheduleRemarkEdenPenetration=20` |
- en: '| This is where you want to start sampling Eden top at least before young generation
    occupancy reaches *1/4*^(th) (in our sample to the right) of the size at which
    you want to schedule remark. | `-XX:CMSScheduleRemark\SamplingRatio=4` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: 这是在年轻代占用达到您想要调度remark的大小的1/4之前，您想要开始采样Eden顶部的位置。| `-XX:CMSScheduleRemarkSamplingRatio=4`
    |
- en: '| You can select `variant=1` or `variant=2` of verification following remark.
    | `-XX:CMSRemarkVerifyVariant=1` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: 您可以选择remark之后的`variant=1`或`variant=2`的验证。| `-XX:CMSRemarkVerifyVariant=1` |
- en: '| Elects to use the parallel algorithm for young space collection. | `-XX:+UseParNewGC`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: 选择使用并行算法进行年轻空间收集。| `-XX:+UseParNewGC` |
- en: '| Enables the use of multiple threads for concurrent phases. | `-XX:+CMSConcurrentMTEnabled`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: 启用并发阶段的多线程使用。| `-XX:+CMSConcurrentMTEnabled` |
- en: '| Sets the number of parallel threads used for the concurrent phases. | `-XX:ConcGCThreads=2`
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: 设置用于并发阶段的并行线程数。| `-XX:ConcGCThreads=2` |
- en: '| Sets the number of parallel threads you want used for *stop-the-world* phases.
    | `-XX:ParallelGCThreads=2` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: 设置您想要用于*stop-the-world*阶段的并行线程数。| `-XX:ParallelGCThreads=2` |
- en: '| You can enable **incremental CMS** (**iCMS**) mode. | `-XX:+CMSIncrementalMode`
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: 您可以启用**增量CMS**（**iCMS**）模式。| `-XX:+CMSIncrementalMode` |
- en: '| If this is not enabled, CMS will not clean permanent space. | `-XX:+CMSClassUnloadingEnabled`
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: 如果此选项未启用，CMS将不会清理永久空间。| `-XX:+CMSClassUnloadingEnabled` |
- en: '| This allows `System.gc()` to trigger concurrent collection instead of a full
    garbage collection cycle. | `-XX:+ExplicitGCInvokes\Concurrent` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: 这允许`System.gc()`触发并发收集而不是完整的垃圾收集周期。| `-XX:+ExplicitGCInvokesConcurrent` |
- en: '| This allows `System.gc()` to trigger concurrent collection of permanent space.
    | `‑XX:+ExplicitGCInvokes\ConcurrentAndUnloadsClasses` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: 这允许`System.gc()`触发永久空间的并发收集。| `-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses`
    |
- en: '**iCMS** (**incremental concurrent mark sweep**) mode is intended for servers
    with a small number of CPUs. It should not be employed on modern hardware.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**iCMS**（**增量并发标记清除**）模式适用于CPU数量较少的服务器。它不应在现代硬件上使用。'
- en: 'Here are some miscellaneous garbage collection options:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些杂项垃圾收集选项：
- en: '| **Miscellaneous garbage collection options** | **Flag** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '**杂项垃圾收集选项** | **标志** |'
- en: '| This will cause the JVM to ignore any `System.gc()` method invocations by
    an application. | `-XX:+DisableExplicitGC` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: 这将导致JVM忽略应用程序对`System.gc()`方法的任何调用。| `-XX:+DisableExplicitGC` |
- en: '| This is the (soft reference) time to live in milliseconds per MB of free
    space in the heap. | `-XX:SoftRefLRU\PolicyMSPerMB=2000` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: 这是堆中每MB空闲空间（软引用）的存活时间（以毫秒计）。| `-XX:SoftRefLRUPolicyMSPerMB=2000` |
- en: '| This is the **use policy** used to limit the time spent in garbage collection
    before an `OutOfMemory` error is thrown. | `-XX:+UseGCOverheadLimit` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: 这是抛出`OutOfMemory`错误之前限制垃圾收集时间的**使用策略**。| `-XX:+UseGCOverheadLimit` |
- en: '| This limits the proportion of time spent in garbage collection before an
    `OutOfMemory` error is thrown. This is used with `GCHeapFreeLimit`. | `-XX:GCTimeLimit=95`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: 这限制了在抛出`OutOfMemory`错误之前垃圾收集所花费的时间比例。这通常与`GCHeapFreeLimit`一起使用。| `-XX:GCTimeLimit=95`
    |
- en: '| This sets the minimum percentage of free space after a full garbage collection
    before an `OutOfMemory` error is thrown. This is used with `GCTimeLimit`. | `-XX:GCHeapFreeLimit=5`
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: 这设置了在抛出`OutOfMemory`错误之前，完整垃圾收集后空闲空间的最低百分比。这通常与`GCTimeLimit`一起使用。| `-XX:GCHeapFreeLimit=5`
    |
- en: 'Finally, here are some G1 specific options. Note that, these are all supported
    starting with JVM 6u26:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些G1特定的选项。请注意，这些选项从JVM 6u26开始都得到了支持：
- en: '| **G1 garbage collection options** | **Flag** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **G1垃圾回收选项** | **标志** |'
- en: '| Size of the heap region. The default is 2,048 and the acceptable range is
    1 MiB to 32 MiB. | `-XX:G1HeapRegionSize=16m` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 堆区域的大小。默认值为2,048，可接受的范围是1 MiB到32 MiB。 | `-XX:G1HeapRegionSize=16m` |'
- en: '| This is the confidence coefficient pause prediction heuristics. | `-XX:G1ConfidencePercent=75`
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 这是暂停预测启发式算法的置信系数。 | `-XX:G1ConfidencePercent=75` |'
- en: '| This determines the minimum reserve in the heap. | `-XX:G1ReservePercent=5`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 这决定了堆中的最小预留。 | `-XX:G1ReservePercent=5` |'
- en: '| This is the garbage collection time per MMU--time slice in milliseconds.
    | `-XX:MaxGCPauseMillis=100` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 这是每个MMU的垃圾回收时间片（以毫秒为单位）。 | `-XX:MaxGCPauseMillis=100` |'
- en: '| This is the pause interval time slice per MMU in milliseconds. | `-XX:GCPauseIntervalMillis=200`
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 这是每个MMU的暂停间隔时间片（以毫秒为单位）。 | `-XX:GCPauseIntervalMillis=200` |'
- en: '**MiB** stands for **Mebibyte** which is a multiple of bytes for digital information.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**MiB**代表**Mebibyte**，是数字信息的字节倍数。'
- en: Java methods relevant to garbage collection
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与垃圾回收相关的Java方法
- en: Let's look at two specific methods associated with garbage collection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与垃圾回收相关的两个特定方法。
- en: The System.gc() method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.gc()方法
- en: 'Although garbage collection is automatic in Java, you can make explicit calls
    to the `java.lang.System.gc()` method to aid in the debugging process. This method
    does not take any parameters and does not return any value. It is an explicit
    call that runs Java''s garbage collector. Here is a sample implementation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java中的垃圾回收是自动的，但你可以通过显式调用`java.lang.System.gc()`方法来帮助调试过程。此方法不接受任何参数，也不返回任何值。这是一个显式调用，它会运行Java的垃圾回收器。以下是一个示例实现：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s look at a more in-depth example. In the following code, we start by
    creating an instance of the `Runtime`, using `Runtime myRuntime = Runtime.getRuntime();`
    which returns a singleton. This gives us access to the JVM. After printing some
    header information and initial memory stats, we create an `ArrayList` with a size
    of `300000`. Then, we create a loop that generates `100000` array list objects.
    Lastly, we provide output in three passes, asking the JVM to invoke the garbage
    collector with `1` second pauses in between. Here is the source code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更深入的例子。在以下代码中，我们首先通过`Runtime myRuntime = Runtime.getRuntime();`创建`Runtime`的一个实例，这返回一个单例。这使我们能够访问JVM。在打印一些标题信息和初始内存统计信息之后，我们创建了一个大小为`300000`的`ArrayList`。然后，我们创建一个循环，生成`100000`个数组列表对象。最后，我们在三个遍历中提供输出，在每次遍历之间请求JVM调用垃圾回收器，每次暂停`1`秒。以下是源代码：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from the following output, the garbage collector did not reallocate
    all of the ''garbage'' during the first or even the second pass:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下输出中看到的，垃圾回收器在第一次甚至第二次遍历中并没有重新分配所有的'垃圾'：
- en: '![](img/e4940c1f-fd9d-462d-b72b-7adfd6cf8ee0.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4940c1f-fd9d-462d-b72b-7adfd6cf8ee0.png)'
- en: There is an alternative to using the `System.gc()` method to invoke the garbage
    collector. In our example, we could have used `myRuntime.gc()`, our earlier singleton
    example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`System.gc()`方法调用垃圾回收器有一个替代方案。在我们的例子中，我们可以使用`myRuntime.gc()`，我们之前的单例示例。
- en: The finalize() method
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: finalize()方法
- en: You can think of Java's garbage collector as a death dealer. When it removes
    something from memory, it is gone. This so-called death dealer is not without
    compassion as it provides each method with their final last words. The objects
    give their *last words* through a `finalize()` method. If an object has a `finalize()`
    method, the garbage collector invokes it before the object is removed and the
    associated memory deallocated. The method takes no parameters and has a return
    type of `void`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Java的垃圾回收器想象成一个死亡使者。当它从内存中移除某个东西时，它就消失了。这个所谓的死亡使者并非没有同情心，因为它为每个方法提供了最后的遗言。对象通过`finalize()`方法给出他们的*最后遗言*。如果一个对象有`finalize()`方法，垃圾回收器在对象被移除和关联内存释放之前会调用它。此方法不接受任何参数，返回类型为`void`。
- en: The `finalize()` method is only called once and there can be variability when
    it is run. Certainly, the method is invoked before it is removed, but when the
    garbage collector runs is dependent on the system. If, as an example, you have
    a relatively small app that is running a memory-rich system, the garbage collector
    might not run at all. So, why include a `finalize()` method at all? It is considered
    poor programming practice to override the `finalize()` method. That being said,
    you can use the method if needed. In fact, you can add code there to add a reference
    to your object to ensure it is not removed by the garbage collector. Again, this
    is not advisable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize()`方法只调用一次，其运行时可能会有所不同。当然，该方法在移除之前会被调用，但垃圾回收器何时运行取决于系统。例如，如果你有一个相对较小的应用程序，在运行内存丰富的系统上，垃圾回收器可能根本不会运行。那么，为什么还要包含一个`finalize()`方法呢？重写`finalize()`方法被认为是一种不良的编程实践。尽管如此，如果需要，你仍然可以使用该方法。实际上，你可以在那里添加代码，添加对对象的引用以确保它不会被垃圾回收器移除。再次强调，这并不建议。'
- en: Because all objects in Java, even the ones you create yourself are child classes
    of `java.lang.Object`, every object in Java has a `finalize()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Java中的所有对象，即使是你自己创建的对象，都是`java.lang.Object`的子类，所以Java中的每个对象都有一个`finalize()`方法。
- en: The garbage collector, as sophisticated as it is, might not close databases,
    files, or network connections the way you want it done. If your application requires
    specific considerations when its objects are collected, you can override the object's
    `finalize()` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管垃圾回收器非常复杂，但它可能不会以你想要的方式关闭数据库、文件或网络连接。如果你的应用程序在对象被回收时需要特定的考虑，你可以重写对象的`finalize()`方法。
- en: 'Here is an example implementation that demonstrates a use case for when you
    might want to override an object''s `finalize()` method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例实现，演示了当你可能想要重写对象的`finalize()`方法时的用例：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding code, the `objectTally` count is incremented
    each time an object of type `Animal` is created and decremented when one is removed
    by the garbage collector.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，每当创建一个类型为`Animal`的对象时，`objectTally`计数就会增加，而当垃圾回收器移除一个对象时，计数就会减少。
- en: Overriding an object's `finalize()` method is usually discouraged. The `finalize()`
    method should normally be declared as `protected`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重写对象的`finalize()`方法通常是不被推荐的。`finalize()`方法通常应该声明为`protected`。
- en: Pre-Java 9 garbage collection
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的垃圾回收
- en: Java's garbage collection is not new to Java 9, it has existed since the initial
    release of Java. Java has long had a sophisticated garbage collection system that
    is automatic and runs in the background. By running in the background, we are
    referring to garbage collection processes running during idle times.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Java的垃圾回收并非Java 9的新特性，它自Java初始发布以来就存在。Java长期以来一直拥有一个复杂的垃圾回收系统，它是自动的，在后台运行。我们所说的后台运行，是指垃圾回收过程在空闲时间运行。
- en: Idle times refer to the time in between input/output such as between keyboard
    input, mouse clicks, and output generation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲时间指的是输入/输出之间的时间，例如键盘输入、鼠标点击和输出生成之间。
- en: This automatic garbage collection has been one of the key factors in developers
    selecting Java for their programming solutions. Other programming languages such
    as C# and Objective-C have implemented garbage collection following the success
    of the Java platform.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动垃圾回收一直是开发者选择Java作为编程解决方案的关键因素之一。其他编程语言，如C#和Objective-C，在Java平台成功之后也实现了垃圾回收。
- en: 'Let''s next take a look at the following listed concepts before we look at
    the changes to garbage collection in the Java 9 platform:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看Java 9平台垃圾回收变化之前，先让我们看一下以下列出的概念：
- en: Visualizing garbage collection
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化垃圾回收
- en: Garbage collection upgrades in Java 8
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8的垃圾回收升级
- en: Case study - Games written with Java
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 - 使用Java编写的游戏
- en: Visualizing garbage collection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化垃圾回收
- en: 'It can be helpful to visualize how garbage collection works and, perhaps more
    importantly, the need for it. Consider the following code snippet that progressively
    creates the string `Garbage`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化垃圾回收的工作原理以及它的重要性可能会有所帮助。考虑以下代码片段，它逐步创建字符串`Garbage`：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clearly, the preceding code generates the output provided as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前述代码按照以下方式生成提供的输出：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What might not be clear is that the sample code results in five unreferenced
    string objects. This is due, in part, because strings are immutable. As you can
    see in the following illustration, with each successive line of code, the referenced
    object is updated and an additional object becomes unreferenced:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不清楚的是，示例代码导致五个未引用的字符串对象。这部分原因是字符串是不可变的。正如您在下图中可以看到的，随着每一行代码的连续执行，引用的对象被更新，并且一个额外的对象变为未引用：
- en: '![](img/b31863c4-6d01-4bc9-b7f2-7a28ca5c54a1.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b31863c4-6d01-4bc9-b7f2-7a28ca5c54a1.png)'
- en: The preceding unreferenced objects listed certainly will not break the memory
    bank, but it is indicative of how quickly a large number of unreferenced objects
    can accumulate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的先前未引用的对象当然不会打破内存银行，但它表明大量未引用对象可以迅速积累。
- en: Garbage collection upgrades in Java 8
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8中的垃圾回收升级
- en: 'As of Java 8, the default garbage collection algorithm was the parallel garbage
    collector. Java 8 was released with some improvements to the G1 garbage collection
    system. One of these improvements was the ability to use the following command-line
    option to optimize the heap memory by removing duplicative string values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Java 8，默认的垃圾回收算法是并行垃圾回收器。Java 8的发布带来了一些对G1垃圾回收系统的改进。这些改进之一是能够使用以下命令行选项通过删除重复的字符串值来优化堆内存：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The G1 garbage collector can view the character arrays when it sees a string.
    It then takes the value and stores it with a new, weak reference to the character
    array. If the G1 garbage collector finds a string with the same hash code, it
    will compare the two strings with a character-by-character review. If a match
    is found, both strings end up pointing to the same character array. Specifically,
    the first string will point to the character array of the second string.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收器可以在看到字符串时查看字符数组。然后它将值存储起来，并使用一个新的弱引用将字符数组存储起来。如果G1垃圾回收器找到一个具有相同哈希码的字符串，它将逐字符比较这两个字符串。如果找到匹配项，两个字符串最终都会指向同一个字符数组。具体来说，第一个字符串将指向第二个字符串的字符数组。
- en: This method can require substantial processing overhead and should only be used
    if deemed beneficial or absolutely necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可能需要大量的处理开销，并且只有在被认为有益或绝对必要时才应使用。
- en: Case study - Games written with Java
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 - 使用Java编写的游戏
- en: Multiplayer games require extensive management techniques, both for server and
    client systems. The JVM runs the garbage collection thread in a low-priority thread
    and periodically runs. Server administrators previously used an incremental garbage
    collection schema using the now depreciated `-Xincgc` command-line option to avoid
    **server stalls** that occur when the server is overloaded. The goal is to have
    garbage collection run more frequently and with much shorter execution cycles
    each time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 多玩家游戏需要广泛的管理技术，包括服务器和客户端系统。JVM以低优先级线程运行垃圾回收线程，并定期运行。服务器管理员以前使用现在已废弃的`-Xincgc`命令行选项来避免服务器过载时发生的**服务器停滞**。目标是让垃圾回收更频繁地运行，并且每次执行周期都更短。
- en: When considering memory usage and garbage collection, it is important to use
    as little memory on the target system as possible and to limit pauses for garbage
    collection to the extent feasible. These tips are especially important for games,
    simulations, and other applications that require real-time performance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑内存使用和垃圾回收时，尽可能在目标系统上使用最少的内存，并在可行范围内将垃圾回收的暂停时间限制到最小。这些技巧对于需要实时性能的游戏、模拟和其他应用程序尤为重要。
- en: The JVM manages the heap where Java memory is stored. The JVM starts with a
    small heap by default and grows as additional objects are created. The heap has
    two partitions--young and tenured. When objects are initially created, they are
    created in the young partition. Persistent objects are moved to the tenure partition.
    The creation of objects is usually very quick with not much more than pointer
    incrementation. Processing in the young partition is much faster than that of
    the tenured partition. This is important because it applies to the overall app,
    or in our case, a game's efficiency.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: JVM管理存储Java内存的堆。JVM默认以一个小堆开始，随着新对象的创建而增长。堆分为两个部分——年轻代和旧代。当对象最初创建时，它们在年轻代中创建。持久对象会被移动到旧代。对象的创建通常非常快，只需指针增量即可。年轻代的处理速度比旧代快得多。这很重要，因为它适用于整个应用程序，或者在我们的情况下，是一个游戏的效率。
- en: 'It becomes important for us to monitor our game''s memory usage and when garbage
    collection occurs. To monitor garbage collection, we can add the verbose flag
    (`-verbose:gc`) when we launch our game such as with the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，监控游戏的内存使用情况和垃圾回收发生时变得很重要。为了监控垃圾回收，我们可以在启动游戏时添加详细标志（`-verbose:gc`），如下例所示：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The JVM will then provide a line of formatted output for each garbage collection.
    Here is the format of the verbose GC output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将为每次垃圾回收提供一行格式化的输出。以下是详细GC输出的格式：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at two examples. In this first example, we see `GC` for type which
    refers to the young partition we previously discussed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个例子。在这个第一个例子中，我们看到`GC`类型指的是我们之前讨论过的年轻代分区：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this second example, `Full GC` indicates that the garbage collection action
    was taken on the tenured partition of the memory heap:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个例子中，`Full GC`表示对内存堆的持久代进行了垃圾回收操作：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can obtain more detailed information from the garbage collector using the
    `-XX:+PrintGCDetails` option as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-XX:+PrintGCDetails`选项从垃圾收集器获取更多详细信息，如下所示：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Collecting garbage with the new Java platform
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的Java平台收集垃圾
- en: 'Java came out of the gate with automatic garbage collection, making it a development
    platform of choice for many programmers. It was commonplace to want to avoid manual
    memory management in other programming languages. We have looked in-depth at the
    garbage collection system to include the various approaches, or algorithms, used
    by the JVM. Java 9 includes some relevant changes to the garbage collection system
    and was the focus of three **Java Enhancement Program** (**JEP**) issues. Those
    issues are listed here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java一开始就提供了自动垃圾回收功能，使其成为许多程序员的开发平台选择。在其它编程语言中避免手动内存管理变得司空见惯。我们已经深入研究了垃圾回收系统，包括JVM使用的各种方法或算法。Java
    9对垃圾回收系统进行了一些相关更改，并成为三个**Java增强计划**（**JEP**）问题的焦点。这些问题如下所示：
- en: Default garbage collection (JEP 248)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认垃圾回收（JEP 248）
- en: Depreciated garbage collection combinations (JEP 214)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的垃圾回收组合（JEP 214）
- en: Unified garbage collection logging (JEP 271)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一垃圾回收日志（JEP 271）
- en: We will review each one of these garbage collection concepts and their corresponding
    **Java Enhancement Plan** (**JEP**) issue in the following sections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中回顾这些垃圾回收概念及其相应的**Java增强计划**（**JEP**）问题。
- en: Default garbage collection
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认垃圾回收
- en: 'We previously detailed the following garbage collection approaches used by
    the JVM prior to Java 9\. These are still plausible garbage collection algorithms:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前详细介绍了Java 9之前JVM使用的以下垃圾回收方法。这些仍然是可能的垃圾回收算法：
- en: CMS garbage collection
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS垃圾回收
- en: Serial garbage collection
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行垃圾回收
- en: Parallel garbage collection
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行垃圾回收
- en: G1 garbage collection
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1垃圾回收
- en: 'Let''s briefly recap each of these approaches:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这些方法：
- en: '**CMS garbage collection**: The CMS garbage collection algorithm scans heap
    memory using multiple threads. Using this approach, the JVM marks objects for
    removal and then makes a sweep to actually remove them.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMS垃圾回收**：CMS垃圾回收算法使用多个线程扫描堆内存。使用这种方法，JVM标记对象以供删除，然后进行清理以实际删除它们。'
- en: '**Serial garbage collection**: This approach uses a thread-freezing schema
    on a single thread. When the garbage collection is in progress, it freezes all
    other threads until garbage collection operations have concluded. Due to the thread-freezing
    nature of serial garbage collection, it is only feasible for very small programs.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行垃圾回收**：这种方法在单个线程上使用无线程冻结模式。当垃圾回收正在进行时，它会冻结所有其他线程，直到垃圾回收操作完成。由于串行垃圾回收的线程冻结特性，它仅适用于非常小的程序。'
- en: '**Parallel garbage collection**: This approach uses multiple threads but freezes
    all non-garbage collection threads in the application until garbage collection
    functions have completed, just like the serial garbage collection algorithm.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行垃圾回收**：这种方法使用多个线程，但在垃圾回收功能完成之前，冻结应用程序中的所有非垃圾回收线程，就像串行垃圾回收算法一样。'
- en: '**G1 garbage collection**: This is the garbage collection algorithm with the
    following characteristics:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**G1垃圾回收**：这是具有以下特性的垃圾回收算法：'
- en: Is used with large memory heaps
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于大内存堆
- en: Involves segmenting the memory heap into regions
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及将内存堆分割成区域
- en: Takes place in parallel with each heap region
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与每个堆区域并行进行
- en: Compacts the heap space when memory is deallocated
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存释放时压缩堆空间
- en: Compacting operations take place using the *Stop the World* approach
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*停止世界*方法进行压缩操作
- en: Prioritizes the regions based on those that have the most garbage to be collected
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据收集垃圾量最多的区域进行优先级排序
- en: Prior to Java 9, the parallel garbage collection algorithm was the default garbage
    collector. In Java 9, the G1 garbage collector is the new default implementation
    of Java's memory management system. This is true for both 32 and 64-bit server
    configurations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，并行垃圾收集算法是默认的垃圾收集器。在Java 9中，G1垃圾收集器是Java内存管理系统的新的默认实现。这对于32位和64位服务器配置都适用。
- en: 'Oracle assessed that the G1 garbage collector, mostly due to its low-pause
    nature, was a better performing garbage collection method than the parallel approach.
    This change was predicated on the following concepts:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle评估认为，由于G1垃圾收集器的低暂停特性，它比并行方法是一个更好的垃圾收集方法。这一变化基于以下概念：
- en: It is important to limit latency
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制延迟很重要
- en: Maximizing throughput is less important than limiting latency
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化吞吐量不如限制延迟重要
- en: The G1 garbage collection algorithm is stable
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1垃圾收集算法是稳定的
- en: 'There are two assumptions involved with making the G1 garbage collection method
    the default method over the parallel approach:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在将G1垃圾收集方法作为默认方法而非并行方法时，涉及两个假设：
- en: Making G1 the default garbage collection method will significantly increase
    its use. This increased usage might unveil performance or stability issues not
    realized before Java 9.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将G1作为默认的垃圾收集方法将显著增加其使用。这种增加的使用可能会揭示在Java 9之前未意识到的性能或稳定性问题。
- en: The G1 approach is more processor-intensive than the parallel approach. In some
    use cases, this could be somewhat problematic.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与并行方法相比，G1方法对处理器的需求更高。在某些用例中，这可能会有些问题。
- en: On the surface this change might seem like a great step for Java 9 and that
    very well might be the case. Caution, however, should be used when blindly accepting
    this new default collection method. It is recommended that systems be tested if
    switching to G1 to ensure your applications do not suffer from performance degradation
    or have unexpected issues that are caused by the use of G1\. As previously suggested,
    G1 has not benefited from the widespread testing that the parallel method has.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这个变化可能对Java 9来说是一个巨大的进步，而且这完全可能是事实。然而，在盲目接受这个新的默认收集方法时，应该保持谨慎。建议在切换到G1时测试系统，以确保您的应用程序不会因性能下降或由G1使用引起的不预期的问题而受到影响。如前所述，G1没有像并行方法那样受益于广泛的测试。
- en: This last point about the lack of widespread testing is significant. Making
    G1 the default automatic memory management (garbage collection) system with Java
    9 is tantamount to turning developers into unsuspecting testers. While no major
    problems are expected, knowing that there is potential for performance and stability
    issues when using G1 with Java 9 will place greater emphasis on testing your Java
    9 applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缺乏广泛测试的最后一个观点具有重要意义。在Java 9中将G1作为默认的自动内存管理（垃圾收集）系统，相当于将开发者变成了不知情的测试者。虽然预期不会有重大问题，但知道在使用Java
    9时G1可能存在性能和稳定性问题，这将使测试您的Java 9应用程序更加重要。
- en: Depreciated garbage collection combinations
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 废弃的垃圾收集组合
- en: 'Oracle has been great about depreciating features, APIs, and libraries before
    removing them from a new release to the Java platform. With this schema in place,
    language components that were depreciated in Java 8 are subject for removal in
    Java 9\. There are a few garbage collection combinations that were deemed to be
    rarely used and depreciated in Java 8\. Those combinations, listed here, have
    been removed in Java 9:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在从Java平台的新版本中删除功能、API和库之前，一直很擅长废弃它们。有了这个方案，Java 8中废弃的语言组件将在Java 9中面临被移除的问题。有一些垃圾收集组合被认为很少使用，并在Java
    8中被废弃。这些组合，如下所示，已在Java 9中被移除：
- en: DefNew + CMS
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DefNew + CMS
- en: ParNew + SerialOld
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ParNew + SerialOld
- en: Incremental CMS
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量CMS
- en: These combinations, in addition to having been rarely used, introduced an unneeded
    level of complexity to the garbage collection system. This resulted in an extra
    drain on system resources without providing a commensurate benefit to the user
    or developer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合，除了很少使用外，还给垃圾收集系统引入了一个不必要的复杂性级别。这导致了对系统资源的额外消耗，而没有为用户或开发者提供相应的利益。
- en: 'The following listed garbage collection configurations were affected by the
    aforementioned depreciation in the Java 8 platform:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的垃圾收集配置受到了Java 8平台上述弃用的 影响：
- en: '| **Garbage collection configuration** | **Flag(s)** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **垃圾收集配置** | **标志** |'
- en: '| DefNew + CMS | `-XX:+UseParNewGC``-XX:UseConcMarkSweepGC` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| DefNew + CMS | `-XX:+UseParNewGC``-XX:UseConcMarkSweepGC` |'
- en: '| ParNew + SerialOld | `-XX:+UseParNewGC` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ParNew + SerialOld | `-XX:+UseParNewGC` |'
- en: '| ParNew + iCMS | `-Xincgc` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| ParNew + iCMS | `-Xincgc` |'
- en: '| ParNew + iCMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| ParNew + iCMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC` |'
- en: '| Defnew + ICMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC``-XX:-UseParNewGC`
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| Defnew + ICMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC``-XX:-UseParNewGC`
    |'
- en: 'The **Java Enhancement Program 214** (**JEP 214**) removed garbage collection
    combinations depreciated in JDK 8\. Those combinations are listed above along
    with the flags that control those combinations. In addition, the flags to enable
    CMS foreground collections were removed and are not present in JDK 9\. Those flags
    are listed as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java增强计划214**（**JEP 214**）移除了JDK 8中弃用的垃圾收集组合。这些组合在上文列出，并列出了控制这些组合的标志。此外，移除了启用CMS前台收集的标志，并且不在JDK
    9中存在。以下列出了这些标志：'
- en: '| **Garbage collection combinations** | **Flag** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **垃圾收集组合** | **标志** |'
- en: '| CMS foreground | `-XX:+UseCMSCompactAtFullCollection` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| CMS foreground | `-XX:+UseCMSCompactAtFullCollection` |'
- en: '| CMS foreground | `-XX+CMSFullGCsBeforeCompaction` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| CMS foreground | `-XX+CMSFullGCsBeforeCompaction` |'
- en: '| CMS foreground | `-XX+UseCMSCollectionPassing` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| CMS foreground | `-XX+UseCMSCollectionPassing` |'
- en: The only assessed downside to the removal of the depreciated garbage collection
    combinations is that applications that use JVM start up files with any of the
    flags listed in this section, will need to have their JVM start up files modified
    to remove or replace the old flags.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 移除已弃用的垃圾收集组合的唯一不利之处在于，使用本节中列出的任何标志的JVM启动文件的应用程序，需要修改它们的JVM启动文件以删除或替换旧标志。
- en: Unified garbage collection logging
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一垃圾收集日志
- en: 'The **Java Enhancement Program #271** (**JEP-271**) titled, *Unified GC Logging*,
    is intended to re-implement garbage collection logging using the unified JVM logging
    framework that was previously introduced with JEP-158\. So, let''s first review
    the Unified JVM Logging (JEP-158).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java增强计划#271**（**JEP-271**）的标题为“统一GC日志”，旨在重新实现使用之前在JEP-158中引入的统一JVM日志框架的垃圾收集日志。因此，让我们首先回顾一下统一JVM日志（JEP-158）。'
- en: Unified JVM logging (JEP-158)
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一JVM日志（JEP-158）
- en: 'Creating a unified logging schema for the JVM was the central goal of JEP-158\.
    Here is a high-level list of the goals of the JEP:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为JVM创建一个统一的日志架构是JEP-158的核心目标。以下是JEP的目标的高层次列表：
- en: Create a JVM-wide set of command-line options for all logging operations
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有日志操作创建一个JVM范围的命令行选项集
- en: Use categorized tags for logging
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分类的标签进行日志记录
- en: 'Provide six levels of logging:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供六个日志级别：
- en: Error
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Warning
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告
- en: Information
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息
- en: Debug
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Trace
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Develop
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: This is not an exhaustive list of goals. We will discuss JEP-158 in greater
    detail in [Chapter 14](e1747284-a850-4e00-b044-fd06c6eb266d.xhtml), *Command Line
    Flags*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是目标列表的详尽无遗。我们将在第14章[命令行标志](e1747284-a850-4e00-b044-fd06c6eb266d.xhtml)中更详细地讨论JEP-158。
- en: 'The changes to the JVM, in the context of logging, can be categorized into:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志的背景下，对JVM的更改可以分为：
- en: Tags
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Levels
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别
- en: Decorations
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰
- en: Output
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出
- en: Command-line options
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项
- en: Let's briefly look at these categories.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看这些类别。
- en: Tags
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: Logging tags are identified in the JVM and can be changed in source code if
    needed. The tags should be self-identifying, such as `gc` for garbage collection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 日志标签在JVM中标识，如果需要，可以在源代码中更改。标签应该是自我标识的，例如`gc`代表垃圾收集。
- en: Levels
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别
- en: 'Each log message has an associated level. As previously listed, the levels
    are error, warning, information, debug, trace, and develop. The following chart
    shows how the levels have an increasing level of verbosity in respect to how much
    information is logged:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每条日志消息都有一个关联的级别。如前所述，级别包括错误、警告、信息、调试、跟踪和开发。以下图表显示了级别在日志记录的信息量方面的递增程度：
- en: '![](img/4873820c-96fb-4fb4-92f8-9e9369193dd9.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4873820c-96fb-4fb4-92f8-9e9369193dd9.png)'
- en: Decorations
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰
- en: 'In the context of Java 9''s logging framework, decorations is metadata about
    the log message. Here is the alphabetic list of decorations that are available:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9的日志框架的背景下，装饰是日志消息的元数据。以下是可用的装饰的字母顺序列表：
- en: level
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: level
- en: pid
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pid
- en: tags
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tags
- en: tid
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tid
- en: time
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: timemillis
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timemillis
- en: timenanos
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timenanos
- en: uptime
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uptime
- en: uptimemillis
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uptimemillis
- en: uptimenanos
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uptimenanos
- en: For an explanation of these decorations, please refer to [Chapter 14](e1747284-a850-4e00-b044-fd06c6eb266d.xhtml),
    *Command Line Flags*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些装饰的解释，请参阅第14章，*命令行标志*。
- en: Output
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出
- en: 'The Java 9 logging framework supports three types of output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9日志框架支持三种类型的输出：
- en: 'stderr: Provides output to stderr'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stderr：提供输出到标准错误
- en: 'stdout: Provides output to stdout'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stdout：提供输出到标准输出
- en: 'text file: Writes the output to text files'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文件：将输出写入文本文件
- en: Command-line options
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行选项
- en: 'A new command-line option was added to the logging framework to provide overall
    control of the JVM''s logging operations. The `-Xlog` command-line option has
    an extensive array of parameters and possibilities. Here is one example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架中添加了一个新的命令行选项，以提供对JVM日志操作的总体控制。`-Xlog`命令行选项具有广泛的参数和可能性。以下是一个示例：
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we are telling the JVM to take the following actions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们正在告诉JVM执行以下操作：
- en: Log all messages tagged with, at a minimum, the `gc` and `rt` tags
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录所有带有至少`gc`和`rt`标签的消息
- en: Use the `debug` level
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`debug`级别
- en: Provide output to `stdout`
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供输出到`stdout`
- en: Unified GC logging (JEP-271)
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一GC日志（JEP-271）
- en: 'Now that we have a general understanding of the changes to Java 9''s logging
    framework, let''s look at what changes JEP-271 introduced. In this section we
    will look at the following areas:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Java 9的日志框架的更改有了大致的了解，让我们看看JEP-271引入了哪些变化。在本节中，我们将探讨以下领域：
- en: Garbage collection logging options
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收日志选项
- en: The `gc` tag
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc`标签'
- en: Macros
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Additional considerations
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他注意事项
- en: Garbage collection logging options
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收日志选项
- en: 'Here is a list of garbage collection logging options and flags we had available
    to us before the introduction of Java 9''s logging framework:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍Java 9的日志框架之前，以下是我们可以使用的垃圾回收日志选项和标志列表：
- en: '| **Garbage collection logging option** | **JVM option flag(s)** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **垃圾回收日志选项** | **JVM选项标志** |'
- en: '| This prints the basic garbage collection information. | `-verbose:gc` or
    `-XX:+PrintGC` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 这将打印基本的垃圾回收信息。| `-verbose:gc` 或 `-XX:+PrintGC` |'
- en: '| This will print more detailed garbage collection information. | `-XX:+PrintGCDetails`
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 这将打印更详细的垃圾回收信息。 | `-XX:+PrintGCDetails` |'
- en: '| You can print timestamps for each garbage collection event. The seconds are
    sequential and begin from the JVM start time. | `-XX:+PrintGCTimeStamps` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 您可以为每个垃圾回收事件打印时戳。秒是连续的，从JVM启动时间开始。 | `-XX:+PrintGCTimeStamps` |'
- en: '| You can print date stamps for each garbage collection event. Sample format:`2017-07-26T03:19:00.319+400:[GC
    . . . ]` | `-XX:+PrintGCDateStamps` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 您可以为每个垃圾回收事件打印日期戳。示例格式：`2017-07-26T03:19:00.319+400:[GC . . . ]` | `-XX:+PrintGCDateStamps`
    |'
- en: '| You can use this flag to print timestamps for individual garbage collection
    work thread tasks. | `-XX:+PrintGC\TaskTimeStamps` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 您可以使用此标志来打印单个垃圾回收工作线程任务的时戳。 | `-XX:+PrintGC\TaskTimeStamps` |'
- en: '| Using this you can redirect garbage collection output to a file instead of
    the console. | `-Xloggc:` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 使用此标志可以将垃圾回收输出重定向到文件而不是控制台。 | `-Xloggc:` |'
- en: '| You can print detailed information regarding young space following each collection
    cycle. | `-XX:+Print\TenuringDistribution` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 您可以在每次收集周期后打印有关年轻空间的详细信息。 | `-XX:+Print\TenuringDistribution` |'
- en: '| You can use this flag to print TLAB allocation statistics. | `-XX:+PrintTLAB`
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 您可以使用此标志来打印TLAB分配统计信息。 | `-XX:+PrintTLAB` |'
- en: '| Using this flag, you can print the times for reference processing (that is,
    weak, soft, and so on) during *stop-the-world* pauses. | `-XX:+PrintReferenceGC`
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 使用此标志，您可以在*stop-the-world*暂停期间打印引用处理（即弱、软等）的时间。 | `-XX:+PrintReferenceGC`
    |'
- en: '| This reports if the garbage collection is waiting for native code to unpin
    objects in memory. | `-XX:+PrintJNIGCStalls` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 这将报告垃圾回收是否正在等待原生代码取消内存中对象的固定。 | `-XX:+PrintJNIGCStalls` |'
- en: '| This will print a pause summary after each *stop-the-world* pause. | `-XX:+PrintGC\ApplicationStoppedTime`
    |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 这将在每次*stop-the-world*暂停后打印暂停摘要。 | `-XX:+PrintGC\ApplicationStoppedTime` |'
- en: '| This flag will print time for each concurrent phase of garbage collection.
    | `-XX:+PrintGC\ApplicationConcurrentTime` |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 此标志将打印垃圾回收每个并发阶段的耗时。 | `-XX:+PrintGC\ApplicationConcurrentTime` |'
- en: '| Using this flag will print a class histogram after a full garbage collection.
    | `-XX:+Print\ClassHistogramAfterFullGC` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 使用此标志将在完整垃圾回收后打印类直方图。 | `-XX:+Print\ClassHistogramAfterFullGC` |'
- en: '| Using this flag will print a class histogram before a full garbage collection.
    | `-XX:+Print\ClassHistogramBeforeFullGC` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 使用此标志将在完全垃圾回收之前打印类直方图。 | `-XX:+Print\ClassHistogramBeforeFullGC` |'
- en: '| This creates a heap dump file after full garbage collection. | `-XX:+HeapDump\AfterFullGC`
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 这将在完全垃圾回收后创建堆转储文件。 | `-XX:+HeapDump\AfterFullGC` |'
- en: '| This creates a heap dump file before full garbage collection. | `-XX:+HeapDump\BeforeFullGC`
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 这将在完全垃圾回收之前创建堆转储文件。 | `-XX:+HeapDump\BeforeFullGC` |'
- en: '| This creates a heap dump file in an out-of-memory condition. | `-XX:+HeapDump\OnOutOfMemoryError`
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 这将在内存不足的情况下创建堆转储文件。 | `-XX:+HeapDump\OnOutOfMemoryError` |'
- en: '| You use this flag to specify the path where you want your heap dumps saved
    on your system. | `-XX:HeapDumpPath=<path>` |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 你使用此标志来指定你想要在系统上保存堆转储文件的路径。 | `-XX:HeapDumpPath=<path>` |'
- en: '| You can use this to print CMS statistics, `if n >= 1`. Applies specifically
    to CMS only. | `-XX:PrintCMSStatistics=2` |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 你可以使用此选项来打印CMS统计信息，`if n >= 1`。仅适用于CMS。 | `-XX:PrintCMSStatistics=2` |'
- en: '| This will print CMS initialization details. Applies specifically to CMS only.
    | `-XX:+Print\CMSInitiationStatistics` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 这将打印CMS初始化的详细信息。仅适用于CMS。 | `-XX:+Print\CMSInitiationStatistics` |'
- en: '| You can use this flag to print additional information concerning free lists.
    Applies specifically to CMS only. | `-XX:PrintFLSStatistics=2` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 你可以使用此标志来打印有关空闲列表的附加信息。仅适用于CMS。 | `-XX:PrintFLSStatistics=2` |'
- en: '| You can use this flag to print additional information concerning free lists.
    Applies specifically to CMS only. | `-XX:PrintFLSCensus=2` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 你可以使用此标志来打印有关空闲列表的附加信息。仅适用于CMS。 | `-XX:PrintFLSCensus=2` |'
- en: '| You can use this flag to print detailed diagnostic information following
    a promotion (young to tenure) failure. Applies specifically to CMS only. | `-XX:+PrintPromotionFailure`
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 你可以使用此标志来打印晋升（年轻到终身）失败后的详细诊断信息。仅适用于CMS。 | `-XX:+PrintPromotionFailure` |'
- en: '| This flag allows you to dump useful information regarding the state of the
    CMS old generation when a promotion (young to tenure) failure occurs. Applies
    specifically to CMS only. | `-XX:+CMSDumpAt\PromotionFailure` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 此标志允许你在晋升（年轻到终身）失败时，输出有关CMS旧代状态的有用信息。仅适用于CMS。 | `-XX:+CMSDumpAt\PromotionFailure`
    |'
- en: '| When the `-XX:+CMSDumpAt\PromotionFailure` flag is used, you can use `-XX:+CMSPrint\ChunksInDump`
    to include additional details regarding free chunks. Applies specifically to CMS
    only. | `-XX:+CMSPrint\ChunksInDump` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 当使用`-XX:+CMSDumpAt\PromotionFailure`标志时，你可以使用`-XX:+CMSPrint\ChunksInDump`来包含有关空闲块的其他详细信息。仅适用于CMS。
    | `-XX:+CMSPrint\ChunksInDump` |'
- en: '| When using the `-XX:+CMSPrint\ChunksInDump` flag, you can include additional
    information about the allocated objects using the `-XX:+CMSPrint\ObjectsInDump`
    flag. Applies specifically to CMS only. | `-XX:+CMSPrint\ObjectsInDump` |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 当使用`-XX:+CMSPrint\ChunksInDump`标志时，你可以通过使用`-XX:+CMSPrint\ObjectsInDump`标志来包含有关分配对象的附加信息。仅适用于CMS。
    | `-XX:+CMSPrint\ObjectsInDump` |'
- en: The gc tag
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gc标签
- en: We can use the `gc` tag with the `-Xlog` option to inform the JVM to only log
    `gc` tagged items at the info level. As you will recall, this is similar to using
    `-XX:+PrintGC`. With both options, the JVM will log one line for each garbage
    collection operation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`gc`标签与`-Xlog`选项一起使用，以通知JVM仅以info级别记录带有`gc`标签的项目。如您所回忆，这与使用`-XX:+PrintGC`类似。使用这两个选项，JVM将为每次垃圾收集操作记录一行。
- en: It is important to note that the `gc` tag was not intended to be used on its
    own; rather, it is recommended that it be used in conjunction with other tags.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：`gc`标签不是为了单独使用而设计的；相反，建议与其他标签一起使用。
- en: Macros
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: 'We can create macros to add logic to our garbage collection logging. Here is
    the general syntax for the log macro:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建宏来向我们的垃圾收集日志添加逻辑。以下是日志宏的一般语法：
- en: '[PRE18]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is an example of a log macro:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个日志宏的示例：
- en: '[PRE19]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following example skeleton log macro shows how you can use the new Java
    9 logging framework to create scripts for greater fidelity in logging:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例骨架日志宏展示了如何使用新的Java 9日志框架创建脚本以实现更精确的日志记录：
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Additional considerations
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他考虑因素
- en: 'Here are some additional items to be considered in regards to garbage collection
    logging:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾收集日志方面，以下是一些需要考虑的附加项：
- en: Using the new `-Xlog:gc` should produce similar results to the `-XX:+PrintGCDetails`
    command-line option and flag pairing
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的`-Xlog:gc`应该会产生与`-XX:+PrintGCDetails`命令行选项和标志配对类似的结果
- en: The new `trace` level provides the level of detail previously provided with
    the `verbose` flag
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`trace`级别提供了与`verbose`标志之前提供的详细程度相同的信息
- en: Persistent issues
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续问题
- en: Even with the advent of Java 9, there were downsides to Java's garbage collection
    system. Because it is an automatic process, we do not have complete control of
    when the collector runs. We, as developers, are not in control of garbage collection,
    the JVM is. The JVM makes the decision when to run garbage collection. As you
    have seen earlier in this chapter, we can ask the JVM to run garbage collection
    using the `System.gc()` method. Despite our use of this method, we are guaranteed
    that our request will be honored or that it will be complied with in a timely
    manner.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Java 9已经问世，Java的垃圾回收系统也存在一些缺点。因为它是一个自动过程，我们无法完全控制垃圾回收器何时运行。作为开发者，我们无法控制垃圾回收，这是由JVM控制的。JVM决定何时运行垃圾回收。正如您在本章前面所见，我们可以使用`System.gc()`方法请求JVM运行垃圾回收。尽管我们使用了这种方法，但我们无法保证我们的请求会被尊重，或者会及时得到响应。
- en: Earlier in this chapter, we reviewed several approaches and algorithms for garbage
    collection. We discussed how we, as developers, can take control of the process.
    That assumes that we have the ability to take control of garbage collection. Even
    when we specify a specific garbage collection technique, for example using `-XX:+UseConcMarkSweepGC`
    for CMS garbage collection, we are not guaranteed that the JVM will use that implementation.
    So, we can do our best to control how the garbage collector works, but should
    remember that the JVM has the ultimate authority regarding how, when, and if garbage
    collection occurs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们回顾了几个垃圾回收的方法和算法。我们讨论了作为开发者，我们如何控制这个过程。这假设我们有控制垃圾回收的能力。即使我们指定了特定的垃圾回收技术，例如使用`-XX:+UseConcMarkSweepGC`进行CMS垃圾回收，我们也无法保证JVM会使用该实现。因此，我们可以尽我们所能控制垃圾收集器的工作方式，但应该记住，JVM在如何、何时以及是否进行垃圾回收方面拥有最终决定权。
- en: Our lack of complete control over garbage collection underscores the importance
    of writing efficient code with memory management in mind. In the next sections,
    we will examine how to write code to explicitly make objects eligible for garbage
    collection by the JVM.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对垃圾回收缺乏完全的控制强调了编写考虑内存管理的有效代码的重要性。在接下来的几节中，我们将探讨如何编写代码，以显式地使对象有资格被JVM进行垃圾回收。
- en: Making objects eligible for garbage collection
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使对象有资格进行垃圾回收
- en: 'An easy method for making objects available for garbage collection is to assign
    `null` to the reference variable that refers to the object. Let''s review this
    example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使对象可用于垃圾回收的简单方法是将引用变量指向对象的引用赋值为`null`。让我们回顾这个例子：
- en: '[PRE21]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As indicated in the in-code comments, once the string object reference variable
    is set to null, in this case using the `junk = null;` statement, the object becomes
    available for garbage collection.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码注释所示，一旦字符串对象引用变量被设置为`null`，在这种情况下使用`junk = null;`语句，对象就可供垃圾回收。
- en: 'In our next example, we will abandon an object by setting its reference variable
    to point to a different object. As you can see in the following code, that results
    in the first object being available for garbage collection:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个例子中，我们将通过将引用变量设置为指向不同的对象来放弃一个对象。正如您在下面的代码中所见，这会导致第一个对象可供垃圾回收：
- en: '[PRE22]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s review one final method of making objects available for garbage collection.
    In this example, we have a single instance variable (`objectNbr`) that is a reference
    variable to an instance of the `GarbageCollectionExperimentThree` class. The class
    does not do anything interesting other than create additional reference variables
    to instances of the `GarbageCollectionExperimentThree` class. In our example,
    we set the `objectNbr2`, `objectNbr3`, `objectNbr4`, and `objectNbr5` references
    to `null`. Although these objects have instance variables and can refer to each
    other, their accessibility outside of the class has been terminated by setting
    their references to `null`. This makes them ( `objectNbr2`, `objectNbr3`, `objectNbr4`,
    and `objectNbr5` ) eligible for garbage collection:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使对象可用于垃圾回收的另一种方法。在这个例子中，我们有一个单个实例变量（`objectNbr`），它是一个指向`GarbageCollectionExperimentThree`类实例的引用变量。这个类除了创建指向`GarbageCollectionExperimentThree`类实例的额外引用变量外，没有做任何有趣的事情。在我们的例子中，我们将`objectNbr2`、`objectNbr3`、`objectNbr4`和`objectNbr5`引用设置为`null`。尽管这些对象有实例变量并且可以相互引用，但通过将它们的引用设置为`null`，它们在类外的可访问性已经被终止。这使得它们（`objectNbr2`、`objectNbr3`、`objectNbr4`和`objectNbr5`）有资格进行垃圾回收：
- en: '[PRE23]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we took an in-depth review of garbage collection as a critical
    pre-Java 9 platform component. Our review included object life cycle, garbage
    collection algorithms, garbage collection options, and methods related to garbage
    collection. We looked at upgrades to garbage collection in Java 8 and looked at
    a case study to help our understanding of modern garbage collection. We then turned
    our focus to the changes to garbage collection with the new Java 9 platform. Our
    exploration of garbage collection in Java 9 included looks at default garbage
    collection, depreciated garbage collection combinations, and unified garbage collection
    logging. We concluded our exploration of garbage collection by looking at a few
    garbage collection issues that persist, even after Java 9.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对垃圾回收作为Java 9平台前一个关键组件进行了深入回顾。我们的回顾包括对象生命周期、垃圾回收算法、垃圾回收选项以及与垃圾回收相关的方法。我们研究了Java
    8中垃圾回收的升级，并分析了案例研究以帮助我们理解现代垃圾回收。然后，我们将注意力转向了与新的Java 9平台相关的垃圾回收更改。我们对Java 9中的垃圾回收的探索包括了对默认垃圾回收、已弃用的垃圾回收组合和统一垃圾回收日志的考察。通过查看即使在Java
    9之后仍然存在的几个垃圾回收问题，我们结束了对垃圾回收的探索。
- en: In the next chapter we will look at how to write performance tests using the
    **Java Microbenchmark Harness** (**JMH**), a Java harness library for writing
    benchmarks for the JVM.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用**Java微基准工具**（**JMH**），这是一个用于为JVM编写基准测试的Java工具库，来编写性能测试。
