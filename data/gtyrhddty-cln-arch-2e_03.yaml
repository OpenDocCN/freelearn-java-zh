- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Inverting Dependencies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转
- en: After the talk about layered architecture in the previous chapter, you’re right
    to expect this chapter to discuss an alternative approach. We’ll start by discussing
    two of the **SOLID**[1](#footnote-015) principles and then apply them to create
    a *Clean* or *Hexagonal* Architecture that addresses the problems of a layered
    architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论分层架构之后，你期待这一章讨论一种替代方法是很自然的。我们将从讨论**SOLID**[1](#footnote-015)原则中的两个开始，然后应用它们来创建一个*整洁*或*六边形*架构，以解决分层架构的问题。
- en: '[1](#footnote-015-backlink) SOLID stands for Single Responsibility Principle,
    Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle,
    and Dependency Inversion Principle. You can read more about these Principles in
    *Clean Architecture* by Robert C. Martin or on Wikipedia at [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-015-backlink) SOLID代表单一责任原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则。你可以在Robert
    C. Martin的《整洁架构》或维基百科上了解更多关于这些原则的信息：[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)。'
- en: The Single Responsibility Principle
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: 'Everyone in software development probably knows the **Single Responsibility
    Principle** (**SRP**) or at least assumes to know it. A common interpretation
    of this principle is this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的每个人可能都知道**单一责任原则**（**SRP**）或者至少认为自己知道。这个原则的常见解释是这样的：
- en: '*A component should do only one thing and do* *it right.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件应该只做一件事，并且做好这件事*。'
- en: That’s good advice, but not the actual intent of the SRP.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条很好的建议，但并非SRP的实际意图。
- en: '*Doing only one thing* is actually the most obvious interpretation of “single
    responsibility,” so it’s no wonder that the SRP is frequently interpreted like
    this. Let’s just observe that the name of the SRP is misleading.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*只做一件事*实际上是“单一责任”最明显的解释，因此SRP经常被这样解释。我们只需观察SRP的名称具有误导性。'
- en: 'Here’s the actual definition of the SRP:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SRP的实际定义：
- en: '*A component should have only one reason* *to change.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件应该只有一个改变的理由*。'
- en: As we see, “responsibility” should actually be translated to “reason to change”
    instead of “do only one thing.” Perhaps we should rename the SRP to the “Single
    Reason to Change Principle.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，“责任”实际上应该翻译为“改变的理由”，而不是“只做一件事”。也许我们应该将SRP重命名为“单一改变理由原则”。
- en: If a component has only one reason to change, it might end up doing only one
    thing, but the more important part is that it has only this one reason to change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件只有一个改变的理由，它最终可能只做一件事，但更重要的是，它只有一个改变的理由。
- en: What does that mean for our architecture?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们架构意味着什么？
- en: If a component has only one reason to change, we don’t have to worry about this
    component at all if we change the software for any other reason because we know
    that it will still work as expected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件只有一个改变的理由，那么在改变软件的其他任何原因时，我们不必担心这个组件，因为我们知道它仍然会按预期工作。
- en: Sadly, it’s very easy for a reason to change to propagate through code via the
    dependencies of a component to other components (see *Figure 3**.1*).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，改变的理由很容易通过组件的依赖关系传播到其他组件（参见*图3.1*）。
- en: '![Figure 3.1 – Each dependency of a component is a possible reason to change
    this component, even if it is only a transitive dependency (dashed arrows)](img/Figure_03.1_B19916.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 组件的每个依赖项都是改变此组件的可能原因，即使它只是一个传递依赖（虚线箭头）](img/Figure_03.1_B19916.jpg)'
- en: Figure 3.1 – Each dependency of a component is a possible reason to change this
    component, even if it is only a transitive dependency (dashed arrows)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 组件的每个依赖项都是改变此组件的可能原因，即使它只是一个传递依赖（虚线箭头）
- en: In the preceding figure, component **A** depends on many other components (either
    directly or transitively) while component **E** has no dependencies at all.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，组件**A**依赖于许多其他组件（无论是直接还是间接），而组件**E**则没有任何依赖。
- en: The only reason to change component **E** is when the functionality of **E**
    must change due to some new requirement. Component **A**, however, might have
    to change when any of the other components change because it depends on them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 改变组件**E**的唯一理由是当**E**的功能必须因为某些新需求而改变。然而，组件**A**可能需要改变，因为其他组件的任何改变都会影响它，因为它依赖于它们。
- en: Many code bases grow harder – and thus more expensive – to change over time
    because the SRP is violated. Over time, components collect more and more reasons
    to change. Having collected many reasons to change, changing one component might
    cause another component to fail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码库随着时间的推移变得越来越难以更改——因此成本也更高——这是因为违反了单一职责原则。随着时间的推移，组件会积累越来越多的变化理由。一旦收集了许多变化理由，更改一个组件可能会引起另一个组件失败。
- en: A tale about side effects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个关于副作用的故事
- en: I once was part of a project where my team inherited a ten-year-old code base
    built by another software shop. The client had decided to replace the development
    team to reduce the ongoing maintenance costs and improve the development speed
    for new features. So, we got the contract.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经参与过一个项目，我的团队继承了另一个软件公司开发的十年老代码库。客户决定更换开发团队以降低持续维护成本并提高新功能的开发速度。因此，我们获得了这个合同。
- en: As was to be expected, it was not easy to gain an understanding of what the
    code actually did, and the changes we made in one area of the code base often
    had side effects in other areas. But we managed by testing exhaustively, adding
    automated tests, and refactoring a lot.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，理解代码的实际功能并不容易，我们在代码库的一个区域所做的更改往往会在其他区域产生副作用。但我们通过彻底测试、添加自动化测试和大量重构来应对。
- en: After some time of successfully maintaining and extending the code base, the
    client requested a new feature. And they wanted us to build it in a way that was
    very awkward for the users of the software. So, I proposed to do it in a more
    user-friendly way that was even less expensive to implement since it needed fewer
    overall changes. It needed a small change in a certain very central component,
    however.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功维护和扩展代码库一段时间后，客户提出了一个新功能的需求。他们希望我们以对软件用户非常不便的方式来实现这个功能。因此，我提出了一个更用户友好的方案，由于它需要的整体改动更少，所以实现起来甚至更加经济。然而，它需要在某个非常核心的组件上进行一个小改动。
- en: The client declined and ordered the more awkward and expensive solution. When
    I asked for the reason, they said that they were afraid of the side effects because
    changes made to that one component by the previous development team had always
    broken something else in the past.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 客户拒绝了我们的建议，并要求采用更不便且昂贵的解决方案。当我询问原因时，他们表示担心副作用，因为之前开发团队对那个组件所做的更改过去总是导致其他地方出现问题。
- en: Sadly, this is an example of how you can indoctrinate your client to pay extra
    for modifying badly architected software. Luckily, most clients will not play
    along with this game, so let’s try to build well-architected software instead.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这是一个例子，说明了你如何使客户为了修改糟糕的架构软件而额外付费。幸运的是，大多数客户不会参与这个游戏，所以让我们尝试构建良好的架构软件。
- en: The Dependency Inversion Principle
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: In our layered architecture, the cross-layer dependencies always point down
    to the next layer. When we apply the Single Responsibility Principle on a high
    level, we notice that the upper layers have more reasons to change than the lower
    layers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的分层架构中，跨层依赖始终指向下一层。当我们从高层次应用单一职责原则时，我们会注意到上层比下层有更多的变化理由。
- en: Thus, due to the domain layer’s dependency on the persistence layer, each change
    in the persistence layer potentially requires a change in the domain layer. But
    the domain code is the most important code in our application! We don’t want to
    have to change it when something changes in the persistence code!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于领域层对持久层有依赖，持久层中的每个更改都可能需要在领域层进行更改。但领域代码是我们应用程序中最重要的代码！我们不希望当持久层代码发生变化时不得不更改它！
- en: So, how can we get rid of this dependency?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何摆脱这种依赖呢？
- en: The **Dependency Inversion Principle** (**DIP**) provides the answer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）提供了答案。'
- en: 'In contrast to the SRP, the DIP means what the name suggests:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与SRP不同，DIP意味着其名称所暗示的含义：
- en: '*We can turn around (invert) the direction of any dependency within our* *code
    base**[2](#footnote-014)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以在我们的代码库中（反转）任何依赖的方向**[2](#footnote-014)*'
- en: '[2](#footnote-014-backlink) Actually, we can only invert dependencies when
    we have control over the code on both ends of the dependency. If we have a dependency
    on a third-party library, we cannot invert it, since we don''t control the code
    of that library.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-014-backlink) 实际上，我们只能在控制依赖两端代码的情况下反转依赖。如果我们依赖于第三方库，我们就不能反转它，因为我们不控制那个库的代码。'
- en: How does that work? Let’s try to invert the dependency between our domain and
    persistence code so that the persistence code depends on the domain code, reducing
    the number of reasons to change the domain code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？让我们尝试反转域代码和持久化代码之间的依赖关系，使持久化代码依赖于域代码，从而减少需要更改域代码的原因。
- en: We start with a structure like that in *Figure 2**.2* from [*Chapter 2*](B19916_03.xhtml),
    *What’s Wrong with Layers?* We have a service in the domain layer that works with
    entities and repositories from the persistence layer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个类似于[*第2章*](B19916_03.xhtml)，*《层有什么问题？》*中*图2.2*的结构开始。我们有一个在域层中的服务，它使用持久化层中的实体和存储库。
- en: First of all, we want to pull up the entities into the domain layer because
    they represent our domain objects and our domain code pretty much revolves around
    changing the state of those entities.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望将实体提升到域层，因为它们代表我们的域对象，我们的域代码基本上是围绕改变这些实体的状态来进行的。
- en: But now, we have a circular dependency between both layers since the repository
    from the persistence layer depends on the entity, which is now in the domain layer.
    This is where we apply the DIP. We create an interface for the repository in the
    domain layer and let the actual repository in the persistence layer implement
    it. The result is something like that in *Figure 3**.2*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，由于持久化层中的存储库依赖于现在位于域层的实体，我们在这两个层之间有一个循环依赖。这就是我们应用DIP的地方。我们在域层为存储库创建一个接口，并让持久化层中的实际存储库实现它。结果是类似于*图3.2*中的那样。
- en: '![Figure 3.2 – By introducing an interface in the domain layer, we can invert
    the dependency so that the persistence layer depends on the domain layer](img/Figure_03.2_B19916.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 通过在域层引入接口，我们可以反转依赖，使持久化层依赖于域层](img/Figure_03.2_B19916.jpg)'
- en: Figure 3.2 – By introducing an interface in the domain layer, we can invert
    the dependency so that the persistence layer depends on the domain layer
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 通过在域层引入接口，我们可以反转依赖，使持久化层依赖于域层
- en: With this trick, we have liberated our domain logic from the oppressive dependency
    on the persistence code. This is a core feature of the two architectural styles
    we’re going to discuss in the upcoming sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个技巧，我们使我们的域逻辑摆脱了对持久化代码的压迫性依赖。这是我们在接下来的章节中将要讨论的两个架构风格的核心特性。
- en: Clean Architecture
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构
- en: Robert C. Martin coined the term “**Clean Architecture**” in his book with the
    same name.[3](#footnote-013) In a Clean Architecture, in his opinion, the business
    rules are testable by design and independent of frameworks, databases, UI technologies,
    and other external applications or interfaces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·C·马丁在他的同名书中提出了“**清洁架构**”这个术语。[3](#footnote-013)在他看来，清洁架构中的业务规则是设计可测试的，并且独立于框架、数据库、UI技术以及其他外部应用程序或接口。
- en: '[3](#footnote-013-backlink) *Clean Architecture* by Robert C. Martin, Prentice
    Hall, 2017, *Chapter 22*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-013-backlink) *《清洁架构》*，罗伯特·C·马丁著，普伦蒂斯·霍尔出版社，2017年，*第22章*。'
- en: This means that the domain code must not have any outward-facing dependencies.
    Instead, with the help of the DIP, all dependencies point toward the domain code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着域代码不能有任何面向外部的依赖。相反，借助DIP（依赖倒置原则），所有依赖都指向域代码。
- en: '*Figure 3**.3* shows what such an architecture might look like on an abstract
    level.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.3*展示了这样一个架构在抽象层面可能的样子。'
- en: '![Figure 3.3 – In a Clean Architecture, all dependencies point inward toward
    the domain logic (Source: Clean Architecture by Robert C. Martin)](img/Figure_03.3_B19916.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 在清洁架构中，所有依赖都指向域逻辑（来源：罗伯特·C·马丁的《清洁架构》）](img/Figure_03.3_B19916.jpg)'
- en: 'Figure 3.3 – In a Clean Architecture, all dependencies point inward toward
    the domain logic (Source: Clean Architecture by Robert C. Martin)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 在清洁架构中，所有依赖都指向域逻辑（来源：罗伯特·C·马丁的《清洁架构》）
- en: The layers in this architecture are wrapped around each other in concentric
    circles. The main rule in such an architecture is the “**Dependency Rule**,” which
    states that all dependencies between those layers must point inward.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个架构中的层以同心圆的形式相互包裹。这种架构中的主要规则是“**依赖规则**”，它规定这些层之间的所有依赖都必须指向内部。
- en: The core of the architecture contains the domain entities, which are accessed
    by the surrounding use cases. The use cases are what we have called services earlier,
    but are more fine-grained to have a single responsibility (i.e., a single reason
    to change), thus avoiding the problem of *broad services*, as we discussed earlier.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 架构的核心包含领域实体，这些实体由周围的使用案例访问。使用案例就是我们之前所说的服务，但它们更细粒度，具有单一责任（即单一改变的理由），从而避免了我们之前讨论的*宽泛的服务*问题。
- en: Around this core, we can find all the other components of our application that
    support the business rules. This support can mean providing persistence or providing
    a UI, for example. Also, the outer layers may provide adapters to any other third-party
    component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕这个核心，我们可以找到支持业务规则的所有其他应用程序组件。这种支持可能意味着提供持久性或提供用户界面，例如。此外，外部层可能为任何第三方组件提供适配器。
- en: Since the domain code knows nothing about which persistence or UI framework
    is used, it cannot contain any code specific to those frameworks and will concentrate
    on the business rules. We have all the freedom we can wish for to model the domain
    code. We could, for example, apply **Domain-Driven Design** (**DDD**) in its purest
    form. Not having to think about persistence or UI-specific problems makes that
    so much easier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于领域代码对使用的持久性或UI框架一无所知，它不能包含任何特定于这些框架的代码，并将专注于业务规则。我们拥有我们所能希望的所有自由来建模领域代码。例如，我们可以以最纯粹的形式应用**领域驱动设计**（**DDD**）。不必考虑持久性或UI特定的问题使得这变得容易得多。
- en: As we might expect, Clean Architecture comes at a cost. Since the domain layer
    is completely decoupled from the outer layers such as the persistence and UI layers,
    we have to maintain a model of our application’s entities in each of the layers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，整洁架构是有代价的。由于领域层完全与外部层（如持久性和UI层）解耦，我们必须在每个层中维护应用程序实体的模型。
- en: Let’s assume, for instance, that we’re using an **object-relational mapping**
    (**ORM**) framework in our persistence layer. An ORM framework usually expects
    specific entity classes that contain metadata describing the database structure
    and the mapping of object fields to database columns. Since the domain layer doesn’t
    know the persistence layer, we cannot use the same entity classes in the domain
    layer and have to create them in both layers. This means that the persistence
    layer needs to map the domain entities to its own representation. A similar mapping
    applies between the domain layer and other outer layers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我们在持久层使用一个**对象关系映射**（**ORM**）框架。ORM框架通常期望特定的实体类，这些类包含描述数据库结构和对象字段到数据库列映射的元数据。由于领域层不知道持久层，我们不能在领域层使用相同的实体类，而必须在两个层中都创建它们。这意味着持久层需要将领域实体映射到其自身的表示。在领域层和其他外部层之间也适用类似的映射。
- en: But that’s a good thing! This decoupling is exactly what we wanted to achieve
    to free the domain code from framework-specific problems. The Java Persistence
    API (the standard object-relational API in the Java world), for instance, requires
    the ORM-managed entities to have a default constructor without arguments that
    we might want to avoid in our domain model. In [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081),
    *Mapping* *b**etween Boundaries*, we’ll talk about different mapping strategies,
    including a *no-mapping* strategy that just accepts the coupling between the domain
    and persistence layers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是好事！这种解耦正是我们想要实现的，以使领域代码摆脱框架特定的问题。例如，Java持久性API（Java世界中的标准对象关系API）要求ORM管理的实体具有不带参数的默认构造函数，而我们可能不想在我们的领域模型中避免它。在[*第9章*](B19916_09.xhtml#_idTextAnchor081)中，我们将讨论不同的映射策略，包括一种*无映射*策略，它只是接受领域和持久层之间的耦合。
- en: Since *Clean Architecture* by Robert C. Martin is somewhat abstract, let’s go
    a level of detail deeper and look at *Hexagonal Architecture*, which gives the
    *Clean Architecture* principles a more concrete shape.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于罗伯特·C·马丁的《*整洁架构*》有些抽象，让我们深入一个层次，看看*六边形架构*，它给*整洁架构*原则提供了更具体的形状。
- en: Hexagonal Architecture
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六边形架构
- en: The term **Hexagonal Architecture** stems from Alistair Cockburn and has been
    around for quite some time.[4](#footnote-012) It applies the same principles that
    Robert C. Martin later described in more general terms in *Clean Architecture*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**这个术语来自阿利斯泰尔·科克本，已经存在一段时间了。[4](#footnote-012)它应用了罗伯特·C·马丁后来在*整洁架构*中以更一般术语描述的相同原则。'
- en: '[4](#footnote-012-backlink) The primary source for the term "Hexagonal Architecture"
    seems to be an article on Alistair Cockburn''s website at [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-012-backlink) “六角架构”这个术语的主要来源似乎是一篇关于Alistair Cockburn网站的文章，网址为[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)。'
- en: '![Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters”
    architecture since the application core provides specific ports for each adapter
    to interact with](img/Figure_03.4_B19916.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 六角架构也被称为“端口和适配器”架构，因为应用程序核心为每个适配器提供特定的端口以进行交互](img/Figure_03.4_B19916.jpg)'
- en: Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters”
    architecture since the application core provides specific ports for each adapter
    to interact with
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 六角架构也被称为“端口和适配器”架构，因为应用程序核心为每个适配器提供特定的端口以进行交互
- en: '*Figure 3**.4* shows what a Hexagonal Architecture might look like. The application
    core is represented as a hexagon, giving this architectural style its name. The
    hexagon shape has no meaning, however, so we might just as well draw an octagon
    and call it “Octagonal Architecture.” According to legend, the hexagon was simply
    used instead of the common rectangle to show that an application can have more
    than four sides connecting it to other systems or adapters.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3*.*4*展示了六角架构可能的样子。应用程序核心以六角形表示，这为这种架构风格命名。然而，六角形的形状没有意义，所以我们也可以画一个八边形并称之为“八角架构”。根据传说，六角形只是用来代替常见的矩形，以表明一个应用程序可以通过多于四条边连接到其他系统或适配器。'
- en: Within the hexagon, we find our domain entities and the use cases that work
    with those entities. Note that the hexagon has no outgoing dependencies so the
    Dependency Rule from Martin’s Clean Architecture holds true. Instead, all dependencies
    point toward the center.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在六角形内部，我们找到我们的领域实体以及与这些实体一起工作的用例。请注意，六角形没有外部依赖，因此马丁的清洁架构中的依赖规则是正确的。相反，所有依赖都指向中心。
- en: Outside the hexagon, we find various **adapters** that interact with the application.
    There might be a web adapter that interacts with a web browser, some adapters
    interacting with external systems, and an adapter that interacts with a database
    for persistence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在六角形外部，我们找到各种**适配器**，它们与应用程序进行交互。可能有一个与网络浏览器交互的网络适配器，一些与外部系统交互的适配器，以及一个与数据库交互以实现持久性的适配器。
- en: The adapters on the left side are adapters that drive our application (because
    they call our application core) while the adapters on the right side are driven
    by our application (because they are called by our application core).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的适配器是驱动我们应用程序的适配器（因为它们调用我们的应用程序核心），而右侧的适配器是由我们的应用程序驱动的（因为它们被应用程序核心调用）。
- en: 'To allow communication between the application core and the adapters, the application
    core provides specific **ports**. For driving adapters, such a port might be an
    interface that is implemented by one of the use case classes in the core and called
    by the adapter. For a driven adapter, it might be an interface that is implemented
    by the adapter and called by the core. We might even have multiple adapters implementing
    the same port: one for communicating with a real external system, and one for
    communicating with a mock to be used in testing, for example.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序核心和适配器之间的通信，应用程序核心提供了特定的**端口**。对于驱动适配器，这样的端口可能是一个由核心中的某个用例类实现并由适配器调用的接口。对于被驱动的适配器，它可能是一个由适配器实现并由核心调用的接口。我们甚至可能有多个适配器实现相同的端口：一个用于与真实的外部系统通信，另一个用于与用于测试的模拟进行通信，例如。
- en: To clearly call out a central attribute of Hexagonal Architecture, *the application
    core (the hexagon) defines and owns the interface to the outside* (*the ports*).
    The adapters then work with this interface. This is the Dependency Inversion Principle
    applied at the architecture level.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地指出六角架构的一个核心属性，*应用程序核心（六角形）定义并拥有对外部接口的所有权*（*端口*）。然后适配器与这个接口一起工作。这是在架构级别应用依赖倒置原则。
- en: Due to its central concepts, this architecture style is also known as a **Ports
    and** **Adapters** architecture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其核心概念，这种架构风格也被称为**端口和****适配器**架构。
- en: Just like Clean Architecture, we can organize this Hexagonal Architecture into
    layers. The outermost layer consists of the adapters that translate between the
    application and other systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像清洁架构一样，我们可以将这种六边形架构组织成层。最外层由适配器组成，它们在应用和其他系统之间进行转换。
- en: Next, we can combine the ports and use case implementations to form the application
    layer because they define the interface of our application. The final layer contains
    the domain entities implementing the business rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将端口和用例实现结合起来形成应用层，因为它们定义了我们的应用接口。最内层包含实现业务规则的领域实体。
- en: The business logic is implemented in the use case classes and entities. The
    use case classes are narrow **domain services**, implementing just a single use
    case. We can choose to combine multiple use cases to a broader domain service,
    of course, but ideally, we do this only when the use cases are often used together,
    to increase maintainability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑在用例类和实体中实现。用例类是狭窄的**领域服务**，仅实现单个用例。当然，我们可以选择将多个用例组合到一个更广泛的领域服务中，但理想情况下，我们只在用例经常一起使用时这样做，以提高可维护性。
- en: Potentially, we will want to introduce the concept of application services,
    too. An **application service** is a service that coordinates calls to use cases
    (**domain services**), as shown in *Figure 3**.5*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的话，我们还想引入应用服务的概念。**应用服务**是一种协调对用例（**领域服务**）调用的服务，如图*图3.5*所示。
- en: '![Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application
    and domain services](img/Figure_03.5_B19916.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 使用应用和领域服务的DDD概念的六边形架构](img/Figure_03.5_B19916.jpg)'
- en: Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application
    and domain services
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 使用应用和领域服务的DDD概念的六边形架构
- en: Here, the application services translate between the input and output ports
    and the domain services, shielding the domain services from the outside world,
    and potentially coordinating between the domain services. The **Domain Service**
    boxes are synonymous with the **Use Case** boxes from *Figure 3**.4*; we’re just
    now using terminology borrowed from DDD.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用服务在输入和输出端口以及领域服务之间进行转换，保护领域服务免受外部世界的干扰，并可能协调领域服务之间的交互。**领域服务**框与*图3.4*中的**用例**框同义；我们只是现在使用了从领域驱动设计（DDD）借用的术语。
- en: As this discussion implies, we’re free to design our application code as we
    see fit inside the hexagon. We can go simple or sophisticated, matching the complexity
    and size of our application. We will learn more about managing code within our
    hexagon in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing Multiple*
    *Bounded Contexts*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这次讨论所暗示的，我们可以在六边形内部自由地设计我们的应用代码。我们可以选择简单或复杂，以匹配我们应用的复杂性和规模。我们将在[*第13章*](B19916_13.xhtml#_idTextAnchor112)“管理多个*有界上下文*”中了解更多关于在六边形内管理代码的知识。
- en: In the next chapter, we’ll discuss a way to organize such an architecture in
    code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一种在代码中组织这种架构的方法。
- en: How does this help me build maintainable software?
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Call it “Clean Architecture,” “Hexagonal Architecture,” or “Ports and Adapters
    Architecture” – by inverting our dependencies so that the domain code has no dependencies
    on the outside, we can decouple our domain logic from all those persistence- and
    UI-specific problems and reduce the number of reasons to make changes throughout
    the code base. And fewer reasons to change lead to better maintainability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 称其为“清洁架构”、“六边形架构”或“端口和适配器架构”，通过反转我们的依赖关系，使得领域代码对外部没有依赖，我们可以将领域逻辑从所有那些与持久化和UI特定的问题解耦，并减少在整个代码库中需要更改的原因。更少的更改原因导致更好的可维护性。
- en: The domain code is free to be modeled as best fits the business problems, while
    the persistence and UI code are free to be modeled as best fits the persistence
    and UI problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 领域代码可以自由地建模以最佳地适应业务问题，而持久化和UI代码可以自由地建模以最佳地适应持久化和UI问题。
- en: In the rest of this book, we’ll apply the Hexagonal Architecture style to a
    web application. We’ll start by creating the package structure of our application
    and discussing the role of dependency injection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将应用六边形架构风格来构建一个Web应用。我们将从创建应用包结构开始，并讨论依赖注入的作用。
