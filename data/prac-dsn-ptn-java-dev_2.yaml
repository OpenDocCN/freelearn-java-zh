- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Discovering the Java Platform for Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java平台的设计模式
- en: Many years ago, motivated by the lack of a suitable **Application Programming
    Interface** (**API**) design, something extraordinary began to happen. In the
    early days of using the **World Wide Web** (**WWW**), the direction of application
    development was a bit shrouded in fog. In one direction, there was a strong need
    in the industry to process a large number of database transactions or develop
    specific proprietary hardware and software. On the other hand, it was not clear
    what kind of applications might be needed to move the demand forward and how such
    an application should be maintained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，由于缺乏合适的**应用程序编程接口**（**API**）设计，一些非凡的事情开始发生。在早期使用**万维网**（**WWW**）的时候，应用开发的走向有些模糊不清。一方面，行业对处理大量数据库事务或开发特定专有硬件和软件有强烈的需求。另一方面，不清楚需要什么样的应用程序来推动需求的发展，以及这样的应用程序应该如何维护。
- en: 'In this chapter, we will prepare the ground for understanding the value of
    design patterns from a memory utilization perspective. We will do so by covering
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从内存利用的角度为理解设计模式的价值做好准备。我们将通过以下主题来实现这一点：
- en: The rise of Java and brief historical facts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的兴起和简要历史事实
- en: How the Java platform works under the hood
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台内部的工作原理
- en: Exploring Java memory area allocation and management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java内存区域分配和管理
- en: How allocated heap is maintained with garbage collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过垃圾收集维护分配的堆内存
- en: Running the first program on the platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在平台上运行第一个程序
- en: The threading nature of the Java platform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台的线程特性
- en: Examining the core Java APIs and their values for software design
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查核心Java API及其在软件设计中的价值
- en: Exploring the importance of the Java Platform Module System
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java平台模块系统的重要性
- en: Discovering new helpful platform enhancements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索新的有用平台增强功能
- en: Introducing Java concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Java并发
- en: By the end of the chapter, you will have a good understanding of memory allocation
    on the Java platform, platform guarantees, core APIs, and more. Together with
    the content of the previous chapter, these topics will form a well-prepared foundation
    so that you can start with design patterns with full awareness of their benefits.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对Java平台上的内存分配、平台保证、核心API等有良好的理解。结合上一章的内容，这些主题将形成一个良好的基础，以便你可以带着对设计模式益处的充分认识开始学习。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter are available on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在GitHub上找到，链接为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02)。
- en: Knocking on Java’s door
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敲响Java的大门
- en: In the early 1990s, a small team at Sun Microsystems was formed in order to
    discover new horizons. The team started with the consideration of extending the
    C++ features available in those days. One of the goals was to introduce a new
    generation of software for a small smart device. The introduction of software
    reusability was a part of this. Small smart devices such as set-top boxes did
    not have much memory and had to use their resources wisely. The memory, among
    other things, such as its complexity, error-prone programs, and probably James
    Gosling’s language extension attempt, later led to the rejection of the C++ idea.
    Instead of struggling with C++, a new language called **Oak** was created in lieu.
    Due to the trademark issue, the newly created language Oak was renamed Java.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代初，Sun Microsystems的一个小团队成立，目的是探索新的领域。团队从考虑扩展当时可用的C++特性开始。其中一个目标是为小型智能设备引入新一代软件。软件的可重用性是这一目标的一部分。小型智能设备，如机顶盒，内存有限，必须明智地使用其资源。内存，以及其他因素，如复杂性、易出错的程序，以及可能詹姆斯·高斯林的语言扩展尝试，最终导致了C++想法的放弃。为了避免与C++的斗争，创造了一种新的语言，称为**Oak**。由于商标问题，新创建的语言Oak被更名为Java。
- en: The first public Java version 1.0a.2, together with HotJava Browser, was announced
    at the SunWorld conference in 1995 by John Gage, the director of science at Sun
    Microsystems. He was involved in re-directing the Java language from being a language
    for small hardware devices to being a platform for WWW applications. In these
    early days, Java was used as part of a website using a technology known as an
    applet. Java applets were small sandboxes, defined by the frame with limited access
    and the capability to execute Java bytecode on the local **Java Virtual Machine**
    (**JVM**). Applets resided on a web browser or as a standalone application; they
    were a very powerful tool that supported one of the basic Java principles, **Write
    Once, Run Anywhere** (**WORA**). However, due to many issues (such as security
    and stability), the applet technology was marked for removal (Java SE 17).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个公开的Java版本1.0a.2，连同HotJava浏览器，于1995年在SunWorld会议上由Sun Microsystems的科学总监John
    Gage宣布。他参与了将Java语言从小型硬件设备的语言重新定位为WWW应用程序的平台。在这些早期日子里，Java被用作网站的一部分，使用一种称为applet的技术。Java
    applet是小型沙盒，由具有有限访问权限的框架定义，并能够在本地**Java虚拟机**（**JVM**）上执行Java字节码。Applet位于网络浏览器中或作为独立应用程序；它们是支持Java的一个基本原则——**一次编写，到处运行**（**WORA**）的非常强大的工具。然而，由于许多问题（如安全和稳定性），applet技术被标记为移除（Java
    SE 17）。
- en: 'The Java platform consists of three main parts (*Figure 2**.1*):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台由三个主要部分组成（*图2.1*）：
- en: "![Figure 2.1 \uFEFF– Java Development Kit architecture](img/B18884_02_01.jpg)"
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Java开发工具包架构](img/B18884_02_01.jpg)'
- en: Figure 2.1 – Java Development Kit architecture
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Java开发工具包架构
- en: 'These parts are the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分如下：
- en: A JVM
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JVM
- en: The **Java SE (Standard Edition) Runtime** **Environment** (**JRE**)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE（标准版）运行时环境**（**JRE**）'
- en: The **Java SE Development** **Kit** (**JDK**)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE开发工具包**（**JDK**）'
- en: Let us start an exciting journey through the platform itself and each part.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一段激动人心的旅程，通过平台本身及其各个部分。
- en: Exploring the model and functionality of the Java platform
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java平台模型和功能
- en: 'History has shown us that the intended direction can evolve or change: Java
    is a nice example and is no exception. From its original purpose, it has moved
    from a platform for smart devices to a platform for entire web solutions, but
    its development did not stop there. Over the years, Java has become one of the
    most widely used languages for application development. This can be taken as a
    side effect of basic hardware independence. It dramatically developed an available
    set of tools and received a very positive response from a vibrant community.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 历史已经证明，预期的方向可以演变或改变：Java是一个很好的例子，也不例外。从其原始目的来看，它已经从智能设备的平台转变为整个Web解决方案的平台，但它的开发并没有停止在这里。多年来，Java已经成为应用开发中最广泛使用的语言之一。这可以被视为基本硬件独立性的副作用。它极大地发展了一套可用的工具，并得到了一个充满活力的社区的积极响应。
- en: Let us review each part of the platform (from *Figure 2**.1*) individually as
    it will boost our understanding of writing code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个回顾平台（从*图2.1*）的各个部分，这将有助于我们更好地理解编写代码。
- en: The JDK
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK
- en: 'The JDK is a software development environment that provides the tools and libraries
    needed to develop and analyze Java applications. The JDK provides a collection
    of basic libraries, functions, and programs needed to compile written code into
    bytecode. The JDK contains the JRE required to run the application. The JDK also
    provides some very useful tools, such as the following examples:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JDK是一个提供开发和分析Java应用程序所需工具和库的软件开发环境。JDK提供了一组基本库、函数和程序，用于将编写的代码编译成字节码。JDK包含运行应用程序所需的JRE。JDK还提供了一些非常实用的工具，例如以下示例：
- en: '`jlink`: This helps generate a custom JRE'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jlink`：这有助于生成自定义JRE'
- en: '`jshell`: This is a handy **Read-Evaluate-Print-Loop** (**REPL**) tool to try
    the Java language'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jshell`：这是一个方便的**读取-评估-打印-循环**（**REPL**）工具，用于尝试Java语言'
- en: '`jcmd`: This is a utility to send a diagnostic command to the active JVM'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jcmd`：这是一个实用程序，可以向活动的JVM发送诊断命令'
- en: '`javac`: This is the Java compiler, which reads an input file with the `.java`
    suffix and produces a Java class file with the `.``class` suffix'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`：这是一个Java编译器，它读取具有`.java`后缀的输入文件，并生成具有`.class`后缀的Java类文件'
- en: '`java`: This executes a JRE'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`：这执行JRE'
- en: 'Others: Located in the JDK `bin` directory'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他：位于JDK `bin`目录中
- en: 'The code is written (*Example 2.1*) and stored in a `.java` file and compiled
    using the `javac` command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被编写（*示例2.1*）并存储在`.java`文件中，使用`javac`命令进行编译：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 2.1 – Simple Java program as an executable class that can also be run
    directly without a compilation step since Java SE 11 (*Reference 26*)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.1 – 简单的 Java 程序作为一个可执行类，也可以直接运行而不需要编译步骤，因为 Java SE 11 (*参考 26*)
- en: 'Next, it is possible to create and compile a class with bytecode inside (*Example
    2.2*). Run the file using the `java` command to run the JRE:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以创建并编译一个包含字节码的类（*示例 2.2*）。使用 `java` 命令运行文件以运行 JRE：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 2.2 – Bytecode example from a compiled program displayed by the Java
    program
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.2 – 由 Java 程序显示的编译程序的字节码示例
- en: The JRE
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JRE
- en: 'The JRE is part of the JDK, or it can be distributed as a standalone program
    for the target operating system. To run a file with a `.class` extension or a
    **Java Archive** (**JAR**) file, the target system is required to contain the
    appropriate version of the JRE. Unlike the JDK, the JRE only contains a minimal
    collection of components needed to run the program, such as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JRE 是 JDK 的一部分，或者它可以作为针对目标操作系统的独立程序进行分发。要运行扩展名为 `.class` 的文件或 **Java 归档**（**JAR**）文件，目标系统必须包含适当的
    JRE 版本。与 JDK 不同，JRE 只包含运行程序所需的最小组件集合，例如以下内容：
- en: 'Core libraries and property files: for example, `rt.jar` and `charset.jar`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心库和属性文件：例如，`rt.jar` 和 `charset.jar`
- en: 'Java extension files: Additional libraries that may reside in the `lib` folder'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 扩展文件：可能位于 `lib` 文件夹中的附加库
- en: 'Security-related files: Certificates, policies, and so on'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全相关文件：证书、策略等
- en: Font files
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体文件
- en: Operating system-specific tools
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于操作系统的工具
- en: 'The JRE includes a JVM and precisely two types of compilers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JRE 包含 JVM 和精确两种类型的编译器：
- en: '**Client Compiler**: Fast loading without optimization. It is designed to run
    the instructions to obtain a result very quickly. Commonly used for standalone
    programs.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端编译器**：快速加载而不进行优化。它旨在快速运行指令以获得结果。通常用于独立程序。'
- en: '**Server Compiler**: Loaded code goes through additional checks to ensure code
    stability. There is also an effort to produce highly optimized machine code to
    deliver better performance. It supports better statistics in order to run machine
    code optimization executed by the **Just-in-Time** (**JIT**) compiler (*Figure
    2**.2*).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器编译器**：加载的代码会经过额外的检查以确保代码稳定性。还有努力产生高度优化的机器代码以提供更好的性能。它支持更好的统计信息，以便运行由 **即时**（**JIT**）编译器执行的机器代码优化（*图
    2.2*）。'
- en: The JVM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM
- en: Both the JDK and the JRE contain the JVM (*Reference 6*). The JVM is platform-dependent.
    This means that every system platform requires the use of a dedicated version.
    Fine, but what does the JVM really do, and how?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 和 JRE 都包含 JVM（*参考 6*）。JVM 是平台相关的。这意味着每个系统平台都需要使用专用版本。好吧，但 JVM 究竟做什么，以及如何做？
- en: Although there are multiple versions of the JVM, even from multiple vendors,
    the JVM itself is defined by a specification that must be followed. The reference
    implementation is represented by OpenJDK. In fact, OpenJDK is a collection of
    several smaller open source projects that may even have different development
    dynamics, but the OpenJDK release contains planned versions of each.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多个版本的 JVM，甚至来自多个供应商，但 JVM 本身是由一个必须遵循的规范定义的。参考实现由 OpenJDK 表示。实际上，OpenJDK 是几个较小的开源项目的集合，这些项目甚至可能具有不同的开发动态，但
    OpenJDK 发布包含每个计划的版本。
- en: '![Figure 2.2 – Key parts of the JVM](img/B18884_02_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – JVM 的关键部分](img/B18884_02_02.jpg)'
- en: Figure 2.2 – Key parts of the JVM
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – JVM 的关键部分
- en: The OpenJDK JVM implementation (*Figure 2**.2*) includes a JIT compiler called
    **HotSpot** (*Reference 7*). HotSpot is part of the JVM and its responsibility
    is runtime compilation. In other words, the JIT compiler translates or compiles
    the provided bytecode into a native system instruction at runtime. This process
    is sometimes called **dynamic translation**. Due to these JVM dynamic translation
    capabilities, Java applications are sometimes referred to as system platform-independent
    and the WORA acronym is used. This statement needs to be abstracted slightly because
    a JVM system implementation is required to translate the bytecode into a native
    instruction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK JVM 实现包括一个称为 **HotSpot**（*参考 7*）的 JIT 编译器。HotSpot 是 JVM 的一部分，其责任是运行时编译。换句话说，JIT
    编译器在运行时将提供的字节码转换为本地系统指令。这个过程有时被称为 **动态转换**。由于 JVM 的这些动态转换能力，Java 应用程序有时被称为系统平台无关，并使用
    WORA 这个缩写。这个陈述需要稍微抽象一下，因为需要 JVM 系统实现来将字节码转换为本地指令。
- en: In addition to the JVM JIT compiler, it includes a garbage collector with various
    algorithms, a class loader, a Java memory implementation model, and a **Java Native
    Interface** (**JNI**) with libraries (as shown in *Figure 2**.2*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JVM JIT编译器外，它还包括具有各种算法的垃圾收集器、类加载器、Java内存实现模型以及带有库的**Java本地接口**（**JNI**）（如图2**.2*所示）。
- en: Every JVM provider must follow the specifications. This guarantees that the
    bytecode will not only be created accordingly but also executed and correctly
    converted into machine instructions. This means that different vendors may provide
    different JVM implementations with slightly different metrics or optimizations,
    such as garbage collector dynamics. These vendors include IBM, Azul, Oracle, and
    so on. The diversity of vendors can be considered one of the main moving factors
    for the Java platform's evolution. New features are extended or modified through
    the **JDK Enhancement Proposal** (**JEP**), where each vendor can contribute or
    get a very detailed overview.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JVM提供者都必须遵循规范。这保证了字节码不仅会被相应地创建，而且会被执行并正确地转换为机器指令。这意味着不同的供应商可能提供具有略微不同指标或优化（如垃圾收集器动态）的不同JVM实现。这些供应商包括IBM、Azul、Oracle等。供应商的多样性可以被认为是Java平台演化的主要推动因素之一。新功能通过**JDK增强提案**（**JEP**）进行扩展或修改，其中每个供应商都可以做出贡献或获得非常详细的概述。
- en: 'To summarize, the JVM’s responsibilities to remember are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，JVM需要记住的责任如下：
- en: Loading linking
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载链接
- en: Initiating classes and interfaces
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化类和接口
- en: Program instruction execution
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序指令执行
- en: The JVM defines several different areas used by each program (*Example 2.2*).
    Let’s look at each of them one by one, area by area (*Figure 2**.2*). This can
    boost our understanding of the value of design patterns and their approaches,
    such as the Builder or Singleton pattern.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JVM定义了多个不同区域，每个程序都会使用到（*示例2.2*）。让我们逐个查看它们，一个区域一个区域（*图2**.2*）。这可以增强我们对设计模式及其方法，如Builder或Singleton模式的价值的理解。
- en: '![Figure 2.3 – Simplified schema of program compilation and execution](img/B18884_02_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 程序编译和执行的简化方案](img/B18884_02_03.jpg)'
- en: Figure 2.3 – Simplified schema of program compilation and execution
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 程序编译和执行的简化方案
- en: It all starts with written text, representing a program stored in a `.java`
    file. The file will be compiled (*Figures 2.3*) and run (*Figure 2**.4*) and threads
    are started. Startup starts the system process in which the JRE is running and
    the JVM is running as part of the JRE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一切始于书面文本，代表存储在`.java`文件中的程序。文件将被编译（*图2.3*）并运行（*图2**.4*），线程将被启动。启动启动了运行JRE的系统进程，JVM作为JRE的一部分运行。
- en: "![Figure 2.4 – Threads\uFEFF that started behind the scene event for a Program.java\
    \ execution example (Java Flight Recorder)](img/B18884_02_04.jpg)"
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 程序.java执行示例背后的场景事件启动的线程（Java飞行记录器）](img/B18884_02_04.jpg)'
- en: Figure 2.4 – Threads that started behind the scene event for a Program.java
    execution example (Java Flight Recorder)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 程序.java执行示例背后的场景事件启动的线程（Java飞行记录器）
- en: With a general idea of the flow, let’s start by loading classes into memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在对流程有一个大致的了解后，我们首先将类加载到内存中。
- en: The class-loader loader area
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类加载器加载区域
- en: 'The class loader subsystem is located in **Random-Access Memory** (**RAM**)
    and is responsible for loading classes into memory. The load step consists of
    the sub-line steps and the first run of the class at runtime. Linking is the process
    of preparing a class or interface for a runtime environment, which may include
    internal dependencies, for example. The platform provides internal functions or
    customized ones; to manage all these capabilities, the platform provides dedicated
    class loaders:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器子系统位于**随机存取存储器**（**RAM**）中，负责将类加载到内存中。加载步骤包括子步骤和类在运行时的首次运行。链接是将类或接口准备为运行时环境的过程，这可能包括内部依赖项，例如。平台提供内部函数或自定义函数；为了管理所有这些功能，平台提供专门的类加载器：
- en: '`BOOTPATH` (property).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOTPATH`（属性）。'
- en: '`lib/ext` directory, which is a part of the JRE installation.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/ext`目录，它是JRE安装的一部分。'
- en: '`main` method and runs the classes from the served class or module path.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`方法并运行来自服务类或模块路径的类。'
- en: '`ClassLoader` and may be used to define custom classes dynamically loading
    processes to the JVM. It is possible to use a user-defined class destination.
    Classes can reside on the network, be encrypted inside files, or be downloaded
    across the network and generated on the fly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassLoader` 可以用来定义动态加载到 JVM 中的自定义类的过程。可以使用用户定义的类目标。类可以位于网络上，存储在文件中的加密状态，或者通过网络下载并在运行时生成。'
- en: Class loaders work in sequence. The sequence is represented by a hierarchy.
    This means that every child must refer to its parents. This automatically defines
    the search order of the binary classes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器按顺序工作。顺序由一个层次结构表示。这意味着每个子类必须引用其父类。这自动定义了二进制类的搜索顺序。
- en: When a class is present in RAM, the Java platform takes action to make the class
    available to the runtime environment. The Java platform runs several processes
    behind the scenes to move relevant class data to other areas, such as the stack,
    heap, and so on. Let’s look at the stack area next.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类存在于 RAM 中时，Java 平台会采取行动使该类可供运行时环境使用。Java 平台在幕后运行多个进程，将相关的类数据移动到其他区域，例如栈、堆等。接下来让我们看看栈区域。
- en: The stack area
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈区域
- en: The stack area (*Figure 2**.2*) is reserved for each thread at runtime. This
    is a small area for storing method references. When a thread executes a method,
    one entry for that method is created and moved to the top of the stack. This kind
    of item is called a stack frame, which has a reference to a field of local variables,
    a stack of operands, and a constant pool to identify the appropriate method. The
    stack frame is removed when the method is executed normally – that is, without
    causing any exceptions. This means that local primitive variables such as `boolean`,
    `byte`, `short`, `char`, `int`, `long`, `float`, and `double` are also stored
    here, so they are not visible to the second thread. Each thread can pass a copy,
    but this does not share the origin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 栈区域（*图 2**.2*）在运行时为每个线程保留。这是一个用于存储方法引用的小区域。当一个线程执行一个方法时，为该方法创建一个条目并将其移动到栈顶。这种项目被称为栈帧，它引用局部变量的字段、操作数的栈和一个常量池以识别适当的方法。当方法正常执行时（即没有引发任何异常）会移除栈帧。这意味着局部原始变量，如
    `boolean`、`byte`、`short`、`char`、`int`、`long`、`float` 和 `double` 也存储在这里，因此它们对第二个线程不可见。每个线程可以传递一个副本，但这并不共享原始数据。
- en: The heap area
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆区域
- en: The heap is the allocated memory where all instances of the class and array
    are located. The heap is allocated at startup and is shared among all JVM-initiated
    threads. Allocated memory is automatically recovered by the automated management
    system process, also known as **Garbage Collection** (**GC**). A local variable
    can contain a reference to objects. The referenced object is located in a heap.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是所有类的实例和数组所在分配的内存。堆在启动时分配，并由所有 JVM 启动的线程共享。分配的内存由自动管理系统进程自动回收，也称为**垃圾回收**（**GC**）。局部变量可以包含对对象的引用。引用的对象位于堆中。
- en: The method area
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法区域
- en: The method area is shared across all JVM-initiated threads. The area is allocated
    during the JVM startup time. It contains runtime data for each class, such as
    a constant pool, field and method data, the code for constructors, and methods.
    Probably the most unfamiliar term mentioned is the constant pool. The constant
    pool is created during the process of loading the class into the method area.
    It contains the initial values of string and primitive constants, the names of
    the reference classes and other data needed to properly execute the loaded class,
    the constants known at compile time, and field references that must be resolved
    at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法区域是所有由 JVM 启动的线程共享的。该区域在 JVM 启动时分配。它包含每个类的运行时数据，例如常量池、字段和方法数据、构造函数和方法的代码。提到的不太熟悉的概念可能是常量池。常量池是在将类加载到方法区域的过程中创建的。它包含字符串和原始常量的初始值、引用类的名称以及其他执行加载的类所需的数据，包括编译时已知的常量和必须在运行时解析的字段引用。
- en: Program counter
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序计数器
- en: The **Program Counter** (**PC**) register is another important reserved area
    in memory. It contains a list of created program counters. A PC record is created
    at the beginning of each thread and contains the address of the currently executed
    instruction by a specific thread. The address points back to the method area.
    The only exception is the native method, which leaves the address undefined.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）寄存器是内存中的另一个重要预留区域。它包含创建的程序计数器列表。每个线程的开始都会创建一个PC记录，包含特定线程当前执行的指令的地址。该地址指向方法区。唯一的例外是原生方法，它将地址设置为未定义。'
- en: The native method stack
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: 'A native method stack record is initiated for each individual thread. Its function
    is to provide access to native methods through the JNI. The JNI operates with
    the underlying system resources. Improper usage may turn into two exceptional
    states:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个单独的线程启动一个原生方法栈记录。其功能是通过JNI提供对原生方法的访问。JNI与底层系统资源一起操作。不当使用可能导致两种异常状态：
- en: The first exception appears when a thread requires more stack space. In this
    case, a `StackOverflowError` error is thrown and the program crashes, executed
    with a state higher than 1.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个异常出现在线程需要更多栈空间时。在这种情况下，会抛出`StackOverflowError`错误，程序崩溃，执行状态高于1。
- en: The second case represents an attempt to add more entries to the stack. The
    program results in an `OutOfMemoryError` error. It is caused by an attempt to
    dynamically expand already fully allocated memory space. The memory is insufficient
    and it is not possible to allocate a new stack for the newly intended thread.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况代表尝试向栈中添加更多条目。程序结果是一个`OutOfMemoryError`错误。这是由于尝试动态扩展已完全分配的内存空间。内存不足，无法为新线程分配新的栈空间。
- en: We have examined all the areas required to load and execute a program and we
    will get acquainted with the areas where the data is located and how they are
    interconnected. It is slowly becoming clear that in order to achieve stability
    and maintainability of the program at runtime, it is necessary to design the software
    in a way that reflects the potential limitations, as the reserved areas correspond
    to the individual areas.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了加载和执行程序所需的所有区域，我们将了解数据所在区域及其相互关联的方式。逐渐变得明显的是，为了在运行时实现程序的可稳定性和可维护性，有必要以反映潜在限制的方式设计软件，因为预留区域对应于各个区域。
- en: Let’s take a closer look at how the Java platform provides available memory
    space for each newly created object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看Java平台是如何为每个新创建的对象提供可用内存空间的。
- en: Reviewing GC and the Java memory model
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾GC和Java内存模型
- en: We mentioned the JIT compiler as part of the JVM earlier (*Figure 2**.2*). Just
    to refresh on the JIT compiler, it is responsible for translating the bytecode
    into system-specific native instructions. These instructions deal with the basic
    memory and I/O resources available to the program. To properly organize these
    instructions, the Java platform requires a set of rules that guarantee the program,
    called bytecode, which must be translated by the JIT compiler at runtime to the
    same end. Because the Java platform does not use physical memory directly, but
    rather virtual and cached views, it is very important that the memory management
    is transparent. The model must provide the required guarantees and is known as
    the **Java Memory** **Model** (**JMM**).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到JIT编译器是JVM的一部分（*图2.2*）。为了刷新一下JIT编译器的概念，它负责将字节码转换为系统特定的原生指令。这些指令处理程序可用的基本内存和I/O资源。为了正确组织这些指令，Java平台需要一套规则来保证程序，即字节码，在运行时必须由JIT编译器转换为相同的最终状态。因为Java平台不直接使用物理内存，而是使用虚拟和缓存的视图，内存管理必须透明。该模型必须提供所需的保证，并被称为**Java内存模型**（**JMM**）。
- en: The JMM
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JMM
- en: The JMM describes how threads interact with each other through access to allocated
    memory – the heap (*Figure 2**.2*). The execution of a single-threaded program
    may seem obvious because the instructions are processed in a certain order without
    external influence and the thread is in isolation. In the case of a single thread
    (see the `main` method in *Example 2.2* and the `main` thread in *Figure 2**.4*),
    the run areas are modified each time the instruction is executed; there is no
    surprise. The situation changes when the program starts multiple threads. The
    JMM enforces its guarantees of reliable Java program execution. The JMM defines
    a set of rules for possible instruction order changes and execution restrictions
    caused by sharing objects in memory between different threads. The fact that the
    JMM strictly follows these rules forces JIT optimization without fear of code
    instability (maintaining a consistent state).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JMM描述了线程如何通过访问分配的内存（*图2.2*）相互交互。单线程程序的执行可能看起来很明显，因为指令以某种顺序处理，没有外部影响，线程是隔离的。在单线程的情况下（参见*示例2.2*中的`main`方法和*图2.4*中的`main`线程），每次执行指令时都会修改运行区域；没有惊喜。当程序启动多个线程时，情况就改变了。JMM强制执行其关于可靠Java程序执行的保证。JMM定义了一组规则，用于可能指令顺序更改和由不同线程之间在内存中共享对象引起的执行限制。JMM严格遵循这些规则的事实，使得JIT优化无需担心代码不稳定（保持一致状态）。
- en: The rules can easily be reformulated and each action can be changed as long
    as the execution of the thread does not violate the program order. Basically,
    this means that the program remains in a consistent state.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可以很容易地重新表述，只要线程的执行不违反程序顺序，每个动作都可以更改。基本上，这意味着程序保持一致状态。
- en: Object locks or releases are governed by the order of the program and each thread
    shares a corresponding memory view of the modified data. The memory view represents
    the portion of allocated physical memory represented by the heap because each
    object created is located inside the heap.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的锁定或释放由程序顺序控制，每个线程共享修改数据的相应内存视图。内存视图表示由堆表示的已分配物理内存的部分，因为每个创建的对象都位于堆内。
- en: One of the important guarantees of the JMM is known as happens-before. It states
    that one action always happens before another in order to maintain the order of
    the program. To better understand this rule, it is necessary to describe how system
    memory works and briefly introduce the general types of memory and how the CPU
    fits into the process of reading values and executing machine instructions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JMM的一个重要保证被称为happens-before。它指出，为了保持程序顺序，一个动作总是发生在另一个动作之前。为了更好地理解这条规则，有必要描述系统内存的工作方式，并简要介绍内存的一般类型以及CPU如何适应读取值和执行机器指令的过程。
- en: Let us start with the CPU. Each CPU contains its own instruction register. The
    machine code compiled by the JIT compiler has a reference to an available set
    of instructions. The CPU contains an internal cache used to store a copy of data
    from the main RAM. The CPU communicates with the reserved RAM. One CPU can run
    multiple platform threads (depending on the type of CPU) at the same time. The
    result of this embodiment modifies the state of the RAM in the thread stack or
    heap. The dedicated RAM for the running Java application is then copied to the
    CPU cache and used by the CPU registry (*Figure 2**.5*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从CPU开始。每个CPU都包含自己的指令寄存器。JIT编译器编译的机器代码有一个对可用指令集的引用。CPU包含一个内部缓存，用于存储主RAM中的数据副本。CPU与保留的RAM进行通信。一个CPU可以同时运行多个平台线程（取决于CPU的类型）。这种实现的结果会修改线程堆栈或堆中的RAM状态。然后，运行Java应用程序的专用RAM被复制到CPU缓存中，并由CPU寄存器使用（*图2.5*）。
- en: '![Figure 2.5 – CPU and memory interaction](img/B18884_02_05.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – CPU和内存交互](img/B18884_02_05.jpg)'
- en: Figure 2.5 – CPU and memory interaction
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – CPU和内存交互
- en: 'Those who are attentive may have already noticed that due to memory differentiation,
    the program can face unpredictable difficulties caused by looking at the program’s
    memory. When multiple threads try to update or read specific values of variables
    without careful handling, this can result in one of the following problems:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察的人可能已经注意到，由于内存差异，程序可能会面临由查看程序内存引起的不可预测的困难。当多个线程试图在不加小心处理的情况下更新或读取变量的特定值时，这可能导致以下问题之一：
- en: '**A racing condition**: This occurs when two threads attempt to access the
    same value in an unsynchronized manner.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：当两个线程以非同步方式尝试访问相同的值时，就会发生这种情况。'
- en: '**Value update visibility**: A variable update that is shared between multiple
    threads has not been propagated to the main memory, so other threads get the old
    value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值更新可见性**：在多个线程之间共享的变量更新尚未传播到主内存，因此其他线程得到旧值。'
- en: To address these challenges, let’s analyze a real access to variables. What
    is already known is that each value is located within the allocated RAM heap.
    It seems obvious that updating the status of each variable may cause some penalties,
    as each instruction has to take a whole journey (*Figure 2**.5*). In most cases,
    this is also not necessary. A good example is the implementation of an isolated
    method (*Example 2.2*). However, there are cases where the actual value of a variable
    is required from memory, for which the Java platform has introduced the `volatile`
    keyword. Using the `volatile` keyword before a variable gives the variable a guarantee
    that when another thread requests a value, it checks its current value in the
    main memory. This means that using the `volatile` keyword provides a guarantee
    of happens-before and each thread sees its true value. It is fair to note that
    because using `volatile` provides a certain level of memory synchronization, it
    should be used wisely. Its use is associated with performance limitations caused
    by main memory access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，让我们分析一个对变量的实际访问。已知的是，每个值都位于分配的RAM堆中。显然，更新每个变量的状态可能会带来一些惩罚，因为每个指令都必须走完整个旅程（*图2.5*）。在大多数情况下，这也不是必要的。一个很好的例子是隔离方法的实现（*示例2.2*）。然而，在某些情况下，需要从内存中获取变量的实际值，为此Java平台引入了`volatile`关键字。在变量前使用`volatile`关键字为变量提供了一个保证，即当另一个线程请求值时，它会检查主内存中的当前值。这意味着使用`volatile`关键字提供了一种happens-before的保证，并且每个线程都能看到其真实值。值得注意的是，由于使用`volatile`提供了一定程度的内存同步，因此应谨慎使用。它的使用与由主内存访问引起的性能限制相关。
- en: Another approach to sharing variable values across multiple threads is to use
    the `synchronized` keyword. Its use gives the method or variable a guarantee that
    each participant, the thread, will be informed about the approaches. Obviously,
    the main disadvantage of using `synchronized` is that all threads will be informed
    about access to the method or variables, which in turn, will cause a decrease
    in performance due to memory synchronization. As with `volatile`, `synchronized`
    guarantees happens-before.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程之间共享变量值的另一种方法是使用`synchronized`关键字。它的使用为方法或变量提供了一个保证，即每个参与者，即线程，都会被告知这些方法。显然，使用`synchronized`的主要缺点是所有线程都会被告知对方法或变量的访问，这反过来又会因为内存同步而导致性能下降。与`volatile`一样，`synchronized`保证了happens-before。
- en: The JMM is bright and fresh; we stated that each new object is located in the
    heap (*Figure 2**.2*). We are familiar with the big picture of the JRE architecture,
    and we know that most Java programs seem to be multi-threaded – there is a set
    of rules that the Java platform follows so that the process forces the correct
    order of programs to achieve consistency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JMM是明亮且新鲜的；我们提到每个新对象都位于堆中（*图2.2*）。我们对JRE架构的大致情况很熟悉，我们知道大多数Java程序似乎是多线程的——Java平台遵循一组规则，以便进程强制程序的正确顺序以实现一致性。
- en: GC and automatic memory management
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC和自动内存管理
- en: Although the Java platform may give the impression that the underlying memory
    is unlimited, this is not true and we will examine it next. So far, we have looked
    at how variable visibility works across multiple threads and how values are referenced
    in physical memory. The JMM is just one part of the whole story – let’s continue
    the investigation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java平台可能给人留下底层内存无限的印象，但这并不正确，我们将在下一节中探讨这一点。到目前为止，我们已经探讨了变量在多个线程之间的可见性工作原理以及如何在物理内存中引用值。JMM只是整个故事的一部分——让我们继续调查。
- en: We already know that the Java platform uses an automatic memory management process
    to maintain the allocated memory for the heap. Part of the process is a program
    that runs in the background of the daemon thread. It is called the garbage collector
    (*Reference 5*) and runs silently behind the scenes, reclaiming and compacting
    unused memory. This is one of the advantages of the dynamic allocation of objects
    in the heap. Another perhaps less obvious advantage is the ability to work with
    recursive data structures, such as lists or maps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Java平台使用自动内存管理过程来维护堆分配的内存。这个过程的一部分是一个在守护线程后台运行的程序。它被称为垃圾回收器（*参考5*），在幕后默默运行，回收和压缩未使用的内存。这是堆中对象动态分配的一个优点。另一个可能不那么明显的优点是能够处理递归数据结构，例如列表或映射。
- en: GC was invented around 1959 by John McCarthy. The goal was to simplify manual
    memory management in Lisp. Since then, GC has undergone massive development and
    various GC techniques have been invented (*Reference 1*). Even after the development
    of various GC approaches, the security rule remains the most important. The GC
    should never regain a repository of live objects that contain active references.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收（GC）大约在1959年由约翰·麦卡锡发明。目标是简化Lisp中的手动内存管理。从那时起，GC经历了大规模的发展，并发明了各种GC技术（*参考1*）。即使在各种GC方法的发展之后，安全规则仍然是最重要的。GC永远不应该恢复包含活动引用的活对象存储库。
- en: Although the developer does not have to bother with memory reclamation, it can
    be very useful to understand the underlying process to avoid unexpected application
    failures because system memory is limited in one way or another. The reason remains
    that even if the GC is in place, it is possible to create code that never loads
    the object, which means that the application may crash with an `OutOfMemoryError`
    error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者不必担心内存回收，但了解底层过程可以非常有用，以避免意外的应用程序失败，因为系统内存总是有限的。原因在于，即使GC已经到位，仍然可能编写永远不会加载对象的代码，这意味着应用程序可能会因为`OutOfMemoryError`错误而崩溃。
- en: 'The goal of the GC process is to keep the heap nice and shiny, ready to allocate
    a new object. The heap area is divided into smaller segments as shown in *Figure
    2**.6*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: GC过程的目标是保持堆干净整洁，准备好分配新的对象。堆区域被划分为更小的段，如图*图2.6*所示：
- en: '![Figure 2.6 – Simplified heap structure divided into promotion segments](img/B18884_02_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 简化的堆结构分为晋升段](img/B18884_02_06.jpg)'
- en: Figure 2.6 – Simplified heap structure divided into promotion segments
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 简化的堆结构分为晋升段
- en: It is a known fact that most objects will be allocated and placed in Eden’s
    memory and will not survive the second round of cleanup. After performing Minor
    GC, all surviving objects are moved to one of the surviving spaces (denoted by
    **S0** and **S1**). The secondary GC round also checks the **S0** and **S1** fields
    and spreads them among the others at a time when one of the survival sites may
    be empty. The object survived; many Minor GCs have been moved to the **Old generation**.
    The heap also contains a permanent section. The permanent section contains the
    metadata required by the JVM to describe classes, static methods, and private
    variables, and is populated at runtime. This area was formerly known as the **Permanent
    generation** (**Permgen**). It was separated from the main heap memory, was not
    loaded, and had to be configured. This disadvantage often led to application instability
    due to insufficient memory requirements. Java SE 8 introduced MetaSpace, which
    replaced the Permgen concept. MetaSpace has solved the problem of space configuration
    because it can grow automatically and in addition, garbage can be collected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，大多数对象将被分配并放置在伊甸园内存中，并且不会在第二次清理中存活。在执行Minor GC之后，所有存活的对象都被移动到其中一个存活空间（用**S0**和**S1**表示）。次要GC轮次也会检查**S0**和**S1**字段，并在其中一个存活位置可能为空的时候将它们分散到其他地方。对象存活了；许多Minor
    GC已经移动到**老年代**。堆还包含一个永久部分。永久部分包含JVM描述类、静态方法和私有变量所需的元数据，并在运行时填充。这个区域以前被称为**永久代**（**Permgen**）。它从主堆内存中分离出来，没有加载，并且需要配置。这个缺点经常由于内存需求不足而导致应用程序不稳定。Java
    SE 8引入了MetaSpace，取代了Permgen概念。MetaSpace解决了空间配置问题，因为它可以自动增长，此外，垃圾也可以被回收。
- en: 'GC works essentially in two steps, described as Minor and Major GC. These steps
    are a proposal for building on the basis of durability – that is, long-term references:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: GC基本上分为两个步骤，称为Minor和Major GC。这些步骤是基于持久性的建议 – 即，长期引用：
- en: '**Minor GC**: This happens when there is no reference to the object, the object
    is marked as unreachable, the Young generation area is reclaimed, and the memory
    can be compacted.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minor GC**：当没有引用到对象时，对象被标记为不可达，年轻代区域被回收，内存可以进行压缩。'
- en: '**Major/Full GC**: An object that has survived several Minor GCs and has been
    moved to an Old generation heap area. After a long time, it does not refer to
    any other object, no other object refers to it, and it is ready to be deleted.
    Full GC is less common than Minor GC and there is a long pause (stop-the-world).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Major/Full GC**：一个已经经历了几次Minor GC并移动到老年代堆区的对象。经过一段时间后，它不再引用任何其他对象，没有其他对象引用它，它准备被删除。Full
    GC比Minor GC少见，并且有一个较长的暂停（停止世界）。'
- en: 'The GC process can be simplified with three steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GC过程可以用三个步骤简化：
- en: 'In the first step, GC marks unreachable objects (*Figure 2**.7*):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，GC标记不可达的对象（**图2.7**.7）：
- en: '![Figure 2.7 – The first collection marking step identifies unused objects
    in the heap](img/B18884_02_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 第一收集标记步骤识别堆中的未使用对象](img/B18884_02_07.jpg)'
- en: Figure 2.7 – The first collection marking step identifies unused objects in
    the heap
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 第一收集标记步骤识别堆中的未使用对象
- en: 'In the second step, the links are removed and the space is left free as it
    was (*Figure 2**.8*):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，移除链接，空间保持空闲，就像它之前一样（**图2.8**）：
- en: '![Figure 2.8 – Freeing memory by deleting marked objects](img/B18884_02_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 通过删除标记对象释放内存](img/B18884_02_08.jpg)'
- en: Figure 2.8 – Freeing memory by deleting marked objects
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 通过删除标记对象释放内存
- en: 'The third step is called compacting (*Figure 2**.9*). It reorganizes the memory
    into larger parts, so when a program tries to allocate a larger object, space
    is ready for it. This makes memory allocation for all objects much faster not
    only due to the free space but also eliminates the need to scan a free memory
    frame:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步称为压缩（**图2.9**）。它将内存重新组织成更大的部分，因此当程序尝试分配更大的对象时，空间已经准备好。这使得所有对象的内存分配速度大大加快，不仅因为空闲空间，还消除了扫描空闲内存帧的需要：
- en: '![Figure 2.9 – Compacting freed memory to be able to allocate bigger objects
    in frames](img/B18884_02_09.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 压缩释放的内存以便在帧中分配更大的对象](img/B18884_02_09.jpg)'
- en: Figure 2.9 – Compacting freed memory to be able to allocate bigger objects in
    frames
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 压缩释放的内存以便在帧中分配更大的对象
- en: 'With a fresh awareness of the tasks of the JMM and GC, there is another important
    concept related to both. The concept of reference types is a way to tell the platform
    how to handle a specific allocated part of the heap space – more specifically,
    how to help the platform’s internal analytical processes. Reference types have
    been added to help GC to evaluate the purpose of variables. This means speeding
    up the decision of whether to collect the variable or not. The concept of a reference
    type is a neat tool, along with a design pattern, and previously renewed themes
    make even more sense. The goal of every program is to run as fast as possible.
    This means that even the waste collection process causes pauses, so it must be
    as fast as possible. Hence, internal platform processes must also be as fast as
    possible. So, regardless of the GC algorithm used, when the dataset is small,
    the process will be much faster. There’s also a place for reference types to help
    keep the allocated memory fresh and clean. The platform offers the following types,
    sorted by their resilience to GC:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在对JMM和GC的任务有了新的认识之后，还有一个与两者都相关的重要概念。引用类型的概念是一种告诉平台如何处理堆空间中特定分配部分的方式 – 更具体地说，如何帮助平台的内部分析过程。引用类型被添加以帮助GC评估变量的目的。这意味着加快是否收集变量的决策。引用类型的概念是一个整洁的工具，与设计模式相结合，以及之前更新的主题，使事情更有意义。每个程序的目标是尽可能快地运行。这意味着即使是垃圾收集过程也会导致暂停，所以它必须尽可能快。因此，内部平台过程也必须尽可能快。所以，无论使用哪种GC算法，当数据集较小时，过程会快得多。引用类型也有助于保持分配的内存新鲜和干净。平台提供了以下类型，按其抵抗GC的能力排序：
- en: '**Strong references**: The most common type of reference – not required to
    be specified.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强引用**：最常见的引用类型 – 不需要指定。'
- en: '`var obj = new WeakReference<Object>();` – and it’s a signal to the GC algorithm
    to reclaim memory during the next GC cycle. This is mostly used during a program
    initiation phase or caching.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var obj = new WeakReference<Object>();` – 这是向GC算法发出信号，在下一个GC周期回收内存。这主要用于程序初始化阶段或缓存。'
- en: '`OutOfMemoryError` error.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutOfMemoryError`错误。'
- en: '**Phantom reference**: This represents the weakest type of reference. This
    team is collected as soon as possible, which means there is no further analysis
    or promotion to another level. A variable of this type is reclaimed immediately
    when the GC cycle runs.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚引用**：这代表最弱类型的引用。这种引用会尽快被收集，这意味着没有进一步的分析或提升到另一个级别。当GC周期运行时，此类类型的变量会立即被回收。'
- en: Before embarking on the Java API journey, let’s quickly summarize our newly
    acquired knowledge.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始Java API之旅之前，让我们快速总结一下我们新获得的知识。
- en: References play an important role in the GC process. They tell garbage collectors
    how to handle a particular variable. The Java memory model provides the required
    guarantees as to how the value of a variable is read, updated, or deleted. We
    examined how values are stored in allocated memory, memory segmentation, and their
    relationship to the underlying system. All this new information helps us with
    better software design and API usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 引用在GC过程中扮演着重要角色。它们告诉垃圾收集器如何处理特定的变量。Java内存模型提供了关于变量值如何读取、更新或删除的必要保证。我们探讨了值在分配内存中的存储、内存分段及其与底层系统的关系。所有这些新信息都有助于我们进行更好的软件设计和API使用。
- en: Examining the core Java APIs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查核心Java API
- en: The JDK provides a set of tools for creating, compiling, and running the required
    Java program. We learned how this program uses basic resources to provide the
    desired result. We have also examined a number of limitations that we must take
    into account when designing this kind of program. The JDK provides tools for software
    designers by making an internal collection of classes grouped into APIs available.
    The previous section explored how the JDK can be extended with external APIs that
    can be added on demand (discussed earlier in *The* *JRE* section).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JDK提供了一套用于创建、编译和运行所需Java程序的工具。我们学习了该程序如何使用基本资源来提供所需的结果。我们还检查了在设计此类程序时必须考虑的许多限制。通过使内部类集合分组到API中可用，JDK为软件设计师提供了工具。上一节探讨了如何通过外部API扩展JDK，这些API可以根据需要添加（在*JRE*部分中讨论过）。
- en: In this section, we will discuss the most important basic APIs we use for design
    patterns in detail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细讨论我们用于设计模式的最重要基本API。
- en: Java is an object-oriented language with many other features and extensions.
    The official basic Java API can be found in the `java. *` package (as listed in
    *Table 2.1*).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种面向对象的语言，具有许多其他特性和扩展。官方基本Java API可以在`java.*`包中找到（如*表2.1*所示）。
- en: '| **Sub-package** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **子包** | **描述** |'
- en: '| `java.io.*` | Related to system I/O through data streams, serialization,
    and filesystems |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `java.io.*` | 通过数据流、序列化和文件系统与系统I/O相关 |'
- en: '| `java.lang.*` | Automatically imported fundamental classes for the Java language
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.*` | Java语言自动导入的基本类 |'
- en: '| `java.math.*` | Classes related to the arbitrary precision arithmetic for
    integers (`BigInteger`) and decimals (`BigDecimal`) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `java.math.*` | 与整数（`BigInteger`）和小数（`BigDecimal`）的任意精度算术相关的类 |'
- en: '| `java.net.*` | APIs related to network protocols and communication |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `java.net.*` | 与网络协议和通信相关的API |'
- en: '| `java.nio.*` | An overview of buffer definitions as data containers and other
    non-blocking packages |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `java.nio.*` | 作为数据容器和其他非阻塞包的缓冲定义概述 |'
- en: '| `java.security.*` | Classes and interfaces for the Java security framework
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `java.security.*` | 用于Java安全框架的类和接口 |'
- en: '| `java.text.*` | Provides classes for handling formatted messages with texts,
    numbers, and dates |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `java.text.*` | 提供用于处理带有文本、数字和日期的格式化消息的类 |'
- en: '| `java.time.*` | APIs for calendars, dates, times, instants, and durations
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.*` | 日历、日期、时间、瞬间和持续时间的API |'
- en: '| `java.util.*` | Serves as a collection framework, string parsing, scanning
    classes, random number generator, Base64 encoders and decoders, and some miscellaneous
    utilities, among other things |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.*` | 作为集合框架、字符串解析、扫描类、随机数生成器、Base64编码器和解码器以及一些其他杂项实用工具 |'
- en: Table 2.1 – java.* packages available in Java 17 SE
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – Java 17 SE中可用的java.*包
- en: Every newly created class can automatically access public classes and interfaces
    that reside in the `java.lang.*` package from the `java.base` module. As everything
    is an object, it implies that each class has an `Object` instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新创建的类都可以自动访问位于`java.lang.*`包中的公共类和接口，这些类和接口位于`java.base`模块中。由于一切都是对象，这意味着每个类都有一个`Object`实例。
- en: Primitive data types and wrappers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数据类型和包装类
- en: Java also provides a set of primitive types (*Reference 4*) called literals
    (*Table 2.2*). One difference between a literal and an `Object` instance is that
    each literal has a well-defined size in memory. In contrast, the size of the `Object`
    instance may vary depending on demand. The literal type of Java is signed, which
    is quite useful to remember if you are dealing with data buffering operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供了一组称为字面量的原始类型（*参考4*），称为字面量（*表2.2*）。字面量和`Object`实例之间的一个区别是，每个字面量在内存中都有一个定义良好的大小。相比之下，`Object`实例的大小可能根据需求而变化。Java的字面量类型是有符号的，如果你在处理数据缓冲操作，这将非常有用记住。
- en: '| **Size** | **Literal name** | **Range** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **字面量名称** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit (*) | `boolean` | `true` or `false` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1位(*) | `boolean` | `true`或`false` |'
- en: '| 1 byte | `byte` | -128 to 127 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1字节 | `byte` | -128到127 |'
- en: '| 2 bytes | `short` | -32,768 to 32,767 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 2字节 | `short` | -32,768到32,767 |'
- en: '| 2 bytes | `char` | \u0000 to \uffff |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 2字节 | `char` | \u0000到\uffff |'
- en: '| 4 bytes | `int` | -2^31 to 2^31-1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 4字节 | `int` | -2^31到2^31-1 |'
- en: '| 4 bytes | `float` | -3.4e38 to 3.4e38 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 4字节 | `float` | -3.4e38到3.4e38 |'
- en: '| 8 bytes | `long` | -2^63 to 2^63-1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 8字节 | `long` | -2^63到2^63-1 |'
- en: '| 8 bytes | `double` | -1.7e308 to 1.7e308 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 8字节 | `double` | -1.7e308到1.7e308 |'
- en: Table 2.2 – Primitive types with their sizes; (*) boolean size is not precisely
    defined
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 – 原始类型及其大小；（*）布尔类型的大小未精确定义
- en: The primitive types reside in the stack area (refer to *Figure 2**.2*) and each
    literal contains a wrapper object (*Figure 2**.10*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型位于栈区（参见图2**.2*）并且每个字面量都包含一个包装对象（*图2**.10*）。
- en: "![Figure 2.10 – Data type wrapper inheritance\uFEFF with the literals with\
    \ String type associations](img/B18884_02_10.jpg)"
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 数据类型包装继承与字面量与String类型关联](img/B18884_02_10.jpg)'
- en: Figure 2.10 – Data type wrapper inheritance with the literals with String type
    associations
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 数据类型包装继承与字面量与String类型关联
- en: 'The envelope is initiated around literal values. This means that the literal
    is stored in the stack area and the wrapper object is located inside the heap.
    The cover provides additional features. Take the `Integer` class as an example,
    which provides the following methods: `byteValue`, `doubleValue`, and `toString`.
    These methods can be called within a specific design pattern to achieve the desired
    goal and avoid unnecessary memory contamination. This is in comparison to literals
    that only provide a native implementation of a value.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 封装围绕字面量值启动。这意味着字面量存储在栈区，而包装对象位于堆中。封面提供了额外的功能。以`Integer`类为例，它提供了以下方法：`byteValue`、`doubleValue`和`toString`。这些方法可以在特定的设计模式中调用以实现预期的目标并避免不必要的内存污染。这与仅提供值原生实现的字面量形成对比。
- en: 'The Java platform automatically addresses the literal to the appropriate wrapper
    class and the like. This fact not only has a bright side but also has a dark side,
    known as an autoboxing issue (*Example 2.3*). This happens exactly when the primitive
    type is cast to a wrapper type. This can lead to very frequent waste collection,
    which can mean an enormous number of stop-the-world events:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台自动将字面量分配给适当的包装类等。这一事实不仅有其光明的一面，也有其阴暗的一面，即所谓的自动装箱问题（*示例2.3*）。这正好发生在原始类型被转换为包装类型时。这可能导致非常频繁的垃圾回收，这可能意味着大量的停止世界事件：
- en: '[PRE2]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 2.3 – Auto-casting example where a new Integer wrapper is created under
    the hood
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.3 – 在幕后创建新的Integer包装器的自动装箱示例
- en: 'When working with literal numbers, it is useful to keep in mind that a literal
    with a smaller byte size (*Table 2.2*) can be automatically assigned to a literal
    with a larger size (*Example 2.4*). The other way around, it causes a compilation
    error due to the precisely allocated byte size in the memory stack area:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字面量数字时，记住一个具有较小字节大小的字面量（*表2.2*）可以自动分配给一个具有较大大小的字面量（*示例2.4*）。反过来，由于内存栈区中精确分配的字节大小，这会导致编译错误：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 2.4 – Literal automatic casting
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.4 – 字面量自动装箱
- en: We have checked the numbering and how automatic submission works on the Java
    platform. A Boolean literal is `true` or `false` and is represented in memory
    as 1 bit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了编号以及Java平台上的自动提交方式。布尔字面量是`true`或`false`，在内存中以1位表示。
- en: The last of the specific literals not yet mentioned is `char` and its cover
    character. Let’s take a closer look because it’s also related to the essential
    `String` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后尚未提到的特定字面量是`char`及其覆盖字符。让我们仔细看看，因为它也与基本的`String`对象有关。
- en: Working with the String API
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用String API
- en: The `String` instance is not literal. A string is represented as an object in
    Java. It is defined by a sequence of characters. It is almost impossible to avoid
    using a string to write any program. In addition to the fact that a Java executable
    requires a `String` field as input to the `main` method, variable names are also
    represented as a string. The string is immutable in Java. This means that any
    operation, such as concatenation, on its value will create a new string. More
    precisely, it is not possible to change its current value. A string is the base
    class of the Java platform.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`实例不是字面量。在Java中，字符串表示为一个对象，由字符序列定义。几乎不可能编写任何程序而不使用字符串。除了Java可执行文件需要将`String`字段作为`main`方法的输入之外，变量名也以字符串的形式表示。在Java中，字符串是不可变的。这意味着对其值的任何操作，如连接，都将创建一个新的字符串。更准确地说，无法更改其当前值。字符串是Java平台的基本类。'
- en: A common way to store a string value is to use a String Pool. The String Pool
    only stores intrinsic values (*Figure 2**.11*). This means that it is only possible
    to have one different constant value present. This approach makes the pool more
    efficient in terms of memory, including time-consuming string operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 存储字符串值的一种常见方式是使用字符串池。字符串池只存储固有值（*图2**.11*）。这意味着只能有一个不同的常量值存在。这种方法在内存效率方面更为高效，包括耗时的字符串操作。
- en: "![Figure 2.11 – The String Pool is a part of the heap memory and a String object\
    \ resides in the heap \uFEFFlike other objects](img/B18884_02_11.jpg)"
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 字符串池是堆内存的一部分，字符串对象像其他对象一样驻留在堆中](img/B18884_02_11.jpg)'
- en: Figure 2.11 – The String Pool is a part of the heap memory and a String object
    resides in the heap like other objects
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 字符串池是堆内存的一部分，字符串对象像其他对象一样驻留在堆中
- en: 'You can also store strings directly in the heap using the `String` constructor
    – for example, `new String`. In this case, the link is not to an equivalent value
    that is already present in the String Pool (represented by `t3` in *Example 2.5*)
    because it is located in a different heap memory space. If you force a search
    in pool strings, you can use the `intern` method (`t4` in *Example 2.5*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`String`构造函数直接在堆中存储字符串 – 例如，`new String`。在这种情况下，链接不是指向字符串池中已存在的等效值（在*示例2.5*中由`t3`表示），因为它位于不同的堆内存空间中。如果您强制在池字符串中进行搜索，可以使用`intern`方法（*示例2.5*中的`t4`）：
- en: '[PRE4]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 2.5 – Comparing different ways of assigning String values
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.5 – 比较不同的字符串值赋值方式
- en: 'Using the `+` operator on String classes can turn into a very inefficient use
    of concatenation or program maintainability. To prevent String contamination,
    the Java platform provides the `StringBuilder` class as part of its APIs. `StringBuilder`
    prevents temporary values from being stored and only stores the result created
    by executing its internal `toString` method, which creates a new `String` object
    in the heap space (*Example 2.6*). `StringBuilder` also introduces the implementation
    and use of the creational design pattern within the Java SDK:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在String类上使用`+`运算符可能会导致连接或程序可维护性非常低效。为了防止字符串污染，Java平台在其API中提供了`StringBuilder`类。`StringBuilder`防止存储临时值，并且只存储执行其内部`toString`方法创建的结果，该方法在堆空间中创建一个新的`String`对象（*示例2.6*）。`StringBuilder`还引入了Java
    SDK中的创建型设计模式和其实施及使用：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 2.6 – StringBuilder creates a new String object by default in the heap
    space
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.6 – StringBuilder默认在堆空间中创建一个新的字符串对象
- en: We found out how String objects are created and in which heap memory they are
    stored. This newly acquired information can strengthen us in making decisions
    by choosing a suitable design pattern or a combination of them to avoid misuse
    of memory. Because the string is under the hood of an array of characters, primitive
    type `char[]`, the array is not primitive – in fact, it is an object. Let’s examine
    this concept a little more closely because it is also essential for the Java language
    and platform.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到 String 对象是如何创建的，以及它们存储在哪个堆内存中。这些新获得的信息可以帮助我们在选择合适的设计模式或它们的组合时做出决策，以避免内存的误用。因为字符串在底层是一个字符数组，原始类型
    `char[]`，所以数组不是原始的——实际上，它是一个对象。让我们更仔细地考察这个概念，因为它对于 Java 语言和平台也是至关重要的。
- en: Introducing arrays
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍数组
- en: 'To understand the Java collections framework better, first, we will look at
    an important concept, arrays. In Java, an array is represented by a sequence of
    the same type of positional index elements. Fields are index-based. Any attempt
    at runtime to get an element from a non-existent position results in `ArrayIndexOutOfBoundsException`.
    The array field is allocated as an object and stored in heap space. This means
    that in the case of insufficient space, an `OutOfMemoryError` exception is thrown.
    Each array requires a defined size due to memory allocation. Simple field allocation
    with literals is relatively memory-efficient (*Example 2.8*):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Java 集合框架，首先，我们将探讨一个重要概念，即数组。在 Java 中，数组通过一系列相同类型的按位置索引元素序列来表示。字段是基于索引的。任何在运行时尝试从不存在位置获取元素的尝试都会导致
    `ArrayIndexOutOfBoundsException` 异常。数组字段作为对象分配并存储在堆空间中。这意味着在空间不足的情况下，会抛出 `OutOfMemoryError`
    异常。由于内存分配，每个数组都需要一个定义的大小。使用字面量进行简单的字段分配相对内存效率较高（*示例 2.8*）：
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 2.8 – Multiple array allocation approaches
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.8 – 多种数组分配方法
- en: 'Arrays allow us to store elements that implement interface classes or a range
    of abstract classes. The field variable declaration does not create or assign
    a new field; the variable contains a field reference (*Example 2.9*):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许我们存储实现接口类或一系列抽象类的元素。字段变量声明不会创建或分配一个新的字段；变量包含一个字段引用（*示例 2.9*）：
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 2.9 – Array initiation, assignment, and verification
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.9 – 数组的初始化、赋值和验证
- en: The use of the field is often neglected due to its potentially precise requirements
    and limited auxiliary methods. However, it can help enforce the open-closed principle,
    which assumes code maintainability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段可能具有精确的要求和有限的辅助方法，其使用往往被忽视。然而，它可以帮助强制执行开放-封闭原则，该原则假设代码的可维护性。
- en: The field is more often replaced by collection or map structures, which provide
    additional helper methods. Let us explore the topic more closely.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 字段通常被集合或映射结构所取代，这些结构提供了额外的辅助方法。让我们更深入地探讨这个主题。
- en: Discovering a collection framework
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现集合框架
- en: Unlike fields, advanced collections provide an automatic resizing feature. This
    means that the required base representation will be copied and the previous version
    will become eligible for GC. The Java collections framework includes `List` (*Table
    2.3*), `Set` (*Table 2.4*), `Queue` (*Table 2.5*), and `Map` interfaces with several
    implementations (*Figure 2**.12*). Implementations may vary by vendor, but all
    must conform to basic specifications.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与字段不同，高级集合提供了自动调整大小的功能。这意味着所需的基本表示将被复制，而之前的版本将变得适合进行垃圾回收。Java 集合框架包括 `List`（*表
    2.3*）、`Set`（*表 2.4*）、`Queue`（*表 2.5*）和 `Map` 接口，以及多个实现（*图 2**.12*）。实现可能因供应商而异，但所有实现都必须符合基本规范。
- en: "![Figure 2.12 – Dependencies between Java collection\uFEFFs framework interfaces](img/B18884_02_12.jpg)"
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – Java 集合框架接口之间的依赖关系](img/B18884_02_12.jpg)'
- en: Figure 2.12 – Dependencies between Java collections framework interfaces
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – Java 集合框架接口之间的依赖关系
- en: The implications of the collection are located in the `java.base` module and
    its `java.util` package. The package contains the most common implementation,
    with the known behavior of time complexity. Space complexity is not very relevant,
    as the framework comes with automatic resizing features. Time complexity can play
    a more important role in selection when it comes to design patterns, as this can
    significantly penalize the response of the proposed program. To assess the time
    complexity of O-notation, O-notation is used to highlight the upper limit and
    the worst-case program must be used to obtain it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的含义位于 `java.base` 模块及其 `java.util` 包中。该包包含最常用的实现，具有已知的时间复杂度行为。空间复杂度不是非常相关，因为框架自带自动调整大小的功能。当涉及到设计模式的选择时，时间复杂度可以发挥更重要的作用，因为这可能会显著惩罚所提出程序的响应。为了评估
    O-符号的时间复杂度，使用 O-符号来突出上限，并必须使用最坏情况的程序来获得它。
- en: To evaluate the impact of time complexity, we can go through some nice examples,
    such as the importance of choosing the right data structure. Let us start with
    the list structures (*Table 2.3*), which allow access to each element using an
    index.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估时间复杂度的影响，我们可以通过一些很好的例子，例如选择正确数据结构的重要性。让我们从列表结构（*表 2.3*）开始，它允许使用索引访问每个元素。
- en: '| **Name** | **Contains** | **Add** | **Get** | **Remove** | **Data structure**
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **包含** | **添加** | **获取** | **移除** | **数据结构** |'
- en: '| `ArrayList` | O(n) | O(1) | O(1) | O(n) | Array |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList` | O(n) | O(1) | O(1) | O(n) | 数组 |'
- en: '| `LinkedList` | O(n) | O(1) | O(n) | O(1) | Linked List |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `LinkedList` | O(n) | O(1) | O(n) | O(1) | 链表 |'
- en: Table 2.3 – Selected List interface implementations with their time complexities
    sorted by the actions offered
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – 按提供的操作及其时间复杂度排序的所选 List 接口实现
- en: An algorithm sometimes requires you to verify the presence of an element in
    the data structure and add or remove a new one. For these cases, let us look at
    the implementation of the `Set` interface (*Table 2.4*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时算法要求您验证数据结构中元素的存在，并添加或移除新的元素。对于这些情况，让我们看看 `Set` 接口的实现（*表 2.4*）。
- en: '| **Name** | **Contains** | **Add** | **Remove** | **Data structure** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **包含** | **添加** | **移除** | **数据结构** |'
- en: '| `HashSet` | O(1) | O(1) | O(1) | Hash Table |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `HashSet` | O(1) | O(1) | O(1) | 哈希表 |'
- en: '| `TreeSet` | O(log n) | O(log n) | O(log n) | Red-Black tree |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `TreeSet` | O(log n) | O(log n) | O(log n) | 红黑树 |'
- en: Table 2.4 – Selected Set interface implementation sorted by their offered actions
    and time complexity
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 – 按提供的操作和时间复杂度排序的所选 Set 接口实现
- en: The last interface provided by the collection group is `Queue` (*Figure 2**.12*).
    This data structure is very useful when you only need to work with the first or
    last element (*Table 2.5*).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 集合组提供的最后一个接口是 `Queue`（*图 2**.12*）。当您只需要处理第一个或最后一个元素时，这种数据结构非常有用（*表 2.5*）。
- en: '| **Name** | **Peak** | **Offer** | **Poll** | **Size** | **Data structure**
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **峰值** | **提供** | **轮询** | **大小** | **数据结构** |'
- en: '| `PriorityQueue` | O(1) | O(log n) | O(log n) | O(1) | Priority Heap |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `PriorityQueue` | O(1) | O(log n) | O(log n) | O(1) | 优先堆 |'
- en: '| `ArrayDequeue` | O(1) | O(1) | O(1) | O(1) | Array |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayDequeue` | O(1) | O(1) | O(1) | O(1) | 数组 |'
- en: Table 2.5 – Selected Queue interface implementations with the actions offered
    and their time complexities
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.5 – 提供的操作及其时间复杂度的所选 Queue 接口实现
- en: 'When it comes to implementing a `Map` interface, it is important to remember
    what kind of map implementation type is considered. A map represents the structure
    of a key-value pair. Both the key and the values are descendants of the `Object`
    class. Apart from the fact that no literals can be used in the definition or initiation
    of the map, the correct implementation of the `hashCode` and `equals` object methods
    is required. This requirement is based on the need to identify the correct bucket
    to resolve potential map collisions. This kind of collision can lead to unexpected
    time complexity that deviates from our expectations (*Table 2.6*):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到实现 `Map` 接口时，重要的是要记住考虑哪种类型的映射实现。映射表示键值对的结构。键和值都是 `Object` 类的子类。除了在映射的定义或初始化中不能使用字面量之外，还需要正确实现
    `hashCode` 和 `equals` 对象方法。这一要求基于识别正确桶以解决潜在的映射冲突的需要。这种冲突可能导致时间复杂度偏离我们的预期（*表 2.6*）：
- en: '| **Name** | **Contains Key** | **Get** **by Key** | **Remove** **by Key**
    | **Data structure** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **包含键** | **通过键获取** | **通过键移除** | **数据结构** |'
- en: '| `HashMap` | O(1) | O(1) | O(1) | Hash table |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `HashMap` | O(1) | O(1) | O(1) | 哈希表 |'
- en: '| `LinkedHashMap` | O(1) | O(1) | O(1) | Hash table, linked list |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `LinkedHashMap` | O(1) | O(1) | O(1) | 哈希表，链表 |'
- en: Table 2.6 – Selected Map interface implementations with time complexities by
    the actions provided
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6 – 通过提供的操作选择Map接口实现及其时间复杂度
- en: The collections framework uses a heavily behavioral iterator design pattern
    to traverse through the considered elements. Those who have a keen eye must have
    already noticed that none of these functions of a collection framework would be
    possible without a proper mathematical basis. One of the main reasons for using
    design patterns is to map or create the right structures used by business logic.
    Let us take a brief look at some basic math features.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架使用了一种高度行为性的迭代器设计模式来遍历考虑的元素。那些有敏锐眼光的人肯定已经注意到，没有适当的数学基础，集合框架中的任何功能都是不可能实现的。使用设计模式的主要原因之一是将或创建业务逻辑所使用的正确结构。让我们简要地看一下一些基本的数学特性。
- en: Math APIs
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Math API
- en: 'Java reveals basic mathematical functions by providing a static implementation
    of the final `Math` class. Final means that this class cannot be extended, which
    includes reluctant changes or replacements of basic functions. The `Math` class
    (*Example 2.10*) is located in the `java.lang` package, which means that it is
    directly available without the need to import it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过提供`Math`类的静态实现来揭示基本的数学函数。最终意味着这个类不能被扩展，这包括不情愿的更改或替换基本函数。`Math`类（*示例2.10*）位于`java.lang`包中，这意味着它可以直接使用，无需导入：
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 2.10 – Using common math functions provided by the Math class
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.10 – 使用`Math`类提供的常用数学函数
- en: 'Although the `Math` class uses the `random` method, it only gets a `double`
    result. The `Random` class is in the `java.util` package and provides more customizable
    capabilities not only for types but also for the required ranges (*Example 2.11*):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Math`类使用了`random`方法，但它只得到一个`double`结果。`Random`类位于`java.util`包中，不仅为类型提供了更多可定制的功能，也为所需的范围提供了更多可定制的功能（*示例2.11*）：
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 2.11 – Generating a random number in a range (0 – upper bound)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.11 – 在一个范围内生成随机数（0 – 上限）
- en: The Java `Math` class is also used here, similar to virtually any required calculation
    that is beyond the capabilities of standard mathematical operators. Using the
    `Math` class methods can be helpful when functional programming approaches are
    being followed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`Math`类在这里也被使用，类似于任何超出标准数学运算能力所需的计算。在遵循函数式编程方法时，使用`Math`类的方法可能会有所帮助。
- en: Functional programming and Java
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程与Java
- en: In the previous chapter, we learned about and demonstrated the key principles
    (APIE) of **Object-Oriented Programming** (**OOP**). In recent decades, the Java
    platform has evolved with the demands of the business and development community.
    The platform has responded to this challenge by implementing an API that uses
    the composition of tree functions to provide the desired result. This is in contrast
    to the traditional loop approach with a collection of imperative commands. This
    approach caused the larger code base to meet the desired goal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了并演示了面向对象编程（**OOP**）的关键原则（APIE）。在过去的几十年里，Java平台随着商业和开发社区的需求而发展。平台通过实现一个使用树函数组合来提供所需结果的API来应对这一挑战。这与传统的循环方法以及一系列命令式命令的集合方法形成对比。这种方法导致更大的代码库达到了预期的目标。
- en: From Java SE 8 onward, the platform provides an API for streaming (*Reference
    15*). It is in the `java.util.stream` package and has nothing to do with Java
    data streams represented by input and errors (`System.out`, `System.in`, and `System.err`).
    The Stream API introduces the ability to apply operations to a sequence of elements.
    There are two types of intermediate operations that can edit or check data, as
    well as terminal operations. The terminal operation may provide a single result
    or void. Intermediate operations can be concatenated, but terminal operations
    terminate the stream. The sequence of elements is lazily evaluated and can also
    be performed in parallel. By default, performing a parallel stream uses the common
    **Fork/Join Framework** executor service. The fork-join model can be considered
    a parallel design pattern that was formulated in the early 1960s (*Reference 17*).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java SE 8开始，平台提供了一种流式API（*参考15*）。它位于`java.util.stream`包中，与由输入和错误（`System.out`、`System.in`和`System.err`）表示的Java数据流无关。Stream
    API引入了对元素序列应用操作的能力。有两种类型的中间操作可以编辑或检查数据，以及终端操作。终端操作可能提供一个单一的结果或无返回值。中间操作可以连接，但终端操作终止流。元素序列是惰性评估的，也可以并行执行。默认情况下，执行并行流使用的是公共**Fork/Join框架**执行服务。Fork/Join模型可以被认为是一种在20世纪60年代初形成的并行设计模式（*参考17*）。
- en: Although the platform allows you to program functional types, OOP concepts remain,
    followed by strong type requirements. This provides the Stream API with the security
    that the original element type remains or must be enforced correctly by an intermediate
    or terminal operation – otherwise, the platform will cause a compilation error.
    As a reminder, none of these functions would be possible without the introduction
    of generic types in Java SE 5\. Generics (*Reference 4*) allow us to parameterize
    a class or interface by a type flag to keep compilation safe (*Reference 2*).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该平台允许您编程功能类型，但面向对象的概念仍然存在，并随后是强类型要求。这为Stream API提供了安全性，即原始元素类型保持不变或必须由中间操作或终端操作正确强制执行
    – 否则，平台将引发编译错误。提醒一下，没有Java SE 5中泛型类型的引入，这些功能都不可能实现。泛型（*参考4*）允许我们通过类型标志来参数化类或接口，以保持编译安全（*参考2*）。
- en: Intermediate or terminal operations are implementations of anonymous functions
    or functional interfaces. They represent a small block of code, formally called
    a lambda. Let’s explain the concept of lambda a little more closely.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作或终端操作是匿名函数或函数式接口的实现。它们代表一小块代码，正式称为lambda。让我们更详细地解释一下lambda的概念。
- en: Introducing lambdas and functional interfaces
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入lambda和函数式接口
- en: The lambda concept was introduced to enable element operations. Lambdas basically
    treat data as a code or function as a method. Lambdas rely on the concept of anonymous
    classes – that is, a class with only one method that performs an action. Java
    contains a collection of already implemented functional interfaces or ready-to-use
    functions. Classes are annotated with the `@FunctionalInterface` annotation, which
    is a tag available from Java SE 8\. It tells the platform that a particular interface
    contains only one abstract method that can be used to instantiate anonymous classes,
    as shown in *Table 2.7*. This also means that the interface may contain some default
    or static functions that belong to the class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda概念被引入以实现元素操作。Lambda基本上将数据视为代码或函数视为方法。Lambda依赖于匿名类概念 – 即，只有一个执行动作的方法的类。Java包含了一组已实现的函数式接口或现成的函数。类使用`@FunctionalInterface`注解进行标注，这是一个从Java
    SE 8开始可用的标签。它告诉平台，特定接口只包含一个抽象方法，可以用来实例化匿名类，如*表2.7*所示。这也意味着接口可能包含一些属于类的默认或静态函数。
- en: '| **Name** | **Input** **argument** | **Return** **type** | **Abstract** **method**
    | **Description** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **输入** **参数** | **返回** **类型** | **抽象** **方法** | **描述** |'
- en: '| `Supplier<T>` | - | T | `get` | Returns a value of type <T> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Supplier<T>` | - | T | `get` | 返回类型为<T>的值 |'
- en: '| `Consumer<T>` | T | - | `accept` | Consumes a value of type <T> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | T | - | `accept` | 消费类型为<T>的值 |'
- en: '| `Function<T, R>` | T | R | `apply` | Consumes a value of type <T> and applies
    a transformation with return type <R> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T, R>` | T | R | `apply` | 消费类型为<T>的值并应用一个具有返回类型<R>的转换 |'
- en: '| `Predicate<T>` | T | Boolean | `test` | Consumes an input of type <T> and
    returns a Boolean result |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | T | 布尔值 | `test` | 消费类型为<T>的输入并返回布尔结果 |'
- en: Table 2.7 – Basic functional interfaces available in the JDK since Java SE 8
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.7 – 自Java SE 8以来在JDK中可用的基本函数式接口
- en: Using functional interfaces in lambda expressions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 lambda 表达式中使用功能接口
- en: 'We have discovered that each lambda expression is lazily loaded, which means
    the code is evaluated on demand, not at compile time, and may be closed by the
    terminal operation (*Example 2.12*):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现每个 lambda 表达式都是惰性加载的，这意味着代码是在需要时评估的，而不是在编译时，并且可能由终端操作关闭（*示例 2.12*）：
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 2.12 – Converting elements of the List interface to the stream and applying
    a terminal operation for each Consumer type instance
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.12 – 将 List 接口的元素转换为流，并对每个 Consumer 类型实例应用终端操作
- en: 'We can chain the different intermediate functions together (*Example 2.13*)
    and close the stream with a terminal operation or pass the stream to another method
    or object:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不同的中间函数链接在一起（*示例 2.13*）并使用终端操作关闭流，或将流传递给另一个方法或对象：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 2.13 – Advanced composition of named and anonymous functional interfaces
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.13 – 命名和匿名功能接口的高级组合
- en: The lambda expression stream API plays an important role in the composition
    of the code. It can be imagined as a process line into which the input object
    enters and, thanks to a collection of adjustments, the expected result is returned
    or the action ends. Since the lambdas are evaluated lazily, this means that the
    process line has a switch. In other words, the Stream API can be considered one
    of the most important breakthroughs in syntax.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式流 API 在代码组合中扮演着重要的角色。它可以想象成一个生产线，输入对象进入其中，并得益于一系列调整，返回预期的结果或结束操作。由于
    lambda 表达式是惰性评估的，这意味着生产线有一个开关。换句话说，Stream API 可以被认为是语法上最重要的突破之一。
- en: Getting to grips with the Java Module System
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 Java 模块系统
- en: 'One of the main purposes of using a higher-order programming language such
    as Java is code reusability. A basic building block of the language is the concept
    of classes according to the principles of APIE. Java can localize these classes
    into groups defined by specific package names. The package concept encapsulates
    a group of classes. Classes can provide different levels of visibility to their
    internal fields and methods. Java specifies the following levels of visibility:
    `public`, default, `private`, and `protected`. Keywords are used to reduce visibility
    across different packages to manage their interactions. The way to share a package
    across an application domain is to keep it public – that is, visible to everyone.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Java 这样的高阶编程语言的主要目的之一是代码重用。语言的基本构建块是根据 APIE 原则的类概念。Java 可以将这些类本地化到由特定包名定义的组中。包概念封装了一组类。类可以为其内部字段和方法提供不同级别的可见性。Java
    指定了以下可见性级别：`public`、默认、`private` 和 `protected`。关键字用于在不同包之间减少可见性以管理它们的交互。在应用程序域中共享包的方法是将其保持为公共的——也就是说，对每个人都是可见的。
- en: Java has been using the concept of class paths for many years. The class path
    is a special place where the Class Loader loads its classes. The loaded classes
    are then used at runtime (denoted as the **Class Loaders Subsystem** in *Figure
    2**.2*).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Java 多年来一直在使用类路径的概念。类路径是一个特殊的地方，类加载器在这里加载其类。然后，在运行时使用这些加载的类（在 *图 2.2* 中表示为 **类加载器子系统**）。
- en: However, this concept does not provide any guarantee for the stored package
    or class. This concept has been considered bad, fragile, and error-prone for many
    years. A good example is trying to package a JAR executable that contains different
    versions of libraries with similar package structures and class names. The class
    path does not differ and the class can be overwritten by different versions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个概念并不为存储的包或类提供任何保证。多年来，这个概念被认为是不好的、脆弱的和容易出错的。一个很好的例子是尝试打包一个包含具有类似包结构和类名的不同版本库的
    JAR 可执行文件。类路径没有区别，类可以被不同版本覆盖。
- en: 'The breakthrough came with the release of Java SE 9\. JSR-376, formerly the
    core of the Jigsaw project (*Reference 3*), became a common part of the platform.
    JSR-376 implements the **Java Platform Module System** (**JPMS**) (*Example 2.14*):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 突破随着 Java SE 9 的发布而来。JSR-376，以前是 Jigsaw 项目的核心（*参考 3*），已成为平台的一个共同部分。JSR-376 实现了
    **Java 平台模块系统**（**JPMS**）（*示例 2.14*）：
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 2.14 – Listing the available JDK modules for a specific version
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.14 – 列出特定版本的可用 JDK 模块
- en: 'Additionally, the platform has been migrated in accordance with the modules
    (*Example 2.15*):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，平台已根据模块进行迁移（*示例 2.15*）：
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 2.15 – Describing a java.logging module. The java.base module is automatically
    present, as it contains the core platform and language functionalities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.15 – 描述 java.logging 模块。java.base 模块自动存在，因为它包含核心平台和语言功能。
- en: 'The JMPS provides a strong package encapsulation concept that defines application
    interactions at the package level (*Example 2.16*). The application can be divided
    into modules that can only detect APIs or services. The JMPS supports package-level
    dependency building and increases the maintainability, reliability, and security
    of the application being developed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: JMPS提供了一个强大的包封装概念，它定义了应用在包级别的交互 (*示例 2.16*)。应用可以被划分为只能检测API或服务的模块。JMPS支持包级别的依赖构建，并提高了正在开发的应用的维护性、可靠性和安全性：
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 2.16 – Example of the module-info.class descriptor exposing a package
    for external usage
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.16 – 模块-info.class 描述符示例，暴露给外部使用的包
- en: The use of the JPMS is not mandatory. The Java platform uses the JMPS, but if
    the application is not ready, unnamed modules can be used. In this case, all packages
    or classes will belong to this kind of unnamed module. In principle, an unnamed
    module reads each readable module or class from the class path without reflecting
    any package-level restrictions required by the JPMS. In this way, compatibility
    with previously developed applications is achieved and the software designer has
    no doubts about the malfunction of the code base – that is, the JPMS is disabled.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JPMS不是强制性的。Java平台使用JMPS，但如果应用尚未准备好，可以使用未命名的模块。在这种情况下，所有包或类都将属于这种未命名的模块。原则上，未命名的模块从类路径中读取每个可读的模块或类，而不反映JPMS要求的任何包级别限制。这样，就实现了与先前开发的应用的兼容性，并且软件设计者对代码库的故障没有疑问——也就是说，JPMS被禁用了。
- en: Although the JPMS has incredible potential for application sustainability, security,
    and reusability, it is often not used because it creates indirect pressure to
    properly configure the underlying JPMS and use a design pattern that enforces
    SOLID principles.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JPMS在应用可持续性、安全性和可重用性方面具有巨大的潜力，但它通常没有被使用，因为它会间接地施加压力，要求正确配置底层的JPMS并使用一种强制SOLID原则的设计模式。
- en: When using the JMPS, the platform ensures that the developed application does
    not contain any cyclic dependencies. Behind the scenes, the JPMS creates an acyclic
    module graph (not a class path case).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JMPS时，平台确保开发的应用不包含任何循环依赖。在幕后，JPMS创建了一个无环的模块图（而不是类路径的情况）。
- en: By creating a module descriptor file, the platform provides a set of directives
    that can be used to expose certain parts of the module to the outside world.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建模块描述符文件，平台提供了一组指令，可用于将模块的某些部分暴露给外部世界。
- en: 'Let’s create a simple example of a module to remove any doubt about the use
    of the JPMS (*Example 2.17*). Our discussion so far can overcome the initial difficulties:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的模块示例，以消除对JPMS使用的任何疑虑 (*示例 2.17*)。到目前为止的讨论可以克服最初的困难：
- en: '[PRE17]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 2.17 – Folder structure of module example developed with OpenJDK 17
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.17 – 使用 OpenJDK 17 开发的模块 example 的文件夹结构
- en: 'We create an appropriate executable class, `ExampleMain.java`, and a module
    descriptor, `module-info.java` (*Example 2.18*). In this way, we tell the platform
    to use the JPMS:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个合适的可执行类，`ExampleMain.java`，以及一个模块描述符，`module-info.java` (*示例 2.18*)。这样，我们告诉平台使用
    JPMS：
- en: '[PRE18]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 2.18 – Simple module example introduced by the file structure in Example
    2.17
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.18 – 由示例 2.17 中的文件结构引入的简单模块示例
- en: 'The example shows how the project could be separated into modules that contain
    their own descriptors, `module-info.java` files (*Example 2.17*). This descriptor
    defines an interaction with other modules through dependencies or exposures of
    module internals. The JPMS ensures that the restrictions, including visibility,
    are maintained:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了如何将项目分割成包含它们自己的描述符、`module-info.java` 文件的模块 (*示例 2.17*)。此描述符定义了通过依赖关系或模块内部暴露与其他模块的交互。JPMS确保包括可见性在内的限制得到维护：
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 2.19 – Steps to compile Example 2.17 with outputs, together with the
    module descriptor check (Example 2.18) after the compiled result
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.19 – 编译示例 2.17 的步骤，包括输出，以及编译结果后的模块描述符检查（示例 2.18）
- en: The JPMS is a big change to the platform and although it opens a new horizon
    for software designers by providing the ability to define clarity in the package
    structure, it is not always well received or understood. This may be due to additional
    requirements that need to be taken into account when designing the system, which
    essentially relate to the knowledge of APIE or SOLID principles.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS 对平台来说是一个重大变化，尽管它通过提供定义包结构清晰性的能力为软件设计师开辟了新的视野，但它并不总是受到欢迎或被理解。这可能是由于在设计系统时需要考虑的额外要求，这些要求本质上与
    APIE 或 SOLID 原则的知识相关。
- en: The JPMS together with the Stream API, as well as lambdas, may be considered
    significant changes addressed by the Java SE 11 release – Java SE 11 being the
    next **Long-Time Support** (**LST**) release after version 8\. Let us dive a bit
    further into some of the changes from Java SE 11 to the next LST version presented
    by release 17.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS 与 Stream API 以及 lambda 一起，可能被认为是 Java SE 11 版本中解决的一些重大变化——Java SE 11 是
    8 版本之后的下一个**长期支持**（**LTS**）版本。让我们进一步探讨一些从 Java SE 11 到下一个由发布 17 呈现的 LTS 版本的变化。
- en: A quick review of Java features from 11 to 17+
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾 Java 从 11 到 17+ 的特性
- en: This version update presents performance and optimization improvements. In this
    section, we will examine those that are very useful for the specific use of a
    design pattern and its structure. This equates to platform enhancements that improve
    code readability, platform usage, or syntax enhancements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本版本更新展示了性能和优化改进。在本节中，我们将检查那些对特定设计模式及其结构的使用非常有用的改进。这相当于平台增强，可以提高代码可读性、平台使用或语法增强。
- en: The local variable syntax for lambda parameters (Java SE 11, JEP-323)
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lambda 参数的局部变量语法（Java SE 11，JEP-323）
- en: 'Java has often been criticized for the amount of standard code in the use of
    a variable; Java SE 10 introduced a new keyword, `var`. The derivation of a local
    type variable lies behind this keyword. It essentially requires that the value
    type is taken from the newly created reference instance (*Example 2.20*). Using
    the stream `boxed` function shows a decorator pattern that wraps the stream value
    with the desired type:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Java 常常因为变量使用中的标准代码量而受到批评；Java SE 10 引入了一个新的关键字，`var`。这个关键字背后的推导是局部类型变量。它本质上要求值类型从新创建的引用实例中获取（*示例
    2.20*）。使用流 `boxed` 函数展示了装饰者模式，它将流值包装在所需类型中：
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 2.20 – Use of local type inference in a lambda expression and stream
    shows the reduction of boilerplate code
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.20 – 在 lambda 表达式和流中使用局部类型推断以减少样板代码
- en: Although a lambda already allowed an implicit type definition, for example,
    the use of annotation was not possible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 lambda 已经允许隐式类型定义，例如，使用注解是不可能的。
- en: Switch expressions (Java SE 14, JEP-361)
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Switch 表达式（Java SE 14，JEP-361）
- en: 'Software designers have long complained about several inconsistencies in the
    use of switch commands, such as a control flow problem. Although this enhancement
    is fully compatible with all controls, it introduces a new form of switch label,
    `case CONSTANT->`. The extension also allows more constants to be used, making
    the entire switch expression more compact. The last improvement is the ability
    of the switch expression to return its computed value (*Example 2.21*). This has
    a very positive impact on the implementation of the design pattern, because, for
    example, behavior types require a precise control flow (*Reference 8*):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计师长期以来一直抱怨 switch 命令的使用存在一些不一致性，例如控制流问题。尽管这个增强与所有控制流完全兼容，但它引入了新的 switch 标签形式，`case
    CONSTANT->`。扩展还允许使用更多的常量，使整个 switch 表达式更加紧凑。最后一个改进是 switch 表达式能够返回其计算值（*示例 2.21*）。这对设计模式的实现有非常积极的影响，因为例如，行为类型需要精确的控制流（*参考
    8*）：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 2.21 – Compact switch expression usage with a return control flow with
    a simple text block
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.21 – 使用简单的文本块进行紧凑的 switch 表达式和带有返回控制流的用法
- en: Text blocks (Java SE 15, JEP-378)
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本块（Java SE 15，JEP-378）
- en: Many times, you need to create multiple lines with a specific format. Previous
    use of multiple escape sequences and characters was not as practical, as it could
    be unpredictable. Text block extension introduces a literal that allows you to
    represent a string in a predictable way (see the `System.out.printf` method in
    *Example 2.21*, as well as *Reference 9*).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你需要创建具有特定格式的多行文本。之前使用多个转义序列和字符并不实用，因为它可能不可预测。文本块扩展引入了一个字面量，允许你以可预测的方式表示一个字符串（参见*示例
    2.21*中的`System.out.printf`方法，以及*参考 9*）。
- en: Pattern matching for instanceof (Java SE 16, JEP-394)
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instanceof 的模式匹配（Java SE 16，JEP-394）
- en: 'Previously, it was necessary to retype a value type that had already been verified
    as positive for its type. This increased the code base and sometimes had a negative
    effect on the stability of the code, even when designing a pattern. This platform
    extension eliminates the need for a rear cast and the variable can be used directly
    with the correct type (*Example 2.22*, *Reference 10*):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，需要重新输入一个已经验证为正值的值类型。这增加了代码库，有时甚至对代码的稳定性产生负面影响，即使在设计模式时也是如此。这个平台扩展消除了需要后置转换的需求，变量可以直接使用正确的类型（*示例
    2.22*，*参考 10*）：
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 2.22 – Using instanceof with direct type methods
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.22 – 使用 instanceof 与直接类型方法
- en: Records (Java SE 16, JEP-395)
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录（Java SE 16，JEP-395）
- en: 'The `record` class type is very useful because its declaration is very simple
    and can carry all the data needed for the program’s business logic. Records carry
    immutable data. They provide an already implemented `hashCode` and `equals`. This
    means that the designed software does not have to provide additional code (*Example
    2.23*, *Reference 11*):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`record` 类类型非常有用，因为它的声明非常简单，可以携带程序业务逻辑所需的所有数据。记录携带不可变数据。它们提供了已实现的 `hashCode`
    和 `equals` 方法。这意味着设计的软件不需要提供额外的代码（*示例 2.23*，*参考 11*）：'
- en: '[PRE25]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 2.23 – New record class type may have a very positive impact on code
    reduction, as it provides generated methods
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.23 – 新的记录类类型可能对代码减少产生非常积极的影响，因为它提供了生成的方法
- en: Sealed classes (Java SE 17, JEP-409)
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封类（Java SE 17，JEP-409）
- en: 'These are very elegant enhancements to gain control over classes and interfaces,
    or class extensions and interface implementations (*Reference 12*). Closed classes
    give software designers wide access to the superclass without the need to extend
    it. They overcome the limitations of the widely used package access modifier,
    which previously required the full implementation of abstract methods. The example
    shows how to define an open class for an extension, the `non-sealed` keyword (*Example
    2.24*):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是获得对类和接口、或类扩展和接口实现的控制的非常优雅的增强（*参考 12*）。封闭类为软件设计师提供了对超类的广泛访问，而无需扩展它。它们克服了广泛使用的包访问修饰符的限制，之前需要完全实现抽象方法。示例展示了如何定义一个用于扩展的开放类，使用
    `non-sealed` 关键字（*示例 2.24*）：
- en: '[PRE26]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example 2.24 – The implementation of the interface methods is provided by the
    abstract class, NormalEngine
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.24 – 接口方法的实现由抽象类 NormalEngine 提供
- en: 'Sealed classes force control over possible extensions (*Example 2.25*) because
    they provide software with potential security against unwanted software design
    changes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类强制控制可能的扩展（*示例 2.25*），因为它们为软件提供了潜在的安全，以防止不想要的软件设计更改：
- en: '[PRE27]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the compilation output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译输出：
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 2.25 – Sealed classes enforce control over the enhancements
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.25 – 密封类强制控制增强
- en: 'Sealed classes also present some potential problems because the software designer
    must decide how the newly created classes will be used, indicating whether class
    extension is allowed, the keyword is unsealed (*Example 2.25*), or the final keyword
    (*Example 2.26*) is locked:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类也带来了一些潜在问题，因为软件设计师必须决定新创建的类将如何被使用，指示是否允许类扩展，关键字是未密封的（*示例 2.25*），或者使用 `final`
    关键字（*示例 2.26*）锁定：
- en: '[PRE29]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 2.26 – It’s required to decide the class behavior and the Bus class
    example is locked for any extension
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.26 – 需要决定类的行为，并且 Bus 类示例被锁定，不允许任何扩展
- en: Although this may seem like a possible disadvantage, it provides greater clarity
    in software development in terms of maintainability and design patterns. This
    reduces potential unwanted interface or class errors.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能是一个可能的缺点，但它从可维护性和设计模式的角度提供了软件开发中的更大清晰度。这减少了潜在的接口或类错误。
- en: UTF-8 by default (Java SE 18, JEP-400)
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认使用 UTF-8 编码（Java SE 18，JEP-400）
- en: For many years, unclear encoding has caused issues. Encoding problems were not
    easy to detect and appeared unpredictably on different system platforms. This
    enhancement has unified everything and forced UTF-8 as the default encoding (*Reference
    13*).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，编码不明确导致了问题。编码问题不易检测，并且在不同系统平台上不可预测地出现。这个增强统一了所有内容，并强制使用 UTF-8 作为默认编码（*参考
    13*）。
- en: Pattern matching for switch (Java SE 18, Second Preview, JEP-420)
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 的模式匹配（Java SE 18，第二次预览，JEP-420）
- en: 'Improvements to `instanceof` fields (JEP-394) and switch case expressions (JEP-361)
    have made it even better to compress the code base and remove previously unnecessary
    if-else constructs by using `instanceof` on a very compact, command-oriented controlled
    command statement: type-served (E*xample 2.27*, *Reference 14*):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`字段（JEP-394）和switch case表达式（JEP-361）的改进使得代码库的压缩和通过在非常紧凑、命令导向的命令语句中使用`instanceof`来移除之前不必要的if-else结构变得更加容易：类型服务（*示例2.27*，*参考14*）：'
- en: '[PRE30]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 2.27 – Compact switch statement with an implicit type match
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.27 – 压缩的switch语句，具有隐式类型匹配
- en: After reviewing the most important syntactic improvements, we can safely start
    to delve deeper into one of the main advantages of the platform. Yes, it is the
    concurrency framework.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了最重要的语法改进之后，我们可以安全地开始深入探讨平台的主要优势之一。是的，它是并发框架。
- en: Understanding Java concurrency
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java并发
- en: At the beginning of this chapter, it was shown that even running a simple program
    (*Example 2.2* and *Figure 2**.3*) will cause multiple concretizations of threads
    (*Figure 2**.4*). This means that a program thread created by executing the `main`
    method did not create any other thread that belonged to that program. The Java
    platform is well-known and valuable for its ability to perform concurrent or parallel
    tasks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，已经展示了即使运行一个简单的程序（*示例2.2*和*图2**.3*）也会导致多个线程的具体化（*图2**.4*）。这意味着通过执行`main`方法创建的程序线程并没有创建属于该程序的任何其他线程。Java平台因其能够执行并发或并行任务而闻名且价值巨大。
- en: We found out how and where initiated threads store their variables and why synchronizing
    objects located in the heap can lead to unwanted or unexpected program behavior.
    In this section, we will look at the possibilities of the main threads using the
    available CPUs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到线程是如何以及在哪里存储它们的变量，以及为什么在堆中同步对象可能会导致不希望或意外的程序行为。在本节中，我们将探讨主线程使用可用CPU的可能性。
- en: The motivation for software designers to consider using any concurrent design
    patterns may be the growing need for better application responsiveness or throughput.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计师考虑使用任何并发设计模式的动机可能是对更好的应用程序响应性或吞吐量的日益增长的需求。
- en: Although the platform already includes the `Thread` class and the `java.lang`
    package, Java concurrency features such as `java.util.concurrent` package, which
    is part of the `java.base` module.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管平台已经包含了`Thread`类和`java.lang`包，但Java并发特性，如`java.util.concurrent`包，它是`java.base`模块的一部分。
- en: Let us look a bit closer.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看。
- en: From a basic thread to executors
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从基本线程到执行器
- en: 'The basic build element of the platform is the thread. A thread is represented
    by an instance of the `Thread` class. The object initiated by the `new` keyword
    still does not create a platform thread. The object provides a method named `start`
    that requires explicit use (*Example 2.28*):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 平台的基本构建元素是线程。线程由`Thread`类的实例表示。使用`new`关键字初始化的对象仍然不会创建平台线程。该对象提供了一个名为`start`的方法，该方法需要显式使用（*示例2.28*）：
- en: '[PRE31]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 2.28 – A simple program with a daemon thread that ends immediately after
    the JVM stops
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.28 – 一个在JVM停止后立即结束的守护线程的简单程序
- en: Although it may appear that the platform can create an unrestricted `Thread`
    instance, this kind of statement is not valid. Each newly created thread instance
    not only takes up heap space or allocates a stack but is also connected to basic
    system threads (processing cycles) through Java runtime partitions (*Figure 2**.2*).
    This means that uncontrolled thread startup can cause a system error exception
    due to unavailable resources, insufficient memory, and so on.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来平台可以创建不受限制的`Thread`实例，但这种说法是不正确的。每个新创建的线程实例不仅占用堆空间或分配栈空间，而且通过Java运行时分区（*图2**.2*）与基本系统线程（处理周期）相连。这意味着不受控制的线程启动可能会由于资源不可用、内存不足等原因导致系统错误异常。
- en: The maximum number of system threads created by the Java platform may vary,
    as it depends on the hardware as well as the JVM configuration. The Java `Thread`
    class might consider a wrapper for the `Runnable` interface, and the thread accepts
    its implementation. The `Runnable` interface is another functional interface and
    requires the implementation of a run method. Starting with the Java SE 8 `Runnable`
    interface, the instance can be passed to the executor service as an anonymous
    function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台创建的系统线程的最大数量可能因硬件以及 JVM 配置而异。Java 的 `Thread` 类可能将 `Runnable` 接口视为包装器，线程接受其实现。`Runnable`
    接口是另一个函数式接口，需要实现一个运行方法。从 Java SE 8 的 `Runnable` 接口开始，实例可以作为匿名函数传递给执行器服务。
- en: The Java platform allows you to run a thread that can even survive the termination
    of the main program, which in many cases, is a reluctant condition and should
    be considered wisely, as it may block other core resources or stay running.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台允许你运行一个线程，甚至可以在主程序终止后仍然存活，这在许多情况下是一个不情愿的条件，应该谨慎考虑，因为它可能会阻塞其他核心资源或持续运行。
- en: It is important to remember that the JVM only terminates when all running threads
    are daemon ones (*Example 2.28*).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，只有当所有运行中的线程都是守护线程时，JVM 才会终止 (*示例 2.28*)。
- en: Because each thread newly created by the main program is non-daemon, by default,
    when the sample program is run without an explicit daemon flag, the JVM remains
    an active process until the base system destroys it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主程序新创建的每个线程都是非守护线程，默认情况下，当示例程序在没有显式守护标志的情况下运行时，JVM 仍然是一个活跃进程，直到基本系统将其销毁。
- en: It allows you to manage uncontrolled thread creation and gives the software
    designer control over the program’s resources and behavior. Java SE 5 introduced
    the `ExecutorService` and `ThreadFactory` interfaces, where multiple implementations
    show using a similarly named creational design pattern factory. The `ThreadFactory`
    interface contains only one `newThread` method, which returns a `Thread` instance.
    This method logic can accommodate the creation of a new thread and set the group,
    thread priority, and daemon flag. It also eliminates the number of new thread
    calls. `ThreadFactory` can be serviced by `ExecutorService` (*Example 2.30*).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你管理不受控制的线程创建，并让软件设计者控制程序的资源和行为。Java SE 5 引入了 `ExecutorService` 和 `ThreadFactory`
    接口，其中多个实现展示了使用类似名称的创建型设计模式工厂。`ThreadFactory` 接口只包含一个 `newThread` 方法，它返回一个 `Thread`
    实例。此方法逻辑可以容纳新线程的创建，并设置组、线程优先级和守护标志。它还消除了新线程调用的数量。`ThreadFactory` 可以由 `ExecutorService`
    服务 (*示例 2.30*)。
- en: 'Some of the most used executor static method names are as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的执行器静态方法名称如下：
- en: '`newSingleThreadExecutor()`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`'
- en: '`newSingleThreadExecutor(ThreadFactory threadFactory)`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor(ThreadFactory threadFactory)`'
- en: '`newCachedThreadPool()`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`'
- en: '`newCachedThreadPool(ThreadFactory threadFactory)`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool(ThreadFactory threadFactory)`'
- en: Java SE 5 came up with a concept for the future, a `Future` interface with a
    generic type of `<T>`. The `Future` interface can be considered an asynchronous
    calculation that provides a result.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 5 提出了一个关于未来的概念，一个具有泛型类型 `<T>` 的 `Future` 接口。`Future` 接口可以被视为一个异步计算，它提供结果。
- en: The Java platform provides two different interfaces that can carry thread logic.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台提供了两个不同的接口，可以携带线程逻辑。
- en: Executing tasks
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行任务
- en: 'The Java platform provides a thread concept from the beginning represented
    by the `Runnable` interface and the `Thread` class (*Example 2.29*):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台从一开始就提供了线程概念，由 `Runnable` 接口和 `Thread` 类表示 (*示例 2.29*)：
- en: '[PRE32]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 2.29 – Different approaches to providing the Runnable interface implementation
    to the executor service, implementation, and anonymous class
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.29 – 向执行器服务提供 `Runnable` 接口实现的多种方法，实现和匿名类
- en: Business requirements, along with community expectations, have created a platform
    for reactive programming or the ability to perform multiple asynchronous payback
    tasks. As of Java SE 5, the platform provides a `Callable` interface. The `Callable`
    interface is considered a functional interface. It contains only one abstract
    method call with a required return type of `<T>`. Because the computation is uncertain,
    it can cause an exception that must be handled correctly. The `Callable` implementation
    can be sent to the executor and the started calculation is packed into a future
    result.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 商业需求以及社区期望共同创造了一个用于反应式编程或执行多个异步回调任务的平台。截至 Java SE 5，该平台提供了一个 `Callable` 接口。`Callable`
    接口被认为是一个函数式接口。它只包含一个带有必需返回类型 `<T>` 的抽象方法调用。由于计算是不确定的，它可能引发必须正确处理的异常。`Callable`
    实现可以发送到执行器，启动的计算被封装到未来结果中。
- en: 'The `Future` instance is the computational work that the base system performs
    in the background. The interface provides a `get` method (*Example 2.30*) that
    can be used to retrieve the result. Using this method pauses the current thread
    and waits until a result is available. Due to the current thread suspension, this
    method should be used wisely, as it can cause performance penalties:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 实例是基础系统在后台执行的计算工作。该接口提供了一个 `get` 方法（*示例 2.30*），可以用来检索结果。使用此方法会暂停当前线程，直到有结果可用。由于当前线程的暂停，此方法应谨慎使用，因为它可能会造成性能损失：'
- en: '[PRE33]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 2.30 – Different approaches to provide a Callable instance to the executor
    service as a realization or an anonymous class
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.30 – 向执行器服务提供 Callable 实例的不同方法，实现或匿名类
- en: This contrasts with the `Runnable` interface because the `Callable` interface
    provides a `Future` instance as a temporary result. The `Callable` exception handling
    request is also relevant because it can cause logic to be executed or the worker
    thread can be interrupted. In this case, it is necessary to transfer this to the
    interim result represented by the `Future` interface.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Runnable` 接口形成对比，因为 `Callable` 接口提供了一个 `Future` 实例作为临时结果。`Callable` 异常处理请求也相关，因为它可能导致逻辑执行或工作线程被中断。在这种情况下，有必要将此转移到由
    `Future` 接口表示的临时结果。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have built a good knowledge base for understanding the
    internal Java platform. We learned about the differences between statically allocated
    arrays or methods compared to object instances. We examined the need for proper
    data synchronization and how Java memory management works and what guarantees
    the platform provides. We now understand the importance of heap memory, segmentation,
    and maintenance. We have also already discovered a few frequently used design
    patterns, which means that when we start implementing any design pattern or collection,
    we will be aware of the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为理解内部 Java 平台建立了一个良好的知识库。我们了解了静态分配的数组或方法与对象实例之间的区别。我们研究了适当数据同步的需要以及 Java
    内存管理的工作原理和平台提供的保证。我们现在理解了堆内存、分段和维护的重要性。我们也已经发现了一些常用的设计模式，这意味着当我们开始实现任何设计模式或集合时，我们将意识到以下内容：
- en: How fields or variables are handled by the platform
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台如何处理字段或变量
- en: The importance of memory management
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理的重要性
- en: Specific program error exit states and the reasons for them
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定程序错误退出状态及其原因
- en: The core APIs provided by the Java platform
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 平台提供的核心 API
- en: How to utilize functional programming features
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用函数式编程特性
- en: What new enhancements the Java platform provides to make employing design patterns
    easier
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 平台提供了哪些新增强功能，以使应用设计模式更加容易
- en: How to approach Java concurrency challenges
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应对 Java 并发挑战
- en: We have built a solid knowledge base over the first two chapters. We will now
    begin to present pattern by pattern. The next chapter will take us on a journey
    through creational design patterns. Creational design patterns intensify our awareness
    of the code structure and how to create sustainable solutions. Let us roll.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前两章中建立了一个坚实的知识库。现在，我们将按模式逐一介绍。下一章将带我们进入创建型设计模式的旅程。创建型设计模式增强了我们对代码结构和如何创建可持续解决方案的认识。让我们开始吧。
- en: Questions
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which elements make up the Java platform?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成 Java 平台的是哪些元素？
- en: What does statically typed language mean?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态类型语言意味着什么？
- en: What are the Java language literals?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 语言字面量是什么？
- en: What is responsible for memory reclamation in the Java memory management concept?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java内存管理概念中，谁负责内存回收？
- en: What are the collections in the Java collections framework?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java集合框架中有哪些集合？
- en: What kind of elements store `Map`?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Map`存储了哪些类型的元素？'
- en: What is the time complexity of retrieving an element from `Set`?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Set`中检索元素的时间复杂度是多少？
- en: What is the time complexity of verifying an element’s existence in `ArrayList`?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`ArrayList`中元素存在的时间复杂度是多少？
- en: What functional interface is used in the `filter` method of the Stream API?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Stream API的`filter`方法中使用了哪种功能接口？
- en: How are elements evaluated in the Stream API?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Stream API中元素是如何评估的？
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Garbage Collection Handbook: The Art of Automatic Memory Management*,
    Anthony Hosking, Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791,
    ISBN-10: 9781420082791, 1996'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《垃圾回收手册：自动内存管理的艺术》*，安东尼·霍斯金斯，埃利奥特·B·莫斯，理查德·琼斯，CRC出版社，ISBN-13：978-1420082791，ISBN-10：9781420082791，1996年'
- en: 'Java Generics: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java泛型：[https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)
- en: 'The JPMS (JSR 376): [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPMS（JSR 376）：[https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)
- en: 'The Java tutorials: [https://docs.oracle.com/javase/tutorial/java](https://docs.oracle.com/javase/tutorial/java)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java教程：[https://docs.oracle.com/javase/tutorial/java](https://docs.oracle.com/javase/tutorial/java)
- en: 'Java GC basics: [https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java GC基础：[https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
- en: 'The JVM specification, Java SE 17 Edition: [https://docs.oracle.com/javase/specs/jvms/se17/html/index.html](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM规范，Java SE 17版：[https://docs.oracle.com/javase/specs/jvms/se17/html/index.html](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)
- en: 'OpenJDK, HotSpot runtime overview: [https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html](https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK，HotSpot运行时概述：[https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html](https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html)
- en: 'JEP 361: Switch Expression: [https://openjdk.java.net/jeps/361](https://openjdk.java.net/jeps/361)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 361：Switch表达式：[https://openjdk.java.net/jeps/361](https://openjdk.java.net/jeps/361)
- en: 'JEP 378: Text Blocks: [https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 378：文本块：[https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378)
- en: 'JEP 394: Pattern matching for `instanceof`: [https://openjdk.java.net/jeps/394](https://openjdk.java.net/jeps/394)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 394：`instanceof`的匹配模式：[https://openjdk.java.net/jeps/394](https://openjdk.java.net/jeps/394)
- en: '*JEP 395:* *Records*: [https://openjdk.java.net/jeps/395](https://openjdk.java.net/jeps/395)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 395：记录*：[https://openjdk.java.net/jeps/395](https://openjdk.java.net/jeps/395)'
- en: '*JEP 409: Sealed* *Classes*: [https://openjdk.java.net/jeps/409](https://openjdk.java.net/jeps/409)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 409：密封类*：[https://openjdk.java.net/jeps/409](https://openjdk.java.net/jeps/409)'
- en: '*JEP 400: UTF-8 by* *Default*: [https://openjdk.java.net/jeps/400](https://openjdk.java.net/jeps/400)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 400：默认UTF-8*：[https://openjdk.java.net/jeps/400](https://openjdk.java.net/jeps/400)'
- en: '*JEP 420: Pattern Matching for switch (Second* *Preview)*: [https://openjdk.java.net/jeps/420](https://openjdk.java.net/jeps/420)'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 420：switch的匹配模式（第二次预览）*：[https://openjdk.java.net/jeps/420](https://openjdk.java.net/jeps/420)'
- en: 'The `java.util.stream` package: [https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.stream`包：[https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)'
- en: '*JEP 300: Launch Single-File Source-Code* *Programs*: [https://openjdk.java.net/jeps/330](https://openjdk.java.net/jeps/330)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 300：启动单文件源代码程序*：[https://openjdk.java.net/jeps/330](https://openjdk.java.net/jeps/330)'
- en: '*A multiprocessor system design*. Fall Join Computer Conference, Melvin E.
    Conway (1963). pp. 139 -146.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《多处理器系统设计》*，秋季计算机会议，梅尔文·E·康威（1963年）。第139-146页。'
- en: 'Part 2: Implementing Standard Design Patterns Using Java Programming'
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用Java编程实现标准设计模式
- en: 'Design patterns are often classified into three well-known categories: creational,
    behavioral, and structural. This part will explore and demonstrate design patterns
    from each of these categories. It will show the types of challenges addressed
    by each design pattern with practical real-world examples.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常被分为三个著名的类别：创建型、行为型和结构型。本部分将探索并展示每个类别中的设计模式。它将通过实际的真实世界案例展示每个设计模式所解决的问题类型。
- en: 'This part contains the following chapters:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 3*](B18884_03.xhtml#_idTextAnchor093), *Working with Creational Design
    Patterns*'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B18884_03.xhtml#_idTextAnchor093), *使用创建型设计模式*'
- en: '[*Chapter 4*](B18884_04.xhtml#_idTextAnchor172), *Applying Structural Design
    Patterns*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18884_04.xhtml#_idTextAnchor172), *应用结构设计模式*'
- en: '[*Chapter 5*](B18884_05.xhtml#_idTextAnchor255), *Behavioral Design Patterns*'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18884_05.xhtml#_idTextAnchor255), *行为设计模式*'
