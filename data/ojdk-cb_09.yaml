- en: Chapter 9. Testing OpenJDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 测试OpenJDK
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Running tests using the downloaded or the built version of jtreg
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下载或构建的jtreg版本运行测试
- en: Building jtreg from the source
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建jtreg
- en: Running the standard set of OpenJDK tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行标准套件的OpenJDK测试
- en: Writing your own test for jtreg
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为jtreg编写自己的测试
- en: Using jtreg in GUI mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GUI模式下使用jtreg
- en: Writing TestNG tests for jtreg
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为jtreg编写TestNG测试
- en: Compiling JT Harness from the source code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码编译JT Harness
- en: Building and running jcstress
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 和 运行 jcstress
- en: Writing tests for jcstress
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为jcstress编写测试
- en: Creating a benchmark project using JMH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMH创建基准测试项目
- en: Downloading the source and compiling JMH
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载源代码并编译JMH
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Back in 1997, when JDK 1.1 was completed and JDK 1.2 had just started, there
    was an obvious problem—JDK had to be tested somehow and there had to be a tool
    for it. This is the moment when **jtreg** appeared as the regression test harness.
    At that time, there were not many testing frameworks for Java. In fact, there
    was not even much software written in Java. So choices were very limited and the
    only reasonable option was the framework that was being used at that time for
    the **Java Compatibility Kit** (**JCK**). Its name was **JavaTest**. But, as JCK
    tests were very different from what a JDK regression test is supposed to do, the
    framework required some adaptation and that is when jtreg appeared. At the moment,
    even though many years have passed since 1997, jtreg still remains the primary
    tool for running unit and regression tests in OpenJDK. Since its introduction
    in OpenJDK, more than 10,000 tests have been created that run using the jtreg
    framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回到1997年，当JDK 1.1完成，JDK 1.2刚刚开始时，有一个明显的问题——JDK必须以某种方式被测试，并且必须有一个工具来完成这项工作。这就是jtreg作为回归测试工具出现的时刻。当时，Java的测试框架并不多。事实上，甚至没有多少软件是用Java编写的。所以选择非常有限，唯一合理的选项是当时用于**Java兼容性工具包**（**JCK**）的框架。它的名字叫**JavaTest**。但是，由于JCK测试与JDK回归测试应该完成的任务非常不同，该框架需要进行一些调整，这就是jtreg出现的时候。到目前为止，尽管自1997年以来已经过去了许多年，jtreg仍然仍然是运行OpenJDK中单元和回归测试的主要工具。自从它在OpenJDK中引入以来，已经创建了超过10,000个使用jtreg框架运行的测试。
- en: As a testing tool, jtreg might look a little unusual for modern developers who
    are used to tools such as jUnit and TestNG. The main reason jtreg looks different
    is because it has a long history. It appeared before jUnit in 1997, which appeared
    sometime around 2000\. At that time, especially when technology was so young,
    three years was a long period. It seems possible that the other contributing factor
    was that jtreg for a long time remained a proprietary tool and, as it was doing
    its job, there was no need to change it. Also, it was not open to the wide open
    source community, who could have changed its shape over time. The other reason
    that contributes to its difference when compared to the current *classical* tools
    is that it provides some special features that are not usually available in testing
    frameworks, but are required to do testing on JDK. These features include running
    a test in a separate instance (or for some tests, even several instances) of JVM
    with a specific set of parameters, testing Java applets (remember them?), running
    shell scripts as tests, running GUI tests which require user interaction, and
    so on. This is a pretty big set of additional features, which is enough to justify
    building a separate framework for it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试工具，jtreg对于习惯了JUnit和TestNG等工具的现代开发者来说可能看起来有些不寻常。jtreg看起来不同的主要原因是因为它有着悠久的历史。它在1997年出现，而jUnit大约在2000年左右出现。在当时，尤其是在技术如此年轻的时候，三年是一个很长的时间。似乎还有一个可能的原因是，jtreg长期以来一直是一个专有工具，并且由于它一直在履行其职责，因此没有必要对其进行更改。此外，它并没有向广大的开源社区开放，这些社区本可以在一段时间内改变其形态。与当前*经典*工具相比，导致其差异的另一个原因是它提供了一些通常不在测试框架中可用，但在进行JDK测试时必需的特殊功能。这些功能包括在具有特定参数的单独JVM实例（或对于某些测试，甚至几个实例）中运行测试，测试Java小程序（还记得它们吗？），将shell脚本作为测试运行，运行需要用户交互的GUI测试等等。这是一套相当大的附加功能，足以证明为它构建一个单独的框架是合理的。
- en: Having said all that, it would not be fair to say that jtreg is some old-fashioned
    tool that is stuck in the 1990s and does not attempt to change itself to be closer
    to the modern way of building frameworks for software testing. It has been integrated
    with testing frameworks such as **TestNG** and provides a way to create tests
    that are based on that framework. However, the majority of tests in JDK are still
    just classes with a main method that are executed by the framework. Though, to
    be fair, such an approach has its benefits since it allows one to run individual
    tests without any framework. There are also some tests that are just batch files
    and there is an ongoing effort to get rid of them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，说jtreg是某种过时的工具，它停滞在20世纪90年代，并且没有尝试改变自己以更接近现代软件测试框架构建方式，这并不公平。它已经与测试框架如**TestNG**集成，并提供了一种基于该框架创建测试的方法。然而，JDK中的大多数测试仍然是只有main方法的类，由框架执行。尽管如此，公平地说，这种做法有其优点，因为它允许一个人在没有框架的情况下运行单个测试。还有一些测试只是批处理文件，并且正在进行努力以消除它们。
- en: As a tool that evolved from JavaTest, jtreg inherited compatibility with its
    framework. This compatibility has been now isolated into a separate project called
    **Java Test Harness** (**JT Harness**). This is a framework for running, building,
    and deploying tests suites. It also provides a GUI to manage and execute the test
    suites.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为从JavaTest演变而来的工具，jtreg继承了与其框架的兼容性。这种兼容性现在已被隔离到一个名为**Java Test Harness**（**JT
    Harness**）的独立项目中。这是一个用于运行、构建和部署测试套件的框架。它还提供了一个GUI来管理和执行测试套件。
- en: In this chapter, you will learn enough to be a confident jtreg user and know
    how to use JT Harness. You will find out how to build jtreg and JT Harness from
    the source code, how to run tests, and how to write your own tests. The chapter
    covers only plain Java and TestNG tests, as they are the most useful ones for
    OpenJDK developers. This chapter does not cover the usage of shell tests, as their
    usage is not considered a good practice and they were created to work around JVM
    limitations that existed a few years back. At the current moment, all OpenJDK
    contributors are encouraged to replace the shell tests with the Java version,
    wherever possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到足够的内容，成为一个自信的jtreg用户，并了解如何使用JT Harness。你将了解到如何从源代码构建jtreg和JT Harness，如何运行测试，以及如何编写自己的测试。本章仅涵盖纯Java和TestNG测试，因为它们对于OpenJDK开发者来说最有用。本章不涵盖shell测试的使用，因为它们的用法不被认为是良好的实践，并且它们是为了解决几年前存在的JVM限制而创建的。在当前时刻，所有OpenJDK贡献者都被鼓励尽可能地将shell测试替换为Java版本。
- en: Running tests using the downloaded or the built version of jtreg
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用下载或构建的jtreg版本运行测试
- en: The simplest way to get started with jtreg is to just download it, unpack it,
    and run some tests. In this recipe, we will do exactly that, without doing any
    additional things such as building it from the source code or trying to create
    our own tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用jtreg的最简单方法是下载它，解压它，并运行一些测试。在这个食谱中，我们将做的是确切地这样做，而不会做任何额外的事情，比如从源代码构建它或尝试创建我们自己的测试。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, nothing much is really required—just the Internet connection,
    a machine with an installed or built OpenJDK, and the OpenJDK source code. In
    a Windows environment, Cygwin has to be installed in your machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，实际上不需要太多东西——只需要互联网连接、安装或构建了OpenJDK的机器，以及OpenJDK源代码。在Windows环境中，必须在您的机器上安装Cygwin。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are a few simple steps to get a set of tests executed by jtreg:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些简单的步骤，以便通过jtreg执行一组测试：
- en: If jtreg is not yet available on the machine, go to the official page of jtreg
    ([https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/](https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/))
    and download the latest available version of jtreg. The other option is to build
    it from the source code. To do this, follow the instructions in the *Building
    Jtreg from the source* recipe that is covered later in this chapter. After you
    have either downloaded jtreg or built it using the source code, proceed to the
    next step.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果jtreg尚未在机器上可用，请访问jtreg的官方网站（[https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/](https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/)）并下载jtreg的最新可用版本。另一种选择是从源代码构建它。为此，请遵循本章后面将涵盖的“从源代码构建Jtreg”食谱中的说明。在你下载了jtreg或使用源代码构建了它之后，继续下一步。
- en: Unpack the downloaded archive to a folder.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的存档解压到一个文件夹中。
- en: 'In the root folder of the OpenJDK source tree, create a shell script with the
    name, `run_test.sh`. This script will be used to run jtreg:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenJDK源代码树的根目录下，创建一个名为`run_test.sh`的shell脚本。这个脚本将用于运行jtreg：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only thing here that needs to be changed is the `JT_JAVA` environment variable
    that has to point to the version of OpenJDK that is higher or equal to 1.5.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里唯一需要更改的是`JT_JAVA`环境变量，它必须指向高于或等于1.5版本的OpenJDK。
- en: 'After running the script, you will see the output as shown:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本后，您将看到如下输出：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After the test, run the HTML report that is generated by jtreg. This is available
    in the folder specified by the `-r` parameter.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，运行由jtreg生成的HTML报告。这个报告可以在由`-r`参数指定的文件夹中找到。
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, the shell script that is used to run jtreg is simple and there
    are only a few points that need to be clarified. These are the `JT_JAVA` environment
    variables and the command line arguments of jtreg.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，用于运行jtreg的shell脚本很简单，只需要澄清几个要点。这些是`JT_JAVA`环境变量和jtreg的命令行参数。
- en: '`JT_JAVA` is one of the two environment variables used by the jtreg shell script.
    `JT_JAVA` specifies the version of Java that will be used to run the framework,
    but not the tests. In this recipe, for the sake of simplicity, we used the same
    version of Java to run jtreg and the tests.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`JT_JAVA`是jtreg shell脚本使用的两个环境变量之一。`JT_JAVA`指定了将用于运行框架的Java版本，但不包括测试。在这个菜谱中，为了简单起见，我们使用了与jtreg和测试相同的Java版本。'
- en: 'The jtreg command line arguments are all described in detail on the jtreg webpage
    ([http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html)),
    so we will cover just a few of them that are used in this recipe:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg的命令行参数在jtreg网页上都有详细描述（[http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html)），所以我们将只介绍在这个菜谱中使用的一些参数：
- en: '`-jdk`: This argument will generate the JDK that will be used to run tests.
    Basically, it is the version of Java which is tested by the test run. In our example,
    we used the version that was installed on the machine. If you want to use the
    version that was built from the source, the variable should be changed appropriately
    to point to the output of the build.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-jdk`：这个参数将生成用于运行测试的JDK。基本上，这是测试运行时被测试的Java版本。在我们的例子中，我们使用了安装在机器上的版本。如果您想使用从源代码构建的版本，变量应该相应地更改以指向构建的输出。'
- en: '`-agentvm`: This is the mode when jtreg uses the pool of reusable JVMs to run
    the tests. When a test requires a separate JVM for the run, that JVM is not created,
    but it is borrowed from the pool of reusable instances. If any parameter is not
    specified, jtreg will recreate a JVM for each test and this will significantly
    slow down the test run.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-agentvm`：这是jtreg使用可重用JVM池来运行测试的模式。当一个测试需要一个单独的JVM来运行时，不会创建新的JVM，而是从可重用实例池中借用。如果没有指定任何参数，jtreg将为每个测试重新创建一个JVM，这将显著减慢测试运行速度。'
- en: '`-verbose:summary`: This argument specifies the output mode. The `summary`
    parameter means that it will print just the status and the test name.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-verbose:summary`：这个参数指定了输出模式。`summary`参数意味着它将只打印状态和测试名称。'
- en: '`-automatic`: This argument means that only the automatic tests that do not
    require user intervention will be run.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-automatic`：这个参数意味着只有不需要用户干预的自动测试将被运行。'
- en: '`-w`: This argument provides the location of the working directory. This will
    be used to store class files, and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：这个参数提供了工作目录的位置。这将用于存储类文件等。'
- en: '`-r`: This argument provides the reporting directory in which reports are to
    be stored. To see the report, open the `<reporting directory>/html/report.html`
    file in any browser.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：这个参数提供了报告目录，报告将存储在这个目录中。要查看报告，请在任何浏览器中打开`<reporting directory>/html/report.html`文件。'
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The complete list of command line options is available at [http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的命令行选项列表可在[http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html)找到。
- en: Some might find it useful to run tests only for a specific bug and, for that,
    the `bug:<bug_id>` command-line option can be used. The tests' logfiles can be
    found in the working directory (specified by the `-w` parameter or in `JTwork`
    if that parameter is not defined). Logfiles are in text format with a `.jtr` extension.
    These files contain the test output along with the command line and an exception,
    if thrown, and are very useful for troubleshooting.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人可能发现只运行特定错误的测试很有用，为此，可以使用 `bug:<bug_id>` 命令行选项。测试的日志文件可以在工作目录中找到（由 `-w` 参数指定或在未定义该参数时在
    `JTwork` 中），日志文件以 `.jtr` 扩展名的文本格式存在。这些文件包含测试输出以及命令行和抛出的异常，对于故障排除非常有用。
- en: Building jtreg from the source
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建 jtreg
- en: Apart from downloading jtreg as a binary package, there is also an option to
    download the source code and build jtreg from the source. This can be beneficial
    for developers who might want to make changes in the source code or get the latest
    fix that has not yet been released as a binary package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了下载 jtreg 作为二进制包之外，还可以选择下载源代码并从源代码构建 jtreg。这对于可能想要修改源代码或获取尚未作为二进制包发布的最新修复的开发者来说可能是有益的。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an Internet connection, a machine capable of running make and
    batch files (Linux or Cygwin), and an installed Mercurial.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个互联网连接，一台能够运行 make 和批处理文件（Linux 或 Cygwin）的机器，以及已安装的 Mercurial。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following simple steps will show you how to get the jtreg source code and
    make the build:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单步骤将展示如何获取 jtreg 源代码并构建：
- en: 'Download the sources from [http://hg.openjdk.java.net/code-tools/jtreg](http://hg.openjdk.java.net/code-tools/jtreg).
    To do this, just execute the following command that will clone the jtreg source
    tree in the local folder, `jtreg`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://hg.openjdk.java.net/code-tools/jtreg](http://hg.openjdk.java.net/code-tools/jtreg)
    下载源代码。为此，只需执行以下命令，该命令将在本地文件夹中克隆 jtreg 源代码树，`jtreg`：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the execution of the command, the current directory can be found in the
    new `jtreg` folder with all the jtreg sources.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令执行后，当前目录可以在新的 `jtreg` 文件夹中找到，其中包含所有 jtreg 源代码。
- en: If there is no Ant software installed on the machine, install it using `yum`
    (or any other packaging tool), or simply download it from [http://ant.apache.org/](http://ant.apache.org/)
    and then unpack it. If you are using a Linux machine, you also have an option
    to install it by running `yum` or any other similar tool that can be found at
    [http://ant.apache.org/](http://ant.apache.org/) and then unpack it.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果机器上没有安装 Ant 软件，可以使用 `yum`（或任何其他打包工具）安装它，或者简单地从 [http://ant.apache.org/](http://ant.apache.org/)
    下载它，然后解压。如果你使用的是 Linux 机器，你也可以选择通过运行 `yum` 或任何其他可以在 [http://ant.apache.org/](http://ant.apache.org/)
    找到的类似工具来安装它，然后解压。
- en: Download the latest available version of JT Harness, which is available at [https://jtharness.java.net/](https://jtharness.java.net/).
    Unpack it in the `jtreg/lib` folder.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 JT Harness 的最新可用版本，它可在 [https://jtharness.java.net/](https://jtharness.java.net/)
    找到。将其解压到 `jtreg/lib` 文件夹中。
- en: jtreg requires JUnit, but not the latest version. The version has to be earlier
    than 4.11\. The simplest way to get it would be to download the version from Maven
    central at [http://mvnrepository.com/artifact/junit/junit/4.5](http://mvnrepository.com/artifact/junit/junit/4.5).
    A jtreg build requires just the JAR file. Put this file in the `jtreg/lib` folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jtreg 需要 JUnit，但不一定是最新版本。版本必须早于 4.11。最简单的方法是从 Maven central 在 [http://mvnrepository.com/artifact/junit/junit/4.5](http://mvnrepository.com/artifact/junit/junit/4.5)
    下载该版本。jtreg 构建只需要 JAR 文件。将此文件放入 `jtreg/lib` 文件夹中。
- en: To make things slightly more exciting, a jtreg build also requires another testing
    framework—**TestNG v.6.8**. This can be downloaded from [http://testng.org/doc/download.html](http://testng.org/doc/download.html).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让事情变得更有趣，jtreg 构建还需要另一个测试框架——**TestNG v.6.8**。可以从 [http://testng.org/doc/download.html](http://testng.org/doc/download.html)
    下载。
- en: Note that the required version is the version for Ant users. To make things
    simpler, just use the link, [http://testng.org/testng-6.8.zip](http://testng.org/testng-6.8.zip).
    Unpack the downloaded archive in the `jtreg/lib` folder.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，所需的版本是针对 Ant 用户版本的。为了简化操作，只需使用链接，[http://testng.org/testng-6.8.zip](http://testng.org/testng-6.8.zip)。将下载的存档解压到
    `jtreg/lib` 文件夹中。
- en: The next dependency is `JavaHelp`. This seems to be available only via a direct
    link at [http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip).
    Unpack it in the `jtreg/lib` folder.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个依赖项是 `JavaHelp`。这似乎只能通过直接链接在 [http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip)
    获取。将其解压缩到 `jtreg/lib` 文件夹中。
- en: And then, finally, the last dependency, that is `Xalan`, the XML transformation
    library. The required version is 2.7.1, which can be downloaded from one of the
    websites listed at [http://www.apache.org/dyn/closer.cgi/xml/xalan-j](http://www.apache.org/dyn/closer.cgi/xml/xalan-j).
    Follow the same procedure that you did with the other libraries and unpack it
    in the `jtreg/lib` folder.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，最后一个依赖项是 `Xalan`，XML 转换库。所需版本是 2.7.1，可以从以下网站之一下载：[http://www.apache.org/dyn/closer.cgi/xml/xalan-j](http://www.apache.org/dyn/closer.cgi/xml/xalan-j)。按照您对其他库所做的相同程序，将其解压缩到
    `jtreg/lib` 文件夹中。
- en: 'Now, it is time to write the script that will execute the build. Put the following
    script code into the `make.sh` file of the `jtreg` folder, created in the first
    step:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写执行构建的脚本了。将以下脚本代码放入在第一步中创建的 `jtreg` 文件夹的 `make.sh` 文件中：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the script is simple and it is only required to set the environment
    variables. Not much explanation is required, as all the variable names are pretty
    self-explanatory. So, just assign appropriate values that are relevant for your
    machine setup. All the variables are mandatory and have to be defined to run the
    framework.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，脚本很简单，只需设置环境变量。不需要太多解释，因为所有变量名都很直观。所以，只需为您的机器设置分配适当的值。所有变量都是强制性的，必须定义才能运行框架。
- en: 'The final step is to just run that script:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步就是运行那个脚本：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the build, which should take just a few seconds, the resulting JAR file
    can be found in the `build/images/jtreg/` folder. This folder will contain a fully
    workable and self-sufficient jtreg distribution:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建（应该只需几秒钟）完成后，生成的 JAR 文件可以在 `build/images/jtreg/` 文件夹中找到。这个文件夹将包含一个完全可工作和自给自足的
    jtreg 发行版：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running the standard set of OpenJDK tests
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 OpenJDK 的标准测试集
- en: This recipe is not much different from the one that describes a simple test
    execution. However, it will focus on how to run JDK tests. This knowledge might
    be required if someone is making changes to HotSpot or to any other part of OpenJDK.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱与描述简单测试执行的菜谱没有太大区别。然而，它将重点介绍如何运行 JDK 测试。如果有人正在修改 HotSpot 或 OpenJDK 的其他部分，可能需要这些知识。
- en: Standard tests are available only in three root folders for JDK7 and in four
    folders for JDK8\. These are `hotspot`, `jdk`, `langtools`, and `nashorn` (for
    jdk8 only). Although tests are not available for other areas such as CORBA, JDBC,
    JAXP, and so on, it doesn't mean that they are not tested at all. It just means
    that tests for them are not part of OpenJDK, that is, they are not provided by
    vendors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 标准测试仅在 JDK7 的三个根文件夹和 JDK8 的四个文件夹中可用。这些是 `hotspot`、`jdk`、`langtools` 和 `nashorn`（仅限
    JDK8）。尽管其他区域如 CORBA、JDBC、JAXP 等没有测试可用，但这并不意味着它们完全没有经过测试。这只意味着它们的测试不是 OpenJDK 的一部分，也就是说，它们不是由供应商提供的。
- en: The way tests are organized varies with the dependency of the area they are
    testing, for example, `hotspot` and `langtools` are mostly grouped by functional
    areas they are testing and, then, by bugs (by their numbers). The `jdk` folder
    is mostly organized by the package name, as this set of tests covers the Java
    APIs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的组织方式因测试区域的依赖性而异，例如，`hotspot` 和 `langtools` 主要按它们测试的功能区域分组，然后按错误（编号）分组。`jdk`
    文件夹主要按包名组织，因为这个测试集涵盖了 Java API。
- en: Keep in mind that some tests might fail, but it does not mean that something
    is particularly wrong with OpenJDK. It just means that there are some situations
    when it is rather hard to create a test that can pass in any environment. For
    example, there can be tests that need a special network configuration or some
    other sort of special environment, which might not be set up on the machine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有些测试可能会失败，但这并不意味着 OpenJDK 有什么特别的问题。这只意味着在某些情况下，很难创建在任何环境中都能通过测试的测试。例如，可能有需要特殊网络配置或某些其他特殊环境的测试，而这些可能没有在机器上设置。
- en: There is a set of tests that are known to fail and there is usually a good reason
    for that. The most obvious example is a test that covers some known problem, but
    whose fix is not going to happen soon. These tests are listed in `jdk/test/ProblemList.txt`
    or marked with a `@ignore` tag. These tests should usually be excluded from the
    standard test run.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些已知的测试会失败，通常有很好的理由。最明显的例子是覆盖了一些已知问题的测试，但修复这些问题的方案不会很快出现。这些测试列在`jdk/test/ProblemList.txt`中，或者用`@ignore`标签标记。通常，这些测试应该从标准测试运行中排除。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As we will be running tests for OpenJDK, it is required to have relevant sources
    available on the machine. The machine should also be set up for the OpenJDK build,
    as we will be using OpenJDK make files to execute the test run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将运行OpenJDK的测试，机器上需要有相关的源代码。机器还应设置好OpenJDK构建环境，因为我们将会使用OpenJDK的make文件来执行测试运行。
- en: jtreg should be downloaded and unpacked in a folder on the machine so that it
    is ready for the test run.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg应该在机器上的一个文件夹中下载并解压，以便为测试运行做好准备。
- en: Some OpenJDK tests are shell scripts, so you will need to use either a Linux
    machine or, in the case of a Windows machine, Cygwin with support for the Bourne
    shell, even though Cygwin is not recommended, as there is a chance that some shell
    tests will not run properly on it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些OpenJDK测试是shell脚本，因此你需要使用Linux机器，或者在Windows机器上使用支持Bourne shell的Cygwin，尽管不推荐使用Cygwin，因为有可能某些shell测试无法在它上面正确运行。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'One of the most convenient ways to run tests is to run them separately for
    each area, such as `hotspot`, `jdk`, and so on. As the aim of this recipe is to
    just explain the concept, we will be using the `jdk` tests, which are just a subset
    of all the tests available in OpenJDK, but the same pattern can be applied to
    all the other areas as well. Follow the given steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试最方便的方式之一是为每个区域单独运行，例如`hotspot`、`jdk`等。由于本菜谱的目的是仅解释概念，我们将使用`jdk`测试，这些测试只是OpenJDK中所有测试的一个子集，但相同的模式也可以应用于所有其他区域。按照以下步骤操作：
- en: 'In the OpenJDK source root folder, create a file with the name, `run_jdk_lang_tests.sh`
    and the following content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenJDK源根目录下，创建一个名为`run_jdk_lang_tests.sh`的文件，并包含以下内容：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `JTREG_HOME` and `JT_HOME` environment variables are both the same and should
    point to a folder with jtreg. Unfortunately, there are places in make files where
    both these variables are used.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JTREG_HOME`和`JT_HOME`环境变量都是相同的，应该指向包含jtreg的文件夹。不幸的是，在make文件中有地方同时使用了这两个变量。'
- en: '`PRODUCT_HOME` points to a JDK in the test. It is not strictly required to
    point it to a version of JDK that was just built from the source, but there is
    also no sense in executing tests on a version that one can''t change.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PRODUCT_HOME`指向测试中的JDK。并不严格要求它指向从源代码构建的JDK版本，但也没有必要在无法更改的版本上执行测试。'
- en: '`TESTDIRS` points to a subset of tests to run. Obviously, the wider that subset,
    the more tests will be executed and the longer it will take to run. So usually
    it makes sense to limit this subset to something reasonable, unless there is a
    need to do a regression test after making big changes.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TESTDIRS`指向要运行的测试子集。显然，这个子集越广，要执行的测试就越多，运行时间也就越长。所以通常来说，将这个子集限制在合理范围内是有意义的，除非在做出重大更改后需要进行回归测试。'
- en: 'Now let''s run the script. It will execute tests in the `jdk` folder and output
    hundreds of lines like these:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行脚本。它将在`jdk`文件夹中执行测试，并输出数百行类似的内容：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When it''s all finished, the make script will report something as shown:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一切完成后，make脚本将报告如下：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding output tells us how many tests were executed, how many failed,
    how many passed, and so on. Now, when all the tests that we were interested in
    are run, the results can be found in the `jdk/build/linux-amd64/testoutput/JTreport`
    folder. There will be standard jtreg text and HTML report files that can be viewed
    using any web browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出告诉我们执行了多少测试，有多少失败了，有多少通过了，等等。现在，当我们运行所有感兴趣的测试后，结果可以在`jdk/build/linux-amd64/testoutput/JTreport`文件夹中找到。将会有标准的jtreg文本和HTML报告文件，可以使用任何网络浏览器查看。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If someone came to a point where there was a need to run an OpenJDK test, there
    is a good chance that there would be a situation when the tests had to be updated
    or extended. In that case, it is important to have a good understanding of what
    is going on inside these tests and what is the exact reason for each of them to
    exist. Mostly, that information is available in the `@bug` and `@summary` tags.
    It is highly recommended to pay attention to their content and put in some effort
    to see how they correlate with actual test code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人到了需要运行OpenJDK测试的地步，很可能会有这样的情况，即测试需要更新或扩展。在这种情况下，了解这些测试内部发生的事情以及每个测试存在的确切原因是很重要的。大多数情况下，这些信息都包含在`@bug`和`@summary`标签中。强烈建议关注它们的内容，并投入一些努力来了解它们如何与实际的测试代码相关联。
- en: 'Most of the tests contain additional information in the `@bug` and `@summary`
    tags. It is important to refer to these tags to understand the reason for the
    test. For example, when you run tests, it is not uncommon to see an output like
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试在`@bug`和`@summary`标签中包含额外的信息。参考这些标签来理解测试的原因是很重要的。例如，当你运行测试时，看到以下类似的输出并不罕见：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It means that this is the test for the bug with ID `7157574`, which can actually
    be found in the JDK bug tracking system at [https://bugs.openjdk.java.net/browse/JDK-7157574](https://bugs.openjdk.java.net/browse/JDK-7157574).
    And, when one takes a look at the test, the following information will be in the
    header:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这是一个针对ID为`7157574`的bug的测试，实际上可以在JDK错误跟踪系统中找到[https://bugs.openjdk.java.net/browse/JDK-7157574](https://bugs.openjdk.java.net/browse/JDK-7157574)。当查看测试时，以下信息将在标题中：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This header has a reference to the bug that this test is testing and, in the
    summary section, it explains exactly what this test is doing. Also, when you look
    at the source of a test, it is quite common to see that it contains a very detailed
    explanation of the problem and the way that the problem is being tested.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题引用了这个测试正在测试的bug，在摘要部分，它详细说明了这个测试正在做什么。此外，当你查看测试的源代码时，通常可以看到它包含了一个非常详细的关于问题的解释以及测试问题的方法。
- en: Writing your own test for jtreg
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为jtreg编写自己的测试
- en: If you are going to add a new feature to OpenJDK or fix a bug, it is really
    a good idea to have a test case to cover the change in functionality and to ensure
    that the implementation change doesn't break anything. This recipe will help you
    to get some understanding of the process and create a simple test. You will find
    that writing your own test case for jtreg is not a complicated task, but it can
    be slightly unusual in some respects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算向OpenJDK添加新功能或修复一个错误，有一个测试用例来覆盖功能的变化并确保实现更改不会破坏任何东西，这确实是一个好主意。这个方法将帮助你了解这个过程并创建一个简单的测试。你会发现为jtreg编写自己的测试用例并不是一个复杂的工作，但在某些方面可能有些不寻常。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: All that is required for this recipe is an installed jtreg and the OpenJDK sources.
    The latter is required only because this recipe assumes that the newly created
    test is for OpenJDK.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只需要安装jtreg和OpenJDK源代码。后者是必需的，因为这种方法假设新创建的测试是针对OpenJDK的。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Writing tests for jtreg can be a little unusual, but when you get used to the
    pattern it is actually quite easy. To begin, just follow the steps. Keep in mind
    that all the paths are given relative to the OpenJDK source root:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为jtreg编写测试可能有些不寻常，但当你习惯了这种模式，实际上相当简单。开始时，只需遵循以下步骤。记住，所有路径都是相对于OpenJDK源根给出的：
- en: 'Go to the root folder of OpenJDK and create the `jdk/test/demo/SampleTest.java`
    file first:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往OpenJDK的根目录，首先创建`jdk/test/demo/SampleTest.java`文件：
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, create the `jdk/test/demo/SampleTimeProvider.java` file as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式在`jdk/test/demo/SampleTimeProvider.java`文件中创建文件：
- en: '[PRE12]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create a script file with the name, `run_jtreg.sh` in the source root
    folder of JDK and run it:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在JDK源根目录下创建一个名为`run_jtreg.sh`的脚本文件并运行它：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should be as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, only one test was run and the run was successful. So, writing
    a simple test case is a very simple task.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，只运行了一个测试，并且运行成功。因此，编写一个简单的测试用例是一个非常简单的任务。
- en: Now, the final step. After all the tests have been run, let's look at the test
    result whose path was provided in the output of jtreg. Let's open `report/html/repost.html`
    in a web browser and take a look at what's there:![How to do it...](img/8405OT_09_01.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后一步。在所有测试都运行完毕后，让我们看看jtreg输出中提供的测试结果路径。让我们在网页浏览器中打开`report/html/repost.html`并查看其中的内容：![如何操作...](img/8405OT_09_01.jpg)
- en: Here, we can see that only one test, **demo/SampleTest.java**, was executed
    and it was the one that passed.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到只有一个测试，**demo/SampleTest.java**被执行，并且它通过了。
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Some explanation is required to find out what actually happened. The test itself
    is in the `SampleTest.java` file. jtreg knows that the file contains the test
    by the presence of the `@test` tag in the class header comments. Without that
    tag, jtreg will not consider it as a test.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些解释来找出实际发生了什么。测试本身位于`SampleTest.java`文件中。jtreg通过类头部注释中存在的`@test`标签知道该文件包含测试。如果没有这个标签，jtreg不会将其视为测试。
- en: The only purpose of the `@summary` tag is to give a summary description for
    the test. This description will also be used in logs and reports. It is very important
    to have a good, readable description for that tag. Also, if a test is for a bug,
    it is necessary to have the `@bug` tag populated with an appropriate bug number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`@summary`标签的唯一目的是为测试提供一个总结描述。这个描述也将用于日志和报告中。为该标签提供一个良好、易读的描述非常重要。此外，如果测试是为了一个错误，那么有必要将`@bug`标签填充适当的错误编号。'
- en: The next tag, `@compile`, has a reference to another file, which is required
    to be compiled to run the test. The only reason for the existence of `SampleTimeProvider.java`
    is to show how to use the `@compile` tag. It is very unusual for Java to do things
    like this. Usually, everything is compiled and then things are picked from the
    classpath, but this is the way Java works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个标签`@compile`引用了另一个文件，该文件需要编译后才能运行测试。`SampleTimeProvider.java`的存在只是为了展示如何使用`@compile`标签。Java做这样的事情非常不寻常。通常，所有内容都会编译，然后从类路径中选取，但这是Java的工作方式。
- en: The `@run` tag tells the harness how to run the test. As can be seen from the
    test class, this parameter can be defined several times, which means that the
    test will also be executed several times and each time it will be run with a configuration
    defined by the associated run tag. In our example, there are two runs, one in
    the same VM and the other in a new instance of VM, which is specified by the `othervm`
    parameter. If this tag is not defined, then, by default, jtreg assumes that it
    is `@run main ClassName`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`@run`标签告诉测试框架如何运行测试。从测试类中可以看出，这个参数可以定义多次，这意味着测试也将执行多次，每次都会使用关联的运行标签定义的配置来运行。在我们的例子中，有两个运行，一个在同一虚拟机中，另一个在由`othervm`参数指定的新虚拟机实例中。如果没有定义此标签，则jtreg默认假设它是`@run
    main ClassName`。'
- en: Note that a test fails if it runs for longer than 2 minutes (120 seconds) and
    can be overwritten by `@run main/timeout=xxx`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果测试运行时间超过2分钟（120秒），则测试失败，并且可以被`@run main/timeout=xxx`覆盖。
- en: Usually, a test indicates its failure by throwing an exception. A test from
    this recipe will throw `RuntimeException` when its conditions are not met.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试通过抛出异常来指示其失败。如果条件不满足，这个测试用例将抛出`RuntimeException`。
- en: jtreg requires the `TEST.ROOT` file to be created in the tests' root folder.
    Without that file, it will not execute any test. Luckily for us, JDK already has
    the required file with the appropriate content, so there is no need for us to
    worry about it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg要求在测试的根目录中创建`TEST.ROOT`文件。没有这个文件，它将不会执行任何测试。幸运的是，对于JDK来说，它已经有了包含适当内容的所需文件，所以我们不需要担心这个问题。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: jtreg test cases are defined by the Javadoc tags and it is useful to be familiar
    with all of them. The complete list of tags and information about each tag is
    available either in the help file that can be accessed by running the jtreg command,
    `–onlineHelp`, or online at [http://openjdk.java.net/jtreg/tag-spec.html](http://openjdk.java.net/jtreg/tag-spec.html).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg测试用例由Javadoc标签定义，熟悉所有这些标签是有用的。标签的完整列表和每个标签的信息可以在通过运行jtreg命令`–onlineHelp`访问的帮助文件中找到，或者在网上[http://openjdk.java.net/jtreg/tag-spec.html](http://openjdk.java.net/jtreg/tag-spec.html)找到。
- en: Using jtreg in GUI mode
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GUI模式下使用jtreg
- en: jtreg is not only a command-line tool, but it also provides a relatively sophisticated
    graphical interface that allows you to run an individual set of tests, prepare
    test runs, see results of the run, and so on. This recipe will cover some basic
    features of UI that are enough for the user to start using the tool.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg不仅是一个命令行工具，还提供了一个相对复杂的图形界面，允许你运行单个测试集、准备测试运行、查看运行结果等等。此配方将涵盖一些基本的UI功能，足以让用户开始使用此工具。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All that is required for this recipe is an installed jtreg and the OpenJDK sources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方所需的所有内容只是一个已安装的jtreg和OpenJDK源代码。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the following script that will launch jtreg with a graphical UI:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下脚本以启动具有图形用户界面的jtreg：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameter that tells jtreg to launch JT Harness UI is `-g`. After it is
    launched, jtreg displays a window similar to the following one:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉jtreg启动JT Harness UI的参数是`-g`。启动后，jtreg显示一个类似于以下窗口：
- en: '![How to do it...](img/8405OT_09_02.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8405OT_09_02.jpg)'
- en: On the right-hand side of the preceding screenshot, you can see the results
    of the latest test run. It knows where to pick them up from the `–r` parameter.
    In this screenshot, you can also see the number of successful and failed tests,
    the total number of executed tests, and some other stats.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的截图右侧，你可以看到最新测试运行的结果。它知道从`–r`参数中提取它们的位置。在此截图中，你还可以看到成功和失败的测试数量、执行的总测试数量和一些其他统计数据。
- en: On the left-hand side of the preceding screenshot, there is a tree with all
    the available tests. This shows all the tests from the root of the test bundle,
    which is the folder with the `TEST.ROOT` configuration file. The green folder
    icon indicates the tests that ran successfully and the red one indicates the ones
    that failed.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的截图左侧，有一个包含所有可用测试的树。这显示了从测试包的根目录开始的全部测试，该目录包含`TEST.ROOT`配置文件。绿色文件夹图标表示成功运行的测试，红色图标表示失败的测试。
- en: To run a specific test from a set of tests, right-click on the individual test
    folder and select the **Execute these test** item from the pop-up menu. This will
    trigger the test run and a new report will be generated. For long running tests,
    there is a status window, which is available via the **Run Tests** | **Monitor
    Progress** menu item:![How to do it...](img/8405OT_09_03.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从一组测试中运行特定的测试，右键单击单个测试文件夹，并从弹出菜单中选择**执行这些测试**项。这将触发测试运行，并生成一个新的报告。对于长时间运行的测试，有一个状态窗口，可通过**运行测试**|**监控进度**菜单项访问：![如何操作...](img/8405OT_09_03.jpg)
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The UI that is used by jtreg does not actually belong to jtreg. It is provided
    by JT Harness and jtreg just integrates it using the provided plugin system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg使用的UI实际上并不属于jtreg。它由JT Harness提供，jtreg只是通过提供的插件系统将其集成。
- en: JT Harness provides a rich interface not only to run tests, but it also has
    a set of wizards to create test configurations, various report conversion tools,
    an agent monitoring tool, and so on. To get more information about all these features,
    refer to JT Harness online help, which is available via the **Help/Online Help**
    menu item.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JT Harness不仅提供了一个丰富的界面来运行测试，还提供了一套向导来创建测试配置、各种报告转换工具、代理监控工具等等。要获取有关所有这些功能的更多信息，请参阅JT
    Harness在线帮助，它可通过**帮助/在线帮助**菜单项访问。
- en: Writing TestNG tests for jtreg
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为jtreg编写TestNG测试
- en: jtreg also provides support to run TestNG test cases, which might be a more
    familiar technique for many developers. There are some steps that need to be performed
    to make it happen and this recipe will go through them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: jtreg还提供了运行TestNG测试用例的支持，这可能对许多开发者来说是一个更熟悉的技巧。需要执行一些步骤才能实现这一点，此配方将介绍这些步骤。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will require the OpenJDK source code and an installed version of
    jtreg. On a Windows machine, it is also required to have Cygwin installed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要OpenJDK源代码和已安装的jtreg版本。在Windows机器上，还需要安装Cygwin。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following procedure should be more familiar to Java developers than writing
    a native jtreg test, as TestNG is what most developers have heard of and used.
    Now, let's get to the practical part and create a test. The paths are relative
    to the OpenJDK source root.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程对Java开发者来说可能比编写本机jtreg测试更熟悉，因为TestNG是大多数开发者所听说并使用的。现在，让我们进入实际部分并创建一个测试。路径相对于OpenJDK源根目录。
- en: Relative to the OpenJDK root folder, create a folder with the name, `jdk/test/testng/org/demo`.
    This is the folder where we are going to create our tests.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相对于OpenJDK根文件夹，创建一个名为`jdk/test/testng/org/demo`的文件夹。这是我们将要创建测试的文件夹。
- en: 'Create the file, `jdk/test/testng/TEST.properties`, relative to the OpenJDK
    source root. Add the following line there:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相对于OpenJDK源根的`jdk/test/testng/TEST.properties`文件中创建文件，添加以下行：
- en: '[PRE16]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is not strictly required to create the file, and it is also possible to define
    the property in `jdk/test/TEST.ROOT`, which will work in the same way as our previous
    property. However, in most cases, it is practical to have that file so that it
    can contain some additional configuration that is specific to the set of TestNG
    tests, for example, the `lib.dirs` property.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建该文件不是严格必要的，也可以在`jdk/test/TEST.ROOT`中定义属性，这将以相同的方式工作，就像我们之前的属性一样。然而，在大多数情况下，有一个这样的文件是实用的，因为它可以包含一些针对TestNG测试集的特定配置，例如，`lib.dirs`属性。
- en: 'In the `jdk/test/testng/org/mydemo` folder, create the following file with
    the name, `MyTestNGTest.java`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jdk/test/testng/org/mydemo`文件夹中，创建以下名称的文件，`MyTestNGTest.java`：
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, in OpenJDK''s source root folder, create the following bash script (fix
    the paths as required to match the machine environment):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在OpenJDK的源根文件夹中，创建以下bash脚本（根据机器环境需要调整路径）：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, give it a name, `./run_jtreg.sh`, and make it executable (running `chmod
    +x ./run_jterg.sh` will do the job) and run it. The resulting output of the script
    should look similar to the following:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，给它一个名字，`./run_jtreg.sh`，并使其可执行（运行`chmod +x ./run_jterg.sh`即可完成此操作）并运行它。脚本的输出结果应类似于以下内容：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that's it. The test has been run and, as can be seen from the output, it
    has passed. The result of the run can be seen by opening `/home/user/openjdk/jdk7u/build/jtreg/report/html/report.html`
    in the browser application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。测试已经运行，并且从输出中可以看出，它已经通过。运行的结果可以通过在浏览器应用程序中打开`/home/user/openjdk/jdk7u/build/jtreg/report/html/report.html`来查看。
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The file named `TEST.properties` that is created in the folder with the tests
    root package, requires a bit of explanation. This is the file that contains sets
    of configurations specific to the TestNG tests in the folder where the file is
    located. For example, it can have a reference to folders with libraries via the
    `lib.dirs` property. That is the `path` type property, which is the same as `TestNG.dirs`,
    and such properties are space-separated lists of paths to some of the folders
    or files. If the path in the list starts with `/`, then it is evaluated relative
    to a folder with `TEST.ROOT`, otherwise it is evaluated from the directory containing
    `TEST.properties`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试根包文件夹中创建的名为`TEST.properties`的文件需要一些解释。这是包含特定于TestNG测试的配置集的文件。例如，它可以通过`lib.dirs`属性引用包含库的文件夹。这是一个`path`类型的属性，与`TestNG.dirs`相同，此类属性是路径到某些文件夹或文件的空格分隔列表。如果列表中的路径以`/`开头，则相对于`TEST.ROOT`文件夹进行评估，否则从包含`TEST.properties`的目录进行评估。
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As it is possible to use the TestNG annotations within the test classes, it
    is worth checking the TestNG website, which contains some documentation on this
    topic at [http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以在测试类中使用TestNG注解，因此查看TestNG网站是值得的，该网站包含一些关于此主题的文档，链接为[http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html)。
- en: It is also possible to use the jtreg style tags and the TestNG style test together.
    In that case, the test should be created as a normal jtreg test (see the *Writing
    your own test for jtreg* recipe), using `testng` as the argument for `@run`, for
    example, `@run testng SampleTest`. In this scenario, there is no need for `TEST.properties`
    and things like `lib.dirs` are defined in the test source file via the jtreg tags,
    rather than in a separate configuration file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用jtreg样式标签和TestNG样式测试一起使用。在这种情况下，测试应创建为正常的jtreg测试（参见*为jtreg编写自己的测试*配方），使用`testng`作为`@run`的参数，例如，`@run
    testng SampleTest`。在这种情况下，不需要`TEST.properties`，并且像`lib.dirs`这样的东西通过jtreg标签在测试源文件中定义，而不是在单独的配置文件中定义。
- en: Compiling JT Harness from the source code
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码编译JT Harness
- en: JT Harness is a framework that allows you to execute different sets of tests.
    It is not necessary to use it only with jtreg. Other testing frameworks can be
    integrated with it as well. This means that it could be useful to have its source
    code to be able to build it from the source. This is exactly what this recipe
    is going to explain.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JT Harness是一个框架，允许您执行不同的测试集。您不必仅使用jtreg。其他测试框架也可以与之集成。这意味着拥有其源代码以便从源代码构建它可能很有用。这正是本食谱将要解释的内容。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need Internet access to download the source code and install the additional
    software that is required for the build.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要互联网访问来下载源代码和安装构建所需的附加软件。
- en: 'Ensure that Ant version 1.6.1 or later is installed on the machine. If not,
    then install it. The *How to do it...* section depends on the OS you are using.
    For example, on Fedora, that will be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 确保机器上安装了Ant版本1.6.1或更高版本。如果没有，请安装它。*如何做...*这一部分取决于您使用的操作系统。例如，在Fedora上，它将是：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On Windows, the simplest way would be to just download the distribution and
    add Ant's `bin` folder to the `PATH` environment variable. The Ant distribution
    can be found at [http://ant.apache.org/](http://ant.apache.org/). Keep in mind
    that, to make it work, the `JAVA_HOME` environment variable has to contain the
    correct path of the Java distribution.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，最简单的方法是下载发行版并将Ant的`bin`文件夹添加到`PATH`环境变量中。Ant发行版可以在[http://ant.apache.org/](http://ant.apache.org/)找到。请注意，为了使其工作，`JAVA_HOME`环境变量必须包含Java发行版的正确路径。
- en: 'Ensure that Subversion is installed on the machine. In contrast to other tools,
    JT Harness doesn''t use the Mercurial repository for its source code. On Fedora,
    Subversion can be installed by running `yum`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保机器上已安装Subversion。与其它工具不同，JT Harness不使用Mercurial仓库来存储其源代码。在Fedora上，可以通过运行`yum`来安装Subversion：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: On any other OS, it really depends on the OS. Check [http://subversion.apache.org/](http://subversion.apache.org/)
    to find out what is available.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他操作系统上，这完全取决于操作系统。请检查[http://subversion.apache.org/](http://subversion.apache.org/)以了解可用的选项。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the following command to check the source code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查源代码：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command will create a folder with the name, `jtharness`, and download the
    source code. In that folder, create another folder and name it, `lib`. Here we
    will put the libraries required to build JT Harness.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为`jtharness`的文件夹，并下载源代码。在该文件夹中创建另一个文件夹，并将其命名为`lib`。在这里，我们将放置构建JT Harness所需的库。
- en: 'Now download the following software (all paths are given relative to the `jtharness`
    folder):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下载以下软件（所有路径都是以`jtharness`文件夹为相对路径）：
- en: JavaHelp seems to be available only via a direct link from [http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip).
    Unpack it into `lib/jh2.0`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaHelp似乎只能通过[http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip)的直接链接获得。将其解压到`lib/jh2.0`。
- en: Go to [http://asm.ow2.org/](http://asm.ow2.org/) and download the ASM Java bytecode
    manipulation library binaries version 3.1\. Unpack the archive into `lib/asm-3.1`.
    This is required only for compilation.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://asm.ow2.org/](http://asm.ow2.org/)下载ASM Java字节码操作库的二进制版本3.1。将其解压到`lib/asm-3.1`。这仅用于编译。
- en: Next, the required library is `Java Communications API`. Go to [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html)
    and download `Java Communications API 3.0u1` or any other higher version that
    is available. Unpack the archive into `lib/commapi`. This is required only for
    compilation.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，所需的库是`Java Communications API`。前往[http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html)下载`Java
    Communications API 3.0u1`或任何其他可用的更高版本。将其解压到`lib/commapi`。这仅用于编译。
- en: Java Servlet APIs are only required for compilation. Probably the simplest way
    to download them is to get the JAR from Maven Central. Go to [http://search.maven.org/](http://search.maven.org/)
    and search for `javax.servlet servlet-api`. Download the JAR v.3.1.0 and put it
    directly into the `lib` folder.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java Servlet API仅用于编译。最简单的方法是直接从Maven Central获取JAR文件。访问[http://search.maven.org/](http://search.maven.org/)并搜索`javax.servlet
    servlet-api`。下载版本3.1.0的JAR文件并将其直接放入`lib`文件夹。
- en: The last one is JUnit, which is also only required for compilation. The recommended
    version is 4.4\. Go to [http://junit.org/](http://junit.org/)and click on the
    **Download** link to download the appropriate version of the JAR file. Place it
    directly into the `lib` folder.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个是JUnit，它也仅用于编译。推荐版本是4.4。访问[http://junit.org/](http://junit.org/)并点击**下载**链接以下载适当的JAR文件版本。将其直接放入`lib`文件夹。
- en: 'The next step is to get the sources. To do this, run the following command
    that will get the latest sources from the trunk:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是获取源代码。为此，运行以下命令，将从主干获取最新源代码：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will create the folder, `jtharness`, with two subfolders: `www` and `code`.
    The `www` folder contains pages with links to the documentation and other useful
    information, but we are really interested in the folder with the name code. It
    is actually not strictly necessary to download `www` at all, but it doesn''t do
    any harm either.'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个名为`jtharness`的文件夹，其中包含两个子文件夹：`www`和`code`。`www`文件夹包含指向文档和其他有用信息的页面链接，但我们真正感兴趣的是名为`code`的文件夹。实际上，根本没有必要下载`www`，但这也不会造成任何伤害。
- en: 'Go to the folder, `jtharness/code/build`, locate the file `local.properties`,
    and edit it to set the following properties to point to the appropriate locations:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往文件夹`jtharness/code/build`，找到文件`local.properties`，并编辑它以设置以下属性以指向适当的路径：
- en: '`jhalljar`: This provides the path to the JavaHelp `jhalljar.jar` file'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhalljar`: 这提供了JavaHelp `jhalljar.jar`文件的路径。'
- en: '`jhjar`: This property provides the path to the JavaHelp `jhjar.jar` file'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhjar`: 此属性提供了JavaHelp `jhjar.jar`文件的路径。'
- en: '`jcommjar`: This provides the path to `comm.jar` from the `Java Communications
    API`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jcommjar`: 这提供了从`Java Communications API`到`comm.jar`文件的路径。'
- en: '`servletjar`: This provides the path to the `servlet-api.jar` file from `Java
    Servlet API`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servletjar`: 这提供了从`Java Servlet API`到`servlet-api.jar`文件的路径。'
- en: '`bytecodelib`: This provides a colon-separated path to the `asm-3.1.jar` and
    `asm-commons-3.1.jar` files'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytecodelib`: 这提供了冒号分隔的`asm-3.1.jar`和`asm-commons-3.1.jar`文件的路径。'
- en: '`junitlib`: This provides the path to `junit-4.4.jar` from jUnit'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junitlib`: 这提供了从jUnit到`junit-4.4.jar`文件的路径。'
- en: 'After the editing, the file should look similar to this:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑后，文件应类似于以下内容：
- en: '[PRE24]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If it is required, the `BUILD_DIR` variable can be changed to a different folder
    but, usually it is not necessary.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，可以将`BUILD_DIR`变量更改为不同的文件夹，但通常没有必要。
- en: 'Now ensure that the current folder is `jtharness/code/build` and run Ant:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确保当前文件夹是`jtharness/code/build`，然后运行Ant：
- en: '[PRE25]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the build is finished, the folder, `jtharness/JTHarness-build/binaries`,
    contains the distribution of JT Harness.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当构建完成后，文件夹`jtharness/JTHarness-build/binaries`将包含JT Harness的分发版本。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There are other targets available in the JT Harness build file that you may
    find useful:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JT Harness构建文件中还有其他一些目标，你可能觉得它们很有用：
- en: '`run`: This builds and runs JT Harness. This is not the only way to launch
    the application. The other option is to run the following command from the source
    root folder after the build:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 这将构建并运行JT Harness。这不是启动应用程序的唯一方法。另一种选择是在构建后从源根目录运行以下命令：'
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`clean`: This just builds the distribution directory.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clean`: 这只是构建分发目录。'
- en: '`build`: This builds JT Harness and then runs all the tests.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 这将构建JT Harness然后运行所有测试。'
- en: '`test`: This just runs the test.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 这只是运行测试。'
- en: '`Javadoc`: This generates the Javadoc API documentation.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Javadoc`: 这将生成Javadoc API文档。'
- en: '`build-examples`: This builds the example test suites packaged with the source.
    This target also automatically builds the core harness first.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-examples`: 这将构建与源代码一起打包的示例测试套件。此目标还会自动首先构建核心工具。'
- en: Building and running jcstress
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 和 运行 jcstress
- en: The **Java Concurrency Stress Test** (**jcstress**) is a set of tests for testing
    the correctness of the Java concurrency support. This is a new tool that is mostly
    targeted to Java 8, which means that not all the tests will run on previous versions
    of Java. As a new tool, jcstress is in its alpha phase and changes for fixes and
    improvements are common, which means that whoever is working with it is expected
    to update the source code and rebuild the tool relatively often.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java并发压力测试**（**jcstress**）是一组用于测试Java并发支持的正确性的测试。这是一个主要针对Java 8的新工具，这意味着并非所有测试都能在Java的先前版本上运行。作为一个新工具，jcstress处于alpha阶段，修复和改进的更改很常见，这意味着使用它的人预计需要相对频繁地更新源代码和重新构建工具。'
- en: Testing concurrency is not an easy task and it may or may not be easy to make
    such tests fail even with incorrect code. This happens due to the nature of concurrent
    code, which might work differently on different hardware configurations. Such
    variations arise from the number of CPUs or the CPU architecture. Overall, this
    means that many tests in jcstress are uncertain and they might require a long
    time before exposing potential problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并发性不是一个容易的任务，即使代码有误，也可能很难使这样的测试失败。这是因为并发代码的性质，它可能在不同的硬件配置上以不同的方式工作。这种差异可能源于CPU的数量或CPU架构。总的来说，这意味着jcstress中的许多测试都是不确定的，它们可能需要很长时间才能暴露潜在的问题。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need Internet access and the Mercurial repository to download the
    source code. As jcstress requires Java 8 for compilation and to run the full set
    of tests, it has to be installed on the machine and set as the current version.
    This means that the following commands should, as illustrated next, show Java
    1.8 as the major version:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要互联网访问和Mercurial仓库来下载源代码。由于jcstress需要Java 8进行编译和运行完整的测试集，因此它必须安装到机器上，并设置为当前版本。这意味着以下命令应显示Java
    1.8作为主要版本，如以下所示：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The build will also require Maven (one of the Java build tools) to be installed
    on the machine. The installation of this tool depends on the OS. For example,
    on Fedora, this can be done by running the following command as root:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 构建还需要在机器上安装Maven（Java构建工具之一）。这个工具的安装取决于操作系统。例如，在Fedora上，可以通过以下命令作为root用户执行：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On other OSs, the simplest way might be to download the binary from [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi),
    unpack the archive, point `M2_HOME` to the root of the unpacked folder and add
    `M2_HOME/bin` to the path.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他操作系统上，最简单的方法可能是从[http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi)下载二进制文件，解压存档，将`M2_HOME`指向解压文件夹的根目录，并将`M2_HOME/bin`添加到路径中。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now it''s time for action. The first few steps of this recipe will cover the
    build process and then it will switch to run the actual tests:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是采取行动的时候了。这个食谱的前几个步骤将涵盖构建过程，然后它将切换到运行实际的测试：
- en: 'The first step is to download the sources. Go to the folder where you want
    to store the source code and run the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是下载源代码。转到您想要存储源代码的文件夹，并运行以下命令：
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When this command is run, Mercurial is downloaded along with the source code
    from the remote repository and it is stored in the folder, `jcstress`.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当运行此命令时，Mercurial将从远程仓库下载源代码，并存储在`jcstress`文件夹中。
- en: 'Now, to build the tool, move to the folder `jcstress` and run the following
    command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要构建这个工具，移动到`jcstress`文件夹并运行以下命令：
- en: '[PRE30]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If successful, it should display something like this as the end:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功，它应该在结束时显示如下：
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This means that the build has done what it was supposed to do and the tests
    are ready to be run.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着构建已经完成了它应该做的事情，测试准备就绪，可以运行。
- en: 'To run all the tests, use the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行所有测试，请使用以下命令：
- en: '[PRE32]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will output thousands of lines like these:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将输出数千行类似的内容：
- en: '[PRE33]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`ETA` is the estimated completion time, `R` is the runtime in nanoseconds,
    `T` is the test number, `F` is the fork number, and `I` is the test iteration
    number. This is all followed by the result (`OK` in this example) and the full
    name of the test class.'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ETA`是预计完成时间，`R`是运行时间（以纳秒为单位），`T`是测试编号，`F`是分支编号，`I`是测试迭代编号。所有这些后面都跟着结果（本例中的`OK`）和测试类的全名。'
- en: 'As you can see, the full standard set of tests run for approximately 40 minutes,
    and this might be too much, so there is an option to select which test to run
    using the `-t` parameter. This is a regular expression selected for the tests,
    for example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，完整的标准测试集运行大约需要40分钟，这可能太多了，所以有一个选项可以使用`-t`参数选择要运行的测试。这是一个为测试选择的正则表达式，例如：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will only run tests which have `ByteBufferAtomicityTests` anywhere in their
    name.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只运行名称中包含`ByteBufferAtomicityTests`的测试。
- en: 'When the tests are completed, it is time to have a look at the reports that
    are generated and, by default, they are put into the `./results/` folder. There
    you can find the file, `index.html`, which can be opened with any browser. The
    result will list all the tests and, if you click on the tests, all the observer
    outputs. These outputs can be something that is expected, not expected, or expected
    but somehow surprising to the user. This can result in the following outcomes
    for a test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试完成后，是时候查看生成的报告了，默认情况下，它们被放入 `./results/` 文件夹中。在那里您可以找到文件 `index.html`，可以用任何浏览器打开。结果将列出所有测试，如果您点击测试，将列出所有观察者输出。这些输出可能是预期的，不是预期的，或者预期但以某种方式对用户来说令人惊讶。这可能导致以下测试结果：
- en: '`FAILED`: The test failed and the outcomes were not what was expected'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED`: 测试失败，结果并非预期'
- en: '`ERROR`: The test crashed'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`: 测试崩溃'
- en: '`ACCEPTABLE`: The test results matched the specifications'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCEPTABLE`: 测试结果符合规范'
- en: '`ACCEPTABLE_INTERESTING`: This is the same as `ACCEPTABLE`, but it has something
    to highlight'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCEPTABLE_INTERESTING`: 这与 `ACCEPTABLE` 相同，但它有一些值得强调的内容'
- en: '`ACCEPTABLE_SPEC`: This is the same as `ACCEPTABLE`, but some interesting behavior
    is also observed that might not be otherwise expected'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCEPTABLE_SPEC`: 这与 `ACCEPTABLE` 相同，但还观察到一些可能不会预料到的有趣行为'
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is recommended that you have a look at the other command-line options that
    are available for jcstress. This information can be retrieved by running the following
    command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您查看jcstress可用的其他命令行选项。这些信息可以通过运行以下命令获取：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: jcstress has its own page at [http://openjdk.java.net/](http://openjdk.java.net/),
    which has some very useful information and links to the source and mailing list
    at [http://openjdk.java.net/projects/code-tools/jcstress/](http://openjdk.java.net/projects/code-tools/jcstress/).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: jcstress在[http://openjdk.java.net/](http://openjdk.java.net/)有自己的页面，那里有一些非常有用的信息和链接到源代码和邮件列表[http://openjdk.java.net/projects/code-tools/jcstress/](http://openjdk.java.net/projects/code-tools/jcstress/)。
- en: Writing tests for jcstress
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为jcstress编写测试
- en: The **Java Concurrency Stress test** is a wonderful tool that is used by JDK
    authors to ensure that their concurrent code works correctly with regards to concurrency.
    Concurrent code is hard to write and even harder to test. Most of their tests
    are probabilistic, require a lot of skill to write, and might take many days running
    time and the appropriate hardware to exhibit the fail behavior. Considering all
    this complexity, having a framework that can help with correct test execution
    is a big advantage. This recipe will go through the steps that are required to
    write your own tests for jcstress.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java并发压力测试**是一个非常好的工具，被JDK作者用来确保他们的并发代码在并发方面工作正确。编写并发代码很困难，测试起来更难。他们的大多数测试都是概率性的，需要很多技巧来编写，可能需要很多天的时间，以及适当的硬件来展示失败行为。考虑到所有这些复杂性，拥有一个可以帮助正确执行测试的框架是一个很大的优势。此配方将介绍编写自己jcstress测试所需的步骤。'
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, the only requirement is to have an environment that is
    capable of compiling and running jcstress (see the *Building and running jcstress*
    recipe).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循此配方，唯一的要求是拥有一个能够编译和运行jcstress的环境（请参阅 *构建和运行jcstress* 配方）。
- en: How to do it…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will lead you through the process of creating a test and
    running it using jcstress:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导您完成创建测试并使用jcstress运行测试的过程：
- en: 'To start, we will need a code to test. Let''s pick the problem which, arguably,
    is the most common cause of headaches in concurrency and is very easy to reproduce.
    Data race sounds like a good candidate. We will make a class called `CASValue`
    and implement it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个代码来测试。让我们选择一个，可以说是并发中最常见的头痛原因，并且很容易复现的问题。数据竞争听起来是一个很好的候选者。我们将创建一个名为
    `CASValue` 的类并实现它：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This class implements a single operation which is supposed to perform the compare-and-swap
    operation (see [http://en.wikipedia.org/wiki/Compare-and-swap](http://en.wikipedia.org/wiki/Compare-and-swap)).
    Without synchronization, it will not work correctly in a multithreaded environment
    and should fail the test that we will create in the next steps of this recipe.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类实现了一个单一的操作，该操作应该执行比较和交换操作（请参阅[http://en.wikipedia.org/wiki/Compare-and-swap](http://en.wikipedia.org/wiki/Compare-and-swap)）。在没有同步的情况下，它将无法在多线程环境中正确工作，并且应该会失败我们将在本配方的下一步中创建的测试。
- en: In the source root folder of jcstress, create the file, `tests-custom/src/main/java/org/openjdk/jcstress/tests/CASValue.java`,
    and put the source code of the `CASValue` class in it.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jcstress的源根文件夹中创建文件，`tests-custom/src/main/java/org/openjdk/jcstress/tests/CASValue.java`，并将`CASValue`类的源代码放入其中。
- en: 'Now it''s time to write a test to see whether our implementation is wrong.
    The test class will look like this:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写一个测试来看看我们的实现是否错误了。测试类看起来像这样：
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save this file in the same folder as `CASValue.java`, that is, in `tests-custom/src/main/java/org/openjdk/jcstress/tests/`,
    and give it the name, `CASValueTests.java`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件保存在与`CASValue.java`相同的文件夹中，即在`tests-custom/src/main/java/org/openjdk/jcstress/tests/`，并命名为`CASValueTests.java`。
- en: The `CASValueTests` class is the container class for other classes within the
    test. This is not strictly required, but it helps to keep the code clean. The
    `ValCas_ValCas` class, which is annotated with `@JCStressTest`, is the test case
    class that contains two actors—methods annotated with `@Actor`. These are the
    methods that will be run in parallel by the test framework.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CASValueTests` 类是测试中其他类的容器类。这并不是严格必要的，但它有助于保持代码整洁。被`@JCStressTest`注解的`ValCas_ValCas`类是包含两个演员（被`@Actor`注解的方法）的测试用例类。这些方法将由测试框架并行运行。'
- en: The subclass `S`, annotated with `@State`, is the state that was shared among
    the actors and, in this case, is the class under test. It extends our class, `CASValue`,
    and is created solely to avoid adding the `@State` annotation on `CASValue`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被注解为`@State`的子类`S`是在演员之间共享的状态，在这种情况下，是正在测试的类。它扩展了我们的类`CASValue`，并且仅为了避免在`CASValue`上添加`@State`注解而创建。
- en: The `@Outcome` annotations specify the outcomes of the test. The outcomes can
    be `ACCEPTABLE`, `FORBIDDEN`, `ACCEPTABLE_INTERESTING`, and `ACCEPTABLE_SPEC`.
    These are defined by the `expect` attribute. The `id` attribute provides the list
    of outcomes, whereas `desc` is just a description of the outcome. This test case
    specifies that, for our test, the only valid outcomes for the values in `LongResul2`
    are `5` and `2` and `1` and `10`, which are the only expected ones if CAS works
    as expected. Any other outcomes are forbidden and will cause the test case to
    fail, which is exactly what we want.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Outcome`注解指定了测试的结果。结果可以是`ACCEPTABLE`、`FORBIDDEN`、`ACCEPTABLE_INTERESTING`和`ACCEPTABLE_SPEC`。这些由`expect`属性定义。`id`属性提供了结果列表，而`desc`只是对结果的一个描述。此测试用例指定，对于我们的测试，`LongResul2`中的有效值只有`5`和`2`以及`1`和`10`，这是如果CAS按预期工作时的唯一预期结果。任何其他结果都是禁止的，并将导致测试用例失败，这正是我们想要的。'
- en: 'Now it''s time to compile the test. To do this, run the following command from
    the source root directory of jcstress:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是编译测试的时候了。为此，请从jcstress的源根目录运行以下命令：
- en: '[PRE38]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will just run the build for the `tests-custom` project, which will compile
    the classes that we have just created.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将仅运行`tests-custom`项目的构建，编译我们刚刚创建的类。
- en: 'The next step is to run our test and see if it works:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是运行我们的测试并查看它是否工作：
- en: '[PRE39]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `-t` parameter in this command specifies that we only want to run the tests
    that satisfy the `.*CASValueTests.*` regular expression.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令中的`-t`参数指定我们只想运行满足`.*CASValueTests.*`正则表达式的测试。
- en: 'As expected, the tests should fail, as the provided implementation does implement
    the CAS operation correctly. The output should have several test outcomes similar
    to this one:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，测试应该失败，因为提供的实现确实实现了CAS操作。输出应该有多个类似于以下结果的测试结果：
- en: '[PRE40]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It shows how many outputs of each outcome were observed. So far, the incorrect
    outcome `[5, 10]` is the leader with `7,609,449` occurrences. This shows that
    the test worked correctly and helped us to identify that we need to fix our implementation
    on the CAS class.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它显示了每种结果的输出数量。到目前为止，不正确的结果`[5, 10]`以`7,609,449`次出现率领先。这表明测试工作正确，并帮助我们确定我们需要修复CAS类的实现。
- en: 'Now let''s fix our class and run the test again. The easiest, though not the
    most efficient, way to fix the problem is to simply add the `synchronized` modifier
    to our CAS method:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们修复我们的类并再次运行测试。最简单但不是最有效的方法是简单地给我们的CAS方法添加`synchronized`修饰符：
- en: '[PRE41]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After changing the implementation, run the build again:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改实现后，再次运行构建：
- en: '[PRE42]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, rerun the test:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重新运行测试：
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, the test should not show any failures and report that the test runs were
    successful:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试不应该显示任何失败，并报告测试运行成功：
- en: '[PRE44]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows that the change in the implementation worked and the implementation
    is correct according to the test case.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明实现的更改是有效的，并且根据测试用例，实现是正确的。
- en: By following these steps, a developer can ensure that a concurrent code works
    as expected according to the specification, as long as the tests and test cases
    are implemented and defined correctly. However, keep in mind that concurrency
    is something that is hard to test, and an implementation that works on one hardware
    can easily fail on other hardware. It means that it is recommended to run these
    test on the widest possible range of configurations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，开发者可以确保并发代码根据规范按预期工作，只要测试和测试用例被正确实现和定义。然而，请注意，并发性是难以测试的，一个在一种硬件上工作的实现很容易在其他硬件上失败。这意味着建议在尽可能广泛的配置上运行这些测试。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: This framework is built and maintained by Aleksey Shipilëv who has his own blog
    and also delivers lectures in various conferences. We recommend that you visit
    his home page ([http://shipilev.net/](http://shipilev.net/)), watch his videos
    on YouTube (for example, [https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk)),
    and read some of his papers. This will help you to get tons of information on
    correct concurrency testing, concurrency in general, support for concurrency in
    Java, and other related topics.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架是由 Aleksey Shipilëv 构建和维护的，他有自己的博客，并在各种会议上发表演讲。我们建议您访问他的主页 ([http://shipilev.net/](http://shipilev.net/))，在
    YouTube 上观看他的视频（例如，[https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk))，并阅读一些他的论文。这将帮助您获得大量关于正确并发测试、一般并发、Java
    中的并发支持以及其他相关主题的信息。
- en: Creating a benchmark project using JMH
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JMH 创建基准项目
- en: Micro benchmarking itself is not an easy topic, and doing it correctly using
    languages like Java is a very difficult task. These difficulties arise from the
    way Java executes the code and the infrastructure required by JVM. Just as things
    like JIT and GC may affect the results of micro benchmarking heavily, to ensure
    that the result of each run is consistent and correct might not be an easy task
    to accomplish. To help with this problem, there are several frameworks that can
    help to ensure that the benchmark test runs properly. One of these frameworks
    is **Java Microbenchmark Harness** (**JMH**), which is a part of OpenJDK. This
    recipe will explain how developers can use this framework to benchmark his/her
    own code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试本身不是一个容易的主题，使用像 Java 这样的语言正确地进行它是一个非常困难的任务。这些困难源于 Java 执行代码的方式和 JVM 所需的基础设施。正如
    JIT 和 GC 可能会严重影响微基准测试的结果一样，确保每次运行的输出结果一致和正确可能不是一个容易完成的任务。为了帮助解决这个问题，有几个框架可以帮助确保基准测试运行正确。其中之一是
    **Java 微基准工具**（**JMH**），它是 OpenJDK 的一部分。这个食谱将解释开发者如何使用这个框架来对其自己的代码进行基准测试。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires a machine with an Internet connection, Maven, Java SDK,
    and your favorite IDE that has support for Maven projects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要一个具有互联网连接的机器、Maven、Java SDK以及支持 Maven 项目的你喜欢的 IDE。
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following steps will take you through the process of creating a benchmark
    project and writing the benchmark, which can be used to analyze the performance
    of the code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您创建基准项目并编写基准测试，这可以用来分析代码的性能：
- en: 'In the command line, run the following Maven command:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，运行以下 Maven 命令：
- en: '[PRE45]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After running this command, in the current directory, Maven will create a folder
    with the name, `mybenchmark`, which will have the skeleton of the project. If
    all goes well, the build should end with an output that is similar to the following:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令后，在当前目录下，Maven 将创建一个名为 `mybenchmark` 的文件夹，其中将包含项目的框架。如果一切顺利，构建应该以类似于以下内容的输出结束：
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, when the project is generated, we can start working with it and create
    our first microbenchmark test. Open the generated project file (`/home/user/openjdk/mybenchmark/pom.xml`)
    with your favorite IDE. Ensure that Maven is correctly configured and all dependencies
    are downloaded correctly. Notice that there is already a class created for the
    benchmark whose name is `org.benchmark.MyBenchmark`. At the beginning, all it
    has is a single method where we will later put the code we are going to test.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当项目生成后，我们可以开始使用它并创建我们的第一个微基准测试。使用您最喜欢的IDE打开生成的项目文件（`/home/user/openjdk/mybenchmark/pom.xml`）。确保Maven配置正确并且所有依赖项都已正确下载。请注意，已经为基准测试创建了一个名为`org.benchmark.MyBenchmark`的类。一开始，它只有一个方法，我们将在其中放置稍后要测试的代码。
- en: 'As an example, let''s test something that is relatively simple but has some
    room for improvement. A binary search is a good choice for this purpose. So, let''s
    draft a simple implementation and put it into the `org.benchmark.BinarySearch1`
    class as shown next:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为例子，让我们测试一些相对简单但仍有改进空间的东西。二分查找是这种目的的好选择。所以，让我们草拟一个简单的实现并将其放入`org.benchmark.BinarySearch1`类中，如下所示：
- en: '[PRE47]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is a very basic implementation, which will be fine for our experiment.
    If you are not familiar with binary search or where to get more information about
    this algorithm, visit the Wikipedia page at [http://en.wikipedia.org/wiki/Binary_search_algorithm](http://en.wikipedia.org/wiki/Binary_search_algorithm).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个非常基本的实现，对于我们的实验来说已经足够好了。如果您不熟悉二分查找或想了解更多关于这个算法的信息，请访问维基百科页面[http://en.wikipedia.org/wiki/Binary_search_algorithm](http://en.wikipedia.org/wiki/Binary_search_algorithm)。
- en: 'Now, when the first draft of the implementation is ready, we will create a
    microbenchmark for it. Put the following code into the `org.benchmark.MyBenchmark`
    class:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当实现的第一稿准备好后，我们将为它创建一个微基准测试。将以下代码放入`org.benchmark.MyBenchmark`类中：
- en: '[PRE48]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code requires some clarification. The `@State` annotation is required to
    tell JMH that this class contains some data that is used by the tests, and that
    data in the `Scope.Thread` scope means that it will not be shared between several
    threads.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码需要一些解释。`@State`注解是必需的，以告诉JMH这个类包含一些由测试使用的数据，并且`Scope.Thread`作用域中的数据意味着它不会在多个线程之间共享。
- en: The `@BenchmarkMode(Mode.AverageTime)` annotation says that what we want to
    measure is the average time required to execute our test, which, by default, measures
    throughput. The `@OutputTimeUnit(TimeUnit.MICROSECONDS)` annotation sets `timeunit`.
    We need to define it, as the default is in seconds, which is a very big scale
    for the benchmark.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@BenchmarkMode(Mode.AverageTime)`注解表示我们想要测量的是执行测试的平均时间，默认情况下，它测量吞吐量。`@OutputTimeUnit(TimeUnit.MICROSECONDS)`注解设置了`timeunit`。我们需要定义它，因为默认值是秒，这对于基准测试来说是一个非常大的尺度。'
- en: The setup method is annotated with the `@Setup` annotation, which means that
    it does some preparation for the tests and it will be called to initialize the
    data for the test. It is similar to the `@Before` annotation from JUnit. Keep
    in mind that this method is executed only once before running the test in the
    fork on JVM. It is not executed before each test method is called. This means
    that the same test method will work with the same data after each iteration.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置方法被`@Setup`注解标记，这意味着它为测试做一些准备工作，并且它将在初始化测试数据时被调用。它与JUnit中的`@Before`注解类似。请注意，这个方法只会在JVM分叉运行测试之前执行一次。它不会在每个测试方法被调用之前执行。这意味着相同的测试方法将在每次迭代后使用相同的数据。
- en: The actual test is in the method annotated with `@Benchmark` that executes the
    code that we are testing.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际的测试在带有`@Benchmark`注解的方法中，该方法执行我们要测试的代码。
- en: 'Now that everything is set up, run a test and find out how fast our code is.
    First, let''s build the project with our code and test it. To do this, go to the
    folder with the project and run the following command:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，运行一个测试来找出我们的代码有多快。首先，让我们用我们的代码构建项目并测试它。为此，转到项目文件夹并运行以下命令：
- en: '[PRE49]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, run the benchmark:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行基准测试：
- en: '[PRE50]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here `wi` defines the number of `warmup` iterations, `i` the number of test
    run iterations, `f` says how many JVM forks to use, and `jvmArgs` are the parameters
    for forked JVM.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`wi`定义了`warmup`迭代次数，`i`定义了测试运行迭代次数，`f`表示要使用的JVM分叉数量，而`jvmArgs`是分叉JVM的参数。
- en: 'The output for each of our test methods should look like this:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们每个测试方法的输出应该看起来像这样：
- en: '[PRE51]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The output shows the runs executed for each fork and the final result. Here
    we can see that, on average, our method takes `77.178` nanoseconds to run.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示了每个分叉执行的运行以及最终结果。在这里，我们可以看到，平均而言，我们的方法运行需要`77.178`纳秒。
- en: 'Now that we have the results, what to do with them? Generally, these results
    make sense only when they are compared with something else. Let''s try to make
    some changes to the code and see whether it helps our implementation of binary
    search to work faster. We can try to remove recursion and see how it''s going
    to work. Create another class with the name, `org.benchmark.BinarySearch2`, and
    put the following implementation there:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了结果，我们应该如何处理它们？通常，这些结果只有在与其他东西比较时才有意义。让我们尝试对代码进行一些修改，看看是否有助于我们的二分查找实现运行得更快。我们可以尝试移除递归并看看效果如何。创建另一个名为`org.benchmark.BinarySearch2`的类，并将以下实现放在那里：
- en: '[PRE52]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is the iterative implementation, which doesn't use recursive calls.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是迭代实现，它不使用递归调用。
- en: 'Now let''s update the benchmark class so that we can compare recursive and
    iterative implementations:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新基准测试类，以便我们可以比较递归和迭代实现：
- en: '[PRE53]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The difference between this benchmark and the previous version is that this
    uses the benchmarking groups that give us a simple comparison of our implementations.
    The `@State` annotation now has to have the `Group` scope, otherwise the tests
    will be using different data instances, which is not what we would want, as we
    want algorithms to work in exactly the same conditions.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上一个版本相比，这个基准测试使用的是提供我们实现简单比较的基准测试组。现在`@State`注解必须具有`Group`范围，否则测试将使用不同的数据实例，这不是我们想要的，因为我们希望算法在完全相同的条件下工作。
- en: 'Now, rebuild the project:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新构建项目：
- en: '[PRE54]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, run the test again:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次运行测试：
- en: '[PRE55]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is going to be slightly different from the previous one, because
    of the use of groups. The main difference in which we are interested is going
    to be at the end of the report:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将略不同于上一个，因为使用了分组。我们感兴趣的主要区别将在报告的末尾：
- en: '[PRE56]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What we can see here is that, for this particular configuration (which includes
    machine spec, version of JDK, OS, and so on), iterative implementation, which
    is implemented by the method, `testBinarySearch2()`, is on average faster than
    the recursive one, implemented by `testBinarySearch1()` (`54.141` < `79.717`).
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到的是，对于这个特定的配置（包括机器规格、JDK版本、操作系统等），通过`testBinarySearch2()`方法实现的迭代实现平均比通过`testBinarySearch1()`实现的递归实现更快（`54.141`
    < `79.717`）。
- en: After going through this recipe, you have learned how to run microbenchmark
    tests, how to interpret results, and how to compare the performance of different
    implementations. Ensure that you microbenchmark each hard task properly and remember
    that the results can vary significantly on different machines, JVM versions, and
    so on.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个菜谱后，你已经学会了如何运行微基准测试，如何解释结果，以及如何比较不同实现的性能。确保你正确地对每个困难任务进行微基准测试，并记住结果在不同机器、JVM版本等上可能会有很大差异。
- en: There's more…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'JMH is a flexible framework that provides flexibility to the way it can be
    used. For example, if someone wants to run tests via the main method, without
    using `benchmarks.jar`, this can be easily achieved. To do this, just add the
    following main method to `MyBenchmark` and run it:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: JMH是一个灵活的框架，它提供了使用方式的灵活性。例如，如果有人想通过主方法运行测试，而不使用`benchmarks.jar`，这可以很容易地实现。为此，只需将以下主方法添加到`MyBenchmark`中并运行它：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This example will give the same result as running the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将给出与运行以下命令相同的结果：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We also recommend that you download the source code (see the *Downloading source
    and compiling JHM* recipe). Have a look at the recipe and JavaDocs, as the JavaDocs
    are well written and explain a lot about the framework.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议你下载源代码（见*下载源代码和编译JHM*菜谱）。查看菜谱和JavaDocs，因为JavaDocs写得很好，解释了很多关于框架的内容。
- en: See also
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Similar to jcstress, this framework is also built and maintained by Aleksey
    Shipilëv who has his own blog and also delivers lectures in various conferences.
    We recommend you visit his home page ([http://shipilev.net/](http://shipilev.net/)),
    watch his videos on YouTube (for example, [https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk)),
    and read some of his papers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与 jcstress 类似，这个框架也是由 Aleksey Shipilëv 构建和维护的，他有自己的博客，并在各种会议上发表演讲。我们建议你访问他的主页
    ([http://shipilev.net/](http://shipilev.net/))，在 YouTube 上观看他的视频（例如，[https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk))，并阅读一些他的论文。
- en: Downloading the source and compiling JHM
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载源代码和编译 JHM
- en: Similar to all other OpenJDK tools and projects, there is an option to download
    the source of the JHM and build it yourself. This might be required if a framework
    requires customization and an extension fix. Luckily the process is very easy
    and straightforward.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他 OpenJDK 工具和项目类似，有一个选项可以下载 JHM 的源代码并自行构建。如果框架需要定制和扩展修复，可能需要这样做。幸运的是，这个过程非常简单直接。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires a machine with an Internet connection that is capable of
    running Mercurial and Maven. Basically, the requirements are the same as that
    for compiling and running `jcstress` (see the *Building and running jcstress*
    recipe).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要一个能够运行 Mercurial 和 Maven 的具有互联网连接的机器。基本上，要求与编译和运行 `jcstress` 的要求相同（参见 *构建和运行
    jcstress* 配方）。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps will lead you through the process of downloading the source
    code and building JHM:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导你通过下载源代码和构建 JHM 的过程：
- en: 'To start, let''s run the following command to download the source files:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们运行以下命令以下载源文件：
- en: '[PRE59]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This command will download the source files and put them into the `jmh` folder.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将下载源文件并将它们放入 `jmh` 文件夹。
- en: 'The next step is to build the source code. The build requires Maven to be installed
    on the machine. Change the current folder to `jmh` and run the following command:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是构建源代码。构建过程需要机器上安装 Maven。将当前文件夹更改为 `jmh` 并运行以下命令：
- en: '[PRE60]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This command should generate an output similar to the following:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令应生成类似于以下内容的输出：
- en: '[PRE61]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This means that the build was successful.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着构建已成功完成。
- en: 'Now, the final step is to change your benchmark project to use the version
    of JHM that was just built. Assuming the project references of the JHM version
    are by properties, just change the version of the JHM dependency in your project
    to `1.0-SNAPHOT`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后一步是将你的基准项目更改为使用刚刚构建的 JHM 版本。假设 JHM 版本的项目引用是通过属性进行的，只需将项目中 JHM 依赖的版本更改为
    `1.0-SNAPSHOT`：
- en: '[PRE62]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you run Maven with the `install` target, it will put the newly built version
    of the artefact in the local repository. In this case, the version is `1.0-SNAPSHOT`.
    When another project has dependency on that version, Maven will pick the version
    from the local repository and use it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `install` 目标运行 Maven 时，它将新构建的工件版本放入本地仓库。在这种情况下，版本是 `1.0-SNAPSHOT`。当其他项目对该版本有依赖时，Maven
    将从本地仓库选择该版本并使用它。
