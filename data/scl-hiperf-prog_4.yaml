- en: Chapter 4. Exploring the Collection API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。探索集合API
- en: In this chapter, we return to MVT in order to take on challenges that span multiple
    MVT teams. The market data team requires improved critical path order book performance
    to handle increased cancel request volume. The data science team wants better
    ad hoc data analysis tools to research trading strategies. Everyone has a problem
    that had to be solved yesterday. That's the start-up lifestyle!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回到MVT，以应对跨越多个MVT团队的多重挑战。市场数据团队需要改进关键路径订单簿性能以处理增加的取消请求量。数据科学团队希望有更好的临时数据分析工具来研究交易策略。每个人都面临一个昨天就必须解决的问题。这就是创业生活！
- en: 'We use the functional paradigm, our existing knowledge, and the Scala collections
    API to our advantage to solve these challenges. The power of the Scala language
    and its collections API allow you to approach problems in ways that you may not
    have thought possible before. As we work through these challenges and encounter
    new Scala collection usage, we detail collection implementation and tradeoffs
    to consider. We will consider the following collections in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用函数式范式、现有知识和Scala集合API的优势来解决这些挑战。Scala语言及其集合API的力量允许你以前未曾想到的方式处理问题。随着我们解决这些挑战并遇到新的Scala集合使用，我们将详细说明集合实现和需要考虑的权衡。在本章中，我们将考虑以下集合：
- en: List
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: List
- en: TreeMap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TreeMap
- en: Queue
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Queue
- en: Set
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set
- en: Vector
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vector
- en: Array
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Array
- en: High-throughput systems – improving the order book
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高吞吐量系统 - 提高订单簿性能
- en: In [Chapter 1](ch01.html "Chapter 1.  The Road to Performance"), *The Road to
    Performance*, you met MVT's head trader, Dave, under tense circumstances. The
    financial markets underwent a period of extreme volatility that exposed a weakness
    in the order book design. After speaking to Dave, you learned that in volatile
    markets, order volume is dominated by cancels because traders are reacting to
    quickly changing market conditions. Through order book benchmarking and profiling,
    you confirmed the suspicion that under high volume, cancel performance causes
    high order book response latency.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章。通往绩效之路")《通往绩效之路》中，你在紧张的情境下遇到了MVT的首席交易员Dave。金融市场经历了一段极端波动的时期，暴露了订单簿设计的弱点。在与Dave交谈后，你了解到在波动市场中，订单量主要由取消订单组成，因为交易员正在对快速变化的市场条件做出反应。通过订单簿基准测试和配置文件分析，你证实了在高成交量下，取消性能导致高订单簿响应延迟的怀疑。
- en: Although the market volatility that caused trading losses has passed, Dave recognizes
    the risk that future volatility poses for MVT's returns. Dave wants to invest
    engineering effort into making the order book more performant when cancelations
    frequently occur. By working with the data science team, Dave analyzed historical
    order book activity over a three month period and discovered interesting market
    characteristics. He shares with you that in the three months analyzed, on a per
    trading day basis, cancels comprised, on average, 70% of order book commands.
    The analysis also revealed that on the most volatile market days, cancel activity
    represents about 85% of order book activity. Known for his puns, Dave concludes
    with, "Now, you know everything I know. Like the order book, we are counting on
    you to execute!"
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管导致交易损失的波动市场已经过去，Dave认识到未来波动对MVT回报的风险。Dave希望投入工程力量，使订单簿在频繁取消时更具性能。通过与数据科学团队合作，Dave分析了三个月的订单簿历史活动，并发现了有趣的市场特征。他与你分享，在分析的三个月中，按每个交易日计算，取消订单平均占订单簿命令的70%。分析还显示，在波动最大的市场日，取消活动占订单簿活动的约85%。以他的双关语而闻名，Dave总结道：“现在，你知道了我所知道的一切。就像订单簿一样，我们依赖你来执行！”
- en: Understanding historical trade-offs – list implementation
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解历史权衡 - 列实现
- en: Excited to improve order book performance, your first step is to familiarize
    yourself with the order book implementation. As you open up the order book repository,
    you ping Gary, a fellow engineer who has prior order book development experience.
    As Gary knows the history of order book development, he tells you to check out
    `ListOrderBook`. "This was our first attempt at modeling the order book. I think
    you can learn from our design by seeing its first incarnation," he adds, "Once
    you understand the implementation, check out `QueueOrderBook`. That's the next
    version of the order book. You profiled an older iteration of this implementation
    when we had the volatility wave. Let me know if you have any questions!" After
    thanking him, you dig into the repository to find `ListOrderBook`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高订单簿的性能而感到兴奋，你的第一步是熟悉订单簿的实现。当你打开订单簿仓库时，你ping了Gary，一位有先前的订单簿开发经验的工程师。由于Gary了解订单簿开发的历史，他告诉你检查`ListOrderBook`。“这是我们第一次尝试建模订单簿。我认为你可以通过看到它的第一个版本来学习我们的设计，”他补充说，“一旦你理解了实现，检查`QueueOrderBook`。那是订单簿的下一个版本。我们在波动波期间对这个实现的老版本进行了分析。如果你有任何问题，请告诉我！”在感谢他之后，你深入到仓库中寻找`ListOrderBook`。
- en: 'The `ListOrderBook` class defines the following state to manage buys (bids)
    and sells (offers):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook`类定义以下状态来管理购买（出价）和销售（报价）：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To refresh our memory, here are definitions of `Price`, `BuyLimitOrder`, and `SellLimitOrder`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新我们的记忆，以下是`Price`、`BuyLimitOrder`和`SellLimitOrder`的定义：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `LimitOrder` is an **algebraic data type** (**ADT**) that represents the
    two possible order sides. The `Price` class is a strongly-typed wrapper for `BigDecimal`.
    Recalling the performance boost that value classes provide, you modify the definition
    of `Price`, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimitOrder`是一种**代数数据类型**（**ADT**），它表示两种可能的订单方向。`Price`类是`BigDecimal`的强类型包装。回忆一下值类提供的性能提升，你修改了`Price`的定义，如下所示：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ListOrderBook` class uses two Scala collection types to maintain its state: `List`
    and `TreeMap`. Let's have a deeper look at these data structures to understand
    the tradeoffs that they present.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook`类使用两种Scala集合类型来维护其状态：`List`和`TreeMap`。让我们更深入地了解这些数据结构，以了解它们所呈现的权衡。'
- en: List
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Scala implements `List` as an immutable singly-linked list. A `List` is an
    ordered collection of elements of the same type. A `List` is a sealed abstract
    class with two implementations: `Nil`, which represents the empty list, and `::`
    (often called cons), which is used to represent an element and a tail. To make
    things more concrete, let''s look at some pseudocode, which is close to the actual
    implementation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Scala将`List`实现为一个不可变的单链表。`List`是相同类型元素的有序集合。`List`是一个密封的抽象类，有两个实现：`Nil`，表示空列表，以及`::`（通常称为cons），用于表示一个元素和尾部。为了使事情更加具体，让我们看看一些伪代码，它接近实际的实现：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A `List` of three integers can be constructed using the following notation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下记法构造包含三个整数的`List`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note the plus sign in the definition of the `List` trait. The plus (`+`) sign
    indicates that `List` is covariant on its type parameter, `A`. Covariance allows
    you to express polymorphic constraints with generic types. To make this more concrete,
    consider the following definitions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`List`特质定义中的加号。加号（`+`）表示`List`在其类型参数`A`上是一致的。一致性允许你使用泛型类型表达多态约束。为了使这一点更加具体，请考虑以下定义：
- en: '`sealed trait Base`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed trait Base`'
- en: '`case class Impl(value: Int) extends Base`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`case class Impl(value: Int) extends Base`'
- en: 'Here, a relationship is expressed between `Base` and `Impl`. The `Impl` class
    is a subtype of `Base`. When used with `List`, covariance allows us to express
    that `List[Impl]` is a subtype of `List[Base]`. Expressed with an example, covariance
    is what allows the following snippet to compile:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Base`和`Impl`之间存在一种关系。`Impl`类是`Base`的子类型。当与`List`一起使用时，一致性允许我们表达`List[Impl]`是`List[Base]`的子类型。用示例表达，一致性是以下代码片段能够编译的原因：
- en: '`val bases: List[Base] = List[Impl](Impl(1))`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`val bases: List[Base] = List[Impl](Impl(1))`'
- en: Covariance belongs to the broader topic of variances. If you wish to learn more
    about variances in Scala, refer to this excellent blog post by Andreas Schroeder
    at [https://blog.codecentric.de/en/2015/03/scala-type-system-parameterized-types-variances-part-1/](https://blog.codecentric.de/en/2015/03/scala-type-system-parameterized-types-variances-part-1/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性属于更广泛的话题——变异性。如果你想要了解更多关于Scala中变异性的信息，请参考Andreas Schroeder在[https://blog.codecentric.de/en/2015/03/scala-type-system-parameterized-types-variances-part-1/](https://blog.codecentric.de/en/2015/03/scala-type-system-parameterized-types-variances-part-1/)上的这篇优秀的博客文章。
- en: 'Unlike most other Scala collections, `List` supports pattern matching on its
    content. This is a powerful way to write expressive code that handles multiple
    scenarios while retaining compile-time safety that all possible cases are handled.
    Consider the following snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与Scala中的大多数其他集合不同，`List`支持对其内容的模式匹配。这是一种编写表达性代码的强大方式，可以处理多个场景，同时保持编译时安全性，即处理所有可能的案例。考虑以下片段：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this simple pattern match, we are able to express several concerns. Here,
    `1` is `1`, `x` is `2`, and `rest` is `List(3,4)`. When compiled, this snippet
    elicits a compiler warning because the Scala compiler infers that there are possible `List`
    patterns that were unmatched (for example, empty `List`). Compiler-provided warnings
    minimize the chance of your forgetting to handle a valid input.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的模式匹配中，我们能够表达几个关注点。在这里，`1`是`1`，`x`是`2`，而`rest`是`List(3,4)`。当编译时，这个片段会引发编译器警告，因为Scala编译器推断出存在可能的未匹配的`List`模式（例如，空的`List`）。编译器提供的警告最小化了你忘记处理有效输入的机会。
- en: 'A `List` is optimized for prepend operations. Adding 0 to the previous list
    is as easy as doing this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`针对预添加操作进行了优化。将0添加到上一个列表就像这样做一样简单：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a constant-time operation, and it has almost no memory cost, as `List`
    implements data sharing. In other words, the new list, `listWithZero`, is not
    a deep copy of `list`. Instead, it re-uses all its allocated elements and allocates
    only one new element, the cell containing `0`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常数时间操作，并且由于`List`实现了数据共享，所以几乎没有内存开销。换句话说，新的列表`listWithZero`不是`list`的深拷贝，而是重新使用所有已分配的元素，并只分配一个新元素，即包含`0`的单元格：
- en: '![List](img/image_04_001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![List](img/image_04_001.jpg)'
- en: 'In contrast to prepend operations, append operations (that is, adding an element
    to the end of the list) are computationally expensive because the entire `List`
    must be copied:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与预添加操作相比，追加操作（即在列表末尾添加一个元素）在计算上很昂贵，因为必须复制整个`List`：
- en: '![List](img/image_04_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![List](img/image_04_002.jpg)'
- en: Given the poor append performance of List, you may wonder whether it is safe
    to use a `map` transform. A `map` transform occurs by applying a function to successive
    elements in the `List`, which can be logically represented by appending transformed
    values to a new `List`. To avoid this performance pitfall, `List.map` overrides
    the default implementation provided by the trait `TraversableOnce` to apply the
    transform using prepend operations. This provides improved `List.map` performance
    while retaining the same API. Overriding default behavior to provide a specialized
    implementation is a common Scala collections pattern. Constant time head operations
    make `List` ideal for algorithms involving last-in, first-out (LIFO) operations.
    For random access and first-in, first-out (FIFO) behaviors, you should employ `List`
    selectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`List`的追加性能较差，你可能想知道是否安全地使用`map`转换。`map`转换是通过将函数应用于`List`中的连续元素来发生的，这可以通过将转换后的值追加到新的`List`中在逻辑上表示。为了避免这种性能陷阱，`List.map`覆盖了由`TraversableOnce`特质提供的默认实现，使用预添加操作来应用转换。这提供了改进的`List.map`性能，同时保留了相同的API。覆盖默认行为以提供专用实现是Scala集合模式中的常见做法。常数时间头部操作使`List`非常适合涉及后进先出（LIFO）操作的算法。对于随机访问和先进先出（FIFO）行为，你应该有选择地使用`List`。
- en: In the next section, we investigate `TreeMap`. The `TreeMap` class is the implementation
    of the `SortedMap` trait that is used to maintain bids and offers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究`TreeMap`。`TreeMap`类是`SortedMap`特质的实现，用于维护出价和报价。
- en: TreeMap
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TreeMap
- en: 'The `TreeMap` class is a map that orders keys according to a provided ordering
    strategy. The following snippet of its class definition makes the ordering requirement
    clear:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap`类是一个根据提供的排序策略对键进行排序的映射。其类定义的以下片段清楚地说明了排序要求：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Ordering` class is a type class that defines a contract for the natural
    ordering of elements of the `A` type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ordering`类是一个类型类，它定义了`A`类型元素的天然排序契约。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If type classes are a concept that is new to you, we encourage you to read Daniel
    Westheide's well-written blog post on the topic at [http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html](http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型类对你来说是一个新概念，我们鼓励你阅读Daniel Westheide关于此主题的出色博客文章，链接为[http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html](http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html)。
- en: 'In `ListOrderBook`, we see that `Price` is the key. Looking at the companion
    object of `Price`, we see that the ordering is defined by delegating to the underlying
    `BigDecimal` type''s ordering definition:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListOrderBook`中，我们看到`Price`是关键。查看`Price`的伴随对象，我们看到排序是通过委托给底层`BigDecimal`类型的排序定义来实现的：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `TreeMap `class referenced by `ListOrderBook`, like `List`, is immutable.
    Immutability provides strong reasoning guarantees. We can be certain that there
    are no side effects because the effect of adding or removing a value from the
    map is always reflected as a new map.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook`中引用的`TreeMap`类，就像`List`一样，是不可变的。不可变性提供了强大的推理保证。我们可以确信没有副作用，因为从映射中添加或删除值的效应总是反映为一个新的映射。'
- en: The `TreeMap` class implementation is a special type of binary search tree,
    the red-black tree. This tree implementation provides logarithmic operation time
    for lookups, additions, and removals. You might be surprised to see `TreeMap`
    in place of `HashMap`. As documented in the Scala collections performance overview
    ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)), `HashMap`
    provides constant time lookups, additions, and removals, which is faster than `TreeMap`.
    However, `TreeMap` offers superior performance when performing ordered traversals.
    For example, finding the largest key in the map can be done in logarithmic time
    with `TreeMap`, while this is done in linear time for `HashMap`. This difference
    is an indicator that the order book implementation requires efficient ordered `Price`
    traversals.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap`类实现是一种特殊的二叉搜索树，即红黑树。这种树实现提供了查找、添加和删除的对数时间操作。你可能惊讶地看到`TreeMap`代替了`HashMap`。如Scala集合性能概述文档所述（[http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)），`HashMap`提供常数时间的查找、添加和删除，这比`TreeMap`更快。然而，`TreeMap`在执行有序遍历时提供了更好的性能。例如，在`TreeMap`中，可以在对数时间内找到映射中的最大键，而在`HashMap`中则需要线性时间。这种差异表明订单簿实现需要高效的有序`Price`遍历。'
- en: Adding limit orders
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加限价订单
- en: 'Coming back to the `ListOrderBook` implementation, we see the following partial
    method definition reflects the heart of the order book:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ListOrderBook`的实现，我们看到以下部分方法定义反映了订单簿的核心：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It might seem curious that a function is supplied as an argument to retrieve
    the current time. A potentially simpler way to achieve the same effect is to invoke
    `System.currentTimeMillis()`. The shortcoming of this approach is that accessing
    the system clock is a side-effect, which means that the function is no longer
    referentially transparent. By providing a function to retrieve the current time,
    we are able to control how this side-effect happens and produce repeatable test
    cases.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人觉得奇怪，一个函数被作为参数提供以检索当前时间。实现相同效果的一个可能更简单的方法是调用`System.currentTimeMillis()`。这种方法的不利之处在于访问系统时钟是一个副作用，这意味着函数不再是引用透明的。通过提供一个函数来检索当前时间，我们能够控制这种副作用的发生，并产生可重复的测试用例。
- en: 'Given a `Command`, an order book instance, and a way to obtain the current
    time for event timestamps, an `Event` and a new state are produced. To refresh
    our memory, here are the commands the order book can process:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`Command`、一个订单簿实例以及获取事件时间戳当前时间的方法，将产生一个`Event`和一个新状态。为了刷新我们的记忆，以下是订单簿可以处理的命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following are the possible events created by processing commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过处理命令可能创建的事件：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s focus on supporting the `AddLimitOrder` command to better understand
    the algorithmic properties of historical design choices. When adding a limit order,
    one of two outcomes is possible:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于支持`AddLimitOrder`命令，以更好地理解历史设计选择算法的特性。当添加限价订单时，可能出现两种结果之一：
- en: The incoming order price crosses the book resulting in `OrderExecuted`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入的订单价格跨越订单簿，导致`OrderExecuted`
- en: The oncoming order rests on the book resulting in `LimitOrderAdded`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即将到来的订单基于产生`LimitOrderAdded`的书籍
- en: 'Deducing whether or not the order crosses the book requires looking at the
    best price on the opposing side. Returning to the definition of `LimitOrderBook`
    with complete implementation of `bestBid` and `bestOffer`, we see the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 判断订单是否跨越订单簿需要查看对立方的最佳价格。回到`LimitOrderBook`的定义，并完全实现`bestBid`和`bestOffer`，我们看到以下内容：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The implementation shows that we are taking advantage of the logarithmic ordered
    search property of `TreeMap`. The best bid is the key with the highest price,
    which is the last value in the tree because the ordering is ascending. The best
    offer is the key with the lowest price, which is the first value in the tree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现显示我们正在利用`TreeMap`的对数有序搜索属性。最佳买入价是具有最高价格的键，它是树中的最后一个值，因为排序是升序的。最佳卖出价是具有最低价格的键，它是树中的第一个值。
- en: 'Focusing specifically on the addition of a buy limit order and given the best
    offer, the following comparison occurs to determine whether the incoming buy order
    crosses the book or rests on the book:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于买入限价订单的添加以及最佳出价，以下比较发生以确定即将到来的买入订单是穿过订单簿还是停留在订单簿上：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s first assume that the incoming buy order''s price is lower than the
    best offer, which means the order is added to the book (that is, rests on the
    book). The question we are trying to answer is, "where in the book should the
    order be added?" The order book performs a logarithmic search to find the price
    level associated with the order price. From the definition of `ListOrderBook`,
    you know that each value in the map (the price level) is represented as a `List`
    of orders. Recalling a discussion with the head trader, Dave, you remember that
    orders within a price level are executed based on time priority. The first order
    added to a price level is the first order to be executed. Conceptually, a price
    level is a first-in, first-out (FIFO) queue. The implication is that adding an
    order to a price level is a linear time operation because the order is appended
    to the end. The following snippet confirms your hypothesis:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先假设即将到来的买入订单的价格低于最佳出价，这意味着订单被添加到订单簿中（即停留在订单簿上）。我们试图回答的问题是，“订单应该添加到订单簿的哪个位置？”订单簿执行对数搜索以找到与订单价格相关的价格水平。根据`ListOrderBook`的定义，你知道映射中的每个值（价格水平）都表示为一个订单的`List`。回忆与首席交易员Dave的讨论，你记得在同一价格水平内的订单是按照时间优先级执行的。首先添加到价格水平的订单是首先被执行的。从概念上讲，价格水平是一个先进先出（FIFO）队列。这意味着向价格水平添加订单是一个线性时间操作，因为订单被追加到末尾。下面的摘要是确认你的假设：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The snippet shows that adding a resting limit order to the book involves a linear
    time append operation to `List` of `BuyLimitOrder`. In your mind, you are beginning
    to wonder how MVT was able to trade profitably at all with this order book. Before
    leaping to this harsh judgment, you consider how crossing the book is handled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要显示，向订单簿中添加一个休息限价订单涉及到对`BuyLimitOrder`的`List`进行线性时间追加操作。在你的脑海中，你开始怀疑MVT如何能够利用这个订单簿进行有利可图的交易。在做出这样的严厉判断之前，你考虑了如何处理订单簿的交叉。
- en: 'Assuming that the incoming buy order''s price is greater than or equal to the
    best offer price, then the buy order crosses the book, causing an execution. Time
    priority dictates that the first sell order received is executed against the incoming
    buy order, which translates to taking the first sell order in the price level.
    When generating an execution, you realize that modeling a price level with a `List`
    provides constant time performance. The following snippet shows how a price level
    is modified on a buy execution:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设即将到来的买入订单的价格大于或等于最佳出价，那么买入订单将穿过订单簿，导致执行。时间优先级规定，首先收到的卖出订单将与即将到来的买入订单执行，这相当于取价格水平中的第一个卖出订单。在生成执行时，你意识到使用`List`来模拟价格水平提供了常数时间性能。以下摘要是如何修改买入执行中的价格水平的：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ListOrderBook` takes advantage of the `List` pattern matching to handle
    the two possible cross scenarios:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook`利用`List`模式匹配来处理两种可能的交叉场景：'
- en: The executed sell order is the only order available in the price level
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的卖出订单是该价格水平中唯一可用的订单
- en: Additional sell orders remain at the price level
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的卖出订单仍然停留在价格水平
- en: In the former scenario, the price level is removed from the book by removing
    the key from the offers `TreeMap`. In the latter scenario, the remaining orders
    form the new price level. Clearly, the order book is optimized for executions
    over adding resting orders. You wonder why this bias exists in the order book
    implementation. You wonder to yourself, "perhaps, executions are more much more
    prevalent than resting orders?" You are unsure and make a mental note to chat
    with Dave.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，通过从 `offers` `TreeMap` 中移除键来从订单簿中删除价格层级。在后一种情况下，剩余的订单形成新的价格层级。显然，订单簿是针对执行操作而不是添加挂起订单进行优化的。你想知道为什么订单簿实现中存在这种偏见。你自问，“也许，执行操作比挂起订单更普遍？”你不确定，并在心里记下要和
    Dave 聊聊。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pause for a moment to consider biases in systems that you have designed. Did
    you optimize operations proportional to usage or latency constraints? Looking
    back, did your design choices lead you towards the best possible performance for
    the most important operations? Of course, hindsight makes it easy to call out
    suboptimal design choices. By reflecting on how you made these choices, you might
    be better able to avoid similar deficiencies in future systems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下，考虑一下你设计的系统中存在的偏见。你是否优化了与使用量或延迟约束成比例的操作？回顾过去，你的设计选择是否使你朝着最重要的操作的最佳性能迈进？当然，事后诸葛亮很容易指出次优的设计选择。通过反思你如何做出这些选择，你可能能够更好地避免未来系统中类似的缺陷。
- en: Canceling orders
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消订单
- en: The `ListOrderBook` also supports the `CancelOrder` command to remove an existing
    order by ID. Cancel requests pose an algorithmic challenge to `ListOrderBook`.
    As only the order ID is provided, `ListOrderBook` cannot efficiently determine
    which side the order rests on (that is, buy or sell). To determine the side, the
    buy and sell price levels are swept to find the order ID. This is an operation
    that is proportional to the number of price levels per side and the length of
    each price level. The worst case scenario is submitting an order ID that does
    not exist in the order book. The entire book must be swept to identify the absence
    of the provided order ID. A malicious trader could slow down MVT order book operations
    by submitting a constant stream of nonexistent order IDs. You make a note to talk
    with Dave about malicious trading activities and what MVT can do to defend against
    them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook` 也支持使用 `CancelOrder` 命令通过 ID 删除现有订单。取消请求对 `ListOrderBook` 构成了算法挑战。因为只提供了订单
    ID，`ListOrderBook` 无法高效地确定订单位于哪一侧（即买入或卖出）。为了确定侧边，需要遍历买入和卖出的价格层级以找到订单 ID。这是一个与每侧价格层级数量和每个价格层级的长度成比例的操作。最坏的情况是提交一个在订单簿中不存在的订单
    ID。整个订单簿必须被遍历以识别提供的订单 ID 是否缺失。恶意交易者可以通过提交一系列不存在的订单 ID 来减缓 MVT 订单簿的操作。你记下笔记，打算和
    Dave 谈谈恶意交易活动以及 MVT 可以如何防御这些活动。'
- en: 'Assuming that the order referenced by the cancel request exists in the book
    and its price level is discovered, the act of removing the cancelled order from
    the book is also expensive. Canceling is a linear time operation that requires
    traversing the linked list of orders and removing the node with the matching order
    ID. The following snippet implements canceling a sell order in `ListOrderBook`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设取消请求中引用的订单存在于订单簿中，并且其价格层级已被发现，从订单簿中移除已取消订单的操作也是昂贵的。取消是一个线性时间操作，需要遍历订单的链表并移除匹配订单
    ID 的节点。以下代码片段实现了在 `ListOrderBook` 中取消卖出订单：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Studying this snippet, it is unsurprising to you that cancelation performance
    is the least performant order book operation. There are two linear time passes
    performed per price level to cancel the order. First, `exists` traverses the list
    of price level orders to determine whether the ID to be canceled exists in the
    price level. Once the price level containing the ID is found, there is a second
    traversal via `filter` to update the state of the order book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 研究这个代码片段，取消性能是最低效的订单簿操作，这并不让你感到惊讶。取消订单需要在每个价格层级上执行两次线性时间遍历。首先，`exists` 遍历价格层级订单列表以确定要取消的
    ID 是否存在于价格层级中。一旦找到包含该 ID 的价格层级，就会通过 `filter` 执行第二次遍历来更新订单簿的状态。
- en: The cancelation implementation in `ListOrderBook` is an illustration of the
    double-edged sword of Scala's expressive collection API. By virtue of being expressive,
    the cancelation logic is simple to understand and to maintain. However, its expressiveness
    also makes it easy to hide that the runtime performance of removing an order from
    a price level is *2 * N*, where *N* is the number of orders in a price level.
    This simple example makes it clear that in a performance-sensitive environment,
    it is important to take a step back from the code to consider the runtime overhead
    of the data structure that is being used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOrderBook`中的取消实现是Scala表达式集合API双刃剑的例证。由于表达能力强，取消逻辑简单易懂且易于维护。然而，其表达性也使得它容易隐藏从价格层级中删除订单的运行时间是*2
    * N*，其中*N*是价格层级中的订单数量。这个简单的例子清楚地表明，在性能敏感的环境中，从代码中退一步考虑所使用数据结构的运行时开销是很重要的。'
- en: The current order book – queue implementation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前订单簿 – 队列实现
- en: 'You refrain from judging `ListOrderBook` too harshly because you know from
    your prior software development experiences that there were likely extenuating
    circumstances that led to this implementation. You turn your attention to the
    current order book implementation, which is in `QueueOrderBook`. Looking over
    the source code, you are surprised to discover the implementation appears to match `ListOrderBook`
    except for the price level data structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会对`ListOrderBook`过于苛刻，因为你从先前的软件开发经验中知道，可能存在导致这种实现的特殊情况。你将注意力转向当前的订单簿实现，它在`QueueOrderBook`中。查看源代码后，你惊讶地发现实现看起来与`ListOrderBook`相似，只是价格层级的数据结构不同：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only difference between the two implementations is the use of `scala.collection.immutable.Queue`
    in place of `List` to represent a price level. From a modeling perspective, using
    a FIFO queue makes sense. As time priority dictates execution order, a FIFO queue
    is a natural fit to store resting orders. You begin wondering whether switching
    out `List` for `Queue` was done purely for modeling purposes. The question on
    your mind is, "how does replacing `List` with `Queue` improve order book performance?"
    Understanding this change requires digging deeper into Scala's `Queue` implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实现之间的唯一区别是将`List`替换为`scala.collection.immutable.Queue`来表示价格层级。从建模的角度来看，使用FIFO队列是有意义的。因为时间优先级决定了执行顺序，所以FIFO队列是存储挂起订单的自然选择。你开始怀疑是否将`List`替换为`Queue`仅仅是为了建模目的。你心中的问题是，“用`Queue`替换`List`是如何提高订单簿性能的？”理解这个变化需要更深入地挖掘Scala的`Queue`实现。
- en: Queue
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: 'This snippet of a `Queue` definition reveals an interesting insight:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Queue`定义的代码片段揭示了一个有趣的见解：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Without reading deeply into the `Queue` implementation, we see that it uses
    two `Lists` to manage state. Given the usage of `List` to model a FIFO queue in `ListOrderBook`,
    it should not be surprising to see the usage of `List` to build an immutable FIFO
    queue data structure. Let''s look at the enqueue and dequeue operations to understand
    how in and out impact `Queue` performance. The following snippet shows the implementation
    of enqueue:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有深入阅读`Queue`实现之前，我们看到它使用两个`Lists`来管理状态。鉴于在`ListOrderBook`中使用`List`来模拟FIFO队列，使用`List`来构建不可变的FIFO队列数据结构并不令人惊讶。让我们看看入队和出队操作，以了解进出如何影响`Queue`性能。以下代码片段显示了入队实现的示例：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As the element is prepended to `in`, enqueueing is a constant time operation.
    Recall that the analogous `ListOrderBook` operation is adding a resting order,
    which has linear runtime performance. This is a clear performance win for `QueueOrderBook`.
    Next, we consider dequeue implementation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素被添加到`in`中时，入队操作是常数时间操作。回想一下，类似的`ListOrderBook`操作是添加一个挂起订单，其运行时间性能是线性的。这是`QueueOrderBook`的一个明显的性能优势。接下来，我们考虑出队实现：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As the implementation shows, dequeue throws an exception when invoked with an
    empty `Queue`. The exception is an unexpected outcome to invoking `dequeue` and
    feels out of place in the functional programming paradigm. For this reason, `Queue`
    also provides `dequeueOption` that returns an `Option`. This makes the handling
    of an empty `Queue` explicit and easier to reason about. We recommend using `dequeueOption`
    in any situation where you cannot guarantee that `dequeue` will always be called
    on a nonempty `Queue`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如实现所示，当使用空的`Queue`调用`dequeue`时，会抛出异常。这个异常是调用`dequeue`时的一个意外结果，在函数式编程范式中感觉不合适。因此，`Queue`还提供了`dequeueOption`，它返回一个`Option`。这使得处理空的`Queue`变得明确且更容易推理。我们建议在无法保证`dequeue`始终在非空`Queue`上调用的情况下使用`dequeueOption`。
- en: 'The `dequeue` operation is more involved than `enqueue` due to the interaction
    between `in` and `out`. To understand how the `Queue` state is managed with the `dequeue`
    operations, review the following table. This table walks through a series of the `enqueue`
    and `dequeue` operations, listing the state of `in` and `out` at each step. As
    you review the table, consider which  `dequeue` patterns match statements that
    are invoked:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作比`enqueue`操作更复杂，因为它是由于`in`和`out`之间的交互。为了理解`Queue`状态是如何通过`dequeue`操作管理的，请查看以下表格。该表格通过一系列的`enqueue`和`dequeue`操作，列出了每个步骤的`in`和`out`状态。在查看表格时，考虑哪些`dequeue`模式与调用的语句相匹配：'
- en: '| **Operation** | **In** | **Out** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **Operation** | **In** | **Out** |'
- en: '| enqueue(1) | List(1) | Nil |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| enqueue(1) | List(1) | Nil |'
- en: '| enqueue(2) | List(1, 2) | Nil |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| enqueue(2) | List(1, 2) | Nil |'
- en: '| enqueue(3) | List(1, 2, 3) | Nil |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| enqueue(3) | List(1, 2, 3) | Nil |'
- en: '| dequeue | Nil | List(2, 3) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| dequeue | Nil | List(2, 3) |'
- en: '| dequeue | Nil | List(3) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| dequeue | Nil | List(3) |'
- en: '| enqueue(4) | List(4) | List(3) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| enqueue(4) | List(4) | List(3) |'
- en: '| dequeue | List(4) | Nil |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| dequeue | List(4) | Nil |'
- en: '| dequeue | Nil | Nil |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| dequeue | Nil | Nil |'
- en: As the `enqueue` and `dequeue` invocations are intermingled, both `in` and `out`
    retain state. In the final sequence displayed, the queue returns to its initial
    state (that is, both `in` and `out` empty). The key insight from this implementation
    is that `Queue` amortizes the cost of `dequeue` to be constant time by deferring
    transfers from `in` and `out`. Each element transfer from `in` and `out` is a
    linear time `reverse` operation to maintain first-in, first-out ordering. Deferring
    the cost of this expensive operation until `out` is empty is a form of lazy evaluation.
    This is an illustrative example of how lazy evaluation can be used to improve
    runtime performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`enqueue`和`dequeue`调用是交织在一起的，`in`和`out`都保留了状态。在显示的最后序列中，队列返回到其初始状态（即，`in`和`out`都为空）。从这个实现的关键洞察是，通过推迟从`in`和`out`的转移，`Queue`将`dequeue`的成本摊销为常数时间。从`in`和`out`到每个元素的转移是一个线性时间的`reverse`操作，以维护先进先出排序。将这种昂贵的操作的成本推迟到`out`为空，是一种惰性评估的形式。这是一个说明如何使用惰性评估来提高运行时性能的示例。
- en: 'Now that you have an understanding of how `Queue` is implemented, you can reason
    about the performance improvements delivered by `QueueOrderBook`. The following
    table itemizes the runtime performance of each scenario to modify a price level:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`Queue`的实现方式，你可以推理出`QueueOrderBook`带来的性能提升。下表列出了每个场景修改价格级别的运行时性能：
- en: '| **Scenario** | **ListOrderBook** | **QueueOrderBook** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **Scenario** | **ListOrderBook** | **QueueOrderBook** |'
- en: '| Add resting limit order | Linear | Constant |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Add resting limit order | Linear | Constant |'
- en: '| Generate execution | Constant | Amortized constant |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Generate execution | Constant | Amortized constant |'
- en: '| Cancel order | Linear | Linear |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Cancel order | Linear | Linear |'
- en: This table illustrates how understanding the runtime characteristics of the
    Scala collection API can result in tangible performance wins with small changes
    to your implementation. Recall that when `QueueOrderBook` was introduced, it was
    noted that its implementation is identical to `ListOrderBook`, the module changes
    to replace `List` operations with analogous `Queue` operations. This is a comparatively
    simple change for the performance boost shown previously.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格说明了如何通过理解Scala集合API的运行时特性，通过对你实现的小幅改动，可以带来实际的性能提升。回想一下，当`QueueOrderBook`被引入时，它的实现与`ListOrderBook`相同，该模块的改变是将`List`操作替换为类似的`Queue`操作。这是之前展示的性能提升的一个相对简单的改动。
- en: You are excited to see the performance win to handle limit orders with `QueueOrderBook`,
    but you are left wondering about what can be done about cancelation performance.
    It remains unsettling to you that `QueueOrderBook` retains the same cancelation
    performance. In particular, because of the recent market volatility that exposed
    order book cancelation performance's weakness that caused MVT to trade unprofitably.
    Lazy evaluation was a big performance win to handle limit orders. Can this principle
    also be applied to cancel requests?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你很高兴看到`QueueOrderBook`在处理限价订单时的性能提升，但你仍然在思考如何提高取消订单的性能。`QueueOrderBook`保持相同的取消性能让你感到不安。特别是，由于最近市场波动暴露了订单簿取消性能的弱点，导致MVT交易无利可图。延迟评估是处理限价订单的一个大性能提升。这个原则是否也可以应用于取消请求？
- en: Improved cancellation performance through lazy evaluation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过延迟评估提高取消性能
- en: 'Queue provides high-performance `enqueue` and `dequeue` operations using the
    additional state, the second `List`, to defer and to batch expensive operations.
    This principle can be applied to the order book. When canceling an order, there
    are two expensive operations:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`使用额外的状态，即第二个`List`，提供高性能的`enqueue`和`dequeue`操作，以延迟和批量处理昂贵的操作。这个原则可以应用于订单簿。在取消订单时，有两个昂贵的操作：'
- en: Identifying the price level containing the order-to-be-canceled
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别包含待取消订单的价格水平
- en: Traversing a `Queue` or `List` to remove the canceled order
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历`Queue`或`List`以移除已取消的订单
- en: 'Focusing on the second operation, the motivating question is, "how can the
    order book defer the cost of linear traversal to modify internal state?" To answer
    this question, it is often helpful to consider the strengths of your implementation.
    With either order book implementation, we know there is excellent execution performance.
    One strategy that takes advantage of this insight is to defer cancellation until
    order execution occurs. The approach is to use additional state to maintain the
    intent to cancel without removing the order from order book state until it is
    performant to do so. This approach could look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于第二个操作，激发的问题是，“订单簿如何将线性遍历的成本延迟到修改内部状态？”为了回答这个问题，考虑你实现的优势通常是有帮助的。无论是哪种订单簿实现，我们都知道有出色的执行性能。利用这一洞察力的一种策略是延迟取消直到订单执行。方法是使用额外的状态来维持取消意图，而不从订单簿状态中移除订单，直到这样做是高效的。这种方法可能看起来如下：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `LazyCancelOrderBook` class adds additional state in the form of a `scala.collection.immutable.Set`
    to manage the IDs of canceled requests that have not been reflected into the the
    state of `bids` and `offers`. Before diving into how `pendingCancelIds` is used,
    let's investigate the Scala implementation of `Set`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyCancelOrderBook`类通过添加一个`scala.collection.immutable.Set`形式的额外状态来管理尚未反映到`bids`和`offers`状态中的已取消请求的ID。在深入研究`pendingCancelIds`的使用之前，让我们调查Scala中`Set`的实现。'
- en: Set
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Set
- en: 'Scala''s implementation of `Set` is neither an ADT, such as `List`, nor a concrete
    implementation, such as `TreeMap`. Instead, it is a trait, as shown in this snippet
    of its definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的`Set`实现既不是ADT（如`List`），也不是具体实现（如`TreeMap`）。相反，它是一个特质，如下是其定义的片段所示：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The reason the standard library defines it is as a trait is to support specific
    implementations depending upon the element count. The `Set` companion object defines
    five implementations for sizes zero to four. Each implementation contains a fixed
    number of elements, as shown in `Set3`, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库将其定义为特质的原因是为了支持根据元素数量特定的实现。`Set`伴生对象定义了从零到四的大小五种实现。每个实现包含固定数量的元素，如`Set3`所示，如下：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the number of elements is small, the runtime performance is faster with
    hand-rolled `Set` implementations. With this technique, additions and removals
    point to the next or previous hand-rolled implementation. For example, consider `+`
    and `-` from `Set3`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素数量较少时，使用手工编写的`Set`实现运行时性能更快。使用这种技术，添加和删除操作指向下一个或上一个手工编写的实现。例如，考虑`Set3`中的`+`和`-`操作：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After `Set4`, the standard library uses an implementation named `HashSet`.
    This is visible when adding an element to `Set4`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Set4`之后，标准库使用了一个名为`HashSet`的实现。这在你向`Set4`添加元素时是可见的：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `HashSet` is analogous to `TreeMap` because it is backed by an efficient
    data structure to manage internal state. For `HashSet`, the backing data structure
    is a hash trie. The hash trie provides amortized constant time performance for
    additions, removals, and contains operations as per the Scala collections performance
    overview ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)).
    If you want to dig deeper into how a hash trie works, the Scala hash trie overview
    ([http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#hash-tries](http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#hash-tries))
    is a good starting point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet` 与 `TreeMap` 类似，因为它背后有一个高效的数据结构来管理内部状态。对于 `HashSet`，其底层数据结构是一个哈希 trie。哈希
    trie 提供了平均常数时间的性能，用于添加、删除和包含操作，如 Scala 集合性能概述（[http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)）中所述。如果你想要深入了解哈希
    trie 的工作原理，Scala 哈希 trie 概述（[http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#hash-tries](http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#hash-tries)）是一个很好的起点。'
- en: 'Returning to the `LazyCancelOrderBook`, we now know that common set operations
    with `pendingCancelIds` are completed in amortized constant time. Provided that
    we focus on additions and removals, and contains operations, this suggests there
    will be minimal overhead as the size of the set increases. We can use `pendingCancelIds`
    to represent the intent to remove an order from the order book without paying
    the cost of performing the removal. This simplifies the handling of a cancel order
    to be a constant time addition to `pendingCancelIds`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `LazyCancelOrderBook`，我们现在知道使用 `pendingCancelIds` 的常见集合操作是在平均常数时间内完成的。只要我们专注于添加、删除和包含操作，这表明随着集合大小的增加，开销将最小。我们可以使用
    `pendingCancelIds` 来表示从订单簿中移除订单的意图，而不必承担执行删除的成本。这简化了取消订单的处理，只需将取消订单添加到 `pendingCancelIds`
    中的常数时间操作即可：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The implementation of `handleCancelOrder` becomes trivial because the work
    to remove the order from the book is deferred. While this is a performance win,
    this implementation suffers from a serious deficiency. This implementation is
    no longer able to identify order IDs that are absent from the order book, which
    result in `OrderCancelRejected`. One way to account for this requirement is to
    maintain an additional `Set` containing order IDs actively resting on the book.
    Now, the `LazyCancelOrderBook` state looks like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleCancelOrder` 的实现变得非常简单，因为从订单簿中删除订单的工作被推迟了。虽然这是一个性能提升，但这种实现存在一个严重的缺陷。这种实现不再能够识别订单簿中不存在的订单
    ID，这会导致 `OrderCancelRejected`。为了满足这一要求，可以维护一个包含正在订单簿上活跃的订单 ID 的额外 `Set`。现在，`LazyCancelOrderBook`
    的状态如下：'
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this definition, we can rewrite `handleCancelOrder` to account for nonexistent
    order IDs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，我们可以重写 `handleCancelOrder` 以处理不存在的订单 ID：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This implementation involves three amortized, constant time operations when
    the order ID exists in the book. First, there is an operation to identify whether
    or not the order ID exists in the order book. Then, the provided order ID is removed
    from the active ID set and added to the pending cancel set. Previously, this scenario
    required two linear runtime operations. The degenerate scenario of handling a
    nonexistent order ID now shrinks to a single amortized constant time operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当订单 ID 存在于订单簿中时，这个实现涉及三个平均常数时间的操作。首先，有一个操作用于确定订单 ID 是否存在于订单簿中。然后，提供的订单 ID 从活动
    ID 集合中移除，并添加到待取消集合中。以前，这种情况需要两个线性运行时操作。处理不存在订单 ID 的退化场景现在缩小到单个平均常数时间的操作。
- en: Before celebrating performance wins, bear in mind that we still need to remove
    canceled orders from the book. To reduce the cost of cancelations, two potentially
    large sets were added to the order book, which increases the size of the memory
    footprint and garbage collection pressure. Additionally, benchmarking is needed
    to prove that theoretical performance improvements translate to real-world performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在庆祝性能提升之前，请记住我们仍然需要从订单簿中移除已取消的订单。为了减少取消的成本，我们在订单簿中添加了两个可能很大的集合，这增加了内存占用和垃圾回收的压力。此外，需要进行基准测试以证明理论上的性能提升可以转化为实际世界的性能提升。
- en: 'To complete `LazyCancelOrderBook` implementation, we need to account for `activeIds`
    when handling a limit order and `pendingCancelIds` when generating an execution.
    As you may recall, handling a limit order involved two scenarios:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`LazyCancelOrderBook`的实现，我们需要在处理限价订单时考虑`activeIds`，在生成执行时考虑`pendingCancelIds`。如您所回忆的那样，处理限价订单涉及两种场景：
- en: Adding a resting limit order
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加挂单限价订单
- en: Crossing the book to generate an execution
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉订单簿以生成执行
- en: 'Here is a partially implemented snippet that prepares us to handle these two
    scenarios for a `BuyLimitOrder`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个部分实现的代码片段，为我们处理这两种场景的`BuyLimitOrder`做准备：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To support resting buy orders, the provided buy order must be enqueued and
    additionally, the buy order ID must be added to the `activeOrderIds` set:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持挂单买入，提供的买入订单必须入队，并且，买入订单ID必须添加到`activeOrderIds`集合中：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The logic to add a resting limit order is shown in the preceding code and extracted
    into a method named `restLimitOrder`. This logic resembles the analogous scenario
    for `ListOrderBook` with the added amortized constant time active order ID addition
    operation. This change is straightforward and adds little processing time overhead.
    Finally, we consider the more complicated order crossing scenario. This scenario
    is analogous to `Queue.dequeue` in that this implementation pays the cost of the
    deferred action. The first dilemma to solve is identifying which order can be
    executed and which orders must be removed because they are canceled. `findActiveOrder`
    supplies this functionality and is shown with the assumption that `orderBook`
    is lexically in scope, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加挂单限价订单的逻辑在前面代码中展示，并提取为一个名为`restLimitOrder`的方法。这个逻辑类似于`ListOrderBook`的类似场景，增加了摊销常数时间的活跃订单ID添加操作。这个更改很简单，并且几乎没有增加处理时间的开销。最后，我们考虑更复杂的订单交叉场景。这个场景类似于`Queue.dequeue`，因为这种实现承担了延迟操作的成本。首先需要解决的困境是确定哪些订单可以执行，哪些订单必须被移除，因为它们已被取消。`findActiveOrder`提供了这个功能，并且假设`orderBook`在作用域内，如下所示：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`findActiveOrder` recursively inspects a sell price level until an executable
    order is found or the price level is empty. In addition to optionally resolving
    a sell order that can be executed, the method returns the remaining price level.
    These order IDs have been canceled and must be removed from `pendingCancelIds`.
    Here, we see the bulk of the canceled work deferred when the cancel request was
    handled. Execution is now amortized to be a constant time operation when executions
    occur repeatedly without a cancelation in-between. The worst case scenario is
    a linear runtime that is proportional to the number of canceled orders in the
    price level. Let''s look at how `findActiveOrder` is used to update the state
    of the order book:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`findActiveOrder`递归检查售价水平，直到找到可执行的订单或价格水平为空。除了可选地解决可以执行的卖出订单外，该方法还返回剩余的价格水平。这些订单ID已被取消，必须从`pendingCancelIds`中移除。在这里，我们看到在处理取消请求时，大部分取消工作被延迟。现在，当执行重复发生且中间没有取消时，执行被摊销为常数时间操作。最坏的情况是线性运行时间，与价格水平中取消订单的数量成比例。让我们看看`findActiveOrder`是如何用来更新订单簿状态的：'
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Order crossing implementation is now arguably more complicated than in `ListOrderBook`
    or `QueueOrderBook` due to the work to remove canceled orders and to remove the
    removed order IDs from `pendingCancelIds`. In all three pattern match statements,
    the set of returned order IDs returned as the final tuple member is removed from
    `pendingCancelIds` to indicate that the order is now removed from the book. The
    first two pattern match statements handle the distinction between finding an active
    order with one or more remaining orders in the price level and finding an active
    order with zero remaining orders in the price level. In the latter scenario, the
    price level is removed from the book. The third pattern match statement accounts
    for the scenario where an active order is not found. If an active order is not
    found because all orders were pending cancelation, then, by definition, the entire
    price level was searched, and it is, therefore, now empty.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要从`pendingCancelIds`中移除已取消的订单以及移除已移除的订单ID，订单交叉实现现在可能比`ListOrderBook`或`QueueOrderBook`更复杂。在所有三个模式匹配语句中，作为最终元组的成员返回的订单ID集合被从`pendingCancelIds`中移除，以指示订单现在已从订单簿中移除。前两个模式匹配语句处理了在价格水平中找到一个有剩余订单的一个或多个订单的活跃订单与找到一个价格水平中剩余订单为零的活跃订单之间的区别。在后一种情况下，价格水平从订单簿中移除。第三个模式匹配语句考虑了找不到活跃订单的情况。如果一个活跃订单因为所有订单都处于挂起取消状态而找不到，那么，根据定义，整个价格水平都被搜索过，因此现在是空的。
- en: Benchmarking LazyCancelOrderBook
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试LazyCancelOrderBook
- en: 'As a rigorous performance engineer, you realize that although your code compiles
    and your tests pass, your work is not yet complete. You begin pondering how to
    benchmark `LazyCancelOrderBook` to determine whether or not your changes have
    improved real-world performance. Your first idea is to test cancelation in isolation
    to confirm that this operation has indeed been optimized. To do this, you rework `CancelBenchmarks`,
    which was introduced in [Chapter 2](ch02.html "Chapter 2.  Measuring Performance
    on the JVM"), *Measuring Performance on the JVM*, to work with `QueueOrderBook`
    and `LazyCancelOrderBook`. This benchmark sweeps different price level sizes canceling
    the first order, the last order, and a nonexistent order. We omit the source code
    because it is identical to the previous implementation and instead consider the
    results. These results were produced by running the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名严谨的性能工程师，你意识到尽管你的代码编译成功且测试通过，但你的工作还远未完成。你开始思考如何基准测试`LazyCancelOrderBook`以确定你的更改是否真正提高了实际性能。你的第一个想法是单独测试取消操作以确认这一操作确实得到了优化。为此，你重新设计了在[第2章](ch02.html
    "第2章。在JVM上测量性能")中引入的`CancelBenchmarks`，即《在JVM上测量性能》，使其与`QueueOrderBook`和`LazyCancelOrderBook`一起工作。这个基准测试通过取消第一订单、最后订单和不存在订单，对不同价格水平大小进行扫描。我们省略了源代码，因为它与之前的实现相同，而是考虑了结果。这些结果是通过运行以下内容产生的：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The benchmark provides us with the following results:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试为我们提供了以下结果：
- en: '| **Benchmark** | **Enqueued order count** | **Throughput (ops per second)**
    | **Error as percentage of throughput** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **入队订单数量** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `eagerCancelFirstOrderInLine` | 1 | 6,912,696.09 | ± 0.44 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 1 | 6,912,696.09 | ± 0.44 |'
- en: '| `lazyCancelFirstOrderInLine` | 1 | 25,676,031.5 | ± 0.22 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 1 | 25,676,031.5 | ± 0.22 |'
- en: '| `eagerCancelFirstOrderInLine` | 10 | 2,332,046.09 | ± 0.96 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 10 | 2,332,046.09 | ± 0.96 |'
- en: '| `lazyCancelFirstOrderInLine` | 10 | 12,656,750.43 | ± 0.31 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 10 | 12,656,750.43 | ± 0.31 |'
- en: '| `eagerCancelFirstOrderInLine` | 1 | 5,641,784.63 | ± 0.49 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 1 | 5,641,784.63 | ± 0.49 |'
- en: '| `lazyCancelFirstOrderInLine` | 1 | 25,619,665.34 | ± 0.48 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 1 | 25,619,665.34 | ± 0.48 |'
- en: '| `eagerCancelFirstOrderInLine` | 10 | 1,788,885.62 | ± 0.39 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 10 | 1,788,885.62 | ± 0.39 |'
- en: '| `lazyCancelFirstOrderInLine` | 10 | 13,269,215.32 | ± 0.30 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 10 | 13,269,215.32 | ± 0.30 |'
- en: '| `eagerCancelFirstOrderInLine` | 1 | 9,351,630.96 | ± 0.19 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 1 | 9,351,630.96 | ± 0.19 |'
- en: '| `lazyCancelFirstOrderInLine` | 1 | 31,742,147.67 | ± 0.65 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 1 | 31,742,147.67 | ± 0.65 |'
- en: '| `eagerCancelFirstOrderInLine` | 10 | 6,897,164.11 | ± 0.25 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `eagerCancelFirstOrderInLine` | 10 | 6,897,164.11 | ± 0.25 |'
- en: '| `lazyCancelFirstOrderInLine` | 10 | 24,102,925.78 | ± 0.24 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `lazyCancelFirstOrderInLine` | 10 | 24,102,925.78 | ± 0.24 |'
- en: This test demonstrates that `LazyCancelOrderBook` consistently outperforms `QueueOrderBook`
    when canceling the first order, the last order, and a nonexistent order across
    order queue sizes of one and ten. This is exactly as expected because `LazyCancelOrderBook`
    defers the most expensive work until an order is executed. We see constant performance
    independent of the position of the order-to-be-canceled, which is further proof
    that the removal work is deferred. Also as expected, we see that canceling a nonexistent
    order results in improved performance because a linear traversal is no longer
    required to ascertain the absence of an order. However, we notice the performance
    hit as the enqueued order count increases from one to ten for `LazyCancelOrderBook`.
    We can hypothesize that the nearly 50% throughput reduction is due to the overhead
    of managing the state of active and pending cancel order IDs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，在取消第一个订单、最后一个订单以及不存在订单时，`LazyCancelOrderBook`在订单队列大小为一和十的情况下，始终优于`QueueOrderBook`。这正是预期的，因为`LazyCancelOrderBook`将最昂贵的操作推迟到订单执行时。我们看到性能保持恒定，不受即将取消的订单位置的影响，这进一步证明了移除工作被推迟。同样，正如预期的那样，我们看到取消一个不存在的订单会导致性能提升，因为不再需要线性遍历来确认订单不存在。然而，我们注意到当入队订单数量从一增加到十时，`LazyCancelOrderBook`的性能下降。我们可以假设近50%的吞吐量减少是由于管理活跃和挂起的取消订单ID状态的开销。
- en: 'This result is a promising sign that your changes are indeed improving the
    real-world performance. As the new implementation passed the initial litmus test,
    you think about how to representatively simulate a combination of executions and
    cancelations. You decide to focus on creating a microbenchmark that combines executions
    and cancelations to exercise `LazyCancelOrderBook` in scenarios that more closely
    resemble production. You think back to a recent lunch conversation you had with
    Dave about market trading flows and recall that he said it is common to see about
    two cancelations per execution. Running with this idea, you create a benchmark
    that interleaves trades and cancelations. For both order book implementations,
    you want to test performance when during the following scenarios:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是一个有希望的迹象，表明你的更改确实提高了现实世界的性能。由于新的实现通过了初始的基准测试，你开始考虑如何代表性地模拟执行和取消的组合。你决定专注于创建一个微基准，该基准结合了执行和取消，以在更接近生产的场景中测试`LazyCancelOrderBook`。你回想起与Dave最近的一次午餐谈话，他提到每笔执行大约有两笔取消是很常见的。带着这个想法，你创建了一个交替交易和取消的基准。对于两个订单簿实现，你想要测试以下场景中的性能：
- en: Two trades per cancelation
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次取消对应两笔交易
- en: One trade per cancelation
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次取消对应一笔交易
- en: Two cancelations per trade
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每笔交易对应两次取消
- en: 'These three scenarios will help reveal shortcomings in `LazyCancelOrderBook`
    by focusing on production-like order book activities. The benchmark requires initializing
    each order book with a set of resting orders to be canceled or executed against.
    The following snippet demonstrates how to initialize the order books in a JMH
    test:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个场景将有助于通过关注类似生产的订单簿活动来揭示`LazyCancelOrderBook`的不足。基准要求为每个订单簿初始化一组待取消或执行的休息订单。以下代码片段展示了如何在JMH测试中初始化订单簿：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before each trial, both order books will be filled with `maxOrderCount` (defined
    to be 30) resting bids. As there are three scenarios to test and two order books,
    there are six benchmarks defined for this test. Each set of three scenarios is
    the same per order book implementation. To avoid duplication, the following snippet
    shows the three benchmarks implemented for `LazyCancelOrderBook`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次试验之前，两个订单簿都将填充`maxOrderCount`（定义为30）的休息出价。由于有三个场景要测试和两个订单簿，因此为此测试定义了六个基准。每个三组场景在每个订单簿实现中都是相同的。为了避免重复，以下代码片段显示了为`LazyCancelOrderBook`实现的三个基准：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These benchmarks follow the convention of denoting the cancelation frequency
    ("C") first and the trade frequency ("T") second. For example, the final benchmark
    implements the scenario that represents one cancelation for every two trades.
    The commands are defined as values out-of-scope to avoid generating garbage during
    benchmark invocation. The benchmark invocation looks like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准遵循先表示取消频率（"C"）然后表示交易频率（"T"）的惯例。例如，最终的基准实现了每两笔交易对应一次取消的场景。命令被定义为作用域之外的值，以避免在基准调用期间生成垃圾。基准调用看起来如下所示：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This invocation produces the following results:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用产生了以下结果：
- en: '| **Benchmark** | **Throughput (ops per second)** | **Error as percentage of
    throughput** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **吞吐量（每秒操作数）** | **错误率作为吞吐量的百分比** |'
- en: '| `eagerOneToTwoCT` | 797,339.08 | ± 2.63 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `eagerOneToTwoCT` | 797,339.08 | ± 2.63 |'
- en: '| `lazyOneToTwoCT` | 1,123,157.94 | ± 1.26 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `lazyOneToTwoCT` | 1,123,157.94 | ± 1.26 |'
- en: '| `eagerOneToOneCT` | 854,635.26 | ± 2.48 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `eagerOneToOneCT` | 854,635.26 | ± 2.48 |'
- en: '| `lazyOneToOneCT` | 1,469,338.46 | ± 1.85 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `lazyOneToOneCT` | 1,469,338.46 | ± 1.85 |'
- en: '| `eagerTwoToOneCT` | 497,368.11 | ± 0.72 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `eagerTwoToOneCT` | 497,368.11 | ± 0.72 |'
- en: '| `lazyTwoToOneCT` | 1,208,671.60 | ± 1.69 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `lazyTwoToOneCT` | 1,208,671.60 | ± 1.69 |'
- en: 'Across the board, `LazyCancelOrderBook` outperforms `QueueOrderBook`. The relative
    difference between lazy and eager performance shows an interesting relationship.
    The following table captures the relative performance difference:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有方面，`LazyCancelOrderBook` 都优于 `QueueOrderBook`。惰性和积极性能之间的相对差异显示出一种有趣的关系。以下表格捕捉了相对性能差异：
- en: '| **Benchmark** | **LazyCancelOrderBook percentage performance improvement**
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **LazyCancelOrderBook 百分比性能提升** |'
- en: '| `OneToTwoCT` | 141.00% |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `OneToTwoCT` | 141.00% |'
- en: '| `OneToOneCT` | 172.00% |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `OneToOneCT` | 172.00% |'
- en: '| `TwoToOneCT` | 243.00% |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `TwoToOneCT` | 243.00% |'
- en: Studying the preceding table, we observe that `LazyCancelOrderBook` shows the
    greatest performance win when there are two cancelations per trade. This result
    demonstrates the benefit of deferring the cost of processing a cancelation request.
    The next trend that we see is that as the frequency of trades increases and the
    frequency of cancelations decreases, `QueueOrderBook` performance improves relative
    to `LazyCancelOrderBook`. This result makes sense because `LazyCancelOrderBook`
    incurs extra costs when performing a trade. In addition to searching for canceled
    orders, `LazyCancelOrderBook` must update `activeIds`. The `QueueOrderBook` avoids
    these costs, but we see the overwhelming cost of cancelation processing continues
    to overshadow `QueueOrderBook` performance. Summarizing these results, we have
    more confidence that `LazyCancelOrderBook` is a stand-in replacement for `QueueOrderBook`.
    In scenarios involving heavy volumes of cancelations, it appears to be a clear
    winner, and in other scenarios, it appears to maintain parity with `QueueOrderBook`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究前表，我们观察到当每笔交易有两个取消操作时，`LazyCancelOrderBook` 显示出最大的性能提升。这一结果证明了推迟处理取消请求成本的好处。我们看到的下一个趋势是，随着交易频率的增加和取消频率的减少，`QueueOrderBook`
    相对于 `LazyCancelOrderBook` 的性能有所提升。这一结果是有道理的，因为 `LazyCancelOrderBook` 在进行交易时会产生额外的成本。除了搜索已取消订单外，`LazyCancelOrderBook`
    还必须更新 `activeIds`。`QueueOrderBook` 避免了这些成本，但我们看到取消处理的高昂成本仍然继续影响 `QueueOrderBook`
    的性能。总结这些结果，我们更有信心认为 `LazyCancelOrderBook` 可以作为 `QueueOrderBook` 的替代品。在涉及大量取消操作的场景中，它似乎是一个明显的赢家，而在其他场景中，它似乎与
    `QueueOrderBook` 保持一致。
- en: Lessons learned
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验教训
- en: In this section, we leveraged Scala collections, in conjunction with the judicious
    use of lazy evaluation, to improve the performance of a critical component in
    MVT's infrastructure. By working through several order book implementations, you
    learned first-hand how a well-suited data structure can improve performance while
    a less optimal choice can derail performance. This exercise also exposed you to
    how Scala implements several of its collections, which you can now use to your
    advantage when working on a performance problem.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用 Scala 集合，并结合谨慎使用惰性评估，来提高 MVT 基础设施中一个关键组件的性能。通过研究几个订单簿实现，你亲自学习了如何选择合适的数据结构可以提升性能，而选择不优的数据结构则可能导致性能下降。这项练习还让你了解了
    Scala 如何实现其一些集合，你现在可以利用这些集合来解决性能问题。
- en: '`LazyCancelOrderBook` illustrates how valuable deferred evaluation can be in
    a performance-sensitive environment. When faced with a performance challenge,
    ask yourself the following questions to see whether it is possible to defer work
    (CPU work, not your actual work!). The following table lists each question and
    how it was answered with the order book:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyCancelOrderBook` 展示了在性能敏感的环境中延迟评估的价值。面对性能挑战时，问问自己以下问题，看看是否有可能推迟工作（CPU
    工作量，而不是你的实际工作量！）！以下表格列出了每个问题以及如何通过订单簿回答：'
- en: '| **Question** | **Application to order book example** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | **订单簿示例应用** |'
- en: '| How can I decompose into smaller discrete chunks? | The act of canceling
    was decomposed into identifying the event that was sent to the requester and removing
    the canceled order from the book state. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 我如何将任务分解成更小的离散块？ | 取消操作被分解为识别发送给请求者的事件，并从订单簿状态中删除已取消的订单。|'
- en: '| Why am I performing all of these steps now? | Originally, order removal happened
    eagerly because it was the most logical way to model the process. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 为什么我现在要执行所有这些步骤？ | 最初，订单移除是急切发生的，因为这是最逻辑的方式来建模这个过程。|'
- en: '| Can I change any constraints to allow me to model the problem differently?
    | Ideally, we would have liked to remove the constraint requiring rejection of
    nonexistent orders. Unfortunately, this was out of our control. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 我能否更改任何约束，以便我可以以不同的方式建模问题？ | 理想情况下，我们希望移除要求拒绝不存在订单的约束。不幸的是，这超出了我们的控制范围。|'
- en: '| What operations in my system are most performant? | Executing an order and
    resting an order on the book are the most performant operations. We leveraged
    fast execution time to perform removals of canceled orders from the book. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 我系统中哪些操作是最高效的？ | 执行订单和在订单簿上挂单是最高效的操作。我们利用快速执行时间从订单簿中移除已取消的订单。|'
- en: Like any approach, deferred evaluation is not a panacea. Diligent benchmarking
    and profiling are necessary to validate the benefit delivered by the change. Arguably
    the implementation of `LazyCancelOrderBook` is more complicated than `QueueOrderBook`,
    which will increase the cost to maintain the system. In addition to making implementation
    more complicated, it is now more difficult to reason about runtime performance
    due to the variable cost of order execution. For the scenarios that we tested, `LazyCancelOrderBook`
    remained at parity with or better than `QueueOrderBook`. However, we only exercised
    a few of the many possible scenarios, and we did so with only a single price level
    in the order book. In a real-world environment, additional benchmarking and profiling
    are needed to build enough confidence that this new implementation delivers better
    performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何方法一样，延迟评估并不是万能的。勤奋的基准测试和性能分析是必要的，以验证变化带来的好处。可以说，`LazyCancelOrderBook`的实现比`QueueOrderBook`更复杂，这将增加维护系统的成本。除了使实现更加复杂之外，由于订单执行的变量成本，现在推理运行时性能也更加困难。对于我们所测试的场景，`LazyCancelOrderBook`与`QueueOrderBook`保持一致，甚至在某些情况下表现更好。然而，我们只测试了众多可能场景中的一小部分，并且我们只在一个订单簿的单个价格水平上进行了测试。在现实世界中，需要额外的基准测试和性能分析，以建立足够的信心，确信这种新的实现提供了更好的性能。
- en: Historical data analysis
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史数据分析
- en: You have done great work with the order book, and we hope, have learned valuable
    skills along the way! It is now time to explore a new facet of MVT's activities.
    A group of expert traders and data scientists are constantly studying historical
    market data to design performant trading strategies. Until now, the company has
    not had the luxury of allocating technical resources to this team. As a result,
    this group has been using clunky, unreliable, and under-performing tools to analyze
    market data and build elaborate trading strategies. With a performant order book,
    the top priority is to focus on improving the strategies implemented by the company.
    Your new best friend, Dave, has explicitly asked for you to join the team and
    help them modernize their infrastructure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你在订单簿方面做了出色的工作，并且我们希望，在这个过程中你已经学到了宝贵的技能！现在是时候探索MVT活动的新方面了。一群专家交易员和数据科学家一直在研究历史市场数据，以设计高效的交易策略。到目前为止，公司还没有奢侈地将技术资源分配给这个团队。因此，这个团队一直在使用笨拙、不可靠且表现不佳的工具来分析市场数据并构建复杂的交易策略。有了高效的订单簿，首要任务是专注于改进公司实施的策略。你的新朋友Dave明确要求你加入团队，帮助他们现代化他们的基础设施。
- en: Lagged time series returns
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滞后时间序列回报
- en: 'The main tool used by the team is a simple program designed to compute lagged
    time series returns from historical trade execution data. So far, this tool has
    been a big disappointment. Not only does it return mostly invalid results, it
    is also slow and fragile. Before diving into the code, Dave gives you a short
    presentation of the business rules involved. Return time series are derived from
    midpoint time series. A midpoint is calculated on each minute, and it is based
    on the bid and ask prices of each trade execution. Consider the following table
    as a simple example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 团队主要使用的工具是一个简单的程序，用于从历史交易执行数据中计算滞后时间序列回报。到目前为止，这个工具令人大失所望。不仅它返回的结果大多无效，而且它运行缓慢且脆弱。在深入代码之前，Dave给你简要介绍了涉及的业务规则。回报时间序列是从中间价时间序列派生出来的。中间价是基于每个交易的买入价和卖出价在每个分钟计算的。以下表格可以作为简单的例子：
- en: '| **Execution time** | **Bid price** | **Ask price** | **Midpoint** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **执行时间** | **买入价** | **卖出价** | **中间价** |'
- en: '| 01/29/16 07:45 | 2.3 | 2.5 | 2.55 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:45 | 2.3 | 2.5 | 2.55 |'
- en: '| 01/29/16 07:46 | 2.1 | 2.4 | 2.25 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:46 | 2.1 | 2.4 | 2.25 |'
- en: '| 01/29/16 07:47 | 2.9 | 3.4 | 3.15 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:47 | 2.9 | 3.4 | 3.15 |'
- en: '| 01/29/16 07:48 | 3.2 | 3.4 | 3.3 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:48 | 3.2 | 3.4 | 3.3 |'
- en: '| 01/29/16 07:49 | 3.1 | 3.3 | 3.2 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:49 | 3.1 | 3.3 | 3.2 |'
- en: The formula to calculate a midpoint is *(bid_price + ask_price) / 2*. For example,
    the midpoint at 01/29/16 07:47 is *(2.9 + 3.4) / 2*, that is, 3.15.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中点的公式是 *(买价 + 卖价) / 2*。例如，01/29/16 07:47 的中点是 *(2.9 + 3.4) / 2*，即 3.15。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: In the real world, a midpoint would be weighed by the volume of the transaction,
    and the time series would use a more fine-grained time unit, such as seconds or
    even milliseconds. To keep the example simple, we disregard the volume dimension
    by assuming a volume of 1 for all executions. We also focus on calculating one
    data point per minute instead of a more granular time series that would use seconds
    or even milliseconds.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，中点会根据交易量进行加权，时间序列会使用更细粒度的时间单位，例如秒或甚至毫秒。为了使示例简单，我们通过假设所有执行的交易量为 1 来忽略体积维度。我们还专注于每分钟计算一个数据点，而不是使用秒或甚至毫秒的更细粒度的时间序列。
- en: 'A series of midpoints is used to compute a series of returns. A series of returns
    is defined for a certain rollup value in minutes. To calculate the three minute
    return at time t[3], the formula is: (midpoint_at_t[3] - midpoint_at_t[0]) / midpoint_at_t[0].
    We also multiply the result by 100 to use percentages. If we use the previous
    midpoint series to calculate a three minute return series, we obtain the following
    table:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列中点用于计算一系列返回值。对于一定分钟的汇总值，定义了一系列返回值。为了计算时间 t[3] 的三分钟返回值，公式是：(t[3] 时的中点 - t[0]
    时的中点) / t[0] 时的中点。我们还乘以 100 以使用百分比。如果我们使用之前的中点系列来计算三分钟返回值系列，我们得到以下表格：
- en: '| **Time** | **Midpoint** | **3 minute return** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **时间** | **中点** | **3分钟回报** |'
- en: '| 01/29/16 07:45 | 2.55 | N/A |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:45 | 2.55 | N/A |'
- en: '| 01/29/16 07:46 | 2.25 | N/A |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:46 | 2.25 | N/A |'
- en: '| 01/29/16 07:47 | 3.15 | N/A |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:47 | 3.15 | N/A |'
- en: '| 01/29/16 07:48 | 3.3 | 22.73 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:48 | 3.3 | 22.73 |'
- en: '| 01/29/16 07:49 | 3.2 | 29.69 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 01/29/16 07:49 | 3.2 | 29.69 |'
- en: Note that the first three midpoints do not have a corresponding three minute
    return as there is no midpoint that is old enough to be used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前三个中点没有对应的三个分钟回报，因为没有足够旧的中点可以使用。
- en: 'You are now familiar with the domain and can have a look at the existing code.
    Starting with this model:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经熟悉了该领域，可以查看现有的代码。从以下模型开始：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Everything looks straightforward. Note that prices, midpoints, and returns are
    represented as `Int` and `Double`. We assume that our system is able to normalize
    the prices as integers instead of decimals. This simplifies our code, and also
    improves the performance of the program since we use primitive `Double` instead
    of, for example, `BigDecimal` instances. `TimestampMinutes` is similar to the
    more commonly used Epoch timestamp, but only down to the minute (see [https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎一切都很直接。请注意，价格、中点和回报被表示为 `Int` 和 `Double`。我们假设我们的系统能够将价格规范化为整数而不是小数。这简化了我们的代码，并提高了程序的性能，因为我们使用原始的
    `Double` 而不是例如 `BigDecimal` 实例。"TimestampMinutes" 与更常用的纪元时间戳类似，但只精确到分钟（见 [https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)）。
- en: 'After studying the model, we look at the existing implementation of the `computeReturnsWithList`
    method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究模型后，我们查看 `computeReturnsWithList` 方法的现有实现：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method assumes that the list of midpoint received as input is already
    sorted by execution time. This randomly accesses various indices of the list to
    read the midpoints that are required to compute each return. To compute the second
    return value (index 1 in the returned list) with a rollup value of three minutes,
    we access elements at index 4 and 1 in the input list. The following diagram provides
    a visual reference for how returns are computed:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法假设接收到的输入中点列表已经按执行时间排序。它随机访问列表的各个索引以读取计算每个返回值所需的中点。为了使用三分钟的汇总值计算第二个返回值（返回列表中的索引
    1），我们访问输入列表中的索引 4 和 1 的元素。以下图表提供了计算返回值的视觉参考：
- en: '![Lagged time series returns](img/image_04_003.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![滞后时间序列回报](img/image_04_003.jpg)'
- en: 'You have been warned that this method is slow, but it is also incorrect. Dave
    has verified many times that it returns incorrect results. Before tackling the
    performance issue, you have to handle the correctness problem. Optimizing an incorrect
    approach would not be a good use of your time and, therefore, of the company''s
    money! Rapidly, you realize that this method puts too much trust in the data that
    it is fed. For this algorithm to work, the input list of midpoints has to do the
    following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经被警告这种方法很慢，但它也是不正确的。Dave已经多次验证它返回了错误的结果。在解决性能问题之前，你必须处理正确性问题。优化一个不正确的方法不会是你时间的良好利用，因此也不会是公司金钱的良好利用！迅速地，你意识到这种方法对输入数据的信任过多。为了使这个算法工作，输入的中点列表必须做到以下几点：
- en: This has to be properly sorted by execution time, from the oldest to the newest
    execution
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这必须按执行时间正确排序，从最早的执行到最新的执行
- en: This has to have no more than one midpoint per minute
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这必须每分钟不超过一个中点
- en: This has to not contain any minutes without a midpoint, that is, it has no missing
    data points
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不能包含任何没有中点的分钟，也就是说，它没有缺失的数据点
- en: You bring this up to Dave to better understand how the midpoint series is generated.
    He explains that it is loaded from sequential logs that are recorded by the order
    book. It is certain that the list is sorted by execution time. Also, he assures
    you that considering the large volume of trades handled by the order book, it
    is impossible to have a minute without a single execution. However, he acknowledges
    that it is more than likely that more than one midpoint is computed for the same
    execution time. It looks like you have found the problem causing invalid returns.
    Fixing it should not be too complicated, and you think that it is now time to
    reflect on the performance issue.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你把这个问题提给Dave，以便更好地理解中点序列是如何生成的。他解释说，它是从由订单簿记录的顺序日志中加载的。可以肯定的是，列表是按执行时间排序的。他还向你保证，考虑到订单簿处理的大量交易量，不可能有一个没有单次执行的分钟。然而，他也承认，对于同一执行时间，很可能计算了多个中点。看起来你已经找到了导致无效返回的问题。修复它不应该太复杂，你认为现在是时候反思性能问题。
- en: 'We spent time studying the structure of a singly-linked list in the previous
    section. You know that it is optimized for operations involving the head and the
    tail of the list. On the contrary, randomly accessing an element by its index
    is an expensive operation requiring linear time. To improve midpoint execution
    performance, we turn to a data structure with improved random access performance:
    `Vector`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们花费时间研究了单链表的结构。你知道它优化了涉及列表头和尾的操作。相反，通过索引随机访问元素是一个昂贵的操作，需要线性时间。为了提高中点执行性能，我们转向具有改进随机访问性能的数据结构：`Vector`。
- en: Vector
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: 'To improve the performance of our system, we should reconsider the data structure
    that stores `Midpoint` values. A good option is to replace `List` with `Vector`,
    another Scala collection provided by the standard library. The `Vector` is an
    efficient collection that provides effectively constant time random access. The
    cost of random access operations depends on various assumptions, such as, the
    maximum length of the `Vector`. The `Vector` is implemented as an ordered tree
    data structure called a trie. In a trie, the keys are the indices of the values
    stored in the `Vector` (to learn more about tries and their use cases, see [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)).
    As `Vector` implements the `Seq` trait, just like `List`, modifying the existing
    method is straightforward:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高我们系统的性能，我们应该重新考虑存储`Midpoint`值的数据库结构。一个好的选择是将`List`替换为标准库提供的另一个Scala集合`Vector`。`Vector`是一个高效的集合，它提供了有效的常数时间随机访问。随机访问操作的成本取决于各种假设，例如，`Vector`的最大长度。`Vector`被实现为一个有序树数据结构，称为trie。在trie中，键是存储在`Vector`中的值的索引（要了解更多关于trie及其用例的信息，请参阅[https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)）。由于`Vector`实现了`Seq`特质，就像`List`一样，修改现有方法很简单：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Changing the type of the collection is enough to switch to a more performant
    implementation. To make sure that we actually improved the performance, we devise
    a simple benchmark that is designed to use a few hours of historical trade executions
    and measure the throughput of each implementation. The results are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改集合的类型就足以切换到更高效的实现。为了确保我们确实提高了性能，我们设计了一个简单的基准测试，该测试旨在使用几小时的历史交易执行情况，并测量每个实现的吞吐量。结果如下：
- en: '| **Benchmark** | **Return rollup in minutes** | **Throughput (ops per second)**
    | **Error as percentage of throughput** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **返回汇总所需时间（分钟）** | **吞吐量（每秒操作数）** | **错误率（吞吐量百分比）** |'
- en: '| `computeReturnsWithList` | 10 | 534.12 | ± 1.69 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithList` | 10 | 534.12 | ± 1.69 |'
- en: '| `computeReturnsWithVector` | 10 | 49,016.77 | ± 0.98 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithVector` | 10 | 49,016.77 | ± 0.98 |'
- en: '| `computeReturnsWithList` | 60 | 621.28 | ± 0.64 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithList` | 60 | 621.28 | ± 0.64 |'
- en: '| `computeReturnsWithVector` | 60 | 51,666.50 | ± 1.64 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithVector` | 60 | 51,666.50 | ± 1.64 |'
- en: '| `computeReturnsWithList` | 120 | 657.44 | ± 1.07 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithList` | 120 | 657.44 | ± 1.07 |'
- en: '| `computeReturnsWithVector` | 120 | 43,297.88 | ± 0.99 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `computeReturnsWithVector` | 120 | 43,297.88 | ± 0.99 |'
- en: Not only does `Vector` yield significantly better performance, it delivers the
    same throughput regardless of the size of the rollup. As a general rule, it is
    better to use `Vector` as a default implementation for immutable indexed sequences. Vector
    effectively provides constant time complexity not only for element random access
    but also for head and tail operations, as well as to append and prepend elements
    to an existing `Vector`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅 `Vector` 提供了显著更好的性能，它无论汇总的大小如何都能提供相同的吞吐量。作为一个一般规则，最好将 `Vector` 作为不可变索引序列的默认实现。`Vector`
    不仅为元素随机访问提供有效常数时间复杂度，还为头部和尾部操作以及向现有 `Vector` 中追加和预追加元素提供有效常数时间复杂度。
- en: The implementation of `Vector` is a tree structure of parity 32\. Each node
    is implemented as an array of size 32, and it can store either up to 32 references
    to child nodes or up to 32 values. This 32-ary tree structure explains why the
    complexity of `Vector` is "effectively constant" instead of "constant". The real
    complexity of the implementation is log(32, N), where N is the size of the vector.
    This is considered close enough to actual constant time. This collection is a
    good choice to store very large sequences because the memory is allocated in chunks
    of 32 elements. These chunks are not preallocated for all levels of the tree,
    but only allocated as needed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector` 的实现是一个32阶的树结构。每个节点实现为一个大小为32的数组，它可以存储最多32个指向子节点的引用或最多32个值。这种32叉树结构解释了为什么`Vector`的复杂度是“有效常数”而不是“常数”。实现的真正复杂度是
    log(32, N)，其中 N 是向量的大小。这被认为足够接近实际常数时间。这个集合是一个存储非常大的序列的好选择，因为内存是在32个元素的块中分配的。这些块不是为树的所有级别预先分配的，而是按需分配。'
- en: 'Until Scala 2.10, one downside of `Vector` as compared to `List` was the lack
    of pattern matching support. This is now fixed and you can pattern-match an instance
    of `Vector` in the same way you pattern match a `List`. Consider this short example
    of a method pattern matching a `Vector` to access and return its third element
    or return `None` if it contains fewer than three elements:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Scala 2.10，与 `List` 相比，`Vector` 的一个缺点是缺乏模式匹配支持。现在这个问题已经解决了，你可以像匹配 `List`
    实例一样匹配 `Vector` 实例。考虑以下一个方法匹配 `Vector` 以访问和返回其第三个元素或如果它包含少于三个元素则返回 `None` 的简短示例：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Invoking this method in the REPL demonstrates that pattern matching can be
    applied, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中调用此方法可以演示模式匹配的应用，如下所示：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Data clean up
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据清理
- en: The return algorithm is now blazingly fast. That is, blazingly fast to return
    incorrect results! Remember that we still have to handle some edge cases and clean
    up the input data. Our algorithm only works if there is exactly one midpoint per
    minute, and Dave informed us that we are likely to see more than one midpoint
    computed for the same minute.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 返回算法现在非常快。也就是说，返回错误结果的速度非常快！记住我们仍然需要处理一些边缘情况并清理输入数据。我们的算法只有在每分钟恰好有一个中点时才有效，Dave
    通知我们我们可能会看到同一分钟计算出的多个中点。
- en: 'To handle this problem, we create a dedicated `MidpointSeries` module and make
    sure that an instance of `MidpointSeries`, wrapping a series of `Midpoint` instances,
    is properly created without duplicates:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们创建了一个专门的 `MidpointSeries` 模块，并确保正确创建了一个 `MidpointSeries` 实例，它包装了一系列
    `Midpoint` 实例，且没有重复：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our `removeDuplicates` method uses a tail recursive method (Refer to [Chapter
    3](ch03.html "Chapter 3. Unleashing Scala Performance"), *Unleashing Scala Performance*).
    This groups all the midpoints with the same execution time, calculates the average
    value of these data points, and builds a new series with these average values.
    Our module provides a `fromExecution` factory method to build an instance of `MidpointSeries`
    from a `Vector` of `Execution`. This factory method calls `removeDuplicates` to
    clean up the data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`removeDuplicates`方法使用尾递归方法（参考第3章[Unleashing Scala Performance](ch03.html
    "Chapter 3. Unleashing Scala Performance")）。这种方法将所有具有相同执行时间的中间点分组，计算这些数据点的平均值，并使用这些平均值构建一个新的序列。我们的模块提供了一个`fromExecution`工厂方法，用于从`Execution`的`Vector`构建`MidpointSeries`的实例。这个工厂方法调用`removeDuplicates`来清理数据。
- en: 'To improve our module, we add our previous `computeReturns` method to the `MidpointSeries`
    class. That way, once constructed, an instance of `MidpointSeries` can be used
    to compute any return series:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的模块，我们将之前的`computeReturns`方法添加到`MidpointSeries`类中。这样，一旦构建，`MidpointSeries`的一个实例就可以用来计算任何回报序列：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the same code that we previously wrote, but this time, we are confident
    that `points` does not contain duplicates. Note that the constructor is marked `private`,
    so the only way to instantiate an instance of `MidpointSeries` is via our factory
    method. This guarantees that it is impossible to create an instance of `MidpointSeries`
    with a "dirty" `Vector`. You release this new version of the program, wish good
    luck to Dave and his team, and leave for a well deserved lunch break.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前写的相同代码，但这次我们确信`points`不包含重复项。请注意，构造函数被标记为`private`，因此创建`MidpointSeries`实例的唯一方法是使用我们的工厂方法。这保证了不可能使用“脏”的`Vector`创建`MidpointSeries`的实例。你发布了这个新版本的程序，祝Dave和他的团队好运，然后离开去享受应得的午餐休息时间。
- en: 'As you return, you are surprised to find Vanessa, one of the data scientists,
    waiting at your desk. "The return series code still doesn''t work", she says.
    The team was so excited to finally be given a working algorithm that they decided
    to skip lunch to play with it. Unfortunately, they discovered some inconsistencies
    with the results. You try to collect as much data as possible, and spend an hour
    looking at the invalid results that Vanessa is talking about. You noticed that
    they all involved trade executions for two specific symbols: FOO and BAR. A surprisingly
    small amount of trades is recorded for these symbols, and it is not unusual for
    several minutes to elapse between trade executions. You questioned Dave about
    these symbols. He explains that these are thinly traded tickers, and it is expected
    to see a lower trading volume for them. The problem is now clear to you. The midpoint
    series recorded for these symbols do not fulfill one of the prerequisite of your
    algorithm: at least one execution per minute. You refrain from reminding Dave
    that he assured you this situation was impossible and start working on a fix.
    The trader is always right!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你回来时，你惊讶地发现数据科学家之一Vanessa正坐在你的办公桌前。“返回序列代码仍然不起作用”，她说。团队对于终于得到了一个可以工作的算法感到非常兴奋，以至于他们决定放弃午餐来玩这个。不幸的是，他们发现了一些与结果的不一致性。你试图收集尽可能多的数据，花了一个小时查看Vanessa提到的无效结果。你注意到它们都涉及两个特定符号的交易执行：FOO和BAR。这些符号的交易记录数量出奇地少，而且交易执行之间通常会有几分钟的间隔。你向Dave询问这些符号。他解释说，这些是交易量较小的股票，对于它们来说，看到较低的成交量并不罕见。现在问题对你来说已经很明确了。这些符号记录的中点序列没有满足你的算法的一个先决条件：每分钟至少有一个执行。你忍住没有提醒Dave他之前向你保证这种情况不可能发生，并开始着手解决问题。交易员总是对的！
- en: 'You are not confident that you can rework the algorithm to make it more robust
    while preserving the current throughput. A better option would be to find a way
    to clean up the data to generate the missing data points. You seek advice from
    Vanessa. She explains that it would not disturb the trading algorithm to perform
    a linear extrapolation of the missing data points, based on the surrounding existing
    points. You write a short method to extrapolate a midpoint at a certain time using
    the previous and following points (respectively, `a` and `b` in the following
    snippet):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不自信能够重新设计算法使其更加健壮，同时保持当前的吞吐量。更好的选择是找到一种方法来清理数据以生成缺失的数据点。你向Vanessa寻求建议。她解释说，基于周围现有的点对缺失数据点进行线性外推不会干扰交易算法。你编写了一个简短的方法来使用前一个和后一个点（以下代码片段中的`a`和`b`）在特定时间外推中点：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this method, we can write a clean up method that follows the model of
    the previously mentioned `removeDuplicates` function to preprocess the data:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以编写一个清理方法，遵循之前提到的`removeDuplicates`函数的模式来预处理数据：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our internal tail-recursive method handles the case where two points are already
    consecutive, and the case where a point is missing. In the latter case, we create
    a new point with our `extrapolate` method and insert it in the result `Vector`.
    Note that we use this new point to extrapolate consecutive missing points. We
    update our factory method to perform this additional clean up after removing possible
    duplicates:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们内部尾递归方法处理了两个点已经连续的情况，以及一个点缺失的情况。在后一种情况下，我们使用我们的`extrapolate`方法创建一个新的点，并将其插入到结果`Vector`中。请注意，我们使用这个新点来外推连续缺失的点。我们更新我们的工厂方法，在删除可能的重复项后执行此附加清理操作：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We now have the assurance that our input data is clean and ready to be used
    by our return series algorithm.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有保证，我们的输入数据是干净的，并且可以用于我们的回报序列算法。
- en: Handling multiple return series
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个回报序列
- en: The team is impressed by the improvements that you implemented, and by how quickly
    you were able to fix the existing code. They mention a project they have had in
    mind for a while without knowing how to approach it. A couple of weeks ago, Vanessa
    designed a machine learning algorithm to evaluate trading strategies over several
    tickers, based on their return series. This algorithm requires that all the return
    series involved contain the same amount of data points. Your previous changes
    already took care of this requirement. However, another condition is that the
    return values must be normalized or scaled. A feature is a machine learning term
    for an individual measurable property. In our example, each return data point
    is a feature. Feature scaling is used to standardize the range of possible values
    to ensure that broad ranges of values do not distort a learning algorithm. Vanessa
    explains that scaling features will help her algorithm to deliver better results.
    Our program will handle a set of return series, compute a scaling vector, and
    calculate a new set of normalized return series.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 团队对你的改进印象深刻，以及你快速修复现有代码的能力。他们提到了一个他们一直想做的项目，但不知道如何着手。几周前，Vanessa设计了一个机器学习算法，用于评估多个股票的贸易策略，基于它们的回报序列。这个算法要求所有涉及的回报序列包含相同数量的数据点。你之前的变化已经处理了这个要求。然而，另一个条件是回报值必须归一化或缩放。特征是机器学习术语，指单个可测量的属性。在我们的例子中，每个回报数据点都是一个特征。特征缩放用于标准化可能值的范围，以确保广泛的值范围不会扭曲学习算法。Vanessa解释说，缩放特征将帮助她的算法提供更好的结果。我们的程序将处理一组回报序列，计算缩放向量，并计算一组新的归一化回报序列。
- en: Array
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array
- en: 'For this system, we consider switching from `Vector` to `Array`. `Array` is
    a mutable, indexed collection of values. It provides real constant complexity
    for random access, as opposed to `Vector`, which implements this operation in
    effectively constant time. However, contrary to `Vector`,  `Array` is allocated
    once as a single and contiguous chunk of memory. Furthermore, it does not permit
    append and prepend operations. A Scala `Array` is implemented with a Java `Array`,
    which is memory optimized. A Scala `Array` is more user-friendly than the native
    Java `Array`. Most methods that are available on other Scala collections are made
    available when using `Array`. Implicit conversions are used to augment `Array`
    with `ArrayOps` and `WrappedArray`. `ArrayOps` is a simple wrapper for `Array`
    to temporarily enrich `Array` with all the operations found in indexed sequences.
    Methods called on `ArrayOps` will yield an `Array`. On the contrary, a conversion
    from `Array` to `WrappedArray` is permanent. Transformer methods called on `WrappedArray`
    yield another `WrappedArray`. We see this in the standard library documentation,
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个系统，我们考虑从`Vector`切换到`Array`。`Array`是一个可变的、索引的值集合。它提供了对随机访问的有效常数复杂度，而`Vector`则在这个操作中实现了有效常数时间。然而，与`Vector`相反，`Array`作为单个连续的内存块分配一次。此外，它不允许追加和预置操作。Scala的`Array`是用Java的`Array`实现的，这是内存优化的。Scala的`Array`比原生的Java`Array`更易于使用。当使用`Array`时，大多数在其他Scala集合上可用的方法都可用。隐式转换用于通过`ArrayOps`和`WrappedArray`增强`Array`。`ArrayOps`是`Array`的一个简单包装，用于暂时丰富`Array`，使其具有索引序列中找到的所有操作。在`ArrayOps`上调用的方法将产生一个`Array`。相反，从`Array`到`WrappedArray`的转换是永久的。在`WrappedArray`上调用转换器方法将产生另一个`WrappedArray`。我们可以在标准库文档中看到这一点，如下所示：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Having decided to use `Array` for our new module, we start working on the code
    to scale the features of each return series:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 决定为我们新的模块使用`Array`后，我们开始编写代码以缩放每个回报序列的特征：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A scaling vector is computed for a set of series. The first value of the vector
    is used to scale the first series, the second value for the second series, and
    so on. The scaling value is simply the greatest value in the series. We can now
    write the code to use the scaling vector and compute the normalized version of
    the frame:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为一组序列计算一个缩放向量。向量的第一个值用于缩放第一个序列，第二个值用于第二个序列，依此类推。缩放值是序列中的最大值。我们现在可以编写代码来使用缩放向量并计算框架的归一化版本：
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We zip each series with its scaling value, and create a new scaled return series.
    We can compare the presented version of the code using `Array` with another, almost
    identical, implementation using `Vector` (this code is omitted here for brevity,
    but it can be found in the source code attached to the book):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个序列与其缩放值压缩在一起，并创建一个新的缩放回报序列。我们可以比较使用`Array`呈现的代码版本与另一个几乎相同的、使用`Vector`实现的版本（为了简洁，此代码在此省略，但可以在附于书籍的源代码中找到）：
- en: '| **Benchmark** | **Series Size** | **Throughput in operations per second**
    | **Error as percentage of throughput** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **序列大小** | **每秒操作吞吐量** | **吞吐量误差百分比** |'
- en: '| `normalizeWithVector` | 60 | 101,116.50 | ± 0.85 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithVector` | 60 | 101,116.50 | ± 0.85 |'
- en: '| `normalizeWithArray` | 60 | 176,260.52 | ± 0.68 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 60 | 176,260.52 | ± 0.68 |'
- en: '| `normalizeWithVector` | 1,440 | 4,077.74 | ± 0.71 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithVector` | 1,440 | 4,077.74 | ± 0.71 |'
- en: '| `normalizeWithArray` | 1,440 | 7,865.85 | ± 1.39 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 1,440 | 7,865.85 | ± 1.39 |'
- en: '| `normalizeWithVector` | 28,800 | 282.90 | ± 1.06 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithVector` | 28,800 | 282.90 | ± 1.06 |'
- en: '| `normalizeWithArray` | 28,800 | 270.36 | ± 1.85 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 28,800 | 270.36 | ± 1.85 |'
- en: These results show that `Array` performs better than `Vector` for shorter series.
    As the size of the series increases, their respective performances are on-par.
    We can even see that the throughput is identical for a series containing 20 days
    of data (28,800 minutes). For larger sequences, the locality of `Vector` and its
    memory allocation model alleviate the difference with `Array`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，对于较短的序列，`Array`的性能优于`Vector`。随着序列大小的增加，它们的性能相当。我们甚至可以看到，对于包含20天数据（28,800分钟）的序列，吞吐量是相同的。对于更长的序列，`Vector`的局部性和其内存分配模型减轻了与`Array`的差异。
- en: 'Our implementation is idiomatic: it uses higher-order functions and immutable
    structures. However, using transform functions, such as `zip` and `map`, creates
    new instances of `Array`. An alternative is to leverage the mutable nature of `Array`
    to limit the amount of garbage generated by our program.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现是典型的：它使用高阶函数和不可变结构。然而，使用转换函数，如`zip`和`map`，会创建新的`Array`实例。另一种选择是利用`Array`的可变性质来限制程序产生的垃圾数量。
- en: Looping with the Spire cfor macro
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Spire的cfor宏循环
- en: 'Scala supports two loop constructs: the `for` loop and the `while` loop. The
    latter, in spite of its good performance characteristics, is usually avoided in
    functional programming. It requires the usage of mutable state and `var` to keep
    track of the looping condition. In this section, we will show you a technique
    to take advantage of `while` loop performance that prevents mutable references
    from leaking into application code.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Scala支持两种循环结构：`for`循环和`while`循环。尽管后者具有良好的性能特性，但在函数式编程中通常避免使用。它需要使用可变状态和`var`来跟踪循环条件。在本节中，我们将向您展示一种利用`while`循环性能的技术，以防止可变引用泄漏到应用程序代码中。
- en: Spire is a numeric library written for Scala that allows developers to write
    efficient numeric code. Spire leverages patterns, such as, type classes, macros,
    and specialization (remember specialization from [Chapter 3](ch03.html "Chapter 3. Unleashing
    Scala Performance"), *Unleashing Scala Performance*). You can learn more about
    Spire at [https://github.com/non/spire](https://github.com/non/spire).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Spire是一个为Scala编写的数值库，允许开发者编写高效的数值代码。Spire利用模式，如类型类、宏和特化（记得第三章中的特化，*释放Scala性能*）。您可以在[https://github.com/non/spire](https://github.com/non/spire)了解更多关于Spire的信息。
- en: 'One of the macros made available by Spire is `cfor`. Its syntax is inspired
    from the more traditional for loop that is encountered in Java. In the following
    implementation of feature scaling, we use the `cfor` macro to iterate over our
    series and normalize the values:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Spire提供的宏之一是`cfor`。其语法灵感来源于Java中更传统的for循环。在以下特征缩放实现的示例中，我们使用`cfor`宏遍历我们的序列并归一化值：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This example highlights that `cfor` macros can be nested. The macro is essentially
    syntactic sugar that compiles to a Scala `while` loop. We can examine the following
    generated bytecode to prove this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例表明`cfor`宏可以嵌套。该宏本质上是一种语法糖，编译为Scala的`while`循环。我们可以检查以下生成的字节码来证明这一点：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We notice the two `goto` statements, instructions `96` and `84`, which are
    used to loop back respectively to the beginning of the outer loop and the inner
    loop (which respectively begin with instructions `11` and `39`). We can run a
    benchmark of this new implementation to confirm the performance gain:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到两个`goto`语句，指令`96`和`84`，分别用于分别回到外循环和内循环的开始（分别从指令`11`和`39`开始）。我们可以运行这个新实现的基准测试来确认性能提升：
- en: '| **Benchmark** | **Series size** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **序列大小** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `normalizeWithArray` | 60 | 176,260.52 | ± 0.68 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 60 | 176,260.52 | ± 0.68 |'
- en: '| `normalizeWithCfor` | 60 | 256,303.49 | ± 1.33 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithCfor` | 60 | 256,303.49 | ± 1.33 |'
- en: '| `normalizeWithArray` | 1,440 | 7,865.85 | ± 1.39 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 1,440 | 7,865.85 | ± 1.39 |'
- en: '| `normalizeWithCfor` | 1,440 | 11,446.47 | ± 0.89 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithCfor` | 1,440 | 11,446.47 | ± 0.89 |'
- en: '| `normalizeWithArray` | 28,800 | 270.36 | ± 1.85 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithArray` | 28,800 | 270.36 | ± 1.85 |'
- en: '| `normalizeWithCfor` | 28,800 | 463.56 | ± 1.51 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `normalizeWithCfor` | 28,800 | 463.56 | ± 1.51 |'
- en: The macro, which is compiled to a while loop, is able to deliver better performance.
    Using the `cfor` construct, we are able to retain performance while avoiding the
    introduction of multiple vars. Although this approach sacrifices immutability,
    the scope of mutability is limited and less error-prone than an equivalent implementation
    using an imperative `while` or `for` loop.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏编译为while循环，能够提供更好的性能。使用`cfor`构造，我们能够在避免引入多个变量的情况下保持性能。尽管这种方法牺牲了不可变性，但可变性的范围有限，并且比使用命令式的`while`或`for`循环的等效实现更不易出错。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored and experimented with various collection implementations.
    We discussed the underlying representation, complexity, and use cases of each
    data structure. We also introduced a third-party library, Spire, to improve the
    performance of our programs. Some of the implementations presented drifted away
    from typical functional programming practices, but we were able to restrict the
    use of mutable state to internal modules, while still exposing functional public
    APIs. We expect that you are eager to learn more, but in the next chapter, we
    will become lazy! In contrast to this chapter, which focused on eager collections,
    we turn our attention to lazy collections in the next chapter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索并实验了各种集合实现。我们讨论了每种数据结构的底层表示、复杂性和用例。我们还引入了第三方库Spire，以提高我们程序的性能。一些实现偏离了典型的函数式编程实践，但我们能够将可变状态的使用限制在内部模块中，同时仍然公开函数式公共API。我们预计你渴望了解更多，但在下一章中，我们将变得懒惰！与本章专注于急切集合相比，我们将注意力转向下一章的懒集合。
