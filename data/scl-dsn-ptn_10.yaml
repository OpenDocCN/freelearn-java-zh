- en: Functional Design Patterns – the Deep Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式 – 深入理论
- en: 'The Scala programming language is a hybrid between a functional and object-oriented
    language. Most of the object-oriented design patterns are still applicable. However,
    in order to facilitate the full power of Scala, you also need to be aware of the
    purely functional aspects of it. When using the language and reading tutorials
    or best practices, developers will most likely notice terms such as **monoids**,
    **monads**, and **functors** appearing more often as the problems become harder
    or the solutions are desired to be more elegant. In this chapter, we will focus
    on the following functional design patterns:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编程语言是函数式和面向对象语言的混合体。大多数面向对象的设计模式仍然适用。然而，为了充分发挥Scala的威力，你还需要了解其纯函数式方面。当使用该语言和阅读教程或最佳实践时，开发者很可能会注意到，随着问题的复杂度增加或需要更优雅的解决方案时，**单例**、**单子**和**函子**等术语出现的频率更高。在本章中，我们将重点关注以下函数式设计模式：
- en: Monoids
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Functors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Monads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子
- en: There are a lot of resources on the preceding topics all over the internet.
    The problem is that many of them are extremely theoretical and hard to understand
    by someone who is not really familiar with mathematics, and more specifically,
    category theory. As it happens, in practice, many developers lack the deep mathematical
    background needed to grasp the topics, and it is not unusual to completely avoid
    these concepts in the code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上关于前面主题的资源很多。问题是许多内容都非常理论化，对于不熟悉数学，尤其是范畴论的人来说很难理解。实际上，许多开发者缺乏掌握这些主题所需的深厚数学背景，完全避免这些概念在代码中并不罕见。
- en: In my experience, most of the Scala developers I know have tried to read tutorials
    on the topics covered in this chapter, and they've found these topics difficult
    to understand and have given up. Expert mathematicians seem to find these concepts
    much easier. However, despite repeated attempts at understanding, most people
    admit that they are not completely comfortable with the deep functional programming
    theory. In this chapter, we will try and present this theory in a way that is
    easy to understand, and we will give an idea of how and when to apply the theory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我所认识的绝大多数Scala开发者都尝试阅读本章涵盖主题的教程，并且他们发现这些主题很难理解，并最终放弃了。专家数学家似乎觉得这些概念更容易理解。然而，尽管反复尝试理解，大多数人承认他们对深入函数式编程理论并不完全适应。在本章中，我们将尝试以一种易于理解的方式呈现这一理论，并给出如何以及何时应用这一理论的想法。
- en: Abstraction and vocabulary
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象和词汇
- en: A big part of programming is abstraction. We find common functionality, laws,
    and behavior and encapsulate them into classes, interfaces, functions, and so
    on, which are abstract and allow code reuse. Then, we refer to them and reuse
    them to minimize code duplication and the possibility of errors. Some of these
    abstractions are more common than others and are observed in different projects
    and used by more people. These abstractions lead to the creation of a common vocabulary,
    which additionally helps in communication and understanding. Everybody knows certain
    data structures such as trees and hash maps, and so there is no need to get into
    detail about them because their behavior and requirements are well-known. Similarly,
    when someone gains enough experience in design patterns, they can see them and
    easily apply the patterns to the problems they are trying to tackle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一大部分是抽象。我们找到常见的功能、法则和行为，并将它们封装到类、接口、函数中等，这些是抽象的，允许代码重用。然后，我们引用并重用它们以最小化代码重复和错误的可能性。其中一些抽象比其他更常见，并在不同的项目中观察到，被更多的人使用。这些抽象导致了一个共同词汇表的形成，这还额外有助于沟通和理解。每个人都知道某些数据结构，如树和哈希表，因此没有必要深入了解它们，因为它们的行为和需求是众所周知的。同样，当某人在设计模式方面有足够的经验时，他们可以很容易地看到它们，并将这些模式应用到他们试图解决的问题上。
- en: In this chapter, we will try to look at monoids, monads, and functors from a
    point of view that will teach us how to recognize them and when to use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试从一种将教会我们如何识别它们以及何时使用它们的角度来看待单例、单子（monads）和函子（functors）。
- en: Monoids
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: All monoids, monads, and functors are derived from mathematics. One thing about
    this subject is that similarly to programming, it tries to find abstractions.
    If we try to map mathematics to programming, we can think about the different
    datatypes we have—`Int`, `Double`, `Long`, or custom datatypes. Each type can
    be characterized by the operations it supports and the laws of these operations,
    and this is called the *algebra* of the type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有幺半群、单子（monads）和函子（functors）都源自数学。关于这个主题的一个特点是，与编程类似，它试图寻找抽象。如果我们试图将数学映射到编程，我们可以考虑我们拥有的不同数据类型——`Int`、`Double`、`Long`或自定义数据类型。每个类型都可以通过它支持的运算和这些运算的法则来表征，这被称为类型的**代数**。
- en: Now, if we think about it, we can identify the operations that are shared by
    multiple types, for example, addition, multiplication, subtraction, and so on.
    Different types can share the same operations and they can conform to exactly
    the same laws. This is something we can take advantage of because this allows
    us to write generic programs that apply to different types that follow some specific
    rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们仔细思考，我们可以识别出多个类型共有的运算，例如，加法、乘法、减法等等。不同的类型可以共享相同的运算，并且它们可以完全遵循相同的法则。我们可以利用这一点，因为这允许我们编写适用于遵循某些特定规则的不同类型的通用程序。
- en: What are monoids?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是幺半群？
- en: 'After the preceding brief introduction to monoids, let''s get straight to business
    and look at a formal definition of a *monoid*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在对幺半群进行前面的简要介绍之后，让我们直接进入正题，看看*幺半群*的正式定义：
- en: A monoid is a purely algebraic structure, which means that it is defined only
    by its algebra. All monoids must conform to the so-called **monoid laws**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是一个纯代数结构，这意味着它仅由其代数来定义。所有幺半群都必须遵循所谓的**幺半群公理**。
- en: The preceding definition is definitely not enough to have a good understanding
    of monoids, so let's break it into pieces in this section and try to come up with
    a better one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义绝对不足以对幺半群有一个好的理解，所以让我们在本节中将它分解成几个部分，并尝试给出一个更好的定义。
- en: 'First, let''s clarify the term **algebraic structure**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们明确一下术语**代数结构**：
- en: '**Algebraic**: It is defined only by its algebra, for example, the operations
    it supports and the laws it conforms to.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数性**：它仅由其代数来定义，例如，它支持的运算和它遵循的法则。'
- en: 'Now that we know that monoids are defined only by the operations they support,
    let''s have a look at the monoid laws:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，幺半群仅由它们支持的运算来定义，那么让我们来看看幺半群公理：
- en: A monoid contains a `T` type.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幺半群包含一个 `T` 类型。
- en: 'A monoid contains one associative binary operation. This means that for any
    `x`, `y`, and `z` of the `T` type, the following is true:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幺半群包含一个结合二元运算。这意味着对于 `T` 类型的任何 `x`、`y` 和 `z`，以下都是正确的：
- en: '`op(op(x, y), z) == op(x, op(y, z))`.'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`op(op(x, y), z) == op(x, op(y, z))`。'
- en: A structure must have an *identity element*—`zero`. This element is characterized
    by the fact that the previous operation will always return the other element—`op(x,
    zero) == x` and `op(zero, x) == x`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个结构必须有一个**单位元**——`零`。这个元素的特点是前一个运算总是返回另一个元素——`op(x, zero) == x` 和 `op(zero,
    x) == x`。
- en: 'Other than the preceding laws, different monoids might not have absolutely
    anything to do with each other—they can have any type. Now let''s look at a better
    definition of a monoid that would actually mean more to you as a developer:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的法则之外，不同的幺半群可能根本没有任何关系——它们可以是任何类型。现在让我们看看一个更好的幺半群的定义，这个定义对你作为开发者来说实际上更有意义：
- en: A monoid is a type with an associative binary operation over it, which also
    has an identity element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是一个具有结合二元运算的类型，它还有一个单位元。
- en: The monoid rules are extremely simple but they give us great power to write
    polymorphic functions based just on the fact that monoids always conform to the
    same rules. With the use of monoids, we can easily facilitate parallel computation
    and build complex calculations from small pieces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群规则非常简单，但它们给了我们极大的能力，仅基于幺半群总是遵循相同的规则这一事实来编写多态函数。使用幺半群，我们可以轻松地促进并行计算，并从小块构建复杂的计算。
- en: Monoids in real life
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的幺半群
- en: 'We use monoids all the time without realizing it—string concatenation, sums
    of integers, products, Boolean operations, lists, and so on—they are all examples
    of monoids. Let''s look at integer addition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用幺半群而没意识到——字符串连接、整数求和、乘积、布尔运算、列表等等，它们都是幺半群的例子。让我们看看整数加法：
- en: '**Our type**: `Int`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的类型**：`Int`。'
- en: '**Our associative operation**: `add`. It is indeed associative because `((1
    + 2) + 3) == (1 + (2 + 3))`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的结合运算**：`add`。它确实是结合的，因为 `((1 + 2) + 3) == (1 + (2 + 3))`。'
- en: '**Our identity element**: `0`. It does nothing when added to another integer.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的单位元素**：`0`。当它被添加到另一个整数时，什么也不做。'
- en: We can easily come up with similar examples for string concatenation, where
    the identity element will be an empty string, or for list concatenation, where
    the identity element will be an empty list, and many others. Similar examples
    can be found absolutely everywhere.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地找到类似的例子，例如字符串连接，其中单位元素将是一个空字符串，或者列表连接，其中单位元素将是一个空列表，以及其他许多例子。类似的例子可以在任何地方找到。
- en: 'Everything we mentioned previously takes us to the following Scala representation
    of a monoid:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的所有内容都引出了以下Scala单例表示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Starting from this base trait, we can define just about any monoid we want.
    The following are a few implementations of a integer addition monoid, integer
    multiplication monoid, and a string concatenation monoid:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基础特质开始，我们可以定义我们想要的任何单例。以下是一些整数加法单例、整数乘法单例和字符串连接单例的实现：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the same framework as shown previously, we can define monoids for as many
    different types as we can think of, as long as they always satisfy the rules.
    However, you should note that not every operation follows the monoid rules. For
    example, integer division—`(6/3)/2 != 6/(3/2)`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前展示的相同框架，我们可以为尽可能多的不同类型定义单例，只要它们始终满足规则。然而，你应该注意，并非每个操作都遵循单例规则。例如，整数除法—`(6/3)/2
    != 6/(3/2)`。
- en: We saw how to write monoids. But how do we use them? What are they helpful for
    and can we just write generic functions based only on the rules we know? Of course
    we can, and we will see this in the following subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何编写单例。但我们是怎样使用它们的？它们有什么用，我们能否仅基于我们知道的规则编写通用函数？当然可以，我们将在以下小节中看到这一点。
- en: Using monoids
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单例
- en: In the preceding section, we already mentioned that monoids can be used for
    parallel computation and to build complex computations using small and simple
    chunks. Monoids can also be naturally used with lists and collections, in general.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经提到单例可以用于并行计算，以及使用小块和简单的计算构建复杂计算。单例也可以与列表和集合自然地结合使用。
- en: In this subsection, we will look at different use cases with examples for monoids.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将通过示例查看单例的不同用例。
- en: Monoids and foldable collections
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和可折叠集合
- en: 'To show how useful monoids are with collections that support the `foldLeft`
    and `foldRight` functions, let''s take a look at the standard Scala list and the
    declarations of these two functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示单例与支持`foldLeft`和`foldRight`函数的集合的有用性，让我们看看标准的Scala列表和这两个函数的声明：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Usually, the `z` parameter in these two functions is called the `zero` value,
    so if `A` and `B` are of the same type, we will end up with the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这两个函数中的`z`参数被称为`zero`值，所以如果`A`和`B`是同一类型，我们最终会得到以下结果：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking at the functions now, we can see that these are exactly monoid rules.
    This means that we can write an example as shown in the following code, which
    uses the monoids we created previously:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这些函数，我们可以看到这些正是单例规则。这意味着我们可以编写一个示例，如下面的代码所示，该代码使用了我们之前创建的单例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another thing to note in the preceding code is that it doesn't actually matter
    for the final result whether we use `foldLeft` or `foldRight` because our monoids
    have an associative operation. It does, however, matter in terms of performance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，还有一点需要注意，即对于最终结果来说，我们使用`foldLeft`还是`foldRight`并不重要，因为我们的单例具有结合操作。然而，在性能方面，这确实很重要。
- en: 'The output of the preceding example is as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的输出如下所示：
- en: '![](img/7686cb64-3b96-44cb-849d-1d0da21aad98.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7686cb64-3b96-44cb-849d-1d0da21aad98.png)'
- en: 'Looking at the preceding example, you can see that we can write a generic function
    that will fold a list using a monoid and do different things depending on the
    monoid operation. Here is the code for it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的例子，你可以看到我们可以编写一个通用函数，该函数将使用单例折叠列表，并根据单例操作执行不同的操作。以下是该函数的代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now rewrite our example and use our generic function as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重写我们的示例并使用我们的通用函数如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output, of course, will be exactly the same. However, things are much neater
    now, and this is how monoids can become useful when used together with lists.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出将完全相同。然而，现在事情要整洁得多，这就是当与列表一起使用时，单例可以变得有用的原因。
- en: 'In the preceding examples, we made the `A` and `B` types to be the same in
    the `foldLeft` and `foldRight` functions. However, we might build a different
    data structure with a different type, or our algorithm might rely on a different
    type that has a different monoid to the type of the list we have. In order to
    support such a scenario, we have to add the possibility of mapping the type of
    the original list to a different type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`foldLeft`和`foldRight`函数中将`A`和`B`类型设为相同。然而，我们可能使用不同的类型构建不同的数据结构，或者我们的算法可能依赖于具有不同单例的类型，而不是我们拥有的列表类型。为了支持这种场景，我们必须添加将原始列表类型映射到不同类型的可能性：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code shows how our fold functions will change. This would give
    us the possibility of implementing even more complex operations on top of our
    lists using different types of monoids.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了我们的折叠函数将如何改变。这将给我们提供在列表上使用不同类型的单例实现更复杂操作的可能性。
- en: Monoids and parallel computations
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和并行计算
- en: 'The fact that a monoid operation is associative means that if we have to chain
    multiple operations, we could probably do it in parallel. For example, if we have
    the numbers `1`, `2`, `3`, and `4` and wanted to find `4!`, we can use what we
    used previously, which would end up being evaluated to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单例操作的结合性意味着如果我们必须链式多个操作，我们可能可以在并行中进行。例如，如果我们有数字`1`、`2`、`3`和`4`，并且想要找到`4!`，我们可以使用之前使用的方法，这将最终被评估为以下内容：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The associativity, however, would allow us to do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结合性将允许我们做以下事情：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, the nested operations could be done independently and in parallel. This
    is also called **balanced fold**. An implementation of a balanced fold would look
    like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，嵌套操作可以独立且并行地进行。这也被称为**平衡折叠**。一个平衡折叠的实现可能如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is worth mentioning that we've used an `IndexedSeq` here, as it will guarantee
    that getting elements by index will be efficient. Also, this code is not parallel,
    but we've switched the order of the operations as we mentioned previously. In
    the case of integers, it might not make much of a difference but for other types
    such as strings, it will improve the performance. The reason is that strings are
    immutable and every concatenation will create a new string by allocating new space.
    So, if we are simply going from the left-hand side to the right-hand side, we
    will be allocating more and more space and throwing away the intermediate results
    all the time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这里我们使用了`IndexedSeq`，因为它将保证通过索引获取元素将是高效的。此外，这段代码不是并行的，但我们已经按照之前提到的顺序改变了操作顺序。对于整数来说，这可能不会有太大的区别，但对于其他类型，如字符串，这将提高性能。原因是字符串是不可变的，每次连接都会通过分配新的空间来创建一个新的字符串。因此，如果我们只是从左侧到右侧进行操作，我们将不断分配更多的空间，并且总是丢弃中间结果。
- en: 'The next code listing shows how to use our `balancedFold` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例展示了如何使用我们的`balancedFold`函数：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/5334da2c-125d-4bd3-a363-e82e973f12a4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5334da2c-125d-4bd3-a363-e82e973f12a4.png)'
- en: There are a few ways to make this code parallel. The hard way would involve
    quite a lot of extra code writing in order to manage threads, and it is really
    advanced. It probably deserves a chapter (if not an entire book) of its own, and
    we will just mention it for the more curious readers—*purely functional parallelism*.
    There are some materials on GitHub ([https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism](https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism))
    that cover this concept nicely with examples.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使此代码并行化有几种方法。困难的方法将涉及编写大量的额外代码来管理线程，这非常高级。这可能值得一个章节（如果不是整本书），我们只是为更好奇的读者提及——*纯函数式并行性*。GitHub上（[https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism](https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism)）有一些材料，通过示例很好地介绍了这个概念。
- en: 'We can also use the `par` method that most Scala collections have. Due to the
    laws that monoids conform to, we are guaranteed to always get the correct results,
    no matter how the underlying collections are parallelized. The following listing
    shows example implementations of our fold methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用大多数Scala集合都有的`par`方法。由于单例遵守的定律，我们可以保证无论底层集合如何并行化，我们总能得到正确的结果。下面的列表展示了我们折叠方法的示例实现：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only difference between these methods and what we had before is the call
    to `par` before we use `foldLeft`. Using the methods is exactly the same as we
    did previously:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的方法相比，这两种方法的唯一区别是在使用`foldLeft`之前调用了`par`。使用这些方法与之前的方法完全相同：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you would expect, the result here would be exactly the same as it was for
    the sequential example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，这里的输出将与顺序示例中的输出完全相同。
- en: Monoids and composition
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幺半群和组合
- en: 'So far, we have seen some examples where monoids are used to improve efficiency
    and write generic functions. They, however, are even more powerful. The reason
    is that they follow another useful rule:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些例子，其中幺半群被用来提高效率并编写通用函数。然而，它们的功能更强大。原因在于它们遵循另一个有用的规则：
- en: Monoids support *composition*; if `A` and `B` are monoids, then their product
    `(A, B)` is also a monoid.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群支持*组合*；如果`A`和`B`是幺半群，那么它们的乘积`(A, B)`也是一个幺半群。
- en: 'What does this mean exactly and how can we take advantage of this? Let''s look
    at the following function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这究竟意味着什么？我们如何利用这一点？让我们看看以下函数：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we showed a function that applies the composition exactly
    as we mentioned in our definition. This would now allow us to simultaneously apply
    multiple operations using a monoid, and we can compose even more and apply even
    more operations. Let''s see an example that will calculate the sum and the factorial
    of the numbers given to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了如何按照我们的定义应用组合函数。这将现在允许我们同时使用幺半群应用多个操作，我们可以组合更多，并应用更多操作。让我们看看以下示例，它将计算给定数字的和与阶乘：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we took advantage of the `map` function as well because
    our new monoid expects a tuple of integers rather than just the single integers
    we have in our array. Running the example will yield the following result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们利用了`map`函数，因为我们的新幺半群期望一个整数元组，而不是我们数组中只有一个整数。运行这个例子将产生以下结果：
- en: '![](img/4e95b3b7-ec3c-4c42-989c-5ca1612402d5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e95b3b7-ec3c-4c42-989c-5ca1612402d5.png)'
- en: The preceding `compose` function is really powerful, and we can do a lot of
    things with it. We can also efficiently calculate the mean of all items in a list—we
    just need to use the `intAddition` monoid twice and map the numbers to `(number,
    1)` in order to have the count together with the sum.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`compose`函数功能非常强大，我们可以用它做很多事情。我们还可以高效地计算列表中所有项的平均值——我们只需要使用`intAddition`幺半群两次，并将数字映射到`(number,
    1)`，以便将计数和总和一起考虑。
- en: So far, we have seen how to compose monoids with operations. However, monoids
    are quite useful for building data structures as well. Data structures can also
    form monoids as long as their values also form monoids.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何通过操作来组合幺半群。然而，幺半群在构建数据结构方面也非常有用。只要它们的值也形成幺半群，数据结构也可以形成幺半群。
- en: Let's go through an example. In machine learning, we might need to extract the
    features from some text. Then, each feature will be weighted using a coefficient
    and a number equal to the number of times we've seen it. Let's try and get to
    a monoid that can be used to fold a collection and give us what we need—the count
    of each feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来讲解。在机器学习中，我们可能需要从某些文本中提取特征。然后，每个特征将使用一个系数和出现次数的数值进行加权。让我们尝试找到一个可以折叠集合并给出所需结果的幺半群——即每个特征的计数。
- en: First of all, it is clear that we will be counting how many times we see each
    feature. Building a map of features to be counted sounds like a good idea! We
    will be incrementing the count for a feature every time we see it. So, if we imagine
    that each element in our feature list becomes a map of one element, we will have
    to fold these maps and use our integer sum monoid to sum the values for the same
    keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，很明显我们将计算每个特征出现的次数。构建一个要计数的特征的映射听起来是个好主意！每次我们看到一个特征时，我们都会增加其计数。所以，如果我们想象我们的特征列表中的每个元素都变成一个包含一个元素的映射，我们就必须折叠这些映射，并使用我们的整数求和幺半群来对相同键的值进行求和。
- en: 'Let''s build a function that can return a monoid, which can be used to fold
    items into a map and will apply any monoid to the values of the same key of the
    map:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个函数，它可以返回一个幺半群，该幺半群可以用于将项目折叠到映射中，并将任何幺半群应用于映射中相同键的值：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now use this monoid to do different aggregations—sums, multiplications,
    concatenations, and so on. For our features counting, we will have to use sums
    and here is how we''ve done it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个幺半群来进行不同的聚合操作——求和、乘法、连接等。对于我们的特征计数，我们将不得不使用求和，以下是我们的实现方法：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding program will be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的输出将如下所示：
- en: '![](img/97ebe6ad-1973-4819-956a-5c689477ea5a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97ebe6ad-1973-4819-956a-5c689477ea5a.png)'
- en: The `mapMerge` function that we defined previously can now take any monoid,
    and we can even easily create maps of maps and so on, without extra code writing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的`mapMerge`函数现在可以接受任何单子，我们甚至可以轻松地创建映射的映射等，而无需额外的代码编写。
- en: When to use monoids
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用单子
- en: 'In the preceding examples, we showed how to use monoids in order to achieve
    certain things. However, if we look at the previous example, we could simplify
    it in the following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们展示了如何使用单子来实现某些功能。然而，如果我们看看前面的例子，我们可以以以下方式简化它：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In fact, each example could be rewritten to a representation similar to the
    preceding code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个例子都可以重写为类似于前面代码的表示形式。
- en: While someone might be tempted to do things this way, it might not always be
    scalable. As we already mentioned, the purpose of monoids is to actually allow
    us to write generic and reusable code. With the help of monoids, we can focus
    on simple operations and then just compose them together rather than build concrete
    implementations for everything we want. It might not be worth it for one-off functions,
    but using monoids would definitely have a positive effect when we are reusing
    functionality. Moreover, as you already saw, composition here is extremely easy,
    and with time it will save us from writing a huge amount of code (read less code
    duplication and possibilities to introduce bugs).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有人可能会倾向于这样做，但这可能并不总是可扩展的。正如我们之前提到的，单子的目的是实际上允许我们编写通用和可重用的代码。借助单子，我们可以专注于简单的操作，然后只需将它们组合在一起，而不是为所有我们想要的每一件事都构建具体的实现。对于一次性函数来说，这可能不值得，但使用单子肯定会在我们重用功能时产生积极的影响。此外，正如你之前看到的，这里的组合非常简单，随着时间的推移，它将帮助我们避免编写大量的代码（减少代码重复和引入错误的可能性）。
- en: Functors
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: A **functor** is one of those terms that comes from category theory in mathematics
    and causes a lot of pain to developers who come into functional programming and
    have less of a mathematical background. It is a requirement for monads, and here
    we will try to explain it in a way that will be easy to understand.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**函子**是那些来自数学范畴论术语之一，对于数学背景较少的开发者在接触函数式编程时可能会造成很多困扰。它是单子的一个要求，在这里我们将尝试以一种易于理解的方式解释它。'
- en: What is a functor? In the preceding section, we looked at monoids as a way to
    abstract some computation and then used them in different ways for optimization
    or to create more complex computations. Even though some people might not agree
    with the correctness of this approach, let's look at functors from the same point
    of view—something that will abstract some specific computations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是函子？在前一节中，我们研究了单子作为抽象某些计算的方法，然后以不同的方式使用它们进行优化或创建更复杂的计算。尽管有些人可能不同意这种方法的正确性，但让我们从相同的角度来看待函子——它将抽象某些特定的计算。
- en: In Scala, a functor is a class that has a  `map` method and conforms to a few
    laws. Let's call them **functor laws**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，一个函子是一个具有`map`方法并符合几条公理的类。我们可以称它们为**函子公理**。
- en: The `map` method for a functor of the `F[T]` type takes a function from `T`
    to `Y` as a parameter and returns a `F[Y]` as a result. This will become much
    clearer in the next subsection, where we will show some actual code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`F[T]`类型的函子的`map`方法接受一个从`T`到`Y`的函数作为参数，并返回一个`F[Y]`作为结果。这将在下一小节中变得更加清晰，我们将展示一些实际的代码。'
- en: 'Functors also obey some functor laws:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函子也遵循一些函子公理：
- en: '**Identity**: Whenever the `identity` function is mapped over some data, it
    doesn''t change it, in other words, `map(x)(i => i) == x`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等性**：当`identity`函数映射到某些数据上时，它不会改变它，换句话说，`map(x)(i => i) == x`。'
- en: '**Composition**: Multiple maps must compose together. It should make no difference
    if we do this operation: `map(map(x)(i => y(i)))(i => z(i))` or `map(x)(i => z(y(i)))`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合性**：多个映射必须组合在一起。如果我们这样做操作：`map(map(x)(i => y(i)))(i => z(i))`或`map(x)(i
    => z(y(i)))`，结果应该没有区别。'
- en: The `map` function preserves the structure of the data, for example, it does
    not add or remove elements, change their order, and so on. It just changes the
    representation.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`函数保留数据的结构，例如，它不会添加或删除元素，改变它们的顺序等。它只是改变表示形式。'
- en: The preceding laws give developers some grounds to assume certain things when
    performing different computations. For example, we can now safely postpone different
    mappings of data in time or just do them all together, and be sure that the final
    result will be the same.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的法则为开发者提供了在进行不同计算时假设某些事情的基础。例如，我们现在可以安全地推迟对数据的不同映射，或者一次性完成它们，并确信最终的结果将是相同的。
- en: From what we mentioned previously, we can actually come up with the conclusion
    that functors set a specific set of laws on their operations (`map`, in this case)
    that must be in place and allow us to automatically reason about their results
    and effects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前提到的内容中，我们可以得出结论，函子为其操作（在这种情况下是`map`）设定了一组特定的法则，这些法则必须就位，并允许我们自动推理其结果和效果。
- en: Now that we have a definition for functors and we showed the laws they should
    follow, in the next subsection we can create a base trait that all functors will
    be able to extend.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为函子定义了一个概念，并展示了它们应遵循的法则，在下一小节中，我们可以创建一个所有函子都可以扩展的基本特质。
- en: Functors in real life
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的函子
- en: Before we show an example functor trait based on the laws we showed in the preceding
    section, you can conclude that standard Scala types such as `List`, `Option`,
    and others that define a `map` method are functors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示基于前一小节中展示的法则的示例函子特质之前，您可以得出结论，标准Scala类型如`List`、`Option`等定义了`map`方法的类型都是函子。
- en: The `map` method in the built-in Scala types such as `List` has a different
    signature from the example we show here. In our examples, the first parameter
    is the functor and the second one is the transformation function we apply to it.
    In the standard Scala types, the first parameter doesn't need to be passed, as
    it is the actual object we're calling it on (`this`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 内置Scala类型如`List`中的`map`方法与我们这里展示的示例有不同的签名。在我们的示例中，第一个参数是函子，第二个参数是我们应用到的转换函数。在标准Scala类型中，第一个参数不需要传递，因为它是我们实际调用的对象（`this`）。
- en: 'If we want to create our own types that follow the functor laws, we can create
    a base trait and make sure to implement it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建遵循函子法则的自定义类型，我们可以创建一个基本特质并确保实现它：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s create a list functor that will simply call the `map` function
    of the Scala `List`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的列表函子，它将简单地调用Scala `List`的`map`函数：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, the fact that an object is a functor simply allows us
    to assume that certain laws are in place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个对象是函子的这一事实仅仅允许我们假设某些法则已经就位。
- en: Using our functors
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的函子
- en: 'A simple example of using our `listFunctor` that we defined in the preceding
    section can be seen as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前定义的`listFunctor`的一个简单例子如下：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding example is shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的输出显示在下述屏幕截图：
- en: '![](img/2fcaad83-9593-40b8-bebd-d780b83c09f3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fcaad83-9593-40b8-bebd-d780b83c09f3.png)'
- en: As you can see, functors don't really do much by themselves. They are not exciting
    at all. However, they set some specific rules that help us understand the results
    from specific operations. This means that we can define methods based on the abstract
    `map` inside the `Functor` trait, which rely on the rules we've stated previously.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函子本身并不真正做很多事情。它们一点也不令人兴奋。然而，它们设定了一些特定的规则，帮助我们理解特定操作的结果。这意味着我们可以在`Functor`特质内部的抽象`map`方法上定义方法，这些方法依赖于我们之前声明的规则。
- en: Functors are an important concept that are required for monads, which we will
    look at in the following subsection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是一个重要的概念，对于单子（monads）来说是必需的，我们将在下一小节中探讨。
- en: Monads
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: In the preceding section, we defined functors. With their `map` methods, the
    standard Scala collections seem to be good examples of functors. We should, however,
    emphasize again that a functor doesn't mean a collection—it can be a container
    and any custom-defined class. Based on an abstract `map` method and the rules
    it follows, we can define other functions that will help us reduce code duplication.
    However, there are not many exciting things we can do based on a mapping only.
    In our programs, we will have different operations, some of which not only transform
    a collection or an object, but also modify it in some way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一小节中，我们定义了函子。通过它们的`map`方法，标准的Scala集合似乎是函子的好例子。然而，我们再次强调，函子并不意味着集合——它可以是容器和任何自定义类。基于一个抽象的`map`方法和它遵循的规则，我们可以定义其他函数，这些函数将帮助我们减少代码重复。然而，基于映射本身，我们并不能做很多令人兴奋的事情。在我们的程序中，我们将有不同的操作，其中一些不仅会转换集合或对象，还会以某种方式修改它们。
- en: Monads are another one of those scary terms that come from category theory,
    which we will try to explain in a way that you will be able to easily understand,
    identify, and use in your daily routine as a developer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是来自范畴论的那些令人畏惧的术语之一，我们将尝试以一种你能够轻松理解、识别并在作为开发者的日常工作中使用的方式解释它。
- en: What is a monad?
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单子？
- en: We already talked about laws earlier in this chapter. The monoid is defined
    based on some laws it follows, and these laws allow us to implement generic functionality
    with certainty, just because we expect certain conditions to hold. If a law is
    broken, then there is no way for us to know for sure what to expect in terms of
    how something will behave. In such cases, things would most probably end up returning
    wrong results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经讨论过法律了。单子是基于它遵循的一些法律来定义的，这些法律允许我们以确定性实现通用功能，仅仅因为我们期望某些条件成立。如果法律被违反，我们就无法确定地知道在某种行为方面可以期待什么。在这种情况下，事情很可能会以错误的结果结束。
- en: 'Similar to the other concepts we already saw in this chapter, monads are defined
    in terms of the laws they follow. In order for a structure to be considered a
    monad, it must satisfy all the rules. Let''s start with a short definition, which
    we will expand on later:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中我们已经看到的其他概念类似，单子是在它们遵循的法律的术语中定义的。为了使一个结构被认为是单子，它必须满足所有规则。让我们从一个简短的定义开始，我们稍后会对其进行扩展：
- en: Monads are functors that have the `unit` and `flatMap` methods and follow the
    **monad rules**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是具有 `unit` 和 `flatMap` 方法并遵循 **单子规则** 的函子。
- en: So, what does the preceding definition mean? First of all, it means that monads
    follow all the rules we previously defined about functors. Additionally, they
    take things further and add support for two more methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，前面的定义意味着什么呢？首先，这意味着单子遵循我们之前定义的所有关于函子的规则。此外，它们更进一步，并添加了对两个更多方法的支持。
- en: The flatMap method
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flatMap 方法
- en: 'Before we formally define the rules, let''s have a brief discussion about `flatMap`.
    We assume that you are familiar with Scala collections and are aware of the existence
    of the `flatten` method. So, just the name of `flatMap` tells us that it maps
    and then flattens, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式定义规则之前，让我们先简要讨论一下 `flatMap`。我们假设你已经熟悉 Scala 集合，并且知道存在 `flatten` 方法。所以，`flatMap`
    的名字本身告诉我们它会先映射然后扁平化，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We don''t have the monad definition we referred to in the preceding code yet,
    but that''s fine. We will get there. For now, let''s just look at it as another
    generic parameter. You should also know that `flatten` has the following declaration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在前面代码中提到的单子定义，但那没关系。我们很快就会到达那里。现在，让我们把它看作另一个通用参数。你还应该知道 `flatten` 有以下声明：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For example, if `F` is actually a `List`, `flatten` will convert a list of lists
    into a simple list of whatever the type of the internal one is. If `F` is an `Option`,
    then the ones with the `None` value in the nested option will disappear and the
    rest will remain. These two examples show us that the `flatten` result actually
    depends on the specifics of the type being flattened, but in any case, it is clear
    how it transforms our data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `F` 实际上是一个 `List`，`flatten` 将将列表的列表转换成一个简单的列表，其类型与内部列表的类型相同。如果 `F` 是一个
    `Option`，那么嵌套选项中的 `None` 值将消失，其余的将保留。这两个例子表明，`flatten` 的结果实际上取决于被扁平化的类型的特定情况，但在任何情况下，它如何转换我们的数据都是清晰的。
- en: The unit method
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子的 unit 方法
- en: 'The other method we mentioned previously is `unit`. It actually doesn''t matter
    how this method is called and it could be different for different languages based
    on their standards. What is important is its functionality. The signature of `unit`
    can be written in the following way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的另一个方法是 `unit`。实际上，这个方法叫什么并不重要，它可能根据不同语言的标准而不同。重要的是它的功能。`unit` 的签名可以写成以下方式：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What does the preceding line mean? It is pretty simple—it takes a value of
    the `T` type and turns it into a monad of the `T` type. This is nothing more than
    a single argument constructor or just a factory method. In Scala, this can be
    expressed using a companion object with an `apply` method as well. As long as
    it does the right thing, the implementation doesn''t really matter. In Scala,
    we have many of the collection types as examples—`List`, `Array`, `Seq`—they all
    have an `apply` method that supports the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行是什么意思？这很简单——它将`T`类型的值转换为`T`类型的单子。这不过是一个单参数构造函数或只是一个工厂方法。在Scala中，这可以通过具有`apply`方法的伴随对象来表示。只要它做正确的事情，实现并不真正重要。在Scala中，我们有许多集合类型作为例子——`List`、`Array`、`Seq`——它们都有支持以下内容的`apply`方法：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The connection between map, flatMap, and unit
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map、flatMap和unit之间的联系
- en: 'In the preceding section, we showed how `flatMap` can be defined using `map`
    and `flatten`. We can, however, take a different approach and define `map` using
    `flatMap`. Here is what the definition would look like in our pseudo code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们展示了如何使用`map`和`flatten`来定义`flatMap`。然而，我们可以采取不同的方法，并使用`flatMap`来定义`map`。以下是我们伪代码中的定义：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding definition is important because it draws the relationship between
    all the `map`, `flatMap`, and `unit` methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义很重要，因为它描绘了所有`map`、`flatMap`和`unit`方法之间的关系。
- en: Depending on what kind of monads we implement, it could sometimes be easier
    to implement `map` first (usually, if we build collection-like monads) and then
    `flatMap` based on it and `flatten`, while other times it could be easier to first
    implement
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们实现哪种类型的单子，有时先实现`map`可能更容易（通常如果我们构建类似集合的单子），然后基于它和`flatten`实现`flatMap`，而有时先实现
- en: '`flatMap` instead. As long as the monad laws are satisfied, it shouldn''t matter
    which approach we take.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`。只要满足单子法则，我们采取的方法就不重要。'
- en: The names of the methods
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法的名称
- en: 'In the preceding section, we mentioned that it doesn''t actually matter how
    the `unit` method is called. While it is true for `unit` and it could be propagated
    to any of the other methods, it is recommended that `map` and `flatMap` actually
    remain this way. It doesn''t mean that it is not possible to make things work,
    but following common conventions would make things much simpler. Moreover, `map`
    and `flatMap` give us something extra—the possibility of using our classes in
    *for comprehensions*. Consider the following example, which is only here to illustrate
    how having methods with such names helps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到实际上调用`unit`方法的方式并不重要。虽然这对于`unit`来说是正确的，并且这可以传播到任何其他方法，但建议`map`和`flatMap`实际上保持这种方式。这并不意味着不可能让事情工作，但遵循通用约定会使事情变得简单得多。此外，`map`和`flatMap`给我们带来了额外的功能——使用我们的类在*for推导式*中的可能性。考虑以下示例，它只是为了说明具有此类名称的方法如何帮助：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we just wrap a list in an object and define the `map`
    and `flatMap` methods. If we didn''t have the preceding object, we could have
    written something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是在一个对象中包装了一个列表，并定义了`map`和`flatMap`方法。如果我们没有前面的对象，我们可以写点像这样的事情：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With our wrapper object, we could do the same as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的包装对象，我们可以这样做：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Both applications do the same and will have exactly the same output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 两次应用都做同样的事情，并将产生完全相同的输出：
- en: '![](img/d4083777-2904-4438-b4d5-495ac7548c79.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4083777-2904-4438-b4d5-495ac7548c79.png)'
- en: What the second application uses, however, is the fact that our wrapper class
    contains methods specifically with the names such as `map` and `flatMap`. If we
    rename any of them, we would get a compilation error—we could still manage to
    write the same code but it will not be able to use syntactic sugar in Scala. Another
    point here is that the *for comprehension* would work correctly in the case where
    both the methods actually follow the rules for `map` and `flatMap`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二次应用使用的是我们的包装类包含具有`map`和`flatMap`等名称的特定方法的事实。如果我们重命名任何一个，我们就会得到一个编译错误——我们仍然可以写出相同的代码，但将无法在Scala中使用语法糖。另一个要点是，*for推导式*将正确地在两个方法实际上遵循`map`和`flatMap`规则的情况下工作。
- en: The monad laws
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子法则
- en: 'After going a bit through the methods a monad is supposed to support, now we
    can formally define the monad laws. You already saw that monads are functors and
    they follow the functor laws. Being explicit is always better, so here we will
    mix the laws together:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一元组应该支持的方法进行了一些了解之后，现在我们可以正式定义一元组的定律。你已经看到一元组是函子，并且遵循函子定律。明确总是更好的，所以在这里我们将混合这些定律：
- en: '**Identity law**: Doing `map` over the identity function doesn''t change the
    data—`map(x)(i => i) == x`. Flat mapping over the `unit` function also keeps the
    data the same—`x.flatMap(i => unit(i)) == x`. The latter basically says that `flatMap`
    undoes `unit`. Using the connection between `map`, `flatMap`, and `unit` we defined
    earlier, we can derive one of these two rules from the other and vice versa. The
    `unit` method can be thought of as the zero element in monoids.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等定律**：对恒等函数进行`map`操作不会改变数据——`map(x)(i => i) == x`。对`unit`函数进行扁平映射也会保持数据不变——`x.flatMap(i
    => unit(i)) == x`。后者基本上说`flatMap`是`unit`的逆操作。使用我们之前定义的`map`、`flatMap`和`unit`之间的联系，我们可以从其中一个规则推导出另一个规则，反之亦然。`unit`方法可以被认为是幺半群中的零元素。'
- en: '**The unit law**: From the definition of `unit`, we can also say this: `unit(x).flatMap
    { y => f(y) } == f(x)`. From this, we will get `unit(x).map { y => f(x) } == unit(f(x))`.
    This gives us some interesting connections between all the methods.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单位定律**：从`unit`的定义中，我们也可以说：`unit(x).flatMap { y => f(y) } == f(x)`。从这个定义中，我们将得到`unit(x).map
    { y => f(x) } == unit(f(x))`。这给我们提供了一些有趣的方法之间的联系。'
- en: '**Composition**: Multiple maps must be composed together. It should make no
    difference if we do `x.map(i => y(i)).map(i => z(i))` or `x.map(i => z(y(i)))`.
    Moreover, multiple `flatMap` calls must also compose, making the following true:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：多个映射必须组合在一起。如果我们做`x.map(i => y(i)).map(i => z(i))`或`x.map(i => z(y(i)))`，应该没有区别。此外，多个`flatMap`调用也必须组合，使得以下成立：'
- en: '`x.flatMap(i => y(i)).flatMap(i => z(i)) == x.flatMap(i => y(i).flatMap(j =>
    z(j)))`.'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`x.flatMap(i => y(i)).flatMap(i => z(i)) == x.flatMap(i => y(i).flatMap(j =>
    z(j)))`。'
- en: 'Monads, similarly to monoids, also have a zero element. Some real-world examples
    of monadic zeros are `Nil` in the Scala List and the `None` option. However, here
    we can also have multiple zero elements, which are represented by an algebraic
    datatype with a constructor parameter to which we can pass different values. In
    order to be complete, we might not have zeros at all if there is no such concept
    for the monads we are modeling. In any case, the zero monad represents some kind
    of emptiness and follows some extra laws:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于幺半群，一元组也有一个零元素。一些实际的零一元组例子有Scala列表中的`Nil`和`None`选项。然而，我们也可以有多个零元素，这些元素由一个代数数据类型表示，该类型有一个构造函数参数，我们可以向它传递不同的值。为了完整，如果我们所建模的一元组没有这样的概念，我们可能根本不会有零元素。无论如何，零一元组代表某种空缺，并遵循一些额外的定律：
- en: '**Zero identity**: This one is pretty straightforward. It says that no matter
    what function we apply to a zero monad, it is still going to be zero—`zero.flatMap(i
    => f(i)) == zero` and `zero.map(i => f(i)) == zero`. `Zero` shouldn''t be confused
    with `unit`, as they are different and the latter doesn''t represent emptiness.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零恒等律**：这一点相当直接。它说无论我们应用什么函数到零一元组，它仍然将是零——`zero.flatMap(i => f(i)) == zero`和`zero.map(i
    => f(i)) == zero`。`Zero`不应该与`unit`混淆，因为它们是不同的，后者不表示空缺。'
- en: '**Reverse zero**: This is straightforward as well. Basically, if we replace
    everything with zero, our final result will also be zero—`x.flatMap(i => zero)
    == zero`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆零**：这一点也很直接。基本上，如果我们用零替换一切，我们的最终结果也将是零——`x.flatMap(i => zero) == zero`。'
- en: '**Commutativity** : Monads can have a concept of addition, whether it is concatenation
    or something else. In any case, this kind of operation when done with the zero
    monad will be commutative, for example, `x plus zero == zero plus x == x`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换律**：一元组可以有一个加法概念，无论是连接还是其他什么。无论如何，这种操作与零一元组一起进行时将是交换的，例如，`x plus zero ==
    zero plus x == x`。'
- en: Monads and side effects
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一元组和副作用
- en: 'When presenting the composition law, we kind of assumed that an operation has
    no side effects. We said the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当展示组合定律时，我们假设操作没有副作用。我们说了以下内容：
- en: '`x.map(i => y(i)).map(i => z(i)) == x.map(i => z(y(i)))`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`x.map(i => y(i)).map(i => z(i)) == x.map(i => z(y(i)))`。'
- en: However, let's now think about what would happen if `y` or `z` cause some side
    effects. On the left-hand side, we first run all `y`s and then all `z`s. On the
    right-hand side, however, we interleave them, doing `y` and `z` all the time.
    Now, if an operation causes a side effect, it would mean that the two might end
    up producing different results. That's why developers should prefer using the
    left-hand side version, especially when there might be side effects such as IO.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们思考一下，如果 `y` 或 `z` 导致了一些副作用会发生什么。在左侧，我们首先运行所有的 `y`，然后运行所有的 `z`。然而，在右侧，我们却是交错进行，一直进行
    `y` 和 `z`。现在，如果一个操作导致了副作用，这意味着两者最终可能会产生不同的结果。这就是为什么开发者应该更喜欢使用左侧版本，尤其是在可能存在诸如IO之类的副作用的情况下。
- en: We have discussed the monad laws. For those who have more experience with Scala,
    monads might seem pretty close to the collection classes, and the rules we defined
    previously might seem logical. However, we are pointing out once more that it
    is not necessary for a monad to be a collection, and it is important that these
    rules are followed in order to be able to call an algebraic data structure a monad.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了单子的定律。对于那些有更多Scala经验的人来说，单子可能看起来非常接近集合类，我们之前定义的规则可能看起来很合理。然而，我们再次指出，单子不一定是集合，遵循这些规则对于能够将代数数据结构称为单子来说非常重要。
- en: Monads in real life
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的单子
- en: After going through a lot of theory about monads, it would now be useful to
    go through some code that demonstrates how to implement and use the theoretical
    concepts, which real-world situations they are good for, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了许多关于单子（monads）的理论之后，现在去了解一些代码示例，这些示例展示了如何实现和使用这些理论概念，以及它们在现实世界中的应用情况，将会非常有用。
- en: 'Let''s now do something similar to what we did before, and show what a monad
    trait will look like in Scala. Before doing this, however, let''s slightly change
    our functor definition:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做类似的事情，展示在Scala中单子特质的样子。然而，在这样做之前，让我们稍微改变一下我们的函子定义：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, instead of passing the element that will be mapped,
    we assume that the type that mixes `Functor` will have a way to pass it to the
    `map` implementation. We also changed the return type so that we can chain multiple
    functors using `map`. After we''ve done this, we can show our `Monad` trait:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不是传递将要映射的元素，而是假设混合了 `Functor` 的类型将有一种方法可以将它传递给 `map` 实现。我们还改变了返回类型，以便我们可以使用
    `map` 连接多个函子。完成这些后，我们可以展示我们的 `Monad` 特质：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code follows a convention similar to what we used for monoids.
    The methods the monad has are exactly the same as we have already mentioned earlier
    in the theoretical part of this chapter. The signatures might be slightly different,
    but mapping them to the theoretical code, which was made to be understood easily,
    shouldn't cause any issues.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遵循了与我们用于单子的约定相似的惯例。单子拥有的方法与我们已经在本章的理论部分提到的方法完全相同。签名可能略有不同，但将它们映射到易于理解的代码上，不应该引起任何问题。
- en: As you can see, the monads extend functors. Now, whenever we want to write monads,
    we just need to extend the preceding trait and implement the methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，单子扩展了函子。现在，每当我们想要编写单子时，我们只需要扩展前面的特质并实现方法。
- en: Using monads
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子
- en: Simply having a monad trait puts us in a framework that we can follow. We already
    went through the theory of monads and the laws that they follow. However, in order
    to understand how monads work and what they are useful for, looking at an actual
    example is invaluable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地拥有一个单子特质就使我们处于一个可以遵循的框架中。我们已经了解了单子的理论和它们遵循的定律。然而，为了理解单子是如何工作的以及它们有什么用，查看一个实际的例子是无价的。
- en: However, how are we supposed to even use monads if we don't know what their
    purpose is? Let's call them computation builders, as this is exactly what they
    are used for. This gives the ordinary developer much more understanding about
    when and where to use monad's computation builder chain operations in some way,
    which are then performed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不知道单子的用途是什么，我们该如何使用它们呢？让我们称它们为计算构建器，因为这正是它们被用于的地方。这使普通开发者对何时何地以某种方式使用单子的计算构建器链操作有了更深入的理解，这些操作随后被执行。
- en: The Option monad
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项单子
- en: We have already mentioned a few times that the standard Scala `Option` is a
    monad. In this subsection, we will provide our own monadical implementation of
    this standard class and show one of the many possible uses of monads.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，标准的Scala `Option` 是一个单子。在本小节中，我们将提供我们自己的单子实现，并展示单子的多种可能用途之一。
- en: 'In order to show how useful the option is, we will see what happens if we don''t
    have it. Let''s imagine that we have the following classes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示选项的有用性，我们将看到如果没有它会发生什么。让我们想象我们有以下类：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to test, we have added a `Boolean` flag that will or will not fail
    to get the required objects. In reality, this could be some complicated function
    that, depending on parameters or something else, could return `null` in some specific
    cases. The following piece of code shows how the preceding classes should be used
    in order to be completely protected from failure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们添加了一个`Boolean`标志，它将成功或失败地获取所需的对象。实际上，这可能是一个复杂的函数，它可能根据参数或其他因素在某些特定情况下返回`null`。以下代码片段展示了如何使用前面的类来完全避免失败：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `compute` method in the `NoMonadExample` object looks really bad and hard
    to read. We shouldn't write code like that.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoMonadExample`对象中的`compute`方法看起来真的很糟糕，难以阅读。我们不应该编写这样的代码。'
- en: Looking at what's happening in the preceding code, we can see that we are actually
    trying to build a chain of operations, which can individually fail. Monads can
    help us and abstract this protective logic. Now, let's show a much better solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的代码，我们可以看到我们实际上正在尝试构建一个操作链，这些操作可以单独失败。单子可以帮助我们并抽象这种保护逻辑。现在，让我们展示一个更好的解决方案。
- en: 'First of all, let''s define our own `Option` monad:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们自己的`Option`单子：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have two concrete cases in the preceding code—one where we can get a value
    and other where the result will be empty. Now, let''s rewrite our computation
    classes so that they use the new monad we just created:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个具体的例子——一个是可以获取值的情况，另一个是结果将为空的情况。现在，让我们重新编写我们的计算类，以便它们使用我们刚刚创建的新单子：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we can use them in the following way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以用以下方式使用它们：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we've shown a *for comprehension* usage of our monad,
    but the part that is commented out is also valid. The first one is preferred because
    it makes things look really simple, and some completely different computations
    end up looking the same, which is good for understanding and changing code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了我们的单子的`for`推导用法，但注释掉的部分也是有效的。第一个更受欢迎，因为它使事情看起来非常简单，一些完全不同的计算最终看起来相同，这对理解和修改代码是有益的。
- en: Of course, everything we showed in our example can be implemented using the
    standard Scala `Option`. It is almost certain that you have already seen and used
    this class before, which means that you have actually used monads before, maybe
    without realizing this was the case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们示例中展示的所有内容都可以使用标准的Scala `Option`来实现。几乎可以肯定，您之前已经见过并使用过这个类，这意味着您实际上已经使用过单子，可能没有意识到这一点。
- en: A more advanced monad example
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的单子示例
- en: The previous example was pretty simple, and it showed a great use of monads.
    We made our code much more straightforward, and we abstracted some logic inside
    the monads. Also, our code became much more readable than it was before.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子相当简单，展示了单子的强大用途。我们使代码更加直接，并在单子内部抽象了一些逻辑。此外，我们的代码比之前更容易阅读。
- en: 'In this subsection, let''s see another use of monads, which is much more advanced
    this time. All the software we write becomes much more challenging and interesting
    whenever we add I/O to it. This can be reading and writing data to and from files,
    communicating with a user, making web requests, and so on. Monads can be used
    in order to write I/O applications in a purely functional way. There is a really
    important feature here: I/O has to deal with side effects, operations are usually
    performed in a sequence, and the result depends on a state. This state can be
    anything—if we ask the user what cars they like, the response would vary depending
    on the user, and if we ask them what they ate for breakfast, or what the weather
    is like, the responses to these question will also depend on the user. Even if
    we try and read the same file twice, there might be differences—we might fail,
    the file could be changed, and so on. Everything we have described so far is a
    state. Monads help us hide this state from the user and just expose the important
    parts as well as abstract the way we deal with errors, and so on.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨monads的另一种更高级的使用方法。每当我们在软件中添加I/O操作时，所有我们编写的软件都会变得更加具有挑战性和趣味性。这包括读取和写入文件、与用户通信、发起网络请求等等。Monads可以被用来以纯函数式的方式编写I/O应用程序。这里有一个非常重要的特性：I/O必须处理副作用，操作通常按顺序执行，结果取决于状态。这个状态可以是任何东西——如果我们询问用户他们喜欢什么车，他们的回答会因用户而异；如果我们询问他们早餐吃了什么，或者天气如何，对这些问题的回答也会因用户而异。即使我们尝试两次读取同一个文件，也可能会有差异——我们可能会失败，文件可能会被更改等等。我们迄今为止所描述的一切都是状态。Monads帮助我们隐藏这个状态，只向用户展示重要的部分，以及抽象我们处理错误的方式等等。
- en: 'There are a few important aspects about the state we will be using:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们将要使用的状态有几个重要的方面：
- en: The state changes between different I/O operations
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态在不同I/O操作之间发生变化
- en: The state is only one and we can't just create a new one whenever we want
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态只有一个，我们不能随意创建一个新的
- en: At any moment in time, there can be only one state
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时刻，只能有一个状态
- en: All of the previous statements are quite logical, but they will actually guide
    the way we implement our state and our monads.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述陈述都非常合理，但它们实际上将指导我们实现状态和monads的方式。
- en: We will write an example, which will read the lines from a file and then go
    through them and write them in a new file with all the letters capitalized. This
    can be written in a really easy and straightforward way with Scala, but as soon
    as some of the operations become more complex or we try to handle errors properly,
    it can become pretty difficult.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个示例，它将读取文件中的行，然后遍历它们，并将它们写入一个新文件，所有字母都大写。这可以用Scala非常简单直接地完成，但一旦某些操作变得更为复杂，或者我们试图正确处理错误，这可能会变得相当困难。
- en: Throughout the example, we will try to show what steps we have taken in order
    to make sure the previous statements about our state are correct.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例中，我们将尝试展示我们为确保关于我们状态的前述陈述正确所采取的步骤。
- en: The  following example we will show doesn't really need to use state. It just
    performs a file read and write in a monadic manner. The reader should have enough
    knowledge by now to take the state out of the code, if needed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的以下示例实际上并不需要使用状态。它只是以monadic方式执行文件读取和写入。读者现在应该有足够的知识，如果需要，可以从代码中移除状态。
- en: We've decided to show a very simple usage of state, where we just increment
    a number. This can give the reader an idea of how a state can be used and wired
    up in applications that might actually need it. Additionally, the use of state
    can actually modify the behavior of our program and trigger different actions
    depending on it—for example, a vending machine and a user trying to request something
    that is out of stock.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定展示一个非常简单的状态使用示例，我们只是增加一个数字。这可以让读者了解状态如何在可能需要它的应用程序中使用和连接。此外，状态的使用实际上可以修改我们程序的行为，并触发不同的动作，例如，自动售货机和用户尝试请求缺货的商品。
- en: 'Let''s start with the state. For the current example, we don''t really need
    a special state, but we have used one anyway. It is just to show how to handle
    cases when one is actually needed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从状态开始。对于当前示例，我们实际上并不需要一个特殊的状态，但我们仍然使用了它。只是为了展示在确实需要时如何处理这种情况：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding trait has a `next` method, which will return the next state when
    we move between different operations. Just by calling it when we pass a state,
    we make sure that different operations cause a change in state.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述特质有一个 `next` 方法，当我们在不同操作之间移动时，它将返回下一个状态。只需在传递状态时调用它，我们就可以确保不同的操作会导致状态的变化。
- en: 'We need to make sure that our application has only one state and that nobody
    can create a state whenever they want. The fact that the trait is sealed helps
    us to make sure nobody can extend our state outside the file, where we have defined
    it. Being sealed is not enough, though. We need to make sure all the implementations
    of the state are hidden:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的应用程序只有一个状态，并且没有人可以在任何时候创建状态。事实是，特质的密封性帮助我们确保没有人可以在我们定义它的文件之外扩展我们的状态。尽管密封是必要的，但我们还需要确保所有状态实现都是隐藏的：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code defines the state as a private class, and this means that
    nobody else will be able to create one. Let's ignore the other methods for now,
    as we will come back to them later.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将状态定义为私有类，这意味着没有人能够创建它。现在我们先忽略其他方法，因为我们稍后会回到它们。
- en: 'The third rule we defined for our state earlier is much trickier to achieve.
    We have taken multiple steps in order to make sure the state behaves correctly.
    First of all, as can be seen from the previous listing, there is no clue of a
    state that the user can get to, except the private class that nobody can instantiate.
    Instead of loading the user with the burden of executing a task and passing a
    state, we only expose an `IOAction` to them, which is defined as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为状态定义的第三条规则要复杂得多。我们采取了多个步骤以确保状态的行为正确。首先，正如前一个列表所示，用户无法获取任何关于状态的信息，除了一个无人能实例化的私有类。我们不是让用户承担执行任务和传递状态的负担，而是只向他们暴露一个
    `IOAction`，其定义如下：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, let''s focus only on the `IOAction` signature. It extends a function
    from an old state to a tuple of the new state and the result of the operation.
    So, it turns out that we are still exposing the state to our users in a way—it
    is just in the form of a class. However, we already saw that it is pretty straightforward
    to hide a state by creating a private class that nobody can instantiate. Our users
    will be working with the `IOAction` class, so we need to make sure they don''t
    have to deal with states themselves. We have already defined the `IOAction` to
    be sealed. Additionally, we can create a factory object, which will help us create
    new instances:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们只关注 `IOAction` 的签名。它将一个函数从一个旧状态扩展到新状态和操作结果的元组。因此，结果是我们在某种方式上仍然以类形式向用户暴露了状态。然而，我们已经看到，通过创建一个无人能实例化的私有类，隐藏状态是非常直接的。我们的用户将使用
    `IOAction` 类，因此我们需要确保他们不必自己处理状态。我们已经定义了 `IOAction` 为密封的。此外，我们可以创建一个工厂对象，这将帮助我们创建新的实例：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code is quite important in terms of how things will get wired
    up later. First of all, we have a private implementation of `IOAction`. It only
    takes a by-name parameter, which means that it will only be evaluated when the
    `apply` method is called—this is really important. Moreover, in the preceding
    code, we have an `apply` method for the `IOAction` object, which allows the users
    to instantiate actions. Again, here the value is passed by name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在后续的连接中非常重要。首先，我们有一个 `IOAction` 的私有实现。它只接受一个按名称传递的参数，这意味着它只会在调用 `apply`
    方法时被评估——这非常重要。此外，在上述代码中，我们有一个 `apply` 方法用于 `IOAction` 对象，它允许用户实例化操作。在这里，值也是按名称传递的。
- en: The preceding code, basically, enables us to define actions and only execute
    them whenever we have a state available.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上使我们能够定义操作，并且只有在有状态可用时才执行它们。
- en: If we now have a think, you can see that we've managed to satisfy all three
    requirements for our state. Indeed, by hiding the state behind a class, whose
    instance creations are controlled by us, we have managed to protect the state
    so that we don't have more than one at the same time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在思考一下，你可以看到我们已经满足了我们对状态的所有三个要求。的确，通过将状态隐藏在我们控制的类后面，我们成功地保护了状态，以确保我们不会同时拥有多个状态。
- en: 'Now that we have everything in place, we can make sure our `IOAction` is a
    monad. It will need to satisfy the monad laws and define the required methods.
    We''ve already shown them, but let''s have a closer look at the methods again:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经一切就绪，我们可以确保我们的 `IOAction` 是一个单子。它需要满足单子法则并定义所需的方法。我们已经展示了它们，但让我们再次仔细看看这些方法：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We haven't specifically extended our `Monad` trait, but instead we have just
    defined the methods here. We already know that `map` can be defined using `flatMap`
    and `unit`. For the latter, we have used the factory method for the `SimpleAction`.
    Our implementation of the former is quite interesting—it performs the current
    operation first and then sequentially after that, based on the resulting state,
    the second operation. This allows us to chain multiple I/O operations together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有具体扩展我们的`Monad`特质，而是在这里定义了方法。我们已经知道`map`可以使用`flatMap`和`unit`来定义。对于后者，我们使用了`SimpleAction`的工厂方法。我们前者的实现相当有趣——它首先执行当前操作，然后根据结果状态，顺序执行第二个操作。这允许我们将多个I/O操作链接在一起。
- en: 'Let''s look at our `IOAction` class again. Does it satisfy the monad rules?
    The answer is no, but there is a really easy fix. The problem is that our `unit`
    method, if we look into it, would change the state because it uses a `SimpleAction`.
    But it shouldn''t. What we have to do is create another `IOAction` implementation
    that doesn''t change the state, and we use it for `unit`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的`IOAction`类。它是否满足单子规则？答案是：不，但有一个非常简单的修复方法。问题在于，如果我们深入研究，我们的`unit`方法会改变状态，因为它使用了`SimpleAction`。但是它不应该这样做。我们必须做的是创建另一个不改变状态的`IOAction`实现，并用于`unit`：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, our `IOAction` object will get an extra function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`IOAction`对象将获得一个额外的函数：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will also have to change the unit method in the `IOAction` abstract class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更改`IOAction`抽象类中的`unit`方法：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So far, we have defined our monad, made sure the state is handled properly,
    and that the actions can be created by a user in a controlled manner. What we
    need to do now is just add some useful methods and try them out:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了我们的单子，确保状态得到适当的处理，并且用户可以以受控的方式创建操作。我们现在需要做的就是添加一些有用的方法并尝试它们：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding is the code of a package object that reads and writes files and
    returns instances of `IOAction` (in the current case, `SimpleAction` is created
    using the `IOAction` `apply` method). Now that we have these methods and our monad,
    we can use the framework we have defined and wire everything up:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是读取和写入文件并返回`IOAction`实例（在当前情况下，使用`IOAction`的`apply`方法创建`SimpleAction`）的包对象的代码。现在我们有了这些方法和我们的单子，我们可以使用我们定义的框架，并将一切连接起来：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code defines a framework that the users of our library will follow;
    they will have to extend `FileIO`, implement `runIO`, and call the `run` method
    whenever they are ready to use our application. By now, you should be familiar
    enough with monads and see that the only thing the highlighted code will do is
    *build a computation*. It can be thought of as a graph of operations that have
    to be performed. It will not execute anything until the next line, where it actually
    gets the state passed to it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个框架，我们的库的用户将遵循；他们必须扩展`FileIO`，实现`runIO`，并在他们准备好使用我们的应用程序时调用`run`方法。到目前为止，你应该足够熟悉单子，看到高亮代码唯一要做的事情是*构建计算*。它可以被认为是一个必须执行的操作的图。它不会执行任何操作，直到下一行，在那里它实际上接收传递给它的状态：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding code shows an example usage of the `FileIO` library that we created.
    We can now run it with the following input file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了我们创建的`FileIO`库的一个示例用法。现在我们可以用以下输入文件运行它：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The command that we need to use is shown as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用的命令如下所示：
- en: '![](img/76ddb10f-b600-4719-b4a2-3942a6fbf7f2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76ddb10f-b600-4719-b4a2-3942a6fbf7f2.png)'
- en: As expected, the output file will contain the same text with all uppercase letters.
    You can, of course, try with different inputs and see how the code performs.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出文件将包含所有大写字母的相同文本。当然，你可以尝试不同的输入，看看代码的表现如何。
- en: Monad intuition
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子直觉
- en: In this section, we went through some theory and real-world examples with monads.
    Hopefully, we have managed to give an easy to understand explanation of what is
    what, and how and why it works. Monads are not as scary as they initially seem
    to be and some time spent with them would give an even better understanding of
    how and why things work in a certain way.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了一些关于单子的理论和实际例子。希望我们已经成功地给出了易于理解的解释，说明了什么是什么是，以及它是如何和为什么工作的。单子并不像它们最初看起来那么可怕，花一些时间与它们相处将更好地理解为什么事情以某种方式工作。
- en: The last example could seem pretty complicated, but some extra time spent with
    it using an IDE will make it clear and easy for you to realize how exactly everything
    gets wired up. Then, you will be able to easily spot and use monads on your own.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的例子可能看起来相当复杂，但花一些额外的时间在IDE中使用它，会使它变得清晰易懂，让你能够清楚地意识到一切是如何连接起来的。然后，你将能够轻松地发现并在自己的代码中使用单子。
- en: Of course, a developer can probably get away without monads, but using them
    can help with hiding details about exception handling, specific operations, and
    so on. Monads are actually good because of the extra work that happens inside
    them, and they can be used to implement some of the design patterns we saw earlier
    in this book. We can implement better states, rollbacks, and many, many more.
    It is also worth mentioning that it is likely that many times we use monads without
    even realizing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发者可能可以不使用单子（monads）而逃脱，但使用它们可以帮助隐藏关于异常处理、特定操作等方面的细节。单子之所以好，实际上是因为它们内部发生的额外工作，并且它们可以用来实现我们在本书前面看到的一些设计模式。我们可以实现更好的状态、回滚以及许多其他功能。还值得一提的是，我们可能很多次在使用单子时甚至都没有意识到。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to some of the functional programming theories that
    seem to put many people off pure functional programming. Because the majority
    of explanations require a strong mathematical background, we see people avoiding
    the concepts covered in this chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了一些似乎让很多人对纯函数式编程望而却步的函数式编程理论。因为大多数解释都需要强大的数学背景，所以我们看到人们避免本章中涵盖的概念。
- en: We talked about monoids, monads, and functors, and we showed some examples of
    how to use them and the difference between having and not having them. It turns
    out that we use these concepts more often than we think, but we just don't realize
    it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了单子、单子和函子，并展示了如何使用它们的示例以及有它们和无它们之间的区别。结果证明，我们比我们想象的更经常使用这些概念，但我们只是没有意识到。
- en: We saw that monoids, functors, and monads can be used for a variety of purposes—performance
    optimization, abstraction, and removal of code duplication. Properly understanding
    these concepts and feeling comfortable with them might take some time initially,
    but after some practice, developers tend to get a much better understanding and
    use them much more often than before. Hopefully, this chapter has made monoids,
    monads, and functors look much simpler than you may have thought and you will
    make them a part of the production code more often.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到单子、函子和单子可以用作各种目的——性能优化、抽象和代码重复的移除。正确理解这些概念并感到舒适可能最初需要一些时间，但经过一些实践，开发者往往会获得更好的理解，并且比以前更频繁地使用它们。希望这一章使单子、单子和函子看起来比你可能想象的要简单得多，你将更频繁地将它们作为生产代码的一部分。
- en: In the next chapter, we will cover some functional programming design patterns
    that are specific to Scala, due to its expressiveness. Some of them will be new
    and previously unseen, while others we have already met, but we will look at 
    from a different perspective.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些特定于Scala的函数式编程设计模式，这得益于其表达性。其中一些将是新的且之前未见过的，而其他一些我们已经遇到过，但我们将从不同的角度来审视它们。
