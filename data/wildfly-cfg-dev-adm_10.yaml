- en: Chapter 10. Securing WildFly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 保护WildFly
- en: Security is a key element of any enterprise application. You must be able to
    control and restrict who is permitted to access your applications and what operations
    users may perform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是企业应用程序的关键元素。您必须能够控制并限制谁有权访问您的应用程序以及用户可以执行哪些操作。
- en: The **Java Enterprise Edition** (**Java EE**) specification defines a simple,
    role-based security model for **Enterprise Java Beans** (**EJBs**) and web components.
    The implementation of JBoss security is delivered by the PicketBox framework (formerly
    known as the JBoss security), which provides authentication, authorization, auditing,
    and mapping capabilities to Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java企业版**（**Java EE**）规范为**企业JavaBeans**（**EJBs**）和Web组件定义了一个简单的基于角色的安全模型。JBoss安全性的实现由PicketBox框架（以前称为JBoss安全）提供，该框架为Java应用程序提供认证、授权、审计和映射功能。'
- en: 'As the number of topics concerned with security requires a book in its own
    right, this chapter will focus on the topics that are of interest to the majority
    of administrators and developers. We will cover the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及安全性的主题数量需要一个专门的书籍来阐述，因此本章将重点关注大多数管理员和开发者感兴趣的主题。我们将详细讨论以下主题：
- en: A short introduction to the Java security API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java安全API简介
- en: The basics of the WildFly security subsystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WildFly安全子系统的基本原理
- en: Defining login modules and their integration with various enterprise components
    (for example, web application EJB)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义登录模块及其与各种企业组件（例如，Web应用EJB）的集成
- en: Securing the management interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护管理接口
- en: Using **Secure Sockets Layer** (**SSL**) to encrypt network calls to web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**安全套接字层**（**SSL**）加密对Web应用的网络调用
- en: Approaching Java security API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近Java安全API
- en: 'Java EE security services provide a robust and easily configurable security
    mechanism to authenticate users and authorize access to application functions
    and associated data. To better understand the topics related to security, we will
    first provide some basic definitions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE安全服务提供了一种强大且易于配置的安全机制，用于验证用户并授权对应用程序功能和相关数据的访问。为了更好地理解与安全性相关的主题，我们首先提供一些基本定义：
- en: '**Authentication** is the process of ensuring that a person is who he claims
    to be. Authentication is usually performed by checking that a user''s login credentials
    match those stored in a datastore. Login credentials typically consist of a username
    and password but can also be in the form of an X.509 certificate or **one-time
    password** (**OTP**). The following figure demonstrates the flow of a login process.
    The end user provides a username and password, which is submitted to the application
    server. The login module checks the user''s details against those stored in a
    datastore. If the credentials match, the user is logged in; if the credentials
    do not match, then the login process will fail. Have a look at the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**是确保一个人是他所声称的人的过程。认证通常通过检查用户的登录凭证是否与存储在数据存储中的凭证匹配来执行。登录凭证通常包括用户名和密码，但也可以是X.509证书或**一次性密码**（**OTP**）的形式。以下图示展示了登录过程的流程。最终用户提供用户名和密码，并将其提交给应用程序服务器。登录模块将用户的详细信息与存储在数据存储中的信息进行核对。如果凭证匹配，则用户登录；如果凭证不匹配，则登录过程将失败。请查看以下图表：'
- en: '![Approaching Java security API](img/6232OS_10_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![接近Java安全API](img/6232OS_10_01.jpg)'
- en: '**Authorization** is the process by which you verify that a user has the permission
    to access a particular system resource. Authorization should occur after authentication
    has taken place. Have a look at the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权**是验证用户是否有权访问特定系统资源的过程。授权应在认证之后进行。请查看以下图表：'
- en: '![Approaching Java security API](img/6232OS_10_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![接近Java安全API](img/6232OS_10_02.jpg)'
- en: 'In Java EE, the component containers are responsible for providing application
    security. A container basically provides two types of security: **declarative**
    and **programmatic**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE中，组件容器负责提供应用程序安全。容器基本上提供两种类型的安全：**声明式**和**程序性**。
- en: '**Declarative security** defines an application component''s security requirements
    by means of deployment descriptors and/or annotations. A deployment descriptor
    is an external file that can be modified without the need to recompile the source
    code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式安全**通过部署描述符和/或注解定义应用程序组件的安全要求。部署描述符是一个外部文件，可以修改而不需要重新编译源代码。'
- en: For example, Enterprise JavaBeans components can use an EJB deployment descriptor
    that must be named `ejb-jar.xml` and placed in the `META-INF` folder of the EJB
    JAR file.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，企业JavaBeans组件可以使用一个名为`ejb-jar.xml`的EJB部署描述符，并将其放置在EJB JAR文件的`META-INF`文件夹中。
- en: Web components use a web application deployment descriptor named `web.xml` located
    in the `WEB-INF` directory.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Web组件使用一个名为`web.xml`的Web应用程序部署描述符，该描述符位于`WEB-INF`目录中。
- en: Annotations are specified within a class file, which means any changes will
    require the code to be recompiled.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注解是在类文件中指定的，这意味着任何更改都需要重新编译代码。
- en: Using annotations provides many benefits over deployment descriptors. First,
    it is clearer in the source code as to what is happening rather than having this
    information scattered over various XML files. Second, it is easier to maintain
    as there are fewer configuration files.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用注解比使用部署描述符提供了许多好处。首先，它在源代码中比在各个XML文件中分散的信息更清晰。其次，它更容易维护，因为配置文件更少。
- en: The use of annotations also means less boilerplate code for the developer.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用注解也意味着开发者需要更少的样板代码。
- en: '**Programmatic security** comes into the picture when security checks are embedded
    within an application code. It can be used when declarative security alone is
    not sufficient to express the security model of an application. For example, the
    Java EE security API allows the developer to test whether or not the current user
    has a specific role, using the following methods:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序式安全**在安全检查嵌入到应用程序代码中时出现。当仅使用声明式安全不足以表达应用程序的安全模型时，可以使用它。例如，Java EE安全API允许开发者使用以下方法测试当前用户是否具有特定的角色：'
- en: '`isUserInRole()`: Use this method within servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUserInRole()`: 在servlets和JSPs中使用此方法（在`javax.servlet.http.HttpServletRequest`中采用）'
- en: '`isCallerInRole()`: Use this method in EJBs (adopted in `javax.ejb.SessionContext`)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCallerInRole()`: 在EJBs中使用此方法（在`javax.ejb.SessionContext`中采用）'
- en: 'In addition, there are other API calls that provide access to the user''s identity,
    which are as follows:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还有其他API调用可以提供对用户身份的访问，如下所示：
- en: '`getUserPrincipal()`: Use this method within servlets and JSPs (adopted in
    `javax.servlet.http.HttpServletRequest`)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUserPrincipal()`: 在servlets和JSPs中使用此方法（在`javax.servlet.http.HttpServletRequest`中采用）'
- en: '`getCallerPrincipal()`: Use this method in EJBs (adopted in `javax.ejb.SessionContext`)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCallerPrincipal()`: 在EJBs中使用此方法（在`javax.ejb.SessionContext`中采用）'
- en: Using these APIs, you can develop a complex authorization model programmatically.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这些API，你可以通过编程方式开发复杂的授权模型。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While annotations themselves are programmatic, they enable a declarative style
    of security. For this reason, annotations are considered to encompass both the
    declarative and programmatic security concepts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然注解本身是程序性的，但它们使安全成为一种声明式风格。因此，注解被认为包含了声明式和程序式安全概念。
- en: The Java EE security model is declarative, due to which embedding the security
    code into your business component is not an option. The term declarative here
    means that you describe the security roles and permissions in a standard XML descriptor.
    Declarative security allows the logic from this cross-cutting concern to be extracted
    away from core business logic. This results in a clearer and more readable code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE安全模型是声明式的，因此将安全代码嵌入到业务组件中不是一个选择。这里的声明式意味着你在一个标准的XML描述符中描述安全角色和权限。声明式安全允许将来自这个横切关注点的逻辑从核心业务逻辑中提取出来。这导致代码更清晰、更易于阅读。
- en: The default implementation of the declarative security model is based on **Java
    Authentication and Authorization Service** (**JAAS**) login modules and subjects.
    WildFly security has a security proxy layer that allows the developer to create
    custom security services if the default implementation does not suffice. This
    allows custom security to be built independently of the bean object using it,
    without polluting the business code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式安全模型的默认实现基于**Java认证和授权服务**（**JAAS**）登录模块和主题。WildFly安全有一个安全代理层，允许开发者创建自定义安全服务，如果默认实现不足以满足需求。这允许在不污染业务代码的情况下独立于使用它的bean对象构建自定义安全。
- en: WildFly uses the PicketBox framework, which builds on JAAS. PicketBox is used
    to secure all the Java EE technologies running in the application server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly使用基于JAAS的PicketBox框架，用于保护在应用服务器中运行的Java EE技术。
- en: The WildFly security subsystem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WildFly安全子系统
- en: 'The WildFly security subsystem is an extension of the application server and
    is included by default in both the standalone servers and domain servers. Have
    a look at the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly安全子系统是应用服务器的一个扩展，默认包含在独立服务器和域服务器中。查看以下代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the default security subsystem contained in the server configuration
    file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在服务器配置文件中包含的默认安全子系统：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the configuration is pretty short, as it relies largely on default
    values, especially for high-level structures, such as the security management
    area.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，配置相当简短，因为它在很大程度上依赖于默认值，特别是对于高级结构，如安全管理区域。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A security domain does not explicitly require an authorization policy. If a
    security domain does not define an authorization module, the default `jboss-web-policy`
    and `jboss-ejb-policy` authorizations are used. In such a case, the delegating
    authorization policy is applied, which simply delegates the authorization to another
    module declared as `<module-option>`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安全域不明确要求授权策略。如果安全域没有定义授权模块，则使用默认的`jboss-web-policy`和`jboss-ejb-policy`授权。在这种情况下，应用委托授权策略，该策略简单地委托授权给另一个作为`<module-option>`声明的模块。
- en: You can override the default authentication/authorization managers with your
    own implementation by defining your own security management configuration. It
    is unlikely that you will have to override these interfaces, so we will concentrate
    on the `security-domain` element, which is a core aspect of the WildFly security
    subsystem.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过定义自己的安全管理配置来覆盖默认的认证/授权管理器。您不太可能需要覆盖这些接口，因此我们将重点放在`security-domain`元素上，这是WildFly安全子系统的核心方面。
- en: A **security domain** can be imagined as a customs office for foreigners. Before
    the request crosses the WildFly borders, the security domain performs all the
    required authorization and authentication checks and notifies the caller whether
    they can proceed or not.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将**安全域**想象成外国人的海关办公室。在请求越过WildFly边界之前，安全域执行所有必要的授权和身份验证检查，并通知调用者他们是否可以继续。
- en: Security domains are generally configured at server startup or in a running
    server and subsequently bound to the JNDI tree under the key `java:/jaas/`. Within
    the security domain, you can configure login authentication modules so that you
    can easily change your authentication provider by simply changing its login module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安全域通常在服务器启动时或在运行中的服务器中进行配置，然后绑定到`java:/jaas/`键下的JNDI树。在安全域内，您可以配置登录身份验证模块，以便您可以简单地通过更改其登录模块来轻松更改您的认证提供者。
- en: 'The following table describes all the available login modules, including a
    short description of them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了所有可用的登录模块，包括它们的简要描述：
- en: '| Login module | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 登录模块 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Client` | This login module is designed to establish caller identity and
    credentials when AS is acting as a client. It should never be used as part of
    a security domain for actual server authentication. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `Client` | 此登录模块旨在在AS作为客户端时建立调用者身份和凭证。它不应作为实际服务器身份验证的安全域的一部分使用。 |'
- en: '| `Database` | This login module loads user/role information from a database.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `Database` | 此登录模块从数据库加载用户/角色信息。 |'
- en: '| `Certificate` | This login module is designed to authenticate users based
    on the X.509 certificates. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Certificate` | 此登录模块旨在根据X.509证书对用户进行身份验证。 |'
- en: '| `CertificateRoles` | This login module extends the `Certificate` login module
    to add role-mapping capabilities from a properties file. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `CertificateRoles` | 此登录模块扩展了`Certificate`登录模块，以添加从属性文件中获取的角色映射功能。 |'
- en: '| `DatabaseCertificate` | This login module extends the `Certificate` login
    module to add role-mapping capabilities from a database table. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `DatabaseCertificate` | 此登录模块扩展了`Certificate`登录模块，以添加从数据库表获取的角色映射功能。 |'
- en: '| `DatabaseUsers` | This is a JDBC-based login module that supports authentication
    and role mapping. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `DatabaseUsers` | 这是一个基于JDBC的登录模块，支持身份验证和角色映射。 |'
- en: '| `Identity` | This login module simply associates the principles specified
    in the module options with any subject authenticated against the module. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Identity` | 此登录模块简单地将模块选项中指定的原则与对模块进行身份验证的任何主体关联。 |'
- en: '| `Ldap` | This login module loads user/role information from an LDAP server.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Ldap` | 此登录模块从LDAP服务器加载用户/角色信息。 |'
- en: '| `LdapExtended` | This login module is an alternate LDAP login module implementation
    that uses searches to locate both the user as well as the associated roles to
    bind the authentication. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `LdapExtended` | 此登录模块是一个替代的 LDAP 登录模块实现，它使用搜索来定位用户以及关联的角色以绑定认证。 |'
- en: '| `RoleMapping` | This login module is used to map roles that are the end result
    of the authentication process to one or more declarative roles. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `RoleMapping` | 此登录模块用于将认证过程的结果角色映射到一个或多个声明性角色。 |'
- en: '| `RunAs` | This login module can be used to allow another login module to
    interact with a secured EJB that provides authentication services. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `RunAs` | 此登录模块可用于允许其他登录模块与提供认证服务的受保护 EJB 交互。 |'
- en: '| `Simple` | This login module is used to quickly set up the security for testing
    purposes. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Simple` | 此登录模块用于快速设置测试目的的安全设置。 |'
- en: '| `ConfigureIdentity` | This is a login module that associates the principles
    specified in the module options with any subject authenticated against the module.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `ConfigureIdentity` | 这是一个将模块选项中指定的原则与模块中认证的任何主体关联的登录模块。 |'
- en: '| `PropertiesUsers` | This login module uses a properties file to store the
    username and password for authentication. No roles are mapped. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `PropertiesUsers` | 此登录模块使用属性文件来存储用于认证的用户名和密码。不映射任何角色。 |'
- en: '| `SimpleUsers` | This login module stores username and password as options.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `SimpleUsers` | 此登录模块将用户名和密码作为选项存储。 |'
- en: '| `LdapUsers` | This login module authenticates users using a LDAP server.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `LdapUsers` | 此登录模块使用 LDAP 服务器进行用户认证。 |'
- en: '| `Kerberos` | This login module uses Sun''s `Kerberos` login module as a mechanism
    for authentication. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Kerberos` | 此登录模块使用 Sun 的 `Kerberos` 登录模块作为认证机制。 |'
- en: '| `SPNEGOUsers` | This login module works in conjunction with `SPNEGOAuthenticator`
    to handle the authentication. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `SPNEGOUsers` | 此登录模块与 `SPNEGOAuthenticator` 协同工作以处理认证。 |'
- en: '| `AdvancedLdap` | This login module is a refactoring of the `LdapExtLoginModule`,
    which is able to separate the login steps (find, authenticate, or map roles) so
    that any of the actions can be undertaken separately. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `AdvancedLdap` | 此登录模块是对 `LdapExtLoginModule` 的重构，它能够分离登录步骤（查找、认证或映射角色），以便任何操作都可以单独执行。
    |'
- en: '| `AdvancedADLdap` | This login module is an extension of the `AdvancedLdap`
    login module, which is also able to query the primary group of the user being
    authenticated. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `AdvancedADLdap` | 此登录模块是 `AdvancedLdap` 登录模块的扩展，它也能够查询正在认证的用户的主组。 |'
- en: '| `UsersRoles` | This login module is a simple properties-map-based login module
    that consults two Java properties-formatted text files to map the username to
    the password (`users.properties`) and username to roles (`roles.properties`).
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `UsersRoles` | 此登录模块是一个简单的基于属性映射的登录模块，它咨询两个 Java 属性格式化的文本文件，将用户名映射到密码（`users.properties`）和用户名映射到角色（`roles.properties`）。
    |'
- en: 'Activating a login module is a two-step procedure, which is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 激活登录模块是一个两步过程，具体如下：
- en: First, you need to define the login module within your `standalone.xml/domain.xml`
    configuration file.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要在您的 `standalone.xml/domain.xml` 配置文件中定义登录模块。
- en: Then, you need to tell your applications to use a login module to perform authentication
    and authorization.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要通知您的应用程序使用登录模块来执行认证和授权。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In earlier releases of the application server, the login module was configured
    in a separate file named `login-config.xml`. Porting earlier login modules into
    the new application server is not too complex, as the format of the login module
    is pretty much the same as the new application server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序服务器的早期版本中，登录模块是在一个名为 `login-config.xml` 的单独文件中配置的。将早期登录模块迁移到新应用程序服务器并不复杂，因为登录模块的格式与新的应用程序服务器几乎相同。
- en: We will now expand these points in more detail. Let's see first how to define
    some commonly-used login modules, and then we will apply them to the Java EE components,
    such as servlets, EJB, and web services.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更详细地展开这些点。首先，让我们看看如何定义一些常用的登录模块，然后我们将将它们应用到 Java EE 组件中，如 servlet、EJB 和
    Web 服务。
- en: Using the UsersRoles login module
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 UsersRoles 登录模块
- en: 'The `UsersRoles` login module is one of the simplest security domains that
    can be implemented for testing purposes in your applications. It is based on two
    files, which are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersRoles` 登录模块是您可以在应用程序中用于测试目的的最简单的安全域之一。它基于两个文件，如下所示：'
- en: '`users.properties`: This file contains the list of usernames and passwords'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users.properties`：此文件包含用户名和密码列表'
- en: '`roles.properties`: This file contains the mapping between the users and the
    roles'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles.properties`: 此文件包含用户与角色之间的映射'
- en: 'Here is a sample `UsersRoles` configuration that stores the security files
    in the application server''s configuration directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例`UsersRoles`配置，它将安全文件存储在应用程序服务器的配置目录中：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All you need to do to start using your security domain is add the two properties
    files into the specified path (for a standalone system, the default is `JBOSS_HOME/standalone/configuration`)
    and add your username and password within it. This login module does not support
    hashed passwords; only clear passwords are supported. For example, the `users.properties`
    file can contain something like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您要开始使用安全域，只需将两个属性文件添加到指定的路径（对于独立系统，默认为`JBOSS_HOME/standalone/configuration`）并在其中添加您的用户名和密码。此登录模块不支持哈希密码；仅支持明文密码。例如，`users.properties`文件可以包含以下内容：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `roles.properties` file contains the sets of roles for a given username.
    Adding a suffix to the username, as shown in the second line of the following
    code, allows you to assign the username roles to a group of roles:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles.properties`文件包含给定用户名的角色集合。在用户名后添加后缀，如以下代码的第二行所示，允许您将用户名角色分配给一组角色：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that authenticating with the admin/admin credentials will assign
    the role of manager to the user.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用管理员/admin凭据进行认证将把管理员的角色分配给用户。
- en: Using the Database login module
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据库登录模块
- en: 'A database security domain follows the same logic exposed in the earlier example,
    the difference being that it stores the credentials within the database. In order
    to run this example, we need to refer to the `MySqlDS` datasource that we created
    earlier, in [Chapter 3](ch03.html "Chapter 3. Configuring Enterprise Services"),
    *Configuring Enterprise Services*. Have a look at the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库安全域遵循与早期示例中相同的逻辑，不同之处在于它将凭据存储在数据库中。为了运行此示例，我们需要参考我们之前创建的`MySqlDS`数据源，在[第3章](ch03.html
    "第3章。配置企业服务")，*配置企业服务*。请查看以下代码：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice in the `rolesQuery` module option that there is a second select
    item (`Roles`). This corresponds to a `RoleGroup` column and must always be supplied
    with "R" (in capital letters)..
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在`rolesQuery`模块选项中注意到有一个第二个选择项（`Roles`）。这对应于`RoleGroup`列，并且必须始终提供大写的"R"（R）。
- en: 'In order to start using this configuration, you first have to create the required
    tables and insert some sample data into it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用此配置，您首先必须创建所需的表并将一些示例数据插入其中：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the admin user will map to the `Manager` role. One caveat of
    this configuration is that it uses clear-text passwords in the database so, before
    rolling this module production, you should consider additional security for your
    login module. Let's see how you can do this in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，管理员用户将映射到`Manager`角色。此配置的一个注意事项是它使用数据库中的明文密码，因此，在将此模块投入生产之前，您应该考虑为您的登录模块提供额外的安全性。让我们在下一节中看看如何做到这一点。
- en: Encrypting passwords
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密密码
- en: Storing passwords in the database as clear-text strings is not considered a
    good practice. As a matter of fact, a database has even more potential security
    issues than a regular filesystem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将密码以明文字符串的形式存储在数据库中不被认为是良好的做法。事实上，数据库甚至比常规文件系统有更多的潜在安全问题。
- en: 'Fortunately, securing application passwords is relatively easy and can be achieved
    by adding a few extra options to your login module. As a minimum, you need to
    specify that the stored passwords are encrypted using a **message digest algorithm**.
    For example, in the `mysqlLogin` module, you can add the highlighted lines at
    the end:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，保护应用程序密码相对简单，可以通过在登录模块中添加一些额外选项来实现。至少，您需要指定存储的密码使用**消息摘要算法**进行加密。例如，在`mysqlLogin`模块中，您可以在末尾添加突出显示的行：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we specified that the password will be hashed against an `MD5` hash algorithm;
    you can alternatively use any other algorithm allowed by your JCA provider, such
    as SHA.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定密码将使用`MD5`哈希算法进行哈希；您也可以使用JCA提供者允许的任何其他算法，例如SHA。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For a production environment, you should avoid MD5 hashing, as it is a very
    weak hash. Ideally, you should use something like SHA-512 with a large number
    of hash iterations. You should also use a single, randomly generated salt per
    user. At the time of writing, one of the best hashing algorithms is bcrypt, which
    generates the salt for you. You should do your research before making a final
    decision. These encryptions are not supported by the `DatabaseServerLoginModule`,
    so you will need to create your own custom login module. Refer to the following
    link to write a custom login module: [https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html](https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，应避免使用MD5散列，因为它非常弱。理想情况下，您应使用类似SHA-512的算法，并具有大量的散列迭代次数。您还应为每个用户使用单个随机生成的盐。在撰写本文时，最好的散列算法之一是bcrypt，它会为您生成盐。在做出最终决定之前，您应该进行一些研究。这些加密不被`DatabaseServerLoginModule`支持，因此您需要创建自己的自定义登录模块。请参阅以下链接以编写自定义登录模块：[https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html](https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html)。
- en: 'For the sake of completeness, we include here a small application, which uses
    the `java.security.MessageDigest` and the `org.jboss.security.Base64Util` classes
    to generate the base-64 hashed password to be inserted in the database. Have a
    look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们在此包含一个小型应用，该应用使用`java.security.MessageDigest`和`org.jboss.security.Base64Util`类来生成要插入数据库的base-64散列密码。请查看以下代码：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the main program with `admin` as the argument generates the hash **X8oyfUbUbfqE9IWvAW1/3**.
    This hash will be the updated password for the admin user of our database. Have
    a look at the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`admin`作为参数运行主程序会生成散列值**X8oyfUbUbfqE9IWvAW1/3**。这个散列值将成为我们数据库管理员用户的更新密码。请查看以下屏幕截图：
- en: '![Encrypting passwords](img/6232OS_10_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![加密密码](img/6232OS_10_03.jpg)'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are not using Java 8, you can use the `org.jboss.security.Base64Utils`
    library instead of `Java 8` as shown in this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Java 8，可以使用本节中所示的`org.jboss.security.Base64Utils`库代替`Java 8`。
- en: Using an LDAP login module
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LDAP登录模块
- en: 'The **Lightweight Directory Access Protocol** (**LDAP**) is the *de facto*
    standard for providing directory services to applications. An LDAP server can
    provide central directory information for the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**轻量级目录访问协议**（**LDAP**）是提供目录服务给应用程序的**事实标准**。LDAP服务器可以为以下提供集中目录信息：'
- en: User credentials (login and password)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户凭据（登录名和密码）
- en: User directory information (such as names and e-mail addresses)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户目录信息（如姓名和电子邮件地址）
- en: Web directories
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络目录
- en: The working of LDAP revolves around a data structure known as **entry**. An
    entry has a set of named component parts called **attributes** that hold the data
    for that entry. These attributes are like the fields in a database record.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP的工作原理围绕一个称为**条目**的数据结构。一个条目有一组称为**属性**的命名组成部分，这些属性包含该条目的数据。这些属性就像数据库记录中的字段一样。
- en: An entry's content and structure are defined by its object class. The object
    class (along with server and user settings) specifies which attributes must exist
    and which may exist in that particular entry.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 条目的内容和结构由其对象类定义。对象类（连同服务器和用户设置）指定在该特定条目中必须存在哪些属性，以及哪些属性可能存在。
- en: 'All entries stored in an LDAP directory have a unique **distinguished name**
    or **DN**. The DN for each LDAP entry is composed of two parts: the **relative
    distinguished name** (**RDN**) and the location within the LDAP directory where
    the record resides.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在LDAP目录中的所有条目都有一个唯一的**区分名称**或**DN**。每个LDAP条目的DN由两部分组成：**相对区分名称**（**RDN**）和记录在LDAP目录中的位置。
- en: 'In practice, the RDN is the portion of your DN that is not related to the directory
    tree structure and, in turn, is composed of one or several attribute names/value
    pairs. Let''s see a concrete example of an organization, as shown in the following
    diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，RDN是DN中与目录树结构无关的部分，并且反过来由一个或多个属性名称/值对组成。让我们看看以下图中的组织示例：
- en: '![Using an LDAP login module](img/6232OS_10_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用LDAP登录模块](img/6232OS_10_04.jpg)'
- en: In the preceding diagram, `cn=John Smith` (where `cn` stands for "common name")
    could be an RDN. The attribute name is `cn`, and the value is `John Smith`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`cn=John Smith`（其中`cn`代表“通用名称”）可能是一个RDN。属性名称是`cn`，值是`John Smith`。
- en: On the other hand, the DN for `John Smith` would be `cn=John Smith`, `ou=Marketing`,
    `o=Acme`, and `c=US` (where `ou` is short for organizational unit, `o` is short
    for organization, and `c` is for country).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`John Smith`的DN将是`cn=John Smith`，`ou=Marketing`，`o=Acme`，`c=US`（其中`ou`代表组织单元，`o`代表组织，`c`代表国家）。
- en: Connecting LDAP to WildFly
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将LDAP连接到WildFly
- en: Connecting WildFly and LDAP can be done by means of several LDAP login modules.
    The first and obvious thing we need to do is run an instance of an LDAP server.
    Today, there are a huge number of LDAP servers available (both commercial and
    open source), and maybe you already configured one to run in your company. Just
    in case you don't have one, or simply don't want to add sample data to it, we
    suggest you have a look at the Apache Directory project ([http://directory.apache.org/](http://directory.apache.org/)).
    It provides an excellent solution to get started with LDAP and to build complex
    directory infrastructures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几种LDAP登录模块可以实现WildFly和LDAP的连接。我们首先需要做的是运行一个LDAP服务器实例。今天，有大量的LDAP服务器可供选择（包括商业和开源），也许你已经在公司中配置了一个来运行。如果你没有，或者只是不想向其中添加示例数据，我们建议你查看Apache
    Directory项目（[http://directory.apache.org/](http://directory.apache.org/)）。它提供了一个出色的解决方案，用于开始使用LDAP并构建复杂的目录基础设施。
- en: Once installed, we suggest that you use the Apache Directory Studio (available
    at the same link), as it allows you to quickly create a directory infrastructure.
    The simplest way to create a directory from scratch is by means of an **LDAP Data
    Interchange Format** (**LDIF**) file. Within this file, you can specify all entries
    that will be loaded by the LDAP engine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们建议你使用Apache Directory Studio（可在同一链接中找到），因为它允许你快速创建目录基础设施。从头开始创建目录的最简单方法是使用**LDAP数据交换格式**（**LDIF**）文件。在此文件中，你可以指定所有将由LDAP引擎加载的条目。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A quick shortcut to import an LDIF file from the Apache studio is in the file
    menu **File** | **Import** | **LDIF** into **LDAP**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从Apache Studio导入LDIF文件的一个快速方法是，在文件菜单中选择**文件** | **导入** | **LDIF**到**LDAP**。
- en: 'Here''s a basic LDIF file we will use:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们将要使用的LDIF文件的基本示例：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once you import this information into the LDAP server, you will end up with
    a small directory, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将此信息导入LDAP服务器，你将得到一个如以下截图所示的小型目录：
- en: '![Connecting LDAP to WildFly](img/6232OS_10_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![将LDAP连接到WildFly](img/6232OS_10_05.jpg)'
- en: Within this directory, we have just one user registered as `admin`, belonging
    to the `Manager` role, as in other login modules we have seen in the earlier sections.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中，我们只注册了一个用户作为`admin`，属于`Manager`角色，就像我们在前面的章节中看到的其他登录模块一样。
- en: 'Now, we will configure the LDAP connection on WildFly. For our purposes, we
    will use the `LdapExtended` login module implementation, as shown in the following
    code. This implementation uses searches to locate both the user and the associated
    roles to bind as per authentication. The `roles` query will follow distinguished
    names (DNs) recursively to navigate a hierarchical role structure. Have a look
    at the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置WildFly上的LDAP连接。为了我们的目的，我们将使用`LdapExtended`登录模块实现，如下面的代码所示。此实现使用搜索来定位用户和关联的角色以进行认证绑定。`roles`查询将递归地跟随区分名（DN）以导航分层角色结构。请查看以下代码：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is a brief description of the `LdapExtended` module''s properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`LdapExtended`模块属性的简要描述：
- en: '`bindDN`: This is the DN used to bind against the LDAP server for the user
    and roles queries, which, in our case, is "`uid=admin,ou=system`".'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindDN`：这是用于对用户和角色查询绑定到LDAP服务器的DN，在我们的案例中是"`uid=admin,ou=system`"。'
- en: '`baseCtxDN`: This is the fixed DN of the context to start the user search from.
    In our example, it is "`ou=People,dc=example,dc=com`.".'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseCtxDN`：这是从用户搜索开始上下文的固定DN。在我们的例子中，它是"`ou=People,dc=example,dc=com`"。'
- en: '`baseFilter`: This is a search filter used to locate the context of the user
    to be authenticated. The input `username` or `userDN`, as obtained from the login
    module, will be substituted into the filter anywhere a `{0}` expression is seen.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseFilter`：这是一个用于定位要认证的用户上下文的搜索过滤器。从登录模块获得的输入`username`或`userDN`将在过滤器中任何出现`{0}`表达式的位置被替换。'
- en: '`rolesCtxDN`: This is the fixed DN of the context to search for user roles.
    Consider that this is not the DN of the location of the actual roles; rather,
    this is the DN of where the objects containing the user roles are.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rolesCtxDN`：这是搜索用户角色的上下文的固定DN。请考虑这并不是实际角色位置的DN；相反，这是包含用户角色的对象的位置的DN。'
- en: '`roleFilter`: This is a search filter used to locate the roles associated with
    the authenticated user. An example search filter that matches on the input username
    is `(member={0})`. An alternative that matches on the authenticated user DN is
    `(member={1})`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roleFilter`：这是一个用于定位与已认证用户关联的角色的搜索过滤器。一个匹配输入用户名的示例搜索过滤器是`(member={0})`。另一个匹配已认证用户DN的替代方案是`(member={1})`。'
- en: '`roleAttributeID`: This is the name of the role attribute of the context that
    corresponds to the name of the role.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roleAttributeID`：这是与角色名称相对应的上下文角色属性的名称。'
- en: '`searchScope`: This sets the search scope to one of the following strings:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchScope`：此设置将搜索范围设置为以下字符串之一：'
- en: '`ONELEVEL_SCOPE`: This scope searches for users and associated roles directly
    under the named roles context.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONELEVEL_SCOPE`：此作用域在命名角色上下文直接下搜索用户和关联的角色。'
- en: '`SUBTREE_SCOPE`: If the role''s context is `DirContext`, this scope searches
    the subtree rooted at the named object, including the named object itself. If
    the role''s context is not `DirContext`, this scope searches only the object.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBTREE_SCOPE`：如果角色的上下文是`DirContext`，则此作用域在命名对象及其子树中搜索，包括命名对象本身。如果角色的上下文不是`DirContext`，则此作用域仅搜索对象。'
- en: '`OBJECT_SCOPE`: This scope searches the named roles context only.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECT_SCOPE`：此作用域仅在命名角色上下文中搜索。'
- en: '`allowEmptyPasswords`: This is a flag indicating whether `empty(length==0)`
    passwords should be passed to the LDAP server.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowEmptyPasswords`：这是一个标志，表示是否应将`empty(length==0)`密码传递给LDAP服务器。'
- en: Securing web applications
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护Web应用程序
- en: Okay! So, we touched upon some of the commonly used login modules. These login
    modules can be used by any Java EE application, so it's time to show a concrete
    example. In this section, we will show you how to apply a login module to a web
    application in order to show an implementation of basic web authentication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！所以，我们提到了一些常用的登录模块。这些登录模块可以被任何Java EE应用程序使用，所以现在是时候展示一个具体的例子了。在本节中，我们将向您展示如何将登录模块应用于Web应用程序，以展示基本Web认证的实现。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Basic access authentication is the simplest way to provide a username and password
    when making a request through a browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 基本访问认证是在通过浏览器发出请求时提供用户名和密码的最简单方式。
- en: It works by sending an encoded string containing the user credentials. This
    Base64-encoded string is transmitted and decoded by the receiver, resulting in
    a colon-separated username and password string.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过发送包含用户凭据的编码字符串来实现。此Base64编码的字符串由接收方传输和解码，结果是一个冒号分隔的用户名和密码字符串。
- en: 'The first thing we need to do is turn on web authentication. This requires
    you to define the `security-constraints` in the web application configuration
    file (`web.xml`). Have a look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是启用web认证。这需要你在web应用程序配置文件（`web.xml`）中定义`security-constraints`。请看以下代码：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding configuration will add a security constraint to all URLs, which
    obviously includes all your JSP servlets. Access will be restricted to users authenticated
    with the `Manager` role.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配置将为所有URL添加一个安全约束，这显然包括你所有的JSP servlets。访问将仅限于具有`Manager`角色的已认证用户。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Considering that we are using the `Database` login module, the `Manager` role
    will be granted to users that have authenticated with the admin credentials.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们正在使用`Database`登录模块，`Manager`角色将授予使用管理员凭据认证的用户。
- en: 'The next configuration tweak needs to be performed in JBoss web deployment''s
    descriptor `WEB-INF/jboss-web.xml`. There, you need to declare the security domain
    that will be used to authenticate the users. Have a look at the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置调整需要在JBoss web部署的描述符`WEB-INF/jboss-web.xml`中执行。在那里，你需要声明用于认证用户的security
    domain。请看以下代码：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Pay attention to the `security-domain` element. The value of this element must
    be exactly the same as the one you typed into the security domain's `name` attribute.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`security-domain`元素。此元素的值必须与你在安全域的`name`属性中输入的值完全相同。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For an overview of which JNDI names are valid in WildFly, please refer to the
    following link: [https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules](https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 WildFly 中哪些 JNDI 名称是有效的概述，请参阅以下链接：[https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules](https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules)。
- en: 'The following diagram outlines the whole configuration sequence as applied
    to a `Database` login module. Have a look at the following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图概述了应用于 `Database` 登录模块的整个配置序列。请查看以下图：
- en: '![Securing web applications](img/6232OS_10_06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![保护 Web 应用程序](img/6232OS_10_06.jpg)'
- en: 'Once you deploy your application, the outcome of this action should be a popup,
    requesting user authentication, as shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 部署您的应用程序后，此操作的输出应该是一个弹出窗口，请求用户身份验证，如下面的屏幕截图所示：
- en: '![Securing web applications](img/6232OS_10_07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![保护 Web 应用程序](img/6232OS_10_07.jpg)'
- en: Logging in with `admin`/`admin` will grant access to the application with the
    `Manager` role.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `admin`/`admin` 登录将授予 `Manager` 角色访问应用程序的权限。
- en: Securing EJBs
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护 EJB
- en: Securing applications by means of a web login form is the most frequent option
    in enterprise applications. Nevertheless, the HTTP protocol is not the only choice
    available to access applications. For example, EJBs can be accessed by remote
    clients using the RMI-IIOP protocol. In such a case, you should further refine
    your security policies by restricting access to the EJB components, which are
    usually involved in the business layer of your applications.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Web 登录表单保护应用程序是企业应用程序中最常见的选项。尽管如此，HTTP 协议并不是访问应用程序的唯一选择。例如，EJB 可以通过 RMI-IIOP
    协议由远程客户端访问。在这种情况下，您应该进一步细化您的安全策略，通过限制对 EJB 组件的访问，这些组件通常涉及您应用程序的业务层。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**How does security happen at EJB level?**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**EJB 层级的安全是如何实现的？**'
- en: Authentication must be performed before any EJB method is called, and authorization
    should be performed at the beginning of each EJB method call.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用任何 EJB 方法之前必须执行身份验证，并且应该在每次 EJB 方法调用开始时执行授权。
- en: 'The basic security checks can be achieved using the following five annotations:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的安全检查可以使用以下五个注解实现：
- en: '`@org.jboss.ejb3.annotation.SecurityDomain`: This annotation specifies the
    security domain, which is associated with a specific class.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@org.jboss.ejb3.annotation.SecurityDomain`：此注解指定安全域，它与一个特定的类相关联。'
- en: '`@javax.annotation.security.RolesAllowed`: This annotation specifies the list
    of roles permitted to access a method(s) in an EJB.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.RolesAllowed`：此注解指定了允许访问 EJB 中方法（s）的角色的列表。'
- en: '`@javax.annotation.security.RunAs`: This annotation assigns a role dynamically
    to the EJB during the invocation of a method. It can be used if you need to *temporarily*
    allow permission to access a certain method.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.RunAs`：此注解在调用方法期间动态地将一个角色分配给 EJB。如果需要临时允许访问某个方法，可以使用它。'
- en: '`@javax.annotation.security.PermitAll`: This annotation allows all roles to
    access a particular bean method. The purpose of this annotation is to widen security
    access to some methods in a situation where you don''t exactly know what role
    will access the EJB. (Imagine that some modules have been developed by a third
    party and they access your EJB with some poorly identified roles).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.PermitAll`：此注解允许所有角色访问特定的 bean 方法。此注解的目的是在您不确定哪个角色将访问
    EJB 的情况下扩大某些方法的安全访问权限。（想象一下，某些模块是由第三方开发的，并且它们使用一些标识不清的角色访问您的 EJB）。'
- en: '`@javax.annotation.security.DenyAll`: This annotation denies access to all
    roles. It has a purpose similar to that of `PermitAll`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.DenyAll`：此注解拒绝所有角色的访问。它的目的与 `PermitAll` 类似。'
- en: 'In the following example, we are restricting access to the EJB named `SecureEJB`
    only to the authorized role of Manager:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们仅将访问名为 `SecureEJB` 的 EJB 的权限限制在授权的 Manager 角色中：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful! There is more than one `SecurityDomain` annotation available in
    the server's classpath. As shown here, you have to include `org.jboss.ejb3.annotation.SecurityDomain`.
    The `@RolesAllowed` annotation, on the other hand, calls for importing `javax.annotation.security.RolesAllowed`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！服务器类路径中存在多个 `SecurityDomain` 注解。如图所示，您必须包含 `org.jboss.ejb3.annotation.SecurityDomain`。另一方面，`@RolesAllowed`
    注解需要导入 `javax.annotation.security.RolesAllowed`。
- en: 'Annotations can also be applied at the method level. For example, if we need
    a special role named `SuperUser` to insert a new user, then we tag the method,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注解也可以应用于方法级别。例如，如果我们需要一个名为`SuperUser`的特殊角色来插入新用户，那么我们可以像以下那样标记方法：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Securing web services
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护Web服务
- en: Web services authorization can be carried out in two ways, depending on whether
    we are dealing with a POJO-based web service or EJB-based web services.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务授权可以通过两种方式执行，具体取决于我们是否处理基于POJO的Web服务或基于EJB的Web服务。
- en: Security changes to POJO web services are identical to those that we introduced
    for servlets or JSP, which include defining `security-constraints` into `web.xml`
    and login modules into `jboss-web.xml`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对POJO Web服务的安全更改与我们为servlets或JSP引入的更改相同，包括在`web.xml`中定义`security-constraints`以及在`jboss-web.xml`中定义登录模块。
- en: 'If you are using a web client to access your web service, that''s all you need
    to get authenticated. If you are using a standalone client, you will need to specify
    the credentials to the JAX-WS factory, as shown in the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Web客户端访问您的Web服务，那么您只需要进行认证。如果您使用的是独立客户端，您将需要指定给JAX-WS工厂的凭据，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What about EJB-based web services? The configuration is slightly different.
    As the security domain is not specified in the web descriptors, we have to provide
    it by means of annotations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，基于EJB的Web服务怎么办？配置略有不同。由于安全域没有在Web描述符中指定，我们必须通过注解提供它：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `@WebContext` annotation reflects the same configuration
    options as POJO-based web services, with BASIC authentication and unrestricted
    WSDL access.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`@WebContext`注解反映了与基于POJO的Web服务相同的配置选项，包括BASIC身份验证和无限制的WSDL访问。
- en: The `@SecurityDomain` annotation should be familiar to you now, as we introduced
    it when showing you how to secure an EJB. As you can see in the preceding web
    service example, it is the equivalent of the information contained in the `jboss-web.xml`
    file (it references the `mysqldomain` security domain).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对`@SecurityDomain`注解很熟悉了，因为我们是在向您展示如何保护EJB时引入它的。正如您在先前的Web服务示例中所见，它与`jboss-web.xml`文件中的信息相当（它引用了`mysqldomain`安全域）。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you prefer using XML deployment descriptors, the previous security configuration
    can also be specified by means of the `META-INF/ejb-jar.xml` and `META-INF/jboss-ejb3.xml`
    files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用XML部署描述符，先前的安全配置也可以通过`META-INF/ejb-jar.xml`和`META-INF/jboss-ejb3.xml`文件指定。
- en: Securing the management interfaces
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护管理接口
- en: One of the most important tasks for the system administrator is restricting
    access to the server management interfaces. Without a security policy, every user
    can gain access to the application server and modify its properties.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于系统管理员来说，最重要的任务之一是限制对服务器管理接口的访问。如果没有安全策略，每个用户都可以访问应用服务器并修改其属性。
- en: 'The attribute that is used to switch on security on the management interface
    is a security realm that needs to be defined within the `security-realms` section.
    Have a look at the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在管理接口上启用安全性的属性是一个需要在`security-realms`部分中定义的安全领域。请查看以下代码：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the default configuration, the user properties are stored in the `mgmt-users.properties`
    file and the group properties in the `mgmt-groups.properties` file. Both these
    files can be found in the `configuration` directory of your server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，用户属性存储在`mgmt-users.properties`文件中，组属性存储在`mgmt-groups.properties`文件中。这两个文件都可以在您的服务器`configuration`目录中找到。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Users and groups can be added to these property files at any time. Any updates
    after the server has started are detected automatically.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和组可以随时添加到这些属性文件中。服务器启动后的任何更新都会自动检测。
- en: 'By default, this management realm expects the entries to be in the following
    format:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此管理领域期望条目以以下格式：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means that each user is associated with a hex-encoded hash that consists
    of the username, the name of the realm, and the password.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个用户都与一个由用户名、领域名称和密码组成的十六进制编码哈希相关联。
- en: 'To add new users, you can use the utility script contained in the `bin` folder
    of your WildFly installation named `add-user.sh` (Linux) or `add-user.bat` (Windows).
    As you can see from the following screenshot, the `add-user` script requires the
    following pieces of information:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新用户，您可以使用包含在您的WildFly安装的`bin`文件夹中的实用脚本，脚本名为`add-user.sh`（Linux）或`add-user.bat`（Windows）。从下面的屏幕截图可以看出，`add-user`脚本需要以下信息：
- en: '**Realm**: This is the name of the realm used to secure the management interfaces.
    If you just press *Enter*, the user will be added in the default realm named `ManagementRealm`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**：这是用于保护管理界面的领域名称。如果您只按*Enter*键，用户将被添加到默认领域`ManagementRealm`。'
- en: '**Username**: This is the username we are going to add (it needs to be alphanumeric).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：这是我们打算添加的用户名（它必须是字母数字的）。'
- en: '**Password**: This is the password field, which needs to be different from
    the username.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：这是密码字段，它需要与用户名不同。'
- en: '**Groups**: This is the name of the group you want the user to be part of.
    If you leave this blank, you will not be added to any groups.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：这是您希望用户所属的组名称。如果您留空，您将不会被添加到任何组。'
- en: '**AS process**: This determines whether you want the user to be used to connect
    to another WildFly instance.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AS进程**：这决定了您是否希望用户用于连接到另一个WildFly实例。'
- en: '![Securing the management interfaces](img/6232OS_10_08.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![保护管理接口](img/6232OS_10_08.jpg)'
- en: 'Here, we have just added the user `chris` to the default realm. This resulted
    in the following property being added to `mgmt-users.properties` of your standalone
    and domain configurations:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已将用户`chris`添加到默认领域。这导致以下属性被添加到您的独立和域配置的`mgmt-users.properties`中：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will now be able to connect to a remote WildFly management interface using
    this user, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用此用户连接到远程WildFly管理界面，如下面的截图所示：
- en: '![Securing the management interfaces](img/6232OS_10_09.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![保护管理接口](img/6232OS_10_09.jpg)'
- en: 'A much easier way to add users is to use a non-interactive shell. This approach
    works by passing the username, password, and optionally the realm name to the
    `add-user` script:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用户的一个更简单的方法是使用非交互式shell。这种方法通过将用户名、密码以及可选的领域名称传递给`add-user`脚本来实现：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Role-based access control
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: '**Role-based access control** (**RBAC**) is a new feature introduced in WildFly
    8\. It allows system administrators to create users for the administration console
    but with restrictions to certain parts of the system. In JBoss AS 7, an admin
    console user had access to everything, which is equivalent to the SuperUser role
    in WildFly 8.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（**RBAC**）是WildFly 8中引入的新功能。它允许系统管理员为管理控制台创建用户，但对其系统的一部分有权限限制。在JBoss
    AS 7中，管理控制台用户可以访问一切，这在WildFly 8中相当于超级用户角色。'
- en: 'RBAC is not enabled by default. To enable it, run the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC默认未启用。要启用它，请运行以下命令：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, reload the server config:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新加载服务器配置：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you have existing users before enabling RBAC, you need to manually configure
    each user by mapping that user to a role. If we had a user called Yevai and wanted
    to assign her the role of SuperUser, we would do the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启用RBAC之前您已有现有用户，您需要手动为每个用户配置，通过将用户映射到角色。如果我们有一个名为Yevai的用户，并希望分配给她超级用户角色，我们会执行以下操作：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are seven predefined roles in WildFly 8\. Each of them is outlined in
    the following table. They are ordered with the most restrictive roles at the top
    and the least restrictive at the bottom.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 8中有七个预定义的角色。以下表格概述了每个角色。它们按最限制性的角色在上，最不限制性的角色在下排序。
- en: '| Role | Permissions |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 角色 | 权限 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Monitor | This user can read the configuration and the current runtime state
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 监视器 | 此用户可以读取配置和当前运行时状态 |'
- en: '| Operator | This user has all the permissions of the preceding role, and can
    modify the runtime state, such as restarting or reloading the server, and flushing
    the database connection pool |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 操作员 | 此用户具有先前角色的所有权限，可以修改运行时状态，例如重启或重新加载服务器，以及刷新数据库连接池 |'
- en: '| Maintainer | This user has all the permissions of all the preceding roles,
    and can modify the persistent state, such as deploying applications and setting
    up new datasources |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 维护者 | 此用户具有所有先前角色的所有权限，可以修改持久状态，例如部署应用程序和设置新的数据源 |'
- en: '| Deployer | This user has all the permissions of all the preceding roles,
    but with permissions to applications only. This user cannot change the configuration
    of the server |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 部署者 | 此用户具有所有先前角色的所有权限，但只有对应用程序的权限。此用户不能更改服务器的配置 |'
- en: '| Administrator | This user has all the permissions of all the preceding roles,
    and can view and modify sensitive data, such as the access control system |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 管理员 | 此用户具有所有先前角色的所有权限，可以查看和修改敏感数据，例如访问控制系统 |'
- en: '| Auditor | This user has all the permissions of all the preceding roles, and
    can view and modify resources to administer the audit-logging system |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 审计员 | 此用户具有所有先前角色的权限，可以查看和修改资源以管理审计日志系统 |'
- en: '| SuperUser | This user has all permissions |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 超级用户 | 此用户拥有所有权限 |'
- en: Configuring groups
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置组
- en: 'One of the new features in WildFly is the ability to assign users to groups.
    This means that you can assign a bunch of users to a group and then the group
    to a role. To create a new user and assign them to a group, you can run the following
    noninteractive command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly的新特性之一是能够将用户分配到组中。这意味着您可以将一组用户分配到组中，然后将组分配到角色中。要创建新用户并将他们分配到组中，您可以运行以下非交互式命令：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Users can be managed via the admin console by a user who has the role of either
    Administrator or SuperUser. To do this, log in to the admin console, and navigate
    to the **Administration** tab. Here, you can add users to groups, create groups,
    and finally view members of each role. Have a look at the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过具有管理员或超级用户角色的用户通过管理控制台进行管理。为此，请登录到管理控制台，并导航到**管理**选项卡。在这里，您可以向组添加用户，创建组，并最终查看每个角色的成员。请看以下截图：
- en: '![Configuring groups](img/6232OS_10_09a.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![配置组](img/6232OS_10_09a.jpg)'
- en: Securing the transport layer
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护传输层
- en: If you create a mission-critical application with just the bare concepts we
    covered until now, you will not be guaranteed to be shielded from all security
    threats. For example, if you need to design a payment gateway, where credit card
    information is transmitted by means of an EJB or servlet, using just the authorization
    and authentication stack is really not enough.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用我们至今为止所涵盖的裸概念来创建一个关键任务应用程序，你不能保证能够免受所有安全威胁。例如，如果你需要设计一个支付网关，其中信用卡信息通过EJB或servlet进行传输，仅仅使用授权和认证堆栈是远远不够的。
- en: In order to prevent disclosure of information, you have to use a protocol that
    provides data **encryption**. Encryption is the conversion of data into a form
    that cannot be understood by people or systems eavesdropping on your network.
    Conversely, **decryption** is the process of converting encrypted data back into
    its original form, so it can be understood.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止信息泄露，你必须使用提供数据**加密**的协议。加密是将数据转换为人们或监听你网络的系统无法理解的形式。相反，**解密**是将加密数据转换回其原始形式的过程，以便它可以被理解。
- en: The protocols used to secure communication are SSL and TLS, the latter being
    considered a replacement for the older SSL.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用于保护通信的协议是SSL和TLS，后者被认为是较旧SSL的替代品。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The differences between the two protocols are minor. TLS uses *stronger* encryption
    algorithms and has the ability to work on different ports. For the rest of our
    chapter, we will refer to SSL for both protocols.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种协议之间的差异很小。TLS使用**更强的**加密算法，并且能够在不同的端口上工作。在接下来的章节中，我们将对这两种协议都使用SSL。
- en: 'There are two basic techniques to encrypt information: **symmetric encryption**
    (also called **secret key** encryption) and **asymmetric encryption** (also called
    **public key** encryption).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 加密信息有两种基本技术：**对称加密**（也称为**密钥加密**）和**非对称加密**（也称为**公钥加密**）。
- en: Symmetric encryption is the oldest and best-known technique. It is based on
    a secret key, which is applied to the text of a message to change the content
    in a particular way. As long as both the sender and recipient know the secret
    key, they can encrypt and decrypt all messages that use this key. These encryption
    algorithms typically work fast and are well-suited to encrypting blocks of messages
    at once.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密是最古老且最知名的技术。它基于一个密钥，该密钥应用于消息的文本以以特定方式更改内容。只要发送者和接收者都知道密钥，他们就可以加密和解密使用此密钥的所有消息。这些加密算法通常运行得很快，非常适合一次性加密大量消息。
- en: One significant issue with symmetric algorithms is the requirement of an organization
    to distribute keys to users. This generally results in more overhead from the
    administrative aspect, while the keys remain vulnerable to unauthorized disclosure
    and potential misuse.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对称算法的一个显著问题是组织需要向用户分发密钥。这通常会导致在管理方面产生更多的开销，同时密钥仍然容易受到未经授权的披露和潜在滥用的威胁。
- en: For this reason, a mission-critical enterprise system usually relies on asymmetric
    encryption algorithms. These tend to be easier to employ, manage, and make the
    system ultimately more secure.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个关键任务的企业系统通常依赖于非对称加密算法。这些算法通常更容易部署、管理和维护，从而使系统最终更加安全。
- en: 'Asymmetric cryptography, also known as public key cryptography, is based on
    the concept that the key used to encrypt the message is not the one used to decrypt
    the message. Each user holds a couple of keys: the public key, which is distributed
    to other parties, and the private key, which is kept in secret. Each message is
    encrypted with the recipient''s public key and can only be decrypted (by the recipient)
    with their private key. Have a look at the following diagram:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密，也称为公钥加密，基于这样一个概念：用于加密消息的密钥不是用于解密消息的密钥。每个用户都持有两把密钥：公钥，它被分发给其他各方，私钥，它被保密保存。每条消息都使用接收者的公钥进行加密，并且只能用他们的私钥解密（由接收者解密）。看看下面的图示：
- en: '![Securing the transport layer](img/6232OS_10_10.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![保护传输层](img/6232OS_10_10.jpg)'
- en: Using asymmetric encryption, you can be sure that your message cannot be disclosed
    by a third party. However, you *still* have one vulnerability.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称加密，你可以确保你的消息不会被第三方泄露。然而，你**仍然**有一个漏洞。
- en: Let's suppose you want to exchange information with a business partner, so you
    are requesting their public key by telephone or by e-mail. A fraudulent user intercepts
    your e-mail or simply listens to your conversation and quickly sends you a fake
    e-mail with their public key. Now, even if your data transmission is secured,
    it will be directed to the wrong person! This type of eavesdropping is called
    the man-in-the-middle attack.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想与一个商业伙伴交换信息，因此你通过电话或电子邮件请求他们的公钥。一个欺诈用户拦截你的电子邮件或简单地监听你的对话，并迅速发送一个带有他们公钥的伪造电子邮件给你。现在，即使你的数据传输是安全的，它也会被错误地发送给错误的人！这种监听被称为中间人攻击。
- en: In order to solve this issue, we need a document that verifies that the public
    key belongs to an individual. This document is called a **digital certificate**
    or the public key certificate. A digital certificate consists of a formatted block
    of data that contains the name of the certificate holder (which may be either
    a username or a system name), the holder's public key, and the digital signature
    of a **Certification Authority** (**CA**) for authentication. The certification
    authority attests that the sender's name is the one associated with the public
    key in the document.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一个文件来验证公钥属于个人。这个文件被称为**数字证书**或公钥证书。数字证书由一个格式化的数据块组成，包含证书持有者的名称（可能是用户名或系统名）、持有者的公钥以及**认证机构**（**CA**）的数字签名以进行认证。认证机构证明发送者的名称与文件中公钥关联。
- en: 'A prototype of a digital certificate is shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个数字证书的原型：
- en: '![Securing the transport layer](img/6232OS_10_11.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![保护传输层](img/6232OS_10_11.jpg)'
- en: Public key certificates are commonly used for secure interaction with websites.
    By default, web browsers ship with a set of predefined CAs. They are used to verify
    that the public certificate served to the browser when you enter a secure site
    has been actually issued by the owner of the website. In short, if you connect
    your browser to `https://www.abc.com` and your browser doesn't give certificate
    warning, you can be sure that you can safely interact with the entity in charge
    of the site.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥证书通常用于与网站进行安全交互。默认情况下，网络浏览器附带一组预定义的CA。它们用于验证当你输入一个安全网站时，浏览器收到的公钥证书确实是由网站所有者签发的。简而言之，如果你通过浏览器连接到`https://www.abc.com`并且你的浏览器没有给出证书警告，你可以确信你可以安全地与网站负责实体进行交互。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Simple authentication and client authentication**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单身份验证和客户端身份验证**'
- en: In the previous example, we depicted a simple server authentication. In this
    scenario, the only party that needs to prove its identity is the server.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们描述了一个简单的服务器身份验证。在这种情况下，唯一需要证明其身份的方是服务器。
- en: However, SSL is also able to perform a **mutual** **authentication** (also called
    client or two-way authentication) in case the server requests a client certificate
    during the SSL handshake over the network.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SSL也能够在网络中的SSL握手期间执行**双向****认证**（也称为客户端或双向认证），如果服务器在SSL握手期间请求客户端证书的话。
- en: The client authentication requires a client certificate in the X.509 format
    from a CA. The X.509 format is an industry-standard format for SSL certificates.
    In the next section, we will explore the available tools to generate digital certificates
    and also how you can have your certificates signed by a CA.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端认证需要一个来自CA的X.509格式的客户端证书。X.509格式是SSL证书的行业标准格式。在下一节中，我们将探讨可用的生成数字证书的工具，以及如何让您的证书由CA签名。
- en: Enabling the Secure Socket Layer
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用安全套接字层
- en: WildFly uses the **Java Secure Socket Extension** (**JSSE**), which is bundled
    in the Java Standard Edition to leverage the SSL/TLS communication.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly使用**Java安全套接字扩展**（**JSSE**），这是Java标准版中捆绑的，以利用SSL/TLS通信。
- en: 'An enterprise application can secure two protocols: HTTP and RMI. HTTP communication
    is handled by the Undertow subsystem within the `standalone.xml`/`domain.xml`
    file. Securing the RMI transport is not always a compelling requirement for your
    applications as, in most production environments, WildFly is placed behind a firewall.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序可以安全地使用两种协议：HTTP和RMI。HTTP通信由`standalone.xml`/`domain.xml`文件内的Undertow子系统处理。对于您的应用程序来说，确保RMI传输的安全性并不总是强制性的要求，因为在大多数生产环境中，WildFly位于防火墙后面。
- en: As you can see from the following diagram, your EJBs are not directly exposed
    to untrusted networks and are usually connected via a web server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，您的EJBs不是直接暴露在不信任的网络中，通常是通过一个Web服务器连接的。
- en: '![Enabling the Secure Socket Layer](img/6232OS_10_12.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![启用安全套接字层](img/6232OS_10_12.jpg)'
- en: In order to configure WildFly to use SSL, we need a tool that generates a public
    key/private key pair in the form of an X.509 certificate for use by the SSL server
    sockets. This is covered in the next section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置WildFly使用SSL，我们需要一个工具，该工具以X.509证书的形式生成公钥/私钥对，用于SSL服务器套接字。这将在下一节中介绍。
- en: Certificate management tools
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书管理工具
- en: One tool that can be used to set up a digital certificate is `keytool`, a key
    and certificate management utility that ships with the Java SE. It enables users
    to administer their own public/private key pairs and associated certificates for
    use in self-authentication (where the user authenticates himself or herself to
    other users or services) or data integrity and authentication services using digital
    signatures. It also allows users to cache the public keys (in the form of certificates)
    of their communicating peers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来设置数字证书的一个工具是`keytool`，这是一个与Java SE一起提供的密钥和证书管理实用程序。它使用户能够管理自己的公钥/私钥对及其相关的证书，用于自我认证（用户向其他用户或服务进行身份验证）或使用数字签名进行数据完整性和认证服务。它还允许用户缓存其通信对等方的公钥（以证书的形式）。
- en: 'The `keytool` certificate stores the keys and certificates in a file termed
    as `keystore`, a repository of certificates used to identify a client or a server.
    Typically, a `keystore` contains a single client or server''s identity, which
    is password protected. Let''s see an example of `keystore` generation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`keytool`证书将密钥和证书存储在一个称为`keystore`的文件中，这是一个用于识别客户端或服务器的证书存储库。通常，`keystore`包含单个客户端或服务器的身份，并受密码保护。让我们看看`keystore`生成的示例：'
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command creates the `keystore` named `wildfly.keystore` in the working
    directory and assigns it the password `mypassword`. It generates a public/private
    key pair for the entity whose "distinguished name" has a common name `packtpub`,
    the organization `PacktPub`, and a two-letter country code of `GB`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在当前工作目录中创建名为`wildfly.keystore`的`keystore`，并为其分配密码`mypassword`。它为具有“区分名称”中通用名`packtpub`、组织`PacktPub`和两个字母国家代码`GB`的实体生成一个公钥/私钥对。
- en: This results in a self-signed certificate (using the RSA signature algorithm)
    that includes the public key and the distinguished-name information. This certificate
    will be valid for 180 days and is associated with the private key in a `keystore`
    entry referred to by the alias as `wildflybook`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个自签名证书（使用RSA签名算法），其中包含公钥和区分名称信息。此证书将有效期为180天，并与`keystore`条目中引用的别名`wildflybook`关联的私钥相关联。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A self-signed certificate is a certificate that has not been verified by a CA
    and hence leaves you vulnerable to the classic man-in-the-middle attack. A self-signed
    certificate is only suitable for in-house use or for testing while you wait for
    the official certificate to arrive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书是一种未经CA验证的证书，因此会使您容易受到经典的中间人攻击。自签名证书仅适用于内部使用或测试，直到官方证书到达。
- en: Securing HTTP communication with a self-signed certificate
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自签名证书确保HTTP通信
- en: Now let's see how you can use this `keystore` file to secure your WildFly web
    channel. Open the server configuration file (`standalone.xml/domain.xml`), and
    navigate to the undertow subsystem.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用这个`keystore`文件来确保你的WildFly Web通道的安全。打开服务器配置文件（`standalone.xml/domain.xml`），导航到Undertow子系统。
- en: 'First, we need to add an `https-listener` element to the server configuration,
    as shown in bold in the following code snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在服务器配置中添加一个`https-listener`元素，如下面的代码片段中加粗所示：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, create a new security realm within the `management` element. The mandatory
    attributes are highlighted in bold in the following code. There is the path of
    the keystore, along with its password. The `keystore` element also takes `alias`,
    `relative-to`, and `key-password` attributes, all of which are optional:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`management`元素内创建一个新的安全域。以下代码中加粗的属性是必需的。其中包括密钥库的路径及其密码。`keystore`元素还接受`alias`、`relative-to`和`key-password`属性，这些都是可选的：
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Last of all, you will need to copy the `wildfly.keystore` file to your `JBOSS_HOME/standalone/configuration`
    folder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将`wildfly.keystore`文件复制到你的`JBOSS_HOME/standalone/configuration`文件夹。
- en: Restart WildFly to load these changes. At the bottom of your console logs, during
    server startup, you should see the following printout (**Undertow HTTPS listener
    https listening on /127.0.0.1:8443**).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动WildFly以加载这些更改。在控制台日志的底部，在服务器启动期间，你应该看到以下输出（**Undertow HTTPS监听器https正在监听/127.0.0.1:8443**）。
- en: '![Securing HTTP communication with a self-signed certificate](img/6232OS_10_12a.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![使用自签名证书确保HTTP通信](img/6232OS_10_12a.jpg)'
- en: 'If you try to access a web application via HTTPS on your SSL-configured WildFly
    server, for example, if you deploy `chapter4` and access it via `https://localhost:8443/chapter4`,
    you will be greeted by the following screen (the screen displayed will depend
    on your browser):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你通过SSL配置的WildFly服务器上的HTTPS访问Web应用程序，比如部署`chapter4`并通过`https://localhost:8443/chapter4`访问它，你会看到以下屏幕（显示的屏幕将取决于你的浏览器）：
- en: '![Securing HTTP communication with a self-signed certificate](img/6232OS_10_13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![使用自签名证书确保HTTP通信](img/6232OS_10_13.jpg)'
- en: If you are unfamiliar with how certificates work, once the browser has established
    a secure connection with the web server, the web server sends a certificate back
    to the browser. Because the certificate we just installed has *not been* signed
    by any recognized CA, the browser security sandbox warns the user about the potential
    security threat.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对证书的工作方式不熟悉，一旦浏览器与Web服务器建立了安全连接，Web服务器就会向浏览器发送一个证书。因为我们刚刚安装的证书**没有被**任何认可的CA签名，浏览器安全沙盒会警告用户潜在的安全威胁。
- en: As this is an in-house test, we can safely proceed by choosing **I Understand
    the Risks** | **Add Exception** | **Confirm Security Exception**. That's all you
    need to do in order to activate the SSL with a self-signed certificate.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个内部测试，我们可以通过选择**我了解风险** | **添加异常** | **确认安全异常**来安全地继续。这就是激活自签名证书的SSL所需做的全部。
- en: Securing the HTTP communication with a certificate signed by a CA
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CA签名的证书确保HTTP通信
- en: In order to get a certificate that your browser recognizes, you need to issue
    a **certificate-signing request** (**CSR**) to a CA. The CA will then return a
    signed certificate that can be installed on your server. Most of these services
    are not free. The cost depends on the number of certificates you are requesting,
    the encryption strength, and other factors. StartSSL provides a free, low assurance
    certificate for servers on a public domain name.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得浏览器能识别的证书，你需要向CA发出**证书签名请求**（**CSR**）。CA随后将返回一个可以在你的服务器上安装的已签名证书。大多数这些服务都不是免费的。费用取决于你请求的证书数量、加密强度和其他因素。StartSSL为公共域名服务器提供免费、低保证的证书。
- en: 'So, to generate a CSR, you need to use the `keystore` that you created earlier
    and `keyentry`. Have a look at the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要生成CSR，你需要使用你之前创建的`keystore`和`keyentry`。看看以下代码：
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will create a new certificate request named `certreq.csr`, with the format
    shown here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`certreq.csr`的新证书请求，格式如下所示：
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following certificate needs to be sent to a CA assuming, for example, you
    have chosen **Verisign** ([http://www.verisign.com](http://www.verisign.com))
    as the CA:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你选择了**Verisign** ([http://www.verisign.com](http://www.verisign.com)) 作为CA，以下证书需要发送给CA：
- en: '![Securing the HTTP communication with a certificate signed by a CA](img/6232OS_10_14.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![由CA签发的证书加密HTTP通信](img/6232OS_10_14.jpg)'
- en: 'After submitting your CSR, the CA will return a signed certificate that needs
    to be imported into your keychain. Let''s suppose that you have saved your CA
    certificate in a file named `signed_ca.txt`. Have a look at the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交你的CSR后，CA将返回一个需要导入到你的密钥链中的已签名证书。假设你将你的CA证书保存在一个名为`signed_ca.txt`的文件中。请看以下命令：
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `-import` option is used to add a certificate or certificate chain
    to the list of trusted certificates as specified by the `-keystore` parameter
    and identified by the `-alias` parameter. The parameter `-storepass` specifies
    the password that is used to protect the `keystore`. If the `-keypass` option
    is not provided, and the private key password is different from the `keystore`
    password, you will be prompted for it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-import`选项用于将证书或证书链添加到由`-keystore`参数指定并由`-alias`参数标识的受信任证书列表中。参数`-storepass`指定用于保护`keystore`的密码。如果未提供`-keypass`选项，并且私钥密码与`keystore`密码不同，系统将提示输入。
- en: Now, your web browser will recognize your new certificate as being signed by
    a CA and will no longer complain that it cannot validate the certificate.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的网络浏览器将识别你的新证书是由CA签发的，并且将不再抱怨无法验证证书。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter discussing the basic concepts of security and the difference
    between authentication and authorization.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时讨论了安全的基本概念以及认证和授权之间的区别。
- en: Authentication is used to verify the identity of a user, while authorization
    is used to check if the user has the rights to access a particular resource.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 认证用于验证用户的身份，而授权用于检查用户是否有权访问特定资源。
- en: WildFly uses the PicketBox framework. PicketBox sits at the top of the Java
    Authentication and Authorization Service (JAAS) and secures all the Java EE technologies
    running in the application. The core section of the security subsystem is contained
    in the security-domain element, which performs all the required authorization
    and authentication checks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly使用PicketBox框架。PicketBox位于Java身份验证和授权服务（JAAS）的顶部，并保护应用程序中运行的所有Java EE技术。安全子系统的核心部分包含在`security-domain`元素中，它执行所有必要的授权和身份验证检查。
- en: We then took a look at some of the login modules used to check user credentials
    against different datastores. Each login module can be used by enterprise applications
    in either a programmatic or a declarative way. While programmatic security can
    provide a fine-grained security model, you should consider using declarative security,
    which allows a clean separation between the business layer and the security policies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着查看了一些用于检查用户凭证与不同数据存储库的登录模块。每个登录模块都可以以编程方式或声明方式由企业应用程序使用。虽然编程安全可以提供细粒度的安全模型，但你应考虑使用声明式安全，它允许业务层和安全策略之间的清晰分离。
- en: Later in the chapter, you saw how you can secure the management interfaces,
    namely, the new command-line interface, by adding a security realm to them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你看到了如何通过向它们添加安全域来保护管理接口，即新的命令行界面。
- en: In the last section of this chapter, we looked at how you can encrypt the communication
    channel using the Secure Socket Layer and how you can use certificates produced
    by the `keytool` Java utility.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们探讨了如何使用安全套接字层（Secure Socket Layer）加密通信通道，以及如何使用由`keytool` Java实用程序生成的证书。
- en: In the next chapter, we will end our discussion of WildFly by showing how you
    can configure and distribute enterprise applications on OpenShift, a JBoss cloud
    solution.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过展示如何在OpenShift上配置和分发企业应用程序来结束对WildFly的讨论，OpenShift是一个JBoss云解决方案。
