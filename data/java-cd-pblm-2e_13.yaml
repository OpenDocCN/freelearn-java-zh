- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Socket API and Simple Web Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket API 和简单 Web 服务器
- en: This chapter includes 11 problems covering the Socket API and 8 problems covering
    JDK 18 **Simple Web Server** (**SWS**). In the first 11 problems we will discuss
    implementing socket-based applications such as blocking/non-blocking server/client
    applications, datagram-based applications, and multicast applications. In the
    second part of this chapter, we discuss SWS as a command-line tool and a suite
    of API points.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括 11 个关于 Socket API 的问题和 8 个关于 JDK 18 **简单 Web 服务器**（**SWS**）的问题。在前 11 个问题中，我们将讨论实现基于套接字的应用程序，如阻塞/非阻塞服务器/客户端应用程序、基于数据报的应用程序和多播应用程序。在本章的第二部分，我们将讨论
    SWS 作为命令行工具和一系列 API 点。
- en: At the end of this chapter, you’ll know how to write applications via the Socket
    API and how to use SWS for testing, debugging, and prototyping tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何通过 Socket API 编写应用程序，以及如何使用 SWS 进行测试、调试和原型设计任务。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your advanced programming prowess in Socket
    API and SWS. I strongly encourage you to give each problem a try before you turn
    to the solutions and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试您在 Socket API 和 SWS 中的高级编程能力。我强烈建议您在查看解决方案和下载示例程序之前尝试解决每个问题：
- en: '**Introducing socket basics**: Provide a brief but meaningful introduction
    to socket basics and related context (TCP, UDP, IP, etc.).'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍套接字基础知识**：提供对套接字基础知识及其相关背景（TCP、UDP、IP 等）的简要但富有意义的介绍。'
- en: '**Introducing TCP server/client applications**: Introduce the knowledge needed
    for writing a blocking/non-blocking TCP server/client application.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 TCP 服务器/客户端应用程序**：介绍编写阻塞/非阻塞 TCP 服务器/客户端应用程序所需的知识。'
- en: '**Introducing the Java Socket API**: Highlight the main Socket API (NIO.2)
    needed for writing socket-based applications in Java.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Java Socket API**：突出编写基于套接字的 Java 应用程序所需的主要 Socket API（NIO.2）。'
- en: '**Writing a blocking TCP server/client application**: Provide a detailed example
    (theory and code) of a blocking TCP server/client application.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写阻塞 TCP 服务器/客户端应用程序**：提供一个阻塞 TCP 服务器/客户端应用程序的详细示例（理论和代码）。'
- en: '**Writing a non-blocking TCP server/client application**: Provide a detailed
    example (theory and code) of a non-blocking TCP server/client application.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写非阻塞 TCP 服务器/客户端应用程序**：提供一个非阻塞 TCP 服务器/客户端应用程序的详细示例（理论和代码）。'
- en: '**Writing UDP server/client applications**: Write a UDP server/client application
    including a connectionless client and a connected client.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写 UDP 服务器/客户端应用程序**：编写一个 UDP 服务器/客户端应用程序，包括无连接客户端和连接客户端。'
- en: '**Introducing multicasting**: Explain in simple terms the meaning of multicast.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍多播**：用简单的话解释多播的含义。'
- en: '**Exploring network interfaces**: Write a snippet of code that displays details
    about the network interfaces available on your machine.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**探索网络接口**：编写一段代码，显示您机器上可用的网络接口的详细信息。'
- en: '**Writing a UDP multicast server/client application**: Explain and exemplify
    the implementation of a UDP multicast-based application.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写 UDP 多播服务器/客户端应用程序**：解释并举例说明基于 UDP 多播的应用程序实现。'
- en: '**Adding Key Encapsulation Mechanism (KEM) to a TCP server/client application**:
    Explain and exemplify the usage of JDK 21 KEM for encrypting/decrypting the communication
    in a TCP server/client application.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将密钥封装机制 (KEM) 添加到 TCP 服务器/客户端应用程序中**：解释并举例说明 JDK 21 KEM 在 TCP 服务器/客户端应用程序中加密/解密通信的使用。'
- en: '**Reimplementing the legacy Socket API**: Provide a quick overview of the Socket
    API evolution among JDK releases.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新实现传统的 Socket API**：简要概述 JDK 版本之间 Socket API 的演变。'
- en: '**Quick overview of SWS**: Provide a brief introduction to the JDK 18 SWS.
    Explain how it works and what its key abstractions are.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SWS 快速概述**：简要介绍 JDK 18 SWS。解释其工作原理及其关键抽象。'
- en: '**Exploring the SWS command-line tool**: Provide a step-by-step guide for starting,
    using, and stopping SWS via the command line.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**探索 SWS 命令行工具**：提供通过命令行启动、使用和停止 SWS 的分步指南。'
- en: '**Introducing the com.sun.net.httpserver API**: Describe the pillars of the
    SWS API.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 com.sun.net.httpserver API**：描述 SWS API 的支柱。'
- en: '**Adapting request/exchange**: Provide a few snippets of code that adapt the
    SWS request/exchange for custom scenarios.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**适配请求/交换**：提供一些代码片段，以适应 SWS 请求/交换的定制场景。'
- en: '**Complementing a conditional HttpHandler with another handler**: Write an
    example that shows how to conditionally choose between two `HttpHandler` instances.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用另一个处理器补充条件 HttpHandler**：编写一个示例，展示如何有条件地选择两个 `HttpHandler` 实例。'
- en: '**Implementing SWS for an in-memory file system**: Write an SWS implementation
    that serves resources from an in-memory file system (for instance, the Google
    Jimfs in-memory file system or other similar solutions).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为内存文件系统实现SWS**：编写一个SWS实现，从内存文件系统中提供资源（例如，Google Jimfs内存文件系统或其他类似解决方案）。'
- en: '**Implementing SWS for a zip file system**: Write an SWS implementation that
    serves resources from a ZIP archive.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为ZIP文件系统实现SWS**：编写一个SWS实现，从ZIP存档中提供资源。'
- en: '**Implementing SWS for a Java runtime directory**: Write an SWS implementation
    that serves resources from a Java runtime directory (JEP 220).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为Java运行时目录实现SWS**：编写一个SWS实现，从Java运行时目录（JEP 220）中提供资源。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13)。
- en: 258\. Introducing socket basics
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 258. 介绍套接字基础
- en: The socket notion was introduced in the ‘80s. This notion was introduced on
    **Berkeley Software Distribution** (**BSD**) (a Unix flavor) as a solution for
    network communication between processes via **Internet Protocol** (**IP**). Java
    introduced its first cross-platform API for sockets in 1996 (JDK 1.0). As you’ll
    see soon, with just a few notions such as network interface, IP address and port,
    a Java developer can write applications that communicate via sockets.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字概念在20世纪80年代被引入。这个概念是在**伯克利软件发行版**（**BSD**）（一种Unix风味）中作为通过**互联网协议**（**IP**）在进程之间进行网络通信的解决方案而被引入的。Java在1996年（JDK
    1.0）引入了其第一个跨平台的套接字API。正如你很快就会看到的，只需几个概念，如网络接口、IP地址和端口，Java开发者就可以编写通过套接字进行通信的应用程序。
- en: At the IP level, data travels from source to destination in chunks (*packets*)
    of data. Each packet is seen as an individual entity and there is no guarantee
    that all packets sent from a source will hit the destination. Nevertheless, on
    top of IP, we have other protocols that are more popular such as **Transmission
    Control Protocol** (**TCP**) and **User Datagram Protocol** (**UDP**). Moreover,
    on top of these protocols, we have the well-known HTTP, DNS, Telnet, and so on.
    Machine communication via sockets works on IP, so Java applications that use the
    Socket API can communicate with other socket-based applications (servers) based
    on their predefined protocol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP层，数据以数据块（*数据包*）的形式从源传输到目的地。每个数据包被视为一个独立的实体，并且无法保证从源发送的所有数据包都会到达目的地。尽管如此，在IP之上，我们还有其他更流行的协议，如**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。此外，在这些协议之上，我们有众所周知的HTTP、DNS、Telnet等等。通过套接字进行机器通信基于IP，因此使用Socket
    API的Java应用程序可以基于它们预定义的协议与其他基于套接字的应用程序（服务器）进行通信。
- en: 'Every machine connected to the Internet is represented by a number or numerical
    label, which is commonly named the *IP address* of that machine. As Java developers,
    we should know that there are categories of IP addresses:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到互联网的每一台机器都由一个数字或数值标签表示，这通常被称为该机器的*IP地址*。作为Java开发者，我们应该知道IP地址有类别：
- en: IPv4 – IP addresses represented on 32 bits (for instance, `89.165.254.108`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4 – 以32位表示的IP地址（例如，`89.165.254.108`）
- en: IPv6 – IP addresses represented on 128 bits (for instance, `2001:db8:3333:4444:5555:6666:7777:8888`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6 – 以128位表示的IP地址（例如，`2001:db8:3333:4444:5555:6666:7777:8888`）
- en: In addition, IP addresses are split into classes A, B, C, D, and E. For instance,
    class D of IP addresses ranges from `224.0.0.0` to `239.255.255.255` and is reserved
    for multicasting applications. And, of course, the `127.0.0.1` is a special IP
    reserved for *localhost*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IP地址被分为A、B、C、D和E类。例如，IP地址的D类范围从`224.0.0.0`到`239.255.255.255`，并保留用于多播应用。当然，`127.0.0.1`是一个为*localhost*保留的特殊IP地址。
- en: Now, speaking about ports, you should know that Java represents them as integers
    in the range `0`-`65535`. Some of the ports are famous and commonly associated
    with a certain type of server – for instance, port `80` is associated with an
    HTTP server, port `23` with a Telnet server, port `21` with an FTP server, and
    so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说到端口，你应该知道Java将它们表示为范围在`0`-`65535`的整数。一些端口是著名的，通常与某种类型的服务器相关联——例如，端口`80`与HTTP服务器相关联，端口`23`与Telnet服务器相关联，端口`21`与FTP服务器相关联，等等。
- en: 'While these notions have books that go deep into detail dedicated to them,
    we have enough information here to start writing server/client applications that
    rely on sockets. Practically, in such a server/client application, we have a server
    that runs on a host (a remote or localhost identified via an IP address and a
    port). While running, the server listens for incoming clients on a certain port.
    A client can locate the server via these two coordinates: the server IP address
    and the port. A client needs to present to the server a local port (automatically
    assigned by the kernel or explicitly set by us) that is used by the server to
    locate the client. A socket (client socket) is associated or bound to this local
    port and is used for communicating with the server. Upon acceptance, the server
    gets a socket (server socket) as well that is bound to a new local port (not the
    server port used for listening for incoming clients). Now, bidirectional communication
    can take place via these two sockets (endpoints).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有针对这些概念深入探讨的书籍，但在这里我们已有足够的信息开始编写依赖套接字的客户端/服务器应用程序。实际上，在这样的客户端/服务器应用程序中，我们有一个在主机（通过IP地址和端口号识别的远程或本地主机）上运行的服务器。在运行过程中，服务器会在特定端口上监听进入的客户端。客户端可以通过这两个坐标定位服务器：服务器的IP地址和端口号。客户端需要向服务器展示一个本地端口（由内核自动分配或由我们显式设置），服务器正是通过这个端口定位客户端。一个套接字（客户端套接字）与这个本地端口关联或绑定，并用于与服务器通信。一旦连接被接受，服务器也会得到一个套接字（服务器套接字），它绑定到一个新的本地端口（不是用于监听进入客户端的服务器端口）。现在，可以通过这两个套接字（端点）进行双向通信。
- en: 259\. Introducing TCP server/client applications
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 259. 介绍TCP服务器/客户端应用程序
- en: We don’t need to be TCP experts in order to write a Java server/client TCP-based
    application. While this topic (TCP) is detailed (very well-documented) in dedicated
    books and articles, let’s have a brief overview of TCP principles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要成为TCP专家就能编写基于Java的TCP服务器/客户端应用程序。虽然这个主题（TCP）在专门的书籍和文章中有详细的描述（非常完善的文档），但让我们简要概述一下TCP原理。
- en: 'TCP’s goal is to provide a point-to-point communication mechanism between two
    endpoints. Once the connection between these two endpoints is established (via
    sockets) it remains open during the communication until one of the sides closes
    it (usually, the client). In other words, two processes that are on different
    machines or the same machine can communicate with each other as in a telephone
    connection. In the following figure, you can see a classical server-client session
    based on sockets:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的目标是在两个端点之间提供点对点通信机制。一旦这两个端点之间的连接建立（通过套接字），在通信期间保持开放，直到其中一方关闭它（通常是客户端）。换句话说，位于不同机器或同一台机器上的两个进程可以像电话连接一样相互通信。在下面的图中，你可以看到一个基于套接字的经典服务器-客户端会话：
- en: '![Figure 13.1.png](img/B19655_13_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1.png](img/B19655_13_01.png)'
- en: 'Figure 13.1: Server/client session based on sockets (TCP)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：基于套接字的服务器/客户端会话（TCP）
- en: 'A server/client TCP connection is represented by certain coordinates as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器/客户端TCP连接通过以下坐标表示：
- en: The server side is represented by its IP address and port
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端通过其IP地址和端口号表示
- en: The client side is represented by its IP address and port
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通过其IP地址和端口号表示
- en: The server and client communicate via a protocol (UDP, TCP/IP, etc.)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端通过一种协议（UDP、TCP/IP等）进行通信
- en: As you can see in *Figure 13.1*, the server’s socket is bound and it listens
    for clients’ requests (the server can communicate with many clients at the same
    time). The client’s socket is bound and is ready to request a connection to the
    server. Once the connection is accepted, they can bidirectionally communicate
    (complete read/write operations) until the client closes the connection. The client
    can connect again later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图13.1*中看到的，服务器的套接字已绑定并监听客户端的请求（服务器可以同时与多个客户端通信）。客户端的套接字已绑定并准备好请求与服务器建立连接。一旦连接被接受，它们可以双向通信（完成读写操作），直到客户端关闭连接。客户端稍后可以再次连接。
- en: TCP (in contrast to UDP) is specialized in handling data packets being able
    to break data into packets, buffer data, and track-resend the lost or out-of-order
    data packets. Moreover, TCP is capable of controlling the speed of sending data
    in order to accommodate the processing capabilities of the receiver. TCP can send
    data as I/O streams of data or as byte arrays.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TCP（与 UDP 相比）擅长处理数据包，能够将数据分成数据包、缓冲数据以及跟踪重发丢失或顺序错误的数据包。此外，TCP 能够控制发送数据的速度，以适应接收者的处理能力。TCP
    可以将数据作为数据 I/O 流或字节数组发送。
- en: Blocking vs. non-blocking mechanisms
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞机制
- en: A Java TCP-based server/client application can be *blocking* or *non-blocking*.
    In a blocking application, a given thread is blocked until the I/O is completely
    received. So, the thread cannot do anything else until the I/O is ready to be
    processed – it will just hang on. On the other hand, in a non-blocking application,
    the I/O requests are queued and the thread is free to do other tasks. The queued
    requests will be processed later by the kernel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Java TCP 的服务器/客户端应用程序可以是 *阻塞* 或 *非阻塞*。在阻塞应用程序中，一个给定的线程会在 I/O 完全接收之前被阻塞。因此，该线程在
    I/O 准备好处理之前不能做任何事情——它只能挂起。另一方面，在非阻塞应用程序中，I/O 请求被排队，线程可以自由地执行其他任务。这些排队的请求将由内核稍后处理。
- en: From the Java implementation perspective, writing blocking applications is much
    easier than writing non-blocking applications. However, non-blocking applications
    are more performant and sustain scalability. NIO.2 supports both and we will implement
    both as well, but after a brief introduction to the Java Socket API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 实现的角度来看，编写阻塞应用程序比编写非阻塞应用程序要容易得多。然而，非阻塞应用程序的性能更高，并且能够持续扩展。NIO.2 支持这两种机制，我们也将实现这两种机制，但在介绍
    Java Socket API 之前。
- en: 260\. Introducing the Java Socket API
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 260. 介绍 Java Socket API
- en: Java Socket API support in Java has constantly evolved from JDK 1.0 to JDK 7\.
    Starting with JDK 7 and NIO.2, sockets support has been seriously improved with
    a new API (new classes and interfaces) for easily writing complex TCP/UDP-based
    applications. For instance, the `NetworkChannel` interface was introduced as a
    common implementation point for all network channel classes. Any class that implements
    `NetworkChannel` has access to common methods useful for handling channels to
    network sockets. Such classes are `SocketChannel`, `ServerSocketChannel`, and
    `DatagramChannel`. These classes take advantage of methods for handling local
    addresses and for configuring socket options via `SocketOption<T>` (interface)
    and `StandardSocketOptions` (class). Moreover, this API exposes methods for accessing
    remote addresses, checking connection status, and shutting down sockets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 Socket API 支持从 JDK 1.0 到 JDK 7 一直在不断进化。从 JDK 7 和 NIO.2 开始，通过引入新的 API（新的类和接口）来极大地改善了套接字支持，这使得编写复杂的
    TCP/UDP 应用程序变得容易。例如，`NetworkChannel` 接口被引入作为所有网络通道类的通用实现点。任何实现 `NetworkChannel`
    的类都可以访问处理通道到网络套接字的有用方法。这些类包括 `SocketChannel`、`ServerSocketChannel` 和 `DatagramChannel`。这些类利用了处理本地地址和通过
    `SocketOption<T>`（接口）和 `StandardSocketOptions`（类）配置套接字选项的方法。此外，此 API 还公开了访问远程地址、检查连接状态和关闭套接字的方法。
- en: One of the most important subinterfaces of `NetworkChannel` is `MulticastChannel`.
    This interface is implemented only by `DatagramChannel` and it knows how to map
    a network channel that is capable of providing IP multicasting. Anybody can get
    a membership key (like a token) that can be used to join a multicast group and
    become a member. The membership key is useful for customizing your presence in
    the multicast group (for instance, block or unblock datagrams based on their sender
    addresses).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkChannel` 的最重要的子接口之一是 `MulticastChannel`。此接口仅由 `DatagramChannel` 实现，并且知道如何将能够提供
    IP 多播的网络通道映射。任何人都可以获得一个成员密钥（类似于令牌），可以用来加入一个多播组并成为成员。成员密钥对于定制你在多播组中的存在非常有用（例如，根据发送者的地址阻塞或解阻塞数据报）。'
- en: Introducing NetworkChannel
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 NetworkChannel
- en: '`NetworkChannel` provides methods that are common to all sockets, so `NetworkChannel`
    is a pillar of the Socket API. One of the most important methods exposed by `NetworkChannel`
    is `bind()`. As its name suggests, this method binds a socket channel to a local
    address (or in short, a socket is associated with a local address). More precisely,
    a socket is bound to a local address via an instance of `InetSocketAddress` –
    this class extends the `SocketAddress` (abstract class) and it maps a socket address
    as a hostname (IP)-port pair. The `bind()` method returns the bound socket channel
    (server socket channel, datagram socket channel, and so on). The returned channel
    was explicitly/manually bound to the given host port or automatically (if no host
    port is given):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkChannel` 提供了适用于所有套接字的方法，因此 `NetworkChannel` 是 Socket API 的一个支柱。`NetworkChannel`
    揭示的最重要方法之一是 `bind()`。正如其名称所暗示的，此方法将套接字通道绑定到本地地址（或简称为套接字与本地地址相关联）。更确切地说，套接字通过 `InetSocketAddress`
    实例绑定到本地地址——此类扩展了 `SocketAddress`（抽象类）并将套接字地址映射为主机（IP）-端口号对。`bind()` 方法返回绑定的套接字通道（服务器套接字通道、数据报套接字通道等）。返回的通道被显式/手动绑定到给定的主机端口或自动绑定（如果没有提供主机端口）：'
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The bound local address can be obtained via `getLocalAddress()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `getLocalAddress()` 获取绑定本地地址：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If no address is present then this method returns `null`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有地址存在，则此方法返回 `null`。
- en: Tackling socket options
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理套接字选项
- en: 'A socket has several options represented via the `SocketOption<T>` interface.
    NIO.2 provides an implementation of `SocketChannel<T>` as a set of standard options
    via `StandardSocketOptions` as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个套接字有多个选项，这些选项通过 `SocketOption<T>` 接口表示。NIO.2 通过 `StandardSocketOptions` 提供了一组标准选项来实现
    `SocketChannel<T>`，如下所示：
- en: '`IP_MULTICAST_IF`: Via this option, we set the `NetworkInterface` used by a
    bounded datagram-oriented socket (or simply, datagram socket) for multicast datagrams.
    We can set this option explicitly or allow the **operating system** (**OS**) to
    choose one (if any is available) by leaving this option as default (`null`).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IP_MULTICAST_IF`：通过此选项，我们设置用于有界数据报套接字（或简称为数据报套接字）进行多播数据报的 `NetworkInterface`。我们可以显式设置此选项，或者允许
    **操作系统**（**OS**）选择一个（如果有可用的话）通过将此选项保留为默认值（`null`）。'
- en: '`IP_MULTICAST_LOOP`: This is a flag option (defaults to `true`) that can be
    set for a bounded datagram socket to control the *loopback* (`true` means that
    the sent data should be looped back to your host) of multicast datagrams.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IP_MULTICAST_LOOP`：这是一个标志选项（默认为 `true`），可以设置给有界数据报套接字，用于控制多播数据报的 **环回**（`true`
    表示发送的数据应回环到您的主机）。 '
- en: '`IP_MULTICAST_TTL`: This option applies to a bounded datagram socket. It is
    known as **time-to-live** (**TTL**) and is useful for setting the scope of multicast
    datagrams (setting the TTL for the multicast packets). By default, the value of
    this option is `1`, which means that multicast datagrams are not sent beyond the
    local network. The value of this option ranges between `0` and `255`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IP_MULTICAST_TTL`：此选项适用于有界数据报套接字。它被称为 **生存时间**（**TTL**），用于设置多播数据报的作用域（设置多播数据包的
    TTL）。默认情况下，此选项的值为 `1`，这意味着多播数据报不会发送到本地网络之外。此选项的值介于 `0` 和 `255` 之间。'
- en: '`IP_TOS`: Via this option, we set the value of the **type-of-service** (**ToS**)
    octet in IP packets for IPv4\. It can be set anytime for a bounded datagram socket
    and its default value is `0`. Further information on the ToS octet can be found
    in RFC 2474 and RFC 1349 (the interpretation of the ToS octet is network-specific).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IP_TOS`：通过此选项，我们设置 IPv4 数据包中 **服务类型**（**ToS**）八位字节的值。对于有界数据报套接字，此值可以随时设置，默认值为
    `0`。有关 ToS 八位字节的更多信息，请参阅 RFC 2474 和 RFC 1349（ToS 八位字节的解释是网络特定的）。'
- en: '`SO_BROADCAST`: This is a flag option that applies to a bounded datagram socket
    sending data to IPv4 broadcast addresses (defaults to `false`). When it is `true`,
    this option allows the transmission of broadcast datagrams.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_BROADCAST`：这是一个标志选项，适用于向 IPv4 广播地址发送数据的有界数据报套接字（默认为 `false`）。当它为 `true`
    时，此选项允许传输广播数据报。'
- en: '`SO_KEEPALIVE`: This is a flag option (defaults to `false`) that applies to
    a bounded socket for indicating if the connection should be kept alive by the
    OS or not.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_KEEPALIVE`：这是一个标志选项（默认为 `false`），适用于有界套接字，用于指示操作系统是否应该保持连接活跃。'
- en: '`SO_LINGER`: This option defines the so-called *linger interval* as an integer
    (timeout in seconds). The linger interval is specific to sockets that work in
    blocking mode only and it represents the timeout applied to the `close()` method.
    In other words, when the `close()` method is called on a socket, its execution
    will be blocked for this timeout (linger interval) while the OS attempts to transmit
    the unsent data (if it is possible). This option can be set at any time (by default,
    it has a negative value that is interpreted as disabled) and the maximum timeout
    is OS-specific.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_LINGER`: 这个选项定义了所谓的*linger间隔*为一个整数（以秒为单位的超时）。linger间隔仅适用于工作在阻塞模式的套接字，它代表了应用于`close()`方法的超时。换句话说，当在套接字上调用`close()`方法时，其执行将被阻塞在这个超时（linger间隔）期间，操作系统尝试传输未发送的数据（如果可能的话）。这个选项可以在任何时候设置（默认情况下，它有一个负值，表示禁用）并且最大超时值是操作系统特定的。'
- en: '`SO_RCVBUF`: This option is a positive integer that can be set before the socket
    is bound/connected (defaults to an OS-dependent value). You need this option if
    you want to set the size of the networking input buffer (in bytes).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_RCVBUF`: 这个选项是一个可以在套接字绑定/连接之前设置的整型值（默认值为操作系统依赖的值）。如果您想设置网络输入缓冲区的大小（以字节为单位），则需要此选项。'
- en: '`SO_SNDBUF`: This option is a positive integer that can be set before the socket
    is bound/connected (defaults to an OS-dependent value). You need this option if
    you want to set the size of the networking output buffer (in bytes).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_SNDBUF`: 这个选项是一个可以在套接字绑定/连接之前设置的整型值（默认值为操作系统依赖的值）。如果您想设置网络输出缓冲区的大小（以字节为单位），则需要此选项。'
- en: '`SO_REUSEADDR`: Via this integer option, we can indicate if an address can
    be reused or not. For datagram multicasting (datagram sockets), this means that
    multiple programs can use (can be bound to) the same address. In the case of stream-oriented
    sockets (or simply, stream sockets), an address can be reused only if the previous
    connection is in the `TIME_WAIT` state (the socket is about to be closed by the
    OS but it still waits for the client side to send possible late communications).
    The default value for this option is OS-dependent and it should be set before
    the socket is bound/connected.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_REUSEADDR`: 通过这个整型选项，我们可以指示一个地址是否可以被重用。对于数据报多播（数据报套接字），这意味着多个程序可以使用（可以绑定到）同一个地址。在面向流的套接字（或简单地说，流套接字）的情况下，只有在之前的连接处于`TIME_WAIT`状态（套接字即将由操作系统关闭，但它仍然等待客户端发送可能的延迟通信）时，地址才能被重用。这个选项的默认值依赖于操作系统，应该在套接字绑定/连接之前设置。'
- en: '`SO_REUSEPORT`: Via this integer option (available from JDK 9), we can indicate
    if a port can be reused or not. For datagram multicasting (datagram sockets) and
    stream sockets, this means that multiple sockets can use (can be bound to) the
    same port and address. The `SO_REUSEPORT` should be set before connecting/binding
    the socket; otherwise, the OS will deliver its default value for it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_REUSEPORT`: 通过这个整型选项（从JDK 9开始可用），我们可以指示一个端口是否可以被重用。对于数据报多播（数据报套接字）和流套接字，这意味着多个套接字可以使用（可以绑定到）同一个端口和地址。应该在连接/绑定套接字之前设置`SO_REUSEPORT`；否则，操作系统将为其提供默认值。'
- en: '`TCP_NODELAY`: This flag option (defaults to `false`) is used for enabling/disabling
    Nagle’s algorithm ([http://en.wikipedia.org/wiki/Nagle%27s_algorithm](http://en.wikipedia.org/wiki/Nagle%27s_algorithm)).
    It can be set at any time.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCP_NODELAY`: 这个标志选项（默认为`false`）用于启用/禁用Nagle算法（[http://en.wikipedia.org/wiki/Nagle%27s_algorithm](http://en.wikipedia.org/wiki/Nagle%27s_algorithm)）。它可以在任何时候设置。'
- en: 'Setting an option can be done via `NetworkChannel.getOption()` while getting
    an option can be done via `NetworkChannel.setOption()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置选项可以通过`NetworkChannel.getOption()`完成，而获取选项可以通过`NetworkChannel.setOption()`完成：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, via `NetworkChannel`, we can obtain the options supported by a specific
    network socket via `supportedOptions()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过`NetworkChannel`，我们可以通过`supportedOptions()`方法获取特定网络套接字支持的所有选项：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Having this information in your hands, it is time to start writing out our first
    client/server socket-based application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些信息后，是时候开始编写我们的第一个基于客户端/服务器套接字的应用程序了。
- en: 261\. Writing a blocking TCP server/client application
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 261. 编写阻塞式TCP服务器/客户端应用程序
- en: In this problem, we will write a blocking TCP server/client application. More
    precisely, let’s start with a single-thread blocking TCP echo server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将编写一个阻塞式TCP服务器/客户端应用程序。更确切地说，让我们从一个单线程阻塞式TCP回显服务器开始。
- en: Writing a single-thread blocking TCP echo server
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单线程阻塞式TCP回显服务器
- en: 'In order to write a single-thread blocking TCP echo server, we will follow
    these steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个单线程阻塞式TCP回显服务器，我们将遵循以下步骤：
- en: Create a new server socket channel
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的服务器套接字通道
- en: Configure the blocking mechanism
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置阻塞机制
- en: Set the server socket channel options
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置服务器套接字通道选项
- en: Bind the server socket channel
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定服务器套接字通道
- en: Accept connections
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受连接
- en: Transmit data over a connection
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过连接传输数据
- en: Close the channel
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭通道
- en: So, let’s start with the first step.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从第一步开始。
- en: Creating a new server socket channel
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的服务器套接字通道
- en: 'Creating and opening a new server socket channel (stream-oriented listening
    socket) can be done via the thread-safe `java.nio.channels.ServerSocketChannel`
    API as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过线程安全的`java.nio.channels.ServerSocketChannel` API创建和打开一个新的服务器套接字通道（面向流的监听套接字）可以按照以下方式完成：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resulting server socket channel is not bound/connected. However, it is
    open, and this can be verified via the `isOpen()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的服务器套接字通道尚未绑定/连接。然而，它是开放的，这可以通过`isOpen()`方法来验证：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, let’s configure the blocking mechanism.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置阻塞机制。
- en: Configuring the blocking mechanism
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置阻塞机制
- en: 'Once the server socket channel has been successfully opened, we can decide
    on the blocking mechanism. This can be done via the `configureBlocking()` method,
    which gets a boolean argument (`true` means a blocking server socket channel):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器套接字通道成功打开，我们可以决定阻塞机制。这可以通过`configureBlocking()`方法完成，该方法接受一个布尔参数（`true`表示阻塞服务器套接字通道）：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A special type of channel (covered in subsequent problems) is `SelectableChannel`.
    Such a channel is returned by the `configureBlocking()` method (inherited from
    `AbstractSelectableChannel`) and is useful for achieving *multiplexing* via the
    `Selector` API. But, as I said, this is covered later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的通道类型（将在后续问题中介绍）是`SelectableChannel`。这种通道由`configureBlocking()`方法返回（从`AbstractSelectableChannel`继承而来），并且对于通过`Selector`
    API实现*多路复用*非常有用。但是，正如我所说的，这将在稍后介绍。
- en: Setting server socket channel options
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置服务器套接字通道选项
- en: 'Since all options have default values, we can go with them out of the box or
    explicitly set only the ones that we need. For instance, let’s set the `SO_RCVBUF`
    and `SO_REUSEADDR` as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有选项都有默认值，我们可以直接使用它们，或者明确设置我们需要的选项。例如，让我们按照以下方式设置`SO_RCVBUF`和`SO_REUSEADDR`：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The options supported for a server socket channel are available via `supportedOptions()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器套接字通道支持的选项可以通过`supportedOptions()`获取：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, you can simply print the supported options on the console.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以在控制台上简单地打印出支持选项。
- en: Binding the server socket channel
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定服务器套接字通道
- en: 'Binding the server socket channel to a local address is a very important step.
    We accomplish this via the `bind()` method – for instance, let’s bind our `serverSC`
    to localhost (`127.0.0.1`) and to the arbitrarily chosen port, `4444`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器套接字通道绑定到本地地址是一个非常重要的步骤。我们通过`bind()`方法来完成这个操作——例如，让我们将`serverSC`绑定到本地主机（`127.0.0.1`）和任意选择的端口`4444`：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we omit the IP address and use the `InetSocketAddress` constructor that
    takes only the port argument then Java will rely on the *wildcard* IP address.
    This address is a special local IP dedicated for bind operations only and typically
    it is interpreted as *any*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略IP地址并使用只接受端口参数的`InetSocketAddress`构造函数，那么Java将依赖于*通配符*IP地址。这个地址是一个仅用于绑定操作的专用本地IP，通常它被解释为*任何*：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, when you decide to use the wildcard IP address keep in mind the following
    note.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您决定使用通配符IP地址时，请记住以下注意事项。
- en: '**Important note**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Pay attention that IP wildcard addresses may lead to undesirable complications
    in the presence of multiple network interfaces with separate IP addresses. If
    you are not prepared to handle such complications, then it is better to bind the
    socket to a specific network address, rather than to the IP wildcard.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IP通配符地址在存在具有单独IP地址的多个网络接口的情况下可能会导致不希望出现的复杂情况。如果您没有准备好处理这种复杂情况，那么将套接字绑定到特定的网络地址，而不是IP通配符，会更好。
- en: 'If we need to specify the socket address (`local_addr`) and the number of pending
    connections (`pending_c`), then we should rely on the following `bind()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要指定套接字地址（`local_addr`）和挂起的连接数（`pending_c`），那么我们应该依赖以下`bind()`：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Getting the bound local address (`SocketAddress`) can be done via `getLocalAddress()`.
    This method returns `null` if the socket has not been bound yet.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getLocalAddress()`方法获取绑定的本地地址（`SocketAddress`）。如果套接字尚未绑定，该方法返回`null`。
- en: Accepting connections
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受连接
- en: So far, the server socket channel is open and bound. We are ready to accept
    the incoming clients. Since we set up the blocking mode, the application will
    be blocked until a connection is established (a client connection request is accepted)
    or an I/O error occurs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，服务器套接字通道已打开并绑定。我们已准备好接受传入的客户端。由于我们设置了阻塞模式，应用程序将在建立连接（接受客户端连接请求）或发生I/O错误之前被阻塞。
- en: 'Accepting connections can be done via the `accept()` method as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`accept()`方法接受连接，如下所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method returns a `SocketChannel` representing the client socket channel
    (or simply, the socket channel associated with the new connection). The returned
    `SocketChannel` is a selectable channel for stream sockets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个表示客户端套接字通道的`SocketChannel`（或者简单地说，与新的连接关联的套接字通道）。返回的`SocketChannel`是一个流套接字的可选择通道。
- en: '**Important note**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: If we call the `accept()` method for a server socket channel that it was not
    bound to yet, then we will get back a `NotYetBoundException` exception.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对一个尚未绑定的服务器套接字通道调用`accept()`方法，那么我们将得到`NotYetBoundException`异常。
- en: 'The remote address (`SocketAddress`) to which this channel’s socket is connected
    is available via the `getRemoteAddress()` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getRemoteAddress()`方法可以获取此通道套接字连接的远程地址（`SocketAddress`）：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let’s see how we can transmit data over this connection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过此连接传输数据。
- en: Transmitting data over a connection
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过连接传输数据
- en: 'At this point, the two-way connection between the server and client is established
    and they can start transmitting data to each other. Each part can send/receive
    data packets mapped using the Java I/O streams or byte arrays. Implementing the
    communication protocol and choosing the proper API is quite flexible. For instance,
    we can rely on `ByteBuffer` to implement our echo server:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，服务器和客户端之间的双向连接已经建立，它们可以开始相互传输数据。每一方都可以使用Java I/O流或字节数组映射发送/接收数据包。实现通信协议和选择合适的API相当灵活。例如，我们可以依赖`ByteBuffer`来实现我们的回声服务器：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To support data transmission via `ByteBuffer`, `SocketChannel` exposes a set
    of `read()`/`write()` methods as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持通过`ByteBuffer`进行数据传输，`SocketChannel`公开了一组`read()`/`write()`方法，如下所示：
- en: 'Read from a channel into the given buffer and return the number of bytes read
    (`-1` if the end of stream has been reached):'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道读取到给定的缓冲区，并返回读取的字节数（如果已到达流末尾，则返回`-1`）：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Write the bytes of a buffer into a channel and return the number of written
    bytes:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缓冲区的字节数写入通道，并返回写入的字节数：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you prefer using the Java I/O API instead of manipulating multiple instances
    of `ByteBuffer`, then go for it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用Java I/O API而不是操作多个`ByteBuffer`实例，那么请这样做：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像这样：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When I/O streams are involved, we have to talk about shutting down a connection
    for I/O as well. Without closing the channel, a connection for I/O can be shut
    down via `shutdownInput()` and `shutdownOutput()`. The `shutdownInput()` method
    shuts down the connection for reading, while the `shutdownOutput()` method shuts
    down the connection for writing. Attempting to read from a closed reading connection
    (end of stream) will result in `-1`. On the other hand, attempting to write on
    a closed writing connection will result in a `ClosedChannelException` exception:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到I/O流时，我们不得不讨论关闭I/O连接的问题。如果不关闭通道，可以通过`shutdownInput()`和`shutdownOutput()`方法关闭I/O连接。`shutdownInput()`方法关闭读取连接，而`shutdownOutput()`方法关闭写入连接。尝试从已关闭的读取连接（流末尾）读取将导致返回`-1`。另一方面，尝试在已关闭的写入连接上写入将引发`ClosedChannelException`异常：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the other hand, if all you need is to check if a connection for I/O is open
    or not, this can be done via the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您只需要检查I/O连接是否打开，可以通过以下代码实现：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These checks are useful before attempting to perform read/write operations via
    this connection for I/O.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试通过此连接进行读写操作之前，这些检查很有用。
- en: Closing the channel
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'Closing a channel can be done via the `close()` method. If we want to close
    a certain client socket channel, then we rely on `SocketChannel.close()` – this
    will not close the server (stop it listening for incoming clients). On the other
    hand, if we want to close the server to stop it listening for incoming clients,
    then simply call `ServerSocketChannel.close()` as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`close()`方法关闭通道。如果我们想关闭特定的客户端套接字通道，那么我们依赖于`SocketChannel.close()` – 这将不会关闭服务器（停止监听传入的客户端）。另一方面，如果我们想关闭服务器以停止它监听传入的客户端，那么只需按照以下方式调用`ServerSocketChannel.close()`：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在 *try-with-resources* 块中关闭这些资源。
- en: Putting it all together into the echo server
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有这些整合到回声服务器中
- en: 'The source code of our echo server can be obtained by chaining the previous
    snippets of code and adding some gluing code and comments:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回声服务器的源代码可以通过连接之前的代码片段并添加一些粘合代码和注释来获取：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, let’s focus on developing a client for our echo server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于开发我们的回声服务器客户端。
- en: Writing a single-thread blocking TCP client
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单线程阻塞 TCP 客户端
- en: 'Before writing a client, we have to define how it works. For instance, our
    client connects to the server and sends the *Hey!* text. Afterward, it continues
    sending random integers in the range 0-100 until the number 50 is generated and
    sent. Once 50 are sent, the client will close the channel. The server will simply
    echo each message received from the client. Now, based on this scenario, we can
    develop a client by following these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写客户端之前，我们必须定义它的工作方式。例如，我们的客户端连接到服务器并发送 *Hey!* 文本。之后，它继续发送 0-100 范围内的随机整数，直到生成并发送数字
    50。一旦发送了 50，客户端将关闭通道。服务器将简单地回显从客户端接收到的每条消息。现在，基于这个场景，我们可以通过以下步骤开发客户端：
- en: Create a new (client) socket channel
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的（客户端）套接字通道
- en: Configure the blocking mechanism
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置阻塞机制
- en: Connect the client socket channel
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接客户端套接字通道
- en: Transmit data over a connection
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过连接传输数据
- en: Close the channel
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭通道
- en: Let’s tackle the first step.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决第一步。
- en: Creating a new (client) socket channel
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的（客户端）套接字通道
- en: 'Creating and opening a new client socket channel (stream-oriented connecting
    socket) can be done via the thread-safe `java.nio.channels.SocketChannel` API
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过线程安全的 `java.nio.channels.SocketChannel` API 创建和打开一个新的客户端套接字通道（面向流的连接套接字）如下所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The resulting client socket channel is not connected. However, it is open,
    and this can be verified via the `isOpen()` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果客户端套接字通道尚未连接。然而，它是打开的，这可以通过 `isOpen()` 方法来验证：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, a client socket channel can be opened and connected in a single step
    via the `open(SocketAddress)` flavor. Next, let’s configure the blocking mechanism.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端套接字通道可以通过 `open(SocketAddress)` 方法在单步中打开和连接。接下来，让我们配置阻塞机制。
- en: Configuring the blocking mechanism
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置阻塞机制
- en: 'Once the client socket channel has been successfully opened, we can decide
    on the blocking mechanism. This can be done via the `configureBlocking()` method,
    which gets a boolean argument (`true` means a blocking client socket channel):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端套接字通道成功打开，我们可以决定阻塞机制。这可以通过 `configureBlocking()` 方法完成，该方法接受一个布尔参数（`true`
    表示阻塞客户端套接字通道）：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we set a few options for this client socket channel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为这个客户端套接字通道设置一些选项。
- en: Setting client socket channel options
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置客户端套接字通道选项
- en: 'The following options are specific to a client socket channel: `IP_TOS`, `SO_RCVBUF`,
    `SO_LINGER`, `SO_OOBINLINE`, `SO_REUSEADDR`, `TCP_NODELAY`, `SO_KEEPALIVE`, and
    `SO_SNDBUF`. These options come with default values but they can be explicitly
    set as in this example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项特定于客户端套接字通道：`IP_TOS`、`SO_RCVBUF`、`SO_LINGER`、`SO_OOBINLINE`、`SO_REUSEADDR`、`TCP_NODELAY`、`SO_KEEPALIVE`
    和 `SO_SNDBUF`。这些选项具有默认值，但可以像以下示例中那样显式设置：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A client socket channel reveals the supported options via `supportedOptions()`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端套接字通道通过 `supportedOptions()` 方法揭示支持的选项：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, you can simply print the supported options to the console.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以将支持的选项简单地打印到控制台。
- en: Connecting the client socket channel
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接客户端套接字通道
- en: 'After opening the client socket channel, we have to connect it to the server
    that listens for incoming clients on `127.0.0.1` and port `4444`. This can be
    done via the `connect()` method as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开客户端套接字通道后，我们必须将其连接到监听 `127.0.0.1` 和端口 `4444` 的服务器。这可以通过 `connect()` 方法完成，如下所示：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since this is a blocking client, the application blocks until a connection to
    this remote address is established or an I/O error occurs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个阻塞客户端，应用程序会阻塞，直到与该远程地址建立连接或发生 I/O 错误。
- en: 'Until transmitting data (sending/receiving data packets), you should ensure
    that the connection is available via `isConnected()` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输数据（发送/接收数据包）之前，您应该确保通过 `isConnected()` 方法连接可用，如下所示：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Moreover, keep in mind the following note:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意以下注意事项：
- en: '**Important note**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要注意事项**'
- en: In our simple example, the server and the client run on the same machine (`localhost/127.0.0.1`).
    However, in reality, you should avoid hard-coding IP addresses and use the server
    hostname in place of its IP address. Since IP addresses can be changed and/or
    dynamically assigned via services such as DHCP, you should rely on hostnames (eventually
    configured via DNS).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，服务器和客户端在同一台机器上运行（`localhost/127.0.0.1`）。然而，在实际应用中，你应该避免硬编码IP地址，并使用服务器的主机名代替其IP地址。由于IP地址可能会更改或通过如DHCP等服务动态分配，你应该依赖主机名（最终通过DNS配置）。
- en: Next, let’s see how we can send and receive data to/from the server.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何向服务器发送和接收数据。
- en: Transmitting data over a connection
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在连接上传输数据
- en: 'First, we send the text *Hey!*. Afterward, we send integers between 0 and 100
    until the integer 50 is generated. At the API level, we rely on `ByteBuffer`/`CharBuffer`
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们发送文本*Hey!*。之后，我们发送介于0到100之间的整数，直到生成整数50。在API级别，我们依赖于`ByteBuffer`/`CharBuffer`如下：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we use `ByteBuffer` for sending/receiving data and `CharBuffer`
    for decoding the data received from the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`ByteBuffer`发送/接收数据，并使用`CharBuffer`解码从服务器接收到的数据。
- en: Closing the channel
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'Disconnecting the client from the server (closing the client socket channel)
    can be done via the `close()` method as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`close()`方法断开客户端与服务器之间的连接（关闭客户端套接字通道）可以这样做：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在`try-with-resources`块中关闭这些资源。
- en: Putting it all together into the client
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合到客户端
- en: 'The source code of our client can be obtained by chaining the previous snippets
    of code and adding some gluing code and comments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端源代码可以通过连接之前的代码片段并添加一些粘合代码和注释来获取：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, let’s test our server/client application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试我们的服务器/客户端应用程序。
- en: Testing the blocking echo application
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试阻塞回显应用程序
- en: 'First, start the server application. Second, start the client application and
    check out the console output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动服务器应用程序。其次，启动客户端应用程序并检查控制台输出：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can even start a few clients at the same time to see how it works. The server
    will display the remote address of each client.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以同时启动几个客户端来查看其工作情况。服务器将显示每个客户端的远程地址。
- en: 262\. Writing a non-blocking TCP server/client application
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 262. 编写非阻塞TCP服务器/客户端应用程序
- en: In this problem, we will write a non-blocking TCP server/client application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将编写一个非阻塞TCP服务器/客户端应用程序。
- en: A non-blocking socket (or a socket in non-blocking mode) allows us to perform
    I/O operations on socket channels without blocking the processes that are using
    it. The major steps of a non-blocking application are exactly the same as for
    a blocking application. The server is opened and bound to a local address ready
    to handle incoming clients. A client is opened and connected to the server. From
    this point forward, the server and the client can exchange data packets in a non-blocking
    fashion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞套接字（或非阻塞模式的套接字）允许我们在套接字通道上执行I/O操作，而不会阻塞使用它的进程。非阻塞应用程序的主要步骤与阻塞应用程序完全相同。服务器被打开并绑定到本地地址，准备处理传入的客户端。客户端被打开并连接到服务器。从这一点开始，服务器和客户端可以以非阻塞方式交换数据包。
- en: When we refer to exchanging data in a non-blocking fashion, we refer to the
    pillar of non-blocking technology, which is the `java.nio.channels.Selector` class.
    The role of the `Selector` is to orchestrate data transfer across multiple available
    socket channels. Basically, a `Selector` can monitor every single recorded socket
    channel and detect the channels that are available for data transfer in order
    to handle the clients’ requests. In addition, a `Selector` is capable of handling
    multiple sockets’ I/O operations via a single thread. This is possible via a concept
    known as *multiplexing*. So, instead of having a thread per socket connection,
    *multiplexing* allows the usage of a single thread for multiple socket connections.
    The `Selector` is known and referred to as the *multiplexor* of a `SelectableChannel`
    that is registered via the `register()` method of `SocketChannel` or `ServerSocketChannel`
    (subclasses of `SelectableChannel`). The `Selector` and the `SelectableChannel`
    are deregistered/deallocated together.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到以非阻塞方式交换数据时，我们指的是非阻塞技术的基石，即`java.nio.channels.Selector`类。`Selector`的作用是在多个可用的套接字通道之间协调数据传输。基本上，一个`Selector`可以监控每个记录的套接字通道，并检测可用于数据传输的通道，以便处理客户端的请求。此外，`Selector`可以通过一个称为*多路复用*的概念来处理多个套接字的I/O操作。这样，就不需要为每个套接字连接分配一个线程，*多路复用*允许使用单个线程来处理多个套接字连接。`Selector`被称为通过`SocketChannel`或`ServerSocketChannel`（`SelectableChannel`的子类）的`register()`方法注册的`SelectableChannel`的*多路复用器*。`Selector`和`SelectableChannel`一起注销/释放。
- en: Using the SelectionKey class
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SelectionKey类
- en: It is time to take a step further and introduce the `SelectionKey` class. A
    channel is registered with a `Selector` via an instance of `java.nio.channels.SelectionKey`
    and all the `SelectionKey` instances are known as selection keys. A selection
    key acts as a helper for the selector being used to sort the requests of a client.
    Practically, a selection key carries information (metadata) about a single client
    subrequest such as the type of subrequest (connect, write, read, and so on) and
    information needed to uniquely identify the client.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进一步介绍`SelectionKey`类了。一个通道通过`java.nio.channels.SelectionKey`的一个实例注册到`Selector`，所有的`SelectionKey`实例都称为选择键。选择键作为辅助器，用于对客户端的请求进行排序。实际上，选择键携带有关单个客户端子请求的信息（元数据），例如子请求的类型（连接、写、读等）以及用于唯一标识客户端所需的信息。
- en: 'During the registration of a `SelectableChannel` with a `Selector`, we point
    out the set of operations for which the key’s channel will be monitored by this
    selector – this is known as the *interest set*. When an operation becomes eligible
    to be performed, it becomes part of the so-called *ready set* (this set is initialized
    with 0 when the key is created). So, a selection key handles two operation sets
    (*interest set* and *ready set*) represented as integer values. Each bit of an
    operation set represents a category of selectable operations that are supported
    by the key’s channel. A key can be of one of the following types:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`SelectableChannel`注册到`Selector`的过程中，我们指出该键的通道将由该选择器监控的操作集——这被称为*兴趣集*。当一个操作有资格执行时，它就成为所谓的*就绪集*（当键创建时，此集初始化为0）。因此，选择键处理两个操作集（*兴趣集*和*就绪集*），这些操作集表示为整数值。操作集的每个位代表由键的通道支持的选可操作类别之一。一个键可以是以下类型之一：
- en: '`SelectionKey.OP_ACCEPT` (*acceptable*): Bit for marking socket-accept operations'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.OP_ACCEPT` (*可接受*): 标记套接字接受操作的位'
- en: '`SelectionKey.OP_CONNECT` (*connectable*): Bit for marking socket-connect operations'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.OP_CONNECT` (*可连接*): 标记套接字连接操作的位'
- en: '`SelectionKey.OP_READ` (*readable*): Bit for marking read operations'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.OP_READ` (*可读*): 标记读操作的位'
- en: '`SelectionKey.OP_WRITE` (*writable*): Bit for marking write operations'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.OP_WRITE` (*可写*): 标记写操作的位'
- en: 'A selector must handle three sets of selection keys as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器必须处理三组选择键，如下所示：
- en: '*key-set*: Contains all the keys of the currently registered channel.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*键集*：包含当前注册通道的所有键。'
- en: '*selected-key*: Every key that is ready for at least one of the operations
    from the key’s *interest set* is part of the *selected-key*.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已选择键*：每个至少准备好执行其*兴趣集*中至少一个操作的键都是*已选择键*的一部分。'
- en: '*canceled-key*: This contains all the keys that have been canceled but still
    have registered channels.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已取消键*：这包含所有已取消但仍注册了通道的键。'
- en: '**Important note**'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: When a selector is created, these three sets are empty. Pay attention that the
    `Selector` instances are thread-safe, but their key sets however are not.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当创建选择器时，这三个集合都是空的。请注意，`Selector` 实例是线程安全的，但它们的键集合却不是。
- en: When some action takes place, the selector wakes up. It starts creating the
    `SelectionKey`, where each such key contains information about the current request.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生某些操作时，选择器会唤醒。它开始创建 `SelectionKey`，其中每个这样的键都包含有关当前请求的信息。
- en: The selector waits for the recorded events (for instance, incoming connection
    requests) in an infinite loop. Commonly, the first line of this loop is `Selector.select()`.
    This is a blocking call that takes place until the `Selector.wakeup()` method
    is called, at least one channel is selectable, or the current thread gets interrupted.
    There is also a `select(long timeout)` method that works as `select()` but with
    a timeout. In addition, we have `selectNow()`, which is non-blocking – if there
    are no selectable channels, then `selectNow()` returns `0` immediately.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器在一个无限循环中等待记录的事件（例如，传入的连接请求）。通常，这个循环的第一行是 `Selector.select()`。这是一个阻塞调用，直到
    `Selector.wakeup()` 方法被调用，至少有一个通道是可选择的，或者当前线程被中断。还有一个 `select(long timeout)` 方法，它的工作方式与
    `select()` 相同，但有一个超时。此外，我们还有 `selectNow()`，它是非阻塞的——如果没有可选择的通道，则 `selectNow()`
    立即返回 `0`。
- en: Let’s assume that the selector waits for a connection attempt. When a client
    attempts to connect, the server checks the type of each key created by the selector.
    If the type is `OP_ACCEPT` (acceptable key) then the `SelectionKey.isAcceptable()`
    method takes action. When this method returns `true` the server locates the client
    socket channel via the `accept()` methods. In addition, it sets this socket channel
    as non-blocking and registers it to the selector as eligible for `OP_READ` and/or
    `OP_WRITE` operations. While processing the keys created by the selector the server
    removes them from the list (an `Iterator` over these keys) in order to prevent
    the re-evaluation of the same key.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设选择器正在等待连接尝试。当客户端尝试连接时，服务器会检查选择器创建的每个键的类型。如果类型是 `OP_ACCEPT`（可接受键），则 `SelectionKey.isAcceptable()`
    方法会采取行动。当此方法返回 `true` 时，服务器通过 `accept()` 方法定位客户端套接字通道。此外，它将此套接字通道设置为非阻塞，并将其注册到选择器，使其适用于
    `OP_READ` 和/或 `OP_WRITE` 操作。在处理选择器创建的键时，服务器将它们从列表中删除（这些键的 `Iterator`），以防止对同一键的重新评估。
- en: So far, the client socket channel is registered to the selector for read/write
    operations. Now, if the client sends (writes to the channel) some data on the
    socket channel then the selector will inform the server side that it should/can
    read that data (in this scenario, the `SelectionKey.isReadable()` method, returns
    `true`). On the other hand, when the client receives (reads) some data from the
    server, the `SelectionKey.isWritable()` method returns `true`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，客户端套接字通道已注册到选择器以进行读写操作。现在，如果客户端在套接字通道上发送（写入）一些数据，则选择器将通知服务器端它应该/可以读取该数据（在这种情况下，`SelectionKey.isReadable()`
    方法返回 `true`）。另一方面，当客户端从服务器接收（读取）一些数据时，`SelectionKey.isWritable()` 方法返回 `true`。
- en: 'The following diagram highlights the selector-based non-blocking flow:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示突出了基于选择器的非阻塞流程：
- en: '![Figure 13.2.png](img/B19655_13_02.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2.png](img/B19655_13_02.png)'
- en: 'Figure 13.2: The selector-based non-blocking flow'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：基于选择器的非阻塞流程
- en: '**Important note**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In non-blocking mode, we may face the so-called *partial read/write*. This means
    that an I/O operation has partially transferred (read or written) some data (fewer
    bytes) or no data at all (0 bytes).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞模式下，我们可能会遇到所谓的 *部分读取/写入*。这意味着一个 I/O 操作已部分传输（读取或写入）了一些数据（字节较少）或根本没有数据（0 字节）。
- en: Next, let’s briefly cover the `Selector` methods.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要介绍 `Selector` 方法。
- en: Using the Selector methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器方法
- en: 'Before coding a non-blocking TCP server/client application, we have to know
    a few built-in methods that sustain our goal:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码非阻塞 TCP 服务器/客户端应用程序之前，我们必须了解一些内置方法，这些方法支持我们的目标：
- en: '`Selector.open()`: This creates and opens a new selector.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.open()`: 这将创建并打开一个新的选择器。'
- en: '`Selector.select()`: This is a blocking operation that selects a set of keys.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.select()`: 这是一个阻塞操作，用于选择一组键。'
- en: '`Selector.select(long t)`: This works exactly as `select()`, but with a timeout
    specified in milliseconds. If there is nothing to select during `t`, then this
    method returns `0`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.select(long t)`: 它的工作方式与 `select()` 完全相同，但有一个以毫秒为单位的超时。如果在 `t` 期间没有可选择的项，则此方法返回
    `0`。'
- en: '`Selector.selectNow()`: This is a non-blocking version of `select()`. If there
    is nothing to select, then this method returns `0`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.selectNow()`: 这是`select()`的非阻塞版本。如果没有可选择的内容，则此方法返回`0`。'
- en: '`Selector.keys()`: This returns `Set<SelectionKey>` (selector’s key set).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.keys()`: 这返回`Set<SelectionKey>`（选择器的键集）。'
- en: '`Selector.selectedKeys()`: This returns `Set<SelectionKey>` (selector’s selected
    key set).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.selectedKeys()`: 这返回`Set<SelectionKey>`（选择器的选择键集）。'
- en: '`Selector.wakeup()`: The first selection operation (which has not yet returned)
    will return immediately.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.wakeup()`: 第一次选择操作（尚未返回）将立即返回。'
- en: '`SelectionKey.isReadable()`: This checks if this key’s channel is ready for
    reading.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.isReadable()`: 这检查此键的通道是否已准备好读取。'
- en: '`SelectionKey.isWritable()`: This checks if this key’s channel is ready for
    writing.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.isWritable()`: 这检查此键的通道是否已准备好写入。'
- en: '`SelectionKey.isValid()`: This checks this key’s validity. An invalid key is
    canceled, its selector is closed, or its channel is closed.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.isValid()`: 这检查此键的有效性。无效的键会被取消，其选择器会被关闭，或者其通道会被关闭。'
- en: '`SelectionKey.isAcceptable()`: If this method returns `true`, then a new socket
    connection will be accepted by this key’s channel.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.isAcceptable()`: 如果此方法返回`true`，则此键的通道将接受一个新的套接字连接。'
- en: '`SelectionKey.isConnectable()`: This checks if this key’s channel has successfully
    finished or failed to finish its current socket connection operation.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.isConnectable()`: 这检查此键的通道是否已成功完成或未能完成其当前的套接字连接操作。'
- en: '`SelectionKey.interestOps()`: This returns this key’s *interest set*.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.interestOps()`: 这返回此键的*兴趣集*。'
- en: '`SelectionKey.interestOps(t)`: This sets this key’s *interest set* to `t`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.interestOps(t)`: 这将此键的*兴趣集*设置为`t`。'
- en: '`SelectionKey.readyOps()`: This returns this key’s *ready-operation set*.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.readyOps()`: 这返回此键的*准备操作集*。'
- en: '`SelectionKey.cancel()`: This cancels the registration of this key’s channel
    with its selector.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey.cancel()`: 这取消此键的通道与其选择器的注册。'
- en: 'Registering a channel with a given selector can be done via the `register()`
    method of `ServerSocketChannel` and `SocketChannel`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ServerSocketChannel`和`SocketChannel`的`register()`方法可以将通道注册到给定的选择器：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `s` argument is the given selector. The `p` argument is the *interest set*
    for the selection key, and the `a` argument is the attachment for the selection
    key (may be `null`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`参数是给定的选择器。`p`参数是选择键的*兴趣集*，`a`参数是选择键的附件（可能为`null`）。'
- en: Writing the non-blocking server
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写非阻塞服务器
- en: 'Based on the previous information, we can write the following non-blocking
    echo server (the code may look a little bit large, but it is sprinkled with helpful
    comments):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，我们可以编写以下非阻塞回声服务器（代码可能看起来有点大，但它包含了有用的注释）：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we have the infinite loop of the `Selector`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`Selector`的无穷循环：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Further, we have a set of helpers responsible for accepting connections and
    performing read/write operations. First, we have the `acceptOperation()` helper:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一组负责接受连接和执行读写操作的辅助工具。首先，我们有`acceptOperation()`辅助工具：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The helpers for read/write operations are:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 读写操作的辅助工具如下：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we have to call the `startEchoServer()`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须调用`startEchoServer()`：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, let’s focus on writing the client for our non-blocking echo server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于编写我们的非阻塞回声服务器的客户端。
- en: Writing the non-blocking client
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写非阻塞客户端
- en: 'The main structure of the non-blocking client is the same as the structure
    of the non-blocking server. However, there are a few things that are not the same
    and they deserve a brief overview as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞客户端的主要结构与非阻塞服务器相同。然而，有一些不同之处，以下简要概述：
- en: The client socket channel must be registered with the `SelectionKey.OP_CONNECT`
    operation. This is needed because the client must be informed by the selector
    when the non-blocking server accepts its connection request.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端套接字通道必须注册到`SelectionKey.OP_CONNECT`操作。这是必需的，因为客户端必须由选择器通知非阻塞服务器已接受其连接请求。
- en: While the server side may wait for incoming clients infinitely, a client cannot
    attempt to connect in the same way. In other words, a client will rely on `Selector.select(long
    timeout)`. A timeout that ranges from 500 to 1,000 ms should do the job.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然服务器端可能无限期地等待传入客户端，但客户端不能以相同的方式尝试连接。换句话说，客户端将依赖于`Selector.select(long timeout)`。500到1,000毫秒的超时应该可以完成任务。
- en: The client is also responsible for checking if the key is connectable via `SelectionKey.isConnectable()`.
    If this method returns `true`, then the client joins the `isConnectionPending()`
    and `finishConnect()` APIs in a conditional statement. This construction is needed
    for closing any pending connections. Practically, the `isConnectionPending()`
    method tells us if there is any connection operation in progress on the current
    client channel, while the `finishConnect()` method will finish the process of
    connecting a socket channel.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端还负责检查是否可以通过 `SelectionKey.isConnectable()` 检查键是否可连接。如果此方法返回 `true`，则客户端在条件语句中连接到
    `isConnectionPending()` 和 `finishConnect()` API。这种结构对于关闭任何挂起的连接是必要的。实际上，`isConnectionPending()`
    方法告诉我们当前客户端通道上是否有任何连接操作正在进行，而 `finishConnect()` 方法将完成连接套接字通道的过程。
- en: 'Now, we are ready to list the client code, which follows the same scenario
    as in the previous problem (we send the *Hey!* text followed by random integers
    ranging from 0 to 100 until the number 50 is generated):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备列出客户端代码，该代码遵循与上一个问题相同的场景（我们发送 *Hey!* 文本，然后是 0 到 100 之间的随机整数，直到生成数字 50）：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we are ready to wait to connect to the server:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备等待连接到服务器：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the client is connected, it can read/write data from/to the server side:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端连接，它就可以从服务器端读取/写入数据：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, let’s test our non-blocking application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试我们的非阻塞应用程序。
- en: Testing the non-blocking echo application
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试非阻塞回显应用程序
- en: 'First, start the server side. Afterward, start a few clients and check each
    console output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动服务器端。然后，启动几个客户端并检查每个控制台输出：
- en: '![Figure 13.3.png](img/B19655_13_03.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3.png](img/B19655_13_03.png)'
- en: 'Figure 13.3: A possible output of our non-blocking server'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：我们的非阻塞服务器的可能输出
- en: Keep in mind that this is not a multithreading application. It is just a single-threaded
    application that relies on the *multiplexing* technique.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不是一个多线程应用程序。它只是一个单线程应用程序，依赖于 *多路复用* 技术。
- en: 263\. Writing UDP server/client applications
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 263. 编写 UDP 服务器/客户端应用程序
- en: UDP is a protocol built on top of IP. Via UDP, we can send data packets of at
    most 65,507 bytes (that is, 65,535-byte IP packet size – plus the minimum IP header
    of 20 bytes – plus the 8-byte UDP header = 65,507 bytes total). In UDP, data packets
    are seen as individual entities. In other words, no packet is aware of others.
    Data packets may arrive in any order or may not arrive at all. The sender will
    not be informed about the lost packets, so it will not know what to resend. Moreover,
    data packets may arrive too fast or too slow, so processing them may be a real
    challenge.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 是建立在 IP 协议之上的协议。通过 UDP，我们可以发送最多 65,507 字节的数据包（即 65,535 字节的 IP 数据包大小减去最小
    IP 头部 20 字节，再加上 8 字节的 UDP 头部，总共 65,507 字节）。在 UDP 中，数据包被视为独立的实体。换句话说，没有任何数据包知道其他数据包的存在。数据包可能以任何顺序到达，也可能根本不会到达。发送者将不会被告知丢失的数据包，因此它将不知道需要重发什么。此外，数据包可能到达得太快或太慢，因此处理它们可能是一个真正的挑战。
- en: While TCP is famous for high-reliability data transmissions, UDP is famous for
    low-overhead transmissions. So, UDP is more like sending a letter (remember that
    TCP is like a phone call). You write on the envelope the address of the receiver
    (here, the remote IP and port) and your address (here, local IP and port) and
    send it (here, over the wires). You don’t know if the letter will ever arrive
    at the receiver (here, the sender cannot trace the routes of the packets) and
    if you send more letters you cannot control the order of their arrival (here,
    an old packet can arrive after a more recent packet). In this context, UDP fits
    well if all you care about is speed. So, if you can afford losing packets and
    the order of receiving them is not important then UDP might be the right choice.
    For instance, an application that should send the state of a sensor every *n*
    milliseconds may take advantage of the UDP protocol.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TCP 以高可靠性数据传输而闻名，但 UDP 以低开销传输而闻名。因此，UDP 更像发送一封信（记住 TCP 像是电话通话）。你在信封上写上接收者的地址（在这里，远程
    IP 和端口）和你的地址（在这里，本地 IP 和端口），然后发送它（在这里，通过电线）。你不知道信件是否会到达接收者（在这里，发送者无法追踪数据包的路径）并且如果你发送更多的信件，你无法控制它们的到达顺序（在这里，旧的数据包可以在较新的数据包之后到达）。在这种情况下，如果你只关心速度，UDP
    就非常适合。因此，如果你可以承受丢失数据包，并且接收它们的顺序不重要，那么 UDP 可能是正确的选择。例如，一个应该每 *n* 毫秒发送传感器状态的程序可以利用
    UDP 协议。
- en: Writing a single-thread blocking UDP echo server
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单个线程阻塞 UDP 回显服务器
- en: 'In order to write a single-thread blocking UDP echo server, we will follow
    these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写单个线程阻塞 UDP 回显服务器，我们将遵循以下步骤：
- en: Create a server datagram-oriented socket channel
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建面向数据报的服务器套接字通道
- en: Set datagram-oriented socket channel options
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置面向数据报的套接字通道选项
- en: Bind the server datagram-oriented socket channel
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定服务器面向数据报的套接字通道
- en: Transmit data packets
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输数据包
- en: Close the channel
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭通道
- en: Let’s start with the first step.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。
- en: Creating a server datagram-oriented socket channel
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建面向数据报的服务器套接字通道
- en: The climax of a server/client UDP application is represented by a thread-safe
    selectable channel dedicated to working with datagram-oriented sockets (or simply,
    datagram sockets). In API terms, this is referred to as `java.nio.channels.DatagramChannel`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器/客户端UDP应用程序的高潮是由一个线程安全的可选择通道表示的，该通道专门用于与面向数据报的套接字（或简单地，数据报套接字）一起工作。在API术语中，这被称为`java.nio.channels.DatagramChannel`。
- en: 'Such a channel can be obtained via `DatagramChannel.open()`, which gets a single
    parameter of the type `java.net.ProtocolFamily`. The protocol family implementation
    (`java.net.StandardProtocolFamily`) has two possible values:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通道可以通过`DatagramChannel.open()`方法获得，该方法接受一个类型为`java.net.ProtocolFamily`的单个参数。协议族实现（`java.net.StandardProtocolFamily`）有两个可能的值：
- en: '`StandardProtocolFamily.INET`: IP version 4 (IPv4)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardProtocolFamily.INET`：IP版本4（IPv4）'
- en: '`StandardProtocolFamily.INET6`: IP version 6 (IPv6)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardProtocolFamily.INET6`：IP版本6（IPv6）'
- en: 'Next, we focus on the datagram socket for IPv4, so we call the `open()` method
    as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注IPv4的数据报套接字，因此我们按照以下方式调用`open()`方法：
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you don’t care about the protocol family, then you can call the `open()`
    method without arguments. In that case, the protocol family is platform-dependent.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎协议族，那么你可以不带参数调用`open()`方法。在这种情况下，协议族是平台相关的。
- en: 'Before going further, we can check if a datagram socket is open via the `isOpen()`
    flag method:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们可以通过`isOpen()`标志方法检查数据报套接字是否打开：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A client datagram socket can be opened in the same manner as a server datagram
    socket.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端数据报套接字可以以与服务器数据报套接字相同的方式打开。
- en: Setting datagram-oriented socket channel options
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置面向数据报的套接字通道选项
- en: 'The options supported by a datagram socket channel are `SO_BROADCAST`, `IP_TOS`,
    `IP_MULTICAST_LOOP`, `IP_MULTICAST_TTL`,`SO_SNDBUF`, `SO_REUSEADDR`, `IP_MULTICAST_IF`,
    and `SO_RCVBUF`. Here are some examples of setting a few of them:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报套接字通道支持以下选项：`SO_BROADCAST`、`IP_TOS`、`IP_MULTICAST_LOOP`、`IP_MULTICAST_TTL`、`SO_SNDBUF`、`SO_REUSEADDR`、`IP_MULTICAST_IF`和`SO_RCVBUF`。以下是一些设置其中几个的示例：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The supported options are available via `supportedOptions()`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的选项可以通过`supportedOptions()`方法获得：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, let’s bind the server datagram socket.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们绑定服务器数据报套接字。
- en: Binding the server datagram-oriented socket channel
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定服务器面向数据报的套接字通道
- en: 'Before listening for connections, the server datagram socket channel should
    be bound to a local address via the `bind()` method. Here, we have *localhost*
    (`127.0.0.1`) and the arbitrarily chosen port `4444`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听连接之前，服务器数据报套接字通道应该通过`bind()`方法绑定到本地地址。这里我们有`localhost`（`127.0.0.1`）和任意选择的端口`4444`：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we go for `bind(null)`, then the local address will be automatically assigned.
    We can discover the local address via the `getLocalAddress()` method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`bind(null)`，那么本地地址将被自动分配。我们可以通过`getLocalAddress()`方法来发现本地地址。
- en: Transmitting data packets
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输数据包
- en: 'The datagram-based echo server is almost ready. We can start sending and receiving
    packets in a connectionless fashion (UDP is a connectionless network protocol).
    This can be done via `send()` and `receive()` methods. The `send()` method gets
    the data to be sent as a `ByteBuffer` and the remote address and returns the number
    of bytes sent. The official documentation gives us the best explanation of how
    it works:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据报的回显服务器几乎准备好了。我们可以通过`send()`和`receive()`方法以无连接的方式开始发送和接收数据包（UDP是一种无连接网络协议）。这可以通过以下方式完成：`send()`方法获取要发送的数据作为`ByteBuffer`，远程地址并返回发送的字节数。官方文档给出了关于其工作原理的最佳解释：
- en: '*If this channel is in non-blocking mode and there is sufficient room in the
    underlying output buffer, or if this channel is in blocking mode and sufficient
    room becomes available, then the remaining bytes in the given buffer are transmitted
    as a single datagram to the given target address. This method may be invoked at
    any time. If another thread has already initiated a write operation upon this
    channel, however, then an invocation of this method will block until the first
    operation is complete. If this channel’s socket is not bound then this method
    will first cause the socket to be bound to an address that is assigned automatically,
    as if by invoking the* *bind() method with a parameter of null.*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果此通道处于非阻塞模式并且底层输出缓冲区有足够的空间，或者如果此通道处于阻塞模式并且有足够的空间变得可用，则给定缓冲区中的剩余字节将作为一个单独的数据报发送到给定的目标地址。此方法可以在任何时候调用。然而，如果另一个线程已经在此通道上启动了写入操作，则对方法的调用将阻塞，直到第一个操作完成。如果此通道的套接字未绑定，则此方法将首先导致套接字绑定到一个自动分配的地址，就像调用带有
    `null` 参数的 `bind()` 方法一样。*'
- en: 'On the other hand, the `receive()` method gets the `ByteBuffer` where you are
    expecting to find the received datagram. The datagram’s source address is the
    return of this method and it can be used to send back an answer packet (if this
    method returns `null`, it means that the channel is in non-blocking mode and no
    datagram is immediately available). Again, the official documentation gives us
    the best explanation of how this method will act:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`receive()` 方法获取你期望找到接收到的数据报的 `ByteBuffer`。数据报的源地址是此方法的返回值，并且可以用来发送回一个应答包（如果此方法返回
    `null`，则表示通道处于非阻塞模式且没有立即可用的数据报）。再次强调，官方文档为我们提供了关于此方法如何工作的最佳解释：
- en: '*If a datagram is immediately available, or if this channel is in blocking
    mode and one eventually becomes available, then the datagram is copied into the
    given byte buffer and its source address is returned. If this channel is in non-blocking
    mode and a datagram is not immediately available then this method immediately
    returns null. This method may be invoked at any time. If another thread has already
    initiated a read operation upon this channel, however, then an invocation of this
    method will block until the first operation is complete. If this channel’s socket
    is not bound then this method will first cause the socket to be bound to an address
    that is assigned automatically, as if by invoking the bind() method with a parameter
    of null.*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果数据报立即可用，或者如果此通道处于阻塞模式并且最终变得可用，则数据报将被复制到给定的字节数组中，并且其源地址将被返回。如果此通道处于非阻塞模式并且数据报不可立即获得，则此方法立即返回
    `null`。此方法可以在任何时候调用。然而，如果另一个线程已经在此通道上启动了读取操作，则对方法的调用将阻塞，直到第一个操作完成。如果此通道的套接字未绑定，则此方法将首先导致套接字绑定到一个自动分配的地址，就像调用带有
    `null` 参数的 `bind()` 方法一样。*'
- en: The remote address can be discovered via `getRemoteAddress()`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 远程地址可以通过 `getRemoteAddress()` 方法发现。
- en: 'Our blocking echo server listens for packets in an infinite loop. When a packet
    is available (has arrived on the server), we extract from it the data and the
    address of the sender (the remote address). We use this address to send back the
    same data (to echo):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的阻塞式回声服务器在一个无限循环中监听数据包。当一个数据包可用（已到达服务器）时，我们从其中提取数据以及发送者的地址（远程地址）。我们使用此地址来发送回相同的数据（回声）：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Closing the channel
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'Disconnecting the datagram socket channel can be done via the `close()` method
    as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 断开数据报套接字通道可以通过以下 `close()` 方法完成：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在 `try-with-resources` 块中关闭这些资源。
- en: Putting it all together into the client
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合到客户端
- en: 'The source code of our server can be obtained by chaining the previous snippets
    of code and adding some gluing code and comments:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器的源代码可以通过链式调用之前的代码片段，并添加一些粘合代码和注释来获得：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, let’s focus on writing a client for the echo server.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于编写回声服务器的客户端。
- en: Writing a connectionless UDP client
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写无连接的 UDP 客户端
- en: 'In implementation terms, writing a connectionless UDP client is almost the
    same as writing the server side. We create a `DatagramChannel`, set the needed
    options, and we are ready to go (ready to send/receive data packets). Notice that
    a datagram client doesn’t need to be bound (but it can be) to a local address
    because the server can extract the IP/port pair from each data packet – the server
    knows where the client lives. However, if the server was bound via `bind(null)`
    (so, automatically bound) then the client should know the assigned server IP/port
    pair (server address). Of course, the reverse is also true: if the server is the
    first one sending a data packet (in this case, the client should be bound).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，编写无连接的UDP客户端几乎与编写服务器端相同。我们创建一个`DatagramChannel`，设置所需选项，然后就可以开始（准备发送/接收数据包）。请注意，数据报客户端不需要绑定（但可以）到本地地址，因为服务器可以从每个数据包中提取IP/端口对——服务器知道客户端在哪里。然而，如果服务器通过`bind(null)`（因此，自动绑定）绑定，则客户端应该知道分配的服务器IP/端口对（服务器地址）。当然，反过来也是正确的：如果服务器是第一个发送数据包的（在这种情况下，客户端应该绑定）。
- en: 'In our case, the client is aware that the echo server listens on `127.0.0.1`/`4444`,
    so it can send the first data packet via the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，客户端知道回声服务器监听在`127.0.0.1`/`4444`，因此它可以发送第一个数据包的以下代码：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, let’s test our blocking server/client datagram-based application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试我们的基于阻塞的客户端/服务器数据报应用程序。
- en: Testing the UDP connectionless echo application
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试UDP无连接回声应用程序
- en: 'For testing our application, we start the server, which will output these messages:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们启动服务器，它将输出以下消息：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we start the client, which sends the text *Echo: I’m a great server!*
    to the server. The client will output the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们启动客户端，它将文本*Echo: 我是一个伟大的服务器!*发送到服务器。客户端将输出以下内容：'
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The server will receive this datagram and send it back:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将接收这个数据报并将其发送回：
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The client will wait for the server to echo for 5 seconds (arbitrarily chosen
    timeout). Since the server will echo the received datagram, the client will get
    it back and print it to the console:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将等待服务器回声5秒钟（任意选择的超时时间）。由于服务器将回声接收到的数据报，客户端将收到它并将其打印到控制台：
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this moment, the client is stopped and the server continues to wait for incoming
    datagrams. So, don’t forget to manually stop the server.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，客户端已经停止，服务器继续等待传入的数据报。所以，别忘了手动停止服务器。
- en: Writing a connected UDP client
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个连接的UDP客户端
- en: Besides the connectionless `send()` and `receive()` methods, the Java API also
    supports the `read()` and `write()` methods. These methods work only for a connected
    UDP client and are based on `ByteBuffer` for holding the read/write data. A connected
    UDP client (in contrast with a connectionless one) relies on a socket channel
    that allows interactions (sending/receiving datagrams) only with the given remote
    peer address. The client datagram socket remains connected. It must be explicitly
    closed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了无连接的`send()`和`receive()`方法之外，Java API还支持`read()`和`write()`方法。这些方法仅适用于连接的UDP客户端，并且基于`ByteBuffer`来保存读写数据。与无连接的UDP客户端（相对）相比，连接的UDP客户端依赖于一个套接字通道，它只允许与给定的远程对等地址进行交互（发送/接收数据报）。客户端数据报套接字保持连接。它必须显式关闭。
- en: 'Connecting a UDP client is accomplished via the `connect()` method, which takes
    as arguments the server-side remote address:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`connect()`方法连接UDP客户端，该方法需要服务器端远程地址作为参数：
- en: '[PRE56]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Since UDP is a connectionless protocol, the `connect()` method doesn’t exchange
    any data packets with the server across the network. The method returns immediately
    without actually blocking the application. Mainly, the `connect()` method can
    be called at any time since it doesn’t affect the currently processed read/write
    operations. Its goal is to bind this socket channel (if it is not) to an automatically
    assigned address (it’s like calling `bind(null)`).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP是一个无连接协议，`connect()`方法不会在网络上与服务器交换任何数据包。该方法立即返回，实际上不会阻塞应用程序。主要来说，`connect()`方法可以在任何时候调用，因为它不会影响当前正在处理的读写操作。它的目的是将这个套接字通道（如果尚未）绑定到一个自动分配的地址（就像调用`bind(null)`一样）。
- en: 'The connection status can be obtained via `isConnected()`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`isConnected()`获取连接状态：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this context, writing a UDP-connected client for our UDP echo server can
    be done as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，为我们的UDP回声服务器编写一个UDP连接客户端可以这样做：
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Testing this client is straightforward. First, start the server. Second, start
    the client and check out the console output.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个客户端很简单。首先，启动服务器。其次，启动客户端并查看控制台输出。
- en: 264\. Introducing multicasting
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 264. 介绍多播
- en: Multicasting is like a flavor of internet broadcasting. We know that a TV station
    can broadcast (share) its signal from the source to all its subscribers or to
    everybody in a certain area. The exceptions are represented by the people who
    don’t have the proper receiver (equipment) or aren’t interested in this TV station.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 多播就像是一种互联网广播的口味。我们知道，电视台可以从源头向所有订阅者或特定区域内的所有人广播（共享）其信号。例外的是那些没有合适的接收器（设备）或对此电视台不感兴趣的人。
- en: From a computer perspective, the TV station can be considered a source that
    sends datagrams to a group of listeners/subscribers or simply destination hosts.
    While point-to-point communication is possible via the *unicast transport service*,
    in multicasting (sending datagrams from a source to multiple destinations in a
    single call) we have the *multicast transport service*. In the case of the *unicast
    transport service*, sending the same data to multiple points is possible via the
    so-called *replicated unicast* (practically each point receives a copy of the
    data).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机的角度来看，电视台可以被视为一个向一组听众/订阅者或简单地说目的地主机发送数据报的源头。虽然可以通过**单播传输服务**进行点对点通信，但在多播（在单个调用中从源头向多个目的地发送数据报）中，我们有**多播传输服务**。在**单播传输服务**的情况下，通过所谓的**复制单播**（实际上每个点都接收数据的副本）向多个点发送相同的数据是可能的。
- en: In multicasting terms, the receivers of multicasted datagrams are known as a
    *group*. This group is uniquely identified by an IP of class D (224.0.0.0-239.255.255.255).
    A new client can listen and receive the multicasted datagrams only after it gets
    connected to the group via the corresponding IP address. There are multiple domains
    where multicasting is useful such as data-sharing management, conferencing, email
    groups, advertising, and so on.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在多播术语中，多播数据报的接收者被称为一个**组**。该组由一个D类IP地址（224.0.0.0-239.255.255.255）唯一标识。只有当新客户端通过相应的IP地址连接到该组后，它才能监听并接收多播数据报。多播在多个领域都有用，例如数据共享管理、会议、电子邮件组、广告等等。
- en: 'Java (NIO.2) shapes multicasting via the `MulticastChannel` interface (a subinterface
    of `NetworkChannel`), which has a single implementation named `DatagramChannel`.
    This interface exposes two `join()` methods as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Java (NIO.2)通过`MulticastChannel`接口（`NetworkChannel`的子接口）来塑造多播，该接口有一个名为`DatagramChannel`的单个实现。该接口公开了两个`join()`方法，如下所示：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A client who wants to join a multicast group must call one of these `join()`
    methods. The first `join()` method requires the IP address of the multicasting
    group and a network interface capable of performing multicasting. The second `join()`
    method has an additional argument (`InetAddress s`) for indicating a source address
    from which group members can begin receiving datagrams. Since membership is *cumulative*,
    we can use multiple sources with the same group and network interface.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 想要加入多播组的客户端必须调用这些`join()`方法之一。第一个`join()`方法需要多播组的IP地址和一个能够执行多播的网络接口。第二个`join()`方法有一个额外的参数（`InetAddress
    s`），用于指示一个源地址，从该地址开始组成员可以接收数据报。由于成员资格是**累积的**，我们可以使用多个源与同一个组和网络接口。
- en: If a client manages to join a multicasting group, then it gets back a `MembershipKey`
    instance, which acts as a token, useful for performing different actions in that
    group.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端成功加入多播组，那么它会得到一个`MembershipKey`实例，该实例作为一个令牌，用于在该组中执行不同的操作。
- en: '**Important note**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: A multicast channel can join multiple groups. Moreover, a multicast channel
    can join the same group on more than one network interface.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 多播通道可以加入多个组。此外，多播通道可以在多个网络接口上加入同一个组。
- en: Leaving a multicast group can be done at any moment via the `close()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任何时候通过`close()`方法离开多播组。
- en: A brief overview of MembershipKey
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MembershipKey简要概述
- en: 'The most common actions that can be performed by a client of a multicast group
    via the `MembershipKey` instance are as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`MembershipKey`实例，多播组的客户端可以执行的最常见操作如下：
- en: '**Block/unblock**: By calling the `block()` method with a source address, we
    can block datagrams sent from that source. On the other hand, we can unblock a
    source via the `unblock()` method.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻止/解锁**：通过调用带有源地址的`block()`方法，我们可以阻止来自该源发送的数据报。另一方面，我们可以通过`unblock()`方法解锁一个源。'
- en: '**Get group**: The `group()` method returns the source address (`InetAddress`)
    of the group where the current membership key was created.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取组**：`group()`方法返回创建当前成员资格密钥的组的源地址（`InetAddress`）。'
- en: '**Get channel**: The `channel()` method returns the channel (`MulticastChannel`)
    of the group where the current membership key was created.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取通道**：`channel()`方法返回创建当前成员资格密钥的组的通道（`MulticastChannel`）。'
- en: '**Get source address**: For a source-specific membership key (receive datagrams
    only from that source), the `sourceAddress()` method returns the source address
    (`InetAddress`).'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取源地址**：对于特定源成员资格密钥（只接收来自该源的数据报），`sourceAddress()`方法返回源地址（`InetAddress`）。'
- en: '**Get network interface**: The network interface of this membership key (`NetworkInterface`)
    is available via `networkInterface()`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取网络接口**：本会员密钥的网络接口（`NetworkInterface`）可通过`networkInterface()`方法获取。'
- en: '**Check validity**: If a membership key is valid, then the `isValid()` method
    returns `true`.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查有效性**：如果成员资格密钥有效，则`isValid()`方法返回`true`。'
- en: '**Drop**: Dropping membership (no longer receiving datagrams from this group)
    can be done via the `drop()` method. Typically, a membership key becomes valid
    after creation and remains like this until the `drop()` method is called or the
    channel is closed.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丢弃**：通过`drop()`方法丢弃成员资格（不再接收来自该组的数据报）可以完成。通常，在创建后，成员资格密钥变得有效，并保持这种状态，直到调用`drop()`方法或关闭通道。'
- en: Next, let’s talk about network interfaces.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈网络接口。
- en: 265\. Exploring network interfaces
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 265. 探索网络接口
- en: In Java, a network interface is represented by the `NetworkInterface` API. Basically,
    a network interface is identified by a name and a list of IPs that are assigned
    to it. Via this information, we can associate a network interface with different
    network tasks such as a multicast group.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，网络接口由`NetworkInterface` API表示。基本上，网络接口通过一个名称和分配给它的IP列表来识别。通过这些信息，我们可以将网络接口与不同的网络任务关联起来，例如多播组。
- en: 'The following snippet of code lists all network interfaces that are available
    on your machine:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段列出了您机器上可用的所有网络接口：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For each network interface, we print at the console the display name (this
    is just a human-readable text that describes the network interface) and the name
    (this is useful to identify the network interface by name). In addition, we check
    if the network interface is virtual (if it is practically a subinterface), supports
    multicast, and is up and running. Running this application on my machine has returned
    multiple network interfaces, and in the following figure, there is a screenshot
    that shows a network interface that supports multicast (`ethernet_32775`):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个网络接口，我们在控制台打印显示名称（这是一个描述网络接口的文本，供人类阅读）和名称（这对于通过名称识别网络接口很有用）。此外，我们检查网络接口是否是虚拟的（如果它实际上是一个子接口），是否支持多播，以及是否正在运行。在我的机器上运行此应用程序已返回多个网络接口，在下图中，有一个显示支持多播的网络接口（`ethernet_32775`）的截图：
- en: '![Figure 13.4.png](img/B19655_13_04.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4.png](img/B19655_13_04.png)'
- en: 'Figure 13.4: A multicast network interface'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：多播网络接口
- en: Next, let’s see how we can use `ethernet_32775`to write a server/client multicast
    application.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用`ethernet_32775`编写一个服务器/客户端多播应用程序。
- en: 266\. Writing a UDP multicast server/client application
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 266. 编写UDP多播服务器/客户端应用程序
- en: In *Problem 263*, we developed a UDP server/client application. So, based on
    that experience, we can go further and highlight the main aspects that can transform
    a classical UDP-based application into a multicast one.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在*问题263*中，我们开发了一个UDP服务器/客户端应用程序。因此，基于这个经验，我们可以进一步深入，并强调可以将基于UDP的经典应用程序转换为多播应用程序的主要方面。
- en: For instance, let’s assume that we want to write a multicast server that sends
    to the group (to all members interested in receiving datagrams from this server)
    a datagram that encapsulates the current date-time on the server. This datagram
    is sent every 10 seconds.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要编写一个多播服务器，该服务器向组（向所有有兴趣接收来自该服务器数据报的成员）发送封装了服务器当前日期时间的数据报。这个数据报每10秒发送一次。
- en: Writing a UDP multicast server
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UDP多播服务器
- en: 'Writing a UDP multicast server starts with a new `DatagramChannel` instance
    obtained via the `open()` method. Next, we set the `IP_MULTICAST_IF` option (used
    to indicate the multicast network interface) and the `SO_REUSEADDR` option (used
    to allow multiple members to bind to the same address – this should be done before
    binding the socket):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 编写UDP多播服务器从通过`open()`方法获取的新`DatagramChannel`实例开始。接下来，我们设置`IP_MULTICAST_IF`选项（用于指示多播网络接口）和`SO_REUSEADDR`选项（用于允许多个成员绑定到同一地址——这应该在绑定套接字之前完成）：
- en: '[PRE61]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we call the `bind()` method to bind the channel’s socket to the local
    address:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`bind()`方法将通道的套接字绑定到本地地址：
- en: '[PRE62]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we need the code for transmitting the datagram containing the date-time
    of the server. We have arbitrarily chosen `225.4.5.6` as the IP address of the
    multicast group. Gluing everything together results in the following server code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要传输包含服务器日期时间的数据报的代码。我们任意选择了`225.4.5.6`作为多播组的IP地址。将所有这些粘合在一起，结果如下面的服务器代码：
- en: '[PRE63]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Next, let’s write a client interested in receiving datagrams from this server.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个感兴趣接收来自该服务器数据报的客户端。
- en: Writing a UDP multicast client
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UDP多播客户端
- en: 'Writing a UDP multicast client is not very different from writing a multicast
    server. However, there are some differences – for instance, we may want to check
    via `isMulticastAddress()` if the remote address (the address from where we receive
    datagrams) is a multicast address. Next, a client must join the multicast group,
    so it must call one of the `join()` methods described earlier in *Problem 264*.
    Finally, the implementation should be written to receive datagrams as in the following
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 编写UDP多播客户端与编写多播服务器没有太大区别。然而，也有一些不同之处——例如，我们可能想通过`isMulticastAddress()`检查远程地址（我们从那里接收数据报的地址）是否是多播地址。接下来，客户端必须加入多播组，因此它必须调用之前在*问题264*中描述的`join()`方法之一。最后，实现应该编写为接收数据报，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Next, let’s talk about blocking/unblocking datagrams.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论阻塞/解除阻塞数据报。
- en: Blocking/unblocking datagrams
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞/解除阻塞数据报
- en: 'As you already know, blocking datagrams from a certain multicast group can
    be done via the `block()` method, while unblocking via the `unblock()` method.
    Here is a snippet of code that blocks a list of addresses that we don’t like:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，可以通过`block()`方法阻塞来自特定多播组的数据报，而通过`unblock()`方法解除阻塞。以下是一个阻止我们不喜欢的地址列表的代码片段：
- en: '[PRE65]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Or, if you have a list of addresses that you like, then you can connect to
    all of them as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您有一个您喜欢的地址列表，那么您可以按照以下方式连接到所有这些地址：
- en: '[PRE66]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Finally, let’s test our application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试我们的应用程序。
- en: Testing the multicasting server/client application
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试多播服务器/客户端应用程序
- en: 'First, start the server and wait until you see the following message in the
    console:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动服务器，等待您在控制台看到以下消息：
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, you can start one or more instances of the client. At every 10 seconds,
    the server will send a datagram marked by the *Sending date-time ...* message:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以启动一个或多个客户端实例。每10秒钟，服务器将发送一个带有“*发送日期时间 ...*”消息标记的数据报：
- en: '[PRE68]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Every client that joined this multicast group will receive the datagrams from
    the server:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 加入此多播组的每个客户端都将从服务器接收数据报：
- en: '[PRE69]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Done! Notice that this application suffers from some shortcomings. For instance,
    the server and the client are not aware of each other. The server sends datagrams
    even if no client is listening, and the client may wait for datagrams even if
    the server is offline. Challenge yourself to address these shortcomings by adding
    more control to each side. Moreover, feel free to experiment with blocking/non-blocking
    modes and connectionless/connected features for multicast applications.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！请注意，这个应用程序存在一些不足之处。例如，服务器和客户端并不知道彼此。即使没有客户端监听，服务器也会发送数据报，而客户端可能会等待数据报，即使服务器已离线。挑战自己，通过为每一侧添加更多控制来解决这个问题。此外，您可以自由地尝试阻塞/非阻塞模式和连接/无连接特性，以进行多播应用程序的实验。
- en: 267\. Adding KEM to a TCP server/client application
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 267. 将KEM添加到TCP服务器/客户端应用程序
- en: In this problem, we attempt to write a TCP server/client application that communicates
    with each other via encrypted messages. The server side is referred to as the
    sender and the client as the receiver.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们试图编写一个TCP服务器/客户端应用程序，通过加密消息相互通信。服务器端被称为发送者，客户端被称为接收者。
- en: In this context, a sender can encrypt a message using its private key, and the
    receiver decrypts it using the sender’s public key. In case you didn’t recognize
    this scenario, then allow me to mention that we are talking about **Authenticated
    Key Exchange** (**AKE**) within **Public Key Encryption** (**PKE**) or, in short,
    about encrypting/decrypting messages based on the key exchange algorithms.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，发送者可以使用其私钥加密消息，接收者则使用发送者的公钥解密它。如果您没有认出这个场景，那么请允许我提一下，我们正在讨论**认证密钥交换**（**AKE**）在**公钥加密**（**PKE**）中的内容，或者简而言之，就是基于密钥交换算法加密/解密消息。
- en: AKE within PKE is a popular choice, but it is not secure. In other words, AKE
    vulnerabilities can be speculated by quantum computers that are capable of altering
    most key exchange algorithms. JDK 21 can prevent such issues via the newly introduced
    KEM ([https://en.wikipedia.org/wiki/Key_encapsulation_mechanism](https://en.wikipedia.org/wiki/Key_encapsulation_mechanism)).
    This is a final feature delivered as JEP 452.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在PKE中，AKE是一个流行的选择，但它并不安全。换句话说，量子计算机可以推测出AKE的漏洞，这些量子计算机能够改变大多数密钥交换算法。JDK 21可以通过新引入的KEM（[https://en.wikipedia.org/wiki/Key_encapsulation_mechanism](https://en.wikipedia.org/wiki/Key_encapsulation_mechanism)）来防止这些问题。这是一个作为JEP
    452交付的最终特性。
- en: KEM schemes rely on a private-public keypair and, additionally, on a common
    secret key. KEM works on the following steps.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: KEM方案依赖于一个私钥公钥对，以及一个共同的密钥。KEM的工作步骤如下。
- en: Generating a public-private keypair by the receiver
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收者生成公私钥对
- en: 'The receiver (client) generates a private-public keypair via the old-school
    approach known as the `KeyPairGenerator` API. The public key is obtained via `getPublic()`
    and the private key via `getPrivate()`. Here, we generate the keypairs for **Diffie-Hellman**
    (**DH**) key exchange with *Curve25519* as defined in RFC 7748:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者（客户端）通过被称为`KeyPairGenerator` API的旧式方法生成一个私钥公钥对。公钥通过`getPublic()`获得，私钥通过`getPrivate()`获得。在这里，我们生成了用于**Diffie-Hellman**（**DH**）密钥交换的密钥对，其中使用*Curve25519*，如RFC
    7748中定义：
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For now, we need only the public key.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要公钥。
- en: Transmitting the public key to the sender
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将公钥传输给发送者
- en: 'Next, the receiver sends the previously generated public key to the sender.
    This is done via the receiver’s `SocketChannel`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，接收者将之前生成的公钥发送给发送者。这是通过接收者的`SocketChannel`完成的：
- en: '[PRE71]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The sender needs the receiver’s public key to generate a secret key.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者需要接收者的公钥来生成一个密钥。
- en: Generating the common secret key by the sender
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送者生成共同的密钥
- en: 'First, the sender needs to reconstruct the receiver’s `PublicKey` instance
    from the received `byte[]` and for this, it can use the `KeyFactory` API as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，发送者需要从接收到的`byte[]`中重建接收者的`PublicKey`实例，为此，它可以使用`KeyFactory` API，如下所示：
- en: '[PRE72]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `buffer.array()` represents the `byte[]` containing the bytes of the public
    key. With the `PublicKey` in hand, the sender can rely on the KEM scheme to obtain
    the secret key. It starts by using the `KEM` class from JDK 21, which provides
    the functionality of a KEM:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer.array()`表示包含公钥字节的`byte[]`。有了`PublicKey`，发送者可以依赖KEM方案来获取密钥。它首先使用JDK
    21中的`KEM`类，该类提供了KEM的功能：'
- en: '[PRE73]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The DHKEM built-in algorithm is an advanced version of the DH algorithm ([https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: DHKEM内置算法是DH算法的高级版本（[https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)）。
- en: 'Next, the sender creates an `Encapsulator` and calls the `encapsulate()` method
    (known as the key encapsulation function), which generates (at each call) a secret
    key and a key encapsulation message:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，发送者创建一个`Encapsulator`并调用`encapsulate()`方法（称为密钥封装函数），该方法在每次调用时生成一个密钥和一个封装消息：
- en: '[PRE74]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If we call the `encapsulate()` method without arguments, then this is equivalent
    to `encapsulate(0, encorSender.secretSize(), "Generic")`. But, as you can see,
    we preferred the `AES` algorithm instead of `Generic`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不带参数调用`encapsulate()`方法，那么这相当于调用`encapsulate(0, encorSender.secretSize(),
    "Generic")`。但是，正如你所见，我们更倾向于使用`AES`算法而不是`Generic`。
- en: At this moment, the sender has the secret key and the encapsulation message
    via `encedSender`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，发送者通过`encedSender`拥有了密钥和封装消息。
- en: Sending the encapsulation message to the receiver
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将封装消息发送给接收者
- en: 'Now, the sender will transmit the key encapsulation message to the receiver
    via the `encapsulation()` method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发送者将通过`encapsulation()`方法将封装消息传输给接收者：
- en: '[PRE75]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The receiver is the only one capable of using their private key to decapsulate
    the received packet via a new `Decapsulator`. Once it does this, the receiver
    has the secret key:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者是唯一能够使用他们的私钥通过一个新的`Decapsulator`解封装接收到的数据包的人。一旦这样做，接收者就拥有了密钥：
- en: '[PRE76]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The secret key of the sender (`secretKeySender`) and the secret key of the receiver
    (`secretKeyReceiver`) are identical.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者的密钥（`secretKeySender`）和接收者的密钥（`secretKeyReceiver`）是相同的。
- en: Using the secret key to encrypt/decrypt messages
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用密钥加密/解密消息
- en: 'Now, the sender and receiver can continue the communication by encrypting/decrypting
    messages using the secret key and the well-known `Cipher` API:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发送者和接收者可以通过使用密钥和已知的 `Cipher` API 加密/解密消息来继续通信：
- en: '[PRE77]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For instance, the receiver can send an encrypted token to the sender:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，接收者可以向发送者发送加密令牌：
- en: '[PRE78]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The sender may generate a password based on this token and send it back to
    the receiver:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者可以根据此令牌生成密码并将其发送回接收者：
- en: '[PRE79]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Finally, the receiver decrypts the received password. In the bundled code, you
    can find the complete code.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，接收者解密接收到的密码。在捆绑的代码中，你可以找到完整的代码。
- en: 268\. Reimplementing the legacy Socket API
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 268. 重构遗留的 Socket API
- en: The Socket API has been improved over time and it is still receiving attention
    for potential further improvements.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Socket API 随着时间的推移得到了改进，并且仍然在为潜在的进一步改进而受到关注。
- en: Prior to JDK 13, the Socket API (`java.net.ServerSocket` and `java.net.Socket`)
    relied on `PlainSocketImpl`. Starting with JDK 13 (JEP 353), this API has been
    replaced by `NioSocketImpl`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 13 之前，Socket API (`java.net.ServerSocket` 和 `java.net.Socket`) 依赖于 `PlainSocketImpl`。从
    JDK 13（JEP 353）开始，此 API 已被 `NioSocketImpl` 替换。
- en: As its name suggests, `NioSocketImpl` is based on the NIO infrastructure. The
    new implementation doesn’t rely on the thread stack being capable of taking advantage
    of buffer cache mechanisms. Moreover, sockets can be closed via the `java.lang.ref.Cleaner`
    mechanism, which gives special attention to how socket objects are garbage collected.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`NioSocketImpl` 基于NIO 基础设施。新的实现不依赖于线程栈能够利用缓冲区缓存机制。此外，可以通过 `java.lang.ref.Cleaner`
    机制关闭套接字，这特别关注套接字对象是如何进行垃圾回收的。
- en: Starting with JDK 15 (JEP 373, follow-on of JEP 353), the internal Socket API
    has been reimplemented at `DatagramSocket` and `MulticastSocket` APIs. The goal
    was to make these APIs simpler and easier to adapt to work with Project Loom (virtual
    threads).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 15（JEP 373，JEP 353 的后续）开始，内部 Socket API 在 `DatagramSocket` 和 `MulticastSocket`
    API 中进行了重构。目标是使这些 API 更简单，更容易适应与 Project Loom（虚拟线程）一起工作。
- en: Whenever you prefer to go for the old `PlainSocketImpl`, you should run your
    code with the JVM `-Djdk.net.usePlainSocketImpl=true` option.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你更喜欢使用旧的 `PlainSocketImpl`，你应该使用 JVM `-Djdk.net.usePlainSocketImpl=true`
    选项运行你的代码。
- en: 269\. Quick overview of SWS
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 269. SWS 快速概述
- en: SWS was added in JDK 18 under JEP 408 in the `jdk.httpserver` module. Basically,
    SWS is a minimalist implementation of a static file server capable of serving
    a single directory hierarchy. If the request points to a file, then SWS will serve
    that file. If the request points to a directory containing an index file, then
    the index file will be served; otherwise, the directory content will be listed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: SWS 在 JDK 18 中通过 JEP 408 添加到 `jdk.httpserver` 模块中。基本上，SWS 是一个静态文件服务器的最小化实现，能够服务于单个目录层次结构。如果请求指向一个文件，则
    SWS 将提供该文件。如果请求指向包含索引文件的目录，则将提供索引文件；否则，将列出目录内容。
- en: SWS is very easy to set up and is available as a command-line tool (`jwebserver`)
    and as a suite of programmatic API points (`com.sun.net.httpserver`). SWS supports
    HTTP 1.1 only (not HTTPS or HTTP/2) and it can respond only to the idempotent
    `HEAD` and `GET` requests (any other request type will return a 405 or 501 HTTP
    code).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: SWS 非常容易设置，作为命令行工具 (`jwebserver`) 和程序化 API 点套件 (`com.sun.net.httpserver`) 提供。SWS
    仅支持 HTTP 1.1（不支持 HTTPS 或 HTTP/2），并且只能响应幂等的 `HEAD` 和 `GET` 请求（任何其他请求类型将返回 405 或
    501 HTTP 状态码）。
- en: In addition, MIME types are set up automatically by SWS and no security mechanism
    (for instance, OAuth) is available.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MIME 类型由 SWS 自动设置，并且没有可用的安全机制（例如 OAuth）。
- en: Key abstractions of SWS
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SWS 的关键抽象
- en: 'To better understand how SWS works behind the scenes, consider the following
    diagram:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 SWS 在幕后是如何工作的，考虑以下图表：
- en: '![Figure 13.10.png](img/B19655_13_05.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10.png](img/B19655_13_05.png)'
- en: 'Figure 13.5: SWS key abstractions'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：SWS 关键抽象
- en: On the left-hand side, we have a client for SWS (for instance, a browser) that
    triggers the HTTP requests and gets back HTTP responses. An HTTP request-response
    cycle is also known as an *exchange* – a client triggers a request and gets a
    response in exchange). On the right-hand side, there is an SWS containing the
    server, and a few *handlers* and *filters*. The server listens for incoming TCP
    connections. Next, each HTTP request is delegated to the proper handler (there
    can be one or more handlers). Here is where the request is practically handled
    by SWS. Finally, we have some filters. These are optional and they can be executed
    before processing the request (pre-processing filters) or after processing the
    request (post-processing filters – for instance, for logging purposes).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有 SWS 的客户端（例如，浏览器）触发 HTTP 请求并获取 HTTP 响应。HTTP 请求-响应周期也称为 *交换*（客户端触发请求并获取响应作为交换）。在右侧，有一个包含服务器、几个
    *处理器* 和 *过滤器* 的 SWS。服务器监听传入的 TCP 连接。接下来，每个 HTTP 请求被委托给适当的处理器（可能有一个或多个处理器）。在这里，请求实际上由
    SWS 处理。最后，我们有一些过滤器。这些是可选的，它们可以在处理请求之前（预处理过滤器）或之后（后处理过滤器，例如，用于记录目的）执行。
- en: 'Going further, an HTTP request flows through SWS as in the following diagram:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，HTTP 请求在 SWS 中的流程如下所示：
- en: '![Figure 13.11.png](img/B19655_13_06.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11.png](img/B19655_13_06.png)'
- en: 'Figure 13.6: SWS handlers and filters'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：SWS 处理器和过滤器
- en: One of the abstractions used by SWS is *context*. A context is a mapping between
    a root URI part and a handler `(/context/`). For instance, the URL `http://localhost:9009/a/file.txt`
    has the context `/a/`, which is associated with a certain handler. This way, SWS
    knows how to dispatch requests to handlers. In other words, SWS inspects the incoming
    request, extracts the context, and tries to find a handler with a matching context.
    That handler will serve the requested resource (`file.txt`). Finally, after the
    request is handled, a post-processing filter will log the request details.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: SWS 使用的抽象之一是 *上下文*。上下文是根 URI 部分（`/context/`）和处理器之间的映射。例如，URL `http://localhost:9009/a/file.txt`
    的上下文是 `/a/`，它与某个特定的处理器相关联。这样，SWS 就知道如何将请求分派给处理器。换句话说，SWS 检查传入的请求，提取上下文，并尝试找到一个与上下文匹配的处理器。该处理器将提供请求的资源（`file.txt`）。最后，在请求被处理后，一个后处理过滤器将记录请求详情。
- en: 270\. Exploring the SWS command-line tool
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 270. 探索 SWS 命令行工具
- en: 'The only prerequisite for running the SWS command-line tool (`jwebserver`)
    is JDK 18 and the following syntax:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 SWS 命令行工具（`jwebserver`）的唯一先决条件是 JDK 18 和以下语法：
- en: '![Figure 13.5.png](img/B19655_13_07.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5.png](img/B19655_13_07.png)'
- en: 'Figure 13.7: jwebserver command-line tool syntax'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：jwebserver 命令行工具语法
- en: 'The options of `jwebserver` are straightforward. Here is a short description
    of the most useful ones:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwebserver` 的选项很简单。以下是其中一些最有用的选项的简要描述：'
- en: '`-b addr`: This is the binding address. It defaults to the loopback, `127.0.0.1`
    or `::1`. For all interfaces, we can use `-b 0.0.0.0` or `-b ::`. The `–b addr`
    is similar to`--bind-address addr`.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b addr`: 这是绑定地址。默认为回环地址，`127.0.0.1` 或 `::1`。对于所有接口，我们可以使用 `-b 0.0.0.0` 或
    `-b ::`。`–b addr` 与 `--bind-address addr` 类似。'
- en: '`-p port`: This specifies the port on which the SWS will listen for incoming
    requests. The default port is `8000`. The `–p` port option is similar to`--port
    port`.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p port`: 这指定了 SWS 将监听传入请求的端口。默认端口是 `8000`。`–p` 端口选项与 `--port port` 类似。'
- en: '`-d dir`: The `dir` variable points out the directory to be served. The default
    is the current directory. The `–d dir` is similar to`--directory dir`.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d dir`: `dir` 变量指向要服务的目录。默认是当前目录。`–d dir` 与 `--directory dir` 类似。'
- en: '`-o level`: The `level` variable can be `none`, `info` (default), or `verbose`
    and it specifies the output format. The `–o level` is similar to `--output level`.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o level`: `level` 变量可以是 `none`、`info`（默认）或 `verbose`，它指定了输出格式。`–o level`
    与 `--output level` 类似。'
- en: You can list all options and their description via the `jwebsever –h` command.
    Keeping these options in mind, let’s start an SWS instance.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `jwebsever –h` 命令列出所有选项及其描述。记住这些选项后，让我们启动一个 SWS 实例。
- en: Starting SWS from the command line
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行启动 SWS
- en: 'Let’s assume that we want to serve the files from a directory named `docs`,
    which contains a text file and a few image files (you’ll find this folder in the
    bundled code). For this, we open a command prompt (in Windows) and navigate to
    the `docs` folder. Next, from this folder, we launch the `jwebserver` command
    as in the following figure:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从一个名为`docs`的目录中提供服务，该目录包含一个文本文件和一些图像文件（你可以在捆绑的代码中找到这个文件夹）。为此，我们打开一个命令提示符（在Windows中）并导航到`docs`文件夹。接下来，从这个文件夹中，我们像以下图所示启动`jwebserver`命令：
- en: '![Figure 13.6.png](img/B19655_13_08.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.6.png](img/B19655_13_08.png)'
- en: 'Figure 13.8: Starting SWS via jwebserver command'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：通过jwebserver命令启动SWS
- en: 'Next, we need to copy the URL displayed on the command prompt into a browser
    address bar (here, the URL is `http://127.0.0.1:8000/`). Since our request points
    to the current directory (`docs`), we get back the listing of this directory in
    the following figure:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将命令提示符上显示的URL复制到浏览器地址栏中（这里，URL是`http://127.0.0.1:8000/`）。由于我们的请求指向当前目录（`docs`），我们得到以下图中的目录列表：
- en: '![Figure 13.7.png](img/B19655_13_09.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.7.png](img/B19655_13_09.png)'
- en: 'Figure 13.9: SWS serving the current directory listing'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：SWS服务当前目录列表
- en: If we click on `books.txt` or on any of the images then we will trigger a request
    to a file, so SWS will return the file content and the browser will render it
    accordingly.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`books.txt`或任何图像，那么我们将触发对文件的请求，因此SWS将返回文件内容，浏览器将相应地渲染它。
- en: 'Here is a screenshot of clicking on `books.txt` and `Java Coding Problems 2nd
    Edition.png`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是点击`books.txt`和`Java Coding Problems 2nd Edition.png`的截图：
- en: '![Figure 13.8.png](img/B19655_13_10.png)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.8.png](img/B19655_13_10.png)'
- en: 'Figure 13.10: SWS serving two files (a text file and an image)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：SWS服务两个文件（一个文本文件和一个图像文件）
- en: 'Meanwhile, SWS has logged each of our requests in the following image:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，SWS已将我们的每个请求记录在以下图片中：
- en: '![Figure 13.9.png](img/B19655_13_11.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.9.png](img/B19655_13_11.png)'
- en: 'Figure 13.11: SWS has logged the GET requests'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：SWS已记录GET请求
- en: Done! Next, let’s see how we can configure the server.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！接下来，让我们看看我们如何配置服务器。
- en: Configuring SWS from the command line
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过命令行配置SWS
- en: 'Configuring SWS from the command line can be done via the options listed earlier.
    For instance, if we want to change the default port then we use `–p port` (or
    `--port port`). In the following example, we use port `9009` instead of the default
    `8000`. Moreover, we make our server available only to the address `172.27.128.1`
    via `–b addr` (this is an address specific to my machine representing a *Hyper-V
    virtual Ethernet adapter* supporting multicast):'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行配置SWS可以通过前面列出的选项来完成。例如，如果我们想更改默认端口，则使用`–p port`（或`--port port`）。在以下示例中，我们使用端口`9009`而不是默认的`8000`。此外，我们通过`–b
    addr`（这是一个特定于我的机器的地址，代表一个支持组播的*Hyper-V虚拟以太网适配器*）使我们的服务器仅对地址`172.27.128.1`可用：
- en: '[PRE80]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This time, we open the browser and point it to `http://172.27.128.1:9009/`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们打开浏览器，将其指向`http://172.27.128.1:9009/`。
- en: Feel free to test other options as well.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 随意测试其他选项。
- en: Stopping SWS from the command line
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过命令行停止SWS
- en: A SWS instance runs until it is explicitly stopped. In Unix/Windows, we can
    stop SWS from the command line by simply typing *Ctrl* + *C*. Sometimes, you have
    to wait a few seconds until the server is stopped and the command prompt is available
    for other commands.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SWS实例会一直运行，直到它被明确停止。在Unix/Windows中，我们可以通过简单地输入*Ctrl* + *C*从命令行停止SWS。有时，你可能需要等待几秒钟，直到服务器停止，命令提示符才可用于其他命令。
- en: 271\. Introducing the com.sun.net.httpserver API
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 271. 介绍com.sun.net.httpserver API
- en: Since 2006, next to the SWS command-line tool, we have the programmatic bridge
    represented by the `com.sun.net.httpserver` API. Practically, the goal of this
    API is to allow us to programmatically launch an SWS instance in a very easy way.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 自2006年以来，除了SWS命令行工具外，我们还拥有由`com.sun.net.httpserver` API表示的程序化桥梁。实际上，这个API的目标是允许我们以非常简单的方式程序化启动一个SWS实例。
- en: 'First, we have the `SimpleFileServer`, which is the main API for creating an
    SWS instance via three static methods, `createFileServer()`, `createFileHandler()`,
    and `createOutputFilter()`. We are especially interested in the `createFileServer(InetSocketAddress
    addr, Path rootDirectory, SimpleFileServer.OutputLevel outputLevel)` method. As
    you can see, via this method, we can create an SWS instance with a given port,
    root directory (this should be an absolute path), and output level as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `SimpleFileServer`，这是通过三个静态方法创建 SWS 实例的主要 API，即 `createFileServer()`、`createFileHandler()`
    和 `createOutputFilter()`。我们特别感兴趣的是 `createFileServer(InetSocketAddress addr, Path
    rootDirectory, SimpleFileServer.OutputLevel outputLevel)` 方法。正如您所看到的，通过此方法，我们可以创建一个具有给定端口、根目录（这应该是一个绝对路径）和输出级别的
    SWS 实例，如下所示：
- en: '[PRE81]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: After running this application, an SWS will be available at `http://localhost:9009/`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序后，将在 `http://localhost:9009/` 处可用一个 SWS。
- en: The default address is the loopback address, so you can also express the `InetSocketAddress`
    as `new InetSocketAddress(InetAddress.getLoopbackAddress(), 9009)`. Moreover,
    we can bind the server after creation via `bind(InetSocketAddress addr, int backlog)`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 默认地址是回环地址，因此您也可以将 `InetSocketAddress` 表达为 `new InetSocketAddress(InetAddress.getLoopbackAddress(),
    9009)`。此外，我们可以在创建服务器后通过 `bind(InetSocketAddress addr, int backlog)` 绑定服务器。
- en: For programmatically starting and stopping the SWS instance, we have the `start()`
    and `stop()` methods.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序化启动和停止 SWS 实例，我们有 `start()` 和 `stop()` 方法。
- en: Using a custom HttpHandler
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义 HttpHandler
- en: 'Another approach for programmatically creating a custom SWS instance relies
    on creating a file handler and passing it to the overloaded `HttpServer.create()`
    method. The file handler can be created as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种程序化创建自定义 SWS 实例的方法是创建一个文件处理器，并将其传递给重载的 `HttpServer.create()` 方法。文件处理器可以创建如下：
- en: '[PRE82]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This file handler can be passed to `HttpServer.create(InetSocketAddress addr,
    int backlog, String path, HttpHandler handler, Filter... filters)` next to the
    port, socket backlog (*maximum number of queued incoming connections to allow
    on the listening socket*), context path, and optional filters as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件处理器可以传递给 `HttpServer.create(InetSocketAddress addr, int backlog, String path,
    HttpHandler handler, Filter... filters)`，与端口、套接字回退（*允许在监听套接字上排队等待的最大传入连接数*）、上下文路径和可选过滤器一起，如下所示：
- en: '[PRE83]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This time, the server will be available at `http://localhost:9009/mybooks/`.
    If you want to achieve the same thing and still use `createFileServer()`, then
    you need to explicitly set the context and the file handler via `setContext()`
    and `setHandler()` after creating an SWS as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，服务器将在 `http://localhost:9009/mybooks/` 处可用。如果您想实现相同的功能并且仍然使用 `createFileServer()`，那么在创建
    SWS 后，您需要通过 `setContext()` 和 `setHandler()` 显式设置上下文和文件处理器，如下所示：
- en: '[PRE84]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There is also a `createContext(String path, HttpHandler handler)`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `createContext(String path, HttpHandler handler)` 方法。
- en: Using a custom filter
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义过滤器
- en: Adding a post-processing filter for SWS logging can be done via `createOutputFilter(OutputStream
    out, OutputLevel outputLevel)`. So, we have to specify an output stream and the
    level of logging.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `createOutputFilter(OutputStream out, OutputLevel outputLevel)` 添加 SWS 记录的后处理过滤器可以完成。因此，我们必须指定一个输出流和日志级别。
- en: 'We can have multiple filters (via the filters array, `Filter...`), but here
    we create a single one that sends the log into a text file named `swslog.txt`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有多个过滤器（通过过滤器数组，`Filter...`），但在这里我们创建一个将日志发送到名为 `swslog.txt` 的文本文件的单一过滤器：
- en: '[PRE85]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This time, each request solved by our SWS will be logged into `swslog.txt`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的 SWS 解决的每个请求都将记录到 `swslog.txt`。
- en: Using a custom executor
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义执行器
- en: 'By default, all HTTP requests of an SWS instance are handled by the thread
    that was created by the `start()` method. But, we can specify any `Executor` for
    handling the HTTP requests via the `setExecutor()` method. For instance, we can
    rely on `newVirtualThreadPerTaskExecutor()` as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SWS 实例的所有 HTTP 请求都由 `start()` 方法创建的线程处理。但是，我们可以通过 `setExecutor()` 方法指定任何
    `Executor` 来处理 HTTP 请求。例如，我们可以依赖 `newVirtualThreadPerTaskExecutor()` 如下所示：
- en: '[PRE86]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Getting the current `Executor` can be done via the `getExecutor()` method. If
    no `Executor` was previously set, then `getExecutor()` returns `null`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `getExecutor()` 方法可以获取当前的 `Executor`。如果没有之前设置 `Executor`，则 `getExecutor()`
    返回 `null`。
- en: 272\. Adapting request/exchange
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 272. 适配请求/交换
- en: Adapting a request can be useful for testing and debugging purposes. Practically,
    we can adapt the request (`com.sun.net.httpserver.Request`) before the handler
    sees it, so we can modify the initial request and pass the result to the handler.
    For this, we can rely on the pre-processing `Filter.adaptRequest(String description,
    UnaryOperator<Request> requestOperator)` method. Besides the description, this
    method gets the effective request state of the exchange as `UnaryOperator<Request>`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 适应请求对于测试和调试目的可能很有用。实际上，我们可以在处理器看到它之前适应请求（`com.sun.net.httpserver.Request`），这样我们就可以修改初始请求并将结果传递给处理器。为此，我们可以依赖预处理`Filter.adaptRequest(String
    description, UnaryOperator<Request> requestOperator)`方法。除了描述外，此方法获取交换的有效请求状态作为`UnaryOperator<Request>`。
- en: 'Here is an example that adds to each request the header `Author` next to a
    post-processing filter that logs the request details to the console:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，它将`Author`头添加到每个请求旁边的一个后处理过滤器中，该过滤器将请求详情记录到控制台：
- en: '[PRE87]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can see that the `Author` header is added to each request directly in the
    logs. In the following figure, you can see this header among other headers:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Author`头直接添加到每个请求中。在下图中，你可以看到这个头在其他头之间：
- en: '![Figure 13.12.png](img/B19655_13_12.png)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.12.png](img/B19655_13_12.png)'
- en: 'Figure 13.12: The Author header was added'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：添加了作者头
- en: 'Besides `adaptRequest()`, the `Filter` class defines the `beforeHandler(String
    description, Consumer<HttpExchange> operation)` pre-processing filter and the
    `afterHandler(String description, Consumer<HttpExchange> operation)` post-processing
    filter. In both cases, the `operation` argument represents the effective implementation
    of the filter. As you can see, these filters are acting as hooks for `com.sun.net.httpserver.HttpExchange`,
    which represents an *exchange* (an HTTP request and the response in exchange):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`adaptRequest()`之外，`Filter`类还定义了`beforeHandler(String description, Consumer<HttpExchange>
    operation)`预处理过滤器和`afterHandler(String description, Consumer<HttpExchange> operation)`后处理过滤器。在两种情况下，`operation`参数代表过滤器的有效实现。正如你所看到的，这些过滤器充当了`com.sun.net.httpserver.HttpExchange`的钩子，它代表一个*交换*（一个HTTP请求和相应的响应）：
- en: '[PRE88]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Via the `exchange` object, we have access to request/response headers and body.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`exchange`对象，我们可以访问请求/响应头和正文。
- en: 273\. Complementing a conditional HttpHandler with another handler
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 273. 使用另一个处理器补充条件`HttpHandler`
- en: 'Let’s assume that we want to choose between two `HttpHandler` instances based
    on a condition. For instance, for all `GET` requests, we want to use the following
    well-known `HttpHandler`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要根据条件在两个`HttpHandler`实例之间进行选择。例如，对于所有`GET`请求，我们希望使用以下众所周知的`HttpHandler`：
- en: '[PRE89]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'For all other requests, we want to use an `HttpHandler` that always returns
    the same resource (for instance, the text *No data available*). Defining a `HttpHandler`
    that always returns the same code and resource (so, a *canned response*) can be
    done via the `HttpHandlers.of(int statusCode, Headers headers, String body)` method
    as in the following example:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他请求，我们希望使用一个`HttpHandler`，它总是返回相同的资源（例如，文本*No data available*）。通过`HttpHandlers.of(int
    statusCode, Headers headers, String body)`方法定义一个总是返回相同代码和资源（因此，一个*预定义响应*）的`HttpHandler`，如下例所示：
- en: '[PRE90]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In addition, the `HttpHandler` class exposes a method that can decide between
    two `HttpHandler` instances based on a condition. This method is `handleOrElse(Predicate<Request>
    handlerTest, HttpHandler handler, HttpHandler fallbackHandler)`. As you can see,
    the condition is expressed as `Predicate<Request>`, so in our case, we can write
    it as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`HttpHandler`类公开了一个方法，可以根据条件在两个`HttpHandler`实例之间进行选择。这个方法是`handleOrElse(Predicate<Request>
    handlerTest, HttpHandler handler, HttpHandler fallbackHandler)`。正如你所看到的，条件被表示为`Predicate<Request>`，因此在我们的情况下，我们可以写成如下：
- en: '[PRE91]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, all we have to do is to pass this `Predicate<Request>` and the two handlers
    to the `handleOrElse()` method:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需将这个`Predicate<Request>`和两个处理器传递给`handleOrElse()`方法：
- en: '[PRE92]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If `predicate` is evaluated to `true` (so, an HTTP `GET` request was received),
    then `fileHandler` will be used; otherwise, `complementHandler` will be used.
    Finally, we create and start an SWS instance as follows:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`predicate`评估为`true`（因此，收到了HTTP `GET`请求），则使用`fileHandler`；否则，使用`complementHandler`。最后，我们创建并启动一个SWS实例，如下所示：
- en: '[PRE93]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Notice that the passed `HttpHandler` is `handler`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传递的`HttpHandler`是`handler`。
- en: 274\. Implementing SWS for an in-memory file system
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 274. 实现内存文件系统的SWS
- en: We already know that SWS can serve files from the default local file system.
    While this file system fits many scenarios, there are also use cases (for instance,
    testing scenarios) where it will be more practical to mock a directory structure
    in order to simulate certain expectations. In such scenarios, an in-memory file
    system will be more suitable than the local file system since we can avoid the
    creation/deletion of resources and we can use different platforms.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道SWS可以从默认的本地文件系统提供文件。虽然这个文件系统适合许多场景，但也有一些用例（例如，测试场景）中，模拟目录结构以模拟某些期望将更加实用。在这种情况下，内存文件系统将比本地文件系统更适合，因为我们可以避免资源的创建/删除，并且可以使用不同的平台。
- en: 'An in-memory file system implementation for Java 8 (based on the `java.nio.file`
    API) is provided by the Google project named *Jimfs* ([https://github.com/google/jimfs](https://github.com/google/jimfs)).
    By following the instructions from the GitHub example, we wrote the following
    code for a simple in-memory file system:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Google项目名为*Jimfs*（[https://github.com/google/jimfs](https://github.com/google/jimfs)）为Java
    8提供了一个基于`java.nio.file` API的内存文件系统实现。通过遵循GitHub示例中的说明，我们编写了以下代码以实现一个简单的内存文件系统：
- en: '[PRE94]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The path returned by the previous code is `/docs/books.txt` (you can easily
    create any kind of directory/files hierarchy). Since the SWS file handler supports
    any kind of path’s file system that implements the `java.nio.file` API, we should
    be able to start an SWS instance for the in-memory path returned via `inMemoryDirectory()`
    as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码返回的路径是`/docs/books.txt`（你可以轻松创建任何类型的目录/文件层次结构）。由于SWS文件处理器支持实现`java.nio.file`
    API的任何类型的路径文件系统，我们应该能够启动一个SWS实例，如下所示，通过`inMemoryDirectory()`返回的内存路径：
- en: '[PRE95]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For testing, point the browser to `http://localhost:9009`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，将浏览器指向`http://localhost:9009`。
- en: 275\. Implementing SWS for a zip file system
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 275. 为zip文件系统实现SWS
- en: '[PRE96]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The result is an archive named `docs.zip` with a single file named `bookszipped.txt`—this
    file was copied into the archive from the external `/docs` folder where it is
    stored under the name `books.txt`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个名为`docs.zip`的存档，其中包含一个名为`bookszipped.txt`的单个文件——这个文件是从外部`/docs`文件夹中复制的，在该文件夹中以`books.txt`命名存储。
- en: 'Next, we can write our SWS instance as follows:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以如下编写我们的SWS实例：
- en: '[PRE98]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: After starting the SWS instance, just point the browser to the `http://localhost:9009/bookszipped.txt`
    URL and you should see the content of the text file.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 启动SWS实例后，只需将浏览器指向`http://localhost:9009/bookszipped.txt` URL，你应该能看到文本文件的内容。
- en: 276\. Implementing SWS for a Java runtime directory
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 276. 为Java运行时目录实现SWS
- en: 'Starting with JDK 9 (JEP 220), the runtime images have been restructured to
    support modules and become more performant and secure. Moreover, naming stored
    modules, classes, and resources has received a new URI scheme (`jrt`). Via the
    `jrt` scheme, we can reference modules, classes, and resources contained in runtime
    images without touching the internal structure of the image. A `jrt` URL looks
    as follows:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 9（JEP 220）开始，运行时图像已经重新构建以支持模块，并变得更加高效和安全。此外，命名存储的模块、类和资源已收到一个新的URI方案（`jrt`）。通过`jrt`方案，我们可以引用运行时图像中包含的模块、类和资源，而无需触及图像的内部结构。一个`jrt`
    URL看起来如下所示：
- en: '[PRE99]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here, `$MODULE` is a module name (optional) and `$PATH` (optional) represents
    the path to a certain class/resource file within that module. For instance, to
    point out the `File` class, we write the following URL:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$MODULE`是一个模块名称（可选），而`$PATH`（可选）表示该模块内某个类/资源文件的路径。例如，要指向`File`类，我们编写以下URL：
- en: '[PRE100]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the `jrt` file system, there is a top-level `modules` directory that contains
    one subdirectory for each module in the image. So, we can fetch the proper path
    for SWS as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jrt`文件系统中，有一个顶层`modules`目录，其中包含图像中每个模块的一个子目录。因此，我们可以如下获取SWS的正确路径：
- en: '[PRE101]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, SWS can serve the `modules` directory of the given runtime image as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，SWS可以如下提供给定运行时图像的`modules`目录：
- en: '[PRE102]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Finally, start SWS and point out the URL to a class/resource. For instance,
    the `http://localhost:9009/java.base/java/io/File.class` URL will download the
    `File.class` for local inspection.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动SWS并将URL指向一个班级/资源。例如，`http://localhost:9009/java.base/java/io/File.class`
    URL将下载`File.class`以供本地检查。
- en: Summary
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 19 problems with Socket API and SWS. In the first part
    of this chapter, we covered NIO.2 features dedicated to TCP/UDP server/client
    applications. In the second part, we covered JDK 18 SWS as a command-line tool
    and as a suite of API points.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了19个与Socket API和SWS相关的问题。在本章的第一部分，我们介绍了NIO.2针对TCP/UDP服务器/客户端应用程序的功能。在第二部分，我们介绍了JDK
    18 SWS作为一个命令行工具以及作为一系列API点的集合。
- en: Leave a review!
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below for a 20% discount code.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论帮助像你这样的读者。扫描下面的二维码获取20%的折扣码。
- en: '![](img/Leave_Reivew_QR.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_Reivew_QR.png)'
- en: '**Limited Offer*'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
