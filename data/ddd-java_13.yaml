- en: '*Chapter 10*: Beginning the Decomposition Journey'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：开始分解之旅'
- en: A distributed system is one in which the failure of a computer you didn’t even
    know existed can render your own computer unusable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分布式系统是这样的，一个你甚至不知道存在的计算机的故障可以使你的计算机无法使用。
- en: — Leslie Lamport
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —— 莱斯利·兰波特
- en: So far, we have a working application for **Letter of Credit** (**LC**) application
    processing, which is bundled along with other components as a single package.
    Although we have discussed the idea of subdomains and bounded contexts, the separation
    between these components is logical rather than physical. Furthermore, we have
    primarily focused on the *LC Application Processing* aspect of the overall solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个用于**信用证**（**LC**）应用处理的运行中的应用程序，它与其他组件捆绑在一起作为一个单一包。尽管我们已经讨论了子域和边界上下文的概念，但这些组件之间的分离是逻辑上的，而不是物理上的。此外，我们主要关注整体解决方案的**LC应用处理**方面。
- en: In this chapter, we will look at how to extract the LC Application Processing
    bounded context into a component that is physically disparate and, hence, enables
    us to deploy them independently of the rest of the solution. We will discuss the
    various options that are available to us, the rationale for choosing a given option,
    and the implications that we need to be cognizant of.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将LC应用处理的边界上下文提取到一个物理上分离的组件中，从而使我们能够独立于整个解决方案进行部署。我们将讨论我们可用的各种选项，选择给定选项的理由，以及我们需要意识到的含义。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Continuing our design journey
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: Decomposing our monolith
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解我们的单体
- en: Changes to frontend interactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端交互的变化
- en: Changes in database interactions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库交互的变化
- en: By the end of this chapter, you will have learned what it takes to design well-factored
    APIs—both remote procedure calls and event-based. For event-based APIs, you will
    gain an understanding of the various guarantees that might be needed to create
    robust solutions. Finally, you will also learn how to manage consistency when
    using multiple data stores.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解到设计良好设计的API所需的因素——无论是远程过程调用还是基于事件的。对于基于事件的API，你将了解可能需要创建健壮解决方案的各种保证。最后，你还将学习如何在使用多个数据存储时管理一致性。
- en: Continuing our design journey
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'In the preceding chapters, we had a solution for LC Application Processing
    that worked as an in-process component of the remainder of the overall application.
    From a logical perspective, our realization of the LC application is similar to
    the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们有一个LC应用处理的解决方案，它作为整体应用程序的进程内组件工作。从逻辑角度来看，我们对LC应用的实现类似于以下图表：
- en: '![Figure 10.1 – The current view of the LC application monolith'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – LC应用单体当前视图'
- en: '](img/B16716_Figure_10.1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.1.jpg)'
- en: Figure 10.1 – The current view of the LC application monolith
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – LC应用单体当前视图
- en: Although the **LC Application Processing** component is loosely coupled with
    the rest of the application, we are still required to coordinate with several
    other teams to realize the business value. This could inhibit our ability to innovate
    at a pace that is faster than the slowest contributor in the ecosystem. This is
    because all teams need to be production-ready before a deployment can happen.
    This can be further exacerbated by the fact that individual teams might be at
    different levels of engineering maturity. Let’s look at some options regarding
    how we can achieve a level of independence from the rest of the ecosystem by physically
    decomposing our components into distinctly deployable artifacts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**LC应用处理**组件与整个应用程序松散耦合，但我们仍然需要与其他几个团队协调以实现业务价值。这可能会阻碍我们以比生态系统中最慢的贡献者更快的速度进行创新。这是因为所有团队都需要准备好生产环境，才能进行部署。此外，由于各个团队可能在工程成熟度方面处于不同的水平，这可能会进一步加剧。让我们看看一些关于我们如何通过将我们的组件物理分解成明显可部署的工件来实现一定程度的独立性的选项。
- en: Decomposing our monolith
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解我们的单体
- en: 'First and foremost, the **LC Application Processing** component exposes only
    in-process APIs when other components interact with it. This includes interactions
    with the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的，**LC应用处理**组件在与其他组件交互时仅暴露进程内API。这包括以下交互：
- en: The frontend
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端
- en: Published/consumed events
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/消费的事件
- en: Databases
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: To extract LC Application Processing functionality into its own, independently
    deployable component, remotely invokable interfaces will have to be supported
    instead of the in-process ones that we currently have. So, let’s examine the remote
    API options for each.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将LC应用程序处理功能提取为其自己的、独立可部署的组件，我们需要支持远程调用接口，而不是我们目前拥有的进程内接口。因此，让我们逐一考察每个远程API选项。
- en: Changes to frontend interactions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端交互的变更
- en: 'Currently, the `CommandGateway` for commands and `QueryGateway` for queries),
    as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如这里所示，`CommandGateway`用于命令和`QueryGateway`用于查询：
- en: '![](img/ch10-1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch10-1.jpg)'
- en: 'One very simple way to replace these in-process calls is to introduce some
    form of **Remote Procedure Call** (**RPC**). Now our application looks similar
    to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 替换这些进程内调用的一个非常简单的方法是引入某种形式的**远程过程调用（RPC**）。现在我们的应用程序看起来类似于以下这样：
- en: '![Figure 10.2 – Introducing remote interaction with the frontend'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – 向前端引入远程交互'
- en: '](img/B16716_Figure_10.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2](img/B16716_Figure_10.2.jpg)'
- en: Figure 10.2 – Introducing remote interaction with the frontend
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 向前端引入远程交互
- en: When working with in-process interactions, we are simply invoking methods on
    objects within the confines of the same process. However, when we switch to using
    out-of-process calls, there are quite a few considerations. These days when working
    with remote APIs, we have several popular choices in the form of **JSON**-based
    web services, **GraphQL**, **gRPC**, and more. While it is possible to make use
    of a completely custom format to facilitate the communication, DDD advocates the
    use of the **Open Host Service pattern** ([https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs](https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs))
    using a published language that we covered in [*Chapter 9*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138),
    *Integrating with External Systems*. Even with the open host service style of
    communication, there are a few considerations, some of which we discuss in the
    following subsections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理进程内交互时，我们只是在同一进程的范围内调用对象的方法。然而，当我们切换到使用进程外调用时，需要考虑很多因素。如今，在处理远程API时，我们有几种流行的选择，包括基于**JSON**的Web服务、**GraphQL**、**gRPC**等。虽然可以使用完全定制的格式来促进通信，但领域驱动设计（DDD）倡导者推荐使用**开放主机服务模式**（[https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs](https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs)），使用我们在[*第9章*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138)中介绍发布的语言，即*与外部系统集成*。即使使用开放主机服务风格的通信，也有一些考虑因素，其中一些我们在以下小节中讨论。
- en: Protocol options
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议选项
- en: 'There are several options available to us when exposing remote APIs. These
    days, using a JSON-based API (often labeled as **Representation State Transfer**
    or **REST**) seems to be quite popular. However, this isn’t the only option available
    to us. In a resource-based approach, the first step is to identify a resource
    (noun) and then map the interactions (verbs) associated with the resource as a
    next step. In an action-based approach, the focus is on the actions to be performed.
    Arguably, REST takes a resource-based approach, whereas **graphQL**, **gRPC**,
    **SOAP**, and more, seem to be action-based. Let’s take an example of an API where
    we want to start a new LC application. In a RESTful world, this could look something
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当暴露远程API时，我们有几种选择。如今，使用基于JSON的API（通常标记为**表示状态转移**或**REST**）似乎相当流行。然而，这并不是我们唯一的选择。在基于资源的方案中，第一步是确定一个资源（名词），然后作为下一步映射与资源相关的交互（动词）。在基于动作的方案中，重点是执行的动作。可以说，REST采用基于资源的方案，而**GraphQL**、**gRPC**、**SOAP**等似乎基于动作。让我们以一个API为例，我们想要启动一个新的LC应用程序。在RESTful世界中，这可能看起来像这样：
- en: '![](img/10-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10-2.jpg)'
- en: 'In comparison, with a graphQL implementation, this could look like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用GraphQL实现，这可能看起来像以下这样：
- en: '![](img/10-3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10-3.jpg)'
- en: In our experience, designing APIs using REST does result in some form of dilution
    when attempting to mirror the language of the domain—because the focus is first
    and foremost on resources. Purists will be quick to point out that the preceding
    example is not RESTful because there is no resource named `start-new` and that
    we should leave the URL to simply include the name of the resource (use /lc- applications
    instead of `/lc-applications/start-new`). Our approach is to place more importance
    on remaining true to the ubiquitous language as opposed to being dogmatic about
    adherence to technical purity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，使用REST设计API在尝试映射领域语言时确实会导致一定程度上的稀释——因为首要关注的是资源。纯粹主义者会迅速指出，前面的例子并不符合REST原则，因为没有名为`start-new`的资源，我们应该让URL仅包含资源的名称（使用`/lc-applications`而不是`/lc-applications/start-new`）。我们的方法是将保持通用语言的准确性置于对技术纯度的教条式遵循之上。
- en: Transport format
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输格式
- en: 'Here, we have two broad choices: **text-based** (for example, **JSON** or **XML**)
    versus **binary** (for example, protocol buffers, [https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers),
    or Avro, [https://avro.apache.org/](https://avro.apache.org/)). If non-functional
    requirements (such as performance) are met, our preference is to use text-based
    protocols as a starting point. That’s because it can afford the flexibility of
    not needing any additional tools to visually interpret the data (when debugging).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种广泛的选择：**基于文本的**（例如，**JSON**或**XML**）与**二进制**（例如，协议缓冲区，[https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers)，或Avro，[https://avro.apache.org/](https://avro.apache.org/)))。如果满足了非功能性需求（如性能），我们的首选是使用基于文本的协议作为起点。这是因为它提供了灵活性，不需要任何额外的工具来直观地解释数据（当调试时）。
- en: When designing a remote API, we have the option of choosing a format that enforces
    a schema (for example, protocol buffers or Avro) or something less formal such
    as plain JSON. In such cases, in order to stay true to the ubiquitous language,
    the process might have to include additional governance in the form of more formal
    design and code reviews, documentation, and more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计远程API时，我们有选择一个强制执行模式（例如，协议缓冲区或Avro）或更非正式的格式（例如，纯JSON）的选项。在这种情况下，为了保持通用语言的准确性，可能需要在更正式的设计和代码审查、文档等方面进行额外的治理。
- en: Compatibility and versioning
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性和版本控制
- en: As requirements evolve, there will be a need to enhance the interfaces to reflect
    these changes. This will mean that our ubiquitous language will also change over
    time, rendering old concepts obsolete. The general principle is to maintain backward
    compatibility with consumers for as long as possible. But this does come at the
    cost of having to maintain old and new concepts together—leading to a situation
    where it can become hard to tell what is relevant versus what is not. Using an
    explicit versioning strategy can help to manage this complexity up to an extent—where
    newer versions might be able to break backward compatibility with older ones.
    However, it is also not feasible to continue supporting a large number of incompatible
    versions indefinitely. Hence, it is important to make sure that the versioning
    strategy makes deprecation and retirement agreements explicit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求的演变，将需要增强接口以反映这些变化。这意味着我们的通用语言也将随着时间的推移而改变，使旧概念变得过时。一般原则是尽可能长时间地保持与消费者的向后兼容性。但这确实意味着必须同时维护旧的和新的概念——导致难以区分哪些是相关的，哪些不是。使用显式的版本控制策略可以在一定程度上帮助管理这种复杂性——新版本可能能够与旧版本断开向后兼容。然而，继续无限期地支持大量不兼容的版本也是不可行的。因此，确保版本控制策略明确地制定弃用和退役协议是很重要的。
- en: REST APIs
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API
- en: 'We recognize that there are several options when exposing web-based APIs, and
    claims of using a REST approach seem quite common these days. REST was coined
    by Roy Fielding as part of his doctoral dissertation. The idea of what constitutes
    REST has been a matter of debate and, arguably, remains ambiguous even today.
    Leonard Richardson introduced the notion of a maturity model for HTTP-based REST
    APIs that somewhat helped provide some clarity. The model describes broad conformance
    to REST in four levels, with each level being more mature than the preceding one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到在公开基于Web的API时，有几种选择，而声称使用REST方法似乎在当今相当普遍。REST是由Roy Fielding在其博士论文中提出的。关于构成REST的想法一直是争论的焦点，并且可以说，即使在今天，它仍然模糊不清。Leonard
    Richardson引入了基于HTTP的REST API成熟度模型的概念，这在一定程度上有助于提供一些清晰性。该模型描述了REST的广泛一致性，分为四个级别，每个级别都比前一个级别更成熟：
- en: '0. **Adhoc**: Where APIs are designed without the use of any perceptible structure.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 0. **Adhoc**：API设计时没有使用任何可感知的结构。
- en: '**Resources**: Where APIs are designed around a *thing* that makes sense on
    its own (usually, this is a noun). Here, a very small subset of verbs (either
    a GET or a POST) could be used to model all operations.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Resources**：API设计围绕一个**事物**进行，这个事物本身就有意义（通常是一个名词）。在这里，可以使用非常小的动词子集（要么是GET，要么是POST）来模拟所有操作。'
- en: '**HTTP verbs**: Where APIs are designed by making use of a standard set of
    operations that can be performed on a resource (for example, GET for reads, POST
    for creates, PUT for updates, DELETE for deletes, and more).'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP动词**：API设计时利用一组标准操作来对资源进行操作（例如，GET用于读取，POST用于创建，PUT用于更新，DELETE用于删除等）。'
- en: '**HATEOAS**: Where APIs include hypermedia links to help clients discover our
    API in a self-service manner.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HATEOAS**：API包括超媒体链接，以帮助客户端以自助方式发现我们的API。'
- en: 'In our experience, most web service-based solutions that claim to be RESTful
    seem to stop at level 2\. Roy Fielding, the inventor of REST, seems to claim that
    *REST APIs must be hypertext-driven* ([https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)).
    In our opinion, the use of hypertext controls in APIs allows them to become self-documenting
    and, thereby, promotes the use of the ubiquitous language more explicitly. More
    importantly, it also indicates what operations are applicable for a given resource
    at that time in its life cycle. For example, let’s look at a sample response where
    all pending LC applications have been listed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，大多数声称是RESTful的基于Web服务的解决方案似乎只停留在第2级。REST的发明者Roy Fielding似乎声称**REST API必须是超文本驱动的**([https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))。在我们看来，在API中使用超文本控制可以使它们变得自我文档化，从而更明确地促进通用语言的运用。更重要的是，它还指出了在资源生命周期中，在特定时刻可以应用哪些操作。例如，让我们看看一个示例响应，其中列出了所有待处理的LC申请：
- en: '![](img/10-4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10-4.jpg)'
- en: In the preceding example, there are two `lc-applications` listed. Based on the
    current status of the LC, the links provide a means to act on the LC appropriately.
    In addition to the *self* link, the first LC application shows a submit link denoting
    that it can be submitted, whereas the second application shows the approve and
    reject links, but not a submit link. Presumably, this is because it has already
    been submitted. Also, notice how the response does not need to include a status
    attribute so that they can use this to deduce which operations are relevant for
    the LC application at that time (this is an example of the *tell**,* *don’t ask*
    principle, [https://martinfowler.com/bliki/TellDontAsk.html](https://martinfowler.com/bliki/TellDontAsk.html)).
    While this might be a subtle nuance, we felt that it is valuable to point out
    in the context of our DDD journey.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，列出了两个`lc-applications`。根据LC的当前状态，链接提供了一种适当处理LC的手段。除了**self**链接外，第一个LC申请显示了提交链接，表示它可以被提交，而第二个申请显示了批准和拒绝链接，但没有提交链接。这可能是由于它已经被提交。此外，请注意，响应不需要包含状态属性，这样它们就可以使用这个属性来推断在当前时刻与LC申请相关的操作（这是一个**告诉**，**不要询问**原则的例子，[https://martinfowler.com/bliki/TellDontAsk.html](https://martinfowler.com/bliki/TellDontAsk.html))。虽然这可能是一个细微的差别，但我们认为在DDD旅程的背景下指出这一点是有价值的。
- en: So, we have looked at a few considerations when moving from an in-process API
    to an out-of-process API. There are quite a few other considerations, specifically
    pertaining to non-functional requirements (such as performance, resilience, error
    handling, and more). We will look at these in more detail in [*Chapter 11*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Decomposing into Finer-Grained Components*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了从进程内API迁移到进程外API时的一些考虑因素。还有许多其他考虑因素，特别是关于非功能性需求（如性能、弹性、错误处理等）。我们将在[*第11章*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164)“分解为更细粒度的组件”中更详细地探讨这些内容。
- en: Now that we have a handle on how we can work with APIs that interact with the
    frontend, let’s look at how we can handle event publication and consumption *remotely*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何与与前端交互的API一起工作，让我们看看我们如何远程处理事件发布和消费*。
- en: Changes for event interactions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件交互的更改
- en: Currently, our application publishes and consumes domain events over an in-process
    bus that the **Axon** framework makes available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序通过**Axon**框架提供的进程内总线发布和消费领域事件。
- en: 'We publish events when processing commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理命令时发布事件：
- en: '![](img/ch10-5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch10-5.jpg)'
- en: 'Publishing an event when processing a command successfully and consume events
    to expose query APIs:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功处理命令时发布事件，并消费事件以公开查询API：
- en: '![](img/ch10-6.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch10-6.jpg)'
- en: We subscribe to an event using the Axon-provided `@EventHandler` annotation.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Axon提供的`@EventHandler`注解订阅事件。
- en: 'In order to process events remotely, we need to introduce an explicit infrastructure
    component in the form of an event bus. Common options include message brokers
    such as **ActiveMQ** and **RabbitMQ**, or a distributed event streaming platform,
    such as **Apache Kafka**. Application components can continue to publish and consume
    events as before—only, now, they will happen using an out-of-process style of
    invocation. Logically, this now causes our application to look similar to the
    following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了远程处理事件，我们需要引入一个显式的基础设施组件，即事件总线。常见选项包括消息代理，如**ActiveMQ**和**RabbitMQ**，或者分布式事件流平台，如**Apache
    Kafka**。应用程序组件可以继续像以前一样发布和消费事件——只是现在，它们将使用进程外调用风格。从逻辑上讲，这使我们的应用程序看起来类似于以下内容：
- en: '![Figure 10.3 – Introducing an out-of-process event bus'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 引入进程外事件总线'
- en: '](img/B16716_Figure_10.3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.3.jpg)'
- en: Figure 10.3 – Introducing an out-of-process event bus
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 引入进程外事件总线
- en: When working with events within the confines of a single process, assuming synchronous
    processing (event publishing and consumption on the same thread), we do not encounter
    a majority of problems that only become apparent when the publisher and the consumer
    are distributed across multiple processes. Let’s examine some of these in more
    detail next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单个进程的范围内处理事件时，假设同步处理（在相同线程上事件发布和消费），我们不会遇到当发布者和消费者分布在多个进程之间时才显现的大多数问题。让我们更详细地检查其中的一些。
- en: Atomicity guarantees
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子性保证
- en: 'Previously, when the publisher processed a command by publishing an event and
    the consumer(s) handled it, transaction processing occurred as a single atomic
    unit, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前，当发布者通过发布事件处理命令，并且消费者处理它时，事务处理作为一个单一的原子单元发生，如下所示：
- en: '![Figure 10.4 – ACID transaction processing within the monolith'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 单体中的ACID事务处理'
- en: '](img/B16716_Figure_10.4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.4.jpg)'
- en: Figure 10.4 – ACID transaction processing within the monolith
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 单体中的ACID事务处理
- en: Notice how all the highlighted operations in the preceding diagram happen as
    part of a single database transaction. This allows the system to be strongly consistent
    from end to end. When the event bus is distributed to work within its own process,
    atomicity cannot be guaranteed as it was previously. Each of the preceding numbered
    operations works as an independent transaction. This means that they can fail
    independently, which can lead to data inconsistencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面图中所有高亮显示的操作都是作为单个数据库事务的一部分发生的。这使系统能够从端到端保持强一致性。当事件总线分布到其自身进程内工作时，原子性无法得到保证，就像之前那样。前面编号的每个操作都作为一个独立的交易进行。这意味着它们可以独立失败，这可能导致数据不一致。
- en: 'To solve this problem, let’s look at each step of the process in more detail,
    starting with command processing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们更详细地查看处理过程的每个步骤，从命令处理开始：
- en: '![Figure 10.5 – Command processing transaction semantics'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 命令处理事务语义'
- en: '](img/B16716_Figure_10.5.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_10.5.jpg)'
- en: Figure 10.5 – Command processing transaction semantics
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 命令处理事务语义
- en: 'Let’s consider a situation where we save to the database but fail to publish
    the event. Consumers will remain oblivious of the event that is occurring and
    become inconsistent. On the flip side, if we publish the event but fail to save
    it in the database, the command processing side itself becomes inconsistent—not
    to mention that the query side now thinks that a domain event occurred, when,
    in fact, it did not. Again, this leads to inconsistency. This **dual-write** problem
    is fairly common in distributed event-driven applications. If command processing
    has to work in a foolproof manner, saving to the database and publishing to the
    event bus have to happen atomically—both operations should succeed or fail in
    unison. Here are a few solutions that we have used to solve this issue (in increasing
    order of complexity):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一种情况：我们成功保存到数据库，但未能发布事件。消费者将不会意识到正在发生的事件，从而导致不一致。另一方面，如果我们发布了事件，但未能将其保存到数据库中，那么命令处理本身就会变得不一致——更不用说查询方现在认为发生了领域事件，而实际上并没有。再次，这导致了不一致。这种**双重写入**问题在分布式事件驱动应用程序中相当常见。如果命令处理必须以万无一失的方式进行，那么保存到数据库和发布到事件总线必须原子性地发生——这两个操作应该同时成功或失败。以下是我们用来解决这个问题的几个解决方案（按复杂度递增）：
- en: '**Do nothing**: Arguably, this approach is not really a solution; however,
    it might be the only placeholder until a more robust solution is in place. While
    it might be puzzling to see this being listed as an option, we have seen several
    occasions where this is indeed how event-driven systems have been implemented.
    We leave this here as a word of caution so that teams become cognizant of the
    pitfalls.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不采取行动**：可以说，这种方法实际上并不是一个解决方案；然而，它可能是唯一的一个占位符，直到有更稳健的解决方案。虽然看到这个选项可能会让人困惑，但我们确实看到过事件驱动系统就是这样实现的。我们将其留在这里作为警告，以便团队意识到潜在的风险。'
- en: '**Transaction synchronization**: In this approach, multiple resource managers
    are synchronized in a way that a failure in any one system will trigger a cleanup
    in the others where the transaction has already been committed. It is pertinent
    to note that this might not be foolproof, as it might lead to cascading failures.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务同步**：在这种方法中，多个资源管理器以这种方式同步，即任何一个系统的失败都会触发其他系统中已提交事务的清理。值得注意的是，这可能不是万无一失的，因为它可能导致级联故障。'
- en: Information
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The Spring Framework provides support for this style of behavior through the
    `TransactionSynchronization` interface and the now deprecated `ChainedTransactionManager`
    interface. Please refer to the framework documentation for further details. Needless
    to say, this interface should not be used without careful consideration of the
    business requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架通过`TransactionSynchronization`接口和已弃用的`ChainedTransactionManager`接口提供了对这种行为风格的支持。请参阅框架文档以获取更多详细信息。不言而喻，在没有仔细考虑业务需求的情况下不应使用此接口。
- en: '**Distributed transactions**: Another approach is to make use of distributed
    transactions. A distributed transaction is a set of operations on data that is
    performed across two or more resource managers (usually, these are databases)
    using techniques such as **two-phase commit** ([https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html](https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html)).
    Typically, this functionality is implemented using pessimistic locking on the
    underlying resource managers (databases) and could present scaling challenges
    in highly concurrent environments.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：另一种方法是利用分布式事务。分布式事务是在两个或更多资源管理器（通常，这些是数据库）上执行的一系列数据操作，使用诸如**两阶段提交**（[https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html](https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html)）等技术。通常，这种功能是通过在底层资源管理器（数据库）上使用悲观锁来实现的，并且在高度并发的环境中可能会带来扩展性的挑战。'
- en: '**Transactional outbox**: None of the preceding methods are completely foolproof
    in the sense that there still exists a window of opportunity where the database
    and the event bus can become inconsistent (this is true even with two-phase commits).
    One way to circumvent this problem is by completely eliminating the dual-write
    problem.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务性输出箱**：前面提到的方法都不是完全万无一失的，因为在数据库和事件总线之间仍然存在一个机会窗口，它们可能会变得不一致（即使在两阶段提交的情况下也是如此）。绕过这个问题的方法之一是完全消除双重写入问题。'
- en: 'In this solution, the command processor writes to its database and the intended
    event to an *outbox* table in a local transaction. A separate poller component
    polls the outbox table and writes to the event bus. Polling can be computationally
    intensive and could lead back to the dual write problem again because the poller
    has to keep track of the last written event. This could be avoided by making event
    processing idempotent on the consumer so that processing duplicate events do not
    cause issues, especially in extremely high concurrency and volume scenarios. Another
    way to mitigate this issue is to use a **Change Data Capture** (**CDC**) tool
    (such as **Debezium**, [https://debezium.io/](https://debezium.io/)) and Oracle
    LogMiner ([https://en.wikipedia.org/wiki/OracleLogMiner](https://en.wikipedia.org/wiki/OracleLogMiner)).
    Most modern databases ship with tools to make this easier, and they may be worth
    exploring. One way to implement this is to use the **transactional outbox pattern**,
    as shown in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，命令处理器在本地事务中将其数据库写入，并将预期的事件写入一个*输出队列*表。一个单独的轮询组件轮询输出队列表并将写入事件总线。轮询可能计算密集，并可能导致再次出现双重写入问题，因为轮询器必须跟踪最后写入的事件。这可以通过在消费者端使事件处理幂等来避免，这样处理重复事件就不会引起问题，尤其是在极端高并发和大量场景中。另一种缓解此问题的方法是使用**变更数据捕获**（**CDC**）工具（如**Debezium**，[https://debezium.io/](https://debezium.io/))和Oracle
    LogMiner ([https://en.wikipedia.org/wiki/OracleLogMiner](https://en.wikipedia.org/wiki/OracleLogMiner))。大多数现代数据库都附带了一些工具来简化这一过程，它们可能值得探索。一种实现方式是使用**事务性输出队列模式**，如下面的图所示：
- en: '![Figure 10.6 – The transactional outbox pattern'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 – 事务性输出队列模式'
- en: '](img/B16716_Figure_10.6.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_10.6.jpg](img/B16716_Figure_10.6.jpg)'
- en: Figure 10.6 – The transactional outbox pattern
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 事务性输出队列模式
- en: The transactional outbox pattern is a robust approach for dealing with the dual-write
    problem. However, it also introduces a non-trivial amount of operational complexity.
    In one of our previous implementations, we made use of transactional synchronization
    to ensure that we never missed writes to the database. Additionally, we ensured
    that the event bus was highly available through redundancy on both the compute
    and storage tiers and, most importantly, by avoiding *any* business logic on the
    event bus.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 事务性输出队列模式是处理双重写入问题的稳健方法。然而，它也引入了相当多的操作复杂性。在我们之前的一个实现中，我们利用事务同步来确保我们永远不会错过对数据库的写入。此外，我们还确保事件总线通过计算和存储层的冗余以及最重要的是，通过避免在事件总线上的任何业务逻辑来保持高可用性。
- en: Delivery guarantees
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投递保证
- en: Previously, because all of our components worked within a single process, the
    delivery of events to the consumers was guaranteed at least as long as the process
    stayed alive. Even if event processing failed on the consumer side, it was fairly
    straightforward to detect the failure because exception handling was fairly straightforward.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，由于所有组件都在单个进程中工作，只要进程保持活跃，向消费者投递事件就有保证。即使事件处理在消费者端失败，检测失败也相对简单，因为异常处理相对直接。
- en: 'Furthermore, rollbacks were straightforward because the production and consumption
    of events happened as part of a single database transaction. With the LC processing
    application now becoming a remote component, event delivery becomes a lot more
    challenging. When it comes to message delivery semantics, there are three basic
    categories:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，回滚也很简单，因为事件的生产和消费是作为单个数据库事务的一部分发生的。随着LC处理应用现在成为一个远程组件，事件投递变得更加具有挑战性。当涉及到消息投递语义时，有三个基本类别：
- en: '**At-most-once delivery**: This means that each message might be delivered
    once or not at all. Arguably, this style of delivery is the easiest to implement
    because the producer creates messages in a fire-and-forget fashion. This might
    be okay in environments where the loss of some messages is tolerated. For example,
    data from click-stream analytics or logging can fall into this category.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最多一次投递**：这意味着每条消息可能只投递一次，或者根本不投递。可以说，这种投递方式最容易实现，因为生产者以“发射并遗忘”的方式创建消息。在可以容忍某些消息丢失的环境中，这可能没问题。例如，点击流分析或日志数据可能属于这一类。'
- en: '**At-least-once delivery**: This means that each message will be delivered
    more than once with no messages being lost. Delivery of undelivered messages is
    retried—potentially infinitely. This style of delivery might be required when
    it is not feasible to lose messages, but where it would be tolerable to process
    the same message more than once. For example, analytical environments can tolerate
    duplicate message delivery or have duplicate detection logic to discard already
    processed messages.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少一次投递**：这意味着每条消息将被投递多次，且不会丢失任何消息。未投递的消息会重试投递——可能无限次。这种投递方式可能在无法容忍丢失消息的情况下是必要的，但可以容忍处理相同消息多次。例如，分析环境可以容忍重复的消息投递或具有重复检测逻辑以丢弃已处理的消息。'
- en: '**Exactly-once delivery**: This means that each message is delivered exactly
    once without either being lost or duplicated. This style of message delivery is
    extremely hard to implement, and a lot of solutions could approach exactly-once
    semantics with some implementation help from the consumers where duplicate messages
    are detected and discarded with the producer sticking to at-least-once delivery
    semantics.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恰好一次投递**：这意味着每条消息恰好投递一次，既不会丢失也不会重复。这种消息投递方式非常难以实现，许多解决方案可以通过从消费者那里获得一些帮助来实现“恰好一次”语义，即检测并丢弃重复消息，而生产者坚持至少一次投递语义。'
- en: For domain event processing, most teams will, of course, prefer to have exactly-once
    processing semantics, given that they would not want to lose any of these events.
    However, given the practical difficulties guaranteeing *exactly-once* semantics,
    it is not unusual to approach exactly-once processing by having the consumer process
    events in an idempotent manner or designing events to make it easier to detect
    errors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于领域事件处理，当然，大多数团队都会更喜欢具有“恰好一次”处理语义，因为他们不希望丢失任何这些事件。然而，鉴于保证“恰好一次”语义的实际困难，通过让消费者以幂等的方式处理事件或设计事件以使其更容易检测错误，以实现“恰好一次”处理并不罕见。
- en: For example, consider a `MonetaryAmountWithdrawn` event, which includes `accountId`
    and `withdrawalAmount`. This event could carry an additional `currentBalance`
    attribute so that the consumer will know if they are out of sync with the producer
    when processing the withdrawal. Another way to do this is for the consumer to
    keep track of the last *n* events processed. When processing an event, the consumer
    can check whether this event has already been processed. If so, they can detect
    it as a duplicate and simply discard it. Again, all the preceding methods add
    a level of complexity to the overall system. Despite all these safeguards, consumers
    could still find themselves out of sync with the system of record (the command
    side that produces the event). If so, as a last resort, it might be necessary
    to use partial or full event replays ([https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays](https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays)),
    which was discussed in [*Chapter 7*](B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112),
    *Implementing Queries*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个`MonetaryAmountWithdrawn`事件，它包括`accountId`和`withdrawalAmount`。此事件可以携带一个额外的`currentBalance`属性，以便消费者在处理提款时知道他们是否与生产者不同步。另一种方法是消费者跟踪最后处理的*n*个事件。在处理事件时，消费者可以检查此事件是否已被处理。如果是，他们可以将其检测为重复并简单地丢弃它。再次强调，所有上述方法都会给整个系统增加一层复杂性。尽管有所有这些安全措施，消费者仍然可能发现自己与记录系统（产生事件的命令端）不同步。如果是这样，作为最后的手段，可能有必要使用部分或全部事件重放（[https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays](https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays)），这在[*第7章*](B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112)
    *实现查询*中已有讨论。
- en: Ordering guarantees
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序保证
- en: In an event-driven system such as the one we are building, it is desirable for
    consumers to receive events in a deterministic order. Not knowing the order or
    receiving it in the wrong order could result in inaccurate outcomes. Let’s consider
    the example of `LCApplicationAddressChangedEvent` occurring twice in *quick succession*.
    If these changes are processed in the wrong order, we could end up displaying
    the wrong address as their current one. This does not necessarily mean that events
    need to be ordered for all use cases. Let’s consider another example where we
    receive `LCApplicationSubmittedEvent` more than once erroneously when it is not
    possible to submit a given LC application more than once. All such notifications
    after the first can be ignored.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在构建的事件驱动系统中，消费者以确定性的顺序接收事件是理想的。不知道顺序或以错误的顺序接收可能会导致结果不准确。让我们考虑一个例子，即`LCApplicationAddressChangedEvent`在*很短的时间内*发生两次。如果这些更改以错误的顺序处理，我们可能会显示错误的地址作为它们的当前地址。这并不一定意味着所有用例都需要对事件进行排序。让我们考虑另一个例子，即当不可能提交给定的LC应用程序超过一次时，我们错误地多次收到`LCApplicationSubmittedEvent`。第一次之后的所有此类通知都可以忽略。
- en: 'As a consumer, it is important to know whether events will be ordered or not
    so that we can make design considerations for out-of-order events. One default
    might be to accommodate for out-of-order events as a default. In our experience,
    this does tend to make the resulting design more complicated, especially in cases
    where the order does matter. Here, we will discuss three-event ordering strategies
    and their implications for both the producer and the consumer:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为消费者，了解事件是否有序是很重要的，这样我们才能为乱序事件做出设计考虑。一个默认的做法可能是将乱序事件作为默认选项。根据我们的经验，这往往会使最终的设计更加复杂，尤其是在顺序很重要的情况下。在这里，我们将讨论三种事件排序策略及其对生产者和消费者的含义：
- en: '![](img/B16716_10_Table_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 持久性与持久性](img/B16716_10_Table_01.jpg)'
- en: In most applications, per aggregate ordering might be a good place to start
    and cater to most business scenarios.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，按聚合排序可能是一个好的起点，并满足大多数业务场景。
- en: Durability and persistence guarantees
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久性和持久性保证
- en: 'When an event is published to the event bus, the happy path scenario is that
    the intended consumer(s) can process it successfully. However, there are scenarios
    that can cause message processing to be impacted adversely. Let’s examine each
    of these scenarios:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发布到事件总线时，理想的情况是目标消费者可以成功处理它。然而，有一些场景可能会对消息处理产生不利影响。让我们检查这些场景中的每一个：
- en: '**Slow consumer**: The consumer is unable to process events as fast as the
    producers are publishing them.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**慢速消费者**：消费者无法像生产者发布它们那样快速处理事件。'
- en: '**Offline consumer**: The consumer is unavailable (down) at the time of the
    events being published.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线消费者**：在事件发布时，消费者不可用（已关闭）。'
- en: '**Failing consumer**: The consumer is experiencing errors when trying to process
    events.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败的消费者**：当消费者尝试处理事件时，会经历错误。'
- en: 'In each of these cases, we could develop a backlog of unprocessed events. Because
    these are domain events, we need to prevent the loss of these events until the
    consumer has been able to process them successfully. There are two communication
    characteristics that need to be true for this to work successfully:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况中，我们可能会积累未处理的事件积压。因为这些是领域事件，我们需要防止在消费者成功处理之前丢失这些事件。为了成功工作，需要满足以下两个通信特性：
- en: '![Figure 10.7 – Persistence versus durability'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 持久性与持久性](img/B16716_Figure_10.7.jpg)'
- en: '](img/B16716_Figure_10.7.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 持久性与持久性](img/B16716_Figure_10.7.jpg)'
- en: Figure 10.7 – Persistence versus durability
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 持久性与持久性
- en: '**Persistence**: This is the communication style between the **Producer** instance
    and the **Event Bus** instance.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这是**生产者**实例和**事件总线**实例之间的通信风格。'
- en: '**Durability**: This is the communication style between the **Event Bus** instance
    and the **Consumer** instance.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这是**事件总线**实例和**消费者**实例之间的通信风格。'
- en: Firstly, messages need to be persistent (that is, stored on disk), and secondly,
    the message subscription (the relationship between the consumer and the event
    bus) needs to be durable (persist across **Event Bus** restarts). It is important
    to note that events have to be made persistent by the producer for them to be
    consumed durably by the consumer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，消息需要是持久的（即存储在磁盘上），其次，消息订阅（消费者与事件总线之间的关系）需要是持久的（在**事件总线**重启时保持持久）。需要注意的是，事件必须由生产者持久化，以便消费者能够持久地消费它们。
- en: Processing guarantees
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理保证
- en: 'When an event is processed by the query side component, as shown here, the
    following steps occur:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询端组件处理事件时，如上图所示，以下步骤会发生：
- en: '![Figure 10.8 – Event processing failure scenarios'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – 事件处理失败场景'
- en: '](img/B16716_Figure_10.8.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.8.jpg)'
- en: Figure 10.8 – Event processing failure scenarios
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 事件处理失败场景
- en: The event is consumed (either through a push or a pull) from the **Event Bus**
    instance.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件从**事件总线**实例中被消费（无论是通过推送还是拉取）。
- en: Transformation logic is applied to the payload of the event.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变换逻辑应用于事件的负载。
- en: The transformed payload is saved in the query side store.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换后的负载保存在查询端存储中。
- en: 'Each of these steps can encounter failures. Irrespective of the cause of failure,
    the event should be durable (as discussed earlier) so that it can be processed
    later when the issue is fixed. These errors can be broadly segregated into four
    categories:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些步骤都可能遇到失败。无论失败的原因是什么，事件应该是持久的（如前所述），以便在问题解决后可以稍后处理。这些错误可以大致分为四个类别：
- en: '![](img/B16716_10_Table_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16716_10_Table_02.jpg)'
- en: 'Now we have looked at the changes that we need to make because of the introduction
    of an out-of-process event bus. Having done this allows us to actually extract
    the **LC Application Processing** component into its own independently deployable
    unit, which will look similar to the following diagram:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了由于引入进程外事件总线而需要做出的变更。完成这些变更后，我们可以实际上将**LC应用处理**组件提取成其自己的独立部署单元，这将在以下图中类似：
- en: '![Figure 10.9 – LC Application Processing deployed independently'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 – 独立部署的LC应用处理'
- en: '](img/B16716_Figure_10.9.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.9.jpg)'
- en: Figure 10.9 – LC Application Processing deployed independently
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 独立部署的LC应用处理
- en: However, we are continuing to use a common datastore for the **LC Application
    Processing** component. Let’s look at what is involved in segregating this into
    its own store.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍在使用公共数据存储来为**LC应用处理**组件服务。让我们看看将此隔离到其自己的存储中涉及的内容。
- en: Changes in database interactions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库交互的变更
- en: While we have extracted our application component into its own unit, we continue
    to be coupled at the database tier. If we are to achieve true independence from
    the monolith, we need to break this database dependency. Let’s look at the changes
    involved in making this happen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经将我们的应用程序组件提取到其自己的单元中，但我们仍然在数据库层耦合。如果我们想要真正从单体中实现独立，我们需要打破这种数据库依赖。让我们看看实现这一目标所需的变化。
- en: Data migration
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据迁移
- en: 'As a first step to start using a database of our own, we will need to start
    migrating data from the command side event store and the query store(s), as shown
    here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开始使用我们自己的数据库的第一步，我们需要开始从命令端事件存储和查询存储（如上图所示）迁移数据：
- en: '![Figure 10.10 – Data migration'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – 数据迁移'
- en: '](img/B16716_Figure_10.10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.10.jpg)'
- en: Figure 10.10 – Data migration
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 数据迁移
- en: 'In our case, we have the command side event store and the query store(s) that
    will need to be migrated out. To minimize effort from the outset, it might be
    prudent to do a simple homogenous migration by keeping the source and target database
    technologies identical. In advance of the cut-over, among other things, it will
    be essential to do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们有一个需要迁移出去的命令端事件存储和查询存储（s）。为了从一开始就最小化工作量，可能明智的做法是进行简单的同构迁移，保持源和目标数据库技术相同。在切换之前，其他事项中，以下事项将是至关重要的：
- en: '**Profile** to make sure that latency numbers are within tolerable limits'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**以确保延迟数字在可容忍的范围内'
- en: '**Test** to make sure that the data has migrated correctly'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**以确保数据已正确迁移'
- en: '**Minimize downtime** by understanding and agreeing on **SLAs**, such as the
    **Recovery Time Objective** (**RTO**) and **Recovery Point Objective** (**RPO**)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过理解和同意**服务等级协议**（SLA），如**恢复时间目标**（RTO）和**恢复点目标**（RPO）来**最小化停机时间**
- en: Cut-over
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换
- en: 'If we have made it so far, we are ready to complete the migration of the LC
    Application Processing from the rest of the monolith. The logical architecture
    of our solution now looks similar to the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经走到这一步，我们就准备好完成LC应用处理从单体剩余部分的迁移。我们解决方案的逻辑架构现在看起来类似于以下图：
- en: '![Figure 10.11 – Independent data persistence'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 独立数据持久化'
- en: '](img/B16716_Figure_10.11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_10.11.jpg)'
- en: Figure 10.11 – Independent data persistence
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 独立数据持久化
- en: With this step, we have successfully completed the migration of our first component.
    There is still quite a lot of work to do. Arguably, our component was already
    well-structured and loosely coupled with the rest of the application. Despite
    that, moving from an in-process model to an out-of-process model between bounded
    contexts is quite an involved process—as should be evident from the work we have
    done in this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一步，我们已经成功完成了第一个组件的迁移。还有很多工作要做。可以说，我们的组件已经结构良好，并且与应用程序的其他部分松散耦合。尽管如此，从进程内模型到有界上下文之间的进程外模型转换是一个相当复杂的过程——这一点应该从我们本章所做的工作中显而易见。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how we can extract a bounded context from an existing
    monolith, although you could argue that this was from a reasonably well-structured
    one. We looked at the challenges involved in decomposing the monolith from various
    interaction points such as the frontend, event exchanges, and the database. You
    should have an understanding of what it takes to go from an in-process event-driven
    application to an out-of-process one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从一个现有的单一应用程序中提取一个有界上下文，尽管你可以争论这来自于一个结构相当合理的单一应用程序。我们探讨了从前端、事件交换和数据库等不同交互点分解单一应用程序所涉及到的挑战。你应该了解从进程内事件驱动应用程序到进程外应用程序需要具备的条件。
- en: In the next chapter, we will look at how to extract pieces out of a monolith
    that might not be as well-structured, possibly very close to the dreaded big ball
    of mud.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何从可能结构不佳的单一应用程序中提取部分内容，可能非常接近令人讨厌的大泥球。
- en: References
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For more information, please refer to the following resources:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅以下资源：
- en: '[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
- en: '[https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html](https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html](https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html)'
- en: '[https://debezium.io/](https://debezium.io/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://debezium.io/](https://debezium.io/)'
