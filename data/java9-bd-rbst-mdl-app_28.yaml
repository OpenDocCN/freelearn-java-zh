- en: Serverless Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器Java
- en: In recent years, the concept of microservices, which we've already looked at,
    has swept across the industry, quickly displacing the battle-tested application
    server with something smaller and leaner. Right on the heels of microservices
    comes a new concept--Functions as a Service, more commonly called **serverless**.
    In this chapter, you'll learn more about this new deployment model and build an
    application to demonstrate how to use it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务概念已经席卷整个行业，迅速取代了经过实战考验的应用程序服务器，取而代之的是更小、更精简的解决方案。紧随微服务之后的是一个新的概念——函数即服务，更常见的是称为**无服务器**。在本章中，你将了解更多关于这种新的部署模型，并构建一个应用程序来演示如何使用它。
- en: 'The application will be a simple notification system using the following technologies:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将是一个简单的通知系统，使用以下技术：
- en: Amazon Web Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务
- en: Amazon Lambda
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊Lambda
- en: Amazon **Identity and Access Management** (**IAM**)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**身份和访问管理**（**IAM**）
- en: Amazon **Simple Notification System** (**SNS**)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**简单通知系统**（**SNS**）
- en: Amazon **Simple Email System** (**SES**)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**简单电子邮件系统**（**SES**）
- en: Amazon DynamoDB
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊DynamoDB
- en: JavaFX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: The options offered by cloud providers can be quite vast, and Amazon Web Services
    is no exception. In this chapter, we will attempt to use just enough of what AWS
    has to offer to help us build a compelling application as we wade into cloud-native
    application development.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商提供的选项可能非常广泛，亚马逊网络服务也不例外。在本章中，我们将尝试使用AWS提供的一些基本服务来帮助我们构建一个引人注目的应用程序，同时我们涉足云原生应用程序开发。
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'Before we get to our application, we should spend some time getting a better
    understanding of the term **Function as a Service** (**FaaS**). The term itself
    is a continuation of the **blank** as a service trend we''ve seen for a few years
    now. There is a host of such terms and offerings, but the big three are **Infrastructure
    as a Service** (**IaaS**), **Platform as a Service** (**PaaS**), and **Software
    as a Service** (**SaaS**). Oftentimes, these three build on each other as seen
    in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入应用程序之前，我们应该花些时间更好地理解术语**函数即服务**（**FaaS**）。这个术语本身是我们已经看到几年的“即服务”趋势的延续。有一系列这样的术语和产品，但最大的三个是**基础设施即服务**（**IaaS**）、**平台即服务**（**PaaS**）和**软件即服务**（**SaaS**）。通常，这三个是相互依赖的，如下面的图所示：
- en: '![](img/7dafe91e-0a22-4aba-a7da-1d12003dd8f9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7dafe91e-0a22-4aba-a7da-1d12003dd8f9.png)'
- en: The lowest level of the cloud computing offerings, Infrastructure as a Service
    providers, offers infrastructure-related assets **in the cloud**. Typically, this
    can be as simple as file storage, but usually means virtual machines. By using
    an Infrastructure as a Service provider, clients need not worry about buying,
    maintaining, or replacing hardware, as that is handled by the provider. Clients
    are billed, instead, only on resources used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算服务最低级别的基础设施即服务提供商，提供**云**中的基础设施相关资产。通常，这可以简单到文件存储，但通常意味着虚拟机。通过使用基础设施即服务提供商，客户无需担心购买、维护或更换硬件，因为这由提供商处理。相反，客户只需根据使用的资源付费。
- en: Moving up the stack, Platform as a Service providers offer cloud-hosted application
    execution environments. This may include things such as an application server,
    a database server, a web server, and so on. The details of the physical environment
    are abstracted away, with customers specifying storage and RAM requirements. Some
    providers also allow the customer to choose the operating system, as this can
    have implications on the application stack, support tools, and more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈中向上移动，平台即服务提供商提供云托管的应用程序执行环境。这可能包括应用程序服务器、数据库服务器、Web服务器等。物理环境的细节被抽象化，客户指定存储和RAM需求。一些提供商还允许客户选择操作系统，因为这可能会影响应用程序堆栈、支持工具等。
- en: Software as a Service is a higher-level abstraction that doesn't focus on the
    hardware at all but, instead, offers hosted software that customers subscribe
    to, typically per user, and typically on a monthly or yearly basis. This is often
    seen in complicated business software, such as financial systems or human resource
    applications, but it is also seen with simpler systems, such as blogging software.
    The user simply subscribes and uses the software, leaving the installation and
    maintenance, including upgrades, to the provider. While this can reduce flexibility
    for the user (for example, it is often not possible to customize the software),
    it also reduces operational costs by pushing maintenance costs to the provider
    as well as guaranteeing, in most cases, access to the latest version of the software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件即服务是一种更高层次的抽象，它根本不关注硬件，而是提供客户订阅的托管软件，通常是按用户订阅，通常是按月或按年订阅。这在复杂的商业软件中很常见，如财务系统或人力资源应用，但也见于更简单的系统，如博客软件。用户只需订阅并使用软件，将安装和维护（包括升级）留给提供商。虽然这可能会减少用户的灵活性（例如，通常无法自定义软件），但它也将维护成本推给了提供商，并在大多数情况下保证了访问软件的最新版本。
- en: There are several other variations on this type of service, such as **Mobile
    Backend as a Service** (**MBaas**) and **Database as a Service** (**DBaaS**).
    As the market continues to gain confidence in cloud computing, and as the internet
    speeds up while the prices go down, we are likely to see more and more of these
    types of systems developed, which brings us to our topic in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这类服务还有几种其他变体，例如**移动后端即服务**（**MBaas**）和**数据库即服务**（**DBaaS**）。随着市场对云计算的信心不断增强，以及互联网速度加快而价格下降，我们可能会看到越来越多这类系统的开发，这把我们带到了本章的主题。
- en: Function as a Service, or **serverless** computing, is the deployment of a small
    piece of code, very literally a function, that can be called from other applications,
    usually via some sort of trigger. Use cases include things such as image conversion,
    log analysis, and, as we will build in this chapter, notification systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数即服务，或称为**无服务器计算**，是将一小段代码（非常直接地说，就是一个函数）部署到其他应用程序中，通常通过某种触发器来调用。用例包括图像转换、日志分析，以及我们将在本章中构建的通知系统。
- en: Despite what the name **serverless** implies, there is actually a server involved,
    which only stands to reason; however, you, as an application developer, need not
    think about the server too deeply. In fact, as we'll see in this chapter, the
    only thing we need to worry about is how much memory our function will need. Everything
    else about the server is completely handled by the Function as a Service provider--the
    operating system, storage, networking, even starting and stopping the virtual
    machine are all handled for us by the provider.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无服务器这个名字暗示了没有服务器，但实际上确实涉及到了服务器，这是合情合理的；然而，作为应用开发者，你不需要深入思考服务器。实际上，正如我们将在本章中看到的，我们唯一需要担心的是我们的函数需要多少内存。关于服务器的其他一切都将完全由函数即服务提供商处理——操作系统、存储、网络，甚至虚拟机的启动和停止都是由提供商为我们处理的。
- en: With that basic understanding of serverless, we need to pick a provider. As
    can be expected, there are a number of options--Amazon, Oracle, IBM, Red Hat,
    and more. Unfortunately, currently, there is no standardized means by which we
    can write a serverless system and deploy it to an arbitrary provider, so that
    means our solution will be necessarily tied to a specific provider, which will
    be **Amazon Web Services** (**AWS**), the dominant provider of cloud computing
    services. As mentioned in the introduction to this chapter, we use a number of
    AWS offerings, but the centerpiece will be AWS Lambda, Amazon's serverless computing
    offering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无服务器的基本理解，我们需要选择一个提供商。正如预期的那样，有众多选择——亚马逊、甲骨文、IBM、红帽等等。不幸的是，目前还没有一种标准化的方法，我们可以用它来编写一个无服务器系统并将其部署到任意提供商，这意味着我们的解决方案将不可避免地与特定的提供商绑定，这个提供商将是**亚马逊网络服务**（**AWS**），云计算服务的主要提供商。正如本章引言中提到的，我们使用了许多AWS服务，但核心将是AWS
    Lambda，亚马逊的无服务器计算服务。
- en: Let's jump in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Planning the application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序规划
- en: 'The application we will build is a very simple **cloud notification** service.
    In a nutshell, our function will **listen** for messages, then forward those messages
    to email addresses and phone numbers registered in the system. While our system
    will be somewhat contrived and certainly very simple, hopefully the more practical
    use cases are clear:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序是一个非常简单的 **云通知** 服务。简而言之，我们的函数将 **监听** 消息，然后将这些消息转发到系统中注册的电子邮件地址和电话号码。虽然我们的系统可能有些牵强，而且肯定非常简单，但希望更实际的使用案例是清晰的：
- en: Our system reminds students and/or parents about upcoming events
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的系统会提醒学生和/或家长有关即将发生的事件
- en: Parents are notified when children enter or leave certain geographic boundaries
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当孩子进入或离开某些地理边界时，家长会收到通知
- en: Systems administrators are notified of certain events as they occur
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当某些事件发生时，系统管理员会收到通知
- en: 'The possibilities are quite vast. For our purposes here, we''ll develop not
    only the cloud-based system, but also a simple desktop application to simulate
    these types of scenarios. We''ll start where the fun is: in the cloud.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性相当广泛。就我们的目的而言，我们将开发不仅基于云的系统，还包括一个简单的桌面应用程序来模拟这些类型的场景。我们将从有趣的地方开始：在云中。
- en: Building your first function
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个函数
- en: The heart of Functions as a Service is, of course, the function. In Amazon Web
    Services, these are deployed using the service AWS Lambda. That's not the only
    AWS feature we'll use, as we've already mentioned. Once we have a function, we
    need a way to execute it. This is done via one or more triggers, and the function
    itself has tasks it needs to perform, so we'll demonstrate more service usage
    via API calls when we finally write the function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项服务（Functions as a Service）的核心当然是函数。在亚马逊网络服务中，这些函数是通过 AWS Lambda 服务部署的。这并不是我们唯一会使用的
    AWS 功能，因为我们已经提到过。一旦我们有了函数，我们需要一种执行它的方式。这是通过一个或多个触发器完成的，函数本身也有需要执行的任务，因此当我们最终编写函数时，我们将通过
    API 调用来演示更多服务使用。
- en: 'It might be helpful at this point, given that our application is structured
    significantly differently than anything else we''ve looked at, to look at a system
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序的结构与我们之前看到的任何其他应用程序都显著不同，此时查看系统图可能会有所帮助：
- en: '![](img/fabef02c-4c32-4279-88bb-dc6065892082.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fabef02c-4c32-4279-88bb-dc6065892082.png)'
- en: 'Here''s the rough flow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是大致流程：
- en: A message is published to a topic in the Simple Notification System
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条消息被发布到简单通知系统中的一个主题
- en: Once the permissions of the caller have been verified, the message is delivered
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦验证了调用者的权限，消息就会被投递
- en: Upon message delivery, a trigger is fired, delivering the message from the topic
    to our function
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息投递后，会触发一个事件，将消息从主题传递到我们的函数
- en: Inside the function, we'll query Amazon's **DynamoDB** to get the list of recipients
    that have signed up, providing either an email address, cell phone number, or
    both
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，我们将查询亚马逊的 **DynamoDB** 来获取已注册的接收者列表，这些接收者提供了电子邮件地址、手机号码或两者都有
- en: All of the cell phone numbers will be sent a text message via **Simple Notification
    System**
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有手机号码将通过 **简单通知系统** 发送短信
- en: All the email addresses will be sent an email via **Simple Email Service**
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有电子邮件地址将通过 **简单电子邮件服务** 发送电子邮件
- en: To start building the function, we need to create a Java project. Like many
    of our other projects, this will be a multi-module Maven project. In NetBeans,
    click on File | New Project | Maven | POM Project. We'll call the `CloudNotice`
    project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建函数，我们需要创建一个 Java 项目。像我们的大多数其他项目一样，这将是一个多模块 Maven 项目。在 NetBeans 中，点击文件 |
    新建项目 | Maven | POM 项目。我们将命名 `CloudNotice` 项目。
- en: The project will have three modules--one for the function, one for a test/demo
    client, and one for a shared API. To create the function module, right-click on
    the `Modules` node in the project explorer and select Create new module. In the
    window, select Maven | Java Application, click on Next, and set the project name
    to `function`. Repeat those steps and create a module called `api`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将包含三个模块——一个用于函数，一个用于测试/演示客户端，还有一个用于共享 API。要创建函数模块，在项目资源管理器中的 `Modules` 节点处右键单击，然后选择创建新模块。在窗口中，选择
    Maven | Java 应用程序，点击下一步，并将项目名称设置为 `function`。重复这些步骤，创建一个名为 `api` 的模块。
- en: 'Before we go any further, we have to address the fact that, at the time of
    writing, AWS does not support Java 9\. We must, therefore, target Java 8 (or earlier)
    for anything we will ship to Lambda. To do that, we need to modify our `pom.xml`
    file like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须指出，在撰写本文时，AWS 不支持 Java 9。因此，我们必须针对 Java 8（或更早版本）进行任何将发送到 Lambda
    的内容。为此，我们需要像这样修改我们的 `pom.xml` 文件：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Modify the POM for both `api` and `function`. Hopefully, AWS will support Java
    9 as quickly as possible after its release. Until then, we'll just have to target
    JDK 8.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `api` 和 `function` 的 POM 文件。希望 AWS 能够在 Java 9 发布后尽快支持它。在此之前，我们只能以 JDK 8 为目标。
- en: 'With our project configured, we''re ready to write our function. AWS Lambdas
    are implemented as `RequestHandler` instances:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目配置完成后，我们就可以编写我们的函数了。AWS Lambdas 是作为 `RequestHandler` 实例实现的：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ultimately, we want our function to be triggered when a message is delivered
    to an SNS topic, so we specify `SNSEvent` as the input type. We also specify `Context`.
    There are several things we can get from the `Context`, such as the request ID,
    memory limit, and others, but all we're interested in is getting a `LambdaLogger`
    instance. We could just write to standard out and standard error, and those messages
    would be saved in Amazon CloudWatch, but `LambdaLogger` allows us to respect system
    permissions and the container configuration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望我们的函数在消息被发送到 SNS 主题时被触发，因此我们将 `SNSEvent` 指定为输入类型。我们还指定了 `Context`。我们可以从
    `Context` 中获取几件事情，例如请求 ID、内存限制等，但我们感兴趣的是获取一个 `LambdaLogger` 实例。我们只需将内容写入标准输出和标准错误，这些消息就会被保存在
    Amazon CloudWatch 中，但 `LambdaLogger` 允许我们尊重系统权限和容器配置。
- en: 'To make this compile, we need to add some dependencies to our application,
    so we add the following lines to `pom.xml`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个编译通过，我们需要向我们的应用程序添加一些依赖项，因此我们在 `pom.xml` 中添加以下行：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now start implementing the method as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现这个方法，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have a couple of new classes to look at, but to recap this code first, we
    will get a list of `Recipient` instances, which represents the numbers and email
    addresses that have been subscribed to our service. We then create a stream from
    the list, filtering for each recipient type, `SMS` or `Email`, extracting the
    value via `map()`, then collecting them in a `List`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些新的类需要查看，但首先让我们回顾一下这段代码，我们将获取一个 `Recipient` 实例的列表，它代表了已订阅我们服务的号码和电子邮件地址。然后我们从这个列表中创建一个流，过滤每个接收者类型，`SMS`
    或 `Email`，通过 `map()` 提取值，然后收集到一个 `List` 中。
- en: 'We will get to `CloudNoticeDAO` and `Recipient` in a moment, but let''s finish
    up with our function first. Once we have our lists, we can then send the messages
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论 `CloudNoticeDAO` 和 `Recipient`，但让我们先完成我们的函数。一旦我们有了列表，我们就可以按照以下方式发送消息：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have encapsulated two more AWS APIs behind our own client classes, `SesClient`
    and `SnsClient`. This may seem a bit excessive, but these types of things tend
    to grow, and this approach puts us in a good position to manage that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的客户端类 `SesClient` 和 `SnsClient` 后面封装了另外两个 AWS API。这看起来可能有点过度，但这些类型的东西往往会增长，而且这种做法使我们能够很好地管理这一点。
- en: 'That leaves us with three APIs to look at: DynamoDB, Simple Email Service,
    and Simple Notification Service. We''ll take them in order.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就有了三个 API 需要查看：DynamoDB、Simple Email Service 和 Simple Notification Service。我们将按顺序进行。
- en: DynamoDB
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB
- en: Amazon DynamoDB is a NoSQL database, very much like MongoDB, which we looked
    at in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking Notes
    with Monumentum*, though DynamDB supports both document and key-value store models.
    A thorough comparison of the two, as well as a recommendation as to which to choose,
    is well outside the scope of our work here. We chose DynamoDB here, since it is
    already provisioned in the Amazon Web Service, and, thus, easily configured for
    our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon DynamoDB 是一个 NoSQL 数据库，非常类似于我们在第 25 章 [Taking Notes with Monumentum](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml)
    中查看的 MongoDB，尽管 DynamDB 支持文档和键值存储模型。对这两种模型的详细比较以及关于选择哪一种的建议超出了我们工作的范围。我们在这里选择了
    DynamoDB，因为它已经在 Amazon Web Service 中配置好了，因此很容易为我们应用程序进行配置。
- en: 'To get started with the DynamoDB API, we need to add some dependencies to our
    application. In the `api` module, add this to the `pom.xml` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 DynamoDB API，我们需要向我们的应用程序添加一些依赖项。在 `api` 模块中，将以下内容添加到 `pom.xml` 文件中：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we start writing our DAO class, let''s define our simple model. The
    DynamoDB API provides an object-relational mapping facility, much like the Java
    Persistence API or Hibernate, which will require a POJO and just a few annotations
    as we see here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写 DAO 类之前，让我们定义我们的简单模型。DynamoDB API 提供了一个对象关系映射功能，类似于 Java Persistence
    API 或 Hibernate，正如我们在这里看到的，它需要一个 POJO 和一些注解：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our POJO, we declared three properties, `id`, `type`, and `address`, then
    annotated the getters with `@DyanoDBAttribute` to help the library understand
    how to map the object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 POJO 中，我们声明了三个属性，`id`、`type` 和 `address`，然后使用 `@DyanoDBAttribute` 注解了 getters，以帮助库理解如何映射对象。
- en: Note that, while most of the property names match the field names in the table,
    you can override the property-to-field name mapping as we did with `id`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管大多数属性名与表中的字段名匹配，但你也可以像我们对 `id` 所做的那样覆盖属性到字段名的映射。
- en: Before we can do anything with our data, we need to declare our table. Remember
    that DynamoDB is a NoSQL database, and we will use it as a document store just
    as we did with MongoDB. However, before we can store any data, we have to define
    **where** to put it. In MongoDB, we would create a collection. DynamoDB, though,
    still refers to this as a table, and, while it is technically schemaless, we do
    need to define a primary key, which is made up of a partition key and an optional
    sort key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够对我们的数据进行任何操作之前，我们需要声明我们的表。记住，DynamoDB 是一个 NoSQL 数据库，我们将像使用 MongoDB 一样将其用作文档存储。然而，在我们能够存储任何数据之前，我们必须定义**在哪里**放置它。在
    MongoDB 中，我们会创建一个集合。但是，DynamoDB 仍然将其称为表，尽管它在技术上是无模式的，我们仍然需要定义一个主键，它由分区键和一个可选的排序键组成。
- en: 'We create the table through the console. Once you''ve logged on to the AWS
    DynamoDB console, you will click on the Create Table button, which will bring
    you to a screen like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过控制台创建表。一旦你登录到 AWS DynamoDB 控制台，你会点击创建表按钮，这将带你到一个类似这样的屏幕：
- en: '![](img/125e9135-0d20-42e4-8941-6c0a0e13ef46.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/125e9135-0d20-42e4-8941-6c0a0e13ef46.png)'
- en: We will name our table `recipients`, and specify `_id` as the partition key.
    Click on the Create Table button and give AWS time to create the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的表为 `recipients`，并指定 `_id` 作为分区键。点击创建表按钮，并给 AWS 时间来创建表。
- en: 'We are now ready to start writing our DAO. In the API module, create a class
    called `CloudNoticeDAO`, to which we''ll add this constructor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们的 DAO 了。在 API 模块中，创建一个名为 `CloudNoticeDAO` 的类，我们将向其中添加这个构造函数：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The local property is used to determine whether or not to use a local DynamoDB
    instance. This is here to support testing (as is the call to `verifyTables`),
    which we will explore in a moment. In production, our code will call `AmazonDynamoDBClientBuilder.defaultClient()`
    to acquire an instance of `AmazonDynamoDB`, which talks to the Amazon-hosted instance.
    Finally, we create an instance of `DynamoDBMapper`, which we'll use for our object
    mapping.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本地属性用于确定是否使用本地 DynamoDB 实例。这是为了支持测试（就像对 `verifyTables()` 的调用一样），我们将在稍后探讨。在生产中，我们的代码将调用
    `AmazonDynamoDBClientBuilder.defaultClient()` 来获取 `AmazonDynamoDB` 的一个实例，它与 Amazon
    托管的实例进行通信。最后，我们创建一个 `DynamoDBMapper` 的实例，我们将使用它进行对象映射。
- en: 'To facilitate creating a new `Recipient`, we will add this method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于创建一个新的 `Recipient`，我们将添加这个方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method will either create a new entry in the database, or update an existing
    one if the primary key already exists. In some scenarios, it might make sense
    to have separate save and update methods, but our use case is so simple that we
    don't need to worry about that. All we need to do is create the key value if it's
    missing. We do so by creating a random UUID, which helps us avoid key collisions
    should there be more than one process or application writing to the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将创建数据库中的新条目，或者如果主键已经存在，则更新现有条目。在某些场景中，可能有必要有单独的保存和更新方法，但我们的用例非常简单，所以我们不需要担心这一点。我们所需做的只是如果缺失，则创建键值。我们通过创建一个随机
    UUID 来做到这一点，这有助于我们避免在存在多个进程或应用程序写入数据库时发生键冲突。
- en: 'Deleting a `Recipient` instance or getting a list of all of the `Recipient`
    instances in the database is just as simple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个 `Recipient` 实例或获取数据库中所有 `Recipient` 实例的列表同样简单：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we leave our DAO, let's take a quick look at how we can test it. Earlier,
    we noted the `local` parameter and the `verifyTables()` method, which exist for
    testing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开我们的 DAO 之前，让我们快速看一下我们如何测试它。早些时候，我们提到了 `local` 参数和 `verifyTables()` 方法，它们都存在于测试中。
- en: Generally speaking, most people will frown, and rightfully so, on adding methods
    to production classes just for testing. There's a difference between writing a
    class that is testable, and adding test methods to a class. I would agree that
    adding methods to a class just for testing is something that should be avoided,
    but I am violating that principle a little here for the sake of simplicity and
    brevity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，大多数人会对在生产类中添加仅用于测试的方法皱眉，这是有道理的。编写可测试的类和向类中添加测试方法之间是有区别的。我同意仅为了测试而向类中添加方法是一种应该避免的做法，但在这里为了简单和简洁，我稍微违反了这个原则。
- en: 'The `verifyTables()` method checks to see if the table exists; if the table
    doesn''t, we call another method that will create it for us. While we manually
    created the production table using the preceding console, we could also let this
    method create that table for us. What approach you use is completely up to you.
    Be aware that there will be performance and permissions issues that will need
    to be addressed. That said, that method looks something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyTables()`方法检查表是否存在；如果表不存在，我们将调用另一个方法来为我们创建它。虽然我们手动使用前面的控制台创建了生产表，但我们可以让此方法为我们创建该表。您使用哪种方法完全取决于您。请注意，将会有性能和权限问题需要解决。话虽如此，该方法看起来像这样：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the call to the `describeTable()` method, we can check to see if the table
    exists. In our test, this will fail every time, which will cause the table to
    be created. In production, should you use this method to create the table, this
    call will fail only on the first invocation. In `createRecipientTable()`, we can
    see how a table is created programmatically. We also wait until the table is active
    to make sure our reads and writes won't fail while the table is being created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`describeTable()`方法，我们可以检查表是否存在。在我们的测试中，这将在每次都失败，这将导致创建表。在生产环境中，如果您使用此方法创建表，则此调用仅在第一次调用时失败。在`createRecipientTable()`中，我们可以看到如何以编程方式创建表。我们还等待表处于活动状态，以确保在表创建过程中我们的读写操作不会失败。
- en: 'Our tests, then, are very simple. For example, consider the following code
    snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行的测试非常简单。例如，考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test helps us verify that our model mapping is correct, and that our DAO
    methods function as expected. You can see additional testing in the `CloudNoticeDaoTest`
    class, in the source bundle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试帮助我们验证我们的模型映射是否正确，以及我们的DAO方法是否按预期工作。您可以在源包中的`CloudNoticeDaoTest`类中看到额外的测试。
- en: Simple Email Service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单电子邮件服务
- en: To send emails, we will use the Amazon Simple Email Service, or SES, which we
    will wrap in the `SesClient` class in the `api` module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们将使用亚马逊简单电子邮件服务（SES），我们将将其包装在`api`模块中的`SesClient`类中。
- en: '**IMPORTANT**: Before you can send an email, you have to verify either your
    sending/from address or domain. The verification process is fairly simple, but
    how to do that is probably best left to Amazon''s documentation, which you can
    read here: [http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**：在您发送电子邮件之前，您必须验证您的发送/接收地址或域名。验证过程相当简单，但如何操作最好留给亚马逊的文档，您可以通过以下链接阅读：[http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html)。'
- en: 'The Simple Email Service API is quite simple. We need to create a `Destination`,
    which tells the system to whom to send the emails; a `Message` that describes
    the message itself, including subject, body, and recipients; and a `SendEmailRequest`
    that ties everything together:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单电子邮件服务API相当简单。我们需要创建一个`Destination`，告诉系统将电子邮件发送给谁；一个`Message`，描述消息本身，包括主题、正文和收件人；以及一个`SendEmailRequest`，将所有这些内容结合起来：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is an important caveat though, which is in the preceding bolded code.
    SES limits the number of recipients per message to 50, so we need to take our
    list of email addresses and process them 50 at a time. We will do that using the
    `getChunkedEmailList()` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的注意事项，那就是前面加粗的代码。SES将每条消息的收件人数量限制为50，因此我们需要将我们的电子邮件地址列表分成50个一组进行处理。我们将使用`getChunkedEmailList()`方法来完成这项工作：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To find the number of groups, we divide the number of addresses by 50 and round
    up (for example, 254 addresses would get us 6 groups--5 of 50 and 1 of 4). Then,
    using an `IntStream` to count from 0 to the number of groups (exclusive), we extract
    sublists from the original list. Each of these lists is then collected into yet
    another `List`, giving us the nested `Collection` instances we see in the method
    signature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到组数，我们将地址数量除以50并向上取整（例如，254个地址将给我们6组--5组各50个，1组4个）。然后，使用`IntStream`从0计数到组数（不包括），我们从原始列表中提取子列表。然后，将这些列表收集到另一个`List`中，给我们看到的方法签名中的嵌套`Collection`实例。
- en: '**Design note**: Many developers will avoid using nested `Collection` instances
    like this, as it can quickly become difficult to understand what exactly the variable
    represents. It is considered by many to be a best practice in situations like
    this to create a new type to hold the nested data. For example, if we were to
    follow that advice here, we could create, perhaps, a new `Group` class that had
    a `List<String>` property to hold the group''s email addresses. We have not done
    so for the sake of brevity, but that would definitely be a good enhancement to
    this code.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计说明**：许多开发者会避免使用这种嵌套`Collection`实例，因为它很快就会变得难以理解变量究竟代表什么。许多人认为在这种情况下创建一个新的类型来保存嵌套数据是一种最佳实践。例如，如果我们遵循这个建议，我们可以创建一个新的`Group`类，它有一个`List<String>`属性来保存组的电子邮件地址。我们没有这样做是为了简洁，但那绝对是对此代码的一个很好的改进。'
- en: Once we've **chunked** our list, we can send the same `Message` to each group,
    and thus fulfill the API contract.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将列表**分块**，我们就可以向每个组发送相同的`消息`，从而满足API合约。
- en: Simple Notification Service
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单通知服务
- en: 'We''ve already seen the Simple Notification System at work, at least in theory,
    as that is what delivers the outbound message to our function: a client of some
    sort publishes a message in a specific SNS topic. We have a subscription to that
    topic (I''ll show you how to create that later) that calls our method with the
    message for us to deliver. We will use the SNS API now to send text (or SMS) messages
    to the users who have subscribed a phone number to the system.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了简单通知系统在工作，至少在理论上是这样，因为它是将出站消息传递给我们的函数的：某种客户端在特定的SNS主题中发布了一条消息。我们对该主题有一个订阅（我稍后会向你展示如何创建它），它会调用我们的方法，为我们传递消息。现在我们将使用SNS
    API向已将电话号码订阅到系统的用户发送文本（或短信）消息。
- en: 'With SNS, to send a message to more than one phone number you must do so through
    a topic to which each number is subscribed. What we''ll do then is follow these
    steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SNS，要向多个电话号码发送消息，你必须通过每个号码已订阅的主题来发送。我们接下来要做的就是遵循以下步骤：
- en: Create a topic.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主题。
- en: Subscribe all of the phone numbers.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅所有电话号码。
- en: Publish the message to the topic.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息发布到主题。
- en: Delete the topic.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除主题。
- en: 'If we use a persistent topic, we will likely get unpredictable results if we
    have more than one instance of the function running simultaneously. The method
    that orchestrates all of this work looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用持久性主题，当有多个该函数实例同时运行时，我们可能会得到不可预测的结果。负责所有这些工作的方法看起来是这样的：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To create a topic, we have the following method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建主题，我们有以下方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To subscribe the numbers to the topic, we have this method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将号码订阅到主题，我们有这个方法：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Publishing a message is equally simple, as we see here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发布消息同样简单，正如我们所看到的：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, you can delete the topic with this simple method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用这个简单的方法删除主题：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All of these methods are clearly very simple, so the calls to the SNS API could
    be made directly inline in the calling code, but this wrapper does provide us
    with a way to hide the details of the API from our business code. This is more
    important, for example, in `createTopic()`, where extra classes are needed, but,
    to be consistent, we'll encapsulate everything behind our own facade.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都非常简单，所以可以直接在调用代码中调用SNS API，但这个包装器确实为我们提供了一种隐藏API细节的方法。这在例如`createTopic()`这样的情况下尤为重要，那里需要额外的类，但为了保持一致性，我们将一切封装在我们的自己的外观之后。
- en: Deploying the function
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署函数
- en: 'We have now completed our function and we''re almost ready to deploy it. To
    do that, we need to package it. AWS allows us to upload either a ZIP or a JAR
    file. We''ll use the latter. However, we have some external dependencies, so we''ll
    use the **Maven Shade** plugin to build a fat jar with our function and all of
    its dependencies. In the `function` module, add the following piece of code to
    the `pom.xml` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了我们的函数，我们几乎准备好部署它了。为此，我们需要打包它。AWS允许我们上传ZIP或JAR文件。我们将使用后者。然而，我们有一些外部依赖项，所以我们将使用**Maven
    Shade**插件来构建一个包含我们的函数及其所有依赖项的胖JAR。在`function`模块中，将以下代码片段添加到`pom.xml`文件中：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when we build the project, we'll get a large file (about 9MB) in the target
    directory. It is this file that we will upload.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建项目时，我们将在目标目录中获得一个大型文件（大约9MB）。这个文件就是我们将要上传的文件。
- en: Creating a role
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建角色
- en: 'Before we can upload the function, we need to prepare our AWS environment by
    creating the appropriate role. Log on to AWS and navigate to the Identity and
    Access Management Console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
    In the navigation pane on the left, click on Roles, then click on Create new role:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以上传函数之前，我们需要通过创建适当的角色来准备我们的 AWS 环境。登录 AWS 并导航到身份和访问管理控制台（[https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)）。在左侧的导航面板中，点击角色，然后点击创建新角色：
- en: '![](img/e5630954-edea-4a15-a810-c91f79bb900e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5630954-edea-4a15-a810-c91f79bb900e.png)'
- en: 'When prompted to select a role, we want to select AWS Lambda. On the next page,
    we will attach the policies:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示选择角色时，我们想要选择 AWS Lambda。在下一页，我们将附加策略：
- en: '![](img/9f50368b-364c-473c-8427-beddb0ba370e.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f50368b-364c-473c-8427-beddb0ba370e.png)'
- en: Click on Next, set the name to `j9bp`, and click on Create role.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步，将名称设置为 `j9bp`，然后点击创建角色。
- en: Creating a topic
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主题
- en: To make creating the function and the associated trigger simpler, we will create
    our topic first. Navigate to the SNS console. Given that not all AWS functionality
    is always available in every region, we need to choose a specific region. We can
    do that in the upper-left corner of the web page. If the region does not say N.
    Virginia, select it--US East (N. Virginia)--from the drop-down menu before continuing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使创建函数和相关触发器更加简单，我们首先创建我们的主题。导航到 SNS 控制台。鉴于并非所有 AWS 功能在所有区域都始终可用，我们需要选择一个特定区域。我们可以在网页的左上角做到这一点。如果区域不显示为
    N. Virginia，请选择它--US East (N. Virginia)--从下拉菜单中选择，然后再继续。
- en: 'Once the region is set correctly, click on Topics in the left navigation bar,
    then click on Create new topic and specify the name as `cloud-notice`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置正确的区域，点击左侧导航栏中的主题，然后点击创建新主题并指定名称为 `cloud-notice`：
- en: '![](img/65ae9024-d65d-4a49-842d-c7bced165265.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65ae9024-d65d-4a49-842d-c7bced165265.png)'
- en: Deploying the function
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署函数
- en: 'We can now navigate to the Lambda console and deploy our function. We will
    start by clicking on the Create a lambda function button. We''ll be asked to select
    a blueprint. The only option suitable for a Java-based function is Blank Function.
    Once we click on that option, we are presented with the Configure Triggers screen.
    When you click on the empty square, you will be presented with a drop-down menu,
    as seen in this screenshot from the AWS console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导航到 Lambda 控制台并部署我们的函数。我们将首先点击创建 Lambda 函数按钮。我们将被要求选择一个蓝图。适合基于 Java 的函数的唯一选项是空白函数。一旦我们点击该选项，我们就会看到配置触发器屏幕。当您点击空方框时，您将看到一个下拉菜单，如
    AWS 控制台的此截图所示：
- en: '![](img/e85d040d-260a-419d-9981-d51fa4541eba.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e85d040d-260a-419d-9981-d51fa4541eba.png)'
- en: 'You can either scroll down to find SNS, or enter `SNS` in the filter box as
    in the preceding screenshot. Either way, when you click on SNS in the list, you
    will be asked to select the topic to which you want to subscribe:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以滚动到找到 SNS，或者在过滤器框中输入 `SNS`，如前面的截图所示。无论哪种方式，当您在列表中点击 SNS 时，您将被要求选择您想要订阅的主题：
- en: '![](img/961a6d80-9ecf-49cf-a606-3fff8103ee53.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/961a6d80-9ecf-49cf-a606-3fff8103ee53.png)'
- en: 'Click on Next. We now need to specify the details of our function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。我们现在需要指定我们函数的详细信息：
- en: '![](img/38ae6c28-8a7b-4fca-8faf-7425e87a128b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38ae6c28-8a7b-4fca-8faf-7425e87a128b.png)'
- en: 'Scrolling down the page, we also need to specify the Lambda function handler
    and role. The Handler is the fully-qualified class name, followed by two colons,
    and the method name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到页面底部，我们还需要指定 Lambda 函数处理程序和角色。处理程序是完整的类名，后面跟着两个冒号，然后是方法名：
- en: '![](img/39f51cb5-e805-421a-a9be-17fed0b46cde.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39f51cb5-e805-421a-a9be-17fed0b46cde.png)'
- en: We now need to select the function archive by clicking on the upload button
    and selecting the jar file created by our Maven build. Click on Next, verify the
    details of the function, and then click on Create function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过点击上传按钮并选择由我们的 Maven 构建创建的 jar 文件来选择函数存档。点击下一步，验证函数的详细信息，然后点击创建函数。
- en: We now have a usable AWS Lambda function. We can test it using the Lambda Console,
    but instead we'll build a small JavaFX application to do that, which will simultaneously
    test all of the service integrations, as well as demonstrate how a production
    application would interact with the function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可用的 AWS Lambda 函数。我们可以使用 Lambda 控制台来测试它，但我们将构建一个小的 JavaFX 应用程序来完成这个任务，这将同时测试所有服务集成，并展示一个生产应用程序如何与该函数交互。
- en: Testing the function
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试函数
- en: To help test and demonstrate the system, we'll create a new module, called `manager`,
    in the `CloudNotice` project. To do that, click on the modules node in the NetBeans
    project explorer, then click on Create New Module... | Maven | JavaFX Application.
    Call the project `Manager` and click on Finish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助测试和演示系统，我们将在`CloudNotice`项目中创建一个新的模块，名为`manager`。为此，在NetBeans项目资源管理器中单击模块节点，然后单击创建新模块...
    | Maven | JavaFX应用程序。将项目命名为`Manager`，然后单击完成。
- en: I have renamed `MainApp` to `CloudNoticeManager`, `FXMLController` to `CloudNoticeManagerController`,
    and `Scene.fxml` to `manager.fxml`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将`MainApp`重命名为`CloudNoticeManager`，将`FXMLController`重命名为`CloudNoticeManagerController`，将`Scene.fxml`重命名为`manager.fxml`。
- en: 'Our `Application` class will look a little different than in previous JavaFX
    applications. Some of the AWS client APIs require that they be shut down explicitly
    when you are finished with them. Failure to do so means that our application won''t
    fully quit, leaving behind **zombie** processes that must be killed. To make sure
    we properly shut down our AWS clients, we need to add a cleanup method to our
    controller, which we''ll call from the `stop()` method in our application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Application`类将与之前的JavaFX应用程序略有不同。一些AWS客户端API要求在完成使用后显式关闭它们。未能这样做意味着我们的应用程序将无法完全退出，留下必须被杀死的**僵尸**进程。为了确保我们正确关闭AWS客户端，我们需要在我们的控制器中添加一个清理方法，然后从应用程序中的`stop()`方法调用它：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, regardless of whether the user clicks on File | Exit or clicks on the Close
    button on the window, our AWS clients can be cleaned up correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论用户是点击文件 | 退出还是点击窗口上的关闭按钮，我们的AWS客户端都可以被正确清理。
- en: 'In terms of layout, there''s nothing new to discuss, so we''ll not dwell on
    that aspect here. This is what our manager app will look like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局方面，没有新的内容可讨论，因此我们不会在此处过多关注这一点。这是我们管理应用程序的外观：
- en: '![](img/32338e18-d903-4abe-956b-1475793a3c80.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32338e18-d903-4abe-956b-1475793a3c80.png)'
- en: We have a list of the subscribed recipients on the left, an area for adding
    and editing a recipient at the top right, and an area for sending a test message
    at the bottom right. We do have some interesting bindings, so let's take a look
    at this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在左侧有一个订阅的收件人列表，在右上角有一个添加和编辑收件人的区域，在右下角有一个发送测试消息的区域。我们确实有一些有趣的绑定，所以让我们看看这个。
- en: 'First, in `CloudNoticeManagerController`, we need to declare some containers
    for our data, so we declare a number of `ObservableList` instances:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`CloudNoticeManagerController`中，我们需要声明一些用于我们的数据容器，所以我们声明了多个`ObservableList`实例：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These three `ObservableList` instances will back the UI controls matching their
    names. We will populate two of those lists (`type` is hardcoded) in `initalize()`
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个`ObservableList`实例将支持与其名称匹配的UI控件。我们将在`initialize()`方法中填充其中两个列表（`type`是硬编码的），如下所示：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using our DAO and SES client, we fetch any already subscribed recipients, as
    well as any topics configured in the account. This will get *every* topic, so
    if you have a lot, this may be a problem, but this is just a demonstration application,
    so that should be fine here. Once we have these two lists, we add them to the
    `ObservableList` instances we created earlier, then associate the `List` with
    the appropriate UI controls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的DAO和SES客户端，我们获取任何已订阅的收件人以及账户中配置的任何主题。这将获取**每个**主题，所以如果你有很多，这可能会成为问题，但这是一个演示应用程序，所以这里应该没问题。一旦我们有了这两个列表，我们将它们添加到我们之前创建的`ObservableList`实例中，然后将`List`与适当的UI控件关联。
- en: 'To make sure the `Recipient` list displays correctly, we need to create a `CellFactory`
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`Recipient`列表正确显示，我们需要创建一个`CellFactory`，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that, if the cell is empty, we need to set the text to null to clear
    out any previous value. Failure to do that will result, at some point, in a `ListView`
    with **phantom** entries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果单元格为空，我们需要将文本设置为null以清除任何之前的值。未能这样做将导致在某个时刻出现带有**幽灵**条目的`ListView`。
- en: 'Next, we need to update the edit controls when the user clicks on a `Recipient`
    in the list. We do this by adding a listener to the `selectedItemProperty`, which
    is run every time the selected item changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在用户点击列表中的`Recipient`时更新编辑控件。我们通过向`selectedItemProperty`添加监听器来实现这一点，该监听器在所选项目更改时运行：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `newRecipient` is not null, we set the value of the controls to the appropriate
    value. Otherwise, we clear the values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`newRecipient`不为null，我们将控件值设置为适当的值。否则，我们将清除值。
- en: We now need to add handlers for the various buttons--the Add and Remove buttons
    above the `Recipient` list, and the `Save` and `Cancel` buttons in the two **form**
    areas on the right.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为各种按钮添加处理程序——位于`收件人`列表上方的添加和删除按钮，以及右侧两个**表单**区域中的保存和取消按钮。
- en: 'The UI control''s `onAction` property can be bound to the method in the class
    by editing the FXML directly, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: UI控件的`onAction`属性可以通过直接编辑FXML绑定到类中的方法，如下所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It can also be bound to the method by editing the property in Scene Builder,
    as shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以通过在Scene Builder中编辑属性来绑定到方法，如下面的截图所示：
- en: '![](img/2d472bcc-4ee9-44d6-b382-e29fc81abe6d.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d472bcc-4ee9-44d6-b382-e29fc81abe6d.png)'
- en: 'Either way, the method will look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，方法看起来都像这样：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We're adding a `Recipient`, so we create a new one, add it to our `ObservableList`,
    then tell the `ListView` to select this entry. Finally, we ask the `type` control
    to request focus so the user can easily change the value with the keyboard, if
    so desired. The new Recipient isn't saved to DynamoDB until the user clicks on
    Save, which we will look at in a moment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`Recipient`，因此我们创建了一个新的，将其添加到我们的`ObservableList`中，然后告诉`ListView`选择这个条目。最后，我们要求`type`控件请求焦点，以便用户可以轻松地使用键盘更改值，如果需要的话。新的收件人只有在用户点击保存时才会保存到DynamoDB，我们稍后会看到这一点。
- en: 'When we delete a `Recipient`, we need to remove it from the UI as well as from
    DynamoDB:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们删除一个`Recipient`时，我们需要从UI以及从DynamoDB中删除它：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Saving is a bit more complicated, but not much:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 保存稍微复杂一些，但并不复杂：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we're not binding the values of the edit controls to the selected item
    in the list, we need to get the reference to the item, then copy the values from
    the controls to the model. Once that's done, we save it to the database via our
    DAO, then ask `ListView` to refresh itself so that any model changes are reflected
    in the list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将编辑控件的值绑定到列表中选定的项目，我们需要获取项目的引用，然后将控件中的值复制到模型中。完成此操作后，我们通过我们的DAO将其保存到数据库，然后要求`ListView`刷新自己，以便任何模型更改都能反映在列表中。
- en: We aren't binding the controls to the item in the list as that leads to a slightly
    confusing user experience. If we did bind, as the user made changes to the model
    `ListView` would reflect those changes. It is conceivable that the user would
    then assume that the changes are being saved to the database when, in fact, they
    are not. That doesn't happen until the user clicks on Save. To avoid this confusion,
    and the loss of data, we have *not* bound the controls and manage the data manually.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将控件绑定到列表中的项目，因为这会导致用户体验略感困惑。如果我们绑定了，当用户对模型进行更改时，`ListView`会反映这些更改。可以想象，用户可能会认为这些更改正在被保存到数据库中，而实际上并不是。这种情况只有在用户点击保存时才会发生。为了避免这种困惑和数据丢失，我们没有绑定控件，而是手动管理数据。
- en: 'To cancel the change, all we need to do is get a reference to the unchanged
    model from `ListView`, and copy its values over those in the edit controls:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消更改，我们只需要从`ListView`获取未更改模型的引用，然后将其值复制到编辑控件中：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That leaves us with the **send a message** section of the UI. Thanks to our
    SNS wrapper API, these methods are very simple:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了UI的**发送消息**部分。多亏了我们的SNS包装器API，这些方法非常简单：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From our desktop application, we can now add, edit, and remove recipients, as
    well as send test messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的桌面应用程序中，我们现在可以添加、编辑和删除收件人，以及发送测试消息。
- en: Configuring your AWS credentials
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的AWS凭证
- en: Those paying very close attention may be asking a very important question--How
    do the AWS client libraries know how to log on to our account? Clearly, we need
    to tell them, and we have a few options.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那些非常关注细节的人可能会问一个非常重要的问题——AWS客户端库是如何知道如何登录到我们的账户的？显然，我们需要告诉它们，我们有一些选择。
- en: The AWS SDK, when run locally, will check three places for the credentials--environment
    variables (`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`), system properties
    (`aws.accessKeyId` and `aws.secretKey`), and the default credentials profiles
    file (`$HOME/.aws/credentials`). What credentials you use is up to you, but I
    will show you here how to configure the profiles file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当AWS SDK在本地运行时，它会在三个地方检查凭证——环境变量（`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`）、系统属性（`aws.accessKeyId`和`aws.secretKey`）以及默认凭证配置文件（`$HOME/.aws/credentials`）。您使用哪种凭证取决于您，但我会在这里向您展示如何配置配置文件。
- en: Just like a Unix or Windows system, your AWS account has a `root` user that
    has complete access to your system. It would be extremely imprudent to run any
    client code connected as this user. To avoid that, we need to create a user, which
    we can do on the Identity and Access Management console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Unix 或 Windows 系统，您的 AWS 账户有一个具有对系统完全访问权限的 `root` 用户。以这个用户身份运行任何客户端代码都是非常不明智的。为了避免这种情况，我们需要创建一个用户，我们可以在身份和访问管理控制台（[https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)）上完成这一操作。
- en: 'Once you''ve logged on, click on Users on the left, then Add user at the top,
    the result of which is shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，点击左侧的“用户”，然后在顶部点击“添加用户”，结果如下截图所示：
- en: '![](img/c16ba08c-f738-4383-aa4d-76a98f2eb58f.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c16ba08c-f738-4383-aa4d-76a98f2eb58f.png)'
- en: 'Click on Next: Permissions and check the entry in the Group list for our role,
    `j9bp`. Click on Next: Review, then Create User. This will take you to the Add
    user screen, which should have a success message box. The important part is the
    user information listed toward the bottom of the screen. On the right side of
    this table, you should see the columns Access key ID and Secret access key. Click
    on Show on the access key to reveal the value. Make a note of both of these, as
    there is no way to retrieve the access key once you leave this page. If you lose
    it, you will have to generate a new set of keys, which will break any other application
    using the old credentials.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步：权限”，然后检查角色列表中我们的角色“j9bp”的条目。点击“下一步：审查”，然后创建用户。这将带您到添加用户屏幕，应该有一个成功消息框。重要的是屏幕底部列出的用户信息。在此表的右侧，你应该看到“访问密钥
    ID”和“秘密访问密钥”这两列。点击“显示”访问密钥以显示其值。请记住这两个值，因为一旦离开此页面，就无法检索访问密钥。如果您丢失了它，您将不得不生成一组新的密钥，这将破坏使用旧凭证的任何其他应用程序。
- en: '![](img/e2754894-8149-4c86-b987-6e010b3f5909.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2754894-8149-4c86-b987-6e010b3f5909.png)'
- en: 'In a text editor, we need to create the `~/.aws/credentials` file. On a Unix
    system, that may be `/home/jdlee/.aws`, and on a Windows machine that will be
    something like `C:Usersjdleeaws`. The credentials file should look something like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中，我们需要创建 `~/.aws/credentials` 文件。在 Unix 系统上，这可能是 `/home/jdlee/.aws`，而在
    Windows 机器上可能是 `C:Usersjdleeaws`。凭证文件应该看起来像这样：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the same directory, we need to create another file called `config`. We''ll
    use this file to tell the SDK which region we want to work in:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，我们还需要创建另一个名为 `config` 的文件。我们将使用此文件来告诉 SDK 我们想要在哪个区域工作：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the AWS clients start up now, they will default to connecting as the `j9bp`
    user in the `us-east-1` region. Should you need to override that, you can either
    edit this file or set the environment variables or system properties noted above
    in the section, *Configuring your AWS Credentials*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 AWS 客户端启动时，它们将默认连接到 `us-east-1` 区域的 `j9bp` 用户。如果您需要覆盖此设置，您可以编辑此文件或设置在 *配置您的
    AWS 凭证* 部分中提到的上述环境变量或系统属性。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've done it! We've created, many of us, our very first AWS Lambda function,
    and it really wasn't all that difficult. It is a simple application, of course,
    but I hope you can see how this type of application could be very useful. Using
    this as a starting point, you can write systems, with the help of a mobile application,
    to help keep track of your family's location. Using embedded devices such as Raspberry
    PI, for example, you can build devices to track inventory as it is shipped across
    the country, reporting location, speed, environmental conditions, sudden drops
    or impacts, and so on. A piece of software running on a server could constantly
    report various metrics about the system, such as CPU temperature, free disk space,
    memory allocated, system load, and so on. Your options are limited only by your
    imagination.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们中的许多人已经创建了我们的第一个 AWS Lambda 函数，这其实并没有那么困难。当然，这是一个简单的应用程序，但我希望你能看到这种类型的应用程序可能非常有用。以这个作为起点，你可以编写系统，借助移动应用程序的帮助，以跟踪你家人的位置。例如，使用嵌入式设备如
    Raspberry PI，你可以构建跟踪货物在全国范围内运输的设备，报告位置、速度、环境条件、突然的下降或冲击等。在服务器上运行的软件可以持续报告有关系统的各种指标，例如
    CPU 温度、可用磁盘空间、分配的内存、系统负载等。你的选择仅受你的想象力限制。
- en: To wrap up, let's take a quick look back at what we've learned. We learned about
    some of the various **... as a service** systems that are being offered today,
    and what **serverless** really means and why it may appeal to us as application
    developers. We learned how to configure various Amazon Web Services offerings,
    including Identity and Access Management, Simple Notification System, Simple Email
    Service, and, of course Lambda, and we learned how to write an AWS Lambda function
    in Java and how to deploy it to the service. And finally, we learned how to configure
    triggers that would tie an SNS publish/subscribe topic to our Lambda function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，让我们快速回顾一下我们所学的内容。我们了解了一些今天提供的各种**...作为服务**系统，以及**无服务器**真正意味着什么，以及为什么它可能对我们这些应用开发者有吸引力。我们学习了如何配置各种亚马逊云服务产品，包括身份和访问管理、简单通知系统、简单电子邮件服务，当然还有Lambda，我们还学习了如何在Java中编写AWS
    Lambda函数以及如何将其部署到服务中。最后，我们学习了如何配置触发器，将SNS发布/订阅主题与我们的Lambda函数关联起来。
- en: There's no denying that our application is somewhat simple, and there's no way
    in the space of a single chapter to make you an expert in all that Amazon Web
    Services or any other cloud provider has to offer. Hopefully, you have enough
    to get you going--and get you excited--about writing cloud-based applications
    using Java. For those wanting to go deeper, there are a number of great books,
    web pages, and so on to help you delve deeper into this rapidly changing and expanding
    area. In our next chapter, we'll return from the cloud and turn our attention
    to another great space for Java developers--your mobile phone.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们的应用相对简单，在一个章节的空间内也不可能让你成为亚马逊云服务或任何其他云服务提供商所提供的一切的专家。希望这足以让你开始——并激发你对使用Java编写云应用的热情。对于那些想要深入研究的人，有许多优秀的书籍、网页等等可以帮助你更深入地了解这个快速变化和扩展的领域。在我们下一章中，我们将从云服务中返回，并将注意力转向Java开发者另一个伟大的空间——你的手机。
