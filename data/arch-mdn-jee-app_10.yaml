- en: Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: So far, most of the topics covered in this book haven't dealt with the topic
    of security. This is an often overlooked topic that in some real-world projects
    only gets interest when it's already too late.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中讨论的大部分主题都没有涉及安全这个话题。这是一个经常被忽视的话题，在一些实际项目中，只有在为时已晚时才会引起关注。
- en: Developers as well as project managers see security as a necessary evil rather
    than as something providing big benefits to the business. Still, it's a topic
    that stakeholders must be made aware of.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员和项目经理将安全视为一种必要的恶，而不是为业务带来巨大利益的东西。尽管如此，它是一个利益相关者必须了解的话题。
- en: 'Quite a few requirements have changed in the age of the cloud and distributed
    applications. This chapter will look into the situation of the past, as well as
    today''s requirements. It will cover how security is realized using modern Java
    EE:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算和分布式应用的年代，许多要求都发生了变化。本章将探讨过去的情况以及今天的要求。它将涵盖如何使用现代Java EE实现安全：
- en: Security lessons learned from the past
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从过去学到的安全经验
- en: Enterprise security principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业安全原则
- en: Modern security solutions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代安全解决方案
- en: How to realize security using modern Java EE
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用现代Java EE实现安全
- en: Lessons learned from the past
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从过去学到的经验教训
- en: In today's world IT security is quite an important aspect. Most people have
    realized that information technology can cause a lot of harm if misused.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，IT安全是一个非常重要的方面。大多数人已经意识到，如果滥用，信息技术可以造成很多危害。
- en: The last half-century of computing contained a lot to learn from, in terms of
    security, and not only for enterprise software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去半个世纪的计算机领域，我们可以从安全方面学到很多东西，这不仅仅适用于企业软件。
- en: Let's look into a few lessons learned from the past of enterprise application
    development. In previous years, the biggest security issues were encryption and
    approaches on how to manage credentials.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下企业应用开发过去的一些经验教训。在过去的几年里，最大的安全问题在于加密和管理凭据的方法。
- en: Encrypting and signing data is an incredibly safe way of keeping secrets, if
    applied correctly. It solely depends on the used algorithms and the key lengths.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确应用，加密和签名数据是保持秘密的一种极其安全的方式。它完全取决于所使用的算法和密钥长度。
- en: There were quite a few encryption and hashing algorithms that turned out to
    not be secure enough. **DES** is an example, as well as the often-used **MD5**
    hashing algorithm. As of writing this book, **AES** with 192- or 256-bit key lengths
    is considered secure. For the hashing algorithm, **SHA-2** or **-3** with at least
    256 bits is advised.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多加密和散列算法最终证明不够安全。**DES**是一个例子，以及常用的**MD5**散列算法。截至本书编写时，**AES**使用192位或256位密钥长度被认为是安全的。对于散列算法，建议使用至少256位的**SHA-2**或**SHA-3**。
- en: User credentials that are stored as part of the application must not be stored
    in plain text. There have been too many security breaches in the past that especially
    targeted databases where the passwords resided. Also, simply hashing passwords
    without providing proper password salts is discouraged.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序一部分存储的用户凭据不得以纯文本形式存储。过去已经发生了太多的安全漏洞，特别是针对存储密码的数据库。此外，简单地散列密码而不提供适当的密码**盐**是不被鼓励的。
- en: In general, it's highly advisable for enterprise developers not to implement
    security functionality themselves if they can avoid it. The idea of companies
    was to create their own security implementations that weren't used anywhere else
    and, therefore, provide *security by obscurity*. This, however, turns out to have
    had the opposite effect, and, unless security experts are involved, in fact leads
    to, less secure solutions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于企业开发者来说，如果可能的话，最好不要自己实现安全功能。公司的想法是创建自己的安全实现，这些实现没有在其他地方使用过，因此提供了一种*隐蔽性安全*。然而，这实际上产生了相反的效果，除非有安全专家的参与，否则实际上会导致更不安全的解决方案。
- en: The vast majority of enterprise security demands don't require their own, custom
    implementations. Enterprise frameworks and the implementations thereof already
    ship with corresponding functionality that has been well-tested in numerous use
    cases. We will have a look at these APIs for Java Enterprise later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数企业安全需求不需要他们自己的、定制的实现。企业框架及其实现已经包含了经过众多用例良好测试的相应功能。我们将在本章后面探讨这些Java企业版的API。
- en: If the application requires the custom use of encryption, then implementations
    provided by runtime or third-party dependencies must be used. The Java platform
    offers the **Java Cryptography Extension** (**JCE**) for this reason. It provides
    implementations for modern encryption and hashing algorithms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要自定义加密的使用，那么必须使用运行时或第三方依赖项提供的实现。出于这个原因，Java平台提供了 **Java Cryptography
    Extension** (**JCE**)。它提供了现代加密和散列算法的实现。
- en: In general, applications should only process and store secure information when
    it's absolutely required by the business use case. In particular, for authentication
    and authorization, there are ways that avoid storing user credentials in multiple
    systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序只有在业务用例绝对需要时才应处理和存储安全信息。特别是对于身份验证和授权，有一些方法可以避免在多个系统中存储用户凭据。
- en: Security in a modern world
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代世界的安全
- en: More distribution of applications leads to higher demand in securing communication.
    The integrity of exchanged information needs to be ensured. Similarly, people
    are aware of the necessity of encryption, especially when it comes to encrypting
    communication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的更多分布导致对保护通信的需求更高。交换信息的完整性需要得到保证。同样，人们意识到加密的必要性，尤其是在加密通信时。
- en: What possibilities do engineers have in today's enterprise world? What principles
    should they follow when realizing security?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的商业世界中，工程师有哪些可能性？他们在实现安全时应该遵循哪些原则？
- en: Security principles
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全原则
- en: There are some basic principles that should be followed when implementing security
    in enterprise applications. The following list aims to give the basic ideas, and
    is not intended to be exhaustive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中实现安全时应遵循一些基本原则。以下列表旨在提供基本思想，并不旨在详尽无遗。
- en: Encrypt communication
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密通信
- en: First of all, it's important to mention that external communication that happens
    over the internet must be encrypted. The usual way of doing this is via TLS using
    trusted certificates. This is possible for HTTP as well as for other communication
    protocols.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要提到，在互联网上发生的所有外部通信都必须加密。通常的做法是通过TLS使用受信任的证书来完成。这对于HTTP以及其他通信协议都是可能的。
- en: The authenticity of the certificates used must be verified at runtime by the
    implementation. They have to be assured by a trusted internal or external certificate
    authority.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的证书的真实性必须在运行时由实现进行验证。它们必须由受信任的内部或外部证书颁发机构保证。
- en: Insecurely accepting any certificates in the application should be avoided,
    for production as well as other environments. This implies that properly signed
    certificates are being provided and used for the communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中不安全地接受任何证书应避免，无论是生产环境还是其他环境。这意味着提供了并使用了正确签名的证书来进行通信。
- en: Delegate security concerns
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委派安全关注
- en: In terms of storing user information, today's approach is to delegate authentication
    and authorization to security providers if possible. This means that an enterprise
    application doesn't store security information, but asks a third-party, a trusted
    security provider.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储用户信息方面，今天的方法是在可能的情况下将身份验证和授权委派给安全提供者。这意味着企业应用程序不会存储安全信息，而是请求第三方，一个受信任的安全提供者。
- en: This is especially interesting in distributed environments, where multiple applications
    offer potential endpoints to the outside world. The secure information moves to
    a single point of responsibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式环境中，这一点尤其有趣，因为多个应用程序为外部世界提供了潜在的端点。安全信息移动到单一的责任点。
- en: Security concerns are usually not a part of the core business logic. The application
    will ask the trusted security provider system to validate the security of user
    requests. The security provider acts as a secure single point of responsibility.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题通常不是核心业务逻辑的一部分。应用程序将请求受信任的安全提供者系统验证用户请求的安全性。安全提供者充当安全单一责任点。
- en: There are decentralized security protocols, such as **OAuth** or **OpenID**,
    that implement this approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着去中心化的安全协议，例如 **OAuth** 或 **OpenID**，它们实现了这种方法。
- en: Delegating the responsibility to a trusted security provider eliminates the
    need to share passwords within enterprise systems. Users identify directly against
    security providers. Applications that require security information about a user
    will be provided session tokens that do not directly contain confidential data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将责任委托给受信任的安全提供商消除了在企业系统中共享密码的需要。用户直接针对安全提供商进行身份验证。需要了解用户安全信息的应用程序将提供不直接包含机密数据的会话令牌。
- en: This principle, however, mainly targets communication that includes application
    users as persons.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一原则主要针对包括应用程序用户作为个人的通信。
- en: Treat user credentials properly
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确处理用户凭证
- en: If for some reason the application manages user authentication itself, it should
    never permanently store passwords and tokens in plain text. This introduces a
    severe security risk. Even if an application or database has sufficient protection
    from the outside world, it's important to protect the credentials from internal
    leaks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因应用程序自行管理用户认证，它绝不应该永久以明文形式存储密码和令牌。这引入了严重的安全风险。即使应用程序或数据库对外部世界有足够的保护，保护凭证免受内部泄露也很重要。
- en: Passwords that need to be managed within the application must be stored only
    via appropriate hashing algorithms and approaches such as **salting**. Doing so
    prevents any malicious attack, from both the inside as well the outside of the
    coorporation. It's advisable to consult security information organizations such
    as **Open Web Application Security Project** (**OWASP**). They provide the modern
    advice for security approaches and algorithms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在应用程序内部管理的密码必须仅通过适当的哈希算法和如**盐值**等方法存储。这样做可以防止来自公司内部和外部任何恶意攻击。建议咨询像**开放网络应用安全项目**（**OWASP**）这样的安全信息组织。它们提供关于安全方法和算法的现代建议。
- en: Avoid storing credentials in version control
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在版本控制中存储凭证
- en: For the same reason that you should not treat secure credentials poorly, developers
    shouldn't store clear credentials in the version-controlled project repository.
    Even if the repository is hosted company-internally, this introduces a security
    risk.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你不应该轻视安全凭证一样，开发者也不应该在版本控制的项目仓库中存储明文凭证。即使仓库是在公司内部托管，这也引入了安全风险。
- en: The credentials will be visible permanently in the repository's history.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证将永久地显示在仓库的历史记录中。
- en: As shown in [Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container
    and Cloud Environments with Java EE*, there are features of cloud environments
    that inject secret configuration values into applications. This functionality
    can be used to provide secret credentials that are configured externally.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)“使用Java EE的容器和云环境”所示，云环境具有将秘密配置值注入应用程序的功能。此功能可用于提供外部配置的秘密凭证。
- en: Include tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含测试
- en: The security mechanisms that are a responsibility of the application need to
    be system-tested properly. Any included authentication and authorization must
    be verified as part of the Continuous Delivery pipeline. This means that you should
    verify the functionality in automated tests, to not only verify it once, but continuously,
    after changes in the software.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要负责的安全机制需要得到适当的系统测试。任何包含的认证和授权都必须作为持续交付管道的一部分进行验证。这意味着你应该在自动化测试中验证功能，不仅验证一次，而且在软件更改后持续验证。
- en: It's especially important for security-relevant tests to include negative tests.
    For example, the test must verify that incorrect credentials or insufficient permissions
    do not allow you to perform specific application functionality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与安全相关的测试，包括负面测试尤为重要。例如，测试必须验证错误的凭证或权限不足不允许你执行特定的应用程序功能。
- en: Possibilities and solutions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能性和解决方案
- en: After a few basic but important security principles, let's have a look at the
    possible security protocols and solutions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个基本但重要的安全原则之后，让我们来看看可能的安全协议和解决方案。
- en: Encrypted communication
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密通信
- en: Encrypted communication usually means that the communications are encrypted
    using **TLS encryption**, as part of the communication protocol in the transport
    layer. Certificates are used to encrypt and sign the communication. Of course,
    it's crucial to be able to rely on the certificates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加密通信通常意味着通信使用**TLS加密**，作为传输层通信协议的一部分。证书用于加密和签名通信。当然，能够依赖证书至关重要。
- en: Companies often operate their own certificate authorities and pre-install their **root
    CA** in their computers and software. This certainly makes sense for internal
    networks. It reduces overhead and potential costs compared to requesting certificates
    for all internal services from an official authority.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常运营自己的证书颁发机构，并在他们的计算机和软件中预先安装**根CA**。这对于内部网络来说确实是有道理的。与从官方机构请求所有内部服务的证书相比，这减少了开销和潜在的成本。
- en: Certificates that are *publicly trusted* are required to be signed by one of
    the official certificate authorities that come pre-installed with operating systems
    or platforms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要由操作系统或平台预先安装的官方证书颁发机构之一签名的**公开受信任**的证书。
- en: Encrypted communication does not authenticate users, unless individual client
    certificates are being used. It lays the foundation for a secure, trusted communication.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 加密通信不验证用户，除非正在使用单个客户端证书。它为安全、可信的通信奠定了基础。
- en: Protocol-based authentication
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于协议的认证
- en: Some communication protocols come with authentication capabilities, such as
    HTTP with basic or digest authentication. These functionalities are part of the
    communication protocol and are usually well-supported in tools and frameworks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通信协议自带认证功能，例如带有基本或摘要认证的HTTP。这些功能是通信协议的一部分，通常在工具和框架中得到很好的支持。
- en: They usually rely on the communication being already securely encrypted, otherwise
    this would make the information accessible for parties that can read it, should
    they intercept the communication. This is important to mention to application
    developers to ensure that protocol-based authentication is provided via encrypted
    communication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常依赖于通信已经被安全加密，否则这将使信息对能够读取它的各方可访问，如果他们拦截了通信。这一点对于确保通过加密通信提供基于协议的认证，对于应用程序开发者来说非常重要。
- en: The credentials for protocol-based security are usually provided directly in
    every message. This simplifies client calls as there is no need for several authentication
    steps, such as in exchanging tokens. The first client invocation can already exchange
    information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于协议的安全凭证通常直接在每条消息中提供。这简化了客户端调用，因为不需要进行多个认证步骤，例如在交换令牌时。第一个客户端调用就可以交换信息。
- en: Decentralized security
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化安全
- en: Other approaches that do not directly include credentials in the client invocations
    will fetch security tokens first and issue the actual communication with the token
    being provided afterwards. This goes in the direction of decentralized security.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不直接在客户端调用中包含凭证的方法会首先获取安全令牌，然后在提供令牌之后发出实际通信。这朝着去中心化安全的方向发展。
- en: In order to decouple security from the application, enterprise systems can include
    identity providers as a central point for authentication or authorization, respectively.
    This delegates the security concerns from the application to a provider.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将安全与应用程序解耦，企业系统可以将身份提供者作为认证或授权的中心点，分别包括在内。这把安全担忧从应用程序委托给提供者。
- en: The identity providers authorize third parties, such as enterprise applications,
    without directly exchanging the credentials with them. The end users are redirected
    to the identity providers and don't hand the secure information to the enterprise
    application. Third-parties only receive the information when the access has been
    permitted, contained in tokens that they can verify.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 身份提供者授权第三方，如企业应用程序，而无需与他们直接交换凭证。最终用户被重定向到身份提供者，不会将安全信息交给企业应用程序。第三方只有在获得访问权限时才会收到信息，这些信息包含在它们可以验证的令牌中。
- en: This three-way authentication avoids concerning the enterprise application with
    security responsibilities. The responsibility to verify whether the information
    that the user provides was correct moves to the identity provider.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种三方认证避免了让企业应用程序承担安全责任。验证用户提供的资料是否正确，责任转移到身份提供者。
- en: One example of this method is **single sign on** (**SSO**) mechanisms. They're
    used quite often in bigger companies to require users to authenticate only once
    and reuse the information in all services that are secured by an SSO. The SSO
    system authenticates the user and provides the required user information to the
    corresponding applications. Users just need to log in once.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的例子之一是**单点登录**（**SSO**）机制。它们在大公司中相当常用，要求用户只进行一次身份验证，并在所有由SSO保护的服务中重复使用信息。SSO系统验证用户并向相应的应用程序提供所需用户信息。用户只需登录一次。
- en: Another approach is to use decentralized access delegation protocols, such as
    OAuth, OpenID, and OpenID Connect. They represent three-way security workflows
    to exchange security information between clients, third-party applications, and
    the identity provider. The idea is similar to single sign on mechanisms. However,
    these protocols enable users to decide which individual application will receive
    the user's information. The applications receive user access tokens, for example,
    in the form of **JSON Web Tokens**, that are validated via the identity provider,
    instead of the actual credentials.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用分散式访问委托协议，例如OAuth、OpenID和OpenID Connect。它们代表客户端、第三方应用程序和身份提供者之间交换安全信息的三方安全工作流程。这种想法与单点登录机制类似。然而，这些协议允许用户决定哪个单独的应用程序将接收用户信息。应用程序接收用户访问令牌，例如，以**JSON
    Web Tokens**的形式，这些令牌通过身份提供者进行验证，而不是实际的凭证。
- en: The decentralized access delegation protocols and their implementation are beyond
    the scope of this book. The responsibility for enterprise systems is to intercept
    and redirect the user authentication to the identity provider. Depending on the
    system architecture, this is the responsibility of a proxy server or the application
    itself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分散式访问委托协议及其实现超出了本书的范围。企业系统的责任是拦截并重定向用户身份验证到身份提供者。根据系统架构，这可能是由代理服务器或应用程序本身负责。
- en: There are open source solutions out there that implement decentralized security.
    An interesting technology is **Keycloak** which is an Identity and Access Management
    solution. It ships with various client adapters and supports standard protocols,
    such as OAuth or OpenID Connect, what makes it easy to secure applications and
    services.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有开源解决方案实现了分散式安全。一项有趣的技术是**Keycloak**，它是一个身份和访问管理解决方案。它附带各种客户端适配器，并支持标准协议，如OAuth或OpenID
    Connect，这使得保护应用程序和服务变得容易。
- en: Proxies
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Proxy servers that encapsulate communication with enterprise applications can
    add security aspects, such as encrypting the communication. Web proxy servers,
    for example, support TLS encryption over HTTPS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 封装与企业应用程序通信的代理服务器可以增加安全方面，例如加密通信。例如，Web代理服务器支持通过HTTPS的TLS加密。
- en: The question is whether engineers want to make a difference between network,
    internal and external communication. Communication in an intranet network is often
    unencrypted. Depending on the nature of the exchanged information, internet communication
    should, in most cases, be encrypted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是工程师是否想要在网络、内部和外部通信之间做出区分。内部网络中的通信通常是未加密的。根据交换信息的性质，在大多数情况下，互联网通信应该是加密的。
- en: Proxy servers can be used to terminate the encryption at the network boundaries,
    so-called **TLS termination**. The proxy server encrypts all outgoing information
    and decrypts all incoming information, respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务器可以用于在网络边界终止加密，即所谓的**TLS终止**。代理服务器分别加密所有传出信息和解密所有传入信息。
- en: It's equally possible to re-encrypt the communication using different certificates
    for different networks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有可能使用不同网络的不同证书重新加密通信。
- en: Integration in modern environments
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代环境中的集成
- en: Modern environments aim to support today's security needs. Container orchestration
    frameworks offer the provisioning of software proxy servers and gateways that
    expose the service; for example, Kubernetes ingress resources, as well as OpenShift routes support
    TLS encryption for cluster-external traffic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现代环境旨在支持今天的网络安全需求。容器编排框架提供软件代理服务器和网关的配置，这些服务器和网关公开服务；例如，Kubernetes的**ingress**资源以及OpenShift的**routes**支持集群外部流量的TLS加密。
- en: In order to provide secret values such as credentials or private keys, orchestration
    frameworks offer the functionality of secrets. As seen previously, this enables
    us to separately provide secret configurations into the environment. [Chapter
    5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container and Cloud Environments
    with Java EE* examined how this is realized.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供诸如凭证或私钥之类的秘密值，编排框架提供了“秘密”功能。如前所述，这使我们能够将秘密配置分别提供到环境中。[第5章](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)，*Java
    EE的容器和云环境*探讨了这是如何实现的。
- en: This enables applications, as well as the configuration in general, to use secret
    values. The secrets can be injected into the container runtimes, if needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得应用程序以及一般的配置可以使用秘密值。如果需要，这些秘密值可以注入到容器运行时。
- en: Implementing security in Java EE applications
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java EE应用程序中实现安全
- en: After seeing the most common security approaches of today's world, let's have
    a look into how security is implemented using Java EE.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了当今世界最常见的安全方法之后，让我们看看如何使用Java EE实现安全。
- en: Of all the Java versions, Java EE version 8 aimed to address security aspects.
    It contains a security API that simplifies and unifies the integration for developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有Java版本中，Java EE版本8旨在解决安全方面的问题。它包含一个安全API，该API简化并统一了开发者的集成。
- en: Transparent security
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明安全
- en: In the simplest way, security in web applications can be implemented by proxy
    web servers, such as **Apache** or **nginx**. In that case, the security responsibilities
    are transparent to the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，可以通过代理Web服务器，如**Apache**或**nginx**，在Web应用程序中实现安全。在这种情况下，安全责任对应用程序来说是透明的。
- en: This is often the case if the enterprise application doesn't have to deal with
    users as domain entities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果企业应用程序不需要处理用户作为域实体，这种情况通常会出现。
- en: Servlets
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlets
- en: In order to secure web services offered by the Java EE application, usually
    security on the servlet layer is used. This is the case for all technology that
    is built on top of servlets such as JAX-RS. Security features are configured using
    the servlet deployment descriptor, that is, the `web.xml`file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护Java EE应用程序提供的Web服务，通常在servlet层使用安全。对于所有建立在servlet之上的技术，如JAX-RS，也是如此。安全功能是通过servlet部署描述符配置的，即`web.xml`文件。
- en: This can happen in several ways such as form-based authentication, HTTP basic
    access authentication, or client certificates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过多种方式发生，例如基于表单的认证、HTTP基本访问认证或客户端证书。
- en: Similarly, security solutions such as Keycloak ship their own implementations
    of adapters and servlet filters. Developers usually just need to configure these
    components to use the security provider.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，像Keycloak这样的安全解决方案会提供自己的适配器和servlet过滤器的实现。开发者通常只需要配置这些组件以使用安全提供者。
- en: Java principals and roles
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java受保护实体和角色
- en: Java security principals and roles represent identities and authorization roles,
    respectively. Principals and roles are usually configured in the application server
    in vendor-specific ways. Authenticated requests are bound to a principal during
    the execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java安全受保护实体和角色分别代表身份和授权角色。受保护实体和角色通常以厂商特定的方式在应用服务器中配置。在执行过程中，认证请求绑定到受保护实体。
- en: 'One example of using the associated roles within the execution workflow is
    by using common security annotations such as `@RolesAllowed`. This declarative
    approach checks whether the principal is authorized correctly and will otherwise
    result in a security exception:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行工作流程中使用相关角色的一个例子是使用常见的安全注解，如`@RolesAllowed`。这种声明式方法检查受保护实体是否被正确授权，否则将导致安全异常：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Besides vendor-specific solutions, users and roles can be extended to contain
    domain-specific information. The `Principal` security type is enhanced in order
    to do so.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了厂商特定的解决方案之外，用户和角色可以扩展以包含特定领域的相关信息。为了实现这一点，`Principal`安全类型得到了增强。
- en: It is possible to inject the principal that is identified by its name and to
    provide a specialization. The container takes care of the user identification,
    for example, by using form-based authentication.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以注入通过其名称识别的受保护实体，并提供一个特殊化。容器负责用户识别，例如，通过使用基于表单的认证。
- en: This approach was especially advised prior to Java EE version 8\. However, modern
    applications will likely use identity stores to represent domain-specific user
    information.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在Java EE版本8之前特别推荐。然而，现代应用程序可能会使用身份存储来表示特定领域的用户信息。
- en: JASPIC
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JASPIC
- en: The **Java Authentication Service Provider Interface for Containers** (**JASPIC**)
    is a standard that defines authentication service providers' interfaces. It comprises
    so-called **Server Authentication Modules** (**SAM**), pluggable authentication
    components, which are added to the application server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java容器身份验证服务提供者接口**（**JASPIC**）是一个定义身份验证服务提供者接口的标准。它包括所谓的**服务器身份验证模块**（**SAM**），可插入的身份验证组件，这些组件被添加到应用程序服务器中。'
- en: This standard offers powerful and flexible ways how to implement authentication.
    Server vendors can ship their own implementation of SAMs. However, implementing
    authentication modules using the JASPIC standard is seen as quite cumbersome by
    a lot of developers. This is why the JASPIC standard is not widely used in enterprise
    projects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本标准提供了强大且灵活的方式来实现身份验证。服务器供应商可以提供他们自己的SAMs实现。然而，许多开发者认为使用JASPIC标准实现身份验证模块相当繁琐。这就是为什么JASPIC标准在企业项目中并不广泛使用。
- en: Security API
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全API
- en: The Security API 1.0 is shipped with Java EE 8\. The idea for this standard
    was to provide modern security approaches that are simpler to use for developers.
    These are implemented in vendor-independent ways, without the need to lock in
    to specific solutions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安全API 1.0与Java EE 8一起发布。这个标准的想法是为开发者提供更简单易用的现代安全方法。这些方法以供应商独立的方式实现，无需锁定到特定解决方案。
- en: Let's have a look into what the Security API includes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看安全API包括哪些内容。
- en: Authentication mechanisms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证机制
- en: First of all, the Security API includes `HttpAuthenticationMechanism`, which
    provides the features of the JASPIC standard with much less development effort
    needed. It's specified to be used in a servlet context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安全API包括`HttpAuthenticationMechanism`，它以较少的开发工作量提供了JASPIC标准的特性。它被指定用于servlet上下文。
- en: Application developers are only required to define a custom `HttpAuthenticationModule` and
    to configure the authentication in the `web.xml` deployment descriptor. We will
    have a look at a custom security implementation later in this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者只需要定义一个自定义的`HttpAuthenticationModule`并在`web.xml`部署描述符中配置身份验证。我们将在本章后面讨论自定义安全实现。
- en: The Java EE container already ships with predefined HTTP authentication mechanisms
    for basic, default, and custom form authentication. The developers can use this
    predefined functionality with minimal effort. Before we see an example, let's
    see how to store the user information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE容器已经预装了基本、默认和自定义表单身份验证的预定义HTTP身份验证机制。开发者可以以最小的努力使用这些预定义功能。在我们看到示例之前，让我们看看如何存储用户信息。
- en: Identity stores
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份存储
- en: The concept of identity stores was also added with the Security API. Identity
    stores provide the authentication and authorization information of users in lightweight,
    portable ways. They offer a unified way to access this information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安全API中也增加了身份存储的概念。身份存储以轻量级、便携的方式提供用户的身份验证和授权信息。它们提供了一种统一的方式来访问这些信息。
- en: The `IdentityStore` type validates a caller's credentials and accesses its information.
    Similarly to HTTP authentication mechanisms, the application containers are required
    to provide identity stores for LDAP and database access.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityStore`类型验证调用者的凭证并访问其信息。类似于HTTP身份验证机制，应用程序容器需要为LDAP和数据库访问提供身份存储。'
- en: 'The following shows an example using the container-provided security functionality:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了使用容器提供的安全功能的一个例子：
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Application developers only need to provide this annotated class. This approach
    provides simple and straightforward security definitions for test purposes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者只需要提供这个注解类。这种方法为测试目的提供了简单直接的安全定义。
- en: Usual enterprise projects arguably require more custom approaches. Organizations
    usually have custom ways of authentication and authorization that need to be integrated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，企业项目可能需要更多的自定义方法。组织通常有自己的身份验证和授权方式，这些方式需要集成。
- en: Custom security
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义安全
- en: The following shows a more sophisticated example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了更复杂的情况。
- en: In order to provide custom authentication, application developers implement
    a custom `HttpAuthenticationMechanism`, especially the `validateRequest()` method.
    The class only has to be visible to the container as a CDI bean. The rest is done
    by the application container. This simplifies the security integration for developers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供自定义认证，应用程序开发者实现了一个自定义的`HttpAuthenticationMechanism`，特别是`validateRequest()`方法。该类只需作为CDI
    bean对容器可见即可。其余的工作由应用程序容器完成。这简化了开发者的安全集成。
- en: 'The following shows a basic example, with *pseudo code* representing the actual
    authentication:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本示例，其中使用**伪代码**表示实际的认证：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `validateRequest()` implementation accesses the user information contained
    in the HTTP request, for example via the HTTP headers. It delegates the validation
    to the identity store using the `IdentityStoreHandler`. The validation result
    contains the result that is provided to the security HTTP message context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateRequest()`实现访问HTTP请求中包含的用户信息，例如通过HTTP头。它使用`IdentityStoreHandler`将验证委托给身份存储库。验证结果包含提供给安全HTTP消息上下文的结果。'
- en: Depending on the requirements, a custom identity handler implementation is required
    as well. It can provide custom authentication and authorization methods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，还需要实现自定义身份处理程序实现。它可以提供自定义认证和授权方法。
- en: If decentralized security protocols, such as OAuth, are being used, a custom
    identity handler will implement the security access token validation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用去中心化安全协议，如OAuth，则自定义身份处理程序将实现安全访问令牌验证。
- en: 'The following shows a custom identity store:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一个自定义身份存储库：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `web.xml` servlet deployment descriptor is used to specify the secure resources.
    The application container takes care of the integration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`web.xml` servlet部署描述符来指定受保护资源。应用程序容器负责集成：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An HTTP authentication mechanism provides a straightforward, yet flexible, way
    to implement JASPIC security. Its implementation is simpler compared to a plain
    JASPIC approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP认证机制提供了一种简单而灵活的方式来实现JASPIC安全。与纯JASPIC方法相比，其实现更简单。
- en: It provides the possibility of intercepting communication flows and can integrate
    the application with third-party security providers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了拦截通信流的可能性，可以将应用程序与第三方安全提供商集成。
- en: Accessing security information
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问安全信息
- en: Enterprise applications sometimes need the functionality to access information
    about the user authorization as part of the business logic. The Security API enables
    us to retrieve this information in a uniform way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序有时需要功能来访问用户授权信息，作为业务逻辑的一部分。安全API使我们能够以统一的方式检索这些信息。
- en: It contains the `SecurityContext` type that provides a programmatic way to retrieve
    information about the caller principal and its roles. The `SecurityContext` is
    injectable into any managed beans. It also integrates with the servlet authentication
    configuration and provides information about whether the caller is allowed to
    access a specific HTTP resource.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含`SecurityContext`类型，该类型提供了一种程序化方式来检索有关调用者主体及其角色的信息。`SecurityContext`可以注入到任何管理bean中。它还与servlet认证配置集成，并提供有关调用者是否允许访问特定HTTP资源的信息。
- en: 'The following shows an example usage of the `SecurityContext`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了`SecurityContext`的一个示例用法：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The idea of the Security API is that it integrates with the existing functionality
    from previous Java EE versions. This implies, for example, that the `@RolesAllowed` annotation
    uses the same role information as the `SecurityContext`. Developers can continue
    to rely on the existing standard functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安全API的想法是与之前Java EE版本中的现有功能集成。这意味着，例如，`@RolesAllowed`注解使用与`SecurityContext`相同的角色信息。开发者可以继续依赖现有的标准功能。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In today's world, IT security is quite an important aspect. In the past, some
    of the biggest security issues were weak encryption and hashing algorithms, how
    passwords are persisted, and home-grown security implementations. A few important
    security principles include encrypting the communication, using external, trusted
    security providers for authentication and authorization, avoiding keeping credentials
    under version control, and including test scenarios that verify protection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，IT安全是一个非常重要的方面。在过去，一些最大的安全问题包括弱加密和散列算法、密码的持久化方式以及自制的安全实现。一些重要的安全原则包括加密通信、使用外部、可信的安全提供者进行认证和授权、避免在版本控制下保留凭证，以及包括验证保护的测试场景。
- en: Communication is usually encrypted in the transport layer using TLS. Used certificates
    should be signed correctly, either by a company-internal or official certificate
    authority. Other approaches includes using security features of the protocol layer,
    such as HTTP basic authentication on top of encrypted communication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通信通常在传输层使用TLS进行加密。使用的证书应该由公司内部或官方证书机构正确签名。其他方法包括使用协议层的安全功能，例如在加密通信之上使用HTTP基本认证。
- en: Decentralized security decouples authentication and authorization responsibilities
    from the applications by including trusted identity providers. Single sign on
    as well as decentralized access delegations protocols are examples for this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含可信的身份提供者，去中心化安全将认证和授权责任从应用程序中分离出来。单点登录以及去中心化访问委托协议是此类示例。
- en: Security in Java EE application boundaries is usually realized on top of Servlets.
    The Security API which was introduced in Java EE 8 aims to provide simpler, uniform
    approaches on how to tackle security in Java EE applications. HTTP authentication
    mechanisms are an example that provide easier usage of the powerful JASPIC functionality.
    Identity stores provide authentication and authorization information of users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE应用程序边界内实现安全通常是在Servlets之上进行的。Java EE 8中引入的Security API旨在提供更简单、统一的方法来处理Java
    EE应用程序中的安全问题。HTTP认证机制是提供更易用JASPIC功能的示例。身份存储提供用户的认证和授权信息。
- en: The idea of the Security API is to integrate with existing functionality and
    offer uniform access mechanisms. The included features should be sufficient to
    secure enterprise application on the HTTP side.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Security API的理念是与现有功能集成并提供统一的访问机制。包含的功能应该足够保护企业应用程序在HTTP方面的安全。
