- en: Chapter 5. Creating Your Own CES Framework with core.async
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用core.async创建您自己的CES框架
- en: In the previous chapter, it was alluded to that `core.async` operates at a lower
    level of abstraction when compared to other frameworks such as RxClojure or RxJava.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，提到`core.async`与其他框架如RxClojure或RxJava相比，在抽象级别上更低。
- en: This is because most of the time we have to think carefully about the channels
    we are creating as well as what types and sizes of buffers to use, whether we
    need pub/sub functionality, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数时候我们必须仔细思考我们创建的通道以及要使用的缓冲区类型和大小，是否需要pub/sub功能，等等。
- en: Not all applications require such level of control, however. Now that we are
    familiar with the motivations and main abstractions of `core.async` we can embark
    into writing a minimal CES framework using `core.async` as the underlying foundation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有应用程序都需要这种级别的控制。现在我们已经熟悉了`core.async`的动机和主要抽象，我们可以开始编写一个使用`core.async`作为底层基础的简单CES框架。
- en: By doing so, we avoid having to think about thread pool management as the framework
    takes care of that for us.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们避免了需要考虑线程池管理，因为框架为我们处理了这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a CES framework using `core.async` as its underlying concurrency strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`core.async`作为其底层并发策略构建CES框架
- en: Building an application that uses our CES framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个使用我们的CES框架的应用程序
- en: Understanding the trade-offs of the different approaches presented so far
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解到目前为止所提出的不同方法的权衡
- en: A minimal CES framework
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个最小化的CES框架
- en: Before we get start on the details, we should define at a high level what *minimal*
    means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，我们应该在较高层面上定义什么是*最小化*。
- en: 'Let''s start with the two main abstractions our framework will provide: behaviors
    and event streams.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的框架将提供的两个主要抽象开始：行为和事件流。
- en: If you can recall from [Chapter 1](part0015_split_000.html#page "Chapter 1. What
    is Reactive Programming?"), *What is Reactive Programming?*, behaviors represent
    continuous, time-varying values such as time or a mouse position behavior. Event
    streams, on the other hand, represent discrete occurrences at a point in time
    *T*, such as key press.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第1章](part0015_split_000.html#page "第1章。什么是响应式编程？")中的内容，*什么是响应式编程？*，行为代表连续、随时间变化的值，如时间或鼠标位置行为。另一方面，事件流代表在时间点T的离散事件，如按键。
- en: 'Next, we should think about what kinds of operations we would like to support.
    Behaviors are fairly simple so at the very minimum we need to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该考虑我们希望支持哪些类型的操作。行为相当简单，所以至少我们需要：
- en: Create new behaviors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的行为
- en: Retrieve the current value of a behavior
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取行为当前值
- en: Convert a behavior into an event stream
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行为转换为事件流
- en: 'Event streams have more interesting logic in play and we should at least support
    these operations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流有更复杂的逻辑，我们至少应该支持以下操作：
- en: Push/deliver a value down the stream
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值推送到流中
- en: Create a stream from a given interval
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定的时间间隔创建流
- en: Transform the stream with the `map` and `filter` operations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`map`和`filter`操作转换流
- en: Combine streams with `flatmap`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`flatmap`组合流
- en: Subscribe to a stream
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅到流
- en: This is a small subset but big enough to demonstrate the overall architecture
    of a CES framework. Once we're done, we'll use it to build a simple example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小的子集，但足够大，可以展示CES框架的整体架构。一旦完成，我们将用它来构建一个简单的示例。
- en: Clojure or ClojureScript?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure还是ClojureScript？
- en: 'Here we''ll shift gears and add another requirement to our little library:
    it should work both in Clojure and ClojureScript. At first, this might sound like
    a tough requirement. However, remember that `core.async`—the foundation of our
    framework—works both on the JVM and in JavaScript. This means we have a lot less
    work to do to make it happen.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将转换方向，并给我们的小库添加另一个要求：它应该既能在Clojure中运行，也能在ClojureScript中运行。起初，这可能会听起来像是一个艰巨的要求。然而，记住`core.async`——我们框架的基础——既可以在JVM上运行，也可以在JavaScript中运行。这意味着我们有很多工作要做来让它实现。
- en: 'It does mean, however, that we need to be capable of producing two artifacts
    from our library: a `jar` file and a JavaScript file. Luckily, there are leiningen
    plugins, which help us do that and we will be using a couple of them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着我们需要能够从我们的库中生成两个工件：一个`jar`文件和一个JavaScript文件。幸运的是，有leiningen插件可以帮助我们做到这一点，我们将使用其中几个：
- en: '`lein-cljsbuild` (see [https://github.com/emezeske/lein-cljsbuild](https://github.com/emezeske/lein-cljsbuild)):
    Leiningen plugin to make building ClojureScript easy'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lein-cljsbuild`（见 [https://github.com/emezeske/lein-cljsbuild](https://github.com/emezeske/lein-cljsbuild)）：用于简化
    ClojureScript 构建的 Leiningen 插件'
- en: '`cljx` (see [https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)):
    A preprocessor used to write portable Clojure codebases, that is, write a single
    file and output both `.clj` and `.cljs` files'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cljx`（见 [https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)）：一个用于编写可移植
    Clojure 代码库的预处理器，即编写一个文件并输出 `.clj` 和 `.cljs` 文件'
- en: You don't need to understand these libraries in great detail. We are only using
    their basic functionality and will be explaining the bits and pieces as we encounter
    them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要详细了解这些库。我们只使用它们的基本功能，并在遇到时会解释各个部分。
- en: 'Let''s get started by creating a new leiningen project. We''ll call our framework
    respondent—one of the many synonyms for the word reactive:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个新的 leiningen 项目。我们将我们的框架命名为 respondent——reactive 这个词的许多同义词之一：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to make a few changes to the `project.clj` file to include the dependencies
    and configurations we''ll be using. First, make sure the project dependencies
    look like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对 `project.clj` 文件进行一些修改，以包含我们将要使用的依赖项和配置。首先，确保项目依赖项看起来如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There should be no surprises here. Still in the project file, add the necessary
    plugins:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有任何惊喜。仍然在项目文件中，添加必要的插件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are the plugins that we've mentioned previously. By themselves they don't
    do much, however, and need to be configured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前提到的插件。它们本身并不做什么，但是需要配置。
- en: 'For `cljx`, add the following to the project file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `cljx`，请在项目文件中添加以下内容：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For example, based on the preceding rules, if we have a file called `src/cljx/core.cljx`
    and we run the preprocessor we will end up with the `target/classes/core.clj`
    and `target/classes/core.cljs` output files. The hooks, on the other hand, are
    simply a convenient way to automatically run `cljx` whenever we start a REPL session.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，根据前面的规则，如果我们有一个名为 `src/cljx/core.cljx` 的文件，并且运行预处理器，我们最终会得到 `target/classes/core.clj`
    和 `target/classes/core.cljs` 输出文件。另一方面，钩子（hooks）只是自动在启动 REPL 会话时运行 `cljx` 的便捷方式。
- en: 'The next part of the configuration is for `cljsbuild`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的下一部分是针对 `cljsbuild` 的：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`cljsbuild` provides leiningen tasks to compile Clojuresript source code into
    JavaScript. We know from our preceding `cljx` configuration that the `source.cljs`
    files will be under `target/classes`, so here we''re simply telling `cljsbuild`
    to compile all ClojureScript files in that directory and spit the contents to
    `target/main.js`. This is the last piece needed for the project file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`cljsbuild` 提供了 leiningen 任务，用于将 Clojuresript 源代码编译成 JavaScript。根据我们之前的 `cljx`
    配置，我们知道 `source.cljs` 文件将位于 `target/classes` 目录下，所以我们只是告诉 `cljsbuild` 编译该目录下的所有
    ClojureScript 文件，并将内容输出到 `target/main.js`。这是项目文件中需要的最后一部分。'
- en: 'Go ahead and delete these files created by the leiningen template as we won''t
    be using them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，请继续删除由 leiningen 模板创建的这些文件，因为我们不会使用它们：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, create a new `core.cljx` file under `src/cljx/respondent/` and add the
    following namespace declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/cljx/respondent/` 下创建一个新的 `core.cljx` 文件，并添加以下命名空间声明：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we start seeing `cljx` annotations. `cljx` is simply a text preprocessor,
    so when it is processing a file using `clj` rules—as seen in the configuration—it
    will keep the `s-`expressions preceded by the annotation `#+clj` in the output
    file, while removing the ones prefixed by `#+cljs`. The reverse process happens
    when using `cljs` rules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始看到 `cljx` 注释。`cljx` 只是一个文本预处理器，所以当它使用 `clj` 规则处理文件时——如配置中所示——它将在输出文件中保留由注释
    `#+clj` 前缀的 `s-` 表达式，同时删除由 `#+cljs` 前缀的。当使用 `cljs` 规则时，发生相反的过程。
- en: This is necessary because macros need to be compiled on the JVM, so they have
    to be included separately using the `:require-macros` namespace option when using
    ClojureScript. Don't worry about the `core.async` functions we haven't encountered
    before; they will be explained as we use them to build our framework.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为宏需要在 JVM 上编译，所以它们必须通过使用 `:require-macros` 命名空间选项单独包含。不要担心我们之前没有遇到的 `core.async`
    函数；我们将在使用它们构建我们的框架时解释它们。
- en: Also, note how we are excluding functions from the Clojure standard API as we
    wish to use the same names and don't want any undesired naming collisions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们如何排除 Clojure 标准 API 中的函数，因为我们希望使用相同的名称，并且不希望有任何不希望的命名冲突。
- en: This section set us up with a new project and the plugins and configurations
    needed for our framework. We're ready to start implementing it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为我们设置了一个新项目以及我们框架所需的插件和配置。我们准备好开始实现了。
- en: Designing the public API
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计公共API
- en: One of the requirements for behaviors we agreed on is the ability to turn a
    given behavior into an event stream. A common way of doing this is by sampling
    a behavior at a specific interval. If we take the *mouse position* behavior as
    an example, by sampling it every *x* seconds we get an event stream, which will
    emit the current mouse position at discrete points in time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对行为的要求之一是将给定行为转换为事件流的能力。一种常见的方法是在特定间隔采样行为。如果我们以*鼠标位置*行为为例，通过每*x*秒采样一次，我们得到一个事件流，该事件流将在离散的时间点发出当前鼠标位置。
- en: 'This leads to the following protocol:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下协议：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It has a single function, `sample`, which we described in the preceding code.
    There are more things we need to do with a behavior, but for now this will suffice.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`sample`的函数，我们在前面的代码中已经描述过。我们还需要对行为做更多的事情，但现在这已经足够了。
- en: 'Our next main abstraction is `EventStream`, which—based on the requirements
    seen previously—leads to the following protocol:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个主要抽象是`EventStream`，根据之前看到的需要，导致以下协议：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This gives us a few basic functions to transform and query an event stream.
    It does leave out the ability to subscribe to a stream. Don't worry, I didn't
    forget it!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一些基本函数来转换和查询事件流。但它确实省略了订阅流的能力。不用担心，我没有忘记它！
- en: 'Although, it is common to subscribe to an event stream, the protocol itself
    doesn''t mandate it and this is because the operation fits best in its own protocol:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，订阅事件流是常见的，但协议本身并没有强制要求这样做，这是因为这种操作最适合它自己的协议：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As far as subscriptions go, it is useful to have a way of unsubscribing from
    a stream. This can be implemented in a couple of ways, but `docstring` of the
    preceding function hints at a specific one: a token that can be used to unsubscribe
    from a stream. This leads to our last protocol:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于订阅，有一个从流中取消订阅的方法是有用的。这可以以几种方式实现，但前面函数的`docstring`暗示了一种特定的方法：一个可以用来取消订阅流的令牌。这导致我们最后的协议：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing tokens
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现令牌
- en: 'The token type is the simplest in the whole framework as it has got a single
    function with a straightforward implementation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌类型在整个框架中是最简单的，因为它只有一个具有直接实现的函数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It simply closes whatever channel it is given, stopping events from flowing
    through subscriptions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是关闭它所给的任何通道，停止事件通过订阅流动。
- en: Implementing event streams
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现事件流
- en: The event stream implementation, on the other hand, is the most complex in our
    framework. We'll tackle it gradually, implementing and experimenting as we go.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，事件流实现是我们框架中最复杂的。我们将逐步解决它，在前进的过程中实现和实验。
- en: 'First, let''s look at our main constructor function, `event-stream`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的主要构造函数，`event-stream`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `docstring` should be sufficient to understand the public API. What might
    not be clear, however, is what all the constructor arguments mean. From left to
    right, the arguments to `EventStream` are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstring`应该足以理解公共API。然而，可能不清楚所有构造函数参数的含义。从左到右，`EventStream`的参数是：'
- en: '`ch`: This is the `core.async` channel backing this stream.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch`: 这是支持此流的`core.async`通道。'
- en: '`multiple`: This is a way to broadcast information from one channel to many
    other channels. It''s a `core.async` concept we will be explaining shortly.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiple`: 这是一种将信息从一条通道广播到许多其他通道的方式。它是我们将要解释的`core.async`概念之一。'
- en: '`completed`: A Boolean flag indicating whether this event stream has completed
    and will not emit any new values.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completed`: 一个布尔标志，表示此事件流是否已完成且不会发出任何新值。'
- en: 'From the implementation, you can see that the multiple is created from the
    channel backing the stream. `multiple` works kind of like a broadcast. Consider
    the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现中，你可以看到`multiple`是从支持流的通道创建的。`multiple`有点像广播。考虑以下示例：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will make understanding the `EventStream` implementation easier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使理解`EventStream`实现更容易。
- en: 'Next, let''s have a look at what a minimal implementation of the `EventStream`
    looks like the following—make sure the implementation goes before the constructor
    function described earlier:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`EventStream`的最小实现是什么样的——确保实现位于前面描述的构造函数之前：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For now, we have chosen to implement only the `map` and `deliver` functions
    from the `IEventStream` protocol. This allows us to deliver values to the stream
    as well as transform those values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们选择只实现 `IEventStream` 协议中的 `map` 和 `deliver` 函数。这允许我们将值传递到流中，并转换这些值。
- en: However, this would not be very useful if we could not retrieve the values delivered.
    This is why we also implement the `subscribe` function from the `IObservable`
    protocol.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不能检索到传递的值，这将不会非常有用。这就是为什么我们还实现了 `IObservable` 协议中的 `subscribe` 函数。
- en: In a nutshell, `map` needs to take a value from the input stream, apply a function
    to it, and send it to the newly created stream. We do this by creating an output
    channel that taps on current `multiple`. We then use this channel to back the
    new event stream.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`map` 需要从输入流中取一个值，对其应用一个函数，并将其发送到新创建的流中。我们通过创建一个连接到当前 `multiple` 的输出通道来完成这个操作。然后我们使用这个通道来支持新的事件流。
- en: The `deliver` function simply puts the value into the backing channel. If the
    value is the namespaced keyword `::complete`, we update the `completed` atom and
    close the backing channel. This ensures the stream will not emit any other values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`deliver` 函数简单地将值放入支持通道。如果值是命名空间关键字 `::complete`，我们更新 `completed` 原子并关闭支持通道。这确保流不会发出任何其他值。'
- en: Finally, we have the `subscribe` function. The way subscribers are notified
    is by using an output channel tapped to backing `multiple`. We loop indefinitely
    calling the subscribing function whenever a new value is emitted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `subscribe` 函数。订阅者被通知的方式是通过使用连接到后端 `multiple` 的输出通道。我们无限循环调用订阅函数，每当发出新值时。
- en: We finish by returning a token, which will close the output channel once disposed,
    causing the `go-loop` to stop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过返回一个令牌来完成，这个令牌会在处置后关闭输出通道，导致 `go-loop` 停止。
- en: 'Let''s make sure that all this makes sense by experimenting with a couple of
    examples in the REPL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 REPL 中进行几个示例实验来确保所有这些内容都很有意义：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Excellent! We have a minimal, working implementation of our `IEventStream` protocol!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经实现了 `IEventStream` 协议的最小、工作版本！
- en: 'The next function we''ll implement is `filter` and it is very similar to `map`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的下一个函数是 `filter`，它与 `map` 非常相似：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The only difference is that we use the `filter>` function and `pred` should
    be a Boolean function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们使用 `filter>` 函数，而 `pred` 应该是一个布尔函数：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we witness, `es2` only emits a new value if and only if that value is an
    even number.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`es2` 只在值是偶数时发出新值。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are following along, typing the examples step by step, you will need
    to restart your REPL whenever we add new functions to any `deftype` definition.
    This is because `deftype` generates and compiles a Java class when evaluated.
    As such, simply reloading the namespace won't be enough.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在逐步跟随示例进行输入，每次我们在任何 `deftype` 定义中添加新函数时，你都需要重新启动你的 REPL。这是因为 `deftype` 在评估时会生成和编译一个
    Java 类。因此，仅仅重新加载命名空间是不够的。
- en: Alternatively, you can use a tool such as `tools.namespace` (see [https://github.com/clojure/tools.namespace](https://github.com/clojure/tools.namespace))
    that addresses some of these REPL reloading limitations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用像 `tools.namespace`（见 [https://github.com/clojure/tools.namespace](https://github.com/clojure/tools.namespace)）这样的工具，它解决了一些这些
    REPL 重新加载的限制。
- en: 'Moving down our list, we now have `flatmap`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的列表中向下移动，我们现在有 `flatmap`：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve encountered this operator before when surveying Reactive Extensions.
    This is what our docstring says about it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调查反应式扩展时已经遇到过这个操作符。这是我们的文档字符串对它的描述：
- en: '*Takes a function f from values in s to a new EventStream.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*将函数 f 从 s 中的值映射到新的 EventStream。*'
- en: '*Returns an EventStream containing values from all underlying streams combined.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*返回一个包含所有底层流值的 EventStream。*'
- en: This means `flatmap` needs to combine all the possible event streams into a
    single output event stream. As before, we tap a new channel to the `multiple`
    stream, but then we loop over the output channel, applying `f` to each output
    value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `flatmap` 需要将所有可能的事件流合并为单个输出事件流。和之前一样，我们向 `multiple` 流中连接一个新的通道，但然后我们在输出通道上循环，对每个输出值应用
    `f`。
- en: However, as we saw, `f` itself returns a new event stream, so we simply subscribe
    to it. Whenever the function registered in the subscription gets called, we deliver
    that value to the output event stream, effectively combining all streams into
    a single one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们所看到的，`f` 本身返回一个新的事件流，所以我们只需订阅它。每当注册在订阅中的函数被调用时，我们将该值传递到输出事件流中，实际上是将所有流合并为一个。
- en: 'Consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have a function, `range-es`, that receives a number `n` and returns an event
    stream that emits numbers from `0` to `n`. As before, we have a starting stream,
    `es1`, and a transformed stream created with `flatmap`, `es2`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `range-es` 的函数，它接收一个数字 `n` 并返回一个事件流，该流从 `0` 到 `n` 发射数字。和之前一样，我们有一个起始流
    `es1` 和通过 `flatmap` 创建的转换流 `es2`。
- en: We can see from the preceding output that the stream created by `range-es` gets
    flattened into `es2` allowing us to receive all values by simply subscribing to
    it once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中我们可以看到，由 `range-es` 创建的流被扁平化为 `es2`，这使得我们只需订阅一次就能接收所有值。
- en: 'This leaves us with single function from `IEventStream` left to implement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了我们从 `IEventStream` 中需要实现的单一函数：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`completed?` simply returns the current value of the `completed` atom. We are
    now ready to implement behaviors.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`completed?` 简单地返回 `completed` 原子的当前值。我们现在可以开始实现行为。'
- en: Implementing behaviors
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现行为
- en: 'If you recall, the `IBehavior` protocol has a single function called `sample`
    whose docstring states: *Turns this Behavior into an EventStream from the sampled
    values at the given interval*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`IBehavior` 协议有一个名为 `sample` 的单一函数，其文档字符串说明：*将此行为转换为从给定间隔的采样值生成的事件流*。
- en: 'In order to implement `sample`, we will first create a useful helper function
    that we will call `from-interval`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `sample`，我们首先将创建一个有用的辅助函数，我们将称之为 `from-interval`：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `docstring` function should be clear enough at this stage, but we would
    like to ensure we understand its behavior correctly by trying it at the REPL:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`docstring` 函数应该足够清晰，但我们希望通过在 REPL 中尝试它来确保我们正确理解其行为：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As expected, `es1` emits integers starting at zero at 500-millisecond intervals.
    By default, it would emit numbers indefinitely; therefore, we keep a reference
    to the token returned by calling `subscribe`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`es1` 以 500 毫秒的间隔从零开始发射整数。默认情况下，它将无限期地发射数字；因此，我们保留调用 `subscribe` 返回的令牌的引用。
- en: This way we can dispose it whenever we're done, causing `es-1` to complete and
    stop emitting items.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在完成时将其丢弃，导致 `es-1` 完成并停止发射项目。
- en: 'Next, we can finally implement the `Behavior` type:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们最终可以实现 `Behavior` 类型：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A behavior is created by passing it a function. You can think of this function
    as a generator responsible for generating the next value in this event stream.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个函数来创建行为。你可以将这个函数视为一个生成器，负责生成此事件流中的下一个值。
- en: This generator function will be called whenever we (1) `deref` the `Behavior`
    or (2) at the interval given to `sample`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器函数将在我们（1）`deref` `Behavior` 或（2）在 `sample` 给定的间隔时被调用。
- en: 'The `behavior` macro is there for convenience and allows us to create a new
    `Behavior` without wrapping the body in a function ourselves:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`behavior` 宏是为了方便而存在的，它允许我们创建一个新的 `Behavior`，而无需我们自己将主体包装在函数中：'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we defined `time-behavior` that always contains the
    current system time. We can then turn this behavior into a stream of discrete
    events by using the `sample` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了 `time-behavior`，它始终包含当前系统时间。然后我们可以通过使用 `sample` 函数将此行为转换为离散事件的流：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember to keep a reference to the subscription token when dealing with
    infinite streams such as the ones created by `sample` and `from-interval`, or
    else you might incur undesired memory leaks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在处理像 `sample` 和 `from-interval` 创建的无穷流时保留订阅令牌的引用，否则你可能会遇到不希望的内存泄漏。
- en: Congratulations! We have a working, minimal CES framework using `core.async`!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经使用 `core.async` 创建了一个工作、最小化的 CES 框架！
- en: We didn't prove it works with ClojureScript, however, which was one of the main
    requirements early on. That's okay. We will be tackling that soon by developing
    a simple ClojureScript application, which makes use of our new framework.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有证明它可以用 ClojureScript 实现，这最初是主要要求之一。没关系。我们将通过开发一个简单的 ClojureScript 应用程序来解决它，该应用程序将使用我们新的框架。
- en: 'In order to do this, we need to deploy the framework to our local Maven repository.
    From the project root, type the following `lein` command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将框架部署到我们的本地 Maven 仓库。从项目根目录，输入以下 `lein` 命令：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exercises
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The following sections have a few exercises for you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节有一些练习供你完成。
- en: Exercise 5.1
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.1
- en: 'Extend our current `EventStream` implementation to include a function called
    `take`. It works much like Clojure''s core `take` function for sequences: it will
    take `n` items from the underlying event stream after which it will stop emitting
    items.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们当前的 `EventStream` 实现扩展以包含一个名为 `take` 的函数。它的工作方式与 Clojure 的核心 `take` 函数对序列的处理非常相似：它将从底层事件流中取出
    `n` 个项目，之后将停止发出项目。
- en: 'A sample interaction, which takes the first five items emitted from the original
    event stream, is shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了从原始事件流中发出的前五个项目的示例交互：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keeping some state might be useful here. Atoms can help. Additionally, try to
    think of a way to dispose of any unwanted subscriptions required by the solution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里保留一些状态可能是有用的。原子可以有所帮助。此外，尝试想出一种方法来处理任何由解决方案要求的未使用的订阅。
- en: Exercise 5.2
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.2
- en: In this exercise, we will add a function called `zip` that zips together items
    emitted from two different event streams into a vector.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加一个名为 `zip` 的函数，该函数将两个不同事件流发出的项目组合到一个向量中。
- en: 'A sample interaction with the `zip` function is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `zip` 函数的一个示例交互如下：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For this exercise, we need a way to know when we have enough items to emit from
    both event streams. Managing this internal state can be tricky at first. Clojure's
    `ref` types and, in particular, `dosync`, can be of use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们需要一种方式来知道我们是否有足够的项目可以从两个事件流中发出。最初管理这种内部状态可能很棘手。Clojure 的 `ref` 类型，特别是
    `dosync`，可能会有所帮助。
- en: A respondent application
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个响应式应用程序
- en: This chapter would not be complete if we didn't go through the whole development
    life cycle of deploying and using the new framework in a new application. This
    is the purpose of this section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有通过在新的应用程序中部署和使用新框架的整个开发生命周期来完善这一章，那么这一章将是不完整的。这正是本节的目的。
- en: The application we will build is extremely simple. All it does is track the
    position of the mouse using the reactive primitives we built into respondent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序非常简单。它所做的只是跟踪鼠标的位置，使用我们构建到响应式程序中的反应式原语。
- en: To that end, we will be using the excellent lein template `cljs-start` (see
    [https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)),
    created by Mimmo Cosenza to help developers get started with ClojureScript.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们将使用由 Mimmo Cosenza 创建的出色的 lein 模板 `cljs-start`（见 [https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)），以帮助开发者开始使用
    ClojureScript。
- en: 'Let''s get started:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let''s modify the project file to include the following dependencies:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修改项目文件以包含以下依赖项：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first dependency is self-explanatory. It's simply our own framework. `dommy`
    is a DOM manipulation library for ClojureScript. We'll briefly use it when building
    our web page.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项是显而易见的。它只是我们自己的框架。`dommy` 是一个用于 ClojureScript 的 DOM 操作库。当构建我们的网页时，我们将简要使用它。
- en: 'Next, edit the `dev-resources/public/index.html` file to match the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑 `dev-resources/public/index.html` 文件以匹配以下内容：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last piece of the puzzle is modifying `src/cljs/respondent_app/core.cljs`
    to match the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是修改 `src/cljs/respondent_app/core.cljs` 以匹配以下内容：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is our main application logic. It creates an event stream to which we deliver
    the current mouse position from the `onmousemove` event of the browser window.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主要应用程序逻辑。它创建了一个事件流，我们将从浏览器窗口的 `onmousemove` 事件中传递当前的鼠标位置到这个事件流。
- en: Later, we simply subscribe to it and use `dommy` to select and set the text
    of the `div` element we added previously.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需简单地订阅它，并使用 `dommy` 来选择和设置我们之前添加的 `div` 元素的文本。
- en: 'We are now ready to use the app! Let''s start by compiling ClojureScript:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用应用程序了！让我们首先编译 ClojureScript：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should take a few seconds. If all is well, the next thing to do is to
    start a REPL session and start up the server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几秒钟。如果一切顺利，接下来要做的事情是启动一个 REPL 会话并启动服务器：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, point your browser to `http://localhost:3000/` and drag the mouse around
    to see its current position.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你的浏览器指向 `http://localhost:3000/` 并拖动鼠标以查看其当前位置。
- en: Congratulations on successfully developing, deploying, and using your own CES
    framework!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你成功开发、部署和使用你自己的 CES 框架！
- en: CES versus core.async
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CES 与 core.async
- en: At this stage, you might be wondering when you should choose one approach over
    the other. After all, as demonstrated at the beginning of this chapter, we could
    use `core.async` to do everything we have done using `respondent`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道何时选择一种方法而不是另一种方法。毕竟，正如本章开头所展示的，我们可以使用 `core.async` 来完成使用 `respondent`
    所做的一切。
- en: It all comes down to using the right level of abstraction for the task at hand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都归结于使用适合当前任务的正确抽象级别。
- en: '`core.async` gives us many low level primitives that are extremely useful when
    working with processes, which need to talk to each other. The `core.async` channels
    work as concurrent blocking queues and are an excellent synchronization mechanism
    in these scenarios.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`为我们提供了许多在处理需要相互通信的进程时非常有用的低级原语。`core.async`的通道作为并发阻塞队列工作，在这些场景中是一个出色的同步机制。'
- en: 'However, it makes other solutions harder to implement: for instance, channels
    are single-take by default, so if we have multiple consumers interested in the
    values put inside a channel, we have to implement the distribution ourselves using
    tools such as `mult` and `tap`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它使得其他解决方案的实现更加困难：例如，通道默认是单次取用的，所以如果我们有多个消费者对放入通道中的值感兴趣，我们必须使用`mult`和`tap`等工具自行实现分发。
- en: CES frameworks, on the other hand, operate at a higher level of abstraction
    and work with multiple subscribers by default.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CES框架在更高的抽象级别上运行，并且默认情况下与多个订阅者一起工作。
- en: Additionally, `core.async` relies on side effects, as can be seen by the use
    of functions such as `>!` inside `go` blocks. Frameworks such as RxClojure promote
    stream transformations by the use of pure functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`core.async`依赖于副作用，这可以通过`go`块内使用`>!`等函数来看到。例如，RxClojure这样的框架通过使用纯函数来促进流转换。
- en: This is not to say there aren't side effects in CES frameworks. There most definitely
    are. However, as a consumer of the library, this is mostly hidden from our eyes,
    allowing us to think of most of our code as simple sequence transformations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说CES框架中没有副作用。当然有。然而，作为库的消费者，这些副作用大部分对我们来说是隐藏的，这让我们认为大部分的代码只是简单的序列转换。
- en: In conclusion, different application domains will benefit more or less from
    either approach—sometimes they can benefit from both. We should think hard about
    our application domain and analyze the types of solutions and idioms developers
    are most likely to design. This will point us in the direction of better abstraction
    for whatever application we are developing at a given time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，不同的应用领域将或多或少地从这两种方法中受益——有时它们可以从两者中受益。我们应该认真思考我们的应用领域，并分析开发者最有可能设计的解决方案和习惯用法。这将指引我们在开发特定应用时朝向更好的抽象方向。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed our very own CES framework. By developing our
    own framework, we have solidified our understanding of both CES and how to effectively
    use `core.async`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了我们自己的CES框架。通过开发自己的框架，我们巩固了对CES以及如何有效使用`core.async`的理解。
- en: The idea that `core.async` could be used as the foundation of a CES framework
    isn't mine, however. James Reeves (see [https://github.com/weavejester](https://github.com/weavejester))—creator
    of the routing library **Compojure** (see [https://github.com/weavejester/compojure](https://github.com/weavejester/compojure))
    and many other useful Clojure libraries—also saw the same potential and set off
    to write **Reagi** (see [https://github.com/weavejester/reagi](https://github.com/weavejester/reagi)),
    a CES library built on top of `core.async`, similar in spirit to the one we developed
    in this chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将`core.async`用作CES框架基础的想法并非是我的。James Reeves（见[https://github.com/weavejester](https://github.com/weavejester)）——路由库**Compojure**（见[https://github.com/weavejester/compojure](https://github.com/weavejester/compojure)）和许多其他有用的Clojure库的创造者——也看到了同样的潜力，并着手编写**Reagi**（见[https://github.com/weavejester/reagi](https://github.com/weavejester/reagi)），这是一个建立在`core.async`之上的CES库，其精神与我们本章开发的类似。
- en: He has put a lot more effort into it, making it a more robust option for a pure
    Clojure framework. We'll be looking at it in the next chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 他投入了更多的努力，使其成为纯Clojure框架的一个更稳健的选择。我们将在下一章中探讨它。
