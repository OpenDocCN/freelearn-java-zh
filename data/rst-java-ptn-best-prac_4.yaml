- en: Chapter 4. Designing for Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。性能设计
- en: REST is an architectural style confirming to the web architecture design and
    needs to be properly designed and implemented so that it allows you to take advantage
    of the scalable web. This chapter covers advanced design principles related to
    performance that every developer must know when building RESTful services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种符合Web架构设计的架构风格，需要正确设计和实现，以便利用可扩展的Web。本章涵盖了与性能相关的高级设计原则，每个开发人员在构建RESTful服务时都必须了解。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Caching principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存原则
- en: Asynchronous and long-running jobs in REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST中的异步和长时间运行的作业
- en: HTTP PATCH and partial updates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP PATCH和部分更新
- en: We will elaborate on the different HTTP cache headers and learn how to send
    conditional requests to see whether the new content or the cached content needs
    to be returned. We will then show with samples how to use JAX-RS to implement
    caching.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍不同的HTTP缓存头，并学习如何发送条件请求，以查看新内容或缓存内容是否需要返回。然后，我们将展示如何使用JAX-RS来实现缓存。
- en: Additionally, we will cover how the Facebook API uses ETags for caching. Next,
    we will walk through asynchronous request response processing with JAX-RS and
    best practices. Finally, we will cover HTTP PATCH method and learn how to implement
    partial updates and common practices around partial updates.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍Facebook API如何使用ETags进行缓存。接下来，我们将介绍如何使用JAX-RS进行异步请求响应处理以及最佳实践。最后，我们将介绍HTTP
    PATCH方法，并学习如何实现部分更新以及部分更新的常见实践。
- en: Different snippets of code are included in the chapter, but complete samples
    that show these snippets in action are included as part of this book's source
    code download bundle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了不同的代码片段，但展示这些片段在实际中的完整示例包含在本书的源代码下载包中。
- en: Caching principles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存原则
- en: In this section, we will cover the different programming principles when designing
    RESTful services. One of the areas we will cover is caching. Caching involves
    storing response information related to the requests in a temporary storage for
    a specific period of time. This ensures the server is not burdened with processing
    those requests in future when the responses can be fulfilled from the cache.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍设计RESTful服务时涉及的不同编程原则。我们将涵盖的一个领域是缓存。缓存涉及将与请求相关的响应信息存储在临时存储中，以特定时间段内。这确保了服务器在未来不需要处理这些请求时，可以从缓存中满足响应。
- en: The cache entries can be invalidated after a specific time interval. The cache
    entries can also be invalidated when the objects, which are in the cache, change,
    for example, when some API modifies or deletes a resource.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存条目可以在特定时间间隔后失效。缓存条目也可以在缓存中的对象发生变化时失效，例如，当某个API修改或删除资源时。
- en: There are many benefits to caching. Caching helps to reduce **latency** and
    improve application responsiveness. It helps in reducing the number of requests
    the server has to deal with and thus the server is able to handle more requests,
    and the clients will get responses quicker.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有许多好处。缓存有助于减少延迟并提高应用程序的响应速度。它有助于减少服务器需要处理的请求数量，因此服务器能够处理更多的请求，客户端将更快地获得响应。
- en: Generally, assets such as images, JavaScript files, and stylesheets can all
    be cached fairly heavily. Also, it is advisable to cache responses, which may
    require intensive computation on the backend.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，诸如图像、JavaScript文件和样式表等资源都可以被相当大地缓存。此外，建议缓存可能需要在后端进行密集计算的响应。
- en: Caching details
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存细节
- en: The following section covers the topics related to caching. The key to making
    caching work effectively is to use HTTP caching headers that specify how long
    a resource is valid and when it was last changed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分涵盖了与缓存相关的主题。使缓存有效工作的关键是使用HTTP缓存头，指定资源的有效时间以及上次更改的时间。
- en: Types of caching headers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存头的类型
- en: 'The next section covers the types of caching headers followed by examples of
    each type of caching header. The following are the types of headers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍缓存头的类型，然后是每种缓存头的示例。以下是头部的类型：
- en: Strong caching headers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强缓存头
- en: Weak caching headers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱缓存头
- en: Strong caching headers
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强缓存头
- en: The strong caching headers specify for how long a cached resource is valid and
    the browser does not need to send any more `GET` requests till that period. `Expires`
    and `Cache-Control max-age` are strong caching headers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 强缓存头指定了缓存资源的有效时间，浏览器在此期间不需要发送任何更多的`GET`请求。`Expires`和`Cache-Control max-age`是强缓存头。
- en: Weak caching headers
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱缓存头
- en: The weak caching headers help the browser decide if it needs to fetch an item
    from the cache by issuing a conditional `GET` request. `Last-Modified` and `ETag`
    are examples of weak caching headers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 弱缓存头帮助浏览器决定是否需要通过发出条件`GET`请求从缓存中获取项目。`Last-Modified`和`ETag`是弱缓存头的示例。
- en: Expires and Cache-Control – max-age
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Expires和Cache-Control - max-age
- en: The `Expires` and `Cache-Control` headers specify the time period during which
    the browser can use the cached resource without checking for a newer version.
    The newer resource will not be fetched until the expiry date or maximum age specified
    is reached if these headers are set. The `Expires` header takes a date after which
    the resource becomes invalid. Instead of specifying a date, the `max-age` attribute
    mentions how long the resource is valid after it is downloaded.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expires`和`Cache-Control`头指定了浏览器可以在不检查更新版本的情况下使用缓存资源的时间段。如果设置了这些头部，直到到期日期或达到最大年龄为止，新资源将不会被获取。`Expires`头部接受一个日期，指定资源失效的时间。而`max-age`属性则指定资源在下载后的有效时间。'
- en: The Cache-Control header and directives
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存控制头和指令
- en: 'In **HTTP 1.1**, the `Cache-Control` header specifies the resource caching
    behavior as well as the maximum age the resource can be cached. The following
    table shows the different directives of the `Cache-Control` header:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**HTTP 1.1**中，`Cache-Control`头指定了资源的缓存行为以及资源可以被缓存的最大年龄。以下表格显示了`Cache-Control`头的不同指令：
- en: '| Directive | Meaning |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 意义 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `private` | When this directive is used, the browser can cache the object,
    but proxies and content delivery networks cannot |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 当使用此指令时，浏览器可以缓存对象，但代理和内容交付网络不能 |'
- en: '| `public` | When this directive is used, an object can be cached by browser,
    proxies, and content delivery networks |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 当使用此指令时，浏览器、代理和内容交付网络可以缓存对象 |'
- en: '| `no-cache` | When this directive is used, an object will not be cached |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `no-cache` | 当使用此指令时，对象将不被缓存 |'
- en: '| `no-store` | When this is used, an object can be cached in memory but should
    not be stored on disk |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `no-store` | 当使用此选项时，对象可以被缓存在内存中，但不应存储在磁盘上 |'
- en: '| `max-age` | This denotes the time for which the resource is valid |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `max-age` | 表示资源有效的时间 |'
- en: 'Here is an example of a response with the `Cache-Control HTTP/1.1` header in
    a response:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有`Cache-Control HTTP/1.1`头的响应的示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding response has a `Cache-Control` header with directives as `private`
    and `max-age` set to 24 hours or 86400 seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应具有`Cache-Control`头，指令为`private`，`max-age`设置为24小时或86400秒。
- en: 'Once a resource is invalid based on the `max-age` or `Expires` header, the
    client can request the resource again or send a conditional `GET` request that
    gets the resource only if it has changed. This can be achieved by the weaker caching
    headers: the `Last-Modified` and ETag headers as shown in the next section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资源基于`max-age`或`Expires`头无效，客户端可以再次请求资源或发送条件`GET`请求，只有在资源发生更改时才获取资源。这可以通过较弱的缓存头来实现：如下一节所示的`Last-Modified`和ETag头。
- en: Last-Modified and ETag
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Last-Modified和ETag
- en: These headers enable the browser to check if the resource has changed since
    the last `GET` request. In the `Last-Modified` header, there is a date associated
    with the modification of the resource. In the ETag header, there can be any value
    that uniquely identifies a resource (like a hash). However, these headers allow
    the browser to efficiently update its cached resources by issuing conditional
    `GET` requests. Conditional `GET` requests will return the full response only
    if the resource has changed at the server. This ensures conditional `GET` requests
    will have lower latency than full `GET` requests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头使浏览器能够检查资源自上次`GET`请求以来是否发生了更改。在`Last-Modified`头中，有一个与资源修改相关的日期。在ETag头中，可以有任何唯一标识资源的值（如哈希）。然而，这些头允许浏览器通过发出条件`GET`请求有效地更新其缓存资源。条件`GET`请求只有在服务器上的资源发生更改时才会返回完整的响应。这确保条件`GET`请求的延迟低于完整的`GET`请求。
- en: The Cache-Control header and the REST API
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cache-Control头和REST API
- en: The following code shows how to add the `Cache-Control` header to a JAX-RS response.
    The sample is available as part of the book's downloadable source bundle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何向JAX-RS响应添加`Cache-Control`头。该示例可作为本书可下载源代码包的一部分。
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JAX-RS has a `javax.ws.rs.core.Cache-Control` class, which is an abstraction
    for the `HTTP/1.1 Cache-Control` header. The `setMaxAge()` method on the `cacheControl`
    object corresponds to the `max-age` directive and `setPrivate(true)` corresponds
    to the `private` directive. The response is built using the `responseBuilder.build()`
    method. The `cacheControl` object is added to the `Response` object that is returned
    by the `getCoffee()` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS有一个`javax.ws.rs.core.Cache-Control`类，它是`HTTP/1.1 Cache-Control`头的抽象。`cacheControl`对象上的`setMaxAge()`方法对应于`max-age`指令，`setPrivate(true)`对应于`private`指令。响应是使用`responseBuilder.build()`方法构建的。`cacheControl`对象被添加到`getCoffee()`方法返回的`Response`对象中。
- en: 'The following is the response with headers produced by this application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此应用程序生成的带有头的响应：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ETags
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ETags
- en: 'HTTP defines a powerful caching mechanism that includes the following headers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP定义了一个强大的缓存机制，其中包括以下头部： '
- en: The `ETag` header
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETag`头'
- en: The `If-Modified-Since` header
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`If-Modified-Since`头'
- en: The `304 Not Modified` response code
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`304 Not Modified`响应代码'
- en: How ETags work
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ETags工作原理
- en: 'The following section digs into some basics of how ETags work. The following
    diagram gives a better picture of this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分深入介绍了ETags的一些基础知识。以下图表更好地展示了这一点：
- en: '![How ETags work](img/7963OS_04_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![ETags工作原理](img/7963OS_04_01.jpg)'
- en: 'Let''s have a look at each of the processes related to ETags:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看与ETags相关的每个过程：
- en: The client sends a `GET` request to the [http://api.com/coffee/1234](http://api.com/coffee/1234)
    REST resource.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向[http://api.com/coffee/1234](http://api.com/coffee/1234) REST资源发送一个`GET`请求。
- en: The server sends back a **200 OK** with an **ETag** value, for example, "**123456789"**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送一个带有**ETag**值的**200 OK**，例如，"**123456789"**。
- en: 'After some time, the client sends another `GET` request to [api.com/coffee/1234](http://api.com/coffee/1234)
    REST resource along with the `If-None-Match: "123456789"` header.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '过一段时间，客户端发送另一个带有`If-None-Match: "123456789"`头的`GET`请求到[api.com/coffee/1234](http://api.com/coffee/1234)
    REST资源。'
- en: The server checks if the resource MD5 hash has not been modified, then sends
    a `304 Not-Modified` response with no response body.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器检查资源的MD5哈希是否未被修改，然后发送一个没有响应主体的`304 Not-Modified`响应。
- en: If the resource had changed, a 200 OK would be sent as the response. Additionally,
    as part of the response, a new ETag is sent by the server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已更改，将发送200 OK作为响应。此外，作为响应的一部分，服务器还发送了一个新的ETag。
- en: The ETag header and the REST API
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ETag头和REST API
- en: 'The following code shows how to add the `ETag` header to the JAX-RS response:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何向JAX-RS响应添加`ETag`头：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet of code, the instance of `javax.ws.core.EntityTag`
    object is created by using a hash of the resource, which for simplicity, we have
    "123456789".
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，使用资源的哈希创建了`javax.ws.core.EntityTag`对象的实例，为简单起见，我们使用了"123456789"。
- en: The `request,evalautePreconditions` method checks for the value of the `EntityTag
    et` object. If the preconditions are met, it returns a response with `200 OK`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`request,evalautePreconditions` 方法检查 `EntityTag et` 对象的值。如果满足先决条件，它将返回一个带有
    `200 OK` 的响应。'
- en: The `EntityTag` object, `et`, is then sent with the response, which is returned
    by the `getCoffeeWithETag` method. For more details, please refer to the sample
    available as part of the source bundle for the book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`EntityTag` 对象 `et` 与响应一起发送，该响应由 `getCoffeeWithETag` 方法返回。有关更多详细信息，请参考书籍源代码包中提供的示例。
- en: Types of ETags
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ETags 的类型
- en: A strongly validating ETag match indicates that the content of the two resources
    is byte-for-byte identical and that all other entity fields (such as Content-Language)
    are also unchanged.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 强验证 ETag 匹配表示两个资源的内容是逐字节相同的，并且所有其他实体字段（例如 Content-Language）也没有更改。
- en: A weakly validating ETag match only indicates that the two resources are semantically
    equivalent, and that cached copies can be used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 弱验证 ETag 匹配仅表示两个资源在语义上是等价的，并且可以使用缓存的副本。
- en: Caching helps reduce the number of requests made by the client. It also helps
    in reducing the number of complete responses saving bandwidth and computational
    time with the conditional `GET` requests and ETags, `IF-None-Match` headers, and
    `304-Not Modified` response.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有助于减少客户端发出的请求次数。它还有助于通过条件 `GET` 请求和 ETags、`IF-None-Match` 头和 `304-Not Modified`
    响应来减少完整响应的数量，从而节省带宽和计算时间。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good practice to specify either `Expires` or `Cache-Control max-age`
    along with one of the two `Last-Modified` and ETag headers in the HTTP response.
    Sending both `Expires` and `Cache-Control max-age` is redundant. Similarly, sending
    both `Last-Modified` and ETag is redundant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中指定 `Expires` 或 `Cache-Control max-age` 以及两者中的一个 `Last-Modified` 和
    ETag 头是一个很好的做法。同时发送 `Expires` 和 `Cache-Control max-age` 是多余的。同样，发送 `Last-Modified`
    和 ETag 也是多余的。
- en: The Facebook REST API and ETags
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facebook REST API 和 ETags
- en: The Facebook Marketing API supports ETags on the Graph API. When the consumer
    makes a Graph API call, the response header includes an ETag with a value that
    is the hash of the data returned in the API call. Next time the consumer makes
    the same API call, he can include the `If-None-Match` request header with the
    ETag value saved from the first step. If the data has not changed, the response
    status code will be `304 –Not Modified` and no data is returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 营销 API 支持 Graph API 上的 ETags。当消费者进行 Graph API 调用时，响应头包括一个 ETag，其值是在
    API 调用返回的数据的哈希值。下次消费者进行相同的 API 调用时，他可以在请求头中包含从第一步保存的 ETag 值的 `If-None-Match` 请求头。如果数据没有更改，响应状态码将是
    `304 - Not Modified`，并且不返回数据。
- en: If the data on the server side has changed since the last query, the data is
    returned as usual with a new ETag. This new value of ETag can be used for subsequent
    calls. For more details, check [http://developers.facebook.com](http://developers.facebook.com).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器端的数据自上次查询以来发生了变化，则数据将像往常一样返回，并附带一个新的 ETag。这个新的 ETag 值可以用于后续调用。有关更多详细信息，请查看
    [http://developers.facebook.com](http://developers.facebook.com)。
- en: RESTEasy and caching
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTEasy 和缓存
- en: RESTEasy is a JBoss project that provides various frameworks to help build RESTful
    web services and RESTful Java applications. RESTEasy can run in any servlet container,
    but has a tighter integration with the JBoss Application Server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 是 JBoss 项目，提供各种框架来帮助构建 RESTful web 服务和 RESTful Java 应用程序。RESTEasy 可以在任何
    servlet 容器中运行，但与 JBoss 应用服务器有更紧密的集成。
- en: RESTEasy provides an extension to JAX-RS that allows setting `Cache-Control`
    headers on a successful `GET` request automatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 提供了一个 JAX-RS 的扩展，允许在成功的 `GET` 请求上自动设置 `Cache-Control` 头。
- en: It also provides a server-side, local, in-memory cache that can sit in front
    of the JAX-RS services. It automatically caches marshalled responses from HTTP
    GET JAX-RS invocations if the JAX-RS resource method sets a `Cache-Control` header.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一个服务器端的本地内存缓存，可以位于 JAX-RS 服务的前面。如果 JAX-RS 资源方法设置了 `Cache-Control` 头，则它会自动缓存来自
    HTTP GET JAX-RS 调用的编组响应。
- en: When a `HTTP GET` request arrives, the RESTEasy server cache will check to see
    if the URI is stored in the cache. If it does, it returns the already marshalled
    response without invoking the JAX-RS method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `HTTP GET` 请求到达时，RESTEasy 服务器缓存将检查 URI 是否存储在缓存中。如果是，则返回已经编组的响应，而不调用 JAX-RS
    方法。
- en: For more information, check [http://www.jboss.org/resteasy](http://www.jboss.org/resteasy).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看 [http://www.jboss.org/resteasy](http://www.jboss.org/resteasy)。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Tips when caching on the server side**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**在服务器端进行缓存时的提示**'
- en: Invalidate the cache entry for a `PUT` or a `POST` request. Do not cache a request
    that has a query parameter, as once the query parameter value changes the cached
    response from the server may not be valid.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `PUT` 或 `POST` 请求，使缓存条目无效。不要缓存具有查询参数的请求，因为一旦查询参数值发生变化，来自服务器的缓存响应可能无效。
- en: Asynchronous and long-running jobs in REST
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 中的异步和长时间运行的作业
- en: A common pattern in developing RESTful API is to deal with asynchronous and
    long-running jobs. API developers need to create resources that might take a considerable
    amount of time. They cannot have the clients wait on the API to finish.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 RESTful API 中的一个常见模式是处理异步和长时间运行的作业。API 开发人员需要创建可能需要相当长时间的资源。他们不能让客户端等待 API
    完成。
- en: Consider placing an order for a coffee at a coffee shop. The order details are
    stored in a queue and when the barista is free, he processes your order. Till
    then you get a receipt acknowledging your order but the actual coffee arrives
    later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在咖啡店订购咖啡。订单详细信息存储在队列中，当咖啡师有空时，他会处理您的订单。在那之前，您会收到一张收据确认您的订单，但实际的咖啡稍后到达。
- en: Asynchronous resource processing works on the same principles. Asynchronous
    resources mean the resources cannot be created immediately. Maybe it will be placed
    inside a task/message queue that will handle the actual creation of the resource
    or something similar.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 异步资源处理遵循相同的原则。异步资源意味着资源不能立即创建。也许它将被放置在一个处理资源实际创建的任务/消息队列中，或者类似的东西。
- en: 'Consider the following request to order a small coffee in our sample:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在我们示例中订购一杯小咖啡的请求：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The response can be sent back as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 响应可以发送回以下内容：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The response sends back a `202 Accepted` header. The `Location` header can provide
    details about the coffee resource.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 响应发送一个`202 Accepted`头。`Location`头可以提供有关咖啡资源的详细信息。
- en: Asynchronous request and response processing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步请求和响应处理
- en: 'The asynchronous processing is included in both client- and server-side APIs
    of JAX-RS 2.0 to facilitate asynchronous interaction between client and server
    components. The following list shows the new interfaces and classes added to support
    this feature on the server and the client side:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理包含在JAX-RS 2.0的客户端和服务器端API中，以促进客户端和服务器组件之间的异步交互。以下列表显示了添加到服务器端和客户端的新接口和类，以支持此功能：
- en: 'Server side:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端：
- en: '`AsyncResponse`: This is an injectable JAX-RS asynchronous response that provides
    means for asynchronous server-side response processing'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncResponse`：这是一个可注入的JAX-RS异步响应，提供了异步服务器端响应处理的手段'
- en: '`@Suspended`: The `@Suspended` annotation instructs the container that the
    HTTP request processing should happen in a secondary thread'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Suspended`：`@Suspended`注解指示容器应在辅助线程中进行HTTP请求处理'
- en: '`CompletionCallback`: This is a request-processing callback that receives request-processing
    completion events'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionCallback`：这是一个接收请求处理完成事件的请求处理回调'
- en: '`ConnectionCallback`: This is an asynchronous request-processing lifecycle
    callback that receives connection-related asynchronous response lifecycle events'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionCallback`：这是一个接收与连接相关的异步响应生命周期事件的异步请求处理生命周期回调'
- en: 'Client side:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端端：
- en: '`InvocationCallback`: This is a callback that can be implemented to receive
    the asynchronous processing events from the invocation processing'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvocationCallback`：这是一个可以实现的回调，用于接收调用处理的异步处理事件'
- en: '`Future`: This allows the client to poll for completion of the asynchronous
    operation or to block and wait for it'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`：这允许客户端轮询异步操作的完成情况，或者阻塞并等待它'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Future` interface introduced in Java SE 5 provides two different mechanism
    to get the result of an asynchronous operation: first by invoking the `Future.get(…)`
    variants that blocks until the result is available or a timeout occurs, and the
    second way is to check for completion by invoking the `isDone()` and `isCancelled()`,
    which are Boolean methods that return the current status of `Future`. For more
    details, check [http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 5中引入的`Future`接口提供了两种不同的机制来获取异步操作的结果：首先是通过调用`Future.get(…)`变体来阻塞直到结果可用或超时发生，第二种方式是通过调用`isDone()`和`isCancelled()`来检查完成情况，这些是返回`Future`当前状态的布尔方法。有关更多详细信息，请查看[http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html)。
- en: 'The following diagram shows the asynchronous request/response processing in
    JAX-RS:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了JAX-RS中的异步请求/响应处理：
- en: '![Asynchronous request and response processing](img/7963OS_04_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![异步请求和响应处理](img/7963OS_04_02.jpg)'
- en: The client makes a request for an asynchronous method on `CoffeeResource`. The
    `CoffeeResource` class creates a new thread, which can do some intensive operation
    and then send back the response. Meanwhile, the request thread is released and
    can handle other requests. When the thread working on the operation finishes the
    processing, it returns the response to the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发出对`CoffeeResource`上异步方法的请求。`CoffeeResource`类创建一个新线程，可以进行一些密集的操作，然后发送响应。同时，请求线程被释放，可以处理其他请求。当处理操作的线程完成处理时，将响应返回给客户端。
- en: 'The following sample code shows how an asynchronous resource can be developed
    using JAX-RS 2.0 API:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了如何使用JAX-RS 2.0 API开发异步资源：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CoffeesResource` class is a stateless session bean, which has a method
    called `order()`. This method is annotated with the `@Asynchronous` annotation,
    which will work in the fire-and-forget manner. When the resource is requested
    by the client through the `order()` method's resource path, a new thread is spawned
    to work on preparing the request's response. The thread is submitted to the executor
    for execution and the thread processing the client request is released (via `ctx.suspend`)
    to process other incoming requests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoffeesResource`类是一个无状态会话bean，其中有一个名为`order()`的方法。该方法带有`@Asynchronous`注解，将以“发出并忘记”的方式工作。当客户端通过`order()`方法的资源路径请求资源时，会生成一个新线程来处理准备请求的响应。线程被提交给执行程序执行，处理客户端请求的线程被释放（通过`ctx.suspend`）以处理其他传入的请求。'
- en: When the worker thread, created to prepare the response, is done with preparing
    the response, it invokes the `ctx.resume` method, which lets the container know
    the response is ready to be sent back to the client. If the `ctx.resume` method
    is invoked before the `ctx.suspend` method (the worker thread has prepared the
    result before the execution reaching the `ctx.suspend` method), the suspension
    is ignored and the result will be sent to the client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当为准备响应创建的工作线程完成准备响应时，它调用`ctx.resume`方法，让容器知道响应已准备好发送回客户端。如果在`ctx.suspend`方法之前调用了`ctx.resume`方法（工作线程在执行到达`ctx.suspend`方法之前已准备好结果），则会忽略暂停，并且结果将发送到客户端。
- en: 'The same functionality can be achieved using the `@Suspended` annotation that
    is shown in the following snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段中显示的`@Suspended`注解来实现相同的功能：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the `@Suspended` annotation is cleaner as this does not involve the use
    of the `ExecutionContext` variable to instruct the container to suspend and then
    resume the communication thread when the worker thread, aka the `prepareResponse()`
    method in this case, is finished. The client code to consume the asynchronous
    resource can use the callback mechanism or polling at the code level. The following
    code shows how to use polling via the `Future` interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Suspended`注解更清晰，因为这不涉及使用`ExecutionContext`变量来指示容器在工作线程完成时暂停然后恢复通信线程，即在这种情况下的`prepareResponse()`方法。消耗异步资源的客户端代码可以使用回调机制或在代码级别进行轮询。以下代码显示了如何通过`Future`接口进行轮询：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code begins with forming the request to the `Coffee` resource. It uses the
    `javax.ws.rs.client.Client` instance to call the `target()` method, which creates
    a `javax.ws.rs.client.WebTarget` instance for the `Coffee` resource. The `Future.get(…)`
    method blocks until the response is back from the server or the 30 seconds timeout
    is reached.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从形成对`Coffee`资源的请求开始。它使用`javax.ws.rs.client.Client`实例调用`target()`方法，该方法为`Coffee`资源创建一个`javax.ws.rs.client.WebTarget`实例。`Future.get(…)`方法会阻塞，直到从服务器收到响应或达到30秒的超时时间。
- en: 'Another API for the asynchronous client is to use the `javax.ws.rs.client.InvocationCallback`
    instance, which is a callback that can be implemented to get asynchronous events
    from the invocation. For more details, check [https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html](https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/     client/InvocationCallback.html).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个用于异步客户端的API是使用`javax.ws.rs.client.InvocationCallback`实例，这是一个可以实现以获取调用的异步事件的回调。有关更多详细信息，请查看[https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html](https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/     client/InvocationCallback.html)。'
- en: Asynchronous resources best practices
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步资源最佳实践
- en: The following section lists the best practices when working with asynchronous
    RESTful resources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节列出了在处理异步RESTful资源时的最佳实践。
- en: Sending a 202 Accepted message
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送202 Accepted消息
- en: For asynchronous requests/responses, the API should send back a `202 Accepted`
    message, in case the request is valid and the resource may be available in time,
    even if it is a few seconds. `202 Accepted` means the request has been accepted
    for processing and the resource will be available shortly. The `202 Accepted`
    message should specify the `Location` header, which can be used by the client
    to know where the resource will be available once it is created. The API should
    not send back a `201 Created` message if the response is not available immediately.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步请求/响应，API应该返回一个`202 Accepted`消息，以表明请求是有效的，资源可能在时间上是可用的，即使只有几秒钟。`202 Accepted`表示请求已被接受处理，资源将很快可用。`202
    Accepted`消息应指定`Location`头，客户端可以使用它来知道资源创建后将在哪里可用。如果响应不立即可用，API不应返回`201 Created`消息。
- en: Setting expiration for objects in the queue
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置队列中对象的过期时间
- en: The API developer should expire the objects after a certain amount of time in
    the queue. This ensures queue objects do not accumulate over time and are purged
    periodically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API开发人员应该在队列中的一定时间后使对象过期。这样可以确保队列对象不会随着时间的推移而积累，并且会定期清除。
- en: Using message queues to handle tasks asynchronously
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息队列来处理任务异步
- en: The API developer should consider using message queuing for asynchronous operations
    so that the messages are placed in the queue until a receiver receives them. **Advanced
    Messaging Queuing Protocol** (**AMQP**) is a standard that enables reliable and
    secure routing, queuing, publishing, and subscribing of messages. For more details,
    check Advanced Message Queuing Protocol at [http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API开发人员应考虑使用消息队列来进行异步操作，以便消息被放置在队列中，直到接收者接收到它们。**高级消息队列协议**（**AMQP**）是一种标准，它能够可靠和安全地路由、排队、发布和订阅消息。有关更多详细信息，请查看[http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)上的高级消息队列协议。
- en: For example, when an asynchronous resource method is invoked, use message queuing
    to send messages and handle different tasks based on messages and events asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当调用异步资源方法时，使用消息队列发送消息，并根据消息和事件异步处理不同的任务。
- en: In our sample, if a coffee order is placed, a message can be sent using RabbitMQ
    ([http://www.rabbitmq.com/](http://www.rabbitmq.com/)) to trigger the `COMPLETED`
    event. Once the order is completed, the details can be moved to an inventory system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，如果下订单咖啡，可以使用RabbitMQ（[http://www.rabbitmq.com/](http://www.rabbitmq.com/)）发送消息来触发“COMPLETED”事件。订单完成后，详细信息可以移至库存系统。
- en: The next section covers another important detail for RESTful services for doing
    partial updates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节涵盖了RESTful服务的另一个重要细节，即进行部分更新。
- en: HTTP PATCH and partial updates
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP PATCH和部分更新
- en: 'A common problem for API developers is to implement partial updates. This can
    happen when the client sends a request that must change just one part of a resource''s
    state. For example, imagine that there is a JSON representation of your `Coffee`
    resource that looks like the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: API开发人员常见的问题是实现部分更新。当客户端发送一个请求，必须改变资源状态的一部分时，就会出现这种情况。例如，想象一下，有一个JSON表示您的`Coffee`资源的代码片段如下所示：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once the order is completed, the status needs to be changed from `"PROCESSING"`
    to `"COMPLETED"`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦订单完成，状态需要从“PROCESSING”更改为“COMPLETED”。
- en: 'In an RPC-style API, this could be handled by adding a method as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在RPC风格的API中，可以通过添加以下方法来处理这个问题：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the REST case using the `PUT` method, all the data like this needs to be
    sent, which will waste bandwidth and memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST情况下使用`PUT`方法，需要发送所有这样的数据，这将浪费带宽和内存。
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To avoid sending the whole data for a minor update, another solution is to
    use `PATCH` to do a partial update:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在进行小的更新时发送整个数据，另一个解决方案是使用`PATCH`进行部分更新：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, not all web servers and client will provide support for `PATCH`, so
    people have been supporting both partial updates with `POST` and `PUT`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的Web服务器和客户端都会提供对`PATCH`的支持，因此人们一直在支持使用`POST`和`PUT`进行部分更新：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Partial updates with `PUT`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PUT`进行部分更新：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To summarize, using either `PUT` or `POST` for partial updates are both acceptable.
    The Facebook API uses `POST` to update partial resources. Using partial `PUT`
    would be more consistent with how we implement RESTful resources and methods as
    CRUD operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用`PUT`或`POST`进行部分更新都是可以接受的。Facebook API使用`POST`来更新部分资源。使用部分`PUT`将更符合我们实现RESTful资源和方法的方式，作为CRUD操作。
- en: 'To implement support for the `PATCH` method, here is how to add an annotation
    in JAX-RS:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现对`PATCH`方法的支持，可以在JAX-RS中添加注释：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding snippet shows how to associate the annotation of `javax.ws.rs.HTTPMethod`
    with the name "`PATCH`". Once this annotation is created, then the `@PATCH` annotation
    can be used on any JAX-RS resource method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的片段显示了如何将`javax.ws.rs.HTTPMethod`的注释与名称“`PATCH`”相关联。一旦创建了这个注释，那么`@PATCH`注释就可以用于任何JAX-RS资源方法。
- en: JSON Patch
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Patch
- en: JSON Patch is part of RFC 6902\. It is a standard designed to allow performing
    operations on JSON documents. JSON Patch can work with the `HTTP PATCH` method.
    It is useful to provide partial updates to JSON documents. The media type `"application/json-patch+json"`
    is used to identify such patch documents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Patch是RFC 6902的一部分。它是一个旨在允许对JSON文档执行操作的标准。JSON Patch可以与`HTTP PATCH`方法一起使用。它对于提供JSON文档的部分更新非常有用。媒体类型`"application/json-patch+json"`用于识别此类补丁文档。
- en: 'It takes the following members:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下成员：
- en: '`op`: This identifies the operation to be performed on the document. The acceptable
    values are `"add"`, `"replace"`, `"move"`, `"remove"`, `"copy"`, or `"test"`.
    Any other value is an error.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op`：这标识要在文档上执行的操作。可接受的值为`"add"`、`"replace"`、`"move"`、`"remove"`、`"copy"`或`"test"`。任何其他值都是错误的。'
- en: '`path`: This is the JSON pointer that represents the location in the JSON document.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是表示JSON文档中位置的JSON指针。'
- en: '`value`: This denotes the value to be replaced in the JSON document.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这表示要在JSON文档中替换的值。'
- en: The `move` operation takes a `"from"` member, which identifies the location
    in the target document to move the value from.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`操作需要一个`"from"`成员，用于标识要从中移动值的目标文档中的位置。'
- en: 'Here is an example of a JSON Patch document sent in a `HTTP PATCH` request:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON Patch文档的示例，发送在`HTTP PATCH`请求中：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding request shows how JSON Patch can be used to replace the status
    of a coffee order identified by resource `coffee/orders/1234` .The operation,
    that is, `"op"` in the preceding snippet, is `"replace"`, which sets the value
    `"COMPLETED"` to the status object in the JSON representation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述请求显示了如何使用JSON Patch来替换由资源`coffee/orders/1234`标识的咖啡订单的状态。操作，即上面片段中的`"op"`，是`"replace"`，它将值`"COMPLETED"`设置为JSON表示中状态对象的值。
- en: The JSON Patch is very useful for single-page applications, real-time collaboration,
    offline data changes, and can also be used in applications that need to make small
    updates in large documents. For more details, check [http://jsonpatchjs.com/](http://jsonpatchjs.com/),
    which is an implementation of `JSON Patch.(RFC 6902)` and `JSON Pointer.(RFC 6901)`
    under the MIT License.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Patch对于单页应用程序、实时协作、离线数据更改非常有用，也可以用于需要在大型文档中进行小型更新的应用程序。有关更多详细信息，请查看[http://jsonpatchjs.com/](http://jsonpatchjs.com/)，这是`JSON
    Patch.(RFC 6902)`和`JSON Pointer.(RFC 6901)`的实现，采用MIT许可证。
- en: Recommended reading
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'The following section lists some of the online resources that are related to
    the topics covered in this chapter and may be useful for review:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分列出了与本章涵盖的主题相关的一些在线资源，可能对复习有用：
- en: 'RESTEasy: [http://resteasy.jboss.org/](http://resteasy.jboss.org/)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RESTEasy: [http://resteasy.jboss.org/](http://resteasy.jboss.org/)'
- en: 'Couchbase: [http://www.couchbase.com/](http://www.couchbase.com/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Couchbase: [http://www.couchbase.com/](http://www.couchbase.com/)'
- en: 'Facebook Graph API Explorer: [https://developers.facebook.com/](https://developers.facebook.com/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Facebook Graph API Explorer: [https://developers.facebook.com/](https://developers.facebook.com/)'
- en: 'RabbitMQ: [https://www.rabbitmq.com/](https://www.rabbitmq.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RabbitMQ: [https://www.rabbitmq.com/](https://www.rabbitmq.com/)'
- en: 'JSON Patch RFC 6902: [http://tools.ietf.org/html/rfc6902](http://tools.ietf.org/html/rfc6902)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON Patch RFC 6902: [http://tools.ietf.org/html/rfc6902](http://tools.ietf.org/html/rfc6902)'
- en: 'JSON Pointer RFC 6901: [http://tools.ietf.org/html/rfc6901](http://tools.ietf.org/html/rfc6901)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON Pointer RFC 6901: [http://tools.ietf.org/html/rfc6901](http://tools.ietf.org/html/rfc6901)'
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered some serious ground introducing fundamental concepts of
    caching, demonstrating the different HTTP caching headers such as `Cache-Control`,
    `Expires`, and so on. We also saw how headers work and how ETags and `Last-Modified`
    headers work for conditional `GET` requests that can improve performance. We covered
    best practices for caching, how RESTEasy supports server-side caching, and how
    Facebook API uses ETags. This chapter addressed asynchronous RESTful resources
    and best practices when working with an asynchronous API. We covered HTTP Patch
    and partial updates along with JSON Patch (RFC 6902).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了缓存的基本概念，演示了不同的HTTP缓存头，如`Cache-Control`，`Expires`等。我们还看到了头部是如何工作的，以及ETags和`Last-Modified`头部如何用于条件`GET`请求以提高性能。我们介绍了缓存的最佳实践，RESTEasy如何支持服务器端缓存，以及Facebook
    API如何使用ETags。本章讨论了异步RESTful资源以及在使用异步API时的最佳实践。我们介绍了HTTP Patch和JSON Patch（RFC 6902）以及部分更新。
- en: The next chapter will deal with advanced topics that every developer building
    RESTful services should know related to commonly used patterns and best practices
    in areas of rate limiting, response pagination, and internationalization of REST
    resources. It will also cover additional topics such as HATEOAS, REST, and their
    extensibility.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涉及每个构建RESTful服务的开发人员都应该了解的高级主题，涉及常用模式和最佳实践，如速率限制、响应分页和REST资源的国际化。它还将涵盖其他主题，如HATEOAS、REST及其可扩展性。
