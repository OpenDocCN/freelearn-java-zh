- en: Configuring Continuous Integration Using Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins配置持续集成
- en: In this chapter, we will teach you how to integrate the pet store application
    with Jenkins, a **Continuous Integration** (**CI**) server. We will introduce
    CI concepts and how they can be implemented using Jenkins. We will configure a
    sample `pipeline` so that you can see how changes in application code are propagated
    to the deployed application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将教你如何将宠物商店应用程序与Jenkins，一个**持续集成**（**CI**）服务器集成。我们将介绍CI概念以及如何使用Jenkins实现它们。我们将配置一个示例`pipeline`，以便你可以看到应用程序代码中的更改是如何传播到已部署的应用程序的。
- en: Let's start with the builds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建开始。
- en: Learning OpenShift builds
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习OpenShift构建
- en: 'In the previous chapters, we did some serious magic in order to build our application.
    To be able to run the builds, we executed the following command:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们为了构建我们的应用程序做了一些真正的魔法。为了能够运行构建，我们执行了以下命令：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In previous chapters, when we wanted to build our application, we invoked the
    following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，当我们想要构建我们的应用程序时，我们调用了以下命令：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After a lot of mysterious stuff had happened (as indicated by growing logs),
    we were able to see our application working. Now, it's time to explain what actually
    happened under the hood. Let's get to know OpenShift builds.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了许多神秘事件（如日志增长所示）之后，我们终于看到了我们的应用程序正在运行。现在，是时候解释一下底层实际发生了什么。让我们来了解OpenShift构建。
- en: In general, an OpenShift build is an operation that transforms input parameters
    into a resulting object that is used to start an application. In most cases, the
    build will transform the source code into an image that will be later deployed
    on the cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个OpenShift构建是一个将输入参数转换成用于启动应用程序的结果对象的操作。在大多数情况下，构建会将源代码转换成一个将在集群上部署的镜像。
- en: 'The details of the build process operation depend on the build type (about
    which we will learn in a moment), but the general algorithm looks as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程操作的细节取决于构建类型（我们将在稍后学习），但一般的算法如下：
- en: The build container starts from the build image
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建容器从构建镜像开始
- en: Sources from all the inputs are being injected into the container
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有输入源都被注入到容器中
- en: The build scripts are being run
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建脚本正在运行
- en: The output docker image is created
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成了输出Docker镜像
- en: The new concept that is being introduced here is the build container. Let's
    take a look at it a little bit closer. What actually is its purpose? The container
    in which you are building your application has to contain all the libraries, tools,
    and runtimes that are necessary to build and run your application. For example,
    if you use the WildFly AS builder image, it will contain Java, Maven, and WildFly
    runtimes among others. After the application is built, the same image is used
    as a base for the Docker image that will be deployed to OpenShift. Speaking precisely,
    your application will be added as another layer on top of the builder image, resulting
    in a runnable image with your application. The good news here is that although
    you can easily create an image yourself, in most cases those images will be created
    by the tool provider.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入的新概念是构建容器。让我们更仔细地看看它。它实际上有什么目的？你构建应用程序的容器必须包含构建和运行应用程序所需的所有库、工具和运行时。例如，如果你使用WildFly
    AS构建镜像，它将包含Java、Maven和WildFly运行时等。应用程序构建完成后，相同的镜像将用作部署到OpenShift的Docker镜像的基础。更准确地说，你的应用程序将作为另一个层添加到构建镜像之上，从而生成一个包含你的应用程序的可运行镜像。好消息是，虽然你可以轻松地自己创建镜像，但在大多数情况下，这些镜像将由工具提供商创建。
- en: The input types can be provided from any resources, such as GitHub repositories,
    existing images, and Dockerfile config. All the sources that you provide are unpacked
    and merged together in the build directory, which will be processed by the builder
    image during the build. The option that we will use (and actually have used a
    few times already) in this book is GitHub repositories.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入类型可以从任何资源提供，例如GitHub仓库、现有镜像和Dockerfile配置。你提供的所有源都会在构建目录中解包并合并，该目录将由构建镜像在构建过程中处理。在这本书中我们将使用（实际上已经多次使用）的选项是GitHub仓库。
- en: As we mentioned previously, the precise way in which a build works depends on
    the build type. You will be able to define the type of build by specifying the
    build strategy. You can create images using Docker, Source-to-image of custom
    builds. The build type that is most interesting for us is the source-to-image
    build, which we will explain in the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，构建的工作方式取决于构建类型。您可以通过指定构建策略来定义构建类型。您可以使用 Docker、源到镜像或自定义构建来创建镜像。对我们来说最有兴趣的构建类型是源到镜像构建，我们将在下一节中解释。
- en: There is also another type of build—`pipeline`. The `pipeline` build is connected
    to the Jenkins CI server and allows you to create a fully featured **Continuous
    Deployment** (**CD**) `pipeline`. We will describe this kind of build thoroughly
    in the second part of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种类型的构建——“管道”。`pipeline` 构建连接到 Jenkins CI 服务器，允许您创建一个功能齐全的 **持续部署** (`CD`)
    管道。我们将在本章的第二部分详细描述这种构建。
- en: Let's turn to the source-to-image build now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向源到镜像构建。
- en: Learning about the source-to-image build
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解源到镜像构建
- en: As we mentioned, the source-to-image build needs a builder image and you have
    to provide it each time when you are configuring such a build. The builder images
    contain scripts that are responsible for assembling and running the application.
    The assembling scripts will be run in phase 3 of the build algorithm, and the
    run script will be used as the start command of the resulting Docker image. During
    the build, the layer that contains the runnable application will be added on top
    of the builder image, the run script will be set as the image starting command,
    and the resulting image will be committed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，源到镜像构建需要一个构建器镜像，并且每次配置此类构建时都必须提供它。构建器镜像包含负责组装和运行应用程序的脚本。组装脚本将在构建算法的第
    3 阶段运行，运行脚本将用作最终 Docker 镜像的启动命令。在构建过程中，包含可运行应用程序的层将被添加到构建器镜像之上，运行脚本将被设置为镜像启动命令，最终镜像将被提交。
- en: 'We know the basics of source-to-image builds, so now we can explain what we
    did when deploying our application in the last chapters. Let''s start with the
    following command that we have invoked before running any builds:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了源到镜像构建的基础知识，因此现在我们可以解释在上一章部署我们的应用程序时我们做了什么。让我们从以下命令开始，这是我们在运行任何构建之前调用的命令：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command is responsible for including a YAML object file into
    our cluster. The main object created by this script is the Docker build configuration.
    If we examine our cluster using command-line tools, we will find that the new
    build config is created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令负责将 YAML 对象文件包含到我们的集群中。此脚本创建的主要对象是 Docker 构建配置。如果我们使用命令行工具检查我们的集群，我们会发现已创建新的构建配置：
- en: '![](img/10100531-2072-4a6f-862c-8a199630347d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10100531-2072-4a6f-862c-8a199630347d.png)'
- en: 'This is the build config for our builder image. We may now examine builds in
    the Web Console. We will be able to see that the build based on `wildfyswarm-10-centos7`
    config has already been executed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的构建器镜像的构建配置。我们现在可以检查 Web 控制台中的构建。我们将能够看到基于 `wildfyswarm-10-centos7` 配置的构建已经执行：
- en: '![](img/27d3b465-578f-4500-8bfd-7f6939ed0253.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27d3b465-578f-4500-8bfd-7f6939ed0253.png)'
- en: 'After the execution of the first command, the builder image was created and
    stored in the cluster. We can confirm this by navigating to Build | Images in
    the web console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行第一个命令后，构建器镜像被创建并存储在集群中。我们可以通过在 Web 控制台中导航到“构建 | 镜像”来确认这一点：
- en: '![](img/c4082b65-aeed-49d5-98c6-44dc07906834.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4082b65-aeed-49d5-98c6-44dc07906834.png)'
- en: As you will have noticed in the preceding screenshot, we have a new image, wildflyswarm-10-centos7,
    available in the cluster. An important thing to note here is that these images
    have been described as `ImageStreams`. What does that actually mean? `ImageStream`,
    as its name suggests, is an object that represents a stream of related objects.
    In our scenario, the `ImageStream` contains all images that are the result of
    the build of the builder image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，我们在集群中有一个新的镜像，wildflyswarm-10-centos7。在这里需要注意的一个重要事项是，这些镜像已被描述为
    `ImageStreams`。这实际上意味着什么？`ImageStream`，正如其名称所暗示的，是一个表示相关对象流的对象。在我们的场景中，`ImageStream`
    包含了构建器镜像构建的所有结果镜像。
- en: We created the BuildConfig for the builder image. The source for this image
    can change; if that happens, OpenShift will create a new version of this image
    and add it to the `ImageStream`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为构建器镜像创建了 BuildConfig。此镜像的源可能会更改；如果发生这种情况，OpenShift 将创建此镜像的新版本并将其添加到 `ImageStream`。
- en: The images in the stream can be tagged, and there is always the latest tag,
    which represents the latest image in the stream.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 流中的图片可以被标记，并且总是有最新的标记，它代表流中的最新图片。
- en: 'Let''s now examine the `new-app` command that we have used before:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查我们之前使用的 `new-app` 命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are now ready to explain what the `new-app` syntax means. It has two parts
    separated by a tilde. The first one is the name of the builder-image stream. The
    second one is the GitHub repository from which the application will be built.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好解释 `new-app` 语法意味着什么。它由两部分组成，由波浪号分隔。第一部分是构建镜像流的名称。第二部分是应用程序将从中构建的 GitHub
    仓库。
- en: After we know the internals of the source-to-image build, we can run the build
    again and examine the build log.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道源到镜像构建的内部原理之后，我们可以再次运行构建并检查构建日志。
- en: 'First, we have to remove the `pricing-service` that we have deployed previously:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须删除我们之前部署的 `pricing-service`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, we are ready to execute the `new-app` command and use web console
    to inspect the log:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们准备好执行 `new-app` 命令，并使用网页控制台来检查日志：
- en: '![](img/6d2191fd-ea40-40bd-8421-8d167f128521.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d2191fd-ea40-40bd-8421-8d167f128521.png)'
- en: 'Oops! We have to download all the dependencies. This fact will result in build
    taking a substantial amount of time:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们必须下载所有依赖项。这个事实将导致构建需要花费大量时间：
- en: '![](img/ea37e902-8fa9-457e-b7e6-fcdaa2c0f279.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea37e902-8fa9-457e-b7e6-fcdaa2c0f279.png)'
- en: This was just a first build. So, what will happen when we run the build for
    the second time?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个第一次构建。那么，当我们第二次运行构建时会发生什么？
- en: You can use the web console to force the second build and inspect the log to
    verify that the dependencies are downloaded again.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用网页控制台强制进行第二次构建，并检查日志以验证依赖项是否已重新下载。
- en: This is a serious inconvenience, as it results in much longer build types. Can
    we do something about it? Yes, we can use incremental builds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种严重的不便，因为它会导致构建类型的时间大大增加。我们能做些什么吗？是的，我们可以使用增量构建。
- en: The incremental build is a feature of the source-to-image build, which extracts
    the build artifacts from the previously created image and uses them to build the
    next one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 增量构建是源到镜像构建的一个特性，它从先前创建的镜像中提取构建艺术品，并使用它们来构建下一个镜像。
- en: Our builder image uses the Maven plugin to build a Swarm application, so the
    artifacts that are being downloaded are the Maven dependency JARs. Usually, different
    build tools and different types of the artifact will be used. As a result, the
    specific type of incremental build has to be implemented by the image provider.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建镜像使用 Maven 插件来构建 Swarm 应用程序，因此正在下载的艺术品是 Maven 依赖 JAR。通常，不同的构建工具和不同类型的艺术品将使用。因此，特定的增量构建类型必须由镜像提供商实现。
- en: In the case of a Swarm builder image, the Maven artifacts are being extracted
    from the last image and placed in the Maven repo of the new one. As a result,
    artifacts that are being used many times have to be downloaded only once. Furthermore,
    in order to decrease the time spent downloading the JARs, you can use a Maven
    mirror.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swarm 构建镜像的情况下，Maven 艺术品正从最后一个镜像中提取出来，并放置在新的 Maven 仓库中。因此，被多次使用的艺术品只需要下载一次。此外，为了减少下载
    JAR 的时间，您可以使用 Maven 镜像。
- en: OK. However, how can we turn the incremental build on? We have to edit the YAML
    of our build.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然而，我们如何开启增量构建？我们必须编辑我们的构建的 YAML 文件。
- en: 'Let''s use the web console for that. We have to select the `pricing-service`
    build and navigate to Actions | Edit YAML in the top-right corner of the screen.
    The YAML has to be edited in the following way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用网页控制台来做这件事。我们必须选择 `pricing-service` 构建，并导航到屏幕右上角的操作 | 编辑 YAML。YAML 必须按照以下方式编辑：
- en: '![](img/42b76cfa-1eb5-4675-90ed-4105e381b73e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42b76cfa-1eb5-4675-90ed-4105e381b73e.png)'
- en: As you will have noticed in the preceding screenshot, we found the `sourceStrategy`
    section of the build config and added an incremental property with a value set
    to `true`. Let's run our build again to see what happens.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，我们在构建配置的 `sourceStrategy` 部分添加了一个增量属性，并将其值设置为 `true`。让我们再次运行我们的构建，看看会发生什么。
- en: 'In our new build log, we can see two optimistic lines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新的构建日志中，我们可以看到两条乐观的行：
- en: '![](img/6bc49bc1-f288-4f34-a5c4-08638921b56b.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bc49bc1-f288-4f34-a5c4-08638921b56b.png)'
- en: 'The first optimistic line is at the beginning where Maven informs us that the
    artifacts are being restored and the second one is at the end:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条乐观的行在开始处，Maven 通知我们艺术品正在被恢复，第二条在结尾：
- en: '![](img/3aca6699-48da-44b9-92be-8621be134dbf.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aca6699-48da-44b9-92be-8621be134dbf.png)'
- en: The build has taken only `16.347` seconds, not much longer than the standalone
    Maven build.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构建只用了`16.347`秒，并没有比独立的Maven构建长多少。
- en: Configuring environment variables
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置环境变量
- en: When we were deploying our services, we provided an environment variables script
    for catalog and `pricing-services` that needs to interact with our database. Processing
    this configuration file is also the responsibility of the source-to-image build.
    If a user wants to provide environment properties to the build, they have to create
    a `.s2i` directory in the root of the service's GitHub repository and create an
    environment file that will contain a list of key-value pairs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署我们的服务时，我们为目录和`定价服务`提供了环境变量脚本，这些脚本需要与我们的数据库交互。处理这个配置文件也是源到镜像构建的责任。如果用户想要向构建提供环境属性，他们必须在服务的GitHub仓库根目录下创建一个`.s2i`目录，并创建一个包含键值对的列表的环境文件。
- en: 'For example, let''s recall the configuration file for the `pricing-service`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾一下`定价服务`的配置文件：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Properties set in this file will be available as environment variables during
    the image build and during its execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中设置的属性将在镜像构建期间及其执行期间作为环境变量可用。
- en: The whole source-to-image algorithm
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整个源到镜像算法
- en: 'After covering the specifics of the source-to-image build operation, let''s
    recap the steps in Swarm''s `s2i` build:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细介绍了源到镜像构建操作的具体内容后，让我们回顾一下Swarm的`s2i`构建步骤：
- en: The container on which the build will take place is created from the builder
    image.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行构建的容器是由构建镜像创建的。
- en: The sources of an application are injected into the container.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的源代码将被注入到容器中。
- en: If incremental builds are enabled, the Maven artifacts will be restored from
    the previous build image.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果启用了增量构建，Maven工件将从之前的构建镜像中恢复。
- en: If provided, environment variables are set.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供了，环境变量将被设置。
- en: The assembly script, provided by the image creator, is executed.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由镜像创建者提供的组装脚本被执行。
- en: The image is committed with the start command set to the run script provided
    by the image creator.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像被提交，启动命令设置为镜像创建者提供的运行脚本。
- en: A developer who will like to build their applications using the source-to-image
    build has to provide the name of the builder image and the source code of an application.
    A developer can enable the incremental build and provide environment variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用源到镜像构建来构建他们的应用程序的开发者必须提供构建镜像的名称和应用程序的源代码。开发者可以启用增量构建并提供环境变量。
- en: Source-to-image summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源到镜像概要
- en: Now that we have covered how the source-to-image build works internally, it's
    time to look at it from a wider perspective.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了源到镜像构建的内部工作原理，是时候从更广泛的角度来看待它了。
- en: The source-to-image build is another tool provided by OpenShift that abstracts
    away the details of the Kubernetes cluster, providing a simple interface for the
    developer. The role of the developer is to provide the source code and the name
    of the image that will be used to build it. It is the responsibility of the image
    creator to assemble the Docker image that will be deployed on the cluster.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift提供的源到镜像构建工具是另一个抽象化Kubernetes集群细节的工具，为开发者提供了一个简单的接口。开发者的角色是提供源代码和将要用于构建的镜像名称。创建镜像的责任在于组装将在集群上部署的Docker镜像。
- en: Again, this leads to the separation of concerns—the builder image provider is
    responsible for assembling source in an optimal way and the details of those optimizations
    don't have to be known by the developer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这导致了关注点的分离——构建镜像提供者负责以最佳方式组装源代码，而这些优化的细节不需要开发者知道。
- en: The performance implications of builds resulting from the build architecture
    are as follows. The libraries that are needed to perform the build and create
    the runnable container are located in the builder image, which is created once
    (and later only updated) inside the cluster. The artifacts that are being downloaded
    during the build can be restored from previous builds if the incremental build
    is enabled. Owing to that, the dependencies of the application can be downloaded
    only once and later reused. This leads to a very fast build time. As you may remember,
    the build of our pricing service took only about 16 seconds, which is only a few
    seconds more than standalone Maven builds on a modern workstation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由构建架构产生的构建的性能影响如下。执行构建和创建可运行容器所需的库位于创建一次（并且后来只在集群内更新）的构建镜像中。在构建过程中下载的工件如果启用了增量构建，可以从之前的构建中恢复。因此，应用程序的依赖项只需下载一次，以后可以重复使用。这导致构建时间非常快。正如你可能记得的那样，我们的定价服务的构建只花了大约16秒，这比现代工作站上的独立Maven构建只多了几秒钟。
- en: Moreover, the reproducibility, which is one of the constant benefits of using
    Docker, holds for builder images also. All the builds are performed using exactly
    the same image. As a result, it is guaranteed that the build result will be the
    same on all of your environments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Docker使用的恒定好处之一——可重复性，也适用于构建镜像。所有构建都是使用完全相同的镜像进行的。因此，可以保证构建结果在所有环境中都是相同的。
- en: In addition, since builder images are just standard Docker containers and the
    explicit builder contract allows tool creators to write builder images easily,
    there is an wide variaty of Docker builder images that you can use. You, as a
    developer, already have access to a wide variety of builder images dedicated to
    number of development tools.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于构建镜像只是标准的Docker容器，并且明确的构建者合约允许工具创建者轻松编写构建镜像，因此有各种各样的Docker构建镜像可供使用。作为开发者，你已经可以访问到大量针对各种开发工具的专用构建镜像。
- en: In the end, a source-to-image build tool is a tool that represents the core
    of the OpenShift philosophy. It provides a simple developer interface, which abstracts
    away the cluster internals, and under the hood it implements the an optimized
    build process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，源到镜像构建工具是代表OpenShift哲学核心的工具。它提供了一个简单的开发者界面，该界面抽象了集群内部结构，并且底层实现了优化的构建过程。
- en: The developer view
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者视图
- en: Till now, we have explained in detail how the source-to-image build builds an
    image based on your code. The new-app command does not just create the build though.
    As you remember, after its execution, we were able to test the working application.
    Clearly, the build and image are not the only product of the command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细解释了源到镜像构建是如何根据你的代码构建镜像的。新应用命令不仅仅创建构建。正如你记得的那样，执行后，我们能够测试运行中的应用。显然，构建和镜像并不是命令的唯一产品。
- en: Apart from the `BuildConfiguration`, the new-app command creates the `DeploymentConfiguration`
    (that we described in [Chapter 6](461aee71-984a-4158-addc-fc49341d3455.xhtml),
    *Deploying Applications on the Cloud with OpenShift*) and an `ImageStream` for
    our application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`BuildConfiguration`之外，新应用命令还会创建`DeploymentConfiguration`（我们在[第6章](461aee71-984a-4158-addc-fc49341d3455.xhtml)中描述过，*使用OpenShift在云上部署应用程序*）以及为我们应用创建的`ImageStream`。
- en: 'Let''s take a look at the created objects in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图中创建的对象：
- en: '![](img/2bbdeae3-1b57-4028-979a-edb786780b6a.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bbdeae3-1b57-4028-979a-edb786780b6a.png)'
- en: In the preceding diagram, the objects related to the builder image are colored
    red, build-related objects are colored blue, and deployment-related objects are
    colored green. The build is triggered by a developer by pushing changes to GitHub.
    It results in the creation of the build objects. If the build is successful, the
    image is pushed to the image stream. This further triggers the deployment of the
    application, which, if successful, results in the creation of application services.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，与构建镜像相关的对象被涂成红色，与构建相关的对象被涂成蓝色，与部署相关的对象被涂成绿色。构建是由开发者通过将更改推送到GitHub触发的。它导致构建对象的创建。如果构建成功，镜像将被推送到镜像流。这进一步触发了应用的部署，如果部署成功，将导致应用服务的创建。
- en: The important thing to note is that, in the simplest scenario, a developer may
    be responsible only for pushing the changes to the repository—in other words,
    programming and their changes will be propagated to the cluster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，在最简单的场景中，开发者可能只需负责将更改推送到仓库——换句话说，编程及其更改将被传播到集群中。
- en: 'That''s nice again, but, in some scenarios, we will like to have more than
    that: a full CD `pipeline` with integration tests, checking the deployed application,
    or staging the changes in different environments. As we hinted earlier, we can
    integrate an OpenShift cluster with Jenkins to use its full power to implement
    the CD `pipeline` for our services. Let''s learn how to do it.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错，但在某些场景中，我们希望得到更多：一个包含集成测试、检查已部署的应用程序或在不同环境中预演更改的完整CD `管道`。正如我们之前暗示的，我们可以将OpenShift集群与Jenkins集成，以充分利用其全部功能来为我们服务的实现CD
    `管道`。让我们学习如何做到这一点。
- en: Pipeline build
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道构建
- en: In the first chapter, when we were explaining why you may be considering implementing
    the microservice architecture in your applications, we mentioned the challenges
    that are being currently faced by application developers and architects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，当我们解释为什么你可能会考虑在你的应用程序中实施微服务架构时，我们提到了当前应用程序开发人员和架构师面临的一些挑战。
- en: One of the key tools that may enable us to deal with providing software in a
    way that enables us to meet those challenges is automation. As we covered in the
    preceding chapter, OpenShift enables us to automate infrastructure provisioning.
    However, we need more than that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可能使我们能够以使我们能够应对那些挑战的方式提供软件的关键工具之一是自动化。正如我们在上一章中提到的，OpenShift使我们能够自动化基础设施的提供。然而，我们需要的不仅仅是这些。
- en: We will also like to automate the process of deploying software into production.
    Ideally, we will like to have tools that will enable us to release software immediately.
    OpenShift provides such a tool in the form of the build `pipeline`. Let's introduce
    the rationale behind this concept.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望自动化将软件部署到生产环境的过程。理想情况下，我们希望拥有能够使我们立即发布软件的工具。OpenShift以构建`管道`的形式提供了这样的工具。让我们介绍这个概念背后的原理。
- en: Let's start with CI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从持续集成（CI）开始。
- en: Continuous integration
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: As a developer, you know too well what the development of projects looks like.
    There are many developers working on different functionalities, which they contribute
    to the same repository. Contributions from all the developers have to be integrated
    into the code repository so that stable code is created. After that, the code
    can be published into the production environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你对项目的开发过程了如指掌。有许多开发者正在处理不同的功能，并将它们贡献给同一个仓库。所有开发者的贡献都必须集成到代码仓库中，以便创建稳定的代码。之后，代码可以发布到生产环境。
- en: This sounds simple, but if you don't create an organized order according to
    which this process is executed, you will quickly end up with a huge mess. If the
    developers will integrate rarely, they are asking for problems. Their repositories
    will be highly diverged, and the application's functionality will be scattered
    between their repositories. As a result, during the development, there will be
    no *current state* source repository, and we will have no information about the
    state of an application. The new version of an application will emerge during
    the time people decide to push their contribution to the main code (which will
    presumably happen the day before the release). The process of integration at this
    point will be painful, where incompatible contributions are being discovered,
    and errors will emerge. Such a situation was described in the past as *integration
    hell*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很简单，但如果你不创建一个执行此过程的有序顺序，你很快就会陷入混乱。如果开发者很少集成，他们就是在自找麻烦。他们的仓库将高度分歧，应用程序的功能将在他们的仓库之间分散。结果，在开发过程中，将没有*当前状态*的源仓库，我们将没有关于应用程序状态的信息。应用程序的新版本将在人们决定将他们的贡献推送到主代码（这可能会发生在发布的前一天）时出现。此时，集成过程将是痛苦的，不兼容的贡献将被发现，错误将出现。这种情况在过去被描述为*集成地狱*。
- en: Owing to the preceding problems, it became clear that it will be a good idea
    to integrate code frequently. The methodology that advocates such a behavior and,
    more importantly, gives hints on how to do it, is called CI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提到的问题，很明显，频繁地集成代码是一个好主意。提倡这种行为并，更重要的是，提供如何操作的提示的方法论被称为持续集成（CI）。
- en: 'Obviously, pushing the code frequently to the repository is not helping us
    much. At each commit, we need to make sure that the current version of the code
    at least compiles, and passes unit and integration tests. This is by no means
    a comprehensive list: to declare your code correctly, you may also need automatic
    code inspections or code reviews to name a few.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，频繁地将代码推送到仓库并不能给我们带来太多帮助。在每次提交时，我们需要确保当前版本的代码至少能够编译，并且通过单元和集成测试。这绝对不是一个详尽的列表：为了正确声明你的代码，你可能还需要自动代码检查或代码审查等。
- en: In order for this process to be executed consistently, it has to be automated
    and executed each time the user wants to make the change to the code. Also, developers
    are supposed to integrate their code frequently, with each logical functionality
    developed, and are supposed to fix any errors that appear as soon as possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此过程能够持续执行，它必须自动化，并在用户想要对代码进行更改时执行。此外，开发者应频繁地集成他们的代码，在每个逻辑功能开发完成后，应尽快修复出现的任何错误。
- en: 'If this procedure is observed, this will lead to a number of benefits:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遵循此程序，这将带来许多好处：
- en: Problems are detected quickly. As the result, their source can be debugged and
    fixed quickly.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题能够迅速被发现。因此，它们的源头可以迅速调试和修复。
- en: The current version of the application is always present—it is the result of
    the last successful build. At each point, we can tell the status of the application,
    how it works, and what functionalities have been currently implemented.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序的版本始终存在——它是最后一次成功构建的结果。在每一个点上，我们都可以了解应用程序的状态、其工作原理以及目前实现了哪些功能。
- en: The automated process works as a trigger for quality control. The build is guaranteed
    to be run and be reproducible.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化过程作为质量控制的一个触发器。构建保证能够运行并且可重复。
- en: Continuous deployment
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署
- en: Continuous Integration ensures continuous builds of source code. It demands
    that fixes are pushed often and provides instant feedback to the developers. What
    if we extend this notion and configure our build infrastructure so that it will
    ensure that our services will be built and deployed automatically?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成确保源代码的持续构建。它要求经常推送修复，并为开发者提供即时反馈。如果我们扩展这个概念，并配置我们的构建基础设施，以确保我们的服务将自动构建和部署，会怎样呢？
- en: Such an approach, which is an extension of CI, is called Continuous Deployment.
    To implement it, we will need to automate the release process also. This means
    that we will have to keep all the resources that are needed to release the software
    to the given environment, such as environment properties or configuration scripts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，作为持续集成的扩展，被称为持续部署。为了实施它，我们还需要自动化发布过程。这意味着我们必须保留所有需要发布软件到指定环境的资源，例如环境属性或配置脚本。
- en: As a reward, we will be able to obtain reliable and repeatable releases. First
    of all, as the release process is no longer manual, all the magic is taken away
    from the release process. The release is executed by the release script using
    environment properties, which are both parts of the versioned build configuration.
    Those files are the one source-of-truth regarding the build process. As a result,
    if an error occurs during the build, those scripts have to be fixed. There is
    no place for manual patches or ad hoc fixes. Also, builds happen often, so configuration
    bugs will have an opportunity to occur and be fixed. On the other hand, after
    builds and releases start to work correctly, each next correct build adds more
    confidence in the release process. As a result, the release becomes a well-tested
    and an automated event.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，我们将能够获得可靠且可重复的发布。首先，由于发布过程不再是手动的，发布过程中的所有魔法都被移除了。发布是通过使用环境属性（这些属性是版本化构建配置的一部分）的发布脚本来执行的。这些文件是关于构建过程的一个单一真相来源。因此，如果在构建过程中发生错误，这些脚本必须被修复。没有地方可以进行手动修补或临时修复。此外，构建经常发生，因此配置错误将有机会发生并被修复。另一方面，一旦构建和发布开始正常工作，每个后续的正确构建都会增加对发布过程的信心。因此，发布成为一个经过充分测试和自动化的活动。
- en: Such an approach changes the way the team works by changing the speed at which
    features are developed. With CD, you are not releasing the software in large chunks
    to the client. Instead, small functionalities are released often and are immediately
    visible to the client.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过改变开发功能的速度来改变团队的工作方式。使用持续部署（CD），你不是将软件的大块内容一次性发布给客户。相反，小的功能经常发布，并且立即对客户可见。
- en: 'This is the expected behavior for a number of reasons. First, customers will
    like to respond to client demand as quickly as possible. Having the tool that
    enables them to do that will be a big market advantage for the customer. However,
    there is more to it: because new functionalities are released often, they are
    visible to the customer immediately. As a result, a customer can immediately assess
    the actually implemented functionality. This creates an efficient feedback loop
    between the developers and the customers, which allow for faster convergence to
    the functionality actually expected by the client.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为许多原因的预期行为。首先，客户会希望尽可能快地响应客户需求。拥有使他们能够做到这一点的工具将是客户的一个很大的市场优势。然而，这不仅仅是这样：因为新功能经常发布，它们会立即对客户可见。因此，客户可以立即评估实际实施的功能。这就在开发者和客户之间创建了一个有效的反馈循环，使他们能够更快地达到客户实际期望的功能。
- en: Deployment pipeline
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署管道
- en: The process of automatic delivery is implemented using a `pipeline`. A `pipeline`
    is a chain of steps that takes the source code as its input and provides a working
    application on it's output.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自动交付的过程是通过一个`pipeline`实现的。`pipeline`是一系列步骤，它以源代码作为输入，并在其输出上提供一个可工作的应用程序。
- en: The goal of the `pipeline` is to make sure that the source code is ready to
    be deployed in production. As a result, a `pipeline` should be able to catch errors
    as soon as possible and provide feedback to the developers immediately.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline`的目标是确保源代码准备好在生产环境中部署。因此，`pipeline`应该能够尽快捕获错误，并立即向开发者提供反馈。'
- en: Also, because the final product is the released application, a `pipeline` should
    automate the release process so that it is run the same in all environments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为最终产品是发布的应用程序，`pipeline`应该自动化发布过程，以便它在所有环境中运行相同。
- en: 'Although a `pipeline` is a configurable script and its direct operation depends
    on your concrete environment, there are a number of common steps that are executed
    in the deployment `pipeline`: commit, build, automatic tests, manual tests, release,
    and so on.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`pipeline`是一个可配置的脚本，其直接操作取决于你的具体环境，但在部署`pipeline`中执行了许多常见的步骤：提交、构建、自动测试、手动测试、发布等。
- en: Configuring Continuous Deployment in OpenShift environments
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenShift环境中配置持续部署
- en: After this quick theory recap, now let's return to our cluster and configure
    CD for our application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速回顾理论之后，现在让我们回到我们的集群，并为我们的应用程序配置CD。
- en: At the beginning of this chapter, we described the source-to-image build, which
    we have used in previous chapters. We also hinted that there is a `pipeline` build
    available. As you probably have guessed by now, this is the kind of build that
    we will use to implement CD of our services.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们描述了源到镜像的构建，我们在前面的章节中使用了它。我们还暗示了有一个`pipeline`构建可用。正如你现在可能已经猜到的，这是我们用来实现服务CD的构建类型。
- en: The `pipeline` build uses the Jenkins server to configure the `pipeline` configuration.
    Before moving further, let's introduce it quickly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline`构建使用Jenkins服务器来配置`pipeline`配置。在继续之前，让我们快速介绍一下它。'
- en: Introducing Jenkins
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jenkins
- en: Jenkins is an open source software automation server. It allows for `pipeline`
    creation and provides the relevant syntax. So, how are we able to use Jenkins
    in OpenShift cluster and configure `pipeline` execution? Let's find out.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个开源的软件自动化服务器。它允许创建`pipeline`并提供相关的语法。那么，我们如何在OpenShift集群中使用Jenkins并配置`pipeline`执行呢？让我们来看看。
- en: Our first pipeline
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个`pipeline`
- en: Let's start by creating our first `pipeline`. We have to log in to our web console
    and navigate to Add to project | Import YAML.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的第一个`pipeline`开始。我们必须登录到我们的网页控制台，并导航到“添加到项目”|“导入YAML”。
- en: 'In order to do that, we have to go the web console''s main web page and navigate
    to Add to Project | Import YAML/Json and enter the following script there:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须进入网页控制台的主网页，并导航到“添加到项目”|“导入YAML/Json”，并在那里输入以下脚本：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the script is created, we can click on the Create button:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本创建后，我们可以点击创建按钮：
- en: '![](img/36d6de0a-fbfe-4258-90d7-67401a187b42.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36d6de0a-fbfe-4258-90d7-67401a187b42.png)'
- en: 'Before we look further at the `pipeline` code, let''s note the other things
    that are happening. If we get to the main view of the web console, we will note
    that there is a new resource:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步查看`pipeline`代码之前，让我们注意正在发生的事情。如果我们到达网页控制台的主视图，我们会注意到有一个新的资源：
- en: '![](img/55b9a649-623f-46d3-b307-cc79a79bd3ae.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55b9a649-623f-46d3-b307-cc79a79bd3ae.png)'
- en: 'Let''s take a look at the currently available Pods too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前可用的 Pods：
- en: '![](img/c055352a-525b-4747-a18a-617bbbc0ec87.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c055352a-525b-4747-a18a-617bbbc0ec87.png)'
- en: Indeed, there is a new deployment of Jenkins server running, and the container
    for the Jenkins server is being created. OpenShift runs a `pipeline` build using
    the Jenkins server. Therefore, whenever you create a `pipeline`, OpenShift must
    check whether there is a Jenkins server present in the cluster. If not, OpenShift
    will start one automatically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，有一个新的 Jenkins 服务器正在运行部署，并且 Jenkins 服务器的容器正在创建中。OpenShift 使用 Jenkins 服务器运行
    `pipeline` 构建。因此，每次你创建一个 `pipeline` 时，OpenShift 都必须检查集群中是否存在 Jenkins 服务器。如果没有，OpenShift
    将自动启动一个。
- en: The creation of the Jenkins server takes some time, so we have to wait till
    it has been deployed. After we are able to see that the application is running
    in the Pods view, we are ready to start the build of our first `pipeline`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 服务器创建需要一些时间，所以我们必须等待它被部署。在我们能够在 Pods 视图中看到应用程序正在运行后，我们就准备好开始构建我们的第一个
    `pipeline`。
- en: 'In order to do that, let''s navigate to Build | Pipelines. You will be able
    to see that there is a new `pipeline` present:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们导航到“构建 | Pipelines”。你将能够看到有一个新的 `pipeline` 存在：
- en: '![](img/3d6f27c8-2cb8-46a8-a715-4e9def53639d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d6f27c8-2cb8-46a8-a715-4e9def53639d.png)'
- en: 'Let''s click on the Start Pipeline button and see what happens:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击“开始 Pipeline”按钮，看看会发生什么：
- en: '![](img/9994127a-285b-4024-8a8c-5b96cb1ec677.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9994127a-285b-4024-8a8c-5b96cb1ec677.png)'
- en: 'Note in the preceding screenshot that the build has run. The dot with the tick
    described as Print means that one stage has been run and that it has been successful.
    We will be talking about the Jenkins `pipeline` structure in just a moment. Now,
    let''s take a look at more information about our current build by clicking on
    the View Log button:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的截图中的构建已经运行。带有勾选标记的点表示一个阶段已经运行并且成功。我们将在稍后讨论 Jenkins `pipeline` 结构。现在，让我们通过点击“查看日志”按钮来查看更多关于当前构建的信息：
- en: '![](img/d7e6c34b-3b7c-4150-a09b-bf2e49a2921b.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7e6c34b-3b7c-4150-a09b-bf2e49a2921b.png)'
- en: As you will have noticed in the preceding screenshot, we have been redirected
    to the Jenkins console. The build has been created, the Print stage has been executed,
    and the print message that we have echoed has indeed been written to a log.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的截图中所注意到的，我们已经被重定向到 Jenkins 控制台。构建已经创建，打印阶段已经执行，我们回显的打印消息确实已经写入日志。
- en: 'As you can see, the `pipeline` build configuration has been automatically turned
    into the Jenkins build and run in the Jenkins console. We will get more information
    about the build when we click on petstore/pricing-service-pipeline in the top-left
    corner of the screen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`pipeline` 构建配置已经自动转换为 Jenkins 构建，并在 Jenkins 控制台中运行。当我们点击屏幕左上角的 petstore/pricing-service-pipeline
    时，我们将获得更多关于构建的信息：
- en: '![](img/f82c848c-08f8-40bd-a744-5dac8d233a5f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f82c848c-08f8-40bd-a744-5dac8d233a5f.png)'
- en: From this window, we can trace the build history, view the logs and time of
    the latest execution, or edit the `pipeline`, among others. At this point, it
    is good to look again at the script that we have written in order to create the
    `pipeline`. You probably have noted immediately that the Jenkins `pipeline` was
    squashed into one line, making it hard to read and edit. Before we take any other
    steps, let's find a human way to edit our `pipeline`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，我们可以追踪构建历史，查看最新执行的日志和时间，或者编辑 `pipeline` 等。在这个时候，再次查看我们为创建 `pipeline`
    编写的脚本是个好主意。你可能立刻就注意到 Jenkins `pipeline` 被压缩成一行，这使得阅读和编辑变得困难。在我们采取任何其他步骤之前，让我们找到一种人工的方式来编辑我们的
    `pipeline`。
- en: 'In order to do that, let''s click on the Configure button on the left-hand
    side menu and scroll down:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们点击左侧菜单上的“配置”按钮并向下滚动：
- en: '![](img/30400538-e076-458d-8030-156f5eb4ee70.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30400538-e076-458d-8030-156f5eb4ee70.png)'
- en: 'We have a good editor for our `pipeline` here. Let''s make our first edit of
    the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个很好的 `pipeline` 编辑器。让我们对文件进行第一次编辑：
- en: '![](img/9e60e66a-3ad4-4f58-baf9-829871ab8bf2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e60e66a-3ad4-4f58-baf9-829871ab8bf2.png)'
- en: 'We will then test it to check whether it works. In order to do that, we have
    to save the `pipeline` and click on the Build Now button in the build view. After
    that, we are ready to examine the log by clicking on the second build that has
    just been executed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将对其进行测试以检查它是否工作。为了做到这一点，我们必须保存 `pipeline` 并在构建视图中点击“立即构建”按钮。之后，我们就可以通过点击刚刚执行的第二次构建来检查日志。
- en: '![](img/aad14228-9d6e-4506-b097-35c58f78752e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aad14228-9d6e-4506-b097-35c58f78752e.png)'
- en: 'We will see the new log as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到新的日志如下：
- en: '![](img/e4bec7ff-ce59-47e8-acda-b9fe45d04c66.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4bec7ff-ce59-47e8-acda-b9fe45d04c66.png)'
- en: 'Also, let''s log in again to the web console and examine that `pipeline` there:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们再次登录到Web控制台，并检查那里的`pipeline`：
- en: '![](img/5e53124c-6629-4e92-bf37-c43f370dc39b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e53124c-6629-4e92-bf37-c43f370dc39b.png)'
- en: As you will have noticed, the `pipeline` build config was modified accordingly
    to the changes that we have made in Jenkins. We will perform our future changes
    using the Jenkins server.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，`pipeline`构建配置已经根据我们在Jenkins中做出的更改进行了相应的修改。我们将使用Jenkins服务器执行未来的更改。
- en: The new message that we are printing in the build promises that our build will
    do something useful at some point. After all, we want to create a CD `pipeline`
    for our services and not print messages. Before we can do it though, we will need
    to learn a few more things. In the beginning, we will need to say a few more words
    about the language that we are using to define the `pipeline`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建中打印的新消息承诺，我们的构建将在某个时候做一些有用的事情。毕竟，我们想要为我们的服务创建一个CD `pipeline`，而不是打印消息。不过，在我们能够做到这一点之前，我们还需要学习一些其他的东西。一开始，我们需要说更多关于我们用来定义`pipeline`的语言的话。
- en: Pipeline syntax language
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pipeline语法语言
- en: When we wrote our first `pipeline`, we used the Jenkins declarative pipeline
    language. We will describe the essentials of the **Declarative Pipeline Language**
    (**DPL**) in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写第一个`pipeline`时，我们使用了Jenkins声明式pipeline语言。我们将在下一节中描述**声明式Pipeline语言**（**DPL**）的要点。
- en: Core pipeline elements
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心pipeline元素
- en: 'In order to do that, let''s return to the `pipeline` that we executed in the
    preceding section:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们回到上一节中执行过的`pipeline`：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each `pipeline` in DPL must be enclosed with the `pipeline` block (1).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: DPL中的每个`pipeline`都必须用`pipeline`块（1）包围。
- en: The `pipeline` must begin with the `agent` directive (2). This directive specifies
    the Jenkins builder machines in which the build stages (more about them in a moment)
    can be executed. This setting can be overridden in each of the stages. In our
    examples, we will use any agent for all the stages.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline`必须以`agent`指令（2）开始。这个指令指定了可以执行构建阶段（稍后会详细介绍）的Jenkins构建机器。这个设置可以在每个阶段中覆盖。在我们的例子中，我们将为所有阶段使用任何代理。'
- en: The core `pipeline` build blocks are the stages. The stages are meant to map
    to the stages in the CD `pipeline`. They are defined in a serial order, and each
    stage can execute only if the stage before has succeeded.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 核心pipeline构建块是阶段。阶段旨在映射到CD `pipeline`中的阶段。它们按顺序定义，并且每个阶段只能在之前的阶段成功后才能执行。
- en: The stages have to be enclosed with the `stages` (3) block. Each stage (there
    need to be at least one of them) has its own `stage` block with the name specified
    as a parameter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段必须用`stages`（3）块包围。每个阶段（至少需要有一个）都有自己的`stage`块，其名称作为参数指定。
- en: Each stage block can contain a bunch of directives followed by the steps block,
    which encloses one or more steps that will be executed in the `pipeline`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段块可以包含一系列指令，后面跟着步骤块，该步骤块包围一个或多个将在`pipeline`中执行的步骤。
- en: Now, we are getting to the key point. What are the available steps that we can
    execute? Jenkins provides a very large number of different steps provided by different
    plugins. We will concentrate on one specific plugin that makes it easy to develop
    and execute operations on OpenShift clusters—let's discuss OpenShift, the `pipeline`
    Jenkins plugin (Further reading, link 1).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了关键点。我们可以执行哪些可用的步骤？Jenkins提供了由不同插件提供的非常多的不同步骤。我们将专注于一个特定的插件，该插件使得在OpenShift集群上开发和执行操作变得容易——让我们讨论OpenShift，`pipeline`
    Jenkins插件（进一步阅读，链接1）。
- en: Standard Maven operation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准Maven操作
- en: 'The first stage that we will implement is the unit testing stage. In the beginning,
    we will add a simple unit test in the same way that we did in [Chapter 5](c1be724d-e5fd-4c33-bd27-c04887d5cc8e.xhtml),
    *Testing Your Services with Arquillian*. We have to extend `pom.xml`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一阶段是单元测试阶段。一开始，我们将像在[第5章](c1be724d-e5fd-4c33-bd27-c04887d5cc8e.xhtml)中那样，以相同的方式添加一个简单的单元测试，*使用Arquillian测试你的服务*。我们必须扩展`pom.xml`：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recall that we had to add dependencies for JUnit (1), Arquillian (2), Swarm's
    Arquillian adapter (3), and the in-memory database that we will use (4).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们必须为JUnit（1）、Arquillian（2）、Swarm的Arquillian适配器（3）以及我们将使用的内存数据库添加依赖项（4）。
- en: 'Secondly, we have to provide test resources, namely `persistence.xml`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须提供测试资源，即`persistence.xml`：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the load script that we are going to use to test the database:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以及我们将用来测试数据库的加载脚本：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ensure that we also add the `h2` driver module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们也添加了`h2`驱动模块：
- en: '![](img/17e1078e-59f2-4af1-b8f3-efa2582103ca.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17e1078e-59f2-4af1-b8f3-efa2582103ca.png)'
- en: 'We are now ready to write a test:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好编写测试了：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we are finally ready to write the testing stage. We will like to make this
    stage run fast and fail immediately if there are some problems, without creating
    an image or changing anything in our OpenShift model. For this, we will use standard
    Maven and git from the command line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好编写测试阶段了。我们希望这个阶段运行得快，如果出现问题，立即失败，而不创建镜像或更改我们的OpenShift模型中的任何内容。为此，我们将使用命令行中的标准Maven和git。
- en: 'In order to do this, we need to configure those tools. To do this, we will
    have to go to Jenkins configuration in the main menu, click on Manage Jenkins
    and select the tool configuration for JDK:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要配置这些工具。为此，我们必须转到Jenkins主菜单中的Jenkins配置，点击管理Jenkins并选择JDK的工具配置：
- en: '![](img/fe72f1b1-c6c4-4c95-b002-32250f3c9e9a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe72f1b1-c6c4-4c95-b002-32250f3c9e9a.png)'
- en: 'And Maven:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以及Maven：
- en: '![](img/3c0d6bbc-025d-4dda-8e3b-ae8420bccb40.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c0d6bbc-025d-4dda-8e3b-ae8420bccb40.png)'
- en: 'We are finally ready to update our `pipeline`. Let''s take a look:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终准备好更新我们的`pipeline`了。让我们看看：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have provided the mandatory agent any (1) and configured Maven, JDK, and
    git tools, providing the versions for all of them. We have replaced our print
    stage with the unit test stage (3), which consists of the following two steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为强制代理提供了任何（1）并配置了Maven、JDK和git工具，为它们都提供了版本。我们将我们的打印阶段替换为单元测试阶段（3），该阶段包括以下两个步骤：
- en: The first step clones the pricing-service's git repository (4)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步克隆了`pricing-service`的git仓库（4）
- en: The second step runs the Maven tests (5)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步运行Maven测试（5）
- en: We have to provide the modules directory in order for the tests to work.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试能够工作，我们必须提供模块目录。
- en: OK. So, we have our first stage. Now, what next? If the unit tests pass, we
    will like to build and deploy an image with our application. In order to do that,
    we will have to interact with our cluster object from within the `pipeline`. The
    tool that will help us do that with ease is the OpenShift Pipeline Plugin. Let's
    learn more about it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，我们有了第一个阶段。接下来是什么？如果单元测试通过，我们希望构建并部署一个包含我们应用程序的镜像。为了做到这一点，我们必须在`pipeline`内部与我们的集群对象交互。将帮助我们轻松完成这项工作的工具是OpenShift
    Pipeline Plugin。让我们更多地了解它。
- en: OpenShift Pipeline Plugin
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift Pipeline Plugin
- en: Jenkins has a pluggable architecture, which allows for plugin development. OpenShift
    provides its own plugin, which allows for straightforward operations on OpenShift
    cluster objects in a declarative manner. The plugin provides a number of commands.
    We will introduce them one by one during the `pipeline` development.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins具有可插拔的架构，这允许插件开发。OpenShift提供了它自己的插件，它允许以声明式方式直接在OpenShift集群对象上执行操作。该插件提供了一系列命令。我们将在`pipeline`开发过程中逐一介绍它们。
- en: In the beginning, we will write a build stage, which will assemble the image
    and ensure that the application works correctly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们将编写一个构建阶段，该阶段将组装镜像并确保应用程序能够正确运行。
- en: The first command that we will use is the `openShiftBuild` command. It allows
    running one of the builds defined in the OpenShift cluster. This command takes
    one mandatory parameter, `buildCfg`, which is the name of the build that will
    be executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个命令是`openShiftBuild`命令。它允许运行OpenShift集群中定义的构建之一。这个命令接受一个强制参数`buildCfg`，它是将要执行的构建的名称。
- en: The second command that we will use is verified as `Build`. This command also
    takes `buildCfg` and checks whether the last build of this type has finished successfully
    within a reasonable time period. To set the period, we will use the `waitTime`
    parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第二个命令是`Build`。这个命令也接受`buildCfg`参数，并检查这种类型的最后构建是否在合理的时间内成功完成。为了设置这个周期，我们将使用`waitTime`参数。
- en: 'Let''s take a look at our new `pipeline`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的新`pipeline`：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have introduced the `Build` stage (1) and added two steps to it, as mentioned
    in the preceding paragraph. The `Build` command runs the `pricing-service` `s2i`
    build that we configured at the beginning of this chapter (2). The verify command
    checks whether the build was executed successfully within 5 minutes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一段所述，我们已经介绍了`Build`阶段（1），并向其中添加了两个步骤。`Build`命令运行我们在本章开头配置的`pricing-service`
    `s2i`构建（2）。验证命令检查构建是否在5分钟内成功执行。
- en: We will like to only build the image here and not deploy it yet. So, we will
    need to modify our build and remove the image change as the trigger for the deployment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在这里只构建镜像，而不部署它。因此，我们需要修改我们的构建并移除镜像更改作为部署的触发器。
- en: 'After that, we are ready to start our `Build` in Jenkins. If you do it and
    click on console output, you will be able to see the execution log. Let''s take
    a look at it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就准备好在 Jenkins 中开始我们的 `Build` 操作。如果你这样做并点击控制台输出，你将能够看到执行日志。让我们来看看：
- en: '![](img/8c9a2cb3-37e8-40a6-8bed-7eebc8a8fabf.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c9a2cb3-37e8-40a6-8bed-7eebc8a8fabf.png)'
- en: 'Oops! If you look again at the test, you will note that there is an error,
    as the price of the test-pet is 5 none 7\. Before we fix it, let''s note how the
    `pipeline` works. Our first unit test stage failed immediately. As a result, no
    further stages were started. No images were built and no applications were deployed.
    Let''s also look at the `pipeline` view on the web console:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果你再次查看测试，你会注意到有一个错误，因为测试宠物价格是 5 而不是 7。在我们修复它之前，让我们记一下 `pipeline` 的工作方式。我们的第一个单元测试阶段立即失败。结果，没有启动其他阶段。没有构建镜像，也没有部署应用程序。让我们也看看网页控制台上的
    `pipeline` 视图：
- en: '![](img/a83f88ec-9570-4368-a320-41fd7161fd8c.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a83f88ec-9570-4368-a320-41fd7161fd8c.png)'
- en: 'The console presents the `pipeline` execution in a graphic way, showing that
    the test stage failed. Let''s fix our tests and run the application again. If
    you do it and look at the console log, you will be able to see that the test has
    passed and the `Build` stage has been executed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台以图形方式呈现 `pipeline` 执行情况，显示测试阶段失败。让我们修复我们的测试并再次运行应用程序。如果你这样做并查看控制台日志，你将能够看到测试已经通过，并且
    `Build` 阶段已经执行：
- en: '![](img/e93b5cfa-0a69-4adb-88fc-e5fde152b404.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e93b5cfa-0a69-4adb-88fc-e5fde152b404.png)'
- en: 'When you take a look at the web console, you will be able to see that the `Build`
    has been finished and that the image has been created:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看网页控制台时，你将能够看到 `Build` 已经完成，并且镜像已经创建：
- en: '![](img/a5954008-32cf-4af6-975c-ce9979401a6d.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5954008-32cf-4af6-975c-ce9979401a6d.png)'
- en: 'Let''s look at the currently available deployments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前可用的部署：
- en: '![](img/7e93af2d-4331-425c-ab7a-2fa18207df4e.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e93af2d-4331-425c-ab7a-2fa18207df4e.png)'
- en: Now, we only have the build image and have not triggered the deployment yet.
    Let's add another stage to our build. We will use `openshiftDeploy`, `openshiftScale`,
    `openShiftVerifyDeployment`, and `openShiftVerifyService`. Before doing that,
    let's introduce each of these commands.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有构建镜像，还没有触发部署。让我们在我们的构建中添加另一个阶段。我们将使用 `openshiftDeploy`、`openshiftScale`、`openShiftVerifyDeployment`
    和 `openShiftVerifyService`。在这样做之前，让我们介绍这些命令中的每一个。
- en: The `openshiftDeploy` command takes a mandatory parameter—`dplCfg`—which is
    the name of the deployment. It runs the deployment of an application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`openshiftDeploy` 命令需要一个强制参数——`dplCfg`——这是部署的名称。它运行应用程序的部署。'
- en: '`openshiftScale`, irrespective of a mandatory `dplCfg` parameter, takes the
    `replicaCount` parameter, which specifies the number of replicas of the application.
    Since we are using this command to scale the application, we will change the number
    of instance deployments in the `deploymentConfig` to zero. As a result, the pods
    will be started only after the `openshiftScale` operation has been executed without
    an unnecessary rescale.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`openshiftScale`，无论是否有强制 `dplCfg` 参数，都会使用 `replicaCount` 参数，该参数指定应用程序的副本数量。由于我们使用此命令来扩展应用程序，我们将更改
    `deploymentConfig` 中的实例部署数量为零。结果，只有在 `openshiftScale` 操作执行后，pods 才会启动，而无需不必要的缩放。'
- en: '`openShiftVerifyDeployment` has the same mandatory parameter as the two previous
    commands—`dplCfg`. This command has three optional parameters, and we will use
    all of them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`openShiftVerifyDeployment` 与前两个命令具有相同的强制参数——`dplCfg`。此命令有三个可选参数，我们将使用所有这些参数：'
- en: '`replicaCount`: This parameter specifies the expected number of replicas'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicaCount`: 此参数指定期望的副本数量'
- en: '`verifyReplicaCount`: This is a Boolean parameter, which specifies whether
    the replica count should be checked'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verifyReplicaCount`: 这是一个布尔参数，指定是否应该检查副本数量'
- en: '`waitTime`: This indicates the time in milliseconds in which we should wait
    for the verification'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitTime`: 这表示我们应该等待验证的时间，以毫秒为单位'
- en: '`openshiftVerifyService`: This command checks whether the service is available'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openshiftVerifyService`: 此命令检查服务是否可用'
- en: '`openshiftVerifyService` has one mandatory parameter:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`openshiftVerifyService` 有一个强制参数：'
- en: '`svcName`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svcName`'
- en: One optional parameter `retryCount` specifies how many times the connection
    is attempted before declaring the verification invalid
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选参数`retryCount`指定在声明验证无效之前尝试连接的次数
- en: Before showing you the new script, we will introduce one more concept. As we
    mentioned in the theoretical section of this chapter, the build should give immediate
    feedback to its authors regarding its status. In order to react to the `Build`
    status, the DPL provides the ability to perform an action after the `pipeline`
    is finished based on the status of the build. The construct that allows doing
    that is post directive.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在向您展示新脚本之前，我们将介绍一个额外的概念。正如我们在本章的理论部分所提到的，构建应该立即向其作者提供关于其状态的反馈。为了响应`构建`状态，DPL提供了在`管道`完成后根据构建状态执行操作的能力。允许这样做的是后指令。
- en: 'A post directive enables us to perform an action after the build has been finished.
    It can be placed at the end of the `pipeline` or at the end of each stage. The
    post directive provides a bunch of subdirectories: always, success, failure, unstable,
    (runs if the build is unstable—the result changes during the build) aborted, and
    changed.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 后指令使我们能够在构建完成后执行操作。它可以放置在`管道`的末尾或每个阶段的末尾。后指令提供了一组子目录：always、success、failure、unstable（如果构建不稳定，则运行——结果在构建过程中发生变化）、aborted和changed。
- en: In our script, for the sake of simplicity, we will echo the build status to
    the console, but we can use the available Jenkins plugins0; to configure email,
    HipChat, or slack notification.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，为了简化，我们将构建状态输出到控制台，但我们可以使用可用的Jenkins插件来配置电子邮件、HipChat或Slack通知。
- en: 'Let''s take a look at the build:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看构建：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have extended our `pipeline` in a way described previously:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经按照之前描述的方式扩展了我们的`管道`：
- en: We have added the `Deploy` stage (1), which deploys the application (2)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`Deploy`阶段（1），用于部署应用程序（2）
- en: Then, it scales the application (3)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它扩展了应用程序（3）
- en: It verifies that the deployment succeeded (4) and that the service is available
    (5)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它验证了部署是否成功（4）以及服务是否可用（5）
- en: After each build, the result of the test is echoed to the output, depending
    on whether the test succeeded (6) or failed (7)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次构建之后，测试的结果都会输出到输出中，具体取决于测试是否成功（6）或失败（7）
- en: If you look at the console output, you will be able to see that all the steps
    that we have implemented have been executed successfully.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看控制台输出，您将能够看到我们已成功执行的所有步骤。
- en: 'You can also verify this in the web console `pipeline` view:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在Web控制台的`管道`视图中验证这一点：
- en: '![](img/235d9bdc-5bae-453a-9d72-f950ae6a6935.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/235d9bdc-5bae-453a-9d72-f950ae6a6935.png)'
- en: Finally, you can verify in the web console that the service has indeed been
    created and that the corresponding pods are running.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在Web控制台中验证服务确实已创建，并且相应的Pod正在运行。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the build infrastructure provided by OpenShift.
    You then learned to use source-to-image build, which abstracts away the details
    of Kubernetes internals from the developer and lets them build the image based
    solely on code with minimal configuration.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了OpenShift提供的构建基础设施。然后您学习了如何使用源到镜像构建，它从开发者那里抽象出了Kubernetes内部细节，并让他们仅基于代码进行构建，配置最小化。
- en: In the second part of this chapter, you learned about the `pipeline` build,
    which, effectively, is a way to integrate Jenkins `pipelines` with OpenShift infrastructures.
    You also learned how to create the `pipeline` build and the basics of the DPL
    syntax. Hence, you were able to create a CD `pipeline` for your petstore's `pricing-service.`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，您学习了`管道`构建，这实际上是一种将Jenkins `管道`与OpenShift基础设施集成的方式。您还学习了如何创建`管道`构建以及DPL语法的基础知识。因此，您能够为您的petstore的`pricing-service`创建一个CD
    `管道`。
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)'
