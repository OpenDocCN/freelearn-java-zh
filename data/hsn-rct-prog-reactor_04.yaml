- en: Processors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: So far in this book, we have been covering the building blocks of Reactive Streams.
    The publisher, subscriber, and operators represent data manipulation components.
    Processors, on the other hand, represent the plumbing required to join these components
    into a single stream of data. In this chapter, we will discuss the types and requirements
    of processors in detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直在介绍响应式流的构建块。发布者、订阅者和操作员代表数据操作组件。另一方面，处理器代表将这些组件组合成单个数据流所需的管道。在本章中，我们将详细讨论处理器的类型和需求。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to processors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器简介
- en: Understanding processor types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解处理器类型
- en: Hot versus cold publishers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热发布者与冷发布者
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04)。
- en: An introduction to processors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器简介
- en: A processor represents a state of data processing. It is therefore presented
    as both a publisher and a subscriber. Since it is a publisher, we can create a
    processor and `Subscribe` to it. Most of the functions of a publisher can be performed
    using a processor; it can inject custom data, as well as generate errors and completion
    events. We can also interface all operators on it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器代表数据处理的状态。因此，它既被表示为发布者，也被表示为订阅者。由于它是一个发布者，我们可以创建一个处理器并对其`Subscribe`。大多数发布者的功能都可以通过处理器执行；它可以注入自定义数据，以及生成错误和完成事件。我们还可以与它接口的所有操作符。
- en: 'Consider the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we did the following things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下几件事：
- en: We added an instance of `DirectProcessor`
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个`DirectProcessor`实例
- en: In the second line, we added the `take` operator, to select two elements
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们添加了`take`操作符，以选择两个元素
- en: We also subscribed and printed the data on the console
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在控制台上订阅并打印了数据
- en: In the last three lines, we published three data elements
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后三行中，我们发布了三个数据元素
- en: 'Let''s take a look at the output, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出结果，如下面的屏幕截图所示：
- en: '![](img/c4a45beb-9327-456f-9a8a-0c7a1e31c393.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4a45beb-9327-456f-9a8a-0c7a1e31c393.png)'
- en: Here, it looks like we can replace the publisher with processors. But if this
    is the case, why did the Reactive Stream specification ask for two interfaces
    for the same function? Well, the publisher and processor are not actually the
    same. Processors are special class publishers that have limited capabilities.
    They represent a stage of data processing. We will familiarize ourselves with
    these limitations when we discuss the different types of available processors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，看起来我们可以用处理器替换发布者。但如果是这种情况，为什么响应式流规范要求为同一功能提供两个接口？嗯，发布者和处理器实际上并不相同。处理器是具有有限能力的特殊类发布者。它们代表数据处理的一个阶段。当我们讨论不同类型的可用处理器时，我们将熟悉这些限制。
- en: 'As a general rule, we should try to refrain from using processors directly.
    Instead, we should try to look for the following alternatives:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，我们应该尽量避免直接使用处理器。相反，我们应该尝试寻找以下替代方案：
- en: First, determine an existing operator that can provide the intended functions.
    Operators should be the first choice for carrying out data manipulation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，确定一个可以提供所需功能的现有操作符。操作符应该是执行数据操作的首选。
- en: If there is no operator available, we should try to adapt the `Flux.generate`
    API and generate a custom stream of data.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有可用的操作符，我们应该尝试适配`Flux.generate` API并生成一个自定义的数据流。
- en: Understanding processor types
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解处理器类型
- en: There are different types of processors available in Reactor. These processors
    differ in various features, such as backpressure capability, the number of clients
    they can handle, synchronous invocation, and so on. Let's look at the types of
    processor available in Reactor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor中提供了不同类型的处理器。这些处理器在各种特性上有所不同，例如背压能力、它们可以处理的客户端数量、同步调用等。让我们看看Reactor中可用的处理器类型。
- en: The DirectProcessor type
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectProcessor类型
- en: '`DirectProcessor` is the simplest of the processors. This processor connects
    a processor to a subscriber, and then directly invokes the `Subscriber.onNext`
    method. The processor does not offer any backpressure handling.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectProcessor` 是处理器中最简单的一种。此处理器将处理器连接到订阅者，然后直接调用 `Subscriber.onNext` 方法。处理器不提供任何背压处理。'
- en: An instance of `DirectProcessor` can be created by invoking the `create()` method.
    Any number of subscribers can subscribe to the processor. It must be noted that
    once the processor has published the complete event, it will reject subsequent
    data events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `create()` 方法创建一个 `DirectProcessor` 实例。任何数量的订阅者都可以订阅处理器。必须注意，一旦处理器发布了完整的事件，它将拒绝后续的数据事件。
- en: 'Consider the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code does the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Creates an instance of `Directprocessor`
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个 `Directprocessor` 实例
- en: Adds a subscriber that can print all events (data/error/completion) to the console
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个订阅者，该订阅者可以将所有事件（数据/错误/完成）打印到控制台
- en: Publishes a data event, followed by a completion event
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布一个数据事件，随后是一个完成事件
- en: Adds another subscriber, which can print all events (data/error/completion)
    to the console
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了另一个订阅者，该订阅者可以将所有事件（数据/错误/完成）打印到控制台
- en: Publishes a data event.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布一个数据事件。
- en: 'When we look at the following output screenshot, we can see that all subscribers
    get the completion event. The data event for the value of `12` then gets dropped:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看以下输出截图时，我们可以看到所有订阅者都收到了完成事件。值为 `12` 的数据事件随后被丢弃：
- en: '![](img/0b9103f1-f5ac-4baf-b064-3b5c0a89b8bd.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b9103f1-f5ac-4baf-b064-3b5c0a89b8bd.png)'
- en: With respect to the handling of backpressure, `DirectProcessor` has another
    important limitation. We mentioned previously that it does not have backpressure
    capability at all. This means that if we push events more than what is asked by
    the subscriber, it leads to an `Overflow` exception.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理背压方面，`DirectProcessor` 有另一个重要的限制。我们之前提到，它根本不具备背压能力。这意味着如果我们推送的事件超过了订阅者请求的数量，会导致
    `Overflow` 异常。
- en: 'Let''s look at the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code does the following things:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Created an instance of `Directprocessor`
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个 `Directprocessor` 实例
- en: Added a subscriber that can print all events (data/error/completion) to the
    console
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个订阅者，该订阅者可以将所有事件（数据/错误/完成）打印到控制台
- en: The subscriber also listened to the subscription event and raised a demand of
    `1` data event
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者还监听了订阅事件，并提出了 `1` 个数据事件的请求
- en: Finally, a couple of data events were published
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布了几个数据事件
- en: 'The preceding code failed, displaying the following error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码失败，显示以下错误：
- en: '![](img/61db4c2b-c7c7-4744-b697-796f90ccbabe.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61db4c2b-c7c7-4744-b697-796f90ccbabe.png)'
- en: The UnicastProcessor type
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`UnicastProcessor` 类型'
- en: The `UnicastProcessor` type is like the `DirectProcessor`, in terms of invocations
    of the `Subscriber.onNext` method. It invokes the subscriber method directly.
    However, unlike the `DirectProcessor`, the `UnicastProcessor` is capable of backpressure.
    Internally, it creates a queue to hold undelivered events. We can also provide
    an optional external queue to buffer the events. After the buffer is full, the
    processor starts to reject elements. The processor also makes it possible to perform
    cleanup for every rejected element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnicastProcessor` 类型与 `DirectProcessor` 类似，在调用 `Subscriber.onNext` 方法方面。它直接调用订阅者方法。然而，与
    `DirectProcessor` 不同，`UnicastProcessor` 具备背压能力。内部，它创建一个队列来存储未交付的事件。我们还可以提供一个可选的外部队列来缓冲事件。当缓冲区满时，处理器开始拒绝元素。处理器还使得对每个被拒绝的元素执行清理成为可能。'
- en: 'The `UnicastProcessor` provides `create` methods to build an instance of the
    processor. Let''s take a look at the following code to see how this is used:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnicastProcessor` 提供了 `create` 方法来构建处理器的一个实例。让我们看看以下代码，看看它是如何使用的：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code did the following things:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了以下操作：
- en: Created an instance of `UnicastProcessor`
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个 `UnicastProcessor` 实例
- en: Added a subscriber, which can print data events to the console
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个订阅者，该订阅者可以将数据事件打印到控制台
- en: Created a `sink` to push a couple of elements
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个 `sink` 来推送几个元素
- en: 'While `UnicastProcessor` provides backpressure capability, a major limitation
    is that only a single subscriber can be worked with. If we add one more subscriber
    to the preceding code, it will fail with the following error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `UnicastProcessor` 提供了背压能力，但一个主要的限制是只能与单个订阅者一起工作。如果我们向上述代码添加另一个订阅者，它将失败并显示以下错误：
- en: '![](img/0876b593-dfd5-4634-93ed-7c9407e942c8.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0876b593-dfd5-4634-93ed-7c9407e942c8.png)'
- en: Each processor provides a `Sink` method. A `Sink` is the preferred way of publishing
    events to the subscriber. It provides methods to publish next, error, and complete
    events. `Sink` provides a thread-safe manner of handling these events, instead
    of directly publishing them by using the `Subsciber.OnNext` method calls.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器都提供了一个`Sink`方法。`Sink`是向订阅者发布事件的推荐方式。它提供了发布下一个、错误和完成事件的机制。`Sink`提供了一种线程安全的方式来处理这些事件，而不是直接通过调用`Subscriber.OnNext`方法来发布它们。
- en: The EmitterProcessor type
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EmitterProcessor`类型'
- en: '`EmitterProcessor` is a processor that can be used with several subscribers.
    Multiple subscribers can ask for the next value event, based on their individual
    rate of consumption. The processor provides the necessary backpressure support
    for each subscriber. This is depicted in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmitterProcessor`是一个可以与多个订阅者一起使用的处理器。多个订阅者可以根据它们各自的消费速率请求下一个值事件。处理器为每个订阅者提供必要的背压支持。这在上面的图中表示：'
- en: '![](img/147b6011-88f2-4f61-ab83-6cdc54361133.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/147b6011-88f2-4f61-ab83-6cdc54361133.png)'
- en: The processor is also capable of publishing events from an external publisher.
    It consumes an event from the injected publisher and synchronously passes it to
    the subscribers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器还可以从外部发布者发布事件。它从注入的发布者那里消费一个事件，并将其同步传递给订阅者。
- en: 'Let''s look at the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code did the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了以下操作：
- en: Created an instance of `EmitterProcessor`
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`EmitterProcessor`的实例
- en: Added a subscriber, which can print data events to the console
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个订阅者，可以将数据事件打印到控制台
- en: Created a `sink` to push a couple of elements
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`sink`来推送一些元素
- en: Added another subscriber, which can print data events to the console
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了另一个订阅者，可以将数据事件打印到控制台
- en: Pushed more events by using the Sink API
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Sink API推送了更多的事件
- en: 'The preceding code builds the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出：
- en: '![](img/c0f6e072-5d27-46a8-ad37-c4e14c598eda.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0f6e072-5d27-46a8-ad37-c4e14c598eda.png)'
- en: 'The preceding code also made the following clear:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还清楚地说明了以下内容：
- en: Both subscribers print items to the console.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个订阅者都将项目打印到控制台。
- en: The processor delivers events to a subscriber after its subscription. This is
    different from Flux, which delivers all items to all subscribers, irrespective
    of the time of subscription.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器在订阅后将其事件传递给订阅者。这与Flux不同，Flux无论何时订阅都会将所有项目传递给所有订阅者。
- en: The ReplayProcessor type
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ReplayProcessor`类型'
- en: '`ReplayProcessor` is a special-purpose processor, capable of caching and replaying
    events to its subscribers. The processor also has the capability of publishing
    events from an external publisher. It consumes an event from the injected publisher
    and synchronously passes it to the subscribers.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplayProcessor`是一个专用处理器，能够缓存并回放事件给其订阅者。处理器还具有从外部发布者发布事件的能力。它从注入的发布者那里消费一个事件，并将其同步传递给订阅者。'
- en: '`ReplayProcessor` can cache events for the following scenarios:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplayProcessor`可以缓存以下场景的事件：'
- en: All events
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事件
- en: A limited count of events
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的事件计数
- en: Events bounded by a specified time period
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由指定的时间段限制的事件
- en: Events bounded by a count and a specified time period
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由计数和指定的时间段限制的事件
- en: The last event only
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅最后的事件
- en: 'Once cached, all events are replayed when a subscriber is added:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦缓存，所有事件在添加订阅者时都会回放：
- en: '![](img/cac7358b-5570-4c04-8cc8-0fb7c370985b.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cac7358b-5570-4c04-8cc8-0fb7c370985b.png)'
- en: 'Let''s look at the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code did the following things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了以下操作：
- en: Created an instance of `ReplayProcessor`, with a cache of three events
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个具有三个事件缓存的`ReplayProcessor`实例
- en: Added a subscriber, which can print data events to the console
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个订阅者，可以将数据事件打印到控制台
- en: Created a `sink` to push a couple of elements
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`sink`来推送一些元素
- en: Added another subscriber, which can print data events to the console
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了另一个订阅者，可以将数据事件打印到控制台
- en: 'The preceding code builds the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出：
- en: The processor caches the last three events, namely, `12`, `13`, and `14`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器缓存了最后三个事件，即`12`、`13`和`14`
- en: When the second subscriber connects, it prints the cached events on the console
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当第二个订阅者连接时，它会在控制台上打印缓存的事件
- en: 'A screenshot of the output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的截图如下：
- en: '![](img/79180414-aa8b-4ce8-935f-bc97aa3fc610.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79180414-aa8b-4ce8-935f-bc97aa3fc610.png)'
- en: The TopicProcessor type
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TopicProcessor`类型'
- en: '`TopicProcessor` is a processor capable of working with multiple subscribers,
    using an event loop architecture. The processor delivers events from a publisher
    to the attached subscribers in an asynchronous manner, and honors backpressure
    for each subscriber by using the `RingBuffer` data structure. The processor is
    also capable of listening to events from multiple publishers. This is illustrated
    in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopicProcessor`是一个能够使用事件循环架构与多个订阅者一起工作的处理器。处理器以异步方式将发布者的事件发送到附加的订阅者，并通过使用`RingBuffer`数据结构为每个订阅者提供背压。处理器还能够监听来自多个发布者的事件。这在上面的图中有所说明：'
- en: '![](img/ebb5070b-070d-4c61-a738-26f692eb3d4d.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebb5070b-070d-4c61-a738-26f692eb3d4d.png)'
- en: Unlike the processors that deliver events in an ordered manner, `TopicProcessor`
    is capable of delivering events to subscribers in a concurrent manner. This is
    governed by the number of threads created in the processor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与按顺序发送事件的处理器不同，`TopicProcessor`能够以并发方式向订阅者发送事件。这由处理器中创建的线程数控制。
- en: 'Let''s look at the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code did the following things:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了以下操作：
- en: Created an instance of `TopicProcessor` by using the provided builder
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的构建器创建了一个`TopicProcessor`实例。
- en: Provided a `ThreadPool` of size `2`, in order to connect two subscribers to
    it
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了一个大小为`2`的`ThreadPool`，以便将其连接到两个订阅者
- en: Added two subscriber instances, which can print data events to the console
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了两个订阅者实例，它们可以将数据事件打印到控制台
- en: Created a `sink` to push a couple of elements
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`sink`来推送几个元素。
- en: 'The preceding code builds the following output, and the processor delivers
    events to both subscribers concurrently:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出，处理器并发地向两个订阅者发送事件：
- en: '![](img/35a1aceb-d476-4f13-aff2-fab38fbe203a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35a1aceb-d476-4f13-aff2-fab38fbe203a.png)'
- en: The WorkQueueProcessor type
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WorkQueueProcessor`类型'
- en: 'The `WorkQueueProcessor` type is similar to the `TopicProcessor`, in that it
    can connect to multiple subscribers. However, it does not deliver all events to
    each subscriber. The demand from every subscriber is added to a queue, and events
    from a publisher are sent to any of the subscribers. The model is more like having
    listeners on a JMS queue; each listener consumes a message when finished. The
    processor delivers messages to each of the subscribers in a round-robin manner.
    The processor is also capable of listening to events from multiple publishers.
    This is depicted in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkQueueProcessor`类型与`TopicProcessor`类似，因为它可以连接到多个订阅者。然而，它不会将所有事件都发送给每个订阅者。每个订阅者的需求被添加到一个队列中，发布者的事件被发送给任何一个订阅者。这种模式更像是JMS队列上的监听器；每个监听器在完成时消费一条消息。处理器以轮询的方式将消息发送给每个订阅者。处理器还能够监听来自多个发布者的事件。这在上面的图中有所展示：'
- en: '![](img/6c294fc3-4c0f-4507-9691-422d02ab49c6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c294fc3-4c0f-4507-9691-422d02ab49c6.png)'
- en: The processor is better in terms of resource requirements, as it does not build
    a thread pool for its subscribers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源需求方面，处理器表现得更好，因为它不会为它的订阅者构建线程池。
- en: 'Let''s look at the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code did the following things:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了以下操作：
- en: Created an instance of `WorkQueueProcessor` by using the provided builder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的构建器创建了一个`WorkQueueProcessor`实例。
- en: Added two subscriber instances, which can print data events to the console.
    Each subscriber prints its ID, as well.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了两个订阅者实例，它们可以将数据事件打印到控制台。每个订阅者也会打印其ID。
- en: Created a `sink` to push a couple of elements.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`sink`来推送几个元素。
- en: 'The preceding code builds the following output. The processor delivers a few
    events to the first subscriber, with the rest being delivered to the second subscriber:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出。处理器向第一个订阅者发送了一些事件，其余的事件发送给了第二个订阅者：
- en: '![](img/5d5b1025-d2e0-40e5-9e42-9e5e0f5444c2.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d5b1025-d2e0-40e5-9e42-9e5e0f5444c2.png)'
- en: Hot versus Cold publishers
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热发布者与冷发布者
- en: In previous chapters, we built publishers that would start publishing data to
    each of the subscriber instances after subscription. The Fibonacci publisher that
    we created in [Chapter 2](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml), *The Publisher
    and Subscriber APIs in a Reactor*, would publish the complete Fibonacci series
    to each of its subscribers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了发布者，它们在订阅后会将数据发布到每个订阅实例。我们在[第2章](2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml)，“Reactors中的发布者和订阅者API”中创建的斐波那契发布者会将完整的斐波那契数列发布给每个订阅者。
- en: 'Consider the following Fibonacci code as a cold publisher:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下斐波那契代码视为冷发布者：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Publishers that start publishing data to the subscriber after subscription are
    known as **cold publishers**. It is important to understand that the data should
    be generated post-subscription. If there is no subscriber, then the publisher
    will not generate any data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅后开始向订阅者发布数据的发布者被称为**冷发布者**。重要的是要理解数据应在订阅后生成。如果没有订阅者，则发布者不会生成任何数据。
- en: 'Let''s take a look at the output of the preceding cold publisher. Here, both
    subscribers print the complete set of Fibonacci numbers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面提到的冷发布者的输出。在这里，两个订阅者都打印了完整的斐波那契数列集合：
- en: '![](img/3396009c-c160-435c-b4a4-73f5259deb3c.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3396009c-c160-435c-b4a4-73f5259deb3c.png)'
- en: In the current chapter, we have used the processors as publishers, which do
    not depend on the subscriber. These publishers keep emitting data, and, when a
    new subscriber arrives, it receives only newly emitted data. This is different
    from cold publisher behavior, which also publishes old data for every new subscriber.
    These publishers are known as **hot publishers**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了作为发布者的处理器，这些处理器不依赖于订阅者。这些发布者持续发射数据，并且当新的订阅者到达时，它只会接收新发射的数据。这与冷发布者的行为不同，冷发布者也会为每个新的订阅者发布旧数据。这些发布者被称为**热发布者**。
- en: 'In the following code, we have converted a Fibonacci publisher into a hot publisher:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将斐波那契发布者转换为热发布者：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code illustrates the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了以下内容：
- en: We built a `UnicastProcessor` and converted it to a `Flux` by using the `publish`
    method
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了一个`UnicastProcessor`，并通过使用`publish`方法将其转换为`Flux`
- en: We then added a subscriber to it
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们向它添加了一个订阅者
- en: Next, we created a `Thread` and used the `UnicastProcessor` instance (created
    previously) to generate the Fibonacci series
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`Thread`，并使用之前创建的`UnicastProcessor`实例来生成斐波那契数列
- en: Another subscriber is added when the series value is `144`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数列值为`144`时，添加了另一个订阅者
- en: 'Let''s take a look at the output of the hot publisher:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看热发布者的输出：
- en: The first subscriber prints the initial values.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个订阅者打印初始值。
- en: 'The second subscriber prints values that are greater than `143`. This is shown
    in the following screenshot:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个订阅者打印大于`143`的值。这在下图中显示：
- en: '![](img/45d41277-e172-46db-8d1e-929209f4bf9a.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45d41277-e172-46db-8d1e-929209f4bf9a.png)'
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various kinds of processors that are available
    in Reactor. You learned that the `DirectProcessor` is the simplest processor,
    but it does not offer backpressure. We then discussed the functions and abilities
    of `UnicastProcessor`, `EmmiterProcessor`, `ReplayProcessor`, `TopicProcessor`,
    and `WorkQueueProcessor`. In the end, we familiarized ourselves with hot and cold
    publishers, ultimately using `UnicastProcessor` to convert a Fibonacci generator
    into a hot publisher.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Reactor中可用的各种处理器。你了解到`DirectProcessor`是最简单的处理器，但它不提供背压。然后我们讨论了`UnicastProcessor`、`EmitterProcessor`、`ReplayProcessor`、`TopicProcessor`和`WorkQueueProcessor`的功能和能力。最后，我们熟悉了热发布者和冷发布者，最终使用`UnicastProcessor`将斐波那契生成器转换为热发布者。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the limitations of `DirectProcessor`?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DirectProcessor`的限制是什么？'
- en: What are the limitations of `UnicastProcessor`?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UnicastProcessor`的限制是什么？'
- en: What are the capabilities of `EmitterProcessor`?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EmitterProcessor`的功能有哪些？'
- en: What are the capabilities of `ReplayProcessor`?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReplayProcessor`的功能有哪些？'
- en: What are the capabilities of `TopicProcessor`?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TopicProcessor`的功能有哪些？'
- en: What are the capabilities of `WorkQueueProcessor`?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WorkQueueProcessor`的功能有哪些？'
- en: What is the difference between a hot publisher and a cold publisher?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 热发布者和冷发布者之间的区别是什么？
