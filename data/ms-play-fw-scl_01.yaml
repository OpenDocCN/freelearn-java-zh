- en: Chapter 1. Getting Started with Play
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Play入门
- en: The World Wide Web has grown by leaps and bounds since its first appearance
    in August 1991\. It has come a long way from line mode browsers and static websites
    to graphical browsers and highly interactive websites, such as search engines,
    online department stores, social networking, gaming, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1991年8月首次出现以来，万维网已经取得了飞跃性的增长。它已经从行模式浏览器和静态网站发展到图形浏览器和高度交互式网站，如搜索引擎、在线百货商店、社交网络、游戏等。
- en: Complex websites or applications are backed by one or more databases and several
    lines of code. In most cases, such web applications use a framework to simplify
    the development process. A framework provides a skeleton structure that handles
    most of the repetitive or common features. Ruby on Rails, Django, Grails, and
    Play are a few examples of this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的网站或应用程序由一个或多个数据库和大量代码支持。在大多数情况下，此类Web应用程序使用框架来简化开发过程。框架提供了一个骨架结构，处理了大多数重复或常见功能。Ruby
    on Rails、Django、Grails和Play是此类框架的几个例子。
- en: Play Framework was developed by Guillaume Bort while he was working at Zenexity
    (now Zengularity). Its first full release was in October 2009 for version 1.0\.
    In 2011, Sadek Drobi joined Guillaume Bort to develop Play 2.0, which was adopted
    by Typesafe Stack 2.0\. Play 2.0 was released on March 13, 2012.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架是由Guillaume Bort在Zenexity（现在为Zengularity）工作时开发的。它的第一个完整版本是在2009年10月发布的1.0版。2011年，Sadek
    Drobi加入了Guillaume Bort，共同开发Play 2.0，该版本被Typesafe Stack 2.0采用。Play 2.0于2012年3月13日发布。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The reasons for choosing Play
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择Play的原因
- en: Creating a sample Play application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个示例Play应用程序
- en: Creating a TaskTracker application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个TaskTracker应用程序
- en: Venturing into the world of Play
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Play的世界
- en: Play's installation is hassle free. If you have Java JDK 6 or a later version,
    all you need to do to get Play working is an installation of **Typesafe Activator**
    or **Simple Build Tool** (**SBT**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Play的安装无需麻烦。如果你有Java JDK 6或更高版本，要使Play运行，你只需安装**Typesafe Activator**或**Simple
    Build Tool**（**SBT**）即可。
- en: Play is fully RESTful! **Representational State Transfer** (**REST**) is an
    architectural style, which relies on a stateless, client-server, and cache-enabled
    communication protocol. It's a lightweight alternative to mechanisms such as **Remote
    Procedure Calls** (**RPC**) and web services (which include SOAP, WSDL, and so
    on). Here stateless means that the client state data is not stored on the server
    and every request should include all the data required for the server to process
    it successfully. The server does not rely on previous data to process the current
    request. The clients store their session state and the servers can service many
    more clients in a stateless fashion. The Play build system uses **Simple Build
    Tool** (**SBT**), which is a build tool used for Scala and Java. It also has a
    plugin to allow native compilation of C and C++. SBT uses incremental recompilation
    to reduce the compilation time and can be run in triggered execution mode, which
    means that if specified by the user, required tasks will be run whenever the user
    saves changes in any of the source files. This feature in particular has been
    leveraged by the Play Framework so that developers need not redeploy after every
    change in development stage. This means that if a Play app is running from source
    on your local machine and you edit its code, you can view the updated app just
    by reloading the app in the browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Play是完全RESTful的！**表示性状态转移**（**REST**）是一种架构风格，它依赖于无状态、客户端-服务器和缓存启用通信协议。它是一种轻量级的替代机制，如**远程过程调用**（**RPC**）和Web服务（包括SOAP、WSDL等）。在这里，无状态意味着客户端状态数据不会存储在服务器上，每个请求都应该包含服务器成功处理所需的所有数据。服务器不依赖于以前的数据来处理当前请求。客户端存储他们的会话状态，服务器可以无状态地服务更多的客户端。Play构建系统使用**Simple
    Build Tool**（**SBT**），这是一个用于Scala和Java的构建工具。它还包含一个插件，允许原生编译C和C++。SBT使用增量重新编译来减少编译时间，并且可以在触发执行模式下运行，这意味着如果用户指定，所需任务将在用户在任何源文件中保存更改时运行。这个特性特别被Play框架利用，因此开发者不需要在开发阶段的每次更改后重新部署。这意味着如果Play应用程序在本地机器上从源代码运行，并且你编辑了它的代码，你只需在浏览器中重新加载应用程序即可查看更新后的应用程序。
- en: It provides a default test framework along with helpers and application stubs
    to simplify both unit and functional testing of the application. **Specs2** is
    the default testing framework used in Play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个默认的测试框架以及辅助器和应用程序存根，以简化应用程序的单元和功能测试。**Specs2**是Play中使用的默认测试框架。
- en: Play comes with a Scala-based template engine, due to which it is possible to
    use Scala objects (`String`, `List`, `Map`, `Int`, user-defined objects, and so
    on) in the templates. This was not possible prior to 2.0 because earlier versions
    of Play relied on Groovy for the template engine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Play 内置了基于 Scala 的模板引擎，因此可以在模板中使用 Scala 对象（`String`、`List`、`Map`、`Int`、用户定义的对象等）。在
    2.0 版本之前，Play 依赖于 Groovy 作为模板引擎，这是不可能的。
- en: It uses JBoss Netty as the default web server but any Play 2 application can
    be packaged as a WAR file and deployed on Servlet 2.5, 3.0, and 3.1 containers,
    if required. There is a plugin called **play2-war-plugin** (it can be found at
    [https://github.com/play2war/play2-war-plugin/](https://github.com/play2war/play2-war-plugin/)),
    which can be used to generate the WAR file for any given Play2 app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 JBoss Netty 作为默认的 Web 服务器，但任何 Play 2 应用程序都可以被打包成 WAR 文件，并在需要时部署在 Servlet
    2.5、3.0 和 3.1 容器上。有一个名为 **play2-war-plugin** 的插件（可以在 [https://github.com/play2war/play2-war-plugin/](https://github.com/play2war/play2-war-plugin/)
    找到），可以用于为任何给定的 Play2 应用程序生成 WAR 文件。
- en: 'Play endorses the **Model-View-Controller** (**MVC**) pattern. According to
    the MVC pattern, the components of an application can be divided into three categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Play 支持 **模型-视图-控制器**（**MVC**）模式。根据 MVC 模式，应用程序的组件可以分为三类：
- en: '**Model**: This represents application data or activity'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这代表应用程序数据或活动'
- en: '**View**: This is the part of the application which is visible to the end user'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是应用程序中用户可以看到的部分'
- en: '**Controller**: This is responsible for processing input from the end user'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是负责处理来自终端用户输入的部分'
- en: 'The pattern also defines how these components are supposed to interact with
    one another. Let''s consider an online store as our application. In this case,
    the products, brands, users, cart, and so on can be represented by a model each.
    The pages in the application where users can view the products are defined in
    the views (HTML pages). When a user adds a product to the cart, the transaction
    is handled by a controller. The view is unaware of the model and the model is
    unaware of the view. The controller sends commands to the model and view. The
    following figure shows how the models, views, and controllers interact:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式还定义了这些组件应该如何相互交互。让我们以在线商店作为我们的应用程序。在这种情况下，产品、品牌、用户、购物车等可以由每个模型表示。用户可以查看产品的应用程序页面定义在视图中（HTML
    页面）。当用户将产品添加到购物车时，事务由控制器处理。视图不知道模型，模型也不知道视图。控制器向模型和视图发送命令。以下图显示了模型、视图和控制器之间的交互：
- en: '![Venturing into the world of Play](img/3803OS_01_07.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![探索 Play 的世界](img/3803OS_01_07.jpg)'
- en: Play also comes prepackaged with an easy to use Hibernate layer, and offers
    OpenID, Ehcache, and web service integration straight out of the box by adding
    a dependency on the individual modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Play 还预包装了一个易于使用的 Hibernate 层，并且通过添加对各个模块的依赖，可以直接提供 OpenID、Ehcache 和 Web 服务集成。
- en: In the following sections of this chapter, we'll make a simple app using Play.
    This is mainly for developers who are using Play earlier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将使用 Play 创建一个简单的应用程序。这主要是针对早期使用 Play 的开发者。
- en: A sample Play app
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例 Play 应用程序
- en: 'There are two ways of creating a new Play application: Activator, and without
    using Activator. It is simpler to create a Play project using Activator since
    the most minimalist app would require at least six files.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 Play 应用程序有两种方式：激活器，和不使用激活器。使用激活器创建 Play 项目更简单，因为最简约的应用程序至少需要六个文件。
- en: '**Typesafe Activator** is a tool that can be used to create applications using
    the Typesafe stack. It relies on using predefined templates to create new projects.
    The instructions for setting up Activator can be found at [http://typesafe.com/get-started](http://typesafe.com/get-started).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Typesafe Activator** 是一个可以用来使用 Typesafe 堆栈创建应用程序的工具。它依赖于使用预定义的模板来创建新项目。设置
    Activator 的说明可以在 [http://typesafe.com/get-started](http://typesafe.com/get-started)
    找到。'
- en: Building a Play application using Activator
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用激活器构建 Play 应用程序
- en: 'Let''s build a new Play application using Activator and a simple template:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用激活器和简单的模板来构建一个新的 Play 应用程序：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, run the project using the `run` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `run` 命令运行项目：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This starts the application, which is accessible at `http://localhost:9000`,
    by default.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它通过 `http://localhost:9000` 启动应用程序，使其可访问。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `run` command starts the project in development mode. In this mode, the
    source code of the application is watched for changes, and if there are any changes
    the code is recompiled. We can then make changes to the models, views, or controllers
    and see them reflected in the application by reloading the browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令以开发模式启动项目。在这种模式下，应用程序的源代码会监视变化，如果有任何变化，代码将被重新编译。然后我们可以修改模型、视图或控制器，并通过重新加载浏览器来看到它们在应用程序中的反映。'
- en: 'Take a look at the project structure. It will be similar to the one shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下项目结构。它将类似于这里所示的结构：
- en: '![Building a Play application using Activator](img/3803OS_01_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![使用Activator构建Play应用程序](img/3803OS_01_01.jpg)'
- en: If we can't use Activator, we will probably have to create all these files.
    Now, let's dig into the files individually and see which is for what purpose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能使用Activator，我们可能不得不创建所有这些文件。现在，让我们逐个深入探讨这些文件，看看它们各自的作用。
- en: The build definition
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建定义
- en: Let's start with the crucial part of the project—its build definition, and in
    our case, the `build.sbt` file. The `.sbt` extension comes from the build tool
    used for Play applications. We will go through the key concepts of this for anyone
    who isn't familiar with SBT. The build definition is essentially a list of keys
    and their corresponding values, more or less like assignment statements with the
    `:=` symbol acting as the assignment operator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从项目的关键部分开始——其构建定义，在我们的案例中，是`build.sbt`文件。`.sbt`扩展名来源于用于Play应用程序的构建工具。我们将为不熟悉SBT的人介绍这个概念。构建定义本质上是一个键值对的列表，类似于带有`:=`符号作为赋值操作符的赋值语句。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SBT version lower than 0.13.7 expects a new line as the delimiter between two
    different statements in the build definition.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SBT版本低于0.13.7期望在构建定义中两个不同语句之间的分隔符为换行符。
- en: 'The contents of the build file are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件的包含内容如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding build definition, the values for the project''s `name`, `version`,
    and `root` are specified. Another way of specifying values is by updating the
    existing ones. We can append to the existing values using the `+=` symbol for
    individual items and `++=` for sequences. For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的构建定义中，指定了项目的`name`、`version`和`root`的值。另一种指定值的方法是更新现有的值。我们可以使用`+=`符号为单个项目追加值，使用`++=`为序列追加值。例如：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`resolvers` is the list of URLs from where the dependencies can be picked up
    and `scalacOptions` is the list of parameters passed to the Scala compiler.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolvers`是依赖项可以从中获取的URL列表，而`scalacOptions`是传递给Scala编译器的参数列表。'
- en: 'Alternatively, an SBT project can also use a `.scala` build file. The structure
    for our application would then be:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，SBT项目也可以使用`.scala`构建文件。我们的应用程序的结构将是：
- en: '![The build definition](img/3803OS_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![构建定义](img/3803OS_01_02.jpg)'
- en: 'The `.scala` build definition for `SimpleApp` will be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleApp`的`.scala`构建定义如下：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `.scala` build definition comes in handy when we need to define custom tasks/settings
    for our application/plugin, since it uses Scala code. The `.sbt` definition is
    generally smaller and simpler than its corresponding `.scala` definition and is
    hence, more preferred.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要为应用程序/插件定义自定义任务/设置时，`.scala`构建定义非常有用，因为它使用Scala代码。`.sbt`定义通常比其对应的`.scala`定义更小、更简单，因此更受欢迎。
- en: Without the Play settings, which are imported by enabling the PlayScala plugin,
    SBT is clueless that our project is a Play application and is defined according
    to the semantics of a Play application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有通过启用PlayScala插件导入的Play设置，SBT将无法知道我们的项目是一个Play应用程序，并且会根据Play应用程序的语义进行定义。
- en: So, is that statement sufficient for SBT to run a Play app correctly?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个声明是否足够让SBT正确运行Play应用程序？
- en: No, there is something else as well! SBT allows us to extend build definitions
    using plugins. Play-based projects make use of the Play SBT plugin and it is from
    this plugin that SBT gets the required settings. In order for SBT to download
    all the plugins that our project will be using, they should be added explicitly.
    This is done by adding them in `plugins.sbt` in the `projectRoot/project` directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不，还有其他的事情！SBT允许我们通过插件扩展构建定义。基于Play的项目使用Play SBT插件，并且SBT就是从这个插件中获取所需的设置。为了使SBT下载我们的项目将使用的所有插件，它们应该被明确添加。这是通过在`projectRoot/project`目录中的`plugins.sbt`中添加它们来完成的。
- en: 'Let''s take a look at the `plugins.sbt` file. The file content will be:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`plugins.sbt`文件。文件内容如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The parameter passed to `addSbtPlugin` is the Ivy module ID for the plugin.
    The resolver is helpful when the plugin is not hosted on Maven or Typesafe repositories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`addSbtPlugin`的参数是插件的Ivy模块ID。当插件不在Maven或Typesafe仓库上托管时，解析器很有帮助。
- en: The `build.properties` file is used to specify the SBT version to avoid incompatibility
    issues between the same build definitions compiled by using two or more different
    versions of SBT.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.properties`文件用于指定SBT版本，以避免使用两个或更多不同版本的SBT编译的相同构建定义之间的不兼容性问题。'
- en: This covers all the build-related files of a Play application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了Play应用程序的所有与构建相关的文件。
- en: The source code
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源代码
- en: Now, let us look at the source code for our project. Most of the source is in
    the `app` folder. Generally, the model's code is within `app/models` or `app/com/projectName/models`
    and the controller's source code is in `app/co` `ntrollers` or `app/com/projectName/controllers`,
    where `com.projectName` is the package. The code for the views should be in `app/views`
    or within a subfolder in `app/views`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们项目的源代码。大部分源代码都在`app`文件夹中。通常，模型的代码在`app/models`或`app/com/projectName/models`中，控制器的源代码在`app/controllers`或`app/com/projectName/controllers`中，其中`com.projectName`是包名。视图的代码应该在`app/views`或`app/views`的子文件夹中。
- en: The `views/main.scala.html` file is the page we will be able to see when we
    run our application. If this file is missing, you can add it. If you are wondering
    why the file is named `main.scala.html` and not `main.html`, this is because it's
    a Twirl template; it facilitates using Scala code along with HTML to define views.
    We will delve deeper into this in [Chapter 4](ch04.html "Chapter 4. Exploring
    Views"), *Exploring Views*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`views/main.scala.html`文件是我们运行应用程序时能看到的那一页。如果这个文件缺失，您可以添加它。如果您想知道为什么文件命名为`main.scala.html`而不是`main.html`，这是因为它是一个Twirl模板；它便于使用Scala代码与HTML结合来定义视图。我们将在[第4章](ch04.html
    "第4章。探索视图")*探索视图*中深入探讨这一点。'
- en: 'Now, update the content of `main.scala.html` to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`main.scala.html`的内容如下：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can provide the title and content from our Scala code to display this view.
    A view can be bound to a specific request through the controllers. So, let''s
    update the code for our controller `SampleAppController`, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Scala代码中提供标题和内容来显示这个视图。一个视图可以通过控制器绑定到特定的请求。所以，让我们更新我们的控制器`SampleAppController`的代码，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: '`Action` and `Ok` are methods made available by the `play.mvc.api` package.
    [Chapter 2](ch02.html "Chapter 2. Defining Actions"), *Defining Actions* covers
    them in detail.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`和`Ok`是由`play.mvc.api`包提供的方法。[第2章](ch02.html "第2章。定义动作")*定义动作*详细介绍了它们。'
- en: 'On saving the changes and running the application, we will see the page hosted
    at `http://localhost:9000`, as shown in the screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并运行应用程序后，我们将看到截图所示的`http://localhost:9000`上托管的页面：
- en: '![The source code](img/3803OS_01_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![源代码](img/3803OS_01_03.jpg)'
- en: Request handling process
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 请求处理过程
- en: Let's see how the request was handled!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看请求是如何处理的！
- en: All requests that will be supported by the application must be defined in the
    `conf/routes` file. Each route definition has three parts. The first part is the
    request method. It can be any one of `GET`, `POST`, `PUT`, and `DELETE`. The second
    part is the path and the third is the method, which returns a response. When a
    request is defined in the `conf/routes` file, the method to which it is mapped
    in the `conf/routes` file is called.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将支持的所有请求必须在`conf/routes`文件中定义。每个路由定义有三个部分。第一部分是请求方法。它可以是`GET`、`POST`、`PUT`和`DELETE`中的任何一个。第二部分是路径，第三部分是返回响应的方法。当在`conf/routes`文件中定义请求时，它在`conf/routes`文件中映射的方法被调用。
- en: 'For example, an entry in the routes file would be:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，路由文件中的一个条目可能是：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that for a GET request on the `/` path, we have mapped the response
    to be the one returned from the `SampleController.index()` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于`/`路径上的GET请求，我们已经将响应映射为从`SampleController.index()`方法返回的那个。
- en: 'A sample request would be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例请求如下：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Go ahead and add a few more pages to the application to get more comfortable,
    maybe a FAQ, Contact Us, or About.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加更多页面到应用程序中，以便更加熟悉，也许是一个常见问题解答、联系我们或关于我们。
- en: 'The request-response cycle for a Play app, explained in the preceding code
    is represented here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中解释的Play应用程序的请求-响应周期在此处表示：
- en: '![Request handling process](img/3803OS_01_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![请求处理过程](img/3803OS_01_08.jpg)'
- en: 'The `public` directory is essentially used to serve resources, such as stylesheets,
    JavaScript, and images that are independent of Play. To make these files accessible,
    the path to `public` is also added in routes by default:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`目录基本上用于提供资源，如样式表、JavaScript和图像，这些资源与Play无关。为了使这些文件可访问，默认情况下也将`public`的路径添加到路由中：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will see routes in detail in [Chapter 3](ch03.html "Chapter 3. Building Routes"),
    *Building Routes*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章。构建路由")*构建路由*中详细了解路由。
- en: The file `conf/application.conf` is used to set application-level configuration
    properties.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`conf/application.conf`用于设置应用程序级别的配置属性。
- en: The `target` directory is used by SBT for the files generated during compile,
    build, or other processes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`目录被SBT用于编译、构建或其他过程中生成的文件。'
- en: Creating a TaskTracker application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建TaskTracker应用程序
- en: Let us create a simple **TaskTracker** application, which allows us to add pending
    tasks and delete them. We will continue by modifying `SampleApp`, built in the
    previous section. In this app, we will not be using a DB to store the tasks. It
    is possible to persist models in Play using **Anorm** or other modules; this is
    discussed in more detail in [Chapter 5](ch05.html "Chapter 5. Working with Data"),
    *Working with Data*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的**TaskTracker**应用程序，它允许我们添加待办任务并删除它们。我们将继续修改上一节中构建的`SampleApp`。在这个应用程序中，我们不会使用数据库来存储任务。在Play中使用**Anorm**或其他模块持久化模型是可能的；这将在[第5章](ch05.html
    "第5章。处理数据")*处理数据*中更详细地讨论。
- en: 'We need a view that has an input box to enter the task. Add another template
    file, `index.scala.html`, to the views, using the template generated in the preceding
    section as boilerplate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个带有输入框以输入任务的视图。将另一个模板文件`index.scala.html`添加到视图中，使用上一节生成的模板作为样板：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to use a template, we can call its generated method from our Scala
    code or refer to it in other templates by using its name. Using a main template
    can come in handy when we want to apply a change to all the templates. For example,
    if we want to add a style sheet for an application, just adding this in our main
    template will ensure that it's added for all the dependent views.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用模板，我们可以从我们的Scala代码中调用其生成的方法，或者通过其名称在其他模板中引用它。当我们想要对所有模板应用更改时，使用主模板会很有帮助。例如，如果我们想为应用程序添加一个样式表，只需在主模板中添加这个样式表即可确保它被添加到所有依赖的视图中。
- en: 'To view this template''s content on loading, update the `index` method to:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在加载时查看此模板的内容，请更新`index`方法为：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we have also replaced all occurrences of `SampleAppController` to
    `TaskController`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将所有`SampleAppController`的实例替换为`TaskController`。
- en: 'Run the application and view it in the browser; the page will look similar
    to this figure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并在浏览器中查看；页面将类似于这个图：
- en: '![Creating a TaskTracker application](img/3803OS_01_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![创建TaskTracker应用程序](img/3803OS_01_04.jpg)'
- en: 'Now, in order to work on the functionality, let''s add a model called `Task`,
    which we''ll use to represent the task in our app. Since we want to delete the
    functionality too, we will need to identify each task using a unique ID, which
    means that our model should have two properties: an ID and a name. The `Task`
    model will be:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了处理功能，让我们添加一个名为`Task`的模型，我们将使用它来表示应用程序中的任务。由于我们还想删除功能，我们需要使用唯一的ID来标识每个任务，这意味着我们的模型应该有两个属性：一个ID和一个名称。`Task`模型将是：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this model, we are using a `taskList` private variable to keep track of the
    tasks for the session.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们使用一个名为`taskList`的私有变量来跟踪会话中的任务。
- en: In the `add` method, whenever a new task is added, we append it to this list.
    Instead of keeping another variable to keep count of the IDs, I choose to increment
    the ID of the last element in the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add`方法中，每当添加一个新任务时，我们将其追加到这个列表中。而不是保持另一个变量来计数ID，我选择递增列表中最后一个元素的ID。
- en: In the `delete` method, we simply filter out the task with the given ID and
    the `all` method returns the list for this session.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`delete`方法中，我们简单地过滤掉具有给定ID的任务，而`all`方法返回这个会话的列表。
- en: 'Now, we need to call these methods in our controller and then bind them to
    a request route. Now, update the controller in this way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的控制器中调用这些方法，然后将它们绑定到一个请求路由。现在，以这种方式更新控制器：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, `routes` refers to the helper that can be used to access
    the routes defined for the application in `conf/routes`. Try running the app now!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`routes`指的是可以用来访问在`conf/routes`中定义的应用程序路由的辅助工具。现在尝试运行应用程序！
- en: It'll throw a compilation error, which says that values tasks is not a member
    of `controllers.ReverseTaskController`. This occurs because we haven't yet updated
    the routes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它将抛出一个编译错误，指出`values tasks`不是`controllers.ReverseTaskController`的成员。这是因为我们还没有更新路由。
- en: Adding a new task
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个新任务
- en: 'Now, let''s bind actions to get tasks and add a new task:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绑定获取任务和添加新任务的行动：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll complete our application''s view so that it can facilitate the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完成我们应用程序的视图，以便它可以促进以下功能：
- en: '`accept and render a List[Task]`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`接受并渲染List[Task]`'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have now added a form in the view, which takes a text input with the `taskName`
    name and submits this data to a `TaskController.newTask` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在视图中添加了一个表单，它接受一个名为`taskName`的文本输入，并将此数据提交给`TaskController.newTask`方法。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we have now added a `tasks` argument for this template and are displaying
    it in the view. Scala elements and predefined templates are prepended with the
    `@` twirl symbol in the views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在为这个模板添加了一个`tasks`参数，并在视图中显示它。Scala元素和预定义模板在视图中以`@`twirl符号开头。
- en: 'Now, when running the app, we will be able to add tasks as well as view existing
    ones, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当运行应用程序时，我们将能够添加任务以及查看现有的任务，如下所示：
- en: '![Adding a new task](img/3803OS_01_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![添加新任务](img/3803OS_01_05.jpg)'
- en: Deleting a task
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除任务
- en: 'The only thing remaining in our app is the ability to delete a task. Update
    the index template so that each `<li>` element has a button, whose click results
    in a delete request to the server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中剩下的唯一功能是删除任务。更新索引模板，以便每个`<li>`元素都有一个按钮，点击该按钮将向服务器发送删除请求：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we would need to update the routes file to map the delete action:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新路由文件以映射删除操作：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to define `deleteTask` in our view. To do this, we can simply
    add a script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的视图中定义`deleteTask`。为此，我们可以简单地添加一个脚本：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, we shouldn't be defining JavaScript methods in the window's global
    namespace. It has been done in this example, so as to keep it simple and it's
    not advised for any real-time application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们不应该在窗口的全局命名空间中定义JavaScript方法。在这个例子中已经这样做，以保持简单，但不建议用于任何实时应用程序。
- en: 'Now, when we run the app, we can add tasks as well as remove them, as shown
    here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行应用程序时，我们可以添加任务以及删除它们，如下所示：
- en: '![Deleting a task](img/3803OS_01_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![删除任务](img/3803OS_01_06.jpg)'
- en: 'I am leaving the task of beautifying the app up to you. Add a style sheet in
    the public directory and declare it in the main template. For example, if the
    `taskTracker.css` file is located at `public/stylesheets`, the link to it in the
    `main.scala.html` file would be:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我将美化应用程序的任务留给你。在公共目录中添加一个样式表，并在主模板中声明它。例如，如果`taskTracker.css`文件位于`public/stylesheets`，则`main.scala.html`文件中的链接将是：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter gives a basic introduction to the Play Framework. In this chapter,
    we have learned how to build simple applications using the Play Framework. We
    have gone through its project structure to understand how the framework plugs
    in required settings through the build file. We have also discussed the various
    bits and pieces of such applications: models, routes, views, controllers, and
    so on.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Play框架的基本概念。在本章中，我们学习了如何使用Play框架构建简单的应用程序。我们了解了其项目结构，以了解框架如何通过构建文件插入所需的设置。我们还讨论了此类应用程序的各个部分：模型、路由、视图、控制器等。
- en: In the next chapter, we will cover actions in detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细介绍操作。
