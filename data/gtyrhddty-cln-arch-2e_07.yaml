- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Implementing a Persistence Adapter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现持久化适配器
- en: In [*Chapter 2*](B19916_07.xhtml), *What's Wrong with Layers?* I complained
    about a traditional layered architecture and claimed that it promotes *database-driven
    design* because, ultimately, everything depends on the persistence layer. In this
    chapter, we’ll have a look at how to make the persistence layer a plugin to the
    application layer to invert this dependency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B19916_07.xhtml)，“层有什么问题？”中，我抱怨了传统的分层架构，并声称它促进了*数据库驱动设计*，因为最终，一切依赖于持久化层。在本章中，我们将探讨如何使持久化层成为应用程序层的插件，以反转这种依赖关系。
- en: Dependency inversion
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: 'Instead of a persistence layer, we’ll talk about a persistence adapter that
    provides persistence functionality to the domain services. *Figure 7**.1* shows
    how we can apply the Dependency Inversion Principle to do just that:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不讨论持久化层，而是讨论一个为领域服务提供持久化功能的持久化适配器。*图7.1*展示了我们如何应用依赖倒置原则来实现这一点：
- en: '![Figure 7.1 – The services from the core use ports to access the persistence
    adapter](img/Figure_07.1._B19916.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 核心服务使用端口访问持久化适配器](img/Figure_07.1._B19916.jpg)'
- en: Figure 7.1 – The services from the core use ports to access the persistence
    adapter
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 核心服务使用端口访问持久化适配器
- en: Our domain services call port interfaces to access persistence functionality.
    These ports are implemented by a persistence adapter class that does the actual
    persistence work and is responsible for talking to the database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域服务调用端口接口以访问持久化功能。这些端口由一个持久化适配器类实现，该类执行实际的持久化工作，并负责与数据库通信。
- en: In Hexagonal Architecture lingo, the persistence adapter is a *driven* or *outgoing*
    adapter because it’s called by our application and not the other way around.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构术语中，持久化适配器是一个*驱动*或*输出*适配器，因为它是由我们的应用程序调用的，而不是反过来。
- en: The ports are effectively a layer of indirection between the domain services
    and the persistence code. Let’s remind ourselves that we’re adding this layer
    of indirection in order to be able to evolve the domain code without having to
    think about persistence problems, meaning without code dependencies on the persistence
    layer. Refactoring in persistence code will not lead to a code change in the core.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 端口在领域服务和持久化代码之间实际上是一个间接层。让我们提醒自己，我们添加这个间接层是为了能够在不思考持久化问题的情况下演进领域代码，也就是说，没有对持久化层的代码依赖。在持久化代码中的重构不会导致核心代码的改变。
- en: Naturally, at runtime, we still have a dependency from our application core
    to the persistence adapter. If we modify the code in the persistence layer and
    introduce a bug, for example, we may still break the functionality in the application
    core. However, as long as the contracts of the ports are fulfilled, we’re free
    to do what we want in the persistence adapter without affecting the core.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在运行时，我们仍然有应用程序核心对持久化适配器的依赖。如果我们修改持久化层的代码并引入了一个错误，例如，我们仍然可能会破坏应用程序核心的功能。然而，只要端口合约得到满足，我们就可以在持久化适配器中自由地做我们想做的事情，而不会影响核心。
- en: Responsibilities of a persistence adapter
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化适配器的职责
- en: 'Let’s have a look at what a persistence adapter usually does:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看持久化适配器通常都做什么：
- en: Takes the input.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收输入。
- en: Maps the input into database format.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入映射到数据库格式。
- en: Sends the input to the database.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入发送到数据库。
- en: Maps the database output into application format.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库输出映射到应用程序格式。
- en: Returns the output.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回输出。
- en: The persistence adapter takes input through a port interface. The input model
    may be a domain entity or an object dedicated to a specific database operation,
    as specified by the interface.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化适配器通过端口接口接收输入。输入模型可能是一个领域实体或一个专门用于特定数据库操作的对象，具体由接口指定。
- en: It then maps the input model to a format it can work with to modify or query
    the database. In Java projects, we commonly use the **Java Persistence API** (**JPA**)
    to talk to a database, so we might map the input into JPA entity objects that
    reflect the structure of the database tables. Depending on the context, mapping
    the input model into JPA entities may be a lot of work for little gain, so we’ll
    talk about strategies without mapping in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081),
    *Mapping* *between Boundaries*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将输入模型映射到它可以处理以修改或查询数据库的格式。在Java项目中，我们通常使用**Java持久化API**（**JPA**）与数据库通信，因此我们可能会将输入映射到反映数据库表结构的JPA实体对象。根据上下文，将输入模型映射到JPA实体可能是一项工作量很大但收益甚微的工作，所以我们将在[*第9章*](B19916_09.xhtml#_idTextAnchor081)“*边界之间的映射*”中讨论不进行映射的策略。
- en: Instead of using JPA or another object-relational mapping framework, we might
    use any other technique to talk to the database. We might map the input model
    into plain SQL statements and send these statements to the database, or we might
    serialize incoming data into files and read them back from there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不会使用JPA或其他对象关系映射框架，而是使用任何其他技术来与数据库通信。我们可能将输入模型映射到普通的SQL语句并将这些语句发送到数据库，或者我们将传入的数据序列化到文件中，然后从那里读取它们。
- en: The important part is that the input model to the persistence adapter lies within
    the application core, and not within the persistence adapter itself, so that changes
    in the persistence adapter don’t affect the core.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，持久化适配器的输入模型位于应用程序核心，而不是持久化适配器本身，这样持久化适配器的变化就不会影响核心。
- en: Next, the persistence adapter queries the database and receives the query results.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，持久化适配器查询数据库并接收查询结果。
- en: Finally, it maps the database answer into the output model expected by the port
    and returns it. Again, it’s important that the output model lies within the application
    core and not within the persistence adapter to have the dependencies point in
    the right direction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将数据库答案映射到端口期望的输出模型，并返回它。同样，输出模型位于应用程序核心而不是持久化适配器中，这对于确保依赖关系指向正确的方向非常重要。
- en: Aside from the fact that the input and output models lie in the application
    core instead of the persistence adapter itself, the responsibilities are not really
    different from those of a traditional persistence layer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输入和输出模型位于应用程序核心而不是持久化适配器本身之外，责任实际上与传统持久层的责任没有太大区别。
- en: However, implementing a persistence adapter as described here will inevitably
    raise some questions that we probably wouldn’t ask when implementing a traditional
    persistence layer, as we’re so used to the traditional way that we don’t think
    about them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按照这里描述的方式实现持久化适配器不可避免地会引发一些问题，这些问题在我们实现传统持久层时可能不会提出，因为我们已经习惯了传统的方式，没有考虑这些问题。
- en: Slicing port interfaces
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口接口切割
- en: One question that comes to mind when implementing services is how to slice the
    port interfaces that define the database operations available to the application
    core.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现服务时，人们可能会想到的一个问题是，如何切割定义应用程序核心可用的数据库操作的端口接口。
- en: It’s a common practice to create a single repository interface that provides
    all database operations for a certain entity, as outlined in *Figure 7**.2*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单一的存储库接口，为某个实体提供所有数据库操作，是一种常见的做法，如*图7.2*所示。
- en: '![Figure 7.2 – Centralizing all database operations into a single outgoing
    port interface makes all services depend on methods they don’t need](img/Figure_07.2._B19916.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 将所有数据库操作集中到单个输出端口接口使所有服务都依赖于它们不需要的方法](img/Figure_07.2._B19916.jpg)'
- en: Figure 7.2 – Centralizing all database operations into a single outgoing port
    interface makes all services depend on methods they don’t need
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2* – 将所有数据库操作集中到单个输出端口接口使所有服务都依赖于它们不需要的方法'
- en: Each service that relies on database operations will then have a dependency
    on this single “broad” port interface, even if it uses only a single method from
    the interface. This means we have unnecessary dependencies in our code base.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个依赖于数据库操作的服务都将随后依赖于这个单一的“广泛”端口接口，即使它只使用接口中的一个方法。这意味着我们在代码库中存在不必要的依赖。
- en: Dependencies on methods that we don’t need in our context make the code harder
    to understand and test. Imagine that we’re writing a unit test for `RegisterAccountService`
    from the preceding figure. Which of the methods of the `AccountRepository` interface
    do we have to create a mock for? We have to first find out which of the `AccountRepository`
    methods the service actually calls. Having mocked only part of the interface may
    lead to other problems, as the next person working on that test might expect the
    interface to be completely mocked and run into errors. So, they again have to
    do some research.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的环境中不需要的方法的依赖关系会使代码更难以理解和测试。想象一下，我们正在为前图中所示的`RegisterAccountService`编写单元测试。我们需要为`AccountRepository`接口的哪些方法创建模拟？我们必须首先找出服务实际调用的`AccountRepository`方法的哪些。只模拟接口的一部分可能会导致其他问题，因为下一个处理这个测试的人可能会期望接口被完全模拟并遇到错误。因此，他们又得进行一些研究。
- en: To put it in the words of Robert C. Martin, “*Depending on something that carries
    baggage that you don’t need can cause you troubles that you* *didn’t expect.*”[1](#footnote-025)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用罗伯特·C·马丁的话来说，“*依赖于携带你不需要的负担的东西可能会给你带来你意想不到的麻烦。*”[1](#footnote-025)
- en: '[1](#footnote-025-backlink). Interface Segregation Principle*: Clean Architecture*
    by Robert C. Martin, page 86.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-025-backlink). 接口分离原则*：罗伯特·C·马丁的《Clean Architecture》，第86页。'
- en: The **Interface Segregation Principle** provides an answer to this problem.
    It states that broad interfaces should be split into specific ones so that clients
    only know the methods they need. If we apply this to our outgoing ports, we might
    get a result as shown in *Figure 7**.3*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**为这个问题提供了一个答案。它指出，宽泛的接口应该被分割成具体的接口，这样客户端只知道他们需要的那些方法。如果我们将这个原则应用到我们的输出端口上，我们可能会得到如图*图7.3*所示的结果。'
- en: '![Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary
    dependencies and makes the existing dependencies more visible](img/Figure_07.3._B19916.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 应用接口分离原则消除了不必要的依赖，并使现有的依赖更加明显](img/Figure_07.3._B19916.jpg)'
- en: Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary
    dependencies and makes the existing dependencies more visible
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 应用接口分离原则消除了不必要的依赖，并使现有的依赖更加明显
- en: Each service now only depends on the methods it actually needs. What’s more,
    the names of the ports clearly state what they’re about. In a test, we no longer
    have to think about which methods to mock since most of the time, there is only
    one method per port.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个服务只依赖于它实际需要的那些方法。更重要的是，端口的名称清楚地说明了它们的内容。在测试中，我们不再需要考虑要模拟哪些方法，因为大多数情况下，每个端口只有一个方法。
- en: Having very narrow ports such as these makes coding a plug-and-play experience.
    When working on a service, we just “plug in” the ports we need. There is no baggage
    to carry around.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有如此狭窄的端口使得编码成为一种即插即用的体验。当处理一个服务时，我们只需“插入”我们需要的端口。没有需要携带的负担。
- en: Of course, the “one method per port” approach may not be applicable in all circumstances.
    There may be groups of database operations that are so cohesive and often used
    together that we may want to bundle them together in a single interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，“每个端口一个方法”的方法可能并不适用于所有情况。可能有一些数据库操作组非常紧密且经常一起使用，我们可能希望将它们捆绑在一个单独的接口中。
- en: Slicing persistence adapters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化适配器的切片
- en: In the preceding figures, we saw a single persistence adapter class that implements
    all persistence ports. There is no rule, however, that forbids us to create more
    than one persistence adapter, as long as all persistence ports are implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到了一个实现所有持久化端口的单一持久化适配器类。然而，没有规则禁止我们创建超过一个持久化适配器，只要所有持久化端口都得到了实现。
- en: We might choose, for instance, to implement one persistence adapter per group
    of domain entities for which we need persistence operations (or aggregate in Domain-Driven
    Design lingo), as shown in *Figure 7**.4*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会选择为需要持久化操作（或在领域驱动设计术语中称为聚合）的每个领域实体组实现一个持久化适配器，如图*图7.4*所示。
- en: '![Figure 7.4 – We can create multiple persistence adapters, one for each aggregate](img/Figure_07.4._B19916.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 我们可以为每个聚合创建多个持久化适配器](img/Figure_07.4._B19916.jpg)'
- en: Figure 7.4 – We can create multiple persistence adapters, one for each aggregate
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 我们可以为每个聚合创建多个持久化适配器
- en: This way, our persistence adapters are automatically sliced along the seams
    of the domain that we support with persistence functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的持久化适配器会自动沿着我们支持持久化功能的领域边界进行切片。
- en: We might split our persistence adapters into even more classes – for instance,
    when we want to implement a couple of persistence ports using JPA (or another
    object-relational mapper) and some other ports using plain SQL for better performance.
    We might then create one JPA adapter and one plain SQL adapter, each implementing
    a subset of the persistence ports.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会将我们的持久化适配器分成更多类——例如，当我们想使用 JPA（或另一个对象关系映射器）实现几个持久化端口，并使用纯 SQL 实现一些其他端口以获得更好的性能时。然后我们可能会创建一个
    JPA 适配器和一個纯 SQL 适配器，每个适配器实现持久化端口的子集。
- en: Remember that our domain code doesn’t care about which class ultimately fulfills
    the contracts defined by the persistence ports. We’re free to do as we see fit
    in the persistence layer, as long as all ports are implemented.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的领域代码不关心哪个类最终实现了持久化端口定义的契约。我们在持久化层中可以自由地按照我们的看法行事，只要所有端口都得到了实现。
- en: The *one persistence adapter per aggregate* approach is also a good foundation
    to separate the persistence needs for multiple bounded contexts in the future.
    Say, after a time, we identify a bounded context responsible for use cases around
    billing. *Figure 7**.5* adds that new domain to the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个聚合只有一个持久化适配器的方法也是为将来分离多个边界上下文的持久化需求打下良好基础。比如说，经过一段时间，我们确定了一个负责围绕计费用例的边界上下文。*图
    7**.5* 将这个新领域添加到应用中。
- en: '![Figure 7.5 – If we want to create hard boundaries between bounded contexts,
    each bounded context should have its own persistence adapter(s)](img/Figure_07.5._B19916.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 如果我们想在边界上下文之间创建硬边界，每个边界上下文都应该有自己的持久化适配器(s)](img/Figure_07.5._B19916.jpg)'
- en: Figure 7.5 – If we want to create hard boundaries between bounded contexts,
    each bounded context should have its own persistence adapter(s)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 如果我们想在边界上下文之间创建硬边界，每个边界上下文都应该有自己的持久化适配器(s)
- en: Each `account` context may not access persistence adapters of the `billing`
    context, and vice versa. If one context needs something of the other, they can
    call each other’s domain services, or we can introduce an application service
    as a coordinator between the bounded contexts. We will talk more about this topic
    in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing Multiple* *Bounded
    Contexts*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `account` 上下文可能无法访问 `billing` 上下文的持久化适配器，反之亦然。如果一个上下文需要另一个上下文的东西，它们可以调用对方的领域服务，或者我们可以引入一个应用服务作为边界上下文之间的协调者。我们将在
    [*第 13 章*](B19916_13.xhtml#_idTextAnchor112)，*管理多个边界上下文* 中更多地讨论这个话题。
- en: An example with Spring Data JPA
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data JPA 的示例
- en: 'Let’s have a look at a code example that implements `AccountPersistenceAdapter`
    from the preceding figures. This adapter will have to save and load accounts to
    and from the database. We already saw the `Account` entity in [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044),
    *Implementing a Use Case*, but here is its skeleton again for reference:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例，该示例实现了前面图中的 `AccountPersistenceAdapter`。这个适配器将需要在数据库中保存和加载账户。我们已经在
    [*第 5 章*](B19916_05.xhtml#_idTextAnchor044)，*实现用例* 中看到了 `Account` 实体，但这里再次提供其结构以供参考：
- en: '![](img/code-7.1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-7.1.jpg)'
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Account` class is not a simple data class with getters and setters but
    instead tries to be as immutable as possible. It only provides factory methods
    that create an account in a valid state, and all mutating methods do some validation,
    such as checking the account balance before withdrawing money, so that we cannot
    create an invalid domain model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account` 类不是一个简单的数据类，带有获取器和设置器，而是试图尽可能不可变。它只提供工厂方法来创建一个处于有效状态的账户，并且所有修改方法都会进行一些验证，例如在取款前检查账户余额，这样我们就不能创建一个无效的领域模型。'
- en: 'We’ll use Spring Data JPA to talk to the database, so we also need `@Entity`-annotated
    classes to represent the database state of an account:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data JPA 与数据库通信，因此我们还需要用 `@Entity` 注解的类来表示账户的数据库状态：
- en: '![](img/code-7.2.jpg)![](img/code-7.3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-7.2.jpg)![](img/code-7.3.jpg)'
- en: The state of an account consists merely of an ID at this stage. Later, additional
    fields such as a user ID may be added. More interesting is `ActivityJpaEntity`,
    which contains all the activities of a specific account. We could have connected
    `ActivitiyJpaEntity` with `AccountJpaEntity` via JPA’s `@ManyToOne` or `@OneToMany`
    annotations to mark the relation between them, but we have opted to leave this
    out for now, as it adds side effects to the database queries. In fact, at this
    stage, it would probably be easier to use a simpler object-relational mapper than
    JPA to implement the persistence adapter, but we will use it anyway because we
    think we might need it in the future.[2](#footnote-024)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，账户的状态仅仅是一个ID。稍后，可能会添加额外的字段，如用户ID。更有趣的是`ActivityJpaEntity`，它包含了一个特定账户的所有活动。我们本可以使用JPA的`@ManyToOne`或`@OneToMany`注解将`ActivitiyJpaEntity`与`AccountJpaEntity`连接起来，以标记它们之间的关系，但我们选择现在不这样做，因为这会给数据库查询带来副作用。实际上，在这个阶段，使用比JPA更简单的对象关系映射器来实现持久化适配器可能更容易，但我们仍然会使用它，因为我们认为我们可能在将来需要它。[2](#footnote-024)
- en: '[2](#footnote-024-backlink). Java Persistence API: does that sound familiar
    to you? You choose JPA as an OR mapper because it’s the thing people use for this
    problem. A couple of months into development, you curse eager and lazy loading
    and the caching features, wishing for something simpler. JPA is a great tool,
    but for many problems, simpler solutions may be, well, simpler. Take a look at
    Spring Data JDBC or jOOQ as an alternative.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-024-backlink). Java Persistence API：这对你来说熟悉吗？你选择JPA作为对象关系映射器，因为它正是人们用来解决这个问题的工具。开发了几个月后，你开始诅咒懒加载和缓存功能，希望有更简单的方法。JPA是一个伟大的工具，但对于许多问题，更简单的解决方案可能确实更简单。看看Spring
    Data JDBC或jOOQ作为替代方案。'
- en: 'Next, we will use Spring Data to create repository interfaces that provide
    basic **C****reate**, **Read**, **Update**, and **Delete** (CRUD) functionality
    out of the box, as well as custom queries to load certain activities from the
    database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Spring Data创建仓库接口，这些接口提供开箱即用的基本**创建**、**读取**、**更新**和**删除**（CRUD）功能，以及自定义查询以从数据库中加载某些活动：
- en: '![](img/code-7.4.jpg)![](img/code-7.5.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-7.4.jpg)![](img/code-7.5.jpg)'
- en: Spring Boot will automatically find these repositories, and Spring Data will
    do its magic to provide an implementation behind the repository interface that
    will actually talk to the database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot将自动找到这些仓库，Spring Data将执行其魔法，为仓库接口提供实现，该接口实际上会与数据库通信。
- en: 'Having JPA entities and repositories in place, we can implement the persistence
    adapter that provides the persistence functionality to our application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了JPA实体和仓库之后，我们可以实现一个持久化适配器，为我们的应用程序提供持久化功能：
- en: '![](img/code-7.6a.jpg)![](img/code-7.6b.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-7.6a.jpg)![](img/code-7.6b.jpg)'
- en: The persistence adapter implements two ports that are needed by the application,
    `LoadAccountPort` and `UpdateAccountStatePort`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化适配器实现了应用程序需要的两个端口，`LoadAccountPort`和`UpdateAccountStatePort`。
- en: To load an account from the database, we load it from `AccountRepository` and
    then load the activities of this account for a certain time window through `ActivityRepository`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中加载一个账户，我们首先从`AccountRepository`中加载它，然后通过`ActivityRepository`加载这个账户在特定时间窗口内的活动。
- en: To create a valid `Account` domain entity, we also need the balance the account
    had before the start of this activity window, so we get the sum of all withdrawals
    and deposits of this account from the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个有效的`Account`域实体，我们还需要这个账户在活动窗口开始前的余额，所以我们从数据库中获取这个账户的所有提款和存款的总和。
- en: Finally, we map all this data to an `Account` domain entity and return it to
    the caller.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些数据映射到`Account`域实体，并将其返回给调用者。
- en: To update the state of an account, we iterate over all activities of the `Account`
    entity and check whether they have IDs. If they don’t, they are new activities,
    which we then persist through `ActivityRepository`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新账户的状态，我们遍历`Account`实体的所有活动，并检查它们是否有ID。如果没有，它们是新的活动，然后我们通过`ActivityRepository`将它们持久化。
- en: In the scenario described previously, we have a two-way mapping between the
    `Account` and `Activity` domain models and the `AccountJpaEntity` and `ActivityJpaEntity`
    database models. Why do we make the effort to map back and forth? Couldn’t we
    just move the JPA annotations to the `Account` and `Activity` classes and directly
    store them as entities in the database?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前描述的场景中，我们在`Account`和`Activity`域模型与`AccountJpaEntity`和`ActivityJpaEntity`数据库模型之间建立了双向映射。我们为什么还要做这种来回映射的努力？我们为什么不直接将JPA注解移动到`Account`和`Activity`类中，并将它们直接作为实体存储在数据库中呢？
- en: Such a *no-mapping* strategy may be a valid choice, as we’ll see in [*Chapter
    9*](B19916_09.xhtml#_idTextAnchor081), *Mapping between Boundaries*, when we talk
    about mapping strategies. However, JPA then forces us to make compromises in the
    domain model. For instance, JPA requires entities to have a no-args constructor.
    Alternatively, it might be that in the persistence layer, a “many-to-one” relationship
    makes sense from a performance point of view, but in the domain model, we want
    this relationship to be the other way around.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*无映射*策略可能是一个有效的选择，正如我们将在[*第9章*](B19916_09.xhtml#_idTextAnchor081)中看到的，*边界之间的映射*，当我们讨论映射策略时。然而，JPA随后迫使我们对领域模型做出妥协。例如，JPA要求实体有一个无参构造函数。或者，在持久化层中，从性能角度来看，“多对一”关系可能是有意义的，但在领域模型中，我们希望这种关系是相反的。
- en: So, if we want to create a rich domain model without making compromises to the
    persistence layer, we’ll have to map between the domain model and the persistence
    model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想创建一个不向持久化层做出妥协的丰富领域模型，我们就必须在领域模型和持久化模型之间进行映射。
- en: What about database transactions?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，数据库事务怎么办呢？
- en: We have not touched on the topic of database transactions yet. Where do we put
    our transaction boundaries?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及到数据库事务的话题。我们的事务边界在哪里？
- en: A transaction should span all write operations to the database that are performed
    within a certain use case, ensuring that all those operations can be rolled back
    together if one of them fails.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事务应该跨越在某个用例中执行的所有数据库写操作，确保如果其中一个操作失败，所有这些操作都可以一起回滚。
- en: Since the persistence adapter doesn’t know which other database operations are
    part of the same use case, it cannot decide when to open and close a transaction.
    We have to delegate this responsibility to the services that orchestrate the calls
    to the persistence adapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持久化适配器不知道哪些其他数据库操作是同一用例的一部分，它不能决定何时打开和关闭事务。我们必须将这项责任委托给协调对持久化适配器调用服务的服务。
- en: 'The easiest way to do this with Java and Spring is to add the `@Transactional`
    annotation to the domain service classes so that Spring will wrap all public methods
    with a transaction:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Spring中，最简单的方法是将`@Transactional`注解添加到领域服务类中，这样Spring就会将所有公共方法包装在一个事务中：
- en: '![](img/code-7.7.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code-7.7.jpg)'
- en: But doesn’t the `@Transactional` annotation introduce a dependency on a framework
    that we don’t want to have in our precious domain code? Well, yes, we have a dependency
    on the annotation, but we get transaction handling for that dependency! We wouldn’t
    want to build our own transaction mechanism just for the code to stay “pure.”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`@Transactional`注解不是引入了我们不想在我们的宝贵领域代码中拥有的框架的依赖吗？嗯，是的，我们对注解有依赖，但我们也为此获得了事务处理！我们不想为了保持代码“纯净”而构建自己的事务机制。
- en: How does this help me build maintainable software?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Building a persistence adapter that acts as a plugin to the domain code frees
    the domain code from persistence details so that we can build a rich domain model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个作为领域代码插件的持久化适配器，可以将领域代码从持久化细节中解放出来，从而我们可以构建一个丰富的领域模型。
- en: Using narrow port interfaces, we’re flexible to implement one port in one way
    and another port in another way, perhaps even with a different persistence technology,
    without the application noticing. We can even switch out the complete persistence
    layer, as long as the port contracts are obeyed.[3](#footnote-023)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用窄端口接口，我们可以灵活地以某种方式实现一个端口，以另一种方式实现另一个端口，甚至可能使用不同的持久化技术，而应用程序不会注意到。我们甚至可以替换整个持久化层，只要遵守端口合约。[3](#footnote-023)
- en: '[3](#footnote-023-backlink). Switching out the persistence layer: while I have
    seen it happen a few times (and for good reasons), the probability of having to
    switch out the whole persistence layer is usually rather low. Even then, having
    dedicated persistence ports is still worthwhile, because it increases testability.
    We can easily implement an in-memory persistence adapter to be used in tests,
    for example.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-023-backlink). 替换持久化层：虽然我见过几次这种情况（并且有很好的理由），但需要替换整个持久化层的概率通常相当低。即便如此，拥有专门的持久化端口仍然值得，因为它增加了可测试性。例如，我们可以轻松实现一个内存中的持久化适配器，用于测试。'
- en: Now that we’ve built a domain model and some adapters, let’s take a look at
    how we can test that they’re really doing what we expect them to do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个领域模型和一些适配器，让我们看看我们如何测试它们是否真的在按照我们期望的方式工作。
