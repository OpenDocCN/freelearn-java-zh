- en: Part I. Module 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。模块1
- en: '**Spring Essentials**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Spring基础知识**'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Build mission-critical enterprise applications using Spring Framework and
    Aspect Oriented Programming*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*使用Spring框架和面向方面的编程构建关键任务的企业应用程序*'
- en: Chapter 1. Getting Started with Spring Core
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。开始使用Spring Core
- en: Spring Framework is the most trusted and widely used application development
    framework in Enterprise Java. Originally introduced as a simple and lightweight
    alternative for the complex J2EE, Spring has now grown to become a truly modern
    application development platform. Spring and its subprojects provide an excellent
    foundation for end-to-end application development, with features beyond even those
    provided by the latest Java EE, such as mobile development, social networking,
    and big data, besides traditional Java web, server-side, or even standalone applications.
    After more than a decade since its inception, Spring continues to inspire technologies
    and technologists across the globe.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架是企业Java中最受信任和广泛使用的应用程序开发框架。最初作为复杂J2EE的简单轻量级替代方案引入，Spring现在已经发展成为一个真正现代的应用程序开发平台。Spring及其子项目为端到端应用程序开发提供了出色的基础，具有甚至超过最新Java
    EE提供的功能，如移动开发、社交网络和大数据，除了传统的Java web、服务器端或独立应用程序。自诞生以来已经超过十年，Spring继续激发全球范围内的技术和技术人员。
- en: Although Spring simplifies Java development drastically, software developers
    and architects are still required to gain a thorough understanding of its core
    concepts and features in order to deduce the best use of the Spring family. The
    simplicity Spring offers to otherwise complex Java development is the result of
    smart abstractions that it provides in the form of excellent APIs and modules.
    Spring components relieve the developer of all the technical complexity and heavy
    lifting of common technical and infrastructure plumbing tasks. As the official
    Spring documentation says, Spring provides comprehensive infrastructure support
    so that you can focus on your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring极大地简化了Java开发，但软件开发人员和架构师仍需要深入了解其核心概念和特性，以便推断出Spring家族的最佳用法。Spring提供给复杂的Java开发带来的简单性是其提供的优秀API和模块形式的智能抽象的结果。Spring组件解除了开发人员对常见技术和基础设施管道任务的所有技术复杂性和繁重工作。正如官方Spring文档所说，Spring提供了全面的基础设施支持，以便您可以专注于您的应用程序。
- en: This book is an attempt to make your Spring learning even easier and a more
    enjoyable experience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书试图使您的Spring学习更加轻松和愉快。
- en: This chapter gives you a solid foundation of the core Spring Framework, guiding
    you through its core concepts, components, and modules accompanied by relevant
    sample code snippets that illustrate the best and most practical usage of each
    feature in order to solve your everyday programming problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了Spring框架核心的坚实基础，引导您了解其核心概念、组件和模块，并附有相关的示例代码片段，以说明每个功能的最佳和最实用的用法，以解决您的日常编程问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Spring landscape
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring的景观
- en: Setting up the development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Your first Spring application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个Spring应用程序
- en: Core concepts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心概念
- en: The IoC (Inversion of Control) container
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoC（控制反转）容器
- en: Beans in detail
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍bean
- en: Working with bean definition profiles
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用bean定义配置文件
- en: Handling resources
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理资源
- en: SpEL (Spring Expression Language)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpEL（Spring表达式语言）
- en: Aspect Oriented Programming
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: The Spring landscape
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring的景观
- en: Spring covers a wide variety of technological aspects handled by applications
    of different types, ranging from a simple standalone Java application up to the
    most complex, mission critical distributed enterprise systems you can imagine.
    Unlike most other open source or proprietary frameworks that focus on a specific
    technology concern such as Web, Messaging, or Remoting, Spring successfully covers
    almost all the technical aspects of business applications. In most cases, instead
    of reinventing solutions, Spring utilizes and integrates proven existing frameworks
    to achieve this end-to-end coverage. Spring is highly modular; hence, it noninvasively
    allows you to cherry-pick just the modules or features you require in order to
    become a one-stop shop for all your development needs on JVM.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring涵盖了由不同类型的应用程序处理的各种技术方面，从简单的独立Java应用程序到您可以想象的最复杂的、关键任务的分布式企业系统。与大多数其他开源或专有框架不同，它专注于特定技术关注点，如Web、消息传递或远程调用，Spring成功地涵盖了几乎所有业务应用程序的技术方面。在大多数情况下，Spring利用和集成了经过验证的现有框架，而不是重新发明解决方案，以实现端到端的覆盖。Spring高度模块化，因此，它非侵入性地允许您挑选您需要的模块或功能，以成为JVM上所有开发需求的一站式商店。
- en: 'The whole Spring Framework portfolio is organized into three major elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 整个Spring框架组合分为三个主要元素：
- en: Spring Framework
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架
- en: Spring Tool Suite
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring工具套件
- en: Spring subprojects
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring子项目
- en: Spring is constantly improving and becoming more and more modular with every
    new version so that you can use just the required modules.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring不断改进，并且随着每个新版本变得越来越模块化，以便您可以只使用所需的模块。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book is based on Spring version 4.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于Spring 4版本。
- en: The Spring Framework modules
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring框架模块
- en: 'The core Spring Framework provides basic infrastructure for Java development
    on top of its core **Inversion of Control** (**IoC**) container. The IoC container
    is an infrastructure that provides **Dependency Injection** (**DI**) for applications.
    Both the concepts of Dependency Injection and IoC containers are explained in
    detail later in this chapter. The core Spring Framework is divided into the following
    modules, providing a range of services:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 核心Spring框架为Java开发提供了基本的基础设施，构建在其核心的**控制反转**（**IoC**）容器之上。IoC容器是为应用程序提供**依赖注入**（**DI**）的基础设施。依赖注入和IoC容器的概念将在本章后面详细解释。核心Spring框架分为以下模块，提供一系列服务：
- en: '| Module | Summary |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Core container | Provides the IoC and Dependency Injection features. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 核心容器 | 提供IoC和依赖注入功能。 |'
- en: '| AOP and instrumentation | Provides AOP Alliance compliant features for weaving
    cross-cutting concerns in Spring applications. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| AOP和仪器 | 为Spring应用程序中的横切关注点提供符合AOP Alliance标准的特性。 |'
- en: '| Messaging | Provides messaging abstraction over the Spring Integration project
    for messaging-based applications. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 消息 | 为基于消息的应用程序提供了Spring Integration项目上的消息抽象。 |'
- en: '| Data access/integration | The data-access/integration layer consists of JDBC,
    ORM, OXM, JMS, and transaction modules. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 数据访问/集成 | 数据访问/集成层包括JDBC、ORM、OXM、JMS和事务模块。 |'
- en: '| Web | Web technology abstraction over Spring MVC, web socket, and portlet
    APIs. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Web | Spring MVC、web socket和portlet API上的Web技术抽象。 |'
- en: '| Test | Unit testing and integration testing support with JUnit and TestNG
    frameworks. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 使用JUnit和TestNG框架支持单元测试和集成测试。 |'
- en: Spring Tool Suite (STS)
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring工具套件（STS）
- en: STS is an Eclipse-based **IDE** (short for **Integrated Development Environment**)
    for Spring development. You can download the pre-bundled STS from [http://spring.io/tools/sts/all](http://spring.io/tools/sts/all)
    or update your existing Eclipse installation from the update site found at the
    same location. STS provides various high-productivity features for Spring development.
    In fact, a Java developer can use any IDE of their choice. Almost all the Java
    IDEs support Spring development, and most of them have got plugins available for
    Spring.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: STS是基于Eclipse的Spring开发**IDE**（**集成开发环境**）。你可以从[http://spring.io/tools/sts/all](http://spring.io/tools/sts/all)下载预打包的STS，或者从同一位置的更新站点更新现有的Eclipse安装。STS为Spring开发提供了各种高生产力的功能。实际上，Java开发人员可以使用他们选择的任何IDE。几乎所有的Java
    IDE都支持Spring开发，并且大多数都有可用于Spring的插件。
- en: Spring subprojects
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring子项目
- en: Spring has many subprojects that solve various application infrastructure needs.
    From configuration to security, web apps to big data, productivity to **enterprise
    application integration** (**EAI**), whatever your technical pain point be, you
    will find a Spring project to help you in your application development. Spring
    projects are located at [http://spring.io/projects](http://spring.io/projects).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有许多子项目，解决各种应用基础设施需求。从配置到安全，从Web应用到大数据，从生产力到**企业应用集成**（**EAI**），无论你的技术痛点是什么，你都会发现一个Spring项目来帮助你进行应用开发。Spring项目位于[http://spring.io/projects](http://spring.io/projects)。
- en: Some notable projects you may find useful right away are Spring Data (JPA, Mongo,
    Redis, and so on), Spring Security, Spring Web Services, Spring Integration, Spring
    for Android, and Spring Boot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能立即发现有用的一些显著项目包括Spring Data（JPA、Mongo、Redis等）、Spring Security、Spring Web Services、Spring
    Integration、Spring for Android和Spring Boot。
- en: Design concepts behind Spring Framework
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架背后的设计概念
- en: 'The design of Spring Framework is motivated by a set of design patterns and
    best practices that have evolved in the industry to address the complexity of
    Object Oriented Programming, including:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架的设计受到一系列设计模式和最佳实践的启发，这些设计模式和框架已经在行业中发展，以解决面向对象编程的复杂性，包括：
- en: Simple, noninvasive, and lightweight **POJO** (**Plain Old Java Objects**) programming,
    without having a need for complex application servers
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单、非侵入式、轻量级的**POJO**（**Plain Old Java Objects**）编程，无需复杂的应用服务器
- en: Loosely-coupled dependencies, achieved by applying the concepts of *program
    to interfaces* and *composition over inheritance*, which are the underlying design
    principles of design patterns and frameworks
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用*面向接口编程*和*组合优于继承*的概念来实现松耦合的依赖关系，这些是设计模式和框架的基本设计原则
- en: Highly configurable systems composed of objects with externalized Dependency
    Injection
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由对象组成的高度可配置系统，具有外部化的依赖注入
- en: Templated abstractions to eliminate repetitive, boilerplate code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化的抽象以消除重复的样板代码
- en: Declarative weaving of cross-cutting aspects without polluting business components
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性地编织横切关注点，而不污染业务组件
- en: Spring implements established design principles and patterns into its elegant
    components and promotes their use as the default design approach in applications
    built using Spring. This noninvasive approach lets you engineer robust and highly
    maintainable systems composed of loosely coupled components and objects written
    in clean and modular code. Spring Framework components, templates, and libraries
    realize the goals and concepts explained earlier in the chapter, leaving you to
    focus on your core business logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring将已建立的设计原则和模式实现到其优雅的组件中，并促进它们作为Spring构建的应用程序的默认设计方法。这种非侵入式的方法让你能够构建松耦合的组件和以清晰、模块化的代码编写的对象组成的健壮且易于维护的系统。Spring框架的组件、模板和库实现了本章前面解释的目标和概念，让你可以专注于核心业务逻辑。
- en: Setting up the development environment
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'Spring projects are usually created as Java projects based in Maven, Gradle,
    or Ivy (which are build automation and dependency management tools). You can easily
    create a Maven-based Spring project using STS or Eclipse with Spring Tools support.
    You need to make sure your `pom.xml` (Maven configuration) file contains, at the
    minimum, a dependency to `spring-context`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring项目通常是基于Maven、Gradle或Ivy（这些是构建自动化和依赖管理工具）的Java项目创建的。你可以使用STS或带有Spring工具支持的Eclipse轻松创建基于Maven的Spring项目。你需要确保你的`pom.xml`（Maven配置）文件至少包含对`spring-context`的依赖：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, you should add further dependencies to modules such as `spring-tx`,
    `spring-data-jpa`, `spring-webmvc`, and `hibernate`, depending on your project
    type and requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该根据项目类型和要求向模块添加进一步的依赖，比如`spring-tx`、`spring-data-jpa`、`spring-webmvc`和`hibernate`。
- en: 'Unless you explicitly specify the repository location, your project works with
    Maven''s central repository. Alternatively, you can point to Spring''s official
    Maven repository (for example, for milestones and snapshots) by specifying it
    in your `pom.xml` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确指定存储库位置，否则你的项目将使用Maven的中央存储库。或者，你可以在`pom.xml`文件中指定Spring的官方Maven存储库（例如，用于里程碑和快照）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use the Spring `release`, `milestone`, and `snapshot` repositories as
    required.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要使用Spring的`release`、`milestone`和`snapshot`仓库。
- en: 'If you are using Gradle as your build system, you can declare your dependencies
    (typically in the `build.gradle` file) as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Gradle作为你的构建系统，你可以在`build.gradle`文件中声明你的依赖关系，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you prefer using the Ivy dependency management tool, then your Spring dependency
    configuration will look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用Ivy依赖管理工具，那么你的Spring依赖配置将如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Your first Spring application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Spring应用程序
- en: 'Let''s start with a very simple Spring application now. This application simply
    greets the user with a welcome message. Technically, it demonstrates how you configure
    a Spring `ApplicationContext` (IoC container) with just a single bean in it and
    invoke that bean method in your application. The application has four artifacts
    in it (besides the project build file, of course):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从一个非常简单的Spring应用程序开始。这个应用程序只是用欢迎消息向用户打招呼。从技术上讲，它演示了如何配置一个Spring `ApplicationContext`（IoC容器），其中只有一个bean，并在应用程序中调用该bean的方法。该应用程序有四个部分（当然还有项目构建文件）：
- en: '`GreetingService.java`: A Java interface—just a single method'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GreetingService.java`：一个Java接口—只有一个方法'
- en: '`GreetingServiceImpl.java`: A simple implementation of `GreetingService`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GreetingServiceImpl.java`：`GreetingService`的简单实现'
- en: '`Application.java`: Your application with a `main` method'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.java`：带有`main`方法的应用程序'
- en: '`application-context.xml`: The Spring configuration file of your application'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-context.xml`：您的应用程序的Spring配置文件'
- en: 'The following are the service components of your application. The service implementation
    just prints a greeting message to the logger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你的应用程序的服务组件。服务实现只是向日志记录器打印一个问候消息：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s take a look at the `application-context.xml` file, which is your
    Spring configuration file, where you register `GreetingService` as a Spring bean
    in the following listing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`application-context.xml`文件，这是你的Spring配置文件，在这里你可以在下面的清单中注册`GreetingService`作为Spring
    bean：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you invoke the `GreetingService.greet()` method from your Spring application,
    as given in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以从你的Spring应用程序中调用`GreetingService.greet()`方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will explore and conquer the mighty Spring Framework right from this very
    simple and pretty much self-explanatory application. We will discuss and elaborate
    the concepts behind this application, and more, in the following sections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个非常简单且相当自解释的应用程序开始，探索并征服强大的Spring框架。我们将在接下来的章节中讨论和详细说明这个应用程序背后的概念，以及更多内容。
- en: Inversion of Control explained
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制反转解释
- en: IoC is a design principle that decouples objects of an object-oriented program
    from their dependencies (collaborators), that is, the objects they work with.
    Usually, this decoupling is achieved by externalizing the responsibility of object
    creation and Dependency Injection to an external component, such as an IoC container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IoC是一种设计原则，它将面向对象程序的对象与它们的依赖关系（协作者）解耦，也就是说，它们所使用的对象。通常，这种解耦是通过将对象创建和依赖注入的责任外部化到外部组件（如IoC容器）来实现的。
- en: This concept is often compared to the Hollywood principle, "Don't call us, we
    will call you." In the programming world, it recommends the main program (or a
    component) not to instantiate its dependencies by itself but let an assembler
    do that job.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念经常被比作好莱坞原则，“不要打电话给我们，我们会打电话给你。”在编程世界中，它建议主程序（或组件）不要自己实例化它的依赖关系，而是让一个组装器来完成这项工作。
- en: This immediately decouples the program from the many problems caused by tightly
    coupled dependencies and relieves the programmer to let them quickly develop their
    code using abstract dependencies (*program to interfaces*). Later, at runtime,
    an external entity, such as an IoC container, resolves their concentrate implementations
    specified somewhere and injects them at runtime.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即将程序与紧密耦合的依赖关系造成的许多问题解耦，并让程序员能够快速使用抽象依赖关系（*按接口编程*）开发他们的代码。稍后，在运行时，外部实体，如IoC容器，解析它们在某处指定的具体实现，并在运行时注入它们。
- en: You can see this concept implemented in the example we just saw. Your main program
    (`Application.java`) is not instantiating the `GreetingService` dependency; it
    just asks the `ApplicationContext` (IoC container) to return an instance. While
    writing `Application.java`, the developer doesn't need to think about how the
    `GreetingService` interface is actually implemented. The Spring `ApplicationContext`
    takes care of object creation and injects any other functionality transparently,
    keeping the application code clean.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们刚刚看到的示例中看到这个概念的实现。你的主程序（`Application.java`）不是实例化`GreetingService`依赖关系；它只是请求`ApplicationContext`（IoC容器）返回一个实例。在编写`Application.java`时，开发人员不需要考虑`GreetingService`接口实际上是如何实现的。Spring
    `ApplicationContext`负责对象的创建，并在运行时透明地注入任何其他功能，保持应用程序代码的清晰。
- en: Objects managed by an IoC container do not control the creation and resolution
    of their dependencies by themselves; rather, that control is inverted by moving
    it away to the container itself; hence the term "Inversion of Control".
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由IoC容器管理的对象不会自己控制它们的依赖关系的创建和解析；相反，这种控制被转移给了容器本身；因此有了“控制反转”的术语。
- en: The IoC container assembles the components of the application as specified in
    the configuration. It handles the life cycles of the managed objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IoC容器根据配置组装应用程序的组件。它处理受管对象的生命周期。
- en: Dependency Injection
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Dependency Injection is a specific form of Inversion of Control. It is a more
    formalized design pattern, whereby dependencies of an object are injected by an
    assembler. DI is generally performed in three major styles: constructor injection,
    property (setter) injection, or, sometimes, interface injection. IoC and DI are
    often used interchangeably.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是控制反转的一种特定形式。它是一种更加正式的设计模式，对象的依赖关系是由组装器注入的。DI通常以三种主要风格进行：构造函数注入、属性（setter）注入，或者有时接口注入。IoC和DI经常可以互换使用。
- en: DI offers several benefits, including effective decoupling of dependencies,
    cleaner code, and increased testability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DI提供了几个好处，包括有效解耦依赖关系、更清晰的代码和增强的可测试性。
- en: The Spring IoC container
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring IoC容器
- en: 'The core Spring modules, `spring-core`, `spring-beans`, `spring-context`, `spring-context-support`,
    and `spring-expression`, together make up the core container. The Spring IoC container
    is designed as an implementation of the following interfaces:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的核心模块，`spring-core`、`spring-beans`、`spring-context`、`spring-context-support`和`spring-expression`，共同组成了核心容器。Spring
    IoC容器被设计为以下接口的实现：
- en: '`org.springframework.beans.factory.BeanFactory`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.beans.factory.BeanFactory`'
- en: '`org.springframework.context.ApplicationContext`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.context.ApplicationContext`'
- en: The `BeanFactory` interface provides the configuration framework and basic functionality,
    while `ApplicationContext`, an extension of `BeanFactory`, adds more enterprise-specific
    functionality, such as easier integration with Spring's AOP features, message
    resource handling (for internationalization), and event publication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanFactory`接口提供了配置框架和基本功能，而`ApplicationContext`作为`BeanFactory`的扩展，添加了更多的企业特定功能，例如更容易集成Spring的AOP功能、消息资源处理（用于国际化）和事件发布。'
- en: 'Spring provides several concrete implementations of `ApplicationContext` out
    of the box for various contexts. The following table lists the most popular ones
    among them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为各种上下文提供了几种`ApplicationContext`的具体实现。以下表列出了其中最受欢迎的几种：
- en: '| Application context | Typical application type |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 应用上下文 | 典型的应用程序类型 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ClassPathXmlApplicationContext` | Standalone |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `ClassPathXmlApplicationContext` | 独立 |'
- en: '| `AnnotationConfigApplicationContext` | Standalone |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `AnnotationConfigApplicationContext` | 独立 |'
- en: '| `FileSystemXmlApplicationContext` | Standalone |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemXmlApplicationContext` | 独立 |'
- en: '| `GenericWebApplicationContext` | Web |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `GenericWebApplicationContext` | Web |'
- en: '| `XmlWebApplicationContext` | Web |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `XmlWebApplicationContext` | Web |'
- en: '| `XmlPortletApplicationContext` | Web portlet |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `XmlPortletApplicationContext` | Web portlet |'
- en: In Spring, objects managed by the IoC container are called **beans**. The IoC
    container handles the assembly and lifecycles of Spring beans. Beans are defined
    in the configuration metadata consumed by the container, which instantiates and
    assembles them in order to compose your application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，由IoC容器管理的对象称为**bean**。IoC容器处理Spring bean的组装和生命周期。Bean在容器消耗的配置元数据中定义，容器实例化和组装它们以组成您的应用程序。
- en: Configuration metadata
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置元数据
- en: 'Spring supports three forms of configuration metadata to configure your beans:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持三种形式的配置元数据来配置您的bean：
- en: XML-based configuration metadata
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的配置元数据
- en: Annotation-based configuration metadata
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的配置元数据
- en: Java-based configuration metadata
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java的配置元数据
- en: The example code listing you saw earlier used XML-based configuration metadata.
    You can always mix and match different forms of metadata in a single application.
    For example, you may define the primary metadata to be a root XML file that combines
    a set of annotation-based metadata that in turn defines beans from different layers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您在之前看到的示例代码清单使用了基于XML的配置元数据。您可以在单个应用程序中随时混合和匹配不同形式的元数据。例如，您可以定义主要元数据为根XML文件，该文件组合了一组基于注解的元数据，这些元数据反过来定义了来自不同层的bean。
- en: XML-based configuration metadata
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于XML的配置元数据
- en: The `application-context.xml` file we saw in the previous Spring application
    sample is a very minimal example for XML-based configuration metadata. Beans are
    configured as `<bean/>` elements inside a top-level `<beans>` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Spring应用程序示例中看到的`application-context.xml`文件是基于XML的配置元数据的一个非常简单的示例。Bean被配置为顶级`<beans>`元素内的`<bean/>`元素。
- en: Classes representing the service layer (core business logic, also known as **Service**
    classes), **Data Access Objects** (**DAOs**), managed web backing beans (such
    as Struts action instances and JSF managed beans), infrastructure objects (such
    as Hibernate session factories and JMS queues), and so forth, are excellent candidates
    for Spring beans. Fine-grained domain objects are not generally configured as
    Spring beans, because it is usually the responsibility of DAOs and the business
    logic to create and load domain objects—Hibernate entities are typical examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代表服务层（核心业务逻辑，也称为**Service**类）、数据访问对象（**DAOs**）、管理的网络后备bean（如Struts操作实例和JSF管理的bean）、基础设施对象（如Hibernate会话工厂和JMS队列）等等，都是Spring
    bean的绝佳候选对象。细粒度的领域对象通常不被配置为Spring bean，因为通常是DAO和业务逻辑的责任来创建和加载领域对象——Hibernate实体是典型的例子。
- en: 'You can create a consolidated (root) `ApplicationContext` XML file that imports
    other XML files representing various layers of the application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个合并（根）`ApplicationContext` XML文件，导入表示应用程序各层的其他XML文件：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Annotation-based configuration metadata
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于注解的配置元数据
- en: This method relies on bytecode metadata to wire up components instead of XML-based
    angle bracket declarations. Configuration of a bean is defined at the source level
    of the bean itself, in the form of annotations at class, field, or method levels.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于字节码元数据来连接组件，而不是基于XML的尖括号声明。Bean的配置是在bean本身的源级别上定义的，以类、字段或方法级别的注解形式。
- en: 'Let''s take a look at the simplest Spring bean configured by source-level annotation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个通过源级别注解配置的最简单的Spring bean：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is just an annotated version of the same `GreetingServiceImpl` shown in
    the *Your first Spring application* section, where it was configured in the `application-context.xml`
    file purely in XML form. In this preceding listing, the annotation `@Component`
    makes it a Spring bean. Now, it doesn''t require to be defined in XML, but you
    should instruct your `ApplicationContext` to consider annotations, as given in
    the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是与*您的第一个Spring应用程序*部分中显示的相同的`GreetingServiceImpl`的带注释版本，在那里它纯粹以XML形式在`application-context.xml`文件中配置。在前面的清单中，注解`@Component`使其成为Spring
    bean。现在，它不需要在XML中定义，但您应该指示您的`ApplicationContext`考虑注解，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code snippet in your `application-context.xml` file forces `ApplicationContext`
    to scan the entire application, including all its dependencies—even inside JAR
    files—for components annotated as Spring beans of various stereotypes, such as
    `@Component`, `@Service`, `@Repository`, and `@Controller`. In addition to component
    scanning, the `ApplicationContext` looks for all the annotations in that bean
    at the class, property, constructor, and method levels (including setter methods)
    in order to inject dependencies and other behaviors into your beans at startup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`application-context.xml`文件中的此代码片段会强制`ApplicationContext`扫描整个应用程序，包括其所有依赖项，甚至包括JAR文件中的组件，这些组件被注释为Spring
    bean的各种原型，例如`@Component`，`@Service`，`@Repository`和`@Controller`。除了组件扫描，`ApplicationContext`还会查找该bean中的所有注释，包括类、属性、构造函数和方法级别（包括setter方法），以便在启动时将依赖项和其他行为注入到您的bean中。
- en: Beware, component scanning can be time consuming if you provide a broader package
    name to the `base-package` attribute; it is advised to provide more specific package
    names to scan (for example, a set of comma-separated package names) so that you
    have more control. You can narrow down your component scanning even further using
    `<context:include-filter/>` and `<context:exclude-filter/>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您为`base-package`属性提供了更广泛的包名称，组件扫描可能会耗费时间；建议提供更具体的包名称进行扫描（例如，一组逗号分隔的包名称），以便更好地控制。您甚至可以使用`<context:include-filter/>`和`<context:exclude-filter/>`进一步缩小组件扫描的范围。
- en: Another simple instruction to enable annotation configuration is `<context:annotation-config/>`.
    It simply looks for annotations on beans registered in the application context
    and will not detect the components, whereas if you use `<context:component-scan/>`,
    it handles both component scanning and other annotations, which will be covered
    later in this chapter, so you do not need to explicitly declare `<context:annotation-config/>`.
    So, the best method for annotation-based configuration is to use `<context:annotation-config/>`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 启用注释配置的另一个简单指令是`<context:annotation-config/>`。它只会查找应用程序上下文中注册的bean上的注释，不会检测组件，而如果您使用`<context:component-scan/>`，它会处理组件扫描和其他注释，这将在本章后面进行介绍，因此您不需要显式声明`<context:annotation-config/>`。因此，基于注释的配置的最佳方法是使用`<context:annotation-config/>`。
- en: XML-based versus annotation-based configuration
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于XML与基于注释的配置
- en: XML-based configuration has some advantages over its annotation-based counterpart.
    The biggest one is that all your bean definitions are in one place and not scattered
    in many classes or even JAR dependencies. XML allows you to split your metadata
    files and then combine them using `<import/>`. Using XML, you can configure any
    class, including third-party ones such as Spring beans, and inject dependencies
    and other services into it, which is impossible in the case of annotation. Also,
    you can define the same class as multiple different beans, each with a different
    name, dependencies, configuration, and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的配置与基于注释的配置相比具有一些优势。最大的优势是所有bean定义都在一个地方，而不是分散在许多类甚至JAR依赖项中。XML允许您拆分元数据文件，然后使用`<import/>`将它们组合起来。使用XML，您可以配置任何类，包括Spring
    bean等第三方类，并将依赖项和其他服务注入其中，这在注释的情况下是不可能的。此外，您可以将同一类定义为多个不同的bean，每个bean具有不同的名称、依赖项、配置等。
- en: Annotation-based metadata too has some advantages over XML configuration. It
    is more concise and much easier to develop and maintain, as your annotation and
    DI are right inside your source code. All information about a class is in one
    place.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注释的元数据也比XML配置具有一些优势。它更简洁，更容易开发和维护，因为您的注释和DI就在源代码中。关于类的所有信息都在一个地方。
- en: For bigger applications, the best option would be a mixed approach where the
    more reusable beans (libraries shared between multiple projects) and third-party
    components are configured in XML and those with a smaller scope are annotated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的应用程序，最佳选择是混合方法，其中更可重用的bean（在多个项目之间共享的库）和第三方组件在XML中进行配置，而范围较小的bean则进行注释。
- en: Component stereotype annotations
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件原型注释
- en: 'Spring provides further component stereotypes for beans that represent various
    roles. The primary stereotype is `@Component`, and all the others are its specializations
    for more specific use cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为代表各种角色的bean提供了更多的组件原型。主要的原型是`@Component`，其他所有原型都是其更具体用例的特殊化：
- en: '| Stereotype | Description |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 原型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Component` | A generic type for all Spring-managed components (beans).
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `@Component` | 所有Spring管理的组件（bean）的通用类型。 |'
- en: '| `@Service` | Marker meta-annotation for service layer components. Currently,
    Spring treats this the same as `@Component`, with no special function. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `@Service` | 服务层组件的标记元注释。目前，Spring将其视为`@Component`，没有特殊功能。 |'
- en: '| `@Repository` | Used as DAOs in your persistence layer. Spring Data libraries
    provide additional functionality. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `@Repository` | 用作持久化层中的DAO。Spring Data库提供了额外的功能。 |'
- en: '| `@Controller` | Handles Web MVC endpoints in order to process HTTP requests
    mapped to specific URLs. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `@Controller` | 处理Web MVC端点，以处理映射到特定URL的HTTP请求。 |'
- en: '| `@RestController` | A specialized controller for RESTful web services, part
    of Web MVC. It is a meta-annotation that combines `@Controller` and `@ResponseBody`.
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `@RestController` | 用于RESTful Web服务的专用控制器，属于Web MVC的一部分。它是一个元注释，结合了`@Controller`和`@ResponseBody`。
    |'
- en: Custom stereotypes can be created by defining meta-annotations from scratch
    or combining existing annotations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从头开始定义元注释或组合现有注释来创建自定义原型。
- en: Java-based configuration metadata
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Java的配置元数据
- en: 'Starting with Spring 3.0, you can configure Spring metadata purely inside Java
    classes, completely avoiding any XML configuration while enhancing annotation-based
    metadata. You annotate any Java class with `@Configuration` annotation at the
    class level and have methods annotated as `@Configuration` annotation on a factory
    method that instantiates an `@Component` annotation, or any other specialized
    bean, to define your application context. Let''s see a simple example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring 3.0开始，您可以纯粹在Java类中配置Spring元数据，完全避免任何XML配置，同时增强基于注解的元数据。您可以在任何Java类上用`@Configuration`注解进行注解，并在工厂方法上用`@Configuration`注解进行注解，该工厂方法实例化`@Component`注解或任何其他专门的bean来定义应用程序上下文。让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In `SpringJavaConfigurator.java`, the Java configuration class configures the
    Spring beans, replacing the `application-context.xml` file. Your Spring application
    can directly depend on this `Configuration` class for loading `ApplicationContext`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpringJavaConfigurator.java`中，Java配置类配置Spring bean，替换了`application-context.xml`文件。您的Spring应用程序可以直接依赖于这个`Configuration`类来加载`ApplicationContext`。
- en: 'Typically, you use an `AnnotationConfigApplication` instance for instantiating
    your application context:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您使用`AnnotationConfigApplication`实例来实例化应用程序上下文：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When `@Configuration` classes are provided as the constructor argument, the
    `@Configuration` class itself is registered as a bean definition and so are all
    declared `@Bean` methods within the class. Spring will scan for the entire project
    and its dependencies for `@Component` or its specializations (the other stereotypes
    listed previously), matching the argument values provided in `@ComponentScan(basePackages
    = "…")` with all other relevant annotations and building the application context.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@Configuration`类作为构造函数参数提供时，`@Configuration`类本身将被注册为bean定义，类中声明的所有`@Bean`方法也将被注册为bean定义。Spring将扫描整个项目及其依赖项，寻找`@Component`或其特殊化（之前列出的其他原型），将`@ComponentScan(basePackages
    = "…")`中提供的参数值与所有其他相关注解进行匹配，并构建应用程序上下文。
- en: The advantage of JavaConfig metadata is that you have programmatic control over
    Spring configuration while separating out the entire DI and bean configuration
    into a separate Java class. Using JavaConfig, you eliminate the complexity of
    managing many XML files. You detect any configuration issues during development
    at the earliest, as JavaConfig fails during compilation itself, while in the case
    of XML, you will know about the configuration issues only on application startup.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JavaConfig元数据的优势在于您可以对Spring配置进行编程控制，同时将整个DI和bean配置分离到单独的Java类中。使用JavaConfig，您可以消除管理许多XML文件的复杂性。您可以在开发过程中尽早检测到任何配置问题，因为JavaConfig在编译时就会失败，而在XML的情况下，您只能在应用程序启动时了解配置问题。
- en: JSR 330 standard annotations
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSR 330标准注解
- en: Besides Spring-specific annotations, Spring supports JSR 330 standard annotations
    for DI, starting from Spring 3.0\. You just need to include `javax.inject` artifacts
    in your Maven or Gradle configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Spring特定的注解外，Spring还支持JSR 330标准注解用于DI，从Spring 3.0开始。您只需要在Maven或Gradle配置中包含`javax.inject`构件。
- en: 'JSR 330 standard annotations have the following equivalents in Spring:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 330标准注解在Spring中有以下等价物：
- en: '| Spring | JSR-330 (javax.inject.*) | Target level / Usage |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Spring | JSR-330 (javax.inject.*) | 目标级别/用法 |'
- en: '| --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@Component` | `@Named` | Type (class) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `@Component` | `@Named` | 类型（类） |'
- en: '| `@Autowired` | `@Inject` | Property and setter methods |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `@Autowired` | `@Inject` | 属性和setter方法 |'
- en: '| `@Qualifier` | `@Named` | Type, property and setter methods |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `@Qualifier` | `@Named` | 类型、属性和setter方法 |'
- en: '| `@Scope("singleton")` | `@Singleton` | Meta-annotation for bean declarations
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `@Scope("singleton")` | `@Singleton` | 用于bean声明的元注解 |'
- en: While the default scope of Spring beans is `singleton`, the JSR 330 default
    scope is like Spring's `prototype`. However, for consistency, Spring treats JSR
    330 annotated beans inside Spring as `singleton`, unless declared prototype explicitly
    using `@Scope("..")`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring bean的默认作用域是`singleton`，但JSR 330的默认作用域类似于Spring的`prototype`。但是，为了保持一致，Spring将Spring中的JSR
    330注解的bean视为`singleton`，除非使用`@Scope("..")`显式声明为prototype。
- en: JSR 330 has no equivalents for some Spring-based DI annotations, such as `@Value`,
    `@Required`, and `@Lazy`. We will discuss more about bean scopes later in this
    chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 330没有一些基于Spring的DI注解的等价物，例如`@Value`，`@Required`和`@Lazy`。我们将在本章后面更多地讨论bean作用域。
- en: Beans in detail
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细的bean
- en: A Spring application is composed of a set of beans that perform functionality
    specific to your application layers and are managed by the IoC container. You
    define your beans with configuration metadata in the form of XML, annotation,
    or JavaConfig.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序由一组bean组成，这些bean执行特定于应用程序层的功能，并由IoC容器管理。您可以使用XML、注解或JavaConfig的配置元数据定义您的bean。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default scope of a Spring bean is `singleton`. This means that a single
    instance is shared between clients anywhere in the application. Beware of keeping
    state (class level data) in `singleton` classes, as a value set by one client
    will be visible to all others. The best use case for such `singleton` classes
    are stateless services.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean的默认作用域是`singleton`。这意味着单个实例在应用程序中的任何位置之间共享。要注意在`singleton`类中保持状态（类级数据），因为一个客户端设置的值将对所有其他客户端可见。这种`singleton`类的最佳用例是无状态服务。
- en: Beans are uniquely identified by an `id` attribute, any of the values supplied
    to the (comma, semicolon, or space separated) `name` attribute of the bean definition,
    or even as an `alias` definition. You can refer to a bean anywhere in the application
    with `id` or any of the names or aliases specified in the bean definition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Bean通过`id`属性唯一标识，也可以通过bean定义中提供的任何值（逗号、分号或空格分隔）的`name`属性，甚至作为`alias`定义。您可以在应用程序中的任何位置引用bean，使用`id`或在bean定义中指定的任何名称或别名。
- en: It's not necessary that you always provide an `id` or name to the bean. If one
    isn't provided, Spring will generate a unique bean name for it; however, if you
    want to refer to it with a name or an `id`, then you must provide one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是必须为bean提供`id`或名称。如果没有提供，Spring将为其生成一个唯一的bean名称；但是，如果您想要用名称或`id`引用它，那么您必须提供一个。
- en: Spring will try to autowire beans by type if `id` or name is not provided. This
    means that `ApplicationContext` will try to match the bean with the same type
    or implementation in case it is an interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`id`或名称，Spring将尝试按类型自动装配bean。这意味着`ApplicationContext`将尝试匹配具有相同类型或实现的bean，如果它是一个接口。
- en: You can refer to a bean by type if it is either the only bean registered of
    that type or marked as `@Primary` (`primary="true"` for XML). Generally, for nested
    bean definitions and autowire collaborators, you don't need to define a name unless
    you refer to it outside the definition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个bean是该类型的唯一注册bean，或者标记为`@Primary`（对于XML为`primary="true"`），则可以按类型引用该bean。通常，对于嵌套的bean定义和自动装配的协作者，除非您在定义之外引用它，否则不需要定义名称。
- en: 'You can alias a bean outside the bean definition using the `<alias/>` tag,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`<alias/>`标签在bean定义之外为bean创建别名，如下所示：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bean definition
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean定义
- en: 'A bean definition object that you define to describe a bean has the following
    metadata:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义的用于描述bean的bean定义对象具有以下元数据：
- en: '| Property | Description |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `class` | The fully qualified class name of the bean. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `class` | bean的完全限定类名。|'
- en: '| `id` | The unique identifier of the bean. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `id` | bean的唯一标识符。|'
- en: '| `name` | One or more unique names separated by commas, semicolons, or whitespace.
    Typically, `id` and name would be the same, and you supply either of these. Other
    names in the list become aliases. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 一个或多个由逗号、分号或空格分隔的唯一名称。通常，`id`和名称将是相同的，您可以提供其中一个。列表中的其他名称将成为别名。|'
- en: '| `parent` | The parent bean for inheriting configuration data from a parent
    bean definition. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `parent` | 从父bean定义继承配置数据的父bean。|'
- en: '| `scope` | This decides the scope of the objects. The default scope of a Spring
    bean is `singleton`. This means that a single instance is shared between calls.
    We will discuss more about bean scopes later. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 这决定了对象的范围。Spring bean的默认范围是`singleton`。这意味着在调用之间共享单个实例。我们将在后面讨论更多关于bean范围的内容。|'
- en: '| `constructor args` | Bean references or names for constructor-based DI. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `constructor args` | 用于基于构造函数的DI的bean引用或名称。|'
- en: '| `properties` | Values or references for setter-based DI. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `properties` | 用于基于setter的DI的值或引用。|'
- en: '| `autowire` mode | Instructs the bean whether or how to autowire relationships
    with collaborators. Autowiring will be discussed later. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `autowire`模式 | 指示bean是否以及如何自动装配与协作者的关系。自动装配将在后面讨论。|'
- en: '| `primary` | This indicates that the bean should be considered as the primary
    autowiring candidate in case of multiple matches being found. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `primary` | 这表示在发现多个匹配项时，bean应被视为主要的自动装配候选项。|'
- en: '| `depends-on` | This forces instantiation of dependent beans prior to this
    bean. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `depends-on` | 这会强制在此bean之前实例化依赖的bean。|'
- en: '| `lazy-init` | If true, this creates a bean instance when it is first requested.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `lazy-init` | 如果为true，则在首次请求时创建bean实例。|'
- en: '| `init-method` | Initialization callback method. This has no `args void` method
    and will be invoked post instance creation. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `init-method` | 初始化回调方法。这是一个没有`args void`方法，将在实例创建后调用的方法。|'
- en: '| `destroy-method` | Destruction callback method. This has no `args void` method
    and will be invoked before `destroy`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `destroy-method` | 销毁回调方法。这是一个没有`args void`方法，将在销毁之前调用的方法。|'
- en: '| `factory-method` | Static instance factory method on the bean itself, unless
    `factory-bean` is provided. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `factory-method` | bean本身上的静态实例工厂方法，除非提供了`factory-bean`。|'
- en: '| `factory-bean` | Another bean reference that is acting as an instance factory
    for this bean. Usually comes along with the `factory-method` property. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `factory-bean` | 作为此bean的实例工厂的另一个bean引用。通常与`factory-method`属性一起使用。|'
- en: 'Let''s take a look at a sample bean definition in XML form:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个XML形式的示例bean定义：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this sample `application-context` file, the bean, `xmlTaskService`, is autowired
    via a constructor, that is, dependencies are injected via a constructor. The first
    constructor argument refers to an existing bean definition, and the second one
    is an inline bean definition without an `id`. The bean has `init-method` and `destroy-method`
    pointed to its own methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的`application-context`文件中，bean `xmlTaskService`是通过构造函数进行自动装配的，也就是说，依赖项是通过构造函数注入的。第一个构造函数参数是指现有的bean定义，第二个是一个没有`id`的内联bean定义。该bean具有`init-method`和`destroy-method`指向其自己的方法。
- en: 'Now, let''s take a look at an annotated bean with slightly different features:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个带有稍微不同特性的注释bean：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `@Service` bean autowires its dependencies on its fields (properties) using
    an `@Autowired` annotation. Note the `@PostConstruct` and `@PreDestroy` annotations,
    the equivalents of `init-method` and `destroy-method` in the previous XML bean
    definition example. These are not Spring specific but are JSR 250 annotations.
    They work pretty well with Spring.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`@Service` bean在其字段（属性）上使用`@Autowired`注解自动装配其依赖项。请注意`@PostConstruct`和`@PreDestroy`注解，这是之前的XML
    bean定义示例中`init-method`和`destroy-method`的等价物。这些不是Spring特定的，而是JSR 250注解。它们与Spring非常配合。
- en: Instantiating beans
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化bean
- en: Bean definitions are recipes for instantiating bean instances. Depending on
    metadata attributes such as `scope`, `lazy`, and `depends-on`, Spring Framework
    decides when and how an instance is created. We will discuss it in detail later.
    Here, let's look at the "how" of instance creation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Bean定义是实例化bean实例的配方。根据`scope`、`lazy`和`depends-on`等元数据属性，Spring框架决定何时以及如何创建实例。我们将在后面详细讨论。在这里，让我们看一下实例创建的“如何”。
- en: With constructors
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: 'Any bean definition with or without constructor arguments but without a `factory-method`
    is instantiated via its own constructor, using the `new` operator:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有或不具有构造函数参数但没有`factory-method`的bean定义都是通过其自己的构造函数实例化，使用`new`运算符：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s see an annotated `@Component` with a default constructor-based instantiation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个带有默认基于构造函数实例化的注释`@Component`：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With a static factory-method
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有静态工厂方法
- en: 'A static method within the same class, marked as `factory-method`, will be
    invoked to create an instance in this case:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将调用同一类中标记为`factory-method`的静态方法来创建一个实例：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With Java configuration, you can use an `@Bean` annotation instead of factory
    methods:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java配置时，您可以使用`@Bean`注解而不是工厂方法：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With an instance factory-method
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实例工厂方法
- en: 'In this case, bean definition does not need a class attribute, but you specify
    the `factory-bean` attribute, which is another bean, with one of its non-static
    methods as `factory-method`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，bean定义不需要class属性，但您可以指定`factory-bean`属性，这是另一个bean，其中一个非静态方法作为`factory-method`：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Injecting bean dependencies
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入bean依赖
- en: The main purpose of an IoC container is to resolve the dependencies of objects
    (beans) before they are returned to the clients who called for an instance (say,
    using the `getBean` method). Spring does this job transparently based on the bean
    configuration. When the client receives the bean, all its dependencies are resolved
    unless specified as not required (`@Autowired(required = false)`), and it is ready
    to use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: IoC容器的主要目的是在将对象（bean）返回给调用实例的客户端之前解析对象（bean）的依赖关系。Spring根据bean配置透明地执行此操作。当客户端接收bean时，除非指定为不需要（`@Autowired(required
    = false)`），否则所有依赖项都已解析，并且可以立即使用。
- en: Spring supports two major variants of DI—constructor-based and setter-based
    DI—right out of the box.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持两种主要的DI变体 - 基于构造函数和基于setter的DI - 开箱即用。
- en: Constructor-based Dependency Injection
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: 'In constructor-based DI, dependencies to a bean are injected as constructor
    arguments. Basically, the container calls the defined constructor, passing the
    resolved values of the arguments. It is best practice to resolve mandatory dependencies
    via a constructor. Let''s look at an example of a simple POJO `@Service` class,
    a ready candidate for constructor-based DI:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于构造函数的DI中，将依赖项注入到bean作为构造函数参数。基本上，容器调用定义的构造函数，传递参数的解析值。最佳实践是通过构造函数解析强制依赖项。让我们看一个简单的POJO
    `@Service`类的示例，这是基于构造函数的DI的一个准备好的候选者：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s define this as a Spring bean in XML:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在XML中将其定义为Spring bean：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Spring container resolves dependencies via a constructor based on the argument's
    type. For the preceding example, you don't need to pass the index or type of the
    arguments, since they are of complex types.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器通过构造函数解析依赖项的类型。对于前面的示例，您不需要传递参数的索引或类型，因为它们是复杂类型。
- en: 'However, if your constructor has simple types, such as primitives (`int`, `long`,
    and `boolean`), primitive wrappers (`java.lang.Integer`, `Long`, and so on) or
    `String`, ambiguities of type and index may arise. In this case, you can explicitly
    specify the type and index of each argument to help the container match the arguments,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的构造函数具有简单类型，例如基本类型（`int`，`long`和`boolean`），基本包装类型（`java.lang.Integer`，`Long`等）或`String`，可能会出现类型和索引的歧义。在这种情况下，您可以显式指定每个参数的类型和索引，以帮助容器匹配参数，如下所示：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember, index numbers start from zero. The same applies to setter-based injection
    as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，索引编号从零开始。基于setter的注入也是如此。
- en: Setter-based Dependency Injection
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: 'The container calls the setter methods of your bean in the case of setter-based
    DI after the constructor (with or without `args`) is invoked. Let''s see how the
    bean definition for the previous `SystemSettings` would look if the dependencies
    were injected via setter methods, assuming the `SystemSettings` now has a `no-args`
    constructor:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数（带或不带`args`）被调用后，容器会调用您的bean的setter方法。让我们看看如果依赖项通过setter方法注入，假设`SystemSettings`现在有一个`no-args`构造函数，那么前面的`SystemSettings`的bean定义会是什么样子：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Spring validates the bean definitions at the startup of the `ApplicationContext`
    and fails with a proper message in case of a wrong configuration. The string values
    given to properties with built-in types such as `int`, `long`, `String`, and `boolean`
    are converted and injected automatically when the bean instances are created.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在`ApplicationContext`启动时验证bean定义，并在配置错误的情况下失败并提供适当的消息。给定给内置类型的属性的字符串值，例如`int`，`long`，`String`和`boolean`，在创建bean实例时会自动转换和注入。
- en: Constructor-based or setter-based DI – which is better?
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于构造函数或基于setter的DI - 哪种更好？
- en: 'Which of these DI methods is better purely depends on your scenario and some
    requirements. The following best practices may provide a guideline:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DI方法中哪种更好纯粹取决于您的场景和一些要求。以下最佳实践可能提供指导：
- en: Use constructor-based DI for mandatory dependencies so that your bean is ready
    to use when it is first called.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于强制依赖项，请使用基于构造函数的DI，以便在首次调用时准备好使用您的bean。
- en: When your constructor gets stuffed with a large number of arguments, it's the
    figurative bad code smell. It's time to break your bean into smaller units for
    maintainability.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的构造函数被填充了大量的参数时，这是一种比喻性的糟糕代码味道。是时候将您的bean分解成更小的单元以便于维护。
- en: Use setter-based DI only for optional dependencies or if you need to reinject
    dependencies later, perhaps using JMX.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在可选依赖项或需要稍后重新注入依赖项时使用基于setter的DI，也许使用JMX。
- en: Avoid circular dependencies that occur when a dependency (say, bean B) of your
    bean (bean A) directly or indirectly depends on the same bean again (bean A),
    and all beans involved use constructor-based DI. You may use setter-based DI here.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免循环依赖，当您的bean（bean A）的依赖项（例如，bean B）直接或间接地再次依赖于相同的bean（bean A），并且所有涉及的bean都使用基于构造函数的DI时。您可以在这里使用基于setter的DI。
- en: You can mix constructor-based and setter-based DI for the same bean, considering
    mandatory, optional, and circular dependencies.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以为同一个bean混合使用基于构造函数和基于setter的DI，考虑到强制、可选和循环依赖。
- en: In a typical Spring application, you can see dependencies injected using both
    approaches, but this depends on the scenario, considering the preceding guidelines.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Spring应用程序中，您可以看到使用两种方法注入依赖项，但这取决于情况，考虑到前面的准则。
- en: Cleaner bean definitions with namespace shortcuts
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间快捷方式使bean定义更清晰
- en: 'You can make your bean definitions cleaner and more expressive using `p:(property)`
    and `c:(constructor)` namespaces, as shown here. While the `p` namespace enables
    you to use the `<bean/>` element''s attributes instead of the nested `<property/>`
    elements in order to describe your property values (or collaborating bean refs),
    the `c` namespace allows you to declare the constructor `args` as the attributes
    of the `<bean/>` element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`p:(property)`和`c:(constructor)`命名空间使bean定义更清晰、更具表现力，如下所示。`p`命名空间使您能够使用`<bean/>`元素的属性来描述您的属性值（或协作bean引用），而不是嵌套的`<property/>`元素，而`c`命名空间允许您将构造函数`args`声明为`<bean/>`元素的属性：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The bean definitions in the preceding listing are cleaner but more expressive.
    Both `c:` and `p:` namespaces follow the same conventions. You need to declare
    both at the XML root element (`<beans/>`) before using them with the `<bean/>`
    elements. Note that you use the `-ref` suffix for bean references.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的bean定义更清晰，但更具表现力。`c:`和`p:`命名空间都遵循相同的约定。在使用`<bean/>`元素之前，您需要在XML根元素(`<beans/>`)中声明两者。请注意，您需要使用`-ref`后缀来引用bean。
- en: Wiring a List as a dependency
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将列表作为依赖项连接
- en: 'On occasion, we will need to inject static collections of data as bean dependencies.
    Spring provides a natural method to wire lists. See this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，我们需要将静态数据集注入为bean的依赖项。Spring提供了一种自然的方法来连接列表。看看这个例子：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding example wires a `java.util.List<String>` for simplicity. If your
    list contains a collection of beans, you can replace `<value>` with `<ref>` or
    `<bean>`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子简单地连接了一个`java.util.List<String>`。如果您的列表包含一组bean，您可以将`<value>`替换为`<ref>`或`<bean>`。
- en: Wiring a Map as a dependency
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Map作为依赖项连接
- en: 'You can inject `java.util.Map` instances too in a similar fashion. Look at
    this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以以类似的方式注入`java.util.Map`实例。看看这个例子：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can inject beans as values, replacing `<value>` with `<ref>` or `<bean>`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将bean注入为值，将`<value>`替换为`<ref>`或`<bean>`。
- en: Autowiring dependencies
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动装配依赖项
- en: 'Spring can autowire dependencies of your beans automatically by inspecting
    the bean definitions present in the `ApplicationContext` if you specify the autowire
    mode. In XML, you specify the `autowire` attribute of the `<bean/>` element. Alternatively,
    you can annotate a bean with `@Autowired` to autowire dependencies. Spring supports
    four autowiring modes: `no`, `byName`, `byType`, and `constructor`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Spring可以通过检查`ApplicationContext`中存在的bean定义来自动装配bean的依赖项，如果您指定了自动装配模式。在XML中，您可以指定`<bean/>`元素的`autowire`属性。或者，您可以使用`@Autowired`注解来自动装配依赖项。Spring支持四种自动装配模式：`no`、`byName`、`byType`和`constructor`。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default autowiring of Spring beans is `byType`. If you are autowiring an
    interface, Spring will try to find an implementation of that interface configured
    as a Spring bean. If there are multiple, Spring will look for the `primary` attribute
    of the configuration to resolve; if not found, it will fail, complaining about
    an ambiguous bean definition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean的默认自动装配是`byType`。如果您正在自动装配一个接口，Spring将尝试找到配置为Spring bean的该接口的实现。如果有多个，Spring将查找配置的`primary`属性来解决；如果找不到，它将失败，并抱怨模糊的bean定义。
- en: 'Here is an example of autowiring constructor arguments:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是自动装配构造函数参数的示例：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can autowire at the field level, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在字段级别进行自动装配，如下所示：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Autowiring can be fine-tuned with an `@Qualifier` annotation and required attribute:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装配可以通过`@Qualifier`注解和required属性进行微调：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can use `@Qualifier` at the constructor level too:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在构造函数级别使用`@Qualifier`：
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Bean scoping
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean范围
- en: 'When defining a bean with its dependencies and other configuration values,
    you can optionally specify the scope of a bean in the bean definition. The scope
    determines the life span of the bean. Spring comes up with six built-in scopes
    out of the box and supports the creation of custom scopes too. If not explicitly
    specified, a bean will assume the `singleton` scope, which is the default scope.
    The following table lists the built-in Spring scopes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个带有其依赖项和其他配置值的bean时，您可以选择在bean定义中指定bean的范围。范围决定了bean的生命周期。Spring提供了六种内置的范围，并支持创建自定义范围。如果没有明确指定，bean将假定为`singleton`范围，这是默认范围。以下表列出了内置的Spring范围：
- en: '| Scope | Description |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 描述 |'
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `singleton` | This ensures a single instance inside the container. This is
    the default scope. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `singleton` | 这确保容器内只有一个实例。这是默认范围。 |'
- en: '| `prototype` | A new instance is created for every request for the bean. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `prototype` | 每次请求bean时都会创建一个新实例。 |'
- en: '| `request` | Scopes an instance with the life cycle of every new HTTP request.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 具有每个新HTTP请求的生命周期。 |'
- en: '| `session` | Scopes with the life cycle of every new HTTP session. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `session` | 具有每个新HTTP会话的生命周期。 |'
- en: '| `globalSession` | Scopes with an HTTP session inside a portlet context. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `globalSession` | 在portlet环境中具有HTTP会话的范围。 |'
- en: '| `application` | Scopes with the life cycle of a `ServletContext`. It''s `singleton`
    for `ServletContext`. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `application` | 具有`ServletContext`的生命周期。对于`ServletContext`来说是`singleton`。
    |'
- en: While `singleton` and `prototype` work in all environments, request, session,
    and application work only in web environments. The `globalSession` scope is for
    portlet environments.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`singleton`和`prototype`在所有环境中都适用，但request、session和application只在web环境中适用。`globalSession`范围适用于portlet环境。
- en: 'In an XML bean definition, the scope is set via the `scope` attribute of the
    `<bean/>` element:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML bean定义中，范围是通过`<bean/>`元素的`scope`属性设置的：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can annotate the bean scope as a meta-annotation to `@Component` or its
    derivations, such as `@Service` and `@Bean`, as shown in the following listing:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将bean作用域注释为@Component或其派生类，例如@Service和@Bean，如下列表所示：
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Generally, service classes and Spring data repositories are declared as `singleton`,
    since they are built stateless according to best practice.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务类和Spring数据存储库被声明为“singleton”，因为它们根据最佳实践构建为无状态。
- en: Dependency Injection with scoped beans
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用作用域bean进行依赖注入
- en: 'Beans of different scopes can be wired up as collaborators in your configuration
    metadata. For example, if you have a session-scoped bean as a dependency to `singleton`
    and face an inconsistency problem, the first instance of the session-scoped bean
    will be shared between all users. This can be solved using a scoped proxy in place
    of the scoped bean:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不同作用域的bean可以在配置元数据中作为协作者进行连接。例如，如果您将会话作用域的bean作为“singleton”的依赖项，并且面临一致性问题，那么会话作用域的bean的第一个实例将在所有用户之间共享。这可以通过在作用域bean的位置使用作用域代理来解决：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Every time the scoped bean is injected, Spring creates a new AOP proxy around
    the bean so that the instance is picked up from the exact scope. The annotated
    version of the preceding listing would look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 每次注入作用域bean时，Spring都会在bean周围创建一个新的AOP代理，以便从确切的作用域中选择实例。前述列表的注释版本将如下所示：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating a custom scope
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义作用域
- en: 'At times, the scopes supplied by Spring are not sufficient for your specific
    needs. Spring allows you to create your own custom scope for your scenario. For
    example, if you want to keep some business process level information throughout
    its life, you will want to create a new process scope. The following steps will
    enable you to achieve this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Spring提供的作用域不足以满足您的特定需求。Spring允许您为您的场景创建自定义作用域。例如，如果您想在整个业务流程中保留一些信息，您将需要创建一个新的流程作用域。以下步骤将帮助您实现这一目标：
- en: Create a Java class extending `org.springframework.beans.factory.config.Scope`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`org.springframework.beans.factory.config.Scope`的Java类。
- en: Define it in your application context (XML or annotation) as a Spring bean.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上下文（XML或注释）中定义为Spring bean。
- en: Register the scope bean with your `ApplicationContext` either programmatically
    or in XML with `CustomScopeConfigurer`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CustomScopeConfigurer`在XML中以编程方式或注册作用域bean到您的`ApplicationContext`。
- en: Hooking to bean life cycles
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到bean生命周期
- en: Often, in enterprise application development, developers will want to plug in
    some extra functionality to be executed just after the construction and before
    the destruction of a business service. Spring provides multiple methods for interacting
    with such stages in the life cycle of a bean.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序开发中，开发人员通常希望在业务服务的构建之后和销毁之前执行一些额外的功能。Spring提供了多种与bean生命周期中这些阶段交互的方法。
- en: Implementing InitializingBean and DisposableBean
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现InitializingBean和DisposableBean
- en: 'The Spring IoC container invokes the callback methods `afterPropertiesSet()`
    of `org.springframework.beans.factory.InitializingBean` and `destroy()` of `org.springframework.beans.factory.DisposableBean`
    on any Spring bean and implements them:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Spring IoC容器在任何Spring bean上调用`org.springframework.beans.factory.InitializingBean`的`afterPropertiesSet()`和`org.springframework.beans.factory.DisposableBean`的`destroy()`回调方法并实现它们：
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Annotating @PostConstruct and @PreDestroy on @Components
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在@Component上注释@PostConstruct和@PreDestroy
- en: 'Spring supports JSR 250 `@PostConstruct` and `@PreDestroy` annotations on any
    Spring bean in an annotation-supported environment, as shown here. Spring encourages
    this approach over implementing Spring-specific interfaces, as given in the previous
    section:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持在注释支持的环境中的任何Spring bean上使用JSR 250 `@PostConstruct`和`@PreDestroy`注释，如下所示。Spring鼓励使用这种方法而不是实现Spring特定的接口，如前一节所述：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The init-method and destroy-method attributes of <bean/>
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <bean/>的init-method和destroy-method属性
- en: 'If you are using XML-only bean configuration metadata, then your best option
    is to declare `init-method` and `destroy-method` attributes on your `<bean/>`
    tags:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只使用XML bean配置元数据，则最佳选择是在<bean/>标签上声明`init-method`和`destroy-method`属性：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Container-level default-init-method and default-destroy-method
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器级别的默认init-method和default-destroy-method
- en: 'You can even set container-level default `init` and `destroy` methods so that
    you don''t need to set it for each bean. The container invokes these methods on
    beans only if they are present:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以设置容器级别的默认`init`和`destroy`方法，这样您就不需要为每个bean设置它。只有在bean存在时，容器才会调用这些方法：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Working with bean definition profiles
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bean定义配置文件
- en: For commercial projects, it is a common requirement to be able to maintain two
    or more environment-specific configurations and beans, activated selectively only
    in the corresponding environment. For example, objects such as data sources, e-mail
    servers, and security settings could be different for development, testing, and
    production environments. You would want to switch them declaratively without touching
    the application code, keeping it externally. Developers traditionally write complex
    scripts and property files with separate builds to do this job. Spring comes to
    your rescue here with environment abstraction using bean definition profiles and
    properties.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于商业项目，通常需要能够维护两个或更多特定于环境的配置和bean，只在相应的环境中选择性地激活。例如，数据源、电子邮件服务器和安全设置等对象可能在开发、测试和生产环境中不同。您希望在不触及应用程序代码的情况下以外部方式声明地切换它们。开发人员传统上会编写复杂的脚本和属性文件，使用单独的构建来完成这项工作。Spring在这里通过使用bean定义配置文件和属性的环境抽象来拯救您。
- en: Bean definition profiles are a mechanism by which application context is configured
    differently for different environments. You group bean definitions under named
    profiles in XML or using annotation and activate one or more profiles in each
    environment. You can set a default profile to be enabled if you do not specify
    one explicitly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Bean定义配置文件是一种通过该机制为不同环境配置应用程序上下文的方法。您可以在XML中或使用注释将bean定义分组到命名配置文件下，并在每个环境中激活一个或多个配置文件。如果您没有明确指定，可以设置默认配置文件以启用。
- en: 'Let''s take a look the following sample listing that configures data sources
    for development and production environments:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例列表，该列表配置了开发和生产环境的数据源：
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Practically, for production environments, externalizing this profile config
    in XML would be a better idea, where you allow your DevOps team to modify it for
    different environments and forbid them to touch your Java code. XML configuration
    would look like the following listing:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于生产环境，将此配置文件外部化为XML会是一个更好的主意，您可以允许您的DevOps团队为不同的环境修改它，并禁止他们触及您的Java代码。XML配置将如下所示：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may create as many profiles as required; it is common for each developer
    to maintain their own configurations, with profiles named after themselves, say
    `@Profile("mary")`. You can have multiple profiles active at the same time too;
    it depends on how well you organize them without having conflicts or duplicate
    bean definitions across profiles.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建尽可能多的配置文件；每个开发人员通常会维护自己的配置文件，配置文件以其自己的名称命名，例如`@Profile("mary")`。您也可以同时激活多个配置文件；这取决于您如何组织它们，以避免冲突或在配置文件之间重复定义bean。
- en: 'Now you can activate one or more profiles as you need in each (`dev`, `test`,
    or `prod`) environment using any one of the following methods:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在每个（`dev`、`test`或`prod`）环境中根据需要激活一个或多个配置文件，使用以下任一方法：
- en: Programmatically invoking `ctx.getEnvironment().setActiveProfiles("p1", "p2",
    ..)`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以编程方式调用`ctx.getEnvironment().setActiveProfiles("p1", "p2", ..)`。
- en: Setting the property `spring.profile.active`—with comma-separated profile names
    as value—as an environment variable, JVM system property, or Servlet context param
    in `web.xml`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性`spring.profile.active`设置为以逗号分隔的配置文件名作为值的环境变量、JVM系统属性或`web.xml`中的Servlet上下文参数。
- en: Add `-Dspring.profile.active="p1,p2, .."` as a command-line or Java argument
    while starting up your application.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动应用程序时，将`-Dspring.profile.active="p1,p2, .."`添加为命令行或Java参数。
- en: Injecting properties into the Spring environment
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性注入Spring环境
- en: Besides the separation of environment-specific configuration using profiles,
    you would still need to externalize many properties, such as database URLs, e-mails,
    and date formats in a property file for easier handling. These properties would
    then either be injected directly into the beans or read from environment by the
    beans at runtime. Spring's environment abstraction, together with `@PropertySource`
    annotation, makes this possible in Spring applications.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用配置文件分离环境特定配置之外，您仍然需要将许多属性外部化，例如数据库URL、电子邮件和日期格式，以便更轻松地处理。然后这些属性要么直接注入到bean中，要么在运行时由bean从环境中读取。Spring的环境抽象与`@PropertySource`注解使这在Spring应用程序中成为可能。
- en: 'The `@PropertySource` annotation provides a convenient and declarative mechanism
    for adding a `PropertySource` to Spring''s environment:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PropertySource`注解提供了一个方便和声明性的机制，用于向Spring的环境添加`PropertySource`。'
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Externalizing properties with PropertyPlaceholderConfigurer
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`PropertyPlaceholderConfigurer`外部化属性
- en: '`PropertyPlaceholderConfigurer` is another convenient utility to externalize
    property values from a bean definition into a separate file that uses the standard
    `java.util.Properties` format. It replaces placeholders in XML bean definitions
    with matching property values in the configured property file, as shown here.
    This is the best way to externalize profile or environment-specific information
    such as datasource config, e-mail settings, and so on. The DevOps team will just
    edit these property files and never mess with your code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyPlaceholderConfigurer`是另一个方便的实用程序，用于将bean定义中的属性值外部化到使用标准`java.util.Properties`格式的单独文件中。它将XML
    bean定义中的占位符替换为配置的属性文件中的匹配属性值，如下所示。这是外部化配置文件的最佳方式，例如数据源配置、电子邮件设置等。DevOps团队将只编辑这些属性文件，而不会影响您的代码：'
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is another simpler declaration of `PropertyPlaceholder`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`PropertyPlaceholder`的另一个更简单的声明：
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Handling resources
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源
- en: Spring Framework provides excellent support for accessing low-level resources,
    thus solving many limitations of Java's standard `java.net.URL` and standard handlers.
    The `org.springframework.core.io.Resource` package and its many concrete implementations
    form a solid foundation for Spring Framework's robust resource handling.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework提供了出色的支持，用于访问低级资源，从而解决了Java标准`java.net.URL`和标准处理程序的许多限制。`org.springframework.core.io.Resource`包及其许多具体实现构成了Spring
    Framework强大资源处理的坚实基础。
- en: 'Resource abstraction is used extensively in Spring itself, inside many implementations
    of `ApplicationContext`—it''s actually very useful to use as a general utility
    class by itself in your own code in order to access resources. You will find the
    following resource implementations that come supplied right out of the box in
    Spring:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Spring本身广泛使用资源抽象，在许多`ApplicationContext`的实现中——在自己的代码中作为通用实用类使用资源是非常有用的。您将在Spring的开箱即用资源实现中找到以下资源实现：
- en: '| Resource Implementation | Description |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 资源实现 | 描述 |'
- en: '| --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `UrlResource` | It wraps `java.net.URL` and is useful for accessing anything
    that can be accessed via a URL, such as files (`file:///`), HTTP targets (`http://`),
    and FTP targets (`ftp://`). |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `UrlResource` | 它包装了`java.net.URL`，用于访问可以通过URL访问的任何内容，例如文件（`file:///`）、HTTP目标（`http://`）和FTP目标（`ftp://`）。'
- en: '| `ClassPathResource` | It is used for accessing any resource from classpath
    using the prefix `classpath:` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `ClassPathResource` | 用于使用前缀`classpath:`从类路径访问任何资源。'
- en: '| `FileSystemResource` | This is the resource implementation of `java.io.File`.
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemResource` | 这是`java.io.File`的资源实现。'
- en: '| `ServletContextResource` | This is the parent bean for inheriting configuration
    data from a parent bean definition. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `ServletContextResource` | 这是从父bean定义继承配置数据的父bean。'
- en: '| `InputStreamResource` | This is the resource implementation for a given `InputStream`.
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `InputStreamResource` | 这是给定`InputStream`的资源实现。'
- en: 'Generally, you do not directly instantiate any of these resources; rather,
    you use a `ResourceLoader` interface to do that job for you. All `ApplicationContext`
    implement a `ResourceLoader` interface; therefore, any `ApplicationContext` can
    be used to obtain resource instances. The code for this is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会直接实例化这些资源；相反，您可以使用`ResourceLoader`接口来为您完成这项工作。所有的`ApplicationContext`都实现了`ResourceLoader`接口；因此，任何`ApplicationContext`都可以用来获取资源实例。其代码如下：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can inject resources into your beans by simply passing the filename or
    URL of your resource as an argument, as shown here. `ApplicationContext`, which
    is a `ResourceLoader` interface, will create an instance of an appropriate resource
    implementation based on the URL you supply:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地将资源的文件名或URL作为参数传递来将资源注入到您的bean中，如下所示。`ApplicationContext`，它是一个`ResourceLoader`接口，将根据您提供的URL创建适当的资源实现的实例：
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the XML version of injecting a resource:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是注入资源的XML版本：
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Spring Expression Language
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring表达式语言
- en: Expression languages are generally used for simple scripting to manipulate object
    graphs in a non object-oriented context. For example, if we want to read data
    or call a method of a Java object from a JSP, XML, or XHTML page, JSP EL and **Unified
    Expression Language (UEL)** come to the rescue. These expression languages allow
    page authors to access external data objects in a simple and easy-to-use way,
    compatible with tag-based languages such as XML and HTML.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语言通常用于简单的脚本编写，以在非面向对象的上下文中操作对象图。例如，如果我们想要从JSP，XML或XHTML页面读取数据或调用Java对象的方法，JSP
    EL和**统一表达式语言（UEL）**就派上用场了。这些表达式语言允许页面作者以简单易用的方式访问外部数据对象，与基于标签的语言（如XML和HTML）兼容。
- en: The **Spring Expression Language** (**SpEL**), with a language syntax similar
    to UEL, is a powerful expression language built for querying and manipulating
    an object graph at runtime. It offers additional features, most notably method
    invocation and basic string-templating functionality.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring表达式语言**（**SpEL**），其语言语法类似于UEL，是一个用于在运行时查询和操作对象图的强大表达式语言。它提供了额外的功能，最显著的是方法调用和基本的字符串模板功能。'
- en: SpEL can be used inside a wide variety of technologies that come under the Spring
    family of projects as well as many technologies that integrate with Spring. It
    can be used directly in the Spring configuration metadata files, both in XML as
    well as Java annotations in the form `#{expression-string}`. You can use SpEL
    inside many view technologies, such as JSP, XML, and XHTML, when integrated with
    the corresponding technologies, such as JSF, JSP, and Thymeleaf.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL可以在Spring系列项目以及许多与Spring集成的技术中广泛使用。它可以直接在Spring配置元数据文件中使用，无论是在XML中还是在Java注解中，都可以使用`#{expression-string}`的形式。当与相应的技术（如JSF，JSP和Thymeleaf）集成时，您可以在许多视图技术中使用SpEL，例如JSP，XML和XHTML。
- en: SpEL features
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpEL功能
- en: 'The SpEL expression language supports the following functionalities out of
    the box:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL表达式语言支持以下功能：
- en: Boolean, relational, and ternary operators
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔，关系和三元运算符
- en: Regular expressions and class expressions
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式和类表达式
- en: Accessing properties, arrays, lists, and maps
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问属性，数组，列表和映射
- en: Method and constructor invocations
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法和构造函数调用
- en: Variables, assignments, and bean references
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量，赋值和bean引用
- en: Array construction, inline lists, and maps
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组构造，内联列表和映射
- en: User-defined functions and templated expressions
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的函数和模板表达式
- en: Collection, projection, and selection
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合，投影和选择
- en: SpEL annotation support
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpEL注解支持
- en: 'SpEL can be used to specify default values for fields, methods and method or
    constructor arguments using the `@Value` annotation. The following sample listing
    contains some excellent usage of SpEL expressions at the field level:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL可以用来指定字段，方法和方法或构造函数参数的默认值，使用`@Value`注解。以下示例清单包含了一些在字段级别使用SpEL表达式的优秀用法：
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The same approach can be used for XML bean definitions too.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法也可以用于XML bean定义。
- en: The SpEL API
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpEL API
- en: Generally, most users use SpEL to evaluate expressions embedded in XML, XHTML,
    or annotations. While SpEL serves as the foundation for expression evaluation
    within the Spring portfolio, it can be used independently in non-Spring environments
    using the SpEL API. The SpEL API provides the bootstrapping infrastructure to
    use SpEL programmatically in any environment.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数用户使用SpEL来评估嵌入在XML，XHTML或注解中的表达式。虽然SpEL作为Spring组合中表达式评估的基础，但它也可以在非Spring环境中使用SpEL
    API独立使用。SpEL API提供了引导基础设施，以在任何环境中以编程方式使用SpEL。
- en: The SpEL API classes and interfaces are located in the (sub)packages under `org.springframework.expression`.
    They provide the specification and default SpEL implementations which can be used
    directly or extended.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL API的类和接口位于`org.springframework.expression`的（子）包中。它们提供了规范和默认的SpEL实现，可以直接使用或扩展。
- en: 'The following interfaces and classes form the foundation of the SpEL API:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下接口和类构成了SpEL API的基础：
- en: '| Class/Interface | Description |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 类/接口 | 描述 |'
- en: '| --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Expression` | The specification for an expression capable of evaluating
    itself against context objects independent of any language such as OGNL or UEL.
    It encapsulates the details of a previously parsed expression string. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `Expression` | 表达式的规范，能够独立于任何语言（如OGNL或UEL）对上下文对象进行评估。它封装了先前解析的表达式字符串的细节。
    |'
- en: '| `SpelExpression` | A SpEL-compliant, parsed expression that is ready to be
    evaluated standalone or in a specified context. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `SpelExpression` | 一个符合SpEL的，已解析的表达式，可以独立评估或在指定上下文中使用。 |'
- en: '| `ExpressionParser` | Parses expression strings (templates as well as standard
    expression strings) into compiled expressions that can be evaluated. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `ExpressionParser` | 解析表达式字符串（模板以及标准表达式字符串）为可以评估的编译表达式。 |'
- en: '| `SpelExpressionParser` | SpEL parser. Instances are reusable and thread-safe.
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `SpelExpressionParser` | SpEL解析器。实例可重用且线程安全。 |'
- en: '| `EvaluationContext` | Expressions are executed in an evaluation context,
    where references are resolved when encountered during expression evaluation. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `EvaluationContext` | 表达式在评估上下文中执行，当在表达式评估过程中遇到引用时会解析引用。 |'
- en: '| `StandardEvaluationContext` | The default `EvaluationContext` implementation,
    which uses reflection to resolve properties/methods/fields of objects. If this
    is not sufficient for your use, you may extend this class to register custom `ConstructorResolver`,
    `MethodResolver`, and `PropertyAccessor` objects and redefine how SpEL evaluates
    expressions. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `StandardEvaluationContext` | 默认的`EvaluationContext`实现，使用反射来解析对象的属性/方法/字段。如果这对你的使用不够，你可以扩展这个类来注册自定义的`ConstructorResolver`、`MethodResolver`和`PropertyAccessor`对象，并重新定义SpEL如何评估表达式。
    |'
- en: '| `SpelCompiler` | Compiles a regular parsed expression instead of the interpreted
    form to a class containing bytecode for evaluation. A far faster method, but still
    at an early stage, it does not yet support every kind of expression as of Spring
    4.1. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `SpelCompiler` | 编译常规解析表达式，而不是解释形式到包含字节码的类进行评估。这是一种更快的方法，但仍处于早期阶段，截至Spring
    4.1，它尚不支持每种类型的表达式。 |'
- en: 'Let''s take a look at an example that evaluates an expression using the SpEL
    API:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用SpEL API评估表达式的例子：
- en: '[PRE48]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In normal scenarios, you would not need to directly use the SpEL API in a Spring
    application; SpEL with annotation or XML bean definitions would be better candidates.
    The SpEL API is mostly used to load externalized business rules dynamically at
    runtime.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，在Spring应用程序中通常不需要直接使用SpEL API；使用注解或XML bean定义的SpEL会是更好的选择。SpEL API主要用于在运行时动态加载外部业务规则。
- en: Aspect Oriented Programming
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向切面编程
- en: Most software applications usually have some secondary—but critical—features,
    such as security, transaction, and audit-logging, spanned across multiple logical
    modules. It would be a nice idea not to mix these cross-cutting concerns in your
    core business logic. **Aspect Oriented Programming** (**AOP**) helps you achieve
    this.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件应用程序通常都有一些次要但至关重要的功能，比如安全、事务和审计日志，跨越多个逻辑模块。最好不要将这些横切关注点混合在核心业务逻辑中。**面向切面编程**（**AOP**）可以帮助你实现这一点。
- en: '**Object Oriented Programming** (**OOP**) is about modularizing complex software
    programs, with objects as the fundamental units that hold your core business logic
    and data. AOP complements OOP to add more complex functionality transparently
    across modules of your application without polluting the original object structure.
    AOP stitches (weaves) cross-cutting concerns into your program, either at compile
    time or runtime, without modifying the base code itself. AOP lets the object-oriented
    program stay clean and just have the core business concerns.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是关于将复杂软件程序模块化，对象是持有核心业务逻辑和数据的基本单元。AOP是为了在不污染原始对象结构的情况下，在应用程序的模块之间透明地添加更复杂的功能。AOP将横切关注点编织到程序中，无论是在编译时还是运行时，而不修改基本代码本身。AOP让面向对象的程序保持干净，只关注核心业务问题。'
- en: Static and dynamic AOP
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和动态AOP
- en: 'In AOP, the framework weaves the cross-cutting concerns into the main program
    transparently. This weaving process comes in two different flavors: static and
    dynamic. In the case of static AOP, as the name implies, Aspects are compiled
    directly into static files, that is, to the Java bytecode, on compilation. This
    method performs better, as there is no special interception at runtime. But the
    drawback is that you need to recompile the entire application every time you change
    anything in the code. AspectJ, one of the most comprehensive AOP implementations,
    provides compile-time weaving of Aspects.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在AOP中，框架会将横切关注点透明地编织到主程序中。这种编织过程有两种不同的方式：静态和动态。在静态AOP的情况下，正如其名称所示，切面直接编译到静态文件中，即在编译时编译为Java字节码。这种方法性能更好，因为在运行时没有特殊的拦截。但缺点是每次更改代码都需要重新编译整个应用程序。AspectJ是最全面的AOP实现之一，提供了切面的编译时编织。
- en: In the case of dynamic AOP, the weaving process is performed dynamically at
    runtime. Different frameworks implement this differently, but the most general
    way of achieving this is using proxies or wrappers for the advised objects, allowing
    the Advice to be invoked as required. This is a more flexible method as you can
    apply AOP with varying behavior at runtime depending on data, which is not possible
    in the case of static AOP. There is no need for recompiling the main application
    code if you use XML files for defining your AOP constructs (schema-based approach).
    The disadvantage of dynamic AOP is a very negligible performance loss due to the
    extra runtime processing.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态AOP的情况下，编织过程是在运行时动态执行的。不同的框架实现方式不同，但最常见的方式是使用代理或包装器来为被建议的对象允许根据需要调用建议。这是一种更灵活的方法，因为你可以根据数据在运行时应用具有不同行为的AOP，而这在静态AOP的情况下是不可能的。如果使用XML文件定义AOP构造（基于模式的方法），则无需重新编译主应用程序代码。动态AOP的缺点是由于额外的运行时处理而导致的非常微不足道的性能损失。
- en: Spring AOP is proxy based, that is, it follows the dynamic flavor of AOP. Spring
    provides the facility to use static AOP by integrating with AspectJ too.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP是基于代理的，即它遵循动态AOP的方式。Spring提供了与AspectJ集成以使用静态AOP的功能。
- en: AOP concepts and terminology
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AOP概念和术语
- en: 'Understanding AOP concepts and terms gives you an excellent starting point
    for AOP; it helps you visualize how and where AOP can be applied in your application:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 理解AOP概念和术语为AOP提供了一个很好的起点；它帮助你想象AOP可以在应用程序中的哪些地方以及如何应用。
- en: '**Aspect**: The concern that cuts across multiple classes or modules. Transaction
    and security are examples. Spring Transaction is implemented as Aspects.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切面**：横跨多个类或模块的关注点。事务和安全是例子。Spring事务是作为切面实现的。'
- en: '**Join point**: A point during the execution of the program at which you want
    to insert additional logic using AOP. A method execution and a class instantiation
    are examples.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接点**：程序执行过程中要插入额外逻辑的点，使用AOP。方法执行和类实例化是例子。'
- en: '**Advice**: The action taken by (the code or method that executes) the Aspect
    at a particular join point. Different types of advices include `before`, `after`,
    and `around` advices. Typically, an Aspect has one or more Advices.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议：在特定连接点执行的切面（代码或方法）采取的行动。不同类型的建议包括`before`、`after`和`around`建议。通常，一个切面有一个或多个建议。
- en: '**Pointcut**: An expression that defines or matches a set of join points. The
    Advice associated with a pointcut executes at any join point it matches. Spring
    supports the AspectJ pointcut expression language by default. An example is `execution(*
    com.xyz.service.*.*(..))`.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切入点：定义或匹配一组连接点的表达式。与切入点相关联的建议在匹配的任何连接点上执行。Spring默认支持AspectJ切入点表达语言。例如，`execution(*
    com.xyz.service.*.*(..))`。
- en: '**Target object**: The advised object. If you use dynamic AOP, this would be
    a proxied object.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标对象：被建议的对象。如果使用动态AOP，这将是一个代理对象。
- en: '**Weaving**: Inserting Aspects into a target object to make it advised at compile
    time, load time or runtime. AspectJ supports compile-time weaving and Spring weaves
    at runtime.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编织：在编译时、加载时或运行时将切面插入目标对象，使其在建议时。AspectJ支持编译时织入，Spring在运行时进行编织。
- en: '**Introduction**: The process by which you add a new method or field to an
    advised object, with or without making it implement an interface.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入：向被建议的对象添加新方法或字段的过程，无论是否使其实现接口。
- en: Spring AOP – definition and configuration styles
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AOP - 定义和配置样式
- en: Spring provides a proxy-based dynamic implementation of AOP, developed purely
    in Java. It neither requires a special compilation process like AspectJ nor controls
    the class loader hierarchy, hence it can be deployed inside any Servlet container
    or application server.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了基于代理的AOP的动态实现，纯粹在Java中开发。它既不需要像AspectJ那样特殊的编译过程，也不控制类加载器层次结构，因此可以部署在任何Servlet容器或应用服务器中。
- en: Although not a full-blown AOP framework like AspectJ, Spring provides a simple
    and easy-to-use abstraction of most of the common features of AOP. It supports
    only method execution join points; field interception is not implemented. Spring
    provides tight integration with AspectJ, in case you want to advise very fine-grained
    Aspect orientation that Spring AOP doesn't cover by adding more AspectJ-specific
    features without breaking the core Spring AOP APIs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不像AspectJ那样是一个完整的AOP框架，Spring提供了AOP大多数常见特性的简单易用的抽象。它仅支持方法执行连接点；字段拦截未实现。Spring与AspectJ紧密集成，如果您想要建议非常精细的切面定向，Spring
    AOP没有涵盖的部分，可以通过添加更多的AspectJ特定功能来扩展而不破坏核心Spring AOP API。
- en: Spring AOP uses standard JDK dynamic proxies for Aspect orientation by default.
    JDK dynamic proxies allow any interface (or set of interfaces) to be proxied.
    If you want to proxy classes rather than interfaces, you may switch to CGLIB proxies.
    Spring automatically switches to use CGLIB if a target object does not implement
    an interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP默认使用标准JDK动态代理进行切面定向。JDK动态代理允许代理任何接口（或一组接口）。如果要代理类而不是接口，可以切换到CGLIB代理。如果目标对象没有实现接口，Spring会自动切换到使用CGLIB。
- en: Starting from Spring 2.0, you can follow either a schema-based approach or an
    `@AspectJ` annotation style to write custom Aspects. Both of these styles offer
    fully typed Advice and use of the AspectJ pointcut language while still using
    Spring AOP for weaving.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring 2.0开始，您可以遵循基于模式的方法或`@AspectJ`注释样式来编写自定义切面。这两种样式都提供了完全类型化的建议和使用AspectJ切入点语言，同时仍然使用Spring
    AOP进行编织。
- en: XML schema-based AOP
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML基于模式的AOP
- en: 'When using schema-based AOP, you need to import `aop` namespace tags into your
    `application-context` file, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于模式的AOP时，需要将`aop`命名空间标签导入到您的`application-context`文件中，如下所示：
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '@AspectJ annotation-based AOP'
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@AspectJ基于注释的AOP'
- en: '`@AspectJ` refers to a style of declaring Aspects as regular Java classes that
    are annotated. Spring interprets the same annotations as AspectJ 5, using a library
    supplied by AspectJ for pointcut parsing and matching. Spring AOP has no dependency
    on the AspectJ compiler or weaver, though.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AspectJ`指的是将切面声明为常规Java类并进行注释的风格。Spring解释相同的注释作为AspectJ 5，使用由AspectJ提供的库进行切入点解析和匹配。Spring
    AOP不依赖于AspectJ编译器或织入器。'
- en: 'When using the `@AspectJ` annotation style, you first need to enable `@AspectJ`
    support in your Spring configuration, whether or not it is in the XML or Java
    configuration. Additionally, you need to make sure you add `aspectjweaver.jar`
    in your classpath. Adding an `@EnableAspectJAutoProxy` annotation to your Java
    `@Configuration` annotation will enable `@AspectJ` support in your project:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@AspectJ`注释样式时，首先需要在Spring配置中启用`@AspectJ`支持，无论是在XML还是Java配置中。此外，您需要确保在类路径中添加`aspectjweaver.jar`。在Java
    `@Configuration`注释中添加`@EnableAspectJAutoProxy`注释将在项目中启用`@AspectJ`支持：
- en: '[PRE50]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Alternatively, if you use XML-based configuration, `@AspectJ` support can be
    enabled by adding the `<aop:aspectj-autoproxy/>` element in your `application-context`
    file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用基于XML的配置，可以通过在您的`application-context`文件中添加`<aop:aspectj-autoproxy/>`元素来启用`@AspectJ`支持。
- en: Declaring an @Aspect annotation
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明@Aspect注释
- en: Your Aspect is a simple POJO, either annotated with `@Aspect` (`org.aspectj.lang.annotation.Aspect`)
    or declared as `<aop:aspect/>` under the `<aop:config>` section of your `application-context`
    XML file. Remember, the class marked as `@Aspect` should be declared as a Spring
    bean using either an annotation or `<bean/>` declaration in your application context
    XML file.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您的切面是一个简单的POJO，可以使用`@Aspect`（`org.aspectj.lang.annotation.Aspect`）进行注释，或者在`application-context`
    XML文件的`<aop:config>`部分下声明为`<aop:aspect/>`。请记住，标记为`@Aspect`的类应该在应用程序上下文XML文件中使用注释或`<bean/>`声明声明为Spring
    bean。
- en: 'Here is an annotated Aspect, a Spring component annotated as `@Aspect`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带注释的切面，一个Spring组件被注释为`@Aspect`：
- en: '[PRE51]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that `@Aspect` is a Spring bean too. It can be any of the specializations
    of `@Component`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`@Aspect`也是一个Spring bean。它可以是`@Component`的任何专业化。
- en: 'Now, let''s take a look at the XML alternative for Aspect declaration:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下Aspect声明的XML替代方案：
- en: '[PRE52]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Aspects may have methods and fields, just like any other class. They may also
    contain pointcut, advice, and introduction (inter-type) declarations. Aspects
    themselves cannot be the target of Advice from other Aspects; they are excluded
    from auto-proxying.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Aspect可能具有方法和字段，就像任何其他类一样。它们还可以包含切入点、advice和introduction（inter-type）声明。Aspect本身不能成为其他Aspect的Advice的目标；它们被排除在自动代理之外。
- en: Pointcuts
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切入点
- en: 'A pointcut comprises two parts, as shown in the following code snippet: a method
    signature (an empty method with a `void` return type inside the `Aspect` class)
    with any parameters and an expression that matches the exact method executions
    we are interested in. Remember, Spring AOP only supports method execution join
    points:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点由两部分组成，如下面的代码片段所示：一个方法签名（在`Aspect`类中具有`void`返回类型的空方法）和一个表达式，匹配我们感兴趣的确切方法执行。请记住，Spring
    AOP仅支持方法执行连接点：
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The pointcut expression follows the standard AspectJ format. You may refer to
    the AspectJ pointcut expression reference for the detailed syntax. The following
    section gives you a strong foundation for constructing pointcuts for Spring AOP.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点表达式遵循标准的AspectJ格式。您可以参考AspectJ切入点表达式参考以获取详细的语法。下一节将为您构建Spring AOP的切入点提供坚实的基础。
- en: Pointcut designators
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切入点设计器
- en: 'Spring AOP supports just a subset of the original AspectJ **pointcut designators**
    (**PCDs**) for use in pointcut expressions, as given in the following table:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP仅支持原始AspectJ **切入点设计器**（**PCDs**）的子集，用于切入点表达式，如下表所示：
- en: '| PCD | Description |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: PCD | 描述
- en: '| --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `execution` | Method execution join point; the default PCD for Spring AOP
    |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '`execution` | 方法执行连接点；Spring AOP的默认PCD'
- en: '| `within` | Matches methods in a range of types, packages, and so on |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '`within` | 匹配一系列类型、包等中的方法'
- en: '| `this` | Matches proxy instances of a given type |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '`this` | 匹配给定类型的代理实例'
- en: '| `target` | Matches target object with a given type |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '`target` | 与给定类型匹配目标对象'
- en: '| `args` | Matches methods with the given argument types |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '`args` | 匹配具有给定参数类型的方法'
- en: '| `@target` | Matches methods of classes with the given annotation |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '`@target` | 匹配具有给定注解的类的方法'
- en: '| `@args` | Matches methods having argument (s) with the given annotation (s)
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '`@args` | 匹配具有给定注解的参数（s）的方法'
- en: '| `@within` | Matches methods within types that have a given annotation |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '`@within` | 匹配具有给定注解的类型内的方法|'
- en: '| `@annotation` | Matches methods with the given annotation |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '`@annotation` | 匹配具有给定注解的方法'
- en: In addition to the preceding table, Spring supports an extra non-AspectJ PCD,
    `bean`, which is useful to directly refer to a Spring bean or a set of beans with
    a comma-separated list of beans using `bean(idsOrNamesOfBean)`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上表之外，Spring还支持额外的非AspectJ PCD，`bean`，它可用于直接引用Spring bean或使用逗号分隔的bean列表`bean(idsOrNamesOfBean)`。
- en: Note that the pointcuts intercept only `public` methods due to the proxy nature
    of Spring AOP. If you want to intercept `protected` and `private` methods or even
    constructors, consider using AspectJ weaving (integrated with Spring itself) instead.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于Spring AOP的代理性质，切入点仅拦截`public`方法。如果您想要拦截`protected`和`private`方法甚至构造函数，请考虑使用AspectJ编织（与Spring集成）。
- en: Pointcut examples
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切入点示例
- en: 'Pointcut expressions can be combined using `&&`, `||`, and `!`. You can refer
    to pointcut expressions by name, too. Let''s see a few examples:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点表达式可以使用`&&`、`||`和`!`进行组合。您也可以通过名称引用切入点表达式。让我们看一些例子：
- en: '[PRE54]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An XML version of a pointcut definition goes like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 点切定义的XML版本如下：
- en: '[PRE55]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Advices
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Advices
- en: An Advice is the action that gets injected before, after, or around the method
    executions matched by the pointcut expression. The pointcut expression associated
    with an Advice could be a named or defined pointcut, as listed in the above examples,
    or a pointcut expression declared in place, that is, advices and pointcuts can
    be declared together.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Advice是在切入点表达式匹配的方法执行之前、之后或周围注入的操作。与Advice相关联的切入点表达式可以是上面示例中列出的命名或定义的切入点，也可以是在适当位置声明的切入点表达式，即，advice和切入点可以一起声明。
- en: 'Let''s see an example for an Advice that refers to a pointcut expression named
    `Pointcut`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个引用名为`Pointcut`的切入点表达式的Advice的示例：
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following code listing combines both a join point and Advice in one go.
    This is the most common approach:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清单将连接点和Advice结合在一起。这是最常见的方法：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following table lists the available Advice annotations:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了可用的Advice注释：
- en: '| Advice annotation | Description |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: Advice注释 | 描述
- en: '| --- | --- |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Before` | Runs before method execution. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '`@Before` | 方法执行前运行。'
- en: '| `@After` | Runs after method exit (finally). |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '`@After` | 方法退出后运行（最终）。'
- en: '| `@AfterReturning` | Runs after the method returns without an exception. You
    can bind the return value with the Advice as the method argument. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '`@AfterReturning` | 方法返回时运行，没有异常。您可以将返回值与Advice绑定为方法参数。'
- en: '| `@AfterThrowing` | Runs after the method exits by throwing an exception.
    You can bind the exception with the Advice as the method argument. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '`@AfterThrowing` | 方法通过抛出异常退出后运行。您可以将异常与Advice绑定为方法参数。'
- en: '| `@Around` | The target method actually runs inside this Advice. It allows
    you to manipulate the method execution inside your Advice method. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '`@Around` | 目标方法实际上在此Advice中运行。它允许您在Advice方法内部操纵方法执行。'
- en: The @Around Advice
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@Around Advice'
- en: 'The `@Around` Advice gives you more control over method execution, as the intercepted
    method essentially runs inside your Advice method. The first argument of the Advice
    must be `ProceedingJoinPoint`. You need to invoke the `proceed()` method of `ProceedingJoinPoint`
    inside the Advice body in order to execute the target method; else, the method
    will not get called. After the method execution returns to you with whatever it
    returns back to your advice, do not forget to return the result in your Advice
    method. Take a look at a sample `@Around` advice:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Around` Advice可以更好地控制方法的执行，因为拦截的方法实际上在Advice方法内部运行。Advice的第一个参数必须是`ProceedingJoinPoint`。您需要在Advice主体内调用`ProceedingJoinPoint`的`proceed()`方法，以执行目标方法；否则，方法将不会被调用。在方法执行返回给您并返回给您的Advice后，不要忘记在Advice方法中返回结果。看一个`@Around`
    advice的示例：'
- en: '[PRE58]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Accessing Advice parameters
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问Advice参数
- en: 'There are two distinct ways of accessing the parameters of the method you are
    advising in the Advice method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方法可以在Advice方法中访问您正在建议的方法的参数：
- en: Declaring a join point as the first argument
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接点声明为第一个参数
- en: Binding `args` in the pointcut definition
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在切入点定义中绑定`args`
- en: 'Let''s see the first approach:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一种方法：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can see that `joinpoint.getArgs()` returns `Object[]` of all the arguments
    passed to the intercepted method. Now, let''s see how to bind named arguments
    to the Advice method:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`joinpoint.getArgs()`返回拦截方法传递的所有参数的`Object[]`。现在，让我们看看如何将命名参数绑定到Advice方法：
- en: '[PRE60]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that the `joinpoint` expression matches the arguments by name. You can
    have a `joinpoint` object as an optional first argument in the method signature
    without specifying it in the expression: you will have both `joinpoint` and arguments,
    enabling more manipulation.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`joinpoint`表达式通过名称匹配参数。您可以在方法签名中将`joinpoint`对象作为可选的第一个参数，而不在表达式中指定它：这样您将同时拥有`joinpoint`和参数，从而实现更多的操作。
- en: Testing with Spring
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring进行测试
- en: The degree of testability shows the elegance and maturity of any framework.
    A more testable system is more maintainable. Spring Framework provides comprehensive
    support for end-to-end testing of applications for both unit testing as well as
    integration testing. Spring promotes **test-driven development** (**TDD**), facilitates
    integration testing, and advocates a set of best practices for the unit testing
    of beans. This is another compelling reason for using Spring to build serious
    applications.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性的程度显示了任何框架的优雅和成熟程度。一个更可测试的系统更易于维护。Spring框架为应用程序的端到端测试提供了全面的支持，包括单元测试和集成测试。Spring推广**测试驱动开发**（**TDD**），促进集成测试，并倡导一套最佳实践来测试bean。这是使用Spring构建严肃应用程序的另一个令人信服的理由。
- en: The POJO-based programming model and loosely coupled nature of Spring beans
    make it easier to participate in JUnit and TestNG tests even without Spring in
    the middle. On top of this, Spring provides many testing support components, utilities,
    and mock objects to make the testing easier.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean基于POJO的编程模型和松耦合的特性使得即使没有Spring在中间，也更容易参与JUnit和TestNG测试。此外，Spring提供了许多测试支持组件、实用工具和模拟对象，以使测试更容易。
- en: Mock objects
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟对象
- en: Spring provides mock implementations of many container-specific components so
    that the beans can be tested outside a server or container environment. `MockEnvironment`
    and `MockPropertySource` are useful for testing environment-dependent beans. To
    test beans that depend on HTTP communications, Spring provides mock classes for
    both client and server sides inside the `org.springframework.mock.http` and `org.springframework.mock.http.client`
    packages.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了许多容器特定组件的模拟实现，以便可以在服务器或容器环境之外测试bean。`MockEnvironment`和`MockPropertySource`对于测试依赖于环境的bean非常有用。为了测试依赖于HTTP通信的bean，Spring在`org.springframework.mock.http`和`org.springframework.mock.http.client`包中提供了客户端和服务器端的模拟类。
- en: Another set of useful classes can be found under `org.springframework.mock.jndi`
    to run test suites that depend on JNDI resources. The `org.springframework.mock.web`
    package contains mock objects for web components based on Servlet 3.0, such as
    web contexts, filters, controllers, and asynchronous request processing.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组有用的类可以在`org.springframework.mock.jndi`中找到，用于运行依赖于JNDI资源的测试套件。`org.springframework.mock.web`包含基于Servlet
    3.0的Web组件的模拟对象，如Web上下文、过滤器、控制器和异步请求处理。
- en: Unit and integration testing utilities
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和集成测试实用工具
- en: Spring ships certain general-purpose and context-specific utilities for unit
    and integration testing. The `org.springframework.test.util` package contains
    a set of utility classes for various testing purposes, including reflection, AOP,
    JSON, and XML manipulations. Classes under `org.springframework.test.web` and
    its nested subdirectories contain a comprehensive set of utility classes to test
    beans dependent on the web environment. Another set of useful classes for usages
    specific to `ApplicationContext` can be found under `org.springframework.test.context`
    and its child packages. Their support includes the loading and caching of web,
    portlet, or application contexts in the test environment; resolving profiles;
    loading property sources and SQL scripts; managing transactions for test environments;
    and so on.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一些通用和特定上下文的单元测试和集成测试的实用工具。`org.springframework.test.util`包含一组实用类，用于各种测试目的，包括反射、AOP、JSON和XML操作。`org.springframework.test.web`及其嵌套子目录中的类包含了一套全面的实用类，用于测试依赖于Web环境的bean。另一组用于`ApplicationContext`特定用途的实用类可以在`org.springframework.test.context`及其子包中找到。它们的支持包括在测试环境中加载和缓存Web、Portlet或应用程序上下文；解析配置文件；加载属性源和SQL脚本；管理测试环境的事务等等。
- en: The support classes and annotations under the packages listed earlier facilitate
    the easy and natural testing of Spring applications. A comprehensive discussion
    over Spring test support is beyond the scope of this book. However, gaining a
    good understanding of Spring's comprehensive support for unit and integration
    tests is vital in order to develop elegant code and maintainable applications
    using Spring.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的包下的支持类和注解有助于轻松自然地测试Spring应用程序。对Spring测试支持的全面讨论超出了本书的范围。然而，了解Spring对单元测试和集成测试的全面支持对于使用Spring开发优雅的代码和可维护的应用程序至关重要。
- en: Summary
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have successfully covered all the major technologies and concepts of core
    Spring Framework in this chapter. We are now capable of developing robust, standalone
    Spring applications composed of loosely-coupled beans inside the powerful Spring
    IoC container. We know how to apply cross-cutting concerns transparently across
    different layers of an application using the very flexible pointcut expressions
    of Spring AOP. We can manipulate Spring beans using Spring Expression Language,
    which helps keep the code clean and highly maintainable. We learned how to maintain
    multiple environment-specific bean configurations and property files using bean
    definition profiles. Now, we are all set for professional Spring development.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地涵盖了核心Spring Framework的所有主要技术和概念。我们现在能够开发由强大的Spring IoC容器中松耦合的bean组成的健壮的独立Spring应用程序。我们知道如何使用Spring
    AOP的非常灵活的切入点表达式在应用程序的不同层之间透明地应用横切关注点。我们可以使用Spring Expression Language操纵Spring
    bean，这有助于保持代码清晰和易于维护。我们学会了使用bean定义配置文件和属性文件来维护多个特定于环境的bean配置。现在，我们已经准备好进行专业的Spring开发了。
- en: The source code available with this chapter contains multiple Spring projects
    that demonstrate the different ways of configuring Spring as well as usage scenarios.
    The examples listed in this chapter have been extracted from them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的源代码包含了多个Spring项目，演示了配置Spring以及使用场景的不同方式。本章列出的示例都是从这些项目中提取出来的。
- en: In the next chapter, we will explore Spring Web module, leveraging all that
    we learned in this chapter in a web-based environment. The topics we have learned
    in this chapter are going to be the foundation for all the advanced topics that
    will be covered in the following chapters.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Spring Web模块，在基于Web的环境中利用本章学到的知识。本章学到的主题将成为接下来章节中所有高级主题的基础。
- en: Chapter 2. Building the Web Layer with Spring Web MVC
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Spring Web MVC构建Web层
- en: Web application development is a major focus area for enterprise systems. In
    this age of cloud and big data, web applications are under a tremendous load of
    an ever-increasing number of concurrent users accessing them from multiple devices
    such as mobiles and tablets, as well as traditional desktop web browsers. Modern
    web applications have to address a newer set of nonfunctional requirements, such
    as scalability, performance, productivity, responsiveness, and multi-device support.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序开发是企业系统的一个主要关注领域。在云和大数据时代，Web应用程序承受着越来越多的并发用户访问的巨大压力，这些用户来自多种设备，如手机、平板以及传统的桌面Web浏览器。现代Web应用程序必须满足一系列新的非功能性需求，如可伸缩性、性能、生产力、响应性和多设备支持。
- en: Spring MVC is a web framework from Spring, perfectly built from the ground up
    to address the concerns of modern web applications. A lightweight and high-performance
    web framework, Spring MVC is designed to be highly productive from day one, flexible,
    and adaptable with a wide variety of view technologies. Sitting on top of the
    mighty Spring Framework, it integrates well with all Java EE technologies and
    other open source frameworks. Just like any technology under the Spring portfolio,
    Spring MVC also promotes POJO programming with the help of a well-defined set
    of annotations, namespace XML tags, and web-support components.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是Spring的一个Web框架，从头开始完美构建，以解决现代Web应用程序的问题。作为一个轻量级高性能的Web框架，Spring MVC旨在从一开始就具有高生产力，灵活，并且能够适应各种视图技术。作为强大的Spring
    Framework的一部分，它与所有Java EE技术和其他开源框架都很好地集成。就像Spring系列下的任何技术一样，Spring MVC也通过一组明确定义的注解、命名空间XML标签和Web支持组件来促进POJO编程。
- en: This chapter introduces Spring MVC and its powerful features to you, describes
    how to set it up, and guides you on its advanced usages, configurations, and optimizations
    with relevant examples. We will mostly use annotations in these examples for simplicity.
    At the end of this chapter, you will be able to build web applications with Spring
    MVC that have HTML-based user interfaces as well as RESTful APIs with JSON and
    XML formats.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Spring MVC及其强大的功能，描述了如何设置它，并指导您如何使用相关示例进行高级用法、配置和优化。在这些示例中，我们将主要使用注解以简化操作。在本章结束时，您将能够使用Spring
    MVC构建具有基于HTML的用户界面以及具有JSON和XML格式的RESTful API的Web应用程序。
- en: Features of Spring MVC
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC的特点
- en: 'Spring MVC bundles a compelling set of features and advantages over rival web
    technologies. Knowledge of these will help you decide on choosing Spring MVC for
    your requirements. The following list covers most of them:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC捆绑了一套引人注目的功能和优势，超过了竞争对手的Web技术。了解这些将有助于您决定是否选择Spring MVC来满足您的需求。以下列表涵盖了大部分内容：
- en: Simple configuration and native integration with Spring Framework, leveraging
    the powerful features of Spring and other open source libraries
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的配置和与Spring Framework的本地集成，利用Spring和其他开源库的强大功能
- en: Built on top of Java web technologies such as Servlets, JSP, and JSTL and can
    be deployed into any standard Servlet container, such as Tomcat
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java Web技术构建，如Servlets、JSP和JSTL，并且可以部署到任何标准的Servlet容器中，比如Tomcat
- en: Implemented based on the **Model-View-Controller** (**MVC**) architecture pattern,
    with clear separation of concerns using simple annotations and namespace XML tags
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于**模型-视图-控制器**（**MVC**）架构模式实现，使用简单的注解和命名空间XML标签清晰地分离关注点
- en: Explicit support for convention over configuration for MVC components
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对MVC组件的约定优于配置的显式支持
- en: Supports a big set of view technologies, such as JSP, Thymeleaf, Handlebars,
    Velocity, FreeMarker, PDF, Excel, and JasperReports
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持大量的视图技术，如JSP、Thymeleaf、Handlebars、Velocity、FreeMarker、PDF、Excel和JasperReports
- en: Declarative input validation, data binding, and exception handling
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性输入验证、数据绑定和异常处理
- en: Flexible URL mapping with automatic request and response transformation into
    various formats such as JSON, XML, and HTML
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的URL映射，自动将请求和响应转换为各种格式，如JSON、XML和HTML
- en: Support for non-blocking asynchronous request processing and HTTP streaming
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持非阻塞异步请求处理和HTTP流式传输
- en: Support for internationalization, themes, and multipart file uploads
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持国际化、主题和多部分文件上传
- en: Easy integration with Spring Security and thorough testability
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Spring Security的轻松集成和全面的可测试性
- en: HTTP caching for increased performance
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加性能的HTTP缓存
- en: A simple, yet powerful, JSP tag library
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单而强大的JSP标签库
- en: What makes Spring MVC outstanding is its simple programming model, a feature
    inherited from the core Spring Framework itself. A developer familiar with any
    standard web framework will find Spring MVC very familiar and easy to learn.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC的杰出之处在于其简单的编程模型，这是从核心Spring框架本身继承的特性。熟悉任何标准Web框架的开发人员会发现Spring MVC非常熟悉和易于学习。
- en: The Model-View-Controller pattern
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器模式
- en: MVC is a well-established architectural pattern popularly used for building
    interactive web and desktop applications. There are numerous frameworks implementing
    this pattern in most software platforms. MVC divides the application into three
    core elements that actually represent layers, separates concerns between these
    three core elements, and defines how they communicate with each other.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种广泛用于构建交互式Web和桌面应用程序的成熟的架构模式。在大多数软件平台上有许多实现这种模式的框架。MVC将应用程序分为三个核心元素，实际上代表层，分离这三个核心元素之间的关注点，并定义它们如何相互通信。
- en: '![The Model-View-Controller pattern](img/image00781.jpeg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-控制器模式](img/image00781.jpeg)'
- en: '**Model** represents data, **View** displays the **Model**, and **Controller**
    handles user actions. Model can be any data, including that stored in a database.
    It usually represents a collection of domain objects with clearly defined relationships
    to each other. A **Model** can be displayed in multiple views depending on how
    the application is designed.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**Model**表示数据，**View**显示**Model**，**Controller**处理用户操作。模型可以是任何数据，包括存储在数据库中的数据。它通常表示具有彼此清晰定义关系的域对象集合。根据应用程序的设计，一个**Model**可以在多个视图中显示。'
- en: '**Controller** acts as an intermediary between **View** and **Model**. It often
    has a set of handlers for each event generated by the view as the user interacts
    with it. **Controller** delegates user actions to appropriate handlers and then
    finally redirects to another view for displaying the result of that action.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**Controller**充当**View**和**Model**之间的中介。它通常具有一组处理程序，用于视图生成的每个事件。**Controller**将用户操作委托给适当的处理程序，然后最终重定向到另一个视图，以显示该操作的结果。'
- en: There are so many implementations of the MVC pattern as frameworks across technology
    platforms use it in different ways. Spring MVC has implemented it in the simplest
    and least invasive fashion, while naturally integrating it with the core Spring
    Framework.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同技术平台上的框架以不同的方式使用MVC模式，因此有许多MVC模式的实现。Spring MVC以最简单和最少侵入性的方式实现了它，并自然地将其与核心Spring框架集成在一起。
- en: Your first Spring MVC application
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个Spring MVC应用程序
- en: Let's jump to creating a very simple Spring MVC web application. For the purpose
    of learning, we will develop the web version of *Taskify*, the task management
    system we started in [Chapter 1](part0012.xhtml#aid-BE6O1 "Chapter 1. Getting
    Started with Spring Core"), *Getting Started with Spring Core*. The samples in
    this chapter use **Spring Tool Suite** (**STS**) as the IDE, but you can use your
    favorite IDE, such as IntelliJ and NetBeans. Almost all Java IDEs support Spring
    development; most of them have plugins to manage Spring projects and artifacts.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个非常简单的Spring MVC Web应用程序。为了学习的目的，我们将开发*Taskify*的Web版本，这是我们在[第1章](part0012.xhtml#aid-BE6O1
    "第1章。开始使用Spring Core")中开始的任务管理系统，*开始使用Spring Core*。本章中的示例使用**Spring Tool Suite**（**STS**）作为IDE，但您也可以使用您喜欢的IDE，如IntelliJ和NetBeans。几乎所有的Java
    IDE都支持Spring开发；它们中的大多数都有插件来管理Spring项目和构件。
- en: 'To begin with, follow these steps; then, we will explore the code:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤进行；然后，我们将探索代码：
- en: Open STS or Eclipse → create a new project → type a project name → select a
    template, either **Spring MVC Project** or **Simple Spring Web Maven** → specify
    the top-level package name → finish. Your project structure will be generated.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STS或Eclipse→创建一个新项目→输入项目名称→选择一个模板，要么是**Spring MVC项目**，要么是**简单的Spring Web Maven**→指定顶级包名称→完成。您的项目结构将被生成。
- en: Make sure your `pom.xml` file contains Maven dependencies for the `spring-context`,
    `spring-mvc`, `servlet-api`, `jsp-api`, and `jstl` libraries. Note that `jsp-api`
    and `jstl` are required only if you are using JSP as the view technology.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的`pom.xml`文件包含`spring-context`、`spring-mvc`、`servlet-api`、`jsp-api`和`jstl`库的Maven依赖项。请注意，只有在使用JSP作为视图技术时，才需要`jsp-api`和`jstl`。
- en: 'If it hasn''t been generated, create `web.xml` under `WEB-INF`, with the following
    content:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未生成，请在`WEB-INF`下创建`web.xml`，内容如下：
- en: '[PRE61]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If it hasn''t been generated, create a `root-context.xml` file, with the following
    content:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未生成，请创建一个`root-context.xml`文件，内容如下：
- en: '[PRE62]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If it hasn''t been generated, create a `servlet-context.xml` file, with the
    following content:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未生成，请创建一个`servlet-context.xml`文件，内容如下：
- en: '[PRE63]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, create a Java class, `HomeController`, under the package `com.taskify.web.controllers`,
    with the following content:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`com.taskify.web.controllers`包下创建一个名为`HomeController`的Java类，内容如下：
- en: '[PRE64]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a JSP view, `home.jsp`, under `~WEB-INF/views`, with the following content:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`~WEB-INF/views`下创建一个名为`home.jsp`的JSP视图，内容如下：
- en: '[PRE65]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Make sure you have the `TaskService` class (copy it from [Chapter 1](part0012.xhtml#aid-BE6O1
    "Chapter 1. Getting Started with Spring Core"), *Getting Started with Spring Core*)
    and its concrete implementation in your project, with the methods `findAllTasksCount()`
    and `findAllOpenTasksCount()` implemented.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的项目中有`TaskService`类（从[第1章](part0012.xhtml#aid-BE6O1 "第1章。开始使用Spring Core")中复制），以及它的具体实现，其中实现了`findAllTasksCount()`和`findAllOpenTasksCount()`方法。
- en: Now that your project is ready, make sure you have an Apache Tomcat (or any
    other) server installed and configured with your IDE. You can download Tomcat
    from [http://tomcat.apache.org/](http://tomcat.apache.org/) and install on your
    PC.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的项目已准备就绪，请确保已安装并配置了Apache Tomcat（或其他任何）服务器与您的IDE。您可以从[http://tomcat.apache.org/](http://tomcat.apache.org/)下载Tomcat并在您的PC上安装。
- en: STS and Eclipse allow you to run Java web apps from the IDE just by right-clicking
    **Run As** → **Run on Server**. Resolve all errors, if any, and run again.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: STS和Eclipse允许您通过右键单击**Run As** → **Run on Server**从IDE中运行Java Web应用程序。解决所有错误（如果有），然后再次运行。
- en: You should see the home screen of your web app (at `http://localhost:8080/chapter2/`),
    as seen here:![Your first Spring MVC application](img/image00782.jpeg)
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到您的Web应用程序的主屏幕（在`http://localhost:8080/chapter2/`），如下所示：![您的第一个Spring MVC应用程序](img/image00782.jpeg)
- en: Setting up a Spring MVC application
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring MVC应用程序
- en: Let's figure out how a Spring MVC web application is configured by analyzing
    the application artifacts listed in the previous section, *Your first Spring MVC
    application*. It contains all the necessary artifacts for building a Spring MVC
    web app.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析前一节*您的第一个Spring MVC应用程序*中列出的应用程序构件来弄清楚Spring MVC Web应用程序是如何配置的。它包含了构建Spring
    MVC Web应用程序所需的所有必要构件。
- en: The project structure of a Spring MVC application
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring MVC应用程序的项目结构
- en: 'The easiest way to create the project structure and the necessary artifacts
    is using STS to create a Spring MVC project, as described in the previous section.
    Alternatively, you may use one of the Maven archetypes available in various repositories
    online. STS uses such a bundled archetype. Here is the typical project structure
    of a Spring MVC application as viewed in STS:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目结构和必要的构件的最简单方法是使用STS创建Spring MVC项目，如前一节所述。或者，您可以使用各种在线存储库中提供的Maven原型之一。STS使用这样一个捆绑的原型。以下是在STS中查看的Spring
    MVC应用程序的典型项目结构：
- en: '![The project structure of a Spring MVC application](img/image00783.jpeg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![Spring MVC应用程序的项目结构](img/image00783.jpeg)'
- en: This structure represents a single-WAR web application where all the services
    and data access components are collocated with the web controllers. In the case
    of bigger applications, many such components could be part of a different JAR
    library project, to be shared between multiple web apps and then added as Maven
    dependencies to the consuming web apps and beans imported to the web application
    context XML files using an `<import/>` tag or annotation config.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构代表一个单一WAR Web应用程序，其中所有服务和数据访问组件与Web控制器共存。在更大的应用程序中，许多这样的组件可能是不同JAR库项目的一部分，可以在多个Web应用程序之间共享，然后作为Maven依赖项添加到消费Web应用程序中，并使用`<import/>`标签或注释配置将其导入到Web应用程序上下文XML文件中的bean。
- en: Now, let's examine each artifact listed in *Your first Spring MVC application*
    in detail.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细检查*您的第一个Spring MVC应用程序*中列出的每个构件。
- en: The web.xml file – Springifying the web app
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: web.xml文件-使web应用程序Spring化
- en: The `web.xml` file is the standard Java web descriptor in which the fundamental
    web components that make up a Java web application are registered with the Servlet
    container. `ServletContextListener`, and `ServletFilter` components are configured
    here.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`web.xml`文件是标准的Java Web描述符，其中注册了构成Java Web应用程序的基本Web组件，这些组件与Servlet容器一起使用。在这里配置了`ServletContextListener`和`ServletFilter`组件。'
- en: A Spring MVC application is also configured and bootstrapped in `web.xml`. `ContextLoaderListener`,
    registered as a `ServletContextListener` in the `web.xml` sample, bootstraps Spring's
    root `WebApplicationContext`. In the previous chapter, we saw how a simple console
    application bootstraps the Spring context from inside the main method using `ClassPathXmlApplicationContext`.
    In the case of a web application, following `ContextLoaderListener` loads the
    `WebApplicationContext`. Remember, a Spring MVC application is not just another
    Servlet-based application but rather Spring integrated within a web context.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC应用程序也在`web.xml`中配置和引导。在`web.xml`示例中，`ContextLoaderListener`注册为`ServletContextListener`，引导Spring的根`WebApplicationContext`。在上一章中，我们看到了一个简单的控制台应用程序如何在主方法内部使用`ClassPathXmlApplicationContext`引导Spring上下文。在Web应用程序的情况下，遵循`ContextLoaderListener`加载`WebApplicationContext`。请记住，Spring
    MVC应用程序不仅仅是另一个基于Servlet的应用程序，而是Spring集成在Web上下文中。
- en: '[PRE66]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following listener looks for a `context-param` tag, `contextConfigLocation`,
    which is the location of the Spring root bean definition XML file, as seen in
    the `web.xml` file earlier:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 以下监听器查找`context-param`标签`contextConfigLocation`，这是Spring根bean定义XML文件的位置，如前面的`web.xml`文件中所示：
- en: '[PRE67]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The next very important Spring component configured in the `web.xml` file is
    `DispatcherServlet`, the centralized entry point into the Spring MVC application
    which maps every request with appropriate handlers. `DispatcherServlet` is an
    implementation of the Front Controller design pattern, which is a single, centralized
    entry-point for all HTTP requests that come into the application. This internally
    delegates them to the actual handler of the request type. Here is an excerpt from
    the earlier `web.xml` listing:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`文件中配置的下一个非常重要的Spring组件是`DispatcherServlet`，它是Spring MVC应用程序的集中入口点，将每个请求映射到适当的处理程序。`DispatcherServlet`是前端控制器设计模式的实现，它是应用程序中所有HTTP请求的单一集中入口点。它内部将它们委托给请求类型的实际处理程序。以下是先前`web.xml`列表中的摘录：
- en: '[PRE68]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding Servlet registration of `DispatcherServlet` maps the root URL
    to `DispatcherServlet` so that every HTTP request that comes into the server will
    be first handled by `DispatcherServlet`. Additionally, it specifies where the
    Spring application context file for this Servlet will be.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`的前面Servlet注册将根URL映射到`DispatcherServlet`，以便每个进入服务器的HTTP请求都将首先由`DispatcherServlet`处理。此外，它指定了此Servlet的Spring应用程序上下文文件的位置。'
- en: Note
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your application can have any number of `DispatcherServlet` definitions with
    unique Servlet names, depending on how you want to divide your URL subcontexts
    logically based on your functional modules. Most applications would have just
    one `DispatcherServlet` defined.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以具有任意数量的`DispatcherServlet`定义，具有唯一的Servlet名称，具体取决于您希望根据功能模块在逻辑上如何划分URL子上下文。大多数应用程序只会定义一个`DispatcherServlet`。
- en: ApplicationContext files in a Spring MVC application
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring MVC应用程序中的ApplicationContext文件
- en: A Spring MVC application is nothing but a Servlet-based Web MVC implementation
    with Spring integrated natively. Hence, it requires Spring bean definitions like
    any other Spring application, as we have seen in the previous chapter. In the
    case of a Spring MVC application, there would be some framework-specific beans
    in addition to application-specific beans registered in the context.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC应用程序只是具有Spring本地集成的基于Servlet的Web MVC实现。因此，它需要像任何其他Spring应用程序一样的Spring豆子定义，正如我们在前一章中所看到的。在Spring
    MVC应用程序的情况下，除了应用程序特定的豆子之外，还会有一些特定于框架的豆子在上下文中注册。
- en: For the sake of organizing beans under different logical categories, such as
    web-specific (`DispatcherServlet`) as well as shared beans, multiple bean definitions
    can be used. For example, `DispatcherServlet` can have its own application context
    file with beans helping its processing (just for the web context), and there could
    be a root application context file, where beans that are not specific to the web
    layer but shared between many layers are defined.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将豆子组织在不同的逻辑类别下，例如特定于Web的（`DispatcherServlet`）以及共享的豆子，可以使用多个豆子定义。例如，`DispatcherServlet`可以有自己的应用程序上下文文件，其中定义了帮助其处理的豆子（仅适用于Web上下文），还可以有一个根应用程序上下文文件，其中定义了不特定于Web层但在许多层之间共享的豆子。
- en: Inside the sample listed in the earlier section as part of *Your first Spring
    MVC application*, you can see two Spring bean definition XML files, `root-context.xml`
    and `servlet-context.xml`. The `root-context.xml` file represents your root `WebApplicationContext`
    loaded via `ContextLoaderListener`. This is the place where you define or import
    your shared beans, such as service beans, and data access objects.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前章节列出的示例中，作为*您的第一个Spring MVC应用程序*的一部分，您可以看到两个Spring豆子定义XML文件，`root-context.xml`和`servlet-context.xml`。`root-context.xml`文件代表通过`ContextLoaderListener`加载的根`WebApplicationContext`。这是您定义或导入共享豆子的地方，例如服务豆子和数据访问对象。
- en: The `servlet-context.xml` file is loaded by `DispatcherServlet` on startup.
    The filename, `servlet-context.xml`, is an explicit filename given in the sample
    listing. By default, `DispatcherServlet` looks for an XML bean definition file
    with the pattern `[servlet-name]-servlet.xml`, that is, if it wasn't specified
    explicitly, `appServlet` would look for a file with the name `appServlet-servlet.xml`
    at the root of the `WEB-INF` folder. Typically, this file contains the bean definitions
    controlling the behavior of this Servlet. For example, you can see the resources
    and view resolver bean definitions in the file `servlet-context.xml`. You can
    see that the view resolver configured in the sample listing only supports JSP
    views.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`servlet-context.xml`文件在启动时由`DispatcherServlet`加载。文件名`servlet-context.xml`是示例清单中明确给出的文件名。默认情况下，`DispatcherServlet`会寻找具有模式`[servlet-name]-servlet.xml`的XML豆子定义文件，也就是说，如果没有明确指定，`appServlet`将在`WEB-INF`文件夹的根目录中寻找名为`appServlet-servlet.xml`的文件。通常，此文件包含控制此Servlet行为的豆子定义。例如，您可以在文件`servlet-context.xml`中看到资源和视图解析器豆子定义。您可以看到示例清单中配置的视图解析器仅支持JSP视图。'
- en: HomeController – @Controller for the home screen
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HomeController - 主屏幕的@Controller
- en: '`HomeController` is a simple POJO with the `@Controller` annotation. This annotation
    registers it as a web controller with a set of annotated handler methods inside
    it. It can have an `@RequestMapping` annotation at the class level to indicate
    the root URL of all handler methods in it. The method `home()` is the request
    handler for the root URL, `http://<context-root>/`.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeController`是一个带有`@Controller`注释的简单POJO。此注释将其注册为具有一组注释处理程序方法的Web控制器。它可以在类级别具有`@RequestMapping`注释，以指示其中所有处理程序方法的根URL。`home()`方法是根URL
    `http://<context-root>/`的请求处理程序。'
- en: Since the `@Controller` annotation is yet another Spring bean, you can inject
    any other bean into it as a dependency. The sample listing shows that `HomeController`
    has an autowired dependency to `TaskService`. In the `home()` method, `TaskService`
    methods are invoked, and finally, the return values are set as `Model` attributes
    for the consumption of the latter parts of the request and to be used in a view.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@Controller`注释是另一个Spring豆子，因此您可以将任何其他豆子注入其中作为依赖项。示例清单显示`HomeController`具有对`TaskService`的自动装配依赖项。在`home()`方法中，调用了`TaskService`方法，最后，将返回值设置为`Model`属性，以供请求的后续部分使用并在视图中使用。
- en: Your application will have many such controllers that serve groups of related
    URL endpoints; consider `HomeController` as your basic example. One controller
    can have multiple request-handling methods that serve different URLs.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将有许多这样的控制器，用于服务相关URL端点的组。将`HomeController`视为您的基本示例。一个控制器可以有多个处理请求的方法，用于服务不同的URL。
- en: The home.jsp file – the landing screen
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: home.jsp文件 - 登陆屏幕
- en: 'The `home.jsp` file is your view artifact for the root (`/`) URL. Notice how
    the `Model` attributes are bound inside the JSP view:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.jsp`文件是根（`/`）URL的视图工件。请注意`Model`属性如何在JSP视图中绑定：'
- en: '[PRE69]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Handling incoming requests
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理传入请求
- en: Any request that hits the root URL of the app is first received by `DispatcherServlet`,
    which delegates it to `HomeController.home()`, which processes the request and
    returns the view name (`home`, in this case). `DispatcherServlet` then picks up
    the `home.jsp` file based on the resource and view configurations specified in
    `servlet-context.xml` and renders it, passing the attributes of the model instance
    created inside `HomeController.home()`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命中应用程序根URL的请求首先由`DispatcherServlet`接收，然后将其委托给`HomeController.home()`，该方法处理请求并返回视图名称（在本例中为`home`）。然后，`DispatcherServlet`根据在`servlet-context.xml`中指定的资源和视图配置选择`home.jsp`文件并进行渲染，传递在`HomeController.home()`中创建的模型实例的属性。
- en: The architecture and components of Spring MVC
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC的架构和组件
- en: 'Having gone through your first Spring MVC application, it is now time to look
    at Spring MVC applications from an architectural perspective:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 通过您的第一个Spring MVC应用程序后，现在是时候从架构的角度来看Spring MVC应用程序了。
- en: '![The architecture and components of Spring MVC](img/image00784.jpeg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![Spring MVC的架构和组件](img/image00784.jpeg)'
- en: Spring MVC components
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC组件
- en: 'As the name implies, Spring MVC follows the renowned MVC architectural pattern.
    This pattern ensures the separation of concerns by dividing responsibilities into
    three major roles:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，Spring MVC遵循着著名的MVC架构模式。这种模式通过将责任分为三个主要角色来确保关注点的分离：
- en: '**Model**: This represents data and business logic'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：代表数据和业务逻辑'
- en: '**View**: This represents presentation'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：代表呈现'
- en: '**Controller**: This processes client requests and delegates them to the view
    for rendering back to the client'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：处理客户端请求并将其委托给视图以返回给客户端进行呈现'
- en: The **Model** we are talking about here is not necessarily persistent data (a
    data model) as such; rather, it represents the information passed back and forth
    between the client and different layers of the server application, which form
    the building blocks of any system.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里谈论的“模型”不一定是持久数据（数据模型）本身；相反，它代表了客户端和服务器应用程序的不同层之间传递的信息，这些信息构成了任何系统的基本构件。
- en: Besides the **Model**, **View**, and **Controller** components, `DispatcherServlet`
    too plays a crucial role in the Spring MVC architecture. It acts as the Front
    Controller, a popular J2EE design pattern adopted by many MVC Frameworks. In fact,
    `DispatcherServlet` does much more than just a Front Controller. It will be explained
    in detail in the next section.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“模型”、“视图”和“控制器”组件之外，`DispatcherServlet`在Spring MVC架构中也扮演着至关重要的角色。它充当了前端控制器，这是许多MVC框架采用的流行J2EE设计模式。实际上，`DispatcherServlet`不仅仅是一个前端控制器。这将在下一节中详细解释。
- en: In a Spring MVC application, `DispatcherServlet` first receives a client request
    hitting the server via HTTP with a URL. With the help of the `HandlerMapping`
    configuration, `DipatcherServlet` finds the appropriate **Controller** method
    for the request based on the URL pattern and delegates the request to it. The
    Controller processes the request, optionally fills in the **Model** object, and
    returns the name of the **View** to be rendered. `DispatcherServlet` then picks
    the **View** up and renders it back on the client after applying the attributes
    of the **Model** to the placeholders in the **View**.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC应用程序中，`DispatcherServlet`首先接收通过HTTP命中服务器的客户端请求的URL。通过`HandlerMapping`配置的帮助，`DispatcherServlet`根据URL模式找到适当的**控制器**方法，并将请求委托给它。控制器处理请求，可选地填充**模型**对象，并返回要呈现的**视图**的名称。`DispatcherServlet`然后选择**视图**并将其呈现回客户端，将**模型**的属性应用于**视图**中的占位符。
- en: What's mentioned in the previous paragraph is simply the typical request processing
    flow of Spring MVC. However, it is extremely flexible, with a great many options
    to support different types of view technologies and input and output structures
    and formats, including files, streams, and so on. We will explore them more in
    the following sections.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 前面段落提到的只是Spring MVC的典型请求处理流程。然而，它非常灵活，有很多选项来支持不同类型的视图技术和输入输出结构和格式，包括文件、流等等。我们将在接下来的部分中更详细地探讨它们。
- en: DispatcherServlet explained
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释了DispatcherServlet
- en: '`DispatcherServlet` is the gateway to any Spring MVC application. Inherited
    from `javax.servlet.http.HttpServlet`, it is typically configured declaratively
    in the `web.xml` file. While you can have multiple definitions of `DispatcherServlet`
    with unique URL patterns, most Spring MVC applications only have single `DispatcherServlet`
    with the `context-root` URL(`/`), that is, all requests coming to that domain
    will be handled by `DispatcherServlet`.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`是任何Spring MVC应用程序的入口。它继承自`javax.servlet.http.HttpServlet`，通常在`web.xml`文件中进行声明式配置。虽然您可以有多个具有唯一URL模式的`DispatcherServlet`的定义，但大多数Spring
    MVC应用程序只有一个`DispatcherServlet`，其`context-root` URL（`/`），也就是说，所有请求都将由`DispatcherServlet`处理。'
- en: 'Starting from Servlet 3.0, in addition to declarative configuration in the
    `web.xml` file, `DispatcherServlet` can be configured programmatically by implementing
    or extending either of these three support classes provided by Spring:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 从Servlet 3.0开始，除了在`web.xml`文件中进行声明式配置外，`DispatcherServlet`还可以通过实现或扩展Spring提供的这三个支持类之一来进行编程配置：
- en: The `WebAppInitializer` interface
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAppInitializer`接口'
- en: The `AbstractDispatcherServletInitializer` abstract class
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractDispatcherServletInitializer`抽象类'
- en: The `AbstractAnnotationConfigDispatcherServletInitializer` abstract class
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractAnnotationConfigDispatcherServletInitializer`抽象类'
- en: 'The following code listing demonstrates how to implement a `WebAppInitializer`
    directly in your application:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清单演示了如何直接在应用程序中实现`WebAppInitializer`：
- en: '[PRE70]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: WebApplicationContext – ApplicationContext for the Web
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebApplicationContext - Web的ApplicationContext
- en: '`DispatcherServlet` uses a specialized `ApplicationContext` called `WebApplicationContext`
    that has many web request processing capabilities. It is aware of which `ServletContext`
    it is associated with and is also capable of resolving themes. This interface
    has concrete implementations for specific contexts such as XML, `@Configuration`
    annotated classes, and portlets. By default, `DispatcherServlet` uses `XMLWebApplicationContext`.
    When `DispatcherServlet` is loaded, it looks for the bean configuration file of
    `WebApplicationContext` and initializes it.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`使用了一个名为`WebApplicationContext`的专门的`ApplicationContext`，具有许多web请求处理功能。它知道它关联的是哪个`ServletContext`，并且还能够解析主题。这个接口有具体的实现，用于特定的上下文，比如XML，`@Configuration`注解的类和portlet。默认情况下，`DispatcherServlet`使用`XMLWebApplicationContext`。当`DispatcherServlet`加载时，它会查找`WebApplicationContext`的bean配置文件并对其进行初始化。'
- en: '`WebApplicationContext` objects are hierarchical. Every Spring MVC application
    has root `ApplicationContext` (configurable with a `context-param` tag called
    `contextConfigLocation` in the `web.xml` file), and each Servlet, including `DispatcherServlet`,
    has its own child context (configurable by its own `init-param`, `contextConfigLocation`).
    Ideally, Servlet-specific child contexts have beans customizing that Servlet,
    and root `ApplicationContext` has all shared beans.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplicationContext`对象是分层的。每个Spring MVC应用程序都有一个根`ApplicationContext`（可以在`web.xml`文件中的`context-param`标签中配置为`contextConfigLocation`），每个Servlet，包括`DispatcherServlet`，都有自己的子上下文（可以通过自己的`init-param`，`contextConfigLocation`进行配置）。理想情况下，Servlet特定的子上下文具有自定义该Servlet的bean，而根`ApplicationContext`具有所有共享的bean。'
- en: Beans supporting DispatcherServlet and their roles
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持DispatcherServlet的bean及其角色
- en: 'Upon receiving a web request, `DispatcherServlet` performs a set of operations
    in sequence as part of the request processing, with the help of a set of supporting
    beans. This table lists these special beans and their responsibilities:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 收到web请求后，`DispatcherServlet`在请求处理的过程中依次执行一系列操作，借助一组支持bean的帮助。此表列出了这些特殊bean及其职责：
- en: '| Bean | Responsibilities |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| Bean | 职责 |'
- en: '| --- | --- |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `HandlerMapping` | Maps incoming web requests to handlers and pre- and post-processors
    |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `HandlerMapping` | 将传入的web请求映射到处理程序和前后处理器 |'
- en: '| `HandlerAdapter` | Invokes the handler which resolves arguments and dependencies,
    such as annotated arguments for URL-mapped controller method endpoints |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `HandlerAdapter` | 调用解析参数和依赖项的处理程序，例如URL映射控制器方法端点的注释参数 |'
- en: '| `HandlerExceptionResolver` | Allows programmatic handling of exceptions and
    maps exceptions to views |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `HandlerExceptionResolver` | 允许以编程方式处理异常并将异常映射到视图 |'
- en: '| `ViewResolver` | Resolves logical view names to view instances |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `ViewResolver` | 将逻辑视图名称解析为视图实例 |'
- en: '| `LocaleResolver` | Resolves the client''s locale in order to enable internationalization
    |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `LocaleResolver` | 解析客户端的区域设置以实现国际化 |'
- en: '| `LocaleContextResolver` | A richer extension of `LocaleResolver`, with timezone
    information |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `LocaleContextResolver` | `LocaleResolver`的更丰富的扩展，带有时区信息 |'
- en: '| `ThemeResolver` | Resolves themes configured in your app for enhanced user
    experience |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `ThemeResolver` | 解析应用程序中配置的主题，以增强用户体验 |'
- en: '| `MultipartResolver` | Handles multipart file uploads as part of HTTP requests
    |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `MultipartResolver` | 处理HTTP请求中的多部分文件上传 |'
- en: '| `FlashMapManager` | Manages FlashMap instances that store temporary Flash
    attributes between requests redirected from one another |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| `FlashMapManager` | 管理FlashMap实例，用于在重定向的请求之间存储临时Flash属性 |'
- en: '`DispatcherServlet` is extremely flexible; we can even create and configure
    custom implementations for all these beans. However, Spring MVC provides a set
    of nice implementations by default so that you don''t need to customize or provide
    your own implementations unless absolutely required. These default implementations
    can be found inside `org.springframework.web.servlet.DispatcherServlet.properties`.
    If you override them with your own implementation of any of these beans, yours
    will override the defaults.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`非常灵活；我们甚至可以为所有这些bean创建和配置自定义实现。但是，Spring MVC默认提供了一组很好的实现，因此除非绝对需要，否则您不需要自定义或提供自己的实现。这些默认实现可以在`org.springframework.web.servlet.DispatcherServlet.properties`中找到。如果您用自己的实现覆盖了这些bean中的任何一个，您的实现将覆盖默认值。'
- en: Controllers in detail
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细的控制器
- en: Controllers, with their methods annotated with `@RequestMapping`, handle web
    requests. They accept input data in multiple forms and transform them into `Model`
    attributes to be consumed by views that are displayed back to the client. They
    connect the user to service-layer beans, where your application behavior is defined.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器，其方法带有`@RequestMapping`注解，处理web请求。它们以多种形式接受输入数据，并将其转换为`Model`属性，以供视图消费，然后显示给客户端。它们将用户连接到服务层bean，其中定义了应用程序行为。
- en: 'A Controller in Spring MVC has the following signature:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC中的控制器具有以下签名：
- en: '[PRE71]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A Controller is designed as an interface, allowing you to create any kind of
    implementation. Starting from Spring version 2.5, you can turn any class into
    a Controller just by annotating it with `@Controller`. It relieves you from implementing
    any specific interface or extending a framework-specific class:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器被设计为一个接口，允许您创建任何类型的实现。从Spring版本2.5开始，您可以通过使用`@Controller`对任何类进行注释，将其转换为控制器。这使您无需实现任何特定的接口或扩展特定于框架的类：
- en: '[PRE72]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `@Controller` annotation assigns the role of a Controller to the given
    class. A Spring MVC application autodetects all the controllers in its classpath
    and registers them with `WebApplicationContext` if you enable component scanning,
    as shown here:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Controller`注解将给定类指定为控制器的角色。Spring MVC应用程序会自动检测其类路径中的所有控制器，并在启用组件扫描时将它们注册到`WebApplicationContext`中，如下所示：'
- en: '[PRE73]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`@Controller`, `@RequestMapping`, and a set of other annotations form the basis
    of Spring MVC. These annotations allow flexible method names and signatures for
    controllers. We will explore them in detail in the following section.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Controller`，`@RequestMapping`和一组其他注解构成了Spring MVC的基础。这些注解允许控制器具有灵活的方法名称和签名。我们将在下一节中详细探讨它们。'
- en: Mapping request URLs with @RequestMapping
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@RequestMapping映射请求URL
- en: 'The `@RequestMapping` annotation maps request URLs onto an entire `@Controller`
    class or its handler methods. It can be applied at the class as well as the method
    levels. Typically, you apply class-level `@RequestMapping` annotation to map a
    group of related URLs, such as a form with many actions, and method-level `@RequestMapping`
    annotation for specific actions, such as create, read, update, delete, upload,
    and download. Let''s take a look at a typical form-based Controller with various
    actions in a pure REST model (`GET`, `POST`, `PUT`, and `DELETE`):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping`注解将请求URL映射到整个`@Controller`类或其处理程序方法。它可以应用于类级别和方法级别。通常，您将类级别的@RequestMapping注解应用于映射一组相关的URL，例如具有多个操作的表单，而方法级别的@RequestMapping注解用于特定操作，例如创建、读取、更新、删除、上传和下载。让我们来看一个典型的基于表单的控制器，其中包含纯REST模型的各种操作（`GET`，`POST`，`PUT`和`DELETE`）：'
- en: '[PRE74]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`UserController`, listed in the preceding code, has methods that serve as request
    handlers for URLs representing CRUD operations on user entities with the help
    of `UserService`, which is injected as a dependency into the Controller. Since
    this Controller is based on web views, the handler methods fill up the Model and
    returns either a view name or `ModelAndView` object for further display. The final
    two handler methods, `updateUser()` and `deleteUser()`, redirect the requests
    at the end. They perform URL redirection after returning the response to the client.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中列出的`UserController`具有作为请求处理程序的方法，用于表示对用户实体进行CRUD操作的URL，并借助`UserService`作为依赖项注入到控制器中。由于这个控制器是基于Web视图的，处理程序方法填充模型并返回视图名称或`ModelAndView`对象以供进一步显示。最后两个处理程序方法`updateUser()`和`deleteUser()`在返回响应后重定向请求。它们在最后执行URL重定向，将响应返回给客户端。
- en: 'Notice that `UserController` has a root URL (`/user`) and handler methods have
    a more narrow mapping with a combination of HTTP methods. They are invoked by
    the exact URLs seen in the following table:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`UserController`有一个根URL（`/user`），处理程序方法具有更窄的映射，使用HTTP方法的组合。它们由以下表中看到的确切URL调用：
- en: '| URL | Handler method | HTTP method | Matching URL (sample) |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| URL | 处理程序方法 | HTTP方法 | 匹配的URL（示例） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `/` | `listAllUsers` | `GET` | `http://localhost:8080/user` |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `listAllUsers` | `GET` | `http://localhost:8080/user` |'
- en: '| `/new` | `newuserForm` | `GET` | `http://localhost:8080/user/new` |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| `/new` | `newuserForm` | `GET` | `http://localhost:8080/user/new` |'
- en: '| `/new` | `saveNewUser` | `POST` | `http://localhost:8080/user/new` |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| `/new` | `saveNewUser` | `POST` | `http://localhost:8080/user/new` |'
- en: '| `/{id}` | `viewUser` | `GET` | `http://localhost:8080/user/123` |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| `/{id}` | `viewUser` | `GET` | `http://localhost:8080/user/123` |'
- en: '| `/{id}/edit` | `editUser` | `GET` | `http://localhost:8080/user/123/edit`
    |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `/{id}/edit` | `editUser` | `GET` | `http://localhost:8080/user/123/edit`
    |'
- en: '| `/{id}` | `updateUser` | `PUT` | `http://localhost:8080/user/123` |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `/{id}` | `updateUser` | `PUT` | `http://localhost:8080/user/123` |'
- en: '| `/{id}` | `deleteUser` | `DELETE` | `http://localhost:8080/user/123` |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| `/{id}` | `deleteUser` | `DELETE` | `http://localhost:8080/user/123` |'
- en: 'The HTTP methods `GET` and `POST` are supported by default, in line with the
    limited HTML (hence browser) support for the other two. However, for `PUT` and
    `DELETE` to work, you need to register `HiddenHttpMethodFilter` in your `web.xml`
    file. Use this code:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下支持`GET`和`POST`方法，与HTML（因此浏览器）对其他两种方法的有限支持一致。但是，要使`PUT`和`DELETE`方法工作，您需要在`web.xml`文件中注册`HiddenHttpMethodFilter`。使用以下代码：
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`HiddenHttpMethodFilter` works even without Spring MVC; you can use it with
    any Java web framework or even a plain Servlet application.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`HiddenHttpMethodFilter`即使在没有Spring MVC的情况下也可以工作；您可以将其与任何Java Web框架甚至纯Servlet应用程序一起使用。'
- en: URI template patterns with the @PathVariable annotation
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有@PathVariable注解的URI模板模式
- en: 'In the sample `UserController` listing in the preceding code, you might have
    noticed templated URL patterns with variable names replaced by values when handling
    requests. See this, for example:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中的示例`UserController`列表中，您可能已经注意到处理请求时使用变量名称替换为值的模板化URL模式。例如：
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, the templated variable, `id`, is mapped to an `@PathVariable` annotation.
    It is enclosed inside curly braces and annotated as a method argument for mapping.
    A URL can have any number of path variables. They support regular expressions
    as well as path patterns in the Apache Ant style. They help you build perfect
    URI endpoints in the classic REST model.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板变量`id`被映射到`@PathVariable`注解。它被包含在大括号中，并被注释为映射的方法参数。URL可以有任意数量的路径变量。它们支持正则表达式以及Apache
    Ant风格的路径模式。它们帮助您在经典的REST模型中构建完美的URI端点。
- en: Binding parameters with the @RequestParam annotation
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@RequestParam注解绑定参数
- en: 'Request parameters that are inline with URI strings can be mapped with method
    arguments using the `@RequestParam` annotation. See the following excerpt from
    `TaskController`:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 与URI字符串内联的请求参数可以使用@RequestParam注解与方法参数进行映射。请参阅`TaskController`中的以下摘录：
- en: '[PRE77]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A typical URL invoking the above handler is `http:<context-root>/tasks?status=Open`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上述处理程序的典型URL是`http:<context-root>/tasks?status=Open`。
- en: '`@RequestParam` has four attributes: `name`, `required`, `value`, and `defaultValue`.
    While `name` is a mandatory attribute, all the others are optional. By default,
    all request parameters are required to be set to `true`, unless you specify them
    as `false`. Values of `@RequestParam` are automatically type-converted to parameter
    types by Spring.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestParam`有四个属性：`name`，`required`，`value`和`defaultValue`。`name`是一个必需的属性，其他所有属性都是可选的。默认情况下，所有请求参数都需要设置为`true`，除非您将它们指定为`false`。Spring会自动将@RequestParam的值转换为参数类型。'
- en: Request handler method arguments
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求处理程序方法参数
- en: The `@RequestMapping` methods can have flexible method signatures; a mix of
    frameworks, custom objects, and annotations are supported. They are injected automatically
    during request processing if found as method arguments. Here is a list of a few
    supported framework classes and annotations; refer to the Spring official documentation
    or the Javadoc of `RequestMapping` for the complete list.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping`方法可以具有灵活的方法签名；支持混合框架，自定义对象和注解。如果在方法参数中找到，它们将在请求处理期间自动注入。以下是一些受支持的框架类和注解的列表；请参阅Spring官方文档或`RequestMapping`的Javadoc以获取完整列表。'
- en: '| Supported classes | Annotations |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 支持的类 | 注解 |'
- en: '| --- | --- |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `javax.servlet.ServletRequest` | `@PathVariable` |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.ServletRequest` | `@PathVariable` |'
- en: '| `javax.servlet.ServletRequest` | `@RequestVariable` |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.ServletRequest` | `@RequestVariable` |'
- en: '| `javax.servlet.http.HttpSession` | `@RequestParam` |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.http.HttpSession` | `@RequestParam` |'
- en: '| `org.springframework.ui.Model` | `@RequestHeader` |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.ui.Model` | `@RequestHeader` |'
- en: '| `org.springframework.validation.BindingResult` | `@RequestBody` |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.validation.BindingResult` | `@RequestBody` |'
- en: '| `Java.util.Map` | `@RequestPart` |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| `Java.util.Map` | `@RequestPart` |'
- en: '| `Java.io.InputStream` | `@InitBinder` |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| `Java.io.InputStream` | `@InitBinder` |'
- en: While the framework classes do not need any specific annotation, custom classes
    often need to accompany one of the supported annotations for the handler adapters
    in order to convert/format from the incoming web request object into the class
    instances.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然框架类不需要任何特定的注解，但自定义类通常需要在处理程序适配器中伴随受支持的注解之一，以将传入的Web请求对象转换/格式化为类实例。
- en: Request handler method return types
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求处理程序方法返回类型
- en: 'Similar to flexible argument types, methods annotated by `@RequestMapping`
    can have either custom types (often annotated as `@ResponseBody`) or one of the
    many supported framework classes. The following list contains some of the many
    supported types:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 与灵活的参数类型类似，由`@RequestMapping`注解的方法可以具有自定义类型（通常注释为`@ResponseBody`）或许多受支持的框架类之一。以下列表包含许多受支持的类型之一：
- en: '`org.springframework.web.servlet.ModelAndView`'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.web.servlet.ModelAndView`'
- en: '`org.springframework.ui.Model`'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.ui.Model`'
- en: '`java.util.Map`'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Map`'
- en: '`org.springframework.web.servlet.View`'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.web.servlet.View`'
- en: '`java.lang.String`'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`'
- en: '`void`'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`java.util.concurrent.Callable<?>`'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Callable<?>`'
- en: '`org.springframework.http.HttpEntity`'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.http.HttpEntity`'
- en: Setting Model attributes
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模型属性
- en: '`Model` attributes are for the consumption of the view for display and binding
    with form elements. They can be set at both the controller and handler method
    level.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model`属性用于视图的显示和与表单元素的绑定。它们可以在控制器和处理程序方法级别设置。'
- en: 'Any method with a non-void return type can be annotated as `@ModelAttribute`
    to make the method return type a `Model` attribute for all views resolved by the
    declared Controller. See an example:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有非void返回类型的方法都可以被注释为`@ModelAttribute`，以使方法返回类型成为由声明的Controller解析的所有视图的`Model`属性。看一个例子：
- en: '[PRE78]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Model attributes specific to a view are set inside the handler method from
    where the view was resolved. Here is an example:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于视图的模型属性在视图解析的处理程序方法内设置。以下是一个例子：
- en: '[PRE79]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Building RESTful services for JSON and XML media
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为JSON和XML媒体构建RESTful服务
- en: A web application often needs to expose some of its services as web APIs with
    the XML or JSON data formats, or both, for the consumption of AJAX requests from
    browsers as well as other devices, such as mobile and tablets.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常需要将其一些服务公开为Web API，使用XML或JSON数据格式，或两者兼而有之，以供浏览器以及移动设备和平板电脑的AJAX请求消费。
- en: '**REpresentational State Transfer** (**REST**), is an established architectural
    style for building web APIs that align with native web protocols and methods.
    With REST, data is represented as resources that can be accessed and manipulated
    using a URI over the stateless protocol of HTTP. REST insists on the mapping of
    the create, read, update, and delete operations (CRUD) around a resource with
    the HTTP methods `POST`, `GET`, `PUT`, and `DELETE`, respectively.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**REpresentational State Transfer** (**REST**), 是一种建立与原生Web协议和方法一致的Web API的已建立的架构风格。使用REST，数据被表示为资源，可以使用HTTP的无状态协议通过URI访问和操作。REST坚持使用HTTP方法`POST`，`GET`，`PUT`和`DELETE`来映射对资源的创建，读取，更新和删除操作（CRUD）。'
- en: 'Spring MVC makes it extremely easy to build simple API endpoints that consume
    and produce different media types such as text, JSON, and XML. A request handler
    method in an `@Controller` annotation can accept JSON, XML, or any other media
    type using the following two steps:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC非常容易构建简单的API端点，以消费和生成不同的媒体类型，如文本，JSON和XML。`@Controller`注解中的请求处理程序方法可以使用以下两个步骤接受JSON，XML或任何其他媒体类型：
- en: Set the attribute `consumes` to the appropriate media type(s) at the `RequestMapping`
    method, for example, `consumes = {"text/plain", "application/json"})`.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RequestMapping`方法中将属性`consumes`设置为适当的媒体类型（例如`consumes = {"text/plain", "application/json"})`。
- en: Annotate the method argument of the required type with `@RequestBody`. The web
    request is expected to contain the data in the format mentioned in step 1 (`consumes`;
    JSON, XML, and so on) and is resolved to this type by `HttpMessageConverter` during
    handling.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@RequestBody`注释所需类型的方法参数。Web请求应包含在步骤1（`consumes`；JSON，XML等）中提到的格式的数据，并在处理期间由`HttpMessageConverter`解析为此类型。
- en: 'Similarly, the request handler method can produce JSON, XML, or any other media
    type using the following two steps:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，请求处理程序方法可以使用以下两个步骤生成JSON，XML或任何其他媒体类型：
- en: Set the attribute `produces` with the appropriate media type(s) at the `RequestMapping`
    method, for example, `consumes = {"text/plain", "application/json"})`.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RequestMapping`方法中将属性`produces`设置为适当的媒体类型（例如`consumes = {"text/plain", "application/json"})`。
- en: Annotate the return type of the handler method or the method declaration itself
    (next to `@RequestMapping`) with `@ResponseBody`. The handler will transform the
    return value into the data format specified in the `produces` attribute of `RequestMapping`.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序方法的返回类型或方法声明本身（紧邻`@RequestMapping`）旁边使用`@ResponseBody`进行注解。处理程序将返回值转换为`RequestMapping`中指定的数据格式。
- en: The `consumes` and `produces` attributes of `RequestMapping` narrow down the
    primary mapping to the given media type (for example, `consumes = "application/xml"`)
    or a sequence of media types (for example, `consumes = {"text/plain", "application/json"}`).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestMapping`的`consumes`和`produces`属性将主映射缩小到给定的媒体类型（例如`consumes = "application/xml"`）或一系列媒体类型（例如`consumes
    = {"text/plain", "application/json"}`）。'
- en: 'In addition to the attributes, make sure the following library exists in the
    `pom.xml` file:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性之外，确保`pom.xml`文件中存在以下库：
- en: '[PRE80]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here is an example handler method that accepts a JSON request and returns a
    JSON response:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个接受JSON请求并返回JSON响应的示例处理程序方法：
- en: '[PRE81]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This handler method expects a web request with JSON content:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序方法期望带有JSON内容的web请求：
- en: '[PRE82]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, the same method could be modified slightly to support XML content, `consumes`
    as well as `produces`. Look at the following listing:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，同样的方法可以稍作修改以支持XML内容，`consumes`和`produces`。看一下以下清单：
- en: '[PRE83]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Make sure you have the JAXB annotation `@XmlRootElement` at the root of both
    `RequestBody` and `ResponseBody` types (`CreateTaskRequest` and `CreateTaskResponse`
    in this case).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`RequestBody`和`ResponseBody`类型的根部分（在这种情况下是`CreateTaskRequest`和`CreateTaskResponse`）存在JAXB注解`@XmlRootElement`。
- en: 'You can invoke the preceding XML handler by sending the following content with
    the web request to the handler URI:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向处理程序URI发送以下内容的web请求来调用前面的XML处理程序：
- en: '[PRE84]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Building a RESTful service with RestController
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RestController构建RESTful服务
- en: '`RestController` is a convenient stereotype provided for building REST API
    endpoints that serve custom media types such as JSON or XML. It combines `@Controller`
    with `@ResponseBody`, that is, you do not need to annotate `@ResponseBody` in
    the handler methods. `@RequestMapping` methods assume `@ResponseBody` semantics
    by default.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestController`是一个方便的构建REST API端点的约定，可以提供自定义媒体类型，比如JSON或XML。它将`@Controller`与`@ResponseBody`结合在一起，也就是说，在处理程序方法中不需要注解`@ResponseBody`。`@RequestMapping`方法默认假定`@ResponseBody`语义。'
- en: 'Let''s see what the JSON handler method looks like when it becomes part of
    an `@RestController` annotation:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当JSON处理程序方法成为`@RestController`注解的一部分时是什么样子：
- en: '[PRE85]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that the only difference in the mapping is the missing `@ResponseBody`
    annotation. It is best practice to define your REST APIs inside REST controllers.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，映射中唯一的区别是缺少`@ResponseBody`注解。最佳实践是在REST控制器内定义REST API。
- en: Asynchronous request processing in Spring MVC
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC中的异步请求处理
- en: In an age of APIs, AJAX clients, and devices, web servers are under exponentially
    growing traffic. Figuring out ways to make servers more scalable is an ongoing
    challenge for server vendors. The traditional **one thread per HTTP connection**
    strategy does not scale well for a bigger number of concurrent user access. In
    this model, every request blocks a thread from the thread pool allocated by the
    Servlet container until the request is completely processed (the examples shown
    so far follow this model). When AJAX clients—where a single screen frequently
    fires multiple concurrent connection requests—join the traditional, blocking I/O
    model of web servers with long-running processes, servers easily get exhausted
    due to the thread starvation problem, since no free thread is available in the
    pool. This makes the application unavailable on increased load.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在API、AJAX客户端和设备的时代，Web服务器的流量呈指数增长。找到使服务器更具可伸缩性的方法是服务器供应商面临的持续挑战。传统的**每个HTTP连接一个线程**策略对于更多并发用户访问并不具备良好的可伸缩性。在这种模型中，每个请求都会阻塞Servlet容器分配的线程池中的一个线程，直到请求完全处理完毕（到目前为止所示的示例都遵循这种模型）。当AJAX客户端（其中一个屏幕经常会发出多个并发连接请求）与长时间运行的进程结合在一起时，由于线程饥饿问题，服务器很容易因为没有空闲线程可用而耗尽。这使得应用程序在负载增加时不可用。
- en: Asynchronous HTTP request processing is a technique that utilizes the non-blocking
    I/O capability of the Java platform's NIO API. In this model, a server thread
    is not constantly attached to a persistent HTTP connection during the whole request
    processing. The Servlet container releases the container thread as soon as the
    request is received and further processing is delegated to a thread managed by
    another application (Spring, in this case) so that the container thread is free
    to serve new incoming requests. This non-blocking request processing model saves
    a lot of server resources and steadily increases the scalability of the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 异步HTTP请求处理是一种利用Java平台NIO API的非阻塞I/O能力的技术。在这种模型中，服务器线程在整个请求处理过程中不会一直附加到持久的HTTP连接上。一旦接收到请求，Servlet容器就会释放容器线程，并将进一步处理委托给另一个应用程序（在这种情况下是Spring）管理的线程，以便容器线程可以自由地为新的传入请求提供服务。这种非阻塞请求处理模型节省了大量服务器资源，并稳定地增加了服务器的可伸缩性。
- en: 'Servlet 3.0 introduced asynchronous processing support, and Spring has implemented
    this support starting from Spring 3.2\. As of 4.2, Spring provides two easy ways
    of defining asynchronous request handlers:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 3.0引入了异步处理支持，Spring从Spring 3.2开始实现了这种支持。截至4.2，Spring提供了两种定义异步请求处理程序的简单方法：
- en: Returning a `java.util.concurrent.Callable` instance instead of a value and
    producing the actual return value form inside the `call` method of `Callable`,
    that is, a thread managed by Spring, instead of a Servlet container
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`java.util.concurrent.Callable`实例而不是值，并在`Callable`的`call`方法中生成实际的返回值，也就是由Spring管理的线程，而不是Servlet容器。
- en: Returning an instance of the Spring-specific `DeferredResult` type and producing
    the actual return value form inside any other thread or external event, such as
    JMS or a Quartz scheduler
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回Spring特定的`DeferredResult`类型的实例，并在任何其他线程或外部事件中生成实际的返回值，比如JMS或Quartz调度程序
- en: 'Both these methods release the container thread at the earliest possible opportunity
    and use external threads to continue long-running transactions asynchronously.
    Let''s look at an example for the first option, that is, using `Callable`:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会尽早释放容器线程，并使用外部线程异步地继续长时间运行的事务。让我们来看一个使用`Callable`的示例：
- en: '[PRE86]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this method, you can see that the handler method returns the `Callable` object
    immediately after receiving the request and without waiting for the `Callable.call()`
    method to execute. Spring MVC invokes the `call()` method in another thread using
    `TaskExecutor`, and the response is dispatched back to the Servlet container once
    the `call()` method returns the value.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，您可以看到处理程序方法在收到请求后立即返回`Callable`对象，而不等待`Callable.call()`方法执行。Spring MVC使用`TaskExecutor`在另一个线程中调用`call()`方法，并在`call()`方法返回值后将响应分派回Servlet容器。
- en: 'The following is an example of how to use `DeferredResult`:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`DeferredResult`的示例：
- en: '[PRE87]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Remember, you must enable asynchronous processing support in `DispatcherServlet`
    as well as for all Servlet filters declared in the `web.xml` file (or wherever
    you are defining them—maybe in the JavaConfig class) for it to work. The following
    code shows how you set it in `web.xml`:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您必须在`DispatcherServlet`以及在`web.xml`文件（或者您定义它们的任何地方，也许是在JavaConfig类中）中声明的所有Servlet过滤器中启用异步处理支持，才能使其工作。以下代码显示了如何在`web.xml`中设置它：
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You may choose any of the preceding approaches as per your convenience to enable
    asynchronous processing. Consider designing all your non-trivial services to work
    asynchronously for high scalability and performance.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据自己的方便选择前面提到的任何方法来启用异步处理。考虑为了高可伸缩性和性能，设计所有非平凡的服务都能异步工作。
- en: Working with views
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理视图
- en: Spring MVC provides a very flexible view resolution mechanism that is fully
    decoupled from the other elements of the MVC framework. It does not force you
    to use a particular view technology; rather, it makes it easier to use your own
    favorite technology. It even allows you to mix and match multiple technologies
    at the view tier. Spring MVC provides out-of-the-box support for JPS, XSLT, and
    Velocity views.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC提供了一个非常灵活的视图解析机制，它与MVC框架的其他元素完全解耦。它不会强迫您使用特定的视图技术；相反，它使您更容易使用您自己喜欢的技术。它甚至允许您在视图层混合和匹配多种技术。Spring
    MVC提供了对JPS、XSLT和Velocity视图的开箱即用支持。
- en: Resolving views
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析视图
- en: In a typical Spring MVC application, the developer chooses a view technology
    of his choice and accordingly uses a `ViewResolver` that resolves views built
    using that technology.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Spring MVC应用程序中，开发人员选择自己喜欢的视图技术，并相应地使用解析使用该技术构建的视图的`ViewResolver`。
- en: The component responsible for resolving views in a Spring MVC application is
    `org.springframework.web.servlet.ViewResolver`. It maps logical view names with
    physical view resources and the chosen view technology.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC应用程序中负责解析视图的组件是`org.springframework.web.servlet.ViewResolver`。它将逻辑视图名称映射到物理视图资源和所选择的视图技术。
- en: All request-handling methods of controllers must resolve a logical view name
    by either returning a view name, a view object, or a `ModelAndView` object. The
    `org.springframework.web.servlet.View` object prepares `HttpRequest` for the consumption
    of the chosen view technology.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的所有请求处理方法必须通过返回视图名称、视图对象或`ModelAndView`对象来解析逻辑视图名称。`org.springframework.web.servlet.View`对象准备`HttpRequest`以消费所选择的视图技术。
- en: 'Spring MVC comes with a set of convenient view resolvers out of the box:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC提供了一组方便的视图解析器，可以直接使用：
- en: '| ViewResolver | Description |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| ViewResolver | Description |'
- en: '| --- | --- |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AbstractCachingViewResolver` | This is a convenient base class for `ViewResolver`
    implementations. For better performance, it caches view objects once they are
    resolved. |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| `AbstractCachingViewResolver` | 这是`ViewResolver`实现的一个方便的基类。为了更好的性能，它会在解析视图对象后缓存视图对象。
    |'
- en: '| `XmlViewResolver` | This uses bean definitions from a dedicated XML file
    to resolve view definitions. The file is specified by a resource location. By
    default, it is located at `WEB-INF/views.xml`. |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| `XmlViewResolver` | 这个解析器使用专用XML文件中的bean定义来解析视图定义。该文件由资源位置指定。默认情况下，它位于`WEB-INF/views.xml`。
    |'
- en: '| `ResourceBundleViewResolver` | This uses bean definitions in `ResourceBundle`
    specified by the bundle basename in order to define views. The default basename
    is `views.properties`. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| `ResourceBundleViewResolver` | 这个解析器使用`ResourceBundle`中指定的bean定义来定义视图。默认的基本名称是`views.properties`。
    |'
- en: '| `UrlBasedViewResolver` | This resolves view names with physical resources
    in the matching URL. Its two supporting properties, prefix and suffix, help locate
    the resource. |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| `UrlBasedViewResolver` | 这个解析器用于解析具有匹配URL中物理资源的视图名称。它的两个支持属性，前缀和后缀，帮助定位资源。
    |'
- en: '| `InternalResourceViewResolver` | This resolves Servlets and JSPs with JSTL
    support. It is a subclass of `UrlBasedViewResolver`. |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| `InternalResourceViewResolver` | 这个解析器用于解析带有JSTL支持的Servlets和JSPs。它是`UrlBasedViewResolver`的子类。
    |'
- en: '| `VelocityViewResolver` | This resolves Velocity templates and is a subclass
    of `UrlBasedViewResolver`. |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| `VelocityViewResolver` | 这个解析器用于解析Velocity模板，是`UrlBasedViewResolver`的子类。
    |'
- en: '| `FreeMarkerViewResolver` | This resolves FreeMarker templates. It is a subclass
    of `UrlBasedViewResolver`. |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| `FreeMarkerViewResolver` | 这个解析器用于解析FreeMarker模板。它是`UrlBasedViewResolver`的子类。
    |'
- en: '| `JasperReportsViewResolver` | This resolves JasperReport views for different
    formats, such as CSV, HTML, XLS, and XLSX. |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| `JasperReportsViewResolver` | 这个解析器用于解析不同格式的JasperReport视图，比如CSV、HTML、XLS和XLSX。
    |'
- en: '| `TilesViewResolver` | This resolves Tiles views for both version 2 and 3.
    |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| `TilesViewResolver` | 这个解析器用于解析版本2和3的Tiles视图。 |'
- en: The sample application in this chapter uses `UrlBasedViewResolver` for resolving
    JSP views. When you use multiple view technologies in a web application, you may
    use `ResourceBundleViewResolver`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例应用程序使用`UrlBasedViewResolver`来解析JSP视图。当您在Web应用程序中使用多个视图技术时，您可以使用`ResourceBundleViewResolver`。
- en: Resolving JSP views
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析JSP视图
- en: '**Java Server Pages** (**JSP**), the primary web templating technology for
    Java EE, is a simple and easy tool for the rapid development of dynamic web content
    based on JVM. Built on top of Servlet technology, JSP has direct access to the
    entire Java API. JSP makes a web page author''s life a lot easier by allowing
    him to design web pages in natural HTML format and then embed the required Java
    code inside scriptlet blocks.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Server Pages** (**JSP**), 是 Java EE 的主要网页模板技术，是一种简单易用的工具，用于基于 JVM 的动态网页内容的快速开发。建立在
    Servlet 技术之上，JSP 可以直接访问整个 Java API。JSP 通过允许用户以自然的 HTML 格式设计网页，然后在脚本块中嵌入所需的 Java
    代码，大大简化了网页作者的工作。'
- en: '**Java Server Pages Tag Library** (**JSTL**) is a set of standardized HTML-style
    tags highly useful for JSP pages. JSTL eliminates the need to mix Java code inside
    JSP pages, thus making JSP pages much cleaner and easier to author.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Server Pages Tag Library** (**JSTL**) 是一组标准化的类似 HTML 标签，非常适用于 JSP 页面。JSTL
    消除了在 JSP 页面中混合 Java 代码的需要，因此使得 JSP 页面更加清洁和易于编写。'
- en: 'Spring MVC resolves JSP pages using `InternalResourceViewResolver`. In an earlier
    section, *Your first Spring MVC application*, we already configured the `ViewResolver`
    class for JSP, as follows:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 使用 `InternalResourceViewResolver` 解析 JSP 页面。在前面的部分 *Your first Spring
    MVC application* 中，我们已经为 JSP 配置了 `ViewResolver` 类。
- en: '[PRE89]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Spring MVC recommends keeping your view files (JSP in this case) under the `WEB-INF`
    directory to avoid direct client access. `ViewResolver` discovers the view files
    from the physical location and caches them by default once resolved, which helps
    performance.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 建议将视图文件（在这种情况下是 JSP）放在 `WEB-INF` 目录下，以避免直接客户端访问。`ViewResolver` 会从物理位置发现视图文件，并在解析后默认缓存它们，这有助于提高性能。
- en: Binding Model attributes in JSP pages using JSTL
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSTL 在 JSP 页面中绑定 Model 属性
- en: 'Views have access to `Model` attributes set from associated handler methods
    and controllers. These `Model` attributes can be displayed in JSP views with the
    help of JSTL. In the following example, the `Model` attribute `tasks` is listed
    using JSTL:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以访问从关联处理程序方法和控制器设置的 `Model` 属性。这些 `Model` 属性可以在 JSP 视图中使用 JSTL 显示。在下面的示例中，使用
    JSTL 列出了 `Model` 属性 `tasks`：
- en: '[PRE90]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You may have noticed the declaration and usage of JSTL tags in the preceding
    JSP extract of the `/tasks/list.jsp` view. Here is how it would be rendered with
    proper styling in a browser:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了在前面 JSP 提取的 `/tasks/list.jsp` 视图中声明和使用 JSTL 标签。以下是在浏览器中以适当样式呈现的方式：
- en: '![Binding Model attributes in JSP pages using JSTL](img/image00785.jpeg)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JSTL 在 JSP 页面中绑定 Model 属性](img/image00785.jpeg)'
- en: Spring and Spring form tag libraries
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 和 Spring 表单标签库
- en: 'Spring bundles a set of tags for the easier authoring of plain JSP pages and
    JSP forms, defined in `spring.tld` and `spring-form.tld` respectively. `spring.tld`
    describes general-purpose JSP tags commonly used in JSP pages, listed in the following
    table:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 捆绑了一组标签，用于更轻松地编写普通 JSP 页面和 JSP 表单，分别在 `spring.tld` 和 `spring-form.tld`
    中定义。`spring.tld` 描述了常用于 JSP 页面的通用目的的 JSP 标签，列在以下表中：
- en: '| Spring tag | Description |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| Spring tag | Description |'
- en: '| --- | --- |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<spring:bind/>` | This allows the data binding of an attribute given in
    the bind path of a locally declared bean or a `Model` attribute and provides a
    `BindStatus` object to the enclosed body content. |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:bind/>` | 这允许绑定在本地声明的 bean 或 `Model` 属性的绑定路径中的属性，并为封闭的主体内容提供 `BindStatus`
    对象。 |'
- en: '| `<spring:escapeBody/>` | This applies HTML escaping and JavaScript escaping
    for the body. |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:escapeBody/>` | 这为主体应用了 HTML 转义和 JavaScript 转义。 |'
- en: '| `<spring:hasBindErrors/>` | This provides an error instance if there are
    bind errors. |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:hasBindErrors/>` | 如果存在绑定错误，则提供错误实例。 |'
- en: '| `<spring:htmlEscape/>` | This sets an HTML escape value for the current JSP
    page. |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:htmlEscape/>` | 这为当前 JSP 页面设置了 HTML 转义值。 |'
- en: '| `<spring:message/>` | This displays a message for a given code, usually resolved
    from a resource bundle. |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:message/>` | 这会显示给定代码的消息，通常是从资源包中解析出来的。 |'
- en: '| `<spring:nestedPath/>` | This sets a nested path of `ModelAttribute` to the
    `<spring:bind/>` tags enclosed inside. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:nestedPath/>` | 这将 `ModelAttribute` 的嵌套路径设置为 `<spring:bind/>` 标签内部的标签。
    |'
- en: '| `<spring:theme/>` | This loads the theme resource using the given code. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:theme/>` | 这使用给定代码加载主题资源。 |'
- en: '| `<spring:transform/>` | This transforms properties inside the `<spring:bind/>`
    tag and exports them to a variable in a given scope. |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:transform/>` | 这会转换 `<spring:bind/>` 标签内部的属性，并将它们导出到给定范围的变量中。 |'
- en: '| `<spring:url/>` | This creates a URL with URI template variables. It is modeled
    after the JSTL `c:url` tag. |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:url/>` | 这会使用 URI 模板变量创建一个 URL。它是基于 JSTL `c:url` 标签建模的。 |'
- en: '| `<spring:eval/>` | This evaluates SpEL expressions. |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| `<spring:eval/>` | 这会评估 SpEL 表达式。 |'
- en: 'Spring `form` tags provide data binding for HTML forms. They have tight integration
    with request handlers in controllers. Generally, they represent similarly named
    HTML `form` elements and share common attributes:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: Spring `form` 标签为 HTML 表单提供数据绑定。它们与控制器中的请求处理程序紧密集成。通常，它们代表名称相似的 HTML `form`
    元素，并共享常见属性：
- en: '| Form tag | Sample |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| Form tag | Sample |'
- en: '| --- | --- |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<form:input/>` | `<form:input path="name" placeholder="Task Name"/>` |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| `<form:input/>` | `<form:input path="name" placeholder="任务名称"/>` |'
- en: '| `<form:textarea/>` | `<form:textarea path="comments" id="txtComments" rows="5"
    cols="30" />` |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| `<form:textarea/>` | `<form:textarea path="comments" id="txtComments" rows="5"
    cols="30" />` |'
- en: '| `<form:select/>``<form:option/>` and`<form:options/>` | `<form:select path="createdBy"
    id="selectCreatedBy">``<form:option value="-1" label="Select"/>``<form:options
    items="${users}" itemValue="id" itemLabel="name" />``</form:select>` |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| `<form:select/>``<form:option/>` and`<form:options/>` | `<form:select path="createdBy"
    id="selectCreatedBy">``<form:option value="-1" label="选择"/>``<form:options items="${users}"
    itemValue="id" itemLabel="name" />``</form:select>` |'
- en: '| `<form:label/>` | `<form:label for="txtTaskName" path="name">Task-names</form:label>`
    |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| `<form:label/>` | `<form:label for="txtTaskName" path="name">任务名称</form:label>`
    |'
- en: '| `<form:hidden/>>` | `<form:hidden path="taskId" id="hdnTaskId"/>` |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| `<form:hidden/>>` | `<form:hidden path="taskId" id="hdnTaskId"/>` |'
- en: '| `<form:password/>` | `<form:password path="userPassword"/>` |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| `<form:password/>` | `<form:password path="userPassword"/>` |'
- en: '| `<form:radiobutton/>` | `<form:radiobutton path="sex" value="Male"/>` |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| `<form:radiobutton/>` | `<form:radiobutton path="sex" value="Male"/>` |'
- en: '| `<form:radiobuttons/>` | `<form:radiobuttons path="sex" items="${sexOptions}"/>`
    |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| `<form:radiobuttons/>` | `<form:radiobuttons path="sex" items="${sexOptions}"/>`
    |'
- en: '| `<form:checkbox/>` | `<form:checkbox path="task.priority" value="1"/>` |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| `<form:checkbox/>` | `<form:checkbox path="task.priority" value="1"/>` |'
- en: '| `<form:checkboxes/>` | `<form:checkboxes path="task.priority" value="${taskPriorities}"/>`
    |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| `<form:checkboxes/>` | `<form:checkboxes path="task.priority" value="${taskPriorities}"/>`
    |'
- en: '| `<form:password/>` | `<form:password path="password" />` |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| `<form:password/>` | `<form:password path="password" />` |'
- en: '| `<form:errors/>` | `<form:errors path="createdBy.id" />` |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| `<form:errors/>` | `<form:errors path="createdBy.id" />` |'
- en: Composing a form in JSP
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JSP中组合表单
- en: 'Spring forms can be composed in JSP pages using the `<spring>` and `<form>`
    tags. For the purpose of illustration, let''s take a look at a JSP form that uses
    both the Spring and form tag libraries along with JSTL. The following is a stripped-down
    version of `views/task/new.jsp`:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: Spring表单可以在JSP页面中使用`<spring>`和`<form>`标签进行组合。为了举例说明，让我们看一个使用Spring和form标签库以及JSTL的JSP表单。以下是`views/task/new.jsp`的简化版本：
- en: '[PRE91]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see in the preceding code listing, you must declare the JSTL, Spring,
    and form tag library directives at the top of your JSP page before you use Spring
    form tags.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码清单所示，您必须在使用Spring表单标签之前，在JSP页面的顶部声明JSTL、Spring和form标签库指令。
- en: 'All `<form>` elements should be inside a `<form:form/>` container element.
    The `commandName` attribute value of `<form:form/>` binds the `Model` attribute
    with the name in the handler method of the Controller. The handler method from
    which the preceding JSP form is resolved would look like the following code:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`<form>`元素都应该在`<form:form/>`容器元素内。`<form:form/>`的`commandName`属性值将`Model`属性与控制器的处理方法中的名称绑定。解析前述JSP表单的处理方法如下所示：
- en: '[PRE92]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Notice the `Model` attribute, `task`, which is bound with the `<form:form/>`
    tag in the JSP page. The form is submitted to the following handler method, which
    again serializes the `Task` object back for persistence:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Model`属性`task`，它与JSP页面中的`<form:form/>`标签绑定。表单提交到以下处理方法，该方法再次将`Task`对象序列化以进行持久化：
- en: '[PRE93]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Validating forms
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证表单
- en: Spring MVC makes form validation a lot easier using Spring's `Validator` framework.
    You might have noticed the `@Valid` annotation and the usage of the `BindingResult.hasErrors()`
    method call inside handler methods listed in the previous section. They are part
    of the validation framework.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC使用Spring的`Validator`框架使表单验证变得更加容易。您可能已经注意到了前一节中列出的处理方法中的`@Valid`注解和`BindingResult.hasErrors()`方法调用的使用。它们是验证框架的一部分。
- en: 'Let''s create a validator for a `Task` object by following these steps:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤为`Task`对象创建一个验证器：
- en: 'Add the Validation API''s Maven dependency, `javax.validation` (build file:
    `pom.xml`).'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件（`pom.xml`）中添加Validation API的Maven依赖项，`javax.validation`。
- en: 'Make sure you have defined `MessageSourceBean` for the `validation-errors`
    properties file in your bean definition:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在bean定义中为`validation-errors`属性文件定义了`MessageSourceBean`：
- en: '[PRE94]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Make sure there is a `validation-errors.properties` file with the following
    sample content in your root resources location. You may add as many error messages
    into it as you like.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在根资源位置有一个名为`validation-errors.properties`的文件，并包含以下示例内容。您可以根据需要添加任意数量的错误消息。
- en: '[PRE95]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a `Validator` class, `TaskValidator`:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Validator`类`TaskValidator`：
- en: '[PRE96]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Register the `TaskValidator` class inside the `TaskController` class using
    `InitBinder`:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InitBinder`在`TaskController`类中注册`TaskValidator`类：
- en: '[PRE97]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Annotate `ModelAttribute` with the `@Valid` annotation of `javax.validation.Valid`
    in the handler method.
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理方法中，使用`javax.validation.Valid`的`@Valid`注解注释`ModelAttribute`。
- en: Handle validation errors in the request handler method, as given in the `createNewTask()`
    method listed in the previous section.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求处理方法中处理验证错误，就像前一节中列出的`createNewTask()`方法一样。
- en: Add a `<form:errors/>` tag for each form field you are validating—as seen in
    the `/tasks/new.jsp` file.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您正在验证的每个表单字段添加一个`<form:errors/>`标签，就像`/tasks/new.jsp`文件中所示的那样。
- en: 'The form will look like this in case of validation errors:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证错误的情况下，表单将如下所示：
- en: '![Validating forms](img/image00786.jpeg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![Validating forms](img/image00786.jpeg)'
- en: Handling file uploads
  id: totrans-763
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: 'Most web applications require multipart file upload functionality. Spring MVC
    makes it extremely easy to handle this otherwise cumbersome feature. It provides
    two built-in implementations of `MultiPartResolvers`: `CommonsMulipartResolver`
    for Apache Commons FileUpload and `StandardServletMultipartResolver` for the Servlet
    3.0 API.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序都需要多部分文件上传功能。Spring MVC使得处理这个繁琐的功能变得非常容易。它提供了两个内置的`MultiPartResolvers`实现：`CommonsMulipartResolver`用于Apache
    Commons FileUpload和`StandardServletMultipartResolver`用于Servlet 3.0 API。
- en: 'Since most modern web applications use a Servlet 3.0 container, let''s see
    how the FileUpload functionality can be handled using `StandardServletMultipartResolver`
    with the help of following example:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数现代Web应用程序使用Servlet 3.0容器，让我们看看如何使用`StandardServletMultipartResolver`处理文件上传功能，以下是一个示例：
- en: 'Register your `MultipartResolver` in your `servlet-context.xml` file (or add
    it programmatically if you are using a Java configuration):'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`servlet-context.xml`文件中注册您的`MultipartResolver`（或者如果您使用Java配置，则以编程方式添加它）：
- en: '[PRE98]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Add multipart configuration support to your `DispatcherServlet` in your `web.xml`
    (or JavaConfig) file:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web.xml`（或JavaConfig）文件中为您的`DispatcherServlet`添加多部分配置支持：
- en: '[PRE99]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Make sure that the location you provided in the previous section really exists.
    Create the directory if it doesn't.
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您在上一节中提供的位置确实存在。如果不存在，请创建该目录。
- en: 'Create the web form with an input file element in it. This sample JSP snippet
    uploads a user''s profile image:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建带有输入文件元素的Web表单。此示例JSP片段上传用户的个人资料图片：
- en: '[PRE100]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the request handler method in your Controller:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中创建请求处理方法：
- en: '[PRE101]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Resolving Thymeleaf views
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析Thymeleaf视图
- en: Thymeleaf is a Java-based XML/HTML/HTML5 template engine library to build web
    applications. It allows faster processing of templates and increased performance
    due to the intelligent caching of parsed view files. Please refer to the official
    Thymeleaf documentation for Thymeleaf page authoring.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf是一个基于Java的XML/HTML/HTML5模板引擎库，用于构建Web应用程序。它允许更快地处理模板，并由于解析视图文件的智能缓存而提高性能。请参考官方的Thymeleaf文档了解Thymeleaf页面编写。
- en: 'You need Thymeleaf and Spring (`org.thymeleaf`) in your Maven dependencies
    in order to use Thymeleaf in your projects. Thymeleaf views can be resolved in
    your project with the following snippet:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Maven依赖项中添加Thymeleaf和Spring（`org.thymeleaf`）才能在项目中使用Thymeleaf。可以使用以下代码片段在项目中解析Thymeleaf视图：
- en: '[PRE102]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: More view technologies
  id: totrans-779
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多视图技术
- en: 'Spring MVC supports an impressive set of view technologies; you can use any
    of these after adding the right Maven dependencies in your project. Spring provides
    view resolvers out of the box for most of the view technologies. Here is a list
    of other view technologies supported by Spring MVC:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC支持一组令人印象深刻的视图技术；在项目中添加正确的Maven依赖项后，您可以使用其中任何一个。Spring为大多数视图技术提供了开箱即用的视图解析器。以下是Spring
    MVC支持的其他视图技术列表：
- en: Velocity and FreeMarker
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Velocity和FreeMarker
- en: Groovy markup templates
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy标记模板
- en: 'JavaScript templates (on Nashhorn): Handlebars, Mustache, ReactJS, and EJS'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript模板（在Nashhorn上）：Handlebars、Mustache、ReactJS和EJS
- en: ERB templates on JRuby and String templates on Jython
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JRuby上的ERB模板和Jython上的String模板
- en: XML views and XSLT (built in)
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML视图和XSLT（内置）
- en: Tiles
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tiles
- en: PDF (iText) and Excel (Apache POI)
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF（iText）和Excel（Apache POI）
- en: JasperReports
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JasperReports
- en: Feed views
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feed视图
- en: In most cases, you will need to mix and match view technologies in the same
    application. For example, you may use JSP for normal HTML screens, but you will
    still need JasperReports to report screens and may need to download some reports
    as PDF and Excel files. Using Spring MVC ensures that all these features can be
    easily integrated.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您需要在同一个应用程序中混合和匹配视图技术。例如，您可能会在普通HTML屏幕上使用JSP，但仍然需要JasperReports来报告屏幕，并可能需要将一些报告下载为PDF和Excel文件。使用Spring
    MVC可以确保所有这些功能可以轻松集成。
- en: Summary
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to build highly scalable and dynamic web applications
    using Spring MVC. Starting from setting up the project and configuring `WebApplicationContext`
    with proper layering, we explored different ways of designing controllers and
    map request handlers for both web and API endpoints—that too including asynchronous
    processing and multipart file uploads—using easily configurable components. Now,
    we can compose beautiful JSP pages using `<spring>` and `<form>` tags and also
    enable form validation using the Validation API.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring MVC构建高度可扩展和动态的Web应用程序。从设置项目和配置`WebApplicationContext`以适当的分层开始，我们探索了设计控制器的不同方式，并为Web和API端点映射请求处理程序，包括异步处理和多部分文件上传，使用易于配置的组件。现在，我们可以使用`<spring>`和`<form>`标签组合美丽的JSP页面，并使用验证API启用表单验证。
- en: So far, we have been holding data in memory without bothering about making it
    persistent somewhere. In the next chapter, we will dive one level deeper into
    the data layer of enterprise application development, learning various data access
    and persistence mechanisms with and without ACID transactions. We are going to
    deal with more serious concerns from this point.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在内存中保存数据，而不用担心将其持久化在某个地方。在下一章中，我们将深入企业应用程序开发的数据层，学习有关ACID事务的各种数据访问和持久化机制，包括有和没有ACID事务。从这一点开始，我们将处理更严重的问题。
- en: Chapter 3. Accessing Data with Spring
  id: totrans-794
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Spring访问数据
- en: Data access or persistence is a major technical feature of data-driven applications.
    This is a critical area where careful design and expertise is required. Modern
    enterprise systems use a wide variety of data storage mechanisms ranging from
    traditional relational databases such as Oracle, SQL Server, and Sybase to more
    flexible, schema-less NoSQL databases such as MongoDB, Cassandra, and Couchbase.
    Spring Framework provides comprehensive support for data persistence in multiple
    flavors of mechanism, ranging from convenient template components to smart abstractions
    over popular **ORM** (**Object Relational Mapping**) tools and libraries, making
    them much easier to use. Spring's data access support is another great reason
    for choosing it for developing Java applications.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问或持久化是数据驱动应用程序的一个重要技术特性。这是一个需要仔细设计和专业知识的关键领域。现代企业系统使用各种各样的数据存储机制，从传统的关系数据库（如Oracle、SQL
    Server和Sybase）到更灵活的无模式数据库（如MongoDB、Cassandra和Couchbase）。Spring框架为多种机制的数据持久化提供了全面的支持，从方便的模板组件到流行的**ORM**（**对象关系映射**）工具和库的智能抽象，使它们更容易使用。Spring的数据访问支持是选择其开发Java应用程序的另一个重要原因。
- en: 'Spring Framework offers the following primary approaches for data persistence
    mechanisms for developers to choose from:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架为开发人员提供了以下主要数据持久化机制的选择：
- en: Spring JDBC
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring JDBC
- en: ORM Data Access
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM数据访问
- en: Spring Data
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data
- en: Furthermore, Spring standardizes the preceding approaches under a unified **DAO**
    (**Data Access Object**) notation called `@Repository`.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Spring将前述方法统一标准化为称为`@Repository`的统一**DAO**（**数据访问对象**）表示法。
- en: Another compelling reason for using Spring is its first class transaction support.
    Spring provides consistent transaction management, abstracting different transaction
    APIs such as JTA, JDBC, JPA, Hibernate, JDO, and other container-specific transaction
    implementations.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring的另一个引人注目的原因是它的一流事务支持。Spring提供一致的事务管理，抽象了不同的事务API，如JTA、JDBC、JPA、Hibernate、JDO和其他特定于容器的事务实现。
- en: In order to make development and prototyping easier, Spring provides embedded
    database support, smart abstractions (`DataSource`), and excellent test integration.
    This chapter explores various data access mechanisms provided by Spring Framework
    and its comprehensive support for transaction management in both standalone and
    web environments, with relevant examples.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发和原型设计更容易，Spring提供了嵌入式数据库支持、智能抽象（`DataSource`）和优秀的测试集成。本章探讨了Spring框架提供的各种数据访问机制以及其在独立和Web环境中对事务管理的全面支持，同时提供相关示例。
- en: Note
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why use Spring Data Access when we have JDBC?**'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用Spring数据访问而不是JDBC？
- en: '**JDBC** (**Java Database Connectivity**), the Java Standard Edition API for
    data connectivity from Java to relational databases, is a very a low-level framework.
    Data access via JDBC is often cumbersome; the boiler-plate code the developer
    needs to write makes the code error-prone. Moreover, JDBC exception handling is
    not sufficient for most use cases; there exists a real need for simplified but
    extensive and configurable exception handling for data access. Spring JDBC encapsulates
    the often repeating code, simplifying the developer code tremendously, and lets
    him/her focus directly on his business logic. Spring Data Access components abstract
    the technical details including the lookup and management of persistence resources
    such as connections, statements, and resultsets, and accept the specific SQL statements
    and relevant parameters to perform the operation. Spring Data Access components
    use the same JDBC API under the hood, while exposing simplified, straightforward
    interfaces for the client''s use. This approach makes for a much cleaner and hence
    maintainable data access layer for Spring applications.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC（Java数据库连接）是Java标准版API，用于从Java到关系数据库的数据连接，是一个非常低级的框架。通过JDBC访问数据通常很麻烦；开发人员需要编写的样板代码使得代码容易出错。此外，JDBC异常处理对于大多数用例来说是不够的；数据访问需要简化但广泛和可配置的异常处理。Spring
    JDBC封装了经常重复的代码，极大地简化了开发人员的代码，并让他/她直接专注于业务逻辑。Spring数据访问组件抽象了技术细节，包括查找和管理持久性资源，如连接、语句和结果集，并接受特定的SQL语句和相关参数来执行操作。Spring数据访问组件在底层使用相同的JDBC
    API，同时为客户端提供了简化、直接的接口。这种方法为Spring应用程序提供了更清晰、因此更易于维护的数据访问层。
- en: Configuring DataSource
  id: totrans-806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置DataSource
- en: The first step to connect to a database from any Java application is to obtain
    a connection object specified by JDBC. `DataSource`, a part of Java SE, is a generalized
    factory of `java.sql.Connection` objects that represents the physical connection
    to the database and is the preferred means of producing a connection. `DataSource`
    handles transaction management, connection lookup, and pooling functionalities,
    relieving the developer of those infrastructural issues.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何Java应用程序连接到数据库的第一步是获取由JDBC指定的连接对象。`DataSource`是Java SE的一部分，是`java.sql.Connection`对象的通用工厂，表示与数据库的物理连接，并且是生成连接的首选方式。`DataSource`处理事务管理、连接查找和池功能，解除了开发人员对这些基础设施问题的负担。
- en: '`DataSource` objects are often implemented by database driver vendors and typically
    looked up via JNDI. Application servers and Servlet engines provide their own
    implementations of `DataSource` (and) or connectors to `DataSource` objects provided
    by the database vendor. Typically configured inside XML-based server descriptor
    files, server-supplied `DataSource` objects generally provide built-in connection
    pooling and transaction support. As a developer, you just configure your data
    sources inside the server configuration files declaratively in XML and look them
    up from your application via JNDI.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataSource`对象通常由数据库驱动程序供应商实现，并通常通过JNDI查找。应用服务器和Servlet引擎提供了它们自己的`DataSource`实现和/或连接器到由数据库供应商提供的`DataSource`对象。通常在基于XML的服务器描述符文件中配置，服务器提供的`DataSource`对象通常提供内置的连接池和事务支持。作为开发人员，您只需在服务器配置文件中以XML方式声明式地配置您的数据源，并通过JNDI从应用程序中查找它们。'
- en: In a Spring application, you configure your `DataSource` reference as a Spring
    bean, and inject it as a dependency into your DAOs or other persistence resources.
    The Spring `<jee:jndi-lookup/>` tag (of [http://www.springframework.org/schema/jee](http://www.springframework.org/schema/jee)
    namespace) allows you to look up and construct JNDI resources easily, including
    a `DataSource` object defined from inside an application server. For applications
    deployed in a J2EE application server, a JNDI `DataSource` object provided by
    the container is recommended.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，您将`DataSource`引用配置为Spring bean，并将其作为依赖项注入到DAO或其他持久性资源中。Spring的`<jee:jndi-lookup/>`标签（来自[http://www.springframework.org/schema/jee](http://www.springframework.org/schema/jee)命名空间）允许您轻松查找和构建JNDI资源，包括从应用服务器内部定义的`DataSource`对象。对于部署在J2EE应用服务器中的应用程序，建议使用容器提供的JNDI`DataSource`对象。
- en: '[PRE103]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: For standalone applications, you need to create your own `DataSource` implementation
    or use third-party implementations such as Apache Commons DBCP, C3P0, or BoneCP.
    The following is a sample `DataSource` configuration using Apache Commons DBCP2\.
    It provides configurable connection pooling features too.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立应用程序，您需要创建自己的`DataSource`实现或使用第三方实现，如Apache Commons DBCP、C3P0或BoneCP。以下是使用Apache
    Commons DBCP2的示例`DataSource`配置。它还提供了可配置的连接池功能。
- en: '[PRE104]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Make sure you add the corresponding dependency to your `DataSource` implementation
    in your build file. The following is for DBCP2:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在构建文件中添加相应的依赖项以使用您的`DataSource`实现。以下是DBCP2的示例：
- en: '[PRE105]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Spring provides `DriverManagerDataSource`, a simple implementation of `DataSource`,
    which is only meant for testing and development purposes, not for production use.
    Note that it does not provide connection pooling. Here is how you configure it
    in your application.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了`DriverManagerDataSource`，这是`DataSource`的一个简单实现，仅用于测试和开发目的，而不用于生产。请注意，它不提供连接池。以下是如何在应用程序中配置它。
- en: '[PRE106]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'It can also be configured using the Java-based configuration, as shown in the
    following code:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用基于Java的配置进行配置，如下所示：
- en: '[PRE107]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never use `DriverManagerDataSource` on production environments. Use third-party
    data sources such as DBCP, C3P0, and BoneCP for standalone applications, and JNDI
    `DataSource` provided by the container, for the J2EE container instead. They are
    more reliable and provide efficient connection pooling functionality off the shelf.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产环境中使用`DriverManagerDataSource`。对于独立应用程序，请使用DBCP、C3P0和BoneCP等第三方数据源，对于J2EE容器，请使用容器提供的JNDI
    `DataSource`。它们更可靠，并且提供了高效的连接池功能。
- en: Using embedded databases
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌入式数据库
- en: 'For prototyping and test environments, it is a good idea to use Java-based
    embedded databases to quickly start up the project and configure easily. They
    are lightweight and easily testable. Spring supports the HSQL, H2, and Derby database
    engines for that purpose natively. Here is a sample `DataSource` configuration
    for an embedded HSQL database:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原型和测试环境，使用基于Java的嵌入式数据库是一个好主意，可以快速启动项目并轻松配置。它们轻量且易于测试。Spring原生支持HSQL、H2和Derby数据库引擎。以下是嵌入式HSQL数据库的示例`DataSource`配置：
- en: '[PRE108]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The XML version of this would look like the following code:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 其XML版本如下所示：
- en: '[PRE109]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Handling exceptions in the Spring Data layer
  id: totrans-826
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Data层处理异常
- en: With traditional JDBC-based applications, exception handling is based on `java.sql.SQLException`,
    which is a checked exception. It forces the developer to write `catch` and `finally`
    blocks carefully for proper handling and to avoid resource leakages such as leaving
    a database connection open. Spring, with its smart exception hierarchy based on
    `RuntimeException`, spares the developer from this nightmare. Having `DataAccessException`
    as the root, Spring bundles a bit set of meaningful exceptions, translating the
    traditional JDBC exceptions. Spring also covers Hibernate, JPA, and JDO exceptions
    in a consistent manner.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的基于JDBC的应用程序中，异常处理基于`java.sql.SQLException`，这是一个受检异常。它强制开发人员仔细编写`catch`和`finally`块，以便正确处理并避免资源泄漏，比如保持数据库连接处于打开状态。Spring基于`RuntimeException`的智能异常层次结构使开发人员摆脱了这一噩梦。以`DataAccessException`为根，Spring捆绑了一系列有意义的异常，翻译了传统的JDBC异常。Spring还以一致的方式涵盖了Hibernate、JPA和JDO异常。
- en: 'Spring uses `SQLErrorCodeExceptionTranslator`, which inherits `SQLExceptionTranslator`
    for translating `SQLException` to `DataAccessExceptions`. We can extend this class
    to customize the default translations. We can replace the default translator with
    our custom implementation by injecting into the persistence resources (such as
    `JdbcTemplate`, to be covered later). See the following code listing for how we
    define a `SQLExceptionTranslator` class in your code:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: Spring使用`SQLErrorCodeExceptionTranslator`，它继承自`SQLExceptionTranslator`，用于将`SQLException`翻译为`DataAccessExceptions`。我们可以扩展此类以自定义默认翻译。我们可以通过将自定义实现注入到持久性资源（如稍后将介绍的`JdbcTemplate`）中来替换默认的翻译器。请参阅以下代码清单，了解如何在代码中定义`SQLExceptionTranslator`类：
- en: '[PRE110]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The preceding code snippet catches any `SQLException` and converts it into
    a Spring-based `BadSqlGrammarException` instance. Then, this custom `SQLExceptionTranslator`
    needs to be passed to the `Jdbctemplate` before use, as shown in the following
    code:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段捕获任何`SQLException`并将其转换为基于Spring的`BadSqlGrammarException`实例。然后，这个自定义的`SQLExceptionTranslator`需要在使用之前传递给`Jdbctemplate`，如下面的代码所示：
- en: '[PRE111]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now, any invalid query will invoke the custom `SQLExceptionTranslator` class.
    You can customize its behavior according to your requirements.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何无效的查询都将调用自定义的`SQLExceptionTranslator`类。您可以根据自己的需求自定义其行为。
- en: DAO support and @Repository annotation
  id: totrans-833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DAO支持和@Repository注释
- en: The standard way of accessing data is via specialized DAOs that perform persistence
    functions under the data access layer. Spring follows the same pattern by providing
    DAO components and allowing developers to mark their data-access components as
    DAOs, using the annotation `@Repository`. This approach ensures consistency over
    various data access technologies such as JDBC, Hibernate, JPA, and JDO, and project-specific
    repositories. Spring applies `SQLExceptionTranslator` across all these methods
    consistently.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据的标准方式是通过执行数据访问层下的持久性功能的专门DAO。Spring通过提供DAO组件并允许开发人员将其数据访问组件标记为DAO，使用注释`@Repository`来遵循相同的模式。这种方法确保了在各种数据访问技术（如JDBC、Hibernate、JPA和JDO）和项目特定存储库上的一致性。Spring在所有这些方法中一致地应用`SQLExceptionTranslator`。
- en: Spring recommends your data-access components to be annotated with stereotype,
    `@Repository`. The term, repository, was originally defined in *Domain-Driven
    Design*, *Eric Evans*, *Addison Wesley* as "a mechanism for encapsulating storage,
    retrieval, and search behavior which emulates a collection of objects." This annotation
    makes the class eligible for `DataAccessException` translation by Spring Framework.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Spring建议将数据访问组件注释为`@Repository`。术语“repository”最初在*Domain-Driven Design*，*Eric
    Evans*，*Addison Wesley*中定义为“一种模拟对象集合的存储、检索和搜索行为的机制”。此注释使类有资格由Spring框架进行`DataAccessException`翻译。
- en: Spring Data, another standard data-access mechanism provided by Spring, revolves
    around `@Repository` components. We will discuss this more in later sections.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data是Spring提供的另一种标准数据访问机制，围绕`@Repository`组件展开。我们将在后面的部分中更多地讨论这个问题。
- en: Spring JDBC abstraction
  id: totrans-837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring JDBC抽象
- en: Spring JDBC components simplify JDBC-based data access by encapsulating the
    boilerplate code and hiding the interaction with JDBC API components from the
    developer with a set of simple interfaces. These interfaces handle the opening
    and closing of JDBC resources (connections, statements, resultsets) as required.
    They prepare and execute statements, extract results from resultsets, provide
    callback hooks for converting, mapping and handling data, handle transactions,
    and translate SQL exceptions into the more sensible and meaningful hierarchy of
    `DataAccessException`.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC 组件通过封装样板代码并使用一组简单的接口隐藏与 JDBC API 组件的交互，简化了基于 JDBC 的数据访问。这些接口处理了
    JDBC 资源（连接、语句、结果集）的打开和关闭。它们准备和执行语句，从结果集中提取结果，提供回调钩子以转换、映射和处理数据，处理事务，并将 SQL 异常转换为更合理和有意义的
    `DataAccessException` 层次结构。
- en: 'Spring JDBC provides three convenient approaches for accessing relational databases:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC 提供了三种便利的方法来访问关系数据库：
- en: '`JdbcTemplate`'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`'
- en: '`SimpleJDBC` classes'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJDBC` 类'
- en: RDBMS `Sql*` classes
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDBMS `Sql*` 类
- en: Each of these Spring JDBC categories has multiple flavors of components under
    them which you can mix-and-match based on your convenience and technical choice.
    You may explore them under the `org.springframework.jdbc` package and its subpackages.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Spring JDBC 类别下都有多种组件的变种，您可以根据自己的方便和技术选择进行混合和匹配。您可以在 `org.springframework.jdbc`
    包及其子包下探索它们。
- en: JdbcTemplate
  id: totrans-844
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JdbcTemplate
- en: '`JdbcTemplate` is the core component under Spring JDBC abstraction. This powerful
    component executes almost all of the possible JDBC operations with its simple,
    meaningful methods, accepting parameters for an impressive set of flavors of data
    access. It belongs to the package, `org.springframework.jdbc.core`, which contains
    many other supporting classes that help `JdbcTemplate` to complete its JDBC operations.
    A `DataSource` instance is the only dependency for this component. All other Spring
    JDBC components use `JdbcTemplate` internally for their operations.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 是 Spring JDBC 抽象下的核心组件。这个强大的组件通过其简单而有意义的方法执行几乎所有可能的 JDBC 操作，接受一组令人印象深刻的数据访问变种的参数。它属于
    `org.springframework.jdbc.core` 包，其中包含许多其他支持类，帮助 `JdbcTemplate` 完成其 JDBC 操作。这个组件的唯一依赖是
    `DataSource` 实例。所有其他 Spring JDBC 组件在内部使用 `JdbcTemplate` 进行操作。'
- en: Usually, you configure `JdbcTemplate` as yet another Spring bean, and inject
    it into your DAOs or into any other bean where you want to invoke its methods.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将 `JdbcTemplate` 配置为另一个 Spring bean，并将其注入到您的 DAO 或任何其他您想要调用其方法的 bean 中。
- en: '[PRE112]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`JdbcTemplate` is one of the implementations of Template Pattern in Spring.
    Template Pattern is a behavioral pattern listed in the *Gang of Four* design pattern
    catalog. It defines the skeleton of an algorithm in a method or operation called
    **Template Method**, deferring some steps into the subclasses, without changing
    the algorithm''s structure. `JdbcTemplate` is a collection of these Template Methods;
    the user can extend it and override some of the behaviors based on specific requirements.
    `JMSTemplate` and `JpaTemplate` are also examples of Template Pattern implementations.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 是 Spring 中模板模式的实现之一。模板模式是 *Gang of Four* 设计模式目录中列出的行为模式。它在一个称为
    **模板方法** 的方法或操作中定义了算法的骨架，将一些步骤推迟到子类中，而不改变算法的结构。`JdbcTemplate` 是这些模板方法的集合；用户可以扩展它并根据特定要求覆盖一些行为。`JMSTemplate`
    和 `JpaTemplate` 也是模板模式实现的例子。'
- en: '`JdbcTemplate` executes SQL queries (`SELECT`), update statements (`INSERT`,
    `UPDATE`, and `DELETE`), stored procedure and function calls, returns extracted
    results (for `SELECT` queries), and invokes call-back methods for result-set extraction
    and mapping rows with domain objects. It has a comprehensive set of query and
    execute methods for different methods of result-set extraction. The following
    table introduces a few very useful `JdbcTemplate` methods:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 执行 SQL 查询（`SELECT`）、更新语句（`INSERT`、`UPDATE` 和 `DELETE`）、存储过程和函数调用，返回提取的结果（对于
    `SELECT` 查询），并调用回调方法进行结果集提取和将行映射到域对象。它具有一套全面的查询和执行方法，用于不同方法的结果集提取。以下表介绍了一些非常有用的
    `JdbcTemplate` 方法：'
- en: '| Method | Description |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `execute` | A set of overloaded methods for executing a SQL update (`INSERT`,
    `UPDATE`, and `DELETE`) statement, with different parameter sets including the
    SQL statement to be executed, bind parameters, a statement creator, and callback
    methods. |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
  zh: '| `execute` | 一组重载的方法，用于执行 SQL 更新（`INSERT`、`UPDATE` 和 `DELETE`）语句，包括要执行的 SQL
    语句、绑定参数、语句创建者和回调方法。|'
- en: '| `query` | A set of overloaded methods for querying `PreparedStatement` for
    a given SQL `SELECT` statement with a multitude of parameter sets including bind
    parameters, argument types, `RowMapper`, `ResultSetExtractor`, `PreparedStatementCreator`,
    `RowCallbackHandler`, and so on. While methods with callbacks are void methods,
    the others return a list of objects of type `<T>` specified with the corresponding
    `RowMapper`, `ResultSetExtractor`, or a populated instance of type `<T>`. |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '| `query` | 一组重载的方法，用于查询给定 SQL `SELECT` 语句的 `PreparedStatement`，包括多种参数集，包括绑定参数、参数类型、`RowMapper`、`ResultSetExtractor`、`PreparedStatementCreator`、`RowCallbackHandler`
    等。虽然带有回调的方法是 void 方法，其他方法返回指定类型 `<T>` 的对象列表，该类型由相应的 `RowMapper`、`ResultSetExtractor`
    指定，或者返回类型为 `<T>` 的填充实例。|'
- en: '| `queryForList` | A set of overloaded query methods executing a `SELECT` query
    returns a list of objects of type `<T>` specified as an argument, `Class<T> elementType`.
    Those methods not specifying the `elementType` return `List<Map<String, Object>>`.
    |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
  zh: '| `queryForList` | 一组重载的查询方法，执行 `SELECT` 查询并返回作为参数指定的类型 `<T>` 的对象列表，`Class<T>
    elementType`。未指定 `elementType` 的方法返回 `List<Map<String, Object>>`。|'
- en: '| `queryForMap` | Executes a (`SELECT`) query and returns the result as `Map<String,
    Object>`. |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
  zh: '| `queryForMap` | 执行（`SELECT`）查询并将结果作为 `Map<String, Object>` 返回。|'
- en: '| `queryForObject` | A set of overloaded methods querying a given SQL `SELECT`
    statement with parameter sets including bind parameters, argument types, `RowMapper`,
    and the required return type `<T>`. |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
  zh: '| `queryForObject` | 一组重载方法，查询给定的SQL `SELECT`语句，包括绑定参数、参数类型、`RowMapper`和所需的返回类型`<T>`。
    |'
- en: '| `update` | A set of overloaded methods issuing an update (`INSERT`, `UPDATE`,
    or `DELETE`) statement with parameter sets including bind parameters, argument
    types, `PreparedStatementCreator`, and so on. It returns an integer, which is
    the count of records affected. |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 一组重载方法，用于发出带有绑定参数、参数类型、`PreparedStatementCreator`等的更新（`INSERT`、`UPDATE`或`DELETE`）语句。它返回一个整数，表示受影响的记录数。
    |'
- en: '| `batchUpdate` | A set of overloaded methods for executing multiple SQL updates
    (`INSERT`, `UPDATE`, and DELETE) with different parameter sets including an array
    of SQL statements and many combinations of `PreparedStatementSetter` and other
    arguments. |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
  zh: '| `batchUpdate` | 一组重载方法，用于执行多个SQL更新（`INSERT`、`UPDATE`和DELETE），包括SQL语句数组和许多`PreparedStatementSetter`等参数的组合。
    |'
- en: '| `execute` | A set of overloaded methods for executing a SQL update (either
    `INSERT`, `UPDATE`, or `DELETE`) statement, with different parameter sets including
    the SQL statement to be executed, bind parameters, `StatementCreator`, and callback
    methods. |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '| `execute` | 一组重载方法，用于执行SQL更新（`INSERT`、`UPDATE`或`DELETE`）语句，包括SQL语句的执行、绑定参数、`StatementCreator`和回调方法等不同的参数集。
    |'
- en: '| `query` | A set of overloaded methods for querying `PreparedStatement` for
    a given SQL `SELECT` statement with several parameter sets including bind parameters,
    argument types, `RowMapper`, `ResultSetExtractor`, `PreparedStatementCreator`,
    `RowCallbackHandler`, and so on. While those methods with callbacks are void methods,
    the others return a list of objects of type `<T>` specified with the corresponding
    `RowMapper`, `ResultSetExtractor`, or a populated instance of type `<T>`. |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
  zh: '| `query` | 一组重载方法，用于查询给定SQL `SELECT`语句的`PreparedStatement`，包括绑定参数、参数类型、`RowMapper`、`ResultSetExtractor`、`PreparedStatementCreator`、`RowCallbackHandler`等多种参数集。虽然具有回调的方法是void方法，其他方法返回与相应的`RowMapper`、`ResultSetExtractor`指定的对象类型`<T>`的对象列表，或者类型`<T>`的填充实例。
    |'
- en: 'Behind the super capabilities of `JdbcTemplate` is a set of callback interfaces
    being passed as arguments for the methods listed in the preceding table. These
    execution hooks help `JdbcTemplate` to deal with relational data in a pure object-oriented
    and reusable fashion. A good understanding of these interfaces is critical for
    the right usage of `JdbcTemplate`. See the following table for these callback
    interfaces:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`的超强功能背后是一组回调接口，作为前面表中列出的方法的参数传递。这些执行钩子帮助`JdbcTemplate`以纯面向对象和可重用的方式处理关系数据。对这些接口的深入理解对于正确使用`JdbcTemplate`至关重要。请参阅以下表格以了解这些回调接口：'
- en: '| Callback interface | Callback method(s) | Responsibilities |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '| 回调接口 | 回调方法 | 职责 |'
- en: '| --- | --- | --- |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CallableStatementCreator` | `execute` | Constructs `java.sql.CallableStatement`,
    which is used to execute stored procedures inside its `createCallableStatement(Connection)`method:.
    |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '| `CallableStatementCreator` | `execute` | 构造`java.sql.CallableStatement`，用于在其`createCallableStatement(Connection)`方法中执行存储过程。
    |'
- en: '| `PreparedStatementCreator` | `execute`, `update`, `query` | Constructs `java.sql.PreparedStatement,`
    given a connection, inside the method, `createPreparedStatement (Connection)`.
    |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '| `PreparedStatementCreator` | `execute`, `update`, `query` | 构造`java.sql.PreparedStatement`，给定一个连接，在方法`createPreparedStatement
    (Connection)`中。 |'
- en: '| `PreparedStatementSetter` | `update`, `query` | Sets values to `PreparedStatement`
    before execution, inside `JdbcTemplate.setValues (PreparedStatement)`. |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '| `PreparedStatementSetter` | `update`, `query` | 在执行之前为`PreparedStatement`设置值，在`JdbcTemplate.setValues
    (PreparedStatement)`中。 |'
- en: '| `CallableStatementCallback` | `execute` | Prepares `CallableStatement`. Usually
    sets the `IN` and `OUT` parameters of a stored procedure or function, before the
    actual execution, inside `JdbcTemplate.doInCallableStatement(CallableStatement)`.
    |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '| `CallableStatementCallback` | `execute` | 准备`CallableStatement`。通常在实际执行之前设置存储过程或函数的`IN`和`OUT`参数，在`JdbcTemplate.doInCallableStatement(CallableStatement)`中：
    |'
- en: '| `PreparedStatementCallback` | `execute` | Used by `JdbcTemplate` execute
    methods for preparing `PreparedStatement`. Usually sets the bind parameters, before
    the actual execution, inside the `doInPreparedStatement(PreparedStatement)`method:.
    |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '| `PreparedStatementCallback` | `execute` | 由`JdbcTemplate`的执行方法使用，用于准备`PreparedStatement`。通常在实际执行之前设置绑定参数，在`doInPreparedStatement(PreparedStatement)`方法中：
    |'
- en: '| `ResultSetExtractor` | `query` | Extracts results from `ResultSet` and returns
    a domain object, inside the `extractData(ResultSet)`method:. |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '| `ResultSetExtractor` | `query` | 从`ResultSet`中提取结果并返回一个域对象，在`extractData(ResultSet)`方法中：
    |'
- en: '| `RowCallbackHandler` | `query` | Processes each row of a `ResultSet` in a
    stateful manner, inside the `processRow(Resultset)`method, which doesn''t return
    anything. |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '| `RowCallbackHandler` | `query` | 以有状态的方式处理`ResultSet`的每一行，在`processRow(Resultset)`方法中，不返回任何内容。
    |'
- en: '| `RowMapper` | `query` | Maps each row of a `ResultSet` into a domain object,
    inside the `mapRow(Resultset, int rowNum)`method, returning the created domain
    object. |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '| `RowMapper` | `query` | 将`ResultSet`的每一行映射到一个域对象中，在`mapRow(Resultset, int
    rowNum)`方法中返回创建的域对象。 |'
- en: Now let's try some nice realistic usages of `JdbcTemplate`. The following is
    a simple method executing a count query using `JdbcTemplate`.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些`JdbcTemplate`的实际用法。以下是使用`JdbcTemplate`执行计数查询的简单方法。
- en: '[PRE113]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Do you see how this straightforward one-liner code saves you from all the boilerplate
    and exception-handling code you would otherwise need to write in typical JDBC
    code?
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了吗，这条简单的一行代码如何帮你摆脱了在典型的JDBC代码中需要编写的样板和异常处理代码？
- en: 'The following code snippet is a bit more complex and illustrates how to query
    a unique row from a table and map it with a domain object (`User`, in this case)
    using `RowMapper`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段稍微复杂，演示了如何从表中查询唯一行，并使用`RowMapper`将其映射到一个域对象（在本例中为`User`）：
- en: '[PRE114]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'It is so much easier to deal with collections of data using `JdbcTemplate`.
    The following code snippet illustrates the query method of `JdbcTemplate` with
    bind parameters and a `RowMapper` that converts `ResultSet` into a list of type:
    `<Task>`.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`JdbcTemplate`处理数据集合要容易得多。以下代码片段说明了`JdbcTemplate`的查询方法，其中使用绑定参数和`RowMapper`将`ResultSet`转换为类型为`<Task>`的列表。
- en: '[PRE115]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`JdbcTemplate` takes care of all the repeating code for you and you just need
    to write the specific code, which is about how you map the data of a row with
    your domain object.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`会为您处理所有重复的代码，您只需要编写特定的代码，即如何将行的数据与您的领域对象进行映射。'
- en: 'Another variation of row mapping that uses a `ResultSetExtractor` interface
    that extracts a single row from `ResultSet` is illustrated in the following code:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用`ResultSetExtractor`接口从`ResultSet`中提取单行的行映射的变化在以下代码中说明：
- en: '[PRE116]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now let's take a look at some update statements. The following is the execution
    of a simple `INSERT` statement as one-liner code. The SQL `UPDATE` and `DELETE`
    statements follow the same pattern.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些更新语句。以下是执行简单`INSERT`语句的一行代码。SQL `UPDATE`和`DELETE`语句遵循相同的模式。
- en: '[PRE117]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The preceding method has a drawback. Although it inserts the new user record
    into the table, the generated ID (probably by a database sequence) is not returned
    back; you would need to issue another query to retrieve it separately. However,
    `JdbcTemplate` offers a nice way to solve this problem: using a `KeyHolder` class.
    It is another `variation` of the `update` method which was explained in the following
    code; you can retrieve the generated key (ID in this case) in a single execution,
    using a `KeyHolder` class in combination with `PreparedStatementCreator`:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法有一个缺点。虽然它将新用户记录插入表中，但生成的ID（可能是通过数据库序列）没有返回；您需要发出另一个查询来单独检索它。但是，`JdbcTemplate`提供了解决这个问题的好方法：使用`KeyHolder`类。这是`update`方法的另一个`variation`，在下面的代码中进行了解释；您可以使用`KeyHolder`类与`PreparedStatementCreator`结合，以单个执行中检索生成的键（在本例中是ID）：
- en: '[PRE118]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '`JdbcTemplate` makes batch updates easy, following the same pattern as shown
    earlier. Take a look at the following code: it executes a single `PreparedStatement`
    over a collection of data:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`使批量更新变得容易，遵循与前面相同的模式。看一下以下代码：它在数据集合上执行单个`PreparedStatement`：'
- en: '[PRE119]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: NamedParameterJdbcTemplate
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NamedParameterJdbcTemplate
- en: So far, we have used `JdbcTemplate` with bind parameters using `?` placeholders.
    When it comes to a bigger number of parameters, a named parameter is a better
    choice for readability and maintainability. `NamedParameterJdbcTemplate`, a specialized
    version of `JdbcTemplate,` supports using named parameters rather than traditional
    `?` placeholders. Instead of extending from `JdbcTemplate`, `NamedParameterJdbcTemplate`
    uses the underlying `JdbcTemplate` for its operations.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`JdbcTemplate`使用`?`占位符进行绑定参数。当涉及更多的参数时，使用命名参数对于可读性和可维护性更好。`NamedParameterJdbcTemplate`是`JdbcTemplate`的专门版本，支持使用命名参数而不是传统的`?`占位符。`NamedParameterJdbcTemplate`不是从`JdbcTemplate`扩展，而是使用底层的`JdbcTemplate`进行其操作。
- en: You can define `NamedParameterJdbcTemplate` in the same way as the classic `JdbcTemplate`,
    passing a `DataSource` object as a mandatory dependency. Then, you can use it
    just like `JdbcTemplate`, but using named parameters instead of bound parameters
    (`?`). The following code snippet illustrates the use of the `NamedParameterJdbcTemplate`
    query method that uses `RowMapper` for object-relational mapping.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以与经典`JdbcTemplate`相同的方式定义`NamedParameterJdbcTemplate`，将`DataSource`对象作为强制依赖项传递。然后，您可以像使用命名参数一样使用它，而不是使用绑定参数（`?`）。以下代码片段说明了使用`NamedParameterJdbcTemplate`查询方法，该方法使用`RowMapper`进行对象关系映射。
- en: '[PRE120]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: SimpleJdbc classes
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SimpleJdbc类
- en: '`SimpleJdbc` classes are another nice approach to accessing data in a more
    object-oriented fashion, but still using the same `JdbcTemplate` internally. They
    belong to the `org.springframework.jdbc.core.simple` package. There are two classes
    in it:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJdbc`类是以更面向对象的方式访问数据的另一种不错的方法，但仍然在内部使用相同的`JdbcTemplate`。它们属于`org.springframework.jdbc.core.simple`包。其中有两个类：'
- en: '`SimpleJdbcCall`'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJdbcCall`'
- en: '`SimpleJdbcInsert`'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJdbcInsert`'
- en: '`SimpleJdbcCall` handles calls to stored procedures and functions and `SimpleJdbcInsert`
    deals with SQL `INSERT` commands to database tables. Both are `DatabaseMetadata`-aware,
    hence they auto-detect or map similarly named fields of domain objects. Both of
    them act as templates for performing JDBC operations around a relational entity
    (a stored procedure or function and a database table respectively), accepting
    parameters that determine the behavior of the operation once (declared globally),
    and then reusing it repeatedly with a dynamic set of data at runtime.'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJdbcCall`处理对存储过程和函数的调用，`SimpleJdbcInsert`处理对数据库表的SQL `INSERT`命令。两者都具有`DatabaseMetadata`意识，因此它们会自动检测或映射领域对象的同名字段。它们都充当了执行关系实体（存储过程或函数和数据库表分别）周围的JDBC操作的模板，接受一次性确定操作行为的参数（在全局声明），然后在运行时重复使用具有动态数据集的参数。'
- en: 'A `SimpleJdbcCall` class is declared as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJdbcCall`类声明如下：'
- en: '[PRE121]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The preceding code declares `SimpleJdbcCall`, which invokes a stored procedure
    (in PostgreSQL, stored procedures are also called functions) and all its parameters.
    Once this is declared, it can be reused any number of times at runtime. Usually,
    you declare it at the class level (of your DAO). The following code illustrates
    how we invoke it at runtime:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了`SimpleJdbcCall`，它调用存储过程（在PostgreSQL中，存储过程也称为函数）及其所有参数。一旦声明了这个，它可以在运行时重复使用任意次数。通常，您在类级别（您的DAO）上声明它。以下代码说明了我们如何在运行时调用它：
- en: '[PRE122]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '`SimpleJdbcInsert` is typically declared as shown in the following code:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJdbcInsert`通常声明如下所示：'
- en: '[PRE123]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note the declaration of the generated key column beside the table name in the
    following code snippet. Again, this is usually declared at the class level for
    better reuse. Now, take a look at how this is invoked at runtime.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下代码片段中表名旁边生成的键列的声明。同样，这通常在类级别声明以便更好地重用。现在，看看这在运行时是如何调用的。
- en: '[PRE124]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You can see that the generated key is returned after the execution, which is
    set back to the `User` object. `SimpleJdbcCall` and `SimpleJdbcInsert` are convenient
    alternatives to the vanilla `JdbcTemplate`; you can use any of these solutions
    consistently or you can mix-and-match them in the same application.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在执行后返回生成的键，该键设置回`User`对象。`SimpleJdbcCall`和`SimpleJdbcInsert`是`JdbcTemplate`的方便替代品；您可以一致使用这些解决方案，或者在同一个应用程序中混合使用它们。
- en: JDBC operations with Sql* classes
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sql*类的JDBC操作
- en: 'A set of classes belonging to the `org.springframework.jdbc.object` package
    offers another method of performing JDBC operations in a more object-oriented
    manner. The following table lists the most common of them:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.jdbc.object`包中的一组类以更面向对象的方式执行JDBC操作。以下表格列出了其中最常见的类：'
- en: '| Component | Responsibilities |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 职责 |'
- en: '| --- | --- |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MappingSqlQuery` | Concrete representation of a SQL query, supporting a
    `RowMapper`, and having a wide variety of convenient `execute` and `find*` methods.
    Supports named parameters too. |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| `MappingSqlQuery` | SQL查询的具体表示，支持`RowMapper`，并具有各种方便的`execute`和`find*`方法。也支持命名参数。
    |'
- en: '| `SqlUpdate` | Executes an SQL update (`INSERT`, `UPDATE`, and `DELETE`) operation,
    with support for named parameters and keyholders (for retrieving generated keys).
    |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| `SqlUpdate` | 执行SQL更新（`INSERT`，`UPDATE`和`DELETE`）操作，支持命名参数和键持有者（用于检索生成的键）。
    |'
- en: '| `SqlCall` | Performs SQL-based calls for stored procedures and functions
    with support for named-parameters and keyholders (for retrieving generated keys).
    |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| `SqlCall` | 执行存储过程和函数的基于SQL的调用，支持命名参数和键持有者（用于检索生成的键）。 |'
- en: 'The following code illustrates the use of `MappingSqlQuery`:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例了`MappingSqlQuery`的使用：
- en: '[PRE125]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'SQL updates (`INSERT`, `UPDATE`, and `DELETE`) can be performed using `SqlUpdate`
    with a more descriptive code, as the example in the following code illustrates:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`SqlUpdate`执行SQL更新（`INSERT`，`UPDATE`和`DELETE`），代码更具描述性，如下面的示例代码所示：
- en: '[PRE126]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`SqlUpdate` provides a variety of convenient update methods, suitable for many
    parameter combinations. You can mix-and-match any of the preceding listed Spring
    JDBC components according to your convenience and preferred programming style.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlUpdate`提供了各种方便的更新方法，适用于许多参数组合。您可以根据自己的方便和首选的编程风格混合使用前面列出的任何Spring JDBC组件。'
- en: Spring Data
  id: totrans-919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: Spring Data is an umbrella project under the Spring portfolio, designed to provide
    consistent data access across a number of different data stores including relational
    and NoSQL Databases, and other types of data stores such as REST (HTTP), search
    engines, and Hadoop. Under Spring Data, there are subprojects for each specific
    approach and data store, put together by companies or developers of those technologies.
    Spring Data significantly simplifies the building of the data layer regardless
    of the underlying database and persistence technology.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data是Spring系列下的一个总称项目，旨在提供跨多种不同数据存储的一致数据访问，包括关系型和NoSQL数据库，以及其他类型的数据存储，如REST（HTTP）、搜索引擎和Hadoop。在Spring
    Data下，有针对每种特定方法和数据存储的子项目，由这些技术的公司或开发人员组合而成。Spring Data显著简化了数据层的构建，无论底层数据库和持久化技术如何。
- en: 'The following table lists a few Spring Data subprojects with a short description
    of each:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些Spring Data子项目及其简要描述：
- en: '| Project | Description |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 描述 |'
- en: '| --- | --- |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Spring Data Commons | Contains a core Spring Data repository specification
    and supporting classes for all Spring Data projects. Specifies concepts such as
    repository, query, auditing, and history. |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data Commons | 包含核心Spring Data存储库规范和所有Spring Data项目的支持类。指定存储库、查询、审计和历史等概念。
    |'
- en: '| Spring Data JPA | Deals with JPA-based repositories. |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data JPA | 处理基于JPA的存储库。 |'
- en: '| Spring Data MongoDB | Provides easy integration with MongoDB, including support
    for query, criteria, and update DSLs. |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data MongoDB | 提供与MongoDB的轻松集成，包括对查询、条件和更新DSL的支持。 |'
- en: '| Spring Data Redis | Integrates with the Redis in-memory data structure store,
    from Spring applications. |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data Redis | 与Redis内存数据结构存储集成，来自Spring应用程序。 |'
- en: '| Spring Data Solr | Provides integration with Apache Solr, a powerful, open
    source search platform based on Apache Lucene. |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data Solr | 提供与Apache Solr的集成，这是一个基于Apache Lucene的强大的开源搜索平台。 |'
- en: '| Spring Data Gemfire | Provides easy integration with Pivotal Gemfire, a data
    management platform that provides real-time data access, reliable asynchronous
    event notifications, and guaranteed message delivery. |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data Gemfire | 提供与Pivotal Gemfire的轻松集成，这是一个提供实时数据访问、可靠的异步事件通知和保证消息传递的数据管理平台。
    |'
- en: '| Spring Data KeyValue | Deals with key value-based data stores. |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data KeyValue | 处理基于键值的数据存储。 |'
- en: '| Spring Data REST | Exposes repositories with REST APIs. |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data REST | 用REST API公开存储库。 |'
- en: The Spring Data portfolio contains community modules for more data stores that
    are not covered by the official Spring Data projects. Communities of several very
    popular open source and proprietary databases are contributing to these projects,
    which makes Spring Data an excellent source of proven solutions for building the
    data-access layer of enterprise applications regardless of the underlying data
    store. Cassandra, Neo4J, Couchbase, and ElasticSearch are some examples of community
    projects based on Spring Data.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data组合包含了更多官方Spring Data项目未涵盖的数据存储的社区模块。几个非常流行的开源和专有数据库的社区正在为这些项目做出贡献，这使得Spring
    Data成为构建企业应用程序数据访问层的经过验证的解决方案的绝佳来源，无论底层数据存储是什么。Cassandra、Neo4J、Couchbase和ElasticSearch是基于Spring
    Data的社区项目的一些例子。
- en: Spring Data Commons
  id: totrans-933
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Data Commons
- en: Spring Data standardizes data-access via all its store-specific modules (subprojects)
    through a consistent API called Spring Data Commons. Spring Data Commons is the
    foundational specification and a guideline for all Spring Data Modules. All Spring
    Data subprojects are store-specific implementations of Spring Data Commons.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data通过名为Spring Data Commons的一致API标准化了所有存储特定模块（子项目）的数据访问。Spring Data Commons是所有Spring
    Data模块的基本规范和指南。所有Spring Data子项目都是Spring Data Commons的存储特定实现。
- en: Spring Data Commons defines the core components and general behaviors of Spring
    Data modules.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Commons定义了Spring Data模块的核心组件和一般行为。
- en: Spring Data repository specification
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data存储库规范
- en: Query derivation methods
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询派生方法
- en: Web support
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web支持
- en: Auditing
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: We will examine each of these components, their setup, and usage in the following
    sections.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分检查每个组件及其设置和用法。
- en: Spring Data repository specification
  id: totrans-941
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Data存储库规范
- en: '`org.springframework.data.repository.Repository` is the central interface of
    Spring Data abstraction. This marker interface is a part of Spring Data Commons
    and has two specialized extensions, `CrudRepository` and `PagingAndSortingRepository`.'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.data.repository.Repository`是Spring Data抽象的中心接口。这个标记接口是Spring
    Data Commons的一部分，有两个专门的扩展，`CrudRepository`和`PagingAndSortingRepository`。'
- en: '[PRE127]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: A repository manages a domain entity (designed as a POJO). `CrudRepository`
    provides CRUD with the following CRUD operations for an entity.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库管理域实体（设计为POJO）。`CrudRepository`为实体提供了以下CRUD操作。
- en: '`save(One)`, `save(List)`'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save(One)`，`save(List)`'
- en: '`find`, `findOne`, `findAll`'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`，`findOne`，`findAll`'
- en: '`delete`, `deleteAll`'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`，`deleteAll`'
- en: '`count`'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`'
- en: '`exists`'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists`'
- en: '`PagingAndSortingRepository` adds pagination and sorting features over `CrudRepository`.
    It has the following two methods:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository`在`CrudRepository`上添加了分页和排序功能。它有以下两种方法：'
- en: '`Page<T> findAll(Pageable)`'
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Page<T> findAll(Pageable)`'
- en: '`Iterable<T> findAll(Sort)`'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable<T> findAll(Sort)`'
- en: 'Now is time to jump ahead and discuss the technology and store-specific modules
    of Spring Data. We are covering Spring Data JPA and Spring Data MongoDB to illustrate
    two totally different worlds in the database universe: relational and NoSQL. When
    we use a specific implementation, we use an implementation-specific repository
    but your method interfaces remain the same; hence, theoretically, a switch from
    a specific Spring Data implementation to another would not affect your client
    programs (service, controller, or test cases).'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向前跳转并讨论Spring Data的技术和存储特定模块。我们将涵盖Spring Data JPA和Spring Data MongoDB，以说明数据库宇宙中的两个完全不同的世界：关系和NoSQL。当我们使用特定实现时，我们使用特定于实现的存储库，但您的方法接口保持不变；因此，理论上，从特定的Spring
    Data实现切换到另一个不会影响您的客户端程序（服务、控制器或测试用例）。
- en: Spring Data JPA
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Data JPA
- en: Spring Data JPA is the **JPA** (**Java Persistence Architecture**)-based implementation
    of Spring Data, dealing with object-relational data access. For a developer, most
    of the programming is based on what is described in Spring Data Commons, whereas
    Spring Data JPA allows for some extra customizations specific to relational SQL
    and JPA. The main difference is in the repository setup and the query optimization
    using the `@Query` annotation.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA是基于**JPA**（**Java持久性架构**）的Spring Data实现，处理对象关系数据访问。对于开发人员，大部分编程都是基于Spring
    Data Commons中描述的内容，而Spring Data JPA允许进行一些特定于关系SQL和JPA的额外定制。主要区别在于存储库设置和使用`@Query`注解进行查询优化。
- en: Enabling Spring Data JPA
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用Spring Data JPA
- en: 'Enabling Spring Data JPA in your project is a simple two-step process:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目中启用Spring Data JPA是一个简单的两步过程：
- en: Add the `spring-data-jpa` dependency to your `maven/gradle` build file.
  id: totrans-958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spring-data-jpa`依赖项添加到您的`maven/gradle`构建文件中。
- en: Declare enable JPA repositories in your bean configuration.
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean配置中声明启用JPA存储库。
- en: 'In Maven, you can add a `spring-data-jpa` dependency as shown in the following
    code:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven中，您可以像下面的代码一样添加`spring-data-jpa`依赖项：
- en: '[PRE128]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can enable JPA repositories, as shown in the following line, if you are
    using XML:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用XML，可以启用JPA存储库，如下所示：
- en: '[PRE129]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In the case of Java configuration, you just annotate to enable JPA repositories.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java配置的情况下，您只需注释以启用JPA存储库。
- en: '[PRE130]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: JpaRepository
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JpaRepository
- en: 'After enabling JPA repositories, Spring scans the given package for Java classes
    annotated with `@Repository`, and creates fully-featured proxy objects ready to
    be used. These are your DAO, where you just define the methods, Spring gives you
    proxy-based implementations at runtime. See a simple example:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 启用JPA存储库后，Spring会扫描给定包中使用`@Repository`注释的Java类，并创建完全功能的代理对象，准备供使用。这些是您的DAO，您只需定义方法，Spring会在运行时为您提供基于代理的实现。看一个简单的例子：
- en: '[PRE131]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Spring generates smart implementations that actually perform the required database
    operations for these methods inside the proxy implementation, looking at the method
    names and arguments.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: Spring生成智能实现，实际上在代理实现内部执行所需的数据库操作，查看方法名称和参数。
- en: Spring Data MongoDB
  id: totrans-970
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Data MongoDB
- en: MongoDB is one of the most popular document-oriented NoSQL databases. It stores
    data in **BSON** (**Binary JSON**) format, allowing you to store an entire complex
    object in nested structures, avoiding the need to break data into a lot of relational
    tables. Its nested object structure maps directly to object-oriented data structures
    and eliminates the need for any object-relational mapping, as is the case with
    JPA/Hibernate.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是最受欢迎的面向文档的NoSQL数据库之一。它以**BSON**（**二进制JSON**）格式存储数据，允许您将整个复杂对象存储在嵌套结构中，避免将数据分解成大量关系表的需求。其嵌套对象结构直接映射到面向对象的数据结构，并消除了任何对象关系映射的需求，就像JPA/Hibernate一样。
- en: Spring Data MongoDB is the Spring Data module for MongoDB. It allows Java objects
    to be mapped directly into MongoDB documents. It also provides a comprehensive
    API and infrastructural support for connecting to MongoDB and manipulating its
    document collections.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data MongoDB是MongoDB的Spring Data模块。它允许将Java对象直接映射到MongoDB文档。它还为连接到MongoDB并操作其文档集合提供了全面的API和基础支持。
- en: Enabling Spring Data MongoDB
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用Spring Data MongoDB
- en: 'Spring Data MongoDB can be enabled with the following steps:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data MongoDB可以通过以下步骤启用：
- en: Add `spring-data-mongodb` to your build file (`maven/gradle`).
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件（`maven/gradle`）中添加`spring-data-mongodb`。
- en: Register a Mongo instance in your Spring metadata configuration.
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring元数据配置中注册一个Mongo实例。
- en: Add a `mongoTemplate` Spring Bean to your Spring metadata.
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Spring元数据添加`mongoTemplate` Spring Bean。
- en: 'Adding the `spring-data-mongodb` dependency with Maven should look like this:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven添加`spring-data-mongodb`依赖项应该如下所示：
- en: '[PRE132]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can register a Mongo instance in your XML metadata, as shown in the following
    line:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在XML元数据中注册一个Mongo实例，如下行所示：
- en: '[PRE133]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This Mongo instance is a proxy of your actual MongoDB instance running on a
    server.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Mongo实例是运行在服务器上的实际MongoDB实例的代理。
- en: 'A simplistic `mongoTemplate` looks like the listing given in the following
    code:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`mongoTemplate`看起来像以下代码中给出的清单：
- en: '[PRE134]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: MongoRepository
  id: totrans-985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MongoRepository
- en: 'MongoRepository is the MongoDB-specific repository for Spring Data MongoDB.
    It looks very similar to `JpaRepository`. Take a look at a sample `MongoRepository`
    class:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: MongoRepository是Spring Data MongoDB的特定于MongoDB的存储库。它看起来非常类似于`JpaRepository`。看一个样本`MongoRepository`类：
- en: '[PRE135]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Domain objects and entities
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域对象和实体
- en: Data-driven applications often design domain objects as entities and then persist
    them into databases either as relational tables or document structures of key-value
    pairs at runtime. Spring Data deals with domain entities like any other persistence
    framework. In order to illustrate the usage of a repository, we will refer to
    the following three related entities, designed as **Plain Old Java Objects** (**POJOs**)
    in your program.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动的应用程序通常将领域对象设计为实体，然后在运行时将它们持久化到数据库中，可以是关系表，也可以是键值对文档结构。Spring Data处理领域实体就像处理任何其他持久化框架一样。为了说明存储库的用法，我们将引用以下三个相关实体，它们在程序中设计为**普通的旧Java对象**（**POJOs**）。
- en: '![Domain objects and entities](img/image00787.jpeg)'
  id: totrans-990
  prefs: []
  type: TYPE_IMG
  zh: '![领域对象和实体](img/image00787.jpeg)'
- en: The following are the Java representations. The first one is annotated for JPA
    and the other two for MongoDB. JPA entities are annotated with `@Entity`. Columns
    are mapped against each field. Remember that, instead of annotations, you can
    use XML-based mapping for JPA entities too. XML mapping offers several benefits
    including centralized control and maintainability. This example uses annotations
    for simplicity, assuming that the reader is already familiar with JPA or Hibernate
    mappings.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java表示。第一个是用于JPA的注释，另外两个是用于MongoDB的。JPA实体使用`@Entity`进行注释。列映射到每个字段。请记住，除了注释之外，您还可以使用基于XML的映射来为JPA实体进行映射。XML映射提供了包括集中控制和可维护性在内的多个好处。本例中为简单起见使用注释，假设读者已经熟悉JPA或Hibernate映射。
- en: '[PRE136]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The following is the task entity, annotated as a MongoDB document. Mongo entities
    are annotated with `@Document`. It requires an ID field, either annotated with
    `@Id` or with the name `id`.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是任务实体，注释为MongoDB文档。Mongo实体使用`@Document`进行注释。它需要一个ID字段，可以用`@Id`进行注释，也可以用名称`id`进行注释。
- en: '[PRE137]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The file entity is annotated as a JPA entity.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 文件实体被注释为JPA实体。
- en: '[PRE138]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Query resolution methods
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询解析方法
- en: 'In addition to the declared query (`find`, `count`, `delete`, `remove`, and
    `exists`) methods at interface level, `CrudRepository` supports declared queries
    using the `@Query` annotation methods with any name, which helps to derive the
    actual SQL queries from the **SpEL** (**Spring Expression Language**) expression
    given as a parameter. Of these two query deriving options, Spring Data adopts
    one based on the following query lookup strategies:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在接口级别声明的查询（`find`，`count`，`delete`，`remove`和`exists`）方法外，`CrudRepository`还支持使用`@Query`注解方法声明查询，该注解方法可以使用任何名称，这有助于从作为参数给定的**SpEL**（**Spring
    Expression Language**）表达式中派生实际的SQL查询。在这两种查询派生选项中，Spring Data采用以下查询查找策略之一：
- en: '| Query Lookup Strategy | Description |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
  zh: '| 查询查找策略 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CREATE` | Generates module-specific queries from the method name. |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE` | 从方法名称生成特定于模块的查询。 |'
- en: '| `USE_DECLARED_QUERY` | Uses a query declared by an annotation or some other
    means. |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '| `USE_DECLARED_QUERY` | 使用由注解或其他方式声明的查询。 |'
- en: '| `CREATE_IF_NOT_FOUND` | This strategy combines the first two. This is the
    default strategy. |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE_IF_NOT_FOUND` | 此策略结合了前两种策略。这是默认策略。 |'
- en: The query lookup strategy is normally set while enabling JPA repositories.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 查询查找策略通常在启用JPA存储库时设置。
- en: '[PRE139]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The query generation strategy (`CREATE`) works around the properties of the
    entity, including their dependencies, in a nested direction. As a developer, you
    define method names based on a specific format that can be interpreted and realized
    by Spring Data. The general structure of the query method is shown here:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 查询生成策略（`CREATE`）围绕实体的属性及其依赖关系以嵌套方式工作。作为开发人员，您可以根据特定格式定义方法名称，这些方法名称可以被Spring
    Data解释和实现。查询方法的一般结构如下所示：
- en: '`[return Type] [queryType][limitKeyword]By[criteria][OrderBy][sortDirection]`'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '`[return Type] [queryType][limitKeyword]By[criteria][OrderBy][sortDirection]`'
- en: '`return type` can be the entity `<T>` itself (in the case of a unique result),
    a list `<T>`, a stream `<T>`, page `<T>`, primitive numbers, Java wrapper types,
    void, future `<T>`, `CompletableFuture<T>`, `ListenableFuture<T>`, and so on.
    The last three are for Spring''s asynchronous method execution and should be annotated
    with `@Async`.'
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`返回类型`可以是实体`<T>`本身（在唯一结果的情况下），列表`<T>`，流`<T>`，页面`<T>`，原始数字，Java包装类型，void，future`<T>`，`CompletableFuture<T>`，`ListenableFuture<T>`等。最后三个用于Spring的异步方法执行，并应该用`@Async`注解。'
- en: '`queryType` can be `find`, `read`, `query`, `count`, `exists`, `delete`, and
    so on.'
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryType`可以是`find`，`read`，`query`，`count`，`exists`，`delete`等。'
- en: '`limitKeyword` supports `distinct`, `First[resultSize]`, and `Top[resultSize]`.
    An example is `First5`.'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limitKeyword`支持`distinct`，`First[resultSize]`和`Top[resultSize]`。例如`First5`。'
- en: '`criteria` is built by combining one or more property expressions (using camel-casing)
    with standard operators such as `Or`, `And`, `Between`, `GreaterThan`, `LessThan`,
    `IsNull`, `StartsWith`, and `Exists`. Criteria can be suffixed by `IgnoreCase`
    or `AllIgnoreCase`, to apply case insensitivity.'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`criteria`是通过将一个或多个属性表达式（使用驼峰命名法）与`Or`、`And`、`Between`、`GreaterThan`、`LessThan`、`IsNull`、`StartsWith`和`Exists`等标准运算符组合而成的。条件可以后缀为`IgnoreCase`或`AllIgnoreCase`，以应用大小写不敏感性。'
- en: '`OrderBy` is used as it is, suffixed by property expressions.'
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`按原样使用，后面跟着属性表达式。'
- en: '`sortDirection` can be either of `Asc` or `Desc`. This is used only with `OrderBy`.'
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortDirection`可以是`Asc`或`Desc`中的任意一个。这仅与`OrderBy`一起使用。'
- en: Let's see some examples for better clarity. The following sample code illustrates
    how to construct query (or delete) methods so that Spring Data can generate the
    actual SQL query at runtime.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些示例以更清晰地说明。以下示例代码说明了如何构造查询（或删除）方法，以便Spring Data可以在运行时生成实际的SQL查询。
- en: '[PRE140]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The preceding example showing `JpaRepository` and `MongoRepository` works in
    the same way; you just need to extend from it, without changing the method signatures.
    You have seen the constraining query and filter methods traversing root-level
    properties of the entity, combining operators appropriately. Besides root-level
    properties, you can traverse and filter by nested properties as well, to define
    query constraints, in other words, limiting the result. Take a look at the following
    example:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示`JpaRepository`和`MongoRepository`的工作方式相同；您只需要扩展它，而不需要更改方法签名。您已经看到了遍历实体的根级属性，适当组合运算符的约束查询和过滤方法。除了根级属性，您还可以遍历和过滤嵌套属性，以定义查询约束，换句话说，限制结果。看一下以下示例：
- en: '[PRE141]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The methods listed in the preceding example are traversing nested properties
    of the task entity:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中列出的方法中，遍历了任务实体的嵌套属性：
- en: '`findByAssigneeId = task.assignee.id`'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findByAssigneeId = task.assignee.id`'
- en: '`findByAssigneeUserName = task.assignee.userName`'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findByAssigneeUserName = task.assignee.userName`'
- en: You can traverse into any level of nested elements of your entity, depending
    on how complex your entity and requirements are.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据实体的复杂程度和要求，遍历实体的任何嵌套元素级别。
- en: Using the @Query annotation
  id: totrans-1022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@Query注释
- en: 'Besides the autogeneration of queries based on method names as demonstrated
    in the previous section, Spring Data allows you to declare queries for entities
    locally, directly in the repository itself, over the method names. You declare
    the query using SpEL, and Spring Data interprets it at runtime and (the proxy
    repository) generates the queries for you. This is an implementation of the query
    resolution strategy: `USE_DECLARED_QUERY`.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根据方法名称自动生成查询的自动生成查询之外，Spring Data还允许您在存储库本身中直接声明实体的查询，而不是方法名称。您可以使用SpEL声明查询，Spring
    Data会在运行时解释它，并（代理存储库）为您生成查询。这是查询解析策略的一种实现：`USE_DECLARED_QUERY`。
- en: 'Let''s take a look at some self-explanatory examples:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些不言自明的例子：
- en: '[PRE142]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can see from the preceding example that we can traverse into nested properties
    to constrain the queries, in the criteria part of it. You can also have both query
    generation strategies (`CREATE` and `USE_DECLARED_QUERY`) in the same repository.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以看出，我们可以遍历嵌套属性以限制查询，在其中的条件部分。您还可以在同一个存储库中同时拥有查询生成策略（`CREATE`和`USE_DECLARED_QUERY`）。
- en: The preceding example was based on Spring Data JPA; the Spring Data MongoDB
    equivalent is given in the following code. You can see how the `@Query` annotation
    values differ in comparison to the MongoDB structure.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是基于Spring Data JPA的；Spring Data MongoDB的等效部分在以下代码中给出。您可以看到`@Query`注释值与MongoDB结构相比有何不同。
- en: '[PRE143]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Spring Data web support extensions
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Data web支持扩展
- en: Spring Data provides a smart extension called `SpringDataWebSupport` to Spring
    MVC applications, integrating a few productivity components automatically if you
    enable it. It primarily resolves domain entities as `Pageable` and `Sort` instances
    with request-mapping controller methods directly from request parameters, if you
    are using Spring Data repository programming model for data access.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data为Spring MVC应用程序提供了一个智能扩展，称为`SpringDataWebSupport`，如果您启用它，它会自动集成一些生产力组件。如果您正在使用Spring
    Data存储库编程模型进行数据访问，它主要会直接从请求参数中解析域实体作为`Pageable`和`Sort`实例，并与请求映射控制器方法集成。
- en: 'You need to enable `SpringDataWebSupport` for your project before you can use
    the features. You can annotate `@EnableSpringDataWebSupport`, as shown in the
    following code, if you are using a Java configuration:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些功能之前，您需要为项目启用`SpringDataWebSupport`。如果您使用Java配置，可以像以下代码中所示注释`@EnableSpringDataWebSupport`。
- en: '[PRE144]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In the case of XML metadata, you can register `SpringDataWebConfiguration`
    as a Spring bean, as shown in the following code:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML元数据的情况下，您可以像以下代码中所示将`SpringDataWebConfiguration`注册为Spring bean：
- en: '[PRE145]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Once you set up `SpringDataWebSupport`, you can start using Spring Data entities
    as request arguments with request-mapping methods, as shown in the following code:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了`SpringDataWebSupport`，您就可以开始在请求映射方法中使用Spring Data实体作为请求参数，如下面的代码所示：
- en: '[PRE146]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In the preceding method, you can see that Spring Data loads the `User` entity
    data using `UserRepository` transparently for you. Similarly, you can accept `Pageable`
    and `Sort` instances against JSON or XML post requests. Wise usage of the `SpringDataWebSupport`
    extension makes your code cleaner and more maintainable.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，您可以看到Spring Data会透明地为您使用`UserRepository`加载`User`实体数据。同样，您可以接受针对JSON或XML的POST请求的`Pageable`和`Sort`实例。明智地使用`SpringDataWebSupport`扩展可以使您的代码更清洁和更易于维护。
- en: Auditing with Spring Data
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Spring Data进行审计
- en: 'Tracking data modifications is a critical feature of serious business applications.
    Administrators and managers are anxious to know when and who changed certain business
    information saved in the database. Spring Data provides smart and easy methods
    for auditing data entities transparently. Spring Data ships the following meaningful
    annotations for capturing modified user and time data entities in the system:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪数据修改是严肃业务应用程序的关键特性。管理员和经理急于知道数据库中保存的某些业务信息是何时以及谁进行了更改。Spring Data提供了智能且简单的方法，可以透明地审计数据实体。Spring
    Data提供了以下有意义的注释，用于在系统中捕获修改的用户和时间数据实体：
- en: '| Annotation | Expected type |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | 预期类型 |'
- en: '| --- | --- |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@CreatedBy` | The principal user who created the entity. Typically, it is
    another entity that represents the domain user. |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '| `@CreatedBy` | 创建实体的主体用户。通常，它是表示域用户的另一个实体。 |'
- en: '| `@CreatedDate` | Records when the entity is created. Supported types: `java.util.Date`,
    calendar, JDK 8 date/time types, `Joda DateTime`. |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '| `@CreatedDate` | 记录实体创建的时间。支持的类型：`java.util.Date`、日历、JDK 8日期/时间类型、`Joda DateTime`。
    |'
- en: '| `@LastModifiedBy` | The user principal who last updated the entity. It is
    the same type as `@CreatedBy`. |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
  zh: '| `@LastModifiedBy` | 最后更新实体的用户主体。与 `@CreatedBy` 相同类型。 |'
- en: '| `@LastModifiedDate` | Records when the entity was last updated. Supported
    types are the same as for `@CreatedDate`. |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| `@LastModifiedDate` | 记录实体上次更新的时间。支持的类型与 `@CreatedDate` 相同。 |'
- en: 'A typical JPA entity should look like the following code:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的JPA实体应该如下所示的代码：
- en: '[PRE147]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: If you are using XML instead of annotations to map your entities, you can either
    implement an auditable interface, which forces you to implement the audit metadata
    fields, or extend `AbstractAuditable`, a convenient base class provided by Spring
    Data.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用XML而不是注释来映射实体，则可以实现一个可审计接口，该接口强制您实现审计元数据字段，或者扩展 `AbstractAuditable`，这是Spring
    Data提供的一个方便的基类。
- en: 'Since you are recording the information of the user who is creating and modifying
    entities, you need to help Spring Data to capture that user information from the
    context. You need to register a bean that implements `AuditAware<T>`, where `T`
    is the same type of field that you annotated with `@CreatedBy` and `@LastModifiedBy`.
    Take a look at the following example:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您记录了创建和修改实体的用户信息，您需要帮助Spring Data从上下文中捕获该用户信息。您需要注册一个实现了 `AuditAware<T>` 的bean，其中
    `T` 是您用 `@CreatedBy` 和 `@LastModifiedBy` 注释的字段的相同类型。看一下以下示例：
- en: '[PRE148]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'If you are using Spring Security for authentication, then the `getCurrentAuditor`
    method should get and return the user from the `SecurityContextHolder` class,
    as follows:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Spring Security进行身份验证，那么 `getCurrentAuditor` 方法应该从 `SecurityContextHolder`
    类中获取并返回用户，如下所示：
- en: '[PRE149]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Now your auditing infrastructure is ready, any modification you make in your
    auditable entities will be tracked transparently by Spring Data.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的审计基础设施已经准备就绪，您对可审计实体所做的任何修改都将被Spring Data透明地跟踪。
- en: So far you have mastered the mighty Spring Data and you know how to create elegant
    and clean yet really powerful data access layers with Spring Data repositories,
    so now it is time to think about how to ensure the data integrity and reliability
    of your application. Spring Transaction is the answer; let's explore it in the
    next section.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经掌握了强大的Spring Data，并且知道如何使用Spring Data存储库创建优雅、干净但非常强大的数据访问层，现在是时候考虑如何确保应用程序的数据完整性和可靠性了。Spring事务就是答案；让我们在下一节中探讨它。
- en: Spring Transaction support
  id: totrans-1055
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring事务支持
- en: Data-driven enterprise systems consider data integrity as paramount, hence transaction
    management is a critical feature supported by major databases and application
    servers. Spring framework provides comprehensive transaction support, abstracting
    any underlying infrastructure. Spring Transaction support includes a consistent
    approach across different transaction choices such as JTA, JPA, and JDO. It integrates
    well with all Spring data-access mechanisms. Spring Transaction supports both
    declarative and programmatic transaction management.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动的企业系统将数据完整性视为至关重要，因此事务管理是主要数据库和应用服务器支持的关键功能。Spring框架提供了全面的事务支持，抽象了任何底层基础设施。Spring事务支持包括跨不同事务选择的一致方法，如JTA、JPA和JDO。它与所有Spring数据访问机制很好地集成。Spring事务支持声明式和编程式事务管理。
- en: Note
  id: totrans-1057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **transaction** can be defined as an atomic unit of data exchange, typically
    SQL statements in the case of relational databases, which should be either committed
    or rolled back as a block (all or nothing). A transactional system or a transaction
    management framework enforces **ACID** (**Atomic**, **Consistent**, **Isolated**,
    **Durable**) properties across the participating systems or resources (such as
    databases and messaging queues).
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务** 可以被定义为数据交换的原子单位，通常是关系数据库中的SQL语句，应该作为一个块（全部或无）提交或回滚。事务系统或事务管理框架在参与系统或资源（如数据库和消息队列）之间强制执行**ACID**（**原子性**、**一致性**、**隔离性**、**持久性**）属性。'
- en: Relevance of Spring Transaction
  id: totrans-1059
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring事务的相关性
- en: Enterprise Java application servers natively provide **JTA** (**Java Transaction
    API**) support, which enables distributed transaction, which is also known as
    global transaction, spanning multiple resources, applications and servers. Traditionally,
    **Enterprise Java Beans** (**EJB**) and **Message Driven Beans** (**MDB**) were
    used for **container-managed transactions** (**CMT**), which is based on JTA and
    JNDI. JTA transaction management is resource-intensive; its exception handling
    is based on checked exceptions and so is not developer-friendly. Moreover, unit
    testing is hard with EJB CMT.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 企业Java应用服务器本地提供**JTA**（**Java事务API**）支持，它使分布式事务（也称为全局事务）跨多个资源、应用程序和服务器。传统上，**企业Java
    Bean**（**EJB**）和**消息驱动Bean**（**MDB**）用于**容器管理的事务**（**CMT**），它基于JTA和JNDI。JTA事务管理资源密集型；其异常处理基于已检查的异常，因此不利于开发人员。此外，使用EJB
    CMT进行单元测试很困难。
- en: For those who do not want to use resource-intensive JTA transactions, a local
    transaction is another available option, and one that allows you to programmatically
    enforce resource-specific transactions using APIs such as JDBC. Although relatively
    easy to use, it is limited to a single resource, as multiple resources cannot
    participate in a single transaction. Moreover, local transactions are often invasive,
    hence they pollute your code.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不想使用资源密集型的JTA事务的人来说，本地事务是另一个可用的选项，它允许您使用诸如JDBC之类的API来以编程方式强制执行特定于资源的事务。虽然相对容易使用，但它仅限于单个资源，因为多个资源不能参与单个事务。此外，本地事务通常是侵入性的，因此会污染您的代码。
- en: Spring Transaction abstraction solves the problems of global and local transactions
    by providing a consistent transaction model that can run in any environment. Although
    it supports both declarative and programmatic transaction management, the declarative
    model is sufficient for most cases. Spring Transaction eliminates the need for
    an application server such as JBoss or WebLogic just for transactions. You can
    start with local transactions using Spring on a simple Servlet engine such as
    Tomcat and scale it up later to distributed transactions on an application server
    without touching your business code, just by changing the transaction manager
    in your Spring metadata.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务抽象通过提供一个一致的事务模型来解决全局和本地事务的问题，可以在任何环境中运行。虽然它支持声明式和编程式事务管理，但对于大多数情况来说，声明式模型已经足够了。Spring事务消除了仅仅为了事务而需要像JBoss或WebLogic这样的应用服务器的需求。您可以从在简单的Servlet引擎（如Tomcat）上使用Spring的本地事务开始，然后在不触及业务代码的情况下，通过更改Spring元数据中的事务管理器，将其扩展到应用服务器上的分布式事务。
- en: Most applications just need local transactions since they do not deal with multiple
    servers or transactional resources such as databases, JMS, and JCA; hence, they
    do not need a full-blown application server. For distributed transactions spanned
    across multiple servers over remote calls, you need JTA, necessitating an application
    server, as JTA needs JNDI to look up the data source. JNDI is normally available
    only in an application server. Use `JTATransactionManager` inside application
    servers for JTA capabilities.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序只需要本地事务，因为它们不涉及多个服务器或诸如数据库、JMS和JCA之类的事务资源；因此，它们不需要一个完整的应用服务器。对于跨多个服务器的分布式事务，需要JTA，这需要一个应用服务器，因为JTA需要使用JNDI来查找数据源。JNDI通常只在应用服务器中可用。在应用服务器内部使用`JTATransactionManager`来实现JTA功能。
- en: Note
  id: totrans-1064
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you deploy your Spring application inside an application server, you can
    use server-specific transaction managers to utilize their full features. Just
    switch the transaction manager to use server-specific `JtaTransactionManager`
    implementations such as `WebLogicJTATransactionManager` and `WebSphereUowTransactionManager`
    inside your Spring metadata. All your code is completely portable now.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用服务器内部部署Spring应用程序时，您可以使用特定于服务器的事务管理器来利用它们的全部功能。只需将事务管理器切换到使用特定于服务器的`JtaTransactionManager`实现，如`WebLogicJTATransactionManager`和`WebSphereUowTransactionManager`，并将其放入Spring元数据中。现在您的所有代码都是完全可移植的。
- en: Spring Transaction fundamentals
  id: totrans-1066
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring事务基础
- en: Spring Transaction Management abstraction is designed around an interface named
    `PlatformTransactionManager`, which you need to configure as a Spring bean in
    your Spring metadata. `PlatformTransactionManager` manages the actual transaction
    instance that performs the transaction operations such as commit and rollback,
    based on a `TransactionDefinition` instance that defines the transaction strategy.
    `TransactionDefinition` defines the critical transaction attributes such as isolation,
    propagation, transaction timeout, and the read-only status of a given transaction
    instance.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务管理抽象是围绕一个名为`PlatformTransactionManager`的接口设计的，您需要在Spring元数据中将其配置为Spring
    bean。`PlatformTransactionManager`管理执行事务操作的实际事务实例，如提交和回滚，基于定义事务策略的`TransactionDefinition`实例。`TransactionDefinition`定义了关键的事务属性，如隔离、传播、事务超时和给定事务实例的只读状态。
- en: Note
  id: totrans-1068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Transaction attributes determine the behavior of transaction instances. They
    can be set programmatically as well as declaratively. Transaction attributes are:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 事务属性决定了事务实例的行为。它们可以以编程方式设置，也可以以声明方式设置。事务属性包括：
- en: '**Isolation level**: Defines how much a transaction is isolated from (can see)
    other transactions running in parallel. Valid values are: `None`, `Read committed`,
    `Read uncommitted`, `Repeatable reads`, and `Serializable`. `Read committed` cannot
    see dirty reads from other transactions.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别：定义了一个事务与并行运行的其他事务之间的隔离程度。有效值包括：`None`、`Read committed`、`Read uncommitted`、`Repeatable
    reads`和`Serializable`。`Read committed`不能看到其他事务的脏读。
- en: '**Propagation**: Determines the transactional scope of a database operation
    in relation to other operations before, after, and nested inside itself. Valid
    values are: `REQUIRED`, `REQUIRES_NEW`, `NESTED`, `MANDATORY`, `SUPPORTS`, `NOT_SUPPORTED`,
    and `NEVER`.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 传播：确定数据库操作的事务范围，与其自身之前、之后和嵌套在其内部的其他操作相关。有效值包括：`REQUIRED`、`REQUIRES_NEW`、`NESTED`、`MANDATORY`、`SUPPORTS`、`NOT_SUPPORTED`和`NEVER`。
- en: '**Timeout**: Maximum time period that a transaction can keep running or waiting
    before it completes. Once at timeout, it will roll back automatically.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 超时：事务在完成之前可以持续运行或等待的最长时间段。一旦超时，它将自动回滚。
- en: '**Read-only status**: You cannot save the data read in this mode.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 只读状态：在此模式下，您无法保存读取的数据。
- en: These transaction attributes are not specific to Spring, but reflect standard
    transactional concepts. The `TransactionDefinition` interface specifies these
    attributes in the Spring Transaction Management context.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事务属性并不特定于Spring，而是反映了标准的事务概念。`TransactionDefinition`接口在Spring事务管理上下文中指定了这些属性。
- en: Depending on your environment (standalone, web/app server) and the persistence
    mechanism you use (such as plain JDBC, JPA, and Hibernate), you choose the appropriate
    implementation of `PlatformTransactionManager` and configure it as required, in
    your Spring metadata. Under the hood, using Spring AOP, Spring injects `TransactionManager`
    into your proxy DAO (or `EntityManager`, in the case of JPA) and executes your
    transactional methods, applying transaction semantics declared in your Spring
    configuration, either using the `@Transactional` annotation or the equivalent
    XML notations. We will discuss the `@Transactional` annotation and its XML equivalent
    later on in this chapter.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的环境（独立、web/app服务器）和您使用的持久化机制（如纯JDBC、JPA和Hibernate），您可以选择适当的`PlatformTransactionManager`实现，并根据需要在Spring元数据中进行配置。在幕后，使用Spring
    AOP，Spring将`TransactionManager`注入到您的代理DAO（或JPA的`EntityManager`）中，并执行您的事务方法，应用在Spring配置中声明的事务语义，无论是使用`@Transactional`注解还是等效的XML标记。我们将在本章后面讨论`@Transactional`注解及其XML等效。
- en: 'For applications that operate on a single `DataSource` object, Spring provides
    `DataSourceTransactionManager`. The following shows how to configure it in XML:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作单个`DataSource`对象的应用程序，Spring提供了`DataSourceTransactionManager`。以下显示了如何在XML中配置它：
- en: '[PRE150]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'For multiple `DataSource` objects or transactional resources, you need a `JtaTransactionManager`
    with JTA capabilities, which usually delegates to a container JTA provider. You
    need to use `DataSource` objects in Java EE application servers, defined with
    the server, and looked up via JNDI along with `JtaTransactionManager`. A typical
    combination should look like the following code fragment:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个`DataSource`对象或事务资源，您需要具有JTA功能的`JtaTransactionManager`，通常委托给容器JTA提供程序。您需要在Java
    EE应用服务器中使用`DataSource`对象，在服务器上定义，并通过JNDI查找，以及`JtaTransactionManager`。典型的组合应该如下代码片段所示：
- en: '[PRE151]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: If you are using Hibernate and just a single `DataSource` (and no other transactional
    resource), then the best option is to use `HibernateTransactionManager`, which
    requires you to pass the session factory as a dependency. For JPA, Spring provides
    `JpaTransactionManager`, which binds a single JPA `EntityManager` instance. However,
    it is advisable to use `JtaTransactionManager` in application-container environments.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Hibernate和只有一个`DataSource`（没有其他事务资源），那么最好的选择是使用`HibernateTransactionManager`，它要求您将会话工厂作为依赖项传递。对于JPA，Spring提供了`JpaTransactionManager`，它绑定了一个单独的JPA
    `EntityManager`实例。但是，在应用容器环境中建议使用`JtaTransactionManager`。
- en: Spring provides specialized transaction managers for application servers for
    WebLogic and WebSphere in order to leverage full power from container-specific
    transaction coordinators. Use `WebLogicTransactionManager` and `WebsphereUowTransactionManager`
    in the respective environments.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为WebLogic和WebSphere的应用服务器提供了专门的事务管理器，以便充分利用容器特定的事务协调器的全部功能。在相应的环境中使用`WebLogicTransactionManager`和`WebsphereUowTransactionManager`。
- en: Declarative transaction management
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式事务管理
- en: Separating Transaction semantics out of your business code into an XML file
    or annotations above the methods is usually called **declarative transaction management**.
    Spring Framework allows you to apply transactional behavior into your beans transparently
    and non-invasively using its declarative transaction management feature.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 将事务语义从业务代码中分离出来，放入XML文件或方法上方的注解通常称为**声明式事务管理**。Spring框架允许您通过其声明式事务管理功能透明且非侵入地将事务行为应用到您的bean中。
- en: You can apply Spring Transaction declaratively on any Spring bean, unlike EJB
    CMT. With Spring Transaction, you can specify transactional advices around your
    bean methods inside the metadata in an AOP style; then Spring will apply your
    those advices at runtime using AOP. You can set rollback rules to specify which
    exceptions around which beans or methods cause automatic rollback or non-rollback.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何Spring bean上声明性地应用Spring事务，与EJB CMT不同。使用Spring事务，您可以在元数据中以AOP样式指定bean方法周围的事务建议；然后Spring将在运行时使用AOP应用您的这些建议。您可以设置回滚规则，以指定哪些异常在哪些bean或方法周围导致自动回滚或非回滚。
- en: Transactional modes – proxy and AspectJ
  id: totrans-1085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务模式 - 代理和AspectJ
- en: 'Spring Transactions supports two transactional modes: proxy mode and AspectJ
    mode. Proxy is the default and most popular mode. In proxy mode, Spring creates
    an AOP proxy object, wrapping the transactional beans, and applies transactional
    behavior transparently around the methods using transaction aspects based on the
    metadata. The AOP proxy created by Spring based on transactional metadata, with
    the help of the configured `PlatformTransactionManager`, performs transactions
    around the transactional methods.'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务支持两种事务模式：代理模式和AspectJ模式。代理是默认和最流行的模式。在代理模式中，Spring创建一个AOP代理对象，包装事务性bean，并在使用基于元数据的事务方面的方法周围透明地应用事务行为。由Spring根据事务元数据创建的AOP代理，借助配置的`PlatformTransactionManager`，在事务性方法周围执行事务。
- en: If you choose AspectJ mode for transactions, the transactional aspects are woven
    into the bean around the specified methods modifying the target class byte code
    during compile-time. There will be no proxying in this case. You will need AspectJ
    mode in special cases such as invoking transactional methods of the same class
    with different propagation levels, where proxying would not help.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择使用AspectJ模式进行事务处理，则事务方面将被编织到指定方法周围的bean中，在编译时修改目标类的字节码。在这种情况下不会进行代理。在特殊情况下，例如调用具有不同传播级别的同一类的事务方法时，代理无法帮助，您将需要使用AspectJ模式。
- en: Defining transactional behavior
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义事务行为
- en: 'Spring offers two convenient approaches for declaratively defining the transactional
    behavior of your beans:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了两种方便的方法来声明性地定义bean的事务行为：
- en: AOP configuration for transactions in an XML metadata file
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML元数据文件中的事务AOP配置
- en: Using the `@Transactional` annotation
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Transactional`注解
- en: Let's start with AOP configuration in an XML file. Refer to the *Aspect Oriented
    Programming* section of [Chapter 1](part0012.xhtml#aid-BE6O1 "Chapter 1. Getting
    Started with Spring Core"), *Getting Started with Spring Core*, for a detailed
    discussion of configuring AOP, using aspects, pointcuts, advice, and so on.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从XML文件中的AOP配置开始。有关配置AOP、使用切面、切入点、建议等的详细讨论，请参阅[第1章](part0012.xhtml#aid-BE6O1
    "第1章。开始使用Spring Core")中的*面向切面编程*部分，*开始使用Spring Core*。
- en: Typically, you declare transaction advices and pointcuts with pointcut expressions
    in your XML metadata file. The best approach is to keep the transaction configuration
    in a separate bean-definition file (for example, `transation-settings.xml`) and
    import it into your primary application-context file.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以在XML元数据文件中使用切入点表达式声明事务建议和切入点。最佳方法是将事务配置保存在单独的bean定义文件中（例如`transation-settings.xml`），并将其导入到主应用程序上下文文件中。
- en: 'Typically, you declare transactional advices and other semantics as shown in
    the following code:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以声明事务建议和其他语义，如下面的代码所示：
- en: '[PRE152]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'You can see that this AOP configuration instructs Spring how to weave transactional
    advices around the methods using pointcuts. It instructs `TransactionManager`
    to make all find methods of the entire service layer read-only, and to force other
    methods to have the transaction propagation: `REQUIRED`, which means that, if
    the caller of the method is already in a transactional context, this method joins
    the same transaction without creating a new one; otherwise, a new transaction
    is created. If you want to create a different transaction for this method, you
    should use the `REQUIRES_NEW` propagation.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个AOP配置指示Spring如何在方法周围使用切入点编织事务建议。它指示`TransactionManager`使整个服务层的所有查找方法都为只读，并强制其他方法具有事务传播：`REQUIRED`，这意味着如果方法的调用者已经处于事务上下文中，则该方法加入相同的事务而不创建新的事务；否则，将创建一个新的事务。如果要为此方法创建一个不同的事务，应该使用`REQUIRES_NEW`传播。
- en: Also, note that the transaction isolation level is specified as `DEFAULT`, which
    means the default isolation of the database is to be used. Most databases default
    to `READ_COMMITTED`, which means a transactional thread cannot see the data of
    other transactions in progress (dirty reads).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，事务隔离级别被指定为`DEFAULT`，这意味着将使用数据库的默认隔离级别。大多数数据库默认为`READ_COMMITTED`，这意味着事务线程无法看到其他事务中正在进行的数据（脏读）。
- en: Setting rollback rules
  id: totrans-1098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置回滚规则
- en: 'With Spring transaction, you can set rollback rules declaratively, in the same
    `<tx:advice>` block, as shown in the following code:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring事务，您可以在相同的`<tx:advice>`块中声明性地设置回滚规则，如下面的代码所示：
- en: '[PRE153]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You can specify which exceptions should or should not rollback transactions
    for your business operations using the `rollback-for` and `no-rollback-for` attributes
    of the `<tx:method>` element.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`<tx:method>`元素的`rollback-for`和`no-rollback-for`属性指定哪些异常应该回滚事务，哪些异常不应该回滚事务，用于您的业务操作。
- en: Note
  id: totrans-1102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`TransactionException` thrown by the `PlatformTransactionManager` interface''s
    methods is the unchecked exception, `RuntimeException`. In Spring, transactions
    rollback for unchecked exceptions automatically. Checked, or application exceptions
    are not rolled back unless specified in the metadata, using the `rollback-for`
    attribute.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlatformTransactionManager`接口的方法抛出的`TransactionException`是未经检查的异常`RuntimeException`。在Spring中，未经检查的异常会自动回滚事务。除非在元数据中指定，使用`rollback-for`属性，否则不会回滚已检查的或应用程序异常。'
- en: Spring Transaction allows you to customize the transactional behavior of your
    beans to a minute level of granularity using Spring AOP and SpEL. Moreover, you
    can specify the behavioral attributes of your transaction such as propagation,
    isolation, and timeout at the method level on the `<tx:method>` element.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务允许您使用Spring AOP和SpEL以分钟级别的粒度自定义bean的事务行为。此外，您可以在`<tx:method>`元素上指定事务的行为属性，如传播、隔离和超时。
- en: Using the @Transactional annotation
  id: totrans-1105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`@Transactional`注解
- en: 'The `@Transactional` annotation describes transactional attributes on a method
    or class. Class-level annotation applies to all methods unless explicitly annotated
    at method level. It supports all the attributes you otherwise set at the XML configuration.
    See the following example:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`注解描述了方法或类的事务属性。类级别的注解适用于所有方法，除非在方法级别明确注释。它支持您在XML配置中设置的所有属性。请参阅以下示例：'
- en: '[PRE154]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In the preceding example, the transactional method `createTask` with propagation
    `REQUIRED` rolls back for `NoUserFoundException`. Similarly, you can set no-rollback
    rules at the same level too.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，具有传播`REQUIRED`的事务方法`createTask`在`NoUserFoundException`发生时回滚。同样，您也可以在相同级别设置不回滚规则。
- en: Note
  id: totrans-1109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`@Transactional` can be applied only to public methods. If you want to annotate
    over protected, private, or package-visible methods, consider using AspectJ, which
    uses compile-time aspect weaving. Spring recommends annotating `@Transactional`
    only on concrete classes as opposed to interfaces, as it will not work in most
    cases such as when you use `proxy-target-class="true"` or `mode="aspectj"`.'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`只能应用于公共方法。如果要对受保护的、私有的或包可见的方法进行注释，请考虑使用AspectJ，它使用编译时切面编织。Spring建议仅在具体类上注释`@Transactional`，而不是在接口上注释，因为在大多数情况下，例如当您使用`proxy-target-class="true"`或`mode="aspectj"`时，它将无法工作。'
- en: Enabling transaction management for @Transactional
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为`@Transactional`启用事务管理
- en: 'You need to first enable transaction management in your application before
    Spring can detect the `@Transactional` annotation for your bean methods. You enable
    transaction in your XML metadata using the following notation:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring可以检测到您的bean方法的`@Transactional`注解之前，您需要在应用程序中首先启用事务管理。您可以在XML元数据中使用以下表示法启用事务：
- en: '[PRE155]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The following is the Java configuration alternative for the preceding listing:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面清单的Java配置替代方案：
- en: '[PRE156]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Spring scans the application context for bean methods annotated with `@Transactional`
    when it sees either of the preceding settings.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring看到上述任何设置时，它会扫描应用程序上下文中使用`@Transactional`注解的bean方法。
- en: 'You can change the transaction mode from `proxy`, which is the default, to
    `aspectj` at this level:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个级别上将事务模式从默认的`proxy`更改为`aspectj`：
- en: '[PRE157]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Another attribute you can set at this level is `proxy-target-class`, which is
    applicable only in the case of the `proxy` mode.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个级别上，你可以设置的另一个属性是`proxy-target-class`，这只适用于`proxy`模式的情况。
- en: Programmatic transaction management
  id: totrans-1120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程式事务管理
- en: 'Spring provides comprehensive support for programmatic transaction management
    using two components: `TransactionTemplate` and `PlatformTransactionManager`.
    The following code snippet illustrates the usage of `TransactionTemplate`:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了全面的支持，使用两个组件进行编程式事务管理：`TransactionTemplate`和`PlatformTransactionManager`。以下代码片段说明了`TransactionTemplate`的用法：
- en: '[PRE158]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`TransactionTemplate` supports the setting of all transaction attributes, as
    in the case of XML configuration, which gives you more granular control at the
    expense of mixing your business code with transactional concerns. Use it only
    if you need absolute control over a particular feature that cannot be achieved
    with declarative transaction management. Use declarative transaction management
    if possible, for better maintainability and management of your application.'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionTemplate`支持设置所有事务属性，就像XML配置一样，这样可以更精细地控制，但会将业务代码与事务关注点混合在一起。只有在需要对无法通过声明式事务管理实现的特定功能进行绝对控制时才使用它。如果可能的话，尽量使用声明式事务管理，以获得更好的可维护性和应用管理。'
- en: Summary
  id: totrans-1124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have so far explored Spring Framework's comprehensive coverage of all technical
    aspects around data access and transaction. Spring provides multiple convenient
    data access methods, which removes much of the hard work for the developer involved
    in building the data layer and standardizing the business components. The correct
    usage of Spring data access components makes the data layer of the Spring application
    clean and highly maintainable. Leveraging Spring Transaction support ensures the
    data integrity of applications without polluting the business code and makes your
    application portable across different server environments. Since Spring abstracts
    much of the technical heavy lifting, building the data layer of your applications
    becomes an enjoyable piece of software engineering.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了Spring框架对数据访问和事务的全面覆盖。Spring提供了多种方便的数据访问方法，这些方法消除了开发人员在构建数据层和标准化业务组件方面的大部分工作。正确使用Spring数据访问组件可以使Spring应用的数据层清晰且易于维护。利用Spring事务支持可以确保应用程序的数据完整性，而不会污染业务代码，并使应用程序可以在不同的服务器环境中移植。由于Spring抽象了大部分技术上的繁重工作，构建应用程序的数据层变得成为一项令人愉快的软件工程工作。
- en: Chapter 4. Understanding WebSocket
  id: totrans-1126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 WebSocket理解
- en: The idea of web applications was built upon a simple paradigm. In a unidirectional
    interaction, a web client sent a request to a server, the server replied to the
    request, and the client rendered the server's response. The communication started
    with a client-side request and ended with the server's response.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用的理念建立在一个简单的范式之上。在单向交互中，Web客户端发送请求到服务器，服务器回复请求，客户端渲染服务器的响应。通信始于客户端的请求，以服务器的响应结束。
- en: 'We built our web applications based on this paradigm; however, some drawbacks
    existed in the technology: the client had to wait for the server''s response and
    refresh the browser to render it. This unidirectional nature of the communication
    required the client to initiate a request. Later technologies such as AJAX and
    long polling brought major advantages to our web applications. In AJAX, the client
    initiated a request but did not wait for the server''s response. In an asynchronous
    manner, the AJAX client-side callback method got the data from the server and
    the browsers'' new DHTML features rendered the data without refreshing the browser.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了基于这一范式的Web应用；然而，技术上存在一些缺点：客户端必须等待服务器的响应并刷新浏览器才能渲染它。这种单向通信的性质要求客户端发起请求。后来的技术，如AJAX和长轮询，为我们的Web应用带来了重大优势。在AJAX中，客户端发起请求，但不等待服务器的响应。以异步的方式，AJAX客户端回调方法从服务器获取数据，浏览器的新DHTML功能渲染数据而不刷新浏览器。
- en: Apart from unidirectional behavior, the HTTP dependencies of these technologies
    required the exchange of extra data in the form of HTTPS headers and cookies.
    This extra data caused latency and became a bottleneck for highly responsive web
    applications.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单向行为之外，这些技术的HTTP依赖性需要以HTTPS头和cookie的形式交换额外的数据。这些额外的数据导致了延迟，并成为高度响应的Web应用的瓶颈。
- en: WebSocket reduced kilobytes of transmitted data to a few bytes and reduced latency
    from 150 milliseconds to 50 milliseconds (for a message packet plus the TCP round
    trip to establish the connection), and these two factors attracted the Google's
    attention (Ian Hickson).
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket将传输的数据量从几千字节减少到几个字节，并将延迟从150毫秒减少到50毫秒（用于消息数据包加上建立连接的TCP往返时间），这两个因素引起了Google的注意（Ian
    Hickson）。
- en: 'WebSocket (RFC 6455) is a full duplex and bidirectional protocol that transmits
    data in the form of frames between client and server. A WebSocket communication,
    as shown in the following figure, starts with an HTTP connection for a handshake
    process between a client and a server. Since firewalls let certain ports be open
    to communicate with the outside, we cannot start with the WebSocket protocol:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket（RFC 6455）是一个全双工和双向的协议，以帧的形式在客户端和服务器之间传输数据。WebSocket通信如下图所示，从客户端和服务器之间的握手过程开始，需要通过HTTP连接。由于防火墙只允许某些端口与外部通信，我们无法直接使用WebSocket协议：
- en: '![Understanding WebSocket](img/image00788.jpeg)'
  id: totrans-1132
  prefs: []
  type: TYPE_IMG
  zh: '![理解WebSocket](img/image00788.jpeg)'
- en: WebSocket communication
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket通信
- en: During the handshake process, the parties (client and server) decide which socket-based
    protocol to choose for transmitting data. At this stage, the server can validate
    the user using HTTP cookies and reject the connection if authentication or authorization
    fails.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手过程中，各方（客户端和服务器）决定选择哪种基于套接字的协议来传输数据。在这个阶段，服务器可以使用HTTP cookies验证用户，并在认证或授权失败时拒绝连接。
- en: Then, both parties upgrade from HTTP to a socket-based protocol. From this point
    onward, the server and client communicate on a full duplex and bidirectional channel
    on a TCP connection.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，双方从HTTP升级到基于套接字的协议。从这一点开始，服务器和客户端在TCP连接上进行全双工和双向通道通信。
- en: Either the client or server can send messages by streaming them into frame format.
    WebSocket uses the heartbeat mechanism using ping/pong message frames to keep
    the connection alive. This looks like sending a ping message from one party and
    expecting a pong from the other side. Either party can also close the channel
    and terminate the communication, as shown in the preceding diagram.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或服务器可以通过将它们流式传输到帧格式中来发送消息。WebSocket使用心跳机制，使用ping/pong消息帧来保持连接活动。这看起来像是一方发送一个ping消息，期望另一方回复一个pong。任何一方也可以关闭通道并终止通信，就像前面的图表所示。
- en: Like a web URI relies on HTTP or HTTPS, WebSocket URI uses `ws` or `wss` schemes
    (for example, `ws://www.sample.org/` or `wss://www.sample.org/`) to communicate.
    WebSocket's `ws` works in a similar way to HTTP by transmitting non-encrypted
    data over TCP/IP. By contrast, `wss` relies on **Transport Layer Security** (**TLS**)
    over TCP, and this combination brings data security and integrity.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Web URI依赖于HTTP或HTTPS一样，WebSocket URI使用`ws`或`wss`方案（例如，`ws://www.sample.org/`或`wss://www.sample.org/）进行通信。WebSocket的`ws`通过TCP/IP传输非加密数据，类似于HTTP的工作方式。相比之下，`wss`依赖于TCP上的**传输层安全**（**TLS**），这种组合带来了数据安全和完整性。
- en: A good question is where to use WebSocket. The best answer is to use it where
    low latency and high frequency of communication are critical—for example, if your
    endpoint data changes within 100 milliseconds and you expect to take very quick
    measures over the data changes.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的问题是在哪里使用WebSocket。最好的答案是在低延迟和高频率通信至关重要的地方——例如，如果您的端点数据在100毫秒内发生变化，并且您希望对数据变化采取非常快速的措施。
- en: Spring Framework 4 includes a new Spring WebSocket module with Java WebSocket
    API standard (JSR-356) compatibility as well as some additional value-adding features.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 4包括一个新的Spring WebSocket模块，具有Java WebSocket API标准（JSR-356）兼容性以及一些附加的增值功能。
- en: While using WebSocket brings advantages to a web application, a lack of compatibility
    in a version of some browser blocks WebSocket communication. To address this issue,
    Spring 4 includes a fallback option that simulates the WebSocket API in case of
    browser incompatibility.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用WebSocket为Web应用程序带来了优势，但某些浏览器版本的兼容性不足会阻止WebSocket通信。为了解决这个问题，Spring 4包括一个回退选项，以模拟WebSocket
    API以解决浏览器不兼容性。
- en: WebSocket transmits data in the frame format, and apart from a single bit to
    distinguish between text and binary data, it is neutral to the message's content.
    In order to handle the message's format, the message needs some extra metadata,
    and the client and server should agree on an application-layer protocol, known
    as a **subprotocol**. The parties choose the subprotocol during the initial handshake.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket以帧格式传输数据，除了用一个单独的位来区分文本和二进制数据之外，它对消息内容是中立的。为了处理消息的格式，消息需要一些额外的元数据，并且客户端和服务器应该在应用层协议上达成一致，即所谓的**子协议**。各方在初始握手期间选择子协议。
- en: WebSocket does not mandate the usage of subprotocols, but in the case of their
    absence, both the client and server need to transmit data in a predefined style
    standard, framework-specific, or customized format.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket不强制使用子协议，但在它们缺失的情况下，客户端和服务器都需要以预定义的样式标准、框架特定或定制格式传输数据。
- en: Spring supports **Simple Text Orientated Messaging Protocol** (**STOMP**) as
    a subprotocol—known as STOMP over WebSocket—in a WebSocket communication. Spring's
    Messaging is built upon integration concepts such as messaging and channel and
    handler, along with annotation of message mapping. Using STOMP over WebSocket
    gives message-based features to a Spring WebSocket application.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持**简单文本定向消息协议**（**STOMP**）作为子协议——称为STOMP over WebSocket——在WebSocket通信中。Spring的消息传递建立在集成概念上，如消息和通道和处理程序，以及消息映射的注释。使用STOMP
    over WebSocket为Spring WebSocket应用程序提供了基于消息的功能。
- en: Using all of these new Spring 4 features, you can create a WebSocket application
    and broadcast a message to all subscribed clients as well as send a message to
    a specific user. In this chapter, we start by creating a simple Spring web application,
    which will show how to set up a WebSocket application and how a client can send
    and receive messages to or from an endpoint. In the second application, we will
    see how Spring WebSocket's fallback option can tackle browser incompatibly, how
    a broker based messaging system works with STOMP over WebSocket, and how subscribed
    clients can send and receive messages. In the last web application, however, we
    will show how we can send broker-based messages to a specific user.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些新的Spring 4功能，您可以创建一个WebSocket应用程序，并向所有订阅的客户端广播消息，以及向特定用户发送消息。在本章中，我们首先创建一个简单的Spring
    Web应用程序，演示如何设置WebSocket应用程序以及客户端如何与端点发送和接收消息。在第二个应用程序中，我们将看到Spring WebSocket的回退选项如何解决浏览器不兼容性，以及基于代理的消息系统如何使用STOMP
    over WebSocket工作，以及订阅的客户端如何发送和接收消息。然而，在最后一个Web应用程序中，我们将展示如何向特定用户发送基于代理的消息。
- en: Creating a simple WebSocket application
  id: totrans-1145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的WebSocket应用程序
- en: In this section, while developing a simple WebSocket application, we will learn
    about WebSocket's client and server components. As mentioned earlier, using a
    subprotocol is optional in a WebSocket communication. In this application, we
    have not used a subprotocol.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在开发一个简单的WebSocket应用程序时了解WebSocket的客户端和服务器组件。如前所述，在WebSocket通信中使用子协议是可选的。在本应用程序中，我们没有使用子协议。
- en: First of all, you need to set up a Spring web application. In order to dispatch
    a request to your service (called a handler in Spring WebSocket), you need to
    set up a framework Servlet (dispatcher Servlet). This means that you should register
    `DispatcherServlet` in `web.xml` and define your beans and service in the application
    context.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要设置一个 Spring web 应用程序。为了将请求分派到你的服务（在 Spring WebSocket 中称为处理程序），你需要设置一个框架
    Servlet（分派器 Servlet）。这意味着你应该在 `web.xml` 中注册 `DispatcherServlet` 并在应用程序上下文中定义你的
    bean 和服务。
- en: Setting up a Spring application requires you to configure it in XML format.
    Spring introduced the Spring Boot module to get rid of XML configuration files
    in Spring applications. Spring Boot aims at configuring a Spring application by
    adding a few lines of annotation to the classes and tagging them as Spring artifacts
    (bean, services, configurations, and so on). By default, it also adds dependencies
    based on what it finds in the classpath. For example, if you have a web dependency,
    then Spring Boot can configure Spring MVC by default. It also lets you override
    this default behavior. Covering Spring Boot in complete detail would require a
    full book; we will just use it here to ease the configuration of a Spring application.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个 Spring 应用程序需要你以 XML 格式进行配置。Spring 引入了 Spring Boot 模块来摆脱 Spring 应用程序中的 XML
    配置文件。Spring Boot 的目标是通过向类添加几行注释并将它们标记为 Spring 构件（bean、服务、配置等）来配置 Spring 应用程序。默认情况下，它还根据类路径中的内容添加依赖项。例如，如果你有一个
    web 依赖项，那么 Spring Boot 可以默认配置 Spring MVC。它还允许你覆盖这种默认行为。详细介绍 Spring Boot 需要一本完整的书；我们只是在这里使用它来简化
    Spring 应用程序的配置。
- en: 'These are the Maven dependencies of this project:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是该项目的 Maven 依赖项：
- en: '[PRE159]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As mentioned in the beginning of this section, there is no subprotocol (and,
    subsequently, no application-layer framework) to interpret WebSocket messages.
    This means that the client and server need to handle the job and be aware of the
    message's format.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所提到的，没有子协议（因此也没有应用层框架）来解释 WebSocket 消息。这意味着客户端和服务器需要处理这项工作并了解消息的格式。
- en: 'On the server''s side, the handler (endpoint) receives and extracts the message
    and replies back (based on the business logic) to the client. In Spring, you can
    create a customized handler by extending either `TextWebSocketHandler` or `BinaryWebSocketHandler`.
    `TextWebSocketHandler` handles string or text messages (such as JSON data) and
    `BinaryWebSocketHandler` handles binary messages (such as image or media data).
    Here is a code listing that uses `TextWebSocketHandler`:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，处理程序（端点）接收并提取消息，并根据业务逻辑回复给客户端。在 Spring 中，你可以通过扩展 `TextWebSocketHandler`
    或 `BinaryWebSocketHandler` 来创建一个自定义处理程序。`TextWebSocketHandler` 处理字符串或文本消息（比如 JSON
    数据），`BinaryWebSocketHandler` 处理二进制消息（比如图像或媒体数据）。下面是一个使用 `TextWebSocketHandler`
    的代码清单：
- en: '[PRE160]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Since we process only JSON data here, the class `SampleTextWebSocketHandler`
    extends `TextWebSocketHandler`. The method `handleTextMessage` obtains the client's
    message by receiving its payload and converting it into JSON data, and then it
    sends a message back to the client.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这里只处理 JSON 数据，所以 `SampleTextWebSocketHandler` 类扩展了 `TextWebSocketHandler`。`handleTextMessage`
    方法通过接收其有效负载并将其转换为 JSON 数据来获取客户端的消息，然后向客户端发送一条消息。
- en: 'In order to tell Spring to forward client requests to the endpoint (or handler
    here), we need to register the handler:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉 Spring 将客户端请求转发到端点（或者这里的处理程序），我们需要注册处理程序：
- en: '[PRE161]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '`@Configuration` and `@EnableWebsocket` tell Spring this is the WebSocket configurator
    of the project. It registers our handler (`SampleTextWebSocketHandler`) and sets
    the request path (in a WebSocket URL, such as `ws://server-ip:port/path/wsAddress`)
    that will be forwarded to this handler.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration` 和 `@EnableWebsocket` 告诉 Spring 这是项目的 WebSocket 配置器。它注册了我们的处理程序
    (`SampleTextWebSocketHandler`) 并设置了请求路径（在 WebSocket URL 中，比如 `ws://server-ip:port/path/wsAddress`）将被转发到这个处理程序。'
- en: 'And now the question is how to set up a Spring application and glue all of
    this stuff together. Spring Boot provides an easy way to set up a Spring-based
    application with a configurable embedded web server that you can "just run":'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是如何设置一个 Spring 应用程序并将所有这些东西粘合在一起。Spring Boot 提供了一种简单的方式来设置一个基于 Spring 的应用程序，它带有一个可配置的嵌入式
    Web 服务器，你可以“只需运行”它：
- en: '[PRE162]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '`@SpringBootApplication` tags the `EchoWebSocketBootApplication` class as a
    special configuration class of your application and `@SpringBootApplication` behaves
    like the following annotations:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 将 `EchoWebSocketBootApplication` 类标记为你的应用程序的特殊配置类，`@SpringBootApplication`
    的行为类似于以下注释：'
- en: '`@Configuration`, which declares the class as a bean definition of an application
    context'
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration` 声明该类作为应用程序上下文的 bean 定义'
- en: '`@EnableAutoConfiguration`, which lets Spring Boot add a dependent bean definition
    based on the classpath (for example, `spring-webmvc` in the project classpath
    tells Spring Boot to set up a web application with its `DispatcherServlet` registration
    in `web.xml`)'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration` 允许 Spring Boot 根据类路径添加一个依赖的 bean 定义（例如，在项目类路径中的
    `spring-webmvc` 告诉 Spring Boot 在 `web.xml` 中设置一个 web 应用程序的 `DispatcherServlet`
    注册）'
- en: '`@ComponentScan`, which is used to scan all annotations (services, controllers,
    configurations, and so on) within the same package (`com.springessentialsbook.chapter4`)
    and configure them accordingly'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan` 用于扫描同一包内的所有注释（服务、控制器、配置等）并相应地配置它们'
- en: Finally, the `main` method calls `SpringApplication.run` to set up a Spring
    application within a web application without writing a single line of XML configuration
    (`applicationContext.xml` or `web.xml`).
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 方法调用 `SpringApplication.run` 来在一个 web 应用程序中设置一个 Spring 应用程序，而不需要编写一行
    XML 配置（`applicationContext.xml` 或 `web.xml`）。
- en: 'When a client wants to send a WebSocket request, it should create a JavaScript
    client object (`ws = new WebSocket(''ws://localhost:8090/path/wsAddress'')`) and
    pass the WebSocket service address. In order to receive the data, we need to attach
    a callback listener (`ws.onmessage`) and an error handler (`ws.onerror`), like
    so:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要发送WebSocket请求时，它应该创建一个JavaScript客户端对象（`ws = new WebSocket('ws://localhost:8090/path/wsAddress')`）并传递WebSocket服务地址。为了接收数据，我们需要附加一个回调监听器（`ws.onmessage`）和一个错误处理程序（`ws.onerror`），如下所示：
- en: '[PRE163]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'You can run the application by running this command:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来运行应用程序：
- en: '[PRE164]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'This runs and deploys the web application on an embedded server on port `8090`
    (`8080` is not used here as it may conflict with your running Apache service).
    So, the index page of the application will be accessible at `http://localhost:8090/`
    (follow the instructions in `read-me.txt` to run the application). It should look
    like this:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`8090`上运行和部署Web应用程序（这里不使用`8080`，因为它可能与您正在运行的Apache服务冲突）。因此，应用程序的索引页面将可以在`http://localhost:8090/`访问（按照`read-me.txt`中的说明运行应用程序）。它应该是这样的：
- en: '![Creating a simple WebSocket application](img/image00789.jpeg)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的WebSocket应用程序](img/image00789.jpeg)'
- en: The opening page of the application in a Chrome browser
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome浏览器中应用程序的开放页面
- en: When a user sends a text in Chrome, it will be handled by `SampleTextWebSocketHandler`,
    the handler will reply, and the response will be rendered in the browser.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在Chrome中发送文本时，它将由`SampleTextWebSocketHandler`处理，处理程序将回复，并且响应将在浏览器中呈现。
- en: If you try to test this application in a version of Internet Explorer lower
    than 10, you will get a JavaScript error.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在低于10的Internet Explorer版本中测试此应用程序，您将收到JavaScript错误。
- en: As we discussed earlier, certain versions of browsers do not support WebSocket.
    Spring 4 provides a fallback option to manage these types of browsers. In the
    next section, this feature of Spring will be explained.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，某些版本的浏览器不支持WebSocket。Spring 4提供了一个回退选项来管理这些类型的浏览器。在下一节中，将解释Spring的这个特性。
- en: STOMP over WebSocket and the fallback option in Spring 4
  id: totrans-1175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 4中的STOMP over WebSocket和回退选项
- en: In the previous section, we saw that in a WebSocket application that does not
    use subprotocols, the client and server should be aware of the message format
    (JSON in this case) in order to handle it. In this section, we use STOMP as a
    subprotocol in a WebSocket application (this is known as **STOMP over WebSocket**)
    and show how this application layer protocol helps us handle messages.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到在一个不使用子协议的WebSocket应用程序中，客户端和服务器应该意识到消息格式（在这种情况下是JSON）以便处理它。在本节中，我们在WebSocket应用程序中使用STOMP作为子协议（这被称为**STOMP
    over WebSocket**），并展示这个应用层协议如何帮助我们处理消息。
- en: The messaging architecture in the previous application was an asynchronous client/server-based
    communication.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个应用程序中的消息架构是基于异步客户端/服务器通信的。
- en: The `spring-messaging` module brings features of asynchronous messaging systems
    to Spring Framework. It is based on some concepts inherited from Spring Integration,
    such as messages, message handlers (classes that handle messages), and message
    channels (data channels between senders and receivers that provide loose coupling
    during communication).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-messaging`模块将异步消息系统的特性引入了Spring Framework。它基于从Spring Integration继承的一些概念，如消息、消息处理程序（处理消息的类）和消息通道（发送者和接收者之间的数据通道，在通信期间提供松散耦合）。'
- en: At the end of this section, we will explain how our Spring WebSocket application
    integrates with the Spring messaging system and works in a similar way to legacy
    messaging systems such as JMS.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，我们将解释我们的Spring WebSocket应用程序如何与Spring消息系统集成，并以类似于传统消息系统（如JMS）的方式工作。
- en: In the first application, we saw that in certain types of browsers, WebSocket
    communication failed because of browser incompatibility. In this section, we will
    explain how Spring's fallback option addresses this problem.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个应用程序中，我们看到在某些类型的浏览器中，WebSocket通信失败是因为浏览器不兼容。在本节中，我们将解释Spring的回退选项如何解决这个问题。
- en: Suppose you are asked to develop a browser-based chat room application in which
    anonymous users can join a chat room and any text sent by a user should be sent
    to all active users. This means that we need a topic that all users should be
    subscribed to and messages sent by any user should be broadcasted to all. Spring
    WebSocket features meet these requirements. In Spring, using STOMP over WebSocket,
    users can exchange messages in a similar way to JMS. In this section, we will
    develop a chat room application and explain some of Spring WebSocket's features.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您被要求开发一个基于浏览器的聊天室应用程序，匿名用户可以加入聊天室，并且任何用户发送的文本都应该发送给所有活跃用户。这意味着我们需要一个所有用户都应该订阅的主题，并且任何用户发送的消息都应该广播给所有用户。Spring
    WebSocket功能满足这些要求。在Spring中，使用STOMP over WebSocket，用户可以以类似于JMS的方式交换消息。在本节中，我们将开发一个聊天室应用程序，并解释一些Spring
    WebSocket的特性。
- en: 'The first task is to configure Spring to handle STOMP messages over WebSocket.
    Using Spring 4, you can instantly configure a very simple, lightweight (memory-based)
    message broker, set up subscription, and let controller methods serve client messages.
    The code for the `ChatroomWebSocketMessageBrokerConfigurer` class is:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是配置Spring以处理WebSocket上的STOMP消息。使用Spring 4，您可以立即配置一个非常简单、轻量级（基于内存的）消息代理，设置订阅，并让控制器方法处理客户端消息。`ChatroomWebSocketMessageBrokerConfigurer`类的代码如下：
- en: '[PRE165]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '`@Configuration` tags a `ChatroomWebSocketMessageBrokerConfigurer` class as
    a Spring configuration class. `@EnableWebSocketMessageBroker` provides WebSocket
    messaging features backed by a message broker.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`标记`ChatroomWebSocketMessageBrokerConfigurer`类为Spring配置类。`@EnableWebSocketMessageBroker`提供由消息代理支持的WebSocket消息功能。'
- en: 'The overridden method `configureMessageBroker`, as its name suggests, overrides
    the parent method for message broker configuration and sets:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的`configureMessageBroker`方法，如其名称所示，重写了消息代理配置的父方法，并设置：
- en: '`setApplicationDestinationPrefixes`: Specify `/myApp` as the prefix, and any
    client message whose destination starts with `/myApp` will be routed to the controller''s
    message-handling methods.'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setApplicationDestinationPrefixes`：指定`/myApp`作为前缀，任何目的地以`/myApp`开头的客户端消息将被路由到控制器的消息处理方法。'
- en: '`enableSimpleBroker`: Set the broker topic to `/chatroomTopic`. Any messages
    whose destinations start with `/chatroomTopic` will be routed to the message broker
    (that is, broadcasted to other connected clients). Since we are using an in-memory
    broker, we can specify any topic. If we use a dedicated broker, the destination''s
    name would be `/topic` or `/queue`, based on the subscription model (pub/sub or
    point-to-point).'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enableSimpleBroker`：将经纪人主题设置为`/chatroomTopic`。任何目的地以`/chatroomTopic`开头的消息将被路由到消息代理（即广播到其他连接的客户端）。由于我们使用的是内存代理，我们可以指定任何主题。如果我们使用专用代理，目的地的名称将是`/topic`或`/queue`，基于订阅模型（发布/订阅或点对点）。'
- en: 'The overridden method `registerStompEndpoints` is used to set the endpoint
    and fallback options. Let''s look at it closely:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的方法`registerStompEndpoints`用于设置端点和回退选项。让我们仔细看一下：
- en: The client-side WebSocket can connect to the server's endpoint at `/broadcastMyMessage`.
    Since STOMP has been selected as the subprotocol, we do not need to know about
    the underlying message format and let STOMP handle it.
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端WebSocket可以连接到服务器的端点`/broadcastMyMessage`。由于选择了STOMP作为子协议，我们不需要了解底层消息格式，让STOMP处理它。
- en: The `.withSockJS()` method enables Spring's fallback option. This guarantees
    successful WebSocket communication in any type or version of browser.
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.withSockJS()`方法启用了Spring的回退选项。这保证了在任何类型或版本的浏览器中成功的WebSocket通信。'
- en: 'As Spring MVC forwards HTTP requests to methods in controllers, the MVC extension
    can receive STOMP messages over WebSocket and forward them to controller methods.
    A Spring `Controller` class can receive client STOMP messages whose destinations
    start with `/myApp`. The handler method can reply to subscribed clients by sending
    the returned message to the broker channel, and the broker replies to the client
    by sending the message to the response channel. At the end of this section, we
    will look at some more information about the messaging architecture. As an example,
    let''s look at the `ChatroomController` class:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring MVC将HTTP请求转发到控制器中的方法，MVC扩展可以通过WebSocket接收STOMP消息并将其转发到控制器方法。Spring
    `Controller`类可以接收目的地以`/myApp`开头的客户端STOMP消息。处理程序方法可以通过将返回的消息发送到经纪人通道来回复订阅的客户端，经纪人通过将消息发送到响应通道来回复客户端。在本节的最后，我们将看一些关于消息架构的更多信息。例如，让我们看一下`ChatroomController`类：
- en: '[PRE166]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Here, `@Controller` tags `ChatroomController` as an MVC workflow controller.
    `@MessageMapping` is used to tell the controller to map the client message to
    the handler method (`broadCastClientMessage`). This will be done by matching a
    message endpoint to the destination (`/broadcastMyMessage`). The method's returned
    object (`ReturnedDataModelBean`) will be sent back through the broker to the subscriber's
    topic (`/chatroomTopic/broadcastClientsMessages`) by the `@SendTo` annotation.
    Any message in the topic will be broadcast to all subscribers (clients). Note
    that clients do not wait for the response, since they send and listen to messages
    to and from the topic and not the service directly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`@Controller`标记`ChatroomController`作为MVC工作流控制器。`@MessageMapping`用于告诉控制器将客户端消息映射到处理程序方法（`broadCastClientMessage`）。这将通过将消息端点与目的地（`/broadcastMyMessage`）进行匹配来完成。方法的返回对象（`ReturnedDataModelBean`）将通过`@SendTo`注解发送回经纪人到订阅者的主题（`/chatroomTopic/broadcastClientsMessages`）。主题中的任何消息都将广播给所有订阅者（客户端）。请注意，客户端不会等待响应，因为它们发送和监听来自主题而不是直接来自服务的消息。
- en: 'Our domain POJOs (`ClientInfoBean` and `ReturnedDataModelBean`), detailed as
    follows, will provide the communication message payloads (actual message content)
    between the client and server:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域POJOs（`ClientInfoBean`和`ReturnedDataModelBean`），如下所述，将提供客户端和服务器之间的通信消息负载（实际消息内容）：
- en: '[PRE167]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'To add some sort of security, we can add basic HTTP authentication, as follows
    (we are not going to explain Spring security in this chapter, but it will be detailed
    in the next chapter):'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一些安全性，我们可以添加基本的HTTP身份验证，如下所示（我们不打算在本章中解释Spring安全性，但将在下一章中详细介绍）：
- en: '[PRE168]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The `@Configuration` tags this class as a configuration class and `@EnableGlobalMethodSecurity`
    and `@EnableWebSecurity` set security methods and web security in the class. In
    the `configure` method, we set basic authentication, and in `configureGlobal`,
    we set the recognized username and password as well as the role that the user
    belongs to.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`标记此类为配置类，`@EnableGlobalMethodSecurity`和`@EnableWebSecurity`在类中设置安全方法和Web安全性。在`configure`方法中，我们设置基本身份验证，在`configureGlobal`中，我们设置了识别的用户名和密码以及用户所属的角色。'
- en: 'To add Spring Security features, we should add the following Maven dependencies:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加Spring Security功能，我们应该添加以下Maven依赖项：
- en: '[PRE169]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'As we explained in the previous section, the `@SpringBootApplication` tag sets
    up a Spring application within a web application without us having to write a
    single line of XML configuration (`applicationContext.xml` or `web.xml`):'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中所解释的，`@SpringBootApplication`标签在不必编写一行XML配置（`applicationContext.xml`或`web.xml`）的情况下在Web应用程序中设置了一个Spring应用程序：
- en: '[PRE170]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Finally, you can run the application by running this command:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行以下命令来运行应用程序：
- en: '[PRE171]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'This runs and deploys the web application on an embedded web server on port
    `8090` (`8080` is not used as it may conflict with your running Apache service).
    So, the index page of the application will be accessible at `http://localhost:8090/`
    (follow `read-me.txt` to run the application):'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 这在端口`8090`上的嵌入式Web服务器上运行和部署Web应用程序（`8080`未使用，因为它可能与正在运行的Apache服务冲突）。因此，应用程序的索引页面将可以在`http://localhost:8090/`上访问（按照`read-me.txt`运行应用程序）：
- en: '[PRE172]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: On the client side, notice how the browser connects (with `joinChatRoom`) and
    sends data (in the `sendMyClientMessage` method). These methods use the JavaScript
    libraries SockJS and Stomp.js.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，注意浏览器如何连接（使用`joinChatRoom`）并发送数据（在`sendMyClientMessage`方法中）。这些方法使用JavaScript库SockJS和Stomp.js。
- en: As you can see, when a client subscribes to a topic, it registers a listener
    method (`stompClient.subscribe(topic, function(serverReturnedData){.…}`). The
    listener method will be called when any message (from any client) arrives in the
    topic.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当客户端订阅主题时，它会注册一个监听方法（`stompClient.subscribe(topic, function(serverReturnedData){.…}`）。当任何消息（来自任何客户端）到达主题时，将调用监听方法。
- en: As discussed earlier, some versions of browsers do not support WebSocket. SockJS
    was introduced to handle all versions of browsers. On the client side, when you
    try to connect to the server, the SockJS client sends the `GET/info` message to
    get some information from the server. Then it chooses the transport protocol,
    which could be one of WebSocket, HTTP streaming, or HTTP long-polling. WebSocket
    is the preferred transport protocol; however, in case of browser incompatibility,
    it chooses HTTP streaming, and in the worse case, HTTP long-polling.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，某些浏览器版本不支持WebSocket。SockJS被引入以处理所有版本的浏览器。在客户端，当您尝试连接到服务器时，SockJS客户端发送`GET/info`消息以从服务器获取一些信息。然后它选择传输协议，可以是WebSocket、HTTP流或HTTP长轮询之一。WebSocket是首选的传输协议；但是，如果浏览器不兼容，它选择HTTP流，并且在更糟糕的情况下选择HTTP长轮询。
- en: In the beginning of this section, we described how our WebSocket application
    integrates with the Spring messaging system and works in a way similar to legacy
    messaging systems.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们描述了我们的WebSocket应用程序如何与Spring消息系统集成，并以类似于传统消息系统的方式工作。
- en: 'The overridden method settings of `@EnableWebSocketMessageBroker` and `ChatroomWebSocketMessageBrokerConfigurer`
    create a concrete message flow (refer to the following diagram). In our messaging
    architecture, channels decouple receivers and senders. The messaging architecture
    contains three channels:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableWebSocketMessageBroker`和`ChatroomWebSocketMessageBrokerConfigurer`的重写方法设置创建了一个具体的消息流（参见下图）。在我们的消息架构中，通道解耦了接收者和发送者。消息架构包含三个通道：'
- en: The client inbound channel (**Request channel**) for request messages sent from
    the client side
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端入站通道（**请求通道**）用于从客户端发送的请求消息
- en: The client outbound channel (**Response channel**) for messages sent to the
    client side
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端出站通道（**响应通道**）用于发送到客户端的消息
- en: The **Broker channel** for internal server messages to the broker
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理通道**用于向代理发送内部服务器消息'
- en: Our system uses STOMP destinations for simple routing by prefix. Any client
    message whose destination starts with `/myApp` will be routed to controller message-handling
    methods. Any message whose destination starts with `/chatroomTopic` will be routed
    to the message broker.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统使用STOMP目的地进行简单的路由前缀。任何目的地以`/myApp`开头的客户端消息将被路由到控制器消息处理方法。任何以`/chatroomTopic`开头的消息将被路由到消息代理。
- en: '![STOMP over WebSocket and the fallback option in Spring 4](img/image00790.jpeg)'
  id: totrans-1216
  prefs: []
  type: TYPE_IMG
  zh: '![Spring 4中的STOMP over WebSocket和回退选项](img/image00790.jpeg)'
- en: The simple broker (in-memory) messaging architecture
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 简单代理（内存中）消息架构
- en: 'Here is the messaging flow of our application:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序的消息流：
- en: The client connects to the WebSocket endpoint (`/broadcastMyMessage`).
  id: totrans-1219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端连接到WebSocket端点（`/broadcastMyMessage`）。
- en: Client messages to `/myApp/broadcastMyMessage` will be forwarded to the `ChatroomController`
    class (through the **Request channel**). The mapping controller's method passes
    the returned value to the Broker channel for the topic `/chatroomTopic/broadcastClientsMessages`.
  id: totrans-1220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端消息到`/myApp/broadcastMyMessage`将通过**请求通道**转发到`ChatroomController`类。映射控制器的方法将返回的值传递给主题`/chatroomTopic/broadcastClientsMessages`的代理通道。
- en: The broker passes the message to the **Response channel**, which is the topic
    `/chatroomTopic/broadcastClientsMessages`, and clients subscribed to this topic
    receive the message.
  id: totrans-1221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理将消息传递到**响应通道**，即主题`/chatroomTopic/broadcastClientsMessages`，订阅了该主题的客户端将收到消息。
- en: Broadcasting a message to a single user in a WebSocket application
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebSocket应用程序中向单个用户广播消息
- en: In the previous section, we saw a WebSocket application of the multiple subscriber
    model, in which a broker sent messages to a topic. Since all clients had subscribed
    to the same topic, all of them received messages. Now, you are asked to develop
    an application that targets a specific user in a WebSocket chat application.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了多个订阅者模型的WebSocket应用程序，其中代理向主题发送消息。由于所有客户端都订阅了相同的主题，因此它们都收到了消息。现在，您被要求开发一个针对WebSocket聊天应用程序中特定用户的应用程序。
- en: 'Suppose you want to develop an automated answering application in which a user
    sends a question to the system and gets an answer automatically. The application
    is almost the same as the previous one (STOMP over WebSocket and the fallback
    option in Spring 4), except that we should change the WebSocket configurer and
    endpoint on the server side and subscription on the client side. The code for
    the `AutoAnsweringWebSocketMessageBrokerConfigurer` class is:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想开发一个自动回答应用程序，其中用户向系统发送问题并自动获得答案。该应用程序与上一个应用程序几乎相同（Spring 4中的STOMP over WebSocket和回退选项），只是我们应该更改服务器端的WebSocket配置器和端点以及客户端端的订阅。`AutoAnsweringWebSocketMessageBrokerConfigurer`类的代码如下：
- en: '[PRE173]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `config.setUserDestinationPrefix("/user")` method sets a prefix noting
    that a user has subscribed and expects to get their own message on the topic.
    The code for the `AutoAnsweringController` class is:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.setUserDestinationPrefix("/user")`方法设置了一个前缀，指示用户已订阅并期望在主题上收到自己的消息。`AutoAnsweringController`类的代码如下：'
- en: '[PRE174]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In the endpoint, we use `@SendToUser` instead of `@SendTo("...")`. This forwards
    the response only to the sender of the message. `@MessageExceptionHandler` will
    send errors `(broadcast = false)` to the sender of message as well.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点中，我们使用`@SendToUser`而不是`@SendTo("...")`。这只将响应转发给消息发送者。`@MessageExceptionHandler`还将错误发送给消息发送者（`broadcast
    = false`）。
- en: '`AutoAnsweringService` is just a mock service to return an answer to the client
    message. On the client side, we only add the `/user` prefix when a user subscribes
    to the topic (`/user/queue/message`):'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoAnsweringService`只是一个模拟服务，用于返回给客户端的答案。在客户端，当用户订阅主题（`/user/queue/message`）时，我们只添加了`/user`前缀：'
- en: '[PRE175]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The topic `user/queue/error` is used to receive errors dispatched from the server
    side.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 主题`user/queue/error`用于接收从服务器端分发的错误。
- en: Note
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more about Spring's WebSocket support, go to [http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html).
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring的WebSocket支持的更多信息，请访问[http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html)。
- en: For more about WebSocket communication, refer to *Chapter 8*, *Replacing HTTP
    with WebSockets* from the book *Enterprise Web Development*, *Yakov Fain, Victor
    Rasputnis, Anatole Tartakovsky, Viktor Gamov*, *O'Reilly*.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WebSocket通信的更多信息，请参阅*第8章*，*用WebSocket替代HTTP*，来自书籍*企业Web开发*，*Yakov Fain，Victor
    Rasputnis，Anatole Tartakovsky，Viktor Gamov*，*O'Reilly*。
- en: Summary
  id: totrans-1235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained WebSocket-based communication, how Spring 4 has
    been upgraded to support WebSocket, and the fallback option to overcome browsers'
    WebSocket incompatibility. We also had a small sample of adding basic HTTP authentication,
    which is a part of Spring Security. We will discuss more on security in [Chapter
    5](part0057.xhtml#aid-1MBG22 "Chapter 5. Securing Your Applications"), *Securing
    Your Applications*.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了基于WebSocket的通信，Spring 4如何升级以支持WebSocket，以及克服浏览器WebSocket不兼容性的备用选项。我们还介绍了添加基本HTTP身份验证的小示例，这是Spring
    Security的一部分。我们将在[第5章](part0057.xhtml#aid-1MBG22 "第5章。保护您的应用程序")*保护您的应用程序*中更多地讨论安全性。
- en: Chapter 5. Securing Your Applications
  id: totrans-1237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。保护您的应用程序
- en: Spring Security provides a wide range of features for securing Java/Spring-based
    enterprise applications. At first glance, the security features of Servlets or
    EJB look an alternative of Spring Security; however, these solutions lack certain
    requirements for developing enterprise applications. The server's environment
    dependency could be another drawback of these solutions.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为保护基于Java/Spring的企业应用程序提供了广泛的功能。乍一看，Servlets或EJB的安全功能看起来是Spring
    Security的替代品；然而，这些解决方案缺乏开发企业应用程序的某些要求。服务器环境的依赖性可能是这些解决方案的另一个缺点。
- en: Authentication and authorization are the main areas of application security.
    Authentication is the verification of a user's identity, whereas authorization
    is the verification of the privileges of a user.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是应用程序安全的主要领域。身份验证是对用户身份的验证，而授权是对用户权限的验证。
- en: 'Spring Security integrates with a variety of authentication models, most of
    which are provided by third-party providers. In addition, Spring Security has
    developed its own authentication models, based upon major security protocols.
    Here are some of these protocols:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security与各种身份验证模型集成，其中大多数由第三方提供者提供。此外，Spring Security还开发了基于主要安全协议的自己的身份验证模型。以下是其中一些协议：
- en: Form-based authentication
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表单的身份验证
- en: HTTP Basic authentication
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP基本身份验证
- en: LDAP
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP
- en: JAAS
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAAS
- en: Java Open Single Sign On
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java开放式单点登录
- en: Open ID authentication
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Open ID认证
- en: Since there is a big list of Spring Security models, we can only detail the
    most popular of them in this chapter.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Security模型的列表很长，我们只能在本章中详细介绍其中最受欢迎的模型。
- en: 'Spring Security is quite strong on authorization features. We can categorize
    these features into three groups: web, method, and domain object authorization.
    Later, in the *Authorization* section, we will explain these categories.'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security在授权功能上非常强大。我们可以将这些功能分为三组：web、方法和域对象授权。稍后在*授权*部分，我们将解释这些类别。
- en: 'In order to use Spring Security features in a web application, you need to
    include the following dependencies in your project:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Web应用程序中使用Spring Security功能，您需要在项目中包含以下依赖项：
- en: '[PRE176]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The **open standard for authorization** (**OAuth**) concept, introduced in late
    2006, aimed to allow third-party limited access to users' resources on Microsoft,
    Google, Facebook, Twitter, or similar accounts, without sharing their usernames
    and passwords.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权的开放标准**（**OAuth**）概念于2006年末引入，旨在允许第三方在Microsoft、Google、Facebook、Twitter或类似账户上获得用户资源的有限访问权限，而无需共享他们的用户名和密码。'
- en: In 2010, OAuth was standardized as the OAuth 1.0a protocol in RFC 5849\. Later
    in 2012, it evolved to the OAuth 2.0 framework in RFC 6749\. In this chapter,
    we explain Spring's OAuth 2.0 framework implementation.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年，OAuth作为OAuth 1.0a协议在RFC 5849中标准化。后来在2012年，它演变为RFC 6749中的OAuth 2.0框架。在本章中，我们解释了Spring的OAuth
    2.0框架实现。
- en: The OAuth 2.0 Authorization Framework enables a third-party application to obtain
    limited access to an HTTP service, either on behalf of a resource owner by orchestrating
    an approval interaction between the resource owner and the HTTP service, or by
    allowing the third-party application to obtain access on its own behalf ([http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)).
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权框架使第三方应用程序能够在资源所有者与HTTP服务之间进行批准交互，或者允许第三方应用程序代表自己获得访问权限([http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749))。
- en: Spring provides a separate module (`spring-security-oauth2`) for its OAuth 2.0
    implementation, which relies on Spring Security features. In this chapter, we
    explain authentication and how Spring facilitates the process by providing its
    own easy-to-use features as well as giving you options to plug in your customized
    implementation. Authorization is the second topic included in this chapter, in
    which we explain how to configure separate security models within the same application.
    In the last section, we explain Spring's OAuth 2.0 feature.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为其OAuth 2.0实现提供了一个单独的模块（`spring-security-oauth2`），依赖于Spring Security的功能。在本章中，我们解释了身份验证以及Spring如何通过提供自己易于使用的功能以及提供插入自定义实现的选项来简化该过程。授权是本章的第二个主题，我们将解释如何在同一应用程序中配置单独的安全模型。在最后一节中，我们解释了Spring的OAuth
    2.0功能。
- en: Authentication
  id: totrans-1255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: In an application's security domain, the first thing that comes to mind is authentication.
    During the authentication process, an application compares a user's credentials
    (for example, a username and password or a token) with the information available
    to it. If these two match, it allows the process to enter the next step. We will
    follow the next step in the *Authorization* section.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的安全领域中，首先想到的是身份验证。在身份验证过程中，应用程序将用户的凭据（例如用户名和密码或令牌）与其可用的信息进行比较。如果这两者匹配，它允许进入下一步。我们将在*授权*部分中跟进下一步。
- en: Spring Security provides features to support a variety of security authentication
    protocols. In this section, we will focus on basis and form-based authentication.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了支持各种安全认证协议的功能。在本节中，我们将重点放在基础和基于表单的身份验证上。
- en: Spring provides a built-in form for the purpose of form-based authentication.
    In addition, it lets you define your own customized login form.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个内置的表单，用于基于表单的身份验证。此外，它还允许您定义自定义的登录表单。
- en: Spring gives you the option to use in-memory authentication, in which the username
    and password will be hardcoded in the application.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为您提供了使用内存中的身份验证的选项，其中用户名和密码将在应用程序中硬编码。
- en: An alternative option is to use a customized authentication provider that lets
    you decide how to authenticate users by program, for example, calling a data layer
    service to validate users. It also lets you integrate Spring Security with your
    existing security framework.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用自定义的身份验证提供程序，让您决定如何通过程序对用户进行身份验证，例如，调用数据层服务来验证用户。它还允许您将Spring Security与现有的安全框架集成。
- en: The first thing you need in order to configure Spring Security to authenticate
    users is to define a Servlet filter known as `springSecurityFilterChain`. This
    filter is responsible for applying security measures (for example, validating
    users, navigating to different pages after login bases on the user's role, and
    protecting application URLs) in a web application.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Spring Security对用户进行身份验证，首先需要定义一个名为`springSecurityFilterChain`的Servlet过滤器。此过滤器负责在Web应用程序中应用安全措施（例如，验证用户、根据用户角色在登录后导航到不同页面以及保护应用程序URL）。
- en: '`WebSecurityConfigurerAdapter` is a convenient Spring template for configuring
    `springSecurityFilterChain`:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSecurityConfigurerAdapter` 是一个方便的Spring模板，用于配置 `springSecurityFilterChain`：'
- en: '[PRE177]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '`@Configuration` registers this class as a configuration class. The method''s
    name, `configureGlobalSecurity`, is not important, as it only configures an `AuthenticationManagerBuilder`
    instance through autowire. The only important thing is annotating the class with
    `@EnableWebSecurity`, which registers Spring web security in the application.
    As you can see, we used in-memory authentication for simplicity, which hardcoded
    the user''s username, password, and role used for user authentication. In real
    enterprise applications, LDAP, databases or the cloud provide services for validating
    user credentials.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`将此类注册为配置类。方法的名称`configureGlobalSecurity`并不重要，因为它只通过自动装配配置了`AuthenticationManagerBuilder`实例。唯一重要的是用`@EnableWebSecurity`注释类，这将在应用程序中注册Spring
    Web安全性。正如您所看到的，为了简单起见，我们使用了内存中的身份验证，这将用户的用户名、密码和用于用户身份验证的角色硬编码。在真实的企业应用程序中，LDAP、数据库或云提供服务来验证用户凭据。'
- en: We don't code all that much in the config class, but it really does a lot behind
    the scenes. Here are some of the features implemented by the class. Apart from
    user authentication and role assignment, we will explain other features next in
    this chapter.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置类中并没有编写太多代码，但它确实在幕后做了很多工作。以下是该类实现的一些功能。除了用户身份验证和角色分配之外，我们将在本章的下一部分中解释其他功能。
- en: Protecting all application URLs by asking for authentication first
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先要求对所有应用程序URL进行身份验证
- en: Creating a Spring default login form to authenticate the user
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Spring默认登录表单来验证用户
- en: Authenticating users (operator/password, admin/password, accountant/password)
    and assigning separate roles for each user (user, admin, and accountant) using
    form-based authentication
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于表单的身份验证对用户进行身份验证（operator/password，admin/password，accountant/password）并为每个用户分配单独的角色（用户、管理员和会计）
- en: Allowing the user to log out
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户注销
- en: CSRF attack prevention
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSRF攻击预防
- en: As we explained, in real-world enterprise applications, one never hardcodes
    user credentials within the application's code. You may have an existing security
    framework that calls a service in order to validate users. In this case, you can
    configure Spring Security in a customized service to authenticate the user.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所解释的，在现实世界的企业应用程序中，从不在应用程序代码中硬编码用户凭据。您可能有一个现有的安全框架，调用服务以验证用户。在这种情况下，您可以配置Spring
    Security在自定义服务中对用户进行身份验证。
- en: The authentication interface implementation is what carries user credentials
    within the Spring Security context. You can obtain the authentication object anywhere
    within the application using `SecurityContextHolder.getContext().getAuthentication()`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证接口实现是在Spring Security上下文中携带用户凭据的内容。您可以在应用程序的任何地方使用`SecurityContextHolder.getContext().getAuthentication()`获取身份验证对象。
- en: When a user is authenticated, `Authentication` will be populated. If you don't
    specify `AuthenticationProvider` (for example, if you use in-memory authentication),
    `Authentication` will be populated automatically. Here, we look at how to customize
    `AuthenticationProvider` and populate the `Authentication` object.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户经过身份验证时，`Authentication`将被填充。如果您没有指定`AuthenticationProvider`（例如，如果您使用内存中的身份验证），`Authentication`将自动填充。在这里，我们将看看如何自定义`AuthenticationProvider`并填充`Authentication`对象。
- en: 'The following code shows how Spring''s `AuthenticationProvider` implementation
    class integrates with a customized user detail service (which returns user credentials
    from a data source):'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了Spring的`AuthenticationProvider`实现类如何与自定义用户详细信息服务集成（该服务从数据源返回用户凭据）：
- en: '[PRE178]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Your customized authentication provider should implement `AuthenticationProvider`
    and its `authenticate` method.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 您的自定义身份验证提供程序应该实现`AuthenticationProvider`及其`authenticate`方法。
- en: 'Note that the `userService` instance here should implement the Spring `UserDetailsService`
    interface and its `loadUserByUserName` method. The method returns the data model
    of a user. Note that you can extend Spring''s `User` object and create your own
    customized user. We mocked the `UserService` integration part with a data service.
    In a real application, there could be a service call to fetch and return user
    data, and your `UserServiceImpl` class will only wrap the user in the `UserDetails`
    data model, as follows:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的`userService`实例应该实现Spring的`UserDetailsService`接口及其`loadUserByUserName`方法。该方法返回用户的数据模型。请注意，您可以扩展Spring的`User`对象并创建自定义的用户。我们使用数据服务模拟了`UserService`的集成部分。在实际应用中，可能会有一个服务调用来获取并返回用户数据，而您的`UserServiceImpl`类只会将用户包装在`UserDetails`数据模型中，如下所示：
- en: '[PRE179]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: After this, you can set your customized provider in the configuration class,
    as shown in the following code. When a user is authenticated, the authentication
    object should be populated programmatically. Later in this chapter, in the *Authorization*
    section, we will explain this object.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以在配置类中设置您的定制提供程序，如下面的代码所示。当用户经过身份验证时，认证对象应该以编程方式填充。在本章的*授权*部分中，我们将解释这个对象。
- en: '[PRE180]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We defined the `springSecurityFilterChain` filter in the first step. To make
    it work, we need to register it in the web application, like so:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一步中定义了`springSecurityFilterChain`过滤器。为了使其工作，我们需要在Web应用程序中注册它，如下所示：
- en: '[PRE181]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The class doesn't need any code, as the superclass (`AbstractSecurityWebApplicationInitializer`)
    registers the Spring Security filter. This happens while the Spring context starts
    up.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 该类不需要任何代码，因为超类（`AbstractSecurityWebApplicationInitializer`）注册了Spring Security过滤器。这发生在Spring上下文启动时。
- en: 'If we don''t use Spring MVC, we should pass the following to the constructor:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用Spring MVC，我们应该将以下内容传递给构造函数：
- en: '[PRE182]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The class `AnnotatedConfigDispatcherServletInitializer` extends Spring''s Servlet
    initializer `AbstractAnnotationConfigDispatcherServletInitializer`. This class
    allows Servlet 3 containers (for example, Tomcat) to detect the web application
    automatically, without needing `web.xml`. This is another step of simplifying
    the setting up of a web application, and it registers `DispatcherServlet` and
    Servlet mapping programmatically. By setting the `WebSecurityConfigurator` class
    in `getRootConfigClasses`, you tell the parent class method that creates the context
    of the application to use your annotated and customized Spring Security configuration
    class. The following is the code for the `AnnotatedConfigDispatcherServletInitializer`
    class:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 类`AnnotatedConfigDispatcherServletInitializer`扩展了Spring的Servlet初始化程序`AbstractAnnotationConfigDispatcherServletInitializer`。这个类允许Servlet
    3容器（例如Tomcat）自动检测Web应用程序，而无需`web.xml`。这是简化Web应用程序设置的另一步，它以编程方式注册`DispatcherServlet`和Servlet映射。通过在`getRootConfigClasses`中设置`WebSecurityConfigurator`类，您告诉父类方法创建应用程序上下文使用您的注释和定制的Spring
    Security配置类。以下是`AnnotatedConfigDispatcherServletInitializer`类的代码：
- en: '[PRE183]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: What we have configured so far in Spring Security is for checking whether the
    username and password are correct. If we want to configure other security features,
    such as defining a login page and the web application URL request to be authenticated,
    we need to override the `configure(HttpSecurity http)` method of `WebSecurityConfigurerAdapter`.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止在Spring Security中我们配置的是检查用户名和密码是否正确。如果我们想要配置其他安全功能，比如定义登录页面和需要进行身份验证的Web应用程序URL请求，我们需要覆盖`WebSecurityConfigurerAdapter`的`configure(HttpSecurity
    http)`方法。
- en: 'In our customized security configurator, we define a login page (`login.jsp`)
    and an authorization failure page (`nonAuthorized.jsp`), as follows:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定制的安全配置器中，我们定义了一个登录页面（`login.jsp`）和一个授权失败页面（`nonAuthorized.jsp`），如下所示：
- en: '[PRE184]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'This code tells Spring to process a submitted HTTP request form (with the POST
    method) with the expected username and password as parameters and `"/login"` as
    the action. Here is the login form:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉Spring处理提交的HTTP请求表单（使用POST方法）并使用预期的用户名和密码作为参数以及`"/login"`作为操作。以下是登录表单：
- en: '[PRE185]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Tip
  id: totrans-1293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you don't specify a username, password, and `loginProcessingUrl` parameter
    in the configuration file, Spring Security expects `j_username`, `j_password`,
    and `j_spring_security_check` from the client browser. By overriding Spring's
    default values, you can hide the Spring Security implementation from the client
    browser.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在配置文件中没有指定用户名、密码和`loginProcessingUrl`参数，Spring Security会期望客户端浏览器提供`j_username`、`j_password`和`j_spring_security_check`。通过覆盖Spring的默认值，您可以隐藏Spring
    Security的实现。
- en: A **cross-site request forgery** (**CSRF**) attack happens, for example, when
    a malicious link clicked by an authenticated web client performs an unwanted action,
    such as transferring funds, obtaining contact e-mails, or changing passwords.
    Spring Security provides a randomly generated CSRF to protect the client from
    CSRF attacks.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）攻击发生在例如，当经过身份验证的Web客户端点击了一个恶意链接并执行了不需要的操作，比如转账、获取联系人电子邮件或更改密码时。Spring
    Security提供了随机生成的CSRF来保护客户端免受CSRF攻击。'
- en: If you omit `.loginPage` in the `configure` method, Spring uses its default
    login page, which is a very plain HTML login page. In this case, Spring Security
    uses the expected `j_username`, `j_password`, and `j_spring_security_check` parameters
    for the username, password, and action, and you should not configure them in the
    method.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`configure`方法中省略了`.loginPage`，Spring将使用其默认登录页面，这是一个非常简单的HTML登录页面。在这种情况下，Spring
    Security使用预期的`j_username`、`j_password`和`j_spring_security_check`参数作为用户名、密码和操作，您不应该在方法中对其进行配置。
- en: 'For example, here we ask Spring to provide its own default login form:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里我们要求Spring提供其自己的默认登录表单：
- en: '[PRE186]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Spring Security supports HTTP Basic authentication, in which the client browser
    opens a popup (for the initial time) when you want to access a resource that matches
    a pattern (`"/adResources*/**"` in this case):'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security支持HTTP基本身份验证，其中客户端浏览器在您想要访问与模式匹配的资源时（在本例中为`"/adResources*/**"`）会打开一个弹出窗口（初始时）：
- en: '[PRE187]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Server-side navigation could be the next step after authentication. Even though
    routing information is provided from the client side in modern client-side frameworks
    such as AngularJS, you may still want to keep routing logic on the server side.
    A success handler is a Spring Security feature that lets you define navigation
    logic after authentication in a web application.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证后，服务器端导航可能是下一步。尽管现代客户端框架（如AngularJS）从客户端提供路由信息，但您可能仍希望将路由逻辑保留在服务器端。成功处理程序是Spring
    Security的一个功能，它允许您在Web应用程序中定义身份验证后的导航逻辑。
- en: 'Spring Security lets you configure customized server-side navigation after
    authentication. You can configure it inside the `configure` method (using `successHandler`):'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许您在身份验证后配置自定义的服务器端导航。您可以在`configure`方法中配置它（使用`successHandler`）：
- en: '[PRE188]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Your customized navigation handler should implement the interface `AuthenticationSuccessHandler`.
    `OnAuthenticationSuccess` is the method that will be called when a user is authenticated.
    Within this method, we should define the target URL. In the sample implementation
    class shown here, the user''s role is just used to define the target URL:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 您的自定义导航处理程序应实现`AuthenticationSuccessHandler`接口。`OnAuthenticationSuccess`是用户经过身份验证时将调用的方法。在此方法中，我们应该定义目标URL。在此处显示的示例实现类中，用户的角色仅用于定义目标URL：
- en: '[PRE189]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Spring Security lets you configure your security configuration in multiple
    methods, and in each method, you can define a different category of resources.
    Here, we have separated the security configuration for form-based and basic authentication
    into these two classes:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许您在多种方法中配置安全配置，并且在每种方法中，您可以定义不同类别的资源。在这里，我们将基于表单和基本身份验证的安全配置分开到这两个类中：
- en: '[PRE190]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: For example, in one method, we configure resources in the `adResources` path
    to be viewed by the admin role in an HTTP-based authentication (the browser opens
    a popup and asks for a username and password). In the second method, we apply
    form login authorization and limit access to resources based on user roles.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一种方法中，我们配置`adResources`路径中的资源，以便管理员角色在基于HTTP的身份验证中查看（浏览器打开弹出窗口并要求输入用户名和密码）。在第二种方法中，我们应用表单登录授权，并根据用户角色限制对资源的访问。
- en: Authorization
  id: totrans-1309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: In the *Authentication* section, we showed how user-provided credentials (username/password)
    are compared with application-stored ones, and if they match, the user is authenticated.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 在*身份验证*部分，我们展示了用户提供的凭据（用户名/密码）如何与应用程序存储的凭据进行比较，如果匹配，则用户被验证。
- en: To boost security, we can limit the user's access to application resources.
    This is where authorization comes into the picture—the question of who should
    access which application's resources.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强安全性，我们可以限制用户对应用程序资源的访问。这就是授权的问题——谁应该访问哪个应用程序的资源。
- en: 'Spring Security provides very comprehensive authorization features. We can
    categorize these features into these three authorization groups:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了非常全面的授权功能。我们可以将这些功能分类为以下三个授权组：
- en: Web request (who can access which application URL?)
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web请求（谁可以访问哪个应用程序URL？）
- en: Method invoking (who can call a method?)
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用（谁可以调用方法？）
- en: Domain object access (who can see which data?)
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域对象访问（谁可以看到哪些数据？）
- en: For example, a customer should be able to see his own order and profile data,
    whereas an admin should be able to see all the customers' orders plus the data
    that is not visible to any customer.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，客户应该能够查看自己的订单和个人资料，而管理员应该能够查看所有客户的订单以及任何客户无法看到的数据。
- en: Since version 3.0 of Spring Security, Spring has added Spring EL expressions
    to its authorization features. Spring EL lets you convert complex authorization
    logic into simple expressions. In this section, we use Spring EL for authorization.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 自Spring Security 3.0版本以来，Spring已将Spring EL表达式添加到其授权功能中。Spring EL允许您将复杂的授权逻辑转换为简单的表达式。在本节中，我们使用Spring
    EL进行授权。
- en: '`GrandAuthority` in Spring Security is the object for including a string value
    that is interchangeably called an authority, right, or permission (refer to the
    *Authentication* section, where the `AuthenticationProvider` interface is explained,
    to see how `GrandAuthority` is created). By default, if this string value starts
    with the prefix `ROLE_` (for example, `ROLE_ADMIN`), it will be considered as
    a user''s role. So, it is also flexible enough to be used as a permission if it
    does not start with the prefix. Spring Security uses this object for web, method,
    and domain object authorization.'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security中的`GrandAuthority`是一个包含字符串值的对象，该字符串值可以互换地称为权限、权利或许可（请参阅*身份验证*部分，了解如何创建`GrandAuthority`，其中解释了`AuthenticationProvider`接口，以查看`GrandAuthority`是如何创建的）。默认情况下，如果此字符串值以前缀`ROLE_`开头（例如，`ROLE_ADMIN`），它将被视为用户的角色。因此，如果不以前缀开头，它也足够灵活，可以用作权限。Spring
    Security使用此对象进行Web、方法和域对象授权。
- en: 'For web request authorization, we can limit user access based on the user''s
    role in Spring Security, as follows (we will see later in this section how to
    do this in a controller):'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web请求授权，我们可以根据Spring Security中用户的角色限制用户访问，如下所示（我们将在本节后面看到如何在控制器中执行此操作）：
- en: '[PRE191]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Since we use spring MVC, we deny all URLs that end with `.jsp` (`*.jsp`) and
    let MVC map the URL to the JSP page. We permit anybody to have access to the login
    page using (`.antMatchers("/", /login").permitAll()`).
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用spring MVC，我们拒绝所有以`.jsp`结尾的URL（`*.jsp`），并让MVC将URL映射到JSP页面。我们允许任何人访问登录页面（`.antMatchers("/",
    /login").permitAll()`）。
- en: We limit user access to accountant resources to the admin and accountant roles
    (for example, `antMatchers("/accountant*//**").access("hasRole('ADMIN') or hasRole('ACCOUNTANT')")`).
    We set an error URL and forward a user to it if he fails authentication or tries
    to access non-authorized resources with `failureUrl("/nonAuthorized")`.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户对会计资源的访问限制为管理员和会计角色（例如，`antMatchers("/accountant*//**").access("hasRole('ADMIN')
    or hasRole('ACCOUNTANT')")`）。如果用户在身份验证失败或尝试访问未经授权的资源时，我们设置了一个错误URL并将用户转发到该URL，使用`failureUrl("/nonAuthorized")`。
- en: 'You need to add `@EnableGlobalMethodSecurity(prePostEnabled=true)` to be able
    to apply method/domain-level authorization:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加`@EnableGlobalMethodSecurity(prePostEnabled=true)`来应用方法/域级别的授权：
- en: '[PRE192]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We already described how to limit access to URLs using a configuration file.
    You can do the same thing in the controller''s methods too:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了如何使用配置文件限制对URL的访问。您也可以在控制器的方法中做同样的事情：
- en: '[PRE193]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'For method-invoking authorization, you can configure Spring Security at the
    method level and define who can run a particular method in your application''s
    service layer:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法调用授权，您可以在方法级别配置Spring Security，并定义谁可以在应用程序的服务层运行特定方法：
- en: '[PRE194]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'For domain object access, you can apply method-invoking authorization and have
    a service method to fine-tune who can see which data in the application. For example,
    in the service layer, you can limit access if the username parameter is equal
    to the logged-in username or the user has an admin role (refer to `bussinessServiceImpl`
    in the code):'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于域对象访问，您可以应用方法调用授权，并有一个服务方法来微调谁可以在应用程序中看到哪些数据。例如，在服务层，如果用户名参数等于已登录的用户名或用户具有管理员角色，您可以限制访问（参考代码中的`bussinessServiceImpl`）：
- en: '[PRE195]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The OAuth2 Authorization Framework
  id: totrans-1331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2授权框架
- en: The OAuth2 Authorization Framework is simply a way to let third-party applications
    access your protected resources without you sharing your user credentials (username/password).
    You will have faced this situation when a website such as LinkedIn asks you to
    share your e-mail contacts, and when you agree, you are forwarded to your mail
    provider's login page (for example, Yahoo!).
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2授权框架只是让第三方应用程序访问您的受保护资源而不共享用户凭据（用户名/密码）的一种方式。当网站（例如LinkedIn）要求您分享电子邮件联系人时，您会面临这种情况，当您同意时，您将被转到您的邮件提供商的登录页面（例如，雅虎）。
- en: When you log in, the mail provider asks for your permission to share your contacts
    with LinkedIn. Then, LinkedIn can get the list of your contacts in order to send
    them an invitation.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录时，邮件提供商会请求您的许可，以便与LinkedIn分享您的联系人。然后，LinkedIn可以获取您的联系人列表以便发送邀请。
- en: 'OAuth2 relies on the following entities:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2依赖于以下实体：
- en: '**The resource owner**: This is the user with protected resources, for example,
    a Yahoo! e-mail user'
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这是拥有受保护资源的用户，例如，雅虎电子邮件用户'
- en: '**The client or third-party application**: This is an external application
    that requires access to the owner''s protected resources, for example, LinkedIn'
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端或第三方应用程序**：这是需要访问所有者受保护资源的外部应用程序，例如，LinkedIn'
- en: '**The authorization server**: This server grants access to the client/third
    party after authenticating the resource owner and obtaining authorization'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这个服务器在验证资源所有者并获得授权后，授予客户端/第三方访问权限'
- en: '**The resource server**: This server hosts the owner''s protected resources,
    for example, the Yahoo! server'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：这个服务器托管所有者的受保护资源，例如，雅虎服务器'
- en: Many leading providers (for example, Google and Facebook) have both authorization
    and resource servers.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 许多领先的提供商（例如，谷歌和脸书）都有授权和资源服务器。
- en: 'This diagram illustrates how the OAuth2 framework works in a simple form:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表说明了OAuth2框架是如何工作的：
- en: '![The OAuth2 Authorization Framework](img/image00791.jpeg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth2授权框架](img/image00791.jpeg)'
- en: 'Spring facilitates the OAuth2 framework by reusing Spring Security concepts
    for authentication and authorization and includes new features to implement authorization
    and resource servers. To use Spring OAuth2 in your project, you need the following
    dependency:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过重用Spring Security的身份验证和授权概念，并包含新功能来实现授权和资源服务器，从而促进了OAuth2框架。要在项目中使用Spring
    OAuth2，您需要以下依赖：
- en: '[PRE196]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: What we explained in the *Authentication* section with respect to validating
    the user and protecting resources remains the same here. The new things are the
    authorization and resource server settings.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在*身份验证*部分我们解释了关于验证用户和保护资源的内容，这里仍然保持不变。新的内容是授权和资源服务器设置。
- en: The OAuth 2.0 service includes authorization and resource servers. Spring Security
    lets you have separate applications as authorization and resource servers, on
    which one authorization server could be shared by one or many resource servers,
    or have both types of servers in a single application. For simplicity, we implement
    authorization and resource servers within the same application.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0服务包括授权和资源服务器。Spring Security允许您将授权服务器和资源服务器作为独立的应用程序，其中一个授权服务器可以被一个或多个资源服务器共享，或者在单个应用程序中同时拥有这两种类型的服务器。为了简化起见，我们在同一个应用程序中实现了授权和资源服务器。
- en: In the class `MultiOAuth2ResourceAndAuthorizationConfigurator`, we define resource
    and authorization servers. `@EnableResourceServer` tags the class `ResourceServerConfiguration`
    as a resource server, which defines resources with the URL `/public` as non-protected
    and ones with the `/protected/**` URL as secure resources that require a valid
    token to access.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MultiOAuth2ResourceAndAuthorizationConfigurator`类中，我们定义了资源和授权服务器。`@EnableResourceServer`标记`ResourceServerConfiguration`类为资源服务器，它定义了URL
    `/public`的资源为非受保护资源，`/protected/**`的资源为需要有效令牌才能访问的安全资源。
- en: '`@EnableAuthorizationServer` tags `AuthorizationServerConfiguration` as an
    authorization server that grants tokens to third-party clients. `TokenStore` is
    a Spring interface; its implementation classes (`InMemoryTokenStore`, `JdbcTokenStore`,
    and `JwtTokenStore`) keep track of tokens.'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableAuthorizationServer`标记`AuthorizationServerConfiguration`为授权服务器，向第三方客户端授予令牌。`TokenStore`是一个Spring接口；它的实现类（`InMemoryTokenStore`，`JdbcTokenStore`和`JwtTokenStore`）跟踪令牌。'
- en: '`JdbcTokenStore` uses a database to store tokens and has a Spring-JDBC dependency.
    `JdbcTokenStore` is suitable when you want to have a history of tokens, recovery
    after server failure, or the sharing of tokens among several servers.'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTokenStore`使用数据库存储令牌，并且有一个Spring-JDBC依赖。当您想要有令牌的历史记录、服务器故障后的恢复或者在多个服务器之间共享令牌时，`JdbcTokenStore`是合适的。'
- en: '`JwtTokenStore` encodes token-related data into the token itself. `JwtTokenStore`
    does not make tokens persistent and requires `JwtAccessTokenConverter` as a translator
    between a JWT-encoded token and OAuth authentication information.'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '`JwtTokenStore`将与令牌相关的数据编码到令牌本身中。`JwtTokenStore`不会使令牌持久化，并且需要`JwtAccessTokenConverter`作为JWT编码令牌和OAuth认证信息之间的翻译器。'
- en: For simplicity, we use the `InMemoryTokenStore` implementation class, but in
    real applications, using `JdbcTokenStore`/`JwtTokenStore` is a better practice.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们使用`InMemoryTokenStore`实现类，但在实际应用中，使用`JdbcTokenStore`/`JwtTokenStore`是更好的做法。
- en: We reuse the `AuthenticationManager` class that was detailed in the *Authentication*
    section.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了在*身份验证*部分详细介绍的`AuthenticationManager`类。
- en: 'The method `configure(ClientDetailsServiceConfigurer clients)` is the location
    in which we configure token generation settings, as follows:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure(ClientDetailsServiceConfigurer clients)`方法是我们配置令牌生成设置的位置，如下所示：'
- en: '`withClient` tells us which client can access resources (this is separate from
    user authentication)'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withClient`告诉我们哪个客户端可以访问资源（这与用户身份验证分开）'
- en: '`secret` is the client''s password'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret`是客户端的密码'
- en: '`authorities` tells us which user roles are eligible to access the resource'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorities`告诉我们哪些用户角色有资格访问资源'
- en: '`authorizedGrantType` specifies which grant type the client has (for example,
    the refresh and access token)'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorizedGrantType`指定客户端具有哪种授权类型（例如，刷新和访问令牌）'
- en: '`accessTokenValiditySeconds` sets the token''s time to live'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessTokenValiditySeconds`设置令牌的生存时间'
- en: 'The settings are mentioned in the following code:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在以下代码中提到：
- en: '[PRE197]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The resources we granted access to using the token are included in a controller.
    Here, we define a very simple resource:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们授予访问令牌的资源包含在一个控制器中。在这里，我们定义了一个非常简单的资源：
- en: '[PRE198]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'You can run the project with the following command, which builds and runs the
    resource and authorization server:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行项目，该命令构建并运行资源和授权服务器：
- en: '[PRE199]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'If you try the following, you can see the resource because this URL is unprotected:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试以下操作，您可以看到资源，因为此URL未受保护：
- en: '[PRE200]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'However, if you try the next command, you get a "non-authorized" error and
    you need a valid token to access this resource:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您尝试下一个命令，您会收到一个“未经授权”的错误，并且您需要一个有效的令牌才能访问此资源：
- en: '[PRE201]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'You need to get a token first to be able to access protected resources. Spring
    MVC exposes an endpoint, `TokenEndpoint`, in order to get the token with the `/oauth/token`
    URL by default. The following command gives you an authorization token:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要首先获取令牌才能访问受保护的资源。Spring MVC默认情况下在`/oauth/token` URL中公开一个名为`TokenEndpoint`的端点，以获取令牌。以下命令会给您一个授权令牌：
- en: '[PRE202]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Now, you can provide the token and access the secure resource:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以提供令牌并访问安全资源：
- en: '[PRE203]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Notice that we set a time to live for the token and we need to refresh the
    token if it expires. The following command renews the token by calling the `/oauth/token`
    endpoint and passing `refresh_token` as the `grant_type` parameter:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为令牌设置了生存时间，并且如果令牌过期，我们需要刷新令牌。以下命令通过调用`/oauth/token`端点并将`refresh_token`作为`grant_type`参数传递来更新令牌：
- en: '[PRE204]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Summary
  id: totrans-1374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we detailed some features of Spring Security. Since Spring
    Security is a separate module and has a variety of features, in order to get more
    information about the whole specification, you need to go through [https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html)
    and [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/).
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了Spring Security的一些特性。由于Spring Security是一个独立的模块，并且具有各种功能，为了获取有关整个规范的更多信息，您需要阅读[https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html)和[http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)。
- en: Chapter 6. Building a Single-Page Spring Application
  id: totrans-1376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。构建单页Spring应用程序
- en: Having mastered many powerful features of Spring Framework while handling all
    the major technical concerns of enterprise applications, it is time to build a
    modern web application by putting all the techniques we learned in the previous
    chapters together. The current trend in web development is to build **single-page
    applications** (**SPAs**) that offer native-like user experience and an intuitive
    UI. In this chapter, let's build a responsive SPA powered by a Spring backend.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理企业应用程序的所有主要技术问题时，掌握了Spring Framework的许多强大功能，现在是将我们在前几章中学到的所有技术结合起来构建现代Web应用程序的时候了。当前Web开发的趋势是构建提供类似本机用户体验和直观用户界面的**单页应用程序**（**SPAs**）。在本章中，让我们构建一个由Spring后端支持的响应式SPA。
- en: We will use Ember.js for building the SPA and Bootstrap for styling and responsive
    behavior. For Ember development, we will use a command-line tool called **Ember
    CLI**, which runs on Node.js and combines a collection of supporting tools for
    various critical functions of JavaScript-based modern frontend development.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Ember.js构建SPA，并使用Bootstrap进行样式和响应行为。对于Ember开发，我们将使用一个名为**Ember CLI**的命令行工具，它在Node.js上运行，并结合了一系列支持工具，用于JavaScript-based现代前端开发的各种关键功能。
- en: The motivations behind SPAs
  id: totrans-1379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPAs背后的动机
- en: We know that Spring mainly focuses on the server side, that is, the integration,
    service, and data layers. Spring relies on other web technologies for rendering
    the presentation layer. Although Spring MVC does facilitate the presentation layer
    with the help of web technologies such as JSP and Thymeleaf, all of them work
    based on server-side rendering and full-page refreshes for responding to user
    interactions. In this traditional approach, the presentation layer of a web application
    is composed of a bunch of totally independent HTML files served by a server on
    demand, each representing a single screen, with just one rendered to the client
    browser at a time, taking a full round trip to the server for each user interaction.
    This provides a very poor user experience compared to native desktop applications,
    which gracefully re-render just the specific parts of the screen when required.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Spring 主要关注服务器端，即集成、服务和数据层。Spring 依赖于其他 Web 技术来呈现表示层。虽然 Spring MVC 通过诸如
    JSP 和 Thymeleaf 等 Web 技术来促进表示层，但它们都是基于服务器端渲染和全页面刷新来响应用户交互的。在这种传统方法中，Web 应用程序的表示层由一堆完全独立的
    HTML 文件组成，由服务器按需提供，每个文件代表一个屏幕，每次只有一个屏幕呈现给客户端浏览器，每次用户交互都需要完整的往返到服务器。与优雅地在需要时重新呈现屏幕的本机桌面应用程序相比，这提供了非常糟糕的用户体验。
- en: Although you can use some AJAX-using frameworks such as jQuery, in order to
    get data from a server or even for partial rendering of the UI (as in the case
    of JSF), it requires a lot of server resources for the presentation layer, and
    server processing is easily exhausted when the number of concurrent users grows.
    The presentation layer concerns are distributed across both the server and client
    tiers in this approach. UI developers need both client-side as well as server-side
    skills in this case, which makes web development harder.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用一些使用 AJAX 的框架，如 jQuery，以从服务器获取数据，甚至用于 UI 的部分渲染（如 JSF 的情况），但这需要大量服务器资源用于表示层，当并发用户数量增加时，服务器处理很容易耗尽。在这种方法中，表示层关注点分布在服务器和客户端层之间。在这种情况下，UI
    开发人员需要具备客户端和服务器端技能，这使得 Web 开发更加困难。
- en: Web developers had always been looking for a smarter method to build the UI
    of a data-driven application which is developed entirely on the client side, running
    inside a web browser, which offers a native-like rich user experience without
    a full refresh to the server for page transitions and navigations. They wanted
    a way to make their UI dynamic with data purely on the client side, eliminating
    the need for a server during frontend development, and plugs in to the server
    only when everything is ready on the client side. And for all these problems and
    requirements, the SPA paradigm is the answer.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: Web 开发人员一直在寻找一种更智能的方法来构建完全在客户端运行的数据驱动应用程序的用户界面，它运行在 Web 浏览器内部，提供类似本机的丰富用户体验，而无需对页面转换和导航进行完全刷新到服务器。他们希望通过纯粹在客户端上使用数据使其
    UI 动态化，消除前端开发中对服务器的需求，并在客户端准备就绪后才将其插入服务器。对于所有这些问题和要求，SPA 范式是答案。
- en: SPAs explained
  id: totrans-1383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 SPA
- en: An SPA is a web application or website composed entirely of static web resources
    such as HTML, JavaScript, and CSS, loaded just once into the web browser in a
    single page load. Once booted, it updates itself intelligently as the user starts
    interacting with it. Unlike traditional web applications that perform a full page
    refresh for screen navigations, SPA routes and redraws (re-renders) screens without
    reloading the whole page (or the next page) from the server. It reconstructs the
    DOM structure with the help of JavaScript and styles itself with CSS in response
    to user actions and application events in order to represent them on the screen.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 是一个完全由静态 Web 资源组成的 Web 应用程序或网站，如 HTML、JavaScript 和 CSS，在单个页面加载中加载一次。一旦启动，随着用户开始与其交互，它会智能地更新自身。与传统
    Web 应用程序为屏幕导航执行完整页面刷新不同，SPA 在不重新加载整个页面（或下一个页面）的情况下路由和重新绘制（重新呈现）屏幕。它使用 JavaScript
    重建 DOM 结构，并响应用户操作和应用程序事件以在屏幕上表示它们。
- en: After the initial boot, the only time an SPA confers with a server is for dynamic
    data. SPAs usually rely on AJAX or WebSockets for data access from the server.
    The data transfer format is mostly JSON and sometimes XML. They contact the server
    via AJAX over HTTP asynchronously behind the scenes; this gives a smooth, fluid
    user experience without blocking the screen or keeping the user waiting for server
    responses. Besides, the server can synchronize its data changes with the client
    using the WebSocket API to provide a real-time experience.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 初始启动后，SPA 与服务器通信的唯一时间是获取动态数据。SPA 通常依赖于 AJAX 或 WebSockets 从服务器获取数据访问。数据传输格式主要是
    JSON，有时也是 XML。它们通过 AJAX 异步地在后台通过 HTTP 与服务器联系；这样可以提供流畅、流畅的用户体验，而不会阻塞屏幕或让用户等待服务器响应。此外，服务器可以使用
    WebSocket API 与客户端同步其数据更改，以提供实时体验。
- en: The architectural benefits of SPAs
  id: totrans-1386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPA 的架构优势
- en: Besides the massive productivity gain and prominence of frontend developers,
    SPA offers many architectural benefits. It is blazingly fast compared to traditional
    server-rendered web applications, since it works entirely locally to the client.
    SPA offers a much more smooth and fluid user experience because of its immediate
    response, without needing us to resubmit the entire page to the server on every
    user interaction.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前端开发人员的巨大生产力增益和显著性，SPA 还提供了许多架构优势。与传统的服务器渲染的 Web 应用程序相比，它的运行速度非常快，因为它完全在客户端本地工作。SPA
    提供了更加流畅和流畅的用户体验，因为它能够立即响应，而无需在每次用户交互时重新提交整个页面到服务器。
- en: Note
  id: totrans-1388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript-intensive web applications run best on modern web browsers with enough
    memory on the host computer. Most frameworks utilize many HTML5 features and newer
    JavaScript functionality such as AJAX. SPAs can kill older browsers on slower
    PCs in no time.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 密集型 Web 应用程序在具有足够内存的现代 Web 浏览器上运行效果最佳。大多数框架利用许多 HTML5 功能和更新的 JavaScript
    功能，如 AJAX。SPA 可以在较慢的 PC 上迅速淘汰旧版浏览器。
- en: SPAs offload the responsibility of the entire application state to the browser,
    freeing up server resources to focus on the core business logic (service) and
    data in terms of stateless web services, often designed as REST APIs. With SPAs,
    the server just becomes an API server; the entire user interaction is handled
    by the client, which improves server scalability a lot.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: SPA将整个应用程序状态的责任转移到浏览器，释放服务器资源以便专注于核心业务逻辑（服务）和状态无关的Web服务数据，通常设计为REST API。使用SPA，服务器只是一个API服务器；整个用户交互由客户端处理，这极大地提高了服务器的可扩展性。
- en: Another advantage, probably the most important one of SPAs, is that both client
    and server applications can be designed and evolved independently from each other.
    You can replace either of these without affecting the other as long as the endpoint
    (API) contracts remain intact. Also, you can let frontend developers build the
    UI and backend developers provide the data; both teams can focus on their own
    domain while working around a data contract.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势，也许是SPA最重要的优势之一，是客户端和服务器应用程序可以独立设计和演进。只要端点（API）合同保持完整，您可以替换其中一个而不影响另一个。此外，您可以让前端开发人员构建UI，后端开发人员提供数据；两个团队都可以专注于自己的领域，同时围绕数据合同进行工作。
- en: SPA frameworks
  id: totrans-1392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPA框架
- en: 'Developing an SPA in plain JavaScript is not a smart idea considering the magnitude
    of responsibility handled by the SPA paradigm. It would be extremely tiring and
    error-prone if we set out to write all the routing, data binding, screen authoring,
    and rendering code from scratch in our applications. Fortunately, a set of very
    impressive frameworks emerged out of the SPA concept. Each of them offers varying
    levels of abstraction and architecture styles; some of them use powerful templating
    technologies. Let''s take a look at the most popular SPA frameworks:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中开发SPA并不是一个明智的想法，考虑到SPA范式所处理的责任的重要性。如果我们打算从头开始编写所有路由、数据绑定、屏幕创作和渲染代码，那将会非常累人且容易出错。幸运的是，一系列令人印象深刻的框架从SPA概念中出现。它们每个都提供不同级别的抽象和架构风格；其中一些使用强大的模板技术。让我们来看看最流行的SPA框架：
- en: '**AngularJS**: Maintained by Google and supported by a community of developers
    and companies, Angular is the most popular and widely used SPA framework. It enhances
    vanilla HTML with the help of smart directives by adding two-way data binding.
    Angular supports localization and the building of reusable components.'
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AngularJS**：由Google维护并得到开发人员和公司社区的支持，Angular是最流行和广泛使用的SPA框架。它通过智能指令增强了原始HTML，实现了双向数据绑定。Angular支持本地化和可重用组件的构建。'
- en: '**ReactJS**: Backed by Facebook, Instagram, and a community of developers and
    companies, React is the fastest growing SPA framework at the time of writing.
    Facebook and Instagram have been developed using React. Its working is based on
    the concept of virtual DOM, an in-memory representation of displayed DOM that
    can be rendered either at the client or server (using Node), and manipulated using
    one-way binding. React screens are authored using JSX, an extension of JavaScript
    that allows the easy quoting of HTML inside JavaScript functions.'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReactJS**：由Facebook、Instagram和一群开发人员和公司支持，React是撰写时增长最快的SPA框架。Facebook和Instagram都是使用React开发的。它的工作基于虚拟DOM的概念，即显示的DOM的内存表示，可以在客户端或服务器（使用Node）上呈现，并使用单向绑定进行操作。React屏幕是使用JSX编写的，这是JavaScript的扩展，允许在JavaScript函数中轻松引用HTML。'
- en: '**Ember.js**: A very powerful JavaScript MVC framework created by Yehuda Katz
    and contributed to by a strong community of active developers, Ember is used by
    many popular heavy traffic websites and applications, such as Groupon, Yahoo!
    (Ad Manager Plus), Zendesk, Square, Discourse, and LivingSocial. Ember can be
    used for building mobile and desktop applications: Apple Music is a notable desktop
    application built with Ember. Ember addresses the end-to-end problems of client-side
    web applications in an opinionated fashion. An early adopter of web and JavaScript
    standards such as ES6, web components, and promises, Ember comes with a set of
    powerful productivity tools and components that make it a complete-stack frontend
    framework.'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember.js**：由Yehuda Katz创建并由一群活跃的开发人员社区贡献的非常强大的JavaScript MVC框架，Ember被许多热门高流量的网站和应用程序使用，如Groupon、Yahoo!（广告管理器Plus）、Zendesk、Square、Discourse和LivingSocial。Ember可用于构建移动和桌面应用程序：Apple
    Music是一个使用Ember构建的著名桌面应用程序。Ember以一种有主见的方式解决了客户端Web应用程序的端到端问题。作为Web和JavaScript标准的早期采用者，如ES6、Web组件和Promises，Ember配备了一套强大的生产工具和组件，使其成为一个完整的前端框架。'
- en: In this chapter, we will use Ember.js for building an SPA that works as the
    frontend for a Spring API server. We will explore Ember.js, its core components,
    and the development tools first and then develop the frontend application using
    Ember, connecting to a Spring-based API server on the backend. This chapter will
    make you a full-stack developer with both server-side and client-side skills on
    the modern technology stack.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Ember.js来构建一个作为Spring API服务器前端的SPA。我们将首先探索Ember.js及其核心组件和开发工具，然后使用Ember开发前端应用程序，连接到后端的基于Spring的API服务器。本章将使您成为现代技术栈上具有服务器端和客户端技能的全栈开发人员。
- en: Introducing Ember.js
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Ember.js
- en: Ember is a comprehensive frontend framework for creating ambitious web applications.
    It is modeled after the **Model-View-Controller** (**MVC**) architectural pattern
    for the frontend. Its well-designed components with clearly defined responsibilities
    and rich capabilities allow developers to develop complex web applications with
    dramatically less code. In an Ember application, screens are composed using Handlebars
    templates that update themselves automatically when the underlying data changes.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: Ember是一个全面的前端框架，用于创建雄心勃勃的Web应用程序。它是根据前端的**模型-视图-控制器**（**MVC**）架构模式建模的。其设计良好的组件具有明确定义的责任和丰富的功能，使开发人员能够使用大大减少的代码开发复杂的Web应用程序。在Ember应用程序中，屏幕是使用Handlebars模板组成的，当底层数据发生变化时，它们会自动更新自己。
- en: 'Ember is productive out of the box, with a comprehensive development stack
    and a friendly API. The Ember development stack contains the following tools:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: Ember在开箱即用时非常高效，具有全面的开发堆栈和友好的API。Ember开发堆栈包含以下工具：
- en: '**Ember CLI**: This is a command-line tool for creating projects, scaffolding,
    and managing their resources. It provides a development server with live reload,
    a testing framework, mocking server, and comprehensive asset management support.'
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember CLI**：这是一个用于创建项目、脚手架和管理资源的命令行工具。它提供了一个带有实时重新加载的开发服务器、一个测试框架、模拟服务器和全面的资产管理支持。'
- en: '**Ember Inspector**: This is a debugger-cum-inspector tool for Ember applications,
    shipped as a plugin for Firefox and Chrome browsers. It allows you to evaluate
    and change Ember objects, elements, and variables while debugging, and provides
    a visual representation of the running Ember app.'
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember Inspector**：这是一个用于Ember应用程序的调试器兼检查器工具，作为Firefox和Chrome浏览器的插件进行发布。它允许您在调试时评估和更改Ember对象、元素和变量，并提供运行中的Ember应用程序的可视化表示。'
- en: '**Ember Data**: This subproject of Ember is a data-persistence library that
    can be directly mapped to a remote data source, such as a REST API. It maps Ember
    model objects with data entities on the server side via channels such as API endpoints.
    Ember Data provides adapters and serializers for standard REST and JSON API endpoints,
    and allows you to create your own adapters for any data source, for example, the
    browser''s local storage.'
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember Data**：Ember的这个子项目是一个数据持久化库，可以直接映射到远程数据源，比如REST API。它通过诸如API端点之类的通道将Ember模型对象与服务器端的数据实体进行映射。Ember
    Data为标准的REST和JSON API端点提供了适配器和序列化器，并允许您为任何数据源创建自己的适配器，例如浏览器的本地存储。'
- en: '**Fastboot**: This is a server based on Node.js for the server-side rendering
    of Ember resources, eliminating the need for downloading JavaScript payloads post
    the loading of static assets for increased performance.'
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fastboot**：这是一个基于Node.js的服务器，用于Ember资源的服务器端渲染，消除了在加载静态资产后下载JavaScript有效负载的需求，从而提高了性能。'
- en: '**Liquid Fire**: This provides animation support for Ember views.'
  id: totrans-1405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liquid Fire**：这为Ember视图提供了动画支持。'
- en: '**A testing framework**: Ember CLI integrates QUnit for testing Ember resources.'
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试框架**：Ember CLI集成了QUnit来测试Ember资源。'
- en: Ember is a very opinionated framework; this means that you are expected to structure
    the app by its own conventions, and then the framework takes care of the rest.
    If you follow the guidelines, you will end up writing very little, and very readable,
    code. Ember CLI generates the Ember project structure and artifacts with simple
    commands, in the way expected by the framework.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: Ember是一个非常有主见的框架；这意味着你应该按照它自己的约定来构建应用程序，然后框架会处理剩下的事情。如果你遵循指南，你最终会写很少而且易读的代码。Ember
    CLI通过简单的命令生成Ember项目结构和构件，符合框架的预期方式。
- en: The anatomy of an Ember application
  id: totrans-1408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ember应用程序的解剖结构
- en: An Ember application is composed of a set of core elements with well-defined
    responsibilities and properties. They are defined under the Ember and DS namespaces
    of the Ember API.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: Ember应用程序由一组具有明确定义的责任和属性的核心元素组成。它们在Ember API的Ember和DS命名空间下定义。
- en: 'This diagram depicts the high-level structure of an Ember application:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图描述了Ember应用程序的高级结构：
- en: '![The anatomy of an Ember application](img/image00792.jpeg)'
  id: totrans-1411
  prefs: []
  type: TYPE_IMG
  zh: '![Ember应用程序的解剖结构](img/image00792.jpeg)'
- en: Routers
  id: totrans-1412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: A router manages the application state. It maps a set of logical routes against
    unique URLs as mapped in the router configuration.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器管理应用程序状态。它将一组逻辑路由映射到路由器配置中映射的唯一URL。
- en: Routes or route handlers
  id: totrans-1414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由或路由处理程序
- en: A route handler, also known as a route (defined in `Ember.Route`), represents
    the handler for an individual route transition. A route can render a template
    that displays a screen. A route provides a model (data) that can be consumed by
    its template and controller. It has a corresponding controller that can handle
    user actions and maintain the state. A route can handle user actions by itself.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序，也称为路由（在`Ember.Route`中定义），表示单个路由转换的处理程序。路由可以呈现显示屏的模板。路由提供一个可以被其模板和控制器使用的模型（数据）。它有一个相应的控制器，可以处理用户操作并维护状态。路由可以自行处理用户操作。
- en: Templates
  id: totrans-1416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are HTML fragments, usually rendered by routes and components. The
    user interface of an Ember application is composed of a collection of templates.
    Templates use the Handlebars syntax, which looks like regular HTML with some Handlebars
    expressions, which are enclosed in double curly braces (`{{ }}`). These Handlebars
    expressions bind Ember resources such as properties, objects, helpers, and components.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是HTML片段，通常由路由和组件渲染。Ember应用程序的用户界面由一系列模板组成。模板使用Handlebars语法，看起来像是带有一些Handlebars表达式的常规HTML，这些表达式用双大括号（`{{
    }}`）括起来。这些Handlebars表达式绑定Ember资源，如属性、对象、帮助器和组件。
- en: Components
  id: totrans-1418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'Components control the behavior of the user interface. They handle user actions
    and manage many attributes that are used by the templates. A component consists
    of two parts:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 组件控制用户界面的行为。它们处理用户操作并管理模板使用的许多属性。组件由两部分组成：
- en: A JavaScript object that extends `Ember.Component`, where the actions and attributes
    are defined
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展了`Ember.Component`的JavaScript对象，其中定义了操作和属性
- en: A template that is rendered into the parent view, usually that of a router
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个渲染到父视图的模板，通常是路由的模板
- en: Models
  id: totrans-1422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Part of the Ember Data project, models represent the state of domain data in
    an Ember application. An Ember application will typically have a set of models
    extending from `DS.Model`. Routes usually display model data with the help of
    templates and modify data from the action handlers. Models are often loaded from
    a store (`DS.Store`), while Model instances are fetched from the actual persistent
    storage, mostly an API endpoint on the web server. Models can be persisted to
    the store; usually, they are sent back to the appropriate API endpoints.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ember Data项目的一部分，模型代表Ember应用程序中域数据的状态。一个Ember应用程序通常会有一组从`DS.Model`扩展的模型。路由通常会使用模板显示模型数据，并通过操作处理程序修改数据。模型通常从存储库（`DS.Store`）加载，而模型实例则从实际的持久存储中获取，通常是Web服务器上的API端点。模型可以持久保存到存储库；通常它们会被发送回适当的API端点。
- en: Controllers
  id: totrans-1424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers have a limited role in modern Ember applications; they will be deprecated
    in future versions. Currently, their use is limited to maintaining the state for
    a route and handling user actions. Since routes and components can handle actions,
    they are the perfect places for adding action handlers instead of controllers.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在现代Ember应用程序中的作用有限；它们将在未来版本中被弃用。目前，它们的用途仅限于维护路由的状态和处理用户操作。由于路由和组件可以处理操作，它们是添加操作处理程序的理想位置，而不是控制器。
- en: Besides these core elements, there are some supporting components that help
    the application development be easier and more elegant.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心元素，还有一些支持组件，可以帮助应用程序开发更加简单和优雅。
- en: Input helpers
  id: totrans-1427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入助手
- en: These are ready-made components bundled with Ember for taking inputs from users.
    Most of them are Ember versions of general form controls. Examples are the `{{input}}`
    and `{{textarea}}` input helpers. Custom-developed components can be used similarly
    to input helpers.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Ember捆绑的现成组件，用于从用户那里获取输入。它们大多是一般表单控件的Ember版本。例如`{{input}}`和`{{textarea}}`输入助手。自定义开发的组件可以类似于输入助手。
- en: Custom helpers
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义助手
- en: Helpers add custom functionality to an application when they are not readily
    available, for using inside templates. Mostly, they are used for some kind of
    formatting. Examples are `{{format-date}}` and `{{format-currency}}`.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 助手在模板内部不容易获得时，可以为应用程序添加自定义功能。它们大多用于某种格式化。例如`{{format-date}}`和`{{format-currency}}`。
- en: Initializers
  id: totrans-1431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化器
- en: 'Initializers can perform certain operations on application boot. There are
    two types of initializers: application initializers, which are executed on application
    boot, and application instance initializers, which load on application instance
    boot.'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器可以在应用程序启动时执行某些操作。有两种类型的初始化器：应用程序初始化器，在应用程序启动时执行；应用程序实例初始化器，在应用程序实例启动时加载。
- en: Services
  id: totrans-1433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Services are objects that can hold data and functions whose scope is application-wide.
    They are typically used for encapsulating core business logic spanned across many
    routes. Services can be injected into controllers, routes, components, and so
    on, where their methods can be invoked.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是可以保存数据和函数的对象，其范围是整个应用程序。它们通常用于封装跨多个路由的核心业务逻辑。服务可以被注入到控制器、路由、组件等中，从而可以调用它们的方法。
- en: Working with Ember CLI
  id: totrans-1435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ember CLI
- en: Ember CLI is an integrated, rapid development environment for Ember applications.
    Based on Broccoli, a fast and reliable asset pipeline that runs on Node.js, Ember
    CLI is a powerful command-line interface that integrates many productivity tools
    and optimization utilities necessary for JavaScript development.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: Ember CLI是用于Ember应用程序的集成快速开发环境。基于Broccoli，一个在Node.js上运行的快速可靠的资产管道，Ember CLI是一个强大的命令行界面，集成了许多必要的JavaScript开发工具和优化实用程序。
- en: 'Ember CLI provides the following features and tools for Ember development:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: Ember CLI为Ember开发提供了以下功能和工具：
- en: It creates a strong, convention-based project structure for Ember applications
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为Ember应用程序创建了一个强大的基于约定的项目结构
- en: It generates Ember-specific application resources, such as routes, templates,
    and components, from the command line
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从命令行生成特定于Ember的应用程序资源，如路由、模板和组件
- en: It supports template authoring in the Handlebars, HTMLBars, and Emblem.js formats
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持在Handlebars、HTMLBars和Emblem.js格式中进行模板编写
- en: It supports scripting in ES2015 (ES6) modules, CoffeeScript, and EmberScript
    syntaxes
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持ES2015（ES6）模块、CoffeeScript和EmberScript语法的脚本编写
- en: It supports CSS authoring in CSS, Sass, Compass, and Stylus
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持在CSS、Sass、Compass和Stylus中进行CSS编写
- en: It converts Node.js-style ES2015 modules into RequireJS-model AMD modules
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将Node.js风格的ES2015模块转换为RequireJS模型的AMD模块
- en: It integrates the npm and Bower package managers for managing dependencies to
    JS libraries
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它集成了npm和Bower包管理器来管理对JS库的依赖关系
- en: It integrates a development server with LiveReload, which automatically rebuilds
    and updates code changes to all connected browsers
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它集成了一个带有LiveReload的开发服务器，可以自动重新构建和更新代码更改到所有连接的浏览器
- en: It performs asset management functions for application resources (combining,
    minifying, uglifying, versioning, and so on)
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为应用程序资源执行资产管理功能（合并、最小化、混淆、版本控制等）
- en: It enables the sharing of code and functionality using add-ons and blueprints
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过使用插件和蓝图来共享代码和功能
- en: Later in this chapter, we will use Ember CLI as a development tool for building
    an Ember application and its various artifacts.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将使用Ember CLI作为构建Ember应用程序及其各种构件的开发工具。
- en: Setting up Ember CLI
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Ember CLI
- en: Ember CLI depends on Node.js. So, the first step is installing Node.js. Follow
    the instructions given on the website [http://nodejs.org](http://nodejs.org) to
    set up Node.js.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: Ember CLI依赖于Node.js。因此，第一步是安装Node.js。请按照网站[http://nodejs.org](http://nodejs.org)上的说明设置Node.js。
- en: 'Once Node.js is installed, you can install Ember CLI using `npm`, with the
    following command:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Node.js，就可以使用以下命令使用`npm`安装Ember CLI：
- en: '[PRE205]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Now, install Bower using the following command:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令安装Bower：
- en: '[PRE206]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: You may optionally install Watchman for better watching of code changes and
    the PhantomJS test-running environment.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择安装Watchman以更好地观察代码更改和PhantomJS测试运行环境。
- en: Getting started with Ember CLI commands
  id: totrans-1456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ember CLI命令开始
- en: 'Once Ember CLI is installed, you may start creating Ember applications incrementally
    using this set of commands to generate the required Ember artifacts:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Ember CLI后，您可以使用以下一组命令逐步创建Ember应用程序所需的构件：
- en: '| Command | Purpose |'
  id: totrans-1458
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 目的 |'
- en: '| --- | --- |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ember` | Prints the available commands. |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
  zh: '| `ember` | 打印可用的命令。 |'
- en: '| `ember new <appname>` | Generates a fresh new project root folder with the
    same name as `<appname>`, the whole project structure, and all the necessary artifacts
    for a starter Ember application. |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
  zh: '| `ember new <appname>` | 生成一个名为`<appname>`的全新项目根目录，整个项目结构以及启动Ember应用程序所需的所有构件。
    |'
- en: '| `ember init` | Turns the current directory into an Ember application and
    generates all necessary artifacts. |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
  zh: '| `ember init` | 将当前目录转换为Ember应用程序，并生成所有必要的构件。 |'
- en: '| `ember build` | Builds and generates the deployable to the `dist` directory.
    Specify the environment using the environment flag, which defaults to `development`.
    |'
  id: totrans-1463
  prefs: []
  type: TYPE_TB
  zh: '| `ember build` | 构建并生成可部署到`dist`目录的内容。使用环境标志指定环境，默认为`development`。 |'
- en: '| `ember server (or serve)` | Starts the development server at port `4200`.
    You may point to another port using the `--port` flag, for example, `ember serve
    --port 8080`. |'
  id: totrans-1464
  prefs: []
  type: TYPE_TB
  zh: '| `ember server (or serve)` | 在端口`4200`启动开发服务器。您可以使用`--port`标志指向另一个端口，例如`ember
    serve --port 8080`。 |'
- en: '| `ember generate <generatortype> <name> <options>` | Generates specific generators,
    such as route, template, and helper, with the given name and options. Type `ember
    help generate` for the full list of available generators. Use the `--pod` flag
    for generators in the POD structure (explained later). |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
  zh: '| `ember generate <generatortype> <name> <options>` | 生成特定的生成器，例如路由、模板和帮助程序，以及给定的名称和选项。输入`ember
    help generate`以获取可用生成器的完整列表。对于POD结构中的生成器，请使用`--pod`标志（稍后会解释）。 |'
- en: '| `ember destroy <generatortype> <name> <options>` | Removes artifacts created
    using the `ember generate` command. Remember to use the `--pod` flag if it was
    used while generating the artifact. |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
  zh: '| `ember destroy <generatortype> <name> <options>` | 删除使用`ember generate`命令创建的构件。记得在生成构件时使用`--pod`标志。
    |'
- en: '| `ember test` | Runs tests written in the application using the Testem test
    runner. |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
  zh: '| `ember test` | 使用Testem测试运行程序运行应用程序中编写的测试。 |'
- en: '| `ember install <addon-name>` | Installs the given add-on into the application
    and registers it in the `package.json` file. |'
  id: totrans-1468
  prefs: []
  type: TYPE_TB
  zh: '| `ember install <addon-name>` | 将给定的插件安装到应用程序中，并在`package.json`文件中注册它。 |'
- en: The Ember project structure
  id: totrans-1469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ember项目结构
- en: 'When you use the `ember new <project-name>` command, Ember CLI generates and
    organizes files in a specific structure based on convention and then compiles
    them and performs a set of tasks during building and runtime. The following table
    describes the folder layout and important files generated by Ember CLI:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ember new <project-name>`命令时，Ember CLI根据约定生成和组织文件，并在构建和运行时编译它们并执行一系列任务。以下表格描述了Ember
    CLI生成的文件夹布局和重要文件：
- en: '| File/Folder | Description |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
  zh: '| 文件/文件夹 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app/` | This is the Ember application root. The `index.html` file and all
    your JavaScript files and templates go inside this, under proper subdirectories.
    Everything except `index.html` is compiled through the ES6 module transpiler,
    minified and concatenated to `<app-name>.js`, and then loaded by the `index.html`
    file at build time. |'
  id: totrans-1473
  prefs: []
  type: TYPE_TB
  zh: '| `app/` | 这是Ember应用程序根目录。`index.html`文件和所有JavaScript文件和模板都放在这里的适当子目录下。除了`index.html`之外的所有内容都通过ES6模块转换器进行编译，然后被缩小和连接到`<app-name>.js`，然后在构建时由`index.html`文件加载。
    |'
- en: '| `app/index.html` | This is the only HTML page loaded from the server, which
    boots the Ember application on load from `<app-name>.js`, and is loaded using
    the `<script/>` tag embedded in it. Ember builds the entire DOM structure from
    inside this foundation HTML document in the browser at runtime. |'
  id: totrans-1474
  prefs: []
  type: TYPE_TB
  zh: '| `app/index.html` | 这是从服务器加载的唯一HTML页面，它从`<app-name>.js`引导Ember应用程序，并使用嵌入其中的`<script/>`标签加载。Ember在运行时从此基础HTML文档内部构建整个DOM结构。
    |'
- en: '| `app/app.js` | This is the Ember application module. This is the application''s
    entry point, where all the other modules are initialized and injected in order
    to create the entire application instance based on the resolver and environment-specific
    configuration. |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '| `app/app.js` | 这是Ember应用程序模块。这是应用程序的入口点，所有其他模块都在这里初始化并注入，以便根据解析器和特定环境的配置创建整个应用程序实例。
    |'
- en: '| `app/router.js` | This is the router configuration module of the application.
    |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
  zh: '| `app/router.js` | 这是应用程序的路由配置模块。 |'
- en: '| `app/adapters/` | Adapters for Ember Data modules go here. This folder is
    generated when the `ember generate adapter <model-name>` command is executed for
    the first time. |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '| `app/adapters/` | Ember Data模块的适配器放在这里。当第一次执行`ember generate adapter <model-name>`命令时，将生成此文件夹。
    |'
- en: '| `app/components/` | All components go here, unless the `--pod` option is
    used. |'
  id: totrans-1478
  prefs: []
  type: TYPE_TB
  zh: '| `app/components/` | 所有组件都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/controllers/` | All controllers go here, unless the `--pod` option is
    used. |'
  id: totrans-1479
  prefs: []
  type: TYPE_TB
  zh: '| `app/controllers/` | 所有控制器都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/helpers/` | All helpers go here, unless the `--pod` option is used.
    |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
  zh: '| `app/helpers/` | 所有帮助程序都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/models/` | All models go here, unless the `--pod` option is used. |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
  zh: '| `app/models/` | 所有模型都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/routes/` | All routes go here, unless the `--pod` option is used. |'
  id: totrans-1482
  prefs: []
  type: TYPE_TB
  zh: '| `app/routes/` | 所有路由都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/services` | All services go here, unless the `--pod` option is used.
    |'
  id: totrans-1483
  prefs: []
  type: TYPE_TB
  zh: '| `app/services` | 所有服务都放在这里，除非使用了`--pod`选项。 |'
- en: '| `app/styles/` | Put all your style sheets for the application, whether Sass,
    LESS, Stylus, Compass, or plain CSS, here. Only plain CSS is supported by default;
    you can enable other types by installing the appropriate `npm` modules. For Sass,
    type `ember install ember-cli-sass` in the command line. For LESS, the command
    is `ember-cli-less`; for Compass, `ember-cli-compass-compiler`, and so on. For
    the default CSS option, add your styles to `app.css`. You can also organize the
    styles in different CSS files and import them to your `app.css` file. |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '| `app/styles/` | 将应用程序的所有样式表放在这里，无论是Sass、LESS、Stylus、Compass还是纯CSS。默认情况下只支持纯CSS；您可以通过安装适当的`npm`模块来启用其他类型。对于Sass，在命令行中输入`ember
    install ember-cli-sass`。对于LESS，命令是`ember-cli-less`；对于Compass，是`ember-cli-compass-compiler`，依此类推。对于默认的CSS选项，请将样式添加到`app.css`中。您还可以将样式组织在不同的CSS文件中，并将它们导入到您的`app.css`文件中。
    |'
- en: '| `app/templates/` | All templates go here, unless the `--pod` option is used.
    |'
  id: totrans-1485
  prefs: []
  type: TYPE_TB
  zh: '| `app/templates/` | 所有模板都放在这里，除非使用了`--pod`选项。 |'
- en: '| `bower.json` | This is the Bower configuration file. |'
  id: totrans-1486
  prefs: []
  type: TYPE_TB
  zh: '| `bower.json` | 这是Bower配置文件。 |'
- en: '| `bower_components/` | Dependencies managed by Bower go here. |'
  id: totrans-1487
  prefs: []
  type: TYPE_TB
  zh: '| `bower_components/` | 由Bower管理的依赖项放在这里。 |'
- en: '| `config/` | Application configuration files fall here. |'
  id: totrans-1488
  prefs: []
  type: TYPE_TB
  zh: '| `config/` | 应用程序配置文件放在这里。 |'
- en: '| `config/environment.js` | Your environment-specific configurations go inside
    this file. |'
  id: totrans-1489
  prefs: []
  type: TYPE_TB
  zh: '| `config/environment.js` | 您的特定于环境的配置放在这个文件中。 |'
- en: '| `dist/` | The deployable files generated by the build process go here. This
    is what you need to distribute for release. |'
  id: totrans-1490
  prefs: []
  type: TYPE_TB
  zh: '| `dist/` | 构建过程生成的可部署文件放在这里。这是您需要发布的内容。 |'
- en: '| `ember-cli-build.js` | This is the Broccoli build file. Include all resources
    managed by Bower and `npm` here. |'
  id: totrans-1491
  prefs: []
  type: TYPE_TB
  zh: '| `ember-cli-build.js` | 这是Broccoli构建文件。在这里包括所有由Bower和`npm`管理的资源。 |'
- en: '| `node_modules` | All node dependencies managed by npm go here. |'
  id: totrans-1492
  prefs: []
  type: TYPE_TB
  zh: '| `node_modules` | 所有由npm管理的node依赖项放在这里。 |'
- en: '| `package.json` | This is the NPM dependency configuration file. |'
  id: totrans-1493
  prefs: []
  type: TYPE_TB
  zh: '| `package.json` | 这是NPM依赖项配置文件。 |'
- en: '| `public/` | This is a directory for uncompiled assets, such as fonts and
    images. The contents are copied as they are. |'
  id: totrans-1494
  prefs: []
  type: TYPE_TB
  zh: '| `public/` | 这是一个用于未编译资产（如字体和图像）的目录。内容会按原样复制。 |'
- en: '| `server/` | This is where you can set up a development server for mock APIs
    and tests. |'
  id: totrans-1495
  prefs: []
  type: TYPE_TB
  zh: '| `server/` | 这是您可以为模拟API和测试设置开发服务器的地方。 |'
- en: '| `tests/` | All your unit and integration tests go here. |'
  id: totrans-1496
  prefs: []
  type: TYPE_TB
  zh: '| `tests/` | 所有单元测试和集成测试都放在这里。 |'
- en: '| `tmp/` | This is a temporary folder for build execution. |'
  id: totrans-1497
  prefs: []
  type: TYPE_TB
  zh: '| `tmp/` | 这是一个用于构建执行的临时文件夹。 |'
- en: '| `vendor/` | Place your external dependencies that are not managed by npm
    or Bower here. |'
  id: totrans-1498
  prefs: []
  type: TYPE_TB
  zh: '| `vendor/` | 将不由npm或Bower管理的外部依赖项放在这里。 |'
- en: At the end of the build process, Ember CLI generates the deployable at `dist/directory`.
    You need to distribute the contents of this directory for hosting the deployable
    on a web server on release.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程结束时，Ember CLI会在`dist/directory`生成可部署文件。您需要分发该目录的内容，以便在发布时将可部署文件托管到Web服务器上。
- en: Working with the POD structure
  id: totrans-1500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用POD结构进行工作
- en: By default, the `ember generate <generator>` command generates artifacts inside
    specific resource directories directly under the `app` root directory. So, all
    your routes go under `app/routes`, templates under `app/templates`, and so on.
    However, this becomes a bit unmaintainable as the application grows. To solve
    this problem, Ember CLI provides the option of organizing your files in a feature-driven
    (POD) structure using the `--pod` flag when you generate an artifact using the
    `ember generate` command.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ember generate <generator>`命令会在`app`根目录下直接生成特定资源目录内的工件。因此，所有路由都放在`app/routes`下，模板放在`app/templates`下，依此类推。然而，随着应用程序的增长，这变得有点难以维护。为了解决这个问题，Ember
    CLI提供了使用`ember generate`命令生成工件时，使用`--pod`标志以特性驱动（POD）结构组织文件的选项。
- en: 'In order for the POD structure to work, you need to first configure the POD
    directory in `config/environment.js` as given in the following code:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使POD结构工作，您需要首先在`config/environment.js`中配置POD目录，如下面的代码所示：
- en: '[PRE207]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The preceding snippet specifies that all the artifacts you generate with the
    `--pod` flag will be generated inside the `<app-root>/pod-modules` directory.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段指定了使用`--pod`标志生成的所有工件将生成在`<app-root>/pod-modules`目录内。
- en: Once you configure the POD, you can start generating your artifacts with the
    `--pod` flag.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了POD，您就可以开始使用`--pod`标志生成您的工件。
- en: 'For example, if you want to generate a route inside the POD structure, use
    the following command:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在POD结构内生成一个路由，可以使用以下命令：
- en: '[PRE208]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: This will generate the route file at `/app/pod-modules/user/route.js`.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`/app/pod-modules/user/route.js`生成路由文件。
- en: POD modules group all the artifacts related to a feature in one place, thus
    making it more manageable.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: POD模块将与特性相关的所有工件组合在一个地方，从而使其更易管理。
- en: Understanding the Ember object model
  id: totrans-1510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Ember对象模型
- en: Ember comes with a rich API out-of-the-box, extending vanilla JavaScript classes
    and introducing new structures, providing enhanced capabilities such as two-way
    data binding, property observation, and so on. It provides smarter replacements
    for most of the common JavaScript constructs such as objects and arrays.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: Ember自带丰富的API，扩展了原生JavaScript类，并引入了新的结构，提供了增强的功能，如双向数据绑定、属性观察等。它为大多数常见的JavaScript构造提供了更智能的替代方案，如对象和数组。
- en: '`Ember.Object` is the main base class of all Ember objects. It provides a class
    system with advanced features such as mixins and constructor methods. `Ember.Object`
    provides many special features, such as computed properties, data binding, and
    property-value change observers.'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Object`是所有Ember对象的主要基类。它提供了一个带有高级特性的类系统，如混入和构造方法。`Ember.Object`提供了许多特殊功能，如计算属性、数据绑定和属性值变化观察者。'
- en: Declaring types (classes) and instances
  id: totrans-1513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类型（类）和实例
- en: 'You can inherit all the features of `Ember.Object` in your objects; just extend
    it in a purely object-oriented fashion, as given in the following code:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以纯粹的面向对象的方式继承`Ember.Object`中的所有功能；如下面的代码所示，只需扩展它：
- en: '[PRE209]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The preceding snippet is just a declaration of the `User` type. Now, you need
    to instantiate this class structure in order to use it in your program, as follows:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段只是`User`类型的声明。现在，您需要实例化此类结构，以便在程序中使用它，如下所示：
- en: '[PRE210]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'You can either call a no args constructor like the preceding snippet, or you
    can pass a set of attributes with values as a JS object in order to create an
    instance of a declared class, as follows:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像前面的片段一样调用无参数构造函数，也可以将一组带有值的属性作为JS对象传递，以创建已声明类的实例，如下所示：
- en: '[PRE211]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Accessing and mutating properties
  id: totrans-1520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问和变异属性
- en: 'Once the type is initialized, you can access its properties using a `get` method,
    as follows:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 类型初始化后，您可以使用`get`方法访问其属性，如下所示：
- en: '[PRE212]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Remember to always use the `get` method instead of `object.property`, since
    Ember objects store managed properties in a different hash, which provides a few
    special features, unlike a vanilla JS object.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住始终使用`get`方法而不是`object.property`，因为Ember对象将托管属性存储在不同的哈希中，提供了一些特殊功能，而不像原始JS对象。
- en: 'Make sure you use the `set` method for enabling all the special features of
    Ember objects, such as computed properties and property observation:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`set`方法以启用Ember对象的所有特殊功能，例如计算属性和属性观察：
- en: '[PRE213]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Computed properties
  id: totrans-1526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'A computed property is a virtual property derived from other normal properties,
    or it is a value returned by a function. `Ember.Object` can have computed properties
    too, as shown here:'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是从其他普通属性派生的虚拟属性，或者是由函数返回的值。`Ember.Object`也可以有计算属性，如下所示：
- en: '[PRE214]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Once instantiated, you can access computed properties as well in the same manner
    as normal properties. They update themselves whenever a dependent property changes.
    You can create mutable computable properties too. The following is an example
    of a sensible implementation of such a computed property:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，您也可以以与普通属性相同的方式访问计算属性。它们在依赖属性更改时会自动更新自身。您也可以创建可变的可计算属性。以下是这种计算属性的合理实现示例：
- en: '[PRE215]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Since the computed property is like any other function, you can add any business
    logic to it.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算属性就像任何其他函数一样，您可以向其添加任何业务逻辑。
- en: Property observers
  id: totrans-1532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性观察者
- en: 'You can observe normal or computed properties for any change in value. Register
    the property with `Ember.Observer` for this purpose. See the following example:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察任何值的普通或计算属性的变化。为此目的，使用`Ember.Observer`注册属性。请参阅以下示例：
- en: '[PRE216]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: In the preceding snippet, the `dobChanged` function will fire whenever the `dateOfBirth`
    property gets updated. You can bind multiple properties with a single observer
    method by passing all the properties as arguments into the `Ember.observer` method
    prior to the function definition.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，`dobChanged`函数将在`dateOfBirth`属性更新时触发。您可以通过将所有属性作为参数传递到`Ember.observer`方法中来绑定多个属性到单个观察者方法中，然后再定义函数。
- en: Note
  id: totrans-1536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Computed properties can also be observed. However, the observer method will
    not be triggered until the computed property is accessed, even if the dependent
    properties are updated.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性也可以被观察。但是，直到访问计算属性之前，观察者方法才会被触发，即使依赖属性已经更新。
- en: Working with collections
  id: totrans-1538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合
- en: 'Ember makes array manipulation smarter using a set of core collection classes,
    shown in the following table. Each of these provide many convenient methods that
    abstract complex array manipulation:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: Ember使用一组核心集合类使数组操作更智能，如下表所示。这些类提供了许多方便的方法，抽象了复杂的数组操作：
- en: '| Collection type | Description |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1541
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Ember.Array` | This is an abstract implementation of observer-friendly array-like
    behavior. Concrete implementations are expected to have implemented methods, such
    as `length()` and `objectAt()`. Notable convenient methods are `any()`, `every()`,
    `filter()`, `filterBy()`, `find()`, `findBy()`, `forEach()`, `getEach()`, `map()`,
    `mapBy()`, `objectAt()`, `replace()`, `reverse()`, `sortBy`, `without()`, and
    so on. |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
  zh: '| `Ember.Array` | 这是观察者友好的数组行为的抽象实现。预期具体实现已经实现了`length()`和`objectAt()`等方法。值得注意的方便方法有`any()`、`every()`、`filter()`、`filterBy()`、`find()`、`findBy()`、`forEach()`、`getEach()`、`map()`、`mapBy()`、`objectAt()`、`replace()`、`reverse()`、`sortBy`、`without()`等。|'
- en: '| `Ember.ArrayProxy` | `ArrayProxy` wraps objects that implement `Ember.Array`
    for binding use cases and swapping content while iterating. |'
  id: totrans-1543
  prefs: []
  type: TYPE_TB
  zh: '| `Ember.ArrayProxy` | `ArrayProxy`包装实现`Ember.Array`的对象，用于绑定用例和在迭代时交换内容。|'
- en: '| `Ember.MutableArray` | This is an extension of `Array`, supporting an array
    of ordered sets. |'
  id: totrans-1544
  prefs: []
  type: TYPE_TB
  zh: '| `Ember.MutableArray` | 这是`Array`的扩展，支持有序集合的数组。|'
- en: '| `Ember.Enumerable` | This is a mixin for enumerating arrays. |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
  zh: '| `Ember.Enumerable` | 这是用于枚举数组的mixin。|'
- en: '| `Ember.NativeArray` | This is the most concrete implementation of all of
    the above. You would use this in most cases. |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
  zh: '| `Ember.NativeArray` | 这是上述所有内容中最具体的实现。在大多数情况下，您会使用它。|'
- en: Building UI templates using Handlebars
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Handlebars构建UI模板
- en: 'The primary UI authoring technology in Ember.js is Handlebars. Handlebars templates
    allow HTML fragments to embed dynamic content using Handlebars expressions placed
    inside double curly braces (`{{ }}`), the dynamic scripting blocks. Handlebars
    expressions perform data binding with attributes of routes, models, controllers,
    components, services, utils, and even application instances. Here is a sample
    Handlebars expression:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js中的主要UI编写技术是Handlebars。Handlebars模板允许使用双大括号(`{{ }}`)内部放置的Handlebars表达式嵌入动态内容的HTML片段，动态脚本块。Handlebars表达式使用路由、模型、控制器、组件、服务、工具甚至应用实例的属性执行数据绑定。以下是一个示例Handlebars表达式：
- en: '[PRE217]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: This code snippet expects an object (preferably derived from `Ember.Object`,
    though it binds with normal JS objects too) with the name `loggedInUser`, present
    somewhere in the context in the parent context hierarchy (template, controller,
    route, or application). Then, it establishes a one-way data binding with the `fullName`
    attribute of the `loggedInUser` object; hence, it just displays the value of the
    bound attribute.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码期望一个对象（最好是从`Ember.Object`派生的对象，尽管它也可以与普通JS对象绑定）具有名称为`loggedInUser`的属性，该对象在父上下文层次结构（模板、控制器、路由或应用程序）中的某个地方存在。然后，它与`loggedInUser`对象的`fullName`属性建立单向数据绑定；因此，它只显示绑定属性的值。
- en: Handlebars helpers
  id: totrans-1551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Handlebars帮助程序
- en: Handlebars relies on helpers for business logic inside the dynamic scripting
    blocks. Handlebars executes the business logic implemented inside the helpers
    (if any) placed inside the curly braces, or it simply performs data binding with
    bound attributes.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars依赖于帮助程序来处理动态脚本块内的业务逻辑。Handlebars执行帮助程序内部实现的业务逻辑（如果有的话），放置在花括号内，或者它只是与绑定属性进行数据绑定。
- en: 'Ember ships a set of built-in helpers and provides a nice way of developing
    custom helpers too. Built-in helpers can be categorized as follows:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: Ember提供了一组内置的帮助程序，并提供了一种很好的开发自定义帮助程序的方式。内置的帮助程序可以分为以下几类：
- en: Input helpers
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入帮助程序
- en: Control flow helpers
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流帮助程序
- en: Event helpers
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件帮助程序
- en: Development helpers
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发帮助程序
- en: 'Helpers can either be inline or en bloc. Inline helpers are just one-liners,
    similar to empty HTML and XML tags. See the `action` helper, which is an inline
    helper that takes parameters for processing:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助程序可以是内联的，也可以是块级的。内联帮助程序只是单行，类似于空的HTML和XML标记。看看`action`帮助程序，它是一个内联帮助程序，用于处理参数：
- en: '[PRE218]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Inline helpers can be nested, embedding more dynamic values inside them:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 内联帮助程序可以嵌套，将更多动态值嵌入其中：
- en: '[PRE219]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Block helpers have a start and an end construct with the same name, similar
    to HTML tags:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 块帮助程序具有与HTML标记类似的开始和结束结构：
- en: '[PRE220]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Data binding with input helpers
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入帮助程序进行数据绑定
- en: 'Templates can establish two-way data binding using input helpers. Input helpers
    are mostly HTML form elements wrapped inside Ember components or views. Ember
    ships some built-in input helpers, such as `Ember.TextField`, `Ember.TextArea`,
    and `Ember.Checkbox`. Let''s take a look at an example:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以使用输入帮助程序建立双向数据绑定。输入帮助程序主要是包装在Ember组件或视图中的HTML表单元素。Ember提供了一些内置的输入帮助程序，例如`Ember.TextField`，`Ember.TextArea`和`Ember.Checkbox`。让我们来看一个例子：
- en: '[PRE221]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '`{{input}}` is a built-in input helper that wraps HTML input text fields and
    checkboxes based on the value of the `type` attribute, which defaults to `text`.
    It allows two-way binding between the generated `<input type="text"/>` tag and
    the attribute `editingUser.userName`. Whenever either of the values is changed,
    it updates the other participant of the two-way binding. The `{{input}}` helper
    supports many useful attributes, such as `readonly`, `required`, `size`, `height`,
    `name`, `autofocus`, `placeholder`, `tabindex`, and `maxlength`.'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{input}}`是一个内置的输入帮助程序，它根据`type`属性的值（默认为`text`）包装HTML输入文本字段和复选框。它允许生成的`<input
    type="text"/>`标签与属性`editingUser.userName`之间进行双向绑定。每当其中一个值发生变化时，它会更新双向绑定的另一个参与者。`{{input}}`帮助程序支持许多有用的属性，例如`readonly`，`required`，`size`，`height`，`name`，`autofocus`，`placeholder`，`tabindex`和`maxlength`。'
- en: Checkboxes are created using the same `{{input}}` helper, but by setting the
    type attribute to `checkbox`. The `{{textarea}}` helper represents the HTML `<textarea/>`
    component.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框是使用相同的`{{input}}`帮助程序创建的，但是通过将type属性设置为`checkbox`。`{{textarea}}`帮助程序表示HTML`<textarea/>`组件。
- en: You can create your own input helpers as Ember components, which we will learn
    later in this chapter.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的输入帮助程序作为Ember组件，我们将在本章后面学习。
- en: Using control flow helpers in Handlebars
  id: totrans-1570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Handlebars中使用控制流帮助程序
- en: 'Like most scripting languages, Handlebars supports the following control flow
    helpers:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数脚本语言一样，Handlebars支持以下控制流帮助程序：
- en: 'Conditionals:'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件：
- en: '`{{if}}`'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{if}}`'
- en: '`{{#else}}`'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#else}}`'
- en: '`{{#else if}}`'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#else if}}`'
- en: '`{{#unless}}`'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#unless}}`'
- en: 'Loops:'
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：
- en: '`{{#each}}`'
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#each}}`'
- en: 'Here is an example of the `{{if}}`, `{{else}}`, and `{{else if}}` helpers:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`{{if}}`，`{{else}}`和`{{else if}}`帮助程序的示例：
- en: '[PRE222]'
  id: totrans-1580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The `{{#each}}` helper is used to loop (iterate) through a collection, display
    it, and provide event hooks or actions around each element in the collection.
    A typical `{{#each}}` helper looks like this:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{#each}}`帮助程序用于循环（迭代）遍历集合，显示它，并在集合中的每个元素周围提供事件挂钩或操作。典型的`{{#each}}`帮助程序如下所示：'
- en: '[PRE223]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Using event helpers
  id: totrans-1583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件帮助程序
- en: Event helpers respond to user-invoked actions. The two primary event helpers
    in Ember are the `{{action}}` and `{{link-to}}` helpers.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 事件帮助程序响应用户触发的操作。Ember中的两个主要事件帮助程序是`{{action}}`和`{{link-to}}`帮助程序。
- en: 'The `{{link-to}}` helper helps in navigating to another route. See the following
    example:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{link-to}}`帮助程序有助于导航到另一个路由。请参阅以下示例：'
- en: '[PRE224]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The `{{action}}` helper is generally added to a normal HTML element in order
    to attach an event and event handler to it:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{action}}`帮助程序通常添加到普通HTML元素中，以便将事件和事件处理程序附加到它：'
- en: '[PRE225]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Handling routes
  id: totrans-1589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路由
- en: An Ember application transitions its state between a set of routes; each can
    render a template that displays the current state and a controller to support
    its state-based data. Routes are registered inside the router configuration, typically
    inside `router.js`, in the case of an Ember CLI project structure. Routes are
    defined inside their own JS files.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: Ember应用程序在一组路由之间转换其状态；每个路由可以呈现一个显示当前状态的模板，并提供支持其基于状态的数据的控制器。路由在路由器配置内注册，通常在Ember
    CLI项目结构中的`router.js`内。路由在其自己的JS文件中定义。
- en: 'Routes can be generated and autoconfigured from the command line as follows:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以通过命令行生成和自动配置，如下所示：
- en: '[PRE226]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'This command generates `route.js` and `template.hbs` under `app/<pod-directory>/user/`.
    Upon generation, both artifacts will have a basic structure and you need to flesh
    them out according to your specific requirements. A typical route will have a
    model hook, which prepares its data. See the structure of a typical but minimal
    route given in the following code:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在`app/<pod-directory>/user/`目录下生成`route.js`和`template.hbs`。生成后，这两个文件都将具有基本结构，您需要根据特定要求完善它们。典型的路由将具有一个模型钩子，用于准备其数据。请参阅以下代码中给出的典型但最小的路由结构：
- en: '[PRE227]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: In the preceding example, the `model` hook fetches data from `DS.Store`, the
    Ember Data repository. The route renders the `template.hbs` file in the same directory
    in the case of an Ember CLI project, unless another template is specified inside
    the `renderTemplate` method. The model of a route is available to the controller
    and template (via a controller) for manipulation and rendering.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`model`钩子从`DS.Store`（Ember Data存储库）获取数据。路由在Ember CLI项目的情况下呈现同一目录中的`template.hbs`文件，除非在`renderTemplate`方法中指定了另一个模板。路由的模型可供控制器和模板（通过控制器）进行操作和呈现。
- en: Handling UI behavior using components
  id: totrans-1596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件处理UI行为
- en: Components are the building blocks of dynamic UI fragments or elements in Ember.
    They render a template, optionally backed by a class extending `Ember.Component`.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Ember中动态UI片段或元素的构建块。它们呈现一个模板，可以选择由扩展`Ember.Component`的类支持。
- en: The easiest way to create a component is to create a template file with a dash-separated
    name in the `app/components/` directory. Then you can embed it in inside other
    templates by just calling `{{<component-name>}}` and passing the required parameters.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组件的最简单方法是在`app/components/`目录中创建一个以破折号分隔的名称的模板文件。然后，您可以通过调用`{{<component-name>}}`并传递所需的参数将其嵌入到其他模板中。
- en: Components are independent and completely isolated from the client context;
    all required data must be passed as parameters. However, if you use `{{yield}}`
    inside the template, it essentially becomes a block (or container) component,
    where you can add any content; this content can access any controller attribute
    and model.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是独立的，与客户端上下文完全隔离；所有必需的数据必须作为参数传递。但是，如果在模板中使用`{{yield}}`，它实质上变成了一个块（或容器）组件，您可以添加任何内容；此内容可以访问任何控制器属性和模型。
- en: 'A component can be generated by the following command:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令生成组件：
- en: '[PRE228]'
  id: totrans-1601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: This command generates two files, `component.js` and `template.hbs`, under the
    `app/<pod-dir>/components/<component-name>/` directory. If you do not use the
    `--pod` flag, it generates the `<component-name>.js` and `<component-name>.hbs`
    files under the directory `app/components/`.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在`app/<pod-dir>/components/<component-name>/`目录下生成两个文件，`component.js`和`template.hbs`。如果不使用`--pod`标志，它将在`app/components/`目录下生成`<component-name>.js`和`<component-name>.hbs`文件。
- en: Components insert the content into the DOM structure, where it is invoked, and
    control the behavior of the inserted content. By default, a component renders
    a `<div/>` element with the content generated by its template inside the `<div/>`
    element. You can specify a different HTML element instead of the `<div/>` element
    by setting the `tagName` attribute inside the `component.js` file. Similarly,
    you can set CSS class names dynamically using another property, `assNameBindings`.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将内容插入到DOM结构中，调用它，并控制插入内容的行为。默认情况下，组件呈现一个带有其模板生成的内容的`<div/>`元素。您可以通过在`component.js`文件中设置`tagName`属性来指定`<div/>`元素的不同HTML元素。同样，您可以使用另一个属性`assNameBindings`动态设置CSS类名。
- en: Components provide some very useful life cycle hooks for manipulating different
    phases of the component. Some life cycle methods that can be overridden in the
    component class are `didInsertElement()`, `willInsertElement()`, and `willDestroyElement()`.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 组件为操纵组件的不同阶段提供了一些非常有用的生命周期钩子。可以在组件类中重写的一些生命周期方法是`didInsertElement()`、`willInsertElement()`和`willDestroyElement()`。
- en: Components support standard HTML element events, depending upon which `tagName`
    is being used. They support all the standard touch events such as `touchStart`
    and `touchMove`, keyboard events such as `keyDown`, `keyUp`, and `keyPressed`,
    mouse events such as `mouseDown`, `mouseOver`, `click`, and `doubleClick`, form
    events such as submit and change, and HTML5 drag and drop events such as `dragStart`
    and `dragEnd`. You just need to declare the event as a function inside the component
    class; the component will fire the event and the associated function will get
    invoked as the user interacts with it.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 组件支持标准HTML元素事件，具体取决于使用的`tagName`。它们支持所有标准触摸事件，如`touchStart`和`touchMove`，键盘事件，如`keyDown`、`keyUp`和`keyPressed`，鼠标事件，如`mouseDown`、`mouseOver`、`click`和`doubleClick`，表单事件，如提交和更改，以及HTML5拖放事件，如`dragStart`和`dragEnd`。您只需在组件类内声明事件作为函数；组件将触发事件，并且相关函数将在用户与其交互时被调用。
- en: Besides events, components can respond to action handlers, which are named functions
    defined inside the `actions` hash of the component class. These actions can be
    triggered anywhere from the component's template. Action handlers can accept parameters
    from the client code or templates.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件之外，组件还可以响应动作处理程序，这些处理程序是在组件类的`actions`哈希内定义的命名函数。这些动作可以在组件的模板中的任何位置触发。动作处理程序可以接受来自客户端代码或模板的参数。
- en: Building a ToggleButton component step by step
  id: totrans-1607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步构建ToggleButton组件
- en: Let's learn how to build an Ember component step by step using Ember CLI. We'll
    build a toggle button that turns off and on when clicked on. The component just
    changes its label and style based on its status attribute, `isActive`. We use
    Bootstrap styles for this example.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步学习如何使用Ember CLI构建Ember组件。我们将构建一个切换按钮，当单击时切换开关。该组件仅根据其状态属性`isActive`更改其标签和样式。我们在此示例中使用Bootstrap样式。
- en: 'First, let''s generate the component class and template file (`.hbs`) using
    Ember CLI. Issue this command from the command line at the root of your project:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Ember CLI逐步生成组件类和模板文件（`.hbs`）。在项目的根目录中，从命令行发出此命令：
- en: '[PRE229]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'See the `component.js` and `template.hbs` files generated at `app/<pod-dir>/components/toggle-button/`.
    Open and see the `component.js` file, it looks as given in the following code:'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`app/<pod-dir>/components/toggle-button/`中生成的`component.js`和`template.hbs`文件。打开并查看`component.js`文件，它看起来如下所示：
- en: '[PRE230]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The generated `template.js` file just has `{{yield}}` inside it. Now you need
    to add necessary attributes and business logic into these two artifacts in order
    to make it a proper toggle button component. Here is a modified `component.js`
    file, with the proper behavior:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`template.js`文件中只有`{{yield}}`。现在，您需要在这两个构件中添加必要的属性和业务逻辑，以使其成为一个合适的切换按钮组件。以下是修改后的`component.js`文件，具有适当的行为：
- en: '[PRE231]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: In the preceding code, notice that you specified the `tagName` attribute as
    `button`; otherwise, the generated HTML would be `<div/>`. Also, see how CSS class
    names are bound dynamically based on the `isActive` attribute. The `currentLabel`
    attribute is a computed attribute that depends on a few other attributes. In effect,
    the component responds to a click event and actually toggles the `isActive` variable.
    Everything else will work based on this event.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意您将`tagName`属性指定为`button`；否则，生成的HTML将是`<div/>`。另外，看看如何基于`isActive`属性动态绑定CSS类名。`currentLabel`属性是一个计算属性，它取决于其他几个属性。实际上，组件响应点击事件，并切换`isActive`变量。其他所有操作都将基于此事件进行。
- en: 'Now, let''s take a look at the modified `template.js` file to see how it utilizes
    the attributes and events handled by the `component.js` file:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下修改后的`template.js`文件，看看它如何利用`component.js`文件处理的属性和事件：
- en: '[PRE232]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Surprise! This is all the content in the template. It''s so simple to build.
    All the rest of the heavy lifting is done by the `component.js` file itself. Now
    the most interesting part is how the component is invoked from the client. Let''s
    take a look:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 惊喜！这就是模板中的所有内容。构建起来是如此简单。其余的繁重工作都是由`component.js`文件自己完成的。现在最有趣的部分是组件如何从客户端调用。让我们来看一下：
- en: '[PRE233]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This is how you add the toggle button component in your client code, it is mostly
    route's template. You can start clicking on the button repeatedly and see that
    it switches on and off.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您在客户端代码中添加切换按钮组件的方式，它主要是路由的模板。您可以开始反复点击按钮，看到它的开启和关闭。
- en: 'This component can be customized by overriding its default properties. Let''s
    try changing its labels when it is on and off from the client side:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件可以通过覆盖其默认属性进行定制。让我们尝试从客户端更改其开启和关闭时的标签：
- en: '[PRE234]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: You can see the new active and inactive labels on the screen as you click on
    the button, toggling it. The toggle button is the simplest example of an Ember
    component, intended to give you just a taste of Ember components. A typical Ember
    application will have many complex components. Converting a reusable UI module
    or portion into a component is the best way to make your application more elegant
    and maintainable.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击按钮时，您可以在屏幕上看到新的活动和非活动标签，切换它。切换按钮是Ember组件的最简单的示例，旨在让您对Ember组件有所了解。典型的Ember应用程序将拥有许多复杂的组件。将可重用的UI模块或部分转换为组件是使您的应用程序更加优雅和可维护的最佳方式。
- en: Persisting data with Ember Data
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ember Data持久化数据
- en: Ember Data is Ember's data-access mechanism. It provides a simple API to deal
    with data, abstracting the complexities and protocols of data access and diverse
    data sources. With Ember Data, clients can deal with data models just as any other
    Ember object.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data是Ember的数据访问机制。它提供了一个简单的API来处理数据，抽象了数据访问和各种数据源的复杂性和协议。使用Ember Data，客户端可以像处理任何其他Ember对象一样处理数据模型。
- en: 'Ember Data defines a set of fundamental components that handle various roles
    and responsibilities in data access. These components are grouped under the namespace
    `DS`. The following table describes the most important Ember Data components defined
    under `DS`:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data定义了一组处理数据访问中各种角色和责任的基本组件。这些组件分组在命名空间`DS`下。以下表格描述了在`DS`下定义的最重要的Ember
    Data组件：
- en: '| Component | Purpose |'
  id: totrans-1627
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 目的 |'
- en: '| --- | --- |'
  id: totrans-1628
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DS.Model` | This is the fundamental unit of data and represents a record
    in a data collection. You need to define your data models by extending this class.
    It provides methods to save, delete, reload, and iterate properties, relationships,
    related types, and so on. It provides information about states, attributes, fields,
    relationships, errors, and so on. Also, it provides life cycle hook events. |'
  id: totrans-1629
  prefs: []
  type: TYPE_TB
  zh: '| `DS.Model` | 这是数据的基本单元，代表数据集合中的记录。您需要通过扩展此类来定义数据模型。它提供了保存、删除、重新加载和迭代属性、关系、相关类型等的方法。它提供了关于状态、属性、字段、关系、错误等的信息。此外，它提供了生命周期钩子事件。
    |'
- en: '| `DS.Store` | This is the local repository of all the data created, fetched,
    and modified by Ember Data. `Store` fetches data with the help of adapters and
    converts them into appropriate `DS.Model` instances. Using serializers, `Store`
    serializes model instances into forms suitable for the servers. It provides methods
    for querying and creating new records. |'
  id: totrans-1630
  prefs: []
  type: TYPE_TB
  zh: '| `DS.Store` | 这是Ember Data创建、获取和修改的所有数据的本地存储库。`Store`通过适配器获取数据，并将其转换为适当的`DS.Model`实例。使用序列化器，`Store`将模型实例序列化为适合服务器的形式。它提供了查询和创建新记录的方法。
    |'
- en: '| `DS.Adapter` | This is an abstract implementation that receives various persistence
    commands from Store and translates them into forms that the actual data source
    (such as a Server API or a browser local storage) understands. Ember ships two
    concrete implementations: `DS.RESTAdapter` and `DS.JSONAPIAdapter`. Override the
    adapters if you want to change the default behaviors or attributes, such as remote
    URLs and headers. |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
  zh: '| `DS.Adapter` | 这是一个抽象实现，接收来自`Store`的各种持久性命令，并将其转换为实际数据源（例如服务器API或浏览器本地存储）理解的形式。Ember提供了两个具体的实现：`DS.RESTAdapter`和`DS.JSONAPIAdapter`。如果要更改默认行为或属性（例如远程URL和标头），请覆盖适配器。
    |'
- en: '| `DS.Serializer` | This normalizes `DS.Model` instances into payloads for
    the API (or whichever data source it is) and serializes them back into the model.
    Two default serializers are `RestSerializer` and `JSONAPISerializer`. Override
    the serializers to customize the data formats for the server. |'
  id: totrans-1632
  prefs: []
  type: TYPE_TB
  zh: '| `DS.Serializer` | 这将`DS.Model`实例标准化为API的有效负载（或任何其他数据源），并将它们序列化回模型。两个默认的序列化器是`RestSerializer`和`JSONAPISerializer`。覆盖序列化器以自定义服务器的数据格式。
    |'
- en: Ember Data architecture
  id: totrans-1633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ember Data架构
- en: 'Ember Data components communicate with each other asynchronously for data access
    operations, based on a **promise**. The `query` and `find` methods of both the
    **Store** and **Adapter** are asynchronous, and essentially return a **promise**
    object immediately. Once resolved, the model instance is created and returned
    to the client. The following diagram demonstrates how Ember Data components coordinate
    a `find` method operation asynchronously:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data组件基于**promise**异步地相互通信进行数据访问操作。**Store**和**Adapter**的`query`和`find`方法是异步的，并且立即返回一个**promise**对象。一旦解析，模型实例就会被创建并返回给客户端。以下图表演示了Ember
    Data组件如何异步协调`find`方法操作：
- en: '![Ember Data architecture](img/image00793.jpeg)'
  id: totrans-1635
  prefs: []
  type: TYPE_IMG
  zh: '![Ember Data architecture](img/image00793.jpeg)'
- en: The clients of Ember Data components, which are typically routes, components,
    controllers, services, and so on, do not directly deal with adapters and serializers.
    They talk to the **Store** and model for normal data-access operations. Since
    the `Route.model` method (hook) supports **promise** objects, the transition will
    pause until the **promise** is resolved. We do not deal with resolving promises
    and hence with asynchronicity; rather, Ember handles it smartly.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data组件的客户端（通常是路由、组件、控制器、服务等）不直接处理适配器和序列化器。它们与**Store**和模型进行正常的数据访问操作。由于`Route.model`方法（钩子）支持**promise**对象，转换将暂停，直到**promise**解析。我们不处理解析promise，因此也不处理异步性；相反，Ember会智能地处理它。
- en: Defining models
  id: totrans-1637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型
- en: Models represent the domain data of an Ember application. They need to be defined
    in proper structures and registered with the store before they can be used for
    data access. An Ember CLI project expects models under the `app/models/` directory,
    or `app/<pod-dir>/models/` in case you are using the POD directory structure.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表了Ember应用程序的领域数据。它们需要以正确的结构定义并在存储中注册，然后才能用于数据访问。Ember CLI项目期望模型位于`app/models/`目录下，或者在使用POD目录结构的情况下为`app/<pod-dir>/models/`。
- en: 'Let''s see a sample model definition. The following is the definition of a
    user model:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例模型定义。以下是用户模型的定义：
- en: '[PRE235]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Model attributes can be of the string, number, Boolean, and date types by default.
    For custom types, you need to subclass `DS.Transform`. Attributes can have default
    values too. You can specify default values as shown in the following line:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 模型属性默认可以是字符串、数字、布尔和日期类型。对于自定义类型，您需要子类化`DS.Transform`。属性也可以有默认值。您可以像下面这行所示指定默认值：
- en: '[PRE236]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Defining model relationships
  id: totrans-1643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型关系
- en: 'Models can engage in one-to-one, one-to-many, and many-to-many relationships
    among themselves:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以在它们之间进行一对一、一对多和多对多的关系：
- en: A one-to-one relationship is defined using `DS.belongsTo` in both model definitions
  id: totrans-1645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一对一关系在两个模型定义中使用`DS.belongsTo`来定义
- en: A one-to-many relationship is defined using `DS.belongsTo` in one model and
    `DS.hasMany` in the other model
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一对多关系在一个模型中使用`DS.belongsTo`，在另一个模型中使用`DS.hasMany`来定义
- en: A many-to-many relationship is declared when both models have `DS.hasMany` defined
    for each other
  id: totrans-1647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个模型都为对方定义了`DS.hasMany`时，就声明了多对多关系
- en: Building a Taskify application
  id: totrans-1648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Taskify应用程序
- en: Hey, it's time to build our Taskify application end-to-end. First, let's go
    back to building a proper API layer using Spring and then revisit Ember to build
    the frontend SPA. We will use Spring Data to connect to and access data from the
    API server.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，是时候全面构建我们的Taskify应用程序了。首先，让我们回到使用Spring构建一个合适的API层，然后再回顾Ember构建前端SPA。我们将使用Spring
    Data连接到API服务器并访问数据。
- en: 'For simplicity, we will not apply any security to the server; we will just
    focus on performing CRUD operations on two models: `User` and `Task`. Both `User`
    and `Task` are related to each other: `Task belongsTo User`. We will build models
    on both (server and client) sides. Let''s see how both technologies work together
    without having direct dependencies on each other.'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们不会对服务器应用任何安全性措施；我们只会专注于对两个模型`User`和`Task`执行CRUD操作。`User`和`Task`彼此相关：`Task属于User`。我们将在服务器端和客户端构建模型。让我们看看这两种技术如何在没有直接依赖的情况下协同工作。
- en: Building the API server app
  id: totrans-1651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API服务器应用程序
- en: We explored the building of web apps using Spring MVC in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Building the Web Layer with Spring Web MVC"), *Building the Web Layer
    with Spring Web MVC*. In [Chapter 3](part0044.xhtml#aid-19UOO1 "Chapter 3. Accessing
    Data with Spring"), *Accessing Data with Spring*, we also learned how to persist
    data using Spring Data JPA. We are going to apply both these techniques again
    for building an API application for Taskify.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](part0028.xhtml#aid-QMFO1 "Chapter 2. Building the Web Layer with Spring
    Web MVC")中探讨了使用Spring MVC构建Web应用程序，*使用Spring Web MVC构建Web层*。在[第3章](part0044.xhtml#aid-19UOO1
    "Chapter 3. Accessing Data with Spring")中，*使用Spring访问数据*，我们还学习了如何使用Spring Data
    JPA持久化数据。我们将再次应用这两种技术来构建Taskify的API应用程序。
- en: Setting up and configuring the project
  id: totrans-1653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和配置项目
- en: 'Since we have already learned the basics of creating Spring MVC applications
    with Spring Data JPA, at this point, we will go into detail only about the specifics
    of the API endpoints. Refer to [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Building
    the Web Layer with Spring Web MVC"), *Building the Web Layer with Spring Web MVC*
    for Spring MVC configuration and [Chapter 3](part0044.xhtml#aid-19UOO1 "Chapter 3. Accessing
    Data with Spring"), *Accessing Data with Spring* for details about Spring Data
    JPA. Set up and configure the project with the following steps:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了使用Spring Data JPA创建Spring MVC应用程序的基础知识，因此在这一点上，我们只会详细介绍API端点的具体内容。有关Spring
    MVC配置，请参阅[第2章](part0028.xhtml#aid-QMFO1 "第2章。使用Spring Web MVC构建Web层")，“使用Spring
    Web MVC构建Web层”，有关Spring Data JPA的详细信息，请参阅[第3章](part0044.xhtml#aid-19UOO1 "第3章。使用Spring访问数据")，“使用Spring访问数据”。使用以下步骤设置和配置项目：
- en: Create a Spring MVC application with a dependency on Spring Data JPA and the
    database of your choice.
  id: totrans-1655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Spring MVC应用程序，依赖于Spring Data JPA和您选择的数据库。
- en: 'Enable JPA repositories, specifying the base packages. For JavaConfig, annotate
    like this:'
  id: totrans-1656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用JPA存储库，指定基本包。对于JavaConfig，注释如下：
- en: '[PRE237]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Configure Spring Data JPA artifacts such as `DataSource`, `JdbcTemplate`, `TransactionManager`,
    and `EntityManager` with the flavor of your choice.
  id: totrans-1658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的风格配置Spring Data JPA工件，如`DataSource`、`JdbcTemplate`、`TransactionManager`和`EntityManager`。
- en: Defining the model definitions – User and Task
  id: totrans-1659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型定义 - User和Task
- en: 'The application has the following two models as domain objects:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序有以下两个模型作为域对象：
- en: '![Defining the model definitions – User and Task](img/image00794.jpeg)'
  id: totrans-1661
  prefs: []
  type: TYPE_IMG
  zh: '![定义模型定义 - User和Task](img/image00794.jpeg)'
- en: 'Now we need to realize these as Java classes, annotated as JPA entities, so
    that we can persist them to a database, as follows:'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些作为Java类实现，并将其注释为JPA实体，以便我们可以将它们持久化到数据库中，如下所示：
- en: '`User.java`'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.java`'
- en: '[PRE238]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '`Task.java`'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.java`'
- en: '[PRE239]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Once the JPA entities are ready, create the DAOs for both `User` and `Task`—`UserDAO`
    and `TaskDAO`—annotated with `@Repository`. As the best approach and for proper
    application layering, create the corresponding `@Service` beans too. Since we
    already covered the JPA `@Repository` and `@Service` classes in the previous chapters,
    the code for these beans is not listed here. You can find the exact code in the
    code bundle provided with this book.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JPA实体准备就绪，为`User`和`Task`创建DAO——`UserDAO`和`TaskDAO`——并用`@Repository`注释。作为最佳方法并且为了正确的应用层分层，也创建相应的`@Service`
    bean。由于我们已经在前几章中介绍了JPA `@Repository`和`@Service`类，这些bean的代码在此处不列出。您可以在本书提供的代码包中找到确切的代码。
- en: Building API endpoints for the Taskify app
  id: totrans-1668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Taskify应用程序构建API端点
- en: The purpose of the API server is to expose API endpoints for the consumption
    of clients, including the Taskify Ember frontend app. Let's build these web services
    in the REST model, with JSON data format support.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器的目的是公开API端点，以供客户端使用，包括Taskify Ember前端应用程序。让我们按照REST模型构建这些Web服务，并支持JSON数据格式。
- en: 'In this section, we will list two classes annotated with `@RestController`:
    `UserController` and `TaskController`. The handler methods support asynchronous,
    non-blocking IO so that they are more scalable and faster. Handler methods are
    designed in the REST model. The HTTP methods `GET`, `POST`, `PUT`, and `DELETE`
    are mapped against the **Create**, **Read**, **Update**, and **Delete** (CRUD)
    operations.'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出两个使用`@RestController`注释的类：`UserController`和`TaskController`。处理程序方法支持异步、非阻塞IO，因此它们更具可伸缩性和更快速。处理程序方法设计为REST模型。HTTP方法`GET`、`POST`、`PUT`和`DELETE`与**创建**、**读取**、**更新**和**删除**（CRUD）操作相对应。
- en: UserController.java
  id: totrans-1671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UserController.java
- en: '`UserController` exposes endpoints for CRUD operations on the `User` entity.
    You can see the endpoints of `UserController` accepting and producing JSON data
    appropriately in its code, which is as follows:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserController`公开了对`User`实体的CRUD操作的端点。您可以在其代码中看到`UserController`接受和生成JSON数据的端点，如下所示：'
- en: '[PRE240]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: TaskController.java
  id: totrans-1674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TaskController.java
- en: '`TaskController` maps request endpoints for CRUD operations around the `Task`
    entity. Its code is as follows:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskController`映射了围绕`Task`实体的CRUD操作的请求端点。其代码如下：'
- en: '[PRE241]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: We have built all the necessary artifacts for the API server. You can package
    the application and deploy it. You should be able to access the `UserController`
    handlers at `http://<app-context-root>/api/v1/user` and the `TaskController` handlers
    at `http://<app-context-root>/api/v1/task/`. Now let's go build the frontend.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为API服务器构建了所有必要的工件。您可以打包应用程序并部署它。您应该能够在`http://<app-context-root>/api/v1/user`访问`UserController`处理程序，并在`http://<app-context-root>/api/v1/task/`访问`TaskController`处理程序。现在让我们构建前端。
- en: Building the Taskify Ember app
  id: totrans-1678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Taskify Ember应用程序
- en: Let's get back to Ember development to build our SPA. Follow these steps. We
    will occasionally refer to previous sections of this chapter, and detail the specifics
    here.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Ember开发，构建我们的SPA。按照以下步骤进行。我们将偶尔参考本章的前几节，并在这里详细说明具体内容。
- en: Setting up Taskify as an Ember CLI project
  id: totrans-1680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Taskify设置为Ember CLI项目
- en: 'Let''s generate the project and set up all the artifacts. Follow these steps:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成项目并设置所有工件。按照以下步骤进行：
- en: 'Create a new Ember project using Ember CLI from the command line:'
  id: totrans-1682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ember CLI从命令行创建一个新的Ember项目：
- en: '[PRE242]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Install `broccoli-merge-trees` and `broccoli-static-compiler` for a richer
    Broccoli configuration. Issue the following commands from the command line:'
  id: totrans-1684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`broccoli-merge-trees`和`broccoli-static-compiler`以获得更丰富的Broccoli配置。从命令行发出以下命令：
- en: '[PRE243]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Install Bootstrap with Bower from the command line:'
  id: totrans-1686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行使用Bower安装Bootstrap：
- en: '[PRE244]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Configure Broccoli to include bootstrap.js, CSS, and fonts in the `ember-cli-build.js`
    file:'
  id: totrans-1688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ember-cli-build.js`文件中配置Broccoli以包括bootstrap.js、CSS和字体：
- en: '[PRE245]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'In the application, we will be using a third-party Ember add-on called `ember-bootstrap-datetimepicker`.
    Let''s install it into the project:'
  id: totrans-1690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中，我们将使用一个名为`ember-bootstrap-datetimepicker`的第三方Ember插件。让我们将其安装到项目中：
- en: '[PRE246]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Build `npm` and `bower` dependencies:'
  id: totrans-1692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`npm`和`bower`依赖项：
- en: '[PRE247]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Start the Ember server using the `ember serve` command, and make sure your application
    is accessible at `http://localhost:4200/`.
  id: totrans-1694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ember serve`命令启动Ember服务器，并确保您的应用程序可以在`http://localhost:4200/`访问。
- en: 'Set the POD directory inside `/config/environment.js`:'
  id: totrans-1695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/config/environment.js`中设置POD目录：
- en: '[PRE248]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Now we can start generating the required Ember artifacts in this POD directory.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始在这个POD目录中生成所需的Ember构件。
- en: Setting up Ember Data
  id: totrans-1698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Ember Data
- en: 'We need two models: `User` and `Task`. Let''s generate them first with the
    following code. For models, we do not use POD:'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个模型：`User`和`Task`。让我们首先使用以下代码生成它们。对于模型，我们不使用POD：
- en: '[PRE249]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Find the generated models under the `/app/models/` folder. Open them and set
    the attributes and relationships:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/models/`文件夹下找到生成的模型。打开它们并设置属性和关系：
- en: '`User.js`'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.js`'
- en: '[PRE250]'
  id: totrans-1703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '`Task.js`'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.js`'
- en: '[PRE251]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Let''s generate an (Ember Data) application adapter that has some global properties
    common to all adapters:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个（Ember Data）应用程序适配器，它具有所有适配器共有的一些全局属性：
- en: '[PRE252]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Open the generated `/app/adapters/application.js` file, and add two attributes,
    `host` and `namespace`, with the right values as shown in the following code.
    After this, adapters for all models will take these attributes unless overridden
    individually:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 打开生成的`/app/adapters/application.js`文件，并添加两个属性`host`和`namespace`，并使用以下代码中显示的正确值。之后，除非单独覆盖，否则所有模型的适配器将使用这些属性：
- en: '[PRE253]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'We need to override the default serializers, as Ember Data expects the ID of
    the dependent objects for sideloading, where the API server sends out nested objects
    embedded within. So, generate both serializers from the command line and then
    update the content appropriately:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖默认的序列化程序，因为Ember Data期望依赖对象的ID进行并行加载，其中API服务器发送嵌入的嵌套对象。因此，从命令行生成两个序列化程序，然后适当更新内容：
- en: '[PRE254]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Update the generated `/app/serializers/user.js` file with the following content:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更新生成的`/app/serializers/user.js`文件：
- en: '[PRE255]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'Update the generated `/app/serializers/task.js` file with the following content:'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更新生成的`/app/serializers/task.js`文件：
- en: '[PRE256]'
  id: totrans-1715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Configuring application routes
  id: totrans-1716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序路由
- en: 'Routes represent application states. They need to be registered with the router
    of the application in order to enable navigation. Our application has three primary
    routes: `index`, `user`, and `task`. Let''s generate them in the `pod` directory.
    Do it from the command line:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 路由代表应用程序的状态。它们需要在应用程序的路由器中注册，以便启用导航。我们的应用程序有三个主要路由：`index`，`user`和`task`。让我们在`pod`目录中生成它们。从命令行执行：
- en: '[PRE257]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Take a look at `router.js` now; you will see these new routes registered there.
    Also, the `route.js` and `template.hbs` files generated for each of these under
    the POD directories will be present.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下`router.js`；您将在那里看到这些新路由已注册。此外，在POD目录下为每个生成的`route.js`和`template.hbs`文件将存在。
- en: Building the home screen
  id: totrans-1720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建主屏幕
- en: 'Now, let''s set up the index template to show counts for the total number of
    tasks and the number of open tasks in the system. Open the `/app/modules/index/template.js`
    file and update it with this content:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置索引模板，以显示系统中任务总数和未完成任务的数量。打开`/app/modules/index/template.js`文件并更新内容：
- en: '[PRE258]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The preceding template binds the model attributes using Handlebars and expects
    the model to be loaded with proper data. Let''s go build the model in the `route.js`
    file:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板使用Handlebars绑定模型属性，并期望模型加载正确的数据。让我们在`route.js`文件中构建模型：
- en: '[PRE259]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'In the preceding code, the model hook first loads data from the server using
    `DS.Store` (Ember Data), constructs the model object with attributes, including
    computed properties, and then returns. The home screen will look like the following
    image (ignore the headers for now):'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，模型钩子首先使用`DS.Store`（Ember Data）从服务器加载数据，构造具有属性的模型对象，包括计算属性，然后返回。主屏幕将看起来像以下图片（暂时忽略标题）：
- en: '![Building the home screen](img/image00795.jpeg)'
  id: totrans-1726
  prefs: []
  type: TYPE_IMG
  zh: '![构建主屏幕](img/image00795.jpeg)'
- en: Building the user screen
  id: totrans-1727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'Now, let''s build the user screen for listing all the users in the system.
    Let''s build the model inside the route''s model hook first. Add this method inside
    `/app/modules/user/route.js`:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为系统中所有用户列出用户的用户界面。首先在路由的模型钩子内构建模型。在`/app/modules/user/route.js`中添加以下方法：
- en: '[PRE260]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: You can see how beautifully Ember and Ember Data work together to simplify such
    an otherwise complex task of fetching, transforming, and deserializing data into
    model instances and finally making it available for the consumption of the template
    and controller, asynchronously, without blocking the screen.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到Ember和Ember Data如何美妙地协同工作，以简化获取、转换和反序列化数据为模型实例，并最终使其异步可供模板和控制器消费，而不会阻塞屏幕。
- en: 'Now let''s display this data on a screen. Update the `/app/modules/user/template.hbs`
    file with the following content:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在屏幕上显示这些数据。使用以下内容更新`/app/modules/user/template.hbs`文件：
- en: '[PRE261]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Now you can see the `user` route at `http://localhost:4200/user`, which looks
    like this:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在`http://localhost:4200/user`看到`user`路由，它看起来像这样：
- en: '![Building the user screen](img/image00796.jpeg)'
  id: totrans-1734
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户界面](img/image00796.jpeg)'
- en: Building a custom helper
  id: totrans-1735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义帮助程序
- en: 'In the `template.hbs` file, you may notice a custom helper:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 在`template.hbs`文件中，您可能会注意到一个自定义帮助程序：
- en: '[PRE262]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Let''s go build it; you should have already got an error since this helper
    hasn''t been defined yet. From the command line, generate it using the following
    command:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建它；你应该已经收到一个错误，因为这个帮助程序还没有被定义。从命令行使用以下命令生成它：
- en: '[PRE263]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Update the generated `/app/helpers/format-date.js` file with the following
    script:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下脚本更新生成的`/app/helpers/format-date.js`文件：
- en: '[PRE264]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Now look at your browser; the user list should render properly.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看您的浏览器；用户列表应该正确渲染。
- en: Adding action handlers
  id: totrans-1743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加操作处理程序
- en: 'Inside the `/app/modules/user/template.hbs` file, there are four action invocations:
    `createNewUser`, `showUser`, `editUser`, and `deleteUser`. All these methods accept
    a `user` variable as a parameter. Let''s add these actions inside `/app/modules/user/route.js`
    first:'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/modules/user/template.hbs`文件内，有四个动作调用：`createNewUser`、`showUser`、`editUser`和`deleteUser`。所有这些方法都接受一个`user`变量作为参数。让我们首先将这些动作添加到`/app/modules/user/route.js`中：
- en: '[PRE265]'
  id: totrans-1745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Building a custom component – modal window
  id: totrans-1746
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义组件-模态窗口
- en: 'In the preceding code listing, both the `createNewUser` and `editUser` methods
    use `userViewModal` using jQuery. This is a Bootstrap modal window built as a
    custom Ember component. In fact, there are four components working together in
    a nested fashion: `{{modal-window}}`, `{{modal-header}}`, `{modal-body}}`, and
    `{{modal-footer}}`.'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码清单中，`createNewUser`和`editUser`方法都使用jQuery使用`userViewModal`。这是一个作为自定义Ember组件构建的Bootstrap模态窗口。实际上，有四个组件以嵌套方式一起工作：`{{modal-window}}`、`{{modal-header}}`、`{modal-body}}`和`{{modal-footer}}`。
- en: 'Let''s generate the artifacts from a commandline first:'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们从命令行生成这些工件：
- en: '[PRE266]'
  id: totrans-1749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The `component.js` and `template.hbs` files should be generated under the `/app/modules/components/<component-name>/`
    directory. Now let''s update the `.js` and `.hbs` files to make it a true modal
    window:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '`component.js`和`template.hbs`文件应该生成在`/app/modules/components/<component-name>/`目录下。现在让我们更新`.js`和`.hbs`文件，使其成为一个真正的模态窗口：'
- en: '`modal-window/template.hbs`'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-window/template.hbs`'
- en: '[PRE267]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '`modal-window/component.js`'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-window/component.js`'
- en: '[PRE268]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '`modal-header/template.hbs`'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-header/template.hbs`'
- en: '[PRE269]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '`modal-header/component.js`'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-header/component.js`'
- en: '[PRE270]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '`modal-body/template.hbs`'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-body/template.hbs`'
- en: '[PRE271]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '`modal-body/component.js`'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-body/component.js`'
- en: '[PRE272]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '`modal-footer/template.hbs`'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-footer/template.hbs`'
- en: '[PRE273]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '`modal-footer/component.js`'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: '`modal-footer/component.js`'
- en: '[PRE274]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Building userEditModal using {{modal-window}}
  id: totrans-1767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用{{modal-window}}构建userEditModal
- en: 'The four modal related components have been built; it''s time to add `userEditModal`
    into the `user/template.js` file. Add the following code or `userEditModal` into
    the `user/template.js` file:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个与模态相关的组件已经构建完成；现在是将`userEditModal`添加到`user/template.js`文件的时候了。将以下代码或`userEditModal`添加到`user/template.js`文件中：
- en: '[PRE275]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'The preceding code listing integrates the user edit form with `{{modal-body}}`,
    with the form title inside `{{modal-header}}`, action buttons inside `{{modal-footer}}`,
    and all of this inside `{{modal-window}}` with the ID `userEditModal`. Just click
    the **Edit** button of a user row; you will see this nice modal window pop up
    in front of you:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码清单将用户编辑表单与`{{modal-body}}`整合在一起，表单标题在`{{modal-header}}`内，动作按钮在`{{modal-footer}}`内，所有这些都在ID为`userEditModal`的`{{modal-window}}`内。只需点击用户行的**编辑**按钮；您将看到这个漂亮的模态窗口在您面前弹出：
- en: '![Building userEditModal using {{modal-window}}](img/image00797.jpeg)'
  id: totrans-1771
  prefs: []
  type: TYPE_IMG
  zh: '![使用{{modal-window}}构建userEditModal](img/image00797.jpeg)'
- en: 'The **Save** button of `userEditModal` invokes the `saveUser` action method,
    the **Cancel** button invokes the `closeEditModal` action, and the **Delete**
    button invokes `deleteUser`. Let''s add them inside the `actions` hash of `user/route.js`,
    next to `deleteUser`:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: '`userEditModal`的**保存**按钮调用`saveUser`动作方法，**取消**按钮调用`closeEditModal`动作，**删除**按钮调用`deleteUser`。让我们将它们添加到`user/route.js`的`actions`哈希中，紧挨着`deleteUser`：'
- en: '[PRE276]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Similarly, `user/template.js` has `userViewModal`, which just displays the user
    data in read-only format. Now, you can easily derive it from `userEditModal`;
    hence, we're not listing it here.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`user/template.js`有`userViewModal`，它只以只读格式显示用户数据。现在，你可以很容易地从`userEditModal`中派生它；因此，我们在这里不列出它。
- en: Building the task screen
  id: totrans-1775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建任务屏幕
- en: The task screen follows the same pattern as the user screen. This section describes
    only the portions logically different from the user screen and assumes that you
    will start developing the task screen from the user screen and incorporate the
    changes described here. Also, you can see the complete code from the project files
    attached to this chapter of the book.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 任务屏幕遵循与用户屏幕相同的模式。本节仅描述与用户屏幕逻辑上不同的部分，并假定您将从用户屏幕开始开发任务屏幕，并整合此处描述的更改。此外，您可以从本书的附带项目文件中查看完整的代码。
- en: 'The task screen has some extra state-specific data besides the model data (the
    list of tasks). For maintaining that data while the task screen is active, we
    will create a controller:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 任务屏幕除了模型数据（任务列表）之外，还有一些额外的特定状态数据。为了在任务屏幕处于活动状态时维护这些数据，我们将创建一个控制器：
- en: '[PRE277]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'The relationship between `Task` and `User` is that a task is created by a user
    and assigned to another user. So, on the edit task (or create new task) screen,
    a list of users should be shown in a selection box so that one can be selected
    from the list. For that, we need to load the list of users from `DS.store` to
    a variable inside the controller. Here is the controller method that loads the
    `user` list:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`和`User`之间的关系是，任务由一个用户创建并分配给另一个用户。因此，在编辑任务（或创建新任务）屏幕上，应该显示一个用户列表，以便可以从列表中选择一个用户。为此，我们需要将用户列表从`DS.store`加载到控制器内的一个变量中。以下是加载`user`列表的控制器方法：'
- en: '[PRE278]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'This method will get fired on initialization of the controller, courtesy of
    the `.on("init")` construct. The template code extract that renders the user list
    in an HTML selection is here:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将在控制器初始化时触发，由`.on("init")`构造提供。渲染用户列表的模板代码摘录在这里：
- en: '[PRE279]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'The action method, `changeCreatedBy`, is listed here:'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeCreatedBy`动作方法在此处列出：'
- en: '[PRE280]'
  id: totrans-1784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Similarly, task priorities are also a list of integers from 1 to 10\. The code
    to load them is here (this goes inside the controller):'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任务优先级也是从1到10的整数列表。加载它们的代码在这里（这些代码放在控制器内）：
- en: '[PRE281]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Code for the priority selection box is as follows:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级选择框的代码如下：
- en: '[PRE282]'
  id: totrans-1788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: As a further step, you may add security to both ends of the application. You
    may personalize tasks for the logged-in user. Ember also supports WebSockets.
    Tasks can be pushed to the client as they are assigned to the logged-in user by
    another user somewhere else. For simplicity, those advanced features are not covered
    in this chapter. However, with the knowledge you have gained in this and the previous
    chapters, you are already at a comfortable stage to implement end-to-end security
    and real-time updates using WebSockets inside Taskify.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的步骤，您可以在应用程序的两端都添加安全性。您可以为已登录的用户个性化任务。Ember还支持WebSockets。任务可以在分配给其他地方的已登录用户时被推送到客户端。为简单起见，这些高级功能在本章中没有涵盖。然而，通过您在本章和前几章中获得的知识，您已经可以舒适地实现端到端的安全性和使用WebSockets进行实时更新，这些功能可以在Taskify中实现。
- en: Summary
  id: totrans-1790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of single-page applications and implemented
    a Taskify frontend as an SPA, connecting to the Spring-based API server on the
    backend. We got a fair understanding of Ember.js and its tools as we built our
    frontend. Spring and Ember have together simplified the building of an otherwise
    complex rich web application of this type. The use of Ember is just an illustration
    of how Spring can power the backend of modern SPAs. Spring powers SPAs built on
    other frameworks, such as Angular, React, and Backbone, created by teams across
    the globe.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了单页应用程序的概念，并将Taskify前端作为SPA实现，连接到后端基于Spring的API服务器。在构建前端时，我们对Ember.js及其工具有了相当的了解。Spring和Ember共同简化了构建这种类型的复杂富Web应用程序。使用Ember只是说明了Spring如何为现代SPA的后端提供支持。Spring支持构建在其他框架上的SPA，例如由全球各地的团队创建的Angular、React和Backbone。
- en: So far, we have successfully covered the most important features of Spring Framework.
    This foundation enables you to venture into more advanced features of Spring,
    packaged as Spring portfolio projects. Projects such as Spring Integration, Spring
    AMQP, Spring Cloud, and Spring Web Services solve the more complex problems of
    enterprise computing. With the knowledge you have gained from this book, you can
    now design powerful solutions using Spring Framework and its subprojects.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已成功涵盖了Spring框架的最重要特性。这个基础使您能够进入Spring组合项目的更高级功能。Spring集成、Spring AMQP、Spring
    Cloud和Spring Web Services等项目解决了企业计算的更复杂的问题。通过本书所获得的知识，您现在可以使用Spring框架及其子项目设计强大的解决方案。
- en: Chapter 7. Integrating with Other Web Frameworks
  id: totrans-1793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。与其他Web框架集成
- en: The flexibility offered by Spring Framework to pick third-party products is
    one of the core value propositions of Spring and Spring supports integration with
    third-party presentation frameworks. While Spring's presentation layer framework—Spring
    MVC, brings the maximum extent of flexibility and efficiency to the development
    of web applications, Spring lets you integrate most popular presentation frameworks.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供的灵活性可以选择第三方产品是Spring的核心价值主张之一，Spring支持与第三方表示框架的集成。虽然Spring的表示层框架Spring
    MVC为Web应用程序的开发带来了最大程度的灵活性和效率，但Spring允许您集成最流行的表示框架。
- en: Spring can be integrated with far too many of Java's web frameworks to be included
    in this chapter, and only the most popular ones, JSF and Struts, will be explained.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: Spring可以与Java的太多Web框架集成，以至于无法在本章中包括所有，只有最流行的JSF和Struts将被解释。
- en: Spring's JSF integration
  id: totrans-1796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring的JSF集成
- en: A JSF web application can be easily integrated with Spring by loading a Spring
    context file within `web.xml` (through a context loader listener). Since JSF 1.2,
    Spring's `SpringBeanFacesELResolver` object reads Spring beans as JSF managed
    beans. JSF only deals with the presentation tier and has a controller named `FacesServlet`.
    All we need to do is register `FacesServlet` in the application deployment descriptor
    or `web.xml` (in this section, we use JavaConfig to register it) and map any request
    with the desired extension (`.xhtml` here) to go through `FacesServlet`.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: JSF Web应用程序可以通过在`web.xml`中加载Spring上下文文件（通过上下文加载器监听器）轻松集成Spring。自JSF 1.2以来，Spring的`SpringBeanFacesELResolver`对象将Spring
    bean读取为JSF托管bean。JSF只处理表示层，并且具有名为`FacesServlet`的控制器。我们只需要在应用程序部署描述符或`web.xml`中注册`FacesServlet`（在本节中，我们使用JavaConfig进行注册），并将任何请求与所需扩展名（这里是`.xhtml`）映射到`FacesServlet`。
- en: 'First, we should include the JSF API and its implementation in the project
    dependencies:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该在项目依赖项中包含JSF API及其实现：
- en: '[PRE283]'
  id: totrans-1799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'The dispatcher Servlet initializer is the location to register `FacesServlet`.
    Notice that we set a mapping request to `FacesServlet` here. Since we use JavaConfig
    to register settings, we register `FacesServlet` in the `AnnotationConfigDispchServletInit`
    class, as follows:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序Servlet初始化程序是注册`FacesServlet`的位置。请注意，我们在此处将请求映射到`FacesServlet`。由于我们使用JavaConfig来注册设置，因此我们在`AnnotationConfigDispchServletInit`类中注册`FacesServlet`，如下所示：
- en: '[PRE284]'
  id: totrans-1801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Note
  id: totrans-1802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must set `FacesServlet` to start up on load prior to the others (notice `facesServlet.setLoadOnStartup`).
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在其他之前设置`FacesServlet`以在加载时启动（注意`facesServlet.setLoadOnStartup`）。
- en: Another important setting is configuring the listener to read the `faces-config`
    XML file. By default, it looks for `faces-config.xml` under the `WEB-INF` folder.
    By setting `org.springframework.web.jsf.el.SpringBeanFacesELResolver` as `ELResolver`,
    we access Spring POJOs as JSF beans. By registering `DelegatingPhaseListenerMulticaster`,
    any Spring's bean that implements the `PhaseListener` interface, JSF's phase events
    will be broadcasted to corresponding implemented methods of `PhaseListener` in
    the Spring's bean.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的设置是配置监听器以读取`faces-config` XML文件。默认情况下，它会在`WEB-INF`文件夹下查找`faces-config.xml`。通过将`org.springframework.web.jsf.el.SpringBeanFacesELResolver`设置为`ELResolver`，我们可以将Spring
    POJO作为JSF bean访问。通过注册`DelegatingPhaseListenerMulticaster`，任何实现`PhaseListener`接口的Spring
    bean，JSF的阶段事件将被广播到Spring bean中实现的相应方法。
- en: 'Here is the `faces-config.xml` file:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`faces-config.xml`文件：
- en: '[PRE285]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'In JSF, we can define beans with a session, request, or application scope and
    the bean values retained within the specific scope. Setting the `eager` flag to
    `false` implies lazy initialization, which creates beans when the first request
    arrives, whereas `true` implies creating the beans on startup. The code for the
    `OrderBean` class is:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF中，我们可以使用会话、请求或应用程序范围来定义bean，并且bean的值在特定范围内保留。将“eager”标志设置为“false”意味着延迟初始化，这会在第一次请求到达时创建bean，而“true”意味着在启动时创建bean。`OrderBean`类的代码如下：
- en: '[PRE286]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Also, these beans are available in the presentation layer to interact with
    the backend. On the first screen (`order.xhtml`), we call the bean''s method (`placeAnOrder`):'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些bean在表示层中可用于与后端交互。在第一个屏幕（`order.xhtml`）上，我们调用bean的方法（`placeAnOrder`）：
- en: '[PRE287]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The method returns a confirmation as a string and specify navigation in the
    `action` attribute means the next page is `confirmation.xhtml`, which looks like
    this:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个字符串作为确认，并在`action`属性中指定导航，意味着下一页是`confirmation.xhtml`，如下所示：
- en: '[PRE288]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Spring's Struts integration
  id: totrans-1813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring的Struts集成
- en: Spring MVC relies on `DispatcherServlet`, which sends requests to controllers
    that are configurable mapping handlers with view and theme resolution. In Struts,
    the controller's name is `Action`. While `Action` instances will be instantiated
    for every request in Struts 2 to tackle the thread safety issue, Spring MVC creates
    controllers once, and each controller's instance serves all requests.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC依赖于`DispatcherServlet`，它将请求发送到可配置的映射处理程序和视图和主题解析的控制器。在Struts中，控制器的名称是`Action`。在Struts
    2中，为了解决线程安全问题，将为每个请求实例化`Action`实例，而Spring MVC只创建一次控制器，每个控制器实例为所有请求提供服务。
- en: To enable Spring integration with Struts 2, Struts provides `struts2-spring-plugin`.
    In Struts 2.1, Struts introduced the convention plugin (`struts2-convention-plugin`),
    which simplified the creation of `Action` classes (by annotation) without any
    configuration file (`struts.xml`). The plugin expects a set of naming conventions
    for the `Action` class, package, and view naming that will be explained in this
    section.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Spring与Struts 2的集成，Struts提供了`struts2-spring-plugin`。在Struts 2.1中，Struts引入了约定插件（`struts2-convention-plugin`），简化了通过注释创建`Action`类（无需任何配置文件`struts.xml`）。该插件期望一组命名约定，用于`Action`类、包和视图命名，将在本节中解释。
- en: 'To integrate Struts 2 with Spring, you need to add these dependencies:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Struts 2与Spring集成，您需要添加这些依赖项：
- en: '[PRE289]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'The `struts2-convention-plugin` plugin searches for packages with the strings
    "struts", "struts2", "action", or "actions", and detects `Action` classes either
    whose names end with `Action` (`*Action`) or who implement the interface `com.opensymphony.xwork2.Action`
    (or extend its subclass `com.opensymphony.xwork2.ActionSupport`). The code for
    the `ViewOrderAction` class is as follows:'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '`struts2-convention-plugin`插件搜索包含字符串“struts”、“struts2”、“action”或“actions”的包，并检测`Action`类，其名称以`Action`(`*Action`)结尾，或者实现`com.opensymphony.xwork2.Action`接口（或扩展其子类`com.opensymphony.xwork2.ActionSupport`）。`ViewOrderAction`类的代码如下：'
- en: '[PRE290]'
  id: totrans-1819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '`@Action` maps `/order` (in the request URL) to this action class and `@ResultPath`
    specifies where views (JSP files) exist. `@Result` specifies navigation to the
    next page up to the string value of the `execute()` method. We created `ViewOrderAction`
    to be able to navigate to a new page and to perform an action (business logic)
    when submitting a form within a view (`orderEntryForm.jsp`):'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Action`将`/order`（在请求URL中）映射到此操作类，`@ResultPath`指定视图（JSP文件）的存在位置。`@Result`指定导航到`execute()`方法的字符串值的下一页。我们创建了`ViewOrderAction`，以便能够导航到新页面，并在视图（`orderEntryForm.jsp`）中提交表单时执行操作（业务逻辑）：'
- en: '[PRE291]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Also, here is the JSP code that calls the `Action` class. Notice the form's
    `doOrder` action, which calls the `DoOrderAction` class (using `@Action("doOrder")`).
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是调用`Action`类的JSP代码。请注意表单的`doOrder`操作，它调用`DoOrderAction`类（使用`@Action("doOrder")`）。
- en: '[PRE292]'
  id: totrans-1823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'As you can see, we used `OrderVO`, whose code is as follows, as the data model
    in the view. Any changes to this object in the JSP code or action class will be
    carried forward to the next page:'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在视图中使用了`OrderVO`，其代码如下，作为数据模型。对JSP代码或操作类中此对象的任何更改都将传递到下一页：
- en: '[PRE293]'
  id: totrans-1825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'In the `DoOrderAction` action class, in the method execution, we implement
    the business logic and return the string value of the method specified in the
    navigation logic in the presentation layer. Here, the action class either goes
    to `orderProceed.jsp` (if it is a valid order) or `failedOrder.jsp` (in the case
    of a failure). Here is the orderProceed.jsp page, to which a success order will
    be forwarded:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DoOrderAction`操作类中，在方法执行中，我们实现业务逻辑，并返回在表示层中导航逻辑中指定方法的字符串值。在这里，操作类要么转到`orderProceed.jsp`（如果是有效订单），要么转到`failedOrder.jsp`（如果失败）。这是`orderProceed.jsp`页面，将转发成功订单：
- en: '[PRE294]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Summary
  id: totrans-1828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explained how to integrate Spring with two famous presentation
    technologies: JSF and Struts.'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了如何将Spring与两种著名的演示技术集成：JSF和Struts。
- en: 'You can get more info about Spring''s integration with web frameworks here:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处获取有关Spring与Web框架集成的更多信息：
- en: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html)'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html)'
- en: 'To know more about Spring''s Struts plugin, visit this link:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Spring的Struts插件的更多信息，请访问此链接：
- en: '[http://struts.apache.org/docs/spring-plugin.html](http://struts.apache.org/docs/spring-plugin.html)'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://struts.apache.org/docs/spring-plugin.html](http://struts.apache.org/docs/spring-plugin.html)'
- en: 'You can get more details about naming conventions in the Struts convention
    plugin here:'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处获取有关Struts约定插件中命名约定的更多详细信息：
- en: '[https://struts.apache.org/docs/convention-plugin.html](https://struts.apache.org/docs/convention-plugin.html)'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://struts.apache.org/docs/convention-plugin.html](https://struts.apache.org/docs/convention-plugin.html)'
- en: Nowadays, big companies are shifting toward single-page applications in the
    presentation layer. To learn about this topic, read [Chapter 6](part0060.xhtml#aid-1P71O1
    "Chapter 6. Building a Single-Page Spring Application"), *Building a Single-Page
    Spring Application*.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大公司正在向单页面应用程序在表示层转变。要了解这个话题，请阅读[第6章](part0060.xhtml#aid-1P71O1 "第6章。构建单页面Spring应用程序")，“构建单页面Spring应用程序”。
