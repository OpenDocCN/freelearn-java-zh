- en: Chapter 9. Building Reactive Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：构建响应式 Web 应用程序
- en: 'Modern web applications increasingly require us to move from static web content
    to a more dynamic paradigm where a lot of integration happens in the background
    and the user interaction is more and more sophisticated. At the same time, the
    provided online services need to adapt to the changing business requirements and
    scale to elastic loads, that is, handling peak hour traffic. Finally, in addition
    to the service they provide, web applications now tend to collect extra information
    concerning user interaction to better understand customer behavior. In this chapter,
    we are going to tackle the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序越来越需要我们从静态Web内容转向更动态的范式，其中大量的集成在后台进行，用户交互越来越复杂。同时，提供的在线服务需要适应不断变化的企业需求，并扩展到弹性负载，即处理高峰时段的流量。最后，除了提供的服务外，Web应用程序现在倾向于收集有关用户交互的额外信息，以更好地理解客户行为。在本章中，我们将探讨以下主题：
- en: Understanding what makes applications reactive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使应用程序成为响应式的因素
- en: Introducing the processing of streams in Play Framework with the *Iteratees*
    pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Play 框架中使用 *Iteratees* 模式处理流
- en: Writing reactive applications including web sockets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写包括 Web Sockets 在内的响应式应用程序
- en: Describing reactive applications
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述响应式应用程序
- en: The traditional pull model adopted by the Web, which is used to browse HTML
    pages now needs to be seconded by two-way communication. This includes a push
    model where users, for example, receive confirmation of asynchronous and long-running
    services or just get notifications of various natures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Web 使用的传统拉模型，现在需要由双向通信来补充。这包括推送模型，其中用户，例如，接收异步和长时间运行服务的确认或只是接收各种类型的通知。
- en: 'The recently created Reactive Manifesto, which is available at [http://www.reactivemanifesto.org](http://www.reactivemanifesto.org),
    aims to summarize the criteria that characterize reactive applications in a technology-agnostic
    way:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最近创建的响应式宣言，可在 [http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)
    查阅，旨在以技术无关的方式总结表征响应式应用程序的标准：
- en: '**React to events**: Message-passing architecture, not wasting the time waiting
    for resources'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应用户事件**：消息传递架构，不浪费等待资源的时间'
- en: '**React to load**: Focuses on scalability by avoiding contention on shared
    resources'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应用户负载**：通过避免对共享资源的竞争来关注可伸缩性'
- en: '**React to failure**: Build resilient systems with the ability to recover at
    all levels'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应用户失败**：构建具有在所有级别恢复能力的弹性系统'
- en: '**React to users**: Honor response time guarantees regardless of load'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应用户操作**：无论负载如何，都要遵守响应时间保证'
- en: Without going into the details of the manifesto that you are encouraged to read,
    we can directly see that the notion of message-driven architecture, which was
    used by Akka in the previous chapter, fits very well with this reactive model.
    In the following sections, we are going to focus on examples of building such
    web applications on top of the Play Framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入探讨你被鼓励阅读的宣言细节的情况下，我们可以直接看到，之前章节中 Akka 所使用的消息驱动架构的概念，与这种响应式模型非常契合。在接下来的章节中，我们将关注在
    Play 框架之上构建此类 Web 应用程序的示例。
- en: Handling streams reactively
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式处理流
- en: Whenever you need to consume and transform streams of data in web applications,
    such as watching stock updates or monitoring log activities on a service, you
    need mechanisms to manipulate chunks of data that can be pushed from a server
    to a browser, for instance, using Comet ([http://en.wikipedia.org/wiki/Comet_(programming)](http://en.wikipedia.org/wiki/Comet_(programming)))
    or WebSocket ([http://en.wikipedia.org/wiki/WebSocket](http://en.wikipedia.org/wiki/WebSocket))
    technologies. The `Iteratee` pattern available within the Play framework is such
    a mechanism. It was borrowed from the Haskell functional language initially.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Web 应用程序中需要消费和转换数据流时，例如监控股票更新或服务上的日志活动，你需要机制来操作可以从服务器推送到浏览器的数据块，例如使用 Comet
    ([http://en.wikipedia.org/wiki/Comet_(programming)](http://en.wikipedia.org/wiki/Comet_(programming)))
    或 WebSocket ([http://en.wikipedia.org/wiki/WebSocket](http://en.wikipedia.org/wiki/WebSocket))
    技术。Play 框架中可用的 `Iteratee` 模式就是这样一种机制。它最初是从 Haskell 函数式语言中借用的。
- en: Understanding Iteratees in Play
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Play 中的 Iteratees
- en: An `Iteratee` construct aims at providing a composable and nonblocking way of
    handling streams produced by its counterpart called `Enumerator`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iteratee` 构造旨在提供一种可组合且非阻塞的方式来处理由其对应者 `Enumerator` 产生的流。'
- en: 'Let''s launch a Scala REPL to explore the `Iteratee`/`Enumerator` constructs
    in more detail. To create a new play project as we have done several times before,
    notably in [Chapter 5](ch05.html "Chapter 5. Getting Started with the Play Framework"),
    *Getting Started with the Play Framework*, use the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个Scala REPL来更详细地探索`Iteratee`/`Enumerator`结构。为了创建一个新的play项目，就像我们之前多次做的那样，特别是在[第5章](ch05.html
    "第5章. Play框架入门")，*Play框架入门*中，使用以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we will remind ourselves how an iteration is done within an imperative
    language such as Java. The following statements written in Scala describe the
    use of a mutable variable `total` that will be updated at each step of the iteration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将提醒自己如何在类似Java这样的命令式语言中完成迭代。以下用Scala编写的语句描述了在迭代的每一步更新可变变量`total`的使用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As explained in the blog post available at [http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/](http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/),
    we need to take care of the following when iterating:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如[http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/](http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/)博客文章中所述，在迭代时，我们需要注意以下事项：
- en: The state of the iteration (are there more elements to follow or is it finished)?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代的状态（是否有更多元素要跟随，或者是否已完成）？
- en: A context (here the total accumulator)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个上下文（这里指总累加器）
- en: An action, updating the context, that is, the total += iterator.next
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更新上下文（即总+=iterator.next）的动作
- en: 'We have seen in [Chapter 1](ch01.html "Chapter 1. Programming Interactively
    within Your Project"), *Programming Interactively within Your Project,* that we
    can implement the same operation in a concise and more functional way by using
    the `foldLeft` Scala construct in the following way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章. 在项目中交互式编程")，*在项目中交互式编程*中看到，我们可以通过使用以下方式的`foldLeft`
    Scala结构以简洁和更函数式的方式实现相同的操作：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `foldLeft` construct is a powerful construct that is applied to Scala collections
    such as `Lists`. If we want to process other forms of input such as a file, a
    network, a database connection, or a flow produced by an Akka actor for instance,
    then the `Enumerator/Iteratee` comes into play. An `Enumerator` construct can
    be seen as the producer of data (similar to the previous `List` ) and an `Iteratee`
    as the consumer of that data, processing each step of the iteration. The preceding
    example involving the `foldLeft` method on a `List` could just be rewritten using
    an `Enumerator/Iteratee` construct. As the `iteratee` library is already available
    within Play, it can be imported directly by using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldLeft`结构是一个强大的结构，它应用于Scala集合，如`Lists`。如果我们想处理其他形式的输入，如文件、网络、数据库连接或由Akka
    actor产生的流等，那么`Enumerator/Iteratee`就派上用场。`Enumerator`结构可以看作是数据的生产者（类似于之前的`List`），而`Iteratee`则是该数据的消费者，处理迭代的每个步骤。先前的涉及`List`上的`foldLeft`方法的例子可以用`Enumerator/Iteratee`结构重写。由于`iteratee`库已经在Play中可用，可以直接使用以下命令导入：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After importing the *iteratee* library and a global execution context for the
    `iteratee` variables to work with, we can define our first `Enumerator` as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入*iteratee*库和全局执行上下文，以便`iteratee`变量可以工作之后，我们可以定义我们的第一个`Enumerator`如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `iteratee` variable defined as follows indicates the computation step to
    be performed while accepting an input from the `enumerator`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义的`iteratee`变量表示在从`enumerator`接受输入的同时要执行的计算步骤：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Combining the `enumerator` construct with the `iteratee` construct is a matter
    of invoking the `run` method of `enumerator` that takes the `iteratee` as an argument:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将`enumerator`结构和`iteratee`结构结合起来，就是调用`enumerator`的`run`方法，该方法接受`iteratee`作为参数：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we have an asynchronous computation, we get back a `result` as a `Future`
    that we can display once it is completed, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个异步计算，我们得到一个`result`作为`Future`，一旦完成，我们可以显示它，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `enumerator` object mentioned previously was an enumerator of integers.
    We can create producers of data of many different types, such as strings or double
    values. This is shown in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的`enumerator`对象是一个整数枚举器。我们可以创建多种不同类型的数据生成器，例如字符串或双精度值。以下代码展示了这一点：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To illustrate the creation of an Enumerator from a file, let''s add a little
    text file named `samplefile.txt` in the root of the current project containing,
    for instance, the following three lines of text:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明从文件创建枚举器的过程，让我们在当前项目的根目录中添加一个名为 `samplefile.txt` 的小文本文件，其中包含以下三行文本：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You may use a separate console window to create this file while leaving the
    REPL running in the original console window. Otherwise, you will have to rerun
    the import statements. Creating an `Enumerator` from a file is shown in the following
    commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在保留原始控制台窗口中的 REPL 运行的同时，在单独的控制台窗口中创建此文件。否则，您将不得不重新运行导入语句。以下命令显示了从文件创建 `Enumerator`
    的示例：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Enumerator` even comprises some useful methods. For example, a stream of events
    that are generated at regular intervals each time the `Promise` object, which
    contains the current time, times out (every 500 milliseconds).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerator` 还包含一些有用的方法。例如，每次包含当前时间的 `Promise` 对象超时（每 500 毫秒）时，都会生成一个事件流。'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In a more general way, we can say that `Enumerator[E]` (read enumerator of
    type E) produces three possible kinds of chunks of data of type E:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以更通用的方式，我们可以这样说，`Enumerator[E]`（读取类型 E 的枚举器）产生三种可能的类型 E 的数据块：
- en: '`Input[E]`: It is a chunk of data of type E, for example, `Input[LogData]`
    is a chunk of `LogData`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input[E]`: 它是类型 E 的一块数据，例如，`Input[LogData]` 是一块 `LogData`'
- en: '`Input.Empty`: It means that the enumerator is empty, for instance, an `Enumerator`
    streaming an empty file'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input.Empty`：这意味着枚举器为空，例如，一个流式传输空文件的 `Enumerator`'
- en: '`Input.EOF`: It means that the enumerator has reached its end, for instance,
    an `Enumerator` construct streaming a file and reaching the end of the file'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input.EOF`：这意味着枚举器已到达其末尾，例如，一个构建文件流并到达文件末尾的 `Enumerator`'
- en: 'In addition to the `run` method used to run an `Enumerator` over an `Iteratee`,
    you can also invoke the constructor, that is, the `apply` method of the enumerator
    directly. Notice in the following two commands, the different result types you
    get depending on how you combine `enumerator`/`iteratee`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于在 `Iteratee` 上运行 `run` 方法外，您还可以直接调用构造函数，即枚举器的 `apply` 方法。注意在以下两个命令中，根据您如何组合
    `enumerator`/`iteratee`，您会得到不同的结果类型：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This last `Future` result contains an `Iteratee[Int,Int]`, that is, an `Iteratee[<type
    contained in chunk>, <result of the iteration>]`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的 `Future` 结果包含一个 `Iteratee[Int,Int]`，即 `Iteratee[数据块中包含的类型, 迭代的结果]`。
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following `Iteratee` consumes all the chunks from the `enumerator` stream
    and returns them as a `List` collection:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Iteratee` 消费来自 `enumerator` 流的所有块，并将它们作为 `List` 集合返回：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The examples of `Iteratee` that we have seen so far use the method `fold` pretty
    much like the `foldLeft` and the `foldRight` methods that are part of the Scala
    collection. Let''s try to build a more sophisticated `Iteratee`: one that, for
    instance, selects words containing the letter `E` out of the enumerator streams.
    This can be done using the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的 `Iteratee` 示例几乎完全使用 `fold` 方法，就像 Scala 集合中的 `foldLeft` 和 `foldRight`
    方法一样。让我们尝试构建一个更复杂的 `Iteratee`：例如，从枚举器流中选择包含字母 `E` 的单词。这可以通过以下代码完成：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `step` recursive function is using a `total` accumulator variable, that
    is, a context to keep some state at each step of the recursion. This is a list
    of strings containing all the results we are interested in. The second argument
    to the `step` function is the new chunk from the `enumerator` stream that comes
    up at each step. This chunk is matched against the possible states; if either
    the stream is empty or we have reached its end, we return the accumulated result
    in a `Done` state. Otherwise, we handle the incoming element. If the element verifies
    the `if` condition, then we add it to the accumulator and invoke the next step
    in our recursion as part of a `Cont` (continue) state. Otherwise, we just invoke
    the next step without saving the element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`step` 递归函数使用一个 `total` 累加变量，即在每个递归步骤中保持一些状态的上下文。这是一个包含所有我们感兴趣的结果的字符串列表。`step`
    函数的第二个参数是每个步骤中从 `enumerator` 流中出现的新的数据块。这个数据块与可能的状态相匹配；如果流为空或者我们已经到达其末尾，我们以 `Done`
    状态返回累积的结果。否则，我们处理传入的元素。如果元素验证 `if` 条件，那么我们将其添加到累加器中，并在递归的下一个步骤中作为 `Cont`（继续）状态调用下一个步骤。否则，我们只是调用下一个步骤而不保存元素。'
- en: 'Finally, the last step initiates the recursion by calling the `step` function
    on the first element of the stream with an empty accumulator. Applying this newly-defined
    `Iteratee` on a simple enumerator looks like the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步通过在流的第一元素上调用 `step` 函数并使用空累加器来启动递归。将这个新定义的 `Iteratee` 应用到一个简单的 `Enumerator`
    上看起来像以下命令：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Every computation step performed on an incoming string either appends that string
    to the total accumulator or ignores it, depending on whether it matches the `if`
    condition or not. In this example, it simply checks that the word contains at
    least one `E`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对传入字符串进行的每个计算步骤要么将该字符串追加到总累加器中，要么忽略它，这取决于它是否匹配 `if` 条件。在这个例子中，它只是简单地检查单词中是否至少包含一个
    `E`。
- en: Adapting Enumerator with Enumeratee
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 `Enumerator` 与 `Enumeratee` 适配
- en: It might happen that the data consumed by an `Iteratee` does not match the input
    produced by an `Enumerator`. The role of an `Enumeratee` is to be an adapter that
    sits in between the `Enumerator` and `Iteratee` to transform the incoming data
    before feeding the `Iteratee`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生这样的情况，`Iteratee` 消费的数据与 `Enumerator` 产生的输入不匹配。`Enumeratee` 的作用是作为位于 `Enumerator`
    和 `Iteratee` 之间的适配器，在将数据馈送到 `Iteratee` 之前对传入的数据进行转换。
- en: 'As an example of simple transformation from an `Enumerator` to another one,
    we could ,for instance, define an `Enumeratee` that converts an input of the type
    `String` to `Int`, as illustrated by the following commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为从 `Enumerator` 到另一个 `Enumerator` 的简单转换的例子，我们可以定义一个将输入类型 `String` 转换为 `Int`
    的 `Enumeratee`，如下面的命令所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The transformation provided by the `Enumeratee` can be declared in its `map`
    method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumeratee` 提供的转换可以在其 `map` 方法中声明。'
- en: 'Adapting the `Enumerator` can also consist of transforming the input data to
    a different format without changing the type. Considering `wordsWithE` that we
    defined previously, we could apply an `Enumeratee` that converts all the input
    data to uppercase so that the consumption of the stream of data by the `Iteratee`
    would produce a different result than the one obtained without `Enumeratee`. The
    following code illustrates that behavior:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 适配 `Enumerator` 还可能包括将输入数据转换成不同的格式，而不改变其类型。考虑到我们之前定义的 `wordsWithE`，我们可以应用一个
    `Enumeratee`，将所有输入数据转换为大写，这样 `Iteratee` 消费数据流的结果就会与没有 `Enumeratee` 时获得的结果不同。以下代码说明了这种行为：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To summarize, an `Enumerator` is a producer of a data stream, an `Iteratee`
    a consumer of that data, and an `Enumeratee` an adapter between the two. The *iteratee*
    pattern has been integrated together with the Play Framework as a way to handle
    streams of data reactively in a web application. In the next section, we are going
    to build web applications in such a way, by additionally using WebSockets to communicate
    between the client and the server in both directions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`Enumerator` 是数据流的生成者，`Iteratee` 是该数据流的消费者，而 `Enumeratee` 是两者之间的适配器。*Iteratee*
    模式已经与 Play 框架集成，作为在 Web 应用中反应式处理数据流的一种方式。在下一节中，我们将通过使用 WebSocket 在客户端和服务器之间双向通信，以这种方式构建
    Web 应用。
- en: Experimenting with WebSockets and Iteratees in Play
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Play 中实验 WebSocket 和 Iteratees
- en: In addition to the traditional pull model of getting HTML displayed in a browser
    when querying a service, most web browsers now support bidirectional communication
    via WebSockets so that servers can push data without the user having to query
    for it first. Once a socket is established between client and server, the communication
    can stay open for further interaction, unlike the HTTP protocol. Modern web apps
    are using this feature more and more to push data from streams reactively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在查询服务时在浏览器中显示 HTML 的传统拉模型之外，大多数网络浏览器现在还支持通过 WebSocket 进行双向通信，这样服务器就可以在用户查询之前推送数据。一旦客户端和服务器之间建立了套接字，通信就可以保持开放，以便进行进一步交互，这与
    HTTP 协议不同。现代 Web 应用越来越多地使用这个功能来从流中反应式地推送数据。
- en: As a reminder, a **WebSocket** is a protocol providing bidirectional communication
    over a single TCP connection, in contrast to the traditional one-way, stateless
    communication of HTTP (either a request or a response). Let's look at the support
    that Play provides in this area and demonstrate in a short example how to establish
    a WebSocket communication between the Play server and a client browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，**WebSocket** 是一种在单个 TCP 连接上提供双向通信的协议，与 HTTP（无论是请求还是响应）的传统单向、无状态通信相反。让我们看看
    Play 在这个领域提供的支持，并通过一个简短的示例演示如何建立 Play 服务器和客户端浏览器之间的 WebSocket 通信。
- en: 'As we have already created a `ch9samples` Play project at the beginning of
    this chapter to experiment with `Iteratees` in the REPL, we can just reuse it.
    We will start by opening the tiny `controllers/Application.scala` server-side
    class that is available by default. We can add a new `connect` method to it to
    create a WebSocket interaction. In a regular Play controller, a method would normally
    use an `Action` class, as we have seen previously. In this example, we use the
    `WebSocket` class instead, illustrated in the controller as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章开头已经创建了一个 `ch9samples` Play 项目来在 REPL 中实验 `Iteratees`，我们可以直接重用它。我们将首先打开默认可用的微小的
    `controllers/Application.scala` 服务器端类。我们可以在其中添加一个新的 `connect` 方法来创建 WebSocket
    交互。在一个常规的 Play 控制器中，一个方法通常会使用一个 `Action` 类，正如我们之前所看到的。在这个例子中，我们使用 `WebSocket`
    类代替，如下所示：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the server-side controller seen in the preceding code, the `in` variable
    contains the logic to handle messages coming from the client, and it will produce
    an `Enumerator` to assemble some response data that will be pushed through the
    channel to each client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中看到的服务器端控制器中，`in` 变量包含处理来自客户端的消息的逻辑，并且它将产生一个 `Enumerator` 来组装一些将被推送到每个客户端的响应数据。
- en: 'On the client side, the `views/main.scala.html` view is where we are going
    to add the WebSocket support, as a part of a JavaScript script, whose role is
    to open a web socket and react to incoming messages. as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，`views/main.scala.html` 视图是我们将要添加 WebSocket 支持的地方，作为 JavaScript 脚本的一部分，其作用是打开一个
    WebSocket 并对传入的消息做出反应。如下所示：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have both ends, the only remaining step is to define a route for
    the controller''s `connect` method. Edit the `conf/routes` file to make it look
    like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了两端，剩下的唯一步骤是为控制器的 `connect` 方法定义一个路由。编辑 `conf/routes` 文件，使其看起来如下所示：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we are ready to try the demo by starting the play server from the command
    prompt:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好通过从命令提示符启动 Play 服务器来尝试演示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Opening a browser at `http://localhost:9000/` (preferably one that supports
    WebSockets) and clicking on the **Run WebSocket** link should first confirm that
    the browser is indeed supporting WebSockets. Clicking on **OK** a couple of times
    will first show you that a message has been sent, and then show that the roundtrip
    has been achieved by receiving a message from the server. You should also see
    the `Message to send` log message on the play server prompt.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `http://localhost:9000/`（最好是支持 WebSocket 的浏览器）中打开浏览器并点击 **运行 WebSocket** 链接，首先应该确认浏览器确实支持
    WebSocket。点击 **确定** 几次后，首先会显示已经发送了一条消息，然后显示通过从服务器接收消息实现了往返。你也应该在 Play 服务器提示符上看到
    `要发送的消息` 日志消息。
- en: Learning from activator templates
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从激活器模板中学习
- en: There is a growing list of reactive applications based on *iteratees* that have
    been packaged and deployed as activator templates. At the time of writing this
    book, we have identified more than five templates and you can look at a few of
    them. They often mix technologies such as WebSockets with Akka for communication
    and message processing and, on the client side, JavaScript frameworks such as
    Angular.js, to often provide simple HTML rendering.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于迭代器的反应性应用程序列表正在不断增长，这些应用程序已经被打包并作为激活器模板部署。在撰写本书时，我们已经确定了超过五个模板，你可以查看其中的一些。它们通常将
    WebSocket 与 Akka 用于通信和消息处理混合在一起，在客户端，使用 Angular.js 等JavaScript 框架来提供简单的 HTML 渲染。
- en: As the Typesafe activator templates HTML page lets you select tags to filter
    out projects depending on some keywords, you may check the appropriate projects
    by selecting the reactive checkbox.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Typesafe 激活器模板 HTML 页面允许你选择标签来根据某些关键词过滤项目，你可以通过选择反应性复选框来检查适当的项目。
- en: Reactive stocks
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应性股票
- en: 'This sample is a project based on the Java version of Play. It graphically
    demonstrates the real-time update of stock values (that are randomly generated
    for simplicity). It contains both Java and Scala code. An Akka `StockActor` actor
    is instantiated for every stock symbol, and its role is to maintain a list of
    all users watching this stock. Some additional functionality queries a twitter
    API to retrieve all tweets matching a particular symbol (for example, [http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl](http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl)).
    This knowledge can then be processed to calculate a sentiment index that should
    help to decide whether to buy this stock or not. The following screenshot illustrates
    graphically what the app looks like, once it is run:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是基于 Play 的 Java 版本的项目。它以图形方式演示了股票价值的实时更新（为了简单起见，这些股票价值是随机生成的）。它包含 Java 和
    Scala 代码。为每个股票符号实例化一个 Akka `StockActor` 演员，其作用是维护一个所有关注该股票的用户列表。一些附加功能通过查询 Twitter
    API 来检索所有匹配特定符号的推文（例如，[http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl](http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl)）。然后，这些知识可以被处理以计算一个情感指数，这有助于决定是否购买这只股票。以下截图展示了应用程序运行后的图形界面：
- en: '![Reactive stocks](img/3637_09_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![响应式股票](img/3637_09_01.jpg)'
- en: Reactive real-time search
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式实时搜索
- en: To demonstrate some integration between ElasticSearch and the reactive features
    of the Typesafe stack through Play iteratees and Akka, this sample exhibits how
    to push log events to a browser. As a reminder, ElasticSearch ([http://www.elasticsearch.org](http://www.elasticsearch.org))
    is a distributed real-time search and an analytics engine based on the well-established
    Apache Lucene ([https://lucene.apache.org](https://lucene.apache.org)) full-text
    search engine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 ElasticSearch 和 Typesafe 堆栈的响应式特性之间的集成，通过 Play iteratees 和 Akka，这个示例展示了如何将日志事件推送到浏览器。提醒一下，ElasticSearch
    ([http://www.elasticsearch.org](http://www.elasticsearch.org)) 是一个基于 Apache Lucene
    ([https://lucene.apache.org](https://lucene.apache.org)) 全文搜索引擎的成熟技术，是一个分布式实时搜索和分析引擎。
- en: It notably provides a **percolation** feature, that notifies your application
    when new content matches your search criteria (instead of having to poll the search
    engine to check regularly for new updates).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别提供了一个**过滤**功能，当新内容与搜索条件匹配时，它会通知您的应用程序（而不是需要轮询搜索引擎以定期检查新更新）。
- en: To emulate content, an Akka `LogEntryProducerActor` actor is responsible for
    generating random log entries each time it receives a `Tick` message. These messages
    are produced at regular intervals by a `MainSearchActor` actor that also acts
    as a coordinator for the search. Finally, an `ElasticSearchActor` actor implements
    the percolation feature by interacting with an embedded ElasticSearch server (`EmbeddedESServer`)
    that is started from the Play `Global` class. Instead of pushing information to
    the browser via WebSockets, the sample uses **Server Side Events** (**SSE**) as
    it only needs one-way communication once the search criteria are known.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟内容，一个 Akka `LogEntryProducerActor` 演员负责在每次接收到一个 `Tick` 消息时生成随机的日志条目。这些消息由充当搜索协调器的
    `MainSearchActor` 演员定期产生。最后，一个 `ElasticSearchActor` 演员通过与嵌入的 ElasticSearch 服务器（`EmbeddedESServer`）交互来实现过滤功能，该服务器是从
    Play 的 `Global` 类启动的。由于一旦知道了搜索条件，只需要单向通信，所以示例使用 **服务器端事件**（**SSE**）而不是通过 WebSocket
    将信息推送到浏览器。
- en: Further information on the template and all the code behind it is available
    at [https://github.com/DrewEaster/realtime-search](https://github.com/DrewEaster/realtime-search).
    In particular, the query syntax to be entered for a search is defined as Lucene
    syntax and is specified at [http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description](http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模板及其所有代码的更多信息可在 [https://github.com/DrewEaster/realtime-search](https://github.com/DrewEaster/realtime-search)
    找到。特别是，搜索时需要输入的查询语法被定义为 Lucene 语法，并在 [http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description](http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description)
    中指定。
- en: 'If we execute this sample by installing and running the activator template
    (with the `> activator run` command from the root of the template project), we
    can open a browser at `localhost:9000` and enter `GET` as the search criterion.
    After a few seconds, some browser output should progressively be displayed, as
    shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过安装和运行激活器模板（从模板项目的根目录使用`> activator run`命令）来执行此示例，我们可以在`localhost:9000`打开浏览器，并将`GET`作为搜索条件输入。几秒钟后，应该会逐渐显示一些浏览器输出，如下截图所示：
- en: '![Reactive real-time search](img/3637_09_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Reactive real-time search](img/3637_09_02.jpg)'
- en: The Play-Akka-Angular-WebSocket template
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The Play-Akka-Angular-WebSocket template
- en: 'As another example of reactively pushing information to the browser, this sample
    updates a clock on the client by scheduling an actor. The role of this actor is
    to send events in the JSON format via a WebSocket connection by using the Play
    `WebSocket.async[JsValue]` method call. The Angular.js JavaScript framework is
    used on the client side and the GUI looks like the following screenshot once it
    starts running:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将信息主动推送到浏览器的另一个示例，此示例通过调度一个演员来更新客户端上的时钟。这个演员的作用是通过使用Play的`WebSocket.async[JsValue]`方法调用，通过WebSocket连接发送JSON格式的事件。在客户端使用Angular.js
    JavaScript框架，一旦开始运行，GUI看起来如下截图所示：
- en: '![The Play-Akka-Angular-WebSocket template](img/3637_09_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![The Play-Akka-Angular-WebSocket template](img/3637_09_03.jpg)'
- en: The number of activator templates that illustrate reactive applications is growing.
    Also, you can check out from time to time the new templates that are available,
    without upgrading the version of the activator each time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 展示反应式应用程序的激活器模板的数量正在增长。此外，您还可以不时查看新模板，而无需每次都升级激活器的版本。
- en: Playing with Actor Room
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playing with Actor Room
- en: In the previous section, we have seen a number of projects that are using `Enumerators`/`Iteratees`
    to send and receive messages reactively, with various levels of complexity. `Iteratees`
    are powerful, but using them can sometimes lead to code snippets that are not
    easy to understand. The Play Actor Room project, which is available at [https://github.com/mandubian/play-actor-room](https://github.com/mandubian/play-actor-room),
    proposes to reduce some of the complexity of setting up `Iteratees` by abstracting
    away this part and letting the programmer focus only on the domain logic, such
    as processing incoming messages and assembling outgoing messages. This project
    started from the observation that many applications need the same functionality,
    which can be seen as a server `Room` (holding state, for instance, and being the
    middle man between distributed clients). The role of this room is to listen for
    incoming messages from connected clients, and either broadcast received messages
    after processing them or just unicast communication to a single client. It is
    a good illustration of how an application can react to users/events. Typical applications
    such as a multiuser chat are therefore very straightforward to write, and they
    are one of the two samples given as examples. Let's experiment with the most basic
    use of the actor room support, a sample called `simplest`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了许多使用`Enumerators`/`Iteratees`来反应式地发送和接收消息的项目，它们具有不同的复杂度级别。`Iteratees`功能强大，但有时使用它们可能会导致难以理解的代码片段。可在[https://github.com/mandubian/play-actor-room](https://github.com/mandubian/play-actor-room)找到的Play
    Actor Room项目，通过抽象这部分内容，让程序员只关注领域逻辑（例如处理传入的消息和组装传出消息），提出减少设置`Iteratees`的一些复杂性。该项目始于观察许多应用程序需要相同的功能，这可以看作是一个服务器`Room`（例如，持有状态，并在分布式客户端之间充当中间人）。这个房间的角色是监听来自已连接客户端的传入消息，在处理这些消息后广播接收到的消息，或者仅向单个客户端进行单播通信。这是应用程序如何对用户/事件做出反应的一个很好的说明。因此，像多用户聊天这样的典型应用程序编写起来非常直接，它们是给出的两个示例之一。让我们实验一下actor
    room支持的最低级使用，一个名为`simplest`的示例。
- en: 'To clone the project somewhere on your disk, just enter the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的磁盘上的某个位置克隆项目，只需输入以下命令：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, we can look at the application once it is running:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以查看应用程序运行后的样子：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Opening a browser at the default play port (`http://localhost:9000/`) will show
    you a simple **sign-in** widget, as shown in the following screenshot. Enter your
    name to log in, type a message in the provided text area, and then press *Enter*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的Play端口（`http://localhost:9000/`）打开浏览器将显示一个简单的**登录**小部件，如下截图所示。输入您的名字进行登录，在提供的文本区域中输入消息，然后按*Enter*键。
- en: '![Playing with Actor Room](img/3637_09_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Playing with Actor Room](img/3637_09_04.jpg)'
- en: 'In the console window where you started the actor room application, you should
    now see the logging information printed by the actor that received messages from
    the client browser. The information can be seen as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在你启动actor room应用程序的控制台窗口中，你现在应该能看到接收来自客户端浏览器消息的actor打印的日志信息。信息如下所示：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On opening several browser windows and logging in with different names, you
    can see all the messages hitting the server room, that is, at the console. The
    actor room actually broadcasts the received messages back to all connected browsers,
    although for now there is nothing in the view to handle the messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开几个浏览器窗口并使用不同的名字登录后，你可以在控制台中看到所有击中服务器房间的消息。实际上，actor room会将接收到的消息广播回所有连接的浏览器，尽管目前视图中还没有处理这些消息的功能。
- en: 'You can, however, open the console of one browser to see the display of the
    broadcast messages, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以打开一个浏览器的控制台来查看广播消息的显示，如下面的截图所示：
- en: '![Playing with Actor Room](img/3637_09_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![与Actor Room玩耍](img/3637_09_05.jpg)'
- en: Additionally, invoking the `http://localhost:9000/list/` URL from a third window
    will return the list of currently connected clients.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从第三个窗口调用`http://localhost:9000/list/` URL将返回当前连接的客户端列表。
- en: Some of the interesting features of this basic application can be observed once
    we import the project into eclipse (entering the `> play eclipse` command) and
    open the controller that includes the implementation of the receiving `Actor`
    class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将项目导入到Eclipse中（输入`> play eclipse`命令）并打开包含接收`Actor`类实现的控制器，就可以观察到这个基本应用的一些有趣特性。
- en: 'The `Receiver` actor that acts as the server has been created by a supervisor
    `Actor`. It handles messages in JSON format. All the default logic of the receiving
    `Actor`, which is the only code that we need to care about for processing messages
    from clients, is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务器角色的`Receiver`角色是由一个监督`Actor`创建的。它处理JSON格式的消息。接收`Actor`的所有默认逻辑，也就是我们处理客户端消息时需要关注的唯一代码，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that broadcasting the response from the server to all the clients is done
    by the supervising actor referenced by `context.parent`. In the previous logic,
    the `Broadcast` message also includes the originator `from` `ActorRef` reference.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将服务器响应广播到所有客户端是由`context.parent`引用的监督角色完成的。在之前的逻辑中，`Broadcast`消息还包括发起者`from`
    `ActorRef`引用。
- en: As a small modification to the default room behavior to fit new business requirements,
    we can, for instance, reuse the `TravelAgent`, `Flight`, and `Hotel` actors that
    we created in [Chapter 8](ch08.html "Chapter 8. Essential Properties of Modern
    Applications – Asynchrony and Concurrency"), *Essential Properties of Modern Applications
    – Asynchrony and Concurrency*. We want to provide each user with the ability to
    book a flight, and (at any time) monitor how many seats are still available. To
    do this, we can involve a slightly bigger JSON message as the exchange format
    between the server and client.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对默认房间行为的小修改以适应新的业务需求，例如，我们可以重用我们在[第8章](ch08.html "第8章. 现代应用程序的基本属性 – 异步和并发")，*现代应用程序的基本属性
    – 异步和并发*中创建的`TravelAgent`、`Flight`和`Hotel`角色。我们希望为每个用户提供预订航班的能力，并且（在任何时候）监控还有多少座位可用。为此，我们可以使用一个稍微大一点的JSON消息作为服务器和客户端之间的交换格式。
- en: 'A useful enhancement to Scala that came with Version 2.10 is the notion of
    string interpolation. We already used this feature throughout this book and introduced
    it in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your
    Project"), *Programming Interactively within Your Project*. Similarly, JSON interpolation
    has been created as an extension to the JSON support in Play. We can reuse JSON
    interpolation, for instance, to do some elegant pattern matching. Just add the
    following extension dependencies to the `Build.scala` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.10版本附带的一个有用的增强是字符串插值的理念。我们已经在整本书中使用了这个特性，并在[第1章](ch01.html "第1章. 在项目中交互式编程")，*在项目中交互式编程*中介绍了它。同样，JSON插值作为Play对JSON支持的扩展也被创建。我们可以重用JSON插值，例如，进行一些优雅的模式匹配。只需将以下扩展依赖项添加到`Build.scala`文件中：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once in place, the JSON pattern matching feature handles the JSON messages coming
    from the browser client to the `Receiver` actor, as follows
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署，JSON模式匹配功能将处理来自浏览器客户端到`Receiver`角色的JSON消息，如下所示
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s add a `Flight` actor to keep the count of seats available. In a new
    package `actors`, which is directly under the `app/` source directory, we can
    add a `Flight.scala` class that looks like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`Flight` actor来跟踪可用座位数。在位于`app/`源目录下的新包`actors`中，我们可以添加一个类似于以下内容的`Flight.scala`类：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rather than creating a mutable state variable `var seatsLeft`, as we did in
    [Chapter 8](ch08.html "Chapter 8. Essential Properties of Modern Applications
    – Asynchrony and Concurrency"), *Essential Properties of Modern Applications –
    Asynchrony and Concurrency*, we encapsulated this state change as an argument
    passed while switching context each time we receive a `BookSeat` message. This
    way of proceeding is a recommended best practice to avoid holding mutable variables.
    We have added a `GetSeatsLeft` message to be able to query the value of the current
    state, in which case the state is sent back to the `sender` actor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第8章](ch08.html "第8章. 现代应用程序的基本属性 – 异步和并发")中创建可变状态变量`var seatsLeft`的做法不同，*现代应用程序的基本属性
    – 异步和并发*，我们将这种状态变化封装为每次接收`BookSeat`消息时切换上下文时传递的参数。这种方式是避免持有可变变量的推荐最佳实践。我们添加了一个`GetSeatsLeft`消息，以便能够查询当前状态值，在这种情况下，状态会发送回`sender`
    actor。
- en: 'On the client side, we can modify the `index.scala.html` view to add a couple
    of simple widgets to our application. In particular, we can add a placeholder
    to display the number of available seats left in the flight. This is the information
    that will be pushed to all connected browsers by the server room actor. An example
    of such a view is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们可以修改`index.scala.html`视图来向我们的应用程序添加几个简单的小部件。特别是，我们可以添加一个占位符来显示航班剩余的座位数。这是服务器室actor将推送到所有连接浏览器的信息。以下是一个此类视图的示例：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to slightly modify the small JavaScript snippet that handles communication
    between the client browser and the server via the WebSocket so that it handles
    the new JSON format. The modified `websocket.scala.js` file is given as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要稍微修改处理客户端浏览器和服务器之间通过WebSocket通信的小型JavaScript片段，以便它能够处理新的JSON格式。修改后的`websocket.scala.js`文件如下所示：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, in the `Application.scala` file of the server part, we can extend
    the `Receiver` actor to handle incoming JSON messages and contact the `Flight`
    actor to both update and read the current value of its state, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在服务器部分的`Application.scala`文件中，我们可以扩展`Receiver` actor以处理传入的JSON消息，并联系`Flight`
    actor来更新和读取其当前状态值，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have all the pieces in place, let''s run the example in a couple
    of browsers. Notice that we have added the `LoggingReceive` call to both the `Receiver`
    and `Flight` actors so that we get extensive logging output once we execute the
    server code. On the command prompt, you may enter the following commands to start
    the Play application with the additional flags to activate the logging output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有组件，让我们在几个浏览器中运行示例。请注意，我们已经向`Receiver`和`Flight` actor添加了`LoggingReceive`调用，以便在执行服务器代码时获得详细的日志输出。在命令提示符中，您可以输入以下命令以启动带有激活日志输出的Play应用程序：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open two browser windows (possibly using two different browsers) at the URL
    `http://localhost/9000`. Complete the sign-in step; for instance, use **Alice**
    and **Bob** as names to connect to the actor room from the two browsers, respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL `http://localhost/9000`上打开两个浏览器窗口（可能使用两个不同的浏览器）。完成登录步骤；例如，使用**Alice**和**Bob**作为名称，分别从两个浏览器连接到actor室。
- en: 'Entering the seats that you want to book from either window will update the
    global number of seats left in both windows, as illustrated in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从任一窗口输入您想要预订的座位数将更新两个窗口中全局剩余座位数，如下面的截图所示：
- en: '![Playing with Actor Room](img/3637_09_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![与Actor Room玩耍](img/3637_09_06.jpg)'
- en: 'The console output from the server should display the logging information as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的控制台输出应显示如下日志信息：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Entering a number of seats that is greater than the number of remaining places
    will not update the counter, and it will end up in a `Fail` message from the `Flight`
    actor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的座位数大于剩余座位数时，计数器不会更新，最终会收到来自`Flight` actor的`Fail`消息。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have experimented with the *iteratees* pattern supported
    by the Play Framework to handle streams reactively. We have then used it along
    with WebSockets and Akka to write a small, reactive web application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们尝试了Play框架支持的*迭代器*模式来处理流式数据。然后，我们结合WebSockets和Akka编写了一个小型、反应式的Web应用程序。
- en: The samples of reactive web applications that we have addressed and discussed
    in this chapter are just a glimpse of the endless possibilities of making applications
    that react to events and are resilient to failure and load. As web applications
    grow in complexity, such architectures should gain in popularity and adoption
    rate.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论和处理的反应式Web应用程序的示例只是构建对事件做出反应且对失败和负载具有弹性的应用程序无限可能性的一个缩影。随着Web应用程序的复杂性增加，这种架构应该会越来越受欢迎和被采用。
- en: Being able to asynchronously process streams in real time is, in our opinion,
    a big competitive advantage if this functionality is built in a manageable and
    maintainable way. This is precisely the goal that the Play Framework combined
    with Akka illustrates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，能够以异步方式实时处理流是一个巨大的竞争优势，如果这个功能是以可管理和可维护的方式构建的。这正是Play框架与Akka结合所展示的目标。
- en: In the next and the last chapter of this book, we are going to consider a few
    areas where we think Scala provides additional, convenient help.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将考虑一些我们认为Scala可以提供额外、方便帮助的领域。
