- en: Writing Your First Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个程序
- en: In 2001, Martin Odersky started to design the Scala language – it took him three
    years to release the first public version. The name comes from Scalable language.
    This was chosen because Scala is designed to grow with the requirements of its
    users – you can use Scala for small scripts or for large enterprise applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年，Martin Odersky开始设计Scala语言——他花了三年时间发布了第一个公开版本。这个名字来源于Scalable language。之所以选择这个名字，是因为Scala被设计成随着用户需求的增长而发展——你可以使用Scala编写小脚本，也可以用它开发大型企业级应用。
- en: Scala has been constantly evolving ever since, with a growing popularity. As
    a general purpose language, it is used in many different industries such as finance,
    telecoms, retail, and media. It is particularly compelling in distributed scalable
    systems and big data processing. Many leading open source software projects have
    been developed in Scala, such as Apache Spark, Apache Kafka, Finagle (by Twitter),
    and Akka. A large number of companies use Scala in production, such as Morgan
    Stanley, Barclays, Twitter, LinkedIn, The Guardian, and Sony.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Scala自那时起一直在不断进化，其受欢迎程度也在不断增长。作为一种通用语言，它被广泛应用于金融、电信、零售和媒体等多个行业。在分布式可扩展系统和大数据处理方面，Scala尤其引人注目。许多领先的开源软件项目都是用Scala开发的，例如Apache
    Spark、Apache Kafka、Finagle（由Twitter开发）和Akka。许多公司都在生产中使用Scala，例如摩根士丹利、巴克莱斯、Twitter、LinkedIn、卫报和索尼。
- en: Scala is not an extension of Java but is fully interoperable with it. You can
    call Java code from Scala, and you can call Scala code from Java. There is also
    a compiler to JavaScript, which we will explore later on in this book. You can,
    therefore, run Scala code in your browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Scala不是Java的扩展，但它与Java完全兼容。你可以从Scala调用Java代码，也可以从Java调用Scala代码。还有一个编译器可以将Scala代码编译成JavaScript，我们将在本书的后续章节中探讨。因此，你可以在浏览器中运行Scala代码。
- en: Scala is a blend of object-oriented and functional programming paradigms, and
    it is statically typed. As such, it can serve as a bridge for people from an object-oriented
    or imperative background to move gradually to functional programming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是面向对象和函数式编程范式的混合体，并且是静态类型的。因此，它可以作为从面向对象或命令式背景的人逐渐过渡到函数式编程的桥梁。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up your environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: Using the basic features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本功能
- en: Running the Scala Console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Scala控制台
- en: Using the Scala Console and Worksheet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala控制台和工作表
- en: Creating my first project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我的第一个项目
- en: Setting up your environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: First things first, we need to set up our work environment. In this section,
    we will get all the tools and libraries, and then install and configure them on
    your computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的工作环境。在本节中，我们将获取所有工具和库，然后在你的计算机上安装和配置它们。
- en: Scala programs are compiled to Java bytecode, which is a kind of assembly language
    that can be executed using a **Java Virtual Machine** (**JVM**). You will, therefore,
    need to have a Java compiler and a JVM installed on your computer. The **Java
    Development Kit** (**JDK**) provides both components, alongside other tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Scala程序被编译成Java字节码，这是一种可以由**Java虚拟机**（**JVM**）执行的汇编语言。因此，你需要在你的计算机上安装Java编译器和JVM。**Java开发工具包**（**JDK**）提供了这两个组件以及其他工具。
- en: You could develop in Scala using a simple text editor and compile your programs
    using the Scala **Simple Build Tool** (**SBT**). However, this would not be a
    pleasant nor productive experience. The majority of professional Scala developers
    use an **Integrated Development Environment** (**IDE**), which provides many helpful
    features such as syntax highlighting, autocompletion, code navigation, integration
    with SBT, and many more. The most widely used IDE for Scala is IntelliJ Idea from
    JetBrains, and this is the one we are going to install and use in this book. The
    other options are Scala IDE for Eclipse and ENSIME. ENSIME is an open source project
    that brings IDE-like features to popular text editors such as Emacs, Vim, Atom,
    Sublime, and VSC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用简单的文本编辑器在Scala中开发，并使用Scala的**简单构建工具**（**SBT**）编译你的程序。然而，这不会是一个愉快或高效的经验。大多数专业的Scala开发者使用**集成开发环境**（**IDE**），它提供了许多有用的功能，如语法高亮、自动完成、代码导航、与SBT集成等。Scala最广泛使用的IDE是来自JetBrains的IntelliJ
    Idea，这是我们将在本书中安装和使用的IDE。其他选项包括Eclipse的Scala IDE和ENSIME。ENSIME是一个开源项目，为流行的文本编辑器（如Emacs、Vim、Atom、Sublime和VSC）带来了类似IDE的功能。
- en: Installing the Java SDK
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java SDK
- en: We are going to install the Oracle JDK, which includes a JVM and a Java compiler.
    On many Linux distributions, the open source OpenJDK is preinstalled. OpenJDK
    is fully compatible with the Oracle JDK, so if you already have it you do not
    need to install anything else to follow this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Oracle JDK，它包括 JVM 和 Java 编译器。在许多 Linux 发行版中，开源的 OpenJDK 已经预安装。OpenJDK
    与 Oracle JDK 完全兼容，因此如果您已经有了它，您不需要安装任何其他东西来遵循这本书。
- en: 'You might already have a Java SDK installed on your computer. We are going
    to check if this is the case. If you are using Windows, open a DOS Command Prompt. If
    you are using macOS or Linux, open a Terminal. After the prompt, type the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在计算机上安装了 Java SDK。我们将检查这是否属实。如果您使用 Windows，请打开 DOS 命令提示符。如果您使用 macOS 或
    Linux，请打开终端。在提示符后，输入以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you have a JDK installed, the version of the installed compiler will be
    printed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 JDK，将打印出已安装编译器的版本：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the version installed is greater than or equal to 1.8.0_112, you can skip
    the JDK installation. The version of Scala that we are going to use is compatible
    with JDK version 1.8 or 1.9.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已安装的版本大于或等于 1.8.0_112，您可以跳过 JDK 安装。我们将使用的 Scala 版本与 JDK 版本 1.8 或 1.9 兼容。
- en: If not, open the following URL, download the SDK for your platform, and follow
    the installation instructions given: [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请打开以下网址，下载您平台上的 SDK，并按照提供的安装说明进行操作：[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)。
- en: Installing IntelliJ IDEA
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 IntelliJ IDEA
- en: Go to [https://www.jetbrains.com/idea/download.](https://www.jetbrains.com/idea/download)
    Download the community edition for your platform. The ultimate edition offers
    more features, but we will not use them in this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://www.jetbrains.com/idea/download.](https://www.jetbrains.com/idea/download)
    下载您平台上的社区版。终极版提供更多功能，但在这本书中我们不会使用它们。
- en: 'The following are the steps to install IntelliJ IDEA:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在安装 IntelliJ IDEA 时的步骤：
- en: Run IntelliJ Idea.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 IntelliJ Idea。
- en: 'Select the Do not import settings option:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“不导入设置”选项：
- en: '![](img/a53b8758-c0cc-47b9-8933-e0fbcf1f6f78.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a53b8758-c0cc-47b9-8933-e0fbcf1f6f78.png)'
- en: 'Choose a UI theme. I personally prefer Dracula, since a dark background saves
    battery on a laptop and is more gentle on the eyes:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 UI 主题。我个人更喜欢 Dracula，因为深色背景在笔记本电脑上可以节省电池，并且对眼睛更温和：
- en: '![](img/d48ef942-8909-4efa-a8ad-45a47487222a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d48ef942-8909-4efa-a8ad-45a47487222a.png)'
- en: 'Create a desktop entry by checking the options given:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选提供的选项来创建桌面条目：
- en: '![](img/06ce0b8c-7f23-4b80-9266-2be97e805fa6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06ce0b8c-7f23-4b80-9266-2be97e805fa6.png)'
- en: 'In the Create Launcher Script dialog window, check the create a script... checkbox.
    It will let you open files in IntelliJ from the command line:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建启动器脚本”对话框窗口中，勾选创建脚本...复选框。这将允许您从命令行打开 IntelliJ 中的文件：
- en: '![](img/6714f751-ed3c-4763-a363-49baa5fef44e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6714f751-ed3c-4763-a363-49baa5fef44e.png)'
- en: 'Customize the plugins. For each component, click on Customize... or Disable
    All. We will not need most of the plugins. You can only select the following:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义插件。对于每个组件，点击“自定义...”或“全部禁用”。我们不需要大多数插件。您只能选择以下选项：
- en: 'Build Tools: Disable All.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具：全部禁用。
- en: 'Version Controls: Only keep Git and GitHub.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制：仅保留 Git 和 GitHub。
- en: 'Test Tools: Disable All.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工具：全部禁用。
- en: 'Swing: Disable.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing：禁用。
- en: 'Android: Disable.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android：禁用。
- en: 'Other Tools: Disable All and keep Bytecode viewer, Terminal, and YAML.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具：全部禁用并保留字节码查看器、终端和 YAML。
- en: 'Plugin Development: Disable.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件开发：禁用。
- en: 'You can see the aforementioned plugins in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到上述插件：
- en: '![](img/7fe5cac6-1d21-4501-837e-c7d3e6618346.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fe5cac6-1d21-4501-837e-c7d3e6618346.png)'
- en: Install the featured plugins—some additional plugins are proposed for you to
    install, such as the Scala plugin and a tool to learn the essential features of
    IntelliJ.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装特色插件——还为您推荐了一些额外的插件，例如 Scala 插件和用于学习 IntelliJ 基本功能的工具。
- en: 'Click on the Install button for Scala and for the IDE Features Trainer, as
    shown in the following screenshot, and then proceed by clicking on Start using
    IntelliJ IDEA:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，点击安装按钮为 Scala 和 IDE 功能训练师，然后通过点击“开始使用 IntelliJ IDEA”继续：
- en: '![](img/56d6e253-1734-428f-998b-2e5c26480292.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56d6e253-1734-428f-998b-2e5c26480292.png)'
- en: If you are already a Vim aficionado, you can install IdeaVim. Otherwise, I would
    recommend that you avoid it. I personally use it daily, but it took me some time
    to get used to it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是Vim爱好者，你可以安装IdeaVim。否则，我建议你避免使用它。我个人每天都在使用它，但花了一些时间才习惯。
- en: 'Click on Create New Project | Scala | sbt:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建新项目 | Scala | sbt：
- en: '![](img/d8ca4efd-cfe5-4dd1-9a31-5e70a3e89f6a.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8ca4efd-cfe5-4dd1-9a31-5e70a3e89f6a.png)'
- en: 'Fill in the following details, as shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写以下详细信息，如以下截图所示：
- en: 'Name: `scala_fundamentals`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`scala_fundamentals`。
- en: 'JDK: Click on New and then select the installation directory of the Oracle
    JDK.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK：点击新建，然后选择Oracle JDK的安装目录。
- en: 'sbt: Choose the version 1.0.4, check Sources.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sbt：选择版本1.0.4，勾选源代码。
- en: 'Scala: Choose the latest version 2.12.x, for instance 2.12.4 (IntelliJ lists
    all the possible versions and will download the one you choose), and check Sources.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala：选择最新版本2.12.x，例如2.12.4（IntelliJ列出了所有可能的版本，并将下载你选择的版本），勾选源代码。
- en: Click on Finish.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'It is going to take some time depending on your internet connection''s speed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将取决于你的互联网连接速度所需的时间：
- en: '![](img/8c23de9f-3e7e-4ede-b12e-93530f90bde3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c23de9f-3e7e-4ede-b12e-93530f90bde3.png)'
- en: 'You should see the following project structure:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下项目结构：
- en: '![](img/a3bbba4a-6292-4c12-9705-2312348e3d4e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3bbba4a-6292-4c12-9705-2312348e3d4e.png)'
- en: Using the basic features
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本功能
- en: In this section, and in the rest of this book, we will highlight some key shortcuts
    in *italics*. I strongly encourage you to use and remember these shortcuts. They
    save a tremendous amount of time and will keep you focused on the task at hand.
    If you cannot remember a shortcut, you can use the mother of all shortcuts, *Ctrl*
    + *Shift* + *A* (Windows/Linux) or *cmd* + *shift* + *A* (macOS), and type the
    name of the action you are looking for.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及本书的其余部分，我们将突出显示一些关键的快捷键（*斜体*）。我强烈建议你使用并记住这些快捷键。它们可以节省大量的时间，并帮助你专注于当前的任务。如果你记不住一个快捷键，你可以使用所有快捷键之母，即*Ctrl*
    + *Shift* + *A*（Windows/Linux）或*cmd* + *shift* + *A*（macOS），然后输入你正在寻找的操作名称。
- en: If you are using IntelliJ for the first time, I find it useful to display all
    tool buttons. Go to the View menu, and check Toolbar and Tool buttons.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次使用IntelliJ，我发现显示所有工具按钮很有用。转到视图菜单，勾选工具栏和工具按钮。
- en: SBT synchronization
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT同步
- en: 'Now, let''s have a look at our build configuration. **SBT** (short for **Simple
    Build Tool**) is the *de facto* build tool in the Scala community. Double-click
    on `build.sbt`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的构建配置。**SBT**（简称**Simple Build Tool**）是Scala社区中的*事实上的*构建工具。双击`build.sbt`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file describes how SBT will compile, test, and deploy our project. For
    now, it is fairly simple.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件描述了SBT将如何编译、测试和部署我们的项目。目前，它相当简单。
- en: One important thing to keep in mind is that IntelliJ manages its own set of
    files to define a project structure. They are located in the `.idea` directory
    of your project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要事情是，IntelliJ管理自己的文件集来定义项目结构。它们位于你的项目`.idea`目录中。
- en: Whenever you change `build.sbt`, IntelliJ has to interpret the changes and translate
    them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你更改`build.sbt`时，IntelliJ都必须解释这些更改并将其翻译。
- en: 'For instance, If I change the Scala version to `2.12.3` and save (*Ctrl* +
    *S* or *cmd + S*), IntelliJ will propose to synchronize the changes or enable
    autoimport:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我将Scala版本更改为`2.12.3`并保存（*Ctrl* + *S* 或 *cmd + S*），IntelliJ将建议同步更改或启用自动导入：
- en: '![](img/f62ef11e-9c53-4824-8565-37ed0b176394.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f62ef11e-9c53-4824-8565-37ed0b176394.png)'
- en: On a small project, it is ok to use autoimport, but on a large one, it can be
    a bit annoying. The synchronization can take time and it might kick off too often.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个小型项目中，使用自动导入是可以的，但在大型项目中，可能会有些烦人。同步可能需要时间，并且可能会过于频繁地启动。
- en: 'When you program in Scala using IntelliJ, you therefore have two ways of compiling
    your project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你使用IntelliJ在Scala中编程时，你有两种编译项目的方式：
- en: SBT, in which case you would only use IntelliJ as an advanced text editor
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用SBT，那么你将只使用IntelliJ作为高级文本编辑器
- en: IntelliJ
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ
- en: 'You could, in theory, mix and match: start building with SBT and continue with
    IntelliJ or the other way around. However, I strongly discourage you to do so,
    as you may get some unexpected compilation errors. When you want to switch to
    one tool or the other, it is best to clean all compiled files first.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以混合搭配：开始使用SBT，然后继续使用IntelliJ或反之亦然。然而，我强烈不建议这样做，因为你可能会遇到一些意外的编译错误。当你想切换到某个工具时，最好先清理所有编译文件。
- en: We will further expand on SBT later in this book, but for now, we are only going
    to use IntelliJ's own build.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面进一步介绍SBT，但到目前为止，我们只将使用IntelliJ自带的构建。
- en: Build
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'The project has been created and ready to be built. The build process does
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已创建并准备好构建。构建过程执行以下操作：
- en: Compiles the source files present at the source path and the test path
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译源路径和测试路径中存在的源文件
- en: Copies any resource files needed in the output path
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制输出路径中需要的任何资源文件
- en: Reports any errors/warnings in the Message tool window
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息工具窗口中报告任何错误/警告
- en: 'There are two ways to build the project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以构建项目：
- en: If you want to build your project incrementally, go to Build | Build Project
    (*Ctrl* + *F9* or *cmd + F9*)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要增量构建你的项目，请转到构建 | 构建项目 (*Ctrl* + *F9* 或 *cmd + F9*)
- en: If you want to delete all files and rebuild everything, go to Build | Rebuild
    All
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要删除所有文件并重新构建一切，请转到构建 | 重新构建所有
- en: As we do not have a source yet, the build is fast and no errors should appear
    in the Message tool window.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有源代码，构建过程很快，消息工具窗口中不应出现错误。
- en: Running the Scala Console
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Scala控制台
- en: 'In IntelliJ, you need to have a run configuration whenever you want to run
    something: a program, a unit test, an external tool. A run configuration sets
    up the classpath, arguments, and environment variables that you need to run your
    executable.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ中，每次你想运行某些内容时：一个程序、一个单元测试、一个外部工具，都需要有一个运行配置：一个运行配置设置了运行可执行文件所需的类路径、参数和环境变量。
- en: 'We need to create a run configuration the first time we want to run the Scala
    console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次想要运行Scala控制台时，需要创建一个运行配置：
- en: 'Go to Run | Edit Configurations. Click on the green + button, and select Scala
    Console. You should see the following screen:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到运行 | 编辑配置。点击绿色+按钮，选择Scala控制台。你应该看到以下屏幕：
- en: '![](img/8049a3f1-7e63-45fe-9b26-d5b846ac03f8.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8049a3f1-7e63-45fe-9b26-d5b846ac03f8.png)'
- en: 'Make the following changes and click OK:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下更改并点击确定：
- en: 'Name: `Scala Console`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`Scala Console`。
- en: Check Single instance only box – we rarely need to have two consoles running
    at the same time.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择仅单实例复选框 - 我们很少需要同时运行两个控制台。
- en: In, Before launch, click on Build and then click the Remove button. This way,
    you will always be able to quickly run a console, even if your code does not compile.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发射前，点击构建，然后点击移除按钮。这样，即使你的代码无法编译，你也能快速运行控制台。
- en: Following that, click on OK.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后，点击确定。
- en: 'On the top toolbar, you should see that IntelliJ created a new Scala Console
    run configuration:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部工具栏上，你应该看到IntelliJ创建了一个新的Scala控制台运行配置：
- en: '![](img/eeec9bab-77cb-48e5-94f3-05d35ba0675a.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eeec9bab-77cb-48e5-94f3-05d35ba0675a.png)'
- en: 'Click on the green arrow to run the console. You should see the following at
    the bottom of the screen, in the Run window. We can now type our first Scala expression
    after the Scala prompt:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色箭头以运行控制台。你应该在屏幕底部的运行窗口中看到以下内容：我们现在可以在Scala提示符后输入我们的第一个Scala表达式：
- en: '![](img/1dff86a2-f0aa-448a-9dcd-af955adf5c0f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1dff86a2-f0aa-448a-9dcd-af955adf5c0f.png)'
- en: Using the Scala Console and Worksheet
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scala控制台和工作表
- en: By now, all the necessary tools and libraries should be installed. Let's start
    to play with the basics of Scala by experimenting in different environments. The
    simplest way to try Scala is to use the Scala Console. Subsequently, we will introduce
    the Scala Worksheet, which allows you to keep all the instructions that are entered
    in a file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有必要的工具和库都应该已经安装。让我们通过在不同的环境中进行实验来开始玩Scala的基础。尝试Scala最简单的方法是使用Scala控制台。随后，我们将介绍Scala工作表，它允许你将输入的所有指令保存在一个文件中。
- en: Using the Scala Console
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scala控制台
- en: The Scala console, also called Scala **REPL** (short for **Read-Eval-Print-Loop**),
    allows you to execute bits of code without having to compile them beforehand.
    It is a very convenient tool to experiment with the language or when you want
    to explore the capabilities of a library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Scala控制台，也称为Scala **REPL**（代表**读取-评估-打印-循环**），允许你执行代码片段，而无需事先编译。这是一个非常方便的工具，用于实验语言或当你想探索库的功能时。
- en: 'In the console, type `1+1` after the `scala>` prompt and hit *Ctrl* + *Enter*
    or *cmd + Enter*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，在`scala>`提示符后输入`1+1`并按*Ctrl* + *Enter*或*cmd + Enter*：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The console displays the result of the evaluation, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示评估结果，如下所示：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What happened here? The REPL compiled, evaluated the expression `1+1`, and automatically
    assigned it to a variable named `res0`. This variable is of type `Int`, and its
    value is `2`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？REPL编译了表达式`1+1`，并自动将其赋值给名为`res0`的变量。这个变量的类型是`Int`，其值是`2`。
- en: Declaring variables
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量
- en: In Scala, a variable can be declared using `val` or `var`. A `val` is **immutable**,
    which means you can never change its value. A var is **mutable**. It is not mandatory
    to declare the type of the variable. If you do not declare it, Scala will **infer** it
    for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，可以使用`val`或`var`声明变量。`val`是**不可变的**，这意味着你永远不能改变它的值。`var`是**可变的**。声明变量的类型不是强制性的。如果你没有声明它，Scala会为你**推断**它。
- en: 'Let''s define some immutable variables:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些不可变变量：
- en: In all the following code examples, you only need to type the code that is after
    the Scala Command Prompt, and hit *Ctrl* + *Enter* or *cmd + return* to evaluate.
    We show the result of the evaluation underneath the prompt, as it would appear
    on your screen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有以下代码示例中，你只需要输入Scala命令提示符后面的代码，然后按*Ctrl* + *Enter*或*cmd + return*来评估。我们将在提示符下方显示评估结果，就像它出现在你的屏幕上一样。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In both cases, the type of the variable is `Int`. The type of `x` was inferred
    by the compiler to be `Int`. The type of `y` was explicitly specified with `:
    Int` after the name of the variable.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '在这两种情况下，变量的类型都是`Int`。编译器推断出`x`的类型是`Int`。`y`的类型通过变量名后的`: Int`显式指定。'
- en: 'We can define a mutable variable and modify it as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个可变变量并按以下方式修改它：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is a good practice to use `val` in most situations. Whenever I see a `val`
    declared, I know that its content will never change subsequently. It helps to
    reason about a program, especially when multiple threads are running. You can
    share an immutable variable across multiple threads without fearing that one thread
    might see a different value at some point. Whenever you see a Scala program using
    `var`, it should make you raise an eyebrow: **the programmer should have a good
    reason to use a mutable variable, and it should be documented**.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下使用`val`是一个好习惯。每当我看到声明了`val`，我就知道其内容将不会随后的改变。这有助于对程序进行推理，尤其是在多线程运行时。你可以在多个线程之间共享不可变变量，而不必担心某个线程可能会在某个时刻看到不同的值。每当你在Scala程序中看到`var`时，它应该让你皱眉：**程序员应该有很好的理由使用可变变量，并且应该进行文档记录**。
- en: 'If we attempt to modify a `val`, the compiler will raise an error message:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试修改一个`val`，编译器将抛出一个错误信息：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a good thing: the compiler helps us make sure that no piece of code
    can ever modify a `val`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事：编译器帮助我们确保没有任何代码片段可以修改一个`val`。
- en: Types
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: We saw in the previous examples that Scala expressions have a **type**. For
    instance, the **value** `1` is of type `Int`, and the expression `1+1` is also
    of type `Int`. A type is a classification of data and provides a finite or infinite
    set of values. An expression of a given type can take any of its provided values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了Scala表达式有**类型**。例如，**值**`1`是`Int`类型，表达式`1+1`也是`Int`类型。类型是数据的分类，提供有限或无限值的集合。给定类型的表达式可以取其提供的任何值。
- en: 'Here are a few examples of types available in Scala:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Scala中可用的一些类型的示例：
- en: '`Int` provides a finite set of values, which are all the integers between -2^(31)
    and 2^(31)-1.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`提供有限值的集合，这些值是介于-2^(31)和2^(31)-1之间的所有整数。'
- en: '`Boolean` provides a finite set of two values: `true` and `false`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`提供有限值的集合：`true`和`false`。'
- en: '`Double` provides a finite set of values: all the 64 bits and IEEE-754 floating
    point numbers.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double`提供有限值的集合：所有64位和IEEE-754浮点数。'
- en: '`String` provides an infinite set of values: all the sequence of characters
    are of an arbitrary length. For instance, `"Hello World"` or `"Scala is great
    !"`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`提供无限值的集合：所有任意长度的字符序列。例如，`"Hello World"`或`"Scala is great !"`。'
- en: 'A type determines the operations that can be performed on the data. For instance,
    you can use the `+` operator with two expressions of type `Int` or `String`, but
    not with expressions of type `Boolean`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类型决定了可以对数据进行哪些操作。例如，你可以使用`+`运算符与类型为`Int`或`String`的两个表达式一起使用，但不能与类型为`Boolean`的表达式一起使用：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we attempt to use an operation on a type that does not support it, the
    Scala compiler complains of a type mismatch error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对一个不支持该操作的类型使用操作时，Scala编译器会报类型不匹配错误。
- en: An important feature of Scala is that it is a statically typed language. This
    means that the type of a variable or expression is known at compile time. The
    compiler will also check that you do not call an operation or function that is
    not legal for this type. This helps tremendously to reduce the number of bugs
    that can occur at **runtime** (when running a program).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的重要特性之一是它是一种静态类型语言。这意味着变量或表达式的类型在编译时是已知的。编译器还会检查你是否调用了不适用于此类型的操作或函数。这极大地减少了在
    **运行时**（程序运行时）可能出现的错误数量。
- en: As we saw earlier, the type of an expression can be specified explicitly with
    `:` followed by the name of the type, or in many cases, it can be automatically
    inferred by the compiler.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，表达式的类型可以通过冒号 `:` 后跟类型名称来显式指定，或者在许多情况下，编译器可以自动推断出来。
- en: If you are not used to working with statically typed languages, you might get
    frustrated to have to fight with the compiler to make it accept your code, but
    you will gradually get more accustomed to the kind of errors thrown at you and
    how to resolve them. You will soon find that the compiler is not an enemy that
    prevents you from running your code; it is acting more like a good friend that
    shows you what logical errors you have made and gives you some indication on how
    to resolve them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不习惯使用静态类型语言，你可能会对与编译器斗争以使其接受你的代码感到沮丧，但你会逐渐习惯于你遇到的错误类型以及如何解决它们。你很快会发现，编译器不是一个阻止你运行代码的敌人；它更像是一个好朋友，它会指出你犯的逻辑错误，并给你一些如何解决的提示。
- en: People coming from dynamically typed languages such as Python, or people coming
    from not-as-strongly statically typed language such as Java or C++, are often
    astonished to see that a Scala program that compiles has a much higher probability
    of being correct on the first run.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 来自动态类型语言，如 Python，或来自不那么强静态类型语言，如 Java 或 C++ 的人，往往会惊讶地发现，一个编译过的 Scala 程序在第一次运行时出现错误的概率要低得多。
- en: IntelliJ can automatically add the inferred type to your definitions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 可以自动将推断的类型添加到你的定义中。
- en: 'For instance, type `val a = 3` in the Scala console, then move the cursor at
    the beginning of the `a`. You should see a light bulb icon. When you click on
    it, you will see a hint *add type annotation to value definition*. Click on it,
    and IntelliJ will add `: Int` after the `a`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，在 Scala 控制台中输入 `val a = 3`，然后将光标移到 `a` 的开头。你应该看到一个灯泡图标。当你点击它时，你会看到一个提示 *为值定义添加类型注解*。点击它，IntelliJ
    将在 `a` 后面添加 `: Int`。'
- en: 'Your definition will become `val a: Int = 3`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '你的定义将变为 `val a: Int = 3`。'
- en: Declaring and calling functions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和调用函数
- en: 'A Scala function takes *0* to *n* **parameters** and returns a value. The type
    of each parameter must be declared. The type of the returned value is optional,
    as it is inferred by the Scala compiler when not specified. However, it is a good
    practice to always specify the return type, as it makes the code more readable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 函数可以接受从 *0* 到 *n* 个 **参数** 并返回一个值。每个参数的类型必须声明。返回值的类型是可选的，因为 Scala 编译器在未指定时可以推断出来。然而，始终指定返回类型是一种良好的做法，因为它使代码更易于阅读：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can call a function by passing arguments in the right order, but we can also
    name the arguments and pass them in any order. It is a good practice to name the
    arguments when some of them have the same type, or when a function takes many
    arguments. It avoids passing the wrong argument and improves readability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过按正确的顺序传递参数来调用函数，但也可以命名参数并以任何顺序传递它们。当一些参数具有相同的类型，或者函数接受许多参数时，命名参数是一种良好的做法。这可以避免传递错误的参数并提高可读性。
- en: Side effects
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: A function or expression is said to have a side effect when it modifies some
    state or has some action in the outside world. For instance, printing a string
    to the console, writing to a file, and modifying a `var`, are all side effects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数或表达式修改某些状态或对外部世界有某些作用时，我们称它具有副作用。例如，将字符串打印到控制台、写入文件和修改 `var` 都是副作用。
- en: 'In Scala, all expressions have a type. A statement which performs a side effect
    is of type `Unit`. The only value provided by the type `Unit` is `()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，所有表达式都有一个类型。执行副作用（side effect）的语句类型为 `Unit`。`Unit` 类型提供的唯一值是 `()`：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A pure function is a function whose result depends only on its arguments, and
    that does not have any observable side effect. Scala allows you to mix side-effecting
    code with pure code, but it is a good practice to push side-effecting code to
    the boundaries of your application. We will talk about this later in more detail
    in the *Ensuring referential transparency* section in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml),
    *Handling Errors*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个结果只依赖于其参数，并且没有可观察副作用的函数。Scala 允许你混合副作用代码和纯代码，但将副作用代码推到应用程序的边界是一个好的实践。我们将在第
    3 章 *确保引用透明性* 部分中更详细地讨论这一点，*处理错误*。
- en: 'Good practice: When a function with no parameters has side effects, you should
    declare it and call it with empty brackets `()`. It informs users of your function
    that it has side effects. Conversely, a pure function with no parameters should
    not have empty brackets, and should not be called with empty brackets. IntelliJ
    helps you in keeping some consistency: it will display a warning if you call a
    parameterless function with `()`, or if you omit the `()` when you call a function
    declared with `()`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践：当一个没有参数的函数有副作用时，你应该声明它，并用空括号 `()` 调用它。这会通知用户你的函数有副作用。相反，没有参数的纯函数不应该有空括号，也不应该用空括号调用。IntelliJ
    帮助你保持一致性：如果你用 `()` 调用一个无参数函数，或者如果你在调用声明为 `()` 的函数时省略了 `()`，它将显示警告。
- en: 'Here is an example of a method call with a side effect where we have to use
    empty brackets, and an example of a pure function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有副作用的方法调用的例子，其中我们必须使用空括号，以及一个纯函数的例子：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If...else expression
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果...否则表达式
- en: 'In Scala, `if (condition) ifExpr else if ifExpr2 else elseExpr` is an expression,
    and has a type. If all sub-expressions have a type `A`, the type of the `if ...
    else` expression will be `A` as well:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，`if (condition) ifExpr else if ifExpr2 else elseExpr` 是一个表达式，并且具有类型。如果所有子表达式都具有类型
    `A`，则 `if ... else` 表达式的类型也将是 `A`：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If sub-expressions have different types, the compiler will infer a common super-type,
    or widen the type if it is a numeric type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子表达式有不同的类型，编译器将推断一个公共超类型，或者如果它是一个数值类型，则将其类型扩展：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first expression present in the preceding code, the first sub-expression
    is of type `Int` and the second is of type `Double`. The type of `ifElseWiden`
    is widened to be `Double`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中第一个表达式中，第一个子表达式是 `Int` 类型，第二个是 `Double` 类型。`ifElseWiden` 的类型被扩展为 `Double`。
- en: In the second expression, the type of `ifElseSupertype` is `Any`, which is the
    common super-type for `Int` and `String`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个表达式中，`ifElseSupertype` 的类型是 `Any`，这是 `Int` 和 `String` 的公共超类型。
- en: 'An `if` without an `else` is equivalent to `if (condition) ifExpr else ()`.
    It is better to always specify the `else` expression, otherwise, the type of the
    `if`/`else` expression might not be the one we expect:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `else` 的 `if` 等价于 `if (condition) ifExpr else ()`。最好总是指定 `else` 表达式，否则 `if`/`else`
    表达式的类型可能不是我们所期望的：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the common super-type between `Int` and `Unit` is `AnyVal`. This
    can be a bit surprising. In most situations, you would want to avoid that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Int` 和 `Unit` 之间的公共超类型是 `AnyVal`。这可能会让人有些惊讶。在大多数情况下，你可能会想要避免这种情况。
- en: Class
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'We mentioned earlier that all Scala expressions have a type. A `class` is a
    sort of template that can create objects of a specific type. When we want to obtain
    a value of a certain type, we can **instantiate** a new **object** using `new`
    followed by the class name:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，所有 Scala 表达式都有类型。`class` 是一种可以创建特定类型对象的模板。当我们想要获得某种类型的值时，我们可以使用 `new`
    后跟类名来 **实例化** 一个新的 **对象**：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The instantiation of an object allocates a portion of **heap** memory in the
    JVM. In the preceding example, the value `nao` is actually a **reference** to
    the portion of heap memory that keeps the content of our new `Robot` object. You
    can observe that when the Scala console printed the variable `nao`, it outputted
    the name of the class, followed by `@78318ac2`. This hexadecimal number is, in
    fact, the memory address of where the object is stored in the heap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的实例化在 JVM 中分配了一部分 **堆** 内存。在先前的例子中，值 `nao` 实际上是新 `Robot` 对象内容所保持的堆内存部分的 **引用**。你可以观察到，当
    Scala 控制台打印变量 `nao` 时，它输出了类的名称，后面跟着 `@78318ac2`。这个十六进制数实际上是对象在堆中存储的内存地址。
- en: 'The `eq` operator can be handy to check if two references are equal. If they
    are equal, this means that they point to the same portion of memory:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq` 运算符可以用来检查两个引用是否相等。如果它们相等，这意味着它们指向相同的内存部分：'
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A class can have zero to many **members**. A member can be either:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有零个或多个**成员**。一个成员可以是：
- en: An **attribute**, also called a **field**. It is a variable whose content is
    unique to each instance of the class.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**属性**，也称为**字段**。它是一个变量，其内容对类的每个实例都是唯一的。
- en: A **method**. This is a function that can read and/or write the attributes of
    the instance. It can have additional parameters.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**方法**。这是一个可以读取和/或写入实例属性的函数。它可以有额外的参数。
- en: 'Here is a class that defines a few members:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个定义了一些成员的类：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The attributes declared inside the brackets `()` are a bit special: they are
    **constructor arguments**, which means that their value must be specified when
    we instantiate a new object of the class. The other members must be defined inside
    the curly brackets `{}`. In our example, we defined four members:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号 `()` 内声明的属性有些特殊：它们是**构造函数参数**，这意味着在实例化类的新对象时必须指定它们的值。其他成员必须在花括号 `{}` 内定义。在我们的例子中，我们定义了四个成员：
- en: 'Two attributes that are constructor arguments: `width` and `height`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个构造函数参数属性：`width` 和 `height`。
- en: One attribute, `area`. Its value is defined when an instance is created by using
    the other attributes.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个属性，`area`。它的值是在使用其他属性创建实例时定义的。
- en: One method, `scale`, which uses the attributes to create a new instance of the
    class `Rectangle`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `scale` 的方法，它使用属性来创建类 `Rectangle` 的新实例。
- en: 'You can call a member on an instance of a class by using the **postfix** notation
    `myInstance.member`. Let''s create a few instances of our class and try to call
    the members:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用**后缀**表示法 `myInstance.member` 来调用类的一个实例的成员。让我们创建我们类的一些实例并尝试调用这些成员：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can call the members `area` and `scale`, but not `width`. Why is that?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用 `area` 和 `scale` 成员，但不能调用 `width`。为什么？
- en: 'This is because, by default, constructor arguments are not accessible from
    the outside world. They are private to the instance and can only be accessed from
    the other members. If you want to make the constructor arguments accessible, you
    need to prefix them with `val`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，默认情况下，构造函数参数不可从外部访问。它们是实例的私有属性，只能从其他成员中访问。如果你想使构造函数参数可访问，你需要用 `val` 前缀：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, we can get access to the constructor arguments. Note that you can
    declare attributes using `var` instead of `val`. This would make your attribute
    modifiable. However, in functional programming, we avoid mutating variables. A
    `var` attribute in a class is something that should be used cautiously in specific
    situations. An experienced Scala programmer would flag it immediately in a code
    review and its usage should be always justified in a code comment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以访问构造函数参数。请注意，你可以使用 `var` 而不是 `val` 来声明属性。这将使你的属性可修改。然而，在函数式编程中，我们避免修改变量。类中的
    `var` 属性在特定情况下应该谨慎使用。经验丰富的 Scala 程序员会在代码审查中立即标记它，并且其使用应该在代码注释中得到合理说明。
- en: If you need to modify an attribute, it is better to return a new instance of
    the class with the modified attribute, as we did in the preceding `Rectangle.scale` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要修改一个属性，最好是返回一个带有修改后属性的新类实例，就像我们在前面的 `Rectangle.scale` 方法中所做的那样。
- en: You might worry that all these new objects will consume too much memory. Fortunately,
    the JVM has a mechanism known as the **garbage collector**. It automatically frees
    up the memory used by objects that are not referenced by any variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心所有这些新对象会消耗太多内存。幸运的是，JVM 有一个称为**垃圾回收器**的机制。它会自动释放那些没有任何变量引用的对象所占用的内存。
- en: Using the worksheet
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作表
- en: 'IntelliJ offers another handy tool to experiment with the language: the Scala
    worksheet.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 提供了另一个方便的工具来实验语言：Scala 工作表。
- en: 'Go to File | New | Scala Worksheet. Name it `worksheet.sc`. You can then enter
    some code on the left-hand side of the screen. A red/green indicator in the top
    right corner shows you if the code you are typing is valid or not. As soon as
    it compiles, the results appear on the right-hand side:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前往文件 | 新建 | Scala 工作表。将其命名为 `worksheet.sc`。然后你可以在屏幕的左侧输入一些代码。右上角的红/绿指示器会显示你输入的代码是否有效。一旦编译成功，结果就会出现在右侧：
- en: '![](img/52041c53-eec6-4efb-a633-65534f6fad94.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52041c53-eec6-4efb-a633-65534f6fad94.png)'
- en: You will notice that nothing gets evaluated until your whole worksheet compiles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，直到整个工作表编译完成之前，没有任何东西会被评估。
- en: Class inheritance
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: Scala classes are extensible. You can extend an existing class to inherit from
    all its members. If `B` extends `A`, we say that `B` is a **subclass** of `A`,
    a **derivation** of `B`, or a **specialization** of `B`. `A` is a **superclass**
    of `B` or a **generalization** of `B`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Scala类是可扩展的。你可以扩展一个现有的类来继承其所有成员。如果`B`扩展了`A`，我们可以说`B`是`A`的**子类**，是`B`的**派生**，或者是`B`的**特殊化**。`A`是`B`的**超类**或`B`的**泛化**。
- en: 'Let''s see how it works in an example. Type the following code in the worksheet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子看看它是如何工作的。在工作表中输入以下代码：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The classes `Rectangle` and `Circle` are subclasses of `Shape`. They inherit
    from all the members of `Shape`: `x`, `y`, and `isAtOrigin`. This means that when
    I instantiate a new `Rectangle`, I can call members declared in `Rectangle`, such
    as `width` and `height`, and I can also call members declared in `Shape`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`和`Circle`类是`Shape`的子类。它们继承了`Shape`的所有成员：`x`、`y`和`isAtOrigin`。这意味着当我实例化一个新的`Rectangle`时，我可以调用在`Rectangle`中声明的成员，例如`width`和`height`，我也可以调用在`Shape`中声明的成员。'
- en: When declaring a subclass, you need to pass the constructor arguments of the
    superclass, as if you were instantiating it. As `Shape` declares two constructor
    parameters, `x` and `y`, we have to pass them in the declaration `extends Shape(x,
    y)`. In this declaration, `x` and `y` are themselves the constructor arguments
    of `Rectangle`. We just passed these arguments up the chain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个子类时，你需要传递超类的构造函数参数，就像你正在实例化它一样。由于`Shape`声明了两个构造函数参数，`x`和`y`，我们必须在声明`extends
    Shape(x, y)`中传递它们。在这个声明中，`x`和`y`本身是`Rectangle`的构造函数参数。我们只是将这些参数向上传递了链。
- en: Notice that in the subclasses, the constructor parameters `x` and `y` are declared
    without `val`. If we had declared them with `val`, they would have been promoted
    as publicly available attributes. The problem is that `Shape` also has `x` and
    `y` as public attributes. In this situation, the compiler would have raised a
    compilation error to highlight the conflict.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在子类中，构造函数参数`x`和`y`没有声明为`val`。如果我们用`val`声明它们，它们将被提升为公开可用的属性。问题是`Shape`也有`x`和`y`作为公开属性。在这种情况下，编译器会引发编译错误以突出显示冲突。
- en: Subclass assignment
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类赋值
- en: Consider two classes, `A` and `B`, with `B extends A`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个类，`A`和`B`，其中`B extends A`。
- en: 'When you declare a variable of type `A`, you can assign it to an instance of
    `B`, with `val a: A = new B`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '当你声明一个类型为`A`的变量时，你可以将它赋值给`B`的一个实例，使用`val a: A = new B`。'
- en: On the other hand, if you declare a variable of type `B`, you cannot assign
    it to an instance of `A`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你声明一个类型为`B`的变量，你不能将它赋值给`A`的一个实例。
- en: 'Here is an example that uses the same `Shape` and `Rectangle` definitions that
    were described earlier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用前面描述的相同`Shape`和`Rectangle`定义的例子：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line compiles because `Rectangle` **is a** `Shape`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行可以编译，因为`Rectangle`**是**一个`Shape`。
- en: The second line does not compile, because not all shapes are rectangles.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行无法编译，因为不是所有形状都是矩形。
- en: Overriding methods
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖方法
- en: 'When you derive a class, you can override the members of the superclass to
    provide a different implementation. Here is an example that you can retype in
    a new worksheet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你派生一个类时，你可以覆盖超类的成员以提供不同的实现。以下是一个你可以重新输入到新工作表中的例子：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run the worksheet, it evaluates and prints the following `description`
    on the right-hand side:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行工作表时，它会在右侧评估并打印以下`description`：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We defined a method `description` on the class `Shape` that returns a String.
    When we call `rect.description`, the method called is the one defined in the class
    `Rectangle`, because `Rectangle` overrides the method `description` with a different
    implementation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Shape`类上定义了一个名为`description`的方法，它返回一个String。当我们调用`rect.description`时，调用的是在`Rectangle`类中定义的方法，因为`Rectangle`用不同的实现覆盖了`description`方法。
- en: The implementation of `description` in the class `Rectangle` refers to `super.description`.
    `super` is a keyword that lets you use the members of the superclass without taking
    into account any overriding. In our case, this was necessary so that we could
    use the `super` reference, otherwise, `description` would have called itself in
    an infinite loop!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`类中`description`的实现引用了`super.description`。`super`是一个关键字，它让你可以使用超类的成员，而不考虑任何覆盖。在我们的情况下，这是必要的，这样我们才能使用`super`引用，否则`description`会陷入无限循环中调用自己！'
- en: 'On the other hand, the keyword `this` allows you to call the members of the
    same class. Change `Rectangle` to add the following methods:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，关键字`this`允许你调用同一类的成员。将`Rectangle`修改为添加以下方法：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you evaluate the worksheet, it prints the following strings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估工作表时，它打印以下字符串：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The call to `this.description` used the definition of `description`, as declared
    in the class `Rectangle`, whereas the call to `super.description` used the definition
    of `description`, as declared in the class `Shape`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.description`的调用使用了在`Rectangle`类中声明的`description`定义，而`super.description`的调用使用了在`Shape`类中声明的`description`定义。'
- en: Abstract class
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'An abstract class is a class that can have many abstract members. An **abstract
    member** defines only a signature for an attribute or a method, without providing
    any implementation. You cannot instantiate an abstract class: you must create
    a subclass that implements all the abstract members.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是一个可以有多个抽象成员的类。一个**抽象成员**只定义了一个属性或方法的签名，而不提供任何实现。你不能实例化一个抽象类：你必须创建一个子类来实现所有抽象成员。
- en: 'Replace the definition of `Shape` and `Rectangle` in the worksheet as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作表中的`Shape`和`Rectangle`的定义替换如下：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our class `Shape` is now abstract. We cannot instantiate a `Shape` class directly
    anymore: we have to create an instance of `Rectangle` or any of the other subclasses
    of `Shape`. `Shape` defines two concrete members, `x` and `y`, and two abstract
    members, `area` and `description`. The subclass, `Rectangle`, implements the two
    abstract members.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的类`Shape`现在是抽象的。我们不能再直接实例化一个`Shape`类了：我们必须创建一个`Rectangle`或`Shape`的其他子类的实例。`Shape`定义了两个具体成员，`x`和`y`，以及两个抽象成员，`area`和`description`。子类`Rectangle`实现了这两个抽象成员。
- en: You can use the prefix `override` when implementing an abstract member, but
    it is not necessary. I recommend **not** adding it to keep the code less cluttered.
    Also, if you subsequently implement the abstract method in the superclass, the
    compiler will help you find all subclasses that had an implementation. It will
    not do this if they use `override`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现抽象成员时，你可以使用前缀`override`，但这不是必要的。我建议**不要**添加它，以保持代码更简洁。此外，如果你随后在超类中实现了抽象方法，编译器将帮助你找到所有已实现该方法的子类。如果它们使用`override`，则不会这样做。
- en: Trait
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: 'A trait is similar to an abstract class: it can declare several abstract or
    concrete members and can be extended. It cannot be instantiated. The difference
    is that a given class can only extend one abstract class, however, it can **mixin**
    one to many traits. Also, a trait cannot have constructor arguments.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 特性类似于抽象类：它可以声明多个抽象或具体成员，并且可以被扩展。它不能被实例化。区别在于一个给定的类只能扩展一个抽象类，然而，它可以**混合**多个特性。此外，特性不能有构造函数参数。
- en: 'For instance, we can declare several traits, each declaring different abstract
    methods, and mixin them all in the `Rectangle` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以声明几个特性，每个特性声明不同的抽象方法，并将它们全部混合到`Rectangle`类中：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following string gets printed when evaluating `rect.description`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估`rect.description`时，打印以下字符串：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The class `Rectangle` mixes in the traits `Coordinates`, `Description`, and `Area`.
    We need to use the keyword `extends` before `trait` or `class`, and the keyword
    `with` for all subsequent traits.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Rectangle`混合了特性`Coordinates`、`Description`和`Area`。我们需要在`trait`或`class`之前使用关键字`extends`，并在所有后续特性中使用关键字`with`。
- en: Notice that the `Coordinates` trait also mixes the `Description` trait, and
    provides a default implementation. As we did when we had a `Shape` class, we override
    this implementation in `Rectangle`, and we can still call `super.description`
    to refer to the implementation of `description` in the `trait Coordinates`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Coordinates`特性也混合了`Description`特性，并提供了默认实现。正如我们在有`Shape`类时所做的，我们在`Rectangle`中覆盖了这个实现，我们仍然可以调用`super.description`来引用`trait
    Coordinates`中`description`的实现。
- en: 'Another interesting point is that you can implement an abstract method with `val` – in
    `trait Area`, we defined `def area: Double`, and implemented it in `Rectangle`
    using `val area: Double`. It is a good practice to define abstract members with
    `def`. This way, the implementer of the trait can decide whether to define it
    by using a method or a variable.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个有趣的观点是，你可以使用`val`来实现一个抽象方法——在`trait Area`中，我们定义了`def area: Double`，并在`Rectangle`中使用`val
    area: Double`实现了它。使用`def`定义抽象成员是一个好习惯。这样，特性的实现者可以决定是否使用方法或变量来定义它。'
- en: Scala class hierarchy
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala类层次结构
- en: 'All Scala types extend a built-in type called `Any`. This type is the root
    of the hierarchy of all Scala types. It has two direct subtypes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Scala类型都扩展了一个名为`Any`的内建类型。这个类型是所有Scala类型层次结构的根。它有两个直接子类型：
- en: '`AnyVal` is the root class of all value types. These types are represented
    as primitive types in the JVM.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyVal` 是所有值类型的根类。这些类型在 JVM 中表示为原始类型。'
- en: '`AnyRef` is the root class of all object types. It is an alias for the class
    `java.lang.Object`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyRef` 是所有对象类型的根类。它是 `java.lang.Object` 类的别名。'
- en: A variable of type `AnyVal` directly contains the value, whereas a variable
    of type `AnyRef` contains the address of an object stored somewhere in memory.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `AnyVal` 的变量直接包含值，而类型 `AnyRef` 的变量包含存储在内存中某个位置的对象的地址。
- en: 'The following diagram shows a partial view of this hierarchy:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了该层次结构的部分视图：
- en: '![](img/efce7006-377a-4192-8a78-3687ddd9ec87.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efce7006-377a-4192-8a78-3687ddd9ec87.png)'
- en: 'When you define a new class, it indirectly extends `AnyRef`. This being an
    alias for `java.lang.Object`, your class inherits from all the default methods
    implemented in `Object`. Its most important methods are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个新类时，它会间接扩展 `AnyRef`。由于这是一个 `java.lang.Object` 的别名，因此您的类继承了 `Object` 中实现的所有默认方法。它最重要的方法如下：
- en: '`def toString: String` returns a string representation of an object. This method
    is called whenever you print an object using `println`. The default implementation
    returns the class''s name followed by the address of the object in memory.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def toString: String` 返回对象的字符串表示形式。当您使用 `println` 打印对象时，会调用此方法。默认实现返回类的名称后跟对象在内存中的地址。'
- en: '`def equals(obj: Object): Boolean` returns `true` if the object is equal to
    another object, and `false` otherwise. This method is called whenever you compare
    two objects using `==`. The default implementation only compares the objects''
    references, and hence is equivalent to `eq`. Fortunately, most classes from the
    Java and Scala SDK override this method to provide a good comparison. For instance,
    the class `java.lang.String` overrides the `equals` method to compare the content
    of the strings, character by character. Therefore, when you compare two strings
    with `==`, the result will be `true` if the strings are the same, even if they
    are stored in different places in memory.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def equals(obj: Object): Boolean` 如果对象等于另一个对象，则返回 `true`，否则返回 `false`。当您使用
    `==` 比较两个对象时，会调用此方法。默认实现仅比较对象的引用，因此与 `eq` 等价。幸运的是，Java 和 Scala SDK 中的大多数类都重写了此方法以提供良好的比较。例如，`java.lang.String`
    类重写了 `equals` 方法以逐字符比较字符串的内容。因此，当您使用 `==` 比较两个字符串时，如果字符串相同，即使它们存储在内存中的不同位置，结果也将是
    `true`。'
- en: '`def hashCode: Int` is called whenever you put an object in `Set` or if you
    use it as a key in `Map`. The default implementation is based on the address of
    the object. You can override this method if you want to have a better distribution
    of the data in `Set` or `Map`, which can improve the performance of these collections.
    However, if you do so, you must make sure that `hashCode` is consistent with `equals`:
    if two objects are equal, their `hashCodes` must also be equal.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def hashCode: Int` 在您将对象放入 `Set` 或将其用作 `Map` 中的键时被调用。默认实现基于对象的地址。如果您想使 `Set`
    或 `Map` 中的数据分布更好，从而提高这些集合的性能，您可以重写此方法。但是，如果您这样做，您必须确保 `hashCode` 与 `equals` 一致：如果两个对象相等，它们的
    `hashCodes` 也必须相等。'
- en: It would be very tedious to have to override these methods for all your classes.
    Fortunately, Scala offers a special construct called `case class` that will automatically
    override these methods for us.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有类重写这些方法将会非常繁琐。幸运的是，Scala 提供了一个特殊的构造，称为 `case class`，它会自动为我们重写这些方法。
- en: Case class
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况类
- en: In Scala, we define most data structures using case classes. `case class` has
    one to many immutable attributes and provides several built-in functions compared
    to a standard class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，我们使用情况类定义大多数数据结构。`case class` 具有一到多个不可变属性，并且与标准类相比提供了几个内置函数。
- en: 'Type the following into the worksheet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容输入到工作表中：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, the text following `//` is a comment that explains the
    preceding statement.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`//` 后面的文本是一个注释，解释了前面的语句。
- en: When you declare a class as `case class`, the Scala compiler automatically generates
    a default constructor, an `equals` and `hashCode` method, a `copy` constructor,
    and an accessor for each attribute.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将类声明为 `case class` 时，Scala 编译器会自动生成默认构造函数、`equals` 和 `hashCode` 方法、`copy`
    构造函数以及每个属性的访问器。
- en: 'Here is a screenshot of the worksheet we have. You can see the results of the
    evaluations on the right-hand side:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们拥有的工作表的截图。您可以在右侧看到评估结果：
- en: '![](img/e1f72981-d0a7-419b-b270-6c8509386678.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1f72981-d0a7-419b-b270-6c8509386678.png)'
- en: Companion object
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴随对象
- en: A class can have a companion object. It must be declared in the same file as
    the class, using the keyword `object` followed by the name of the class it is
    accompanying. A companion object is a **singleton** – there is only one instance
    of this object in the JVM. It has its own type and is not an instance of the accompanied
    class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有一个伴随对象。它必须在与类相同的文件中声明，使用关键字 `object` 后跟伴随对象的名称。伴随对象是一个**单例** - 在JVM中只有一个此对象的实例。它有自己的类型，不是伴随类的实例。
- en: 'This object defines static functions or values that are closely related to
    the class it is accompanying. If you are familiar with Java, it replaces the keyword
    `static`: in Scala, all static members of a class are declared inside the companion
    object.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象定义了与伴随类紧密相关的静态函数或值。如果你熟悉Java，它替换了关键字 `static`：在Scala中，类的所有静态成员都在伴随对象中声明。
- en: 'Some functions in the companion object have a special meaning. Functions named
    `apply` are constructors of the class. The name `apply` can be omitted when we
    call them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象中的某些函数具有特殊含义。名为 `apply` 的函数是类的构造函数。当我们调用它们时，可以省略 `apply` 名称：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we defined a companion object for the class `City`, which
    defines some **constants**. The convention for constants is to have the first
    letter in uppercase.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `City` 类定义了一个伴随对象，它定义了一些**常量**。常量的约定是将第一个字母大写。
- en: The companion object for the class `Person` defines an additional `apply` function
    that acts as a constructor. Its implementation calls the method `split(" ")`,
    which splits a string separated by spaces to produce an array of type string.
    It allows us to construct a `Person` instance using a single string where the
    first name and last name are separated by a space. We then demonstrated that we
    can either call the default `apply` function that comes with the case class, or
    the one we implemented.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类的伴随对象定义了一个额外的 `apply` 函数，它充当构造函数。其实现调用方法 `split(" ")`，该方法将用空格分隔的字符串分割成字符串数组。它允许我们使用单个字符串来构造
    `Person` 实例，其中第一个名字和姓氏由空格分隔。然后我们演示了我们可以调用随case类提供的默认 `apply` 函数，或者我们实现的那个。'
- en: Creating my first project
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我的第一个项目
- en: As you now know the basics of running code in the REPL and the worksheet, it
    is time to create your first 'Hello World' project. In this section, we are going
    to filter a list of people and print their name and age into the console.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你已经掌握了在REPL和表格中运行代码的基础，现在是时候创建你的第一个“Hello World”项目了。在本节中，我们将过滤一组人员并将他们的姓名和年龄打印到控制台。
- en: Creating the project
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Repeat the same recipe that you completed in the *Installing IntelliJ* section
    to create a new project. Here is a summary of the tasks you must complete:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重复你在 *安装IntelliJ* 部分中完成的相同步骤来创建一个新项目。以下是你必须完成的任务摘要：
- en: Run IntelliJ and select Create New Project
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行IntelliJ并选择创建新项目
- en: Select Scala and sbt
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Scala和sbt
- en: Input the name of the project, such as `Examples`
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目的名称，例如 `Examples`
- en: If the selected directory doesn't exist, IntelliJ will ask you if you want to
    create it – select OK
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选定的目录不存在，IntelliJ会询问你是否想要创建它 - 选择“确定”
- en: As soon as you accept that you are going to create the directory, IntelliJ is
    going to download all the necessary dependencies and build the project structure.
    Be patient, as this could take a while, especially if you do not have a good internet
    connection.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你接受将创建目录，IntelliJ就会下载所有必要的依赖项并构建项目结构。请耐心等待，因为这可能需要一段时间，尤其是如果你没有良好的互联网连接。
- en: 'Once everything is downloaded, you should have your IDE in the following state:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一切下载完毕后，你的IDE应该处于以下状态：
- en: '![](img/9d4c33c6-bb33-49a3-a3bf-d3b602c8d889.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d4c33c6-bb33-49a3-a3bf-d3b602c8d889.png)'
- en: Notice the folder structure. The source code is under `src/main/scala` and the
    test code is under `src/test/scala`. If you have used Maven before, this structure
    should sound familiar.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件夹结构。源代码位于 `src/main/scala` 目录下，测试代码位于 `src/test/scala` 目录下。如果你之前使用过Maven，这种结构应该很熟悉。
- en: Creating the Main object
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Main对象
- en: Here we are! Let's create our first application. First, create the entry point
    for the program. If you are coming from Java, it would be equivalent to defining
    the `public static void main(String[] args)`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了！让我们创建我们的第一个应用程序。首先，创建程序的入口点。如果你来自Java，它相当于定义 `public static void main(String[]
    args)`。
- en: 'Right-click on the `src/main/scala` folder and select New | Scala Class. Give
    `Main` as the class name and `Object` as the Kind:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 `src/main/scala` 文件夹，然后选择 New | Scala Class。将类名命名为 `Main`，将类型设置为 `Object`：
- en: '![](img/4445c695-e866-4165-a4e7-d2fe6d25fb2e.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4445c695-e866-4165-a4e7-d2fe6d25fb2e.png)'
- en: We have created our first object. This object is a singleton. There can be only
    one instance of it in the JVM. The equivalent in Java would be a static class
    with static methods.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了第一个对象。这个对象是一个单例。在 JVM 中只能有一个实例。在 Java 中的等效物是一个具有静态方法的静态类。
- en: 'We would like to use it as the main entry point of our program. Scala provides
    a convenient class named `App` that needs to be extended. Let''s extend our `Main`
    object with that class:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将其用作程序的主要入口点。Scala 提供了一个方便的名为 `App` 的类，需要对其进行扩展。让我们用这个类扩展我们的 `Main` 对象：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `App` superclass defines a static `main` method that will execute all the
    code defined inside your `Main` object. That's all – we created our first version,
    which does nothing!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 超类定义了一个静态的 `main` 方法，它将执行您在 `Main` 对象内部定义的所有代码。就这样——我们创建了第一个版本，它什么也不做！'
- en: 'We can now run the program in IntelliJ. Click on the small green triangle in
    the gutter of the object definition, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 IntelliJ 中运行程序。如下所示，点击对象定义区域中的小绿色三角形：
- en: '![](img/061b5895-ab23-4769-a0a9-277cc6d46c22.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/061b5895-ab23-4769-a0a9-277cc6d46c22.png)'
- en: 'The program gets compiled and executed, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被编译并执行，如下面的截图所示：
- en: '![](img/e1c01182-986e-4739-ad94-9c6b0e209fe5.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1c01182-986e-4739-ad94-9c6b0e209fe5.png)'
- en: It is not spectacular, but let's improve it. To get the right habits, we are
    going to use the **TDD** technique to proceed further.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不引人注目，但让我们来改进它。为了养成正确的习惯，我们将使用**TDD**技术来进一步进行。
- en: Writing the first unit test
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一个单元测试
- en: 'TDD is a very powerful technique to write efficient, modular, and safe programs.
    It is very simple, and there are only three rules to play this game:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种非常强大的技术，可以编写高效、模块化和安全的程序。它非常简单，玩这个游戏只有三条规则：
- en: You are not allowed to write any production code unless it is to make a failing
    unit test pass.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非是为了使失败的单元测试通过，否则不允许编写任何生产代码。
- en: You are not allowed to write any more of a unit test than is sufficient to fail,
    and compilation failures are failures.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您不允许编写比足以失败的单元测试更多的代码，编译失败也是失败。
- en: You are not allowed to write any more production code than is sufficient to
    pass the one failing unit test.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您不允许编写比通过一个失败的单元测试所需的生产代码更多的代码。
- en: 'See the full article from Uncle Bob here: [http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以查看 Bob Uncle 的完整文章：[http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)。
- en: There are multiple testing frameworks in Scala, but we chose ScalaTest ([http://www.scalatest.org/](http://www.scalatest.org/))
    for its simplicity.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中有多个测试框架，但我们选择了 ScalaTest ([http://www.scalatest.org/](http://www.scalatest.org/))，因为它简单。
- en: 'In order to add the ScalaTest library in the project, follow these steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在项目中添加 ScalaTest 库，请按照以下步骤操作：
- en: Edit the `build.sbt` file.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `build.sbt` 文件。
- en: Add a new repository resolver to search for Scala libraries.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的仓库解析器以搜索 Scala 库。
- en: 'Add the ScalaTest library:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 ScalaTest 库：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice the information bar on the top of the screen. It tells you that your
    file has changed and asks for multiple choices. As this is a small project, you
    can select **enable autoimport**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意屏幕顶部的信息栏。它告诉您文件已更改，并要求进行多项选择。由于这是一个小型项目，您可以选择**启用自动导入**。
- en: Create the test class by right-clicking on the `test/scala` folder and clicking
    on create a new class. Name it `MainSpec`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击 `test/scala` 文件夹并创建一个新类来创建测试类。将其命名为 `MainSpec`。
- en: ScalaTest offers multiple ways to define your test – the full list can be found
    on the official website ([http://www.scalatest.org/at_a_glance/WordSpec](http://www.scalatest.org/at_a_glance/WordSpec)).
    We are going to use the `WordSpec` style since it is quite prescriptive, offers
    a hierarchical structure, and is commonly used on large Scala projects.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaTest 提供了多种定义测试的方法——完整的列表可以在官方网站上找到 ([http://www.scalatest.org/at_a_glance/WordSpec](http://www.scalatest.org/at_a_glance/WordSpec))。我们将使用
    `WordSpec` 风格，因为它相当具体，提供了层次结构，并且在大型 Scala 项目中常用。
- en: 'Your `MainSpec` should extend the `WordSpec` class and the `Matchers` class,
    like so:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `MainSpec` 应该扩展 `WordSpec` 类和 `Matchers` 类，如下所示：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The class `Matchers` is providing the word `should` as a keyword to perform
    the comparison on a test.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matchers`类提供了`should`这个关键字来在测试中执行比较。'
- en: '`WordSpec` and `Matchers` are underlined in red, which means that the class
    is not resolved. To make it resolved, go with the cursor on the class and press
    *Alt* + *Enter* of your keyboard. If you are positioned on the `WordSpec` word,
    a popup should appear. This is normal, as there are several classes named `WordSpec`
    in different packages:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordSpec`和`Matchers`被红色下划线标注，这意味着类没有被解析。要使其解析，将光标移至类上，并按键盘上的*Alt* + *Enter*。如果你位于`WordSpec`这个词上，应该会出现一个弹出窗口。这是正常的，因为不同包中存在多个名为`WordSpec`的类：'
- en: '![](img/1d0292f5-2ed4-4cc9-8eb7-12a507cafe24.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d0292f5-2ed4-4cc9-8eb7-12a507cafe24.png)'
- en: Select the first option and IntelliJ will automatically add the import on the
    top of your code. On the `Matchers` class, as soon as you type *Alt* + *Enter*,
    the import will be added directly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第一个选项，IntelliJ会自动在代码顶部添加导入。在`Matchers`类中，只要你输入*Alt* + *Enter*，就会直接添加导入。
- en: 'The final code should be as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码应该如下所示：
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our class skeleton is now ready for our first test. We would like to create
    the `Person` class and test its constructor.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的课程框架现在为我们的第一个测试做好了准备。我们想要创建`Person`类并测试其构造函数。
- en: 'Let''s explain what we would like to test using simple sentences. Complete
    the test class with the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用简单的句子解释我们想要测试的内容。用以下代码完成测试类：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: IntelliJ is complaining that it cannot resolve the symbols `Person`, `name`,
    `surname`, and `age`. This is expected since the `Person` class does not exist.
    Let's create it in the folder `src/main/scala`. Right-click on the folder and
    create a new class named `Person`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ抱怨它无法解析符号`Person`、`name`、`surname`和`age`。这是预期的，因为`Person`类不存在。让我们在`src/main/scala`文件夹中创建它。右键单击文件夹，创建一个名为`Person`的新类。
- en: 'Transform it in the case of the class by adding the `case` keyword and defining
    the constructor with the `name`, `surname`, and `age`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的情况下，通过添加`case`关键字并使用`name`、`surname`和`age`定义构造函数来转换它：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you go back to the `MainSpec.scala` file, you'll notice that the class is
    now compiled without any error and warning. The green tick (![](img/9f8ce7bf-9938-4c7d-9407-5956acda33e4.png))
    on the top-right of the code window confirms this.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到`MainSpec.scala`文件，你会注意到类现在编译时没有任何错误和警告。代码窗口右上角的绿色勾号(![](img/9f8ce7bf-9938-4c7d-9407-5956acda33e4.png))确认了这一点。
- en: 'Run the test by right-clicking on the `MainSpec.scala` file and selecting `Run
    ''MainSpec''`, or use the keyboard shortcut *Ctrl* + *Shift* + *F10* or *Ctrl
    + Shift + R*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击`MainSpec.scala`文件并选择`Run 'MainSpec'`或使用键盘快捷键*Ctrl* + *Shift* + *F10*或*Ctrl
    + Shift + R*来运行测试：
- en: '![](img/23c5dc20-e039-4e05-9e54-47620e355584.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23c5dc20-e039-4e05-9e54-47620e355584.png)'
- en: 'The test contained in `MainSpec` runs and the results appear in the Run window:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainSpec`中的测试运行，结果出现在运行窗口中：'
- en: '![](img/40f72e70-ebe3-4992-88c3-66a60fc9d9c0.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40f72e70-ebe3-4992-88c3-66a60fc9d9c0.png)'
- en: Implementing another feature
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现另一个功能
- en: 'Now, we would like to have a nice representation of the person by stating his/her
    name and age. The test should look like the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要通过说明他的/她的姓名和年龄来有一个关于这个人的良好表示。测试应该看起来像以下这样：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the test again. We will get a compilation error:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。我们将得到一个编译错误：
- en: '![](img/083f47c0-b6db-4aa9-bbb2-69f5aa4eb291.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/083f47c0-b6db-4aa9-bbb2-69f5aa4eb291.png)'
- en: This is expected as the function doesn't exist on the `Person` class. To implement
    it, add the expected implementation by setting the cursor on the `description()`
    error in the `MainSpec.scala` class, hitting *Alt* + *Enter*, and selecting the
    create method description.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为`Person`类中不存在这个函数。要实现它，在`MainSpec.scala`类中的`description()`错误上设置光标，按*Alt*
    + *Enter*，并选择创建方法描述。
- en: 'IntelliJ generates the method for you and sets the implementation to `???`.
    Replace `???` with the expected code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ为你生成方法并设置实现为`???`。将`???`替换为预期的代码：
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By doing so, we defined a method that does not take any parameter and return
    a string representing `Person`. In order to simplify the code, we are using a
    **string interpolation** to build the string. To use string interpolation, you
    just have to prepend an `s` before the first quote. Inside the quote, you can
    use the wildcard `$` so that we can use an external variable and use the bracket
    after the dollar sign to enter more code than just a variable name.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们定义了一个不接受任何参数并返回表示 `Person` 的字符串的方法。为了简化代码，我们使用 **字符串插值** 来构建字符串。要使用字符串插值，只需在第一个引号前加上
    `s`。在引号内，您可以使用通配符 `$`，这样我们就可以使用外部变量，并在美元符号后使用括号来输入比变量名更多的代码。
- en: 'Execute the test and the result should be green:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试，结果应该是绿色的：
- en: '![](img/1f693679-234a-4b66-be9f-6a8d605365ad.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f693679-234a-4b66-be9f-6a8d605365ad.png)'
- en: The next step is to write a utility function that, given a list of people, returns
    only the adults.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写一个实用函数，给定一个人员列表，只返回成年人。
- en: 'For the tests, two cases are defined:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，定义了两个情况：
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we used a tuple to define three variables. This is a convenient way to
    define multiple variables. The scope of the variables is bounded by the enclosing
    curly brackets.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用元组定义了三个变量。这是一种方便定义多个变量的方式。变量的作用域由包围的括号限制。
- en: Use IntelliJ to create the `filterAdult` function by using the *Alt*+ *Enter*
    shortcut. The IDE understands that the function should be in the `Person` companion
    object and generates it for you.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IntelliJ 通过 *Alt* + *Enter* 快捷键创建 `filterAdult` 函数。IDE 会理解该函数应该位于 `Person`
    伴生对象中，并为您生成它。
- en: 'If you didn''t use the named parameters and would like to use them, IntelliJ
    can help you: hit *Alt* + *Enter* when the cursor is after the parenthesis and
    select "used named arguments ...".'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用命名参数并希望使用它们，IntelliJ 可以帮助您：当光标在括号后时，按 *Alt* + *Enter* 并选择 "使用命名参数 ...".
- en: 'We implement this method using the `for` **comprehension** Scala feature:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Scala 的 `for` **推导** 功能来实现此方法：
- en: '[PRE40]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is a good practice to define the return type of the method, especially when
    this method is exposed as a public API.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方法的返回类型是一个好习惯，特别是当这个方法作为公共 API 公开时。
- en: 'The `for` comprehension has been used only for demonstration purposes. We can
    simplify it using the `filter` method on `List`. `filter` is part of the Scala
    Collections API and is available for many kinds of collections:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 推导仅用于演示目的。我们可以使用 `List` 上的 `filter` 方法来简化它。`filter` 是 Scala 集合 API 的一部分，并且适用于许多类型的集合：'
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Implementing the Main method
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Main 方法
- en: 'Now that all our tests are green, we can implement the `main` method. The implementation
    becomes trivial as all the code is already in the test:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的测试都是绿色的，我们可以实现 `main` 方法。实现变得非常简单，因为所有代码已经在测试中：
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first thing is to define a list of `Person`, so that `Person.filterAdult()`
    is used to remove all the persons, not the adults. The `adults` variable is a
    list of `Person`, but I would like to transform this list of `Person` into a list
    of the description of the `Person`. To perform this operation, the `map` function
    of the collection is used. The `map` function transforms each element of the list
    by applying the function in the parameter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是定义一个 `Person` 列表，这样 `Person.filterAdult()` 就可以用来移除所有人，而不是成年人。`adults` 变量是一个
    `Person` 列表，但我想将这个 `Person` 列表转换为描述 `Person` 的列表。为了执行此操作，使用集合的 `map` 函数。`map`
    函数通过在参数中应用函数来转换列表中的每个元素。
- en: The notation inside the `map()` function defines an anonymous function that
    takes `p` as the parameter. The body of the function is `p.description`. This
    notation is commonly used whenever a function takes another function as an argument.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数内的符号定义了一个匿名函数，该函数以 `p` 作为参数。函数体是 `p.description`。这种符号在函数接受另一个函数作为参数时常用。'
- en: Once we have a list of descriptions, we create a string with the `mkString()` function.
    It concatenates all the elements of the list using the special character `\n\t`,
    which are respectively the carriage return and the tab character.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了描述列表，我们使用 `mkString()` 函数创建一个字符串。它使用特殊字符 `\n\t` 连接列表的所有元素，其中 `\n` 分别是换行符，`\t`
    是制表符。
- en: Finally, we perform the side effect, which is the print on the console. To print
    in the console, the `println` alias is used. It is a syntactic sugar for `System.out.println`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行副作用，即控制台打印。要在控制台打印，使用 `println` 别名。它是 `System.out.println` 的语法糖。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have finished the first chapter, and you should now have the basics to start
    a project on your own. We covered the installation of an IDE to code in Scala
    with the basic usage of the dedicated build tool named SBT. Three ways to explore
    Scala have been demonstrated, including the REPL to test simple Scala features,
    the IntelliJ worksheet to play with a small environment, and lastly a real project.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一章，现在你应该有了自己开始项目的必备基础知识。我们涵盖了在Scala中使用IDE进行编码的安装，以及专用构建工具SBT的基本用法。展示了探索Scala的三种方法，包括REPL来测试简单的Scala特性，IntelliJ工作表来在小环境中进行实验，最后是一个真实的项目。
- en: To code our first project, we used ScalaTest and the TDD methodology so that
    we had good code quality from the beginning.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写我们的第一个项目，我们使用了ScalaTest和TDD方法，以确保我们从一开始就有良好的代码质量。
- en: In the next chapter, we will write a complete program. It is a financial application
    that allows its users to estimate when they can retire. We will keep using the
    TDD technique and will further explore the Scala language, its development kit,
    and their best practices.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写一个完整的程序。这是一个财务应用程序，允许用户估算他们何时可以退休。我们将继续使用TDD技术，并进一步探索Scala语言、其开发工具包以及最佳实践。
