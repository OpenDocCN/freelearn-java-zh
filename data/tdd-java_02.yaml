- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using TDD to Create Good Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD创建好代码
- en: 'We’ve seen that bad code is bad news: bad for business, bad for users, and
    bad for developers. **Test-driven development** (**TDD**) is a core software engineering
    practice that helps us keep bad code out of our systems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，糟糕的代码是坏消息：对商业不利，对用户不利，对开发者也不利。**测试驱动开发**（**TDD**）是一种核心的软件工程实践，它帮助我们避免将糟糕的代码引入我们的系统。
- en: The goal of this chapter is to learn the specifics of how TDD helps us to create
    well-engineered, correct code, and how it helps us to keep it that way. By the
    end, we will understand the basic principles behind good code and how TDD helps
    us create it. It is important for us to understand why TDD works in order to motivate
    us and so that we have a response to give to colleagues about why we recommend
    that they use it as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是了解TDD如何帮助我们创建经过良好工程设计的、正确的代码，以及它是如何帮助我们保持这种状态的。到本章结束时，我们将理解好代码背后的基本原理以及TDD如何帮助我们创建它。了解TDD为什么有效对我们来说很重要，这样我们可以激励自己，并且能够向同事们解释为什么我们也推荐他们使用它。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Designing good quality code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计高质量代码
- en: Revealing design flaws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示设计缺陷
- en: Preventing logic flaws
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预防逻辑缺陷
- en: Protecting against future defects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止未来缺陷
- en: Documenting our code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录我们的代码
- en: Designing good quality code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计高质量代码
- en: Good quality code doesn’t happen by accident. It is intentional. It is the result
    of thousands of small decisions, each one shaping how easy our code is to read,
    test, compose, and change. We must choose between quick-and-dirty hacks, where
    we have no idea what edge cases are covered, and more robust approaches, where
    we are confident that no matter how the user misuses our code, it will work as
    expected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量代码不是偶然发生的。它是故意的。它是成千上万个小决策的结果，每个决策都塑造了我们的代码的可读性、可测试性、可组合性和可变更性。我们必须在快速且草率的解决方案和更稳健的方法之间做出选择，后者让我们有信心，无论用户如何误用我们的代码，它都会按预期工作。
- en: Every line of source code involves at least one of these decisions. That’s an
    awful lot of deciding that we have to do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行源代码至少涉及这些决策中的一个。这需要我们做出大量的决策。
- en: You’ll notice that we haven’t mentioned TDD so far. As we will see, TDD does
    not design your code for you. It doesn’t remove that essential engineering sensibility
    and creative input that is needed to turn requirements into code. To be honest,
    I’m grateful for that – it’s the part that I enjoy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们之前没有提到TDD。正如我们将看到的，TDD不会为你设计代码。它不会移除将需求转化为代码所必需的工程敏感性和创造性输入。坦白说，我很感激这一点——这是我享受的部分。
- en: However, that does cause a lot of early failure with TDD, which is worth noting.
    Expecting to *implement the TDD process* and get good quality code out without
    your own design input will simply not work. TDD, as we will see, is a tool that
    allows you to get rapid feedback on these design decisions. You can change your
    mind and adapt while the code is still cheap and quick to change but they are
    still *your* design decisions that are playing out.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实会在TDD中导致很多早期失败，这是值得注意的。期望在不提供自己的设计输入的情况下实现TDD流程并获得高质量代码的想法将根本行不通。正如我们将看到的，TDD是一种允许你对这些设计决策获得快速反馈的工具。你可以在代码仍然便宜且易于更改时改变主意并适应，但它们仍然是你的设计决策，正在发挥作用。
- en: So, what is good code? What are we aiming for?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是好的代码？我们追求的是什么？
- en: Good code, for me, is all about readability. I optimize for clarity. I want
    to be kind to my future self and my long-suffering colleagues by engineering code
    that is clear and safe to work with. I want to create clear and simple code that
    is free of hidden traps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，好的代码就是可读性。我追求清晰。我想通过编写清晰且易于工作的代码来善待未来的自己和那些长期忍受的同事们。我想创建清晰且简单的代码，其中不包含隐藏的陷阱。
- en: 'While there is a huge range of advice on what makes good code, the basics are
    straightforward:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于什么使代码好的建议有很多，但基本原理是直接的：
- en: Say what you mean, mean what you say
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说你所想，想你所言
- en: Take care of the details in private
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在私下里注意细节
- en: Avoid accidental complexity
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免意外的复杂性
- en: It’s worth a quick review of what I mean by those things.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值得快速回顾一下我所说的这些内容。
- en: Say what you mean, mean what you say
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说你所想，想你所言
- en: Here’s an interesting experiment. Take a piece of source code (in any language)
    and strip out everything that is not part of the language specification, then
    see if you can figure out what it does. To make things really stand out, we will
    replace all method names and variable identifiers with the symbol `???`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的实验。取一段源代码（任何语言都可以），移除所有不属于语言规范的部分，然后看看你是否能弄清楚它是做什么的。为了使事情更加突出，我们将所有方法名称和变量标识符替换为符号`???`。
- en: 'Here’s a quick example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any ideas what this code does? No, me neither. I haven’t a clue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你有什么想法这个代码做什么吗？不，我也没有。我一点线索都没有。
- en: I can tell by its shape that it is some kind of *assessment* method that passes
    something in and returns `true`/`false`. Maybe it implements a threshold or limit.
    It uses a multipath return structure, where we check something, then return an
    answer as soon as we know what that answer is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过它的形状判断出它是一种某种**评估**方法，它接收一些内容并返回`true`/`false`。也许它实现了一个阈值或限制。它使用多路径返回结构，我们在检查某些内容后，一旦我们知道答案，就立即返回一个答案。
- en: While the shape of the code and the syntax tell us something, it’s not telling
    us much. It is definitely not enough. Nearly all the information we share about
    what our code does is a result of the natural language identifiers we choose.
    Names are absolutely vital to good code. They are beyond important. They are everything.
    They can reveal intent, explain outcomes, and describe why a piece of data is
    important to us, but they can’t do any of this if we do a bad job choosing our
    names.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码的形状和语法告诉我们一些信息，但它并没有告诉我们太多。这绝对不够。我们关于代码做什么的几乎所有信息都是我们选择的自然语言标识符的结果。名称对于良好的代码至关重要。它们是至关重要的。它们是全部。它们可以揭示意图，解释结果，并描述为什么某些数据对我们很重要，但如果我们选择名称不当，它们就不能做到这些。
- en: 'I use two guidelines for names, one for naming active code – methods and functions
    – and one for variables:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用两个命名指南，一个用于命名活动代码——方法和函数——另一个用于变量：
- en: '**Method** – Say what it does. What is the outcome? Why would I call this?'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法** – 说明它做什么。结果是什么？我为什么要调用它？'
- en: '**Variable** – Say what it contains. Why would I access this?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量** – 说明它包含的内容。我为什么要访问它？'
- en: A common mistake with method naming is to describe how it works internally,
    instead of describing what the outcome is. A method called `addTodoItemToItemQueue`
    is committing us to one specific implementation of a method that we don’t really
    care about. Either that or it is misinformation. We can improve the name by calling
    it `add(Todo item)`. This name tells us why exactly we should call this method.
    It leaves us free to revise how it is coded later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 方法命名的一个常见错误是描述它内部是如何工作的，而不是描述结果是什么。一个名为`addTodoItemToItemQueue`的方法让我们承诺采用一种特定的方法实现，而我们并不真正关心。要么是这样，要么是误导信息。我们可以通过将其命名为`add(Todo
    item)`来改进名称。这个名称告诉我们为什么我们应该调用这个方法。它让我们有自由在以后修改它的编码方式。
- en: The classic mistake with variable names is to say what they are made of. For
    example, the variable name `String string` helps nobody, whereas `String firstName`
    tells me clearly that this variable is somebody’s first name. It tells me why
    I would want to read or write that variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名的一个经典错误是说明它们是由什么构成的。例如，变量名`String string`对任何人都没有帮助，而`String firstName`清楚地告诉我这个变量是某人的名字。它告诉我为什么我想读取或写入这个变量。
- en: Perhaps more importantly, it tells us what *not* to write in that variable.
    Having one variable serve multiple purposes in the same scope is a real headache.
    Been there, done that, never going back.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更重要的是，它告诉我们不应该在那个变量中写什么。在同一个作用域内让一个变量承担多个功能确实是个头疼的问题。我经历过，已经做了，再也不想回头了。
- en: It turns out that code is *storytelling*, pure and simple. We tell the story
    of what problem we are solving and how we have decided to solve it to human programmers.
    We can throw any old code into a compiler and the computer will make it work but
    we must take more care if we want humans to understand our work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明代码就是**讲故事**，纯粹而简单。我们向人类程序员讲述我们正在解决的问题以及我们是如何决定解决它的。我们可以把任何旧代码扔进编译器，计算机就会让它工作，但如果我们想让人类理解我们的工作，我们必须更加小心。
- en: Take care of the details in private
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在私下里注意细节
- en: Taking care of the details in private is a simple way to describe the computer
    science concepts of **abstraction** and **information hiding**. These are fundamental
    ideas that allow us to break complex systems into smaller, simpler parts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在私下里注意细节是描述计算机科学概念**抽象**和**信息隐藏**的简单方法。这些是基本思想，使我们能够将复杂系统分解成更小、更简单的部分。
- en: The way I think about abstraction is the same way I think about hiring an electrician
    for my house.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为抽象的方式与我请电工为我修理房子的方式相同。
- en: I know that my electric water heater needs to be fixed but I don’t want to know
    how. I don’t want to learn how to do it. I don’t want to have to figure out what
    tools are needed and buy them. I want to have nothing whatsoever to do with it,
    beyond asking that it gets done when I need it done. So, I’ll call the electrician
    and ask them to do it. I’m more than happy to pay for a good job, as long as I
    don’t have to do it myself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我的电热水器需要修理，但我不想知道如何修理。我不想学习如何修理。我不想弄清楚需要哪些工具并购买它们。我只想完全不参与这件事，只要在我需要的时候完成即可。所以，我会打电话给电工，让他们来修理。只要我不需要亲自做，我非常乐意支付一笔不错的费用。
- en: This is what abstraction means. The electrician abstracts the job of fixing
    my water heater. Complex stuff gets done in response to my simple requests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是抽象的含义。电工抽象了我的热水器修理工作。复杂的任务会根据我的简单请求来完成。
- en: Abstraction happens everywhere in good software.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在优秀的软件中无处不在。
- en: Every time you make some kind of detail less important, you have abstracted
    it. A method has a simple signature but the code inside it may be complex. This
    is an abstraction of an algorithm. A local variable might be declared as type
    `String`. This is an abstraction of the memory management of each text character
    and the character encoding. A microservice that will send discount vouchers to
    our top customers who haven’t visited the site in a while is an abstraction of
    a business process. Abstraction is everywhere in programming, across all major
    paradigms – **object-oriented programming** (**OOP**), **procedural**, and **functional**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使某种细节变得不那么重要时，你就进行了抽象。一个方法有一个简单的签名，但其中的代码可能很复杂。这是算法的抽象。一个局部变量可能被声明为`String`类型。这是对每个文本字符的内存管理和字符编码的抽象。一个将折扣券发送给一段时间未访问过我们网站的顶级客户的微服务是对业务流程的抽象。抽象在编程中无处不在，跨越所有主要范式——**面向对象编程**（**OOP**）、**过程式**和**函数式**。
- en: The idea of splitting software into components, each of which takes care of
    something for us, is a massive quality driver. We centralize decisions, meaning
    that we don’t make mistakes in duplicated code. We can test a component thoroughly
    in isolation. We *design out* problems caused by hard-to-write code just by writing
    it once and having an easy-to-use interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件拆分成组件的想法，每个组件都为我们处理一些事情，这是一个巨大的质量驱动因素。我们集中决策，这意味着我们不会在重复的代码中犯错误。我们可以独立彻底地测试一个组件。我们只需编写一次并拥有一个易于使用的接口，就可以通过编写它来*设计出*由难以编写的代码引起的问题。
- en: Avoid accidental complexity
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免意外的复杂性
- en: This is my personal favorite destroyer of good code – complex code that simply
    never needed to exist.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我个人最喜欢的优秀代码的破坏者——那些根本不需要存在的复杂代码。
- en: There are always many ways of writing a piece of code. Some of them use complicated
    features or go all around the houses; they use convoluted chains of actions to
    do a simple thing. All versions of the code get the same result but some just
    do it in a more complicated way by accident.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一段代码总是有无数种方法。其中一些使用复杂的特性或绕弯子；它们使用复杂的动作链来完成简单的事情。所有版本的代码都能得到相同的结果，但有些版本却意外地以更复杂的方式完成。
- en: My goal for code is to tell at first sight the story of what problem I am solving,
    leaving the details about how I am solving it for closer analysis. This is quite
    different from how I learned how to code originally. I choose to emphasize **domain**
    over **mechanism**. The domain here means using the same language as the user,
    for example, expressing the problem in business terms, not just raw computer code
    syntax. If I am writing a banking system, I want to see money, ledgers, and transactions
    coming to the forefront. The story the code is telling has to be that of banking.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我对代码的目标是首先一眼就能看出我在解决什么问题，而将关于我是如何解决它的细节留给更深入的分析。这与我最初学习如何编码的方式大不相同。我选择强调**领域**而不是**机制**。这里的领域意味着使用与用户相同的语言，例如，用业务术语表达问题，而不仅仅是原始的计算机代码语法。如果我正在编写一个银行系统，我希望看到金钱、账簿和交易出现在最前面。代码所讲述的故事必须是关于银行的。
- en: Implementation details such as message queues and databases are important but
    only as far as they describe how we are solving the problem today. They may need
    to change later. Whether they change or not, we still want the primary story to
    be about *transactions going into an account* and not *message queues talking
    to* *REST services*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实现细节，如消息队列和数据库，虽然很重要，但仅限于它们描述我们今天是如何解决问题的。它们可能需要稍后更改。无论它们是否更改，我们仍然希望主要的故事是关于
    *交易进入账户*，而不是 *消息队列与 REST 服务通信*。
- en: As our code gets better at telling the story of the problem we are solving,
    we make it easier to write replacement components. Swapping out a database for
    another vendor’s product is simplified because we know exactly what purpose it
    is serving in our system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码越来越擅长讲述我们正在解决的问题的故事，我们使其更容易编写替换组件。用另一个供应商的产品替换数据库变得简单，因为我们确切地知道它在我们的系统中扮演着什么角色。
- en: This is what we mean by hiding details. At some level, it is important to see
    how we wired up the database, but only after we have seen why we even needed one
    in the first place.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的隐藏细节。在某种程度上，看到我们是如何连接数据库的很重要，但只有在我们看到为什么我们最初需要它之后。
- en: 'To give you a concrete example, here is a piece of code similar to some code
    that I found in a production system:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您一个具体的例子，这里有一段代码，它与我在生产系统中找到的一些代码类似：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see the problem here. Yes, there is a need for a method like this. It
    is a low-level mechanism that converts a Java `true`/`false` object into its equivalent
    primitive type and does it safely. It covers all edge cases relating to a `null`
    value input, as well as valid `true`/`false` values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里可以看到问题。是的，确实需要这样的方法。这是一个低级机制，它将 Java 的 `true`/`false` 对象转换为等效的基本类型，并且是安全的。它涵盖了与
    `null` 值输入相关的所有边缘情况，以及有效的 `true`/`false` 值。
- en: However, it has problems. This code is cluttered. It is unnecessarily hard to
    read and test. It has high **cyclomatic complexity (CYC)**. CYC is an objective
    measure of how complex a piece of code is, based on the number of independent
    execution paths possible in a section of code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有问题。这段代码很杂乱。它不必要地难以阅读和测试。它具有很高的 **循环复杂度 (CYC**)。CYC 是一个基于代码段中可能存在的独立执行路径数量的客观度量代码复杂性的指标。
- en: The previous code is unnecessarily verbose and over-complicated. I’m pretty
    sure it has a `else`, as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码不必要地冗长且过于复杂。我相当肯定它有一个 `else`。
- en: 'Looking at the logic needed, there are only three interesting input conditions:
    `null`, `true`, and `false`. It certainly does not need all those `else/if` chains
    to decode that. Once you’ve got that *null-to-false* conversion out of the way,
    you really only need to inspect one value before you can fully decide what to
    return.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从所需的逻辑来看，只有三个有趣的输入条件：`null`、`true` 和 `false`。它当然不需要所有那些 `else/if` 链来解码。一旦你处理完那个
    *null-to-false* 转换，你实际上只需要检查一个值，然后你就可以完全决定返回什么。
- en: 'A better equivalent would be the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的等效代码如下：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code does the same thing with a lot less fuss. It does not have the same
    level of accidental complexity as the previous code. It reads better. It is easier
    to test with fewer paths needing testing. It has a better cyclomatic complexity
    figure, which means fewer places for bugs to hide. It tells a better story about
    why the method exists. To be perfectly honest, I might even refactor this method
    by inlining it. I’m not sure the method adds any worthwhile extra explanation
    to the implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以更少的麻烦做同样的事情。它不具有先前代码相同的偶然复杂性。它读起来更好。它更容易测试，需要测试的路径更少。它具有更好的循环复杂度指标，这意味着隐藏错误的地方更少。它更好地讲述了这个方法存在的原因。坦白说，我甚至可能会通过内联来重构这个方法。我不确定这个方法是否为实现添加了任何有价值的额外解释。
- en: This method was a simple example. Just imagine seeing this scaled up to thousands
    of lines of copy-pasted, slightly-changed code. You can see why accidental complexity
    is a killer. This cruft builds up over time and grows exponentially. Everything
    becomes harder to read and harder to safely change.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是一个简单的例子。想象一下，如果把它扩展到数千行复制粘贴、略有变化的代码，您就能理解为什么偶然的复杂性是一个杀手。这种冗余随着时间的推移而积累，并以指数级增长。一切变得难以阅读，也难以安全地更改。
- en: Yes, I have seen that. I will never stop being sad about it when I do. We can
    do better than this. As professional software engineers, we really should.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我看到了。每当我看到它时，我都会感到非常难过。我们可以做得比这更好。作为专业的软件工程师，我们真的应该做到这一点。
- en: This section has been a lightning tour of *good design* fundamentals. They apply
    across all styles of programming. However, if we can do things right, we can also
    do things wrong. In the next section, we’ll take a look at how TDD tests can help
    us prevent bad designs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本节对**良好设计**的基本原则进行了闪电般的巡礼。这些原则适用于所有编程风格。然而，如果我们能正确地做事，我们也能做错事。在下一节中，我们将探讨TDD测试如何帮助我们预防不良设计。
- en: Revealing design flaws
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示设计缺陷
- en: Bad design is truly bad. It is the root cause of software being hard to change
    and hard to work with. You can never quite be sure whether your changes are going
    to work because you can never quite be sure what a bad design is really doing.
    Changing that kind of code is scary and often gets put off. Whole sections of
    code can be left to rot with only a `/* Here be dragons! */` comment to show for
    it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不良设计确实很糟糕。它是软件难以更改和难以工作的根本原因。你永远无法完全确定你的更改是否会起作用，因为你永远无法完全确定一个糟糕的设计真正在做什么。改变这种代码令人恐惧，通常会被推迟。整个代码段可能会被遗弃，只留下一个`/*
    Here be dragons! */`注释作为证明。
- en: The first major benefit of TDD is that it forces us to think about the design
    of a component. We do that before we think about how we implement it. By doing
    things in this order, we are far less likely to drift into a bad design by mistake.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的第一个主要好处是它迫使我们考虑组件的设计。我们在考虑如何实现它之前就做这件事。通过按这种顺序做事，我们不太可能不小心陷入一个糟糕的设计。
- en: The way we consider the design first is to think about the public interfaces
    of a component. We think about how that component will be used and how it will
    be called. We don’t yet consider how we will make any implementations actually
    work. This is *outside-in* thinking. We consider the usage of the code from outside
    callers before we consider any inside implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑设计的方式是思考组件的公共接口。我们思考该组件将被如何使用，以及它将被如何调用。我们还没有考虑我们如何使任何实现真正工作。这是**从外向内**的思考。我们在考虑任何内部实现之前，先考虑代码从外部调用者的使用。
- en: This is quite a different approach to take for many of us. Typically, when we
    need code to do something, we start by writing the implementation. After that,
    we will ripple out whatever is needed in method signatures, without a thought
    about the call site. This is *inside-out* thinking. It works, of course, but it
    often leads to complex calling code. It locks us into implementation details that
    just aren’t important.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们中的许多人来说是一种相当不同的方法。通常，当我们需要代码做某事时，我们首先编写实现。之后，我们将根据方法签名中需要的内容进行扩展，而不考虑调用点。这是**从内向外**的思考。当然，它有效，但它通常会导致复杂的调用代码。它使我们陷入不重要的实现细节中。
- en: Outside-in thinking means we get to dream up the perfect component for its users.
    Then, we will bend the implementation to work with our desired code at the call
    site. Ultimately, this is far more important than the implementation. This is,
    of course, abstraction being used in practice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**从外向内**的思考意味着我们可以为用户梦想出完美的组件。然后，我们将调整实现以适应我们希望在调用点使用的代码。最终，这比实现本身更重要。这当然是抽象在实践中的应用。'
- en: 'We can ask questions like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出以下问题：
- en: Is it easy to set up?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否容易设置？
- en: Is it easy to ask it to do something?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否容易要求它做某事？
- en: Is the outcome easy to work with?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是否容易处理？
- en: Is it difficult to use it the wrong way?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否难以以错误的方式使用它？
- en: Have we made any incorrect assumptions about it?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对它是否做出了任何错误的假设？
- en: You can see that by asking the right sort of questions, we’re going to get the
    right sort of results.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提出正确的问题，我们可以得到正确的结果。
- en: By writing tests first, we cover all these questions. We decide upfront how
    we are going to set up our component, perhaps deciding on a clear constructor
    signature for an object. We decide how we are going to make the calling code look
    and what the call site will be. We decide how we will consume any results returned
    or what the effect will be on collaborating components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过先编写测试，我们涵盖了所有这些问题。我们提前决定如何设置我们的组件，可能为对象决定一个清晰的构造函数签名。我们决定如何使调用代码看起来如何，以及调用点将是什么。我们决定如何消费任何返回的结果，或者它将对协作组件产生什么影响。
- en: This is the heart of software design. TDD does not do this for us, nor does
    it force us to do a good job. We could still come up with terrible answers for
    all those questions and simply write a test to lock those poor answers into place.
    I’ve seen that happen on numerous occasions in real code as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是软件设计的核心。TDD不会为我们做这件事，也不会强迫我们做得很好。我们仍然可以为所有这些问题想出糟糕的答案，然后简单地编写一个测试来锁定那些糟糕的答案。我也在现实代码中多次看到这种情况发生。
- en: TDD provides that early opportunity to reflect on our decisions. We are literally
    writing the first example of a working, executable call site for our code before
    we even think about how it will work. We are totally focused on how this new component
    is going to fit into the bigger picture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TDD提供了早期反思我们决策的机会。在我们甚至还没有考虑代码如何工作之前，我们实际上已经在为我们的代码编写第一个可执行调用点的第一个示例。我们完全专注于这个新组件将如何融入更大的画面中。
- en: The test itself provides immediate feedback on how well our decisions have worked
    out. It gives three tell-tale signals that we could and should improve. We’ll
    save the details for a later chapter but the test code itself clearly shows when
    your component is either hard to set up, hard to call, or its outputs are hard
    to work with.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身立即提供了关于我们的决策效果如何的反馈。它给出了三个明显的信号，表明我们可以也应该改进。我们将把细节留到后面的章节，但测试代码本身清楚地显示了当你的组件难以设置、难以调用或其输出难以处理时的情况。
- en: Analyzing the benefits of writing tests before production code
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析在生成代码之前编写测试的好处
- en: 'There are three times you can choose to write tests: before the code, after
    the code, or never.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在三个时间点选择编写测试：在代码之前，在代码之后，或者永远不写。
- en: Obviously, never writing any tests sends us back to the dark ages of development.
    We’re winging it. We write code assuming it will work, then leave it all to a
    manual test stage later. If we’re lucky, we will discover functional errors at
    this stage, before our customers do.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从不编写任何测试会将我们带回到开发的黑暗时代。我们在盲目行动。我们编写代码假设它将工作，然后将其全部留给后续的手动测试阶段。如果我们幸运的话，我们将在客户之前发现功能错误。
- en: Writing tests just after we complete a small chunk of code is a much better
    option. We get much faster feedback. Our code isn’t necessarily any better though,
    because we write with the same mindset as we do without the implementation of
    tests. The same kinds of functional errors will be present. The good news is that
    we will then write tests to uncover them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成一小块代码后立即编写测试是一个更好的选择。我们得到了更快的反馈。我们的代码不一定更好，因为我们编写代码的心态与没有测试实现时的心态相同。同样类型的功能错误仍然存在。好消息是，我们将编写测试来揭示它们。
- en: 'This is a big improvement, but it still isn’t the gold standard, as it leads
    to a couple of subtle problems:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项很大的改进，但这还不是黄金标准，因为它导致了一些微妙的问题：
- en: Missing tests
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少的测试
- en: Leaky abstractions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄露的抽象
- en: Missing tests – undetected errors
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺少的测试 – 未检测到的错误
- en: Missing tests happen because of human nature. When we are busy writing code,
    we are juggling many ideas in our heads at once. We focus on specific details
    at the expense of others. I always find that I mentally *move on* a bit too quickly
    after a line of code. I just assume that it’s going to be okay. Unfortunately,
    when I come to write my tests, that means I’ve forgotten some key points.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的测试是由于人类的天性造成的。当我们忙于编写代码时，我们的大脑中同时有很多想法。我们专注于特定的细节，而忽略了其他方面。我总是发现，在写完一行代码后，我心理上会很快地“继续前进”。我只是假设它将会没问题。不幸的是，当我开始编写测试时，这意味着我已经忘记了某些关键点。
- en: 'Suppose I end up writing some code like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我最终编写了一些这样的代码：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ll probably have quickly started with the `> 18` check, then *moved on* mentally
    and remembered that the age could be `null`. I will have added the `And` clause
    to check whether it is or not. That makes sense. My experience tells me that this
    particular snippet of code needs to do more than be a basic, robust check.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能很快就开始了`> 18`的检查，然后心理上“继续前进”并记得年龄可能是`null`。我将添加`And`子句来检查它是否是或不是。这很有道理。我的经验告诉我，这段特定的代码需要做的不仅仅是进行基本的、健壮的检查。
- en: When I write my test, I’ll remember to write a test for what happens when I
    pass in `null`, as that is fresh in my mind. Then, I will write another test for
    what happens with a higher age, say *21*. Again, good.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写测试时，我会记得编写一个测试来处理传入`null`的情况，因为这一点在我脑海中很清晰。然后，我将为更高的年龄编写另一个测试，比如*21*。再次，很好。
- en: Chances are that I will forget about writing a test for the edge case of an
    age value of `18`. That’s really important here but my mind has moved on from
    that detail already. All it will take is one Slack message from a colleague about
    what’s for lunch, and I will most likely forget all about that test and start
    coding the next method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能我会忘记为年龄值为`18`的边缘情况编写测试。这里真的很重要，但我的注意力已经从那个细节转移开了。只需要同事的一条关于午餐的Slack消息，我很可能就会忘记那个测试，开始编写下一个方法。
- en: The preceding code has a subtle bug in it. It is supposed to return `true` for
    any age that is `18` or above. It doesn’t. It returns `true` only for `19` and
    above. The greater-than symbol should have been a greater-than-or-equal-to symbol
    but I missed this detail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中有一个微妙的错误。它应该对任何`18`岁或以上的年龄返回`true`。它没有。它只对`19`岁或以上的年龄返回`true`。应该使用大于等于符号，但我忽略了这个细节。
- en: Not only did I miss the nuance in the code but I missed out a vital test. I
    wrote two important tests but I needed three.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我在代码中忽略了细微差别，我还遗漏了一个重要的测试。我写了两个重要的测试，但我需要三个。
- en: Because I wrote the other tests, I get no warning at all about this. You don’t
    get a failing test that you haven’t written.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我自己写了其他测试，所以我对此没有任何警告。你没有得到一个你没有写的失败的测试。
- en: We can avoid this by writing a failing test for every piece of code, then adding
    only enough code to make that test pass. That workflow would have been more likely
    to steer us toward thinking through the four tests needed to drive out `null`
    handling and the three boundary cases relating to age. It cannot guarantee it,
    of course, but it can drive the right kind of thinking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为每段代码编写失败的测试，然后只添加足够的代码来使测试通过来避免这种情况。这种工作流程更有可能引导我们思考四个测试，以排除`null`处理和与年龄相关的三个边界情况。当然，它不能保证这一点，但它可以引导正确的思考方式。
- en: Leaky abstractions – exposing irrelevant details
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泄漏的抽象——暴露无关的细节
- en: Leaky abstractions are a different problem. This is where we focus so much on
    the inside of the method that we forget to think about our *dream call site*.
    We just ripple out whatever is easiest to code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏的抽象是另一个问题。这是我们如此关注方法内部，以至于忘记了考虑我们的**梦想调用点**。我们只是随意地传播最容易编码的内容。
- en: We might be writing an interface where we store `UserProfile` objects. We might
    proceed code-first, pick ourselves a `JDBC` library that we like, code up the
    method, then find that it needs a database connection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能正在编写一个存储`UserProfile`对象的接口。我们可能先从代码开始，选择我们喜欢的`JDBC`库，编写方法，然后发现它需要一个数据库连接。
- en: 'We might simply add a `Connection` parameter to fix that:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地添加一个`Connection`参数来解决这个问题：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At first sight, there’s nothing much wrong with it. However, look at that first
    parameter: it’s the `JDBC`-specific `Connection` object. We have locked our interface
    into having to use `JDBC`. Or at the very least, having to supply some `JDBC`-related
    thing as a first parameter. We didn’t even mean to do that. We simply hadn’t thought
    about it thoroughly.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，似乎没有什么大问题。然而，看看第一个参数：它是特定的`JDBC`连接对象。我们已经将我们的接口锁定为必须使用`JDBC`。或者至少，必须作为第一个参数提供一些与`JDBC`相关的东西。我们甚至没有打算这样做。我们只是没有彻底考虑。
- en: If we think about the ideal abstraction, it should load the corresponding `UserProfile`
    object for the given `userId`. It should *not* know how it is stored. The `JDBC`-specific
    `Connection` parameter should not be there.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑理想的抽象，它应该为给定的`userId`加载相应的`UserProfile`对象。它**不应该**知道它是如何存储的。不应该有特定的`JDBC`连接参数。
- en: If we think outside-in and consider the design before the implementation, we
    are less likely to go down this route.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从外部考虑并先考虑设计再考虑实现，我们就不太可能走这条路。
- en: Leaky abstractions like this create accidental complexity. They make code harder
    to understand by forcing future readers to wonder why we are insisting on `JDBC`
    use when we never meant to do so. We just forgot to design it out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种泄漏的抽象会创建意外的复杂性。它们通过迫使未来的读者思考为什么我们坚持使用`JDBC`，而实际上我们从未打算这样做，使得代码更难理解。我们只是忘记设计它出来。
- en: Writing tests first helps prevent this. It leads us to think about the ideal
    abstractions as a first step so we can write the test for them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 先编写测试有助于防止这种情况。它引导我们首先考虑理想的抽象，这样我们就可以为它们编写测试。
- en: Once we have that test coded up, we have locked in our decision on how the code
    will be used. Then, we can figure out how to implement that without any unwanted
    details leaking out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了那个测试，我们就已经锁定了代码的使用决策。然后，我们可以找出如何在不泄露任何不想要的细节的情况下实现它。
- en: 'The previously explained techniques are simple but cover most of the basics
    of good design. Use clear names. Use simple logic. Use abstraction to hide implementation
    details, so that we emphasize what problem we are solving, rather than how we
    are solving it. In the next section, let’s review the most obvious benefit of
    TDD: preventing flaws in our logic.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前解释的技术很简单，但涵盖了良好设计的绝大部分基础。使用清晰的名称。使用简单的逻辑。使用抽象来隐藏实现细节，这样我们就可以强调我们正在解决的问题，而不是我们是如何解决问题的。在下一节中，让我们回顾TDD最明显的益处：预防我们逻辑中的缺陷。
- en: Preventing logic flaws
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防逻辑错误
- en: 'The idea of logic errors is perhaps what everybody thinks of first when we
    talk about testing: *did it* *work right?*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论测试时，逻辑错误的观念可能是每个人首先想到的：*它**工作正确了吗*？
- en: I can’t disagree here – this is really important. As far as users, revenues,
    our Net Promoter Score®™, and market growth go, if your code doesn’t work right,
    it doesn’t sell. It’s that simple.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不能不同意——这真的很重要。就用户、收入、我们的Net Promoter Score®™和市场增长而言，如果你的代码不能正确工作，它就不会销售。就是这么简单。
- en: Understanding the limits of manual testing
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解手动测试的局限性
- en: We know from bitter experience that the simplest logic flaws are often the easiest
    to create. The examples that we can all relate to are those one-off errors, that
    `NullPointerException` from an uninitialized variable, and that exception thrown
    by a library that wasn’t in the documentation. They are all so simple and small.
    It seems like it would be so obvious for us to realize that we were making these
    mistakes, yet we all know they are often the hardest to spot. When we humans concentrate
    on the big picture of our code, sometimes these critical details just go unnoticed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从痛苦的教训中知道，最简单的逻辑错误往往是最容易创建的。我们可以联想到的例子是那些一次性的错误，比如从未初始化的变量中产生的`NullPointerException`，以及那些未在文档中提到的库抛出的异常。它们都是如此简单和微小。似乎对我们来说，意识到我们犯了这些错误应该是显而易见的，但我们都知道它们往往是最难发现的。当我们人类专注于代码的大局时，有时这些关键细节就会被人忽视。
- en: We know that manual testing *can* reveal these logic flaws but we also know
    from experience that manual test plans are fragile. It is possible to miss steps
    out or rush and miss important errors. We might simply assume that something does
    not need testing on this release *because we did not change that section of code*.
    You guessed it – that doesn’t always work out so well for us. Bugs can arise in
    sections of code that seem totally unrelated to the bug if some underlying assumption
    has changed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道手动测试*可以*揭示这些逻辑错误，但我们也知道从经验中得知手动测试计划是脆弱的。可能会遗漏步骤或匆忙中错过重要的错误。我们可能会简单地假设在这个版本中*不需要测试这个代码部分*，因为我们没有更改那个代码部分。你猜对了——这并不总是对我们有利。如果某些基本假设发生了变化，代码中的某些部分可能会出现与错误完全无关的bug。
- en: Manual testing costs money, which is money that can now not be spent on adding
    shiny new features instead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试需要花钱，而这些钱现在不能用来添加闪亮的新功能。
- en: Manual testing also gets blamed for delaying ship dates. Now, this is spectacularly
    unfair to our manual test colleagues. The development team – obviously writing
    code without TDD tests – stumble over their own bugs until there are only a couple
    of days left to ship. Then, we hand over the code to the testers, who have to
    run a huge test document in next to no time. They sometimes get blamed for *delaying
    the release*, even though the real cause was development taking longer than it
    should.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试还受到推迟发货日期的指责。现在，这对我们的手动测试同事来说是非常不公平的。显然，开发团队——显然没有编写TDD测试的代码——直到发货前只有几天时间，才会遇到自己的bug。然后，我们将代码交给测试人员，他们必须在几乎没有时间的情况下运行大量的测试文档。他们有时会因*推迟发布*而受到责备，尽管真正的原因是开发时间比预期要长。
- en: Yet, we never truly had a release. If we define a release as including tested
    code, which we should, then it is clear that the necessary testing never happened.
    You can’t ethically release code when you don’t even know whether it works. If
    you do, your users will be quick to complain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们从未真正发布过。如果我们把发布定义为包括经过测试的代码，我们应该这样做，那么很明显，必要的测试从未发生。如果你不知道代码是否工作，你就不应该道德地发布代码。如果你这样做，你的用户会很快提出投诉。
- en: It’s no wonder some of my testing colleagues get so grumpy by the end of a sprint.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 wonder，一些测试同事在冲刺结束时变得如此烦躁。
- en: Solving problems by automating the tests
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过自动化测试解决问题
- en: TDD has this totally covered. These logic errors simply cannot arise, which
    sounds like fantasy, but it really is true.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TDD完全解决了这个问题。这些逻辑错误根本不可能出现，这听起来像是一个幻想，但这是真的。
- en: 'Before you type any production code, you have already written a failing test.
    Once you add your new code, you rerun the test. If you somehow typed in a logic
    error, the test still fails and you know about it *right away*. That’s the magic
    here: your mistake happens but is highlighted right away. This enables you to
    fix it when it is fresh in your mind. It also means you cannot forget about fixing
    it later on.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写任何生产代码之前，你已经编写了一个失败的测试。一旦你添加了新的代码，你重新运行测试。如果你输入了逻辑错误，测试仍然会失败，你立刻就会知道。这里的魔法就在这里：你的错误发生了，但立刻就被突出显示出来。这使得你可以在它还新鲜在你的脑海中时修复它。这也意味着你不能忘记稍后修复它。
- en: You can often go to the exact line that’s wrong and make the change. It’s 10
    seconds of work, not months of waiting for a test silo to get to work and fill
    out a *JIRA* bug ticket.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以直接找到出错的行并做出更改。这只需要10秒钟的工作，而不是等待几个月，直到测试隔离区开始工作并填写一个*JIRA*错误报告票。
- en: The kinds of unit tests we are talking about are also fast to run – very fast.
    Many of them run within a millisecond. Compare that to the total time to write
    a test plan document, run the whole app, set up stored data, operate the **user
    interface** (**UI**), record output, then write up a bug ticket. It is incomparably
    better, isn’t it?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的单元测试也运行得非常快——非常快。其中许多测试在毫秒内完成。与编写整个测试计划文档、运行整个应用程序、设置存储数据、操作**用户界面**（**UI**）、记录输出，然后编写错误报告票相比，这要好得多，不是吗？
- en: You can see how this is a bug-squashing superpower. We are making significant
    time savings within the code-test-debug cycle. This reduces development costs
    and increases delivery velocity. These are big wins for our team and our users.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这如何是一种消除错误的超级能力。我们在代码-测试-调试周期中节省了大量的时间。这降低了开发成本并提高了交付速度。这对我们的团队和用户来说都是巨大的胜利。
- en: Every time you write a test before code, you have kept bugs out of that code.
    You follow the most basic rule that you do not check code with failing tests.
    You make them pass.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在代码之前编写测试时，你都已经将错误排除在了那个代码之外。你遵循了最基本的规则，即不检查失败的测试代码。你使它们通过。
- en: It shouldn’t need saying but you also don’t cheat around that failing test by
    deleting it, ignoring it, or making it *always pass* by using some technical hack.
    However, I am saying all this because I have seen exactly that done in real code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要说，你也不应该通过删除它、忽略它或使用某种技术手段使其“总是通过”来欺骗那个失败的测试。然而，我之所以说这些，是因为我确实在真实代码中看到了这种行为。
- en: 'We’ve seen how writing tests first helps prevent adding bugs in our new code
    but TDD is even better than that: it helps prevent adding bugs in code that we
    will add *in the future*, which we will cover in the next section.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到先编写测试如何帮助我们预防在新的代码中添加错误，但TDD（测试驱动开发）甚至比这更好：它帮助我们预防在未来添加代码时引入错误，这一点我们将在下一节中讨论。
- en: Protecting against future defects
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御未来缺陷
- en: As we grow our code by writing tests first, we could always simply delete each
    test after it has passed. I’ve seen some students do that when I’ve taught them
    TDD because I hadn’t explained that we shouldn’t do that yet. Regardless, we don’t
    delete tests once they pass. We keep them all.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过先编写测试来扩展代码时，我们总是可以简单地删除每个通过后的测试。我曾看到一些学生在教他们TDD时这样做，因为我还没有解释过我们还不应该这样做。无论如何，一旦测试通过，我们不会删除它们。我们保留所有测试。
- en: Tests grow into large regression suites, automatically testing every feature
    of the code we have built. By frequently running all the tests, we gain safety
    and confidence in the entire code base.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试逐渐发展成为大型回归测试套件，自动测试我们构建的代码的每个功能。通过频繁运行所有测试，我们在整个代码库中获得安全感和信心。
- en: As team members add features to this code base, keeping all the tests passing
    shows that nobody has accidentally broken something. It is quite possible in software
    to add a perfectly innocent change somewhere, only to find that some seemingly
    unrelated thing has now stopped working. This will be because of the relationship
    between those two pieces that we previously did not understand.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队成员向这个代码库添加功能时，保持所有测试通过表明没有人意外地破坏了某些东西。在软件中，你可能在某个地方添加了一个完全无辜的更改，结果发现一些看似无关的事情现在停止工作了。这将是由于我们之前没有理解的那两个部分之间的关系。
- en: The tests have now caused us to learn more about our system and our assumptions.
    They have prevented a defect from being written into the code base. These are
    both great benefits but the bigger picture is that our team has the confidence
    to make changes safely and know they have tests automatically looking after them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试现在让我们对我们的系统和我们的假设有了更多的了解。它们防止了缺陷被写入代码库。这两者都是巨大的好处，但更大的图景是，我们的团队能够有信心安全地做出改变，并且知道有测试自动地照顾着它们。
- en: This is true agility, the freedom to change. Agility was never about JIRA tickets
    and sprints. It was always about the ability to move quickly, with confidence,
    through an ever-changing landscape of requirements. Having tens of thousands of
    fast-running automated tests is probably the biggest enabling practice we have.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这才是真正的敏捷，改变的自由。敏捷从来不是关于JIRA工单和冲刺。它始终是关于在不断变化的需求景观中快速、有信心地移动的能力。拥有数以万计的快速运行的自动化测试可能是我们最大的启用实践。
- en: The ability of tests to give team members confidence to work quickly and effectively
    is a huge benefit of TDD. You may have heard the phrase *move fast and break things*,
    famous from the early days of Facebook. TDD allows us to move fast and *not* break
    things.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 测试能够给予团队成员快速、有效地工作的信心，这是TDD的一个巨大好处。你可能听说过“快速行动，打破事物”的短语，这是来自Facebook早期的一个著名说法。TDD允许我们快速行动，*不*打破事物。
- en: As we’ve seen, tests are great at providing fast feedback on design and logic
    correctness, as well as providing a defense against future bugs, but one huge
    extra benefit is that tests document our code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，测试在提供关于设计和逻辑正确性的快速反馈以及提供对未来错误的防御方面非常出色，但一个巨大的额外好处是，测试记录了我们的代码。
- en: Documenting our code
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录我们的代码
- en: Everybody likes helpful, clear documentation, but not when it is out of date
    and unrelated to the current code base.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢有帮助、清晰的文档，但不是当它过时且与当前代码库无关时。
- en: There is a general principle in software that the more separation there is between
    two related ideas, the more pain they will bring. As an example, think of some
    code that reads some obscure file format that nobody remembers. All works well,
    so long as you are reading files in that old format. Then you upgrade the application,
    that old file format is no longer supported, and everything breaks. The code was
    separated from the data content in those old files. The files didn’t change but
    the code did. We didn’t even realize what was going on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中有一个普遍的原则，即两个相关想法之间的分离越多，它们带来的痛苦就越大。作为一个例子，想想一些读取一些鲜为人知的文件格式的代码。只要你在读取那个旧格式的文件，一切都会正常工作。然后你升级了应用程序，那个旧文件格式不再被支持，一切都会崩溃。代码与那些旧文件中的数据内容分离了。文件没有改变，但代码改变了。我们甚至没有意识到发生了什么。
- en: It’s the same with documentation. The worst documentation is often contained
    in the glossiest productions. These are artifacts written a long time after the
    code was created by teams with separate skillsets – copywriting, graphic design,
    and so on. Documentation updates are the first thing to get dropped from a release
    when time gets tight.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文档也是如此。最糟糕的文档通常包含在光泽最亮的生产中。这些是在代码创建很长时间后由具有不同技能集的团队编写的工件——文案写作、图形设计等等。当时间紧迫时，文档更新通常是首先被放弃的事情。
- en: The solution is to bring documentation closer to the code. Get it produced by
    people closer to the code who know how it works in detail. Get it read by people
    who need to work directly with that code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将文档与代码更接近。让它由更接近代码、详细了解其工作原理的人来生成。让它由需要直接与该代码工作的人来阅读。
- en: As with all other aspects of **Extreme Programming (XP)**, the most obvious
    major win is to make it so close to the code that it is the code. Part of this
    involves using our good design fundamentals to write clear code and our test suite
    also plays a key role.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像极限编程（XP）的所有其他方面一样，最明显的主要胜利是让它与代码如此接近，以至于它就是代码。这包括使用我们良好的设计原则来编写清晰的代码，我们的测试套件也扮演着关键角色。
- en: Our TDD tests are code, not manual test documents. They are usually written
    in the same language and repo as the main code base. They will be written by the
    same people who are writing the production code – the developers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TDD测试是代码，而不是手动测试文档。它们通常与主代码库使用相同的语言和仓库编写。它们将由编写生产代码的同一个人编写——开发者。
- en: The tests are executable. As a form of documentation, you know that something
    that can run has to be up to date. Otherwise, the compiler will complain, and
    the code will not run.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是可执行的。作为一种文档形式，你知道可以运行的东西必须是最新的。否则，编译器会抱怨，代码将无法运行。
- en: Tests also form the perfect example of how to use our production code. They
    clearly define how it should be set up, what dependencies it has, what its interesting
    methods and functions are, what its expected effects are, and how it will report
    errors. Everything you would want to know about that code is in the tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试也完美地展示了如何使用我们的生产代码。它们清楚地定义了它应该如何设置，它有什么依赖项，它有哪些有趣的方法和函数，它的预期效果是什么，以及它将如何报告错误。关于该代码的任何你想知道的信息都在测试中。
- en: It may be surprising at first. Testing and documentation are not normally confused
    with each other. Because of how TDD works, there is a huge overlap between the
    two. Our test is a detailed description of what our code should do and how we
    can make it do that for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能会令人惊讶。测试和文档通常不会被混淆。由于TDD的工作方式，两者之间有很大的重叠。我们的测试是对我们的代码应该做什么以及我们如何让它为我们做到这一点的详细描述。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve learned that TDD helps us create good designs, write
    correct logic, prevent future defects, and provide executable documentation for
    our code. Understanding what TDD will do for our projects is important to use
    it effectively and to persuade our teams to use it as well. There are many advantages
    to TDD and yet it is not used as often as it should be in real-world projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到TDD帮助我们创建良好的设计，编写正确的逻辑，预防未来的缺陷，并为我们的代码提供可执行的文档。理解TDD对我们项目的作用对于有效地使用它以及说服我们的团队使用它非常重要。TDD有很多优点，但在现实世界的项目中并没有像应该的那样经常使用。
- en: In the next chapter, we will look into some common objections to TDD, learn
    why they are not valid, and how we can help our colleagues overcome them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些常见的对TDD的反对意见，了解为什么它们不成立，以及我们如何帮助我们的同事克服它们。
- en: Questions and answers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: What is the connection between testing and clean code?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试和干净代码之间有什么联系？
- en: There is not a direct one, which is why we need to understand how to write clean
    code. How TDD adds value is that it forces us to think about how our code will
    be used before we write it and when it is easiest to clean up. It also allows
    us to refactor our code, changing its structure without changing its function,
    with certainty that we have not broken that function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接的路径，这就是为什么我们需要了解如何编写干净的代码。TDD（测试驱动开发）增加价值的地方在于，它迫使我们在我们编写代码之前和最容易清理的时候去思考代码的用途。它还允许我们重构代码，改变其结构而不改变其功能，并确信我们没有破坏那个功能。
- en: Can tests replace documentation?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试能否替代文档？
- en: Well-written tests replace some but not all documentation. They become a detailed
    and up-to-date executable specification for our code. What they cannot replace
    are documents such as user manuals, operations manuals, or contractual specifications
    for public **application programming** **interfaces** (**APIs**).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编写得好的测试可以替代一些但不是所有的文档。它们成为我们代码的详细和最新的可执行规范。它们无法替代的是用户手册、操作手册或公共**应用程序编程****接口**（**API**）的合同规范等文档。
- en: What are the problems with writing production code before tests?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前编写生产代码有什么问题？
- en: 'If we write production code first, then add tests later, we are more likely
    to face the following problems:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先编写生产代码，然后添加测试，我们更有可能面临以下问题：
- en: Missing broken edge cases on conditionals
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条件语句上遗漏了破坏性的边缘情况
- en: Leaking implementation details through interfaces
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口泄露实现细节
- en: Forgetting important tests
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记重要的测试
- en: Having untested execution paths
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在未测试的执行路径
- en: Creating difficult-to-use code
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建难以使用的代码
- en: Forcing more rework when design flaws are revealed later in the process
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计缺陷在后期过程中被揭示时，迫使进行更多的返工
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A formal definition of cyclomatic complexity can be found in the WikiPedia
    link. Basically, every conditional statement adds to the complexity, as it creates
    a new possible execution path:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在维基百科链接中找到循环复杂性的正式定义。基本上，每个条件语句都会增加复杂性，因为它创建了一个新的可能的执行路径：
- en: '[https://en.wikipedia.org/wiki/Cyclomatic_complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Cyclomatic_complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)'
