- en: Chapter 8. WebSockets and Actors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. WebSocket和Actor
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to WebSockets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket简介
- en: Actor Model and Akka Actors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor模型和Akka Actor
- en: 'WebSockets in Play: using Iteratees and Actors'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Play中的WebSocket：使用Iteratee和Actor
- en: FrameFormatters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FrameFormatters
- en: An introduction to WebSockets
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket简介
- en: 'Picture this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：
- en: A moviegoer is trying to purchase movie tickets online. He or she has selected
    the seats, entered the payment details, and submitted. He or she gets an error
    message saying that the tickets they tried to book have sold out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个电影爱好者正在尝试在线购买电影票。他或她已经选定了座位，输入了付款详情，并提交了。他或她收到一个错误消息，说他们试图预订的票已经售罄。
- en: Consider an application, which gives detailed information about the stock market
    and allows purchasing/selling stocks. When someone enters payment details and
    submits these details, they get an error saying that the purchase has been rejected
    as the price of the stock has now changed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个应用程序，它提供了有关股市的详细信息，并允许购买/出售股票。当有人输入付款详情并提交这些详情时，他们会收到一个错误消息，说购买已被拒绝，因为股票价格已经改变。
- en: 'Initially, in applications where real-time data was required over HTTP, developers
    realized that they needed bidirectional communication between the client side
    and server side. It was generally implemented using one of the following approaches:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初需要通过HTTP获取实时数据的应用程序中，开发者意识到他们需要在客户端和服务器端之间实现双向通信。这通常是通过以下方法之一实现的：
- en: '**Polling**: Requests are sent from the client side at fixed and regular intervals.
    The server responds within a short span (less than 1 second or so) with a result
    for each request made.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询**：客户端以固定和规律的时间间隔发送请求。服务器在短时间内（不到1秒或如此）对每个请求做出响应。'
- en: '**Long-polling**: When a request is sent, the server does not respond with
    a result unless there has been a change in the state within a specified time period.
    A request is fired after a response is received from the server. Therefore, the
    client side makes repeated requests as and when it gets the response for the previous
    one.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长轮询**：当发送请求时，服务器在指定时间间隔内状态没有变化时不会响应结果。在从服务器收到响应后，才会触发请求。因此，客户端会根据需要重复请求，直到收到前一个请求的响应。'
- en: '**Streaming**: A request to the server results in an open response, which is
    continuously updated and kept open indefinitely.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式传输**：向服务器发送请求会导致一个打开的响应，该响应会持续更新并无限期保持打开状态。'
- en: 'Although these approaches worked, using them led to some problems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法有效，但使用它们导致了一些问题：
- en: It led to an increase in the number of TCP connections per client
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这导致了每个客户端TCP连接数量的增加
- en: There was a high overhead of HTTP Header Overhead while mapping a response to
    its corresponding request on the client side
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端将响应映射到其对应请求时，HTTP头部开销很大
- en: In 2011, a protocol that uses a single TCP connection for bidirectional traffic,
    WebSocket (RFC6455), was standardized by the **Internet Engineering Task Force**
    (**IETF**). By September 20, 2012, the **World Wide Web Consortium** (**W3C**)
    came up with the specifications for a WebSocket API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，一个使用单个TCP连接进行双向通信的协议WebSocket（RFC6455）被互联网工程任务组（**IETF**）标准化。到2012年9月20日，**万维网联盟**（**W3C**）提出了WebSocket
    API的规范。
- en: Unlike HTTP, there is no request-response cycle in a WebSocket. Once connected,
    the client and server can send messages to each other. The communication can be
    by server and by client, that is, a two-way full duplex communication.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP不同，WebSocket中没有请求-响应周期。一旦连接，客户端和服务器就可以互相发送消息。通信可以是服务器到客户端，也可以是客户端到服务器，即双向全双工通信。
- en: 'According to the WebSocket API:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据WebSocket API：
- en: A WebSocket connection can be established by invoking the constructor, such
    as `WebSocket(url, protocols)`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过调用构造函数来建立WebSocket连接，例如`WebSocket(url, protocols)`
- en: Data can be sent to the server via a connection using the `send(data)` method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`send(data)`方法通过连接将数据发送到服务器
- en: Calling `close()` will result in closing the connection
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`close()`将导致关闭连接
- en: 'The following event handlers can be defined on the client side:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下事件处理程序可以在客户端定义：
- en: '`onopen`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onopen`'
- en: '`onmessage`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onmessage`'
- en: '`onerror`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`'
- en: '`onclose`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onclose`'
- en: 'A snippet using JavaScript is shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用JavaScript的示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: WebSockets in Play
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play中的WebSocket
- en: '**WebSockets** cannot be defined using Action since they should be bidirectional.
    Play provides a helper to assist with WebSockets, which is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSockets** 不能使用 Action 定义，因为它们应该是双向的。Play 提供了一个辅助工具来帮助处理 WebSockets，该工具的文档位于
    [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$)。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebSockets, which are defined using the helper, use the Play server's underlying
    TCP port.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助工具定义的 WebSockets 使用 Play 服务器底层的 TCP 端口。
- en: WebSockets can be defined similarly to Actions in Play applications. Starting
    from Play 2.3, a WebSocket helper finds a method to define WebSocket interactions
    using an Actor. However, before we learn more about the methods provided by the
    helper, let's take a small detour and get a little familiar with the **Actor Model**
    and **Akka Actors**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 可以在 Play 应用程序中以类似于 Actions 的方式定义。从 Play 2.3 开始，WebSocket 辅助工具找到了使用
    Actor 定义 WebSocket 交互的方法。然而，在我们了解更多关于辅助工具提供的方法之前，让我们稍微偏离一下，先熟悉一下 **Actor Model**
    和 **Akka Actors**。
- en: Actor Model
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor Model
- en: Concurrency in programming can be achieved by using *Threads* which may include
    the risk of a lost update or a deadlock. The Actor Model facilitates concurrency
    by utilizing asynchronous communication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的并发可以通过使用*线程*来实现，这可能会包括丢失更新或死锁的风险。通过利用异步通信，Actor 模型促进了并发。
- en: According to the Actor Model, an actor is the fundamental unit of computation.
    It cannot exist independently, that is, it is always part of a specific actor
    system. An actor can send messages to one or more actors within its actor system
    if it knows the address of the other actor. It can also send messages to itself.
    The order in which the messages are sent or received cannot be guaranteed since
    the communication is asynchronous.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Actor模型，actor是计算的基本单元。它不能独立存在，也就是说，它总是特定actor系统的一部分。如果一个actor知道另一个actor的地址，它可以向其actor系统中的一个或多个actor发送消息。它也可以向自己发送消息。由于通信是异步的，因此无法保证消息发送或接收的顺序。
- en: 'When an actor receives a message, it can do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当actor收到一条消息时，它可以执行以下操作：
- en: Forward it to another actor whose address is known to it
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其转发给另一个已知地址的actor
- en: Create more actors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更多actors
- en: Designate the action it will take for the next message
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定它将为下一条消息采取的操作
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Actor Model was first described in August 1973 in a publication by Carl
    Hewitt, Peter Bishop and Richard Steiger in the paper *A Universal Modular ACTOR
    Formalism for Artificial Intelligence*, which was a part of the International
    Joint Conference on Artificial Intelligence (IJCAI'73).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Actor Model 首次在 1973 年 8 月由 Carl Hewitt、Peter Bishop 和 Richard Steiger 在国际人工智能联合会议（IJCAI'73）论文
    *A Universal Modular ACTOR Formalism for Artificial Intelligence* 中描述，该论文是会议的一部分。
- en: Introducing Akka Actors
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Akka Actors
- en: '**Akka** is a part of the Typesafe Reactive Platform, which is similar to the
    Play Framework. According to their website:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Akka** 是 Typesafe Reactive Platform 的一部分，与 Play 框架类似。根据他们的网站：'
- en: '*Akka is a toolkit and runtime used to build highly concurrent, distributed,
    and fault-tolerant event-driven applications on the JVM.*'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Akka* 是一个用于在 JVM 上构建高度并发、分布式和容错的事件驱动应用的工具包和运行时。'
- en: 'Akka implements a version of the Actor Model, which is commonly called Akka
    Actors and is available for both Java and Scala. According to the Akka documentation,
    Actors give you:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 实现了 Actor Model 的一种版本，通常称为 Akka Actors，并且对 Java 和 Scala 都可用。根据 Akka 文档，Actors
    给你：
- en: Simple and high-level abstractions for concurrency and parallelism
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单且高级的并发和并行抽象
- en: Asynchronous, nonblocking, and highly performant event-driven programming model
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步、非阻塞且高性能的事件驱动编程模型
- en: Very lightweight event-driven processes (several million actors per GB of heap
    memory)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常轻量级的事件驱动进程（每 GB 堆内存中有数百万个 actors）
- en: 'Akka Actors are available as a library and can be used within a project by
    adding them into the dependencies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Actors 可以作为一个库使用，可以通过将它们添加到项目的依赖项中来在项目中使用：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding a dependency in Akka explicitly is not required in a Play project as
    Play uses Akka internally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Play 项目中，不需要在 Akka 中显式添加依赖项，因为 Play 内部使用 Akka。
- en: 'We can then define an actor by extending the Actor trait and defining the behavior
    in the `receive` method. Let''s build an Actor, which reverses any string message
    it receives:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个actor，通过扩展Actor trait并在`receive`方法中定义行为来实现。让我们构建一个actor，它反转接收到的任何字符串消息：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To use the actor, we first need to initialize `ActorSystem`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用actor，我们首先需要初始化`ActorSystem`：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can get a reference of the actor by using the `actorOf` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用`actorOf`方法来获取actor的引用：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This reference can then be used to send messages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引用可以用来发送消息：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s run the application and see what the actor does:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序并看看actor做了什么：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Suppose we wanted to define an Actor that accepted `minLength` and `MaxLength`
    as arguments, we would need to modify the `Reverser` class and its companion as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个接受`minLength`和`MaxLength`作为参数的Actor，我们需要修改`Reverser`类及其伴随类如下：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For more details on Akka actors, refer to [http://akka.io/docs/](http://akka.io/docs/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Akka actor的详细信息，请参阅[http://akka.io/docs/](http://akka.io/docs/)。
- en: WebSocket using Iteratee
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Iteratee的WebSocket
- en: 'Let''s define a WebSocket connection, which accepts strings and sends back
    the reverse of a string using **Iteratee**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个WebSocket连接，它接受字符串并通过**Iteratee**发送字符串的逆序：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `WebSocket.using` method creates a WebSocket of a specific type using an
    Iteratee (inbound channel) and its corresponding enumerator (outbound channel).
    In the preceding code snippet, we return a tuple of the Iteratee in and the Enumerator
    out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket.using`方法使用一个Iteratee（输入通道）及其对应的枚举器（输出通道）创建一个特定类型的WebSocket。在前面的代码片段中，我们返回一个包含Iteratee输入和枚举器输出的元组。'
- en: The `Concurrent` object is also a helper, which provides utilities to use Iteratees,
    Enumerators, and Enumeratees concurrently. The `broadcast[E]` method creates an
    Enumerator and a channel and returns a `(Enumerator[E], Channel[E])` tuple. The
    Enumerator and channel, thus obtained, can be used to broadcast data to multiple
    Iteratees.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concurrent`对象也是一个辅助工具，它提供了使用Iteratee、枚举器和枚举器的并发实用工具。`broadcast[E]`方法创建一个枚举器和通道，并返回一个`(Enumerator[E],
    Channel[E])`元组。因此获得的枚举器和通道可以用来向多个Iteratee广播数据。'
- en: 'After this, we need to bind it to a path in the routes file, which is similar
    to what we do for an Action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要将其绑定到路由文件中的路径，这与我们对Action所做的操作类似：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, using a browser plugin, such as simple WebSocket client for Chrome (refer
    to [https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo](https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo)),
    we can send messages through the WebSocket when an application is running, as
    shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用一个浏览器插件，例如Chrome的简单WebSocket客户端（请参阅[https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo](https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo)），我们可以在应用程序运行时通过WebSocket发送消息，如图所示：
- en: '![WebSocket using Iteratee](img/3803OS_08_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Iteratee的WebSocket](img/3803OS_08_01.jpg)'
- en: 'Since we do not use multiple Iteratees in our application, we can use `Concurrent.unicast`.
    This will require us to modify our code slightly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序中没有使用多个Iteratee，我们可以使用`Concurrent.unicast`。这将需要我们稍微修改我们的代码：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that, unlike the `broadcast` method, the `unicast` method does not return
    a tuple of enumerators and channels, but instead only provides an enumerator.
    We have to declare a channel variable and initialize it with null, so that it
    is accessible within the Iteratee. When the `unicast` method is called, it is
    set to the channel generated within the `unicast` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`broadcast`方法不同，`unicast`方法不返回一个枚举器和通道的元组，而是只提供一个枚举器。我们必须声明一个通道变量并将其初始化为null，以便在Iteratee中可以访问它。当调用`unicast`方法时，它被设置为`unicast`方法内部生成的通道。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `unicast` method also allows us to define the `onComplete` and `onError`
    methods, but they are not aware of the Iteratee, that is, we cannot refer to the
    Iteratee within these methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicast`方法还允许我们定义`onComplete`和`onError`方法，但它们并不了解Iteratee，也就是说，我们无法在这些方法中引用Iteratee。'
- en: This example is overtly simple and does not highlight the complications involved
    in defining and using Iteratees. Let's try a more challenging use case. Now, we
    might need to build a web application that lets users connect to their database
    and load/view data over a WebSocket. Given this condition, the frontend sends
    JSON messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子过于简单，并没有突出定义和使用Iteratee所涉及的复杂性。让我们尝试一个更具挑战性的用例。现在，我们可能需要构建一个允许用户通过WebSocket连接到他们的数据库并加载/查看数据的Web应用程序。在这种情况下，前端发送JSON消息。
- en: 'Now the WebSocket can get any of the following messages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WebSocket可以接收以下任何消息：
- en: '**Connection request**: It is a message that shows the information required
    to connect to a database (such as a host, port, user ID, and password)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接请求**：这是一个显示连接到数据库所需信息的消息（例如主机、端口、用户ID和密码）'
- en: '**Query string**: It is the query to be executed in the database'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询字符串**：这是要在数据库中执行的查询'
- en: '**Disconnect request**: It is a message that closes a connection with the database'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断开连接请求**：这是一个关闭与数据库连接的消息'
- en: After this, the message is translated and sent to the **DBActor**, which sends
    back a status message or a result with row data, and is then translated to JSON
    and sent back by the WebSocket.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，消息被翻译并发送到**DBActor**，它发送回状态消息或带有行数据的查询结果，然后通过WebSocket将其翻译为JSON并发送回。
- en: 'The response received from the DBActor can be one of the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从DBActor收到的响应可以是以下之一：
- en: A successful connection
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功连接
- en: Connection failure
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接失败
- en: Query result
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询结果
- en: Invalid query
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效查询
- en: Disconnected
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已断开连接
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can define a WebSocket handler for this scenario in the following manner:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以下方式定义一个WebSocket处理器来处理此场景：
- en: 'Here, `WebSocketChannel` is an actor, which communicates with the DBActor and
    its companion object and is defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`WebSocketChannel`是一个actor，它与DBActor及其伴随对象通信，并定义如下：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`WebSocketChannel` is defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocketChannel`定义如下：'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `convertJson` translates `JsValue` to the format that
    is understood by the DBActor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`convertJson`将`JsValue`转换为DBActor可以理解的格式。
- en: In the following section, we will implement the same application using the new
    WebSocket methods available in Play since the 2.3.x version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Play 2.3.x版本中可用的新WebSocket方法实现相同的应用程序。
- en: WebSocket using Actors without Iteratees
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Actors而不使用Iterates的WebSocket
- en: 'The Play WebSocket API allows the use of Actors to define the behavior. Let''s
    build the WebSocket application that replies with the reverse of a given String
    once it''s connected. We can do this by slightly modifying our Reverser Actor
    to have an argument as the reference of the Actor to which it can/must send messages,
    as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Play WebSocket API允许使用Actors来定义行为。让我们构建一个WebSocket应用程序，一旦连接，就回复给定字符串的反转。我们可以通过稍微修改我们的Reverser
    Actor，使其具有一个参数作为可以/必须发送消息的Actor的引用来实现，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `websocket` can then be defined in a controller as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`websocket`可以在控制器中如下定义：'
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we make an entry in the routes file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在路由文件中添加一个条目：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can now send messages through the WebSocket when the application is running
    using a browser plugin.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，我们可以通过浏览器插件通过WebSocket发送消息。
- en: 'Now, lets try to implement `dbWebSocket` using this method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用这种方法实现`dbWebSocket`：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `WebSocketChannel` is defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`WebSocketChannel`定义如下：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `convertJsonToMsg` method is responsible for translating JSON to a format
    that is accepted by the DBActor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`convertJsonToMsg`方法负责将JSON转换为DBActor可以接受的格式。'
- en: Closing a WebSocket
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭WebSocket
- en: 'When the WebSocket is closed, Play automatically stops the actor bound to it.
    This binding works in two ways: the WebSocket connection is closed when the underlying
    actor is killed. If there is a need to free any resources once the connection
    is closed, we can do so by overriding the actor''s `postStop` method. In our example,
    we have initialized a DBActor within `WebSocketChannel`. We will need to ensure
    that it''s killed once the WebSocket is closed, since each connection to the WebSocket
    will lead to the initialization of a DBActor. We can do so by sending it a poison
    pill, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebSocket关闭时，Play会自动停止与其绑定的actor。这种绑定以两种方式工作：当底层actor被杀死时，WebSocket连接会关闭。如果需要在连接关闭后释放任何资源，我们可以通过覆盖actor的`postStop`方法来实现。在我们的例子中，我们在`WebSocketChannel`中初始化了一个DBActor。我们需要确保在WebSocket关闭时将其杀死，因为每个WebSocket连接都会导致DBActor的初始化。我们可以通过发送一个毒药丸来实现，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using FrameFormatter
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FrameFormatter
- en: 'Suppose that an incoming JSON has the same fields for every request, instead
    of parsing it every time; we can define an equivalent class in this way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个传入的JSON在每次请求中都有相同的字段，而不是每次都解析它；我们可以以这种方式定义一个等效的类：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can define our WebSocket to translate the JSON message to a `WebSocketRequest`
    automatically. This is possible by specifying the data type for the `acceptWithActor`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的WebSocket，以自动将JSON消息转换为`WebSocketRequest`。这是通过指定`acceptWithActor`方法的数据类型来实现的：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, for this to work as expected, we need two implicit values. The first
    is for translating incoming frames to `WebsocketRequest`, which requires a `JsValue`
    to the `WebSocketRequest` formatter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了按预期工作，我们需要两个隐式值。第一个是将传入的帧转换为`WebsocketRequest`，这需要一个`JsValue`到`WebSocketRequest`格式化器的转换：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, we can specify the types of the outgoing messages as well:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以指定输出消息的类型：
- en: '`FrameFormatter` is a helper and can convert `org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame`
    to `play.core.server.websocket.Frames`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameFormatter`是一个辅助工具，可以将`org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame`转换为`play.core.server.websocket.Frames`。'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The WebSocket methods do not validate the format of data received automatically
    in the same manner as Action parsers. We will need to do this additionally, if
    required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket方法不会像Action解析器那样自动验证接收到的数据的格式。如果需要，我们将需要额外进行此操作。
- en: Troubleshooting
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'What is the equivalent of interrupting `Actions` in `GlobalSettings` for `WebSockets`?
    What if we want to refuse a WebSocket connection when certain headers are missing?
    Something similar to the following code snippet didn''t work as expected:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GlobalSettings`中，`WebSockets`中断`Actions`的等效操作是什么？如果我们想拒绝缺少某些头部的WebSocket连接怎么办？以下代码片段没有按预期工作：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Interrupting WebSocket from the global object does not work as it does for
    Actions. However, there are other means of doing so: by using the `tryAccept`
    and `tryAcceptWithActor` methods. A WebSocket definition can be replaced by the
    following code:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从全局对象中断WebSocket的方式与中断Action的方式不同。然而，还有其他方法可以实现这一点：通过使用`tryAccept`和`tryAcceptWithActor`方法。WebSocket定义可以用以下代码替换：
- en: '[PRE24]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When using an Actor, define a WebSocket with the `tryAcceptWithActor` method:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用Actor时，使用`tryAcceptWithActor`方法定义WebSocket：
- en: '[PRE25]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding examples, we are only checking to see if there is a token header,
    but this can be updated to any other criteria.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是检查是否存在令牌头部，但这可以更新为任何其他标准。
- en: Does Play support wss?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Play支持wss吗？
- en: As of 2.3.x, there is no built-in support for wss. However, it's possible to
    use proxies, such as Nginx or HAProxy as the secure WebSocket (wss) endpoint and
    forward to an internal Play app with an insecure WebSocket endpoint.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至2.3.x版本，没有内置对wss的支持。然而，可以使用代理，如Nginx或HAProxy作为安全的WebSocket（wss）端点，并将请求转发到具有不安全WebSocket端点的内部Play应用程序。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have learned a couple of things in this chapter. This chapter briefly covered
    the Actor Model and usage of Akka Actors in an application. In addition to this,
    we defined a WebSocket connection in a Play application with various constraints
    and requirements using two different approaches: the first one where we use Iteratees
    and Enumerators, and the second where we use Akka Actors.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了一些东西。本章简要介绍了Actor模型以及在应用程序中使用Akka Actor的方法。此外，我们使用两种不同的方法在Play应用程序中定义了具有各种约束和要求的WebSocket连接：第一种方法是我们使用Iteratees和Enumerators，第二种方法是我们使用Akka
    Actors。
- en: In the next chapter, we will see the different ways in which we can test a Play
    application using **Specs2** and **ScalaTest**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到我们可以使用**Specs2**和**ScalaTest**测试Play应用程序的不同方法。
