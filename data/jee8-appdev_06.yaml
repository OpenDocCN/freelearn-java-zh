- en: JSON Processing with JSON-P and JSON-B
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON-P和JSON-B进行JSON处理
- en: '**JSON**, or the **JavaScript Object Notation**, is a human-readable data interchange
    format. As its name implies, JSON is derived from JavaScript. Java EE 7 introduced
    **JSON-P**, the Java API for JSON processing. Java EE 8 introduced an additional
    JSON API, namely, the Java API for **JSON Binding** (**JSON-B**). In this chapter,
    we will cover both JSON-P and JSON-B.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**，或称**JavaScript对象表示法**，是一种人类可读的数据交换格式。正如其名所示，JSON源自JavaScript。Java
    EE 7引入了**JSON-P**，即Java JSON处理API。Java EE 8引入了一个额外的JSON API，即Java API for **JSON绑定**（**JSON-B**）。在本章中，我们将涵盖JSON-P和JSON-B。'
- en: JSON-P includes two APIs for processing JSON, the **Model API** and the **Streaming
    API**, both of which will be covered in this chapter. JSON-B transparently populates
    Java objects from JSON strings, as well as easily generating JSON strings from
    Java objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P包括两个用于处理JSON的API，即**模型API**和**流式API**，这两个API都将在本章中介绍。JSON-B可以透明地从JSON字符串填充Java对象，以及轻松地从Java对象生成JSON字符串。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'The JSON-P Model API:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P模型API：
- en: Generating JSON data with the Model API
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型API生成JSON数据
- en: Parsing JSON data with the Model API
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型API解析JSON数据
- en: 'The JSON-P Streaming API:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P流式API：
- en: Generating JSON data with the Streaming API
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流式API生成JSON数据
- en: Parsing JSON data with the Streaming API
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流式API解析JSON数据
- en: Populating Java objects from JSON with JSON-B
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON-B从JSON填充Java对象
- en: Generating JSON strings from Java objects with JSON-B
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON-B从Java对象生成JSON字符串
- en: The JSON-P Model API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-P模型API
- en: The JSON-P Model API allows us to generate an in-memory representation of a
    JSON object. This API is more flexible than the Streaming API discussed later
    in this chapter, however, it is slower and requires more memory, which can be
    a concern when handling large volumes of data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P模型API允许我们生成一个JSON对象的内存表示。这个API比本章后面讨论的流式API更灵活，然而，它速度较慢且需要更多的内存，这在处理大量数据时可能是一个问题。
- en: Generating JSON data with the Model API
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型API生成JSON数据
- en: At the heart of the JSON-P Model API is the `JsonObjectBuilder` class. This
    class has several overloaded `add()` methods, which can be used to add properties
    and their corresponding values to generated JSON data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P模型API的核心是`JsonObjectBuilder`类。这个类有几个重载的`add()`方法，可以用来向生成的JSON数据添加属性及其对应的值。
- en: 'The following code sample illustrates how to generate JSON data using the Model
    API:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用模型API生成JSON数据：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As can be seen in the preceding example, we generate an instance of `JsonObject`
    by invoking the `add()` method on an instance of `JsonObjectBuilder`. In the preceding
    example, we see how we can add `String` values to our `JsonObject` by invoking
    the `add()` method on `JsonObjectBuilder`. The first parameter of the `add()`
    method is the property name of the generated JSON object, and the second parameter
    corresponds to the value of said property. The return value of the `add()` method
    is another instance of `JsonObjectBuilder`, therefore, invocations to the `add()`
    method can be chained, as shown in the preceding example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们通过在`JsonObjectBuilder`的实例上调用`add()`方法来生成`JsonObject`的实例。在前例中，我们看到如何通过在`JsonObjectBuilder`上调用`add()`方法将`String`值添加到我们的`JsonObject`中。`add()`方法的第一参数是生成的JSON对象的属性名，第二个参数对应于该属性的值。`add()`方法的返回值是另一个`JsonObjectBuilder`的实例，因此，`add()`方法的调用可以像前例那样链式调用。
- en: The preceding example is a CDI-named bean corresponding to a larger JSF application.
    Other parts of the application are not shown because they are not relevant to
    the discussion. The complete sample application can be obtained as part of this
    book's example code download.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个对应于更大JSF应用的CDI命名bean。应用的其他部分没有显示，因为它们与讨论无关。完整的示例应用可以作为本书示例代码下载的一部分获得。
- en: Once we have added all the desired properties, we need to invoke the `build()`
    method of `JsonObjectBuilder`, which returns an instance of a class implementing
    the `JsonObject` interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了所有需要的属性，我们需要调用`JsonObjectBuilder`的`build()`方法，它返回一个实现`JsonObject`接口的类的实例。
- en: In many cases, we will want to generate a `String` representation of the JSON
    object we created so that it can be processed by another process or service. We
    can do this by creating an instance of a class implementing the `JsonWriter` interface
    by invoking the static `createWriter()` method of the `Json` class and passing
    an instance of `StringWriter` as its sole parameter. Once we have an instance
    of the `JsonWriter` implementation, we need to invoke its `writeObject()` method,
    passing our `JsonObject` instance as its sole parameter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能希望生成我们创建的 JSON 对象的 `String` 表示形式，以便它可以被另一个进程或服务处理。我们可以通过创建一个实现 `JsonWriter`
    接口的类的实例，通过调用 `Json` 类的静态 `createWriter()` 方法并传递一个 `StringWriter` 实例作为其唯一参数来实现这一点。一旦我们有了
    `JsonWriter` 实现的实例，我们需要调用它的 `writeObject()` 方法，并将我们的 `JsonObject` 实例作为其唯一参数传递。
- en: At this point, our `StringWriter` instance will have the `String` representation
    of our JSON object as its value, so invoking its `toString()` method will return
    a `String` containing our JSON object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们的 `StringWriter` 实例将包含我们 JSON 对象的 `String` 表示形式作为其值，因此调用其 `toString()`
    方法将返回一个包含我们 JSON 对象的 `String`。
- en: 'Our specific example will generate a JSON string that looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特定示例将生成一个看起来像这样的 JSON 字符串：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although, in our example, we added only `String` objects to our JSON object,
    we are not limited to this type of value; `JsonObjectBuilder` has several overloaded
    versions of its `add()` method, allowing us to add several different types of
    values to our JSON objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的示例中，我们只向我们的 JSON 对象添加了 `String` 对象，但我们并不局限于这种类型的值；`JsonObjectBuilder`
    有几个重载的 `add()` 方法版本，允许我们向我们的 JSON 对象添加几种不同类型的值。
- en: 'The following table summarizes all of the available versions of the `add()`
    method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了所有可用的 `add()` 方法版本：
- en: '| `add`(`String` name, `BigDecimal` value) | Adds a `BigDecimal` value to our
    JSON object. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `BigDecimal` value) | 将一个 `BigDecimal` 值添加到我们的 JSON
    对象中。|'
- en: '| `add`(`String` name, `BigInteger` value) | Adds a `BigInteger` value to our
    JSON object. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `BigInteger` value) | 将一个 `BigInteger` 值添加到我们的 JSON
    对象中。|'
- en: '| `add`(`String` name, `JsonArrayBuilder` value) | Adds an array to our JSON
    object. A `JsonArrayBuilder` implementation allows us to create JSON arrays. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `JsonArrayBuilder` value) | 向我们的 JSON 对象添加一个数组。`JsonArrayBuilder`
    实现允许我们创建 JSON 数组。|'
- en: '| `add`(`String` name, `JsonObjectBuilder` value) | Adds another JSON object
    to our original JSON object (property values for JSON objects can be other JSON
    objects). The added `JsonObject` implementation is built from the provided `JsonObjectBuilder`
    parameter. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `JsonObjectBuilder` value) | 将另一个 JSON 对象添加到我们的原始 JSON
    对象中（JSON 对象的属性值可以是其他 JSON 对象）。添加的 `JsonObject` 实现是由提供的 `JsonObjectBuilder` 参数构建的。|'
- en: '| `add`(`String` name, `JsonValue` value) | Adds another JSON object to our
    original JSON object (property values for JSON objects can be other JSON objects).
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `JsonValue` value) | 将另一个 JSON 对象添加到我们的原始 JSON 对象中（JSON
    对象的属性值可以是其他 JSON 对象）。|'
- en: '| `add`(`String` name, `String` value) | Adds a `String` value to our JSON
    object. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `String` value) | 将一个 `String` 值添加到我们的 JSON 对象中。|'
- en: '| `add`(`String` name, `boolean` value) | Adds a `boolean` value to our JSON
    object. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `boolean` value) | 将一个 `boolean` 值添加到我们的 JSON 对象中。|'
- en: '| `add`(`String` name, `double` value) | Adds a `double` value to our JSON
    object. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `double` value) | 将一个 `double` 值添加到我们的 JSON 对象中。|'
- en: '| `add`(`String` name, `int` value) | Adds an `int` value to our JSON object.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `int` value) | 将一个 `int` 值添加到我们的 JSON 对象中。|'
- en: '| `add`(`String` name, `long` value) | Adds a `long` value to our JSON object.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `add`(`String` name, `long` value) | 将一个 `long` 值添加到我们的 JSON 对象中。|'
- en: In all cases, the first parameter of the `add()` method corresponds to the name
    of the property in our JSON object, and the second parameter corresponds to the
    value of the property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`add()` 方法的第一个参数对应于我们 JSON 对象中的属性名，第二个参数对应于属性的值。
- en: Parsing JSON data with the Model API
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型 API 解析 JSON 数据
- en: 'In the last section, we saw how to generate JSON data from our Java code with
    the object model API. In this section, we will see how we can read and parse existing
    JSON data. The following code sample illustrates how to do this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用对象模型 API 从我们的 Java 代码中生成 JSON 数据。在本节中，我们将了解如何读取和解析现有的 JSON 数据。以下代码示例说明了如何进行此操作：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To parse an existing JSON string, we need to create a `StringReader` object,
    passing the `String` object containing the JSON to be parsed as a parameter. We
    then pass the resulting `StringReader` instance to the static `createReader()`
    method of the `Json` class. This method invocation will return an instance of
    `JsonReader`. We can then obtain an instance of `JsonObject` by invoking the `readObject()`
    method on it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析现有的JSON字符串，我们需要创建一个`StringReader`对象，将包含要解析的JSON的`String`对象作为参数传递。然后，我们将生成的`StringReader`实例传递给`Json`类的静态`createReader()`方法。这个方法调用将返回一个`JsonReader`实例。然后，我们可以通过调用它的`readObject()`方法来获取`JsonObject`的实例。
- en: In the preceding example, we used the `getString()` method to obtain the values
    of all properties in our JSON object. The first and only argument for this method
    is the name of the property we wish to retrieve. Unsurprisingly, the return value
    is the value of the property.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`getString()`方法来获取JSON对象中所有属性的值。此方法的第一和唯一参数是我们希望检索的属性的名称。不出所料，返回值是属性的值。
- en: 'In addition to the `getString()` method, there are several other similar methods
    to obtain values of other types. The following table summarizes these methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`getString()`方法之外，还有其他几个类似的方法可以获取其他类型的数据值。以下表格总结了这些方法：
- en: '| `get`(`Object` key) | Retrieves an instance of a class implementing the `JsonValue`
    interface. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `get`(`Object` key) | 获取实现`JsonValue`接口的类的实例。|'
- en: '| `getBoolean`(`String` name) | Retrieves a `boolean` value corresponding to
    the given key. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `getBoolean`(`String` name) | 获取与给定键对应的`boolean`值。|'
- en: '| `getInt`(`String` name) | Retrieves a `int` value corresponding to the given
    key. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `getInt`(`String` name) | 获取与给定键对应的`int`值。|'
- en: '| `getJsonArray`(`String` name) | Retrieves the instance of a class implementing
    the `JsonArray` interface corresponding to the given key. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonArray`(`String` name) | 获取与给定键对应的实现`JsonArray`接口的类的实例。|'
- en: '| `getJsonNumber`(`String` name) | Retrieves the instance of a class implementing
    the `JsonNumber` interface corresponding to the given key. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonNumber`(`String` name) | 获取与给定键对应的实现`JsonNumber`接口的类的实例。|'
- en: '| `getJsonObject`(`String` name) | Retrieves the instance of a class implementing
    the `JsonObject` interface corresponding to the given key. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonObject`(`String` name) | 获取与给定键对应的实现`JsonObject`接口的类的实例。|'
- en: '| `getJsonString`(`String` name) | Retrieves the instance of a class implementing
    the `JsonString` interface corresponding to the given key. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonString`(`String` name) | 获取与给定键对应的实现`JsonString`接口的类的实例。|'
- en: '| `getString`(`String` name) | Retrieves a `String` corresponding to the given
    key. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `getString`(`String` name) | 获取与给定键对应的`String`。|'
- en: In all cases, the `String` parameter of the method corresponds to the key name,
    and the return value is the JSON property value we wish to retrieve.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，方法中的`String`参数对应于键名，返回值是我们希望检索的JSON属性值。
- en: The JSON-P Streaming API
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-P Streaming API
- en: The JSON-P Streaming API allows sequential reading of a JSON object from a stream
    (a subclass of `java.io.OutputStream` or a subclass of `java.io.Writer`). It is
    faster and more memory efficient than the Model API, however, the trade-off is
    that it is more limited, since the JSON data needs to be read sequentially and
    we cannot access specific JSON properties directly the way the Model API allows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P Streaming API允许从流（`java.io.OutputStream`的子类或`java.io.Writer`的子类）中顺序读取JSON对象。它比Model
    API更快、更节省内存，然而，代价是它的功能更加有限，因为JSON数据需要顺序读取，并且我们不能像Model API那样直接访问特定的JSON属性。
- en: Generating JSON data with the Streaming API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Streaming API生成JSON数据
- en: The JSON Streaming API has a `JsonGenerator` class that we can use to generate
    JSON data and write it to a stream. This class has several overloaded `write()`
    methods, which can be used to add properties and their corresponding values to
    the generated JSON data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Streaming API有一个`JsonGenerator`类，我们可以使用它来生成JSON数据并将其写入流。这个类有几个重载的`write()`方法，可以用来向生成的JSON数据中添加属性及其对应的值。
- en: 'The following code sample illustrates how to generate JSON data using the Streaming
    API:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用Streaming API生成JSON数据：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We create an instance of `JsonGenerator` by invoking the `createGenerator()`
    static method of the `Json` class. The JSON-P API provides two overloaded versions
    of this method: one takes an instance of a class that extends `java.io.Writer`
    (such as `StringWriter`, which we used in our example), and the other one takes
    an instance of a class that extends `java.io.OutputStream`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `Json` 类的 `createGenerator()` 静态方法来创建 `JsonGenerator` 实例。JSON-P API 提供了此方法的两个重载版本：一个接受一个扩展
    `java.io.Writer` 类的实例（例如我们例子中使用的 `StringWriter`），另一个接受一个扩展 `java.io.OutputStream`
    类的实例。
- en: Before we can start adding properties to the generated JSON stream, we need
    to invoke the `writeStartObject()` method on `JsonGenerator`. This method writes
    the JSON start object character (represented by an opening curly brace ("`{`")
    in JSON strings), and returns another instance of `JsonGenerator`, allowing us
    to chain write() invocations to add properties to our JSON stream.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向生成的 JSON 流添加属性之前，我们需要在 `JsonGenerator` 上调用 `writeStartObject()` 方法。此方法写入
    JSON 开始对象字符（在 JSON 字符串中表示为开括号（`{`）），并返回另一个 `JsonGenerator` 实例，允许我们将 `write()`
    调用链式添加到我们的 JSON 流中。
- en: The `write()` method on `JsonGenerator` allows us to add properties to the JSON
    stream we are generating. Its first parameter is a `String` corresponding to the
    name of the property we are adding, and the second parameter is the value of the
    property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonGenerator` 上的 `write()` 方法允许我们向正在生成的 JSON 流中添加属性。它的第一个参数是一个 `String`，对应于我们添加的属性名称，第二个参数是属性的值。'
- en: 'In our example, we are adding only `String` values to the JSON stream we are
    creating, however, we are not limited to Strings; the JSON-P Streaming API provides
    several overloaded `write()` methods that allow us to add several different types
    of data to our JSON stream. The following table summarizes all of the available
    versions of the `write()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只向创建的 JSON 流添加 `String` 值，但我们并不局限于字符串；JSON-P Streaming API 提供了几个重载的
    `write()` 方法，允许我们向 JSON 流添加多种不同类型的数据。以下表格总结了所有可用的 `write()` 方法版本：
- en: '| `write(String name, BigDecimal value)` | Writes a `BigDecimal` value to our
    JSON stream. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, BigDecimal value)` | 将一个 `BigDecimal` 值写入我们的 JSON 流。|'
- en: '| `write(String name, BigInteger value)` | Writes a `BigInteger` value to our
    JSON stream |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, BigInteger value)` | 将一个 `BigInteger` 值写入我们的 JSON 流 |'
- en: '| `write(String name, JsonValue value)` | Writes a JSON object to our JSON
    stream (property values for JSON streams can be other JSON objects) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, JsonValue value)` | 将一个 JSON 对象写入我们的 JSON 流（JSON 流的属性值可以是其他
    JSON 对象）|'
- en: '| `write(String name, String value)` | Writes a `String` value to our JSON
    stream |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, String value)` | 将一个 `String` 值写入我们的 JSON 流 |'
- en: '| `write(String name, boolean value)` | Writes a `boolean` value to our JSON
    stream |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, boolean value)` | 将一个 `boolean` 值写入我们的 JSON 流 |'
- en: '| `write(String name, double value)` | Writes a `double` value to our JSON
    stream |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, double value)` | 将一个 `double` 值写入我们的 JSON 流 |'
- en: '| `write(String name, int value)` | Writes an `int` value to our JSON stream
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, int value)` | 将一个 `int` 值写入我们的 JSON 流 |'
- en: '| `write(String name, long value)` | Writes a `long` value to our JSON stream
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name, long value)` | 将一个 `long` 值写入我们的 JSON 流 |'
- en: In all cases, the first parameter of the `write()` method corresponds to the
    name of the property we are adding to our JSON stream, and the second parameter
    corresponds to the value of the property.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`write()` 方法的第一个参数对应于我们添加到 JSON 流中的属性名称，第二个参数对应于属性的值。
- en: Once we are done adding properties to our JSON stream, we need to invoke the
    `writeEnd()` method on `JsonGenerator`. This method adds the JSON end object character
    (represented by a closing curly brace (`}`) in JSON strings).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成向我们的 JSON 流添加属性后，我们需要在 `JsonGenerator` 上调用 `writeEnd()` 方法。此方法在 JSON 字符串中添加
    JSON 结束对象字符（由一个闭合花括号（`}`）表示）。
- en: At this point, our stream or reader is populated with the JSON data we generated.
    What we do with it depends on our application logic. In our example, we simply
    invoked the `toString()` method of our `StringReader` to obtain the `String` representation
    of the JSON data we created.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的流或读取器中填充了我们生成的 JSON 数据。我们如何处理它取决于我们的应用程序逻辑。在我们的例子中，我们简单地调用了 `StringReader`
    的 `toString()` 方法，以获取我们创建的 JSON 数据的字符串表示形式。
- en: Parsing JSON data with the Streaming API
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streaming API 解析 JSON 数据
- en: 'In this section, we will cover how to parse the JSON data we receive from a
    stream. Please refer to the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何解析我们从流中接收到的 JSON 数据。请参考以下代码：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first thing we need to do to read JSON data using the Streaming API is
    to create an instance of `JsonParser` by invoking the static `createJsonParser()`
    method on the `Json` class. There are two overloaded versions of the `createJsonParser()`
    method: one takes an instance of a class that extends `java.io.InputStream`, the
    other one takes an instance of a class that extends `java.io.Reader`. In our example,
    we use the latter, passing an instance of `java.io.StringReader`, which is a subclass
    of `java.io.Reader`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Streaming API 读取 JSON 数据的第一步是创建一个 `JsonParser` 实例，通过在 `Json` 类上调用静态方法 `createJsonParser()`
    实现。`createJsonParser()` 方法有两种重载版本：一个接受一个扩展 `java.io.InputStream` 类的类的实例，另一个接受一个扩展
    `java.io.Reader` 类的类的实例。在我们的示例中，我们使用后者，传递一个 `java.io.StringReader` 的实例，它是 `java.io.Reader`
    的子类。
- en: The next step is to loop through the JSON data to obtain the data to be parsed.
    We can achieve this by invoking the `hasNext()` method on `JsonParser`, which
    returns true if there is more data to be read, and false otherwise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是循环遍历 JSON 数据以获取要解析的数据。我们可以通过在 `JsonParser` 上调用 `hasNext()` 方法来实现这一点，如果还有更多数据要读取，则返回
    `true`，否则返回 `false`。
- en: We then need to read the next piece of data in our stream. The `JsonParser.next()`
    method returns an instance of `JsonParser.Event`, which indicates the type of
    data that we just read. In our example, we check only for key names (that is,
    `firstName`, `lastName`, and `email`), and the corresponding string values. We
    check for the type of data we just read by comparing the event returned by `JsonParser.next()`
    against several values defined in the `Event` enum defined in `JsonParser`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要读取流中的下一份数据。`JsonParser.next()` 方法返回一个 `JsonParser.Event` 实例，它表示我们刚刚读取的数据类型。在我们的示例中，我们只检查键名（即
    `firstName`、`lastName` 和 `email`），以及相应的字符串值。我们通过将 `JsonParser.next()` 返回的事件与在
    `JsonParser` 中定义的 `Event` 枚举中定义的几个值进行比较来检查我们刚刚读取的数据类型。
- en: 'The following table summarizes all of the possible events that can be returned
    from `JsonParser.next()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了 `JsonParser.next()` 可以返回的所有可能的事件：
- en: '| `Event.START_OBJECT` | Indicates the start of a JSON object. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Event.START_OBJECT` | 表示 JSON 对象的开始。|'
- en: '| `Event.END_OBJECT` | Indicates the end of a JSON object. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Event.END_OBJECT` | 表示 JSON 对象的结束。|'
- en: '| `Event.START_ARRAY` | Indicates the start of an array. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Event.START_ARRAY` | 表示数组的开始。|'
- en: '| `Event.END_ARRAY` | Indicates the end of an array. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Event.END_ARRAY` | 表示数组的结束。|'
- en: '| `Event.KEY_NAME` | Indicates the name of a JSON property was read; we can
    obtain the key name by invoking `getString()` on `JsonParser`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Event.KEY_NAME` | 表示读取了一个 JSON 属性的名称；我们可以通过在 `JsonParser` 上调用 `getString()`
    来获取键名。|'
- en: '| `Event.VALUE_TRUE` | Indicates that a Boolean value of `true` was read. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_TRUE` | 表示读取了一个 `true` 的布尔值。|'
- en: '| `Event.VALUE_FALSE` | Indicates that a Boolean value of `false` was read.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_FALSE` | 表示读取了一个 `false` 的布尔值。|'
- en: '| `Event.VALUE_NULL` | Indicates that a `null` value was read. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_NULL` | 表示读取了一个 `null` 值。|'
- en: '| `Event.VALUE_NUMBER` | Indicates that a `numeric` value was read. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_NUMBER` | 表示读取了一个 `numeric` 值。|'
- en: '| `Event.VALUE_STRING` | Indicates that a `string` value was read. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_STRING` | 表示读取了一个 `string` 值。|'
- en: 'As shown in the example, `String` values can be retrieved by invoking `getString()`
    on `JsonParser`. Numeric values can be retrieved in several different formats;
    the following table summarizes the methods in `JsonParser` that can be used to
    retrieve numeric values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，可以通过在 `JsonParser` 上调用 `getString()` 来检索 `String` 值。数值可以以几种不同的格式检索；以下表格总结了
    `JsonParser` 中可以用来检索数值的方法：
- en: '| `getInt()` | Retrieves the numeric value as an `int`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `getInt()` | 以 `int` 的形式检索数值。|'
- en: '| `getLong()` | Retrieves the numeric value as a `long`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `getLong()` | 以 `long` 的形式检索数值。|'
- en: '| `getBigDecimal()` | Retrieves the numeric value as an instance of `java.math.BigDecimal`.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `getBigDecimal()` | 以 `java.math.BigDecimal` 实例的形式检索数值。|'
- en: '`JsonParser` also provides a convenience `isIntegralNumber()` method, which
    returns `true` if the numeric value can be safely cast to an `int` or a `long`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonParser` 还提供了一个方便的 `isIntegralNumber()` 方法，如果数值可以安全地转换为 `int` 或 `long`，则返回
    `true`。'
- en: What we do with the values we obtain from the stream depends on our application
    logic. In our example, we place them on a `Map`, then use said `Map` to populate
    a Java class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对从流中获取的值所做的事情取决于我们的应用程序逻辑。在我们的示例中，我们将它们放置在一个 `Map` 中，然后使用这个 `Map` 来填充一个 Java
    类。
- en: JSON pointer
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 指针
- en: JSON-P 1.1, introduced in Java EE 8, introduces support for JSON Pointer. JSON
    Pointer is an **Internet Engineering Task Force** (**IETF**) standard that defines
    a string syntax to identify a specific value within a JSON document, similar to
    what XPath provides for XML documents.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8 中引入的 JSON-P 1.1 引入了对 JSON Pointer 的支持。JSON Pointer 是一个 **互联网工程任务组**
    (**IETF**) 标准，它定义了一种字符串语法，用于在 JSON 文档中标识特定的值，类似于 XPath 为 XML 文档提供的功能。
- en: 'The syntax for JSON Pointer is straightforward, for example, suppose we have
    the following JSON document:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Pointer 的语法很简单，例如，假设我们有以下 JSON 文档：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we would like to obtain the value of the `lastName` property of the document,
    the JSON Pointer expression to use would be `"/lastName"`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取文档中 `lastName` 属性的值，要使用的 JSON Pointer 表达式将是 `"/lastName"`。
- en: 'If our JSON document consisted of an array, then we would have to prefix the
    property with the index in the array, for example, to obtain the `lastName` property
    of the second element in the following JSON array:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 JSON 文档由一个数组组成，那么我们必须在属性前加上数组中的索引作为前缀，例如，要获取以下 JSON 数组中第二个元素的 `lastName`
    属性，我们需要这样做：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The JSON Pointer expression to do so would be `"/1/lastName"`. The `"/1"` at
    the beginning of the expression refers to the element index in the array. Just
    as in Java, JSON arrays are `0` indexed, therefore, in this example, we are obtaining
    the value of the `lastName` property in the second element of the array. Let''s
    now look at an example of how we would use the new JSON-P JSON Pointer API to
    perform this task:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，JSON Pointer 表达式将是 `"/1/lastName"`。表达式开头的 `"/1"` 指的是数组中的元素索引。就像在 Java 中一样，JSON
    数组是 `0` 索引的，因此，在这个例子中，我们正在获取数组中第二个元素的 `lastName` 属性的值。现在让我们看看如何使用新的 JSON-P JSON
    Pointer API 来执行此任务的示例：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code sample is a RESTful web service written using Java EE's JAX-RS
    API (see [Chapter 10](4987ac18-1f2a-410c-9613-530174a64bad.xhtml), *RESTful Web
    Services with JAX-RS* for details). In order to read property values from a JSON
    document, we first need to create an instance of `javax.json.JsonReader` by invoking
    the static `createReader()` method on `javax.json.Json`. The `createReader()`
    method takes an instance of any class implementing the `java.io.Reader` interface
    as an argument. In our example, we are creating a new instance of `java.io.StringReader`
    on the fly, and passing our JSON string as a parameter to its constructor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例是一个使用 Java EE 的 JAX-RS API 编写的 RESTful 网络服务（有关详细信息，请参阅第 10 章 [4987ac18-1f2a-410c-9613-530174a64bad.xhtml]，*使用
    JAX-RS 的 RESTful 网络服务*）。为了从 JSON 文档中读取属性值，我们首先需要通过在 `javax.json.Json` 上调用静态的 `createReader()`
    方法来创建一个 `javax.json.JsonReader` 的实例。`createReader()` 方法接受任何实现 `java.io.Reader`
    接口类的实例作为参数。在我们的例子中，我们即时创建了一个新的 `java.io.StringReader` 实例，并将我们的 JSON 字符串作为参数传递给其构造函数。
- en: There is an overloaded version of `JSON.createReader()` that takes an instance
    of any class implementing `java.io.InputStream`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.createReader()` 有一个重载版本，它接受任何实现 `java.io.InputStream` 类的实例。'
- en: In our example, our JSON document consists of an array of objects, therefore,
    we populate an instance of `javax.json.JsonArray` by invoking the `readArray()`
    method on the `JsonReader` object we created (if our JSON document had consisted
    of a single JSON object, we would have invoked `JsonReader.readObject()` instead).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们的 JSON 文档由一个对象数组组成，因此，我们通过在创建的 `JsonReader` 对象上调用 `readArray()` 方法来填充
    `javax.json.JsonArray` 的一个实例（如果我们的 JSON 文档由一个单独的 JSON 对象组成，我们则会调用 `JsonReader.readObject()`）。
- en: Now that we have populated our `JsonArray` variable, we create an instance of
    `javax.json.JsonPointer` and initialize it with the JSON Pointer expression we
    want to use to obtain the value we are searching for. Remember that we are looking
    for the value of the `lastName` property in the second element of the array, therefore,
    the appropriate JSON Pointer expression is `/1/lastName`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填充了我们的 `JsonArray` 变量，我们创建了一个 `javax.json.JsonPointer` 的实例，并用我们想要使用的 JSON
    Pointer 表达式初始化它。记住，我们正在寻找数组中第二个元素的 `lastName` 属性的值，因此，适当的 JSON Pointer 表达式是 `/1/lastName`。
- en: Now that we have created an instance of `JsonPointer` with the appropriate JSON
    Pointer expression, we simply invoke its `getValue()` method, passing our `JsonArray`
    object as a parameter, then invoke `toString()` on the result. The return value
    of this invocation will be the value of the `lastName` property on the JSON document
    ("Heffelfinger", in our example).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个带有适当 JSON Pointer 表达式的 `JsonPointer` 实例，我们只需调用它的 `getValue()` 方法，并将我们的
    `JsonArray` 对象作为参数传递，然后对结果调用 `toString()`。这个调用的返回值将是 JSON 文档中 `lastName` 属性的值（在我们的示例中是
    "Heffelfinger"）。
- en: JSON Patch
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Patch
- en: JSON-P 1.1 also introduced support for JSON Patch, another **Internet Engineering
    Task Force** standard, this one providing a series of operations that can be applied
    to a JSON document. JSON Patch allows us to perform partial updates on a JSON
    object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P 1.1 还引入了对 JSON Patch 的支持，这是另一个 **互联网工程任务组** 标准，它提供了一系列可以应用于 JSON 文档的操作。JSON
    Patch 允许我们对 JSON 对象进行部分更新。
- en: 'The following operations are supported by JSON Patch:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Patch 支持以下操作：
- en: '| **JSON Patch Operation** | **Description** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **JSON Patch 操作** | **描述** |'
- en: '| `add` | Adds an element to a JSON document. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 向 JSON 文档中添加一个元素。|'
- en: '| `remove` | Removes an element from a JSON document. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 从 JSON 文档中删除一个元素。|'
- en: '| `replace` | Replaces a value in a JSON document with a new value. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | 用新值替换 JSON 文档中的一个值。|'
- en: '| `move` | Moves a value in a JSON document from its current location in the
    document to a new position. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `move` | 将 JSON 文档中的一个值从其在文档中的当前位置移动到新位置。|'
- en: '| `copy` | Copies a value in a JSON document to a new location in the document.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | 将 JSON 文档中的一个值复制到文档中的新位置。|'
- en: '| `test` | Verifies that the value in a specific location in a JSON document
    is equal to the specified value. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `test` | 验证 JSON 文档中特定位置的值是否等于指定的值。|'
- en: JSON-P supports all of the preceding JSON Patch operations, which rely on JSON
    Pointer expressions to locate the source and target locations in JSON documents.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P 支持所有上述 JSON Patch 操作，这些操作依赖于 JSON Pointer 表达式来定位 JSON 文档中的源和目标位置。
- en: 'The following example illustrates how we can use JSON Patch with JSON-P 1.1:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何使用 JSON-P 1.1 与 JSON Patch：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, let''s assume we are dealing with the same JSON document we
    used in our previous example: an array of two individual JSON objects, each with
    a `dateOfBirth` property (among other properties).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，让我们假设我们正在处理与之前示例相同的 JSON 文档：一个包含两个单独 JSON 对象的数组，每个对象都有一个 `dateOfBirth`
    属性（以及其他属性）。
- en: In our example, we create an instance of `JsonArray`, as before, then modify
    the `dateOfBirth` of the second element in the array. In order to do this, we
    create an instance of `javax.json.JsonPatchBuilder` via the static `createPatchBuilder()`
    method in the `javax.json.Json` class. In our example, we are replacing the value
    of one of the properties with a new value. We use the `replace()` method of our
    `JsonPatch` instance to accomplish this; the first argument in the method is a
    JSON Pointer expression indicating the location of the property we are going to
    modify, the second argument is the new value for the property. As its name implies
    `JsonPatchBuilder` follows the `Builder` design pattern, meaning that most of
    its methods return another instance of `JsonPatchBuilder`; this allows us to chain
    method calls on the resulting instances of `JsonPatchBuilder` (in our example,
    we are performing only one operation, but this doesn't have to be the case).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个 `JsonArray` 实例，就像之前一样，然后修改数组中第二个元素的 `dateOfBirth` 属性。为了做到这一点，我们通过
    `javax.json.Json` 类中的静态 `createPatchBuilder()` 方法创建了一个 `javax.json.JsonPatchBuilder`
    实例。在我们的示例中，我们用一个新值替换了一个属性的值。我们使用 `JsonPatch` 实例的 `replace()` 方法来完成这个操作；方法中的第一个参数是一个
    JSON Pointer 表达式，指示我们要修改的属性的定位，第二个参数是属性的新值。正如其名称所暗示的，`JsonPatchBuilder` 遵循 `Builder`
    设计模式，这意味着它的大多数方法都返回另一个 `JsonPatchBuilder` 实例；这允许我们在 `JsonPatchBuilder` 的结果实例上链式调用方法（在我们的示例中，我们只执行一个操作，但这不必是这种情况）。
- en: Once we are done specifying the operation(s) to perform on our JSON object,
    we create an instance of `javax.json.JsonPatch` by invoking the `build()` method
    on `JsonPatchBuilder`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了要在我们的 JSON 对象上执行的操作，我们就通过在 `JsonPatchBuilder` 上调用 `build()` 方法来创建一个 `javax.json.JsonPatch`
    实例。
- en: Once we have created the patch, we apply it to our JSON object (an instance
    of `JsonArray`, in our example), by invoking its `patch()` method, passing the
    JSON object as a parameter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了补丁，我们就通过调用其 `patch()` 方法并将其作为参数传递 JSON 对象（在我们的示例中是一个 `JsonArray` 实例）来将其应用到我们的
    JSON 对象上。
- en: In our example of how to replace the value of a JSON property with another via
    JSON Patch support in JSON-P 1.1, JSON-P supports all operations currently supported
    by JSON Patch. The API is straightforward. For details on how to use other JSON
    Patch operations with JSON-P, consult the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，如何通过 JSON-P 1.1 中的 JSON Patch 支持替换 JSON 属性的值，JSON-P 支持当前 JSON Patch
    所支持的所有操作。API 是直接的。有关如何使用 JSON-P 中的其他 JSON Patch 操作的详细信息，请参阅 Java EE 8 API 文档，网址为
    [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)。
- en: Populating Java objects from JSON with JSON-B
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON-B 从 JSON 填充 Java 对象
- en: A common programming task is to populate Java objects from JSON strings. It
    is such a common tasks that several libraries have been created to transparently
    populate Java objects from JSON, freeing application developers from having to
    manually code this functionality. There are some non-standard Java libraries that
    accomplish this task, such as Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)),
    JSON-simple ([https://github.com/fangyidong/json-simple](https://github.com/fangyidong/json-simple)),
    and Gson ([https://github.com/google/gson](https://github.com/google/gson)). Java
    EE 8 introduces a new API providing this functionality, namely the Java API for
    JSON Binding (JSON-B). In this section, we will cover how to transparently populate
    a Java object from a JSON string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 填充 Java 对象从 JSON 字符串是一个常见的编程任务。这是一个如此常见的任务，以至于已经创建了几个库来透明地填充 Java 对象从 JSON，从而让应用程序开发者免于手动编写此功能。有一些非标准的
    Java 库可以完成这个任务，例如 Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson))、JSON-simple
    ([https://github.com/fangyidong/json-simple](https://github.com/fangyidong/json-simple))
    和 Gson ([https://github.com/google/gson](https://github.com/google/gson))。Java
    EE 8 引入了一个提供此功能的新 API，即 Java API for JSON Binding (JSON-B)。在本节中，我们将介绍如何透明地从 JSON
    字符串填充 Java 对象。
- en: 'The following example shows a RESTful web service written using the Java API
    for RESTful Web Services (JAX-RS). The service responds to HTTP POST requests
    in its `addCustomer()` method. This method takes a `String` as a parameter and
    this string is expected to contain valid JSON. Please refer to the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用 Java API for RESTful Web Services (JAX-RS) 编写的 RESTful 网络服务。该服务在其
    `addCustomer()` 方法中响应 HTTP POST 请求。此方法接受一个 `String` 参数，并且这个字符串预期包含有效的 JSON。请参考以下代码：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The JSON-B implementation provided by our application server provides an instance
    of a class implementing the `JsonbBuilder` interface. This class provides a static
    `create()` method that we can use to obtain an instance of `Jsonb`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用服务器提供的 JSON-B 实现提供了一个实现 `JsonbBuilder` 接口的类的实例。这个类提供了一个静态的 `create()` 方法，我们可以使用它来获取
    `Jsonb` 的实例。
- en: Once we have an instance of `Jsonb`, we can use it to parse a JSON string and
    automatically populate a Java object. This is done via its `fromJson()` method.
    The `fromJson()` method takes a `String` containing the JSON data we need to parse
    as its first parameter, and the type of the object we wish to populate as its
    second parameter. In our example, we are populating a simple `Customer` class
    containing fields such as `firstName`, `middleName`, `lastName`, and `dateOfBirth`.
    JSON-B will look for JSON property names matching the property names in the Java
    object and automatically populate the Java object with the corresponding JSON
    properties. It couldn't be more simple than that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `Jsonb` 的实例，我们可以使用它来解析 JSON 字符串并自动填充 Java 对象。这是通过其 `fromJson()` 方法完成的。`fromJson()`
    方法接受一个包含我们需要解析的 JSON 数据的 `String` 作为其第一个参数，以及我们希望填充的对象的类型作为其第二个参数。在我们的例子中，我们正在填充一个包含
    `firstName`、`middleName`、`lastName` 和 `dateOfBirth` 等字段的简单 `Customer` 类。JSON-B
    将寻找与 Java 对象中的属性名称匹配的 JSON 属性名称，并自动用相应的 JSON 属性填充 Java 对象。这再简单不过了。
- en: Once we have populated our Java object, we can do whatever we need to do with
    it. In our example, we simply log the properties of the Java object to verify
    that it was populated correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们填充了我们的 Java 对象，我们就可以用它做我们需要的任何事情。在我们的例子中，我们只是记录 Java 对象的属性，以验证它是否正确填充。
- en: Generating JSON strings from Java objects with JSON-B
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON-B 从 Java 对象生成 JSON 字符串
- en: 'In addition to populating Java objects from JSON data, JSON-B can also generate
    JSON strings from Java objects. The following example illustrates how to do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 JSON 数据填充 Java 对象之外，JSON-B 还可以从 Java 对象生成 JSON 字符串。以下示例说明了如何做到这一点：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are converting a `List` of `Customer` objects to JSON.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `Customer` 对象的 `List` 转换为 JSON。
- en: We chose a `List` for the example to illustrate that JSON-B supports this functionality,
    but of course, we could also convert a single object to its JSON representation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 `List` 作为示例来说明 JSON-B 支持此功能，但当然，我们也可以将单个对象转换为它的 JSON 表示形式。
- en: Just as before, we create an instance of `javax.json.bind.Jsonb` by invoking
    the static `javax.json.bind.JsonbBuilder.create()` method. Once we have our `Jsonb`
    instance, we simply invoke its `toJson()` method to convert the list of objects
    to its equivalent JSON representation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们通过调用静态方法 `javax.json.bind.JsonbBuilder.create()` 来创建一个 `javax.json.bind.Jsonb`
    实例。一旦我们有了 `Jsonb` 实例，我们只需调用它的 `toJson()` 方法，将对象列表转换为等价的 JSON 表示形式。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Java API for JSON Processing (JSON-P). We illustrated
    how to generate and parse JSON data via JSON-P's model and Streaming APIs. Additionally,
    we covered new JSON-P 1.1 features, such as support for JSON Pointer and JSON
    Patch. Finally, we covered how to seamlessly populate Java objects from JSON,
    and how to easily generate JSON strings from Java objects via the new JSON-B API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java API for JSON Processing (JSON-P)。我们展示了如何通过 JSON-P 的模型和流式 API
    生成和解析 JSON 数据。此外，我们还介绍了新的 JSON-P 1.1 功能，例如对 JSON Pointer 和 JSON Patch 的支持。最后，我们介绍了如何无缝地将
    Java 对象从 JSON 中填充，以及如何通过新的 JSON-B API 简单地生成 Java 对象的 JSON 字符串。
