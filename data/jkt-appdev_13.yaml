- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Jakarta Messaging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Messaging
- en: '**Jakarta Messaging** provides a mechanism for Jakarta EE applications to send
    messages to each other. Jakarta Messaging applications do not communicate directly;
    instead, message producers send messages to a destination, and message consumers
    receive the message from the destination.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jakarta Messaging**为Jakarta EE应用程序之间发送消息提供了一种机制。Jakarta Messaging应用程序不直接通信；相反，消息生产者将消息发送到目的地，而消息消费者从目的地接收消息。'
- en: The message destination is a message queue when the **point-to-point** (**PTP**)
    messaging domain is used, or a message topic when the **publish/subscribe** (**pub/sub**)
    messaging domain is used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**点对点**（**PTP**）消息域时，消息目的地是消息队列，或者当使用**发布/订阅**（**pub/sub**）消息域时，消息目的地是消息主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Working with message queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与消息队列一起工作
- en: Working with message topics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与消息主题一起工作
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src)。
- en: Working with message queues
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与消息队列一起工作
- en: As we mentioned earlier, message queues are used when our Jakarta Messaging
    code uses the PTP messaging domain. For the PTP messaging domain, there is usually
    one message producer and one message consumer. The message producer and the message
    consumer don’t need to be running concurrently in order to communicate. The messages
    placed in the message queue by the message producer will stay in the message queue
    until the message consumer executes and requests the messages from the queue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，当我们的Jakarta Messaging代码使用PTP消息域时，会使用消息队列。对于PTP消息域，通常有一个消息生产者和一个消息消费者。消息生产者和消息消费者不需要同时运行以进行通信。消息生产者放入消息队列中的消息将保持在消息队列中，直到消息消费者执行并从队列中请求这些消息。
- en: Sending messages to a message queue
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向消息队列发送消息
- en: 'The following example illustrates how to add messages to a message queue:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息队列添加消息：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most examples in this chapter are implemented as **Contexts and Dependency Injection**
    (**CDI**) beans. Refer to [*Chapter 2*](B21231_02.xhtml#_idTextAnchor022) for
    an explanation of CDI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数示例都是作为**上下文和依赖注入**（**CDI**）豆实现的。有关CDI的解释，请参阅[*第2章*](B21231_02.xhtml#_idTextAnchor022)。
- en: The class-level `@JMSDestinationDefinition` annotation defines a Jakarta Messaging
    destination where our messages will be placed. This annotation has two required
    attributes, `name` and `interfaceName`. The `name` attribute of `@JMSDestinationDefinition`
    defines a `interfaceName` specifies the Jakarta Messaging destination interface;
    PTP messaging, this value must always be `produceMessages()` method of the preceding
    class is invoked from a `commandButton` from a Jakarta Faces page implemented
    using Facelets. For brevity, we will not show the XHTML markup for this page.
    The code download bundle for this chapter contains the complete example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@JMSDestinationDefinition`注解定义了一个Jakarta Messaging目的地，我们的消息将被放置在这里。此注解有两个必需的属性，`name`和`interfaceName`。`@JMSDestinationDefinition`的`name`属性定义了一个`interfaceName`，它指定了Jakarta
    Messaging目的地接口；对于PTP消息，此值必须始终是`produceMessages()`方法，该方法从使用Facelets实现的Jakarta Faces页面上的`commandButton`调用前面的类。为了简洁，我们不会显示此页面的XHTML标记。本章的代码下载包包含完整的示例。
- en: The `produceMessages()` method in the `MessageSender` class performs all the
    necessary steps to send messages to a message queue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSender`类中的`produceMessages()`方法执行所有必要的步骤以将消息发送到消息队列。'
- en: The first thing this method does is create an instance of `jakarta.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `jakarta.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the `name` attribute of the `@JMSDestinationDefinition`
    annotation. Behind the scenes, a JNDI lookup is made using this name to obtain
    the connection factory object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先执行的操作是通过在注入的`jakarta.jms.ConnectionFactory`实例上调用`createContext()`方法来创建一个`jakarta.jms.JMSContext`实例。请注意，装饰连接工厂对象的`@Resource`注解的`mappedName`属性与`@JMSDestinationDefinition`注解的`name`属性相匹配。在幕后，使用此名称进行JNDI查找以获取连接工厂对象。
- en: Next, we create an instance of `jakarta.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在刚刚创建的`JMSContext`实例上调用`createProducer()`方法来创建`jakarta.jms.JMSProducer`实例。
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method. This method takes the message destination
    as its first parameter, and a `String` containing the message text as its second
    parameter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`JMSProducer`实例后，代码通过调用其`send()`方法发送一系列文本消息。此方法将消息目的地作为其第一个参数，将包含消息文本的`String`作为其第二个参数。
- en: There are several overloaded versions of the `send()` method in `JMSProducer`.
    The one we used in our example is a convenient method that creates an instance
    of `jakarta.jms.TextMessage` and sets its text to the `String` we provide as the
    second parameter in the method invocation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JMSProducer`中，`send()`方法有几个重载版本。我们在示例中使用的是一种方便的方法，它创建`jakarta.jms.TextMessage`实例并将其文本设置为方法调用中提供的第二个参数的`String`。
- en: 'Although the preceding example sends only text messages to the queue, we are
    not limited to this type of message. Jakarta Messaging provides several types
    of messages that can be sent and received by Jakarta Messaging applications. All
    message types are defined as interfaces in the `jakarta.jms` package. *Table 13.1*
    lists all of the available message types:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前例只向队列发送文本消息，但我们并不局限于这种消息类型。Jakarta Messaging提供了多种类型的消息，这些消息可以被Jakarta Messaging应用程序发送和接收。所有消息类型都在`jakarta.jms`包中定义为接口。*表13.1*列出了所有可用的消息类型：
- en: '| **Message Type** | **Description** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **消息类型** | **描述** |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenient `send()` method that takes an array of bytes as one of its parameters.
    This method creates an instance of `jakarta.jms.BytesMessage` on the fly as the
    message is being sent. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `BytesMessage` | 允许发送字节数组作为消息。`JMSProducer`有一个方便的`send()`方法，它将字节数组作为其参数之一。此方法在发送消息时即时创建`jakarta.jms.BytesMessage`实例。|'
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenient `send()` method that takes a `Map` as one of its
    parameters. This method creates an instance of `jakarta.jms.MapMessage` on the
    fly as the message is being sent. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `MapMessage` | 允许发送实现`java.util.Map`接口的消息。`JMSProducer`有一个方便的`send()`方法，它将`Map`作为其参数之一。此方法在发送消息时即时创建`jakarta.jms.MapMessage`实例。|'
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenient `send()` method, which takes an instance
    of a class implementing `java.io.Serializable` as its second parameter. This method
    creates an instance of `jakarta.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `ObjectMessage` | 允许发送实现`java.io.Serializable`接口的任何Java对象作为消息。`JMSProducer`有一个方便的`send()`方法，它将实现`java.io.Serializable`接口的类的实例作为其第二个参数。此方法在发送消息时即时创建`jakarta.jms.ObjectMessage`实例。|'
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive added to the
    stream |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `StreamMessage` | 允许发送字节数组作为消息。与`BytesMessage`不同，它存储添加到流中的每个原始类型的类型。|'
- en: '| `TextMessage` | Allows sending `java.lang.String` as a message. As seen in
    the preceding example, `JMSProducer` has a convenient `send()` method that takes
    a `String` as its second parameter. This method creates an instance of `jakarta.jms.TextMessage`
    on the fly as the message is being sent. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `TextMessage` | 允许发送`java.lang.String`作为消息。如前例所示，`JMSProducer`有一个方便的`send()`方法，它将`String`作为其第二个参数。此方法在发送消息时即时创建`jakarta.jms.TextMessage`实例。|'
- en: Table 13.1 – Jakarta Messaging message types
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 – Jakarta Messaging消息类型
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on all of the preceding message types, consult the `JavaDoc`
    documentation at [https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary](https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有上述消息类型的更多信息，请参阅[https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary](https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary)的`JavaDoc`文档。
- en: Retrieving messages from a message queue
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从消息队列中检索消息
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a message queue:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有任何接收者，从队列中发送消息是没有意义的。以下示例说明了如何从消息队列中检索消息：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just like in the previous example, we define a destination via the `@JMSDestinationDefinition`
    annotation, plus we inject instances of `jakarta.jms.ConnectionFactory` and `jakarta.jms.Queue`
    by using the `@``Resource` annotation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的示例中一样，我们通过`@JMSDestinationDefinition`注解定义了一个目的地，并且通过使用`@Resource`注解注入了`jakarta.jms.ConnectionFactory`和`jakarta.jms.Queue`的实例。
- en: In our code, we get an instance of `jakarta.jms.JMSContext` by invoking the
    `createContext()` method of `ConnectionFactory`, just like in the previous example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过调用`ConnectionFactory`的`createContext()`方法来获取`jakarta.jms.JMSContext`的实例，就像在之前的示例中一样。
- en: In this example, we obtain an instance of `jakarta.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过在我们的`JMSContext`实例上调用`createConsumer()`方法来获取`jakarta.jms.JMSConsumer`的实例。
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example). This method returns an object
    of the type specified in its parameter (an instance of `java.lang.String` in our
    example). Once the message is consumed by `JMSConsumer.receiveBody()`, it is removed
    from the queue.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的`JMSConsumer`实例上调用`receiveBody()`方法来接收消息。此方法只接受我们期望的消息类型作为其唯一参数（在我们的示例中为`String.class`）。此方法返回其参数指定的类型的对象（在我们的示例中为`java.lang.String`的实例）。一旦消息被`JMSConsumer.receiveBody()`消费，它就会从队列中移除。
- en: In this particular example, we placed this method call in a `while` loop since
    we are expecting a message that will let us know no more messages are coming.
    Specifically, we are looking for a message containing the text “Good bye!”. Once
    we receive said message, we break out of the loop and continue processing. In
    this particular case, there is no more processing to do, therefore execution ends
    after we break out of the loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们将这个方法调用放在了一个`while`循环中，因为我们期望一个消息会告诉我们没有更多的消息到来。具体来说，我们正在寻找包含文本“再见！”的消息。一旦我们收到这个消息，我们就跳出循环并继续处理。在这个特定的案例中，没有更多的处理要做，因此执行在跳出循环后结束。
- en: 'After executing the code, we should see the following output in the server
    log:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该在服务器日志中看到以下输出：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This of course assumes that the previous example was already executed and it
    placed messages in the message queue.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设之前的示例已经执行，并且它已经将消息放入了消息队列。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A disadvantage of processing messages as discussed in this section is that message
    processing is synchronous. In Jakarta EE environments, we can process messages
    asynchronously by employing message-driven beans, as discussed in [*Chapter 12*](B21231_12.xhtml#_idTextAnchor164).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的消息处理的一个缺点是消息处理是同步的。在Jakarta EE环境中，我们可以通过使用消息驱动豆（如[*第12章*](B21231_12.xhtml#_idTextAnchor164)中讨论的那样）来异步处理消息。
- en: Browsing message queues
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览消息队列
- en: 'Jakarta Messaging provides a way to browse message queues without actually
    removing the messages from the queue. The following example illustrates how to
    do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Messaging提供了一种方法来浏览消息队列，而实际上并不从队列中移除消息。以下示例说明了如何做到这一点：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a connection factory, a queue, and a context the usual way, then invoke
    the `createBrowser()` method on the context object. This method returns an implementation
    of the `jakarta.jms.QueueBrowser` interface. This interface contains a `getEnumeration()`
    method, which we can invoke to obtain an `Enumeration` containing all messages
    in the queue. To examine the messages in the queue, we simply traverse this enumeration
    and obtain the messages one by one. In the example that we discussed, we simply
    invoke the `getText()` method of each message in the queue.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，浏览消息队列的流程非常直接。我们以通常的方式获取连接工厂、队列和上下文，然后在上下文对象上调用`createBrowser()`方法。此方法返回`jakarta.jms.QueueBrowser`接口的实现。此接口包含一个`getEnumeration()`方法，我们可以调用它来获取包含队列中所有消息的`Enumeration`。要检查队列中的消息，我们只需遍历这个枚举并逐个获取消息。在我们讨论的示例中，我们简单地调用队列中每个消息的`getText()`方法。
- en: Now that we’ve seen how to send and receive messages to and from a queue with
    the PTP messaging domain, we’ll focus our attention on sending and receiving messages
    to and from message topics with the pub/sub messaging domain.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用PTP消息域发送和接收队列中的消息，我们将把注意力集中在使用pub/sub消息域发送和接收消息主题上的消息。
- en: Working with message topics
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与消息主题一起工作
- en: Message topics are used when our Jakarta Messaging code uses the pub/sub messaging
    domain. When using this messaging domain, the same message can be sent to all
    subscribers to the topic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的Jakarta Messaging代码使用pub/sub消息域时，会使用消息主题。当使用此消息域时，相同的消息可以发送到主题的所有订阅者。
- en: Sending messages to a message topic
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向消息主题发送消息
- en: 'The following example illustrates how to send messages to a message topic:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息主题发送消息：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the preceding code is nearly identical to the `MessageSender`
    class we saw when we discussed PTP messaging. Jakarta Messaging was designed so
    that the same API can be used for both the PTP and pub/sub domains.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码几乎与我们在讨论PTP消息时看到的`MessageSender`类相同。Jakarta Messaging被设计成可以使用相同的API来处理PTP和pub/sub域。
- en: Since the code in this example is nearly identical to the corresponding example
    in the *Working with message queues* section, we will only explain the differences
    between the two examples. In this case, `@JMSDestinationDefinition` has a value
    of `jakarta.jms.Topic` for its `name` attribute, as required when using the pub/sub
    messaging domain. Additionally, instead of declaring an instance of a class implementing
    `jakarta.jms.Queue`, we declare an instance of a class implementing `jakarta.jms.Topic`.
    We then pass this instance of `jakarta.jms.Topic` as the first method of the `send()`
    method of our `JMSProducer` object, along with the message we wish to send.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本例中的代码几乎与*使用消息队列*部分中的相应示例相同，我们只解释两个示例之间的差异。在这种情况下，`@JMSDestinationDefinition`的`name`属性值为`jakarta.jms.Topic`，这是在使用pub/sub消息域时所需的。此外，我们不是声明一个实现`jakarta.jms.Queue`类的实例，而是声明一个实现`jakarta.jms.Topic`类的实例。然后，我们将这个`jakarta.jms.Topic`的实例作为`JMSProducer`对象的`send()`方法的第一参数传递，同时传递我们希望发送的消息。
- en: Receiving messages from a message topic
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从消息主题接收消息
- en: 'Just as sending messages to a message topic is nearly identical to sending
    messages to a message queue, receiving messages from a message topic is nearly
    identical to receiving messages from a message queue:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如向消息主题发送消息几乎与向消息队列发送消息相同一样，从消息主题接收消息几乎与从消息队列接收消息相同：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, the differences between this code and the corresponding code for
    PTP are trivial. Instead of declaring an instance of a class implementing `jakarta.jms.Queue`,
    we declare a class implementing `jakarta.jms.Topic`. We use the `@Resource` annotation
    to inject an instance of this class into our code, using the JNDI name we used
    when configuring our application server. We then obtain an instance of `JMSContext`
    and `JMSConsumer` like before, then it receives the messages from the topic by
    invoking the `receiveBody()` method on `JMSConsumer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此代码与PTP对应代码之间的差异微乎其微。我们不是声明一个实现`jakarta.jms.Queue`类的实例，而是声明一个实现`jakarta.jms.Topic`类的实例。我们使用`@Resource`注解将此类的实例注入到我们的代码中，使用我们在配置应用程序服务器时使用的JNDI名称。然后，我们像以前一样获取`JMSContext`和`JMSConsumer`的实例，然后通过在`JMSConsumer`上调用`receiveBody()`方法来接收来自主题的消息。
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, and then executing the `MessageSender` class we developed in
    the previous section. We should see console output for each instance, indicating
    that both instances received all messages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，使用pub/sub消息域的优点是消息可以发送到多个消息消费者。这可以通过同时执行本节中开发的`MessageReceiver`类的两个实例，然后执行上一节中开发的`MessageSender`类来轻松测试。我们应该看到每个实例的控制台输出，表明两个实例都接收到了所有消息。
- en: Creating durable subscribers
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建持久订阅者
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be executing when the messages are sent to the topic. If the message consumer
    is not executing at the time, it will not receive the messages, whereas in PTP,
    messages are kept in the queue until the message consumer executes. Fortunately,
    Jakarta Messaging provides a way to use the pub/sub messaging domain and keep
    messages in the topic until all subscribed message consumers execute and receive
    the message. This can be accomplished by creating durable subscribers to a message
    topic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pub/sub消息域的缺点是，消息消费者必须在消息发送到主题时正在执行。如果消息消费者在那时没有执行，它将不会收到消息，而在PTP中，消息将保留在队列中，直到消息消费者执行。幸运的是，Jakarta
    Messaging提供了一种方法，可以在pub/sub消息域中使用并保留消息在主题中，直到所有已订阅的消息消费者执行并接收消息。这可以通过创建对消息主题的持久订阅者来实现。
- en: In order to be able to service durable subscribers, we need to set the `clientId`
    property of our Jakarta Messaging connection factory. Each durable subscriber
    must have a unique client ID, therefore a unique connection factory must be declared
    for each potential durable subscriber.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够服务持久的订阅者，我们需要设置我们的Jakarta Messaging连接工厂的`clientId`属性。每个持久的订阅者都必须有一个唯一的客户端ID，因此必须为每个潜在的持久订阅者声明一个唯一的连接工厂。
- en: 'We can set the `clientId` property of our connection factory using the `@JMSConnectionFactoryDefinition`
    annotation, as illustrated in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@JMSConnectionFactoryDefinition`注解设置我们的连接工厂的`clientId`属性，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the preceding code is not much different from previous examples
    whose purpose was to retrieve messages. There are only a few differences from
    previous examples: the instance of `ConnectionFactory` we are injecting is defined
    via `@JMSConnectionFactoryDefinition` and given a client ID via its `clientId`
    attribute. Notice the `@Resource` annotation for our connection factory has a
    `mappedName` attribute whose value matches the name attribute we defined in `@JMSConnectionFactoryDefinition`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码与之前用于检索消息的示例没有太大区别：与之前的示例相比，只有几个不同之处：我们注入的`ConnectionFactory`实例是通过`@JMSConnectionFactoryDefinition`定义的，并通过其`clientId`属性分配了一个客户端ID。注意，我们的连接工厂的`@Resource`注解有一个`mappedName`属性，其值与我们定义在`@JMSConnectionFactoryDefinition`中的名称属性相匹配。
- en: Another difference is that instead of calling the `createConsumer()` method
    on `JMSContext`, we are calling `createDurableConsumer()`. The `createDurableConsumer()`
    method takes two arguments, a messaging `Topic` object to retrieve messages from
    and a `String` designating a name for this subscription. This second parameter
    must be unique between all subscribers to the durable topic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，我们不是在`JMSContext`上调用`createConsumer()`方法，而是在调用`createDurableConsumer()`。`createDurableConsumer()`方法接受两个参数，一个用于检索消息的消息`Topic`对象和一个指定此订阅名称的`String`。这个第二个参数必须在所有持久主题的订阅者之间是唯一的。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed at length how to send messages with Jakarta Messaging,
    using both the PTP and pub/sub messaging domains.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了如何使用Jakarta Messaging发送消息，既使用了PTP消息域，也使用了pub/sub消息域。
- en: 'Topics we covered included the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的主题包括以下内容：
- en: How to send messages to a message queue via the `jakarta.jms.JMSProducer` interface
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过`jakarta.jms.JMSProducer`接口向消息队列发送消息
- en: How to receive messages from a message queue via the `jakarta.jms.JMSConsumer`
    interface
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过`jakarta.jms.JMSConsumer`接口从消息队列接收消息
- en: How to asynchronously receive messages from a message queue by implementing
    the `jakarta.jms.MessageListener` interface
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过实现`jakarta.jms.MessageListener`接口异步从消息队列接收消息
- en: How to use the preceding interfaces to send and receive messages to and from
    a message topic
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用前面的接口发送和接收消息到和从消息主题
- en: How to browse messages in a message queue without removing the messages from
    the queue via the `jakarta.jms.QueueBrowser` interface
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过`jakarta.jms.QueueBrowser`接口浏览消息队列中的消息而不从队列中移除消息
- en: How to set up and interact with durable subscriptions to messaging topics
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和交互持久订阅到消息主题
- en: Armed with the knowledge in this chapter, we can now implement asynchronous
    communication between processes with Jakarta Messaging.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 带着本章的知识，我们现在可以实现在Jakarta Messaging之间进行异步通信。
