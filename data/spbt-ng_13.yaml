- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Saving, Deleting, and Updating with NgRx
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgRx进行保存、删除和更新
- en: In the previous chapter, we learned about the concepts and features of NgRx.
    We learned the importance of state management as it provides a single source for
    the application to have a unidirectional data flow and reduces the responsibility
    of components. We also learned the building blocks of NgRx, which are actions,
    effects, reducers, and selectors. Lastly, we implemented the getting and displaying
    of the anti-heroes list feature using NgRx in our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了NgRx的概念和功能。我们了解到状态管理的重要性，因为它为应用程序提供了一个单一的数据流源，并减少了组件的责任。我们还学习了NgRx的构建块，即操作、效果、reducer和选择器。最后，我们使用NgRx在我们的应用程序中实现了获取和显示反英雄列表功能。
- en: In this chapter, we will now complete our application’s missing features – saving,
    deleting, and updating data by still using NgRx.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成我们应用程序缺失的功能——通过仍然使用NgRx来保存、删除和更新数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Removing an item without side effects using NgRx
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NgRx无副作用地删除项目
- en: Removing an item with side effects using NgRx
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NgRx通过副作用删除项目
- en: Adding an item with side effects using NgRx
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NgRx添加具有副作用的项目
- en: Updating an item with side effects using NgRx
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NgRx通过副作用更新项目
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The link to the finished version of the code is [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成版本的链接为 [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes).
- en: Removing an item without a side effect using NgRx
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgRx无副作用地删除项目
- en: In this section, we will first see how to delete items without using side effects
    in NgRx. As we learned in the previous chapter, side effects are used to call
    external APIs to retrieve data. This means that without using effects, we will
    delete the data by dispatching an action to invoke a reducer base on the dispatched
    type. This section will help us see the difference in the flow and behavior of
    using effects in the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解如何在NgRx中不使用副作用来删除项目。正如我们在上一章中学到的，副作用用于调用外部API以检索数据。这意味着在不使用效果的情况下，我们将通过派发一个操作来删除数据，该操作将根据派发的类型调用reducer。本节将帮助我们了解在应用程序中使用效果时的流程和行为差异。
- en: Creating the delete action
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建删除操作
- en: The first step is to create the action for the delete feature. In our project,
    in the `anti-hero/state/anti-hero.actions.ts` file, we will add a new action interface
    and a new function for deletion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建删除功能的操作。在我们的项目中，在 `anti-hero/state/anti-hero.actions.ts` 文件中，我们将添加一个新的操作接口和一个新的删除函数。
- en: 'Let’s have a look at the implementation of the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码的实现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code example, we can see that we have added a new action named
    `REMOVE_ANTI_HERO_STATE`. We have also created an action with the newly created
    type, which has a `props` parameter that accepts an anti-hero ID. The ID is needed
    for the reducer to identify what data we should delete from our store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们添加了一个名为 `REMOVE_ANTI_HERO_STATE` 的新操作。我们还创建了一个具有新创建类型的操作，该类型具有一个接受反英雄ID的
    `props` 参数。ID是reducer识别我们应该从我们的存储中删除哪些数据所必需的。
- en: Creating the delete reducer
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建删除reducer
- en: Now, let’s create the reducer for deleting data from our store. The first thing
    we need to think of is what our reducer would look like if it could remove a single
    piece of data from an array using the provided ID. One way we can implement this
    is by using the `filter()` function to extract the data in the array.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建用于从我们的存储中删除数据的reducer。我们首先需要考虑的是，如果我们的reducer能够使用提供的ID从数组中删除单个数据项，它会是什么样子。我们可以实现这一点的其中一种方法是通过使用
    `filter()` 函数从数组中提取数据。
- en: 'Let’s add the following code in the `anti-hero/state/anti-hero.reducers.ts`
    file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `anti-hero/state/anti-hero.reducers.ts` 文件中添加以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code example, we can see that we have added a new reducer for
    our delete feature. This accepts the anti-hero ID coming from the `removeAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value where the
    anti-hero data that has the given ID is already filtered. If the reducer successfully
    modifies the value of the `antiHeroes` state, any selectors subscribed to the
    changes of this state will emit the new value in the component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们为我们的删除功能添加了一个新的reducer。它接受来自`removeAntiHeroState`动作的反英雄ID，并返回一个新的状态，其中已过滤掉具有给定ID的反英雄数据，并修改了`antiHeroes`值。如果reducer成功修改了`antiHeroes`状态值，任何订阅此状态变化的选择器将在组件中发出新值。
- en: Dispatching the action
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发动作
- en: The last step we need to do is to dispatch the action in our component. To implement
    this step, we need to call a dispatch when the **Delete** button for each piece
    of anti-hero data is clicked.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一个步骤是在我们的组件中分发动作。为了实现这一步骤，我们需要在点击每条反英雄数据的**删除**按钮时调用分发。
- en: In the `anti-hero/components/anti-hero-list.component.ts` file, we have added
    `emittethatch`, which passes the selected anti-hero object and `TableAction`,
    based on the button clicked by the user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`anti-hero/components/anti-hero-list.component.ts`文件中，我们添加了`emittethatch`，它根据用户点击的按钮传递选定的反英雄对象和`TableAction`。
- en: 'Let’s have a recap of the code we have implemented for this feature in the
    following files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们为这个功能在以下文件中实现的代码：
- en: anti-hero-list.component.ts
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: anti-hero-list.component.ts
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: anti-hero-list.component.html
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: anti-hero-list.component.html
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: table-actions.enum.ts
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: table-actions.enum.ts
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code example, we can see that if the `1`, which represents
    the value for **Delete enum**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到`1`代表**删除枚举**的值。
- en: 'Now, we need to dispatch the `REMOVE_ANTI_HERO_STATE` action in the list component
    when the **Delete** button has emitted an event. To implement this part, we will
    add the following code in the following files:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在列表组件中分发`REMOVE_ANTI_HERO_STATE`动作，当**删除**按钮发出事件时。为了实现这部分，我们将在以下文件中添加以下代码：
- en: list.component.ts
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: list.component.ts
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: list.component.html
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: list.component.html
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code example, we created a function that checks the action
    triggered by the user with the `TableActions` value. If `TableActions` has a delete
    value, we will dispatch `REMOVE_ANTI_HERO_STATE` and pass the ID of the anti-hero
    object that will be used by the reducer we have created.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个函数，该函数检查由用户触发的`TableActions`值。如果`TableActions`具有删除值，我们将分发`REMOVE_ANTI_HERO_STATE`并传递将由我们创建的reducer使用的反英雄对象的ID。
- en: We have now successfully implemented the delete feature of our application with
    NgRx, but in this case, we are only deleting the items in our UI, and we are not
    syncing the changes in the database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功使用NgRx实现了我们应用程序的删除功能，但在这个案例中，我们只删除了UI中的项目，并没有同步数据库中的更改。
- en: In the next section, we will implement the use of side effects in the deleting
    of data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现使用副作用来删除数据的方法。
- en: Removing an item with side effects using NgRx
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgRx通过副作用删除项目
- en: In this section, we will improve the delete functionality by adding effects
    in our state. Our current delete feature only removes the data in the store but
    does not sync the changes in the database. This means that if we refresh our application,
    the data that we have deleted will be available again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过在我们的状态中添加副作用来改进删除功能。我们当前的删除功能仅从存储中删除数据，但不会同步数据库中的更改。这意味着如果我们刷新我们的应用程序，我们已删除的数据将再次可用。
- en: To sync the changes in the database, what we should do is create an effect that
    will invoke the delete API. Let’s have a look at the step-by-step changes in our
    code in the following sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同步数据库中的更改，我们应该创建一个将调用删除API的效果。让我们看看以下章节中我们代码的逐步更改。
- en: Creating a new action type
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的动作类型
- en: The first step we need to do is create a new action type. The effects in NgRx
    will use the new action type for deleting feature later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是创建一个新的动作类型。NgRx中的效果将使用新的动作类型来删除功能。
- en: We will add `REMOVE_ANTI_HERO_API` in the `AntiHeroActions` enum under the `anti-hero/state/anti-hero.actions.ts`
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`anti-hero/state/anti-hero.actions.ts`文件下的`AntiHeroActions`枚举中添加`REMOVE_ANTI_HERO_API`。
- en: 'Let’s have a look at the added action in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码中添加的动作：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see in the preceding code example that a new action type was added for
    our actions. Take note that we do not need to create a new action for this type
    as we will be calling an effect instead of an action once this action type is
    dispatched.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到为我们的动作添加了一个新的动作类型。请注意，我们不需要为这个类型创建一个新的动作，因为一旦这个动作类型被派发，我们将调用一个副作用而不是一个动作。
- en: Creating the delete effect
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建删除副作用
- en: 'The next step we need to do is to create the effect for the delete feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的步骤是创建删除功能的副作用。在 `anti-hero/state/anti-hero.effect.ts` 文件中，我们将添加以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code example, we can see that we have created a new effect
    for our delete action; this has a type of `REMOVE_ANTI_HERO_API`, which calls
    the `deleteAntiHero()` function in `AntiHeroService` for the data deletion based
    on the passed ID, and once the API is successful.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们为我们的删除动作创建了一个新的副作用；这个副作用的类型是 `REMOVE_ANTI_HERO_API`，它调用 `AntiHeroService`
    中的 `deleteAntiHero()` 函数，根据传递的 ID 删除数据，一旦 API 调用成功。
- en: The effect will dispatch another action, `REMOVE_ANTI_HERO_STATE`, which we
    created in the previous section, which removes the anti-hero from the store. This
    means that the data we delete from the database will also be deleted from our
    NgRx store.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该副作用将派发另一个动作，`REMOVE_ANTI_HERO_STATE`，这是我们之前创建的，它从存储中删除反英雄。这意味着我们从数据库中删除的数据也将从我们的
    NgRx 存储中删除。
- en: Modifying the dispatch
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改派发
- en: The last step for this feature is to modify the action being dispatched in the
    `list.component.ts` file. In the previous section, we call the `REMOVE_ANTI_HERO_STATE`
    action directly in our component; we will change this into `REMOVE_ANTI_HERO_API`
    as we should now call the effect, which will invoke the API and at the same time
    will call the `REMOVE_ANTI_HERO_STATE` action.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的最后一步是在 `list.component.ts` 文件中修改派发的动作。在上一节中，我们直接在我们的组件中调用 `REMOVE_ANTI_HERO_STATE`
    动作；我们将将其更改为 `REMOVE_ANTI_HERO_API`，因为我们现在应该调用副作用，这将调用 API，同时也会调用 `REMOVE_ANTI_HERO_STATE`
    动作。
- en: 'Let’s have a look at the following code example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码示例：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code example, we are now dispatching the effect in our list
    component. This will call the API first before updating our store in the application;
    the changes in our store and database are synced.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们现在在我们的列表组件中派发副作用。这将首先调用 API，然后再更新我们的应用存储；我们存储和数据库中的更改是同步的。
- en: In the next section, we will implement the addition of data with side effects
    to our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现具有副作用的数据添加到我们的应用中。
- en: Adding an item with side effects using NgRx
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgRx 添加具有副作用的项目
- en: In this section, we will implement the *add* functionality with side effects
    in NgRx. The steps are similar to how we implemented the delete feature. We will
    create the building blocks step by step and create the dispatch logic in our component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 NgRx 实现具有副作用的 *添加* 功能。步骤与我们实现删除功能的方式相似。我们将逐步创建构建块并在我们的组件中创建派发逻辑。
- en: Creating the actions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动作
- en: The first step we need to do is create the required action types and actions
    for our add feature. To implement the actions, we can think of how we created
    the actions for the delete feature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是创建我们添加功能所需的动作类型和动作。为了实现动作，我们可以考虑我们是如何创建删除功能的动作的。
- en: The concept is the same. There are two action types that we need to create,
    and these are `ADD_ANTI_HERO_API` and `ADD_ANTI_HERO_STATE`. The first type will
    be used by the effect that will call the API, and the second type will be used
    by the reducer that will modify the state by adding the newly created data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是相同的。我们需要创建两种动作类型，这些是 `ADD_ANTI_HERO_API` 和 `ADD_ANTI_HERO_STATE`。第一种类型将由调用
    API 的副作用使用，第二种类型将由修改状态的还原器使用，通过添加新创建的数据。
- en: After creating the two action types, we also need to create an action using
    the `createAction()` function for the `ADD_ANTI_HERO_STATE` type. The effect will
    dispatch this once the API has been successfully called.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了两种动作类型之后，我们还需要使用 `createAction()` 函数为 `ADD_ANTI_HERO_STATE` 类型创建一个动作。一旦
    API 调用成功，副作用将派发这个动作。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code example, we can see that we have added the two new types
    in `AntiHeroActions`. We have also created a new action with the `ADD_ANTI_HERO_STATE`
    type, which accepts an `antiHero` property that will be pushed as a new item in
    the anti-hero state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们在`AntiHeroActions`中添加了两个新的类型。我们还创建了一个新的动作，类型为`ADD_ANTI_HERO_STATE`，它接受一个`antiHero`属性，该属性将被推送到反英雄状态中的新条目。
- en: Creating the effect
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建效果
- en: 'The next step we need to do is to create the effect for the *add* feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步需要做的是为*添加*功能创建效果。在`anti-hero/state/anti-hero.effect.ts`文件中，我们将添加以下代码：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code example, we can see that we have created an effect similar
    to the effect for the delete feature. This effect uses the `ADD_ANTI_HERO_API`
    type and invokes the `addAntiHero()` function from `antiHeroService` to call the
    POST API to add new data to the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们创建了一个类似于删除功能效果的效果。这个效果使用`ADD_ANTI_HERO_API`类型，并从`antiHeroService`调用`addAntiHero()`函数来调用POST
    API将新数据添加到数据库中。
- en: After successfully calling the POST API, the effect will dispatch the `ADD_ANTI_HERO_STATE`
    action and pass the new anti-hero data coming from the API response to be added
    by the reducer. We have also added a `tap` operator, which calls a `navigate`
    function that will navigate to the list page after creating the new anti-hero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用POST API之后，效果将分发`ADD_ANTI_HERO_STATE`动作，并将来自API响应的新反英雄数据传递给reducer进行添加。我们还添加了一个`tap`操作符，它调用一个`navigate`函数，在创建新的反英雄后将导航到列表页面。
- en: Creating the reducer
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建reducer
- en: After creating the effects, we need to sync the changes implemented in the database
    with our store, and the reducer will do this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建效果之后，我们需要将数据库中实现的变化与我们的存储同步，reducer将完成这项工作。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code example, we can see that we have added a new reducer for
    our *add* feature. This accepts the new anti-hero data coming from the `addAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value where the
    new anti-hero is already added in the array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们为*添加*功能添加了一个新的reducer。它接受来自`addAntiHeroState`动作的新反英雄数据，并返回一个新的状态，其中`antiHeroes`值已被修改，新反英雄已添加到数组中。
- en: If the reducer successfully modifies the value of the `antiHeroes` state, any
    selectors subscribed to the changes of this state will emit the new value in the
    component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果reducer成功修改了`antiHeroes`状态的值，任何订阅了这个状态变化的选择器将发出新的值在组件中。
- en: Dispatching the action
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发动作
- en: The last step we need to do is to dispatch the action in our component. To implement
    this step, we will invoke the dispatch action once the `anti-hero/components/anti-hero-form.component.ts`
    file, we have added an emitter that passes the value of the form and the button
    label to identify if the action is created or updated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一步是在我们的组件中分发动作。为了实现这一步，我们将在`anti-hero/components/anti-hero-form.component.ts`文件中调用分发动作，我们已添加了一个发射器，它传递表单的值和按钮标签以识别动作是创建还是更新。
- en: 'Let’s have a recap of the code we have implemented for this anti-hero form:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们为这个反英雄表单实现的代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code example, we can see that the anti-hero form emits the
    form value as an anti-hero object that will be passed to the effect.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到反英雄表单将表单值作为反英雄对象发出，该对象将被传递到效果中。
- en: This also gives the current action, as we will also be using this anti-hero
    form component for the update. Once the button is clicked, we need to have a function
    in the `form.component.ts` file that will dispatch the effect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这也提供了当前的操作，因为我们还将使用这种反英雄表单组件进行更新。一旦按钮被点击，我们就需要在`form.component.ts`文件中有一个函数来分发效果。
- en: 'Let’s have a look at the following code example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码示例：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code example, we can see that we have created the `formAction()`
    function, which dispatches an action based on the passed value from the anti-hero
    form component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们创建了一个`formAction()`函数，它根据从反英雄表单组件传递的值分发一个动作。
- en: This uses a `switch` statement, as this will also be called when the action
    is `update`. We have now successfully created the *add* feature for our application
    using the building blocks of NgRx.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个`switch`语句，因为当动作是`update`时也会被调用。现在我们已经成功地为我们的应用程序使用NgRx的构建块创建了*添加*功能。
- en: In the next section, we will implement the modification of data with side effects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现具有副作用的数据修改。
- en: Updating an item with a side effect using NgRx
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgRx 更新带有副作用的项目
- en: In this last section, we will implement the final missing feature, which is
    the *update* functionality, where we will create the building blocks step by step
    and the dispatch logic in our component as we did for the *add* and *delete* features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将实现最后缺失的功能，即 *更新* 功能，我们将逐步创建构建块和组件中的分发逻辑，就像我们对 *添加* 和 *删除* 功能所做的那样。
- en: Creating the actions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动作
- en: The first step we need to do is to create the required action types and actions
    for our update feature. We will first create the two action types we need, which
    are `MODIFY_ANTI_HERO_API` and `MODIFY_ANTI_HERO_STATE`. The first type will be
    used by the effect that will call the API, and the second type will be used by
    the reducer that will modify the state by changing the data based on the new anti-hero
    object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是创建更新功能所需的动作类型和动作。我们首先创建所需的两个动作类型，分别是 `MODIFY_ANTI_HERO_API` 和 `MODIFY_ANTI_HERO_STATE`。第一个类型将由调用
    API 的副作用使用，第二个类型将由通过根据新的反英雄对象更改数据来修改状态的 reducer 使用。
- en: After creating the two action types, we also need to create an action using
    the `createAction()` function for the `MODIFY_ANTI_HERO_STATE` type. The effect
    will dispatch this once the API has been successfully called.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了两个动作类型之后，我们还需要使用 `createAction()` 函数为 `MODIFY_ANTI_HERO_STATE` 类型创建一个动作。效果将在
    API 调用成功后分发此动作。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code example, we can see that we have added the two new types
    in `AntiHeroActions`. We have also created a new action with the `MODIFY_ANTI_HERO_STATE`
    type, which accepts an `antiHero` property that will be used to modify the current
    values in the store.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们在 `AntiHeroActions` 中添加了两个新类型。我们还创建了一个新的动作，其类型为 `MODIFY_ANTI_HERO_STATE`，它接受一个
    `antiHero` 属性，该属性将用于修改存储中的当前值。
- en: Creating the effect
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建效果
- en: 'The next step we need to do is to create the effect for the *add* feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是创建 *添加* 功能的效果。在 `anti-hero/state/anti-hero.effect.ts` 文件中，我们将添加以下代码：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code example, we can see that we have created an effect similar
    to the effect for the *add* and *delete* features. This effect uses the `MODIFY_ANTI_HERO_API`
    type and invokes the `updateAntiHero()` function from `antiHeroService` to call
    the PUT API to modify the anti-hero with the ID parameter in the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们创建了一个类似于 *添加* 和 *删除* 功能的效果。此效果使用 `MODIFY_ANTI_HERO_API` 类型，并从
    `antiHeroService` 调用 `updateAntiHero()` 函数来调用 PUT API 以修改具有 ID 参数的数据库中的反英雄。
- en: After successfully calling the PUT API, the effect will dispatch the `MODIFY_ANTI_HERO_STATE`
    action and pass the modified anti-hero data coming from the API response to be
    added by the reducer, and the same as with the *add* effect, we have also added
    a `tap` operator, which calls a `navigate` function that will navigate to the
    list page after modifying the anti-hero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用 PUT API 后，效果将分发 `MODIFY_ANTI_HERO_STATE` 动作，并将来自 API 响应的修改后的反英雄数据传递给 reducer，就像在
    *添加* 效果中一样，我们同样添加了一个 `tap` 操作符，该操作符在修改反英雄后调用一个 `navigate` 函数，该函数将导航到列表页面。
- en: Creating the reducer
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 reducer
- en: After creating the effects, we need to sync the changes implemented in the database
    with our store, and the reducer will do this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建效果之后，我们需要将数据库中实现的变化与我们的存储同步，reducer 将执行此操作。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code example, we can see that we have added a new reducer for
    our update feature. This accepts the modified anti-hero data coming from the `addAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value, where we
    replace the anti-hero with the given ID with the new object using the `map()`
    operator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们为更新功能添加了一个新的 reducer。它接受来自 `addAntiHeroState` 动作的修改后的反英雄数据，并返回包含修改后的
    `antiHeroes` 值的新状态，其中我们使用 `map()` 操作符用新对象替换了给定 ID 的反英雄。
- en: If the reducer successfully modifies the value of the `antiHeroes` state, any
    selectors subscribed to the changes of this state will emit the new value in the
    component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 reducer 成功修改了 `antiHeroes` 状态的值，任何订阅此状态变化的 selectors 都会在组件中发出新的值。
- en: Dispatching the action
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发动作
- en: The last step we need to do is to dispatch the action to our component. To implement
    this step, we will do the same steps as we did for the *add* feature. We will
    still use the `anti-hero/components/anti-hero-form.component.ts` file for updating
    the data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一步是将动作分发到我们的组件。为了实现这一步，我们将执行与添加功能相同的步骤。我们仍然会使用`anti-hero/components/anti-hero-form.component.ts`文件来更新数据。
- en: The only difference here is that we will bind the selected anti-hero value in
    our form; the anti-hero form component should accept an anti-hero object and should
    patch the value in the form group.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是我们将绑定所选反英雄的值到我们的表单中；反英雄表单组件应该接受一个反英雄对象，并且应该通过表单组修补值。
- en: 'Let’s have a look at the following code example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码示例：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code example, we can see that we have added the `checkAction()`
    function, which checks whether we have passed an anti-hero object in the anti-hero
    form component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们添加了`checkAction()`函数，该函数检查我们是否在反英雄表单组件中传递了一个反英雄对象。
- en: This indicates that if the object is not null, this will be an *Update* action,
    and we must display the selected anti-hero details in each field by binding the
    form using the `patchValue()` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明如果对象不为空，这将是一个*更新*动作，我们必须通过使用`patchValue()`方法绑定表单来在每个字段中显示所选反英雄的详细信息。
- en: 'Now let’s have the code implementation for the `form` component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现`form`组件的代码：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code example, we can see that we have added a new case in the
    `formAction()` function, which also dispatches an action but of type `MODIFY_ANTI_HERO_API`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们在`formAction()`函数中添加了一个新的情况，它也会分发一个动作，但动作类型为`MODIFY_ANTI_HERO_API`。
- en: We have also used the `selectAntiHero()` selector to select the anti-hero using
    the ID in our URL route that will be passed in our `anti-hero-form.component.ts`
    file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`selectAntiHero()`选择器，通过URL路由中的ID选择反英雄，该ID将被传递到我们的`anti-hero-form.component.ts`文件中。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things we have learned; we have completed the CRUD features of applications
    using the building blocks of NgRx, and we have learned the difference between
    using and not using side effects in state management. Side effects are essential
    for our changes in the store to be synced with the database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经到达了这一章的结尾。让我们回顾一下我们学到的宝贵知识；我们使用NgRx的构建块完成了应用的CRUD功能，并且我们学习了在状态管理中使用和不使用副作用之间的区别。副作用对于我们的更改在存储中与数据库同步是必不可少的。
- en: We have also learned, step by step, how to create the building blocks of NgRx
    with the different actions we need for our application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也一步一步地学习了如何使用我们应用所需的不同动作来创建NgRx的构建块。
- en: In the next chapter, we will learn how to apply security features in Angular,
    such as adding user login and logout, retrieving user profile information, protecting
    application routes, and calling an API with protected endpoints.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在Angular中应用安全功能，例如添加用户登录和注销、检索用户配置文件信息、保护应用路由以及调用具有受保护端点的API。
