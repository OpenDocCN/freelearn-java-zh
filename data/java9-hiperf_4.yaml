- en: Chapter 4. Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：微服务
- en: As long as we kept talking about the designing, implementation, and tuning of
    one process, we were able to keep illustrating it with vivid images (albeit in
    our imagination only) of pyramid building. Multiple thread management, based on
    the democratic principle of equality between thread pool members, had also a sense
    of centralized planning and supervision. Different priorities were assigned to
    threads programmatically, hardcoded (for most cases) after thoughtful consideration
    by the programmer in accordance with the expected load, and adjusted after monitoring.
    The upper limits of the available resources were fixed, although they could be
    increased after, again, a relatively big centralized decision.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们一直在谈论一个过程的设计、实施和调整，我们就能用金字塔建造的生动图像（尽管只是我们想象中的）来展示它。基于线程池成员之间平等民主原则的多线程管理，也有一种集中规划和监督的感觉。线程的优先级被程序性地分配，在程序员经过深思熟虑后（对于大多数情况）硬编码，并根据预期的负载进行调整。可用的资源上限是固定的，尽管在再次做出相对较大的集中决策后，它们可以被增加。
- en: Such systems had great success and still constitute the majority of the web
    applications currently deployed to production. Many of them are monoliths, sealed
    inside a single `.ear` or `.war` file. This works fine for relatively small applications
    and a corresponding team size that supports them. They are easy (if the code is
    well structured) to maintain, build, and if the production load is not very high,
    they can be easily deployed. If the business does not grow or has little impact
    on the company's internet presence, they continue to do the job and will do so
    probably for the foreseeable future. Many service providers are eager to host
    such websites by charging a small fee and relieving the website owner of the technical
    worries of production maintenance not directly related to the business. But that
    is not the case for everybody.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统取得了巨大的成功，并且仍然构成了目前部署到生产中的大多数网络应用。其中许多是单体应用，密封在单个`.ear`或`.war`文件中。这对相对较小的应用和相应的支持团队规模来说效果很好。如果代码结构良好，它们易于维护、构建，并且如果生产负载不是非常高，它们可以轻松部署。如果业务没有增长或对公司的互联网存在影响不大，它们将继续完成工作，并且可能会在可预见的未来继续这样做。许多服务提供商都渴望通过收取少量费用来托管此类网站，从而减轻网站所有者与业务无关的生产维护的技术担忧。但并非所有人都如此。
- en: The higher the load, the more difficult and expensive the scaling becomes unless
    the code and the overall architecture is restructured in order to become more
    flexible and resilient to the growing load. This lesson describes the solution
    many leaders of the industry have adopted while addressing the issue and the motivation
    behind it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 负载越高，扩展就越困难、成本越高，除非代码和整体架构被重构以变得更加灵活和能够应对不断增长的压力。本课程描述了行业领导者们在解决该问题及其背后的动机时采用的解决方案。
- en: 'The particular aspects of the microservices we are going to discuss in this
    lesson include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中我们将讨论的微服务的特定方面包括以下内容：
- en: The motivation for the microservices rising
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务兴起的动机
- en: The frameworks that were developed recently in support of microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近为支持微服务而开发的框架
- en: The process of microservices development with practical examples, including
    the considerations and decision-making process during microservices building
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有实际案例的微服务开发过程，包括在构建微服务时的考虑和决策过程
- en: Pros and cons of the three main deployment methods such as container-less, self-contained,
    and in-container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种主要部署方法（如无容器、自包含和在容器内）的优缺点
- en: Why Microservices?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择微服务？
- en: Some businesses have a higher demand for the deployment plan because of the
    need to keep up with the bigger volume of traffic. The natural answer to this
    challenge would be and was to add servers with the same `.ear` or `.war` file
    deployed and join all the servers into a cluster. So, one failed server could
    be automatically replaced with another one from the cluster, and the site user
    would never experience disconnect of the service. The database that backed all
    the clustered servers could be clustered too. A connection to each of the clusters
    went through a load balancer, making sure that none of the cluster members worked
    more than the others.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些企业对部署计划的需求更高，因为需要跟上更大流量的需求。应对这一挑战的自然答案，并且也是实际的做法，就是添加具有相同 `.ear` 或 `.war`
    文件的服务器，并将所有服务器加入到一个集群中。这样，一个失败的服务器可以被集群中的另一个服务器自动替换，而网站用户永远不会体验到服务的断开。支持所有集群服务器的数据库也可以进行集群。每个集群的连接都通过负载均衡器进行，确保集群中的任何成员都不会比其他成员工作得更多。
- en: 'The web server and database clustering help but only to a degree, because as
    the code base grows, its structure can create one or several bottlenecks unless
    such and similar issues are addressed with a scalable design. One of the ways
    to do it is to split the code into tiers: front end (or web tier), middle tier
    (or app tier) and back end (or backend tier). Then, again, each tier can be deployed
    independently (if the protocol between tiers has not changed) and in its own cluster
    of servers, as each tier can grow horizontally as needed independently of other
    tiers. Such a solution provides more flexibility for scaling up, but makes the
    deployment plan more complex, especially if the new code introduces breaking changes.
    One of the approaches is to create a second cluster that will host a new code,
    then take the servers one by one from the old cluster, deploy the new code, and
    put them in the new cluster. The new cluster would be turned on as soon as at
    least one server in each tier has the new code. This approach worked fine for
    the web and app tiers but was more complex for the backend, which once in a while
    required data migration and similar joyful exercises. Add to it unexpected outages
    in the middle of the deployment caused by human errors, defects in the code, pure
    accidents, or some combination of all the earlier mentioned (one time, for example,
    an electric power cable was cut by an excavator in the nearby construction site),
    and it is easy to understand why very few people love a deployment of a major
    release to production.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器和数据库集群虽然有所帮助，但仅限于一定程度，因为随着代码库的增长，其结构可能会产生一个或多个瓶颈，除非用可扩展的设计来解决类似问题。实现这一目标的一种方法是将代码分成层：前端（或网络层）、中间层（或应用层）和后端（或后端层）。然后，再次，每一层都可以独立部署（如果层之间的协议没有改变），并在其自己的服务器集群中部署，因为每一层可以根据需要独立地水平扩展，而不依赖于其他层。这种解决方案为扩展提供了更多的灵活性，但使得部署计划更加复杂，尤其是在新代码引入破坏性更改的情况下。其中一种方法是为新代码创建第二个集群，然后逐个从旧集群中取出服务器，部署新代码，并将它们放入新集群。一旦每个层的至少一个服务器都部署了新代码，新集群就会启动。这种方法对于网络和应用层来说效果良好，但对于后端来说则更为复杂，后端偶尔需要数据迁移和类似的愉快练习。再加上在部署过程中由于人为错误、代码缺陷、纯粹的事故或上述所有因素的某种组合而导致的意外中断，就不难理解为什么很少有人喜欢将主要版本发布到生产环境中了。
- en: Programmers, being by nature problem solvers, tried to prevent the earlier scenario
    as best as they could by writing defensive code, deprecating instead of changing,
    testing, and so on. One of the approaches was to break the application into more
    independently deployable parts with the hope of avoiding deploying everything
    at the same time. They called these independent units **services**, and **Service-Oriented
    Architecture** (**SOA**) was born.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员作为天生的问题解决者，通过编写防御性代码、弃用而不是更改、测试等方式，尽可能地防止早期场景的发生。其中一种方法是将应用程序分解成更多独立部署的部分，希望避免同时部署所有内容。他们将这些独立单元称为**服务**，从而诞生了**面向服务的架构**（**SOA**）。
- en: Unfortunately, in many companies, the natural growth of the code base was not
    adjusted to the new challenges in a timely manner. Like the frog that was eventually
    boiled in a slowly heated pot of water, they never had time to jump out of the
    hot spot by changing the design. It was always cheaper to add another feature
    to the blob of the existing functionality than redesign the whole app. Business
    metrics of the time-to-market and keeping the bottom line in the black always
    were and will remain the main criterion for the decision making, until the poorly
    structured source code eventually stops working, pulling down all the business
    transactions with it or, if the company is lucky, allows them to weather the storm
    and shows the importance of the investment in the redesign.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在许多公司中，代码库的自然增长并没有及时调整以适应新的挑战。就像最终在慢慢加热的水壶中被煮青蛙一样，他们从未有时间通过改变设计跳出热点。总是比重新设计整个应用程序更便宜，只需向现有功能的块中添加另一个功能。当时的时间到市场指标和保持底线不变的业务指标一直是决策的主要标准，直到结构不良的源代码最终停止工作，带着所有的商业交易一起崩溃，或者，如果公司运气好，让他们度过风暴，并显示出对重新设计的投资的重要性。
- en: As a result of all that, some lucky companies remained in the business with
    their monolithic application still running as expected (maybe not for long, but
    who knows), some went out of business, some learned from their mistakes and progressed
    into the brave world of the new challenges, and others learned from their mistakes
    and designed their systems to be SOA upfront.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些，一些幸运的公司仍然在业务中，他们的单体应用程序仍然按预期运行（也许不会太久，但谁知道呢），一些公司倒闭了，一些从错误中学习并进步到充满新挑战的勇敢世界，还有一些从错误中学习并设计他们的系统，从一开始就是SOA。
- en: It is interesting to observe similar tendencies in the social sphere. Society
    moved from the strong centralized governments to more loosely coupled confederations
    of semi-independent states tied together by the mutually beneficial economic and
    cultural exchange.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在社会领域观察类似的趋势也很有趣。社会从强大的中央政府转向了更松散耦合的、由互惠互利的经济和文化交流联系在一起的半独立国家联盟。
- en: Unfortunately, maintaining such a loose structure comes with a price. Each participant
    has to be more responsible in maintaining the contract (social, in the case of
    a society, and API, in the case of the software) not only formally but also in
    spirit. Otherwise, for example, the data flowing from a new version of one component,
    although correct by type, might be unacceptable to another component by value
    (too big or too small). Maintaining a cross-team understanding and overlapping
    of responsibility requires constant vigilance in keeping the culture alive and
    enlightening. Encouraging innovation and risk taking, which can lead to a business
    breakthrough, contradict the protecting tendencies for stability and risk aversion
    coming from the same business people.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，维持这种松散的结构是要付出代价的。每个参与者都必须在维护合同（在社会的情况下是社交，在软件的情况下是API）方面更加负责，不仅形式上，而且在精神上。否则，例如，从一个组件的新版本中流出的数据，虽然按类型正确，但可能因为值（太大或太小）而被另一个组件不接受。保持跨团队的理解和责任重叠需要不断保持文化的活力和启迪。鼓励创新和冒险，这可能导致商业突破，与来自同一商业人士的稳定性和风险规避的倾向相矛盾。
- en: Moving from monolithic single-team development to multiple teams and an independent
    components-based system requires an effort on all levels of the enterprise. What
    do you mean by **No more Quality Assurance Department**? Who then will care about
    the professional growth of the testers? And what about the IT group? What do you
    mean by **The developers are going to support production**? Such changes affect
    human lives and are not easy to implement. That's why SOA architecture is not
    just a software principle. It affects everybody in the company.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体单团队开发转向多团队和基于独立组件的系统需要企业在所有层面上的努力。你说的**不再有质量保证部门**是什么意思？那么谁会关心测试人员的职业发展？至于IT团队呢？你说的**开发者将支持生产**是什么意思？这样的变化影响人们的生活，并且不容易实施。这就是为什么SOA架构不仅仅是一个软件原则。它影响公司中的每个人。
- en: Meanwhile, the industry leaders, who have managed to grow beyond anything we
    could imagine just a decade ago, were forced to solve even more daunting problems
    and came back to the software community with their solutions. And that is where
    our analogy with the pyramid building does not work anymore. Because the new challenge
    is not just to build something so big that was never built before but also to
    do it quickly not in a matter of years, but in a few weeks and even days. And
    the result has to last not for a thousand years but has to be able to evolve constantly
    and be flexible enough to adapt to new, unexpected requirements in real time.
    If only one aspect of the functionality has changed, we should be able to redeploy
    only this one service. If the demand for any service grows, we should be able
    to scale only along this one service and release resources when the demand drops.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，那些成功发展到我们十年前无法想象的地步的行业领导者，被迫解决更多令人畏惧的问题，并带着他们的解决方案回到了软件社区。这就是我们的金字塔建造类比不再适用之处。因为新的挑战不仅仅是建造一个前所未有的巨大事物，而且还要快速完成，不是以年为单位，而是以几周甚至几天为单位。结果必须能够持续不断进化，并且足够灵活，能够实时适应新的、意外的需求。如果只有功能的一个方面发生了变化，我们应当能够仅重新部署这一项服务。如果对任何服务的需求增加，我们应当能够仅在这一项服务上进行扩展，并在需求下降时释放资源。
- en: To avoid big deployments with all hands on deck and to come closer to the continuous
    deployment (which decreases time-to-market and is thus supported by business),
    the functionality continued to split into smaller chunks of services. In response
    to the demand, more sophisticated and robust cloud environments, deployment tools
    (including containers and container orchestration), and monitoring systems supported
    this move. The reactive streams, described in the previous lesson, started to
    develop even before the Reactive Manifesto came out and plugged a snag into the
    stack of modern frameworks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免大规模部署和全员参与，并更接近持续部署（这减少了上市时间，因此得到了商业的支持），功能继续细分为更小的服务块。为了应对需求，更复杂和稳健的云环境、部署工具（包括容器和容器编排）以及监控系统支持了这一转变。在前一课中描述的响应式流，甚至在响应式宣言发布之前就开始发展，并填补了现代框架堆栈中的漏洞。
- en: Splitting an application into independent deployment units brought several not
    quite expected benefits that have increased the motivation for plowing ahead.
    The physical isolation of services allows more flexibility in choosing a programming
    language and platform of implementation. It helps not only to select technology
    that is the best for the job but also to hire people able to implement it, not
    being bound by a certain technological stack of the company. It also helped the
    recruiters to spread the net wider and use smaller cells for bringing in new talent,
    which is not a small advantage with a limited number of available specialists
    and the unlimited demand of the fast-growing data processing industry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序拆分为独立的部署单元带来了几个并非完全预期的益处，这些益处增加了继续前进的动力。服务的物理隔离使得在选择编程语言和实现平台方面具有更大的灵活性。这不仅有助于选择最适合工作的技术，而且还能雇佣能够实现这些技术的人员，而不会受到公司特定技术栈的限制。这也帮助招聘人员扩大搜索范围，并使用更小的团队来吸引新人才，这对于可用专家数量有限且数据处理行业需求无限增长的情况来说，是一个不小的优势。
- en: Also, such architecture enforced a discussion and explicit definition of the
    interfaces between smaller parts of the complex system, thus creating a solid
    foundation for further growth and tuning of the processing sophistication.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种架构强制对复杂系统较小部分的接口进行讨论和明确定义，从而为处理复杂性的进一步增长和调整奠定了坚实的基础。
- en: And that is how microservices came into the picture and were put to work by
    giants of traffic such as Netflix, Google, Twitter, eBay, Amazon, and Uber. Now,
    let's talk about the results of this effort and the lessons learned.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这样，微服务进入了视野，并被像Netflix、Google、Twitter、eBay、Amazon和Uber这样的流量巨头所采用。现在，让我们谈谈这项努力的成果和学到的教训。
- en: Building Microservices
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务
- en: 'Before diving into the building process, let''s revisit the characteristics
    a chunk of code has to possess in order to be qualified as a microservice. We
    will do it in no particular order:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入构建过程之前，让我们回顾一下，一段代码必须具备哪些特性才能被认定为微服务。我们将按无特定顺序进行：
- en: The size of the source code of one microservice should be smaller to that of
    an SOA, and one development team should be able to support several of them.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个微服务的源代码大小应该小于SOA，一个开发团队应该能够支持多个微服务。
- en: It has to be deployed independently of other services.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须独立于其他服务进行部署。
- en: Each has to have its own database (or schema or set of tables), although this
    statement is still under debate, especially in cases when several services modify
    the same data set or the inter-dependent data sets; if the same team owns all
    of the related services, it is easier to accomplish. Otherwise, there are several
    possible strategies we will discuss later.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都应该有自己的数据库（或模式或一组表），尽管这个说法仍在争议中，特别是在多个服务修改相同数据集或相互依赖的数据集的情况下；如果同一个团队拥有所有相关的服务，那么完成它更容易。否则，我们将在稍后讨论几种可能的策略。
- en: It has to be stateless and idempotent. If one instance of the service has failed,
    another should be able to accomplish what was expected from the service.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是无状态的且幂等的。如果一个服务的实例失败了，另一个应该能够完成该服务预期的任务。
- en: It should provide a way to check its **health**, meaning that the service is
    up and running and ready to do the job.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该提供一种检查其**健康状态**的方法，这意味着该服务正在运行并且准备好执行工作。
- en: Sharing resources has to be considered during the design, development, and,
    after deployment, monitored for validation of the assumptions. In the previous
    lesson, we talked about threads synchronization. You could see that this problem
    was not easy to solve, and we have presented several possible ways to do it. Similar
    approaches can be applied toward microservices. Although they are run in different
    processes, they can communicate to each other if need be, so they can coordinate
    and synchronize their actions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计、开发和部署后，必须考虑资源共享，并在部署后进行监控以验证假设。在上一课中，我们讨论了线程同步。你可以看到这个问题并不容易解决，我们已经提出了几种可能的解决方案。类似的方法也可以应用于微服务。尽管它们在不同的进程中运行，但在需要时它们可以相互通信，因此它们可以协调和同步它们的行为。
- en: Special care has to be taken during modification of the same persistent data
    whether shared across databases, schemas, or tables within the same schema. If
    an eventual consistency is acceptable (which is often the case for larger sets
    of data, used for statistical purposes, for example) then no special measures
    are necessary. However, the need for transactional integrity poses a more difficult
    problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改跨数据库、模式或同一模式内的表中的相同持久数据时，必须特别小心。如果最终一致性是可以接受的（例如，对于用于统计目的的大型数据集通常是这种情况），则不需要采取特殊措施。然而，事务完整性的需求提出了一个更困难的问题。
- en: One way to support a transaction across several microservices is to create a
    service that would play the role of a **Distributed Transaction Manager** (**DTM**).
    Other services that need coordination would pass to it the new modified values.
    The DTM service could keep the concurrently modified data temporarily in a database
    table and would move it into the main table(s) in one transaction after all the
    data is ready (and consistent).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 支持跨多个微服务的交易的一种方法是为扮演**分布式事务管理器**（**DTM**）角色的服务创建一个服务。需要协调的其他服务会将新的修改后的值传递给它。DTM服务可以将并发修改的数据暂时存储在数据库表中，并在所有数据准备（并且一致）后，在一个事务中将它移动到主表（们）中。
- en: If the time to access the data is an issue or you need to protect the database
    from an excessive number of concurrent connections, dedicating a database to some
    services may be an answer. Alternatively, if you would like to try another option,
    memory cache could be the way to go. Adding a service that provides access to
    the cache (and updates it as needed) increases isolation from the services that
    use it, but requires (sometimes difficult) synchronization between the peers that
    are managing the same cache too.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问数据的时间是一个问题，或者你需要保护数据库免受过多并发连接的影响，为某些服务分配一个数据库可能是一个解决方案。或者，如果你想尝试另一种选择，内存缓存可能是可行的。添加一个提供对缓存访问（并在需要时更新它）的服务可以增加与使用它的服务的隔离性，但需要在管理同一缓存的对等体之间进行（有时是困难的）同步。
- en: After considering all the options and possible solutions for data sharing, it
    is often helpful to revisit the idea of creating its own database (or schema)
    for each microservice. One may discover that the effort of the data isolation
    (and subsequent synchronization on the database level) does not look as daunting
    as before if compared with the effort to synchronize the data dynamically.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了所有数据共享的选项和可能的解决方案之后，重新审视为每个微服务创建自己的数据库（或模式）的想法通常是有帮助的。人们可能会发现，与动态同步数据相比，数据隔离（以及在数据库层面的后续同步）的努力看起来不再那么令人畏惧。
- en: That said, let's look over the field of the frameworks for microservices implementation.
    One can definitely write the microservices from scratch, but before doing that,
    it is always worth looking at what is out there already, even if to find eventually
    that nothing fits your particular needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来看看微服务实现框架的领域。当然可以从头开始编写微服务，但在这样做之前，总是值得看看已经存在的东西，即使最终发现没有什么适合您的特定需求。
- en: There are more than a dozen frameworks that are currently used for building
    microservices. Two most popular are Spring Boot ([https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/))
    and raw J2EE. The J2EE community founded the initiative MicroProfile ([https://microprofile.io/](https://microprofile.io/))
    with a declared goal of **Optimizing Enterprise Java** for a microservices architecture.
    KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/)) is a lightweight
    open-source microservice framework coplined with MicroProfile.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前用于构建微服务的框架超过一打。其中最受欢迎的两个是 Spring Boot ([https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/))
    和原生 J2EE。J2EE 社区成立了 MicroProfile ([https://microprofile.io/](https://microprofile.io/))
    初始化项目，其目标是**优化企业 Java**以适应微服务架构。KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/))
    是一个轻量级的开源微服务框架，与 MicroProfile 集成。
- en: 'The list of some other frameworks include the following (in alphabetical order):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他框架的列表如下（按字母顺序排列）：
- en: '**Akka**: This is a toolkit for building highly concurrent, distributed, and
    resilient message-driven applications for Java and Scala ([akka.io](https://akka.io/))'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Akka**：这是一个用于构建高度并发、分布式和健壮的消息驱动应用的 Java 和 Scala 工具包 ([akka.io](https://akka.io/))'
- en: '**Bootique**: This is a minimally opinionated framework for runnable Java apps
    ([bootique.io](http://bootique.io))'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootique**：这是一个对可运行 Java 应用有最小观点的框架 ([bootique.io](http://bootique.io))'
- en: '**Dropwizard**: This is a Java framework for developing ops-friendly, high-performance,
    RESTful web services ([www.dropwizard.io](http://www.dropwizard.io))'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dropwizard**：这是一个用于开发操作友好、高性能、RESTful 网络服务的 Java 框架 ([www.dropwizard.io](http://www.dropwizard.io))'
- en: '**Jodd**: This is a set of Java microframeworks, tools, and utilities, under
    1.7 MB ([jodd.org](http://jodd.org))'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jodd**：这是一个包含 Java 微框架、工具和实用程序的集合，大小不到 1.7 MB ([jodd.org](http://jodd.org))'
- en: '**Lightbend Lagom**: This is an opinionated microservice framework built on
    Akka and Play ([www.lightbend.com](http://www.lightbend.com))'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lightbend Lagom**：这是一个基于 Akka 和 Play 的有观点的微服务框架 ([www.lightbend.com](http://www.lightbend.com))'
- en: '**Ninja**: This is a full stack web framework for Java ([www.ninjaframework.org](http://www.ninjaframework.org))'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninja**：这是一个全栈式 Java 网络框架 ([www.ninjaframework.org](http://www.ninjaframework.org))'
- en: '**Spotify Apollo**: This is a set of Java libraries used at Spotify for writing
    microservices ([spotify.github.io/apollo](http://spotify.github.io/apollo))'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spotify Apollo**：这是一套 Spotify 用于编写微服务的 Java 库 ([spotify.github.io/apollo](http://spotify.github.io/apollo))'
- en: '**Vert.x**: This is a toolkit for building reactive applications on the JVM
    ([vertx.io](http://vertx.io))'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vert.x**：这是一个用于在 JVM 上构建反应式应用的工具包 ([vertx.io](http://vertx.io))'
- en: All frameworks support HTTP/JSON communication between microservices; some of
    them also have an additional way to send messages. If not the latter, any lightweight
    messaging system can be used. We mentioned it here because, as you may recall,
    message-driven asynchronous processing is a foundation for elasticity, responsiveness,
    and resilience of a reactive system composed of microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有框架都支持微服务之间的 HTTP/JSON 通信；其中一些还提供了发送消息的额外方式。如果不是后者，可以使用任何轻量级消息系统。我们在这里提到它是因为，如您所回忆的那样，消息驱动的异步处理是微服务组成的反应式系统弹性和响应性的基础。
- en: To demonstrate the process of microservices building, we will use Vert.x, an
    event-driven, non-blocking, lightweight, and polyglot toolkit (components can
    be written in Java, JavaScript, Groovy, Ruby, Scala, Kotlin, and Ceylon). It supports
    an asynchronous programming model and a distributed event bus that reaches even
    into in-browser JavaScript (thus allowing the creation of real-time web applications).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示微服务构建的过程，我们将使用 Vert.x，这是一个事件驱动、非阻塞、轻量级和多种语言（组件可以用 Java、JavaScript、Groovy、Ruby、Scala、Kotlin
    和 Ceylon 编写）的工具包。它支持异步编程模型和分布式事件总线，甚至可以扩展到浏览器中的 JavaScript（从而允许创建实时网络应用程序）。
- en: 'One starts using Vert.x by creating a `Verticle` class that implements the
    interface `io.vertx.core.Verticle`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Vert.x，通过创建一个实现 `io.vertx.core.Verticle` 接口的 `Verticle` 类：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The method names previously mentioned are self-explanatory. The method `getVertex()`
    provides access to the `Vertx` object the entry point into the Vert.x Core API.
    It provides access to the following functionality necessary for the microservices
    building:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的方法名称是自解释的。`getVertex()` 方法提供了访问 `Vertx` 对象的途径，这是 Vert.x 核心API的入口点。它提供了构建微服务所需的功能：
- en: Creating TCP and HTTP clients and servers
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TCP 和 HTTP 客户端和服务器
- en: Creating DNS clients
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 DNS 客户端
- en: Creating Datagram sockets
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据报套接字
- en: Creating periodic services
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建周期性服务
- en: Providing access to the event bus and file system API
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对事件总线文件系统API的访问
- en: Providing access to the shared data API
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对共享数据API的访问
- en: Deploying and undeploying verticles
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和卸载 verticle
- en: Using this Vertx object, various verticles can be deployed, which talk to each
    other, receive an external request, and process and store data as any other Java
    application, thus forming a system of microservices. Using RxJava implementation
    from the package `io.vertx.rxjava`, we will show how one can create a reactive
    system of microservices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 Vertx 对象，可以部署各种 verticle，它们相互通信，接收外部请求，并像任何其他 Java 应用程序一样处理和存储数据，从而形成一个微服务系统。使用来自
    `io.vertx.rxjava` 包的 RxJava 实现，我们将展示如何创建一个反应式微服务系统。
- en: 'A verticle is a building block in Vert.`x` world. It can easily be created
    by extending the `io.vertx.rxjava.core.AbstractVerticle` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vert.`x` 世界中，一个垂直（verticle）是一个构建块。它可以很容易地通过扩展 `io.vertx.rxjava.core.AbstractVerticle`
    类来创建：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The earlier mentioned class, in turn, extends `io.vertx.core.AbstractVerticle`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的类反过来又扩展了 `io.vertx.core.AbstractVerticle`：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A verticle can be created by extending the class `io.vertx.core.AbstractVerticle`,
    too. However, we will write reactive microservices, so we will extend its rx-fied
    version, `io.vertx.rxjava.core.AbstractVerticle`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展类 `io.vertx.core.AbstractVerticle` 也可以创建 verticle。然而，我们将编写反应式微服务，因此我们将扩展其
    rx-fied 版本，`io.vertx.rxjava.core.AbstractVerticle`。
- en: 'To use Vert.x and run the provided example, all you need to do is to add the
    following dependencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vert.x 并运行提供的示例，你需要做的只是添加以下依赖项：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other Vert.x functionality can be added as needed by including other Maven dependencies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，可以通过包含其他 Maven 依赖项来添加其他 Vert.x 功能。
- en: What makes `Vert.x` `Verticle` reactive is the underlying implementation of
    an event loop (a thread) that receives an event and delivers it a `Handler` (we
    will show how to write the code for it). When a `Handler` gets the result, the
    event loop invokes the callback.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使 `Vert.x` 的 `Verticle` 具有反应性的是其底层事件循环（一个线程）的实现，该循环接收事件并将其传递给 `Handler`（我们将展示如何编写该代码）。当
    `Handler` 获取结果时，事件循环将调用回调。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As you see, it is important not to write a code that blocks the event loop,
    thus the Vert.x golden rule: don''t block the event loop.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，不要编写阻塞事件循环的代码是很重要的，这是 Vert.x 的黄金法则：不要阻塞事件循环。
- en: If not blocked, the event loop works very quickly and delivers a huge number
    of events in a short period of time. This is called the reactor pattern ([https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern)).
    Such an event-driven non-blocking programming model is a very good fit for reactive
    microservices. For certain types of code that are blocking by nature (JDBC calls
    and long computations are good examples) a worker verticle can be executed asynchronously
    (not by the event loop, but by a separate thread using the method `vertx.executeBlocking()`),
    which keeps the golden rule intact.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有被阻塞，事件循环运行得非常快，在短时间内处理大量事件。这被称为反应器模式 ([https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern))。这种事件驱动的非阻塞编程模型非常适合反应式微服务。对于某些本质上阻塞的代码类型（JDBC
    调用和长时间计算是很好的例子），可以通过 `vertx.executeBlocking()` 方法异步执行工作端点（不是通过事件循环，而是通过一个单独的线程），这样就可以保持黄金法则。
- en: 'Let''s look at a few examples. Here is a `Verticle` class that works as an
    HTTP server:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个示例。以下是一个作为 HTTP 服务器的 `Verticle` 类：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous code, the server is created, and the stream of data from a
    possible request is wrapped into an `Observable`. We then subscribed to the data
    coming from the `Observable` and passed in a function (a request handler) that
    will process the request and generate a necessary response. We also told the server
    which port to listen. Using this `Verticle`, we can deploy several instances of
    an HTTP server listening on different ports. Here is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，服务器被创建，可能请求的数据流被包装在一个 `Observable` 中。然后我们订阅了来自 `Observable` 的数据，并传递了一个函数（一个请求处理器），该函数将处理请求并生成必要的响应。我们还告诉服务器要监听哪个端口。使用这个
    `Verticle`，我们可以部署多个监听不同端口的 HTTP 服务器实例。以下是一个示例：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run this application, the output would be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个应用程序，输出将如下所示：
- en: '![Building Microservices](img/04_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_01.jpg)'
- en: 'As you can see, the same thread is listening on both ports. If we now place
    a request to each of the running servers, we will get the response we have hardcoded:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，相同的线程正在监听两个端口。如果我们现在向每个运行的服务器发送请求，我们将得到我们硬编码的响应：
- en: '![Building Microservices](img/04_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_02.jpg)'
- en: 'We ran our examples from the `main()` method. A plugin `maven-shade-plugin`
    allows you to specify which verticle you would like to be the starting point of
    your application. Here is an example from [http://vertx.io/blog/my-first-vert-x-3-application](http://vertx.io/blog/my-first-vert-x-3-application):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `main()` 方法运行了我们的示例。一个插件 `maven-shade-plugin` 允许你指定你希望作为应用程序起点的端点。以下是从 [http://vertx.io/blog/my-first-vert-x-3-application](http://vertx.io/blog/my-first-vert-x-3-application)
    的一个示例：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, run the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It will generate a specified JAR file (called `target/my-first-app-1.0-SNAPSHOT-fat.jar`,
    in this example). It is called `fat` because it contains all the necessary dependencies.
    This file will also contain `MANIFEST.MF` with the following entries in it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成一个指定的 JAR 文件（在这个例子中称为 `target/my-first-app-1.0-SNAPSHOT-fat.jar`）。它被称为 `fat`，因为它包含了所有必要的依赖项。此文件还将包含
    `MANIFEST.MF`，其中包含以下条目：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use any verticle instead of `io.vertx.blog.first.MyFirstVerticle`,
    used in this example, but `io.vertx.core.Starter` has to be there because that
    is the name of the `Vert.x` class that knows how to read the manifest and execute
    the method `start()` of the specified verticle. Now, you can run the following
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何端点代替此示例中使用的 `io.vertx.blog.first.MyFirstVerticle`，但 `io.vertx.core.Starter`
    必须存在，因为它是知道如何读取清单并执行指定端点的 `start()` 方法的 `Vert.x` 类的名称。现在，你可以运行以下命令：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will execute the `start()` method of the `MyFirstVerticle` class
    the same way the `main()` method is executed in our example, which we will continue
    to use for the simplicity of demonstration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将以与我们的示例中 `main()` 方法执行相同的方式执行 `MyFirstVerticle` 类的 `start()` 方法，我们将继续使用它以简化演示。
- en: 'To compliment the HTTP server, we can create an HTTP client too. However, first,
    we will modify the method `start()` in the `server` verticle to accept the parameter
    `name`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充 HTTP 服务器，我们也可以创建一个 HTTP 客户端。然而，首先，我们将修改 `server` 端点的 `start()` 方法以接受参数
    `name`：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can create an HTTP `client` verticle that sends a request and prints
    out the response every second for 3 seconds, then stops:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 HTTP `客户端` 端点，该端点每秒发送一个请求并打印出响应，持续 3 秒后停止：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s assume we deploy both verticles as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们以以下方式部署两个端点：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Building Microservices](img/04_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_03.jpg)'
- en: In this last example, we demonstrated how to create an HTTP client and periodic
    service. Now, let's add more functionality to our system. For example, let's add
    another verticle that will interact with the database and use it via the HTTP
    server we have already created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们展示了如何创建一个 HTTP 客户端和周期性服务。现在，让我们给我们的系统添加更多功能。例如，让我们添加另一个 verticle，它将与数据库交互并通过我们已创建的
    HTTP 服务器使用它。
- en: 'First, we need to add this dependency:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加这个依赖项：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The newly added JAR file allows us to create an in-memory database and a handler
    to access it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的 JAR 文件允许我们创建一个内存数据库和一个处理器来访问它：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Those familiar with RxJava can see that Vert.x code closely follows the style
    and naming convention of RxJava. Nevertheless, we encourage you to go through
    Vert.x documentation, because it has a very rich API that covers many more cases
    than just demonstrated. In the previous code, the operation `flatMap()` receives
    the function that runs the script and then closes the connection. The operation
    `doAfterTerminate()` in this case acts as if it was placed inside a finally block
    in a traditional code and closes the connection either in case of success or if
    an exception is generated. The `subscribe()` method has several overloaded versions.
    For our code, we have selected the one that takes two functions one is going to
    be executed in the case of success (we print a message about the table being created)
    and another in the case of an exception (we just print the stack trace then).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 RxJava 的人可以观察到 Vert.x 代码紧密遵循 RxJava 的风格和命名约定。尽管如此，我们仍然鼓励您阅读 Vert.x 文档，因为它拥有一个非常丰富的
    API，涵盖了比演示中展示的更多情况。在前面的代码中，操作 `flatMap()` 接收运行脚本的函数，然后关闭连接。在这种情况下，`doAfterTerminate()`
    操作相当于在传统代码中的 finally 块内执行，无论成功与否都会关闭连接。`subscribe()` 方法有几个重载版本。对于我们的代码，我们选择了接受两个函数的版本，一个在成功情况下执行（我们打印关于创建表的消息），另一个在异常情况下执行（我们只打印堆栈跟踪）。
- en: 'To use the created database, we can add to `DbHandler` methods `insert()`,
    `process()`, and `readProcessed()` that will allow us to demonstrate how to build
    a reactive system. The code for the method `insert()` can look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用创建的数据库，我们可以向 `DbHandler` 添加 `insert()`、`process()` 和 `readProcessed()` 方法，这将允许我们展示如何构建一个响应式系统。`insert()`
    方法的代码可能看起来像这样：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `insert()` method, as well as other methods we are going to write, takes
    full advantage of Java functional interfaces. It creates a record in the table
    `who_called` (using the passed in parameter `name`). Then, the operation `subscribe()`
    executes one of the two functions passed in by the code that calls this method.
    We use the method `printAction()` only for better traceability:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法，以及我们将要编写的其他方法，充分利用了 Java 函数式接口。它在 `who_called` 表中创建一个记录（使用传入的参数
    `name`）。然后，`subscribe()` 操作执行调用此方法的代码传入的两个函数之一。我们只使用 `printAction()` 方法来提高可追踪性：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The method `process()` also accepts two functions but does not need other parameters.
    It processes all the records from the table `who_called` that are not processed
    yet (not listed in the table `processed`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `process()` 也接受两个函数，但不需要其他参数。它处理表 `who_called` 中尚未处理的全部记录（未列入表 `processed`）：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If two threads are reading the table `who_called` for the purpose of selecting
    records not processed yet, the clause `for update` in the SQL query makes sure
    that only one gets each record, so they are not going to be processed twice. The
    significant advantage of the method `process()` code is its usage of the `rxQUeryStream()`
    operation that emits the found records one at a time so that they are processed
    independently of each other. In the case of a big number of not processed records,
    such a solution guarantees a smooth delivery of the results without the spiking
    of the resources consumption. The following `flatMap()` operation does processing
    using the function passed in. The only requirement for that function is that it
    must return one integer value (in `JsonArray`) that is going to be used as a parameter
    for the `SQL_INSERT_PROCESSED` statement. So, it is up to the code that calls
    this method to decide the nature of the processing. The rest of the code is similar
    to the method `insert()`. The code indentation helps to follow the nesting of
    the operations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个线程正在读取 `who_called` 表以选择尚未处理的记录，SQL 查询中的 `for update` 子句确保只有一个线程获取每个记录，因此它们不会被处理两次。`process()`
    方法代码的显著优势是其对 `rxQUeryStream()` 操作的使用，该操作一次发出一个找到的记录，这样它们就可以独立地处理。在存在大量未处理记录的情况下，这种解决方案保证了结果的平稳交付，而不会导致资源消耗的峰值。接下来的
    `flatMap()` 操作使用传入的函数进行处理。对该函数的唯一要求是它必须返回一个整数值（在 `JsonArray` 中），该值将用作 `SQL_INSERT_PROCESSED`
    语句的参数。因此，决定处理性质的代码取决于调用此方法的代码。其余的代码与 `insert()` 方法类似。代码缩进有助于跟踪操作的嵌套。
- en: 'The method `readProcessed()` has code that looks very similar to the code of
    the method `insert()`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `readProcessed()` 的代码看起来与 `insert()` 方法的代码非常相似：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code reads the specified number of the latest processed records.
    The difference from the method `process()` is that the method `readProcessed()`
    returns all the read records in one result set, so it is up to the user of this
    method to decide how to process the result in bulk or one at a time. We show all
    these possibilities just to demonstrate the variety of the possible options. With
    the `DbHandler` class in place, we are ready to use it and create the `DbServiceHttp`
    microservice, which allows a remote access to the `DbHandler` capabilities by
    wrapping around it an HTTP server. Here is the constructor of the new microservice:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码读取指定数量的最新处理的记录。与 `process()` 方法不同的是，`readProcessed()` 方法将所有读取的记录作为一个结果集返回，因此用户必须决定如何批量或逐个处理结果。我们展示所有这些可能性只是为了演示可能的选项的多样性。有了
    `DbHandler` 类，我们就准备好使用它并创建 `DbServiceHttp` 微服务，该服务通过围绕它包装一个 HTTP 服务器来允许远程访问 `DbHandler`
    的功能。以下是新微服务的构造函数：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the earlier mentioned code, you can see how the URL mapping is done in Vert.x.
    For each possible route, a corresponding `Verticle` method is assigned, each accepting
    the `RoutingContext` object that contains all the data of HTTP context, including
    the `HttpServerRequest` and `HttpServerResponse` objects. A variety of convenience
    methods allows us to easily access the URL parameters and other data necessary
    to process the request. Here is the method `insert()` referred in the `start()`
    method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的代码中，你可以看到在 Vert.x 中如何进行 URL 映射。对于每个可能的路由，都会分配一个相应的 `Verticle` 方法，每个方法都接受包含
    HTTP 上下文所有数据的 `RoutingContext` 对象，包括 `HttpServerRequest` 和 `HttpServerResponse`
    对象。一系列便利方法使我们能够轻松访问 URL 参数和其他处理请求所需的数据。以下是 `start()` 方法中提到的 `insert()` 方法：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All it does is extracts the parameter `name` from the request and constructs
    the two functions necessary to call method `insert()` of `DbHandler` we discussed
    earlier. The method `process()` looks similar to the previous method `insert()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是从请求中提取参数 `name`，并构建调用我们之前讨论过的 `DbHandler` 的 `insert()` 方法的两个必要函数。方法 `process()`
    与之前的方法 `insert()` 非常相似：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function `process` mentioned earlier defines what should be done with the
    records coming from the `SQL_SELECT_TO_PROCESS` statement inside the method `process()`
    in `DbHandler`. In our case, it calculates the length of the caller's name and
    passes it as a parameter along with the name itself (as a return value) to the
    next SQL statement that inserts the result into the table `processed`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的函数 `process` 定义了在 `DbHandler` 类的 `process()` 方法内部，对来自 `SQL_SELECT_TO_PROCESS`
    语句的记录应该执行的操作。在我们的例子中，它计算调用者名称的长度，并将它作为参数（连同名称本身作为返回值）传递给下一个 SQL 语句，该语句将结果插入到 `processed`
    表中。
- en: 'Here is the method `readProcessed()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `readProcessed()` 方法：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That is where (in the previous code in the function `onSuccess()`) the result
    set from the query `SQL_READ_PROCESSED` is read and used to construct the response.
    Notice that we do it by creating an `Observable` first, then subscribing to it
    and passing the result of the subscription as the response into method `end()`.
    Otherwise, the response can be returned without waiting for the response to be
    constructed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是之前代码中在 `onSuccess()` 函数中从查询 `SQL_READ_PROCESSED` 读取结果集并用于构建响应的地方。请注意，我们首先创建一个
    `Observable`，然后订阅它，并将订阅的结果作为响应传递到 `end()` 方法中。否则，响应可以在不等待构建响应的情况下返回。
- en: 'Now, we can launch our reactive system by deploying the `DbServiceHttp` verticle:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过部署 `DbServiceHttp` 纵列来启动我们的响应式系统：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we do that, in the output we will see the following lines of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，在输出中我们将看到以下代码行：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In another window, we can issue the command that generates an HTTP request:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，我们可以发出生成 HTTP 请求的命令：
- en: '![Building Microservices](img/04_04.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_04.jpg)'
- en: 'If we read the processed records now, there should be none:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在读取已处理的记录，应该没有：
- en: '![Building Microservices](img/04_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_05.jpg)'
- en: 'The log messages show the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息显示以下内容：
- en: '![Building Microservices](img/4_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/4_06.jpg)'
- en: 'Now, we can request processing of the existing records and then read the results
    again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以请求处理现有记录，然后再次读取结果：
- en: '![Building Microservices](img/04_07.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_07.jpg)'
- en: In principle, it is enough already to build a reactive system. We can deploy
    many `DbServiceHttp` microservices on different ports or cluster them to increase
    processing capacity, resilience, and responsiveness. We can wrap other services
    inside an HTTP client or an HTTP server and let them talk to each other, processing
    the input and passing the results along the processing pipeline.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，已经足够构建一个响应式系统。我们可以在不同的端口上部署许多 `DbServiceHttp` 微服务，或者将它们集群起来以增加处理能力、弹性和响应性。我们可以在
    HTTP 客户端或 HTTP 服务器中包装其他服务，并让它们相互通信，处理输入并通过处理管道传递结果。
- en: However, Vert.x also has a feature that even better suits the message-driven
    architecture (without using HTTP). It is called an event bus. Any verticle has
    access to the event bus and can send any message to any address (which is just
    a string) using either method `send()` (`rxSend()` in the case of reactive programming)
    or method `publish()`. One or many verticles can register themselves as a consumer
    for a certain address.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Vert.x 还有一个功能，它更适合消息驱动架构（而不使用 HTTP）。它被称为事件总线。任何纵列都可以访问事件总线，并可以使用 `send()`
    方法（在响应式编程中为 `rxSend()`）或 `publish()` 方法将任何消息发送到任何地址（它只是一个字符串）。一个或多个纵列可以注册自己作为某个地址的消费者。
- en: If many verticles are consumers for the same address, then the method `send()`
    (`rxSend()`) delivers the message only to one of them (using a round-robin algorithm
    to pick the next consumer). The method `publish()`, as you would expect, delivers
    the message to all consumers with the same address. Let's see an example, using
    the already familiar `DbHandler` as the main working horse.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果许多纵列是同一地址的消费者，那么 `send()` 方法（在响应式编程中为 `rxSend()`）只将消息发送给其中之一（使用轮询算法选择下一个消费者）。正如预期的那样，`publish()`
    方法将消息发送到具有相同地址的所有消费者。让我们通过使用已经熟悉的 `DbHandler` 作为主要工作马来看一个例子。
- en: 'A microservice, based on an event bus, looks very similar to the one based
    on the HTTP protocol we discussed already:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件总线的一个微服务看起来与我们之前讨论的基于 HTTP 协议的微服务非常相似：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We simplified the preceding code by skipping some sections (that are very similar
    to the `DbServiceHttp` class) and trying to highlight the code structure. For
    demo purposes, we will deploy two instances of this class and send three messages
    to each of the addresses `INSERT`, `PROCESS`, and `READ_PROCESSED`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过跳过一些部分（这些部分与 `DbServiceHttp` 类非常相似）并尝试突出代码结构来简化了前面的代码。为了演示目的，我们将部署这个类的两个实例，并向地址
    `INSERT`、`PROCESS` 和 `READ_PROCESSED` 发送三条消息：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the delay for 200 ms we inserted using the method `delayMs()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用 `delayMs()` 方法插入的 200 毫秒延迟：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The delay is necessary to let the `DbServiceBus` verticle to be deployed and
    started (and the consumers registered with the address). Otherwise, an attempt
    to send a message may fail because the consumer is not registered with the address
    yet. The `PeriodicServiceBusSend()` verticle code is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是必要的，以便让 `DbServiceBus` 纵列被部署并启动（以及与地址注册的消费者）。否则，发送消息的尝试可能会失败，因为消费者尚未在地址上注册。`PeriodicServiceBusSend()`
    纵列代码如下：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The previous code sends a message to an address every `delaySec` seconds as
    many times as the length of the array `caller[]`, and then undeploys the verticle
    (itself). If we run the demo, the beginning of the output will be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在每`delaySec`秒向一个地址发送一次消息，发送次数与数组`caller[]`的长度相同，然后卸载这个垂直（即自身）。如果我们运行这个演示，输出结果的开头将如下所示：
- en: '![Building Microservices](img/04_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_08.jpg)'
- en: 'As you can see, for each address, only `DbServiceBus(1)` was a receiver of
    the first message. The second message to the same address was received by `DbServiceBus(2)`.
    That was the round-robin algorithm (which we mentioned earlier) in action. The
    final section of the output looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于每个地址，只有`DbServiceBus(1)`是第一条消息的接收者。第二条发送到同一地址的消息被`DbServiceBus(2)`接收。这就是我们之前提到的轮询算法（round-robin
    algorithm）在起作用。输出结果的最后部分看起来如下所示：
- en: '![Building Microservices](img/04_09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_09.jpg)'
- en: 'We can deploy as many verticles of the same type as needed. For example, let''s
    deploy four verticles that send messages to the address `INSERT`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要部署相同类型的垂直。例如，让我们部署四个发送消息到地址`INSERT`的垂直：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To see the results, we will also ask the reading Verticle to read the last
    eight records:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看结果，我们还将要求读取垂直读取最后八条记录：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result (the final section of the output) then will be as expected:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（输出结果的最后部分）将如预期的那样：
- en: '![Building Microservices](img/04_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_10.jpg)'
- en: Four verticles have sent the same messages, so each name was sent four times
    and processed that is what we see in the previous output.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 四个垂直发送了相同的消息，所以每个名称发送了四次，这就是我们在之前的输出中看到的内容。
- en: 'We will now return to one inserting periodic verticle but will change it from
    using the method `rxSend()` to the method `publish()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到一个插入周期垂直，但将其从使用`rxSend()`方法更改为`publish()`方法：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This change would mean that the message has to be sent to all verticles that
    are registered as the consumers at that address. Now, let''s run the following
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改意味着消息必须发送到在该地址注册为消费者的所有垂直。现在，让我们运行以下代码：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have included another delay for 200 ms to give the publishing verticle time
    to send the message. The output (in the final section) now shows that each message
    was processed twice:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为发布垂直发送消息留出200毫秒的延迟，以便发布垂直有时间发送消息。输出（在最后部分）现在显示每条消息都被处理了两次：
- en: '![Building Microservices](img/04_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![构建微服务](img/04_11.jpg)'
- en: That is because two consumers `DbServiceBus(1)` and `DbServiceBus(2)` were deployed,
    and each received a message to the address `INSERT` and inserted it in the table
    `who_called`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为部署了两个消费者`DbServiceBus(1)`和`DbServiceBus(2)`，每个都收到了发送到地址`INSERT`的消息并将其插入到`who_called`表中。
- en: All the previous examples we have run in one JVM process. If necessary, Vert.x
    instances can be deployed in different JVM processes and clustered by adding the
    `-cluster` option to the run command. Therefore, they share the event bus and
    the addresses are visible to all Vert.x instances. This way, the resources can
    be added to each address as needed. For example, we can increase the number of
    processing microservices only and compensate the load's increase.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前运行的所有示例都是在单个JVM进程中运行的。如果需要，可以通过在运行命令中添加`-cluster`选项将Vert.x实例部署在不同的JVM进程中并实现集群。因此，它们共享事件总线，地址对所有Vert.x实例都是可见的。这样，可以根据需要向每个地址添加资源。例如，我们可以仅增加处理微服务的数量，以补偿负载的增加。
- en: Other frameworks we mentioned earlier have similar capabilities. They make microservices
    creation easy and may encourage breaking the application into tiny single-method
    operations with an expectation of assembling a very resilient and responsive system.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的其他框架也有类似的功能。它们使微服务的创建变得容易，并可能鼓励将应用程序分解成微小的单方法操作，期望组装一个非常健壮和响应迅速的系统。
- en: However, these are not the only criteria of good quality. System decomposition
    increases the complexity of its deployment. Also, if one development team is responsible
    for many microservices, the complexity of versioning so many pieces in different
    stages (development, test, integration test, certification, staging, production)
    may lead to confusion and a very challenging deployment process, which, in turn,
    may slow down the rate of changes necessary to keep the system in sync with the
    market requirements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些并非是衡量高质量的唯一标准。系统分解增加了其部署的复杂性。此外，如果一个开发团队负责许多微服务，那么在不同阶段（开发、测试、集成测试、认证、预发布、生产）对这些多个部分进行版本控制可能会引起混淆，并导致一个极具挑战性的部署过程，这反过来可能会减缓系统与市场需求保持同步所需的变更速度。
- en: 'In addition to the developing of the microservices, many other aspects have
    to be addressed to support the reactive system:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发微服务之外，还必须解决许多其他方面的问题以支持反应式系统：
- en: A monitoring system has to be designed to provide an insight into the state
    of the application, but it should not be so complex as to pull the development
    resources away from the main application.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设计一个监控系统，以便深入了解应用程序的状态，但它不应过于复杂，以至于将开发资源从主要应用程序中拉走。
- en: Alerts have to be installed to warn the team about possible and actual issues
    in a timely manner, so they can be addressed before affecting the business.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须安装警报来及时提醒团队关于可能和实际问题的信息，以便在影响业务之前得到解决。
- en: If possible, self-correcting automated processes have to be implemented. For
    example, the system should be able to add and release resources in accordance
    with the current load; the retry logic has to be implemented with a reasonable
    upper limit of a attempts before declaring the failure.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，必须实施自我纠正的自动化流程。例如，系统应该能够根据当前负载添加和释放资源；重试逻辑必须实现一个合理的尝试上限，在宣布失败之前。
- en: A layer of circuit breakers has to protect the system from the domino effect
    when failure of one component deprives other components of the necessary resources.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一层断路器来保护系统免受单点故障的连锁反应，当一个组件的故障剥夺了其他组件所需资源时。
- en: An embedded testing system should be able to introduce disruptions and simulate
    processing load to ensure that the application resilience and responsiveness do
    not degrade over time. For example, the Netflix team has introduced a **chaos
    monkey** a system that is able to shut down various parts of the production system
    to test the ability to recover. They use it even in production because a production
    environment has a specific configuration, and no test in another environment can
    guarantee that all possible issues are found.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内嵌的测试系统应该能够引入中断并模拟处理负载，以确保应用程序的弹性和响应性不会随着时间的推移而降低。例如，Netflix 团队引入了一个名为 **混沌猴子**
    的系统，该系统能够关闭生产系统的各个部分以测试恢复能力。他们甚至在生产环境中使用它，因为生产环境有一个特定的配置，而在其他环境中进行的任何测试都无法保证发现所有可能的问题。
- en: One of the main considerations of a reactive system design is the selection
    of the deployment methodology that can be either container-less, self-contained,
    or in-container. We will look into the pros and cons of each of these approaches
    in the following sections of this lesson.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统设计的主要考虑之一是选择部署方法，这可以是无容器、自包含或在容器内。我们将在本课程的后续部分探讨这些方法的优缺点。
- en: Container-Less Deployment
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无容器部署
- en: People use the term **container** to refer to very different things. In the
    original usage, a container was something that carried its content from one location
    to another without changing anything inside. However, when servers were introduced,
    only one aspect was emphasized the ability to hold an application to contain it.
    Also, another meaning was added to provide life-supportive infrastructure so that
    the container's content (an application) can not only survive but also be active
    and respond to the external requests. Such a redefined notion of a container was
    applied to web servers (servlet container), application servers (an application
    container with or without an EJB container), and other software facilities that
    provided the supportive environment for applications. Sometimes, even the JVM
    itself was called a container, but this association did not survive, probably,
    because the ability to actively engage (execute) the content does not align well
    with the original meaning of a container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用术语**容器**来指代非常不同的事物。在原始用法中，容器是一种将内容从一个地方运送到另一个地方而不改变内容内部任何东西的东西。然而，当服务器被引入时，只强调了一个方面，即能够容纳应用程序以包含它。此外，还增加了一个含义，提供生命支持的基础设施，以便容器的内容（一个应用程序）不仅能够生存，而且能够活跃并对外部请求做出响应。这种重新定义的容器概念被应用于Web服务器（servlet容器）、应用程序服务器（带有或没有EJB容器的应用程序容器）以及其他提供应用程序支持环境的软件设施。有时，JVM本身甚至被称为容器，但这种联系可能没有持续下去，可能是因为积极参与（执行）内容的能力与容器的原始含义不太一致。
- en: That is why, later, when people started talking about container-less deployment,
    they typically meant the ability to deploy an application into a JVM directly,
    without first installing WebSphere, WebLogic, JBoss, or any other mediating software
    that provides the runtime environment for the application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，后来当人们开始谈论无容器部署时，他们通常指的是将应用程序直接部署到JVM中的能力，而无需首先安装WebSphere、WebLogic、JBoss或任何其他提供应用程序运行环境的中间件软件。
- en: 'In the previous sections, we described many frameworks that allow us to build
    and deploy an application (or rather a reactive system of microservices) without
    the need for any other container beyond the JVM itself. All you need to do is
    to build a fat JAR file that includes all the dependencies (except those that
    come from the JVM itself) and then run it as a standalone Java process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了许多框架，这些框架允许我们构建和部署应用程序（或者更确切地说，是一个无容器微服务系统），而无需使用JVM之外的任何其他容器。你所需做的只是构建一个包含所有依赖项（除了来自JVM本身的依赖项）的胖JAR文件，然后作为一个独立的Java进程运行它：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Well, you also need to make sure that `MANIFEST.MF` in your JAR file has an
    entry `main` class that points to the fully qualified class name that has the
    `main()` method and will be run at the startup. We have described how to do it
    in the previous section, *Building Microservices*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你还需要确保你的JAR文件中的`MANIFEST.MF`有一个指向具有`main()`方法的完全限定类名并将在启动时运行的`main`类的条目。我们已经在之前的章节中描述了如何做到这一点，*构建微服务*。
- en: That is the promised compile-once-run-everywhere of Java, everywhere meaning
    everywhere where JVM of a certain version or higher is installed. There are several
    advantages and disadvantages of this approach. We will discuss them not relative
    to the traditional deployment in a server container. The advantages of deployment
    without using the traditional containers are quite obvious, starting with much
    fewer (if any) licensing costs and ending up with much a lighter deployment and
    scalability process, not even mentioning much less consumption of resources. Instead,
    we will compare container-less deployment not with the traditional one, but with
    a self-contained and an in-container in a new generation of containers that have
    been developed a few years ago.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java承诺的一次编译，到处运行的特点，这里的“到处”指的是安装了某个版本或更高版本的JVM的任何地方。这种方法的优点和缺点有很多。我们将讨论它们，而不是相对于传统服务器容器部署的情况。不使用传统容器进行部署的优点非常明显，从更少的（如果有的话）许可成本开始，到更轻量级的部署和可扩展性过程，更不用说资源消耗更少了。相反，我们将比较无容器部署，不是与传统的部署相比，而是与几年前开发的新一代容器中的自包含和在容器内的部署相比。
- en: They allow the ability not only to contain and execute the contained code, which
    the traditional containers did too, but also to move it to a different location
    without any change to the contained code. From now on, by a container, we are
    going to mean only the new ones.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不仅允许包含和执行包含的代码，这与传统的容器也做到了，而且还可以将其移动到不同的位置，而无需对包含的代码进行任何更改。从现在起，当我们提到容器时，我们只指新的容器。
- en: 'The advantages of container-less deployment are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 无容器部署的优点如下：
- en: It is easy to add more Java processes either inside the same physical (or virtual
    or in the cloud) machine or on new hardware
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易在同一个物理（或虚拟或云）机器内部或在新硬件上添加更多的 Java 进程。
- en: An isolation level between processes is high, which is especially important
    in the shared environment when you have no control over other co-deployed applications,
    and it is possible that a rogue application would try to penetrate the neighboring
    execution environment
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程之间的隔离级别很高，这在共享环境中尤为重要，当你无法控制其他共同部署的应用程序时，可能有一个恶意应用程序会试图渗透相邻的执行环境。
- en: It has a small footprint since it does not include anything else beyond the
    application itself or a group of microservices
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的占用空间很小，因为它不包含除应用程序本身或一组微服务之外的其他任何内容。
- en: 'The disadvantages of container-less deployment are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无容器部署的缺点如下：
- en: Each JAR file requires the JVM of a certain version or higher, which may force
    you to bring up a new physical or virtual machine just for this reason, to deploy
    one particular JAR file
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 JAR 文件都需要特定版本或更高版本的 JVM，这可能会迫使你仅仅因为这个原因就启动一个新的物理或虚拟机来部署特定的 JAR 文件。
- en: In the case of an environment you do not control, your code might be deployed
    with a wrong version of JVM, which could lead to unpredictable results
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你无法控制的环境中，你的代码可能会使用错误的 JVM 版本部署，这可能导致不可预测的结果。
- en: Processes in the same JVM compete for resources, which are especially hard to
    manage in the case of the environments shared by different teams or different
    companies
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一个 JVM 中的进程会竞争资源，这在由不同团队或不同公司共享的环境中尤其难以管理。
- en: When several microservices are bundled into the same JAR file, they might require
    different versions of a third-party library or even incompatible libraries
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个微服务捆绑到同一个 JAR 文件中时，它们可能需要不同版本的第三方库，甚至是不兼容的库。
- en: Microservices can be deployed one per JAR or bundled together by a team, by
    related services, by the unit of scale, or using another criterion. Not the least
    important consideration is the total number of such JAR files. As this number
    grows (Google today deals with hundreds of thousands of deployment units at a
    time), it may become impossible to handle deployment via simple bash script and
    require a complex process that allows account ability for possible incompatibilities.
    If that is the case, then it is reasonable to consider using virtual machines
    or containers (in their new incarnation, see the following section) for better
    isolation and management.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以单独每个 JAR 部署，也可以由团队、相关服务、规模单元或使用其他标准打包在一起。其中最不可忽视的考虑因素是此类 JAR 文件的总数。随着这个数字的增长（谷歌今天一次处理数十万个部署单元），可能无法通过简单的
    bash 脚本来处理部署，而需要复杂的流程，以便对可能的不兼容性负责。如果是这种情况，那么考虑使用虚拟机或容器（在其新形态中，见下文）以实现更好的隔离和管理是合理的。
- en: Self-Contained Microservices
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自包含的微服务
- en: Self-contained microservices look much similar to container-less. The only difference
    is that the JVM (or JRE, actually) or any other external frameworks and servers
    necessary for the application to run are included in the fat JAR file too. There
    are many ways to build such an all-inclusive JAR file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含的微服务看起来与无容器部署非常相似。唯一的区别是，JVM（或 JRE，实际上）或任何其他必要的应用程序运行的外部框架和服务器都包含在胖 JAR 文件中。有许多方法可以构建这样的全包含
    JAR 文件。
- en: Spring Boot, for example, provides a convenient GUI with checkbox list that
    allows you to select which parts of your Spring Boot application and the external
    tools you would like to package. Similarly, WildFly Swarm allows you to choose
    which parts of the Java EE components you would like to bundle along with your
    application. Alternatively, you can do it yourself using the `javapackager` tool.
    It compiles and packages the application and JRE in the same JAR file (it can
    also be `.exe` or `.dmg`) for distribution. You can read about the tool on the
    Oracle website [https://docs.oracle.com/javase/9/tools/javapackager.htm](https://docs.oracle.com/javase/9/tools/javapackager.htm)
    or you can just run the command `javapackager` on a computer where JDK is installed
    (it comes with Java 8 too) you will get the list of tool options and their brief
    description.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Spring Boot提供了一个方便的GUI复选框列表，允许你选择你想要打包的Spring Boot应用程序和外部工具的部分。同样，WildFly
    Swarm允许你选择你想要与应用程序捆绑的Java EE组件的部分。或者，你也可以使用`javapackager`工具自己完成。它将应用程序和JRE编译并打包在同一JAR文件中（也可以是`.exe`或`.dmg`）以进行分发。你可以在Oracle网站上了解有关该工具的更多信息[https://docs.oracle.com/javase/9/tools/javapackager.htm](https://docs.oracle.com/javase/9/tools/javapackager.htm)，或者你可以在安装了JDK的计算机上运行`javapackager`命令（它也包含在Java
    8中），你将获得工具选项及其简要描述的列表。
- en: Basically, to use the `javapackager` tool, all you need to do is to prepare
    a project with everything you would like to package together, including all the
    dependencies (packaged in JAR files), and run the `javapackager` command with
    the necessary options that allow you to specify the type of output you would like
    to have (`.exe` or `.dmg`, for example), the JRE location you would like to bundle
    together, the icon to use, the `main` class entry for `MANIFEST.MF`, and so on.
    There are also Maven plugins that make the packaging command simpler because much
    of the setup has to be configured in `pom.xml`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，要使用`javapackager`工具，你需要做的就是准备一个包含你想要打包在一起的所有内容的工程，包括所有依赖项（打包在JAR文件中），然后运行带有必要选项的`javapackager`命令，这些选项允许你指定你想要的输出类型（例如`.exe`或`.dmg`），你想要捆绑的JRE位置，要使用的图标，`MANIFEST.MF`的`main`类入口，等等。还有Maven插件可以使打包命令更简单，因为大部分设置都需要在`pom.xml`中配置。
- en: 'The advantages of self-contained deployment are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含部署的优点如下：
- en: It is one file (with all the microservices that compose the reactive system
    or some part of it) to handle, which is simpler for a user and for a distributor
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个文件（包含构成反应式系统的所有微服务或其部分），这对于用户和分销商来说都更简单
- en: There is no need to pre-install JRE and no risk of mismatching the required
    version
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要预先安装JRE，也没有版本不匹配的风险
- en: The isolation level is high because your application has a dedicated JRE, so
    the risk of an intrusion from a co-deployed application is minimal
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离级别很高，因为你的应用程序有一个专用的JRE，所以来自共同部署的应用程序的入侵风险最小
- en: You have full control over the dependencies included in the bundle
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以完全控制包含在捆绑包中的依赖项
- en: 'The disadvantages are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: The size of the file is bigger, which might be an impediment if it has to be
    downloaded
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的大小更大，这可能会成为下载时的障碍
- en: The configuration is more complex than in the case of a container-less JAR file
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置比无容器JAR文件的配置更复杂
- en: The bundle has to be generated on a platform that matches the target one, which
    might lead to mismatch if you have no control over the installation process
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捆绑包必须在与目标平台匹配的平台上生成，如果你无法控制安装过程，这可能会导致不匹配
- en: Other processes deployed on the same hardware or virtual machine can hog the
    resources critical for your application needs, which are especially hard to manage
    if your application is downloaded and run not by the team that has developed it
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一硬件或虚拟机上部署的其他进程可能会占用对应用程序需求至关重要的资源，如果你的应用程序不是由开发它的团队下载和运行，这将特别难以管理
- en: In-Container Deployment
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器内部署
- en: Those who are familiar with **Virtual Machine** (**VM**) and not familiar with
    modern containers (such as Docker, Rocket by CoreOS, VMware Photon, or similar)
    could get the impression that we were talking about VM while saying that a container
    could not only contain and execute the contained code, but also to move it to
    a different location without any change to the contained code. If so, that would
    be quite an apt assumption. VM does allow all of that, and a modern container
    can be considered a lightweight VM as it also allows the allocation of resources
    and provides the feeling of a separate machine. Yet, a container is not a full-blown
    isolated virtual computer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那些熟悉**虚拟机**（**VM**）但不熟悉现代容器（如Docker、CoreOS的Rocket、VMware Photon或类似技术）的人可能会产生这样的印象：我们在谈论容器时，实际上是在谈论虚拟机，因为容器不仅能包含和执行代码，还能将其移动到不同的位置，而不会对包含的代码进行任何更改。如果是这样，那将是一个非常恰当的假设。虚拟机确实允许所有这些操作，而现代容器可以被视为轻量级的虚拟机，因为它也允许分配资源并提供独立机器的感觉。然而，容器并不是一个完整的独立虚拟计算机。
- en: The key difference is that the bundle that can be passed around as a VM includes
    an entire operating system (with the application deployed). So, it is quite possible
    that a physical server running two VMs would have two different operating systems
    running on it. By contrast, a physical server (or a VM) running three containerized
    applications has only one operating system running, and the two containers share
    (read-only) the operating system kernel, each having its own access (mount) for
    writing to the resources they do not share. This means, for example, a much shorter
    start time, because starting a container does not require us to boot the operating
    system (as in the case of a VM).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区别在于，可以作为虚拟机传递的捆绑包包括整个操作系统（以及部署的应用程序）。因此，一个物理服务器上运行两个虚拟机可能会运行两个不同的操作系统。相比之下，一个物理服务器（或虚拟机）上运行三个容器化应用程序只有一个操作系统在运行，这两个容器共享（只读）操作系统内核，每个容器都有其自己的访问（挂载）权限，用于写入它们不共享的资源。这意味着，例如，启动时间会大大缩短，因为启动容器不需要我们引导操作系统（如虚拟机的情况）。
- en: For an example, let's take a closer look at Docker the community leader in container.
    In 2015, an initiative called **Open Container Project** was announced, later
    renamed the **Open Container Initiative** (**OCI**), which was supported by Google,
    IBM, Amazon, Microsoft, Red Hat, Oracle, VMware, HP, Twitter, and many other companies.
    Its purpose was to develop industry standards for a container format and container
    runtime software for all platforms. Docker has donated about 5 percent of its
    code base to the project because its solution was chosen as the starting point.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以社区容器领导者Docker为例，让我们更深入地了解一下。2015年，一个名为**开放容器项目**的倡议被宣布，后来更名为**开放容器倡议**（**OCI**），得到了谷歌、IBM、亚马逊、微软、红帽、甲骨文、VMware、惠普、推特和许多其他公司的支持。其目的是为所有平台开发容器格式和容器运行时软件的行业标准。Docker将其大约5%的代码库捐赠给了该项目，因为其解决方案被选为起点。
- en: 'There is an extensive Docker documentation at: [https://docs.docker.com](https://docs.docker.com).
    Using Docker, one can include in the package all the Java EE Container and the
    application as a Docker image, achieving essentially the same result as with a
    self-contained deployment. Then, you can launch your application by starting the
    Docker image in the Docker engine using this command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.docker.com](https://docs.docker.com)有大量的Docker文档。使用Docker，可以将Java
    EE容器和应用程序作为一个Docker镜像打包，从而实现与自包含部署基本相同的结果。然后，您可以通过在Docker引擎中启动Docker镜像来启动您的应用程序，使用以下命令：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It starts a process that looks like running an OS on a physical computer, although
    it can also be happening in a cloud inside a VM that is running on the physical
    Linux server shared by many different companies and individuals. That is why an
    isolation level (which, in the case of containers, is almost as high as in a VM)
    may be critical in choosing between different deployment models.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它启动的过程类似于在物理计算机上运行操作系统，尽管它也可能发生在云中，在运行在物理Linux服务器上的虚拟机中，该服务器由许多不同的公司和个人共享。这就是为什么隔离级别（在容器的情况下，几乎与虚拟机一样高）在选择不同的部署模型时可能至关重要。
- en: A typical recommendation would be to put one microservice in each container,
    but nothing prevents you from putting several microservices in one Docker image
    (or any other container for that matter). However, there are already mature systems
    of container management (in the world of containers called **orchestration**)
    that can help you with deployment, so the complexity of having many containers,
    although a valid consideration, should not be a big obstacle if resilience and
    responsiveness are at stake. One of the popular orchestrations called **Kubernetes**
    supports microservice registry, discovery, and load balancing. Kubernetes can
    be used in any cloud or in a private infrastructure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的建议是将每个微服务放入一个容器中，但没有任何东西阻止你将多个微服务放入一个Docker镜像（或者任何其他容器）。然而，已经存在成熟的容器管理系统（在容器世界中称为**编排**），可以帮助你进行部署，因此拥有许多容器的复杂性，尽管是一个有效的考虑因素，但如果涉及到弹性和响应性，不应该成为一个大的障碍。其中一种流行的编排称为**Kubernetes**，支持微服务注册、发现和负载均衡。Kubernetes可以在任何云或私有基础设施中使用。
- en: Containers allow a fast, reliable, and consistent deployment in practically
    any of the current deployment environments, whether it is your own infrastructure
    or a cloud at Amazon, Google, or Microsoft. They also allow the easy movement
    of an application through the development, testing, and production stages. Such
    infrastructure independence allows you, if necessary, to use a public cloud for
    development and testing and your own computers for production.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 容器允许在几乎任何当前的部署环境中快速、可靠和一致地部署，无论是你的基础设施还是亚马逊、谷歌或微软的云。它们还允许应用程序轻松地在开发、测试和生产阶段之间移动。这种基础设施独立性允许你在必要时使用公共云进行开发和测试，并使用你自己的计算机进行生产。
- en: Once a base operating image is created, each development team can then build
    their application on top, thus avoiding the complexities of environment configuration.
    The versions of a container can also be tracked in a version control system.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个基础操作系统镜像，每个开发团队就可以在其上构建他们的应用程序，从而避免了环境配置的复杂性。容器版本也可以在版本控制系统中跟踪。
- en: 'The advantages of using containers are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的优点如下：
- en: The level of isolation is the highest if compared with container-less and self-contained
    deployment. In addition, more efforts were put recently into adding security to
    containers.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与无容器和自包含部署相比，隔离级别是最高的。此外，最近还投入了更多努力来增强容器的安全性。
- en: Each container is managed, distributed, deployed, started, and stopped by the
    same set of commands.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个容器都由同一组命令进行管理、分发、部署、启动和停止。
- en: There is no need to pre-install JRE and risk of mismatching the required version.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要预先安装JRE，也无需担心版本不匹配的风险。
- en: You have full control over the dependencies included in the container.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以完全控制容器中包含的依赖项。
- en: It is straightforward to scale up/down each microservice by adding/removing
    container instances.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加/删除容器实例，可以轻松地向上/向下扩展每个微服务。
- en: 'The disadvantages of using containers are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的缺点如下：
- en: You and your team have to learn a whole new set of tools and become involved
    more heavily in the production stage. On the other hand, that seems to be the
    general tendency in recent years.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你和你的团队必须学习一套全新的工具，并在生产阶段更加深入地参与。另一方面，这似乎是近年来的一般趋势。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Microservices is a new architectural and design solution for highly loaded processing
    systems that became popular after being successfully used in production by such
    giants as Amazon, Google, Twitter, Microsoft, IBM, and others. It does not mean
    though that you must adopt it too, but you can consider the new approach and see
    if some or any of it can help your applications to be more resilient and responsive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是针对高度负载处理系统的一种新的架构和设计解决方案，在亚马逊、谷歌、推特、微软、IBM等巨头在生产中成功应用后变得流行。但这并不意味着你必须采用它，但你可以考虑这种新方法，看看它是否可以帮助你的应用程序更加弹性和响应。
- en: Using microservices can provide a substantial value, but it is not free. It
    comes with increased complexity of the need to manage many more units through
    all the lifecycle from requirements and development through testing to production.
    Before committing to the full-scale microservice architecture, give it a shot
    by implementing just a few microservices and move them all the way to production.
    Then, let it run for some time and gauge the experience. It will be very specific
    to your organization. Any successful solution must not be blindly copied but adopted
    as fit for your particular needs and abilities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务可以提供巨大的价值，但这并非没有代价。它伴随着管理更多单元的复杂性，这些单元需要从需求、开发、测试到生产的整个生命周期进行管理。在全面采用微服务架构之前，先尝试实现几个微服务并将它们全部部署到生产环境中。然后，让它运行一段时间并评估经验。这将对您的组织非常具体。任何成功的解决方案都不能盲目复制，而应该根据您的特定需求和能力进行采用。
- en: Better performance and overall efficiency often can be achieved by gradual improvements
    of what is already in place than by radical redesign and re-architecture.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步改进现有的内容，通常可以比通过彻底的重设计和重构实现更好的性能和整体效率。
- en: In the next lesson, we will discuss and demonstrate new API that can improve
    your code by making it more readable and faster performing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将讨论和演示新的API，它可以通过使代码更具可读性和更快的性能来改进您的代码。
- en: Assessments
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Using the _________ object, various verticles can be deployed, which talk to
    each other, receive an external request, and process and store data as any other
    Java application, thus forming a system of microservices.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该 _________ 对象，可以部署各种verticles，它们相互通信，接收外部请求，并以任何其他Java应用程序的方式处理和存储数据，从而形成一个微服务系统。
- en: Which of the following is advantage of container-less deployment?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是无容器部署的优势？
- en: Each JAR file requires the JVM of a certain version or higher, which may force
    you to bring up a new physical or virtual machine just for this reason, to deploy
    one particular JAR file
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个JAR文件都需要一定版本或更高版本的JVM，这可能会迫使您仅为此原因启动一个新的物理或虚拟机来部署特定的JAR文件。
- en: In the case of an environment you do not control, your code might be deployed
    with a right version of JVM, which could lead to unpredictable results
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您无法控制的环境中，您的代码可能会使用正确的JVM版本进行部署，这可能导致不可预测的结果。
- en: Processes in the same JVM compete for resources, which are especially hard to
    manage in the case of the environments shared by different teams or different
    companies
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一个JVM中的进程会竞争资源，这在由不同团队或不同公司共享的环境中尤其难以管理。
- en: It has a small footprint since it does not include anything else beyond the
    application itself or a group of microservices
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它不包括除应用程序本身或一组微服务之外的其他任何内容，因此它具有很小的占用空间。
- en: 'State whether True or False: One way to support a transaction across several
    microservices is to create a service that would play the role of a Parallel Transaction
    Manager.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：支持跨多个微服务的交易的一种方法是为扮演并行事务管理器角色的服务创建一个服务。
- en: Which of the following are the Java frameworks that are included in Java 9?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是Java 9中包含的Java框架？
- en: Akka
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Akka
- en: Ninja
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ninja
- en: Orange
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Orange
- en: Selenium
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Selenium
- en: 'State whether True or False: The level of isolation in a container is the highest
    if compared with container-less and self-contained deployment.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：与无容器和自包含部署相比，容器中的隔离级别是最高的。
