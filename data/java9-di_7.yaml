- en: IoC Patterns and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IoC模式和最佳实践
- en: Now that you have reached this chapter, you should know what **Dependency Injection**
    (**DI**) is, why it's so important, how it's projected in recent versions of Java,
    and how to implement it with popular frameworks, such as Spring and Google Guice,
    with various scopes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经到达了这一章节，你应该知道什么是**依赖注入**（**DI**），为什么它如此重要，它在Java的最近版本中是如何体现的，以及如何使用流行的框架，如Spring和Google
    Guice，以及各种作用域来实现它。
- en: It's said that knowing something is not enough until it's applied with best
    methodologies and practices. Knowledge is power only when it's implemented in
    the right manner. An improper approach may create a big mess.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 据说，直到用最佳的方法和实践应用，知道某事是不够的。只有当知识以正确的方式实施时，知识才是力量。不恰当的方法可能会造成大混乱。
- en: The software industry is moving toward modularity. The concepts of DI and **Inversion
    of Control** (**IoC**) containers were created due to this, and this is why they
    are so popular today. Still, many developers don't know how to utilize DI to its
    full potential.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业正朝着模块化发展。DI和**控制反转**（**IoC**）容器的概念正是由于这一点而创建的，这也是为什么它们今天如此受欢迎。尽管如此，许多开发者不知道如何充分利用DI。
- en: In this chapter, we will explore the real strength of DI by learning the right
    patterns and best practices to apply the expertise we gained in DI in previous
    chapters. This chapter is not meant to do anything new; instead, we will learn
    how to do things in the right manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过学习正确的模式和最佳实践来探索DI的真实优势，将这些我们在前几章中获得的DI专业知识应用到实践中。这一章的目的不是做任何新的事情；相反，我们将学习如何以正确的方式做事。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Various patterns to achieve IoC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现IoC的各种模式
- en: Configuration styles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置样式
- en: Injection using the setter method versus constructor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用setter方法与构造函数进行注入
- en: Circular dependency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环依赖
- en: Best practices and anti-patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践和反模式
- en: Various patterns to achieve IoC
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现IoC的各种模式
- en: 'Let''s recall what the  **Dependency Inversion Principle** (**DIP**) states:
    high-level modules should not depend upon low-level modules; both should depend
    upon abstraction. This is a fundamental requirement for making any application
    modular and adjustable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下**依赖倒置原则**（**DIP**）的内容：高级模块不应该依赖于低级模块；两者都应该依赖于抽象。这是使任何应用程序模块化和可调整的基本要求。
- en: While designing any system, we should make sure that high-level classes do not
    instantiate low-level classes; instead, they should rely on abstraction (the interface
    or abstract class) rather than depending on other concrete classes directly. The
    DIP does not specify how this happens, so a technique is required to separate
    the low-level modules from the high-level modules. IoC provides this technique.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计任何系统时，我们应该确保高级类不直接实例化低级类；相反，它们应该依赖于抽象（接口或抽象类）而不是直接依赖于其他具体类。DIP没有指定这是如何发生的，因此需要一种技术来分离低级模块和高级模块。IoC提供了这种技术。
- en: 'There are various patterns to achieve IoC, including inverting the object creation
    process from your class to some other class and reducing the coupling between
    modules or classes. Let''s discuss these patterns, focusing more on how they decouple
    the modules and achieve separation of concerns:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实现IoC有多种模式，包括将对象创建过程从你的类反转到其他类，以及减少模块或类之间的耦合。让我们讨论这些模式，更多地关注它们如何解耦模块并实现关注点的分离：
- en: The factory method pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The service locator pattern
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器模式
- en: The template method pattern
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The strategy pattern
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: All of these patterns encapsulate a specific responsibility, which makes the
    system modular.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式封装了特定的责任，这使得系统模块化。
- en: The factory method pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The factory method pattern concerns defining an interface (or abstract class)
    method for creating dependency objects. This method is called a factory method. The
    class (or interface) that holds the factory method will be considered an abstract
    creator. The actual object creation process does not happen in the factory method
    directly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式关注定义一个用于创建依赖对象的接口（或抽象类）方法。这个方法被称为工厂方法。持有工厂方法的类（或接口）将被视为抽象创建者。实际的对象创建过程不会在工厂方法中直接发生。
- en: 'The concrete creators (which implement the factory method) will decide which
    dependent class to instantiate. In short, the dependent object is decided at runtime. This
    process has been described in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 具体创建者（实现工厂方法的类）将决定实例化哪个依赖类。简而言之，依赖对象是在运行时决定的。这个过程已在以下图中描述：
- en: '![](img/00052.gif)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.gif)'
- en: 'The factory pattern''s implementation is a four-step process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式的实现是一个四步过程：
- en: Declaring the product (the abstract product type).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明产品（抽象产品类型）。
- en: Creating the concrete product.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具体产品。
- en: Defining the factory method – a creator.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义工厂方法 – 创建者。
- en: Creating concrete creators (concrete subclasses).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具体创建者（具体子类）。
- en: Let's understand these steps by using an example. Suppose you are developing
    an application for a message service provider. Initially, the company provides
    an SMS service for cellular devices. So, the first version of your application
    code is handling message distribution with SMS only, assuming that the bulk of
    code is written in the `SMS` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这些步骤。假设你正在为一家消息服务提供商开发一个应用程序。最初，公司为蜂窝设备提供短信服务。因此，你应用程序代码的第一个版本仅处理短信消息分发，假设大部分代码是在`SMS`类中编写的。
- en: Gradually, the service becomes popular and you want to add other bulk message
    services, such as email, WhatsApp, and other social media message services. This
    requires code changes because you have added all the code to the `SMS` class.
    This change in code is required for every new messaging service that is introduced
    into the system in future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 逐渐地，服务变得流行，你希望添加其他大量消息服务，如电子邮件、WhatsApp和其他社交媒体消息服务。这需要代码更改，因为你已经将所有代码添加到了`SMS`类中。在将来，每当引入新的消息服务到系统中时，都需要这种代码更改。
- en: 'The factory method pattern suggests that the solution to this problem will
    be inverting the object creation process from the client code (with a new operator)
    to a specific method: the factory method. The factory method defines a common
    interface that returns an abstract product type. A concrete product''s creation
    is done in the child classes, which implement the factory method. The objects
    returned from the factory method are referred to as **Product** in the preceding
    diagram. First, let''s define an abstract product type and its concrete implementation
    for the preceding example.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式建议，这个问题的解决方案将是通过将对象创建过程从客户端代码（使用new运算符）倒置到特定方法：工厂方法。工厂方法定义了一个公共接口，它返回一个抽象产品类型。具体产品的创建是在实现工厂方法的子类中完成的。在前面的图中，从工厂方法返回的对象被称为**Product**。首先，让我们为前面的例子定义一个抽象产品类型及其具体实现。
- en: Defining the product (abstract type) and its concrete implementation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义产品（抽象类型）及其具体实现
- en: 'In our case, the **MessageApp** interface represents an abstract product type.
    The implementation of each messaging app would reside in their respective concrete
    classes, which are concrete product types, such as **SMSMessage**, **EmailMessage**,
    and **WhatsAppMessage**. This relationship is described with the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`**MessageApp**`接口代表一个抽象产品类型。每个消息应用程序的实现将位于它们各自的 concrete 类中，这些类是具体产品类型，例如`**SMSMessage**`、`**EmailMessage**`和`**WhatsAppMessage**`。这种关系用以下图表示：
- en: '![](img/00053.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00053.gif)'
- en: 'The product (abstract type) and all of the concrete product classes should
    look as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 产品（抽象类型）和所有具体产品类应如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining the factory method (creator interface) and its concrete implementation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义工厂方法（创建者接口）及其具体实现
- en: 'The next step is to create a class and define the factory method that returns
    the abstract product type (**MessageApp**, in our case). This class is considered
    an abstract creator. The factory method would be in the form of either an interface
    or the abstract method. All concrete creators must implement this factory method.
    The following diagram describes the complete relationship between these components:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个类并定义一个返回抽象产品类型（在我们的案例中是**MessageApp**）的工厂方法。这个类被认为是抽象创建者。工厂方法可以是接口或抽象方法的形式。所有具体创建者都必须实现这个工厂方法。以下图描述了这些组件之间的完整关系：
- en: '![](img/00054.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.gif)'
- en: Here, **MessagingService** is the creator, while **EmailServices**, **SMSServices**,
    and **WhatsAppServices** are concrete creators. Each concrete creator produces
    the respective concrete product type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`**MessagingService**`是创建者，而`**EmailServices**`、`**SMSServices**`和`**WhatsAppServices**`是具体创建者。每个具体创建者生产相应的具体产品类型。
- en: 'The factory method and its concrete implementation classes should look as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法和其具体的实现类应如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding case, we have used an abstract class, but you can also use
    an interface for the factory method (abstract creator). If you are planning to
    provide any common methods, you can choose an abstract class, or else an interface
    would be an appropriate choice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了抽象类，但你也可以使用接口作为工厂方法（抽象创建者）。如果你计划提供任何公共方法，你可以选择抽象类，否则接口是一个合适的选择。
- en: 'Finally, the factory class that provided the specific implementation looks
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提供特定实现的工厂类如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class returns the concrete implementation based on a specific `enum` type.
    The following code snippet depicts how client code can use the factory method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类根据特定的`enum`类型返回具体的实现。以下代码片段展示了客户端代码如何使用工厂方法：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is described with the following diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下图表来描述：
- en: '![](img/00055.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.gif)'
- en: With the factory method pattern, you can make the product creation process abstracted
    from the client class. This way, the factory method pattern removes the dependency
    of the concrete product classes from the rest of the system. Additionally, the
    factory method delegates the actual object creation process to concrete creators.
    As long as the client code knows the type, the factory class will supply the dependency
    object of that type. This way, the factory method allows client code to depend
    on abstraction rather than concrete implementation. This is how IoC is achieved
    through the factory method pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法模式，你可以将产品创建过程从客户端类中抽象出来。这样，工厂方法模式消除了具体产品类对整个系统的依赖。此外，工厂方法将实际的对象创建过程委托给具体的创建者。只要客户端代码知道类型，工厂类就会提供该类型的依赖对象。这样，工厂方法允许客户端代码依赖于抽象而不是具体实现。这就是通过工厂方法模式实现IoC的方式。
- en: The service locator pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器模式
- en: The service locator pattern entails removing dependencies from the client object
    by introducing a mediator. The client object will talk to the mediator to get
    a desired dependency. We will call this mediator the service locator, or just
    the locator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器模式涉及通过引入一个中介来从客户端对象中移除依赖。客户端对象将通过中介来获取所需的依赖。我们将这个中介称为服务定位器，或者简称定位器。
- en: The service locator involves the process of obtaining services with the abstract
    layer. Ideally, the locator should hold all the services (dependencies) and provide
    them with a single interface. It is a kind of central repository to find a service,
    usually by a string or interface type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器涉及通过抽象层获取服务的过程。理想情况下，定位器应持有所有服务（依赖），并通过单个接口提供它们。它是一种中央存储库，通常通过字符串或接口类型来查找服务。
- en: 'The service locator describes how to register and locate the service rather
    than telling us how to instantiate it. It lets the application register the concrete
    implementation for the given contract. You can add services either programmatically
    or through configuration. The implementation of the service locator is described
    in the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器描述了如何注册和定位服务，而不是告诉我们如何实例化它。它允许应用程序为给定的契约注册具体的实现。你可以通过编程或通过配置添加服务。服务定位器的实现如下所示：
- en: '![](img/00056.gif)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.gif)'
- en: This is a very simple form of the service locator pattern. **ModuleA** is dependent
    on **ServiceB** and **ServiceC**, which are provided by the **Service Locator**.
    However, you can make the **Service Locator** more abstract so that it can handle
    any type of service. Let's understand how to do that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的服务定位器模式。**ModuleA**依赖于由**Service Locator**提供的**ServiceB**和**ServiceC**。然而，你可以使**Service
    Locator**更加抽象，以便它可以处理任何类型的服务。让我们了解如何做到这一点。
- en: 'It is always a good idea to expose any service with an interface. We will take
    an example of two such service interfaces and their implementations in the following
    snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总是暴露任何服务的一个接口是一个好主意。以下代码片段将展示两个这样的服务接口及其实现：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want to get compression and encryption services from the service locator.
    We will write the `ServiceLocator` class, which is a singleton, and allows us
    to register these services. Once this is done, the client can get the services
    by the type of service interface. The `ServiceLocator` class will look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从服务定位器获取压缩和加密服务。我们将编写`ServiceLocator`类，它是一个单例，允许我们注册这些服务。一旦完成，客户端就可以通过服务接口类型来获取服务。`ServiceLocator`类将如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is not mandatory to use the interface for registering the services, but it
    is good practice. In future, if any new service of the same interface is introduced
    or a completely new set of services of a brand new interface is introduced, they
    can be easily accommodated without affecting the client code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注册服务来说，使用接口不是强制性的，但这是一个好的实践。在未来，如果引入了相同接口的新服务或引入了全新的接口的一组新服务，它们可以很容易地适应，而不会影响客户端代码。
- en: 'Also, with an interface, client code is more generic and you can change the
    implementation just by changing the key, making the system more flexible and loosely
    coupled. Finally, the service locator is used in client code, as you can see in
    the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有了界面，客户端代码更加通用，你只需更改键值就可以更改实现，使系统更加灵活和松散耦合。最后，客户端代码中使用了服务定位器，正如以下代码片段所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The service locator decouples the classes from their dependencies. The direct
    benefit of this arrangement is that the dependency can be replaced with little
    or (ideally) no code change. This way, the service locator pattern inverts the
    flow of control from the client code to the locator component. This is how IoC
    is implemented.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器解耦了类与其依赖关系。这种安排的直接好处是，依赖关系可以替换，而几乎不需要或（理想情况下）不需要代码更改。这样，服务定位器模式就颠倒了客户端代码到定位器组件的控制流。这就是IoC是如何实现的。
- en: In the service locator pattern, you need to make sure that all services are
    readily available before your objects start consuming it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务定位器模式中，你需要确保在对象开始使用服务之前，所有服务都 readily available。
- en: 'At first glance, it looks like the factory method pattern and service locator
    pattern work similarly. However, there are a few differences, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，工厂方法模式和服务定位器模式似乎工作方式相似。然而，它们之间有一些区别，如下所示：
- en: '**Construction cost:** If the class instantiation process inside the factory
    method is very expensive (in terms of resource consumption), then creating a new
    object in the factory method will result in performance issues. In short, the
    cost of construction in the factory method may impact overall system performance.
    In the service locator pattern, all of the dependency objects are created (ideally)
    during the application startup. The client can get the dependency service from
    a pre-instantiated registry.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建成本：**如果工厂方法中的类实例化过程非常昂贵（从资源消耗的角度来看），那么在工厂方法中创建新对象将导致性能问题。简而言之，工厂方法中的构建成本可能会影响整体系统性能。在服务定位器模式中，所有依赖对象都是在应用程序启动时（理想情况下）创建的。客户端可以从预先实例化的注册表中获取依赖服务。'
- en: '**Existing versus new objects:** Sometimes, you need same object every time. In
    the factory method pattern, we are returning a new instance every time, while
    the service locator pattern returns an existing instance of the dependency service
    to the caller.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有对象与新建对象：**有时，你需要每次都使用相同的对象。在工厂方法模式中，我们每次都返回一个新的实例，而服务定位器模式返回依赖服务的现有实例给调用者。'
- en: '**Ownership:** Since the factory class returns a fresh new instance to the
    caller, the ownership lies with the caller class, whereas the service locator locates
    and returns an existing instance of the service, and so the ownership of the returned
    objects would be with the service locator.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权：**由于工厂类向调用者返回一个全新的实例，因此所有权属于调用者类，而服务定位器定位并返回服务的现有实例，因此返回对象的拥有权属于服务定位器。'
- en: The template method pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The template method pattern involves defining the common structure of an algorithm,
    and then allowing subclasses to change or redefine some portion of the algorithm
    without changing the complete structure. In other words, the template method pattern
    defines a function in a set of operations, allowing subclasses to redefine a few
    steps without altering the complete structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式涉及定义算法的通用结构，然后允许子类在不改变完整结构的情况下更改或重新定义算法的一部分。换句话说，模板方法模式在一系列操作中定义了一个函数，允许子类在不改变完整结构的情况下重新定义几个步骤。
- en: In this pattern, the base class declares the generic procedure with placeholders
    and lets subclasses provide the specific implementations of those placeholders
    while keeping the overall structure unchanged.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式中，基类声明了具有占位符的通用过程，并允许子类提供这些占位符的具体实现，同时保持整体结构不变。
- en: 'Let''s understand the template method pattern with an example. Suppose you
    are writing a program to take row data, validate it, format it, and insert it
    into a database. Initially, the row data is provided in a CSV file, so you have
    created a class called `ProcessCSVData`. This class contains the logic for the
    following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解模板方法模式。假设您正在编写一个程序来获取行数据，验证它，格式化它，并将其插入到数据库中。最初，行数据以CSV文件的形式提供，因此您创建了一个名为`ProcessCSVData`的类。此类包含以下步骤的逻辑：
- en: Reading the CSV file
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取CSV文件
- en: Validating data
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证数据
- en: Formatting data
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化数据
- en: Inserting the data into the database
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据插入到数据库中
- en: A year later, a few more formats of raw data are introduced, such as HTML, XML,
    text, and Excel. For each of these formats, if you a create separate class, you
    will end up having lots of similar code. It is obvious that each of these classes
    is quite different in file formats, while their other logic of data validation,
    formation, and insertion into the database is identical among them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一年后，引入了更多原始数据格式，如HTML、XML、文本和Excel。对于这些格式中的每一个，如果您创建一个单独的类，您将最终拥有大量的相似代码。显然，这些类在文件格式上相当不同，而它们在数据验证、格式化和插入到数据库中的其他逻辑上是相同的。
- en: Think about the client code where these classes are used. You need to provide
    lots of `if...else` conditions to choose a specific implementation. This is not
    a good design. To achieve reusability, it is essential to get rid of code duplication
    and make the algorithm structure unbroken. If all of these classes are sharing
    a common base class, this problem can be solved by using polymorphism.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用这些类的客户端代码。您需要提供大量的`if...else`条件来选择特定的实现。这不是一个好的设计。为了实现可重用性，消除代码重复并使算法结构完整是至关重要的。如果所有这些类都共享一个公共基类，则可以通过使用多态来解决这个问题。
- en: To implement the template method pattern, you need to identify which steps of
    the algorithm are common and which are variants or customizable in nature. The
    common steps should be implemented in the base class, while the variant steps
    should be placed in the base class with either the default implementation or no
    implementation at all. The variant steps will be considered as placeholder or
    extension points that must be supplied by a concrete-derived class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现模板方法模式，您需要确定算法中哪些步骤是通用的，哪些是变体或可定制的。通用步骤应在基类中实现，而变体步骤应放置在基类中，带有默认实现或根本无实现。变体步骤将被视为占位符或扩展点，必须由具体派生类提供。
- en: 'In our example, reading data from a file is the only varying step, so we will
    keep it in the base class with default (or no) implementation in the method. This
    is considered as a template method. All concrete subclasses must provide implementations
    of this template method (reading the file from the respective formats). Other
    steps, such as validating, formatting, and inserting into the database, are common
    or invariant, so keep them in the base class as is. This implementation is described
    by the following diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，从文件中读取数据是唯一的可变步骤，因此我们将它保留在基类中，并在方法中使用默认（或无）实现。这被认为是模板方法。所有具体子类都必须提供此模板方法的实现（从相应格式中读取文件）。其他步骤，如验证、格式化和插入到数据库中，是通用或不变的，因此保持它们在基类中不变。此实现由以下图表描述：
- en: '![](img/00057.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: 'The following code snippet represents this implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示此实现：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The implementation''s subclasses should look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的子类应如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, the client code that uses the template method should look as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用模板方法的客户端代码应如下所示：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have used just two subclasses in client code. Similarly, you can use the
    remaining two subclasses. You will get the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们只使用了两个子类。同样，您也可以使用剩余的两个子类。您将得到以下输出：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The template method pattern allows the framework to define invariant pieces
    of the program and to specify the hook or placeholder for all possible customization
    options. This way, the framework becomes the center point of the product, while
    the customization is considered as an additional capability or add-on on top of
    the core functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式允许框架定义程序的不变部分，并指定所有可能的定制选项的钩子或占位符。这样，框架成为产品的中心点，而定制化被视为核心功能之上的附加功能或附加组件。
- en: The customization written for each of the template methods will get common functionalities
    from a generic framework or component. In other words, each client's customization
    receives the flow of control from the generic framework. The inverted control
    mechanism has been affectionately named the Hollywood Principle – "do not call
    us, we will call you". This is how IoC is achieved through the template method
    pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个模板方法编写的定制化代码将从通用框架或组件中获取通用功能。换句话说，每个客户的定制化都从通用框架接收控制流。这种倒置的控制机制被亲切地命名为好莱坞原则——“不要调用我们，我们会调用你”。这就是通过模板方法模式实现IoC的方式。
- en: The strategy pattern
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern defines a set of algorithms, encapsulates each of them,
    and makes them interchangeable at runtime. This pattern lets the implementation
    vary independently from the clients that use it. In short, you can change the
    output of a class by changing the algorithm at runtime. The strategy pattern focuses
    on creating an interface with different implementations that follows the same
    behavioral contract.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式定义了一组算法，封装每个算法，并在运行时使它们可互换。这种模式让实现独立于使用它的客户端。简而言之，你可以通过在运行时更改算法来更改类的输出。策略模式侧重于创建一个具有不同实现且遵循相同行为契约的接口。
- en: Let's understand this pattern with an example. Suppose you are developing an
    application to upload documents into the cloud. Initially, you have been provided
    with a Google Drive upload. You probably wrote the `GoogleDriveCloud` class and
    put all of the logic in that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来理解这个模式。假设你正在开发一个将文档上传到云中的应用程序。最初，你被提供了一个Google Drive上传。你可能编写了 `GoogleDriveCloud`
    类并将所有逻辑放在那里。
- en: At a later stage, you decided to support uploading documents on a few more cloud
    platforms, such as Dropbox, OneDrive, and Amazon S3\. At this moment in time,
    you write separate classes for each of them, such as `DropboxCloud`, `OneDriveCloud`,
    and `AmazoneS3Cloud`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的某个阶段，你决定支持上传到更多云平台，如Dropbox、OneDrive和Amazon S3。在这个时候，你为每个平台编写了单独的类，例如 `DropboxCloud`、`OneDriveCloud`
    和 `AmazoneS3Cloud`。
- en: All of these classes are used to upload documents onto the respective cloud.
    When you use them in your code, you will probably write the code to choose a specific
    implementation based on some condition.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类都用于将文档上传到相应的云。当你使用它们在代码中时，你可能会根据某些条件编写选择特定实现的代码。
- en: 'In the preceding case, the `CloudUpload` class is tightly coupled with each
    of the cloud implementations, which is not a good design. You can think about
    the problems when you try to accommodate more cloud support in future. Every new
    implementation requires a change to the `CloudUpload` class. This is a clear violation
    of the open-closes principle: which talks about **open for extension but closed
    for modification**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述情况下，`CloudUpload` 类与每个云实现紧密耦合，这不是一个好的设计。当你试图在未来适应更多的云支持时，你可以考虑这些问题。每个新的实现都需要修改
    `CloudUpload` 类。这是对开放-封闭原则的明显违反：它讨论的是**对扩展开放但对修改封闭**。
- en: 'This situation can be mitigated with the strategy pattern. The pattern involves
    defining a set of related algorithms (implementations of various cloud platforms)
    and encapsulating them in classes that are separate from the host class (`CloudUpload`).
    The solution is described with the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以通过策略模式来缓解。该模式涉及定义一组相关的算法（各种云平台的实现）并将它们封装在独立于宿主类（`CloudUpload`）的类中。解决方案用以下图表描述：
- en: '![](img/00058.gif)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.gif)'
- en: 'The implementation of the preceding diagram will look as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前述图表的实现将如下所示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have declared an interface called `Cloud`, which will be implemented by
    each concrete class. The  `CloudUpload` class represents a `Context` class. It
    holds the reference to `Cloud`, which is supplied through a constructor which
    is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个名为 `Cloud` 的接口，它将由每个具体类实现。`CloudUpload` 类代表一个 `Context` 类。它持有 `Cloud`
    的引用，该引用通过以下构造函数提供：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this design, each cloud implementation class has the logic of uploading a
    document to that particular cloud only, obeying the **single responsibility**
    principle. The `CloudUpload` class does not have a direct reference to any concrete
    class, but a reference of type `Cloud`, which holds the actual implementation.
    In this case, we are following this principle: **program to an interface, not
    implementation**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，每个云实现类只具有将文档上传到特定云的逻辑，遵循**单一职责**原则。`CloudUpload`类没有直接引用任何具体类，而是引用类型`Cloud`，它包含实际的实现。在这种情况下，我们遵循以下原则：**面向接口编程，而不是面向实现**。
- en: 'After applying the strategy pattern, you may now upload the document by creating
    an object of the `CloudUpload` class and passing the appropriate implementation
    in the constructor, as in the following snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用策略模式之后，你现在可以通过创建`CloudUpload`类的对象并在构造函数中传递适当的实现来上传文档，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In case of additional cloud implementation support in future, there is no change
    to the `CloudUpload` class. Unit testing becomes straightforward and easy. The
    `CloudUpload` class simply knows what to do with the strategy classes (the `Cloud`
    implementation) instead of putting conditional blocks to choose a specific implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未来需要额外的云实现支持，`CloudUpload`类不会发生变化。单元测试变得简单直接。`CloudUpload`类只知道如何处理策略类（`Cloud`实现），而不是通过条件块来选择特定的实现。
- en: This way, the strategy pattern helps us to achieve pluggable behavior. The logic
    of choosing the `Cloud` implementation is now shifted from the `CloudUpload` class.
    This is how IoC is achieved with the help of the strategy pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，策略模式帮助我们实现可插拔的行为。选择`Cloud`实现的逻辑现在已从`CloudUpload`类中移除。这就是如何借助策略模式实现IoC。
- en: Configuration styles
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置样式
- en: Almost all IoC containers allow you to choose either code or file-based (XML)
    configuration for declaring dependencies. Although they serve the same purpose,
    you might feel confused as to which option is best for the given scenario.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的IoC容器都允许你选择代码或基于文件（XML）的配置来声明依赖项。尽管它们服务于相同的目的，但你可能会对在特定场景下哪种选项最好感到困惑。
- en: For instance, file-based (mainly XML) configuration is appropriate for the applications
    that need deployment to multiple environments. On the other hand, there are specific
    scenarios where code-based configuration is chosen over file-based configuration.
    Identifying the difference between these two will help you choose which one is
    right for you.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于文件（主要是XML）的配置适用于需要部署到多个环境的应用程序。另一方面，存在一些特定场景，在这些场景中，基于代码的配置被优先选择。识别这两种配置之间的差异将有助于你选择哪一种更适合你。
- en: File-based (XML) versus code-based configuration
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件（XML）与基于代码的配置
- en: The benefit of XML-based configuration is that you can alter dependencies without
    recompiling, building, and deploying the application code. This sounds useful
    in a situation where you need to swap the dependencies of the same type. But again,
    is this really what you are looking for? In other words, if you do not have the
    requirements for changing the implementation of dependencies on the fly at runtime,
    then file-based configuration is not that useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的配置的好处是，你可以在不重新编译、构建和部署应用程序代码的情况下更改依赖项。这在需要交换相同类型依赖项的情况下听起来很有用。但再次强调，这真的是你想要的吗？换句话说，如果你没有在运行时动态更改依赖项实现的要求，那么基于文件的配置并不那么有用。
- en: On the downside, file-based configuration is generally more difficult to read
    and analyze, especially when it becomes large and clumsy. XML-based configuration
    does not warn you about any errors at compile time. Such errors can only be picked
    up at runtime, and they are quite tricky and time-consuming to fix. On the other
    hand, code-based configuration supports compile-time error checking. This means
    that if the build is successful, you are done and will not get any surprises at
    runtime.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于文件的配置通常更难以阅读和分析，尤其是在它变得庞大而笨拙时。基于XML的配置在编译时不会警告你任何错误。这些错误只能在运行时被发现，而且修复它们相当棘手且耗时。另一方面，基于代码的配置支持编译时错误检查。这意味着如果构建成功，你就完成了，并且在运行时不会遇到任何惊喜。
- en: Injection using the setter method versus the constructor
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setter方法与构造函数进行注入
- en: There are two straightforward options of DI – setter- or constructor-based DI.
    Both of these methods perform the same operation—injecting dependencies—but at
    different times of the object's lifespan. One happens during object instantiation,
    while the other happens on calling the setter method explicitly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入有两种简单的方法——基于setter或基于构造函数的依赖注入。这两种方法执行相同的操作——注入依赖项，但在对象生命周期的不同时间。一个发生在对象实例化期间，而另一个发生在显式调用setter方法时。
- en: 'A very obvious dilemma comes into the picture when you implement DI with these
    two options. Understanding the difference is important because it reflects the
    basic problem of the object-oriented programming context: do we initiate the field
    variable with the constructor argument or through the setter method?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这两种选项实现依赖注入时，一个非常明显的困境就会出现。理解这些差异很重要，因为它反映了面向对象编程环境中的基本问题：我们是使用构造函数参数初始化字段变量，还是通过setter方法来初始化？
- en: Constructor-based DI
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: Passing dependencies with a constructor is more clear in terms of describing
    what is required to create an object. You may write multiple versions of constructors,
    each taking a different combination of dependency objects, if that is allowed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数传递依赖项在描述创建对象所需内容方面更为清晰。如果允许，你可以编写多个版本的构造函数，每个构造函数接受不同组合的依赖项对象。
- en: Alongside initializing fields with the constructor, you can hide them by not
    providing a setter method. The advantage of this arrangement is that you can make
    sure the dependencies being set through the constructor will be available for
    the lifespan of an object. This is important, because if you do not want a particular
    dependency to be changed with the birth of an object, then initializing it with
    the constructor and not providing a setter will make it immutable. A constructor-based
    DI will decide the DI order while loading the context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用构造函数初始化字段外，你还可以通过不提供setter方法来隐藏它们。这种安排的优势在于，你可以确保通过构造函数设置的依赖项将可用于对象的生命周期。这很重要，因为如果你不希望某个依赖项在对象出生时被更改，那么使用构造函数初始化而不提供setter将使其不可变。基于构造函数的依赖注入将在加载上下文时决定依赖注入的顺序。
- en: Passing the dependencies through the constructor will manage the order of the
    object creation graph and will eventually reduce the risk of circular dependency.
    Conversely, for constructor-based DI, Spring does not allow you to create a proxy
    with the **Code Generation Library** (**CGLIB**). You need to use either an interface-based
    proxy or a no-argument constructor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造函数传递依赖项将管理对象创建图的顺序，并最终降低循环依赖的风险。相反，对于基于构造函数的依赖注入，Spring不允许你使用**代码生成库**（**CGLIB**）创建代理。你需要使用基于接口的代理或无参数构造函数。
- en: You should choose the approach of passing dependencies into a constructor as
    your default preference. Ideally, all active/mandatory dependencies must be passed
    through a constructor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将传递依赖到构造函数的方法作为你的首选方法。理想情况下，所有活动/强制依赖项都必须通过构造函数传递。
- en: Setter-based DI
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: The basic idea behind setter-based DI is that once the object is created (mainly
    with no argument constructors), a setter can be called to supply the dependencies
    to form an object graph, or just to supply the mock object for testing purposes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入的基本思想是，一旦对象被创建（主要是使用无参数构造函数），就可以调用setter方法来提供依赖项以形成一个对象图，或者只是为了测试目的提供模拟对象。
- en: Constructor-based DI is appropriate if there are only a couple of constructor
    parameters. If there are lots of constructor parameters, it will look messy. Even
    multiple versions of a constructor will not help much. In this case, you should
    rely on setter-based DI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有几个构造函数参数，基于构造函数的依赖注入是合适的。如果有大量的构造函数参数，看起来会很混乱。即使有多个构造函数版本，帮助也不大。在这种情况下，你应该依赖于基于setter的依赖注入。
- en: Ideally, all optional or conditional dependencies should be supplied through
    setter-based DI. The drawback to this approach is that you should make sure the
    setter methods are called before a client object starts using it. Another risk
    in using the setter method is that the dependency being altered at a later part
    of execution will result in an unexpected or ambiguous result, which is sometimes
    hard to trace. Also, if configuration is not done properly with the setter approach,
    you may end up with a circular dependency, which you could face at runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有可选或条件依赖都应该通过基于setter的依赖注入来提供。这种方法的缺点是，你必须确保在客户端对象开始使用之前调用setter方法。使用setter方法的另一个风险是，在执行后期修改的依赖项可能会导致意外的或模糊的结果，这有时很难追踪。此外，如果使用setter方法配置不当，你可能会遇到循环依赖，这在运行时可能会遇到。
- en: Circular dependency
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: A circular or cyclic dependency is a situation where two or more independent
    modules or components rely on each other to function properly. This is referred
    to as mutual recursion. Circular dependency generally occurs in a modular framework
    while defining a dependency between modules or components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 循环或循环依赖是一种情况，其中两个或多个独立模块或组件依赖于彼此以正常工作。这被称为相互递归。循环依赖通常在定义模块或组件之间的依赖关系时在模块化框架中发生。
- en: The term circular dependency is very common across domain models where a set
    of objects are associated with each other. Circular dependencies between classes are not
    necessarily harmful. In fact, in particular situations, they are appropriate.
    Take an example of an application where you are dealing with domain objects such
    as a student and a course. You probably need a `Student` class that gets courses
    a student has enrolled in, and a `Course` class that gets a list of students enrolled
    on that course. It is clear that the `Student` and the `Course` classes are interdependent,
    but if circular dependency is required in this case, then taking a chance to remove
    it may introduce some other problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “循环依赖”这个术语在领域模型中非常常见，其中一组对象相互关联。类之间的循环依赖不一定有害。事实上，在特定情况下，它们是合适的。以一个处理领域对象，如学生和课程的示例，你可能需要一个`Student`类来获取学生已报名的课程，以及一个`Course`类来获取在该课程上报名的学生列表。很明显，`Student`和`Course`类是相互依赖的，但如果在这种情况下需要循环依赖，那么尝试移除它可能会引入其他问题。
- en: In a software design context, circular dependency between software components
    or modules produces a negative effect and is hence considered a bad practice.
    This is probably a design issue. Generally, a software design with a poorly managed
    dependency is harder to maintain than one with a clear and layered module structure.
    While designing the system in a modular fashion, you need to keep in mind the
    problems that occur, especially due to circular dependency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计环境中，软件组件或模块之间的循环依赖会产生负面影响，因此被视为不良实践。这可能是设计问题。一般来说，管理不善的依赖关系的软件设计比具有清晰分层模块结构的软件设计更难维护。在设计系统时，以模块化方式设计，你需要记住可能会出现的问题，特别是由于循环依赖引起的问题。
- en: Problems of circular dependency
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖问题
- en: 'Circular dependency can create many redundant effects in software programs.
    The very first among them in terms of design is the tight coupling between mutually
    dependent modules, which results in reusing an individual module becoming more
    difficult or impossible. In general, there are several reasons why you should
    avoid circular references between objects. It creates the following problems:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖可以在软件程序中创建许多冗余效果。在设计方面，首先是相互依赖的模块之间的紧密耦合，这使得重用单个模块变得更加困难或不可能。一般来说，有几个原因你应该避免对象之间的循环引用。它会导致以下问题：
- en: '**No dependency hierarchy and no reusability:** Generally, we quantify the
    code with the layer it is at; for example, high level, low level, and so on. Every
    layer should only set a dependency (if any) on the layers below it. Normally,
    when you define dependency between modules, a dependency graph or hierarchy will
    be created, but in the case of a circular dependency situation, this will be eradicated.
    This means that there is no dependency hierarchy. For example, say you have the
    following dependency hierarchy:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有依赖层次和可重用性：** 通常，我们用代码所在的层来量化代码；例如，高级、低级等。每一层只应设置对下面层的依赖（如果有的话）。通常，当你定义模块之间的依赖关系时，会创建一个依赖图或层次结构，但在循环依赖的情况下，这会被消除。这意味着没有依赖层次。例如，假设你有以下依赖层次：'
- en: Module A depends on module B
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A依赖于模块B
- en: Module B depends on module C
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块B依赖于模块C
- en: Assume that, at present, module C has no dependencies
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设目前模块C没有依赖
- en: Based on this arrangement, we can identify module A as the top level, module
    B as somewhere in the middle level, and module C as the lower level of the hierarchy.
    Let's say that, after some time, we need to make module C dependent on module
    A (for whatever reason).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这种安排，我们可以将模块A识别为顶层，模块B位于中间级别，模块C位于层次结构的底层。假设在一段时间后，我们需要让模块C依赖于模块A（无论出于什么原因）。
- en: When this happens, there is no more differentiation between the high, middle,
    and low levels, which means that there is no longer a hierarchy. All modules are
    at the same level. Also, since they are in a circular dependency, they are no
    longer independent. This situation forms a single giant virtual module, which
    is divided into interdependent pieces. You cannot use any of them independently.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，高低级别之间不再有区分，这意味着不再存在层次结构。所有模块处于同一级别。此外，由于它们存在循环依赖，它们也不再是独立的。这种情况形成了一个单一的巨大虚拟模块，它被划分为相互依赖的部分。您无法独立使用其中任何一个。
- en: '**Changing replication:** Circular dependency creates a ripple effect of changes.
    For example, if any change happens in one module, this may impact other modules,
    which results in undesirable effects on the overall software architecture, such
    as compilation errors, and logical program errors. Due to its nature, circular
    dependency may create other unpredictable issues, such as endless recursion.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改复制：**循环依赖会引发一系列的变化。例如，如果某个模块发生任何变化，这可能会影响其他模块，从而对整体软件架构产生不良影响，例如编译错误和逻辑程序错误。由于其本质，循环依赖可能会产生其他不可预测的问题，例如无限递归。'
- en: '**Readability and maintainability:** Code that has a circular reference is
    naturally harder to understand and read than code that doesn''t have a circular
    reference. Such code is intrinsically delicate and easy to breach. Ensuring that
    your code is free from circular dependencies will make the code easy to work with
    and make the code be able to accommodate changes with ease, resulting in easy
    maintenance. From a unit testing point of view, code that has a circular dependency
    is more difficult to test since it can''t be isolated.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性和可维护性：**具有循环引用的代码自然比没有循环引用的代码更难以理解和阅读。这种代码本质上是脆弱的，容易出错。确保您的代码没有循环依赖将使代码易于操作，并使代码能够轻松适应变化，从而实现易于维护。从单元测试的角度来看，具有循环依赖的代码更难以测试，因为它无法被隔离。'
- en: Causes and solutions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原因和解决方案
- en: As we have already seen, circular dependency mostly occurs as a result of bad
    design/coding practice. In large software application development, the coders
    may deviate from the context and produce a circular reference.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，循环依赖通常是由于不良的设计/编码实践造成的。在大型的软件应用开发中，程序员可能会偏离上下文并产生循环引用。
- en: To overcome this, you can take the help of various tools to find unwanted circular
    dependencies. This should be an ongoing activity and be applied from the beginning
    of the development cycle. For example, Eclipse has a plugin called Java Dependency
    Viewer, which will help to see the dependency between classes and Java packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，您可以借助各种工具来查找不想要的循环依赖。这应该是一个持续的活动，并从开发周期的开始就应用。例如，Eclipse有一个名为Java Dependency
    Viewer的插件，可以帮助查看类和Java包之间的依赖关系。
- en: Issues of circular dependency can be addressed by following certain patterns
    and principles, which are discussed in the following sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循某些模式和原则可以解决循环依赖问题，这些模式和原则将在以下章节中讨论。
- en: The single responsibility principle
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'Let''s understand how circular dependency can be eliminated by applying the
    single responsibility principle. Let''s assume you are following three modules
    in a system:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何通过应用单一职责原则来消除循环依赖。假设您正在跟踪系统中的三个模块：
- en: Salary module
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 薪酬模块
- en: Employee module
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工模块
- en: HR module
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人力资源模块
- en: 'The **Salary module** generates salary and sends it over email. Generating
    salary depends upon the **Employee module**. To get a few details, such as the
    appraisal process, and reward points the **Employee module** depends upon the
    HR module. At this moment, the dependency hierarchy will be as shown in the following
    diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**薪酬模块**生成薪酬并通过电子邮件发送。生成薪酬依赖于**员工模块**。为了获取一些细节，例如评估过程和奖励积分，**员工模块**依赖于人力资源模块。此时，依赖层次结构将如图所示：'
- en: '![](img/00059.gif)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00059.gif)'
- en: 'At some point in time, let''s say you need email functionality in the **HR
    module**. Since email functionality is present in the **Salary module**, you decide
    to give dependency of the **Salary module** to the **HR module**. At this moment,
    the dependency graph looks like the following diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时间点，比如说您需要在**人力资源模块**中实现电子邮件功能。由于电子邮件功能存在于**薪资模块**中，您决定将**薪资模块**的依赖关系赋予**人力资源模块**。在这个时刻，依赖关系图看起来像以下图表：
- en: '![](img/00060.gif)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00060.gif)'
- en: This situation forms a circular dependency. To avoid this, you need to follow
    the single responsibility principle. This principle states that a module or class
    should hold responsibility of a single part of the functionality. That module
    or class should take total ownership of that functionality and must be encapsulated
    entirely. All services provided by the module must not deviate from the main functionality.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况形成了一个循环依赖。为了避免这种情况，您需要遵循单一职责原则。这个原则指出，一个模块或类应该承担功能单一部分的职责。该模块或类应该完全拥有该功能，并且必须完全封装。模块提供的所有服务不得偏离主要功能。
- en: 'In our case, the Salary module not only generates salary, but sends emails,
    too. This is a violation of the single responsibility principle. When a single
    module performs more than one responsibility, there''s a chance of poor dependency
    management, which may result in either:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，薪资模块不仅生成薪资，还发送电子邮件。这是违反单一职责原则的。当一个模块执行多个职责时，可能会出现不良的依赖管理，这可能导致以下情况：
- en: '**Code duplication:** You may write similar and common functionalities in multiple
    modules. For example, in this case, you may write an email sending functionality
    in the HR module to avoid circular dependency, but will end up with code duplication,
    which raises maintenance problems later on.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复：**您可能在多个模块中编写相似和通用的功能。例如，在这种情况下，您可以在人力资源模块中编写电子邮件发送功能以避免循环依赖，但最终会导致代码重复，这会在以后引发维护问题。'
- en: '**Circular dependency:** As we have seen in the preceding case.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环依赖：**正如我们在前面的案例中看到的。'
- en: 'You need to write a separate module called the Utility module and put the email
    sending functionality in that. After you have refactored this code, both the **HR
    module** and the **Salary module** are now dependent on the Utility module. This
    is how circular dependency can be removed: by following the single responsibility
    principle.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要编写一个名为“工具模块”的独立模块，并将电子邮件发送功能放在其中。在重构此代码后，**人力资源模块**和**薪资模块**现在都依赖于工具模块。这就是如何通过遵循单一职责原则来消除循环依赖。
- en: Deferring the setting of a dependency from constructor to setter
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将依赖的设置从构造函数推迟到设置器
- en: 'Let''s understand how solves circular dependency by providing a dependency
    from the constructor to the setter method. There is a special case where due to
    circular dependency, you can''t even create the object of the domain model. For
    example, say you are developing an application for a `tyre` manufacturer; who
    uses these tyres for cars. Based on the car''s max speed, you need to set the
    min rim size of the `tyre`. For this, you have created the `Car` and `Tyre` classes,
    as in the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提供从构造函数到设置器的依赖关系来了解如何解决循环依赖。存在一个特殊情况，由于循环依赖，甚至无法创建领域模型的对象。例如，假设您正在开发一个为`tyre`制造商的应用程序；这些轮胎用于汽车。根据汽车的最大速度，您需要设置轮胎的最小轮辋尺寸。为此，您创建了`Car`和`Tyre`类，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, the `Car` and `Tyre` classes are dependent on each another.
    The dependency is passed through the constructor, hence why it is a circular dependency.
    You can''t create an object for either of them. To handle this situation, you
    need to defer setting the dependency from the constructor to the setter in each
    case. We decided to make this change in the `Car` class, as in the following snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Car`和`Tyre`类相互依赖。依赖关系通过构造函数传递，这就是为什么它是循环依赖的原因。您无法为它们中的任何一个创建对象。为了处理这种情况，您需要在每种情况下将设置依赖关系从构造函数推迟到设置器。我们决定在`Car`类中进行此更改，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The dependency (of `Tyre`) is moved from the constructor to the setter method.
    In the `Tyre` class, you need to set a reference of the current class (`Tyre`)
    into the `Car` object, as in the following snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Tyre`的依赖关系从构造函数移动到设置器方法。在`Tyre`类中，您需要将当前类的引用（`Tyre`）设置到`Car`对象中，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Everything is settled now. You can create an object of type `Car` first, then
    create an object of type `Tyre` so that you can pass the reference of the `car`
    object to it. The client code will be as in the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已解决。您可以首先创建`Car`类型的对象，然后创建`Tyre`类型的对象，以便您可以传递`car`对象的引用给它。客户端代码如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Relocation of classes and packages
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和包的迁移
- en: One of the possible reasons for circular dependency is a chain of dependencies
    starting from some classes in a Java package. Let's say that `com.packt.util` traverses
    with a different package and reaches some other class in the same package, `com.packt.util`.
    This is a package arrangement issue that can be solved by moving the classes and
    restructuring the packages. You can perform such refactoring activities with modern
    IDEs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖的一个可能原因是Java包中某些类的一个依赖链。比如说，`com.packt.util`与不同的包交叉，到达同一包中的其他类，`com.packt.util`。这是一个可以通过移动类和重新组织包来解决的问题。您可以使用现代IDE执行此类重构活动。
- en: Circular dependency in the Spring framework
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中的循环依赖
- en: 'Let''s explore how circular dependency occurs in the Spring framework and how
    to deal with it. Spring provides an IoC container that loads all the beans and
    tries to create objects in a specific order so that they work properly. For example,
    say we have three beans with the following dependency hierarchy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨在Spring框架中循环依赖是如何发生的以及如何处理它。Spring提供了一个IoC容器，该容器加载所有豆类并尝试按特定顺序创建对象，以确保它们正常工作。例如，假设我们有三个豆类，以下是他们依赖关系的层次结构：
- en: '`Employee` bean'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Employee`豆类'
- en: '`HRService` bean'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HRService`豆类'
- en: '`CommonUtilService` bean'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonUtilService`豆类'
- en: The `Employee` bean depends on the `HRService` bean, which depends on the `CommonUtilService`
    bean.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`豆类依赖于`HRService`豆类，而`HRService`豆类又依赖于`CommonUtilService`豆类。'
- en: In this case, `CommonUtilService` is considered a low-level bean, while the
    Employee bean is considered a high-level bean. Spring will first create an object
    for all low-level beans so that it creates the `CommonUtilService` bean, then
    it will create the `HRService` bean (and inject the object of the `CommonUtilService` bean
    into it), and then it will create an object of the `Employee` bean (and inject
    the object of the `HRService` bean into it).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CommonUtilService`被视为低级豆类，而`Employee`豆类被视为高级豆类。Spring将首先为所有低级豆类创建对象，以便创建`CommonUtilService`豆类，然后它将创建`HRService`豆类（并将`CommonUtilService`豆类的对象注入其中），然后它将创建`Employee`豆类的对象（并将`HRService`豆类的对象注入其中）。
- en: Now, you need to make the `CommonUtilService`bean dependent on the `Employee`.This
    is circular dependency. Furthermore, all dependencies are set through a constructor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要使`CommonUtilService`豆类依赖于`Employee`。这是一个循环依赖。此外，所有依赖关系都是通过构造函数设置的。
- en: In the case of circular dependency, the difference between high and low-level
    modules disappears. This means that Spring will be in a dilemma of which bean
    should be instantiated first, since they depend on each other. As a result, Spring
    will raise a `BeanCurrentlyInCreationException` error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环依赖的情况下，高级和低级模块之间的区别消失了。这意味着Spring将陷入困境，不知道应该先实例化哪个豆类，因为它们相互依赖。结果，Spring将引发`BeanCurrentlyInCreationException`错误。
- en: This will only happen in the case of constructor injection. If dependencies
    are set through the setter method, this problem will not occur, even if beans
    are interdependent. This is because at the time of context loading, no dependencies
    are present.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在构造函数注入的情况下发生。如果依赖关系是通过setter方法设置的，即使豆类相互依赖，这个问题也不会发生。这是因为上下文加载时，没有依赖关系存在。
- en: 'Let''s create the code for this and see how Spring detects circular dependency.
    The code will be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个创建代码并看看Spring是如何检测循环依赖的。代码如下：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Java config and client code will be as in the following snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Java配置和客户端代码如下所示：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On running this code, you will get a `BeanCurrentlyInCreationException` error
    for all the beans, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，所有豆类都会出现`BeanCurrentlyInCreationException`错误，如下所示：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To avoid this situation, you need to redesign the preceding structure. In a
    few circumstances, it's not possible to change the structure, maybe due to design
    limitations of the legacy code. In this case, Spring provides some solutions,
    as follows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您需要重新设计前面的结构。在少数情况下，可能由于遗留代码的设计限制，无法更改结构。在这种情况下，Spring提供了一些解决方案，如下所述。
- en: Using setter/field injection over constructor injection
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相比构造函数注入，使用setter/field注入
- en: 'This is probably the most easy and straightforward option. In circular dependency,
    if constructor injection creates a circular reference, you can defer the DI in
    the setter method. This allows Spring to load a bean context without any issues.
    The updated code would be as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单、最直接的选择。在循环依赖中，如果构造函数注入创建了循环引用，你可以在 setter 方法中延迟 DI。这允许 Spring 无问题地加载
    bean 上下文。更新的代码如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All dependencies are set in the setter method with the `@Autowired` annotation.
    Spring will create instances of all three beans first and will then set them with
    the setter method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖都通过带有 `@Autowired` 注解的 setter 方法设置。Spring 首先创建所有三个实例，然后使用 setter 方法设置它们。
- en: Setting the `@Autowired` annotation on fields of the bean is equivalent to setter
    injection. If you annotate the fields of the class with the `@Autowired` annotation,
    Spring will not complain about circular dependency.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bean 的字段上设置 `@Autowired` 注解与 setter 注入等效。如果你在类的字段上使用 `@Autowired` 注解，Spring
    不会对循环依赖发出抱怨。
- en: Using the @Lazy annotation
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `@Lazy` 注解
- en: 'Another workaround is to use the `@Lazy` annotation. This annotation will instruct
    Spring to load the bean only when it is used, instead of at the time of context
    loading. Spring will create a proxy of the bean during context loading and will
    pass it into another object. The updated code will look as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `@Lazy` 注解。这个注解将指示 Spring 仅在需要时加载 bean，而不是在上下文加载时。Spring 将在上下文加载期间创建一个代理
    bean 并将其传递给另一个对象。更新的代码如下所示：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The constructor dependencies are set through the `@Lazy` annotation. This code
    will run without any issue. The actual dependency is injected only when it''s
    being called. To demonstrate this, the  `displayEmployeeName` method is created
    in the `Employee` bean, which we will call with the dependency reference from
    the `CommonUtilService` bean, as in the following snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数依赖通过 `@Lazy` 注解设置。这段代码将正常运行，实际依赖仅在调用时注入。为了演示这一点，我们在 `Employee` 实例中创建了一个
    `displayEmployeeName` 方法，我们将使用来自 `CommonUtilService` 实例的依赖引用来调用它，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the `showEmployeeNameFromDependency` method is called, it will internally
    call the `displayEmployeeName` method on the employee reference in `CommonUtilService`.
    When this happens, Spring will actually inject the dependency. You will get the
    following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `showEmployeeNameFromDependency` 方法时，它将内部调用 `CommonUtilService` 中员工引用的 `displayEmployeeName`
    方法。当发生这种情况时，Spring 实际上会注入依赖。你将得到以下输出：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Best practices and anti-patterns
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和反模式
- en: So far, we have talked about using IoC containers to achieve DI, but one of
    the most common mistakes is to use IoC containers without doing real DI. This
    may sound strange, but it is a fact. Such mistakes are possible in the absence
    of having a proper understanding of underlying concepts.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了使用 IoC 容器来实现 DI，但最常见的错误之一是在没有进行真正的 DI 的情况下使用 IoC 容器。这听起来可能有些奇怪，但这是一个事实。在没有正确理解底层概念的情况下，这样的错误是可能发生的。
- en: Ideally, DI implementation should only reference the IoC container during the
    time of the application's startup. If a developer wraps the IoC container itself
    and passes it into other component to reduce any dependency, this is not a good
    design. Let's understand this issue with an example.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，DI 实现应该仅在应用程序启动时引用 IoC 容器。如果开发者自己包装 IoC 容器并将其传递给其他组件以减少任何依赖，这并不是一个好的设计。让我们用一个例子来理解这个问题。
- en: What to inject – the container itself or just dependencies?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要注入什么 - 容器本身还是只是依赖？
- en: 'The situation of injecting container occurs when you try to wrap the container
    itself either in a singleton class or a public static method to provide the dependency
    to other components or modules, as in the following snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将容器本身包装在单例类或公共静态方法中，以向其他组件或模块提供依赖时，就会发生注入容器的情况，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is equivalent to the service locator pattern. In this code, the `ServiceManager` class
    holds the reference of the container. It will return the dependency (services)
    through its static method. The  `EmployeeService ` class uses the `ServiceManager` to
    get its dependencies (`HRService` and `AccountService`). At first glance, this
    looks perfectly fine as we don't want the `EmployeeService` to be tightly coupled
    with `HRService` and `AccountService`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这与服务定位器模式等价。在这段代码中，`ServiceManager` 类持有容器的引用。它将通过其静态方法返回依赖（服务）。`EmployeeService`
    类使用 `ServiceManager` 获取其依赖（`HRService` 和 `AccountService`）。乍一看，这似乎非常合适，因为我们不希望
    `EmployeeService` 与 `HRService` 和 `AccountService` 紧密耦合。
- en: Though we removed the coupling of dependencies in the preceding code, this is
    not what we mean by DI.  The fundamental mistake in the preceding case is that
    instead of providing the dependency, we are relying on other classes to supply
    it. In reality, we are removing the dependency of one entity, but adding another.
    This is one of the classic examples of using an IoC container very badly and without
    implementing DI properly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的代码中移除了依赖的耦合，但这并不是我们所说的 DI。前一个案例中的基本错误是，我们没有提供依赖，而是依赖其他类来提供它。实际上，我们移除了一个实体的依赖，但添加了另一个。这是使用
    IoC 容器非常糟糕且没有正确实现 DI 的一个经典例子。
- en: The `ServiceManager` class is a singleton class that supplies the dependencies
    with its static method. Instead of injecting `HRService` and `AccountService` into `EmployeeService`,
    we are relying on `SerivceManager` to provide the dependency.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceManager` 类是一个单例类，通过其静态方法提供依赖。我们不是将 `HRService` 和 `AccountService` 注入到
    `EmployeeService` 中，而是依赖 `ServiceManager` 提供依赖。'
- en: You might argue that the preceding approach will replace multiple dependencies
    with a single class, and will effectively reduce the dependency. However, the
    benefits of DI are not 100% achieved. The design issue of being tightly dependent
    on `ServiceManager`  is unseen until any change happens in that class. For example,
    if you change the configuration of either the `HRManager` or `AccoutService` class,
    you need to change the code of `ServiceManager`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，前面的方法将多个依赖项替换为单个类，并将有效地减少依赖。然而，DI 的好处并没有完全实现。当该类发生变化时，对 `ServiceManager`
    的紧密依赖问题才会显现出来。例如，如果你更改 `HRManager` 或 `AccoutService` 类的配置，你需要更改 `ServiceManager`
    的代码。
- en: Another side effect of this scenario is that things are not clear from a unit
    testing point of view. The benefit of DI is that just by looking at the constructor
    of the class, you should know what things are dependent on it so that you can
    inject the mock object very easily while doing unit testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个副作用是，从单元测试的角度来看，事情并不清晰。DI 的好处是，只需查看类的构造函数，就应该知道它依赖于什么，这样你就可以在单元测试时非常容易地注入模拟对象。
- en: The scenario in this case is the opposite. Ideally, the caller should supply
    the dependency, but in our case, the caller doesn't provide anything, while the
    component (`EmployeeService`) is getting the dependencies by using its own singleton
    class. The constructor of the `EmployeeService` class will be empty and you probably
    won't determine its dependency until you refer to its source code thoroughly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，情况正好相反。理想情况下，调用者应该提供依赖，但在这个案例中，调用者没有提供任何东西，而组件（`EmployeeService`）通过使用自己的单例类来获取依赖。`EmployeeService`
    类的构造函数将是空的，你可能只有在彻底查看其源代码后才能确定其依赖。
- en: 'The preceding design is more of a service locator implementation. However,
    there are a few other limitations of the service locator, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的设计更像是服务定位器的实现。然而，服务定位器还有一些其他的局限性，如下所示：
- en: '**Isolation: ** The services added into the registry are ultimately black boxes
    to the caller or client class. This results in a less reliable system as it would
    be difficult to identify and rectify the errors that occur in the dependency services.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性：** 注册到注册表中的服务对于调用者或客户端类来说最终是黑盒。这导致系统可靠性降低，因为很难识别和纠正依赖服务中发生的错误。'
- en: '**Concurrency: ** The service locator has a unique registry of services, which
    may cause a performance bottleneck if it is accessed by concurrent components.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性：** 服务定位器有一个独特的服务注册表，如果它被并发组件访问，可能会导致性能瓶颈。'
- en: '**Dependency resolution:** For the client code, the registry provided by the
    service locator is kind of a black box, and this may cause issues at runtime,
    for example, if dependencies are not yet registered, or there are any dependency-specific
    issues.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖解析：** 对于客户端代码，服务定位器提供的注册表有点像黑盒，这可能在运行时引起问题，例如，如果依赖项尚未注册，或者存在任何特定的依赖项问题。'
- en: '**Maintainability:** In the service locator, since the code of the service
    implementation is isolated from clients, it is unclear when the new changes will
    break this functionality at runtime.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性：** 在服务定位器中，由于服务实现的代码与客户端代码是隔离的，因此不清楚何时新的更改会在运行时破坏此功能。'
- en: '**Testability:** The service locator stores all of the services in the registry,
    which makes unit testing a bit harder since all of the tests may rely on the registry
    to set various mock service classes explicitly.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性：** 服务定位器将所有服务存储在注册表中，这使得单元测试变得稍微困难一些，因为所有测试可能都需要依赖注册表来显式设置各种模拟服务类。'
- en: Our goal is to make the client code 100% decoupled from its dependencies or
    any class who supplies the dependencies. In the preceding case, we want to break
    the coupling between `EmployeeService` and its dependencies.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使客户端代码与其依赖项或提供依赖项的任何类完全解耦。在前面的例子中，我们希望打破 `EmployeeService` 与其依赖项之间的耦合。
- en: 'Let''s improve the preceding design and rewrite the `EmployeeSerice` class,
    as in the following snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进前面的设计，并重写 `EmployeeService` 类，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the `EmployeeService` class does not depend on the `HRService` and `AccountService` classes.
    This is what we wanted to achieve. Your business code should not know anything
    about its dependencies. It is the IoC container's job to provide them. This code
    is now more readable and easy to understand. The dependencies can be predicated
    just by looking at the constructor.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`EmployeeService` 类不再依赖于 `HRService` 和 `AccountService` 类。这正是我们想要达到的目标。你的业务代码不应该了解其依赖项。这是IoC容器的职责来提供它们。现在这段代码更易于阅读和理解。依赖关系可以通过查看构造函数来预测。
- en: If you wish to instantiate `EmployeeService`, you just need to pass the object
    of the `HRService` and `AccountService` classes. While doing unit testing, you
    can just pass the mock objects and test the integration between these services.
    The process becomes very simple now. This is the correct implementation and meaning
    of DI.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望实例化 `EmployeeService`，你只需要传递 `HRService` 和 `AccountService` 类的对象。在进行单元测试时，你可以传递模拟对象并测试这些服务之间的集成。现在这个过程变得非常简单。这是DI的正确实现和含义。
- en: Excessive injection
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度注入
- en: Every design pattern solves specific design problems, but any single pattern
    is not necessarily appropriate for every case that you come across. A pattern
    or methodology you are applying should be chosen because it is the right choice
    for the given problem, not just because you know it and wish to implement it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设计模式都解决特定设计问题，但任何单一模式并不一定适用于你遇到的每一个情况。你应用的模式或方法应该是因为它是给定问题的正确选择，而不仅仅是因为你了解它并希望实现它。
- en: Dependency injection is a pattern (and not a framework), so you need to consider
    the right scenario to implement it. There are chances that may make DI become
    redundant. It is not necessary to inject everything in your code. If you do so,
    the purpose of making the code decoupled is not achieved properly; instead, the
    dependency graph becomes ineffectual.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种模式（而不是一个框架），因此你需要考虑合适的场景来实现它。有可能使DI变得冗余。在代码中注入一切并不是必要的。如果你这样做，代码解耦的目的就无法得到正确实现；相反，依赖图变得无效。
- en: Evidently, DI produces great flexibility in terms of code maintenance, executing
    unit testing in a more meaningful and useful way to achieve modularity. However,
    you should utilize its flexibility only when you really need to. The intention
    of DI is to diminish coupling instead of wrapping and supplying every single dependency,
    which is not a wise decision.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，DI在代码维护方面提供了很大的灵活性，以更有意义和有用的方式执行单元测试，从而实现模块化。然而，你应该只在真正需要时利用其灵活性。DI的目的是减少耦合，而不是包装和提供每个依赖项，这不是一个明智的决定。
- en: For example, let's say that you need a `Calendar` object to perform various
    calendar-related operations. The traditional way is by using a static method -
    `getInstance` of the `Calendar` class, for example, `Calendar.getInstance()` .
    It is a kind of static factory within the `Calendar` class, which creates the
    object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要一个`Calendar`对象来执行各种日历相关操作。传统的方法是使用静态方法——例如`Calendar`类的`getInstance`方法，例如`Calendar.getInstance()`。这是`Calendar`类中的一个静态工厂，用于创建对象。
- en: If you try to pass the `Calendar` object with DI, you will not achieve anything
    new. All of the methods in which the `Calendar` object is passed through (an entire
    call chain – from where it is injected to where it is used) will have additional
    arguments. This ultimately adds the burden of passing the `Calendar` object to
    the programmer. Also, the `Calendar` object is not injected with an abstraction,
    so the argument is of the `Calendar` type rather than any abstract or interface. This
    means that there is no clear benefit of changing the implementation because we
    are passing the dependency with the concrete type rather than the abstract type
    (because that is not possible for the `Calendar` class in Java).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过DI传递`Calendar`对象，你将不会得到任何新东西。所有传递`Calendar`对象的方法（整个调用链——从注入位置到使用位置）都将有额外的参数。这最终给程序员带来了传递`Calendar`对象的负担。此外，`Calendar`对象没有通过抽象注入，因此参数是`Calendar`类型，而不是任何抽象或接口类型。这意味着改变实现没有明显的优势，因为我们传递的是具体类型而不是抽象类型（因为在Java中的`Calendar`类中这是不可能的）。
- en: Ideally, any Java, third library, or custom class that simply provides static
    functionality that can be common across all components or modules should be used
    either statically (class reference) or in a single instance mechanism (if an instance
    is required) instead of injecting them into classes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，任何Java、第三方库或仅提供静态功能且可以在所有组件或模块中通用的自定义类，都应使用静态方式（类引用）或单例机制（如果需要实例）来使用，而不是将它们注入到类中。
- en: Another example is using `Logger` in Java. A typical way of getting a logger
    instance is to call the `getLogger` static method of the `Logger` class and pass
    the class which you want to provide the logging feature of. In this case, passing
    the `Logger` object with DI would be overkill.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在Java中使用`Logger`。获取logger实例的典型方式是调用`Logger`类的`getLogger`静态方法，并传递你想要提供日志功能的类。在这种情况下，通过DI传递`Logger`对象将是过度设计。
- en: Not only that, but injecting such a library with DI would result in reducing
    the availability of functionalities available only to those components that take
    the dependencies either through a constructor, the method, or property injection.
    Also, there is almost no chance of providing any meaningful abstraction that can
    be easily applied to any such libraries. This will keep you from getting any meaningful
    flexibility over the implementation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，使用DI注入此类库将导致仅通过构造函数、方法或属性注入依赖项的组件可用的功能减少。此外，几乎不可能提供任何有意义的抽象，这些抽象可以轻松应用于任何此类库。这将使你在实现上无法获得任何有意义的灵活性。
- en: Choose DI patterns when you need to supply dependencies with different configurations
    of dependencies or when you want to back different implementations of the same
    dependency. If it is not required to mix up your dependencies or to supply different
    implementations, then DI is not an appropriate solution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要提供具有不同依赖配置的依赖项，或者当你想支持同一依赖项的不同实现时，请选择DI模式。如果不需要混合依赖项或提供不同的实现，那么DI不是合适的解决方案。
- en: Achieving IoC in the absence of a container
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有容器的情况下实现IoC
- en: Now, we are well aware that DI is meant to provide the dependencies to components
    through either a constructor, the setter method, or properties to make them separate
    from dependency services. The conventional understanding is that this can only
    be possible by using IoC containers. However, this is not true for all cases.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们深知DI（依赖注入）的目的是通过构造函数、setter方法或属性为组件提供依赖，从而使它们与依赖服务分离。传统的理解是，这只能通过使用IoC（控制反转）容器来实现。然而，并非所有情况都如此。
- en: Ideally, IoC containers should be used for configuring and resolving a comparatively
    large set of dependencies in complex applications. If you are dealing with a simple
    application that has just a few components and dependencies, it is sensible not
    to use containers. Instead, you can wire dependencies manually.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，IoC容器应该用于配置和解决复杂应用中相对较大的依赖项集合。如果你处理的是一个只有少数组件和依赖项的简单应用，不使用容器是明智的。相反，你可以手动配置依赖项。
- en: Also, in the case of any legacy system where the integration of a container
    is difficult, you can opt for supplying dependencies manually. You can implement
    various patterns, such as the factory method, service locator, strategy, or template
    method patterns, to manage the dependencies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在集成容器困难的传统系统中，你可以选择手动提供依赖项。你可以实现各种模式，例如工厂方法、服务定位器、策略或模板方法模式来管理依赖项。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned a few important points about the best practices and patterns
    for managing dependencies in this chapter. Though it is proven that DI brings
    greater flexibility and modularity in the code by decoupling the client code from
    its dependencies, there are a few things that we should follow to get the best
    out of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些关于管理依赖项的最佳实践和模式的重要观点。尽管已经证明DI通过解耦客户端代码与其依赖项，为代码带来了更大的灵活性和模块化，但还有一些事情我们应该遵循，以充分利用它。
- en: In the beginning, we learned about patterns other than DI that help us to implement
    IoC. You can definitely use them in your code to decouple modules where the use
    of IoC containers is not possible. For example, in a legacy code where managing
    dependencies is not possible through an IoC container, these patterns are useful
    to achieve IoC.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们学习了除了依赖注入（DI）之外的其他模式，这些模式有助于我们实现控制反转（IoC）。你绝对可以在代码中使用它们来解耦无法使用IoC容器的模块。例如，在一个无法通过IoC容器管理依赖项的传统代码中，这些模式对于实现IoC非常有用。
- en: We became familiar with various configuration options and learned how to choose
    the right one. We also saw the injection styles used in wiring the dependencies.
    When working with dependency management, one very obvious problem that occurs
    is circular reference, which causes circular dependency. We have observed what
    problems circular dependencies create, what the cause of them is, and how to avoid
    them in coding.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉了各种配置选项，并学习了如何选择正确的选项。我们还看到了在配置依赖项时使用的注入风格。在处理依赖项管理时，一个非常明显的问题是循环引用，这会导致循环依赖。我们已经观察到了循环依赖引起的问题、其成因以及如何在编码中避免它们。
- en: At the end, we dived into best practices, patterns, and anti-patterns that you
    should follow while using DI. If we know how to do something, it does not mean
    that it is applicable all the time. The same is applicable to DI. It is a pattern,
    and hence it should be used in the right manner to solve specific problems. It
    may not be suitable for all conditions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了在使用DI时应遵循的最佳实践、模式和反模式。如果我们知道如何做某事，并不意味着它总是适用。DI也是如此。它是一个模式，因此应该以正确的方式使用来解决特定问题。它可能并不适用于所有情况。
- en: We are taking a pause here. We hope you enjoyed the journey of learning about
    DI throughout the book. We tried to convey the fundamentals as simply as possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里暂停一下。我们希望你喜欢在整本书中学习DI的旅程。我们试图尽可能简单明了地传达基本原理。
