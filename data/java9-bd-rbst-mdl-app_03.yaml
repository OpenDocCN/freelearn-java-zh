- en: Discovering Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java 9
- en: Java 9 represents a major release and consists of a large number of internal
    changes to the Java platform. Collectively, these internal changes represent a
    tremendous set of new possibilities for Java developers, some stemming from developer
    requests, others from Oracle-inspired enhancements. In this chapter, we will review
    26 of the most important changes. Each change is related to a **JDK Enhancement
    Proposal** (**JEP**). JEPs are indexed and housed at [openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0).
    You can visit this site for additional information on each JEP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9是一个重大版本，包含对Java平台的大量内部更改。这些内部更改共同代表了一组巨大的新可能性，对于Java开发者来说，这些可能性有些来自开发者的请求，有些来自Oracle启发的增强。在本章中，我们将回顾26项最重要的更改。每个更改都与一个**JDK增强提案**（**JEP**）相关。JEPs被索引并托管在[openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0)。你可以访问这个网站获取每个JEP的更多信息。
- en: The JEP program is part of Oracle's support for open source, open innovation,
    and open standards. While other open source Java projects can be found, OpenJDK
    is the only one supported by Oracle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JEP项目是Oracle对开源、开放创新和开放标准支持的一部分。虽然可以找到其他开源Java项目，但OpenJDK是Oracle唯一支持的项目。
- en: 'In this chapter, we will cover changes to the Java platform. These changes
    have several impressive implications, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Java平台的变化。这些变化具有几个令人印象深刻的含义，包括：
- en: Heap space efficiencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆空间效率
- en: Memory allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配
- en: Compilation process improvements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译过程改进
- en: Type testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型测试
- en: Annotations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Automated runtime compiler tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化运行时编译器测试
- en: Improved garbage collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的垃圾收集
- en: Playing around with the Java Shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java Shell中玩耍
- en: For a long time, there has been no standard shell shipped with the Java programming
    language to experiment with new language features or libraries or for rapid prototyping.
    If you wanted to do this, you could write a test application with a main method,
    compile it with `javac`, and run it. This could be done either at the command
    line or using a Java IDE; however, in both cases, this is not as convenient as
    having an interactive shell for the purpose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，Java编程语言没有提供标准的shell来实验新的语言特性或库，或者用于快速原型设计。如果你想要这样做，你可以编写一个带有main方法的测试应用程序，使用`javac`编译它，然后运行。这可以在命令行或使用Java
    IDE完成；然而，在这两种情况下，这都不如拥有一个交互式shell那么方便。
- en: 'Starting an interactive shell in JDK 9 is as simple as running the following
    command (assuming the `bin` directory of your JDK 9 installation is in the current
    path):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK 9中启动交互式shell就像运行以下命令一样简单（假设你的JDK 9安装的`bin`目录在当前路径中）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may find it somewhat puzzling that an interactive shell has not been introduced
    earlier in the Java platform as many programming languages, such as Python, Ruby,
    and a number of others, already come with an interactive shell in their earliest
    versions; However, this had still not made it on the priority features list for
    the earlier Java releases, until now, and it is out there and ready for use. The
    Java shell makes use of a JShell API that provides capabilities to enable autocompletion
    or evaluation of expressions and code snippets, among other features. A full chapter
    is dedicated to discussing the details of the Java shell so that developers can
    make the best use out of it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得有些困惑，为什么交互式shell没有在Java平台早期版本中引入，因为许多编程语言，如Python、Ruby以及其他一些语言，在它们的早期版本中已经包含了交互式shell；然而，这仍然没有成为早期Java版本优先功能列表的一部分，直到现在，它已经出现并准备好使用。Java
    shell利用了JShell API，该API提供了一组功能，包括自动完成或评估表达式和代码片段等。
- en: Taking control of external processes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制外部进程
- en: Up to JDK 9, if you wanted to create a Java process and handle process input/output,
    you had to use either the `Runtime.getRuntime.exec()` method, which allows us
    to execute a command in a separate OS process and get a `java.lang.Process` instance
    over which to provide certain operations in order to manage the external process,
    or use the new `java.lang.ProcessBuilder` class with some more enhancements in
    regard to interacting with the external process and also create a `java.lang.Process`
    instance to represent the external process. Both mechanisms were inflexible and
    also non-portable as the set of commands executed by the external processes were
    highly dependent on the operating system (additional effort had to be exerted
    in order to make the particular process operations portable across multiple operating
    systems). A chapter is dedicated to the new process API, providing developers
    with the knowledge of creating and managing external processes in a much easier
    way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDK 9 之前，如果您想创建一个 Java 进程并处理进程的输入/输出，您必须使用 `Runtime.getRuntime.exec()` 方法，该方法允许我们在单独的操作系统进程中执行一个命令，并获取一个
    `java.lang.Process` 实例，通过它提供某些操作来管理外部进程，或者使用新的 `java.lang.ProcessBuilder` 类，它在与外部进程交互方面提供了一些增强，并创建一个
    `java.lang.Process` 实例来表示外部进程。这两种机制都不灵活，也不可移植，因为外部进程执行的命令集高度依赖于操作系统（需要付出额外的努力才能使特定的进程操作在多个操作系统之间可移植）。有一个章节专门介绍新的进程
    API，为开发者提供创建和管理外部进程的更简单方式的知识。
- en: Boosting performance with G1
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 G1 提升性能
- en: The G1 garbage collector was already introduced in JDK 7 and is now enabled
    by default in JDK 9\. It is targeted for systems with multiple processing cores
    and a lot of available memory. What are the benefits of the G1 compared to previous
    types of garbage collectors? How does it achieve these improvements? Is there
    a need to manually tune it, and in what scenarios? These, and several more questions
    regarding G1, will be discussed in a separate chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: G1 垃圾收集器已经在 JDK 7 中被引入，现在在 JDK 9 中默认启用。它针对的是具有多个处理核心和大量可用内存的系统。与之前的垃圾收集器类型相比，G1
    的优势是什么？它是如何实现这些改进的？是否需要手动调整它，以及在什么场景下？这些问题以及更多关于 G1 的问题将在单独的章节中讨论。
- en: Measuring performance with JMH
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JMH 测量性能
- en: On many occasions, Java applications may suffer from performance degradation.
    Exacerbating the issue is a lack of performance tests that can provide at least
    a minimal set of guarantees that performance requirements are met and, moreover,
    the performance of certain features will not degrade over time. Measuring performance
    of Java applications is not trivial, especially due to the fact that there is
    a number of compiler and runtime optimizations that may affect performance statistics.
    For that reason, additional measures such as warm-up phases and other tricks must
    be used in order to provide more accurate performance measurements. The Java Microbenchmark
    Harness is a framework that incorporates a number of techniques along with a convenient
    API that can be used for this purpose. It is not a new tool, but is included with
    the distribution of Java 9\. If you have not added JMH to your toolbox yet, read
    the detailed chapter on the usage of JMH in the context of Java 9 application
    development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，Java 应用程序可能会遭受性能下降。加剧这个问题的是缺乏性能测试，这些测试至少可以提供一组保证，即满足性能要求，而且某些功能的性能不会随时间退化。测量
    Java 应用程序的性能并不简单，特别是由于存在许多可能影响性能统计信息的编译器和运行时优化。因此，必须使用额外的措施，如预热阶段和其他技巧，以提供更准确的性能测量。Java
    Microbenchmark Harness 是一个框架，它结合了多种技术，并附带一个方便的 API，可用于此目的。它不是一个新工具，但它包含在 Java
    9 的发行版中。如果您还没有将 JMH 添加到您的工具箱中，请阅读关于在 Java 9 应用程序开发中使用 JMH 的详细章节。
- en: Getting started with HTTP 2.0
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 HTTP 2.0
- en: HTTP 2.0 is the successor of the HTTP 1.1 protocol, and this new version of
    the protocol addresses some limitations and drawbacks of the previous one. HTTP
    2.0 improves performance in several ways and provides capabilities such as request/response
    multiplexing in a single TCP connection, sending of responses in a server-push,
    flow control, and request prioritization, among others.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 2.0 是 HTTP 1.1 协议的继任者，这个新版本的协议解决了之前版本的一些局限性和缺点。HTTP 2.0 通过多种方式提高了性能，并提供了诸如在单个
    TCP 连接中进行请求/响应多路复用、服务器推送响应、流量控制和请求优先级等功能。
- en: Java provides the `java.net.HttpURLConnection` utility that can be used to establish
    a non-secure HTTP 1.1 connection. However, the API was considered difficult to
    maintain and further extended with the support for HTTP 2.0 and, so, an entirely
    new client API was introduced in order to establish a connection via the HTTP
    2.0 or the web socket protocols. The new HTTP 2.0 client, along with the capabilities
    it provides, will be covered in a dedicated chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`java.net.HttpURLConnection`实用工具，可用于建立非安全的HTTP 1.1连接。然而，该API被认为难以维护，并且随着对HTTP
    2.0的支持，进行了进一步的扩展。因此，引入了一个全新的客户端API，以便通过HTTP 2.0或WebSocket协议建立连接。新的HTTP 2.0客户端及其提供的功能将在单独的章节中介绍。
- en: Encompassing reactive programming
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖响应式编程
- en: Reactive programming is a paradigm used to describe a certain pattern for propagation
    of changes in a system. Reactiveness is not built in Java itself, but reactive
    data flows can be established using third-party libraries such as RxJava or project
    Reactor (part of the Spring Framework). JDK 9 also addresses the need for an API
    that aids the development of highly-responsive applications built around the idea
    of reactive streams by providing the `java.util.concurrent.Flow` class for the
    purpose. The `Flow` class, along with other related changes introduced in JDK
    9, will be covered in a separate chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种用于描述系统变化传播特定模式的范式。响应性不是Java本身固有的，但可以使用第三方库如RxJava或Reactor项目（Spring框架的一部分）建立响应式数据流。JDK
    9还通过提供`java.util.concurrent.Flow`类来满足开发围绕响应式流概念构建的高响应性应用程序的API需求。`Flow`类以及JDK
    9中引入的其他相关更改将在单独的章节中介绍。
- en: Expanding the wish list
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展愿望清单
- en: 'Apart from all of the new stuff in JDK 9, a whole new set of features is expected
    in future releases of the platform. Among these are the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JDK 9中的所有新特性外，平台未来版本预计还将引入一系列全新的功能。其中一些包括：
- en: '**Generics over primitive types**: This is one of the features planned for
    JDK 10 as part of project Valhalla. Other language enhancements, such as value
    handles, are already part of Java 9 and will be introduced later in this book.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型上的泛型**：这是JDK 10计划中Valhalla项目的一部分特性。其他语言增强，如值处理，已经是Java 9的一部分，将在本书的后续章节中介绍。'
- en: '**Reified generics**: This is another featured part of project Valhalla that
    aims to provide the ability to preserve generic types at runtime. The related
    goals are listed as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具现泛型**：这是Valhalla项目的一个特色部分，旨在提供在运行时保留泛型类型的能力。相关目标如下：'
- en: The foreign functional interface aims to introduce a new API to call and manage
    native functions. The API addresses some of the drawbacks of JNI and especially
    a lack of simplicity for use by application developers. The foreign functional
    interface is developed as part of project Panama in the JDK ecosystem.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部功能接口旨在引入一个新的API来调用和管理本地函数。该API解决了JNI的一些缺点，特别是对于应用开发者来说缺乏简单性。外部功能接口是作为JDK生态系统中的Panama项目的一部分开发的。
- en: New money and currency API (developed under JSR 354) was initially planned for
    Java 9, but was postponed.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的货币和货币API（在JSR 354下开发）最初计划在Java 9中推出，但已推迟。
- en: New lightweight JSON API (developed under JSR 353) was also planned for Java
    9, but postponed to Java 10.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的轻量级JSON API（在JSR 353下开发）也计划在Java 9中推出，但已推迟到Java 10。
- en: These are just some of the new things one may expect in subsequent releases
    of the JDK. Project Penrose aims to bridge the gap between the module system in
    Java and the OSGi module system, and to provide different methodologies for interoperability
    between the two systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是JDK后续版本中可能期待的一些新特性。Penrose项目旨在弥合Java模块系统与OSGi模块系统之间的差距，并为两个系统之间的互操作性提供不同的方法。
- en: The Graal VM is another interesting research project that is a potential candidate
    for subsequent releases of the Java platform. It aims to bring the runtime performance
    of Java to dynamic languages such as JavaScript or Ruby.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Graal VM是另一个有趣的研究项目，它可能是Java平台后续版本的一个潜在候选者。它的目标是提高Java的运行时性能，使其达到动态语言如JavaScript或Ruby的水平。
- en: A chapter dedicated to the future of JDK discusses all of these points in detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 专门讨论JDK未来的章节详细讨论了所有这些点。
- en: Summary
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this brief introductory chapter, we revealed the small universe of capabilities
    provided by JDK 9\. The module system introduced in this release of the platform
    is indisputably a cornerstone in the development of Java applications. We also
    discovered that a number of other major features and changes are introduced in
    JDK 9 that deserve special attention and will be discussed in great detail in
    subsequent chapters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本简要的介绍章节中，我们揭示了由 JDK 9 提供的强大功能的小宇宙。在这个平台版本中引入的模块系统无疑是 Java 应用程序开发的一个基石。我们还发现，JDK
    9 中引入了许多其他重要特性和变更，这些特性和变更值得特别关注，将在后续章节中详细讨论。
- en: In the next chapter, we will take a look at 26 internal changes to the Java
    platform.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Java 平台的 26 个内部变更。
- en: Improved Contended Locking [JEP 143]
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进的竞争锁 [JEP 143]
- en: The JVM uses Heap space for classes and objects. The JVM allocates memory on
    the heap whenever we create an object. This helps facilitate Java's garbage collection
    which releases memory previously used to hold objects that no longer have a reference
    to it. Java Stack memory is a bit different and is usually much smaller than heap
    memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 使用堆空间来存储类和对象。每当创建一个对象时，JVM 都会在堆上分配内存。这有助于促进 Java 的垃圾回收，它释放了之前用于存储不再有引用的对象的内存。Java
    栈内存有些不同，通常比堆内存小得多。
- en: The JVM does a good job of managing data areas that are shared by multiple threads.
    It associates a monitor with every object and class; these monitors have locks
    that are controlled by a single thread at any one time. These locks, controlled
    by the JVM, are, in essence, giving the controlling thread the object's monitor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 在管理多个线程共享的数据区域方面做得很好。它将监视器与每个对象和类关联；这些监视器有锁，在任何时候都由一个线程控制。这些由 JVM 控制的锁，本质上是在给予控制线程对象监视器的权限。
- en: 'So, what is contended locking? When a thread is in a queue for a currently
    locked object, it is said to be in contention for that lock. The following diagram
    shows a high-level view of this contention:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是竞争锁？当一个线程正在等待当前已锁定对象的队列中时，它就被说成是在竞争该锁。以下图展示了这一竞争的高级视图：
- en: '![](img/0f195fbd-f2f1-4152-8fcd-c5a02b2fe215.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f195fbd-f2f1-4152-8fcd-c5a02b2fe215.png)'
- en: As you can see in the preceding illustration, any threads in waiting cannot
    use a locked object until it is released.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，任何等待的线程在对象被释放之前都不能使用被锁定的对象。
- en: Improvement goals
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进目标
- en: 'The general goal of JEP 143 was to increase the overall performance of how
    the JVM manages contention over locked Java object monitors. The improvements
    to contended locking were all internal to the JVM and do not require any developer
    actions to benefit from them. The overall improvement goals were related to faster
    operations. These include:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 143 的一般目标是提高 JVM 管理锁定 Java 对象监视器竞争的整体性能。竞争锁的改进全部在 JVM 内部进行，并且不需要任何开发者的行动来从中受益。整体改进目标与更快操作相关。这包括：
- en: Faster monitor enter
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的监视器进入
- en: Faster monitor exit
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的监视器退出
- en: Faster notifications
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的通知
- en: The notifications are the `notify()` and `notifyAll()` operations that are called
    when the locked status of an object is changed. Testing this improvement is not
    something you can easily accomplish. Greater efficiency, at any level, is welcome,
    so this improvement is one we can be thankful for even without any easily observable
    testing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是当对象锁定状态改变时调用的 `notify()` 和 `notifyAll()` 操作。测试这一改进并不是一件容易的事情。在任何级别上的更高效率都是受欢迎的，因此，即使没有容易观察到的测试，这一改进也是我们可以感激的。
- en: Segmented code cache [JEP 197]
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分段代码缓存 [JEP 197]
- en: The segmented code cache JEP (197) upgrade was completed and results in faster,
    more efficient execution time. At the core of this change was the segmentation
    of the code cache into three distinct segments--non-method, profiled, and non-profiled
    code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分段代码缓存 JEP (197) 升级已完成，并导致更快的、更高效的执行时间。这一变化的核心理念是将代码缓存分割成三个不同的部分——非方法、已分析和未分析代码。
- en: A code cache is the area of memory where the Java Virtual Machine stores generated
    native code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码缓存是 Java 虚拟机存储生成的本地代码的内存区域。
- en: 'Each of the aforementioned code cache segments will hold a specific type of
    compiled code. As you can see in the following diagram, the code heap areas are
    segmented by type of compiled code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码缓存分段将包含特定类型的编译代码。如以下图所示，代码堆区域按编译代码的类型进行分段：
- en: '![](img/d2b14b35-4bed-4a9e-8b9f-bcb5832112c9.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2b14b35-4bed-4a9e-8b9f-bcb5832112c9.png)'
- en: Memory allocation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: The code heap containing non-method code is for JVM internal code and consists
    of a 3 MB fixed memory block. The rest of the code cache memory is equally allocated
    for the profiled code and non-profiled code segments. You have control of this
    via command-line commands.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 包含非方法代码的代码堆是用于JVM内部代码的，由一个3MB的固定内存块组成。其余的代码缓存内存平均分配给已分析代码和非分析代码段。你可以通过命令行命令来控制这一点。
- en: 'The following command can be used to define the code heap size for the non-method
    compiled code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义非方法编译代码的代码堆大小：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following command can be used to define the code heap size for the profiled
    compiled methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义已分析编译方法的代码堆大小：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following command can be used to define the code heap size for the non-profiled
    compiled methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义非分析编译方法的代码堆大小：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Java 9 feature certainly stands to improve Java application efficiency.
    It also impacts other processes that employ the code cache.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Java 9特性确实有助于提高Java应用程序的效率。它还影响了使用代码缓存的其他进程。
- en: Smart Java compilation, phase two [JEP 199]
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能Java编译，第二阶段 [JEP 199]
- en: The JDK Enhancement Proposal 199 is aimed at improving the code compilation
    process. All Java developers will be familiar with the **javac** tool for compiling
    source code to bytecode, which is used by the JVM to run Java programs. **Smart
    Java Compilation**, also referred to as Smart Javac and **sjavac**, adds a *smart*
    wrapper around the javac process. Perhaps the core improvement sjavac adds is
    that only the necessary code is recompiled. Necessary code, in this context, is
    code that has changed since the last compile cycle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JDK增强提案199旨在改进代码编译过程。所有Java开发者都将熟悉用于将源代码编译成字节码的**javac**工具，这是JVM运行Java程序所使用的。**智能Java编译**，也称为Smart
    Javac和**sjavac**，在javac进程周围添加了一个*智能*包装。sjavac可能带来的核心改进是只重新编译必要的代码。在这个上下文中，必要的代码是指自上次编译周期以来已更改的代码。
- en: This enhancement might not get developers excited if they only work on small
    projects. Consider, however, the tremendous gains in efficiency when you continuously
    have to recompile your code for medium and large projects. The time developers
    stand to save is enough reason to embrace JEP 199.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者只在小项目上工作，这个增强可能不会让他们感到兴奋。然而，考虑到在中等和大型项目中你不得不不断重新编译代码时在效率上的巨大提升，开发者可以节省的时间足以让他们接受JEP
    199。
- en: How will this change how you compile your code? It probably will not, at least
    not yet. Javac will remain the default compiler. While sjavac offers efficiencies
    regarding incremental builds, Oracle has deemed it to not have sufficient stability
    to become part of the standard compilation workflow.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将如何改变你编译代码的方式？可能不会，至少目前不会。Javac将继续作为默认编译器。虽然sjavac在增量构建方面提供了效率，但Oracle认为它没有足够的稳定性成为标准编译工作流程的一部分。
- en: 'You can read more information about the smart javac wrapper tool here: [http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html](http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处阅读有关智能javac包装工具的更多信息：[http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html](http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html)。
- en: Resolving Lint and Doclint warnings [JEP 212]
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决Lint和Doclint警告 [JEP 212]
- en: 'Do not worry if you are not familiar with Lint or Doclint in Java. As you can
    determine from the section title, they are sources that report warnings to javac.
    Let''s take a look at each one:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Java中的Lint或Doclint不熟悉，请不要担心。正如标题所示，它们是向javac报告警告的来源。让我们逐一看看：
- en: '**Lint** analyzes byte code and source code for javac. The goal of Lint is
    to identify security vulnerabilities in the code being analyzed. Lint can also
    provide insights into scalability and thread locking concerns. There is more to
    Lint, and the overall purpose is to save developers time.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lint**分析javac的字节码和源代码。Lint的目标是识别正在分析代码中的安全漏洞。Lint还可以提供关于可扩展性和线程锁定问题的见解。Lint还有更多功能，其总体目的是节省开发者的时间。'
- en: 'You can read more about Lint here: [https://en.wikipedia.org/wiki/Lint_(software)](https://en.wikipedia.org/wiki/Lint_(software)).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多关于Lint的信息：[https://en.wikipedia.org/wiki/Lint_(software)](https://en.wikipedia.org/wiki/Lint_(software))。
- en: '**Doclint** is similar to Lint and is specific to javadoc. Both Lint and Doclint
    report errors and warnings during the compile process. Resolution of these warnings
    was the focus of JEP 212\. When using core libraries, there should not be any
    warnings. This mindset led to JEP 212, which has been resolved and implemented
    in Java 9.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Doclint** 与 Lint 类似，且特定于 javadoc。Lint 和 Doclint 都在编译过程中报告错误和警告。这些警告的解决是 JEP
    212 的重点。当使用核心库时，不应有任何警告。这种心态导致了 JEP 212，它已在 Java 9 中得到解决并实现。'
- en: A comprehensive list of the Lint and Doclint warnings can be reviewed in the
    [https://bugs.openjdk.java.net](https://bugs.openjdk.java.net) JDK Bug System.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://bugs.openjdk.java.net](https://bugs.openjdk.java.net) JDK Bug 系统中查看
    Lint 和 Doclint 警告的完整列表。
- en: Tiered attribution for javac [JEP 215]
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: javac 的分层归因 [JEP 215]
- en: JEP 215 represents an impressive undertaking to streamline javac's type checking
    schema. Let's first review how type checking works in Java 8; then we will explore
    the changes in Java 9.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 215 代表了对 javac 类型检查架构进行简化的令人印象深刻的努力。让我们首先回顾一下 Java 8 中的类型检查是如何工作的；然后我们将探讨
    Java 9 中的变化。
- en: In Java 8, type checking of poly expressions is handled by a **speculative attribution**
    tool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，多态表达式类型检查由一个**推测性归因**工具处理。
- en: Speculative attribution is a method of type checking as part of javac's compilation
    process. It has a significant processing overhead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 推测性归因是 javac 编译过程的一部分类型检查方法。它具有显著的处理开销。
- en: Using the speculative attribution approach to type checking is accurate, but
    lacks efficiency. These checks include argument position, and are exponentially
    slower when testing in the midst of recursion, polymorphism, nested loops, and
    lambda expressions. So the goal with JEP 215 was to change the type checking schema
    to create faster results. The results themselves were not inaccurate with speculative
    attribution; they were just not generated rapidly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用推测性归因方法进行类型检查是准确的，但缺乏效率。这些检查包括参数位置，在递归、多态、嵌套循环和 lambda 表达式中测试时，速度呈指数级下降。因此，JEP
    215 的目标是改变类型检查架构以创建更快的结果。使用推测性归因的结果本身并不不准确；只是生成速度不够快。
- en: 'The new approach, released with Java 9, uses a tiered attribution tool. This
    tool implements a tiered approach for type checking argument expressions for all
    method calls. Permissions are also made for method overriding. In order for this
    new schema to work, new structural types are created for each of the following
    listed types of method arguments:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法，随 Java 9 一起发布，使用分层归因工具。此工具为所有方法调用中的参数表达式类型检查实现分层方法。还允许方法重写。为了使此新架构工作，为以下列出的每种方法参数类型创建了新的结构化类型：
- en: Lambda expressions
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Poly expressions
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态表达式
- en: Regular method calls
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常方法调用
- en: Method references
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用
- en: Diamond instance creation expressions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钻石实例创建表达式
- en: The changes to javac from JEP 215 are more complex than what has been highlighted
    in this section. There is no immediate impact to developers other than a more
    efficient javac and time saved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 215 对 javac 的更改比本节所强调的更为复杂。除了更高效的 javac 和节省的时间外，对开发者的直接影响并不立即显现。
- en: Annotations pipeline 2.0 [JEP 217]
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解管道 2.0 [JEP 217]
- en: Java annotations refer to a special kind of metadata that resides inside your
    Java source code files. They are not stripped by javac, so that they can remain
    available to the JVM at runtime.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java 注解指的是位于您的 Java 源代码文件中的特殊类型的元数据。它们不会被 javac 移除，因此它们可以在运行时对 JVM 可用。
- en: 'Annotations look similar to JavaDocs references because they start with the
    `@` symbol. There are three types of annotations. Let''s examine each:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注解看起来与 JavaDocs 引用相似，因为它们以 `@` 符号开头。有三种类型的注解。让我们逐一检查：
- en: 'The most basic form of annotation is a **marker** annotation. These are standalone
    annotations with the only component being the name of the animation. Here is an
    example:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最基本的注解形式是**标记**注解。这些是独立的注解，唯一的组件是动画的名称。以下是一个示例：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second type of annotation is one that contains a *single value*, or piece
    of data. As you can see in the following code, the annotation, which starts with
    the `@` symbol, is followed by parentheses containing data:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种类型的注解是包含一个*单个值*或数据的注解。正如您在以下代码中所看到的，以 `@` 符号开始的注解后面跟着包含数据的括号：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An alternative way of coding the single value annotation type is to omit the
    `data=` component, as illustrated in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编码单值注解类型的另一种方法是省略 `data=` 组件，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The third type of annotation is when there is *more than one data component*.
    With this type of annotation, the `data=` component cannot be omitted. Here is
    an example:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种类型的注解是当存在*多个数据组件*时。在这种类型的注解中，`data=`组件不能省略。以下是一个示例：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, what has changed in Java 9? To answer this question, we need to recall
    a couple of changes introduced with Java 8 that impacted Java annotations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Java 9 中有什么变化？要回答这个问题，我们需要回顾一下 Java 8 中引入的一些变化，这些变化影响了 Java 注解：
- en: Lambda expressions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Repeated annotations
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复注解
- en: Java type annotations
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 类型注解
- en: These Java 8 related changes impacted Java annotations, but did not usher in
    a change to how javac processed them. There were some hardcoded solutions that
    allowed javac to handle the new annotations, but they were not efficient. Moreover,
    this type of coding (hardcoding workarounds) is difficult to maintain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与 Java 8 相关的更改影响了 Java 注解，但并没有导致 javac 处理它们的方式发生变化。有一些硬编码的解决方案允许 javac 处理新的注解，但它们并不高效。此外，这种类型的编码（硬编码解决方案）难以维护。
- en: So, JEP 217 focused on refactoring the javac annotation pipeline. This refactoring
    was all internal to javac, so it should not be evident to developers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JEP 217 专注于重构 javac 注解管道。这次重构完全在 javac 内部进行，所以它不应该对开发者明显。
- en: New version-string scheme [JEP 223]
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的版本字符串方案 [JEP 223]
- en: 'Prior to Java 9, the release numbers did not follow industry standard versioning--**semantic
    versioning**. For example, at the time of writing, the last four JDK releases
    were:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，发布号没有遵循行业标准版本控制--**语义版本控制**。例如，在撰写本文时，最后四个 JDK 发布版是：
- en: JDK 8 update 131
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 131
- en: JDK 8 update 121
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 121
- en: JDK 8 update 112
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 112
- en: '**Semantic versioning** uses a major, minor, patch (0.0.0) schema:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制**使用主版本、次版本、补丁版本（0.0.0）的方案：'
- en: '**Major** equates to new API changes that are not backwards compatible.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**主版本**等同于不向后兼容的新 API 变更。'
- en: '**Minor** is when functionality is added that is backwards compatible.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**次版本**是指添加了向后兼容的功能。'
- en: '**Patch** refers to bug fixes or minor changes that are backwards compatible.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**补丁**指的是向后兼容的错误修复或小更改。'
- en: 'Oracle has embraced semantic versioning for Java 9 and beyond. For Java, a
    **major-minor-security** schema will be used for the first three elements of Java
    version numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 已经接受了 Java 9 及以后的语义版本控制。对于 Java，将使用**主版本-次版本-安全**方案来表示 Java 版本号的前三个元素：
- en: '**Major**: A major release consisting of a significant new set of features'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主版本**：包含一组重大新功能的重大版本'
- en: '**Minor**: Revisions and bug fixes that are backwards compatible'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次版本**：向后兼容的修订和错误修复'
- en: '**Security**: Fixes deemed critical to improve security'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：被认为对提高安全性至关重要的修复'
- en: 'This description of JEP 223 might make the versioning schema seem basic. To
    the contrary, a very detailed set of rules and practices have been developed to
    manage the future version numbers. To demonstrate the complexity, see the following
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 223 的这个描述可能会使版本控制方案看起来很基础。相反，已经开发了一套非常详细的规则和实践来管理未来的版本号。为了展示复杂性，请参见以下示例：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generating run-time compiler tests automatically [JEP 233]
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动生成运行时编译器测试 [JEP 233]
- en: Java is arguably the most used programming language and resides on an increasingly
    diverse number of platforms. This exacerbates the problem of running targeted
    compiler tests in an efficient manner. The purpose of JEP 233 was to create a
    tool that could automate the runtime compiler tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Java 可能是使用最广泛的编程语言，并且运行在日益多样化的平台上。这加剧了在高效方式下运行针对编译器的测试的问题。JEP 233 的目的是创建一个可以自动化运行时编译器测试的工具。
- en: 'The tool that was created starts by generating a random set of Java source
    code and/or byte code. The generated code will have three key characteristics:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的工具首先生成一组随机的 Java 源代码和/或字节码。生成的代码将具有三个关键特征：
- en: Be syntactically correct
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法正确
- en: Be semantically correct
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义正确
- en: Use a random seed that permits reusing the same randomly-generated code
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个允许重用相同随机生成代码的随机种子
- en: 'The source code that is randomly generated will be saved in the following directory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成的源代码将被保存在以下目录中：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These test cases will be stored for later re-use. They can be run from the `j-treg`
    directory or from the tool's makefile. One of the benefits of re-running saved
    tests is to test the stability of your system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例将被存储以供以后重用。它们可以从`j-treg`目录或从工具的 makefile 中运行。重新运行保存的测试的好处之一是测试系统的稳定性。
- en: Testing class-file attributes generated by Javac [JEP 235]
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试由 Javac 生成的类文件属性 [JEP 235]
- en: The lack of, or insufficient, capability to create tests for class-file attributes
    was the impetus behind JEP 235\. The goal is to ensure javac creates a class-file's
    attributes completely and correctly. This suggests that even if some attributes
    are not used by the class-file, all class-files should be generated with a complete
    set of attributes. There also needs to be a way of testing that the class-files
    were created correctly, in regards to the file's attributes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏或能力不足创建用于类文件属性的测试是 JEP 235 的动力。目标是确保 javac 完全且正确地创建类文件的属性。这表明即使某些属性没有被类文件使用，所有类文件都应生成一个完整的属性集。还需要有一种方法来测试类文件是否正确创建，特别是关于文件的属性。
- en: Prior to Java 9, there was no method of testing a class-file's attributes. Running
    a class and testing the code for anticipated or expected results was the most
    commonly used method of testing javac generated class-files. This technique falls
    short of testing to validate the file's attributes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，没有测试类文件属性的方法。运行一个类并测试代码以获得预期的结果是最常用的测试 javac 生成类文件的方法。这种技术不足以测试以验证文件的属性。
- en: There are three categories of class-file attributes--attributes used by the
    JVM, optional attributes, and attributes not used by the JVM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件属性有三个类别——JVM 使用的属性、可选属性和 JVM 未使用的属性。
- en: 'Attributes used by the JVM include:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 使用的属性包括：
- en: '`BootstrapMethods`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BootstrapMethods`'
- en: '`Code`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Code`'
- en: '`ConstantValue`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstantValue`'
- en: '`Exceptions`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exceptions`'
- en: '`StackMapTable`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackMapTable`'
- en: 'Optional attributes include:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性包括：
- en: '`Deprecated`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deprecated`'
- en: '`LineNumberTable`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineNumberTable`'
- en: '`LocalVariableTable`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalVariableTable`'
- en: '`LocalVariableTypeTable`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalVariableTypeTable`'
- en: '`SourceDebugExtension`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceDebugExtension`'
- en: '`SourceFile`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceFile`'
- en: 'Attributes not used by the JVM include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 未使用的属性包括：
- en: '`AnnotationDefault`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationDefault`'
- en: '`EnclosingMethod`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnclosingMethod`'
- en: '`InnerClasses`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InnerClasses`'
- en: '`MethodParameters`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodParameters`'
- en: '`RuntimeInvisibleAnnotations`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleAnnotations`'
- en: '`RuntimeInvisibleParameterAnnotations`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleParameterAnnotations`'
- en: '`RuntimeInvisibleTypeAnnotations`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleTypeAnnotations`'
- en: '`RuntimeVisibleAnnotations`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleAnnotations`'
- en: '`RuntimeVisibleParameterAnnotations`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleParameterAnnotations`'
- en: '`RuntimeVisibleTypeAnnotations`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleTypeAnnotations`'
- en: '`Signature`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signature`'
- en: '`Synthetic`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Synthetic`'
- en: Storing interned strings in CDS archives [JEP 250]
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CDS 归档中存储内部字符串 [JEP 250]
- en: 'The method in which strings are stored and accessed to and from **Class Data
    Sharing** (**CDS**) archives is inefficient, excessively time consuming, and wastes
    memory. The following diagram illustrates the method in which Java stores interned
    strings in a CDS archive:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和访问字符串以及从 **类数据共享**（**CDS**）归档中存储字符串的方法效率低下，耗时过多，且浪费内存。以下图示说明了 Java 在 CDS
    归档中存储内部字符串的方法：
- en: '![](img/326abe1b-f83d-421b-b919-49ff22f1cb89.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/326abe1b-f83d-421b-b919-49ff22f1cb89.png)'
- en: The inefficiency stems from the current storage schema. Especially when the
    **Class Data Sharing** tool dumps the classes into the shared archive file, the
    constant pools containing `CONSTANT_String` items have a UTF-8 string representation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 低效源于当前的存储架构。特别是当**类数据共享**工具将类导出到共享归档文件时，包含`CONSTANT_String`项的常量池具有 UTF-8 字符串表示形式。
- en: UTF-8 is an 8-bit variable-length character encoding standard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是一个 8 位可变长度字符编码标准。
- en: The problem
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: With the current use of UTF-8, the strings must be converted to string objects,
    instances of the `java.lang.String` class. This conversion takes place on-demand
    which can result in slower systems and unnecessary memory usage. The processing
    time is extremely short, but the memory usage cannot be overlooked. Every character
    in an interned string requires at least 3 bytes of memory and potentially more.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前使用 UTF-8 的情况下，字符串必须转换为字符串对象，即 `java.lang.String` 类的实例。这种转换是按需进行的，可能会导致系统运行速度变慢和不必要的内存使用。处理时间非常短，但内存使用不能忽视。每个内部字符串中的字符至少需要
    3 字节内存，可能还需要更多。
- en: A related problem is that the stored strings are not accessible to all JVM processes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是存储的字符串对所有 JVM 进程不可访问。
- en: The solution
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'CDS archives now allocate specific space on the heap for strings:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CDS 归档现在在堆上为字符串分配特定空间：
- en: '![](img/91cce5a8-f4ef-419d-881f-a809d4f600f2.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91cce5a8-f4ef-419d-881f-a809d4f600f2.png)'
- en: The string space is mapped using a shared-string table, hash tables, and deduplication.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串空间是通过共享字符串表、哈希表和去重来映射的。
- en: Deduplication is a data compression technique that eliminates duplicative information
    in an archive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 去重是一种数据压缩技术，它消除了归档中的重复信息。
- en: Preparing JavaFX UI controls and CSS APIs for modularization [JEP 253]
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模块化准备JavaFX UI控件和CSS API [JEP 253]
- en: JavaFX is a set of packages that permits the design and development of media-rich
    graphical user interfaces. JavaFX applications provide developers with a great
    API for creating a consistent interface for applications. **Cascading Style Sheets**
    (**CSS**) can be used to customize the interfaces. One of the great things about
    JavaFX is that the tasks of programming and interface design can easily be separated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX是一组允许设计和开发富媒体图形用户界面的包。JavaFX应用程序为开发者提供了一个优秀的API，用于创建应用程序的一致界面。**层叠样式表**（**CSS**）可以用来自定义界面。JavaFX的伟大之处之一是编程和界面设计任务可以轻松分离。
- en: JavaFX overview
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX概述
- en: There is a wonderful visual scripting tool called Scene Builder that allows
    you to create graphical user interfaces by using drag and drop and property settings.
    Scene Builder generates the necessary FXML files that are used by your **Integrated
    Development Environment** (**IDE**) such as NetBeans.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个叫做Scene Builder的出色的可视化脚本工具，它允许您通过拖放和属性设置来创建图形用户界面。Scene Builder生成必要的FXML文件，这些文件由您的**集成开发环境**（**IDE**）如NetBeans使用。
- en: 'Here is a sample UI created with Scene Builder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用Scene Builder创建的示例UI：
- en: '![](img/c0c58de4-e328-41dd-9ea0-821385a82099.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0c58de4-e328-41dd-9ea0-821385a82099.png)'
- en: 'And, here is the FXML file created by Scene Builder:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，以下是Scene Builder创建的FXML文件：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implications for Java 9
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的影响
- en: Prior to Java 9, JavaFX controls as well as CSS functionality were only available
    to developers by interfacing with internal APIs. Java 9's modularization has made
    the internal APIs inaccessible. Therefore, JEP 253 was created to define public,
    instead of internal, APIs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，JavaFX控件以及CSS功能只能通过接口内部API供开发者使用。Java 9的模块化使得内部API不可访问。因此，JEP 253被创建来定义公共API，而不是内部API。
- en: 'This was a larger undertaking than it might seem. Here are a few actions that
    were taken as part of this JEP:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作比看起来要大得多。以下是作为此JEP一部分采取的一些行动：
- en: Moving javaFX control skins from the internal to public API (`javafx.scene.skin`)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将javaFX控件皮肤从内部API移动到公共API（`javafx.scene.skin`）
- en: Ensuring API consistencies
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保API一致性
- en: Generation of a thorough javadoc
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成详尽的javadoc
- en: 'The following classes were moved from internal packages to a public `javafx.scene.control.skin`
    package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类已从内部包移动到公共`javafx.scene.control.skin`包：
- en: '| `AccordionSkin` | `ButtonBarSkin` | `ButtonSkin` | `CellSkinBase` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `AccordionSkin` | `ButtonBarSkin` | `ButtonSkin` | `CellSkinBase` |'
- en: '| `CheckBoxSkin` | `ChoiceBoxSkin` | `ColorPickerSkin` | `ComboBoxBaseSkin`
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `CheckBoxSkin` | `ChoiceBoxSkin` | `ColorPickerSkin` | `ComboBoxBaseSkin`
    |'
- en: '| `ComboBoxListViewSkin` | `ComboBoxPopupControl` | `ContextMenuSkin` | `DateCellSkin`
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `ComboBoxListViewSkin` | `ComboBoxPopupControl` | `ContextMenuSkin` | `DateCellSkin`
    |'
- en: '| `DatePickerSkin` | `HyperLinkSkin` | `LabelSkin` | `LabeledSkinBase` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `DatePickerSkin` | `HyperLinkSkin` | `LabelSkin` | `LabeledSkinBase` |'
- en: '| `ListCellSkin` | `ListViewSkin` | `MenuBarSkin` | `MenuButtonSkin` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `ListCellSkin` | `ListViewSkin` | `MenuBarSkin` | `MenuButtonSkin` |'
- en: '| `MenuButtonSkinbase` | `NestedTableColumHeader` | `PaginationSkin` | `ProgressBarSkin`
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `MenuButtonSkinbase` | `NestedTableColumHeader` | `PaginationSkin` | `ProgressBarSkin`
    |'
- en: '| `ProgressIndicatorSkin` | `RadioButtonSkin` | `ScrollBarSkin` | `ScrollPaneSkin`
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `ProgressIndicatorSkin` | `RadioButtonSkin` | `ScrollBarSkin` | `ScrollPaneSkin`
    |'
- en: '| `SeparatorSkin` | `SliderSkin` | `SpinnerSkin` | `SplitMenuButtonSkin` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `SeparatorSkin` | `SliderSkin` | `SpinnerSkin` | `SplitMenuButtonSkin` |'
- en: '| `SplitPaneSkin` | `TabPaneSkin` | `TableCellSkin` | `TableCellSkinBase` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `SplitPaneSkin` | `TabPaneSkin` | `TableCellSkin` | `TableCellSkinBase` |'
- en: '| `TableColumnHeader` | `TableHeaderRow` | `TableHeaderSkin` | `TableRowSkinBase`
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `TableColumnHeader` | `TableHeaderRow` | `TableHeaderSkin` | `TableRowSkinBase`
    |'
- en: '| `TableViewSkin` | `TableViewSkinBase` | `TextAreaSkin` | `TextFieldSkin`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `TableViewSkin` | `TableViewSkinBase` | `TextAreaSkin` | `TextFieldSkin`
    |'
- en: '| `TextInputControlSkin` | `TitledPaneSkin` | `ToggleButtonSkin` | `TooBarSkin`
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `TextInputControlSkin` | `TitledPaneSkin` | `ToggleButtonSkin` | `TooBarSkin`
    |'
- en: '| `TooltipSkin` | `TreeCellSkin` | `TreeTableCellSkin` | `TreeTableRowSkin`
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `TooltipSkin` | `TreeCellSkin` | `TreeTableCellSkin` | `TreeTableRowSkin`
    |'
- en: '| `TreeTableViewSkin` | `TreeViewSkin` | `VirtualContainerBase` | `VirtualFlow`
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `TreeTableViewSkin` | `TreeViewSkin` | `VirtualContainerBase` | `VirtualFlow`
    |'
- en: 'The public `javafx.css` package now has the additional classes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 公共`javafx.css`包现在有额外的类：
- en: '`CascadingStyle.java:public class CascadingStyle implements Comparable<CascadingStyle>`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CascadingStyle.java:public class CascadingStyle implements Comparable<CascadingStyle>`'
- en: '`CompoundSelector.java:final public class CompoundSelector extends Selector`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompoundSelector.java:final public class CompoundSelector extends Selector`'
- en: '`CssError.java:public class CssError`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CssError.java:public class CssError`'
- en: '`Declaration.java:final public class Declaration`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Declaration.java:final public class Declaration`'
- en: '`Rule.java:final public class Rule`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rule.java:final public class Rule`'
- en: '`Selector.java:abstract public class Selector`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.java:abstract public class Selector`'
- en: '`SimpleSelector.java:final public class SimpleSelector extends Selector`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleSelector.java:final public class SimpleSelector extends Selector`'
- en: '`Size.java:final public class Size`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size.java:final public class Size`'
- en: '`Style.java:final public class Style`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Style.java:final public class Style`'
- en: '`Stylesheet.java:public class Stylesheet`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stylesheet.java:public class Stylesheet`'
- en: '`CssParser.java:final public class CssParser`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CssParser.java:final public class CssParser`'
- en: Compact strings [JEP 254]
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧凑字符串 [JEP 254]
- en: The string data type is an important part of nearly every Java app. While JEP
    254's aim was to make strings more space-efficient, it was approached with caution
    so that existing performance and compatibilities would not be negatively impacted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型是几乎所有 Java 应用程序的重要部分。虽然 JEP 254 的目标是使字符串更节省空间，但它采取了谨慎的态度，以确保现有的性能和兼容性不会受到负面影响。
- en: Pre-Java 9 status
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 之前的状态
- en: Prior to Java 9, string data was stored as an array of chars. This required
    16 bits for each char. It was determined that the majority of String objects could
    be stored with only 8 bits, or 1 byte of storage. This is due to the fact that
    most strings consist of Latin-1 characters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，字符串数据存储为字符数组。每个字符需要 16 位。确定大多数 String 对象可以用仅 8 位，即 1 字节的空间存储。这是因为大多数字符串由
    Latin-1 字符组成。
- en: The ISO Latin-1 Character Set is a single-byte set of character's encodings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ISO Latin-1 字符集是一个单字节字符编码集合。
- en: New with Java 9
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 新增
- en: Starting with Java 9, strings are now internally represented using a byte array
    along with a flag field for encoding references.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 9 开始，字符串现在使用字节数组内部表示，并带有编码引用的标志字段。
- en: Merging selected Xerces 2.11.0 updates into JAXP [JEP 255]
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将选定的 Xerces 2.11.0 更新合并到 JAXP [JEP 255]
- en: Xerces is a library used for parsing XML in Java. It was updated to 2.11.0 in
    late 2010, so JEP 255's aim was to update JAXP to incorporate changes in Xerces
    2.11.0.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Xerces 是一个用于在 Java 中解析 XML 的库。它在 2010 年晚些时候更新到 2.11.0，因此 JEP 255 的目标是更新 JAXP
    以包含 Xerces 2.11.0 的更改。
- en: JAXP is Java's API for XML processing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JAXP 是 Java 的 XML 处理 API。
- en: Prior to Java 9, the JDK's latest update regarding XML processing was based
    on Xerces 2.7.1\. There were some additional changes to JDK 7 based on Xerces,
    2.10.0\. JEP 255 is a further refinement of the JAXP based on Xerces 2.11.0.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，JDK 关于 XML 处理的最新更新基于 Xerces 2.7.1。基于 Xerces 的 JDK 7 进行了一些额外的更改，版本为
    2.10.0。JEP 255 是基于 Xerces 2.11.0 的 JAXP 的进一步改进。
- en: 'Xerces 2.11.0 supports the following standards:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Xerces 2.11.0 支持以下标准：
- en: XML 1.0, Fourth Edition
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.0，第四版
- en: Namespaces in XML 1.0, Second Edition
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.0 第二版中的命名空间
- en: XML 1.1, Second Edition
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.1，第二版
- en: Namespaces in XML 1.1, Second Edition
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.1 第二版中的命名空间
- en: XML Inclusions 1.0, Second Edition
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 包含 1.0，第二版
- en: '**Document Object Model** (**DOM**)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型** (**DOM**)'
- en: Level 3
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三级
- en: Core
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心功能
- en: Load & save
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载与保存
- en: Level 2
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二级
- en: Core
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心功能
- en: Events
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Traversal & Range
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历与范围
- en: Element Traversal, First Edition
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素遍历，第一版
- en: Simple API for XML 2.0.2
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单 XML API 2.0.2
- en: '**Java APIs for XML Processing** (**JAXP**) 1.4'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java XML 处理 API** (**JAXP**) 1.4'
- en: Streaming API for XML 1.0
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 流式 API 1.0
- en: XML Schema 1.0
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML Schema 1.0
- en: XML Schema 1.1
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML Schema 1.1
- en: XML Schema Definition Language
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式定义语言
- en: 'The JDK was updated to include the following Xerces 2.11.0 categories:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 更新以包括以下 Xerces 2.11.0 类别：
- en: Catalog resolver
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录解析器
- en: Datatypes
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Document Object Model Level 3
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档对象模型第三级
- en: XML Schema Validation
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式验证
- en: XPointer
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XPointer
- en: The public API for JAXP was not changed in Java 9.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中 JAXP 的公共 API 没有发生变化。
- en: Updating JavaFX/Media to newer version of GStreamer [JEP 257]
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JavaFX/Media 更新到 GStreamer 的新版本 [JEP 257]
- en: 'JavaFX is used for creating desktop and web applications. JavaFX was created
    to replace Swing as Java''s standard GUI library. The `Media` class, `javafx.scene.media.Media`,
    is used to instantiate an object representing a media resource. JavaFX/Media refers
    to the following class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 用于创建桌面和 Web 应用程序。JavaFX 是为了取代 Swing 而创建的，作为 Java 的标准 GUI 库。`Media` 类，`javafx.scene.media.Media`，用于实例化表示媒体资源的对象。JavaFX/Media
    指的是以下类：
- en: '[PRE11]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class provides referential data to a media resource. The `javafx.scene.media`
    package provides developers with the ability to incorporate media into their JavaFX
    applications. JavaFX/Media utilizes a GStreamer pipeline.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此类为媒体资源提供引用数据。`javafx.scene.media` 包为开发者提供了将媒体集成到他们的 JavaFX 应用程序中的能力。JavaFX/Media
    使用 GStreamer 管道。
- en: GStreamer is a multimedia processing framework that can be used to build systems
    that take in media from several different formats and, after processing, export
    them in selected formats.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer 是一个多媒体处理框架，可用于构建从多种不同格式获取媒体，并在处理后将它们导出为选定格式的系统。
- en: The purpose of JEP 257 was to ensure JavaFX/Media was updated to include the
    latest release of GStreamer for stability, performance, and security assurances.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 257 的目的是确保 JavaFX/Media 被更新以包含 GStreamer 的最新版本，以提供稳定性、性能和安全保证。
- en: HarfBuzz Font-Layout Engine [JEP 258]
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HarfBuzz 字体布局引擎 [JEP 258]
- en: Prior to Java 9, the layout engine used to handle font complexities; specifically
    fonts that have rendering behaviors beyond what the common Latin fonts have. Java
    used the uniform client interface, also referred to as ICU, as the defacto text
    rendering tool. The ICU layout engine has been depreciated and, in Java 9, has
    been replaced with the HarfBuzz font layout engine.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，布局引擎用于处理字体复杂性；特别是具有超出常见拉丁字体渲染行为的字体。Java 使用统一客户端界面，也称为 ICU，作为默认文本渲染工具。ICU
    布局引擎已被弃用，并在 Java 9 中被 HarfBuzz 字体布局引擎所取代。
- en: HarfBuzz is an **OpenType** text rendering engine. This type of layout engine
    has the characteristic of providing script-aware code to help ensure text is laid
    out as desired.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: HarfBuzz 是一个 **OpenType** 文本渲染引擎。这种布局引擎具有提供脚本感知代码的特性，以帮助确保文本按预期布局。
- en: OpenType is an HTML formatted font format specification.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: OpenType 是一种 HTML 格式的字体格式规范。
- en: The impetus for the change from the ICU Layout Engine to the HarfBuzz Font Layout
    Engine was IBM's decision to cease supporting the ICU Layout Engine. Therefore,
    the JDK was updated to contain the HarfBuzz Font Layout Engine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ICU 布局引擎到 HarfBuzz 字体布局引擎的变更动力源于 IBM 决定停止支持 ICU 布局引擎。因此，JDK 被更新以包含 HarfBuzz
    字体布局引擎。
- en: HiDPI graphics on Windows and Linux [JEP 263]
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 和 Linux 上的 HiDPI 图形 [JEP 263]
- en: 'JEP 263 was focused on ensuring the crispness of on-screen components, relative
    to the pixel density of the display. The following terms are relevant to this
    JEP and are provided along with the below listed descriptive information:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 263 专注于确保屏幕组件的清晰度，相对于显示器的像素密度。以下术语与该 JEP 相关，并附带以下列出的描述性信息：
- en: '**DPI-aware application**: An application that is able to detect and scale
    images for the display''s specific pixel density'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DPI感知应用程序**：能够检测和缩放图像以适应显示特定像素密度的应用程序'
- en: '**DPI-unaware application**: An application that makes no attempt to detect
    and scale images for the display''s specific pixel density'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DPI 不可感知应用程序**：不尝试检测和缩放图像以适应显示器特定像素密度的应用程序'
- en: '**HiDPI graphics**: High dots-per-inch graphics'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HiDPI 图形**：每英寸高点的图形'
- en: '**Retina display**: This term was created by Apple to refer to displays with
    a pixel density of at least 300 pixels per inch'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retina 显示**：这个术语是由苹果公司创造的，指的是至少每英寸有 300 个像素密度的显示器'
- en: 'Displaying graphics, both images and graphical user interface components, to
    the user is typically of paramount performance. Displaying this imagery in high
    quality can be somewhat problematic. There is large variability in computer monitor
    DPIs. There are three basic approaches to developing for displays:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户显示图形，无论是图像还是图形用户界面组件，通常具有至关重要的性能。以高质量显示这些图像可能有些问题。计算机监视器的 DPI 存在很大的差异。开发针对显示器的三种基本方法如下：
- en: Develop apps without regard for the potential different display dimensions.
    In other words, create a DPI-unaware application.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发不考虑潜在不同显示尺寸的应用程序。换句话说，创建一个 DPI 不可感知应用程序。
- en: Develop a DPI-aware application that selectively uses pre-rendered image sizes
    for a given display.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个选择性地使用预渲染图像大小以适应特定显示的 DPI 感知应用程序。
- en: Develop a DPI-aware application that properly scales images up/down to account
    for the specific display the application is run on.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个 DPI 感知应用程序，能够适当地放大或缩小图像以适应应用程序运行的特定显示。
- en: Clearly, the first two approaches are problematic, and for different reasons.
    With the first approach, the user experience is not considered. Of course, if
    the application was being developed for a very specific display with no expected
    pixel density variability, then this approach could be viable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前两种方法都有问题，原因各不相同。在第一种方法中，用户体验没有被考虑。当然，如果应用程序是为一个非常具体的显示而开发的，且没有预期的像素密度变化，那么这种方法可能是可行的。
- en: The second approach requires a lot of work on the design and development end
    to ensure images for each expected display density are created and implemented
    programmatically. In addition to the tremendous amount of work, the app size will
    unnecessarily increase, and new and different pixel densities will not have been
    accounted for.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法需要在设计和开发端进行大量工作，以确保为每个预期的显示密度创建并实现图像。除了大量的工作外，应用程序的大小将不必要地增加，并且没有考虑到新的和不同的像素密度。
- en: The third approach is to create a DPI-aware application with efficient and effective
    scaling capabilities. This approach works well and has been proven with the Mac
    retina displays.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是通过创建具有高效和有效缩放能力的DPI感知应用程序。这种方法效果良好，并且已经在Mac视网膜显示器上得到验证。
- en: Prior to Java 9, automatic scaling and sizing was already implemented in Java
    for the Mac OS X operating system. This capability was added in Java 9 for Windows
    and Linux operating systems.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，Java已经在Mac OS X操作系统上实现了自动缩放和尺寸调整功能。此功能在Java 9中添加到了Windows和Linux操作系统。
- en: Marlin graphics renderer [JEP 265]
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 马林图形渲染器 [JEP 265]
- en: JEP 265 replaced the Pisces graphics rasterizer with the Marlin graphics renderer
    in the Java 2D API. This API is used to draw 2D graphics and animations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 265在Java 2D API中将鱼鹰图形光栅化器替换为马林图形渲染器。此API用于绘制2D图形和动画。
- en: The goal was to replace Pisces with a rasterizer/renderer that was much more
    efficient and without any quality loss. This goal was realized in Java 9\. An
    intended collateral benefit was to include a developer-accessible API. Previously,
    the means of interfacing with the AWT and Java 2D was internal.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是用一个效率更高且没有任何质量损失的光栅化器/渲染器替换鱼鹰。这个目标在Java 9中实现了。一个预期的附带好处是包括一个开发者可访问的API。以前，与AWT和Java
    2D交互的方式是内部的。
- en: Unicode 8.0.0 [JEP 267]
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 8.0.0 [JEP 267]
- en: Unicode 8.0.0 was released on June 17, 2015\. JEP 267 focused on updating the
    relevant APIs to support Unicode 8.0.0.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 8.0.0于2015年6月17日发布。JEP 267专注于更新相关API以支持Unicode 8.0.0。
- en: New in Unicode 8.0.0
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新增于Unicode 8.0.0
- en: 'Unicode 8.0.0 added nearly 8,000 characters. Here are the highlights of the
    release:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 8.0.0增加了近8000个字符。以下是发布的高亮内容：
- en: Ahom script for the Tai Ahom language (India)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泰阿洪语（印度）的阿洪文字
- en: Arwi, Tamil language (Arabic)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿尔威语，泰米尔语（阿拉伯语）
- en: Cherokee symbols
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切罗基符号
- en: CJK unified ideographs
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CJK统一表意文字
- en: Emoji symbols along with flesh-tone symbol modifiers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有肤色符号修饰符的表情符号
- en: Georgian lari currency symbol
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格鲁吉亚拉里货币符号
- en: lk language (Uganda)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lk语言（乌干达）
- en: Kulango languge (Côte d’Ivoire)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库朗戈语（科特迪瓦）
- en: Updated Classes in Java 9
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9中更新的类
- en: 'In order to fully comply with the new Unicode standard, several Java classes
    were updated. The following listed classes were updated for Java 9 to comply with
    the new Unicode standard:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全符合新的Unicode标准，几个Java类被更新。以下列出的类被更新以符合Java 9的新Unicode标准：
- en: '`java.awt.font.NumericShaper`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.font.NumericShaper`'
- en: '`java.lang.Character`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character`'
- en: '`java.lang.String`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`'
- en: '`java.text.Bidi`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.Bidi`'
- en: '`java.text.BreakIterator`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.BreakIterator`'
- en: '`java.text.Normalizer`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.Normalizer`'
- en: Reserved stack areas for critical sections [JEP 270]
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为关键部分保留堆栈区域 [JEP 270]
- en: The goal of JEP 270 was to mitigate problems stemming from stack overflows during
    the execution of critical sections. This mitigation took the form of reserving
    additional thread stack space.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 270的目标是在执行关键部分时减轻堆栈溢出问题。这种缓解措施是通过保留额外的线程堆栈空间来实现的。
- en: The pre-Java 9 situation
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的情况
- en: The JVM throws a `StackOverflowError` when it is asked to perform data computation
    in a thread that has insufficient stack space and does not have permission to
    allocate additional space. This is an asynchronous exception. The JVM can also
    throw the `StackOverflowError` exception synchronously when a method is invoked.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM被要求在缺乏堆空间且没有权限分配额外空间的线程中执行数据计算时，它会抛出`StackOverflowError`异常。这是一个异步异常。当方法被调用时，JVM也可以同步地抛出`StackOverflowError`异常。
- en: When a method is invoked, an internal process is used to report the Stack Overflow.
    While the current schema works sufficiently for reporting the error, there is
    no room for the calling application to easily recover from the error. This can
    result in being more than a nuisance for developers and users. If the `StackOverflowError`
    was thrown during a critical computational operation, the data might be corrupted,
    causing additional problems.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被调用时，会使用一个内部过程来报告栈溢出。虽然当前的架构足以报告错误，但调用应用程序无法轻易地从错误中恢复。这可能会给开发人员和用户带来更多的不便。如果在关键的计算操作期间抛出了`StackOverflowError`，数据可能会被损坏，导致额外的麻烦。
- en: While not the sole cause of these problems, the effected status of locks from
    the `ReentrantLock` class were a common cause of undesirable outcomes. This issue
    was evident in Java 7 because the `ConcurrentHasMap` code implemented the `ReentrantLock`
    class. The `ConcurrentHasMap` code was modified for Java 8, but problems still
    persisted for any implementation of the `ReentrantLock` class. Similar problems
    existed beyond just `ReentrantLock` class usage.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是这些问题的唯一原因，但`ReentrantLock`类的受影响状态是导致不理想结果的一个常见原因。这个问题在Java 7中很明显，因为`ConcurrentHasMap`代码实现了`ReentrantLock`类。`ConcurrentHasMap`代码在Java
    8中进行了修改，但对于`ReentrantLock`类的任何实现，问题仍然存在。类似的问题超出了仅仅使用`ReentrantLock`类的情况。
- en: 'The following diagram provides a broad overview of the `StackOverflowError`
    problem:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表提供了一个关于`StackOverflowError`问题的广泛概述：
- en: '![](img/49c4c434-1548-47f8-84e9-c74bce5c3901.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49c4c434-1548-47f8-84e9-c74bce5c3901.png)'
- en: In the next section, we will look at how this issue was resolved for Java 9.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何解决Java 9中的这个问题。
- en: New in Java 9
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新增于Java 9
- en: With the JEP 270 changes for Java 9, a critical section will automatically be
    given additional space so that it can complete its execution and not suffer from
    the `StackOverflowError`. This is predicated on the additional space allocation
    needs being small. The necessary changes have been made to the JVM to permit this
    functionality.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Java 9的JEP 270更改，关键部分将自动获得额外的空间，以便它可以完成其执行而不会受到`StackOverflowError`的影响。这基于额外的空间分配需求很小。为了允许这个功能，JVM已经做出了必要的更改。
- en: 'The JVM actually delays the `StackOverflowError`, or at least attempts to,
    while critical sections are executing. In order to capitalize on this new schema,
    methods must be annotated with the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: JVM实际上会延迟`StackOverflowError`，或者至少在执行关键部分时尝试这样做。为了利用这个新的架构，方法必须使用以下注解：
- en: '[PRE12]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When a method has this annotation and a `StackOverflowError` condition exists,
    temporary access to the reserved memory space is granted. The new process is,
    at a high level of abstraction, presented as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法有这个注解并且存在`StackOverflowError`条件时，将授予对保留内存空间的临时访问权限。这个新过程在高度抽象的层面上可以表示如下：
- en: '![](img/f576b05c-8b60-454e-bb51-3972d50dd8d9.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f576b05c-8b60-454e-bb51-3972d50dd8d9.png)'
- en: Dynamic linking of language-defined object models [JEP 276]
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言定义的对象模型的动态链接 [JEP 276]
- en: Java interoperability was enhanced with JEP 276\. The necessary JDK changes
    were made to permit runtime linkers from multiple languages to coexist in a single
    JVM instance. This change applies to high-level operations, as you would expect.
    An example of a relevant high-level operation is the reading or writing of a property
    with elements such as accessors and mutators.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Java互操作性通过JEP 276得到了增强。为了允许多种语言的运行时链接器在单个JVM实例中共存，已经做出了必要的JDK更改。正如您所期望的，这个更改适用于高级操作。一个相关的高级操作示例是使用访问器和修改器等元素读取或写入属性。
- en: 'The high-level operations apply to objects of unknown types. They can be invoked
    with `INVOKEDYNAMIC` instructions. Here is an example of calling an object''s
    property when the object''s type is unknown at compile time:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 高级操作适用于未知类型的对象。它们可以使用`INVOKEDYNAMIC`指令来调用。以下是一个示例，当在编译时未知对象的类型时调用对象的属性：
- en: '[PRE13]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Proof of concept
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念验证
- en: 'Nashorn is a lightweight, high-performance, JavaScript runtime that permits
    embedding JavaScript in Java applications. This was created for Java 8 and replaced
    the previous JavaScript scripting engine that was based on Mozilla Rhino. Nashorn
    already has this functionality. It provides linkage between high-level operations
    on any object of unknown type, such as `obj.something`, where it produces the
    following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn 是一个轻量级、高性能的 JavaScript 运行时，允许在 Java 应用程序中嵌入 JavaScript。这是为 Java 8 创建的，并取代了基于
    Mozilla Rhino 的先前 JavaScript 脚本引擎。Nashorn 已经具有此功能。它提供未知类型任何对象的高级操作之间的链接，例如 `obj.something`，它产生以下结果：
- en: '[PRE14]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The dynamic linker springs into action and provides, when possible, the appropriate
    implementation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器迅速行动起来，并在可能的情况下提供适当的实现。
- en: Additional tests for humongous objects in G1 [JEP 278]
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1 中针对巨大对象的额外测试 [JEP 278]
- en: One of the long-favored features of the Java platform is the behind the scenes
    garbage collection. JEP 278's focus was to create additional WhiteBox tests for
    humongous objects as a feature of the G1 garbage collector.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台长期受欢迎的功能之一是幕后垃圾收集。JEP 278 的重点是创建针对巨大对象的额外白盒测试，作为 G1 垃圾收集器的一个功能。
- en: WhiteBox testing is an API used to query JVM internals. The WhiteBox testing
    API was introduced in Java 7 and upgraded in Java 8 and Java 9.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试是一个用于查询 JVM 内部的 API。白盒测试 API 在 Java 7 中引入，并在 Java 8 和 Java 9 中进行了升级。
- en: 'The G1 garbage collector works extremely well, but there was room for some
    improved efficiency. The way the G1 garbage collector worked is based on first
    dividing the heap into regions of equal size, illustrated as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: G1 垃圾收集器工作得非常好，但还有改进效率的空间。G1 垃圾收集器的工作方式是基于首先将堆划分为大小相等的区域，如下所示：
- en: '![](img/1e81f892-f803-458c-ae5b-7f080daa6710.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e81f892-f803-458c-ae5b-7f080daa6710.png)'
- en: The problem with the G1 garbage collector was how humongous objects were handled.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: G1 垃圾收集器的问题在于如何处理巨大对象。
- en: A humongous object in the context of garbage collection, is any object that
    takes up more than one region on the heap.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾收集的上下文中，巨大对象是指占据堆上多个区域的任何对象。
- en: 'The problem with humongous objects was that if they took up any part of a region
    on the heap, the remaining space was not able to be allocated for other objects.
    In Java 9, the WhiteBox API was extended with four types of new methods:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 巨大对象的问题在于，如果它们占据了堆上任何区域的一部分，剩余的空间就无法为其他对象分配。在 Java 9 中，WhiteBox API 通过四种新的方法进行了扩展：
- en: Methods with the purpose of blocking full garbage collection and to initiate
    concurrent marking.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于阻止完全垃圾收集并启动并发标记的方法。
- en: Methods that can access individual G1 garbage collection heap regions. Access
    to these regions consist of attribute reading, such as with the current state
    of the region.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问单个 G1 垃圾收集堆区域的方法。对这些区域的访问包括属性读取，例如读取区域的当前状态。
- en: Methods with direct access to the G1 garbage collection internal variables.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接访问 G1 垃圾收集内部变量的方法。
- en: Methods that can determine if humongous objects reside on the heap and, if so,
    in what regions.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以确定巨大对象是否位于堆上以及（如果位于）位于哪些区域的方法。
- en: Improving test-failure troubleshooting [JEP 279]
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进测试故障排除 [JEP 279]
- en: For developers that do a lot of testing, JEP 279 is worth reading about. Additional
    functionality has been added in Java 9 to automatically collect information to
    support troubleshooting test failures as well as timeouts. Collecting readily
    available diagnostic information during tests stands to provide developers and
    engineers with greater fidelity in their logs and other output.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进行大量测试的开发者来说，阅读关于 JEP 279 的内容是值得的。Java 9 中添加了额外的功能，以自动收集信息以支持故障排除测试失败以及超时。在测试期间收集可用的诊断信息，可以为开发者和工程师提供更精确的日志和其他输出。
- en: There are two basic types of information in the context of testing--environmental
    and process.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的上下文中，有两种基本类型的信息——环境和进程。
- en: Environmental information
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境信息
- en: 'When running tests, the testing environment information can be important for
    troubleshooting efforts. This information includes the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，测试环境信息对于故障排除工作可能很重要。以下信息包括：
- en: CPU loads
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 负载
- en: Disk space
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间
- en: I/O loads
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 负载
- en: Memory space
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存空间
- en: Open files
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件
- en: Open sockets
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开套接字
- en: Processes running
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在运行的进程
- en: System events
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统事件
- en: System messages
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统消息
- en: Java process information
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 进程信息
- en: 'There is also information available during the testing process directly related
    to Java processes. These include:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，还可以直接获得与 Java 进程相关的信息。这些包括：
- en: C stacks
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 栈
- en: Core dumps
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心转储
- en: Mini dumps
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型转储
- en: Heap statistics
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆统计信息
- en: Java stacks
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 栈
- en: For additional information on this concept, read about the JDK's regression
    test harness (jtreg).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此概念的更多信息，请阅读 JDK 的回归测试工具（jtreg）。
- en: Optimizing string concatenation [JEP 280]
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化字符串连接 [JEP 280]
- en: 'JEP 280 is an interesting enhancement for the Java platform. Prior to Java
    9, string concatenation was translated by javac into `StringBuilder : : append`
    chains. This was a sub-optimal translation methodology often requiring `StringBuilder`
    presizing.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'JEP 280 是 Java 平台的一个有趣增强。在 Java 9 之前，字符串连接被 javac 转换为 `StringBuilder :: append`
    链。这是一种次优的转换方法，通常需要 `StringBuilder` 预分配大小。'
- en: The enhancement changed the string concatenation bytecode sequence, generated
    by javac, so that it uses `INVOKEDYNAMIC` calls. The purpose of the enhancement
    was to increase optimization and to support future optimizations without the need
    to reformat the javac's bytecode.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 该增强改变了 javac 生成的字符串连接字节码序列，使其使用 `INVOKEDYNAMIC` 调用。增强的目的是提高优化并支持未来的优化，而无需重新格式化
    javac 的字节码。
- en: See JEP 276 for more information on `INVOKEDYNAMIC`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `INVOKEDYNAMIC` 的更多信息，请参阅 JEP 276。
- en: The use of `INVOKEDYAMIC` calls to `java.lang.invoke.StringConcatFactory` allows
    us to use a methodology similar to lambda expressions instead of using StringBuilder's
    step-wise process. This results in more efficient processing of string concatenation.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `INVOKEDYAMIC` 调用 `java.lang.invoke.StringConcatFactory` 允许我们使用类似于 lambda
    表达式的技术，而不是使用 `StringBuilder` 的逐步过程。这导致字符串连接处理更加高效。
- en: HotSpot C++ unit-test framework [JEP 281]
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HotSpot C++ 单元测试框架 [JEP 281]
- en: 'HotSpot is the name of the JVM. This Java enhancement was intended to support
    the development of C++ unit tests for the JVM. Here is a partial, non-prioritized,
    list of goals for this enhancement:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot 是 JVM 的名称。这个 Java 增强旨在支持为 JVM 开发 C++ 单元测试。以下是此增强的某些部分、非优先级列表的目标：
- en: Command-line testing
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行测试
- en: Create appropriate documentation
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建适当的文档
- en: Debug compile targets
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试编译目标
- en: Framework elasticity
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架弹性
- en: IDE support
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE 支持
- en: Individual and isolated unit testing
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独和隔离的单元测试
- en: Individualized test results
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化测试结果
- en: Integrate with existing infrastructure
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有基础设施集成
- en: Internal test support
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部测试支持
- en: Positive and negative testing
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正面和负面测试
- en: Short execution time testing
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短执行时间测试
- en: Support all JDK 9 build platforms
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持所有 JDK 9 构建平台
- en: Test compile targets
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试编译目标
- en: Test exclusion
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试排除
- en: Test grouping
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试分组
- en: Testing that requires the JVM to be initialized
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要初始化 JVM 的测试
- en: Tests co-located with source code
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与源代码位于同一位置
- en: Tests for platform-dependent code
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试平台相关代码
- en: Write and execute unit testing (for classes and methods)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和执行单元测试（对于类和方法）
- en: This enhancement is evidence of the increasing extensibility.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此增强是日益可扩展性的证据。
- en: Enabling GTK 3 on Linux [JEP 283]
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上启用 GTK 3 [JEP 283]
- en: GTK+, formally known as the GIMP toolbox, is a cross-platform tool used for
    creating **Graphical User Interfaces** (**GUI**). The tool consists of widgets
    accessible through its API. JEP 283's focus was to ensure GTK 2 and GTK 3 were
    supported on Linux when developing Java applications with graphical components.
    The implementation supports Java apps that employ JavaFX, AWT, and Swing.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+，正式名称为 GIMP 工具箱，是一个跨平台工具，用于创建 **图形用户界面**（**GUI**）。该工具由其 API 可访问的小部件组成。JEP
    283 的重点是确保在开发具有图形组件的 Java 应用程序时，Linux 上支持 GTK 2 和 GTK 3。实现支持使用 JavaFX、AWT 和 Swing
    的 Java 应用程序。
- en: 'We can create Java graphical applications with JavaFX, AWT, and Swing. Here
    is a table to summarize those three approaches as they relate to GTK, prior to
    Java 9:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaFX、AWT 和 Swing 创建 Java 图形应用程序。以下是一个表格，总结这三个方法与 GTK 的关系，在 Java 9 之前：
- en: '| **Approach** | **Remarks** |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **备注** |'
- en: '| JavaFX |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| JavaFX |'
- en: Uses a dynamic GTK function lookup
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: Interacts with AWT and Swing via JFXPanel
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 JFXPanel 与 AWT 和 Swing 交互
- en: Uses AWT printing functionality
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWT 打印功能
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| AWT |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| AWT |'
- en: Uses a dynamic GTK function lookup
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: '|'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Swing |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| Swing |'
- en: Uses a dynamic GTK function lookup
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'So, what changes were necessary to implement this JEP? For JavaFX, three specific
    things were changed:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为了实现这个 JEP，需要做出哪些改变？对于 JavaFX，有三个具体的变化：
- en: Automated testing was added for both GTK 2 and GTK 3
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GTK 2 和 GTK 3 添加了自动测试
- en: Functionality was added to dynamically load GTK 2
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了动态加载 GTK 2 的功能
- en: Support was added for GTK 3
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了对 GTK 3 的支持
- en: 'For AWT and Swing, the following changes were implemented:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AWT 和 Swing，实施了以下更改：
- en: Automated testing was added for both GTK 2 and GTK 3
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GTK 2 和 GTK 3 添加了自动测试
- en: '`AwtRobot` was migrated to GTK 3'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AwtRobot` 已迁移到 GTK 3'
- en: '`FileChooserDilaog` was updated for GTK 3'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileChooserDilaog` 已更新以支持 GTK 3'
- en: Functionality was added to dynamically load GTK 3
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了动态加载 GTK 3 的功能
- en: The Swing GTK LnF was modified to support GTK 3
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing GTK LnF 已修改以支持 GTK 3
- en: Swing GTK LnF is short for Swing GTK look and feel.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Swing GTK LnF 是 Swing GTK look and feel 的缩写。
- en: New HotSpot build system [JEP 284]
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的 HotSpot 构建系统 [JEP 284]
- en: 'The Java platform used, prior to Java 9, was a build system riddled with duplicate
    code, redundancies, and other inefficiencies. The build system has been reworked
    for Java 9 based on the build-infra framework. In this context, infra is short
    for infrastructure. The overarching goal for JEP 284 was to upgrade the build
    system to one that was simplified. Specific goals included:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前使用的 Java 平台是一个充斥着重复代码、冗余和其他低效的构建系统。该构建系统已根据内置的 build-infra 框架进行了重构。在此上下文中，infra
    是 infrastructure 的缩写。JEP 284 的总体目标是升级构建系统，使其简化。具体目标包括：
- en: Leverage existing build system
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有的构建系统
- en: Maintainable code
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护的代码
- en: Minimize duplicate code
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化重复代码
- en: Simplification
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化
- en: Support future enhancements
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持未来的增强
- en: 'You can learn more about Oracle''s infrastructure framework at this site: [http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html](http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此网站上了解更多关于 Oracle 基础设施框架的信息：[http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html](http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html)
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some impressive new features of the Java platform,
    with specific focus on javac, JDK libraries, and various test suites. Memory management
    improvements, including heap space efficiencies, memory allocation, and improved
    garbage collection represent a powerful new set of Java platform enhancements.
    Changes regarding the compilation process resulting in greater efficiencies were
    part of our chapter. We also covered important improvements, such as with the
    compilation process, type testing, annotations, and automated runtime compiler
    tests.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java 平台的一些令人印象深刻的新特性，特别关注 javac、JDK 库和各种测试套件。内存管理改进，包括堆空间效率、内存分配和改进的垃圾回收，代表了一组强大的
    Java 平台增强。关于编译过程的更改，导致更高的效率，也是我们章节的一部分。我们还介绍了重要的改进，如编译过程、类型测试、注解和自动运行时编译器测试。
- en: In the next chapter, we will look at several minor language enhancements introduced
    in Java 9.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Java 9 中引入的几个小的语言增强。
