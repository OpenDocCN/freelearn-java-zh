- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: JDBC-based Authentication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于JDBC的认证
- en: 'In the previous chapter, we saw how we can extend Spring Security to utilize
    our `CalendarDao` interface and our existing domain model to authenticate users.
    In this chapter, we will see how we can use Spring Security’s built-in JDBC support.
    To keep things simple, this chapter’s sample code is based on our Spring Security
    setup from [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with
    Spring Security*. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何扩展Spring Security以利用我们的`CalendarDao`接口和现有的领域模型来认证用户。在本章中，我们将看到如何使用Spring
    Security的内置JDBC支持。为了保持简单，本章的示例代码基于我们从[*第2章*](B21757_02.xhtml#_idTextAnchor043)继承的Spring
    Security设置，*Spring Security入门*。在本章中，我们将涵盖以下主题：
- en: Using Spring Security’s built-in JDBC-based authentication support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security内置的基于JDBC的认证支持
- en: Utilizing Spring Security’s group-based authorization to make administering
    users easier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Spring Security的基于组的授权来简化用户管理
- en: Learning how to use Spring Security’s UserDetailsManager interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Spring Security的UserDetailsManager接口
- en: Configuring Spring Security to utilize the existing CalendarUser schema to authenticate
    users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以利用现有的CalendarUser模式进行用户认证
- en: Learning how we can secure passwords using Spring Security’s new cryptography
    module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Spring Security的新加密模块来安全地存储密码
- en: Using Spring Security’s default JDBC authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security的默认JDBC认证
- en: If your application has not yet implemented security, or if your security infrastructure
    is using a database, Spring Security provides out-of-the-box support that can
    simplify the solving of your security needs. Spring Security provides a default
    schema for users, authorities, and groups. If that does not meet your needs, it
    allows for the querying and managing of users to be customized. In the next section,
    we are going to go through the basic steps for setting up JDBC authentication
    with Spring Security.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序尚未实现安全功能，或者您的安全基础设施正在使用数据库，Spring Security提供开箱即用的支持，可以简化解决您的安全需求。Spring
    Security为用户、权限和组提供默认模式。如果这不符合您的需求，它允许自定义查询和管理用户。在下一节中，我们将介绍使用Spring Security设置JDBC认证的基本步骤。
- en: 'This chapter''s code in action link is here: [https://packt.link/of0XA](https://packt.link/of0XA).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的实际链接在此：[https://packt.link/of0XA](https://packt.link/of0XA)。
- en: Installing the required dependencies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的依赖项
- en: Our application has already defined all the necessary dependencies required
    for this chapter. However, if you are using Spring Security’s JDBC support, you
    are likely going to want the following dependencies listed in your `build.gradle`
    file. It is important to highlight that the JDBC driver that you will use will
    depend on which database you are using. Consult your database vendor’s documentation
    for details on which driver is needed for your database.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经定义了本章所需的所有必要依赖项。然而，如果您正在使用Spring Security的JDBC支持，您可能希望在`build.gradle`文件中列出以下依赖项。重要的是要强调，您将使用的JDBC驱动程序将取决于您正在使用的数据库。请咨询您的数据库供应商的文档，以获取有关您数据库所需驱动程序的详细信息。
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Remember that all the Spring versions need to match, and all Spring Security
    versions need to match (this includes transitive dependency versions). If you
    are having difficulty getting this to work in your own application, you may want
    to define the dependency management section in `build.gradle` to enforce this,
    as shown in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*. As previously mentioned, you will not need to worry about
    this when using the sample code, since we have already set up the necessary dependencies
    for you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有Spring版本都需要匹配，所有Spring Security版本也需要匹配（这包括传递依赖项版本）。如果您在自己的应用程序中遇到困难，您可能希望在`build.gradle`中定义依赖项管理部分以强制执行此操作，如[*第2章*](B21757_02.xhtml#_idTextAnchor043)中所示，*Spring
    Security入门*。如前所述，当使用示例代码时，您无需担心这一点，因为我们已经为您设置了必要的依赖项。
- en: 'The following snippet defines the required dependencies needed for this chapter,
    including Spring Security and JDBC dependencies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段定义了本章所需的依赖项，包括Spring Security和JDBC依赖项：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main change here of the `build.gradle`, is to add the `spring-boot-starter-data-jdbc`
    dependency, to enable the Spring JDBC support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`中的主要更改是添加`spring-boot-starter-data-jdbc`依赖项，以启用Spring JDBC支持。
- en: Using the H2 database
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H2数据库
- en: The first portion of this exercise involves setting up an instance of the Java-based
    H2 which is an open-source, in-memory and embedded relational database written
    in Java. It is designed to be fast, lightweight, and easy to use. H2 database
    will be populated with the Spring Security default schema. We’ll configure H2
    to run in memory using Spring’s `EmbeddedDatabase` configuration feature a significantly
    simpler method of configuration than setting up the database by hand. You can
    find additional information on the H2 website at [http://www.h2database.com/](http://www.h2database.com/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的第一部分涉及设置Java基础的H2实例，这是一个用Java编写的开源、内存和嵌入式关系型数据库。它设计得快速、轻量级且易于使用。H2数据库将填充Spring
    Security默认的模式。我们将使用Spring的`EmbeddedDatabase`配置功能配置H2在内存中运行，这是一种比手动设置数据库显著更简单的配置方法。你可以在H2网站上找到更多信息：[http://www.h2database.com/](http://www.h2database.com/)。
- en: Keep in mind that in our sample application, we’ll primarily use H2 due to its
    ease of setup. Spring Security will work with any database that supports ANSI
    SQL out of the box. We encourage you to tweak the configuration and use the database
    of your preference if you’re following along with the examples. As we didn’t want
    this portion of the book to focus on the complexities of database setup, we chose
    convenience over realism for the purpose of the exercises.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的示例应用程序中，我们主要使用H2，因为它易于设置。Spring Security可以与任何支持ANSI SQL的数据库无缝工作。我们鼓励你在跟随示例时调整配置并使用你偏好的数据库。由于我们不想让这本书的这一部分专注于数据库设置的复杂性，我们选择了便利性而不是现实性来设计练习。
- en: In the following subsections, we will provide sample SQL scripts for our JBCP
    Calendar application. The scripts will be configured using H2 embedded database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将提供我们的JBCP日历应用程序的示例SQL脚本。这些脚本将使用H2嵌入式数据库进行配置。
- en: Finally, we will enable the spring-security support, we will have to add a custom
    implementation of `UserDetailsManager`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将启用spring-security支持，我们需要添加一个自定义的`UserDetailsManager`实现。
- en: Provided JDBC scripts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供的JDBC脚本
- en: We’ve supplied all the SQL files that are used for creating the schema and data
    in an H2 database for this chapter in the `src/main/resources/database/h2/` folder.
    Any files prefixed with `calendar` are custom SQL files for the JBCP calendar
    application. Hopefully, this will make running the samples a little easier. If
    you’re following along with your own database instance, you may have to adjust
    the schema definition syntax to fit your particular database. Additional database
    schemas can be found in the Spring Security reference. You can find a link to
    the Spring Security Reference in the book’s [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将用于创建H2数据库中模式和数据的所有SQL文件提供在了`src/main/resources/database/h2/`文件夹中。任何以`calendar`开头的前缀文件都是JBCP日历应用的定制SQL文件。希望这会使运行示例变得稍微容易一些。如果你正在跟随自己的数据库实例，你可能需要调整模式定义语法以适应你的特定数据库。额外的数据库模式可以在Spring
    Security参考文档中找到。你可以在书籍的[*附录*](B21757_20.xhtml#_idTextAnchor642)中找到Spring Security参考的链接，*附加*
    *参考资料*。
- en: Configuring the H2 embedded database
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置H2嵌入式数据库
- en: 'To configure the H2 embedded database, we need to create a `DataSource` and
    run SQL to create the Spring Security table structure. We will need to update
    the SQL that is loaded at startup to include Spring Security’s basic schema definition,
    Spring Security user definitions, and the authority mappings for users. You can
    find the `DataSource` definition and the relevant updates in the following code
    snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置H2嵌入式数据库，我们需要创建一个`DataSource`并运行SQL来创建Spring Security表结构。我们需要更新启动时加载的SQL，包括Spring
    Security的基本模式定义、Spring Security用户定义和用户的权限映射。你可以在以下代码片段中找到`DataSource`定义和相关的更新：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that the `EmbeddedDatabaseBuilder()` method creates this database only
    in memory, so you won’t see anything on the disk, and you won’t be able to use
    standard tools to query it. However, you can use the H2 console that is embedded
    in the application to interact with the database. See the instructions on the
    **Welcome** page of our application to learn how to use it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`EmbeddedDatabaseBuilder()`方法仅在内存中创建此数据库，因此你不会在磁盘上看到任何东西，并且你无法使用标准工具来查询它。然而，你可以使用应用程序内嵌入的H2控制台与数据库交互。查看我们应用程序的**欢迎**页面上的说明，了解如何使用它。
- en: Configuring a JDBC UserDetailsManager implementation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置JDBC UserDetailsManager实现
- en: 'We’ll modify the `SecurityConfig.java` file to declare that we’re using a JDBC
    `User` **DetailsManager** implementation, instead of the Spring Security in-memory
    `User` **DetailsService** implementation that we configured in[*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. This is done with a simple change to the
    `UserDetailsManager` declaration, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 `SecurityConfig.java` 文件，声明我们使用的是 JDBC `User` **DetailsManager** 实现，而不是我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)中配置的
    Spring Security 内存 `User` **DetailsService** 实现，即 *Spring Security 入门*。这是通过简单更改
    `UserDetailsManager` 声明来实现的，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We replace the previous `configure(AuthenticationManagerBuilder)` method, along
    with all of the child elements, with the `userDetailsService()` method, as shown
    in the preceding code snippet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `userDetailsService()` 方法替换了之前的 `configure(AuthenticationManagerBuilder)`
    方法以及所有子元素，如前述代码片段所示。
- en: In this section, we have been able to configure H2 database with custom `UserDetailsManager`
    implementation, to enable Spring Security support.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经能够使用自定义 `UserDetailsManager` 实现配置 H2 数据库，以启用 Spring Security 支持。
- en: The default user schema of Spring Security
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 的默认用户模式
- en: 'Let’s take a look at each of the SQL files used to initialize the database.
    The first script we added contains the default Spring Security schema definition
    for users and their authorities. The following script has been adapted from Spring
    Security’s Reference, which is listed in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material* to have explicitly named constraints, to make
    troubleshooting easier:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下初始化数据库所使用的每个 SQL 文件。我们添加的第一个脚本包含了默认的 Spring Security 用户模式和权限定义。下面的脚本已经从
    Spring Security 的参考中改编，该参考列在[*附录*](B21757_20.xhtml#_idTextAnchor642)中，*附加参考资料*，以具有明确命名的约束，以便更容易进行故障排除：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining users
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户
- en: 'The next script is in charge of defining the users in our application. The
    included SQL statement creates the same users that we have used throughout the
    entire book so far. The file also adds an additional user, `disabled1@example.com`,
    who will not be able to log in since we indicate the user as disabled:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本负责定义我们应用程序中的用户。包含的 SQL 语句创建了我们在整本书中一直使用的相同用户。该文件还添加了一个额外的用户 `disabled1@example.com`，由于我们指示该用户已被禁用，因此该用户将无法登录：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining user authorities
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户权限
- en: 'You may have noticed that there is no indication if a user is an administrator
    or a regular user. The next file specifies a direct mapping of the user to the
    corresponding authorities. If a user did not have an authority mapped to it, Spring
    Security would not allow that user to be logged in:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，没有指示说明一个用户是管理员还是普通用户。下一个文件指定了用户到相应权限的直接映射。如果一个用户没有映射到任何权限，Spring Security
    将不允许该用户登录：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the SQL is added to the embedded database configuration, we should be
    able to start the application and log in. Try logging in with the new user using
    `disabled1@example.com` as the `username` and `disabled1` as the `password`. Notice
    that Spring Security does not allow the user to log in and provides the error
    message `Reason: User` `is disabled`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 SQL 添加到嵌入式数据库配置之后，我们应该能够启动应用程序并登录。尝试使用 `disabled1@example.com` 作为 `username`
    和 `disabled1` 作为 `password` 登录新用户。注意，Spring Security 不允许用户登录，并提供了错误信息 `原因：用户被禁用`。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.01-calendar`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像这样：`calendar04.01-calendar`。
- en: In this section, we have used the default Spring Security user schema and authorities.
    In the next section, we will explore how we can define **Group Based Access**
    **Control** (**GBAC**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了默认的 Spring Security 用户模式和权限。在下一节中，我们将探讨如何定义 **基于组的访问控制**（**GBAC**）。
- en: Exploring UserDetailsManager interface
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 UserDetailsManager 接口
- en: We have already leveraged the `InMemoryUserDetailsManager` class in Spring Security
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*, to
    look up the current `CalendarUser` application in our `SpringSecurityUserContext`
    implementation of `UserContext`. This allowed us to determine which `CalendarUser`
    should be used when looking up the events for the `DefaultCalendarService.java`
    file to utilize `InMemoryUserDetailsManager`, to ensure that we created a new
    Spring Security user when we created `CalendarUser`. This chapter reuses exactly
    the same code. The only difference is that the `UserDetailsManager` implementation
    is backed by the `JdbcUserDetailsManager` class of Spring Security, which uses
    a database instead of an in-memory datastore.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第3章*](B21757_03.xhtml#_idTextAnchor068)，*自定义认证* 中利用了 Spring Security
    的 `InMemoryUserDetailsManager` 类，在我们的 `SpringSecurityUserContext` 实现 `UserContext`
    中查找当前的 `CalendarUser` 应用程序。这允许我们确定在查找 `DefaultCalendarService.java` 文件的事件时应该使用哪个
    `CalendarUser`，以确保在创建 `CalendarUser` 时创建一个新的 Spring Security 用户。本章重复使用完全相同的代码。唯一的不同之处在于，`UserDetailsManager`
    的实现由 Spring Security 的 `JdbcUserDetailsManager` 类支持，该类使用数据库而不是内存数据存储。
- en: What other features does `UserDetailsManager` provide out of the box?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDetailsManager` 还提供了哪些开箱即用的功能？'
- en: 'Although these types of functions are relatively easy to write with additional
    JDBC statements, Spring Security actually provides out-of-the-box functionality
    to support many common **Create, Read, Update, and Delete** (**CRUD**) operations
    on users in JDBC databases. This can be convenient for simple systems, and a good
    base to build on for any custom requirements that a user may have:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些类型的函数可以通过额外的 JDBC 语句相对容易地编写，但 Spring Security 实际上提供了一些开箱即用的功能来支持在 JDBC 数据库上对用户执行许多常见的
    **创建、读取、更新和删除** （**CRUD**）操作。这对于简单的系统来说可能很方便，并且是构建任何用户可能需要的自定义要求的好基础：
- en: '| **Method** | **Description** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `void` `createUser(UserDetails user)` | It creates a new user with the given
    `UserDetails` information, including any declared `GrantedAuthority` authorities.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `void` `createUser(UserDetails user)` | 它使用给定的 `UserDetails` 信息创建一个新用户，包括任何声明的
    `GrantedAuthority` 权限。 |'
- en: '| `void updateUser(final` `UserDetails user)` | It updates a user with the
    given `UserDetails` information. It updates `GrantedAuthority` and removes the
    user from the user cache. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `void updateUser(final` `UserDetails user)` | 它使用给定的 `UserDetails` 信息更新一个用户。它更新
    `GrantedAuthority` 并从用户缓存中删除用户。 |'
- en: '| `void` `deleteUser(String username)` | It deletes the user with the given
    username and removes the user from the user cache. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `void` `deleteUser(String username)` | 它删除具有给定用户名的用户，并从用户缓存中删除用户。 |'
- en: '| `boolean` `userExists(String username)` | It indicates whether or not a user
    (active or inactive) exists with the given username. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` `userExists(String username)` | 它指示是否有一个具有给定用户名的用户（活动或非活动）存在。 |'
- en: '| `void changePassword(String oldPassword,` `String` `newPassword)` | It changes
    the password of the currently logged-in user. The user must then supply the correct
    password in order for the operation to succeed. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `void changePassword(String oldPassword,` `String` `newPassword)` | 它更改当前登录用户的密码。用户必须提供正确的密码才能使操作成功。
    |'
- en: Table 4.1 – Custom database requirements settings
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 自定义数据库要求设置
- en: If `UserDetailsManager` does not provide all the methods that are necessary
    for your application, you can extend the interface to provide these custom requirements.
    For example, if you needed the ability to list all of the possible users in an
    administrative view, you could write your own interface with this method and provide
    an implementation that points to the same datastore as the `UserDetailsManager`
    implementation you are currently using.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `UserDetailsManager` 没有提供您应用程序所需的所有方法，您可以扩展该接口以提供这些自定义要求。例如，如果您需要能够在管理视图中列出所有可能的用户，您可以编写自己的接口并实现一个指向您当前使用的
    `UserDetailsManager` 实现相同数据存储的实现。
- en: Group-based access control
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组的访问控制
- en: The `JdbcUserDetailsManager` class supports the ability to add a level of indirection
    between the users and the `GrantedAuthority` declarations by grouping `GrantedAuthority`
    into logical sets called groups.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcUserDetailsManager` 类支持通过将 `GrantedAuthority` 分组到称为组的逻辑集合中，在用户和 `GrantedAuthority`
    声明之间添加一层间接性。'
- en: 'Users are then assigned one or more groups, and their membership confers a
    set of the `Granted``Authority` declarations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用户被分配一个或多个组，他们的成员资格赋予了一组 `GrantedAuthority` 声明：
- en: '![Figure 4.1 – Group-based access control sample](img/B21757_04_1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 基于组的访问控制示例](img/B21757_04_1.jpg)'
- en: Figure 4.1 – Group-based access control sample
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 基于组的访问控制示例
- en: As you can see in the preceding diagram, this indirection allows the assignment
    of the same set of roles to multiple users, by simply assigning any new users
    to existing groups. This is different behavior that we’ve seen so far, where previously
    we assigned `GrantedAuthority` directly to individual users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到，这种间接性允许通过简单地将任何新用户分配到现有组来将同一组角色分配给多个用户。这与我们迄今为止看到的不同，我们之前直接将 `GrantedAuthority`
    分配给单个用户。
- en: 'This bundling of common sets of authorities can be helpful in the following
    scenarios:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将常见权限集捆绑起来的做法在以下场景中可能很有帮助：
- en: You need to segregate users into communities, with some overlapping roles between
    groups.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要将用户隔离到社区中，组之间存在一些重叠的角色。
- en: You want to globally change the authorization for a class of user. For example,
    if you have a supplier group, you might want to enable or disable their access
    to particular portions of the application.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想全局更改一类用户的授权。例如，如果您有一个供应商组，您可能希望启用或禁用他们对应用程序特定部分的访问。
- en: You have a large number of users, and you don’t need user-level authority configuration.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有大量用户，并且不需要用户级权限配置。
- en: Unless your application has a very small user base, there is a very high likelihood
    that you’ll be using group-based access control. While group-based access control
    is slightly more complex than other strategies, the flexibility and simplicity
    of managing a user’s access makes this complexity worthwhile. This indirect technique
    of aggregating user privileges by group is commonly referred to as GBAC.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的应用程序用户基数非常小，否则您很可能正在使用基于组的访问控制。虽然基于组的访问控制比其他策略稍微复杂一些，但管理用户访问的灵活性和简单性使这种复杂性变得值得。这种通过组聚合用户权限的间接技术通常被称为
    GBAC。
- en: GBAC is an approach common to almost every secured operating system or software
    package on the market. **Microsoft Active Directory** (**AD**) is one of the most
    visible implementations of large-scale GBAC, due to its design of slotting AD
    users into groups and assigning privileges to those groups. Management of privileges
    in large AD-based organizations is made exponentially simpler through the use
    of GBAC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: GBAC 是市场上几乎每个受保护操作系统或软件包中常见的做法。**Microsoft Active Directory**（**AD**）是大型 GBAC
    的最明显实现之一，因为它将 AD 用户放入组中并为这些组分配权限。通过使用 GBAC，大型基于 AD 的组织中的权限管理变得指数级简单。
- en: Try to think of the security models of the software you use—how are the users,
    groups, and privileges managed? What are the pros and cons of the way the security
    model is written?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试思考您使用的软件的安全模型——用户、组和权限是如何管理的？安全模型编写的方式有哪些优缺点？
- en: Let’s add a level of abstraction to the JBCP calendar application and apply
    the concept of group-based authorization to the site.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 JBCP 日历应用程序中添加一层抽象，并将基于组的授权概念应用于网站。
- en: Configuring group-based access control
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置基于组的访问控制
- en: 'We’ll add two groups to the application: regular users, which we’ll call `Users`,
    and administrative users, which we’ll call `Administrators`. Our existing accounts
    will be associated with the appropriate groups through an additional SQL script.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向应用程序添加两个组：普通用户，我们将其称为 `Users`，以及管理员用户，我们将其称为 `Administrators`。我们的现有账户将通过一个额外的
    SQL 脚本与适当的组关联。
- en: Configuring JdbcUserDetailsManager to use groups
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 JdbcUserDetailsManager 以使用组
- en: 'By default, Spring Security does not use GBAC. Therefore, we must instruct
    Spring Security to enable the use of groups. Modify the `SecurityConfig.java`
    file to use `GROUP_AUTHORITIES_BY_USERNAME_QUERY`, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Security 不使用 GBAC。因此，我们必须指示 Spring Security 启用组的使用。修改 `SecurityConfig.java`
    文件以使用 `GROUP_AUTHORITIES_BY_USERNAME_QUERY`，如下所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Utilizing GBAC JDBC scripts
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 GBAC JDBC 脚本
- en: 'Next, we need to update the scripts that are being loaded at startup. We need
    to remove the `security-user-authorities.sql` mapping so that our users no longer
    obtain their authorities with direct mapping. We then need to add two additional
    SQL `scripts`. Update the `DataSource` bean configuration to load the SQL required
    for GBAC, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新启动时加载的脚本。我们需要删除 `security-user-authorities.sql` 映射，以便我们的用户不再通过直接映射获得其权限。然后我们需要添加两个额外的
    SQL `脚本`。更新 `DataSource` 实例配置以加载 GBAC 所需的 SQL，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The group-based schema
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于组的模式
- en: 'It may be obvious, but the first SQL file we added contains updates to the
    schema to support group-based authorization. You can find the contents of the
    file in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很明显，但我们添加的第一个SQL文件包含了对模式的支持以支持基于组的授权的更新。您可以在以下代码片段中找到文件的内容：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Group authority mappings
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组权限映射
- en: 'Now we need to map our existing users to groups, and the groups to authorities.
    This is done in the `security-groups-mappings.sql` file. Mapping based on groups
    can be convenient because often, organizations already have a logical group of
    users for various reasons. By utilizing the existing groupings of users, we can
    drastically simplify our configuration. This is how a layer of indirection helps
    us. We have included the group definitions, group to authority mappings, and a
    few users in the following group mapping:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将现有用户映射到组，将组映射到权限。这是在`security-groups-mappings.sql`文件中完成的。基于组的映射可以很方便，因为组织通常已经根据各种原因有一个逻辑用户组。通过利用现有的用户分组，我们可以极大地简化我们的配置。这就是间接层如何帮助我们。我们在以下组映射中包含了组定义、组到权限映射和一些用户：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Go ahead and start the application, and it will behave just as before; however,
    the additional layer of abstraction between the users and roles simplifies the
    managing of large groups of users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开始启动应用程序，它将表现得和以前一样；然而，用户和角色之间的额外抽象层简化了管理大量用户。
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.02-calendar`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.02-calendar`。
- en: After exploring in this section how we can define GBAC, we will define in the
    following section a custom database queries to retrieve users and authorities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何定义GBAC之后，将在下一节中定义一个自定义数据库查询来检索用户和权限。
- en: Support for a custom schema
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持自定义模式
- en: It’s common for new users of Spring Security to begin their experience by adapting
    the JDBC user, group, or role mapping to an existing schema. Even though a legacy
    database doesn’t conform to the expected Spring Security schema, we can still
    configure `JdbcDaoImpl` to map to it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Spring Security的新用户来说，通常是通过将JDBC用户、组或角色映射到现有模式来开始他们的体验。即使遗留数据库不符合预期的Spring
    Security模式，我们仍然可以配置`JdbcDaoImpl`来映射到它。
- en: We will now update Spring Security’s JDBC support to use our existing `CalendarUser`
    database along with a new `calendar_authorities` table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新Spring Security的JDBC支持，以使用我们现有的`CalendarUser`数据库以及一个新的`calendar_authorities`表。
- en: We can easily change the configuration of `JdbcUserDetailsManager` to utilize
    this schema and override Spring Security’s expected table definitions and columns,
    which we’re using for the JBCP calendar application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地更改`JdbcUserDetailsManager`的配置，以利用此模式并覆盖我们用于JBCP日历应用程序的Spring Security预期的表定义和列。
- en: In the following subsections, we will update the SQL user and authorities scripts
    to insert custom roles. At the end, we will configure `JdbcUserDetailsManager`
    to use this custom SQL queries.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将更新SQL用户和权限脚本以插入自定义角色。最后，我们将配置`JdbcUserDetailsManager`以使用这些自定义SQL查询。
- en: Determining the correct JDBC SQL queries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定正确的JDBC SQL查询
- en: 'The `JdbcUserDetailsManager` class has three SQL queries that have a well-defined
    parameter and a set of returned columns. We must determine the SQL that we’ll
    assign to each of these queries, based on the intended functionality. Each SQL
    query used by `JdbcUserDetailsManager` takes the username presented at login as
    its one and only parameter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcUserDetailsManager`类有三个具有明确定义参数和一组返回列的SQL查询。我们必须根据预期的功能确定我们将分配给这些查询的SQL。`JdbcUserDetailsManager`使用的每个SQL查询都以其在登录时提供的用户名作为其唯一参数：'
- en: '| **Namespace query** **attribute name** | **Description** | **Expected** **SQL
    columns** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间查询** **属性名** | **描述** | **预期** **SQL列** |'
- en: '| `users-by-username-query` | Returns one ormore usersmatching theusername;
    only thefirst user is used. | `Username (string)``Password (string)``Enabled (Boolean)`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `users-by-username-query` | 返回一个或多个匹配用户名的用户；仅使用第一个用户。 | `Username (字符串)`
    `Password (字符串)` `Enabled (布尔值)` |'
- en: '| `authorities-by-username-query` | Returns one or more granted authorities
    directly provided to the user. Typically used when GBAC is disabled. | `Username
    (string)` `GrantedAuthority (string)` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `authorities-by-username-query` | 返回直接提供给用户的授权权限。通常在GBAC禁用时使用。 | `Username
    (字符串)` `GrantedAuthority (字符串)` |'
- en: '| `group-authorities-by-username-query` | Returns grantedauthorities andgroup
    detailsprovided to theuser through groupmembership. Usedwhen GBAC is enabled.
    | `Group` `Primary Key``(``any)``Group` `Name (any)``GrantedAuthority (string)`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `group-authorities-by-username-query` | 返回通过组成员关系授予用户的 grantedauthorities
    和组详情。当启用 GBAC 时使用。 | `Group` `主键``(``任何)``Group` `名称 (任何)``GrantedAuthority (字符串)`
    |'
- en: Table 4.2 – JDBC queries in spring-security
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 – Spring-security 中的 JDBC 查询
- en: Be aware that in some cases, the return columns are not used by the default
    `JdbcUserDetailsManager` implementation, but they must be returned anyway.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下，默认的 `JdbcUserDetailsManager` 实现可能没有使用返回的列，但仍然必须返回它们。
- en: Updating the SQL scripts that are loaded
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新加载的 SQL 脚本
- en: 'We need to initialize the `DataSource` with our custom schema, rather than
    with Spring Security’s default schema. Update the `DataSourceConfig.java` file,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用我们的自定义模式而不是 Spring Security 的默认模式来初始化 `DataSource`。按照以下方式更新 `DataSourceConfig.java`
    文件：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we have removed all of the scripts that start with security and
    replaced them with `calendar-authorities.sql`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经移除了所有以安全开头的脚本，并用 `calendar-authorities.sql` 替换它们。
- en: The CalendarUser authority SQL
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日历用户权限 SQL
- en: 'You can view the `CalendarUser` authority mappings in the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码片段中查看 `CalendarUser` 权限映射：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that we use the id as the foreign key, which is better than utilizing
    the username as a foreign key (as Spring Security does). By using the id as the
    foreign key, we can allow users to easily change their username.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 ID 作为外键，这比使用用户名作为外键（如 Spring Security 所做的那样）更好。通过使用 ID 作为外键，我们可以允许用户轻松更改他们的用户名。
- en: Inserting custom authorities
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入自定义权限
- en: 'We need to update `DefaultCalendarService` to insert the authorities for the
    user using our custom schema when we add a new `CalendarUser` class. This is because
    while we reused the schema for the user definition, we did not define custom authorities
    in our existing application. Update `DefaultCalendarService`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加新的 `CalendarUser` 类时，我们需要更新 `DefaultCalendarService` 以使用我们的自定义模式插入用户的权限。这是因为虽然我们重用了用户定义的模式，但我们在现有应用程序中没有定义自定义权限。按照以下方式更新
    `DefaultCalendarService`：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may have noticed the `JdbcOperations` interface that is used for inserting
    our user. This is a convenient template provided by Spring that helps manage boilerplate
    code, such as connection and transaction handling. For more details, refer to
    the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*
    of this book to find the Spring Reference.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了用于插入我们的用户的 `JdbcOperations` 接口。这是 Spring 提供的一个方便的模板，有助于管理样板代码，例如连接和事务处理。有关更多详细信息，请参阅本书的
    [*附录*](B21757_20.xhtml#_idTextAnchor642)，*附加参考资料*，以找到 Spring 参考。
- en: Configuring JdbcUserDetailsManager to use custom SQL queries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 JdbcUserDetailsManager 使用自定义 SQL 查询
- en: 'In order to use custom SQL queries for our non-standard schema, we’ll simply
    update our `userDetailsService()` method to include new queries. This is quite
    similar to how we enabled support for GBAC, except instead of using the default
    SQL, we will use our modified SQL. Notice that we remove our old `setGroupAuthoritiesByUsernameQuery()`
    method call, since we will not be using it in this example, in order to keep things
    simple:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用针对非标准模式的自定义 SQL 查询，我们将简单地更新我们的 `userDetailsService()` 方法以包含新的查询。这与我们启用 GBAC
    支持的方式非常相似，除了我们使用的是修改后的 SQL 而不是默认 SQL。请注意，我们移除了旧的 `setGroupAuthoritiesByUsernameQuery()`
    方法调用，因为我们在这个示例中不会使用它，以保持事情简单：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the only configuration required to use Spring Security to read settings
    from an existing, non-default schema! Start up the application and ensure that
    everything is working properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 Spring Security 从现有非默认模式读取设置所需的唯一配置！启动应用程序并确保一切运行正常。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.03-calendar`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.03-calendar`。
- en: Keep in mind that the utilization of an existing schema commonly requires an
    extension of `JdbcUserDetailsManager` to support the changing of passwords, the
    renaming of user accounts, and other user-management functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用现有模式通常需要扩展 `JdbcUserDetailsManager` 以支持更改密码、重命名用户账户和其他用户管理功能。
- en: If you are using `JdbcUserDetailsManager` to perform user-management tasks,
    then there are over 20 SQL queries utilized by the class that are accessible through
    the configuration. However, only the three covered are available through the namespace
    configuration. Please refer to the Javadoc or source code to review the defaults
    for the queries used by `JdbcUserDetailsManager`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`JdbcUserDetailsManager`执行用户管理任务，那么该类使用了超过20个SQL查询，这些查询可以通过配置访问。然而，只有三个在命名空间配置中可用。请参阅Javadoc或源代码以查看`JdbcUserDetailsManager`使用的查询的默认值。
- en: Configuring secure passwords
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置安全密码
- en: You might recall from the security audit in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, that the security of passwords stored in cleartext
    was a top priority of the auditors. In fact, in any secured system, password security
    is a critical aspect of trust and authoritativeness of an authenticated principal.
    Designers of a fully secured system must ensure that passwords are stored in a
    way in which malicious users would have an impractically difficult time compromising
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得从[*第一章*](B21757_01.xhtml#_idTextAnchor015)《不安全应用程序解剖》中的安全审计，密码以明文形式存储的安全性是审计员的首要任务。事实上，在任何安全系统中，密码安全都是认证主体的信任和权威性的关键方面。完全安全系统的设计者必须确保密码以恶意用户难以攻破的方式存储。
- en: 'The following general rules should be applied to passwords stored in a database:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应将该以下一般规则应用于数据库中存储的密码：
- en: Passwords must not be stored in cleartext (plaintext)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码不得以明文（plaintext）形式存储
- en: Passwords supplied by the user must be compared to the recorded passwords in
    the database
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的密码必须与数据库中记录的密码进行比较
- en: A user’s password should not be supplied to the user upon demand (even if the
    user forgets it)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密码不应在用户要求时提供（即使用户忘记了）
- en: For the purposes of most applications, the best fit for these requirements involves
    one-way encoding, known as the **hashing** of the passwords. Using a cryptographic
    hash provides properties such as security and uniqueness that are important to
    properly authenticate users, with the added bonus that once it is hashed, the
    password cannot be extracted from the value that is stored.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序而言，满足这些要求的最合适的方法涉及单向编码，即密码的**哈希**。使用加密哈希提供了诸如安全性和唯一性等属性，这对于正确验证用户非常重要，而且还有一个额外的优点，即一旦哈希，密码就不能从存储的值中提取出来。
- en: In most secure application designs, it is neither required nor desirable to
    ever retrieve the user’s actual password upon request, as providing the user’s
    password to them without the proper additional credentials could present a major
    security risk. Instead, most applications provide the user the ability to reset
    their password, either by presenting additional credentials (such as their social
    security number, date of birth, tax ID, or other personal information), or through
    an email-based system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数安全的应用程序设计中，在请求时检索用户的实际密码既不是必需的，也不是所希望的，因为在不适当的额外凭证的情况下向用户提供密码可能会带来重大的安全风险。相反，大多数应用程序提供用户重置密码的能力，无论是通过提供额外的凭证（如他们的社会保险号码、出生日期、税务ID或其他个人信息），还是通过基于电子邮件的系统。
- en: Storing other types of sensitive information
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 存储其他类型的敏感信息
- en: Many of the guidelines listed that apply to passwords apply equally to other
    types of sensitive information, including social security numbers and credit card
    information (although, depending on the application, some of these may require
    the ability to decrypt). Storing this type of information to represent it in multiple
    ways, for example, a customer’s full 16-digit credit card number, would be stored
    in a highly encrypted form, but the last four digits might be stored in cleartext.
    For reference, think of any internet commerce site that displays `XXXX XXXX XXXX
    1234` to help you identify your stored credit cards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的许多适用于密码的指南同样适用于其他类型的敏感信息，包括社会保险号码和信用卡信息（尽管，根据应用程序的不同，其中一些可能需要解密的能力）。存储此类信息以以多种方式表示，例如，客户的完整16位信用卡号可能会以高度加密的形式存储，但最后四位可能以明文形式存储。为了参考，想想任何显示`XXXX
    XXXX XXXX 1234`以帮助您识别存储的信用卡的互联网商业网站。
- en: You may already be thinking ahead and wondering, given our admittedly unrealistic
    approach of using SQL to populate our H2 database with users, how do we encode
    the passwords? H2, or most other databases for that matter, don’t offer encryption
    methods as built-in database functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在思考，鉴于我们承认的不切实际的方法，即使用 SQL 填充我们的 H2 数据库中的用户，我们如何对密码进行编码？H2 或其他大多数数据库都没有提供作为内置数据库功能的加密方法。
- en: Typically, the bootstrap process (populating a system with initial users and
    data) is handled through a combination of SQL loads and Java code. Depending on
    the complexity of your application, this process can get very complicated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，引导过程（通过 SQL 加载和 Java 代码将初始用户和数据填充到系统中）是通过 SQL 加载和 Java 代码的组合来处理的。根据应用程序的复杂性，这个过程可能会变得非常复杂。
- en: For the JBCP calendar application, we’ll retain the `dataSource()` bean declaration
    and `DataSource` is a name in code in the corresponding SQL, and then add some
    SQL that will modify the passwords to their hashed values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JBCP 日历应用程序，我们将保留 `dataSource()` 象声明，并在相应的 SQL 代码中将 `DataSource` 作为名称，然后添加一些
    SQL 语句，将密码修改为它们的散列值。
- en: We have seen in this section the best practices for configuring secure password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了配置安全密码的最佳实践。
- en: In the following section, we will deep dive into the different options to configure
    secured passwords using the `PasswordEncoder` interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨使用 `PasswordEncoder` 接口配置安全密码的不同选项。
- en: Exploring the PasswordEncoder interface
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 PasswordEncoder 接口
- en: 'Password hashing in Spring Security is encapsulated and defined by implementations
    of the `o.s.s.authentication.encoding.PasswordEncoder` interface. The simple configuration
    of a password encoder is possible through the `createDelegatingPasswordEncoder()`
    method within the `PasswordEncoderFactories` element, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 中的密码散列封装并由 `o.s.s.authentication.encoding.PasswordEncoder` 接口的实现定义。通过
    `PasswordEncoderFactories` 元素内的 `createDelegatingPasswordEncoder()` 方法可以简单地配置密码编码器，如下所示：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll be happy to learn that Spring Security ships with a number of implementations
    of `passwordEncoder`, which are applicable for different needs and security requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很高兴地了解到，Spring Security 随带了许多 `passwordEncoder` 的实现，这些实现适用于不同的需求和安全性要求。
- en: The following table provides a list of the out-of-the-box implementation classes
    and their benefits.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下表提供了一组开箱即用的实现类及其优点。
- en: We can find the complete list of supported encoders in spring security in the
    `Password` **EncoderFactories** class. If one of these matches our requirement,
    we don’t need to rewrite it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Spring Security 的 `Password` **EncoderFactories** 类中找到支持的完整编码器列表。如果其中之一符合我们的要求，我们就不需要重写它。
- en: 'Note that all implementations reside in the `o.s.s.crypto` package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有实现类都位于 `o.s.s.crypto` 包中：
- en: '| **Encoder** | **Algorithm** | **Usage** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **编码器** | **算法** | **用途** |'
- en: '| `Pbkdf2PasswordEncoder` | PBKDF2 | Provides key strengthening with configurable
    iteration count, suitable for password hashing.Suitable for password storage.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Pbkdf2PasswordEncoder` | PBKDF2 | 提供可配置迭代次数的密钥增强，适用于密码散列。适用于密码存储。|'
- en: '| `SCryptPasswordEncoder` | Scrypt | Memory-hard key derivation function, making
    it resistant to brute-force attacks.Suitable for password storage. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `SCryptPasswordEncoder` | Scrypt | 内存硬密钥派生函数，使其对暴力攻击具有抵抗力。适用于密码存储。|'
- en: '| `StandardPasswordEncoder` | SHA-256 | Uses a standard SHA-256 algorithm.
    Note that SHA-256 alone is not recommended for password hashing due to its speed.Suitable
    for legacy systems but not recommended for new applications. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `StandardPasswordEncoder` | SHA-256 | 使用标准的 SHA-256 算法。请注意，由于速度原因，SHA-256
    单独不推荐用于密码散列。适用于旧系统，但不推荐用于新应用。|'
- en: '| `NoOpPasswordEncoder` | No operation | No hashing or encoding; passwords
    are stored as plain text.Not recommended for production. Useful for testing and
    development. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `NoOpPasswordEncoder` | 无操作 | 不进行散列或编码；密码以纯文本形式存储。不推荐用于生产环境。适用于测试和开发。|'
- en: '| `LdapShaPasswordEncoder` | SHA-1 | Performs SHA-1 hashing with optional salt.
    Suitable for compatibility with LDAP directories.Suitable for integration with
    LDAP-based systems. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `LdapShaPasswordEncoder` | SHA-1 | 可选盐的 SHA-1 散列。适用于与 LDAP 目录的兼容性。适用于与基于
    LDAP 的系统集成。|'
- en: '| `BCryptPasswordEncoder` | BCrypt | One-way hash function with adaptive hashing,
    suitable for password hashing.Recommended for password storage. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `BCryptPasswordEncoder` | BCrypt | 带有自适应散列的单向散列函数，适用于密码散列。推荐用于密码存储。|'
- en: '| `MessageDigest PasswordEncoder` | Configurable(e.g., MD5,SHA-256,SHA-512)
    | Uses various message digest algorithms, but the choice of algorithm is crucial
    for security.Depends on the selected algorithm. Not recommended for new applications
    due to weaknesses in some algorithms. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `MessageDigest PasswordEncoder` | 可配置（例如，MD5、SHA-256、SHA-512） | 使用各种消息摘要算法，但算法的选择对于安全性至关重要。取决于所选算法。由于某些算法的弱点，不推荐用于新应用。
    |'
- en: Table 4.3 – Main PasswordEncoder implementation
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 – 主要PasswordEncoder实现
- en: As with many other areas of Spring Security, it’s also possible to reference
    a bean definition by implementing `PasswordEncoder` to provide more precise configuration
    and
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Security的许多其他领域一样，也可以通过实现`PasswordEncoder`来引用bean定义，以提供更精确的配置和
- en: allowing `PasswordEncoder` to be wired into other beans through the dependency
    injection. For the JBCP calendar application, we’ll need to use this bean reference
    method in order to hash the passwords of the newly created users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 允许`PasswordEncoder`通过依赖注入与其他bean连接。对于JBCP日历应用，我们需要使用这个bean引用方法来对新创建的用户密码进行哈希处理。
- en: The DelegatingPasswordEncoder implementation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DelegatingPasswordEncoder实现
- en: 'Prior to Spring Security 5.0, the default `PasswordEncoder` was `NoOpPasswordEncoder`,
    which required plain-text passwords. Based on the Password History section, you
    might expect that the default `PasswordEncoder` would now be something like `BCryptPasswordEncoder`.
    However, this ignores three real world problems:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security 5.0之前，默认的`PasswordEncoder`是`NoOpPasswordEncoder`，它需要明文密码。根据密码历史记录部分，你可能会预期默认的`PasswordEncoder`现在会是类似`BCryptPasswordEncoder`的东西。然而，这忽略了三个现实世界的问题：
- en: Many applications use old password encodings that cannot easily migrate.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多应用使用旧的密码编码，难以轻松迁移。
- en: The best practice for password storage will change again.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码存储的最佳实践将再次改变。
- en: As a framework, Spring Security cannot make breaking changes frequently.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为框架，Spring Security不能频繁地进行破坏性更改。
- en: 'Instead, Spring Security introduces `DelegatingPasswordEncoder`, which solves
    all of the problems by:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Spring Security引入了`DelegatingPasswordEncoder`，通过以下方式解决了所有问题：
- en: Ensuring that passwords are encoded by using the current password storage recommendations.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用当前密码存储建议进行密码编码。
- en: Allowing for validating passwords in modern and legacy formats.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许验证现代和旧格式中的密码。
- en: Allowing for upgrading the encoding in the future.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在未来升级编码。
- en: 'You can easily construct an instance of `DelegatingPasswordEncoder` by using
    `Password``EncoderFactories`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`PasswordEncoderFactories`轻松构建`DelegatingPasswordEncoder`的实例：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s walk through the process of configuring basic password encoding for the
    JBCP calendar application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过配置JBCP日历应用的基本密码编码过程来了解这个过程。
- en: Configuring password encoding
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置密码编码
- en: 'Configuring basic password encoding involves two steps: hashing the passwords
    we load into the database after the SQL script executes and ensuring that Spring
    Security is configured to work with `PasswordEncoder`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 配置基本密码编码涉及两个步骤：在SQL脚本执行后对加载到数据库中的密码进行哈希处理，并确保Spring Security配置为与`PasswordEncoder`一起工作。
- en: Configuring the PasswordEncoder method
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置PasswordEncoder方法
- en: 'First, we’ll declare an instance of `PasswordEncoder` as a normal Spring bean,
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一个`PasswordEncoder`的实例作为普通的Spring bean，如下所示：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Making Spring Security aware of the PasswordEncoder method
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使Spring Security了解PasswordEncoder方法
- en: We’ll need to configure Spring Security to have a reference to a Bean of type
    `PasswordEncoder`, so that it can encode and compare the presented password during
    user login.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置Spring Security以引用一个类型为`PasswordEncoder`的Bean，以便它可以在用户登录期间对提供的密码进行编码和比较。
- en: If you were to try the application at this point, you’d notice that what were
    previously valid login credentials would now be rejected. This is because the
    passwords stored in the database (loaded with the `calendar-users.sql` script)
    are not stored as a `hash` that matches the password encoder. We’ll need to update
    the stored passwords to be hashed values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时尝试运行应用，你会注意到之前有效的登录凭证现在被拒绝。这是因为数据库中存储的密码（由`calendar-users.sql`脚本加载）并不是以与密码编码器匹配的哈希形式存储的。我们需要更新存储的密码，使其成为哈希值。
- en: Hashing the stored passwords
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对存储的密码进行哈希处理
- en: 'As illustrated in the following diagram, when a user submits a password, Spring
    Security hashes the submitted password and then compares that against the unhashed
    password in the database:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，当用户提交密码时，Spring Security对提交的密码进行哈希处理，然后将其与数据库中的未哈希密码进行比较：
- en: '![Figure 4.2 – Hashing the stored passwords workflow](img/B21757_04_2.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 存储密码的哈希处理工作流程](img/B21757_04_2.jpg)'
- en: Figure 4.2 – Hashing the stored passwords workflow
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 存储密码的哈希处理工作流程
- en: 'This means that users cannot log in to our application. To fix this, we will
    update the SQL that is loaded at startup time to update the passwords to be the
    hashed values. Update the `DataSourceConfig.java` file, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户无法登录我们的应用程序。为了解决这个问题，我们将更新启动时加载的 SQL，将密码更新为哈希值。更新 `DataSourceConfig.java`
    文件，如下所示：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `calendar-sha256.sql` file simply updates the existing passwords to their
    expected hashed values, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`calendar-sha256.sql` 文件只是将现有密码更新为其预期的哈希值，如下所示：'
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'How did we know what value to update the password to? We have provided `o.s.s.authentication.encoding.Sha256PasswordEncoderMain`
    to demonstrate how to use the configured `PasswordEncoder` interface to hash the
    existing passwords. The relevant code is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何知道更新密码应该使用什么值的？我们提供了 `o.s.s.authentication.encoding.Sha256PasswordEncoderMain`
    来演示如何使用配置的 `PasswordEncoder` 接口来哈希现有密码。相关代码如下：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hashing the passwords of new users
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对新用户密码进行哈希处理
- en: 'If we tried running the application and creating a new user, we would not be
    able to log in. This is because the newly-created user’s password would not be
    hashed. We need to update `DefaultCalendarService` to hash the password. Make
    the following updates to ensure that the newly-created users passwords are hashed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行应用程序并创建新用户，我们将无法登录。这是因为新创建的用户密码不会被哈希。我们需要更新 `DefaultCalendarService`
    以哈希密码。进行以下更新以确保新创建的用户密码被哈希：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Not quite secure
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并不完全安全
- en: Go ahead and start the application. Try creating a new user with `user1` as
    the password. Log out of the application, then use the instructions on the `user1@example.com`
    are the same value? The fact that we have now figured out another user’s password
    is a little disturbing. We will solve this with a technique known as **salting**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始应用程序。尝试使用 `user1` 作为密码创建一个新用户。从应用程序中注销，然后使用 `user1@example.com` 的说明。这些值是否相同？我们现在已经发现了另一个用户的密码，这有点令人不安。我们将使用一种称为
    **盐分** 的技术来解决这个问题。
- en: Important note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.04-calendar`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.04-calendar`。
- en: 'Would you like some salt with that password? If the security auditor were to
    examine the encoded passwords in the database, he’d find something that would
    still make him concerned about the website’s security. Let’s examine the following
    stored username and password values for a few of our users:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要为这个密码添加一些盐分吗？如果安全审计员检查数据库中的编码密码，他可能会发现一些仍然会让他对网站的安全性感到担忧的事情。让我们检查以下存储的用户名和密码值：
- en: '| **Username** | **Plaintext password** | **Hashed password** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **明文密码** | **哈希密码** |'
- en: '| `admin1@example.com` | `admin1` | `{``SHA-256}25f43b1486ad95a1 398e3eeb3d83bc4010015fcc9``bedb35b432e00298d5021f7`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `admin1@example.com` | `admin1` | `{``SHA-256}25f43b1486ad95a1 398e3eeb3d83bc4010015fcc9``bedb35b432e00298d5021f7`
    |'
- en: '| `user1@example.com` | `user1` | `{``SHA-256}0a041b9462caa4a3 1bac3567e0b6e6fd9100787db``2ab433d96f6d178cabfce90`
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `user1@example.com` | `user1` | `{``SHA-256}0a041b9462caa4a3 1bac3567e0b6e6fd9100787db``2ab433d96f6d178cabfce90`
    |'
- en: Table 4.4 – Hashed users passwords
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – 哈希用户密码
- en: This looks very secure—the encrypted passwords obviously bear no resemblance
    to the original passwords. What could the auditor be concerned about? What if
    we add a new user who happens to have the same password as our `user1@example.com`
    user?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常安全——加密的密码显然与原始密码没有任何相似之处。审计员可能会担心什么？如果我们添加一个恰好与我们的 `user1@example.com`
    用户具有相同密码的新用户呢？
- en: '| **Username** | **Plaintext** **password** | **Hashed password** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **明文密码** | **哈希密码** |'
- en: '| `hacker@example.com` | `user1` | `{``SHA-256}0a041b9462caa4 a31bac3567e0b6e6fd91007``87db2ab433d96f6d178cabfce90`
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `hacker@example.com` | `user1` | `{``SHA-256}0a041b9462caa4 a31bac3567e0b6e6fd91007``87db2ab433d96f6d178cabfce90`
    |'
- en: Table 4.5 – Hacked hashed user password
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5 – 被破解的哈希用户密码
- en: Now, note that the encrypted password of the `hacker@example.com` user is exactly
    the same as the real user! Thus, a hacker who had somehow gained the ability to
    read the encrypted passwords in the database could compare their known password’s
    encrypted representation with the unknown one for the user account, and see they
    are the same! If the hacker had access to an automated tool to perform this analysis,
    they could likely compromise the user’s account within a matter of hours.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，`hacker@example.com`用户的加密密码与真实用户完全相同！因此，如果一个黑客以某种方式获得了读取数据库中加密密码的能力，他们可以将已知密码的加密表示与用户账户的未知加密表示进行比较，并发现它们是相同的！如果黑客能够访问一个自动化的工具来执行这种分析，他们可能在几小时内就能攻破用户的账户。
- en: While it is difficult to guess a single password, hackers can calculate all
    the hashes ahead of time and store a mapping of the hash to the original password.
    Then, figuring out the original password is a matter of looking up the password
    by its hashed value in constant time. This is a hacking technique known as **rainbow
    tables**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然猜测单个密码很困难，但黑客可以在事先计算出所有hash值并存储hash到原始密码的映射。然后，找出原始密码只需通过其hash值在常数时间内查找密码。这是一种称为**彩虹表**的攻击技术。
- en: One common and effective method of adding another layer of security to encrypted
    passwords is to incorporate a **salt**. A salt is a second plaintext component,
    which is concatenated with the plaintext password prior to performing the hash,
    in order to ensure that two factors must be used to generate (and thus compare)
    the hashed password values. Properly selected salts can guarantee that no two
    passwords will ever have the same hashed value, thus preventing the scenario that
    concerned our auditor, and avoiding many common types of brute force password
    cracking techniques.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密密码中增加另一层安全性的一个常见且有效的方法是加入一个**盐**。盐是一个第二个明文组件，在执行哈希之前与明文密码连接，以确保必须使用两个因素来生成（以及比较）哈希密码值。正确选择的盐可以保证没有任何两个密码会有相同的哈希值，从而防止我们审计员所关心的场景，并避免许多常见的暴力破解密码技术。
- en: 'Best practice salts generally fall into one of the following three categories:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践盐通常分为以下三个类别：
- en: They are algorithmically generated from some pieces of data associated with
    the user, for example, the timestamp that the user created
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是从与用户关联的一些数据中算法生成的，例如，用户创建的时间戳
- en: They are randomly generated and stored in some form
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是随机生成的并以某种形式存储
- en: They are plaintext or two-way encrypted along with the user’s password record
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是纯文本或与用户密码记录双向加密的
- en: Remember that because the `salt` value for a given user’s record in order to
    calculate the `hash` of the password, and to compare it with the stored `hash`
    of the user when performing authentication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为给定用户的记录中的`salt`值是为了计算密码的`hash`值，并在进行身份验证时将其与存储的用户`hash`值进行比较。
- en: Using salt in Spring Security
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Security中使用盐
- en: '`spring-security-core` module and are available separately in `spring-security-crypto`.
    The `o.s.s.crypto.password.PasswordEncoder` interface. In fact, using this interface
    is the preferred method for encoding passwords, because it will salt passwords
    using a random `salt`. At the time of this writing, there are the following three
    implementations of `o.s.s.crypto.password.PasswordEncoder`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-security-core`模块，并在`spring-security-crypto`中单独提供。`o.s.s.crypto.password.PasswordEncoder`接口。实际上，使用此接口是编码密码的首选方法，因为它将使用随机`salt`对密码进行编码。在撰写本文时，`o.s.s.crypto.password.PasswordEncoder`有以下三种实现：'
- en: '| **Class** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **描述** |'
- en: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | This class uses the `bcrypt`
    hashing function. It supports `salt` and the ability to slow down to perform over
    time as technology improves. This helps protect against brute- force search attacks.
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | 这个类使用`bcrypt`哈希函数。它支持盐和随着技术改进而减慢速度的能力。这有助于防止暴力搜索攻击。|'
- en: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | This class does no encoding
    (it returns the password in its plaintext form). Provided for legacy and testing
    purposes only and is not considered secure. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | 这个类不进行编码（它以明文形式返回密码）。仅用于遗留和测试目的，并且不被认为是安全的。|'
- en: '| `o.s.s.crypto.password.StandardPasswordEncoder` | This class uses `SHA-256`
    with multiple iterations and a random `salt` value. Provided for legacy and testing
    purposes only and is not considered secure. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.password.StandardPasswordEncoder` | 此类使用 `SHA-256` 并多次迭代，以及一个随机的
    `salt` 值。仅提供用于遗留和测试目的，并不被认为是安全的。|'
- en: Table 4.6 – Common PasswordEncoder implementations
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.6 – 常见的 PasswordEncoder 实现
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For those who are familiar with `Spring Security`, The Spring Security Crypto
    module provides support for symmetric encryption, key generation, and password
    encoding. The classes above are part of the core module and has no dependencies
    on any other Spring Security (or Spring) code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 `Spring Security` 的人来说，Spring Security Crypto 模块提供了对称加密、密钥生成和密码编码的支持。上述类是核心模块的一部分，并且没有依赖任何其他
    Spring Security（或 Spring）代码。
- en: Updating the Spring Security configuration
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Spring Security 配置
- en: 'This can be done by updating the Spring Security configuration. Remove the
    old `ShaPasswordEncoder` encoder and add the new `StandardPasswordEncoder` encoder,
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过更新 Spring Security 配置来完成。移除旧的 `ShaPasswordEncoder` 编码器，并添加新的 `StandardPasswordEncoder`
    编码器，如下所示：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Migrating existing passwords
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移现有密码
- en: 'Let’s take a look at the following steps and learn about migrating existing
    passwords:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，了解如何迁移现有密码：
- en: 'We need to update our existing passwords to use the values produced by the
    new `PasswordEncoder` class. If you would like to generate your own passwords,
    you can use the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新我们的现有密码以使用由新的 `PasswordEncoder` 类生成的值。如果您想生成自己的密码，可以使用以下代码片段：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remove the previously used `calendar-sha256.sql` file, and add the provided
    `saltedsha256.sql` file as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除之前使用的 `calendar-sha256.sql` 文件，并添加提供的 `saltedsha256.sql` 文件，如下所示：
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Updating DefaultCalendarUserService
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 DefaultCalendarUserService
- en: 'The `passwordEncoder()` method we defined previously is smart enough to handle
    the new password encoder interface. However, `DefaultCalendarUserService` needs
    to update to the new interface. Make the following updates to the `DefaultCalendarUserService`
    class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的 `passwordEncoder()` 方法足够智能，可以处理新的密码编码器接口。然而，`DefaultCalendarUserService`
    需要更新到新的接口。对 `DefaultCalendarUserService` 类进行以下更新：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the preceding code implementation, we have been able to configure Salt
    SHA256 in Spring Security. The `DefaultCalendarService` uses this Salt `PasswordEncoder`
    to insert user’s password.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码实现，我们已经能够在 Spring Security 中配置 Salt SHA256。`DefaultCalendarService` 使用此
    Salt `PasswordEncoder` 插入用户的密码。
- en: In the next section, we will explore another option to use `Salt` with `Bcrypt`
    algorithm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用 `Salt` 与 `Bcrypt` 算法结合的另一种选项。
- en: Trying out salted passwords
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用加盐密码
- en: Start up the application and try creating another user with the password `user1`.
    Use the H2 console to compare the new user’s password and observe that they are
    different.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，并尝试使用密码 `user1` 创建另一个用户。使用 H2 控制台比较新用户的密码，并观察它们是不同的。
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.05-calendar`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.05-calendar`。
- en: 'Spring Security now generates a random `salt` and combines this with the password
    before hashing our password. It then adds the random `salt` to the beginning of
    the password in plaintext, so that passwords can be checked. The stored password
    can be summarized as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 现在生成一个随机的 `salt` 并将其与密码结合在一起在哈希我们的密码之前。然后，它将随机的 `salt` 添加到密码的文本开头，以便可以检查密码。存储的密码可以总结如下：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the pseudocode for hashing a newly created password.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建新密码的伪代码。
- en: 'To authenticate a user, `salt` and `hash` can be extracted from the stored
    password, since both `salt` and `hash` are fixed lengths. Then, the extracted
    `hash` can be compared against a new `hash`, computed with extracted `salt` and
    the inputted password:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证用户，可以从存储的密码中提取 `salt` 和 `hash`，因为 `salt` 和 `hash` 都是固定长度的。然后，可以比较提取的 `hash`
    与使用提取的 `salt` 和输入的密码计算出的新 `hash`：
- en: '![Figure 4.3 – Salting the stored passwords workflow](img/B21757_04_3.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 存储密码的加盐工作流程](img/B21757_04_3.jpg)'
- en: Figure 4.3 – Salting the stored passwords workflow
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 存储密码的加盐工作流程
- en: 'The following is the pseudocode for validating a salted password:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对加盐密码进行验证的伪代码：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`BCryptPasswordEncoder` is another salt implementation uses the widely supported
    `bcrypt` algorithm to hash the passwords. `Bcrypt` uses a random `16-byte salt`
    value and is a deliberately slow algorithm, to hinder password crackers. You can
    tune the amount of work it does by using the strength parameter, which takes a
    value from *4* to *31*. The higher the value, the more work has to be done to
    calculate the hash. The default value is `10`. You can change this value in your
    deployed system without affecting existing passwords, as the value is also stored
    in the encoded hash. The following example uses the `BCryptPasswordEncoder` with
    strength parameter value equal to `4`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`BCryptPasswordEncoder` 是另一种使用广泛支持的 `bcrypt` 算法来散列密码的盐实现。`Bcrypt` 使用随机的 `16
    字节盐` 值，并且是一个故意设计得较慢的算法，以阻碍密码破解者。您可以通过使用强度参数来调整它所做的工作量，该参数的值从 *4* 到 *31*。值越高，计算散列所需的努力就越多。默认值是
    `10`。您可以在部署的系统更改此值而不影响现有密码，因为该值也存储在编码的散列中。以下示例使用强度参数值为 `4` 的 `BCryptPasswordEncoder`：'
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, we had to use add the provided `calendar-bcrypt.sql` file as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不得不添加提供的 `calendar-bcrypt.sql` 文件，如下所示：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Start up the application and try logging to the application with username `user1@example.com`
    and password `user1`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试使用用户名 `user1@example.com` 和密码 `user1` 登录到应用程序。
- en: Important note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.06-calendar`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.06-calendar`。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Spring Security’s built-in *JDBC support*.
    Specifically, we have learned that Spring Security provides a default schema for
    new applications. We also explored how to implement *GBAC* and how it can make
    managing users easier.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Spring Security 的内置 *JDBC 支持*。具体来说，我们了解到 Spring Security 为新应用程序提供了一个默认的模式。我们还探讨了如何实现
    *GBAC* 以及它如何简化用户管理。
- en: We also learned how to integrate Spring Security’s JDBC support with an existing
    database and also how to secure our passwords by hashing them and using a randomly
    generated *salt*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何将 Spring Security 的 JDBC 支持与现有数据库集成，以及如何通过散列密码并使用随机生成的 *盐* 来保护我们的密码。
- en: In the next chapter, we will explore the *Spring Data* project and how to configure
    Spring Security to use **object-relational mapping** (**ORM**) to connect to an
    RDBMS, as well as a document database.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 *Spring Data* 项目以及如何配置 Spring Security 以使用 **对象关系映射** (**ORM**)
    连接到 RDBMS，以及文档数据库。
