- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Memory Leaks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Memory leaks occur as a result of improper memory management and can directly
    impact the performance of an application. These leaks occur when memory is improperly
    deallocated or when it is allocated but becomes inaccessible. Improper memory
    management not only negatively impacts performance but can also hinder scalability,
    result in system crashes due to `OutOfMemoryError`, and ruin the user experience.
    Many developers implicitly trust Java’s garbage collector (covered in [*Chapter
    1*](B21942_01.xhtml#_idTextAnchor014)) to manage memory while their applications
    run; however, despite the garbage collector’s incredible capabilities, memory
    leaks are a persistent issue.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是由于不当的内存管理而发生的，可以直接影响应用程序的性能。这些泄漏发生在内存被不当释放或分配但变得不可访问时。不当的内存管理不仅会负面影响性能，还会阻碍可扩展性，由于`OutOfMemoryError`而导致系统崩溃，并破坏用户体验。许多开发者隐含地相信Java的垃圾收集器（在第[*第1章*](B21942_01.xhtml#_idTextAnchor014)中介绍）在应用程序运行时管理内存；然而，尽管垃圾收集器具有不可思议的能力，内存泄漏仍然是一个持续存在的问题。
- en: The garbage collector is not faulty; rather, memory leaks occur when the garbage
    collector is unable to reclaim memory that stores objects that are no longer needed
    by the application. Improper referencing is the primary culprit, and fortunately,
    we can avoid this. This chapter provides techniques, design patterns, coding examples,
    and best practices to avoid memory leaks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器并没有出错；相反，当垃圾收集器无法回收不再被应用程序需要的对象所存储的内存时，就会发生内存泄漏。不当的引用是主要原因，幸运的是，我们可以避免这种情况。本章提供了避免内存泄漏的技术、设计模式、编码示例和最佳实践。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要内容：
- en: Proper referencing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确引用
- en: Listeners and loaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器和加载器
- en: Caching and threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存和线程
- en: By the end of this chapter, you should have a comprehensive understanding of
    what can lead to memory leaks at runtime and the potential devastation they can
    inflict on our Java applications, and you will know how to prevent them purposefully
    and efficiently. You can gain confidence in implementing your own memory leak
    prevention strategy by experimenting with the sample code provided.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对可能导致运行时内存泄漏的因素以及它们可能对我们Java应用程序造成的潜在破坏有一个全面的理解，并且你会知道如何有目的地和高效地预防它们。通过实验提供的示例代码，你可以对自己的内存泄漏预防策略充满信心。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，你需要具备加载、编辑和运行Java代码的能力。如果你还没有设置你的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下链接找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08)。
- en: Proper referencing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确引用
- en: It is undeniable – memory leaks can result in a gradual decrease in resource
    availability and lead to sluggish systems and potential system crashes. The good
    news is that there are two major components that offer a solution. One component
    is the garbage collector that is part of the **Java Virtual Machine** (**JVM**).
    It is highly capable and one of the shining characteristics of the Java language.
    The second, and more important, component is the developer. As Java developers,
    we have the power to minimize and even eliminate memory leaks by taking a purposeful
    approach to memory management in our code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认——内存泄漏会导致资源可用性的逐渐下降，导致系统变慢和潜在的系统崩溃。好消息是，有两个主要组件提供了解决方案。一个组件是Java虚拟机（**JVM**）的一部分，即垃圾收集器。它功能强大，是Java语言的一个亮点。第二个，也是更重要的一点，是开发者。作为Java开发者，我们通过在代码中对内存管理采取有目的的方法，有权力最小化甚至消除内存泄漏。
- en: To support the developer component of the solution to eradicate memory leaks,
    this section will focus on how to properly reference objects so that they do not
    lead to memory leaks, how to identify memory leaks, and the strategies to avoid
    them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持解决方案中开发者部分的消除内存泄漏，本节将重点介绍如何正确引用对象，以防止它们导致内存泄漏，如何识别内存泄漏，以及避免它们的策略。
- en: An introduction to references
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用简介
- en: Perhaps the most important aspect of avoiding memory leaks is to use proper
    referencing. This should be encouraged, since it puts control in the developer’s
    hands. Java offers a great toolbox to aid our efforts in this area. Specifically,
    there are several types of references, each with its own purpose and associated
    garbage collector behavior.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存泄漏最重要的方面可能是使用适当的引用。这应该被鼓励，因为它将控制权交给了开发者。Java为我们提供了强大的工具箱来帮助我们在这方面的工作。具体来说，有几种引用类型，每种类型都有自己的用途和相关的垃圾回收器行为。
- en: References
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: In Java, references are pointers to memory locations and are a critical component
    of memory management and memory leak mitigation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，引用是内存位置的指针，是内存管理和内存泄漏缓解的关键组件。
- en: Let’s examine the various types of referencing in Java, strong, soft, weak,
    and phantom, so we can determine which method is the most appropriate for any
    given use case. Remember, our overall purpose is to have efficient memory management
    and avoid memory links to increase the overall performance of our Java applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查Java中各种引用类型，包括强引用、软引用、弱引用和虚引用，以便我们可以确定哪种方法最适合任何给定的用例。记住，我们的总体目的是实现高效的内存管理，避免内存链接，以提高我们Java应用程序的整体性能。
- en: Strong references
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强引用
- en: '**Strong referencing** is the most important reference type for us to focus
    on. Not only is it the default reference type in Java, but it is also the most
    common source of memory leaks. Objects that have a strong reference type are not
    eligible for garbage collection. To create a strong reference, we simply use a
    variable to directly reference an object.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**强引用**是我们需要重点关注的最重要的引用类型。它不仅是Java中的默认引用类型，而且也是内存泄漏最常见的原因。具有强引用类型的对象不符合垃圾回收的条件。要创建强引用，我们只需使用变量直接引用对象即可。'
- en: 'In the following example code, we create a strong reference to an object using
    the `sampleCorgiObject` variable. As long as that variable contains a reference
    to the `SampleCorgiObject` instance, we will have that object in memory and the
    garbage collector will not be able to deallocate its memory:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，我们使用`sampleCorgiObject`变量创建了一个对象的强引用。只要该变量包含对`SampleCorgiObject`实例的引用，我们就会在内存中保留该对象，垃圾回收器将无法释放其内存：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the default reference type in Java for a reason. The typical use case
    is when we have objects that we need the entire time our application is running,
    such as configuration properties. We should use strong referencing with caution,
    especially when the objects are large. A best practice is to set our references
    to `null` as soon as they are no longer needed. This will empower the garbage
    collector to deallocate associated memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以是Java中的默认引用类型，是有原因的。典型的用例是我们需要在整个应用程序运行期间保持对象，例如配置属性。我们应该谨慎使用强引用，特别是当对象很大时。一个最佳实践是在不再需要引用时立即将其设置为`null`。这将使垃圾回收器能够释放相关的内存。
- en: Soft references
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软引用
- en: '`OutOfMemoryError` and system crashes. When we create soft references, those
    objects are retained in memory only when there is sufficient space. This makes
    soft referencing an ideal solution to cache large objects.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutOfMemoryError`和系统崩溃。当我们创建软引用时，只有在有足够空间的情况下，这些对象才会保留在内存中。这使得软引用成为缓存大型对象的理想解决方案。'
- en: It is important to understand that the JVM collects these objects that have
    soft references to them only when necessary. The JVM’s garbage collector will
    collect everything else it can first and then, as a final effort, collect objects
    with soft references, and only then if the system is running out of memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，JVM仅在必要时才会收集具有软引用的对象。JVM的垃圾回收器首先收集所有其他可以收集的对象，然后作为最后的努力，收集具有软引用的对象，并且只有在系统内存不足的情况下才会这样做。
- en: To implement a soft reference, we use the `SoftReference` class that is a part
    of the `java.lang-ref` package. Let’s look at an example in code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现软引用，我们使用`java.lang-ref`包中的`SoftReference`类。让我们通过代码示例来看看。
- en: 'We start our application by importing `SoftReference`. Then, we create our
    class header and initially create `MyBougieObject`, using strong referencing by
    `myBougieObject`. We then wrap it with `SoftReference<MyBougieObject>` to establish
    the soft reference. Note that we set `myBougieObject` to null, which ensures that
    our `MyBougieObject` instance is only accessible through the soft reference we
    created:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过导入`SoftReference`开始我们的应用程序。然后，我们创建类头，并使用强引用通过`myBougieObject`初始化`MyBougieObject`。然后我们用`SoftReference<MyBougieObject>`包装它以建立软引用。请注意，我们将`myBougieObject`设置为null，这确保了我们的`MyBougieObject`实例只能通过我们创建的软引用访问：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the next section of code, we attempt to review `myBougieObject` from the
    soft reference. We use `System.gc()` to provide a way to observe the behavior
    of our software references under normal conditions and then simulate memory pressure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节代码中，我们尝试从软引用中回顾`myBougieObject`。我们使用`System.gc()`来提供一个在正常条件下观察我们的软件引用行为的方法，然后模拟内存压力：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This last section implies our `MyBougieObject` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一部分暗示了我们的`MyBougieObject`类：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is what the output might look like. Of course, the results will depend
    on your system’s available memory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出可能的样子。当然，结果将取决于您系统可用内存的大小：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Weak references
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱引用
- en: So far, we have covered **strong references** that prevent garbage collection
    and **soft references** that allow garbage collection as a last-ditch effort to
    reclaim memory. **Weak references** are unique in that they permit garbage collection
    only if the weak reference is the only reference to the specific object. This
    approach can be especially useful when we want more flexibility in our memory
    management solutions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了防止垃圾回收的**强引用**和允许垃圾回收作为最后手段以回收内存的**软引用**。**弱引用**的独特之处在于，只有当弱引用是特定对象的唯一引用时，才允许垃圾回收。这种方法在需要更多灵活性的内存管理解决方案中特别有用。
- en: 'A common use of weak references is in caching when we want objects to remain
    in memory but not prevent them from being reclaimed by JVM’s garbage collection
    when a system runs low on memory. To implement a weak reference, we use the `WeakReference`
    class that is a part of the `java.lang-ref` package. Let’s look at an example
    in code. We start our code with the necessary `import` statement and the class
    declaration. As you can see in the following code block, we wrap our `CacheCorgiObject`
    in `WeakReference`, which can initially be accessed via the weak reference. When
    we set the strong reference (`cacheCorgiObject`) to null, we call `System.gc()`
    to invoke the JVM’s garbage collector. Depending on your system’s memory, the
    object might be collected, as it is available. Following the garbage collection,
    we call `weakCacheCorgiObject.get()`, and `null` is returned if the object collection
    took place:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用的一个常见用途是在缓存中，当我们希望对象保留在内存中，但又不想阻止它们在系统内存不足时被JVM的垃圾回收器回收。为了实现弱引用，我们使用`WeakReference`类，它是`java.lang-ref`包的一部分。让我们通过一个代码示例来看看。我们的代码从必要的`import`语句和类声明开始。正如您在下面的代码块中可以看到的，我们将`CacheCorgiObject`包装在`WeakReference`中，它最初可以通过弱引用访问。当我们将强引用（`cacheCorgiObject`）设置为null时，我们调用`System.gc()`来调用JVM的垃圾回收器。根据您的系统内存，对象可能会被回收，因为它可用。在垃圾回收之后，我们调用`weakCacheCorgiObject.get()`，如果发生了对象回收，则返回`null`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a sample output from our program. Results will vary, depending on the
    system’s available memory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的一个示例输出。结果将因系统可用内存的不同而有所变化：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Phantom references
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幻影引用
- en: Our last type of reference is a **phantom reference**. This reference type does
    not permit direct retrieval of the referenced object; instead, it provides a method
    to determine whether the object has been finalized and reclaimed by the JVM garbage
    collector. This happens without preventing the object from being collected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一种引用类型是**幻影引用**。这种引用类型不允许直接检索引用的对象；相反，它提供了一个方法来确定对象是否已经被JVM垃圾回收器终结并回收。这发生时不会阻止对象被回收。
- en: 'Implementation requires two classes from the `java.lang.ref` package – `PhantomReference`
    and `ReferenceQueue`. Our example code demonstrates the garbage collector determining
    whether an object with a phantom reference is reachable. This means that the object
    has been **finalized** and is ready for garbage collection. When this is the case,
    the reference is queued, and our application is able to respond accordingly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实现需要`java.lang.ref`包中的两个类——`PhantomReference`和`ReferenceQueue`。我们的示例代码演示了垃圾收集器确定具有虚引用的对象是否可达。这意味着该对象已被**终结**并准备进行垃圾回收。在这种情况下，引用将被排队，我们的应用程序能够相应地做出反应：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adopting the phantom reference approach enables us to invoke our own memory-cleaning
    actions, based on an object with a phantom reference’s collection. This approach
    does not interfere with the normal garbage collection operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 采用虚引用方法使我们能够根据具有虚引用集合的对象调用我们自己的内存清理操作，这种方法不会干扰正常的垃圾回收操作。
- en: Using the finalize() method
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`finalize()`方法
- en: The `finalize()` method has been depreciated and is scheduled for removal from
    Java in a future release. It is used in the previous code example simply to demonstrate
    the phantom reference approach and does not suggest using `finalize()`. Consult
    the Java documentation for additional information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize()`方法已被弃用，并计划在未来版本的Java中删除。在先前的代码示例中，它仅用于演示虚引用方法，并不建议使用`finalize()`。有关更多信息，请参阅Java文档。'
- en: Now that we have reviewed proper referencing, we should have an appreciation
    for how much developer intervention can solve the memory leak problem. Further,
    examination of the coding examples should lead to confidence in implementing proper
    referencing throughout our Java applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了正确的引用方法，我们应该对开发者干预解决内存泄漏问题的重要性有所认识。此外，对编码示例的审查应使我们能够自信地在我们的Java应用程序中实现正确的引用。
- en: Memory leak identification
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏识别
- en: One of the most important things we should implement in our Java applications
    is the ability to identify memory leaks. Our goal is to create high-performance
    Java applications, and memory leaks are counter to that goal. In order to identify
    memory leaks, we need to understand what symptoms indicate that a memory leak
    exists. These symptoms include increased garbage collection activity, `OutOfMemoryError`,
    and progressive performance degradation. Let’s look at five methods to identify
    memory leaks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中，我们应该实现的最重要的事情之一是识别内存泄漏的能力。我们的目标是创建高性能的Java应用程序，而内存泄漏与这一目标相悖。为了识别内存泄漏，我们需要了解哪些症状表明存在内存泄漏。这些症状包括垃圾回收活动增加、`OutOfMemoryError`和性能逐渐下降。让我们看看五种识别内存泄漏的方法。
- en: 'One of the most important methods to identify memory leaks is to review our
    code to ensure that we follow best practices and avoid common pitfalls, such as
    failing to clear static collections, not removing **listeners** after use, and
    caches that grow out of control. We will cover listeners later in this chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 识别内存泄漏最重要的方法之一是审查我们的代码，以确保我们遵循最佳实践并避免常见陷阱，例如未能清除静态集合、使用后未移除**监听器**以及失去控制的缓存。我们将在本章后面讨论监听器：
- en: A second method involves using a tool that can reveal which of our application’s
    objects consumes the most memory.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法涉及使用一个工具，该工具可以揭示我们应用程序中哪个对象消耗了最多的内存。
- en: A third method is to use a tool to generate a heap dump, which is a moment-in-time
    snapshot of all objects currently in memory. This can help you analyze and detect
    potential issues.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种方法是使用工具生成堆转储，这是当前内存中所有对象的瞬间快照。这可以帮助您分析和检测潜在问题。
- en: When reviewing object retention, look for unusual or unwanted patterns. Examples
    include when objects have a longer life cycle than expected or a large number
    of objects of a specific type that you do not expect to see large numbers of.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查对象保留时，寻找异常或不希望的图案。例如，当对象的生命周期比预期更长或存在大量您不期望看到的大量特定类型的对象时。
- en: A fifth method to identify memory leaks is to continually and iteratively test
    and profile your application. Once you identify a memory leak, you implement a
    fix, and should then retest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 识别内存泄漏的第五种方法是持续不断地测试和评估您的应用程序。一旦您确定了内存泄漏，您就实施修复，然后应该重新测试。
- en: We can use tools to help us identify memory leaks, including **JProfiler**,
    **YourKit**, **Java Flight Recorder** (**JFR**), **VisualVM**, and the Eclipse
    **Memory Analyzer Tool** (**MAT**). If you want to take memory leak identification
    seriously, you should research these tools to see how you can leverage their capabilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用工具来帮助我们识别内存泄漏，包括**JProfiler**、**YourKit**、**Java Flight Recorder**（**JFR**）、**VisualVM**和Eclipse的**内存分析工具**（**MAT**）。如果您想认真对待内存泄漏的识别，您应该研究这些工具，看看您如何利用它们的功能。
- en: Memory leak avoidance strategies
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免内存泄漏的策略
- en: Proper object referencing, as detailed earlier in this chapter, is a primary
    strategy to avoid memory leaks in your Java applications. Identifying and fixing
    memory leaks is another strategy, albeit a reactive one. These two strategies
    are important and have already been covered. Let’s briefly look at some additional
    strategies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的对象引用，如本章前面所述，是避免Java应用程序中内存泄漏的主要策略。识别和修复内存泄漏是另一种策略，尽管它是反应性的。这两种策略都很重要，并且已经讨论过。让我们简要地看看一些额外的策略。
- en: A third memory leak avoidance strategy is to properly manage collection objects.
    It is not uncommon for objects to be put into collections and then ignored or
    forgotten. This can result in memory leaks. So, to avoid this, we should develop
    our applications so that they regularly remove objects that are no longer required
    by our application. Using weak references can help with this. We should also be
    careful when using static collections. This type of collection has its life cycle
    linked with the class loader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存泄漏的第三种策略是正确管理集合对象。将对象放入集合中然后忽略或遗忘的情况并不少见，这可能导致内存泄漏。因此，为了避免这种情况，我们应该开发应用程序，使其定期删除不再需要的应用程序对象。使用弱引用可以帮助实现这一点。在使用静态集合时，我们也应该小心谨慎。这种类型的集合其生命周期与类加载器相关联。
- en: We should also be mindful of how we implement caches. The use of caches can
    significantly improve an application’s performance but can also result in memory
    leaks. When implementing caches, we should use soft references, set finite cache
    size limits, and continuously monitor cache usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意我们如何实现缓存。缓存的使用可以显著提高应用程序的性能，但也可能导致内存泄漏。在实现缓存时，我们应该使用软引用，设置有限的缓存大小限制，并持续监控缓存使用情况。
- en: A fifth strategy is to continuously use a profiling tool and test your application.
    This strategy requires a never-ending dedication to detecting and removing memory
    leaks in your application. It is an important strategy that should not be taken
    lightly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第五种策略是持续使用分析工具并测试您的应用程序。这种策略需要不断致力于检测和删除应用程序中的内存泄漏。这是一个重要的策略，不应被轻视。
- en: When we implement a set of memory leak avoidance strategies, we have a better
    chance of ensuring our applications have high performance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实施一系列避免内存泄漏的策略时，我们更有可能确保我们的应用程序具有高性能。
- en: Next, we will review how listeners and loaders can be used to help avoid memory
    leaks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾如何使用监听器和加载器来帮助避免内存泄漏。
- en: Listeners and loaders
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器和加载器
- en: Several aspects of our Java applications can impact performance and, more specifically,
    result in memory leaks. Two of those aspects are **listeners** and **loaders**.
    This section looks specifically at **event listeners** and **class loaders** and
    includes strategies to mitigate the risks of using them, without sacrificing the
    power and efficiencies they can provide to our Java applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Java应用程序的几个方面可能会影响性能，更具体地说，会导致内存泄漏。其中两个方面是**监听器**和**加载器**。本节专门探讨**事件监听器**和**类加载器**，并包括减轻使用它们的风险的策略，同时不牺牲它们可以为我们的Java应用程序提供的强大功能和效率。
- en: Event listeners
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件监听器
- en: Event listeners are used to allow objects to react to events. This approach
    is used heavily in interactive applications and is a critical component of event-driven
    programming. These listeners can result in a highly interactive application; however,
    if not properly managed, they can be the source of memory leaks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器用于允许对象对事件做出反应。这种方法在交互式应用程序中得到了广泛的应用，并且是事件驱动编程的一个关键组件。这些监听器可以导致高度交互的应用程序；然而，如果管理不当，它们也可能成为内存泄漏的来源。
- en: To understand the issue better, it is important to note that event listeners
    must subscribe to event sources so that they can receive notifications that need
    to be acted upon (e.g., a button click, or a non-player character in a game entering
    a predefined zone). As you would expect, each event listener maintains references
    to the event sources they subscribe to. A problem arises when an event source
    is no longer needed but is referenced by one or more listeners; this prevents
    the garbage collector from collecting the event source.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个问题，重要的是要注意，事件监听器必须订阅事件源，以便它们可以接收需要采取行动的通知（例如，按钮点击或游戏中的非玩家角色进入预定义区域）。正如你所期望的，每个事件监听器都维护着它们所订阅的事件源的引用。当事件源不再需要但被一个或多个监听器引用时，就会出现问题；这阻止了垃圾收集器收集事件源。
- en: 'Here are some best practices to avoid memory leaks when working with event
    listeners:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理事件监听器时，以下是一些避免内存泄漏的最佳实践：
- en: Use weak references, as detailed earlier in this chapter.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱引用，正如本章前面详细说明的那样。
- en: Explicitly deregister listeners from event sources when applicable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当适用时，明确从事件源注销监听器。
- en: Implement static nested classes for listeners because they do not have implicit
    references to outer class instances. This approach should be used instead of implementing
    non-static inner classes.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为监听器实现静态嵌套类，因为它们没有对外部类实例的隐式引用。应使用这种方法而不是实现非静态内部类。
- en: Align your event listener life cycles with those of their associated event sources.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件监听器的生命周期与其相关的事件源对齐。
- en: Class loaders
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类加载器。
- en: Class loaders enable us to dynamically load classes, making them a key component
    of **Java’s Runtime Environment** (**JRE**). Class loaders offer great power and
    flexibility through the support of polymorphism and extensibility. When our applications
    load classes dynamically, it illustrates that Java does not need to know about
    these classes at compile time. With this powerful flexibility comes the potential
    for memory leaks, which we need to mitigate, if not eliminate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器使我们能够动态加载类，使它们成为**Java运行时环境**（**JRE**）的关键组件。类加载器通过支持多态性和可扩展性提供了巨大的力量和灵活性。当我们的应用程序动态加载类时，这表明Java在编译时不需要了解这些类。这种强大的灵活性带来了内存泄漏的潜在风险，我们需要减轻，如果不是消除。
- en: 'The JVM has a class loading delegation model that involves several class loader
    types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JVM有一个涉及多个类加载器类型的类加载委托模型：
- en: A **bootstrap class loader** that loads Java’s core API classes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**引导类加载器**，用于加载Java的核心API类。
- en: An `java.ext.dirs` property.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.ext.dirs`属性。'
- en: An `classpath`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classpath`。'
- en: 'Class loaders are necessary, and when the loaded classes are retained in memory
    for longer than necessary, they can introduce memory leaks. The culprits here
    are typically with static fields in classes holding reference to objects that
    should otherwise be collected by the garbage collector, objects of loaded classes
    that are referenced by objects that have long lifespans, and a cache that retains
    class instances without proper management. Here are a few strategies to mitigate
    these risks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器是必要的，当加载的类在内存中保留的时间超过必要的时间时，它们可以引入内存泄漏。这里的罪魁祸首通常是具有静态字段的类，这些字段持有应该由垃圾收集器收集的对象的引用，被具有长期生命周期的对象引用的加载类对象，以及没有适当管理的缓存保留类实例。以下是一些减轻这些风险的策略：
- en: Use weak references
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱引用。
- en: Minimize the use of static fields
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化静态字段的使用。
- en: Make sure that custom class loaders are available to the garbage collection
    when no longer needed
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保当不再需要时，自定义类加载器对垃圾收集器可用。
- en: Monitor, profile, and refine as needed
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要监控、分析和改进。
- en: When we have a thorough understanding of loaders and listeners as well as strategies
    to mitigate their associated risks, we improve our chances of minimizing memory
    leaks in our Java applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对加载器和监听器以及减轻它们相关风险的战略有彻底的了解时，我们提高在Java应用程序中最大限度地减少内存泄漏的机会。
- en: Caching and threads
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存和线程。
- en: This section explores caching strategies, thread management, and the effective
    use of Java concurrency utilities. These are important concepts to embrace as
    we continue our journey of developing high-performance Java applications. We will
    explore these concepts, the associated best practices, and techniques to mitigate
    the risk of memory leaks introduced by their use.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了缓存策略、线程管理和Java并发工具的有效使用。这些是我们继续开发高性能Java应用程序旅程中需要掌握的重要概念。我们将探讨这些概念、相关的最佳实践以及减轻使用它们引入的内存泄漏风险的技巧。
- en: Caching strategies
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存策略
- en: In programming, we use **caching** to temporarily store data in memory locations
    to permit rapid access. This allows us to repeatedly access the data without causing
    lag or system crashes. The benefits of caching include more responsible applications
    and less load on longer-term storage solutions, such as databases and database
    servers. Of course, there are pitfalls. If we do not properly manage our caches,
    we can introduce significant memory leaks into our applications.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们使用**缓存**在内存位置临时存储数据，以便允许快速访问。这允许我们重复访问数据，而不会造成延迟或系统崩溃。缓存的好处包括更负责任的应用程序和减少对长期存储解决方案（如数据库和数据库服务器）的负载。当然，也存在陷阱。如果我们没有妥善管理我们的缓存，我们可能会在我们的应用程序中引入显著的内存泄漏。
- en: There are multiple caching strategies for us to consider; two of them you should
    already be familiar with, as they were covered earlier in this chapter, albeit
    not specific to caching. The first familiar strategy is to use weak references.
    When we use weak references with caching, we allow garbage collection when memory
    runs low. The second familiar strategy is using soft references. This strategy
    enables higher retention priority during garbage collection cycles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个缓存策略可以考虑；其中两个你应该已经熟悉，因为它们在本章的早期已经介绍过，尽管不是专门针对缓存。第一个熟悉策略是使用弱引用。当我们使用缓存中的弱引用时，允许在内存不足时进行垃圾回收。第二个熟悉策略是使用软引用。这种策略在垃圾回收周期中提供了更高的保留优先级。
- en: Another caching strategy is referred to as **Least Recently Used** (**LRU**),
    and as the name suggests, we remove the least accessed items first, as they are
    the least likely to be used by our application again.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓存策略被称为**最近最少使用**（**LRU**），正如其名所示，我们首先移除最少访问的项目，因为它们再次被我们的应用程序使用的可能性最小。
- en: '**Time to Live** (**TTL**) is another useful caching strategy. The TTL approach
    tracks cache insertion times and automatically expires items based on a prescribed
    amount of time.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**生存时间**（**TTL**）是另一种有用的缓存策略。TTL方法跟踪缓存插入时间，并基于规定的时间自动过期项目。'
- en: One additional caching strategy is using **size-based eviction**. This strategy
    ensures that caches do not exceed the amount of memory you set as the maximum
    boundary. The boundary can be set in terms of memory usage or the total number
    of items.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓存策略是使用基于**大小**的驱逐。这种策略确保缓存不会超过你设定的最大内存边界。这个边界可以用内存使用量或项目总数来设定。
- en: When we implement caching, we should be mindful of introducing memory leaks
    due to poor implementation. This purposeful approach requires us to conduct capacity
    planning, establish an eviction policy for the LRU and TTL approaches, and monitor
    our system. This monitoring requires subsequent fine-tuning and retesting.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现缓存时，我们应该注意由于实现不佳而引入内存泄漏。这种有意的做法要求我们进行容量规划，为LRU和TTL方法建立驱逐策略，并监控系统。这种监控需要后续的微调和重新测试。
- en: Thread management
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程管理
- en: We use **threads** in our applications to facilitate multiple concurrent operations.
    This makes better use of modern CPUs and improves the responsiveness of our Java
    applications. When we manage our threads manually, we can introduce memory leaks
    due to the complexity and error-prone nature of managing threads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用**线程**来促进多个并发操作。这使现代CPU得到更好的利用，并提高了Java应用程序的响应性。当我们手动管理线程时，由于线程管理的复杂性和易出错性，我们可能会引入内存泄漏。
- en: We can create threads in Java by extending the `Thread` class, or even by implementing
    the `Runnable` interface. These methods are a direct and easy way to use threads;
    however, it is not a recommended approach for large systems because they directly
    create and utilize threads, resulting in significant overhead. Instead of the
    direct approach, consider using Java’s **Executor** framework to abstract thread
    management from the main application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展`Thread`类或在Java中实现`Runnable`接口来创建线程。这些方法直接且易于使用线程；然而，对于大型系统来说，这不是推荐的方法，因为它们直接创建和利用线程，导致显著的开销。相反，考虑使用Java的**Executor**框架来从主应用程序中抽象线程管理。
- en: 'Some best practices for thread management include the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 线程管理的最佳实践包括以下内容：
- en: Favor Executor over direct thread creation
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用执行器而非直接创建线程
- en: Limit the number of thread pools you use to a minimum
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你使用的线程池数量限制在最小值
- en: Support thread interruptions in your code
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中支持线程中断
- en: Monitor and refine consistently
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续监控和优化
- en: 'Let’s look at a simple example to demonstrate proper thread usage. We will
    use the `Executor` framework. As you will see, the following application creates
    a fixed thread pool to run a set of tasks. Each task simulates a real-world operation
    by sleeping for a defined amount of time. As you walk through the code, you will
    see that the `Executor` framework is efficiently used to manage threads:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来展示正确的线程使用方法。我们将使用`Executor`框架。正如您将看到的，以下应用程序创建了一个固定线程池来运行一系列任务。每个任务通过暂停一段时间来模拟现实世界的操作。在您浏览代码的过程中，您将看到`Executor`框架被有效地用于管理线程：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sample application provides an efficient method of managing concurrency
    in a Java application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序提供了一种在Java应用程序中管理并发的高效方法。
- en: Java concurrency utilities
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java并发工具
- en: We are fortunate that the `java.util.concurrent` package contains a set of utilities
    we can use for **concurrency**. These utilities empower us to write thread-safe
    applications that are reliable and scalable. The utilities help us address common
    pitfalls and challenges in concurrent programming, including data consistency,
    life cycle management, and synchronization.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，`java.util.concurrent`包包含了一组我们可以用于**并发**的实用工具。这些工具使我们能够编写线程安全的应用程序，这些应用程序是可靠和可扩展的。这些工具帮助我们解决并发编程中的常见陷阱和挑战，包括数据一致性、生命周期管理和同步。
- en: The advantages of using the concurrency utilities that are part of the `java.util.concurrent`
    package includes making our applications more reliable, making them perform at
    a higher level, and simplifying the programming effort. Let’s look at five specific
    concurrency utilities.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.util.concurrent`包中包含的并发工具的优点包括使我们的应用程序更加可靠，使它们在更高的水平上运行，并简化编程工作。让我们看看五个具体的并发工具。
- en: Our first concurrency utility is the `Executor` framework that we previously
    covered. Looking at this framework closely reveals that there are multiple types
    of Executor services, including the `ScheduledExecutorService` interface. This
    interface can be used to introduce an execution delay. The primary interface,
    `ExecutorService`, empowers us to manage thread termination and helps us track
    our synchronous tasks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个并发工具是之前提到的`Executor`框架。仔细研究这个框架可以发现，存在多种类型的Executor服务，包括`ScheduledExecutorService`接口。此接口可用于引入执行延迟。主要接口`ExecutorService`使我们能够管理线程终止并帮助我们跟踪同步任务。
- en: '`CountDownLatch`, `CyclicBarrier`, `Exchanger`, `Phaser`, and `Semaphore`.
    If you need to improve your thread management in your Java application, these
    methods are worth reviewing in the Java documentation.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch`、`CyclicBarrier`、`Exchanger`、`Phaser`和`Semaphore`。如果您需要提高Java应用程序中的线程管理，这些方法在Java文档中值得回顾。'
- en: Three additional concurrency utilities are `java.util.concurrent.atomic package`.
    Locks, available in the `java.util.concurrent.locks` package, allow us to lock
    threads and waits until a specific condition is met. Lastly, concurrent collections
    provide thread-safe collections that have full support for concurrency.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 三个额外的并发工具是`java.util.concurrent.atomic`包。在`java.util.concurrent.locks`包中可用的锁允许我们锁定线程并等待直到满足特定条件。最后，并发集合提供了具有完整并发支持的线程安全集合。
- en: Now that we explored caching strategies, thread management, and the effective
    use of Java concurrency utility, you should be well-equipped to continue building
    high-performance Java applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了缓存策略、线程管理和Java并发工具的有效使用，您应该已经准备好继续构建高性能的Java应用程序。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took a deep look at the complexities of managing memory effectively
    to help prevent memory leaks. These leaks must be avoided at all costs because
    they can degrade our systems, ruin the user experience, and even result in system
    crashes. We identified that memory leaks typically occur due to improper referencing,
    which inhibits the garbage collector’s ability to deallocate memory. We focused
    on proper referencing, listeners and loaders, and caching and threads. You should
    now be equipped and confident to implement efficient memory leak avoidance strategies
    in your Java applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了有效管理内存的复杂性，以帮助防止内存泄漏。我们必须不惜一切代价避免这些泄漏，因为它们可能会降低我们的系统性能，破坏用户体验，甚至导致系统崩溃。我们确定了内存泄漏通常是由于不当引用引起的，这阻碍了垃圾收集器释放内存的能力。我们专注于正确的引用、监听器和加载器，以及缓存和线程。现在，您应该已经准备好并自信地实施有效的内存泄漏避免策略，以应用于您的Java应用程序。
- en: In the next chapter, *Concurrency Strategies*, we will cover the concepts of
    threads, synchronization, volatile, atomic classes, locks, and so on. We will
    leverage the thread-related content covered in this chapter to give us a head
    start as we dive deeper into concurrency. Through a hands-on approach, you can
    gain insights into concurrency in Java and adopt strategies to help make your
    Java programs highly performant.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*并发策略*中，我们将涵盖线程、同步、volatile、原子类、锁等概念。我们将利用本章中涵盖的线程相关内容，为我们深入研究并发提供一个先发优势。通过实践方法，您可以深入了解Java中的并发，并采用策略帮助您的Java程序性能更佳。
- en: 'Part 3: Concurrency and Networking'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：并发和网络
- en: Concurrency and networking are essential for modern Java applications, especially
    those requiring high throughput and low latency. This part introduces advanced
    concurrency strategies to manage multiple threads efficiently. It also covers
    connection pooling techniques to optimize network performance and explores the
    intricacies of hypertext transfer protocols. By understanding and applying these
    concepts, you will create highly responsive and scalable applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和网络对于现代Java应用程序至关重要，尤其是那些需要高吞吐量和低延迟的应用程序。本部分介绍了高级并发策略来高效地管理多个线程。它还涵盖了连接池技术以优化网络性能，并探讨了超文本传输协议的复杂性。通过理解和应用这些概念，您将创建高度响应和可扩展的应用程序。
- en: 'This part has the following chapters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B21942_09.xhtml#_idTextAnchor159), *Concurrency Strategies* *and
    Models*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21942_09.xhtml#_idTextAnchor159)，*并发策略*和*模型*'
- en: '[*Chapter 10*](B21942_10.xhtml#_idTextAnchor172), *Connection Pooling*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21942_10.xhtml#_idTextAnchor172)，*连接池*'
- en: '[*Chapter 11*](B21942_11.xhtml#_idTextAnchor189), *Hypertext Transfer Protocols*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21942_11.xhtml#_idTextAnchor189)，*超文本传输协议*'
