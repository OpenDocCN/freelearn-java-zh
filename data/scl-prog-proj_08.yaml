- en: Online Shopping - User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线购物 - 用户界面
- en: In this chapter, we are going to use Scala.js to build the user interface. In
    this interface, you can select a product to add to your cart, update the number
    of products that you wish to buy, and remove them from the cart if needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Scala.js 来构建用户界面。在这个界面中，你可以选择产品添加到购物车，更新你希望购买的产品数量，如果需要，也可以从购物车中移除它们。
- en: Scala.js is a project initiated by Sebastien Doeraene back in 2013\. This project
    is mature and provides a clean way to build frontend applications. Indeed, you
    can code with a strongly-typed system to avoid stupid mistakes, but this is not
    only for strong typing; the code—written in Scala—is compiled into a highly efficient
    JavaScript. It can interoperate with all of the JavaScript frameworks. Moreover,
    the code can be shared between the front-end and the back-end developers. This
    feature simplifies communication between developers, as they are using the same
    concepts and classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Scala.js 是由 Sébastien Doeraene 在 2013 年启动的项目。该项目已经成熟，提供了一种干净的方式来构建前端应用程序。实际上，你可以使用强类型系统来避免愚蠢的错误，但这不仅是为了强类型；用
    Scala 编写的代码被编译成高度高效的 JavaScript。它可以与所有的 JavaScript 框架互操作。此外，代码可以在前端和后端开发者之间共享。这个特性简化了开发者之间的沟通，因为他们使用的是相同的概念和类。
- en: Thanks to its interoperability, there are multiple ways to use Scala.js. You
    can use an HTML template and adapt it to interoperate with Scala.js. For example,
    you can buy the excellent SmartAdmin ([https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0](https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0))
    template (HTML5 version) as a base for the layout and all of the components/widgets,
    and then use Scala.js to implement the specific behaviors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其互操作性，Scala.js 有多种使用方式。你可以使用 HTML 模板并将其适配以与 Scala.js 互操作。例如，你可以购买优秀的 SmartAdmin
    ([https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0](https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0))
    模板（HTML5 版本）作为布局和所有组件/小部件的基础，然后使用 Scala.js 实现特定的行为。
- en: Another way is to start from scratch and build the HTML layout, CSS, components,
    and behaviors using the Scala.js ecosystem. This is the option that we will choose
    in this book. To generate the HTML and CSS, ScalaTags ([http://www.lihaoyi.com/scalatags/](http://www.lihaoyi.com/scalatags/))
    from Li Haoyi ([http://www.lihaoyi.com/](http://www.lihaoyi.com/)) will be used.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是从头开始构建 HTML 布局、CSS、组件和行为，使用 Scala.js 生态系统。这是本书中我们将选择的方法。为了生成 HTML 和 CSS，我们将使用
    Li Haoyi ([http://www.lihaoyi.com/](http://www.lihaoyi.com/)) 的 ScalaTags ([http://www.lihaoyi.com/scalatags/](http://www.lihaoyi.com/scalatags/))。
- en: This chapter will explain how to develop a dynamic web UI using Scala.js.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何使用 Scala.js 开发动态 Web UI。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Defining the layout
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义布局
- en: Creating the layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建布局
- en: Building the layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建布局
- en: Main layout
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主布局
- en: Product list panel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品列表面板
- en: Cart panel
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车面板
- en: Introducing the UI manager
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 UI 管理器
- en: Learning objectives
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习目标
- en: The objectives of this chapter are to introduce a user interface into our project
    and interact with the server to get data from it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是将用户界面引入我们的项目，并与服务器交互以从其中获取数据。
- en: 'More precisely, we will learn the following skills:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将学习以下技能：
- en: How to develop a simple web UI
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开发简单的 Web UI
- en: How to apply styles
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用样式
- en: How to interact with the server using a web service call
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Web 服务调用与服务器交互
- en: How to debug Scala code on the client side
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在客户端调试 Scala 代码
- en: Setting up
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Note that this setup has already been completed when you start using the template.
    The following steps are only for reference:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你开始使用模板时，此设置已经完成。以下步骤仅供参考：
- en: 'To enable Scala.js with Play, you first need to add the following code to `project`/`plugins.sbt`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 Scala.js 与 Play，你首先需要将以下代码添加到 `project/plugins.sbt`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `build.sbt`, you need to add the plugins by adding the following code
    in the `client` variable:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 文件中，你需要在 `client` 变量中添加插件，通过以下代码实现：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You need to add the ScalaTags dependency by adding the following in `libraryDependencies`
    of the client configuration:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在客户端配置的 `libraryDependencies` 中添加 ScalaTags 依赖项，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Defining the layout
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义布局
- en: 'For the purpose of this book, the shopping cart is designed as shown in the
    following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，购物车被设计如下所示：
- en: '![](img/6ff8c185-587f-4c23-8bb9-6d9509b41240.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ff8c185-587f-4c23-8bb9-6d9509b41240.png)'
- en: On the left-hand side, a panel lists all of the products with all of their details.
    Underneath, a button adds the product to the cart. On the right-hand panel, there
    is a list of all of the products that have been added to the cart. On the **Cart Panel**,
    the number of products can be changed by clicking on the number and entering the
    right number. Each line has a button to delete the product from the list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，一个面板列出了所有产品及其详细信息。下方有一个按钮可以将产品添加到购物车中。在右侧面板中，有一个已添加到购物车的所有产品的列表。在**购物车面板**中，可以通过点击数字并输入正确的数字来更改产品的数量。每一行都有一个按钮可以删除列表中的产品。
- en: Creating the layout
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布局
- en: Multiple technologies are used to create the layout—more specifically, the top
    layout—using the `<html>` and `<body>` tags, and the two `div` containers for
    the products and the cart panels respectively are going to be built with a Play
    template engine, named Twirl. Using this template, the inner HTML of the product
    and cart instances of `div` are going to be filled with ScalaTags.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<html>`和`<body>`标签以及两个`div`容器（分别用于产品和购物车面板）来创建布局，使用了多种技术——更具体地说，是顶部布局——这些容器将使用名为Twirl的Play模板引擎构建。使用这个模板，`div`实例的产品和购物车内部的HTML将被ScalaTags填充。
- en: Let's first create the main entry point. We named it `index.html`, and it is
    implemented by creating a file called `index.scala.html` in the `view` package
    of the server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建主入口点。我们将其命名为`index.html`，并在服务器的`view`包中创建一个名为`index.scala.html`的文件来实现它。
- en: 'The content is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内容如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file looks like a standard HTML file. In fact, this file is a template
    that is processed by the server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件看起来像一个标准的HTML文件。实际上，这个文件是一个由服务器处理的模板。
- en: The first line starts with an `@` character. It defines the input parameter
    that is passed by the caller, but who is calling this template? It is the `index()`
    function in the `Application` controller that calls the template, and effectively,
    the template is called by using the title of the page.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以一个`@`字符开始。它定义了调用者传递的输入参数，但谁在调用这个模板？是`Application`控制器中的`index()`函数在调用模板，实际上，模板是通过使用页面标题来调用的。
- en: On the line starting with `@scalajs.html.scripts`, we are using a helper method
    provided by the `sbt-web-scalajs` plugin. This method retrieves all of the scripts
    generated by the `client` Scala.js project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以`@scalajs.html.scripts`开始的行中，我们正在使用由`sbt-web-scalajs`插件提供的辅助方法。此方法检索由`client`
    Scala.js项目生成的所有脚本。
- en: The two instances of `div` are going to be set from the code; we will look at
    this in more detail in the next chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`div`实例将由代码设置；我们将在下一章中更详细地探讨这一点。
- en: Building the page
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建页面
- en: 'We will have two main sections on the main page: the product list and the cart.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主页上有两个主要部分：产品列表和购物车。
- en: To create the layout, we could use basic HTML tags, such as `table` and `div`,
    but this is quite laborious for our task. Instead, let's introduce a framework
    named Bootstrap ([https://getbootstrap.com/](https://getbootstrap.com/)[).](https://getbootstrap.com/)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建布局，我们可以使用基本的HTML标签，如`table`和`div`，但这对于我们这个任务来说相当繁琐。相反，让我们引入一个名为Bootstrap的框架（[https://getbootstrap.com/](https://getbootstrap.com/)）。
- en: This open source framework is widely used and very mature. It allows us to build
    a responsive website based on a grid, with a lot of components such as notifications,
    menus, badges, and tooltips. Bootstrap needs a CSS and some JavaScript libraries
    to work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开源框架被广泛使用，并且非常成熟。它允许我们基于网格构建一个响应式网站，包含许多组件，如通知、菜单、徽章和工具提示。Bootstrap需要CSS和一些JavaScript库才能工作。
- en: 'For now, we just need to add the Bootstrap CSS by adding the link in the HTML
    header, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要通过在HTML头部添加链接来添加Bootstrap CSS，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Main layout
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主布局
- en: In Bootstrap, a grid is a container composed of rows, each with 12 columns.
    A `class` attribute is used to define the type of `div`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap中，一个网格是由行组成的容器，每行有12列。一个`class`属性用于定义`div`的类型。
- en: So, in our case, we would like to have the product list occupy two-thirds of
    the screen, with the cart getting the rest of `row`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，我们希望产品列表占据屏幕的三分之二，购物车则占据剩余的`row`。
- en: 'The structure of the body in our `index.scala.html` is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index.scala.html`中的body结构如下：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Product list panel
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表面板
- en: To structure our HTML page, we are going to create a panel called `productPanel`.
    This panel is a container for all product details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结构化我们的HTML页面，我们将创建一个名为`productPanel`的面板。这个面板是所有产品详细信息的容器。
- en: 'A product is defined with a name, description, and button to add it to the
    cart, as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 产品通过名称、描述和添加到购物车的按钮来定义，如下面的截图所示：
- en: '![](img/a5831e93-4191-4718-b456-44238369c614.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a5831e93-4191-4718-b456-44238369c614.png)'
- en: 'As we have multiple products, we would like to add each one in `productPanel`
    and fit the total width of `productPanel`, as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有多个产品，我们希望在`productPanel`中添加每个产品，并适应`productPanel`的总宽度，如下面的截图所示：
- en: '![](img/1f47f425-56d8-4cf7-97d3-6e578e1ed0c4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1f47f425-56d8-4cf7-97d3-6e578e1ed0c4.png)'
- en: 'To reach this goal, we can recreate a row inside `productPanel`, with `products`
    forming a column of the row, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，我们可以在`productPanel`内部重新创建一个行，其中`products`形成行的列，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There we go. The main layout is done. Now we have to create the HTML product's
    representation as `div`, with its name, description, price, and a button to add
    it to the cart.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经完成了主要布局。现在我们需要创建HTML产品的表示，作为一个`div`，包括其名称、描述、价格以及一个添加到购物车的按钮。
- en: This looks almost the same as what we did when we modeled the product for the
    database. Wouldn't it be great if we could reuse the model created on the server
    side on the client? As we are using Scala.js, this is possible; indeed, we are
    using the same language. This is what we call an **isomorphic** **application**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎和我们为数据库建模产品时所做的相同。如果我们可以重用服务器端创建的模型在客户端使用，那岂不是很好？因为我们使用Scala.js，这是可能的；实际上，我们正在使用相同的语言。这就是我们所说的**同构****应用程序**。
- en: All we have to do is move the model code from the server project to the shared
    project. Using IntelliJ, just drag the `Models.scala` file from `server/app/models`
    to `shared/src/main/scala/io/fscala/shopping/shared`. By doing so, we can use
    the same model to create our product representation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是将模型代码从服务器项目移动到共享项目。使用IntelliJ，只需将`Models.scala`文件从`server/app/models`拖到`shared/src/main/scala/io/fscala/shopping/shared`。这样做，我们就可以使用相同的模型来创建我们的产品表示。
- en: Create a new class named `ProductDiv` under `client/src/main/scala/io/fscala/shopping`.
    This class represents the HTML content of a product with a button to add itself
    to the cart.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client/src/main/scala/io/fscala/shopping`下创建一个名为`ProductDiv`的新类。这个类代表一个产品带有添加到购物车按钮的HTML内容。
- en: 'The `ProductDiv` class contains the `Product` model, and looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDiv`类包含`Product`模型，如下所示：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main method is the `content` method. It creates the product description
    and the button.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法是`content`方法。它创建产品描述和按钮。
- en: The `getProductDescription` method creates an HTML `div` with a paragraph for
    each of its properties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProductDescription`方法创建一个HTML`div`，并为每个属性创建一个段落。'
- en: The `getButton()` method creates an HTML button and uses the `addToCart` function
    to handle the `onclick` event. For now, we are not going to look at the implementation
    details of the `onclick` event.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`getButton()`方法创建一个HTML按钮，并使用`addToCart`函数处理`onclick`事件。现在我们不会查看`onclick`事件的实现细节。'
- en: Cart panel
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车面板
- en: 'The cart panel is a representation of the cart. It has a line for every product
    that is added, displaying the number of items, the name of the item type, the
    total price, and a button to remove it from the cart, as shown in the following
    screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车面板是购物车的表示。它为每个添加的产品有一条线，显示项目数量、项目类型名称、总价以及一个从购物车中移除它的按钮，如下面的截图所示：
- en: '![](img/bb709f62-78c1-4eb9-8cea-4561a58391af.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![代码截图](img/bb709f62-78c1-4eb9-8cea-4561a58391af.png)'
- en: 'We would like to add a line each time a new product is added to the cart, as
    shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在每次添加新产品到购物车时都添加一行，如下面的截图所示：
- en: '![](img/0113d396-0a16-47a6-ae9e-020e6906ef59.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![代码截图](img/0113d396-0a16-47a6-ae9e-020e6906ef59.png)'
- en: 'In this case, we do not need to modify the main layout as we are going to represent
    each line as a row with columns. The model of a line in the cart is shown in the
    following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要修改主要布局，因为我们打算将每一行表示为一个带有列的行。购物车中行的模型如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The HTML content of the cart is shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车的HTML内容如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code is for a row with four columns. The code for the button to
    delete it from the cart (`getDeleteButton`) is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是为有四个列的行。从购物车中删除按钮的代码（`getDeleteButton`）如下所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note how you can add a listener to an event emitted by the component just by
    adding the method name on the `onclick` event. For now, we are not going to implement
    the action, and will leave it unimplemented (`???`), as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你只需在`onclick`事件上添加方法名，就可以向组件发出的事件添加监听器。目前，我们不会实现这个动作，并将它留作未实现（`???`），如下面的代码所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `input` text field representing the quantity in the cart (`quantityInput`)
    is written as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表示购物车中数量（`quantityInput`）的`input`文本字段编写如下：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Again, on the `onchange` event, we call the `changeQty` function, defined as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在`onchange`事件上，我们调用以下定义的`changeQty`函数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The product name (`getProductLabel`) is written as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 产品名称（`getProductLabel`）编写如下：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the total price is written as `getPriceLabel`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，总价格被写入`getPriceLabel`，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we will have the definition of a line in the cart, we can define the cart's `div`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将有购物车中的行定义，我们可以定义购物车的`div`。
- en: 'This `div` should provide an HTML representation of all of the lines and allow
    you to add a cart `line`. The implementation is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`div`应该提供所有行的HTML表示，并允许你添加购物车`line`。实现如下：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Upon its creation, `CartDiv` receives the list of lines represented by the `lines`
    value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，`CartDiv`接收由`lines`值表示的行列表。
- en: To get the HTML representation, the `content` function is called. In this function,
    we create an empty `div` and then append each `CartLine` into that `div`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取HTML表示，调用`content`函数。在这个函数中，我们创建一个空的`div`，然后将每个`CartLine`追加到该`div`中。
- en: This is implemented using `foldLeft`. The empty `div` is created as the initial
    value, and then for each `CartLine` an anonymous function is called with `(a,
    b)` as parameters. The `a` parameter is the previous value (the empty `div` on
    the first iteration) and the `b` parameter is the next `CartLine` of the collection.
    The body of the method just appends the content of `CartDiv` to `div` and returns
    `div` for the next iteration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`foldLeft`实现的。空`div`作为初始值被创建，然后对于每个`CartLine`，都会调用一个匿名函数，参数为`(a, b)`。`a`参数是前一个值（第一次迭代时的空`div`），而`b`参数是集合中的下一个`CartLine`。该方法体只是将`CartDiv`的内容追加到`div`中，并返回`div`以供下一次迭代。
- en: We added a function to add a product to `div` (`addProduct()`). We could have
    implemented this method by creating a mutable variable that holds the list of
    `CartLine` and updates it each time we want to add `CartLine`, but this would
    not be in the spirit of functional programming.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个函数来将产品添加到`div`中（`addProduct()`）。我们本可以通过创建一个可变变量来持有`CartLine`列表，并在每次想要添加`CartLine`时更新它来实现这个方法，但这不符合函数式编程的精神。
- en: Instead, a new `CartDiv` with `new CartLine` that we added is returned from
    the function call.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，从函数调用中返回一个新的`CartDiv`，其中包含我们添加的`new CartLine`。
- en: Now that we have defined the product `div` and the cart `div`, it is time to
    build the interaction between these instances of `div`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了产品`div`和购物车`div`，是时候构建这些`div`实例之间的交互了。
- en: Introducing the UI manager
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍UI管理器
- en: At some point, we will need to have a class that is responsible for the workflow
    of the user experience. For example, when a user clicks on the Add to cart button,
    the product has to be added to the cart at the server level and the user interface
    has to be updated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们需要有一个负责用户体验工作流程的类。例如，当用户点击“添加到购物车”按钮时，产品必须在服务器级别添加到购物车中，并且用户界面需要更新。
- en: The UI manager takes responsibility for managing the workflow of the user experience,
    handling all communication with the server when needed, and is used as an entry
    point to start the Scala.js code. This is the main entry point of our client application
    when the application is executed in the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: UI管理器负责管理用户体验的工作流程，在需要时处理与服务器的所有通信，并用作启动Scala.js代码的入口点。这是当应用程序在浏览器中执行时，我们客户端应用程序的主要入口点。
- en: For communicating with the server, we are going to use jQuery. This JavaScript
    library is widely used and is a reference in the JavaScript world.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与服务器通信，我们将使用jQuery。这个JavaScript库被广泛使用，并在JavaScript世界中是一个参考。
- en: This is one of the advantages of Scala.js. We can use existing JavaScript libraries,
    such as jQuery, from Scala. To use existing JavaScript libraries, we only need
    to define an interface, which is called a **facade** in Scala.js. The facade can
    be seen as an interface to redefine the JavaScript type and the JavaScript function
    signature. It means we need a facade for all of the JavaScript libraries we want
    to use. Fortunately, there are already a number of facades that already exist
    for the most important JavaScript frameworks. A list of available facades can
    be found at the Scala website ([https://www.scala-js.org/libraries/facades.html](https://www.scala-js.org/libraries/facades.html)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Scala.js的一个优点之一。我们可以从Scala中使用现有的JavaScript库，如jQuery。要使用现有的JavaScript库，我们只需要定义一个接口，在Scala.js中称为**facade**。facade可以看作是重新定义JavaScript类型和JavaScript函数签名的接口。这意味着我们需要为所有我们想要使用的JavaScript库创建一个facade。幸运的是，已经存在许多为最重要的JavaScript框架创建的facade。可以在Scala网站上找到可用facade的列表（[https://www.scala-js.org/libraries/facades.html](https://www.scala-js.org/libraries/facades.html)）。
- en: Adding jQuery to our project
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将jQuery添加到我们的项目中
- en: To add jQuery and its facade into our project, we need to add the Scala facade
    and the JavaScript library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将jQuery及其facade添加到我们的项目中，我们需要添加Scala facade和JavaScript库。
- en: 'For the facade, add the following dependency to the `libraryDependencies` variable
    in the `build.sbt` file :'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于facade，将以下依赖项添加到`build.sbt`文件中的`libraryDependencies`变量中：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To add the JavaScript library, add the following dependency to the `jsDependencies` variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加JavaScript库，将以下依赖项添加到`jsDependencies`变量中：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the first library we are using in which we are adding a WebJar as a
    JavaScript library. This WebJar is a repository of JavaScript libraries packaged
    as a JAR file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在其中添加WebJar作为JavaScript库的第一个库。这个WebJar是一个将JavaScript库打包成JAR文件的仓库。
- en: Calling our API
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们的API
- en: The first call we have to perform is the login to the server. For the purposes
    of this book, we have not designed a proper login page. Besides, the login itself
    is not really a login as it accepts any user!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须执行的第一步调用是登录到服务器。为了本书的目的，我们没有设计一个合适的登录页面。此外，登录本身也不是真正的登录，因为它接受任何用户！
- en: We are going to log in with a random user every time we browse the index of
    the website.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们浏览网站索引时，我们都会使用一个随机用户登录。
- en: By the way, what is the entry point of our client application?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，我们的客户端应用程序的入口点是什么？
- en: Setting the main method
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主方法
- en: 'By default, Scala.js only creates a JavaScript library with all your dependencies.
    To make it an application, you have to add the client configuration of the `build.sbt` file,
    as shown in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Scala.js只创建一个包含所有依赖项的JavaScript库。要使其成为一个应用程序，你必须添加`build.sbt`文件的客户端配置，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once defined, Scala.js looks for an object containing the `main` method, as
    in a normal JVM application. We can create that object in the `client/src/main/scala/io/fscala/shopping/client` folder. Create
    a Scala file named `UIManager.scala`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，Scala.js会寻找包含`main`方法的对象，就像一个正常的JVM应用程序一样。我们可以在`client/src/main/scala/io/fscala/shopping/client`文件夹中创建该对象。创建一个名为`UIManager.scala`的Scala文件。
- en: 'In the `main` function, we would like to log in to the API and initialize the
    interface with `ProductDiv` and `CartDiv`, which we defined earlier, as shown
    in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们希望登录到API，并使用我们之前定义的`ProductDiv`和`CartDiv`初始化接口，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We define three properties on the `UIManager` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`UIManager`对象上定义了三个属性：
- en: The first is the `origin` property. This property uses the `dom` utility object
    from Scala.js; we will get `document.location.origin` from it. This represents
    the server location, with the protocol, hostname, and port. In development mode,
    this looks like `http://locahost:9000`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是`origin`属性。该属性使用Scala.js的`dom`实用工具对象；我们将从其中获取`document.location.origin`。这代表服务器位置，包括协议、主机名和端口。在开发模式下，它看起来像`http://locahost:9000`。
- en: The second property is `cart`, representing `CartDiv`. This is to keep a reference
    to it on the manager for later use. In the `main` function, we perform the login
    with a hardcoded user and, once successful, we initialize the user interface.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性是`cart`，表示`CartDiv`。这是为了在管理器中保持对其的引用以供以后使用。在`main`函数中，我们使用硬编码的用户进行登录，一旦成功，我们初始化用户界面。
- en: The last property is `dummyUserName`, representing a randomly generated username.
    This will simplify the code as we are not going to implement a real login process.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性是`dummyUserName`，表示一个随机生成的用户名。这将简化代码，因为我们不会实现真正的登录过程。
- en: Note how we can use jQuery from Scala. This is the beauty of the facade—we can
    use almost the same syntax as in JavaScript but with the advantage of strong Scala
    typing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何从 Scala 使用 jQuery。这是外观模式的美丽之处——我们可以使用几乎与 JavaScript 相同的语法，但具有强 Scala 类型化的优势。
- en: For example, to create the settings of the `post` call, we can use a method
    on the `JQueryAjaxSettings` object instead of creating a `Map` with a string as
    a key and anything as a value. This way, it is less error-prone, and we can take
    advantage of the IDE to autocomplete all of the possible properties.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建 `post` 调用的设置，我们可以使用 `JQueryAjaxSettings` 对象上的一个方法，而不是创建一个以字符串为键、任何内容为值的
    `Map`。这样，它更不容易出错，我们可以利用 IDE 自动完成所有可能的属性。
- en: 'The signature of the `done` jQuery function is `Function` (`PlainObject` data,
    `String textStatus`, jqXHR). You can find out more about these types on the jQuery
    website:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`done` jQuery 函数的签名是 `Function` (`PlainObject` data, `String textStatus`, jqXHR)。你可以在
    jQuery 网站上了解更多关于这些类型的信息：'
- en: '[http://api.jquery.com/Types/#Function](http://api.jquery.com/Types/#Function)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/Types/#Function](http://api.jquery.com/Types/#Function)'
- en: '[http://api.jquery.com/Types/#PlainObject](http://api.jquery.com/Types/#PlainObject)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/Types/#PlainObject](http://api.jquery.com/Types/#PlainObject)'
- en: '[http://api.jquery.com/Types/#String](http://api.jquery.com/Types/#String)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/Types/#String](http://api.jquery.com/Types/#String)'
- en: '[http://api.jquery.com/Types/#jqXHR](http://api.jquery.com/Types/#jqXHR)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/Types/#jqXHR](http://api.jquery.com/Types/#jqXHR)'
- en: 'This function takes three parameters, but as we are just interested in the
    first one, the `data` response, we can ignore the others. This is a particularity
    of JavaScript. The implementation of the corresponding facade is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数，但因为我们只对第一个参数感兴趣，即 `data` 响应，我们可以忽略其他参数。这是 JavaScript 的一个特性。相应的外观模式的实现如下：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function uses variadic parameters, noted with the asterisk character after
    the type. This is a perfect match with JavaScript, where the parameters are not
    mandatory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用可变参数，类型后面带有星号字符。这与 JavaScript 完美匹配，在 JavaScript 中参数不是强制的。
- en: It is now time to look at the creation of the user interface based on the data
    coming from the server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候查看基于从服务器传来的数据创建用户界面的过程了。
- en: Initializing the user interface
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化用户界面
- en: 'To initialize the user interface, we need to get all of the products from the
    database—including the cart for the user, if there are any—through the web service
    API and add it to the layout. The code for this looks like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化用户界面，我们需要通过 Web 服务 API 从数据库中获取所有产品——包括用户的购物车（如果有）——并将其添加到布局中。这个代码看起来如下所示：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will come as no surprise that we use jQuery to perform the `GET` method on
    the API. The `dataType` asks for a text response, so that we can use Circe to
    parse the response and transform it into a sequence of `Product`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不会令人惊讶的是，我们使用 jQuery 在 API 上执行 `GET` 方法。`dataType` 请求文本响应，这样我们就可以使用 Circe 解析响应并将其转换为
    `Product` 序列。
- en: But, is `decode[Seq[Product]]` the same code that we used in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, the REST API, when we received JSON and converted it
    into a class?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`decode[Seq[Product]]` 是否与我们在 [第 2 章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”，REST
    API 中使用的相同代码，当时我们接收 JSON 并将其转换为类？
- en: Yes, we are using the same code with the same framework (Circe) to decode JSON
    and encode the class to JSON! The code running on the server, compiled as a JVM
    bytecode, is the same as the one running on the client, compiled as JavaScript.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们正在使用相同的代码和相同的框架（Circe）来解码 JSON 并将类编码为 JSON！在服务器上运行的代码，编译为 JVM 字节码，与在客户端运行的代码，编译为
    JavaScript 的代码相同。
- en: Once we get the list of products, for each of them, we add `ProductDiv` in the `products`
    container. Again, jQuery is used to get an HTML element using its `id` attribute.
    At this point, knowledge of jQuery is more important than the Scala syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到产品列表，对于每一个产品，我们在 `products` 容器中添加 `ProductDiv`。再次，jQuery 被用来通过其 `id`
    属性获取 HTML 元素。在这个阶段，jQuery 的知识比 Scala 语法更重要。
- en: The product panel is set up. Now it is the cart's turn.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 产品面板已设置。现在轮到购物车了。
- en: 'The `initCartUI()` function is responsible for creating the HTML code representing
    the cart.The cart for the user is taken from the server. We cast it to a `Cart `sequence and,
    for each of them, we get the corresponding product in order to have the name and
    price. Finally we append the line in `CartDiv`, as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`initCartUI()`函数负责创建表示购物车的HTML代码。用户的购物车从服务器获取。我们将其转换为`Cart`序列，并为每个序列，我们获取相应的产品以获取名称和价格。最后，我们将行追加到`CartDiv`中，如下面的代码所示：'
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In case of failure, we just print the error in the browser console.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生失败，我们只需在浏览器控制台中打印错误。
- en: With all this code, our user interface is now initialized. We can now implement
    the action on the user interface that we left unimplemented.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些代码，我们的用户界面现在已初始化。我们现在可以实现对用户界面中未实现的操作。
- en: Implementing UI actions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UI操作
- en: When the application is started, the user interface is the representation of
    the database in terms of the product and the user cart.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，用户界面是数据库中产品和用户购物车的表示。
- en: In this chapter, we will implement actions such as adding a product to the cart,
    updating the quantity to buy, and removing a product from the cart.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现添加产品到购物车、更新购买数量和从购物车中删除产品等操作。
- en: Adding a product to the cart
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加产品到购物车
- en: To add a product to the cart, we have to click on the Add to cart button of
    the product panel. We need to edit `ProductDiv` again and implement the `addToCart`
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将产品添加到购物车，我们必须点击产品面板上的“添加到购物车”按钮。我们需要再次编辑`ProductDiv`并实现`addToCart`方法。
- en: 'As we said in the *Introducing the UI manager* section of this chapter, we
    would like to delegate the user interface manipulation to the `UIManager` class,
    so the `addToCart` method implementation is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在本章的“介绍UI管理器”部分所说，我们希望将用户界面操作委托给`UIManager`类，因此`addToCart`方法的实现如下：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Indeed, we are asking `UIManager` to add the product to the cart. The `UIManager`
    builds a `div` representing the product in the cart, and if it is already in the
    cart, nothing happens.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们正在请求`UIManager`将产品添加到购物车。`UIManager`构建一个表示购物车中产品的`div`，如果它已经在购物车中，则不会发生任何操作。
- en: 'The implementation is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `postInCart` method is called with the product code and the initial quantity
    of one to create a new entry in the `Cart` table. Once created, the `onDone()` method is
    called. This method adds the HTML elements that are needed to visualize the cart
    line in the user interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品代码和初始数量一，调用`postInCart`方法在`Cart`表中创建一个新条目。一旦创建，就调用`onDone()`方法。此方法添加了在用户界面中可视化购物车行的HTML元素。
- en: 'The `postInCart` method receives `productCode`, the quantity, and the method
    to call once the web service call is a success, as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`postInCart`方法接收`productCode`、数量以及一旦网络服务调用成功要调用的方法，如下面的代码所示：'
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the web service call is a failure, we just print the error in the browser
    console and nothing is added to the user interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络服务调用失败，我们只需在浏览器控制台中打印错误，并且不会向用户界面添加任何内容。
- en: Removing a product from the cart
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从购物车中删除产品
- en: 'The action to remove a product from the cart is triggered when the X button
    related to a cart entry is clicked. This is implemented in the `removeFromCart()`
    method, located in the `CartLine` class. This is similar to the method we used
    in the previous section. The code is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击与购物车条目相关的X按钮时，触发从购物车中删除产品的操作。这是在`CartLine`类中的`removeFromCart()`方法中实现的。这与我们在上一节中使用的方法类似。代码如下：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We delegate the action to `UIManager`, and the implementation is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将操作委托给`UIManager`，实现如下：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time, we call the `deleteFromCart` method and remove the row with the related
    ID.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们调用`deleteFromCart`方法并删除与相关ID关联的行。
- en: 'The implementation of the web service call is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务调用的实现如下：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As jQuery does not have a `delete()` method, we have to use the `ajax()` method
    and set the HTTP method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于jQuery没有`delete()`方法，我们必须使用`ajax()`方法并设置HTTP方法。
- en: Updating the quantity
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数量
- en: To update the quantity of a product in the cart, an HTML input text is used.
    As soon as the value is changed, we update the database with the new value. The
    `onchange()` event of the input text is used for this purpose.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新购物车中产品的数量，使用HTML输入文本。一旦值改变，我们就使用新的值更新数据库。为此目的使用输入文本的`onchange()`事件。
- en: 'It should come as no surprise that, in `CartDiv`, as we did previously, we
    delegate the call to `UIManager`, as shown in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，在 `CartDiv` 中，正如我们之前所做的那样，我们将调用委托给 `UIManager`，如下代码所示：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The implementation of `updateProduct` is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateProduct` 的实现如下：'
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We call the web service using the `quantity` set in `inputText`. The method
    to get the quantity is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在 `inputText` 中设置的 `quantity` 调用网络服务。获取数量的方法是如下：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We get the quantity from the HTML input text element. If it exists, we parse
    it as an integer. If the field does not exist or we are having a parsing error
    (a letter is inputted), we return the quantity of `1`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 HTML 输入文本元素中获取数量。如果它存在，我们将其解析为整数。如果字段不存在或我们遇到解析错误（输入了字母），我们返回数量 `1`。
- en: 'The web service call to update the product quantity is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更新产品数量的网络服务调用如下：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There we are. We have finished the implementation of the user interface for
    the shopping cart.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里为止。我们已经完成了购物车用户界面的实现。
- en: It is time to deploy it and check whether it works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候部署它并检查它是否正常工作了。
- en: Deploying the user interface
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署用户界面
- en: 'To deploy from the command line in the root of your project, enter the following
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目根目录的命令行中部署，请输入以下代码：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once the deployment is a success, you can browse [https://shopping-fs.herokuapp.com/](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json). The
    interface will be displayed as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署成功，您可以通过浏览 [https://shopping-fs.herokuapp.com/](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json)
    来查看。界面将显示如下截图所示：
- en: '![](img/7a9cd9db-8f6c-4550-8325-981034bf2ad0.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a9cd9db-8f6c-4550-8325-981034bf2ad0.png)'
- en: You can now play with the interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以玩转界面。
- en: Debugging the interface
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试界面
- en: During development, we will not write the right code on the first draft. As
    humans, we make mistakes and do not perfectly remember all of the framework that
    we use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们不会在第一稿中写出正确的代码。作为人类，我们会犯错误，并且不会完美地记住我们使用的所有框架。
- en: In this chapter, we would like to give an entry point into debugging the code.
    The most obvious debugging system is to print in the console of the browser. This
    is done by directly using `println()` in Scala, and then looking at the log that
    is displayed in the console.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望提供一个调试代码的入口点。最明显的调试系统是在浏览器的控制台中打印。这是通过直接在 Scala 中使用 `println()` 来完成的，然后查看控制台显示的日志。
- en: To have a look at the console and other debugging tools, you have to enable
    the developer tools on your browser. I am using Safari on Macintosh, but if you
    do not want to use it, I would recommend Google Chrome; the features are almost
    the same.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看控制台和其他调试工具，您必须在浏览器中启用开发者工具。我使用的是 Macintosh 上的 Safari，但如果您不想使用它，我推荐使用 Google
    Chrome；功能几乎相同。
- en: In Safari, enable the developer tools by clicking on the Show Develop menu in
    menu bar checkbox from the Advanced Preferences.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Safari 中，通过点击菜单栏中的“显示开发”菜单旁边的复选框来启用开发者工具。
- en: 'Once done, a new Develop menu will appear. Open this menu and select Show JavaScript
    Console. A new section will appear in the Safari window with the console. If you
    click on the button to delete a cart row, a log is printed in the console, as
    shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将出现一个新的“开发”菜单。打开此菜单并选择“显示 JavaScript 控制台”。在 Safari 窗口中将出现一个包含控制台的新部分。如果您点击删除购物车行按钮，控制台将打印出日志，如下截图所示：
- en: '![](img/34173816-d2d5-4d88-a189-52a312f71fd2.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34173816-d2d5-4d88-a189-52a312f71fd2.png)'
- en: You can interact with JavaScript by typing anything in the last line of the
    console.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在控制台最后一行输入任何内容与 JavaScript 进行交互。
- en: 'For example, if you input `$("#productPanel")`, then the product `div` is selected,
    and you can inspect it, as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您输入 `$("#productPanel")`，则产品 `div` 被选中，您可以检查它，如下截图所示：
- en: '![](img/d9165c82-2284-4532-8be3-379cc95374bd.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9165c82-2284-4532-8be3-379cc95374bd.png)'
- en: The inspect element code of the web page
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的检查元素代码
- en: 'You can even run tests. If you input `$("#productPanel").remove()`, the `div`
    will be removed from `dom` and your page will look like the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以运行测试。如果您输入 `$("#productPanel").remove()`，则 `div` 将从 `dom` 中移除，您的页面将看起来如下截图所示：
- en: '![](img/aa7483bd-c569-4a58-b7c5-0c09209ed5d6.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa7483bd-c569-4a58-b7c5-0c09209ed5d6.png)'
- en: The inspect element code for the test
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的检查元素代码
- en: Refresh the page to get back to the product list. You can even debug the Scala
    code from inside the browser.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面以返回产品列表。你甚至可以从浏览器内部调试Scala代码。
- en: You need to have the project in development mode to have the necessary files
    generated for debugging (the source maps files).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将项目置于开发模式，以便生成调试所需的必要文件（源映射文件）。
- en: 'Click on the Debugger tab and look for `UIManager.scala` on the left-hand panel,
    under `Sources/client-fast-opt.js`, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 点击调试选项卡，在左侧面板的`Sources/client-fast-opt.js`下查找`UIManager.scala`，如下截图所示：
- en: '![](img/50f1f776-4826-43f6-b9b8-1fcdb7c689e7.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50f1f776-4826-43f6-b9b8-1fcdb7c689e7.png)'
- en: The UIManager.scala source code
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: UIManager.scala源代码
- en: Once `UIManager.scala` is selected, you can see the Scala source on the middle
    panel. Click on the gutter in line **30**. A breakpoint will be set when the UI
    is initialized and product `div` instances are appended.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择`UIManager.scala`，你可以在中间面板上看到Scala源代码。点击第**30**行的侧边栏。当UI初始化并且产品`div`实例被附加时，将会设置一个断点。
- en: If you refresh the page, the engine will stop at that point and, on the right-hand
    panel, you will have all of the variables, even the local variables, such as `p`,
    representing the product to add at this point.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新页面，引擎将在该点停止，在右侧面板上，你将拥有所有变量，包括局部变量，例如`p`，代表此点要添加的产品。
- en: 'Click on the Continue script execution button, as shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 点击继续脚本执行按钮，如下截图所示：
- en: '![](img/76838a18-ada5-4ea6-903e-e2fc81e1d165.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76838a18-ada5-4ea6-903e-e2fc81e1d165.png)'
- en: The script will continue until the next element in the collection, and the `p`
    variable on the right-hand panel will be updated with the next element.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将继续执行，直到集合中的下一个元素，并且右侧面板上的`p`变量将更新为下一个元素。
- en: I've just scratched the surface of all of the Develop menu possibilities. You
    can have metrics that govern the time spent to load elements in the page and to
    process, inspect, and change any HTML elements in the page.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚触及了“开发”菜单所有可能性的表面。你可以有度量标准来控制页面元素加载和处理的耗时，以及检查和更改页面中的任何HTML元素。
- en: For more information, read the official documentation for Safari ([https://support.apple.com/en-in/guide/safari-developer/welcome/mac](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)[)](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)
    and for Google Chrome ([https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅Safari的官方文档([https://support.apple.com/en-in/guide/safari-developer/welcome/mac](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)[)](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)和Google
    Chrome([https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/))。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to build a user interface from scratch by first
    creating a mockup of the interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从头开始构建用户界面，首先创建界面的原型。
- en: Then, we implemented the main layout, representing the skeleton of the application
    with all of the files that need to be linked, such as the CSS files and scripts.
    Once the layout was ready, we modeled the different HTML parts of the user interface
    in Scala, such as the product panel and the cart panel. The last step was to create
    the navigation system and user interaction. For that purpose, we created a UI
    manager, responsible for all the interaction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了主要布局，用所有需要链接的文件表示应用程序的骨架，例如CSS文件和脚本。一旦布局准备就绪，我们就用Scala建模用户界面的不同HTML部分，例如产品面板和购物车面板。最后一步是创建导航系统和用户交互。为此，我们创建了一个UI管理器，负责所有交互。
- en: As a side note, our user interface is pretty simple, without much interaction.
    This is why we chose to write the UI manager by hand. If the interface becomes
    more complex, then it might be useful to use a framework to manage it. At the
    time of writing, React.js and Angular are two of the most popular frameworks.
    Be aware, however, that frameworks come with a learning curve, and can quickly
    become obsolete.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们的用户界面相当简单，没有太多交互。这就是我们选择手动编写UI管理器的原因。如果界面变得更加复杂，那么使用框架来管理它可能是有用的。在撰写本文时，React.js和Angular是最受欢迎的两个框架。然而，请注意，框架的学习曲线可能很陡峭，并且可能会迅速过时。
- en: Another solution would be to use Akka.js and more specifically the FSM actor
    to manage your user interface. After all, this is a state machine, reacting and
    acting based on events. This will be developed in the next chapter on the automatic
    price updater.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 Akka.js，更具体地说，使用 FSM actor 来管理您的用户界面。毕竟，这是一个状态机，根据事件进行反应和行动。这将在下一章关于自动价格更新器的内容中展开。
- en: We also looked at the debugging facilities provided by the browser. By now,
    you should be aware of the advantages of using the same principles and code when
    writing the back-end and front-end of a complete solution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了浏览器提供的调试功能。到现在为止，您应该已经意识到了在编写完整解决方案的后端和前端时使用相同原则和代码的优势。
- en: We are going to go a step further in the next chapter. We will enable our application
    to get data from external sources and asynchronously update the user interface
    using Akka/Akka.js.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更进一步。我们将使我们的应用程序能够从外部来源获取数据，并使用 Akka/Akka.js 异步更新用户界面。
