- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Adding Spring Boot Security with JWT
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Spring Boot 安全性与 JWT
- en: In the previous chapter, we learned mainly how to generate automated documentation
    for our created APIs in our Spring Boot project. We learned how to add and use
    the features and properties of `springdoc-openapi`, configure the plugin on the
    project, and access the generated JSON and YAML documentation. We also learned
    how to implement the Swagger UI to make our documentation interactive and allow
    us to test endpoints directly on the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们主要学习了如何在 Spring Boot 项目中为创建的 API 生成自动化文档。我们学习了如何添加和使用 `springdoc-openapi`
    的特性和属性，配置项目上的插件，以及访问生成的 JSON 和 YAML 文档。我们还学习了如何实现 Swagger UI，使我们的文档交互式，并允许我们在浏览器上直接测试端点。
- en: This chapter will now focus on the security side of our application. We will
    discuss the concept of **Cross-Origin Resource Sharing** (**CORS**) and how it
    can secure our application. We will also be discussing the features and implementation
    of Spring Security in Spring Boot, the concept of **JSON Web Token** (**JWT**),
    and **Identity as a** **Service** (**IDaaS**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章现在将关注我们应用程序的安全方面。我们将讨论 **跨源资源共享**（**CORS**）的概念以及它如何保护我们的应用程序。我们还将讨论 Spring
    Boot 中 Spring Security 的特性和实现、**JSON Web Token**（**JWT**）的概念以及 **身份即服务**（**IDaaS**）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding CORS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CORS
- en: Adding a CORS policy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 CORS 策略
- en: Understanding Spring Security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Security
- en: Authentication and authorization in Spring Boot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 中的身份验证和授权
- en: IDaaS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDaaS
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The link to the finished version of this chapter’s code is here: [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的完成版本链接在此：[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes)。
- en: Understanding CORS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CORS
- en: We might have already encountered the term CORS several times when creating
    our applications as developers. Still, we may ask questions such as what does
    CORS do? Or what is the advantage of implementing CORS in our application? With
    these questions in mind, we will dive deeply, in this section, into the concepts
    and features of CORS and understand how it is used to secure our applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们作为开发者创建应用程序时，可能已经多次遇到过 CORS 这个术语。然而，我们可能会提出诸如 CORS 是做什么的？或者在应用程序中实现 CORS
    的优势是什么等问题。带着这些问题，在本节中，我们将深入探讨 CORS 的概念和特性，并了解它是如何用于保护我们的应用程序的。
- en: CORS is a header-based mechanism that allows a server to define a set of domains,
    schemes, or ports permitted to access the application’s resources. CORS is commonly
    used in REST APIs. Different frontend applications can access the APIs under our
    backend applications, especially in complex architectures. We don’t want our APIs
    to be accessed by unknown applications, and CORS is responsible for securing this
    part.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 是一种基于头部的机制，允许服务器定义一组允许访问应用程序资源的域、方案或端口。CORS 通常用于 REST API。不同的前端应用程序可以访问我们后端应用程序下的
    API，尤其是在复杂的架构中。我们不希望我们的 API 被未知的应用程序访问，而 CORS 负责保护这部分。
- en: Let’s see a simple example of a cross-origin request. Say we have a frontend
    application with a domain of `https://domain-one.com` and a backend application
    served with a domain of [https://domain-two.com](https://domain-two.com). We can
    see that our application is served with different domains, and once the frontend
    application sends a request to the backend, this is considered a cross-origin
    request.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的跨源请求示例。假设我们有一个前端应用程序，其域为 `https://domain-one.com`，以及一个后端应用程序，其域为 [https://domain-two.com](https://domain-two.com)。我们可以看到我们的应用程序由不同的域提供服务，一旦前端应用程序向后端发送请求，这被视为跨源请求。
- en: We should never forget that browsers restrict cross-origin requests by default,
    and same-origin requests are the only ones allowed for requesting resources unless
    the origin requesting the resources includes the proper CORS headers and is permitted
    on the backend application. This is just a simple example of how CORS works. Let’s
    look at a more detailed overview of the concept of CORS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不应该忘记，浏览器默认会限制跨源请求，并且只有请求资源的源包含适当的 CORS 头部并且被后端应用程序允许时，才允许请求同源资源。这只是 CORS
    的工作原理的一个简单示例。让我们更详细地了解一下 CORS 的概念。
- en: How CORS works
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS 的工作原理
- en: 'CORS is a header-based mechanism, which means that the first step to achieving
    cross-origin sharing is to add new HTTP headers that will describe the list of
    origins that are permitted to access resources. These headers can be described
    as our key to communication. The HTTP headers are divided into two categories,
    which are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 是一个基于头部的机制，这意味着实现跨源共享的第一步是添加新的 HTTP 头部，这些头部将描述允许访问资源的来源列表。这些头部可以被视为我们沟通的关键。HTTP
    头部分为两类，如下所示：
- en: Request headers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求头部
- en: Response headers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头部
- en: Request headers
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求头部
- en: 'Request headers are the headers required for the client to make use of the
    CORS mechanism. They are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头部是客户端为了使用 CORS 机制所必需的头部。它们如下所示：
- en: '`Origin`: This indicates the origin of the requesting client or simply the
    host of your frontend application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Origin`：这表示请求客户端的来源或简单地表示前端应用程序的主机。'
- en: '`Access-Control-Request-Method`: This header is used on a preflight request
    to indicate the HTTP method used to make the request.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Request-Method`：这个头部在预检请求中使用，用于指示用于发送请求的 HTTP 方法。'
- en: '`Access-Control-Request-Headers`: This header is used on a preflight request
    to indicate the list of HTTP headers used for the request.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Request-Headers`：这个头部在预检请求中使用，用于指示请求中使用的 HTTP 头部列表。'
- en: 'Let’s see an example of what a request would look like using the request headers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用请求头部的一个请求示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Response headers
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应头部
- en: 'Response headers are the headers that the servers send back with the response.
    They are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头部是服务器随响应发送的头部。它们如下所示：
- en: '`Access-Control-Allow-Origin`: This is a header used to specify the origin
    of accessing the resource on the server.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin`：这是一个用于指定服务器上资源访问来源的头部。'
- en: '`Access-Control-Expose-headers`: This header indicates the headers that the
    browser can access.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Expose-headers`：这个头部指示浏览器可以访问的头部。'
- en: '`Access-Control-Max-Age`: This is a header that indicates the information of
    preflight request expiration.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Max-Age`：这是一个指示预检请求过期信息的头部。'
- en: '`Access-Control-Allow-Credentials`: This is a header that indicates that a
    browser can access the response when the request has valid credentials.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Credentials`：这是一个指示当请求具有有效凭据时浏览器可以访问响应的头部。'
- en: '`Access-Control-Allow-Headers`: This header indicates the list of headers allowed
    to be used in a request.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Headers`：这个头部指示在请求中允许使用的头部列表。'
- en: '`Access-Control-Allow-Methods`: This is a header that indicates the list of
    request methods that are allowed to be used in the server.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Methods`：这是一个指示在服务器中允许使用的请求方法列表的头部。'
- en: 'Let’s see an example of what response we would like with the given headers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看给定头部我们希望得到的响应示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are the standard headers that we will use to allow the CORS mechanism,
    but there are several different scenarios in which cross-origin sharing works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将使用以允许 CORS 机制的标准头部，但存在几种不同的场景，在这些场景中跨源共享是有效的。
- en: Simple requests
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单请求
- en: 'These are requests that don’t trigger CORS preflight requests and, having no
    initial request, will be sent to the server for validation. To consider a request
    to be simple, it should satisfy the following conditions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求不会触发 CORS 预检请求，并且由于没有初始请求，将直接发送到服务器进行验证。要考虑一个请求是简单的，它应该满足以下条件：
- en: Uses the `POST` and `GET` methods.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `POST` 和 `GET` 方法。
- en: Contains headers that can be manually set, such as `Accept`, `Accept-Language`,
    `Content-Language`, and `Content-Type`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含可以手动设置的头部，例如 `Accept`、`Accept-Language`、`Content-Language` 和 `Content-Type`。
- en: '`Content-Type` should have one of the following types: `text/plain`, `multipart/form-data`,
    or `application/x-www-form-urlencoded`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type` 应该具有以下类型之一：`text/plain`、`multipart/form-data` 或 `application/x-www-form-urlencoded`。'
- en: No `ReadableStream` object is used in the request.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中没有使用 `ReadableStream` 对象。
- en: 'Let’s see an example of a simple request:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单请求的示例：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This request will perform a simple exchange between the client and the server.
    In response, the server returns the header with `Access-Control-Allow-Origin:
    *`, which means that the resource or endpoint can be accessed by any origin.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '这个请求将在客户端和服务器之间执行一个简单的交换。作为响应，服务器返回带有 `Access-Control-Allow-Origin: *` 的头部，这意味着资源或端点可以被任何来源访问。'
- en: Preflight requests
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预检请求
- en: The browser sends a test or first HTTP request using the `OPTIONS` method to
    validate that the request is permitted or safe. Preflight requests will always
    occur on cross-origin requests as preflight requests check whether a different
    origin is allowed or permitted to access the resource.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会发送一个测试或第一个HTTP请求，使用`OPTIONS`方法来验证请求是否被允许或安全。预请求总是发生在跨源请求上，因为预请求会检查是否允许或允许不同的源访问资源。
- en: 'Let’s see an example of a preflight request:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个预请求的例子：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding example shows that the preflight request uses the `OPTIONS` request
    method to execute the preflight request. The `OPTIONS` method is used to identify
    more information from the servers to know whether the actual request is permitted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子显示，预请求使用`OPTIONS`请求方法来执行预请求。`OPTIONS`方法用于从服务器获取更多信息，以确定实际请求是否被允许。
- en: We can also see that `Access-Control-Request-Method` and `Access-Control-Request-Headers`
    are identified. This indicates the request headers and request method to be used
    in the actual request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到`Access-Control-Request-Method`和`Access-Control-Request-Headers`被识别。这表示实际请求中要使用的请求头部和请求方法。
- en: 'Here is the header info:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是头部信息：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, in the preceding example, this is an example response returned after the
    preflight request. `Access-Control-Allow-Origin` indicates that access to resources
    is only allowed on the specified domain (`https://frontend.com` in the example).
    `Access-Control-Allow-Methods` confirms that `POST` and `GET` are valid methods.
    `Access-Control-Allow-Headers` ensures that `X-PINGOTHER` and `Content-Type` are
    proper headers for the actual request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在之前的例子中，这是一个预请求返回的示例响应。`Access-Control-Allow-Origin`表示只有指定域名（例如示例中的`https://frontend.com`）的资源访问是被允许的。`Access-Control-Allow-Methods`确认`POST`和`GET`是有效的请求方法。`Access-Control-Allow-Headers`确保`X-PINGOTHER`和`Content-Type`是实际请求中适当的头部。
- en: We have learned the basic concepts of CORS; now, we will implement CORS in our
    Spring Boot application in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了CORS的基本概念；现在，我们将在下一节中实现Spring Boot应用程序中的CORS。
- en: Adding a CORS policy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加CORS策略
- en: We have learned how CORS works and the advantage it brings to the security of
    our applications. Now, we will configure and implement a CORS policy in our Spring
    Boot project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了CORS的工作原理及其对我们应用程序安全性的优势。现在，我们将在我们的Spring Boot项目中配置和实现一个CORS策略。
- en: There are several ways to configure CORS on our project. We will discuss them
    one by one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中配置CORS有几种方法。我们将逐一讨论。
- en: CORS applications for each method
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个方法的CORS应用
- en: 'We can enable CORS on a single endpoint; this means that we can specify different
    permitted origins for other endpoints. Let’s have a look at the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个端点上启用CORS；这意味着我们可以为其他端点指定不同的允许源。让我们看看以下例子：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our Spring Boot project, we have the `getAntiHeroes()` method. To enable
    CORS on a specific method, we will use the `@CrossOrigin` annotation. We can see
    that we have not configured any other settings, and this applies the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Spring Boot项目中，我们有`getAntiHeroes()`方法。为了在特定方法上启用CORS，我们将使用`@CrossOrigin`注解。我们可以看到我们没有配置任何其他设置，并且这适用以下情况：
- en: All origins are permitted.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有源都被允许。
- en: HTTP methods that are allowed are the ones configured for the method (in this
    method, the allowed HTTP method is `GET`).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的HTTP方法是配置给该方法的方法（在这个方法中，允许的HTTP方法是`GET`）。
- en: The time of the preflight response is cached at 30 minutes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预请求响应的时间被缓存了30分钟。
- en: 'We can also specify the configuration of the CORS policy by adding the values
    of the origin, methods, `allowedHeaders`, `exposedHeaders`, `allowedCredentials`,
    and `maxAge`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过添加`origin`、`methods`、`allowedHeaders`、`exposedHeaders`、`allowedCredentials`和`maxAge`的值来指定CORS策略的配置：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: CORS applications at the controller level
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器级别的CORS应用
- en: 'In the previous configuration, we were adding CORS to each method. Now, we
    will add the CORS policy at the controller level. Let’s have a look at the following
    example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，我们是在每个方法上添加CORS。现在，我们将在控制器级别添加CORS策略。让我们看看以下例子：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that `@CrossOrigin` is added at the class level. This means that
    the CORS policy will be added to all the methods under `AntiHeroController`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在类级别添加了`@CrossOrigin`。这意味着CORS策略将被添加到`AntiHeroController`下的所有方法。
- en: CORS application at the controller and method levels
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器和方法的CORS应用
- en: 'We can combine the application of CORS at both the controller and method levels
    in our application. Let’s have a look at the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的应用程序中同时应用控制器和方法级别的 CORS 应用。让我们看看以下示例：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see in our example that we have applied the `@CrossOrigin` annotation
    at both the controller and method levels, `@CrossOrigin(allowedHeaders = "Content-type")`
    will be used on all the methods under `AntiHeroController`, and `@CrossOrigin(origins
    = http://localhost:4200)` will be applied only on the `getAntiHeroes()` method,
    thus other methods will allow all origins.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以看到我们在控制器和方法级别都应用了 `@CrossOrigin` 注解，`@CrossOrigin(allowedHeaders
    = "Content-type")` 将应用于 `AntiHeroController` 下的所有方法，而 `@CrossOrigin(origins =
    http://localhost:4200)` 仅应用于 `getAntiHeroes()` 方法，因此其他方法将允许所有来源。
- en: Global CORS configuration
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局 CORS 配置
- en: 'The last way we can implement a CORS policy is by using `CorsFilter`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现的最后一种实现 CORS 策略的方法是使用 `CorsFilter`：
- en: 'The first step is to add a configuration class for our CORS policy. To accomplish
    this, go to the `config` folder of our project and create a new class named `CorsConfig`.
    We will add the `@Configuration` annotation to identify this class as a configuration
    upon starting the application, and we should have the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是为我们的 CORS 策略添加一个配置类。为此，请访问我们项目的 `config` 文件夹并创建一个名为 `CorsConfig` 的新类。我们将添加
    `@Configuration` 注解以在应用程序启动时将此类识别为配置类，并且我们应该有以下的代码：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next step is to create our `CorsFilter Bean`. We will just create a new
    method with `@Bean` that returns a `CorsFilter` object:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建我们的 `CorsFilter Bean`。我们将仅创建一个带有 `@Bean` 的新方法，该方法返回一个 `CorsFilter` 对象：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under the `corsFilter()` method, we will place all of our CORS settings. We
    will instantiate a `CorsConfiguration` object that we will use to set the attributes
    by calling several methods. The methods that we will use are as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `corsFilter()` 方法下，我们将放置所有的 CORS 设置。我们将实例化一个 `CorsConfiguration` 对象，我们将通过调用几个方法来设置其属性。我们将使用的方法如下：
- en: 'The `setAllowCredentials()` method indicates whether the browser should send
    credentials such as cookies with cross-origin requests. This means that we want
    to set this option to `true` if we retrieve cookies and **Cross-Site Request Forgery**
    (**CSRF**) tokens:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAllowCredentials()` 方法指示浏览器是否应在跨源请求中发送诸如 cookies 之类的凭据。这意味着如果我们检索 cookies
    和 **跨站请求伪造**（**CSRF**）令牌，我们希望将此选项设置为 `true`：'
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `setAllowedOrigins()` method allows us to set the permitted origins that
    can access our endpoints. These are the domains for the trusted frontend applications.
    In the following example, we have set `http://localhost:4200`, which will be the
    development server of our frontend application:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAllowedOrigins()` 方法允许我们设置可以访问我们的端点的允许来源。这些是受信任的前端应用程序的域名。在以下示例中，我们已将 `http://localhost:4200`
    设置为，这将是我们的前端应用程序的开发服务器：'
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `setAllowedHeaders()` method allows us to configure the list of headers
    permitted in the HTTP requests. In the preceding example, we have set several
    headers that can be used in the requests:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAllowedHeaders()` 方法允许我们配置 HTTP 请求中允许的头列表。在前面的示例中，我们已设置了一些可以在请求中使用的头：'
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `setExposedHeaders()` method allows us to specify the list of response
    headers from the server. We can use this method to limit the headers on the response
    for security measures:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setExposedHeaders()` 方法允许我们指定来自服务器的响应头列表。我们可以使用此方法通过安全措施限制响应中的头：'
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `setAllowedMethods()` method will allow us to add the HTTP request methods
    that are authorized to be used to access the endpoints. In the following example,
    we have configured `GET`, `POST`, `PUT`, `DELETE`, and `OPTIONS` as the allowed
    methods since we are only building a simple **Create, Read, Update, and Delete**
    (**CRUD**) application:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAllowedMethods()` 方法将允许我们添加授权用于访问端点的 HTTP 请求方法。在以下示例中，我们已将 `GET`、`POST`、`PUT`、`DELETE`
    和 `OPTIONS` 配置为允许的方法，因为我们只构建一个简单的 **创建、读取、更新和删除**（**CRUD**）应用程序：'
- en: '[PRE43]'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last step we need to do is register the CORS configuration. We will instantiate
    a new `urlBasedCorsConfigurarationSource()` and use the `registerCorsConfiguration()`
    method for the registration. The first parameter is `"/**"`, which indicates that
    the configuration applies to all the methods found in the application, and the
    second parameter is `corsConfiguration`, which is the configuration we have created:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一步是注册 CORS 配置。我们将实例化一个新的`urlBasedCorsConfigurarationSource()`，并使用`registerCorsConfiguration()`方法进行注册。第一个参数是`"/**"`，表示配置适用于应用程序中找到的所有方法，第二个参数是`corsConfiguration`，这是我们创建的配置：
- en: '[PRE47]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After the registration, we will use the configuration source as a parameter
    for `CorsFilter`, and this is how our `corsFilter()` method would look after successfully
    configuring the CORS settings:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，我们将使用配置源作为`CorsFilter`的参数，以下是成功配置 CORS 设置后我们的`corsFilter()`方法将如何看起来：
- en: '[PRE54]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Having started our application, we will now apply the CORS configuration to
    all the methods in our project. We have successfully implemented a CORS policy
    in our application, but this is just part of how we secure our application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动我们的应用程序后，我们现在将 CORS 配置应用于我们项目中的所有方法。我们已经成功地在我们的应用程序中实现了 CORS 策略，但这只是我们保护应用程序的一部分。
- en: In the next section, we will discuss the concept of Spring Security and how
    to implement it in a Spring Boot project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 Spring Security 的概念以及如何在 Spring Boot 项目中实现它。
- en: Understanding Spring Security
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Spring Security
- en: '**Spring Security** is an application-level security framework widely used
    in Spring Boot applications. It is a flexible authentication framework that provides
    most of the standard security requirements for Java applications. Spring Security
    is popular owing to the fact that it allows developers to integrate different
    authorization and authentication providers on the fly with the other modules available.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Security** 是一个在 Spring Boot 应用程序中广泛使用的应用级安全框架。它是一个灵活的认证框架，为 Java 应用程序提供了大多数标准安全需求。Spring
    Security 因其允许开发人员即时与其他模块集成不同的授权和认证提供者而受到欢迎。'
- en: As we’re using Spring Security in our application, we do not need to code security-related
    tasks from scratch as Spring Security has these features under the hood.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序中使用 Spring Security，我们不需要从头开始编写安全相关的任务，因为 Spring Security 在幕后提供了这些功能。
- en: Let’s discuss the concepts of Spring Security further.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步讨论 Spring Security 的概念。
- en: Features of Spring Security
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Security 的特性
- en: Spring Security mainly focuses on integrating authentication and authorization
    into applications. To compare the two, **authentication** refers to validating
    that a user can access your application and identifying who the user is. This
    mainly refers to the login page itself. On the other hand, **authorization** is
    used for more complex applications; this relates to the operations or actions
    that a specific user can do inside your applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 主要关注将认证和授权集成到应用程序中。为了比较这两个概念，**认证**指的是验证用户可以访问您的应用程序并识别用户是谁。这主要指的是登录页面本身。另一方面，**授权**用于更复杂的应用程序；这关系到特定用户可以在您的应用程序中执行的操作或动作。
- en: 'Authorization can be accomplished by integrating roles to implement user access
    controls. Spring Security also provides different password encoders – one-way
    transformation passwords – which are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 授权可以通过集成角色来实现用户访问控制。Spring Security 还提供了不同的密码编码器——单向变换密码——如下所示：
- en: '`BCryptPasswordEncoder`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BCryptPasswordEncoder`'
- en: '`Argon2PasswordEncoder`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Argon2PasswordEncoder`'
- en: '`Pbkdf2PasswordEncoder`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pbkdf2PasswordEncoder`'
- en: '`SCryptPasswordEncoder`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCryptPasswordEncoder`'
- en: 'The preceding list is of the most commonly used password encoders and can be
    accessed directly when using Spring Security. It also provides different features
    that will help you to meet security requirements, which are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表是最常用的密码编码器，当使用 Spring Security 时可以直接访问。它还提供了不同的功能，将帮助您满足安全需求，如下所示：
- en: '**Lightweight Directory Access Protocol** (**LDAP**): A protocol for containing
    and accessing distributed directory information services over an internet protocol.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级目录访问协议**（**LDAP**）：一种在互联网协议上包含和访问分布式目录信息服务协议。'
- en: '**Remember me**: This feature provides a capability to remember a user from
    a single machine to prevent logging in again.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记住我**：此功能提供了一种从单台机器记住用户的能力，以防止再次登录。'
- en: '**Single Sign-On** (**SSO**): This feature allows users to access multiple
    applications with a single account, centralizing user information.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录**（**SSO**）：此功能允许用户使用单个账户访问多个应用程序，集中管理用户信息。'
- en: '**Software localization**: This feature gives the capability to develop a user
    interface with our preferred language.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件本地化**：此功能使我们能够用我们喜欢的语言开发用户界面。'
- en: '**HTTP authorization**: This feature provides authorization.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 认证**：此功能提供授权。'
- en: '**Basic access authentication**: This feature provides the base authentication
    process, which requires a username and password for requests.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本访问认证**：此功能提供基本的认证过程，请求需要用户名和密码。'
- en: '**Digest access authentication**: This feature provides more secure authentication
    that confirms the user’s identity before accessing resources.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要访问认证**：此功能提供更安全的认证，在访问资源之前确认用户的身份。'
- en: '**Web form authentication**: A form will be generated that will authenticate
    the user credentials directly from the web browser.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 表单认证**：将生成一个表单，可以直接从网页浏览器中验证用户凭据。'
- en: Spring Security offers a wide range of features for the application. In this
    case, the design of Spring Security is divided into separate **Java Archive**
    (**JAR**) files based on its functionality, only requiring the installation of
    the needed part for our development.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 为应用程序提供了一系列功能。在这种情况下，Spring Security 的设计根据其功能被划分为独立的 **Java
    归档**（**JAR**）文件，只需安装我们开发所需的部分。
- en: 'The following is a list of JAR files that are included in the Spring Security
    module:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Spring Security 模块中包含的 JAR 文件列表：
- en: '`spring-security-core`: The standard requirement for an application to use
    Spring Security. `Spring-security-core` consists of the core authentication classes
    and interfaces.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-core`：应用程序使用 Spring Security 的标准要求。`Spring-security-core`
    包含核心认证类和接口。'
- en: '`spring-security-web`: This JAR file is used for web authentication and URL-based
    access control. It is found under `org.springframework.security.web`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-web`：此 JAR 文件用于 Web 认证和基于 URL 的访问控制。它位于 `org.springframework.security.web`
    下。'
- en: '`spring-security-config`: This JAR file is used for implementing Spring Security
    configuration, using XML and Java. All classes and interfaces are found under
    `org.springframework.security.config`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-config`：此 JAR 文件用于实现 Spring Security 配置，使用 XML 和 Java。所有类和接口都位于
    `org.springframework.security.config` 下。'
- en: '`spring-security-ldap`: This JAR file is required for implementing LDAP in
    our application. All classes and interfaces are found under `org.springframework.security.ldap`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-ldap`：此 JAR 文件是我们在应用程序中实现 LDAP 所必需的。所有类和接口都位于 `org.springframework.security.ldap`
    下。'
- en: '`spring-security-oauth2-core`: This JAR file is used to implement the OAuth
    2.0 authorization framework and OpenID Connect Core. The classes are located under
    `org.springframework.security.oauth2.core`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-oauth2-core`：此 JAR 文件用于实现 OAuth 2.0 授权框架和 OpenID Connect Core。类位于
    `org.springframework.security.oauth2.core` 下。'
- en: '`spring-security-oauth2-client`: This JAR file provides the OAuth login and
    OpenID client support. All classes and interfaces are located under `org.springframework.security.oauth2.client`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-oauth2-client`：此 JAR 文件提供 OAuth 登录和 OpenID 客户端支持。所有类和接口都位于
    `org.springframework.security.oauth2.client` 下。'
- en: '`spring-security-openid`: This JAR file is used for OpenID web authentication
    support to validate users with an external OpenID server.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-openid`：此 JAR 文件用于支持 OpenID Web 认证，以验证外部 OpenID 服务器上的用户。'
- en: '`spring-security-test`: This JAR file is used to support testing for the Spring
    Security application.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-test`：此 JAR 文件用于支持 Spring Security 应用程序的测试。'
- en: '`spring-security-cas`: This JAR file implements web authentication with a CAS
    SSO server. All classes and interfaces are found under `org.springframewok.security.cas`.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-cas`：此 JAR 文件实现了与 CAS SSO 服务器的 Web 认证。所有类和接口都位于 `org.springframewok.security.cas`
    下。'
- en: '`spring-security-acl`: This JAR file is used to integrate security into the
    application’s domain object. We can access the classes and interfaces under `org.springframework.security.acls`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-acl`：此 JAR 文件用于将安全集成到应用程序的域对象中。我们可以访问位于 `org.springframework.security.acls`
    下的类和接口。'
- en: We have now learned about the different features and modules that Spring Security
    offers. In the next section, we will learn how to implement authentication and
    authorization using Spring Security in our Spring Boot application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已了解了 Spring Security 提供的不同功能和模块。在下一节中，我们将学习如何在 Spring Boot 应用程序中使用 Spring
    Security 实现身份验证和授权。
- en: Authentication and authorization in Spring Boot
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 中的身份验证和授权
- en: We have already discussed the concepts of Spring Security in the previous section;
    now, we will learn how to integrate Spring Security into our Spring Boot application.
    As we move on to the examples, we will be using all the modules and features of
    Spring Boot Security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中讨论了 Spring Security 的概念；现在，我们将学习如何将 Spring Security 集成到我们的 Spring Boot
    应用程序中。随着我们继续到示例中，我们将使用 Spring Boot Security 的所有模块和功能。
- en: Authentication and authorization are the most common concepts that we come across
    when we implement security in our applications. These are the two validations
    we apply for our application to be secure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是我们实现应用程序安全时遇到的最常见概念。这是我们为使应用程序安全而应用的两个验证。
- en: Configuring Spring Boot and implementing authentication
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Spring Boot 并实现身份验证
- en: 'We will first implement authentication in our application. We first need to
    add the Spring Boot Security dependency to our project. To add the dependency,
    we will add the following to `pom.xml`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的应用程序中实现身份验证。我们首先需要将 Spring Boot Security 依赖项添加到我们的项目中。要添加依赖项，我们将在 `pom.xml`
    中添加以下内容：
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Reload the project to install the new dependency and run the server. Let’s
    try to visit `localhost:8080` to open the Spring Boot application project in the
    browser. As we can see, a login page is now applied to our project as we’ve installed
    Spring Boot Security:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载项目以安装新的依赖项并运行服务器。让我们尝试访问 `localhost:8080` 以在浏览器中打开 Spring Boot 应用程序项目。正如我们所见，由于我们已安装
    Spring Boot Security，现在已将登录页面应用于我们的项目：
- en: '![Figure 7.1 – Login page integrated from Spring Boot Security](img/B18159_07_01.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 从 Spring Boot Security 集成的登录页面](img/B18159_07_01.jpg)'
- en: Figure 7.1 – Login page integrated from Spring Boot Security
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 从 Spring Boot Security 集成的登录页面
- en: 'To create credentials for the login, we can configure the username and password
    under the `application.properties` file by placing the following setting:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要为登录创建凭据，我们可以在 `application.properties` 文件下配置用户名和密码，通过放置以下设置：
- en: '[PRE89]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the preceding example, we have used `admin` as the username and `test` as
    the password for our Spring Boot Security login, which will allow us to log in
    successfully to our application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已使用 `admin` 作为用户名，`test` 作为密码进行我们的 Spring Boot Security 登录，这将允许我们成功登录到我们的应用程序。
- en: We have now successfully set up Spring Boot Security for our project, and this
    automatically applies authentication to our endpoints. The next step we need to
    do is add a configuration for our security; we would want to override the default
    configuration and implement a customized login endpoint for our application to
    give access to our other endpoints provided.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功为我们的项目设置了 Spring Boot Security，这会自动将身份验证应用于我们的端点。下一步我们需要做的是添加我们的安全配置；我们希望覆盖默认配置并为我们应用程序的其他端点实现一个定制的登录端点。
- en: 'To start with the configuration, let’s first create a new class named `SecurityConfig`
    under the config file. We will extend our new `SecurityConfig` class with `WebSecurityConfigurerAdapter`.
    This adapter allows us to override and customize the configuration of `WebSecurity`
    and `HttpSecurity`, and after extending the class, we will override the first
    two methods:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始配置，让我们首先在配置文件下创建一个名为 `SecurityConfig` 的新类。我们将使用 `WebSecurityConfigurerAdapter`
    扩展我们的新 `SecurityConfig` 类。此适配器允许我们覆盖和自定义 `WebSecurity` 和 `HttpSecurity` 的配置，并在扩展类之后，我们将覆盖前两个方法：
- en: '[PRE90]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first method that we will override on `WebSecurityConifigurerAdapter` is
    the `configure(AuthenticationManagerBuilder auth)` method, which accepts `AuthenticationManagerBuilder`,
    which is used to build LDAP authentication, JDBC-based authentication, adding
    a custom `UserDetailsService`, and adding `AuthenticationProviders`. In this case,
    we will use this to access `userDetailsServiceMethod()` to customize our authentication.
    We will do that in the following steps as we have not yet created our modified
    `UseDetailsService`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `WebSecurityConfigurerAdapter` 上重写的第一个方法是 `configure(AuthenticationManagerBuilder
    auth)` 方法，它接受 `AuthenticationManagerBuilder`，用于构建 LDAP 认证、基于 JDBC 的认证、添加自定义的 `UserDetailsService`
    以及添加 `AuthenticationProviders`。在这种情况下，我们将使用它来访问 `userDetailsServiceMethod()` 以自定义我们的认证。我们将在以下步骤中这样做，因为我们尚未创建我们的修改后的
    `UseDetailsService`。
- en: The second method is `authenticationManagerBean()`; we override this method
    to expose `AuthenticationManager` as a bean in our application, which we will
    later use in `AuthenticateController`. The next step is to implement the configuration
    we want for our HTTP requests. To achieve this, we will override the `configure(HttpSecurity`
    `http)` method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是 `authenticationManagerBean()`；我们重写此方法以将 `AuthenticationManager` 作为我们的应用程序中的一个
    bean 暴露出来，我们将在稍后的 `AuthenticateController` 中使用它。下一步是实现我们想要的 HTTP 请求的配置。为了实现这一点，我们将重写
    `configure(HttpSecurity http)` 方法。
- en: '`HttpSecurity` allows us to call methods that will implement configuration
    for web-based security requests for the HTTP requests. By default, the security
    configuration will be applied to all HTTP requests, but we can also set only specific
    requests by using the `requestMatcher()` methods. `HttpSecurity` is the same as
    the Spring Security XML configuration.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpSecurity` 允许我们调用方法来实现对基于 Web 的安全请求的 HTTP 请求的配置。默认情况下，安全配置将应用于所有 HTTP 请求，但我们可以通过使用
    `requestMatcher()` 方法仅设置特定的请求。`HttpSecurity` 与 Spring Security XML 配置相同。'
- en: 'Let’s discuss the standard methods under `HttpSecurity`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论 `HttpSecurity` 下的标准方法：
- en: '`csrf()`: Enables the **CSRF** protections. This is enabled by default.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csrf()`: 启用 **CSRF** 保护。默认情况下是启用的。'
- en: '`disable()`: Disables the initial configurations; a new version can be applied
    after calling the method.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable()`: 禁用初始配置；在调用此方法后可以应用新版本。'
- en: '`antMatcher("/**")`: By default, our configuration will be applied to all HTTP
    requests. We can use the `antMatcher()` method to specify the URL patterns where
    we want to apply the configuration.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antMatcher("/**")`: 默认情况下，我们的配置将应用于所有 HTTP 请求。我们可以使用 `antMatcher()` 方法来指定我们想要应用配置的
    URL 模式。'
- en: '`antMatchers("/**")`: Similar to the `antMatcher()` method, but accepts a list
    of patterns where we want to apply the configuration.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antMatchers("/**")`: 与 `antMatcher()` 方法类似，但接受一个我们想要应用配置的模式列表。'
- en: '`permitAll()`: Specifies that access to any URL endpoints are allowed by anyone.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permitAll()`: 指定任何人都可以访问任何 URL 端点。'
- en: '`anyRequest()`: Applies to any type of HTTP request.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anyRequest()`: 适用于任何类型的 HTTP 请求。'
- en: '`authenticated()`: Specifies that any URL endpoints are allowed by any authenticated
    user.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authenticated()`: 指定任何已认证用户都可以访问任何 URL 端点。'
- en: '`exceptionHandling()`: Exception handling configuration.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exceptionHandling()`: 异常处理配置。'
- en: '`sessionManagement()`: This method is commonly used to manage how many allowed
    sessions for a user can be active; for example, we configure `sessionManagement().maximumSessions(1).expiredUrl("/login?expired")`,
    which indicates that when the user is logged in to another terminal and attempts
    to log in to another instance, it will automatically log them out of the other
    instance.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionManagement()`: 此方法通常用于管理一个用户可以有多少个活动会话；例如，我们配置 `sessionManagement().maximumSessions(1).expiredUrl("/login?expired")`，这表示当用户在另一个终端登录并尝试登录到另一个实例时，它将自动将其从另一个实例注销。'
- en: '`sessionCreationPolicy()`: Allows us to create a policy for when a session
    should get created; the possible values are `ALWAYS`, `IF_REQUIRED`, `NEVER`,
    and `STATELESS`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionCreationPolicy()`: 允许我们为会话何时创建创建一个策略；可能的值有 `ALWAYS`、`IF_REQUIRED`、`NEVER`
    和 `STATELESS`。'
- en: 'In our code, let’s configure a basic configuration for our security. Let’s
    place the following code inside the `configure(HttpSecurity` `http)` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，让我们为我们的安全配置一个基本配置。让我们将以下代码放在 `configure(HttpSecurity http)` 方法中：
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the preceding example configuration, we have implemented several configurations
    for our application. You can notice that we have divided the methods into chains.
    This is to show the methods are related to each other.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置示例中，我们已经为我们的应用程序实现了几个配置。你可以注意到，我们已经将方法分成了链。这是为了展示这些方法之间的关系。
- en: The first chain, with `.csrf().disable()`, disables the use of CSRF protection.
    This is just an example, and disabling CSRF is not recommended when building your
    application. The second chain, with `.antMatcher("/**").authorizedRequests()`,
    states that any requests are authorized to be accessed by any users regardless
    of the role.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个链，`.csrf().disable()`，禁用了 CSRF 保护的使用。这只是一个例子，不建议在构建应用程序时禁用 CSRF。
- en: This can be modified by specifying the role in the `hasRole()` method by restricting
    the users based on the assigned roles. The third chain is `.antMatchers("/**").permitAll()`,
    which indicates that any users can access all the URLs, and lastly, `sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)`
    indicates that no session should be created by Spring Security.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 `hasRole()` 方法中指定角色来修改，通过限制基于分配的角色来限制用户。第三个链 `.antMatchers("/**").permitAll()`
    指示任何用户都可以访问所有 URL，最后，`sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)`
    指示 Spring Security 不应该创建任何会话。
- en: 'We have successfully created `SecurityConfig`, which contains all of our configurations
    for Spring Security; our code should look like the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了 `SecurityConfig`，它包含了我们所有 Spring Security 的配置；我们的代码应该看起来像以下这样：
- en: '[PRE92]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, we will move on to the next step, where we will create our endpoints for
    our user entity.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续下一步，创建我们用户实体的端点。
- en: Creating user endpoints
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户端点
- en: When implementing CRUD, we need to create our user endpoints. We need to develop
    these endpoints such that they will be used for the registration of a new user
    in our database. In this example, we will repeat the steps on how to develop endpoints
    discussed in *w*, *Documenting APIs with OpenAPI Specification*, but we will also
    create a whole CRUD capability for the user entity.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现 CRUD 时，我们需要创建我们的用户端点。我们需要开发这些端点，以便它们将用于在我们数据库中注册新用户。在这个例子中，我们将重复讨论如何开发端点的步骤，如
    *w*，*使用 OpenAPI 规范记录 API*，但我们还将为用户实体创建整个 CRUD 功能。
- en: Let’s create a new user package and make the controller, data, entity, repository,
    and service packages under the user package.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的用户包，并在用户包下创建控制器、数据、实体、仓库和服务包。
- en: Creating the user entity
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户实体
- en: 'Let’s create the user entity first by creating a new class named `UserEntity`
    under the entity package, and we will place the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建用户实体，在实体包下创建一个名为 `UserEntity` 的新类，我们将放置以下代码：
- en: '[PRE93]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the preceding example, we have assigned several properties for `UserEntity`.
    We have annotated it with `@Entity` to indicate that this is a `storedHash`, and
    a `storedSalt` property. `storedHash` and `storedSalt` will be used for hashing
    and verifying the user’s password.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经为 `UserEntity` 分配了几个属性。我们用 `@Entity` 注解来表示这是一个 `storedHash` 和 `storedSalt`
    属性。`storedHash` 和 `storedSalt` 将用于散列和验证用户的密码。
- en: Creating the user DTO
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户 DTO
- en: 'After creating the user entity, we will make the `UserDto` under the data package,
    and we will place the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用户实体后，我们将在数据包下创建 `UserDto`，并将以下代码放置其中：
- en: '[PRE94]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Creating the user repository
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户仓库
- en: 'The next thing we need to do is create the repository for our user. Under the
    repository package, create a new class named `UserRepository`, and we will extend
    the class with `JPARepository` by adding the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是创建我们用户的仓库。在仓库包下，创建一个名为 `UserRepository` 的新类，我们将通过添加以下代码来使用 `JPARepository`
    扩展这个类：
- en: '[PRE95]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In the preceding example, we extended `UserRepository` with `JPARepository`,
    which grants all the CRUD capabilities to our repository. We have also created
    two methods with an `@Query` annotation, which checks whether the email address
    already exists.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过扩展 `UserRepository` 使用 `JPARepository` 赋予了我们的仓库所有 CRUD 功能。我们还创建了两个带有
    `@Query` 注解的方法，用于检查电子邮件地址是否已存在。
- en: Creating the user service
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户服务
- en: The next step is now to create our user service where we will implement the
    business logic of the application. Under the service package, we will create a
    new class named `UserService`, after the creation of the service.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的用户服务，我们将在这里实现应用程序的业务逻辑。在服务包下，我们将在创建服务后创建一个名为`UserService`的新类。
- en: We will place `@AllArgsConstructor` for the constructor injecting the dependencies
    and the `@Service` annotation to let Spring know that this is a service layer,
    and we will also inject `ModelMapper` and `UserRepository` into our service after
    the annotations and dependency injection.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为构造函数添加`@AllArgsConstructor`以注入依赖项，并使用`@Service`注解让Spring知道这是一个服务层，我们还将在此注解和依赖注入之后将`ModelMapper`和`UserRepository`注入到我们的服务中。
- en: 'We can create two methods that allow us to convert an entity into a DTO and
    vice versa by placing the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个方法，允许我们将实体转换为DTO，反之亦然，具体代码如下：
- en: '[PRE96]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we will create the code for the basic CRUD functionalities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建基本CRUD功能性的代码：
- en: '**Getting all users**: To get all of the users, we will place the following
    code:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有用户**: 要获取所有用户，我们将放置以下代码：'
- en: '[PRE97]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The example code returns all the list of users converted into a DTO.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码返回所有用户列表转换为DTO。
- en: '**Getting users by ID**: To get a specific user by ID, we will place the following
    code:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过ID获取用户**: 要通过ID获取特定用户，我们将放置以下代码：'
- en: '[PRE105]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This example method retrieves a specific user using the `findByID()` method
    of the user repository.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例方法使用用户仓库的`findByID()`方法检索特定用户。
- en: '`createSalt()` method, which will allow us to create a salt for the user’s
    password.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSalt()`方法，它将允许我们为用户的密码创建盐。'
- en: 'Let’s place the code for the `createSalt()` method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`createSalt()`方法的代码放进来：
- en: '[PRE114]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The next method is `createPasswordHash()`, which will allow us to hash the
    user’s password. We use the SHA-512 hashing algorithm and the provided salt to
    create the method. The following code is for the `createPasswordHash()` implementation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`createPasswordHash()`，它将允许我们哈希用户的密码。我们使用SHA-512哈希算法和提供的盐来创建该方法。以下是对`createPasswordHash()`实现的代码：
- en: '[PRE115]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The last method is the `createUser()` method itself. We will first check whether
    a password is provided and then whether the email address already exists using
    the `selectExistsEmail()` method we have created. Next, after all the validations
    have passed, make a salt using the `createSalt()` method and hash the password
    using `createPasswordHash()`. Lastly, save the new user in the database. The following
    code is for the `createUser()` implementation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是`createUser()`方法本身。我们首先检查是否提供了密码，然后使用我们创建的`selectExistsEmail()`方法检查电子邮件地址是否已存在。接下来，在所有验证都通过之后，使用`createSalt()`方法创建盐，并使用`createPasswordHash()`方法哈希密码。最后，将新用户保存到数据库中。以下是对`createUser()`实现的代码：
- en: '[PRE116]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`updateUser()` and `deleteUser()`. This is a different method we can implement
    to give us the capability to edit the details of the user or delete the user in
    the database.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateUser()`和`deleteUser()`。这是一个不同的方法，我们可以实现它，以赋予我们编辑用户详细信息或从数据库中删除用户的能力。'
- en: 'Let’s see the following code implementation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE117]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We have already created the services needed for our user entity. Now, the last
    step is to make our controller.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用户实体所需的所有服务。现在，最后一步是创建我们的控制器。
- en: Creating the user controller
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户控制器
- en: The last requirement for the user is to create the controller. We will create
    a method for `findAllUsers()`, `findUserById()`, `deleteUserById()`, `createUser()`,
    and `putUser()` under the annotated services with specific HTTP requests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 用户最后的需要是创建控制器。我们将在注解的服务下创建`findAllUsers()`、`findUserById()`、`deleteUserById()`、`createUser()`和`putUser()`的方法，具体HTTP请求。
- en: 'Let’s see the following code implementation:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE118]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We have successfully created our endpoints for our user entity; we can now use
    the `/register` endpoint to create a new user for a valid authentication. Now,
    we will make the login endpoint using JWT.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了用户实体的端点；现在，我们可以使用`/register`端点来为有效的身份验证创建新用户。现在，我们将使用JWT创建登录端点。
- en: JWT
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT
- en: JWT is a URL-safe method for communicating data. A JWT can be seen as an encrypted
    string containing a JSON object with a lot of information. It includes an additional
    structure consisting of a header payload that uses JSON format. JWTs can be encrypted
    or signed with a **Message Authentication Code** (**MAC**). A JWT is created by
    combining the header and payload JSON, and the whole token is Base64-URL-encoded.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是一种安全的 URL 方法，用于数据通信。JWT 可以看作是一个包含大量信息的 JSON 对象的加密字符串。它包括一个额外的结构，由使用 JSON
    格式的头部和负载组成。JWT 可以使用 **消息认证码**（**MAC**）进行加密或签名。JWT 通过组合头部和负载 JSON 创建，整个令牌是 Base64-URL
    编码的。
- en: When to use JWT
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用 JWT
- en: JWT is used chiefly on RESTful web services that cannot maintain a client state
    since JWT holds some information connected to the user. It can provide state information
    to the server for each request. JWT is utilized in applications that require client
    authentication and authorization.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 主要用于无法维护客户端状态的 RESTful Web 服务，因为 JWT 包含一些与用户相关的信息。它可以向服务器提供每个请求的状态信息。JWT
    在需要客户端认证和授权的应用程序中被使用。
- en: JWT example
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT 示例
- en: 'Let’s have a look at the following JWT example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 JWT 示例：
- en: '[PRE119]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The JWT in the given example is composed of three parts – we can notice that
    it is divided with a dot (*.*) character. The first string is the encoded header,
    the second string is the encoded payload, and the last string is the signature
    of the JWT.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 给定示例中的 JWT 由三个部分组成——我们可以注意到它被一个点 (*.*) 字符分隔。第一个字符串是编码的头部，第二个字符串是编码的负载，最后一个字符串是
    JWT 的签名。
- en: 'The following block is an example of the decoded structure:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的块是一个解码结构的示例：
- en: '[PRE120]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We can see in the preceding example that the three parts are JSON objects, the
    headers, which contain the algorithm used for signing the JWT, the payload, which
    holds information that can be used to define the state, and the signature, which
    encodes both the headers and the payload appended by the secret key.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到这三个部分都是 JSON 对象，头部包含用于签名 JWT 的算法，负载包含可以用来定义状态的信息，签名则编码了附加了密钥的头部和负载。
- en: JWT implementation
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT 实现
- en: We already know the concept and use of JWT; now, we will implement JWT generation
    in our Spring Boot project. We want to create an authentication endpoint that
    will return a valid JWT when a valid credential is submitted.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 JWT 的概念和使用；现在，我们将在 Spring Boot 项目中实现 JWT 生成。我们希望创建一个认证端点，当提交有效凭证时，将返回有效的
    JWT。
- en: The first step is to add the JWT dependencies to our Spring Boot project.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将 JWT 依赖项添加到我们的 Spring Boot 项目中。
- en: 'Let’s add the following XML code to `pom.xml`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `pom.xml` 中添加以下 XML 代码：
- en: '[PRE121]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Next, we need to create a package named `jwt` under our project package, and
    after its creation, create packages called `controllers`, `filters`, `models`,
    `services`, and `util`. We will start making the necessary models for our authentication
    endpoint.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的项目包下创建一个名为 `jwt` 的包，创建完成后，再创建名为 `controllers`、`filters`、`models`、`services`
    和 `util` 的包。我们将开始为我们的认证端点制作必要的模型。
- en: Creating the authentication models
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建认证模型
- en: We need to create three models for our authentication. The first model is for
    the request, the next is for the response, and lastly, we have a model containing
    the user information and one to implement `UserDetails` from Spring Security.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为认证创建三个模型。第一个模型是用于请求的，下一个是用于响应的，最后是一个包含用户信息和实现 Spring Security 的 `UserDetails`
    的模型。
- en: 'For the request model, create a new class named `AuthenticationRequest` under
    the models’ package. The implementation of the model is shown in the following
    code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于请求模型，在 `models` 包下创建一个名为 `AuthenticationRequest` 的新类。模型的实现如下所示：
- en: '[PRE122]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The request only needs the email address and the password, since these are the
    credentials we need to validate.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请求只需要电子邮件地址和密码，因为这些是我们需要验证的凭证。
- en: 'Then, for the response model, create a new class named `AuthenticationResponse`;
    the implementation of the model is shown in the following code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于响应模型，创建一个名为 `AuthenticationResponse` 的新类；模型的实现如下所示：
- en: '[PRE123]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The response model only contains the token; the JWT is returned once the credentials
    are validated.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 响应模型只包含令牌；在凭证验证后，JWT 被返回。
- en: 'Lastly, for the user principal model, create a new class named `UserPrincipal`;
    the implementation of the model is shown in the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于用户主体模型，创建一个名为 `UserPrincipal` 的新类；模型的实现如下所示：
- en: '[PRE124]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The use principal model implements `UserDetails` as this will be our custom
    user for Spring Security. We have overridden several methods, such as `getAuthorities()`,
    which retrieves the list of authorizations of the user, `isAccountNonLocked()`,
    which checks whether the user is locked, `isAccountNonExpired()`, which validates
    that the user is valid and not yet expired, and `isEnabled()`, which checks whether
    the user is active.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主体模型实现 `UserDetails`，因为这将是我们用于 Spring Security 的自定义用户。我们已经覆盖了几个方法，例如 `getAuthorities()`，它检索用户的授权列表，`isAccountNonLocked()`，它检查用户是否被锁定，`isAccountNonExpired()`，它验证用户是否有效且尚未过期，以及
    `isEnabled()`，它检查用户是否活跃。
- en: Creating the authentication utilities
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建认证工具
- en: We need to create the utilities for our authentication; the utilities will be
    responsible for the JWT creation, validation and expiration checks, and extraction
    of the information. These are the methods we will use to validate our token.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建我们的认证工具；工具将负责 JWT 的创建、验证和过期检查，以及信息的提取。我们将使用以下方法来验证我们的令牌。
- en: We will create a class named `JwtUtil` under the `util` package, and we will
    annotate this with an `@Service` annotation. Let’s start with the methods needed
    for `util`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `util` 包下创建一个名为 `JwtUtil` 的类，并使用 `@Service` 注解来标注它。让我们从 `util` 所需的方法开始。
- en: 'Let’s create the first two methods that we need to create a valid token:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建创建有效令牌所需的前两个方法：
- en: '[PRE125]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The preceding implementation calls several methods from the JWT extension:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现调用了 JWT 扩展的几个方法：
- en: The `builder()` method, which is responsible for the building of the JWT.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder()` 方法负责 JWT 的构建。'
- en: The `setClaims()` method, which sets the claims of the JWT.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setClaims()` 方法用于设置 JWT 的声明。'
- en: The `setSubject()` method, which sets the subject; in this case, the value is
    the email address of the user.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSubject()` 方法用于设置主题；在这种情况下，该值是用户的电子邮件地址。'
- en: The `setIssuedAt()` method, which sets the date when the JWT is created.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setIssuedAt()` 方法用于设置 JWT 创建的日期。'
- en: The `setExpiration()` method, which sets the expiration date of the JWT.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setExpiration()` 方法用于设置 JWT 的过期日期。'
- en: The `signWith()` method, which signs the JWT with the provided key and algorithm.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signWith()` 方法使用提供的密钥和算法对 JWT 进行签名。'
- en: The next method we need to implement is the claims extraction. We will use this
    method mainly to get useful information, such as the subject and the expiration
    of the token.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要实现的方法是声明提取。我们将主要使用此方法来获取有用的信息，例如主题和令牌的过期时间。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE126]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `extractAllClaims()` method receives the token and uses the secret key provided
    by the application. We have called the `parseClaimsJWS()` method to extract the
    claims from the JWT.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractAllClaims()` 方法接收令牌并使用应用程序提供的密钥。我们已经调用了 `parseClaimsJWS()` 方法从 JWT
    中提取声明。'
- en: Now, we will create the methods to extract and check whether the token is expired
    and extract the username using the `extractClaims()` method we have created.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建提取和检查令牌是否过期以及使用我们创建的 `extractClaims()` 方法提取用户名的方法。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE127]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We have used the `getExpiration` and `getSubject` built-in functions to get
    the expiration date and subject from the claims.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `getExpiration` 和 `getSubject` 内置函数从声明中获取过期日期和主题。
- en: Lastly, we will create a method to validate that the token is not yet expired
    or a valid user is using the token.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个方法来验证令牌尚未过期或有效用户正在使用该令牌。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE128]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Creating the authentication service
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建认证服务
- en: Now, we will create the service for our authentication, as we know that services
    are responsible for the logic of our application. We will make the following methods,
    which will verify whether the password is correct using the hash, check whether
    the user has valid credentials, and provide a method that will override the default
    authentication.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的认证服务，因为我们知道服务负责我们应用程序的逻辑。我们将创建以下方法，这些方法将使用哈希验证密码是否正确，检查用户是否有有效的凭据，并提供一个将覆盖默认认证的方法。
- en: 'The first step is to create a new class named `ApplicationUserDetailsService`
    under the service package, and we will implement the class using `UserDetailsService`
    from Spring Security. We will override the `loadUserByUsername()` method and execute
    the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在服务包下创建一个名为`ApplicationUserDetailsService`的新类，我们将使用Spring Security中的`UserDetailsService`来实现这个类。我们将重写`loadUserByUsername()`方法并执行以下代码：
- en: '[PRE129]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The preceding code calls the `searchByEmail()` method, which is our custom implementation
    for checking whether a user exists, and we will return the user as a `UserPrincipal`
    object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码调用了`searchByEmail()`方法，这是我们自定义的实现，用于检查用户是否存在，并且我们将返回一个`UserPrincipal`对象。
- en: The next step is to create the `verifyPasswordHash()` method, which will validate
    the user’s password.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`verifyPasswordHash()`方法，用于验证用户的密码。
- en: 'Let’s have a look at the following code implementation:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE130]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The method we have created accepts the password, the stored salt, and the user’s
    hash. We will first check whether `storedHash` has a length of 64 and `storedSalt`
    has a size of 128 to validate whether it is 64 bytes. We will get the computed
    hash by using the stored salt and message digest for the password, and lastly,
    we will check whether the passwords match by seeing whether the calculated hash
    and stored hash are equal.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的方法接受密码、存储的盐和用户的哈希。我们首先检查`storedHash`的长度是否为64，`storedSalt`的大小是否为128，以验证它是否为64字节。我们将使用存储的盐和密码的消息摘要来获取计算出的哈希，最后，我们将检查密码是否匹配，通过查看计算出的哈希和存储的哈希是否相等。
- en: The last method we need to implement is the `authenticate()` method. This is
    the primary method that our authenticate endpoint will call.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个方法是`authenticate()`方法。这是我们的认证端点将调用的主要方法。
- en: 'Let’s have a look the following code implementation:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现：
- en: '[PRE131]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The method first checks whether the user exists using the `searchByEmail()`
    method and checks whether the password is valid using the `verifyPasswordHash()`
    method that we have created.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先使用`searchByEmail()`方法检查用户是否存在，并使用我们创建的`verifyPasswordHash()`方法检查密码是否有效。
- en: Creating the authentication controller
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建认证控制器
- en: 'Now, we will create the controllers of our authentication. This would create
    the primary endpoint for our login. The first step is to create a class named
    `AuthenticateController` under the controllers’ package, and next, we will make
    `authenticate()` with the following implementation:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的认证控制器。这将创建我们的登录的主要端点。第一步是在控制器包下创建一个名为`AuthenticateController`的新类，接下来，我们将实现`authenticate()`方法如下：
- en: '[PRE132]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Then, we get the details of the user by calling `loadUserByUsername` from `userDetailsService`
    but don’t forget to pass the email address of the user like so:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`userDetailsService`中的`loadUserByUsername`方法来获取用户详情，但不要忘记像这样传递用户的电子邮件地址：
- en: '[PRE133]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `authenticate()` method accepts an `AuthenticationRequest` body, which requires
    an email address and password. We will use `service.authenticate()` we previously
    created to check whether the credentials are valid. Once this is confirmed, we
    can generate the token using `generateToken()` from our utilities and return an
    `AuthenticationResponse` object.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate()`方法接受一个`AuthenticationRequest`体，它需要一个电子邮件地址和密码。我们将使用之前创建的`service.authenticate()`来检查凭据是否有效。一旦确认，我们可以使用我们的工具中的`generateToken()`生成令牌，并返回一个`AuthenticationResponse`对象。'
- en: Creating the authentication filters
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建认证过滤器
- en: The last step we need to accomplish is to create the filter for our authentication.
    We will use filters to validate each HTTP request with a valid JWT in the request
    headers. We need to make sure that a filter is invoked only once for each request.
    We can achieve this by using `OncePerRequestFilter`. We will extend our filter
    class with the filter to ensure that the filter is only executed once for a specific
    request.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是我们需要完成的步骤是创建我们的认证过滤器。我们将使用过滤器来验证每个带有有效JWT的请求头部的HTTP请求。我们需要确保每个请求只调用一次过滤器。我们可以通过使用`OncePerRequestFilter`来实现这一点。我们将扩展我们的过滤器类，以确保过滤器只为特定请求执行一次。
- en: Now, let’s create our authentication filter; first, let’s create a class named
    `JwtRequestFilter` under the `filters` package, and we will extend this class
    with `OncePerRequestFilter`, then we will override the `doFilterInternal()` method,
    which has parameters of `HttpServletRequest`, `HttpServletResponse`, and `FilterChain`.
    We will also inject `ApplicationUserDetailsService` and `JwtUtil` for the credentials
    and token validation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的认证过滤器；首先，在`filters`包下创建一个名为`JwtRequestFilter`的类，然后我们将使用`OncePerRequestFilter`扩展这个类，然后我们将重写`doFilterInternal()`方法，该方法具有`HttpServletRequest`、`HttpServletResponse`和`FilterChain`参数。我们还将注入`ApplicationUserDetailsService`和`JwtUtil`以进行凭证和令牌验证。
- en: 'Our code will look like the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码将如下所示：
- en: '[PRE134]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, for the implementation of the method, the first thing we need to do is
    extract the JWT from the request header. Let’s implement the following code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于方法的实现，我们首先需要从请求头中提取JWT。让我们实现以下代码：
- en: '[PRE135]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The preceding code retrieves the JWT on the header with an *authorization* key,
    and when a token is retrieved, we will extract the username to check whether the
    user exists.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从头部通过带有*授权*键的JWT中检索，当检索到令牌时，我们将提取用户名以检查用户是否存在。
- en: Then, the next step is to load the user’s details using the retrieved username
    and check that the token is valid and not yet expired. If the token is good, we
    will create a `UsernamePasswordAuthenticationToken` from the user details and
    the list of the authorized users.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，下一步是使用检索到的用户名加载用户详情，并检查令牌是否有效且尚未过期。如果令牌有效，我们将从用户详情和授权用户列表中创建一个`UsernamePasswordAuthenticationToken`。
- en: 'We will set the new authenticated principal in our security context; let’s
    have a look the following code implementation:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的安全上下文中设置新的已认证主体；让我们看一下以下代码实现：
- en: '[PRE136]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We have successfully created a filter for our requests, and our authentication
    endpoints are all configured. The only thing we need to do is finalize our configuration.
    We would want to modify `UserDetailsService` with our custom authentication.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为我们的请求创建了一个过滤器，并且我们的认证端点都已经配置好了。我们唯一需要做的是完成我们的配置。我们希望修改`UserDetailsService`以使用我们自定义的认证。
- en: 'To achieve this, we will go back to our `SecurityConfig` file and place the
    following code implementation on our `configure(AuthenticationManagerBuilder`
    `auth)` method:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将回到我们的`SecurityConfig`文件，并在我们的`configure(AuthenticationManagerBuilder
    auth)`方法上放置以下代码实现：
- en: '[PRE137]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The next step is we need to add the filter we have created; under the `configure(HttpSecurity
    http)` method, we will place the following code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要添加我们创建的过滤器；在`configure(HttpSecurity http)`方法下，我们将放置以下代码：
- en: '[PRE138]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Now that our security configuration is complete, our final step is to add authentication
    to our anti-hero endpoints. A valid JWT is required upon making a request to the
    anti-hero endpoints.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了安全配置，我们的最后一步是为我们的反英雄端点添加认证。向反英雄端点发出请求时需要有效的JWT。
- en: 'To achieve this, we will annotate `AntiHeroController` with `@PreAuthorize("isAuthenticated()")`
    to configure the endpoints with the authentication process:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`@PreAuthorize("isAuthenticated()")`注解`AntiHeroController`来配置端点与认证过程：
- en: '[PRE139]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We have successfully implemented Spring Security and JWT on our application;
    let’s simulate the endpoints created.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用程序中成功实现了Spring Security和JWT；让我们模拟创建的端点。
- en: 'We will send an HTTP `GET` request for the anti-hero controller to get the
    list of all anti-heroes:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向反英雄控制器发送一个HTTP `GET`请求以获取所有反英雄的列表：
- en: "![Figure 7.2 – 403 Forbidden on getting\uFEFF the anti-heroes list](img/B18159_07_02.jpg)"
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 获取反英雄列表时403禁止](img/B18159_07_02.jpg)'
- en: Figure 7.2 – 403 Forbidden on getting the anti-heroes list
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 获取反英雄列表时403禁止
- en: 'When we send a sample request to one of the anti-heroes, this will now return
    a 403 error since it requires a valid token from our request headers. In this
    case, we need to create a new user using the `/``register` endpoint:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向其中一个反英雄发送一个示例请求时，现在这将返回一个403错误，因为它需要我们请求头中的有效令牌。在这种情况下，我们需要使用`/register`端点创建一个新的用户：
- en: '![Figure 7.3 – User registration](img/B18159_07_03.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 用户注册](img/B18159_07_03.jpg)'
- en: Figure 7.3 – User registration
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 用户注册
- en: 'After successfully creating our user, this is now a valid credential, and we
    can log in using the `/``authenticate` endpoint:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户成功后，现在这是一个有效的凭证，我们可以使用`/authenticate`端点进行登录：
- en: '![Figure 7.4 – New credential login](img/B18159_07_04.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 新凭证登录](img/B18159_07_04.jpg)'
- en: Figure 7.4 – New credential login
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 新凭证登录
- en: 'We can see in the preceding example that our login is successful and the `/authenticate`
    endpoint returned a valid token. We can now use the token in the request header
    to send a request to anti-hero endpoints:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在先前的例子中看到，我们的登录是成功的，并且`/authenticate`端点返回了一个有效的令牌。我们现在可以使用这个令牌在请求头中发送请求到反英雄端点：
- en: '![Figure 7.5 – Anti-hero endpoint returns the list successfully](img/B18159_07_05.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 反英雄端点成功返回列表](img/B18159_07_05.jpg)'
- en: Figure 7.5 – Anti-hero endpoint returns the list successfully
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 反英雄端点成功返回列表
- en: We can see in the preceding example that we have used the generated token in
    our authorization header, and we have received a 200 response and returned the
    list of anti-heroes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在先前的例子中看到，我们在授权头中使用了生成的令牌，并且收到了200响应并返回了反英雄列表。
- en: We have now successfully created the custom authentication and authorization
    for our Spring Boot application using Spring Security. In the next section, we
    will discuss an additional topic relating to security, called IDaaS.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地为我们的Spring Boot应用程序使用Spring Security创建了自定义的验证和授权。在下一节中，我们将讨论一个与安全相关的附加主题，称为IDaaS。
- en: IDaaS
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDaaS
- en: In the previous section, we created our custom login authentication using Spring
    Security. We utilized some of the features of Spring Security and also used JWT
    to store user states and validate credentials. However, this example is not enough
    of a reliable and secure way of implementing authentication for our application.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用Spring Security创建了自定义的登录验证。我们利用了Spring Security的一些功能，并使用JWT来存储用户状态和验证凭证。然而，这个例子不足以作为我们应用程序实现验证的可靠和安全的方式。
- en: Large and enterprise applications nowadays demand several security features
    to be able to prevent possible vulnerabilities that can occur. These features
    can include the architecture and the implementation of other services, such as
    SSO and **Multi-Factor Authentication** (**MFA**). These features can be cumbersome
    to work with and can require several sprints to modify, leading to a longer time
    to develop. This is where IDaaS comes to the rescue.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现今的大型和企业级应用程序需要几个安全特性来防止可能出现的漏洞。这些特性可能包括架构和其他服务的实现，如单点登录和多因素认证（**MFA**）。这些特性可能难以处理，可能需要几个迭代来修改，从而导致更长的开发时间。这就是IDaaS发挥作用的地方。
- en: IDaaS is a delivery model that allows users to connect, authenticate, and use
    identity management services from the cloud. IDaaS helps speed up the development
    process as all authentication and authorization processes are provided under the
    hood.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: IDaaS是一种交付模式，允许用户从云端连接、验证和使用身份管理服务。IDaaS有助于加快开发过程，因为所有验证和授权过程都在幕后提供。
- en: It is commonly used by large and enterprise applications because of the advantages
    and features it offers. IDaaS systems utilize the power of cloud computing to
    handle **Identity Access Management** (**IAM**), which ensures that the right
    users access the resources. It is very helpful as companies do not need to worry
    about security and IAM responsibilities, which are very demanding due to the adaptation
    of cybersecurity threats.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被大型和企业级应用程序使用，因为它提供了优势和特性。IDaaS系统利用云计算的力量来处理**身份访问管理**（**IAM**），确保正确的用户访问资源。这对公司来说非常有帮助，因为它们不需要担心由于网络安全威胁的适应而变得非常繁重的安全和IAM责任。
- en: Types of IDaaS
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDaaS类型
- en: 'There are several types of IDaaS available on the market; some providers only
    provide clients with a directory, others offer several sets of features, which
    include SSO and MFA, but we will split IDaaS into two categories:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多种类型的IDaaS可用；一些提供商只为客户端提供目录，其他提供包括单点登录和多因素认证（MFA）在内的多套功能，但我们将IDaaS分为两个类别：
- en: Basic IDaaS
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本IDaaS
- en: Enterprise IDaaS
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业IDaaS
- en: Basic IDaaS
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本IDaaS
- en: Small- and medium-sized businesses commonly use basic IDaaS. It usually provides
    SSO and MFA and a cloud directory for storing credentials.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 小型和中等企业通常使用基本的IDaaS。它通常提供单点登录和多因素认证（MFA）以及一个云目录来存储凭证。
- en: Basic IDaaS providers are also packaged with a more straightforward interface
    that gives users the capability to handle configuration and administrative tasks.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的IDaaS提供商还包含一个更直观的界面，使用户能够处理配置和管理任务。
- en: Enterprise IDaaS
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业IDaaS
- en: Enterprise IDaaS, compared to basic IDaaS, is more complex and used by large
    and enterprise businesses. This is commonly used to extend the IAM infrastructure
    of the organization and provide access management to web, mobile, and API environments.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本的IDaaS相比，企业IDaaS更为复杂，并被大型和企业级业务所使用。这通常用于扩展组织的IAM基础设施，并为Web、移动和API环境提供访问管理。
- en: 'There are five requirements that an IDaaS should possess:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IDaaS应该具备以下五个要求：
- en: '**SSO**: Gives users the capability to access all platforms and applications
    using a single authentication'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录（SSO）**：使用单一认证让用户能够访问所有平台和应用程序'
- en: '**MFA**: Increases the layers of security, requiring the user to present two
    valid pieces of evidence to prove their identity'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多因素认证（MFA）**：增加安全层，要求用户出示两份有效的证据来证明其身份'
- en: '**Cloud directory**: Provides a cloud directory where data and credentials
    can be stored'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云目录**：提供一个云目录，其中可以存储数据和凭证'
- en: '**Access security**: Policy-based management for applications for increasing
    security'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问安全**：基于策略的应用程序管理，用于提高安全性'
- en: '**Provisioning**: Provides capabilities to automate the exchange of user identities
    between applications and service providers using **System for Cross-Domain Identity**
    **Management** (**SCIM**)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：提供使用**跨域身份管理**（**SCIM**）系统自动在应用程序和服务提供商之间交换用户身份的能力'
- en: Those are the five characteristics required of an IDaaS.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是IDaaS所需的五个特性。
- en: 'If you are wondering about any examples of an IDaaS that you can use, here
    are some service providers:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道可以使用哪些IDaaS的示例，以下是一些服务提供商：
- en: '**Google Cloud Identity**: Google Cloud Identity provides a wide range of security
    features for users to enable authentication, access management, and authorization.
    It is an enterprise IDaaS with several security features, such as SSO, MFA, automated
    user provisioning, and context-aware access.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌云身份**：谷歌云身份为用户提供了一系列安全功能，以启用身份验证、访问管理和授权。它是一个具有多个安全功能的企业IDaaS，例如SSO、MFA、自动用户配置和上下文感知访问。'
- en: To learn more about Google Cloud Identity, you can visit [https://cloud.google.com/identity](https://cloud.google.com/identity).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于谷歌云身份的信息，您可以访问[https://cloud.google.com/identity](https://cloud.google.com/identity).
- en: '**Okta Workforce Identity**: Okta is one of the top IDaaS providers on the
    market. It is also an enterprise IDaaS provider that has several basic and advanced
    features, such as SSO, MFA, Universal Directory, B2B integration, and API Access
    Management.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Okta工作身份**：Okta是市场上领先的IDaaS提供商之一。它也是一家企业级IDaaS提供商，拥有多个基本和高级功能，例如SSO、MFA、通用目录、B2B集成和API访问管理。'
- en: Okta and Auth0 joined forces around 2021, providing identity platforms and solutions
    such as universal login, password-less authentication, and machine-to-machine
    communication.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Okta和Auth0于2021年联合起来，提供通用登录、无密码认证和机器到机器通信等身份平台和解决方案。
- en: 'To learn more about Auth0 and Okta, you can visit the following links: [https://auth0.com/](https://auth0.com/)
    and [https://www.okta.com/workforce-identity/](https://www.okta.com/workforce-identity/).'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Auth0和Okta的信息，您可以访问以下链接：[https://auth0.com/](https://auth0.com/) 和 [https://www.okta.com/workforce-identity/](https://www.okta.com/workforce-identity/).
- en: '**Azure Active Directory**: Azure Active Directory is also an enterprise-grade
    IDaaS solution, the same as the other providers. It offers a wide range of security
    solutions, has several features, such as identity governance, unified identity
    management, and password-less authentication, for users, and best of all has a
    basic tier that is free to use.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Active Directory**：Azure Active Directory也是一个企业级IDaaS解决方案，与其他提供商相同。它提供了一系列安全解决方案，具有多个功能，如身份治理、统一身份管理和无密码认证，并且最好的是有一个免费使用的入门级服务。'
- en: To learn more about Azure Active Directory, you can visit [https://azure.microsoft.com/en-us/services/active-directory/](https://azure.microsoft.com/en-us/services/active-directory/).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Azure Active Directory的信息，您可以访问[https://azure.microsoft.com/en-us/services/active-directory/](https://azure.microsoft.com/en-us/services/active-directory/).
- en: Summary
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned. You have learned about the concept and importance
    of CORS and how it can provide security for accessing resources. We have discussed
    the different ways that we can implement CORS in our Spring Boot applications,
    which are at the method level, at the controller level, and a combination of both
    approaches.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经到达了本章的结尾。让我们回顾一下你所学到的宝贵知识。你学习了CORS的概念和重要性，以及它是如何为访问资源提供安全性的。我们讨论了在Spring
    Boot应用中实现CORS的不同方法，这些方法包括在方法级别、控制器级别，以及两者的结合方式。
- en: We have also learned about the concept and features of Spring Security and discussed
    the implementation of custom authentication and authorization in our application.
    Lastly, we have also learned about IDaaS, a delivery model that allows users to
    connect, authenticate, and use identity management services from the cloud.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了Spring Security的概念和特性，并讨论了在我们应用中实现自定义认证和授权的实现方法。最后，我们还了解了IDaaS，这是一种允许用户从云端连接、认证和使用身份管理服务的交付模式。
- en: In the next chapter, we will be learning about the integration of event loggers
    into our Spring Boot application.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将事件记录器集成到我们的Spring Boot应用中。
