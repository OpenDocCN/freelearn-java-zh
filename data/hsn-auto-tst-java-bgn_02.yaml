- en: Understanding Classes, Objects, and Their Usage in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java中的类、对象及其用法
- en: In the previous chapter, we covered a short introduction to Java and how to
    install the editor that we will be typing our code in. We also wrote and executed
    our first code on the editor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了Java以及我们将要输入代码的编辑器的安装方法。我们还编写并执行了在编辑器上的第一个代码。
- en: In this chapter, we will go deeper into some basic concepts, such as strings
    and variables, and how they are different from each other. We will also see what
    methods are and how they are put to use with different code. We will discuss why
    objects are important in our code and how we can implement them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨一些基本概念，例如字符串和变量，以及它们之间的不同。我们还将了解方法是什么，以及它们如何与不同的代码一起使用。我们将讨论对象在我们的代码中的重要性以及如何实现它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Difference between strings and variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和变量的区别
- en: Using methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法
- en: Importance of classes and objects in Java
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中类和对象的重要性
- en: Difference between strings and variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和变量的区别
- en: 'In [Chapter 1](89991415-42e6-424d-83e8-8009fdc38f8f.xhtml), *First Programming
    Steps in Java*, we printed a string and the variable. If we look closely, when
    we print a variable we are not using double quotes, but when we print a string,
    we are using them. This is because the value is already present in the variable,
    hence we need not use any double quotes. If we use them, Java considers it to
    be a string and the output will be printed as the letter `a` in the following
    example. If we run this and observe the output, the letter `a` will be printed
    as shown in the following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](89991415-42e6-424d-83e8-8009fdc38f8f.xhtml)，“Java中的第一步编程”，我们打印了一个字符串和变量。如果我们仔细观察，当我们打印一个变量时，我们并没有使用双引号，但是当我们打印一个字符串时，我们使用了它们。这是因为值已经存在于变量中，所以我们不需要使用任何双引号。如果我们使用它们，Java会将其视为字符串，并且输出将像以下示例中的字母`a`一样打印。如果我们运行这个程序并观察输出，字母`a`将按以下截图所示打印：
- en: '![](img/95c911f9-6b23-4f44-a268-444f52f7de93.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95c911f9-6b23-4f44-a268-444f52f7de93.png)'
- en: Output displaying the value of a as per the code
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示根据代码的a的值
- en: 'If we don''t use double quotes, Java will check whether there is any variable
    defined with this letter. If so, it prints the value present in that variable.
    If there is no variable defined, then it gives an error. If we comment out the
    variable declaration, what we see is an error. Hovering the mouse over the variable,
    we will get a prompt saying Create a local variable ''a'', or we can use it by
    adding double quotes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用双引号，Java将检查是否有任何变量被定义为这个字母。如果有，它将打印该变量中的值。如果没有定义任何变量，那么它将给出一个错误。如果我们注释掉变量声明，我们会看到一个错误。将鼠标悬停在变量上，我们会得到一个提示说创建一个局部变量`a`，或者我们可以通过添加双引号来使用它：
- en: '![](img/701160b8-1228-4ed6-a4ea-2c80aeadbda7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/701160b8-1228-4ed6-a4ea-2c80aeadbda7.png)'
- en: Quick fixes drop down with suggestions to correct the code error
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提供代码错误纠正建议的快速修复下拉菜单
- en: In short, if we simply use double quotes, the variable will be treated as a
    string, but if we don't use double quotes, we must declare the variable somewhere.
    That is the difference between printing out strings and printing out variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们简单地使用双引号，变量将被视为字符串，但如果我们不使用双引号，我们必须在某个地方声明变量。这就是打印字符串和打印变量之间的区别。
- en: Using methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Basically, methods are blocks in our Java class. Let''s write one block here
    as an example, and observe where the opened and closed brackets are placed. The
    following example shows one complete block:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，方法是我们Java类中的代码块。让我们在这里写一个代码块作为例子，并观察开闭括号放置的位置。以下示例显示了一个完整的代码块：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we have named the block of code `getData()` and `void` is the
    return type for this method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们给代码块命名为`getData()`，而`void`是这个方法的返回类型。
- en: If we are expecting to return a number from the method, and the number is an
    integer, then we have to write `integer` in place of `void`. The same applies
    with strings; if we are planning to return a string from the `getData()` method,
    then we have to declare it as a `string`. If we are not returning anything, that
    is, if we are simply writing a few lines of code, then we leave it as `void`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望从方法返回一个数字，并且这个数字是一个整数，那么我们必须在`void`的位置写上`integer`。同样的规则也适用于字符串；如果我们计划从`getData()`方法返回一个字符串，那么我们必须将其声明为`string`。如果我们不返回任何内容，也就是说，如果我们只是写了几行代码，那么我们将其保留为`void`。
- en: 'Take a look at the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下截图：
- en: '![](img/f19e2e43-91e8-49bf-9df8-a86691130e56.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f19e2e43-91e8-49bf-9df8-a86691130e56.png)'
- en: Return type is given as void for getData()
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`getData()`，返回类型被指定为`void`。
- en: Here, we are not returning anything, so we keep it as `void`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有返回任何内容，所以我们将其保持为`void`。
- en: 'Let''s add a `return 2;` line below `System.out.println(" I am in method");`.
    Here, we are returning a number that is an integer. That''s why we will receive
    an error here. If we hover our mouse over the error shown over `return 2;`, you
    will see a suggestion, Change method return type to ''int'':'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`System.out.println(" I am in method");`下面添加一行`return 2;`。在这里，我们返回的是一个整数。这就是为什么我们会在这里收到错误。如果我们将鼠标悬停在`return
    2;`上显示的错误上，你会看到一个建议，将方法返回类型更改为'int'：
- en: '![](img/bbef302b-2ad0-4e6f-ac27-7403c44d3042.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbef302b-2ad0-4e6f-ac27-7403c44d3042.png)'
- en: Quick fixes drop down with suggestions to correct the code error
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单会显示建议以纠正代码错误
- en: On clicking on the suggestion, our IDE automatically modifies the return type
    to integer and the error disappears. The same is also the case with the string
    data type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 点击建议后，我们的IDE会自动将返回类型修改为整数，错误消失。字符串数据类型的情况也是如此。
- en: We will discuss the `public` access modifier later on in [Chapter 10](b0ee13be-6d61-427c-9dca-99750b6fafdd.xhtml), *The
    Importance of the final Keyword, Packages, and Modifiers*. There is a lot to discuss
    since there are different access modifiers in Java, such as `public`, `private`,
    `protected`, and `default`. We will take a look at each access modifier with appropriate
    examples so that they are explained in detail. For now, let's just accept all
    access modifiers as `public`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](b0ee13be-6d61-427c-9dca-99750b6fafdd.xhtml)“关键字final的重要性、包和修饰符”中讨论`public`访问修饰符。由于Java中有不同的访问修饰符，如`public`、`private`、`protected`和`default`，所以有很多要讨论的内容。我们将通过适当的示例查看每个访问修饰符，以便详细解释。现在，我们只需将所有访问修饰符视为`public`。
- en: Now you must be wondering why these methods are present in Java. What is their
    use?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道为什么这些方法存在于Java中。它们有什么用？
- en: Let's say that we are executing a 10-line block of code, for example, to add
    two integers on a page. Now every time we reach a page that requires us to add
    two integers, we have to write the 10 lines of code again. Maybe replicating the
    10 lines of code won't matter for one instance but what if we were to require
    this block of code for 10 instances throughout the entire project? So 10 pages
    and 10 lines of code makes 100 lines of code that we are replicating in a single
    Java program. So to avoid that, we write all the 10 lines of code into one block,
    and we name that block as, for example, `getData` or anything else. Thereafter,
    whenever we require the 10 lines of code that we typed, we can simply call the
    `getData` method. All the 10 lines of code will fall into that particular block,
    and it will get executed. In this case, we avoid writing the code 10 times; we
    write it only once in a method and call that method whenever it is required.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在执行一段10行的代码块，例如，在页面上添加两个整数。现在每次我们到达需要添加两个整数的页面时，我们必须再次编写这10行代码。也许复制这10行代码对于单个实例来说可能无关紧要，但如果在整个项目中需要这个代码块10次呢？所以10页和10行代码在单个Java程序中就变成了100行代码，这是我们在复制。为了避免这种情况，我们将所有10行代码写入一个代码块中，例如命名为`getData`或其他任何名称。此后，每次我们需要输入这10行代码时，我们只需简单地调用`getData`方法。所有10行代码都会落入这个特定的代码块中，并会被执行。在这种情况下，我们避免了10次编写代码；我们只在方法中编写一次，并在需要时调用该方法。
- en: 'Let''s explain this with an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来解释这一点：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding class, we will consider `" I am in method"` as the 10 lines
    of code that we were talking about earlier. We want to call this method, but here
    the `getData()` block is outside the `main` block, which means that the code cannot
    be executed. To execute it, we must move it inside the `main` block. In most cases,
    people just copy the code inside the `main` block and then receive an error since
    no methods are allowed inside the `main` block. The method should be written outside
    the main block, but inside the class. If we write something outside the class,
    there is no point since Java does not catch it. But if we write the method outside
    the `main` block, how do we get it inside the `main` block? For that, we need
    to create an object for the class where our method is defined. Here, our methods
    are defined in the `Firstclass` class, so we create an object for this class and
    with that object we can access the methods and variables present in the class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们将“我在方法中”视为我们之前提到的10行代码。我们想要调用这个方法，但在这里`getData()`块在`main`方法块之外，这意味着代码无法执行。要执行它，我们必须将其移动到`main`方法块内部。在大多数情况下，人们只是将代码复制到`main`方法块中，然后收到错误，因为不允许在`main`方法块中存在方法。方法应该写在`main`方法块之外，但类内部。如果我们把东西写在类外部，那就没有意义，因为Java不会捕获它。但是，如果我们把方法写在`main`方法块之外，我们如何将其放入`main`方法块中呢？为此，我们需要为定义方法的类创建一个对象。在这里，我们的方法是在`Firstclass`类中定义的，所以我们为这个类创建一个对象，然后我们可以通过这个对象访问类中存在的方法和变量。
- en: In the next section, we'll see what the objects are, where we use them, and
    how objects are used to call the methods and variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解对象是什么，在哪里使用它们，以及如何使用对象调用方法和变量。
- en: Importance of classes and objects in Java
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中类和对象的重要性
- en: Objects are instances or references of a class. So we can call the methods and
    variables present in this class with the help of their objects. We cannot call
    methods and objects directly, we can only use them with the help of their objects. So
    first, we need to create objects for the class, and then we can call the method
    inside the `main` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是类的实例或引用。因此，我们可以通过它们的对象来调用类中存在的方法和变量。我们不能直接调用方法和对象，我们只能通过它们的对象来使用它们。因此，首先，我们需要为类创建对象，然后我们才能在`main`类中调用方法。
- en: 'Let''s take a look at the previous example to explain this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的例子来解释这一点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the `main` block is already in the class, why do we need to create an
    object again for this class and call it?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然`main`方法块已经在类中，为什么我们还需要为这个类创建一个对象并调用它呢？
- en: The answer is that there is no way that the `main` block will come to know about
    the method outside it until and unless we create an object to call the method.
    There is an exception for that, which is the `static` variable, saying that the
    method is static. So, in general, accessing other methods is only possible with
    objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，除非我们创建一个对象来调用方法，否则`main`方法块将无法知道其外部的方法。有一个例外，那就是`static`变量，表示该方法为静态。因此，通常情况下，只有通过对象才能访问其他方法。
- en: Creating an object in Java
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中创建对象
- en: 'First, we need to allocate some memory for the object in the class. Memory
    can be allocated with the help of the `new` operator followed by the class name.
    Then we define an object name for it. The return type should always be the class
    name. This is the syntax for creating a memory allocation for a class. So the
    code for memory allocation for the preceding example will look something like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在类中为对象分配一些内存。内存可以通过在类名后跟`new`操作符来分配。然后我们为它定义一个对象名称。返回类型始终应该是类名。这是为类创建内存分配的语法。因此，前一个示例的内存分配代码将类似于以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we say `fn` is the object of the `Firstclass` class. Now that we have
    created an object, let's see how we can access it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说`fn`是`Firstclass`类的对象。现在我们已经创建了一个对象，让我们看看我们如何访问它。
- en: Accessing an object in Java
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中访问对象
- en: To access the method of the class, we write the object name and then `.` (dot).
    All the methods that qualify for the class are displayed in a drop-down—this is
    another great feature in Eclipse. We can just look for the method in the drop-down
    rather than searching for it through the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问类的成员方法，我们写入对象名称，然后 `.` (点)。所有符合该类的成员方法都会在下拉列表中显示——这是Eclipse的另一个优秀特性。我们只需在下拉列表中查找方法，而不是通过代码搜索它。
- en: 'In the example, we are using the `getData()` method. The rest of the methods
    shown are all built-in Java methods. Observe how the methods are displayed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用的是`getData()`方法。其余显示的方法都是Java的内置方法。观察方法是如何显示的：
- en: '![](img/6a444ef7-aadf-4fc7-85cc-748bcd5af95a.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a444ef7-aadf-4fc7-85cc-748bcd5af95a.png)'
- en: Drop-down showing all the class methods available to the editor to use
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉菜单显示编辑器可用的所有类方法
- en: 'On clicking on `getData()`, the `getData()` block will be transferred to the
    line where the object was called, and when we run the program, the code will be
    executed as it is part of the `main` block. The accessing code will finally look
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击`getData()`时，`getData()`块将被转移到调用对象所在的行，当我们运行程序时，代码将作为`main`块的一部分执行。访问代码最终将如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see what the final code for this example will look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例的最终代码将是什么样子：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So if we run the class given in the example, our result will be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们运行示例中给出的类，我们的结果将如下所示：
- en: '![](img/816f4740-d7ba-4ca8-a963-eede62592cc2.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/816f4740-d7ba-4ca8-a963-eede62592cc2.png)'
- en: Output displaying I am in method as per the code
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码显示的“I am in method”
- en: '`I am in method` is what we see in the output; this is because control starts
    from the memory-allocation line, creates an object, and using the object we call
    the method of that class. Control goes back to the `getData()` block and completes
    the lines of code that are present in that particular block; it executes the print
    statement, and we see that it gets printed. This is why objects are powerful in
    calling a method.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中我们看到的是“I am in method”；这是因为控制从内存分配行开始，创建一个对象，然后使用该对象调用该类的的方法。控制返回到`getData()`块并完成该特定块中存在的代码行；它执行打印语句，我们看到它被打印出来。这就是为什么对象在调用方法时是强大的。
- en: 'The same technique can be used for calling integers. Let''s say we declare
    a variable in the `a` class and assign a value to it. We can print the variable
    value by adding the following line in the `main` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术也可以用于调用整数。假设我们在`a`类中声明一个变量并给它赋值。我们可以在`main`方法中添加以下行来打印变量的值：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is one way of using classes, objects, and methods in Java; basically we
    are encapsulating.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Java中使用类、对象和方法的一种方式；基本上我们是在封装。
- en: Accessing a method in a different class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同类中访问方法
- en: Let's say we face a situation where we are working with one class and we need
    to access an object in another class; this can be done in Java. Let's use an example
    to help explain this. Let's use two classes, `Firstclass()` (from the *Accessing
    an object in Java* section ), and we'll create a new class, called `secondclass()`.
    On creating a new class, the default code is created by the editor and we're able
    to add code in it. We add a random method, `public void setData()`, within which
    we print the `I am in second class method` statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们面临一个情况，我们正在处理一个类，我们需要访问另一个类中的对象；在Java中可以这样做。让我们用一个例子来帮助解释这一点。让我们使用两个类，`Firstclass()`（来自*Java中访问对象*部分），然后我们创建一个新的类，称为`secondclass()`。在创建新类时，编辑器会创建默认代码，我们可以在其中添加代码。我们添加一个随机方法，`public
    void setData()`，在其中我们打印`I am in second class method`语句。
- en: 'Now, we want the `setData()` method in the `Firstclass()` class. Basically
    we want to execute the `setData()` method in `Firstclass()`. And methods can be
    called only with the objects of that particular class. To do so, we create an
    object in the method that calls the method in the other class. We use similar
    code to what we used in the previous example to allocate memory for an object.
    The following code is added in the `main` method of `Firstclass()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在`Firstclass()`类中实现`setData()`方法。基本上我们想在`Firstclass()`中执行`setData()`方法。并且只能通过该特定类的对象来调用方法。为此，我们在调用另一个类中方法的方法中创建一个对象。我们使用与上一个示例中相同的代码来为对象分配内存。以下代码被添加到`Firstclass()`的`main`方法中：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While typing the code in the `main` class, when we type `sn.` to call the method,
    we will again get all the choices of methods that there are in Java. Since we
    want to call `setData()`, we select it from the multiple options that are shared
    with us. This will successfully bring `setData()` into in the `main` method of
    `Firstclass()` by creating an object for the class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`类中编写代码时，当我们输入`sn.`来调用方法时，我们又将得到Java中所有方法的选项。由于我们想调用`setData()`，我们从与我们共享的多个选项中选择它。这将通过为该类创建一个对象，成功地将`setData()`带入`Firstclass()`的`main`方法中。
- en: 'If we run the code, we will get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们将得到以下输出：
- en: '![](img/5735c3cf-5d54-4ade-9e34-992f83229f8b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5735c3cf-5d54-4ade-9e34-992f83229f8b.png)'
- en: Output displaying I am in second class method as per the code
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示“根据代码，我在第二个类方法中”
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started off by discussing the difference between strings and variables, and
    how they appear in a code. We then saw what methods are and how can they be used
    to write our code. After that, we discussed the importance of classes and objects,
    and how they are used to call methods that execute a class. We learned how to
    allocate memory to an object and call the method of that object while executing
    the code.Finally, we learned how to access a method that is present in another
    class using objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了字符串和变量之间的区别，以及它们在代码中的表现形式。然后，我们了解了方法是什么，以及如何使用它们来编写我们的代码。接着，我们讨论了类和对象的重要性，以及它们是如何被用来调用执行类的方法的。我们学习了如何为对象分配内存，并在执行代码时调用该对象的方法。最后，我们学习了如何通过对象访问另一个类中存在的方法。
- en: In the next chapter we will learn more about strings and have a look at the `String` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于字符串的知识，并查看`String`类。
