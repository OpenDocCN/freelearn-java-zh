- en: Concurrency and Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与响应式编程
- en: In the previous chapter, we covered several **Java Enhancement Proposals** (**JEPs**)
    that were incorporated into the Java 9 platform. These JEPs represented a wide
    range of tools and updates to APIs to make developing with Java easier, with greater
    optimization possibilities for our Java applications. We looked at the new HTTP
    client, changes to Javadoc and the Doclet API, the new JavaScript parser, JAR
    and JRE changes, the new Java-level JVM compiler interface, the new support for
    TIFF images, platform logging, XML catalog support, collections, and the new platform-specific
    desktop features. We also looked at enhancements to method handling and the deprecation
    annotation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了几个被纳入Java 9平台的**Java增强提案**（**JEPs**）。这些JEPs代表了一系列工具和API的更新，使得使用Java进行开发更加容易，并为我们的Java应用程序提供了更大的优化可能性。我们探讨了新的HTTP客户端、Javadoc和Doclet
    API的变更、新的JavaScript解析器、JAR和JRE的变更、新的Java级别JVM编译器接口、对TIFF图像的新支持、平台日志记录、XML目录支持、集合以及新的平台特定桌面功能。我们还探讨了方法处理增强和弃用注解。
- en: In this chapter we will cover concurrency enhancements introduced with the Java
    9 platform. Our primary focus will be the support for reactive programming, a
    concurrency enhancement that is provided by the `Flow` class API. Reactive programming
    is a new concept for Java 9, so we will take an exploratory approach to the topic.
    We will also explore additional concurrency enhancements introduced in Java 9.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Java 9平台引入的并发增强。我们的主要关注点将是响应式编程的支持，这是由`Flow`类API提供的并发增强。响应式编程是Java
    9的一个新概念，因此我们将对该主题采取探索性方法。我们还将探讨Java 9中引入的其他并发增强。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Reactive programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: The new `Flow` API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`Flow` API
- en: Additional concurrency updates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的并发更新
- en: Spin-wait hints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自旋等待提示
- en: Reactive Programming
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: 'Reactive programming is when applications react to an asynchronous data stream
    as it occurs. The following image illustrates the flow:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是指应用程序对异步数据流进行响应，当它发生时。以下图像展示了流程：
- en: '![](img/d1dd7408-4b2c-45c4-a860-372e960daefa.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1dd7408-4b2c-45c4-a860-372e960daefa.png)'
- en: Reactive programming is not a fancy software engineering term only used by academics.
    It is, in fact, a programming model that can result in much greater efficiencies
    as opposed to the more common method of having applications iterate over data
    that is in memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程不是一个只有学者使用的花哨的软件工程术语。实际上，它是一种编程模型，与更常见的应用程序遍历内存中数据的方法相比，它可以带来更高的效率。
- en: There is more to reactive programming. First, let's consider that the data stream
    is provided by a publisher in an asynchronous manner to the subscriber.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程还有更多内容。首先，让我们考虑数据流是以异步方式由发布者提供给订阅者的。
- en: Data streams are a binary input/output of strings and primitive data types.
    The `DataInput` interface is used for an input stream and the `DataOutput` interface
    is used for output streams.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是字符串和原始数据类型的二进制输入/输出。`DataInput`接口用于输入流，而`DataOutput`接口用于输出流。
- en: 'Processors, or a chain of processors, can be used to transform the data stream
    without the publisher or subscriber being impacted. In the following example,
    the **Processors** work on the stream of data without **Publisher** or **Subscriber**
    involvement, or even awareness:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器，或处理器链，可以用来转换数据流，而不会影响发布者或订阅者。在以下示例中，**处理器**在数据流上工作，而不涉及**发布者**或**订阅者**，甚至不需要它们知道：
- en: '![](img/c4263677-4fe1-4d74-bc3d-b70ad1f721fb.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4263677-4fe1-4d74-bc3d-b70ad1f721fb.png)'
- en: 'In addition to greater efficiency, reactive programming represents several
    additional benefits, which are highlighted here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更高的效率外，响应式编程还代表了几项额外的优势，以下将重点介绍：
- en: 'The code base can be less verbose, making it:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库可以更简洁，这使得它：
- en: Easier to code
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易编码
- en: Easier to maintain
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易维护
- en: Easier to read
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易阅读
- en: Stream processing results in memory efficiencies
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流处理导致内存效率提升
- en: This is a solution for a variety of programming applications
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个适用于各种编程应用的解决方案
- en: Less boiler-plate code needs to be written, so development time can be focused
    on programming core functionalities
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写的样板代码更少，因此可以将开发时间集中在编程核心功能上
- en: 'The following types of programming require less time and code:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下类型的编程需要更少的时间和代码：
- en: Concurrency
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Low-level threading
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低级线程
- en: Synchronization
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: Reactive programming standardization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程标准化
- en: There are standards in many aspects of software development, and reactive programming
    has not escaped this. There is a **Reactive Streams** initiative to standardize
    asynchronous stream processing. The specific focus, in the context of Java, is
    with the JVM and JavaScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的许多方面都有标准，响应式编程也不例外。有一个**Reactive Streams**倡议用于标准化异步流处理。在Java的上下文中，具体关注的是JVM和JavaScript。
- en: 'The Reactive Streams initiative aims at tackling the issue of governing how
    the data stream is exchanged between threads. As you will recall from the previous
    section, the idea of processors is predicated on there being no impact on the
    publisher or receiver. This no-impact mandate stipulates that the following are
    not required:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams倡议旨在解决如何管理线程之间数据流交换的问题。如您从上一节所回忆的那样，处理器概念基于对发布者或接收者没有影响。这个无影响的要求规定以下内容是不必要的：
- en: Data buffering
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据缓冲
- en: Data translation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换
- en: Conversion
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: The basic semantics of the standard define the regulation of data stream element
    transmission. This standard was specifically established for delivery with the
    Java 9 platform. Reactive Streams includes a library that will help developers
    convert from `org.reactivestreams` and `java.util.concurrent.Flow` namespaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的基本语义定义了数据流元素传输的规范。这个标准是专门为与Java 9平台一起交付而设立的。Reactive Streams包括一个库，可以帮助开发者从`org.reactivestreams`和`java.util.concurrent.Flow`命名空间进行转换。
- en: 'The key to being successful with reactive programming and the Reactive Streams
    standardization is understanding the relevant terminology:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程和Reactive Streams标准化中取得成功的关键是理解相关的术语：
- en: '| **Term** | **Description** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **描述** |'
- en: '| Demand | Demand refers to the subscriber''s request for more elements as
    well as referring to the total number of elements requested that have not been
    fulfilled by the publisher yet. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 需求 | 需求指的是订阅者请求更多元素，同时也指尚未由发布者满足的请求元素的总数。|'
- en: '| Demand | Demand also refers to the total number of elements requested that
    have not been fulfilled by the publisher yet. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 需求 | 需求也指尚未由发布者满足的请求元素的总数。|'
- en: '| External synchronization | External access coordination for thread safety.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 外部同步 | 线程安全的外部访问协调。|'
- en: '| Non-obstructing | Methods are said to be non-obstructing if they rapidly
    execute without the requirement for heavy computations. Non-obstructing methods
    do not delay a subscriber''s thread execution. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 非阻塞 | 如果方法快速执行而不需要大量计算，则称这些方法为非阻塞方法。非阻塞方法不会延迟订阅者的线程执行。|'
- en: '| NOP | NOP execution is execution that can be called repeatedly without impact
    to the calling thread. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 无操作 | 无操作执行是可以反复调用而不影响调用线程的执行。|'
- en: '| Responsivity | This term refers to a component''s ability to respond. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 响应性 | 这个术语指的是组件的响应能力。|'
- en: '| Return normally | Return normally refers to when there are no errors--the
    normal condition. The `onError` method is the only way permitted by the standard
    to inform the subscriber of a failure. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 正常返回 | 正常返回指的是没有错误发生的情况，即正常状态。`onError`方法是标准允许的唯一通知订阅者失败的方式。|'
- en: '| Signal | One of the following methods:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| 信号 | 以下方法之一：'
- en: '`cancel`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel`'
- en: '`onComplete`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`'
- en: '`onError`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`'
- en: '`onNext`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`'
- en: '`onSubscribe`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe`'
- en: '`request`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'You can obtain the standard on Maven Central ([https://search.maven.org](https://search.maven.org)).
    Here is the standard from Maven Central as of the publication date of this book:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Maven Central（[https://search.maven.org](https://search.maven.org)）获取标准。以下是截至本书出版日期的Maven
    Central上的标准：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the next section, we will look at the Flow APIs in the Java 9 platform, as
    they correspond to the Reactive Streams specification.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Java 9平台中的Flow API，因为它们对应于Reactive Streams规范。
- en: The New Flow API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的Flow API
- en: The `Flow` class is part of the `java.util.concurrent` package. It helps developers
    incorporate reactive programming in their applications. The class has one method,
    `defaultBufferSize()`, and four interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow`类是`java.util.concurrent`包的一部分。它帮助开发者将响应式编程融入他们的应用程序。该类有一个方法`defaultBufferSize()`和四个接口。'
- en: The `defaultBufferSize()` is a static method that returns the default buffer
    size for publishing and subscribing buffering. This default value is `256` and
    it is returned as an `int`. Let's look at the four interfaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultBufferSize()`是一个静态方法，它返回发布和订阅缓冲的默认缓冲区大小。这个默认值是`256`，并以`int`的形式返回。让我们看看这四个接口。'
- en: The Flow.Publisher interface
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flow.Publisher`接口'
- en: 'The `Flow.Publisher` interface is a functional interface. A `Publisher` is
    a producer of data sent to subscribers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Publisher`接口是一个函数式接口。一个`Publisher`是向订阅者发送数据的生产者：'
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This functional interface can serve as a lambda expression assignment target.
    It only takes one argument--the subscribed item type `<T>`. It has one method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数式接口可以作为lambda表达式赋值的目标。它只接受一个参数--订阅项的类型`<T>`。它有一个方法：
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onSubscribe(Flow.Subscription subscription)`'
- en: The Flow.Subscriber interface
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flow.Subscriber`接口'
- en: 'The `Flow.Subscriber` interface is used to receive messages and its implementation
    is shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscriber`接口用于接收消息，其实现如下：'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This interface is set up to receive messages. It only takes one argument--the
    subscribed item type `<T>`. It has the following methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口被设置为接收消息。它只接受一个参数--订阅项的类型`<T>`。它有以下方法：
- en: '`void onComplete()`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onComplete()`'
- en: '`void onError(Throwable throwable)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onError(Throwable throwable)`'
- en: '`void onNext(T item)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onNext(T item)`'
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onSubscribe(Flow.Subscription subscription)`'
- en: The Flow.Subscription interface
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flow.Subscription`接口'
- en: 'The `Flow.Subscription` interface ensures that only subscribers receive what
    is requested. Also, as you will see here, a subscription can be cancelled at anytime:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscription`接口确保只有订阅者会接收到请求的内容。同时，您将在此处看到，订阅可以在任何时候取消：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This interface does not take any arguments and is the linkage that controls
    the messages between instances of `Flow.Publisher` and `Flow.Subscriber`. It has
    the following methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口不接受任何参数，是控制`Flow.Publisher`和`Flow.Subscriber`实例之间消息的链接。它有以下方法：
- en: '`void cancel()`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void cancel()`'
- en: '`void request(long n)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void request(long n)`'
- en: The Flow.Processor interface
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flow.Processor`接口'
- en: 'The `Flow.Processor` interface can serve as both a `Subscriber` and a `Publisher`.
    The implementation is provided here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor`接口可以作为`Subscriber`和`Publisher`使用。实现如下：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This interface takes two arguments--the subscribed item type `<T>` and the
    published item type `<R>`. It does not have its own methods, but does inherit
    the following method from `java.util.concurrent.Flow.Publisher`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口接受两个参数--订阅项的类型`<T>`和发布项的类型`<R>`。它没有自己的方法，但继承自`java.util.concurrent.Flow.Publisher`的以下方法：
- en: '`void subscribe(Flow.Subscriber<? super T> subscriber)`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void subscribe(Flow.Subscriber<? super T> subscriber)`'
- en: '`Flow.Processor` also inherits the following methods from the `java.util.concurrent.Flow.Subscriber`
    interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor`还从`java.util.concurrent.Flow.Subscriber`接口继承了以下方法：'
- en: '`void onComplete()`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onComplete()`'
- en: '`void onError(Throwable throwable)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onError(Throwable throwable)`'
- en: '`void onNext(T item)`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onNext(T item)`'
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onSubscribe(Flow.Subscription subscription)`'
- en: Sample implementation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例实现
- en: 'In any given implementation of reactive programming, we will have a `Subscriber`
    that requests data and a `Publisher` that provides the data. Let''s first look
    at a sample `Subscriber` implementation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何响应式编程的实现中，我们都会有一个请求数据的`Subscriber`和一个提供数据的`Publisher`。让我们首先看看一个示例`Subscriber`实现：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, implementing the `Subscriber` is not difficult. The heavy work
    is done with the processors in-between the `Subscriber` and `Publisher`. Let''s
    look at a sample implementation where the `Publisher` publishes a data stream
    to subscribers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现`Subscriber`并不困难。重头戏是在`Subscriber`和`Publisher`之间的处理器中完成的。让我们看看一个示例实现，其中`Publisher`向订阅者发布数据流：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Additional Concurrency Updates
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他并发更新
- en: 'The **More Concurrency Updates** Java Enhancement Proposal, JEP 266, aimed
    to improve the use of concurrency in Java. In this section, we will briefly explore
    the concept of Java concurrency and look at related enhancements to the Java 9
    platform:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多并发更新** Java增强提案，JEP 266，旨在改善Java中的并发使用。在本节中，我们将简要探讨Java并发的概念，并查看对Java 9平台的相关增强：'
- en: Java concurrency
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java并发
- en: Supporting Reactive Streams
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持响应式流
- en: '`CompletableFuture` API enhancements'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture` API增强'
- en: Java concurrency
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发
- en: In this section, we will start with a brief explanation of concurrency, then
    look at system configurations, cover Java threads, and then look at the concurrency
    improvements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从并发的一个简要解释开始，然后查看系统配置，涵盖Java线程，然后查看并发改进。
- en: Concurrency explained
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发解释
- en: Concurrent processing has been around since the 1960s. In those formative years,
    we already had systems that permitted multiple processes to share a single processor.
    These systems are more clearly defined as pseudo-parallel systems because it only
    appeared that multiple processes were being simultaneously executed. Our computers
    today still operate in this manner. The difference between the 1960s and current
    day is that our computers can have multiple CPUs, each with multiple cores, which
    better supports concurrency.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 并发处理自20世纪60年代以来就已经存在。在那些形成年份，我们已经有允许多个进程共享单个处理器的系统。这些系统更明确地定义为伪并行系统，因为它们看起来像多个进程正在同时执行。我们今天的计算机仍然以这种方式运行。20世纪60年代和今天之间的区别在于，我们的计算机可以有多个CPU，每个CPU有多个核心，这更好地支持了并发。
- en: Concurrency and parallelism are often used as interchangeable terms. Concurrency
    is when multiple processes overlap, although the start and stop times could be
    different. Parallelism occurs when tasks start, run, and stop at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行性经常被互换使用。并发是指多个进程重叠，尽管开始和结束时间可能不同。并行性发生在任务同时开始、运行和停止时。
- en: System configurations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统配置
- en: 'There are several different processor configurations that need to be considered.
    This section features two common configurations. The first configuration is that
    of shared memory and is illustrated here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑几种不同的处理器配置。本节介绍了两种常见的配置。第一种配置是共享内存，如下所示：
- en: '![](img/16c7840b-fe24-479a-a6f1-e0524122b049.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16c7840b-fe24-479a-a6f1-e0524122b049.png)'
- en: 'As you can see, the shared memory system configuration has multiple processors
    that all share a common system memory. The second featured system configuration
    is a distributed memory system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，共享内存系统配置具有多个处理器，它们都共享一个公共的系统内存。第二个特色系统配置是分布式内存系统：
- en: '![](img/2fd7c1a8-e2ff-44b8-96c8-35535ef9c6e1.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fd7c1a8-e2ff-44b8-96c8-35535ef9c6e1.png)'
- en: With the distributed memory system, each processor has its own memory and each
    individual processor is fully linked with the other processors, making for a distributed
    system that is fully linked.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式内存系统中，每个处理器都有自己的内存，每个单独的处理器与其他处理器完全连接，从而形成一个完全连接的分布式系统。
- en: Java threads
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java线程
- en: A thread in Java is a program execution and is built into the JVM. The `Thread`
    class is part of the `java.lang` package (`java.lang.Thread`). Threads have priorities
    that control in what order the JVM executes them. While the concept is simple,
    implementation is not. Let's start by taking a close look at the `Thread` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的线程是一个程序执行，它是内置在JVM中的。`Thread`类是`java.lang`包的一部分（`java.lang.Thread`）。线程有优先级，它控制JVM执行它们的顺序。虽然这个概念很简单，但实现并不简单。让我们先仔细看看`Thread`类。
- en: 'The `Thread` class has two nested classes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`线程`类有两个嵌套类：'
- en: '`public static enum Thread.State`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static enum Thread.State`'
- en: '`public static interface Thread.UncaughtExceptionHandler`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static interface Thread.UncaughtExceptionHandler`'
- en: 'There are three instance variables for managing thread priorities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个实例变量用于管理线程优先级：
- en: '`public static final int MAX_PRIORITY`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static final int MAX_PRIORITY`'
- en: '`public static final int MIN_PRIORITY`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static final int MIN_PRIORITY`'
- en: '`public static final int NORM_PRIORITY`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static final int NORM_PRIORITY`'
- en: 'The `Thread` class has eight constructors, all of which allocate a new `Thread`
    object. Here are the constructor signatures:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`线程`类有八个构造函数，它们都会分配一个新的`Thread`对象。以下是构造函数的签名：'
- en: '`public Thread()`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread()`'
- en: '`public Thread(Runnable target)`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(Runnable target)`'
- en: '`public Thread(Runnable target, String name)`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(Runnable target, String name)`'
- en: '`public Thread(String name)`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(String name)`'
- en: '`public Thread(ThreadGroup group, Runnable target)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(ThreadGroup group, Runnable target)`'
- en: '`public Thread(ThreadGroup group, Runnable target, String name)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(ThreadGroup group, Runnable target, String name)`'
- en: '`public Thread(ThreadGroup group, Runnable target, String name, long stackSize)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(ThreadGroup group, Runnable target, String name, long stackSize)`'
- en: '`public Thread(ThreadGroup group, String name)`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread(ThreadGroup group, String name)`'
- en: 'The `Thread` class also has 43 methods, six of which have been deprecated.
    The remaining methods are listed here, save for the accessors and mutators which
    are listed separately. You can consult the documentation for details about each
    of these methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`线程`类还有43个方法，其中六个已被弃用。其余的方法在此列出，除了访问器和修改器，它们将单独列出。您可以查阅文档以了解每个方法的详细信息：'
- en: '`public static int activeCount()`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int activeCount()`'
- en: '`public final void checkAccess()`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void checkAccess()`'
- en: '`protected Object clone() throws CloneNotSupportedException`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected Object clone() throws CloneNotSupportedException`'
- en: '`public static Thread currentThread()`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Thread currentThread()`'
- en: '`public static void dumpStack()`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void dumpStack()`'
- en: '`public static int enumerate(Thread[] array)`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int enumerate(Thread[] array)`'
- en: '`public static boolean holdsLock(Object obj)`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static boolean holdsLock(Object obj)`'
- en: '`public void interrupt()`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void interrupt()`'
- en: '`public static boolean interrupted()`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static boolean interrupted()`'
- en: '`public final boolean isAlive()`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final boolean isAlive()`'
- en: '`public final boolean isDaemon()`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final boolean isDaemon()`'
- en: '`public boolean isInterrupted()`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean isInterrupted()`'
- en: 'join methods:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待方法：
- en: '`public final void join() throws InterruptedException`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void join() throws InterruptedException`'
- en: '`public final void join(long millis) throws InterruptedException`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void join(long millis) throws InterruptedException`'
- en: '`public final void join(long millis, int nano) throws InterruptedException`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void join(long millis, int nano) throws InterruptedException`'
- en: '`public void run()`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void run()`'
- en: 'sleep methods:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '睡眠方法:'
- en: '`public static void sleep(long mills) throws InterruptedException`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void sleep(long mills) throws InterruptedException`'
- en: '`public static void sleep(long mills, int nano) throws InterruptedException`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void sleep(long mills, int nano) throws InterruptedException`'
- en: '`public void start()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void start()`'
- en: '`public String toString()`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String toString()`'
- en: '`public static void yield()`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void yield()`'
- en: 'Here is the list of accessors/getters and mutators/setters for the `Thread`
    class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Thread`类的访问器/获取器和修改器/设置器的列表：
- en: 'accessors/getters:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '访问器/获取器:'
- en: '`public static Map<Thread, StackTraceElement[]> getAllStacktraces()`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Map<Thread, StackTraceElement[]> getAllStacktraces()`'
- en: '`public ClassLoader getContextClassLoader()`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public ClassLoader getContextClassLoader()`'
- en: '`public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()`'
- en: '`public long getId()`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public long getId()`'
- en: '`public final String getName()`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final String getName()`'
- en: '`public final int getPriority()`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final int getPriority()`'
- en: '`public StackTraceElement[] getStackTrace()`'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public StackTraceElement[] getStackTrace()`'
- en: '`public Thread.State getState()`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread.State getState()`'
- en: '`public final ThreadGroup getThreadGroup()`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final ThreadGroup getThreadGroup()`'
- en: '`public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()`'
- en: 'mutators/setters:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '修改器/设置器:'
- en: '`public void setContextClassLoader(ClassLoader cl)`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void setContextClassLoader(ClassLoader cl)`'
- en: '`public final void setDaemon(boolean on)`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void setDaemon(boolean on)`'
- en: '`public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler
    eh)`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler
    eh)`'
- en: '`public final void setName(String name)`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void setName(String name)`'
- en: '`public final void setPriority(int newPriority)`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public final void setPriority(int newPriority)`'
- en: '`public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`'
- en: 'In Java, concurrency is commonly referred to as multithreading. As indicated
    earlier, managing threads, and especially multithreads, requires great fidelity
    in control. Java employs a couple of techniques including the use of locks. Code
    segments can be locked to ensure that only a single thread can execute that code
    at any given time. We can lock classes and method with the use of the `synchronized`
    keyword. Here is an example of how to lock an entire method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，并发通常被称为多线程。如前所述，管理线程，尤其是多线程，需要极高的控制精度。Java采用了一些技术，包括使用锁。代码段可以被锁定，以确保在任何给定时间只有一个线程可以执行该代码。我们可以使用`synchronized`关键字来锁定类和方法。以下是如何锁定整个方法的示例：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next code snippet demonstrates how to use the synchronized keyword to lock
    blocks of code within a method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段演示了如何使用`synchronized`关键字在方法内锁定代码块：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Concurrency improvements
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发改进
- en: The ability to employ multiple threads in our Java applications stands to greatly
    improve efficiency and leverage the increasing processing capabilities of modern
    computers. The use of threads in Java gives us great granularity in our concurrency
    controls.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中，使用多线程的能力可以大大提高效率并利用现代计算机日益增强的处理能力。Java中使用线程为我们提供了在并发控制中的高度粒度。
- en: 'Threads are at the core of Java''s concurrency functionality. We can create
    a thread in Java by defining a `run` method and instantiating a `Thread` object.
    There are two methods of accomplishing this set of tasks. Our first option is
    to extend the `Thread` class and override the `Thread.run` method. Here is an
    example of that approach:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是Java并发功能的核心。我们可以在Java中通过定义一个`run`方法并实例化一个`Thread`对象来创建一个线程。有两种方法来完成这一组任务。我们的第一个选项是扩展`Thread`类并重写`Thread.run`方法。以下是一个示例：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A second approach is to create a class that implements the `Runnable` interface
    and passing an instance of the class to the constructor of the `Thread`. Here
    is an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是创建一个实现`Runnable`接口的类，并将该类的实例传递给`Thread`构造函数。以下是一个示例：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both of these methods work equally well, and which one you use is considered
    to be the developer's choice. Of course, if you are looking for additional flexibility,
    the second approach is probably a better one to use. You can experiment with both
    methods to help you make your determination.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法效果相同，您使用哪一种取决于开发者的选择。当然，如果您需要额外的灵活性，第二种方法可能是一个更好的选择。您可以尝试这两种方法来帮助您做出决定。
- en: CompletableFuture API enhancements
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CompletableFuture API增强
- en: The `CompleteableFuture<T>` class is part of the `java.util.concurrent` package.
    The class extends the `Object` class and implements the `Future<T>` and `CompletionStage<T>`
    interfaces. This class is used to annotate threads that can be completed. We can
    use the `CompletableFuture` class to represent a future result. When the complete
    method is used, that future result can be completed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteableFuture<T>`类是`java.util.concurrent`包的一部分。该类扩展了`Object`类并实现了`Future<T>`和`CompletionStage<T>`接口。此类用于注释可以完成的线程。我们可以使用`CompletableFuture`类来表示未来的结果。当使用`complete`方法时，该未来的结果可以被完成。'
- en: It is important to realize that if multiple threads attempt to simultaneously
    complete (finish or cancel), all but one will fail. Let's look at the class and
    then look at the enhancements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，如果有多个线程同时尝试完成（完成或取消），除了一个之外，其他都会失败。让我们看看这个类，然后再看看增强功能。
- en: Class details
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类详细信息
- en: 'The `CompleteableFuture<T>` class has one internal class that marks asynchronous
    tasks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteableFuture<T>`类有一个内部类，用于标记异步任务：'
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The constructor for the `CompleteableFuture<T>` class has to be in sync with
    the provided constructor signature, and it takes no arguments. The class has the
    following methods organized by what they return.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteableFuture<T>`类的构造函数必须与提供的构造函数签名同步，并且不接受任何参数。该类有以下方法，按它们返回的内容组织。'
- en: 'Returns a `CompletionStage`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个`CompletionStage`：
- en: '`public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other,
    Consumer<? super T> action)`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other,
    Consumer<? super T> action)`'
- en: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action)`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action)`'
- en: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action, Executor executor)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action, Executor executor)`'
- en: '`public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T>
    other, Function<? super T, U> fn)`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T>
    other, Function<? super T, U> fn)`'
- en: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn)`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn)`'
- en: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn, Executor executor)`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn, Executor executor)`'
- en: '`public static <U> CompletedStage<U> completedStage(U value)`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <U> CompletionStage<U> completedStage(U value)`'
- en: '`public static <U> CompletionStage<U> failedStage(Throwable ex)`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <U> CompletionStage<U> failedStage(Throwable ex)`'
- en: '`public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ?
    extends U> fn)`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ?
    extends U> fn)`'
- en: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn)`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn)`'
- en: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn, Executor executor)`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn, Executor executor)`'
- en: '`public CompletionStage<T> minimalCompletionStage()`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletionStage<T> minimalCompletionStage()`'
- en: '`` `public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable
    action)` ``'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable
    action)` ``'
- en: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action)`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action)`'
- en: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
- en: '`public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable
    action)`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable
    action)`'
- en: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action)`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action)`'
- en: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
- en: '`public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable>
    action)`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable>
    action)`'
- en: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action)`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action)`'
- en: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action, Executor executor)`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action, Executor executor)`'
- en: 'These methods return a `CompletionStage`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '这些方法返回一个 `CompletionStage`:'
- en: '`public CompletableFuture<Void> thenAccept(Consumer<? super T> action)`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> thenAccept(Consumer<? super T> action)`'
- en: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)`'
- en: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action,
    Executor executor)`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action,
    Executor executor)`'
- en: '`public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
- en: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
- en: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action, Executor executor)`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action, Executor executor)`'
- en: '`` `public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends
    U> fn)` ``'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends
    U> fn)` ``'
- en: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn)`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn)`'
- en: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn, Executor executor)`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn, Executor executor)`'
- en: '`public <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U>
    other, BiFunction<? super T, ? super U, ? extends V> fn)`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U>
    other, BiFunction<? super T, ? super U, ? extends V> fn)`'
- en: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn)`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn)`'
- en: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn, Executor executor)`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn, Executor executor)`'
- en: '`public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
- en: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
- en: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn, Executor executor)`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn, Executor executor)`'
- en: '`public CompletableFuture<Void> thenRun(Runnable action)`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void> thenRun(Runnable action)`'
- en: '`public CompletableFuture<Void>thenRunAsync(Runnable action)`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void>thenRunAsync(Runnable action)`'
- en: '`public CompletableFuture<Void>thenRunAsync(Runnable action, Executor executor)`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<Void>thenRunAsync(Runnable action, Executor executor)`'
- en: 'These methods return a `CompleteableFuture`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '这些方法返回一个 `CompleteableFuture`:'
- en: '`public static CompletableFuture<Void> allOf(CompletableFuture<?>...cfs)`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static CompletableFuture<Void> allOf(CompletableFuture<?>...cfs)`'
- en: '`public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`'
- en: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier,
    Executor executor)`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier,
    Executor executor)`'
- en: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier)`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier)`'
- en: '`` `public static <U> CompletableFuture<U> completedFuture(U value)` ``'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `public static <U> CompletableFuture<U> completedFuture(U value)` ``'
- en: '`public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit
    unit)`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit
    unit)`'
- en: '`public CompletableFuture<T> copy()`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> copy()`'
- en: '`public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T>
    fn)`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T>
    fn)`'
- en: '`public static <U> CompletableFuture<U> failedFuture(Throwable ex)`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <U> CompletableFuture<U> failedFuture(Throwable ex)`'
- en: '`public <U> CompletableFuture<U> newIncompeteFuture()`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public <U> CompletableFuture<U> newIncompeteFuture()`'
- en: '`public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)`'
- en: '`public static ComletableFuture<Void> runAsync(Runnable runnable)`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ComletableFuture<Void> runAsync(Runnable runnable)`'
- en: '`public static CompletableFuture<Void> runAsync(Runnable runnable, Executor
    executor)`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static CompletableFuture<Void> runAsync(Runnable runnable, Executor
    executor)`'
- en: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`'
- en: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U. supplier, Executor
    executor)`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor
    executor)`'
- en: '`public CompletableFuture<T> toCompletableFuture()`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CompletableFuture<T> toCompletableFuture()`'
- en: 'These methods return a `Executor`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回一个`Executor`：
- en: '`public Executor defaultExecutor()`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Executor defaultExecutor()`'
- en: '`public static Executor delayedExecutor(long delay, Timeunit unit, Executor
    executor)`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Executor delayedExecutor(long delay, Timeunit unit, Executor
    executor)`'
- en: '`public static Executor delayedExecutor(long delay, Timeunit unit)`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Executor delayedExecutor(long delay, Timeunit unit)`'
- en: 'These methods return a `boolean`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回一个`布尔值`：
- en: '`public boolean cancel(boolean mayInterruptIfRunning)`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean cancel(boolean mayInterruptIfRunning)`'
- en: '`public boolean complete(T value)`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean complete(T value)`'
- en: '`public boolean completeExceptionally(Throwable ex)`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean completeExceptionally(Throwable ex)`'
- en: '`public boolean isCancelled()`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean isCancelled()`'
- en: '`public boolean isCompletedExceptionally()`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean isCompletedExceptionally()`'
- en: '`public boolean isDone()`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean isDone()`'
- en: 'No return type:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 没有返回类型：
- en: '`public void obtrudeException(Throwable ex)`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void obtrudeException(Throwable ex)`'
- en: '`public void obtrudeValue(T value)`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void obtrudeValue(T value)`'
- en: 'Additional methods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法：
- en: '`public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException,
    TimeoutException`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException,
    TimeoutException`'
- en: '`public T get() throws InterruptedException, ExecutionException`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public T get() throws InterruptedException, ExecutionException`'
- en: '`public T getNow(T valueIfAbsent)`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public T getNow(T valueIfAbsent)`'
- en: '`public int getNumberOfDependents()`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int getNumberOfDependents()`'
- en: '`public T join()`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public T join()`'
- en: '`public String toString()`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String toString()`'
- en: Enhancements
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强功能：
- en: 'The `CompleteableFuture<T>` class received the following enhancements as part
    of the Java 9 platform:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteableFuture<T>`类作为Java 9平台的一部分获得了以下增强：'
- en: 'Added time-based enhancements:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了基于时间增强：
- en: This enables completions based on lapsed time
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得基于超时的完成成为可能
- en: Delayed executions are now also supported
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在也支持延迟执行
- en: 'Significant enhancement to subclasses:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对子类的重要增强：
- en: Extending `CompletableFuture` is easier
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`CompletableFuture`更加容易
- en: Subclasses support alternative default executors
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类支持替代默认执行器
- en: 'Specifically, the following methods were added in Java 9:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，以下方法是在Java 9中添加的：
- en: '`newIncompleteFuture()`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newIncompleteFuture()`'
- en: '`defaultExecutor()`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultExecutor()`'
- en: '`copy()`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`'
- en: '`minimalCompletionStage()`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimalCompletionStage()`'
- en: '`completeAsync()`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completeAsync()`'
- en: '`orTimeout()`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orTimeout()`'
- en: '`` `completeOnTimeout()` ``'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `completeOnTimeout()` ``'
- en: '`delayedExecutor()`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delayedExecutor()`'
- en: '`completedStage()`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completedStage()`'
- en: '`failedFuture()`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failedFuture()`'
- en: '`failedStage()`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failedStage()`'
- en: Spin-Wait Hints
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自旋等待提示：
- en: With concurrency, we need to ensure that threads waiting to be executed actually
    get executed. The concept of spin-wait is a process that continually checks for
    a true condition. The aim of Java Enhancement Proposal 285 was to create an API
    that permits Java code to issue hints that a spin loop is currently being executed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发中，我们需要确保等待执行的线程实际上被执行。自旋等待的概念是一个不断检查真实条件的过程。Java增强提案285的目的是创建一个API，允许Java代码发出自旋循环正在执行的提示。
- en: 'While this is not a feature that every Java developer will use, it can be useful
    for low-level programming. The hint system simply issues hints--indications, and
    performs no other actions. Justifications for adding these hints include the following
    assumptions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是每个Java开发者都会使用的功能，但它对于底层编程可能很有用。提示系统仅发出提示——指示，并不执行其他操作。添加这些提示的理由包括以下假设：
- en: A spin loop's action time can be improved when using a spin hint
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自旋提示时，自旋循环的动作时间可以得到改善
- en: Use of spin hints will reduce thread-to-thread latency
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自旋提示将减少线程间的延迟
- en: CPU power consumption will be reduced
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU功耗将会降低
- en: Hardware threads will execute faster
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件线程将执行得更快
- en: 'This hint functionality will be contained in a new `onSpinWait()` method as
    part of the `java.lang.Thread` class. Here is an example of implementing the `onSpinWait()`
    method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示功能将被包含在一个新的`onSpinWait()`方法中，作为`java.lang.Thread`类的一部分。以下是一个实现`onSpinWait()`方法的示例：
- en: '[PRE12]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered concurrency enhancements introduced with the Java
    9 platform. We took a deep look at concurrency both as a core Java concept and
    with an eye to what Java 9 is delivering. We also explored the `Flow` class API
    that supports reactive programming, a new concept in Java 9\. In addition, we
    explored concurrency enhancements and the new spin-wait hints introduced in Java
    9.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java 9平台引入的并发增强功能。我们深入探讨了并发，既作为Java的核心概念，也着眼于Java 9所提供的内容。我们还探讨了支持响应式编程的`Flow`类API，这是Java
    9中的新概念。此外，我们还探讨了Java 9中的并发增强和新引入的自旋等待提示。
- en: In the next chapter, we will highlight the security enhancements introduced
    in Java 9 along with practical examples.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将突出介绍Java 9引入的安全增强功能，以及实际示例。
