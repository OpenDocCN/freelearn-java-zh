- en: 18\. Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18. 单元测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter focuses on testing with JUnit, one of the primary testing frameworks
    for Java. In its earliest sections and exercises, you will learn to write a successful
    unit test with JUnit to test your code, using assertions to verify that your code
    is correct. You will then be introduced to parameterized tests—a type of unit
    test which allows you to run the same test on a set of data inputs—which you will
    also learn to write. Finally, the chapter will define mocking, which is the technique
    whereby you will practice how to 'mock out' external dependencies so that you
    can concentrate on testing a single Java class.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用JUnit进行测试，它是Java的主要测试框架之一。在其早期章节和练习中，你将学习如何使用JUnit编写成功的单元测试来测试你的代码，使用断言来验证你的代码是否正确。然后，你将介绍参数化测试——一种允许你在一系列数据输入上运行相同测试的单元测试类型——你也将学习如何编写。最后，本章将定义模拟技术，这是一种练习如何“模拟”外部依赖的技术，这样你就可以专注于测试单个Java类。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Testing allows you to make sure your Java code performs correctly. For example,
    if you were calculating employees' pay, you would want the code to be accurate;
    otherwise, your organization may face legal consequences. While not every programming
    issue leads to legal doom, it is still a good idea to test your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以帮助你确保你的Java代码运行正确。例如，如果你在计算员工的工资，你希望代码是准确的；否则，你的组织可能会面临法律后果。虽然并非每个编程问题都会导致法律灾难，但测试你的代码仍然是一个好主意。
- en: Writing tests while you code, as opposed to when you are done, can speed up
    your work. This is because you won't be spending time trying to figure out why
    things don't seem to work. Instead, you will know exactly what part of the code
    isn't correct. This is especially useful for any code that requires complex logic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时编写测试，而不是在完成时编写，可以加快你的工作速度。这是因为你不会花费时间去试图弄清楚为什么事情似乎不起作用。相反，你会确切地知道代码的哪个部分是不正确的。这对于任何需要复杂逻辑的代码来说特别有用。
- en: In addition to this, as new enhancements are added to the code, you will want
    to make sure that nothing in the new code breaks the old functionality. Having
    a suite of well-written unit tests can really help in this regard. If you are
    a new developer hired into a team that has been working on an application for
    some time, a good suite of tests is a sign that your team follows engineering
    best practices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着代码中添加了新的增强功能，你将想要确保新代码中没有破坏旧功能。一套编写良好的单元测试可以在这一方面真正帮助你。如果你是一名新开发人员，被雇佣到一个已经开发了一段时间的应用程序团队中，一套良好的测试是团队遵循工程最佳实践的标志。
- en: Getting Started with Unit Tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写单元测试
- en: A unit test tests one unit of code. In Java terms, this usually means that a
    unit test tests a single Java class. The test should run quickly, so you know
    whether there are any problems as soon as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试测试一个代码单元。在Java术语中，这通常意味着单元测试测试一个单一的Java类。测试应该运行得很快，这样你就可以尽快知道是否有任何问题。
- en: A unit test is a separate Java class designed just for testing. You should write
    separate test methods for each part of the original class you want to test. Typically,
    the more fine-grained the test, the better.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一个专门用于测试的独立Java类。你应该为原始类中你想测试的每个部分编写单独的测试方法。通常，测试越细粒度，越好。
- en: Sometimes, due to necessity, a unit test will test more than one class. That's
    OK and not something to worry about. In general, though, you want to concentrate
    on writing separate tests for each class in your Java application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于必要性，单元测试可能会测试多个类。这是可以的，不必担心。不过，通常来说，你希望专注于为你的Java应用程序中的每个类编写单独的测试。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Writing your Java classes so that they are easy to test will improve your code.
    You'll have better code organization, clearer code, and better quality as a result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写易于测试的Java类可以提高你的代码质量。这将使你的代码组织更好，代码更清晰，质量更高。
- en: Integration tests, on the other hand, test a part of the entire system, including
    external dependencies. For example, a unit test should not access a database.
    That's the job of integration tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，集成测试测试整个系统的一部分，包括外部依赖。例如，单元测试不应该访问数据库。这是集成测试的工作。
- en: Functional tests go further and test an entire system all in one, such as an
    online banking application or a retail store application. This is sometimes called
    end-to-end testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试更进一步，测试整个系统，例如在线银行应用程序或零售商店应用程序。这有时被称为端到端测试。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Software development job interviews tend to go badly if you say you do not believe
    in writing tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你表示不相信编写测试，软件开发工作面试往往会进行得很糟糕。
- en: Introducing JUnit
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 JUnit
- en: JUnit provides the most widely used test framework for Java code. Now on version
    5, JUnit has been around for years.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 为 Java 代码提供了最广泛使用的测试框架。现在已经是第 5 版，JUnit 已经存在多年。
- en: 'With JUnit, your tests reside in test classes, that is, classes that use JUnit''s
    framework to validate your code. These test classes reside outside of the main
    application code. That''s why both Maven and Gradle projects have two subdirectories
    under the `src` directory: main, for your application code, and test, for the
    tests.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit，你的测试将位于测试类中，即使用 JUnit 框架来验证代码的类。这些测试类位于主应用程序代码之外。这就是为什么 Maven 和 Gradle
    项目在 `src` 目录下都有两个子目录：main，用于你的应用程序代码，test，用于测试。
- en: Typically, tests are not part of your built application. So, if you build a
    JAR file for your application, the tests will not be part of that JAR file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试不是你构建的应用程序的一部分。所以，如果你为你的应用程序构建一个 JAR 文件，测试将不会包含在那个 JAR 文件中。
- en: JUnit has been around for a long time, and you will find the official documentation
    at [https://packt.live/2J9seWE](https://packt.live/2J9seWE) and the official site
    at [https://packt.live/31xFtXu](https://packt.live/31xFtXu).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 已经存在很长时间了，你可以在[https://packt.live/2J9seWE](https://packt.live/2J9seWE)找到官方文档，在[https://packt.live/31xFtXu](https://packt.live/31xFtXu)找到官方网站。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another popular test framework is called Spock. Spock uses the Groovy language,
    which is a JVM language that is similar to Java. You can refer to [https://packt.live/2P4fPqG](https://packt.live/2P4fPqG)
    for more information about Spock. TestNG is another Java unit testing framework.
    You can refer to [https://packt.live/33X2nct](https://packt.live/33X2nct) for
    more information about TestNG.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的测试框架叫做 Spock。Spock 使用 Groovy 语言，这是一种类似于 Java 的 JVM 语言。你可以参考[https://packt.live/2P4fPqG](https://packt.live/2P4fPqG)了解更多关于
    Spock 的信息。TestNG 是另一个 Java 单元测试框架。你可以参考[https://packt.live/33X2nct](https://packt.live/33X2nct)了解更多关于
    TestNG 的信息。
- en: Writing Unit Tests with JUnit
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JUnit 编写单元测试
- en: Oozie is a workflow scheduler for the Hadoop big data clusters. Oozie workflows
    are jobs that perform tasks on potentially massive amounts of data stored in Hadoop
    clusters. Oozie coordinator jobs run workflow jobs on a schedule.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Oozie 是 Hadoop 大数据集群的工作流调度器。Oozie 工作流是在 Hadoop 集群中存储的潜在大量数据上执行任务的作业。Oozie 协调器作业按计划运行工作流作业。
- en: 'When defining a schedule, you typically set three values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义计划时，你通常设置三个值：
- en: The starting timestamp, which defines when the coordinator should start a workflow
    job.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始时间戳，定义协调器何时应该启动工作流作业。
- en: The ending timestamp, which defines when the coordinator should end.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束时间戳，定义协调器何时应该结束。
- en: A frequency, in minutes, at which the coordinator should launch jobs. For example,
    a frequency of 60 specifies launching a workflow job every 60 minutes (that is,
    each hour), from the starting timestamp to the ending timestamp.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调器应该启动作业的频率（以分钟为单位）。例如，60 的频率表示每 60 分钟（即每小时）启动一个工作流作业，从开始时间戳到结束时间戳。
- en: Note
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to [https://packt.live/2BzqlOJ](https://packt.live/2BzqlOJ) for
    more information about Oozie coordinators and even more scheduling options. For
    now, we'll just concentrate on validating the coordinator scheduling information.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以参考[https://packt.live/2BzqlOJ](https://packt.live/2BzqlOJ)了解更多关于 Oozie 协调器和更多调度选项的信息。现在，我们只需集中验证协调器的调度信息。
- en: Here, we're going to define a simple JavaBean class that holds the scheduling
    information and then write a JUnit test to validate a coordinator schedule.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个简单的 JavaBean 类来存储调度信息，然后编写一个 JUnit 测试来验证协调器的调度。
- en: 'The basic bean looks like the following (with the getters, setters, and constructors
    not shown):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基本 Bean 的样子如下（省略了 getters、setters 和构造函数）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The starting and ending timestamps are `String` values based on an assumption
    that this bean would hold data read in from a configuration file. It also allows
    us to validate the `String` format for the timestamps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束时间戳是基于这样一个假设，即这个 Bean 会持有从配置文件中读取的数据的 `String` 值。它还允许我们验证时间戳的 `String`
    格式。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that IntelliJ can generate constructors along with the getter and setter
    methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 IntelliJ 可以生成构造函数以及 getter 和 setter 方法。
- en: Now, consider what you would want to test, along with how you would write those
    tests. Testing edge cases is a good idea.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑你想要测试的内容，以及你将如何编写这些测试。测试边缘情况是一个好主意。
- en: 'For a coordinator, here are the rules:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于协调者，以下是一些规则：
- en: The ending timestamp must be after the starting timestamp.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束时间戳必须晚于开始时间戳。
- en: Both timestamps must be in UTC in the format of `yyyy-MM-ddTHH:mmZ` (this is
    the ISO 8601 format).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个时间戳都必须以 `yyyy-MM-ddTHH:mmZ` 的格式（这是 ISO 8601 格式）在 UTC 中。
- en: The frequency must be less than 1,440 (that is, the number of minutes in a normal
    day). Oozie provides alternative configuration settings to go beyond this limitation.
    For now, we'll just test against this limit.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率必须小于 1,440（即正常一天中的分钟数）。Oozie 提供了超越此限制的替代配置设置。现在，我们只需测试这个限制。
- en: The frequency should be greater than 5 (this is an arbitrary rule designed to
    prevent new workflows starting while another workflow is still running).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率应大于 5（这是一个旨在防止在另一个工作流程仍在运行时启动新工作流程的任意规则）。
- en: To create a test, you create a separate test class. Test classes should have
    a single no-argument constructor. Test classes cannot be abstract classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个测试，你需要创建一个单独的测试类。测试类应该有一个无参数的构造函数。测试类不能是抽象类。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you work with the Maven build tool (refer to *Chapter 6*, *Libraries, Packages,
    and Modules*), then your test classes should all have names that end in `Test`,
    `Tests`, or `TestCase`. All test classes in this chapter have names ending in
    `Test`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Maven 构建工具（参考第 6 章，*库、包和模块*），那么你的测试类应该都以 `Test`、`Tests` 或 `TestCase` 结尾。本章中所有测试类的名称都以
    `Test` 结尾。
- en: 'JUnit uses the `@Test` annotation to identify a test method. You can add a
    `@DisplayName` annotation to specify the text to be displayed should the test
    fail. This can make your test reports easier to read:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 使用 `@Test` 注解来识别测试方法。你可以添加一个 `@DisplayName` 注解来指定在测试失败时显示的文本。这可以使你的测试报告更容易阅读：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside your test methods, use the `Assertions` class methods to validate the
    results:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试方法中，使用 `Assertions` 类的方法来验证结果：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JUnit provides a few other assertion methods, such as `assertEquals()` and `assertAll()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 提供了一些其他断言方法，例如 `assertEquals()` 和 `assertAll()`。
- en: 'Exercise 1: Writing a First Unit Test'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：编写第一个单元测试
- en: 'This example will show the basics of writing a JUnit unit test. For this exercise,
    we will simply test whether the properties are correct; though, typically, you
    would also test program logic:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将展示编写 JUnit 单元测试的基础。对于这个练习，我们将简单地测试属性是否正确；尽管通常，你还会测试程序逻辑：
- en: Select `New` and then `Project…` from the `File` menu in IntelliJ.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 IntelliJ 的 `文件` 菜单中选择 `新建`，然后选择 `项目…`。
- en: Select `Gradle` for the type of project. Click on `Next`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目的类型为 `Gradle`。点击 `下一步`。
- en: For `Group Id`, enter `com.packtpub.testing`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Group Id`，输入 `com.packtpub.testing`。
- en: For `Artifact Id`, enter `chapter18`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Artifact Id`，输入 `chapter18`。
- en: For `Version`, enter `1.0`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `版本`，输入 `1.0`。
- en: Accept the default settings on the next pane. Click on `Next`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受下一页的默认设置。点击 `下一步`。
- en: Leave the project name as `chapter18`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称保留为 `chapter18`。
- en: Click on `Finish`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `完成`。
- en: Call up `build.gradle` in the IntelliJ text editor.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 文本编辑器中调用 `build.gradle`。
- en: 'Change `sourceCompatibility` so that it is set to `12`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sourceCompatibility` 修改为 `12`：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remove the JUnit dependency defined in the `build.gradle` file (it is for an
    older version). Replace that dependency with the following dependencies:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `build.gradle` 文件中删除定义的 JUnit 依赖项（它是为旧版本设计的）。用以下依赖项替换该依赖项：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This brings in JUnit 5 to our project, rather than JUnit 4.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将 JUnit 5 引入到我们的项目中，而不是 JUnit 4。
- en: 'Add the following to `build.gradle` after the dependencies section:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在依赖项部分之后添加以下内容到 `build.gradle`：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This ensures that you use the JUnit 5 test platform for running tests.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了你使用 JUnit 5 测试平台来运行测试。
- en: In the `src/main/java` folder, create a new Java package.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java` 文件夹中，创建一个新的 Java 包。
- en: Enter `com.packtpub.testing` as the package name.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名输入为 `com.packtpub.testing`。
- en: In the `src/test/java` folder, create a new Java package.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/test/java` 文件夹中，创建一个新的 Java 包。
- en: Enter the same name, `com.packtpub.testing`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入相同的名称，`com.packtpub.testing`。
- en: The `src/test/java` folder is where you will place your test classes. The `src/main/java`
    folder is where the application classes are located.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`src/test/java` 文件夹是你放置测试类的地方。`src/main/java` 文件夹是应用程序类所在的位置。'
- en: Right-click on this package in the `src/main/java` folder and create a new Java
    class named `CoordSchedule`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java` 文件夹中右键单击此包，并创建一个名为 `CoordSchedule` 的新 Java 类。
- en: 'Enter two constants that we''ll use to validate the data:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入两个我们将用于验证数据的常量：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Enter the properties of this class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入这个类的属性：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the editor cursor inside the class (that is, between the starting and ending
    curly braces), right-click and choose `Generate…`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编辑光标放在类内部（即起始和结束的大括号之间），右键点击并选择 `Generate…`。
- en: 'Select `Constructor` and then select all three properties. You should see a
    constructor like the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Constructor`，然后选择所有三个属性。您应该看到一个如下所示的构造函数：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, with the editor cursor inside the class (that is, between the starting
    and ending curly braces), right-click and choose `Generate…`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，将编辑光标放在类内部（即起始和结束的大括号之间），右键点击并选择 `Generate…`。
- en: Select `Getter` and `Setter` and then select all three properties. You will
    then see the `get` and `set` methods for each of the three properties.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Getter` 和 `Setter`，然后选择所有三个属性。您将看到三个属性的 `get` 和 `set` 方法。
- en: 'Enter the following method to parse the `String` timestamp value:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法来解析 `String` 时间戳值：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enter the following two utility methods to return the `Date` objects for the
    two timestamps:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下两个实用方法来返回两个时间戳的 `Date` 对象：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These methods allow other code to get the timestamps in date format, rather
    than as a string.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法允许其他代码以日期格式获取时间戳，而不是作为字符串。
- en: We now have the Java class that we are going to test.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在有了将要测试的 Java 类。
- en: The next step is to create a unit test class.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是创建一个单元测试类。
- en: Right-click on this package in the `src/test/java` folder and create a new Java
    class named `CoordScheduleTest`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/test/java` 文件夹中右键点击此包，创建一个名为 `CoordScheduleTest` 的新 Java 类。
- en: 'Enter the following test method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下测试方法：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this test should fail because we use a maximum value of `50` instead
    of the actual requirement, which is a maximum of `1,440`. It is good to see what
    failure will look like first.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个测试应该失败，因为我们使用了 `50` 的最大值而不是实际要求的最大值 `1,440`。首先看到失败的样子是好的。
- en: Click on the `Gradle` pane. Expand `Tasks` and then expand `verification`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Gradle` 面板。展开 `Tasks`，然后展开 `verification`。
- en: 'Double-click on `Test`. This runs the Gradle `test` task. This will show an
    output like the following (with most of the stack trace omitted for clarity):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Test`。这会运行 Gradle 的 `test` 任务。这将显示如下输出（为了清晰起见，省略了大部分堆栈跟踪）：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This isn''t a very nice test report. Luckily, JUnit provides a much nicer report.
    Click on the Gradle elephant icon and the test report will appear in your web
    browser:![Figure 18.1: The IntelliJ Run pane with the Gradle icon shown'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不是一个很好的测试报告。幸运的是，JUnit 提供了一个更好的报告。点击 Gradle 的象形图标，测试报告将在您的网页浏览器中显示：![图 18.1：显示
    Gradle 图标的 IntelliJ 运行面板](img/C13927_18_01.jpg)
- en: '](img/C13927_18_01.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C13927_18_01.jpg](img/C13927_18_01.jpg)'
- en: 'Figure 18.1: The IntelliJ Run pane with the Gradle icon shown'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.1：显示 Gradle 图标的 IntelliJ 运行面板
- en: 'Switch to your web browser and you will see the test report:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您的网页浏览器，您将看到测试报告：
- en: '![Figure 18.2: The test report as displayed in the browser](img/C13927_18_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.2：在浏览器中显示的测试报告](img/C13927_18_02.jpg)'
- en: 'Figure 18.2: The test report as displayed in the browser'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2：在浏览器中显示的测试报告
- en: You will see a list of failed tests with the text from the `DisplayName` annotation.
    For each failed test, you can drill down into the test. This provides a much better
    format with which to display the test results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到失败测试的列表，其中包含 `DisplayName` 注解的文本。对于每个失败的测试，您可以深入测试。这提供了一个更好的格式来显示测试结果。
- en: Next, we'll fix the broken test and validate the other rules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修复损坏的测试并验证其他规则。
- en: 'Exercise 2: Writing a Successful Test'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2：编写成功的测试
- en: 'Now that we have a test that fails, we''ll need to fix the test and add test
    methods to verify the starting and ending timestamps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的测试，我们需要修复测试并添加测试方法来验证开始和结束时间戳：
- en: Edit `CoordScheduleTest` in IntelliJ.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中编辑 `CoordScheduleTest`。
- en: 'Replace the `testFrequency()` method with the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `testFrequency()` 方法替换为以下代码：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a test method to check for an incorrectly formatted date:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试方法来检查格式不正确的日期：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a test method to verify that the ending timestamp is later than the starting
    timestamp:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试方法来验证结束时间戳是否晚于开始时间戳：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Click on the `Gradle` pane. Expand `Tasks` and then expand `verification`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Gradle` 面板。展开 `Tasks`，然后展开 `verification`。
- en: 'Double-click on `Test`. This runs the Gradle `test` task. This will show an
    output like the following (with most of the stack trace omitted for clarity):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Test`。这会运行 Gradle 的 `test` 任务。这将显示如下输出（为了清晰起见，省略了大部分堆栈跟踪）：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the incorrectly formatted timestamp shows an exception stack trace
    (truncated here for length). This was expected (the input timestamp was not correct),
    so it is not an error. These tests should succeed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，格式错误的日期时间戳显示了一个异常堆栈跟踪（此处已截断以节省空间）。这是预期的（输入的日期时间戳不正确），因此这不是错误。这些测试应该成功。
- en: Deciding What to Test
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定要测试什么
- en: You can always write more tests, so, sooner or later, you need to decide on
    what you really do need to test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以编写更多的测试，所以，迟早，你需要决定你真正需要测试什么。
- en: 'It is normally a good idea to focus on:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，专注于以下内容是一个好主意：
- en: What code, if in error, would cause the greatest impact?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码出错，哪种代码会造成最大的影响？
- en: What code is depended on the most by other code? This code should get extra
    tests.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么代码被其他代码依赖最多？这段代码应该得到额外的测试。
- en: Are you checking for edge cases, such as maximum and minimum values?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否正在检查边缘情况，例如最大值和最小值？
- en: In order to simplify writing better tests, and especially to deal with a few
    edge cases, you may want to use parameterized tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化编写更好的测试，特别是为了处理一些边缘情况，你可能想要使用参数化测试。
- en: Writing Parameterized Tests
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写参数化测试
- en: A parameterized test is a unit test that accepts parameters. Instead of all
    the test values being set in the `test` method, you can pass parameters. This
    makes it much easier to test multiple cases. For example, when processing string
    data, you may want to test multiple strings, including null and empty strings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试是一种接受参数的单元测试。你不需要在`test`方法中设置所有测试值，而是可以传递参数。这使得测试多个案例变得容易得多。例如，在处理字符串数据时，你可能想要测试多个字符串，包括null和空字符串。
- en: 'With a parameterized test, you need to specify the parameters you want to pass
    to the test. JUnit will pass these parameters as actual method parameters to your
    test. For example, look at the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化测试，你需要指定要传递给测试的参数。JUnit会将这些参数作为实际方法参数传递给你的测试。例如，看看以下：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, you use a `@ParameterizedTest` annotation instead of `@Test`.
    This tells JUnit to look for the parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用`@ParameterizedTest`注解而不是`@Test`。这告诉JUnit寻找参数。
- en: 'The `@ValueSource` annotation defines two values to get passed to the `test`
    method: `10000` and `11000`. In both cases, this test assumes that the passed-in
    parameters will each result in the `hasMetGoal()` method returning `true`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ValueSource`注解定义了两个值传递给`test`方法：`10000`和`11000`。在这两种情况下，这个测试假设传入的参数将导致`hasMetGoal()`方法返回`true`。'
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Parameterized tests make JUnit much more acceptable to someone who uses Spock.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试使JUnit对使用Spock的人更加可接受。
- en: JUnit will call the `test` method once for each value in the `@ValueSource`
    list, so two times in this example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit将为`@ValueSource`列表中的每个值调用一次`test`方法，所以在这个例子中会调用两次。
- en: The `@ValueSource` annotation expects a list of values to pass to the test method.
    If you have more complex values, you can use the `@CsvSource` annotation instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ValueSource`注解期望一个值列表传递给测试方法。如果你有更复杂的值，可以使用`@CsvSource`注解。'
- en: 'The `@CsvSource` annotation takes a comma-separated set of values. For example,
    look at the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`@CsvSource`注解接受一个以逗号分隔的值集。例如，看看以下：'
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the first call to `testHasMetStepGoal()` will return `10` for
    the `steps` parameter and `false` for the `expected` parameter. Note that JUnit
    converts the types for you. Similar to `@ValueSource`, each data line results
    in a separate call to the `test` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对`testHasMetStepGoal()`的第一个调用将为`steps`参数返回`10`，为`expected`参数返回`false`。请注意，JUnit会为你转换类型。类似于`@ValueSource`，每行数据都会导致对`test`方法的单独调用。
- en: '`@CsvSource` is very handy if you want to pass in a number of values to be
    compared against each other, or in the case here, where you would want to pass
    both good and bad values, along with a parameter that indicates whether the test
    is expected to be `true` or not.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递多个值进行比较，或者在这个例子中，你想要传递好值和坏值，以及一个参数来指示测试是否预期为`true`，那么`@CsvSource`非常有用。
- en: 'Because the values within `@CsvSource` are stored as strings, you need some
    special syntax to handle empty strings, null strings, and strings with spaces:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`@CsvSource`中的值存储为字符串，所以你需要一些特殊的语法来处理空字符串、null字符串和包含空格的字符串：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line has a string with spaces. Use single quote characters (`'`) to
    delimit strings with spaces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行有一个包含空格的字符串。使用单引号字符（`'`）来界定包含空格的字符串。
- en: The third line has just a comma for the first parameter. JUnit will pass `null`
    for this construct.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行只有一个逗号作为第一个参数。JUnit将为这个构造传递`null`。
- en: The fourth line has two single quotes used to generate an empty string.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行使用了两个单引号来生成一个空字符串。
- en: In addition to `@CsvSource`, you can load the data from an external comma-separated
    value (CSV) file using the `@CsvFileSource` annotation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `@CsvSource`，你还可以使用 `@CsvFileSource` 注解从外部逗号分隔值（CSV）文件加载数据。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JUnit supports a few other ways to get the parameter values, including from
    a separate file, from a method you write, and more. You can refer to [https://packt.live/2J8oXGU](https://packt.live/2J8oXGU)
    for more information about parameterized tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 支持几种获取参数值的方法，包括从单独的文件、从你编写的方法中获取，等等。你可以参考 [https://packt.live/2J8oXGU](https://packt.live/2J8oXGU)
    获取有关参数化测试的更多信息。
- en: 'Exercise 3: Writing a Parameterized Test'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3：编写参数化测试
- en: Let's assume that you are writing code that accesses a wearable fitness device.
    One of the things the device tracks is the number of steps the wearer takes on
    a given day. You can then compare the number of steps taken against a daily goal.
    Has the wearer met this goal?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写访问可穿戴健身设备的代码。设备跟踪的一件事是佩戴者在某一天所走的步数。然后你可以将所走的步数与每日目标进行比较。佩戴者是否达到了这个目标？
- en: 'This example demonstrates how to write a parameterized test, based on the daily
    step goal from *Chapter 6*, *Libraries, Packages, and Modules*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本例演示了如何根据第6章中*库、包和模块*的每日步数目标编写参数化测试：
- en: Edit `build.gradle`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `build.gradle` 文件。
- en: 'Add the following to the dependencies block:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到依赖项块中：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This dependency brings in support for the parameterized tests.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个依赖项引入了对参数化测试的支持。
- en: Right-click on the `com.packtpub.testing` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java` 文件夹中的 `com.packtpub.testing` 包上右键单击。选择 `New` 和 `Java Class`。
- en: Enter `DailyGoal` as the class name.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DailyGoal` 作为类名。
- en: 'Enter the following code for this class:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此类输入以下代码：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the class we will test.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们将要测试的类。
- en: Right-click on the `com.packtpub.testing` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/test/java` 文件夹中的 `com.packtpub.testing` 包上右键单击。选择 `New` 和 `Java Class`。
- en: Enter `DailyGoalTest` as the class name.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DailyGoalTest` 作为类名。
- en: 'Enter the following constant for the device wearer''s daily step goal:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为设备佩戴者的每日步数目标输入以下常量：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, enter a `test` method for step counts that meet or exceed the daily goal:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入一个用于满足或超过每日步数目标的 `test` 方法：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With a daily step goal of `10000` steps, `10000` and `11000` both meet this
    goal.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每日步数目标为 `10000` 步时，`10000` 和 `11000` 都达到了这个目标。
- en: 'Next, we''ll test the result when the step count is lower than the daily step
    goal:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试步数低于每日步数目标的结果：
- en: '[PRE24]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how `9999` is just one step below the goal.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `9999` 只比目标少一步。
- en: 'Next, enter a test method using the `@CsvSource` values for the test parameters:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，使用 `@CsvSource` 的测试参数值输入一个测试方法：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This test method is a bit more complicated. Each call to the test passes two
    parameters.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个测试方法稍微复杂一些。每次调用测试都会传递两个参数。
- en: The lambda expression in the call to `Assertions.assertTrue()` is the error
    message. Using a lambda expression means that the error message won't get evaluated
    unless the test assertion fails.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Assertions.assertTrue()` 调用中的 lambda 表达式是错误消息。使用 lambda 表达式意味着错误消息只有在测试断言失败时才会被评估。
- en: When you run this test class, it should succeed.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行这个测试类时，它应该成功。
- en: When Tests Won't Work—Disabling Tests
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当测试无法工作——禁用测试
- en: 'The `@Disabled` annotation allows you to disable a test. Normally, it is not
    good practice to simply disable any test that fails. This defeats the whole idea
    of testing. However, you may come across times where, due to some condition outside
    of your control, you just must disable tests. For example, if you are using the
    code from another group, and that group has broken an expectation or introduced
    a bug in its code, you may need to—temporarily—disable tests that depend on that
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Disabled` 注解允许你禁用测试。通常，简单地禁用任何失败的测试并不是一个好的实践。这违背了测试的整个目的。然而，你可能遇到由于一些你无法控制的条件，你不得不禁用测试的情况。例如，如果你正在使用另一个组的代码，并且该组在其代码中破坏了一个期望或引入了一个错误，你可能需要——暂时——禁用依赖于该代码的测试：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can add the `@Disabled` annotation to an entire test class, or just to a
    test method, as shown in the preceding code block.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `@Disabled` 注解添加到整个测试类，或者只添加到测试方法，如前面的代码块所示。
- en: Test Setup
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试设置
- en: In many tests, you may need to perform some setup work, as well as cleanup work
    after the test. For example, you may want to initialize the objects that are needed
    for the test. JUnit provides a number of life cycle annotations to support such
    work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多测试中，你可能需要执行一些设置工作，以及测试后的清理工作。例如，你可能需要初始化测试所需的对象。JUnit提供了一系列生命周期注解来支持此类工作。
- en: If you annotate a method with `@BeforeEach`, JUnit will run that method before
    running each test method. Similarly, methods annotated with `@AfterEach` are run
    after each test method. If you want to run the setup or clean up the code just
    once for a test class, you can use `@BeforeAll` and `@AfterAll`. These two methods
    come with some restrictions, though.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用`@BeforeEach`注解一个方法，JUnit将在运行每个测试方法之前运行该方法。同样，用`@AfterEach`注解的方法将在每个测试方法之后运行。如果你想为测试类只运行一次设置或清理代码，可以使用`@BeforeAll`和`@AfterAll`。尽管这两个方法有一些限制。
- en: JUnit creates a new instance of your test class for each test method. This ensures
    your tests run in isolation and avoid what is called test pollution, where one
    test impacts another test. Normally, this is a good thing, because tracking down
    test failures that depend on the order of the test execution is particularly frustrating.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit为每个测试方法创建你的测试类的新实例。这确保了你的测试在隔离状态下运行，避免了所谓的测试污染，即一个测试影响另一个测试。通常，这是好事，因为追踪依赖于测试执行顺序的测试失败尤其令人沮丧。
- en: Because JUnit creates a new instance of the test class for each test method,
    the `@BeforeAll` and `@AfterAll` methods must be `static`. Additionally, the data
    that these methods initialize or clean up should also be `static`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JUnit为每个测试方法创建测试类的新实例，所以`@BeforeAll`和`@AfterAll`方法必须是`static`。此外，这些方法初始化或清理的数据也应该是`static`。
- en: If you don't want to create `static` methods, you can change JUnit's policy
    of creating a new instance of the test class for each test method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想创建`static`方法，你可以更改JUnit为每个测试方法创建测试类新实例的策略。
- en: 'If you annotate your test class with the following, JUnit will create just
    one instance of the test class shared by all the test methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用以下内容注解你的测试类，JUnit将为所有测试方法创建一个共享的测试类实例：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You'll see an example of this in the *Mocking* section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*Mocking*部分看到一个例子。
- en: '*Exercise 4*, *Using Test Setup and Cleanup Methods* demonstrates how to code
    these setup and cleanup methods.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习4*，*使用测试设置和清理方法*演示了如何编写这些设置和清理方法。'
- en: 'Exercise 4: Using Test Setup and Cleanup Methods'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4：使用测试设置和清理方法
- en: 'This exercise demonstrates a simple unit test with placeholder methods for
    both setting up and cleaning up. The test will verify a simple class that converts
    Celsius temperature values to Fahrenheit:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习演示了一个简单的单元测试，其中包含用于设置和清理的占位符方法。该测试将验证一个简单的类，该类将摄氏温度值转换为华氏温度：
- en: Right-click on the `com.packtpub.testing` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`src/main/java`文件夹中的`com.packtpub.testing`包。选择`New`然后`Java Class`。
- en: Enter `TempConverter` as the class name.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名输入为`TempConverter`。
- en: 'Enter the following method:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法：
- en: '[PRE28]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Right-click on the `com.packtpub.testing` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`src/test/java`文件夹中的`com.packtpub.testing`包。选择`New`然后`Java Class`。
- en: Enter `TempConverterTest` as the class name.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名输入为`TempConverterTest`。
- en: 'Enter the following test method that checks for `-40.0` degrees on both temperature
    scales:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下测试方法，检查两种温度尺度上的`-40.0`度：
- en: '[PRE29]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This temperature is unpleasant regardless of the temperature scale used.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论使用哪种温度尺度，这种温度都是令人不愉快的。
- en: Notice how this test uses the `assertEquals()` assertion.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个测试是如何使用`assertEquals()`断言的。
- en: 'Enter another test method to ensure the conversion works when the temperature
    is `100.0` degrees Celsius:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入另一个测试方法以确保当温度为`100.0`摄氏度时转换工作正常：
- en: '[PRE30]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, enter a method to be run before all the tests:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入在每个测试之前运行的测试方法：
- en: '[PRE31]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that this method must be static (or you must use the class-level annotation
    listed previously).
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此方法必须是静态的（或者你必须使用前面列出的类级别注解）。
- en: Normally, you would use this method to set up complex test data instead of just
    printing a value.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，你会使用此方法来设置复杂的测试数据，而不仅仅是打印一个值。
- en: 'Enter a method to be run after all the tests:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个在每个测试之后运行的测试方法：
- en: '[PRE32]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, this method must be static.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，此方法必须是静态的。
- en: 'Now, enter a method to be run before each of the two test methods:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入在每个两个测试方法之前运行的测试方法：
- en: '[PRE33]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, enter a method to be run after each test method:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，输入一个在每个测试方法之后运行的测试方法：
- en: '[PRE34]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Click on the green arrow by the class statement and select `Run 'TempConverterTest'`.
    The test should run without errors.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击类语句旁边的绿色箭头，并选择“运行'TempConverterTest'”。测试应该无错误运行。
- en: 'You will see an output like the following:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下类似的输出：
- en: '[PRE35]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the `@BeforeAll` method is only run once. Then, with each test method,
    the `@BeforeEach` and `@AfterEach` methods are executed. Finally, the `@AfterAll`
    method is executed.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`@BeforeAll`方法只运行一次。然后，对于每个测试方法，执行`@BeforeEach`和`@AfterEach`方法。最后，执行`@AfterAll`方法。
- en: Mocking
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: A unit test is supposed to test just one Java class. There are times, however,
    where a class is heavily dependent on other classes, and perhaps even external
    systems such as databases or handheld devices. In these cases, a technique called
    mocking proves useful. Mocking is where you mock out the other dependencies so
    that you can test just the class you want to look at.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该只测试一个Java类。然而，有时一个类高度依赖于其他类，甚至可能依赖于外部系统，如数据库或手持设备。在这些情况下，一种称为模拟的技术非常有用。模拟就是模拟其他依赖项，以便您可以测试您想要查看的类。
- en: A **mock** is a class used just for testing that pretends to be some external
    dependency. With a mocking framework, you can examine a mocked class to ensure
    that the right methods were called the right number of times with the right parameters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**是一个仅用于测试的类，它假装是某些外部依赖。使用模拟框架，您可以检查模拟类以确保正确的方法以正确的次数和参数被调用。'
- en: Mocking works great when you have code that queries for data in a database or
    external system. What you do is create an instance that is a mock for a particular
    class. Then, when the query method gets called, you have the mock return arbitrary
    test data. This avoids the dependency on the external system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有代码在数据库或外部系统中查询数据时，模拟效果很好。您所做的是创建一个特定类的模拟实例。然后，当查询方法被调用时，模拟返回任意测试数据。这避免了对外部系统的依赖。
- en: Mocking also works great when you want to verify that a particular method was
    called, without actually calling that method. Think of an email notifier that
    sends email messages on some kind of failure. In a unit test, you don't want actual
    email messages to get sent. (In an integration or functional test, however, you
    should verify that the messages do get sent.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在您想验证特定方法被调用，而实际上并没有调用该方法时也效果很好。想象一下一个在某种失败情况下发送电子邮件消息的电子邮件通知器。在单元测试中，您不希望实际发送电子邮件消息。（然而，在集成或功能测试中，您应该验证消息确实被发送。）
- en: Testing with Mocks Using Mockito
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mockito进行模拟测试
- en: Mockito is a great framework for adding mocks to your testing. Say that you
    have an application that monitors workflows running in a big data cluster; these
    could be Oozie workflows mentioned previously, or any other type of workflows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito是一个用于向测试添加模拟的出色框架。假设您有一个监控在大数据集群中运行的工作流程的应用程序；这些可能是之前提到的Oozie工作流程，或者任何其他类型的工作流程。
- en: Your application gets the status of the workflows by calling a remote web service.
    In your unit tests, you don't want to call the remote web service. Instead, you
    just want to mock out the external system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序通过调用远程Web服务来获取工作流程的状态。在您的单元测试中，您不想调用远程Web服务。相反，您只想模拟外部系统。
- en: 'The code we want to test will look something like the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试的代码可能看起来像以下这样：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, the code calls a remote web service to get the status of a workflow,
    based on the workflow ID. Then, if the workflow status is not OK, the code sends
    an email message. For unit tests, we need to mock both the call to `getStatus()`
    and the call to `sendFailureEmail()`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码调用远程Web服务以获取工作流程的状态，基于工作流程ID。然后，如果工作流程状态不是OK，代码发送电子邮件消息。对于单元测试，我们需要模拟对`getStatus()`和`sendFailureEmail()`的调用。
- en: The `WorkflowClient` class manages the HTTP communication to the remote web
    service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkflowClient`类管理对远程Web服务的HTTP通信。'
- en: 'A call to the `getStatus()` method with a workflow ID returns the status of
    that given workflow:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作流程ID调用`getStatus()`方法返回给定工作流程的状态：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to *Chapter 9*, *Working with HTTP*, for more information about
    HTTP and web services.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考*第9章*，*与HTTP协作*，以获取更多关于HTTP和Web服务的相关信息。
- en: 'With Mockito, the first thing you need to do is to create a mock of the `WorkflowClient`
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mockito，您需要做的第一件事是创建`WorkflowClient`类的模拟：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to stub out the call to `getStatus()`. In Mockito terminology,
    when something happens, then a particular result is returned. In this case, the
    stubbed code should return a prebuilt `WorkflowStatus` object with the desired
    status of a test:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是模拟对`getStatus()`的调用。在Mockito术语中，当发生某事时，将返回特定的结果。在这种情况下，模拟的代码应该返回一个预先构建的、具有所需测试状态的`WorkflowStatus`对象。
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this code, we first set up a string of the workflow ID and then construct
    a `WorkflowStatus` object with a successful status (`OK`). The crucial code starts
    with `when()`. Read this code when the `getStatus` call is made with the given
    ID on the mock `WorkflowClient` class, and then return our prebuilt `WorkflowStatus`
    object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先设置一个工作流程ID的字符串，然后使用成功状态（`OK`）构造一个`WorkflowStatus`对象。关键代码从`when()`开始。当在模拟的`WorkflowClient`类上使用给定ID调用`getStatus`时，请阅读此代码，然后返回我们预先构建的`WorkflowStatus`对象。
- en: 'In this case, Mockito is looking for an exact match. The passed-in workflow
    ID must match, or the mock will not return the specified result. You can also
    specify that the mock should return the result with any input workflow ID, as
    shown in the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Mockito正在寻找一个精确匹配。传入的工作流程ID必须匹配，否则模拟将不会返回指定的结果。你还可以指定模拟应该返回任何输入工作流程ID的结果，如下所示：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, the `anyString()` call means any string value passed in will match.
    Note that Mockito has other calls, such as `anyInt()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`anyString()`调用意味着任何传入的字符串值都会匹配。请注意，Mockito还有其他调用，例如`anyInt()`。
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Mockito includes very good documentation at [https://packt.live/2P6ogl9](https://packt.live/31xFtXu).
    You can do a lot more with mocks than the examples shown here, but you should
    avoid the temptation to mock everything.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito在[https://packt.live/2P6ogl9](https://packt.live/31xFtXu)提供了非常好的文档。你可以使用模拟做比这里展示的更多的事情，但你应该避免模拟一切的诱惑。
- en: 'With the call to the external web service mocked out, the next step is to check
    whether a failure email gets sent. To do this, mock the class that sends email
    failure messages:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟外部Web服务调用之后，下一步是检查是否发送了失败电子邮件。为此，模拟发送电子邮件失败消息的类：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the code we want to test, the email message is sent only on failures. So,
    we will want to test two things:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要测试的代码中，只有在失败时才会发送电子邮件消息。因此，我们将想要测试以下两点：
- en: The email is not sent if the status is OK.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态是OK，则不会发送电子邮件。
- en: The email is sent if the status is *not* OK.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态不是OK，则会发送电子邮件。
- en: In both cases, we will use Mockito to check the number of times the `sendFailureEmail()`
    method gets called. If it is zero times, then no email is sent. If it is one or
    more times, then an email message is sent.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们将使用Mockito来检查`sendFailureEmail()`方法被调用的次数。如果为零次，则不会发送电子邮件。如果是一次或更多次，则发送电子邮件消息。
- en: 'To ensure that no email message was sent, use code like the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保没有发送电子邮件消息，请使用以下代码：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code checks that the `sendFailureEmail()` method was called zero times,
    that is, not called at all.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查`sendFailureEmail()`方法没有被调用零次，即完全没有被调用。
- en: 'To verify that the email message was sent, you can specify the number of times
    as `1`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证是否发送了电子邮件消息，你可以指定次数为`1`：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also use Mockito''s shortcut, which assumes the method gets called
    just once:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Mockito的快捷方式，它假设该方法只被调用一次：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In more complex tests, you may want to ensure a method gets called a few times.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的测试中，你可能想要确保一个方法被调用几次。
- en: As mentioned previously, JUnit creates a new instance of your test class for
    each test method. When mocking, you may want to set up the mocks once, instead
    of every time a test method runs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JUnit为每个测试方法创建你的测试类的新实例。在模拟时，你可能想要在测试方法运行时只设置一次模拟。
- en: 'To tell JUnit to create just one instance of the test class and share it among
    all test methods, add the following annotation to the class:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要让JUnit只为测试类创建一个实例并在所有测试方法之间共享它，请将以下注解添加到类中：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `setUpMocks()` method will get called once before all the test methods run.
    It sets up the two mock classes and then passes the mock objects to the constructor
    for the `WorkflowMonitor` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpMocks()`方法将在所有测试方法运行之前被调用一次。它设置了两个模拟类，然后将模拟对象传递给`WorkflowMonitor`类的构造函数。'
- en: The following exercise shows all these classes together, using Mockito-based
    mocks in the unit test.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习展示了所有这些类一起使用，在单元测试中使用基于Mockito的模拟。
- en: 'Exercise 5: Using Mocks when Testing'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5：在测试时使用模拟
- en: 'This exercise creates a `WorkflowMonitor` class and then uses mock objects
    to handle external dependencies:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习创建了一个`WorkflowMonitor`类，然后使用模拟对象来处理外部依赖：
- en: In the `src/main/java` folder in the IntelliJ `Project` pane, create a new Java
    package.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ的`项目`面板中的`src/main/java`文件夹中创建一个新的Java包。
- en: Enter `com.packtpub.workflow` as the package name.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入包名`com.packtpub.workflow`。
- en: In the `src/test/java` folder, create a new Java package.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/test/java`文件夹中创建一个新的Java包。
- en: Enter the same name, `com.packtpub.workflow`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入相同的名称，`com.packtpub.workflow`。
- en: Edit `build.gradle`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.gradle`。
- en: 'Add the following to the dependencies block:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在依赖项块中添加以下内容：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java`文件夹中的`com.packtpub.workflow`包上右键单击。选择`新建`然后选择`Java类`。
- en: Enter `WorkflowStatus` as the class name.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`WorkflowStatus`。
- en: 'Enter the following code for this simple value object class:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此简单值对象类输入以下代码：
- en: '[PRE47]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a real system, this class would hold additional values, such as when the
    workflow started, when it stopped, and other information on the workflow. The
    status information was simplified for this exercise.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际系统中，这个类将包含额外的值，例如工作流程开始的时间、停止的时间以及其他关于工作流程的信息。为了这个练习，状态信息被简化了。
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java`文件夹中的`com.packtpub.workflow`包上右键单击。选择`新建`然后选择`Java类`。
- en: Enter `EmailNotifier` as the class name.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`EmailNotifier`。
- en: 'Enter the following method:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法：
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In a real application, this would send email messages. For simplicity, we'll
    leave that blank.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际应用中，这将发送电子邮件消息。为了简单起见，我们将留空。
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java`文件夹中的`com.packtpub.workflow`包上右键单击。选择`新建`然后选择`Java类`。
- en: Enter `WorkflowClient` as the class name.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`WorkflowClient`。
- en: 'Enter the following method:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法：
- en: '[PRE49]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, this is simplified.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，这也是简化的。
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java`文件夹中的`com.packtpub.workflow`包上右键单击。选择`新建`然后选择`Java类`。
- en: Enter `WorkflowMonitor` as the class name.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`WorkflowMonitor`。
- en: 'Enter the following properties:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下属性：
- en: '[PRE50]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Right-click on the class, choose `Generate…` and then choose `Constructor`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类上右键单击，选择`生成…`然后选择`构造函数`。
- en: Select both properties and then click on `OK`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个属性，然后点击`确定`。
- en: 'Enter the following method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法：
- en: '[PRE51]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the method we will test using mock objects.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们将使用模拟对象进行测试的方法。
- en: Right-click on the `com.packtpub.workflow` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/test/java`文件夹中的`com.packtpub.workflow`包上右键单击。选择`新建`然后选择`Java类`。
- en: Enter `WorkflowMonitorTest` as the class name.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`WorkflowMonitorTest`。
- en: 'Annotate the class so that we can create a `@BeforeAll` method:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释该类，以便我们可以创建一个`@BeforeAll`方法：
- en: '[PRE52]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Enter the following properties and set up the `@BeforeAll` method:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下属性并设置`@BeforeAll`方法：
- en: '[PRE53]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This sets up the mock objects and then instantiates a `WorkflowMonitor` object
    using the mocked dependencies.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这设置了模拟对象，然后使用模拟的依赖项实例化一个`WorkflowMonitor`对象。
- en: 'Enter the following test method to test a case when the workflow is successful:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下测试方法以测试工作流程成功的情况：
- en: '[PRE54]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We should also test a case where the workflow status is not OK.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还应该测试一个工作流程状态不是OK的情况。
- en: 'Enter the following test method:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下测试方法：
- en: '[PRE55]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Click on the green arrow by the class statement and select `Run 'WorkflowMonitorTest'`.
    The test should run without errors.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击类声明旁边的绿色箭头，选择`运行 'WorkflowMonitorTest'`。测试应该没有错误运行。
- en: 'Activity 1: Counting the Words in the String'
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：计算字符串中的单词
- en: Word count is of paramount value in the publishing industry. Write a class that,
    given a string, will count all the words in the string.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 单词计数在出版行业中至关重要。编写一个类，给定一个字符串，将计算字符串中的所有单词。
- en: You can use the `split()` method to break up the string into words, using the
    `\s+` regular expression to separate the words, which matches whitespace characters(that
    is, spaces and tabs). Name this class `WordCount`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`split()`方法将字符串拆分为单词，使用`\s+`正则表达式来分隔单词，这匹配空白字符（即空格和制表符）。将此类命名为`WordCount`。
- en: Trim the input string to remove any spaces at the beginning or end.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除输入字符串开头或结尾的任何空格。
- en: Note that an empty string should generate zero for the word count; so should
    a `null` string. Input strings that are all spaces should generate zero as well.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，空字符串应该生成单词计数为零；同样，`null`字符串也应该生成零。全部为空格的输入字符串也应该生成零。
- en: Once you have the class written, write a parameterized unit test for that class.
    Use the parameters and `@CsvSource` to pass in a string along with the expected
    word count. Be sure to include punctuation such as commas and periods in your
    input strings. In addition to this, be sure to include input strings with null
    strings and empty strings in the input parameters.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你写好了类，就为该类编写一个参数化单元测试。使用参数和`@CsvSource`传递一个字符串以及预期的单词数。确保在你的输入字符串中包含标点符号，如逗号和句号。此外，确保在输入参数中包含包含空字符串和空字符串的输入字符串。
- en: Note
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 569.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 569 页找到。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced unit testing. Testing is good and you want to write
    tests for all your Java code. If you write successful tests, then you can feel
    confident your code was written correctly.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了单元测试。测试是好的，你希望为所有的 Java 代码编写测试。如果你编写了成功的测试，那么你可以有信心你的代码是正确编写的。
- en: JUnit provides the most popular testing framework for writing Java unit tests,
    though there are other frameworks you can try as well. The `@Test` annotation
    on a method tells JUnit that the given code is considered a test. JUnit will execute
    the test and see whether it succeeds. The JUnit assertions class contains a few
    `static` methods that you can use to verify the test results.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 提供了编写 Java 单元测试最流行的测试框架，尽管你也可以尝试其他框架。方法上的`@Test`注解告诉 JUnit 给定的代码被视为一个测试。JUnit
    将执行测试并查看它是否成功。JUnit 断言类包含一些你可以用来验证测试结果的`static`方法。
- en: A parameterized test is a test into which you pass a few parameters. This is
    very useful when writing tests for code that you want to ensure can handle a variety
    of inputs. Mocking is a technique where you mock out external dependencies so
    that a unit test can concentrate on testing just one class.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试是一种测试，你向其中传递一些参数。当你需要为想要确保能够处理各种输入的代码编写测试时，这非常有用。模拟是一种技术，通过模拟外部依赖，使得单元测试可以专注于测试单个类。
