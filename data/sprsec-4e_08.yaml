- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Client Certificate Authentication with TLS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TLS的客户端证书认证
- en: Although username and password authentication are extremely common, as we discussed
    in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of an Unsafe Application*,
    and in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with
    Spring Security*, forms of authentication exist that allow users to present different
    types of credentials. Spring Security caters to these requirements as well. In
    this chapter, we’ll move beyond form-based authentication to explore authentication
    using trusted client-side certificates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户名和密码认证非常常见，正如我们在[*第一章*](B21757_01.xhtml#_idTextAnchor015)，*不安全应用程序的解剖*和[*第二章*](B21757_02.xhtml#_idTextAnchor043)，*Spring
    Security入门*中讨论的那样，存在其他认证形式，允许用户展示不同类型的凭证。Spring Security也满足这些需求。在本章中，我们将超越基于表单的认证，探索使用可信客户端证书进行认证。
- en: 'During the course of this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论过程中，我们将涵盖以下主题：
- en: Learning how client certificate authentication is negotiated between the user’s
    browser and a compliant server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习客户端证书认证如何在用户的浏览器和符合规定的服务器之间协商
- en: Configuring Spring Security to authenticate users with client certificates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以使用客户端证书进行用户认证
- en: Understanding the architecture of client certificate authentication in Spring
    Security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Spring Security中客户端证书认证的架构
- en: Exploring advanced configuration options related to client certificate authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索与客户端证书认证相关的高级配置选项
- en: Reviewing pros, cons, and common troubleshooting steps when dealing with client
    certificate authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查处理客户端证书认证时的优缺点和常见故障排除步骤
- en: 'This chapter’s code in action link is here: [https://packt.link/XgAQ7](https://packt.link/XgAQ7).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例链接在此：[https://packt.link/XgAQ7](https://packt.link/XgAQ7)。
- en: How does client certificate authentication work?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端证书认证是如何工作的？
- en: Client certificate authentication requires a request for information from the
    server and a response from the browser to negotiate a trusted authentication relationship
    between the client (that is, a user’s browser) and the server application. This
    trusted relationship is built through the use of the exchange of trusted and verifiable
    credentials, known as **certificates**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证需要服务器请求信息以及浏览器响应来协商客户端（即用户的浏览器）与服务器应用之间的可信认证关系。这种可信关系是通过使用交换的可信和可验证的凭证，即所谓的**证书**来建立的。
- en: Unlike much of what we have seen up to this point, with client certificate authentication,
    the Servlet container or application server itself is typically responsible for
    negotiating the trust relationship between the browser and server by requesting
    a certificate, evaluating it, and accepting it as valid.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止看到的大部分内容不同，在客户端证书认证中，Servlet容器或应用程序服务器本身通常负责通过请求证书、评估它并接受其为有效来协商浏览器与服务器之间的信任关系。
- en: Client certificate authentication is also known as **mutual authentication**
    and is part of the **Secure Sockets Layer** (**SSL**) protocol and its successor,
    **Transport Layer Security** (**TLS**). As mutual authentication is part of the
    SSL and TLS protocols, it follows that an HTTPS connection (secured with SSL or
    TLS) is required in order to make use of client certificate authentication. For
    more details on SSL/TLS support in Spring Security, please refer to the *Generating
    a server certificate* section in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*. Setting up SSL/TLS is required to implement client
    certificate authentication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证也称为**相互认证**，是**安全套接字层**（**SSL**）协议及其继任者**传输层安全性**（**TLS**）的一部分。由于相互认证是SSL和TLS协议的一部分，因此使用客户端证书认证需要HTTPS连接（由SSL或TLS加密）来使用。有关Spring
    Security中SSL/TLS支持的更多详细信息，请参阅[*附录*](B21757_20.xhtml#_idTextAnchor642)中的*生成服务器证书*部分，*附加参考资料*。设置SSL/TLS是实施客户端证书认证所必需的。
- en: 'The following sequence diagram illustrates the interaction between the client
    browser and the web server when negotiating an SSL connection and validating the
    trust of a client certificate used for mutual authentication:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的序列图展示了客户端浏览器与Web服务器在协商SSL连接并验证用于相互认证的客户端证书的可信度时的交互：
- en: '![Figure 8.1 – Client certificate authentication](img/B21757_08_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 客户端证书认证](img/B21757_08_1.jpg)'
- en: Figure 8.1 – Client certificate authentication
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 客户端证书认证
- en: 'We can see that the exchange of two certificates, the server and client certificates,
    provides the authentication that both parties are known and can be trusted to
    continue their conversation securely. In the interest of clarity, we omit some
    details of the SSL handshake and trust the checking of the certificates themselves;
    however, you are encouraged to do further reading in the area of the SSL and TLS
    protocols, and certificates in general, as many good reference guides on these
    subjects exist. *RFC 8446*, *The Transport Layer Security (TLS) Protocol Version
    1.3* ([https://datatracker.ietf.org/doc/html/rfc8446](https://datatracker.ietf.org/doc/html/rfc8446)),
    is a good place to begin reading about client certificate presentation, and if
    you’d like to get into more detail, *SL and TLS: Designing and Building Secure
    Systems, Eric Rescorla, Addison-Wesley* ([https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983))
    has an incredibly detailed review of the protocol and its implementation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，交换两个证书，即服务器证书和客户端证书，提供了双方都已知并且可以信任继续安全对话的认证。为了清晰起见，我们省略了一些SSL握手的细节，并信任证书本身的检查；然而，我们鼓励您进一步阅读SSL和TLS协议以及证书的一般知识，因为关于这些主题存在许多优秀的参考指南。*RFC
    8446*，*传输层安全性（TLS）协议版本1.3* ([https://datatracker.ietf.org/doc/html/rfc8446](https://datatracker.ietf.org/doc/html/rfc8446))），是开始阅读客户端证书展示的好地方，如果您想深入了解，*SL和TLS：设计并构建安全系统，埃里克·雷斯科拉，Addison-Wesley*
    ([https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983))对协议及其实现有非常详细的回顾。
- en: An alternative name for client certificate-based authentication is **X.509 authentication**.
    The term X.509 is derived from the X.509 standard, originally published by the
    **International Telecommunication Union Telecommunication** (**ITU-T**) organization
    for use in directories based on the X.500 standard (the origins of **Lightweight
    Directory Access Protocol** (**LDAP**), as you may recall from [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180),
    *LDAP Directory Services*). Later, this standard was adapted for use in securing
    internet communications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于客户端证书认证的另一种名称是**X.509认证**。术语X.509来源于X.509标准，最初由**国际电信联盟电信**（**ITU-T**）组织发布，用于基于X.500标准（如您可能从[*第6章*](B21757_06.xhtml#_idTextAnchor180)，*LDAP目录服务*）的目录。后来，这个标准被修改用于确保互联网通信的安全。
- en: We mention this here because many of the classes in Spring Security related
    to this subject refer to X.509\. Remember that X.509 doesn’t define the mutual
    authentication protocol itself, but defines the format and structure of the certificates
    and the encompassing trusted certificate authorities instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到这一点，因为Spring Security中与这个主题相关的许多类都引用了X.509。请记住，X.509本身并不定义相互认证协议，而是定义了证书的格式和结构以及包含的受信任证书颁发机构。
- en: Setting up the client certificate authentication infrastructure
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置客户端证书认证基础设施
- en: Unfortunately for you as an individual developer, being able to experiment with
    client certificate authentication requires some non-trivial configuration and
    setup prior to the relatively easy integration with Spring Security. As these
    setup steps tend to cause a lot of problems for first-time developers, we feel
    it is important to walk you through them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你作为一个个人开发者来说，能够实验客户端证书认证需要在相对容易的与Spring Security集成之前进行一些非平凡的配置和设置。由于这些设置步骤往往会给初学者带来很多问题，我们认为向您介绍这些步骤非常重要。
- en: We assume that you are using a local, self-signed server certificate, self-signed
    client certificates, and Apache Tomcat. This is typical of most development environments;
    however, it’s possible that you may have access to a valid server certificate,
    a **certificate authority** (**CA**), or another application server. If this is
    the case, you may use these setup instructions as guidelines and configure your
    environment in an analogous manner. Please refer to the SSL setup instructions
    in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*,
    for assistance in configuring Tomcat and Spring Security to work with SSL in a
    standalone environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你正在使用本地自签名的服务器证书、自签名客户端证书和Apache Tomcat。这在大多数开发环境中很典型；然而，你可能有权访问有效的服务器证书、**证书颁发机构**（**CA**）或另一个应用程序服务器。如果是这种情况，你可以将这些设置说明作为指南，并以类似的方式配置你的环境。请参考[*附录*](B21757_20.xhtml#_idTextAnchor642)中的SSL设置说明，*附加参考资料*，以获取配置Tomcat和Spring
    Security以在独立环境中使用SSL的帮助。
- en: Understanding the purpose of a public key infrastructure
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解公钥基础设施的目的
- en: This chapter focuses on setting up a self-contained development environment
    for the purposes of learning and education. However, in most cases where you are
    integrating Spring Security into an existing client certificate-secured environment,
    there will be a significant amount of infrastructure (usually a combination of
    hardware and software) in place to provide functionality, such as certificate
    granting and management, user self-service, and revocation. Environments of this
    type define a public key infrastructure—a combination of hardware, software, and
    security policies that result in a highly secure authentication-driven network
    ecosystem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注为学习和教育目的设置一个自包含的开发环境。然而，在大多数情况下，当你将Spring Security集成到现有的客户端证书安全环境中时，将存在大量的基础设施（通常是硬件和软件的组合），以提供诸如证书授予和管理、用户自助服务以及撤销等功能。这类环境定义了一个公钥基础设施——硬件、软件和安全策略的组合，从而形成一个高度安全的基于认证的网络生态系统。
- en: In addition to being used for web application authentication, certificates or
    hardware devices in these environments can be used for secure, non-repudiated
    email (using `S/MIME`), network authentication, and even physical building access
    (using `PKCS 11`-based hardware devices).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于Web应用程序认证外，这些环境中的证书或硬件设备还可以用于安全的、不可否认的电子邮件（使用`S/MIME`）、网络认证，甚至物理建筑访问（使用基于`PKCS
    11`的硬件设备）。
- en: While the management overhead of such an environment can be high (and requires
    both IT and process excellence to implement well), it is arguably one of the most
    secure operating environments possible for technology professionals.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种环境的运维成本可能很高（并且需要IT和流程的卓越表现才能有效实施），但可以说，这是技术专业人士可能拥有的最安全的操作环境之一。
- en: Creating a client certificate key pair
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建客户端证书密钥对
- en: The self-signed client certificate is created in the same way as the self-signed
    server certificate is created—by generating a key pair using the `keytool` command.
    A client certificate key pair differs in that it requires the key store to be
    available to the web browser and requires the client’s public key to be loaded
    into the server’s trust store (we’ll explain what this is in a moment).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名客户端证书的创建方式与自签名服务器证书的创建方式相同——通过使用`keytool`命令生成密钥对。客户端证书密钥对的不同之处在于它需要密钥库对Web浏览器可用，并且需要将客户端的公钥加载到服务器的信任库中（我们将在稍后解释这是什么）。
- en: 'If you do not wish to generate your own key right now, you may skip to the
    next section and use the sample certificates in the `./src/main/resources/keys`
    folder in the sample chapter. Otherwise, create the client key pair, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在不想生成自己的密钥，你可以跳到下一节，并使用示例章节中`./src/main/resources/keys`文件夹中的示例证书。否则，请按照以下步骤创建客户端密钥对：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find additional information about `keytool`, along with all of the
    configuration options, at Oracle’s site, here: [https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml](https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Oracle网站上找到有关`keytool`的更多信息，以及所有配置选项，请访问以下链接：[https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml](https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml)。
- en: 'Most of the arguments to `keytool` are fairly arbitrary for this use case.
    However, when prompted to set up the first and last name (the `admin1@example.com`
    is an appropriate value since we have the `admin1@example.com` user setup in Spring
    Security. An example of the command-line interaction is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此用例，`keytool` 的大多数参数都是相当任意的。然而，当提示设置姓名和姓氏时（`admin1@example.com` 是一个合适的值，因为我们已经在
    Spring Security 中设置了 `admin1@example.com` 用户。命令行交互的示例如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll see why this is important when we configure Spring Security to access
    the information from the certificate-authenticated user. We have one final step
    before we can set up certificate authentication within Tomcat, which is explained
    in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们配置 Spring Security 从证书认证用户获取信息时，我们将看到这一点的重要性。在我们可以设置 Tomcat 内部的证书认证之前，我们还有最后一个步骤，这将在下一节中解释。
- en: Configuring the Tomcat trust store
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Tomcat 信任存储库
- en: Recall that the definition of a key pair includes both a private and public
    key. Similar to SSL certificates verifying and securing server communication,
    the validity of the client certificate needs to be verified by the certifying
    authority that created it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，密钥对的定义包括私钥和公钥。类似于 SSL 证书验证和保障服务器通信，客户端证书的有效性需要由创建它的认证机构进行验证。
- en: As we have created our own self-signed client certificate using the `keytool`
    command, the **Java Virtual Machine** (**JVM**) will not implicitly trust it as
    having been assigned by a trusted certificate authority.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用 `keytool` 命令创建了自己的自签名客户端证书，Java 虚拟机（**JVM**）不会隐式地信任它，因为它是由受信任的证书颁发机构分配的。
- en: 'Let’s take a look at the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: We will need to force Tomcat to recognize the certificate as a trusted certificate.
    We do this by exporting the public key from the key pair and adding it to the
    Tomcat trust store.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要强制 Tomcat 识别证书为受信任证书。我们通过从密钥对中导出公钥并将其添加到 Tomcat 信任存储库来实现这一点。
- en: Again, if you do not wish to perform this step now, you can use the existing
    trust store in `.src/main/resources/keys` and skip to where we configure `server.xml`
    later in this section.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次提醒，如果您现在不想执行此步骤，您可以使用 `.src/main/resources/keys` 中的现有信任存储库，并跳转到本节后面配置 `server.xml`
    的部分。
- en: 'We’ll export the public key to a standard certificate file named `jbcp_clientauth.cer`,
    as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导出公钥到一个名为 `jbcp_clientauth.cer` 的标准证书文件，如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll import the certificate into the trust store (this will create the
    trust store, but in a typical deployment scenario you’d probably already have
    some other certificates in the trust store):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将证书导入信任存储库（这将创建信任存储库，但在典型的部署场景中，您可能已经在信任存储库中拥有其他证书）：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Owner: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT,
    C=US'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 持有人：CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US
- en: 'Issuer: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT,
    C=US'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发行者：CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US
- en: 'Serial number: 464fc10c'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 序列号：464fc10c
- en: 'Valid from: Fri Jun 23 11:10:19 MDT 2017 until: Thu Feb 12 10:10:19'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效期从：2017 年 6 月 23 日星期五 11:10:19 MDT 至：2018 年 2 月 12 日星期四 10:10:19
- en: MST 2043
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MST 2043
- en: '//Certificate fingerprints:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //证书指纹：
- en: 'MD5: 8D:27:CE:F7:8B:C3:BD:BD:64:D6:F5:24:D8:A1:8B:50'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MD5: 8D:27:CE:F7:8B:C3:BD:BD:64:D6:F5:24:D8:A1:8B:50'
- en: 'SHA1: C1:51:4A:47:EC:9D:01:5A:28:BB:59:F5:FC:10:87:EA:68:24:E3:1F'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'SHA1: C1:51:4A:47:EC:9D:01:5A:28:BB:59:F5:FC:10:87:EA:68:24:E3:1F'
- en: 'SHA256: 2C:F6:2F:29:ED:09:48:FD:FE:A5:83:67:E0:A0:B9:DA:C5:3B: FD:CF:4F:95:50:3A:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'SHA256: 2C:F6:2F:29:ED:09:48:FD:FE:A5:83:67:E0:A0:B9:DA:C5:3B: FD:CF:4F:95:50:3A:'
- en: 2C:B8:2B:BD:81:48:BB:EF
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2C:B8:2B:BD:81:48:BB:EF
- en: 'Signature algorithm name: SHA256withRSA Version: 3'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 签名算法名称：SHA256withRSA 版本：3
- en: //Extensions
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //扩展
- en: '#1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier ['
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier ['
- en: KeyIdentifier [
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: KeyIdentifier [
- en: '0000: 29 F3 A7 A1 8F D2 87 4B'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '0000: 29 F3 A7 A1 8F D2 87 4B'
- en: EA 74 AC 8A 4B BC 4B 5D
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: EA 74 AC 8A 4B BC 4B 5D
- en: )
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: K.t..K.K]
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: K.t..K.K]
- en: '0010: 7C 9B 44 4A'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '0010: 7C 9B 44 4A'
- en: ..DJ
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ..DJ
- en: ']'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: ']'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: tomcat.truststore file, as we will need to reference it in our Tomcat configuration.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tomcat.truststore 文件，因为我们将在我们的 Tomcat 配置中引用它。
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What’s the difference between a key store and a trust store?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥存储库和信任存储库之间的区别是什么？
- en: The `keystoreFile` and `truststoreFile` attributes of the connector). The format
    of the files themselves can be exactly the same. Really, each file can be any
    JSSE-supported keystore format, including `PKCS 12`, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的 `keystoreFile` 和 `truststoreFile` 属性）。文件本身的格式可以完全相同。实际上，每个文件可以是任何 JSSE
    支持的密钥存储格式，包括 `PKCS 12` 等。
- en: As previously mentioned, we assume you have already configured the SSL Connector,
    as outlined in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional
    Reference Material*. If you do not see the `keystoreFile` or `keystorePass` attributes
    in `server.xml`, it means you should visit the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*, to get SSL set up.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们假设您已经按照 [*附录*](B21757_20.xhtml#_idTextAnchor642) 中的说明配置了 SSL 连接器，*附加参考资料*。如果您在
    `server.xml` 中看不到 `keystoreFile` 或 `keystorePass` 属性，这意味着您应该访问 [*附录*](B21757_20.xhtml#_idTextAnchor642)
    中的 *附加参考资料*，以获取 SSL 设置。
- en: 'Finally, we’ll need to point Tomcat at the trust store and enable client certificate
    authentication. This is done by adding three additional attributes to the SSL
    connector in the Tomcat `server.xml` file, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将 Tomcat 指向信任库并启用客户端证书认证。这通过在 Tomcat 的 `server.xml` 文件中的 SSL 连接器添加三个额外的属性来完成，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should be the remaining configuration required to trigger Tomcat to request
    a client certificate when an SSL connection is made. Of course, you will want
    to ensure you replace both `<CERT_PATH>` and `<KEYSTORE_PATH>` with the full paths.
    For example, on a Unix-based `/home/packt/chapter8/keys/tomcat.keystore`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该是触发 Tomcat 在建立 SSL 连接时请求客户端证书所需的剩余配置。当然，您需要确保将 `<CERT_PATH>` 和 `<KEYSTORE_PATH>`
    替换为完整路径。例如，在基于 Unix 的 `/home/packt/chapter8/keys/tomcat.keystore`。
- en: Go ahead and try to start up Tomcat to ensure that the server starts up without
    any errors in the logs.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试启动 Tomcat，以确保服务器在日志中没有错误地启动。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There’s also a way to configure Tomcat to optionally use client certificate
    authentication—we’ll enable this later in the chapter. For now, we require the
    use of client certificates to even connect to the Tomcat server in the first place.
    This makes it easier to diagnose whether or not you have set this up correctly!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种配置 Tomcat 以可选方式使用客户端证书认证的方法——我们将在本章后面启用它。目前，我们要求使用客户端证书才能首先连接到 Tomcat
    服务器。这使得诊断您是否正确设置了此功能变得更加容易！
- en: Configuring Tomcat in Spring Boot
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中配置 Tomcat
- en: We can also configure the embedded Tomcat instance within Spring Boot, which
    is how we will be working with Tomcat for the rest of this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置 Spring Boot 内嵌的 Tomcat 实例，这是我们将在本章的其余部分使用 Tomcat 的方式。
- en: 'Configuring Spring Boot to use our newly created certificates is as straightforward
    as configuring the properties of the YAML entry, as shown in the following code
    snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Boot 配置为使用我们新创建的证书与配置 YAML 条目的属性一样简单，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The final step is to import the certificate into the client browser.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将证书导入客户端浏览器。
- en: Importing the certificate key pair into a browser
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将证书密钥对导入浏览器
- en: Depending on what browser you are using, the process of importing a certificate
    may differ. We will provide instructions for installations of Firefox, Chrome,
    and Internet Explorer here, but if you are using another browser, please consult
    its help section or your favorite search engine for assistance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的浏览器，导入证书的过程可能不同。我们将在此处提供 Firefox、Chrome 和 Internet Explorer 的安装说明，但如果您使用其他浏览器，请咨询其帮助部分或您喜欢的搜索引擎以获取帮助。
- en: Using Mozilla Firefox
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Mozilla Firefox
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Firefox:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在 Firefox 中导入包含客户端证书密钥对的密钥库：
- en: Click on **Edit** | **Preferences**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **编辑** | **首选项**。
- en: Click on the **Advanced** button.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **高级** 按钮。
- en: Click on the **Encryption** tab.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **加密** 选项卡。
- en: Click on the **View Certificates** button. The **Certificate Manager** window
    should open up.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **查看证书** 按钮。应该打开 **证书管理器** 窗口。
- en: Click on the **Your** **Certificates** tab.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **您的** **证书** 选项卡。
- en: Click on the **Import...** button.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **导入...** 按钮。
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it. You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到您保存 `jbcp_clientauth.p12` 文件的位置并选择它。您需要输入创建文件时使用的密码（即 `changeit`）。
- en: The client certificate should be imported, and you should see it on the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书应该被导入，并且您应该能在列表中看到它。
- en: Using Google Chrome
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Google Chrome
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Chrome:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在 Chrome 中导入包含客户端证书密钥对的密钥库：
- en: Click on the wrench icon on the browser toolbar.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览器工具栏上的扳手图标。
- en: Select **Settings**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**设置**。
- en: Click on **Show** **advanced settings...**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示****高级设置...**。
- en: In the **HTTPS/SSL** section, click on the **Manage** **certificates...** button.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**HTTPS/SSL**部分，点击**管理****证书...**按钮。
- en: In the **Personal** tab click on the **Import...** button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**个人**选项卡中点击**导入...**按钮。
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it (Ensure that you utilize the .p12 extension for the certificate).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到保存`jbcp_clientauth.p12`文件的位置并选择它（确保使用证书的.p12扩展名）。
- en: You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要输入你创建文件时使用的密码（即`changeit`）。
- en: Click on **OK**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: Using Microsoft Edge
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Microsoft Edge
- en: 'Let’s take a look at the steps of using Microsoft Edge with Windows OS:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Windows OS的Microsoft Edge的步骤：
- en: Double-click on the `jbcp_clientauth.p12` file in Windows Explorer. The **Certificate
    Import Wizard** window should open (Ensure that you utilize the .p12 extension
    for the certificate).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中双击`jbcp_clientauth.p12`文件。应该会打开**证书导入向导**窗口（确保使用证书的.p12扩展名）。
- en: Click on **Next** and accept the default values until you are prompted for the
    certificate password.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**并接受默认值，直到提示输入证书密码。
- en: Enter the certificate password (that is, `changeit`) and click **Next**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入证书密码（即`changeit`）并点击**下一步**。
- en: Accept the default **Automatically select the certificate store** option and
    click **Next**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受默认的**自动选择证书存储**选项并点击**下一步**。
- en: Click on **Finish**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**。
- en: 'To verify that the certificate was installed correctly, you will need to perform
    another series of steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证证书是否正确安装，你需要执行另一系列步骤：
- en: Open the **Settings** menu in Microsoft Edge.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Microsoft Edge中打开**设置**菜单。
- en: Select **Privacy, search** **and services**
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**隐私、搜索**和**服务**。
- en: Scroll down to **Security** and
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**安全**并
- en: Click **Manage certificates**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**管理证书**。
- en: Click on the **Personal** tab, if it is not already selected. You should see
    the certificate listed here.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果个人选项卡尚未选中，请点击**个人**选项卡。你应该在这里看到证书列表。
- en: Wrapping up testing
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试总结
- en: 'You should now be able to connect to the `https://localhost:8443/`, taking
    care to use **HTTPS** and **8443**. If all is set up correctly, you should be
    prompted for a certificate when you attempt to access the site—in Chrome, the
    certificate is displayed as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够连接到`https://localhost:8443/`，注意使用**HTTPS**和**8443**。如果一切设置正确，当你尝试访问网站时，应该会提示输入证书——在Chrome中，证书显示如下：
- en: '![Figure 8.2 – Client certificate details in Chrome](img/B21757_08_2.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – Chrome中的客户端证书详情](img/B21757_08_2.jpg)'
- en: Figure 8.2 – Client certificate details in Chrome
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Chrome中的客户端证书详情
- en: You’ll notice, however, that if you attempt to access a protected section of
    the site, such as the **My Events** section, you’ll be redirected to the login
    page. This is because we haven’t yet configured Spring Security to recognize the
    information in the certificate—at this point, the negotiation between the client
    and server has stopped at the Tomcat server itself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会发现，如果你尝试访问受保护的网站部分，例如**我的事件**部分，你会被重定向到登录页面。这是因为我们还没有配置Spring Security来识别证书中的信息——在这个阶段，客户端和服务器之间的协商已经停止在Tomcat服务器本身。
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter08.00-calendar`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter08.00-calendar`中的代码开始。
- en: Troubleshooting client certificate authentication
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端证书认证故障排除
- en: Unfortunately, if we said that getting client certificate authentication configured
    correctly for the first time—without anything going wrong—was easy, we’d be lying
    to you. The fact is, although this is a great and very powerful security apparatus,
    it is poorly documented by both the browser and web server manufacturers, and
    the error messages, when present, can be confusing at best and misleading at worst.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们说第一次正确配置客户端证书认证——没有任何问题发生——很容易，那我们就是在对你撒谎。事实是，尽管这是一个伟大且非常强大的安全装置，但浏览器和Web服务器制造商的文档都做得不好，而且当错误信息出现时，它们最好时令人困惑，最坏时具有误导性。
- en: Remember that, at this point, we have not involved Spring Security in the equation
    at all, so a debugger will most likely not help you (unless you have the Tomcat
    source code handy). There are some common errors and things to check.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，到目前为止，我们完全没有在等式中涉及Spring Security，所以调试器可能不会帮助你（除非你手头有Tomcat源代码）。有一些常见的错误和需要检查的事项。
- en: 'You aren’t prompted for a certificate when you access the site. There are many
    possible causes for this, and this can be the most puzzling problem to try to
    solve. Here are some things to check:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问网站时不会被提示证书。这可能有多种可能的原因，这可能是最难以解决的问题之一。以下是一些需要检查的事项：
- en: Ensure that the certificate has been installed in the browser client you are
    using. Sometimes, you need to restart the whole browser (close all windows) if
    you attempted to access the site previously and were rejected.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保证书已安装到您正在使用的浏览器客户端中。有时，如果您之前尝试访问该网站并被拒绝，您可能需要重新启动整个浏览器（关闭所有窗口）。
- en: Ensure you are accessing the SSL port for the server (typically `8443` in a
    development setup), and have selected the HTTPS protocol in your URL. The client
    certificates are not presented in insecure browser connections. Make sure the
    browser also trusts the server SSL certificate, even if you have to force it to
    trust a self-signed certificate.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您正在访问服务器的 SSL 端口（在开发设置中通常是 `8443`），并在您的 URL 中选择了 HTTPS 协议。客户端证书不会在不安全的浏览器连接中显示。请确保浏览器也信任服务器的
    SSL 证书，即使您必须强制它信任自签名证书。
- en: Ensure you have added the `clientAuth` directive to your Tomcat configuration
    (or the equivalent for whatever application server you are using).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已将 `clientAuth` 指令添加到您的 Tomcat 配置中（或您所使用的任何应用服务器的等效配置）。
- en: If all else fails, use a network analyzer or packet sniffer, such as Wireshark
    ([http://www.wireshark.org/](http://www.wireshark.org/)) or Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/)),
    to review the traffic and SSL key exchange over the wire (check with your IT department
    first—many companies do not allow tools of this kind on their networks).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有其他方法都失败了，请使用网络分析器或数据包嗅探器，如 Wireshark ([http://www.wireshark.org/](http://www.wireshark.org/))
    或 Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/)))，来审查网络上的流量和
    SSL 密钥交换（首先与您的 IT 部门确认——许多公司不允许在其网络上使用此类工具）。
- en: If you are using a self-signed client certificate, make sure the public key
    has been imported into the server’s trust store. If you are using a CA-assigned
    certificate, make sure the CA is trusted by the **Java Virtual Machine** (**JVM**)
    or that the CA certificate is imported into the server’s trust store.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用自签名客户端证书，请确保公钥已导入到服务器的信任存储中。如果您正在使用由 CA 分配的证书，请确保 CA 被信任的 **Java 虚拟机**（**JVM**）或
    CA 证书已导入到服务器的信任存储中。
- en: Internet Explorer, in particular, does not report details of client certificate
    failures at all (it simply reports a generic **Page Cannot be Displayed** error).
    Use Firefox to diagnose whether an issue you are seeing is related to client certificates
    or not.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尤其是Internet Explorer，它根本不会报告客户端证书失败的具体细节（它只是报告一个通用的**页面无法显示**错误）。使用 Firefox
    来诊断您遇到的问题是否与客户端证书有关。
- en: 'The following JVM option will enable SSL handshake level logging: `-Djavax.net.debug=ssl:handshake`.
    This debugging flag can produce a large amount of output but can be very helpful
    in diagnosing underlying SSL connectivity issues.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 JVM 选项将启用 SSL 握手级别的日志记录：`-Djavax.net.debug=ssl:handshake`。这个调试标志可能会产生大量输出，但在诊断底层
    SSL 连接问题时非常有帮助。
- en: Configuring client certificate authentication in Spring Security
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Spring Security 中配置客户端证书身份验证
- en: Unlike the authentication mechanisms that we have utilized thus far, the use
    of client certificate authentication results in the user’s request being pre-authenticated
    by the server. As the server (Tomcat) has already established that the user has
    provided a valid and trustworthy certificate, Spring Security can simply trust
    this assertion of validity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止所使用的身份验证机制不同，使用客户端证书身份验证会导致用户的请求在服务器端预先进行身份验证。由于服务器（Tomcat）已经确认用户提供了有效且可信的证书，Spring
    Security 可以简单地信任这个有效性的声明。
- en: An important component of the secure login process is still missing, which is
    the authorization of the authenticated user. This is where our configuration of
    Spring Security comes in—we must add a component to Spring Security that will
    recognize the certificate authentication information from the user’s HTTP session
    (populated by Tomcat), and then validate the presented credentials against the
    Spring Security `UserDetailsService` invocation. The invocation of `UserDetailsService`
    will result in the determination of whether the user declared in the certificate
    is known to Spring Security at all, and then it will assign `GrantedAuthority`
    as per the usual login rules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安全登录过程中仍缺少一个重要组件，那就是认证用户的授权。这正是我们配置Spring Security的地方——我们必须向Spring Security添加一个组件，该组件将识别用户HTTP会话（由Tomcat填充）中的证书认证信息，然后根据Spring
    Security的 `UserDetailsService` 调用来验证提供的凭据。`UserDetailsService` 的调用将导致确定证书中声明的用户是否为Spring
    Security所知，然后根据常规登录规则分配 `GrantedAuthority`。
- en: Configuring client certificate authentication using the security namespace
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全命名空间配置客户端证书认证
- en: 'With all of the complexity of LDAP configuration, configuring client certificate
    authentication is a welcome reprieve. If we are using the security namespace style
    of configuration, the addition of client certificate authentication is a simple
    one-line configuration change, added within the `HttpSecurity` declaration. Go
    ahead and make the following changes to the provided `SecurityConfig.java` configuration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在LDAP配置的复杂性中，配置客户端证书认证是一个受欢迎的缓解。如果我们使用安全命名空间风格的配置，添加客户端证书认证只是一个简单的单行配置更改，添加在
    `HttpSecurity` 声明中。请对提供的 `SecurityConfig.java` 配置进行以下更改：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Observe that the `.x509()` method references our existing `userDetailsService()`
    configuration. For simplicity, we use the `UserDetailsServiceImpl` implementation
    covered in [*Chapter 5*](B21757_05.xhtml#_idTextAnchor150), *Authentication with
    Spring Data*. However, we could easily swap this out with any other implementation
    (that is, the LDAP or JDBC-based implementation covered in [*Chapter 4*](B21757_04.xhtml#_idTextAnchor106),
    *JDBC-based Authentication*).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `.x509()` 方法引用了我们现有的 `userDetailsService()` 配置。为了简化，我们使用了在 [*第5章*](B21757_05.xhtml#_idTextAnchor150)
    中介绍的 `UserDetailsServiceImpl` 实现，即 *使用Spring Data进行认证*。然而，我们可以轻松地将它替换为任何其他实现（即，在
    [*第4章*](B21757_04.xhtml#_idTextAnchor106) 中介绍的基于LDAP或JDBC的实现，即 *基于JDBC的认证*)。
- en: After restarting the application, you’ll again be prompted for a client certificate,
    but this time, you should be able to access areas of the site requiring authorization.
    You can see from the logs (if you have them enabled) that you have been logged
    in as the `admin1@example.com` user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动应用程序后，您将再次被提示输入客户端证书，但这次，您应该能够访问需要授权的网站区域。您可以从日志中看到（如果您已启用），您已以 `admin1@example.com`
    用户登录。
- en: Important note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like `chapter08.01-calendar`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应类似于 `chapter08.01-calendar`。
- en: How does Spring Security use certificate information?
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Security如何使用证书信息？
- en: 'As previously discussed, Spring Security’s involvement in certificate exchange
    is to pick up information from the presented certificate and map the user’s credentials
    to a user service. What we did not see in the use of the `.x509()` method was
    the magic that makes this happen. Recall that when we set the client certificate
    up, a DN similar to an LDAP DN was associated with the certificate:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Security在证书交换中的作用是从提供的证书中提取信息，并将用户的凭据映射到用户服务。在使用 `.x509()` 方法时，我们没有看到使这一切发生的魔法。回想一下，当我们设置客户端证书时，一个类似于LDAP
    DN的DN与证书相关联：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Spring Security uses the information in this DN to determine the actual username
    of the principal and it will look for this information in `UserDetailsService`.
    In particular, it allows for the specification of a regular expression, which
    is used to match a portion of the DN established with the certificate, and the
    utilization of this portion of the DN as the principal name. The implicit, default
    configuration for the `.x509()` method would be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security使用此DN中的信息来确定主体的实际用户名，它将在 `UserDetailsService` 中查找此信息。特别是，它允许指定一个正则表达式，该表达式用于匹配与证书建立的DN的一部分，并将此DN部分用作主体名称。`.x509()`
    方法的隐含默认配置如下：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that this regular expression would match the `admin1@example.com`
    value as the principal’s name. This regular expression must contain a single matching
    group, but it can be configured to support the username and DN issuance requirements
    of your application. For example, if the DNs for your organization’s certificates
    include the `email` or `userid` fields, the regular expression can be modified
    to use these values as the authenticated principal’s name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个正则表达式将匹配作为主体名称的 `admin1@example.com` 值。这个正则表达式必须包含一个匹配组，但它可以被配置为支持应用程序的用户名和DN发行要求。例如，如果您的组织证书的DN包括
    `email` 或 `userid` 字段，则可以将正则表达式修改为使用这些值作为认证主体名称。
- en: How Spring Security certificate authentication works
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Security证书认证是如何工作的
- en: 'Let’s review the various actors involved in the review and evaluation of the
    client certificates and translation into a Spring-Security-authenticated session,
    with the help of the following diagram:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表来回顾参与客户端证书审查和评估以及将其转换为Spring-Security认证会话的各种参与者：
- en: '![Figure 8.3 – Spring Security certificate authentication workflow](img/B21757_08_3.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – Spring Security证书认证工作流程](img/B21757_08_3.jpg)'
- en: Figure 8.3 – Spring Security certificate authentication workflow
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – Spring Security证书认证工作流程
- en: We can see that `o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter`
    is responsible for examining the request of an unauthenticated user for the presentation
    of client certificates. If it sees that the request includes a valid client certificate,
    it will extract the principal using `o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor`,
    using a regular expression matching the certificate owner’s DN, as previously
    described.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter` 负责检查未认证用户请求展示客户端证书。如果它发现请求包含有效的客户端证书，它将使用
    `o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor` 提取主体，使用与之前描述的证书所有者DN匹配的正则表达式。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that although the preceding diagram indicates that examination of the
    certificate occurs for unauthenticated users, a check can also be performed when
    the presented certificate identifies a different user than the one that was previously
    authenticated. This would result in a new authentication request using the newly
    provided credentials. The reason for this should be clear—any time a user presents
    a new set of credentials, the application must be aware of this and react in a
    responsible fashion by ensuring that the user is still able to access it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管前面的图表表明证书的审查发生在未认证用户的情况下，但当展示的证书标识的用户与之前认证的用户不同时，也可以执行检查。这将导致使用新提供的凭据发起新的认证请求。这样做的原因应该是显而易见的——任何用户展示新的凭证集时，应用程序都必须意识到这一点，并通过确保用户仍然能够访问它来负责任地做出反应。
- en: 'Once the certificate has been accepted (or rejected/ignored), as with other
    authentication mechanisms, an `Authentication` token is built and passed along
    to `AuthenticationManager` for authentication. We can now review the very brief
    illustration of the `o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`
    handling of the authentication token:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦证书被接受（或拒绝/忽略），就像其他认证机制一样，将构建一个 `Authentication` 令牌并将其传递给 `AuthenticationManager`
    进行认证。现在我们可以回顾一下 `o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`
    处理认证令牌的简要说明：
- en: '![Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow](img/B21757_08_4.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – Spring Security PreAuthenticatedAuthenticationProvider工作流程](img/B21757_08_4.jpg)'
- en: Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – Spring Security PreAuthenticatedAuthenticationProvider工作流程
- en: Though we will not go over them in detail, there are a number of other pre-authenticated
    mechanisms supported by Spring Security. Some examples include Java EE role mapping
    (`J2eePreAuthenticatedProcessingFilter`), WebSphere integration (`WebSpherePreAuthenticatedProcessingFilter`),
    and SiteMinder-style authentication (`RequestHeaderAuthenticationFilter`). If
    you understand the process flow of client certificate authentication, understanding
    these other authentication types is significantly easier.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细讨论它们，但Spring Security支持许多其他预认证机制。一些例子包括Java EE角色映射（`J2eePreAuthenticatedProcessingFilter`）、WebSphere集成（`WebSpherePreAuthenticatedProcessingFilter`）和SiteMinder风格的认证（`RequestHeaderAuthenticationFilter`）。如果你理解了客户端证书认证的过程流程，理解这些其他认证类型会容易得多。
- en: Handling unauthenticated requests with AuthenticationEntryPoint
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AuthenticationEntryPoint 处理未认证请求
- en: Since `X509AuthenticationFilter` will continue processing the request if authentication
    fails, we’ll need to handle situations where the user does not authenticate successfully
    and has requested a protected resource. The way that Spring Security allows developers
    to customize this is by plugging in a custom `o.s.s.web.AuthenticationEntryPoint`
    implementation. In a default form login scenario, `LoginUrlAuthenticationEntryPoint`
    is used to redirect the user to a login page if they have been denied access to
    a protected resource and are not authenticated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `X509AuthenticationFilter` 在认证失败时会继续处理请求，我们需要处理用户未能成功认证并请求受保护资源的情况。Spring
    Security 允许开发者通过插入自定义的 `o.s.s.web.AuthenticationEntryPoint` 实现来自定义这一点。在默认表单登录场景中，如果用户被拒绝访问受保护资源且未认证，`LoginUrlAuthenticationEntryPoint`
    用于将用户重定向到登录页面。
- en: 'In contrast, in typical client certificate authentication environments, alternative
    methods of authentication are simply not supported (remember that Tomcat expects
    the certificate well before the Spring Security form login takes place anyway).
    As such, it doesn’t make sense to retain the default behavior of redirection to
    a form login page. Instead, we’ll modify the entry point to simply return an `HTTP
    403 Forbidden` message, using `o.s.s.web.authentication.Http403ForbiddenEntryPoint`.
    Go ahead and make the following updates in your `SecurityConfig.java` file, as
    follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在典型的客户端证书认证环境中，不支持替代认证方法（记住，无论如何，Tomcat 都会在 Spring Security 表单登录之前期望证书）。因此，保留重定向到表单登录页面的默认行为是没有意义的。相反，我们将修改入口点以简单地返回一个
    `HTTP 403 禁止` 消息，使用 `o.s.s.web.authentication.Http403ForbiddenEntryPoint`。请按照以下方式在您的
    `SecurityConfig.java` 文件中进行以下更新：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if a user tries to access a protected resource and is unable to provide
    a valid certificate, they will be presented with the following page, instead of
    being redirected to the login page:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户尝试访问受保护资源且无法提供有效的证书，他们将看到以下页面，而不是被重定向到登录页面：
- en: '![Figure 8.5 – Spring Security forbidden error](img/B21757_08_5.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – Spring Security 禁止错误](img/B21757_08_5.jpg)'
- en: Figure 8.5 – Spring Security forbidden error
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – Spring Security 禁止错误
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have removed the username of `admin1@example.com`, to make sure there is
    no matching user with the certificate CN.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已删除 `admin1@example.com` 的用户名，以确保没有与证书 CN 匹配的用户。
- en: Your code should look like `chapter08.02-calendar`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像 `chapter08.02-calendar`。
- en: 'Other configuration or application flow adjustments that are commonly performed
    with client certificate authentication are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其他通常与客户端证书认证一起执行的配置或应用程序流程调整如下：
- en: Removal of the form-based login page altogether
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全删除基于表单的登录页面
- en: Removal of the logout link (as there’s no reason to log out because the browser
    will always present the user’s certificate)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除注销链接（因为没有理由注销，因为浏览器总是会显示用户的证书）
- en: Removal of the functionality to rename the user account and change the password
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除重命名用户账户和更改密码的功能
- en: Removal of the user registration functionality (unless you are able to tie it
    into the issuance of a new certificate)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除用户注册功能（除非你能够将其与新的证书发放关联）
- en: Supporting dual-mode authentication
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持双模式认证
- en: It is also possible that some environments may support both certificate-based
    and form-based authentication. If this is the case in your environment, it is
    also possible (and trivial) to support it with Spring Security. We can simply
    leave the default `AuthenticationEntryPoint` interface (redirecting to the form-based
    login page) intact and allow the user to log in using the standard login form
    if they do not supply a client certificate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在某些环境可能同时支持基于证书和基于表单的认证。如果你的环境是这样，使用 Spring Security 支持它也是可能的（并且是微不足道的）。我们可以简单地保留默认的
    `AuthenticationEntryPoint` 接口（重定向到基于表单的登录页面）不变，并允许用户在没有提供客户端证书的情况下使用标准登录表单登录。
- en: 'If you choose to configure your application this way, you’ll need to adjust
    the Tomcat SSL settings (change as appropriate for your application server). Simply
    change the `clientAuth` directive to `want`, instead of `true`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择以这种方式配置你的应用程序，你需要调整 Tomcat SSL 设置（根据你的应用程序服务器适当更改）：简单地将 `clientAuth` 指令更改为
    `want`，而不是 `true`：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll also need to remove the `authenticationEntryPoint()` method that we configured
    in the previous exercise so that the standard form-based authentication workflow
    takes over if the user isn’t able to supply a valid certificate upon the browser
    first being queried.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要删除在之前的练习中配置的`authenticationEntryPoint()`方法，以便如果用户在浏览器首次查询时无法提供有效的证书，则标准的基于表单的认证工作流程将接管。
- en: 'Although this is convenient, there are a few things to keep in mind about dual-mode
    (form-based and certificate-based) authentication, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很方便，但在双模式（基于表单和基于证书）认证方面，还有一些事情需要记住，如下所示：
- en: Most browsers will not re-prompt the user for a certificate if they have failed
    certificate authentication once, so make sure that your users are aware that they
    may need to reenter the browser to present their certificate again.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数浏览器在用户一次证书认证失败后不会再次提示用户输入证书，所以请确保您的用户知道他们可能需要重新进入浏览器以再次展示他们的证书。
- en: Recall that a password is not required to authenticate users with certificates;
    however, if you are still using `UserDetailsService` to support your form-based
    authenticated users, this may be the same `UserDetailsService` object that you
    use to give the `PreAuthenticatedAuthenticationProvider` information about your
    users. This presents a potential security risk, as users who you intend to sign
    in only with certificates could potentially authenticate using form login credentials.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，使用证书进行用户认证不需要密码；然而，如果您仍然使用`UserDetailsService`来支持您的基于表单认证的用户，这可能就是您用来向`PreAuthenticatedAuthenticationProvider`提供用户信息的同一个`UserDetailsService`对象。这可能会带来潜在的安全风险，因为您打算仅使用证书登录的用户可能会使用表单登录凭据进行认证。
- en: 'There are several ways to solve this problem, and they are described in the
    following list:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方法，以下列表中进行了描述：
- en: Ensure that the users authenticating with certificates have an appropriately
    strong password in your user store.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用证书进行认证的用户在您的用户存储中有一个适当的强密码。
- en: Consider customizing your user store to clearly identify users who are enabled
    for form-based login. This can be tracked with an additional field in the table
    holding user account information, and with minor adjustments to the SQL queries
    used by the `JpaDaoImpl` object.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑自定义您的用户存储，以便清楚地识别已启用基于表单登录的用户。这可以通过在包含用户账户信息的表中添加一个额外字段，以及通过调整`JpaDaoImpl`对象使用的SQL查询来实现。
- en: Configure a separate user details store altogether for users who are logging
    in as certificate-authenticated users, to completely segregate them from users
    that are allowed to use form-based login.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全为以证书认证用户登录的用户配置一个独立的用户详情存储，以将他们完全与允许使用基于表单登录的用户隔离开。
- en: Dual-mode authentication can be a powerful addition to your site and can be
    deployed effectively and securely, provided that you keep in mind the situations
    under which users will be granted access to it.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双模式认证可以成为您网站的一个强大补充，并且可以有效地安全部署，前提是您要考虑到用户将获得访问它的条件。
- en: Configuring client certificate authentication using Spring beans
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Bean配置客户端证书认证
- en: 'Earlier in this chapter, we reviewed the flow of the classes involved in client
    certificate authentication. As such, it should be straightforward for us to configure
    the JBCP calendar using explicit beans. By using the explicit configuration, we
    will have additional configuration options at our disposal. Let’s take a look
    and see how to use explicit configuration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们回顾了参与客户端证书认证的类的流程。因此，我们应该能够直接使用显式Bean来配置JBCP日历。通过使用显式配置，我们将有更多的配置选项可供使用。让我们看看如何使用显式配置：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We’ll also need to remove the `x509()` method, add `x509Filter` to our filter
    chain, and add our `AuthenticationProvider` implementation to `AuthenticationManger`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要删除`x509()`方法，将`x509Filter`添加到我们的过滤器链中，并将我们的`AuthenticationProvider`实现添加到`AuthenticationManger`中：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, give the application a try. Nothing much has changed from a user perspective,
    but as developers, we have opened the door to a number of additional configuration
    options.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试一下应用程序。从用户的角度来看，没有太多变化，但作为开发者，我们已经打开了许多额外的配置选项的大门。
- en: Important note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like `chapter08.03-calendar`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应类似于`chapter08.03-calendar`。
- en: Additional capabilities of bean-based configuration
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于Bean的配置的附加功能
- en: The use of Spring-bean-based configuration provides us with additional capabilities
    through the exposure of bean properties that aren’t exposed via the security namespace
    style of configuration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Spring-bean的配置通过暴露通过安全命名空间样式配置未暴露的bean属性，为我们提供了额外的能力。
- en: 'Additional properties available on `X509AuthenticationFilter` are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`X509AuthenticationFilter` 上可用的其他属性如下：'
- en: '| **Property** | **Description** | **Default** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **默认** |'
- en: '| --- | --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `continueFilterChainOn` `UnsuccessfulAuthentication` | If false, a failed
    authentication will throw an exception rather than allow the request to continue.
    This would typically be set in cases where a valid certificate is expected and
    required to access the secured site. If true, the filter chain will proceed, even
    if there is a failed authentication. | `true` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `continueFilterChainOn` `UnsuccessfulAuthentication` | 如果为假，失败的认证将抛出异常而不是允许请求继续。这通常会在预期并需要有效证书才能访问受保护站点的情况下设置。如果为真，即使有失败的认证，过滤器链也会继续。
    | `true` |'
- en: '| `checkForPrincipalChanges` | If true, the filter will check to see whether
    the currently authenticated username differs from the username presented in the
    client certificate. If so, authentication against the new certificate will be
    performed and the HTTP session will be invalidated (optionally, see the next attribute).
    If false, once the user is authenticated, they will remain authenticated even
    if they present different credentials. | `false` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `checkForPrincipalChanges` | 如果为真，过滤器将检查当前认证的用户名是否与客户端证书中提供的用户名不同。如果是，将执行对新证书的认证，并将HTTP会话作废（可选，见下一个属性）。如果为假，一旦用户认证成功，即使他们提供不同的凭据，他们也将保持认证状态。
    | `false` |'
- en: '| `invalidateSessionOn` `PrincipalChange` | If true, and the principal in the
    request changes, the user’s HTTP session will be invalidated prior to being reauthenticated.
    If false, the session will remain—note that this may introduce security risks.
    | `true` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `invalidateSessionOn` `PrincipalChange` | 如果为真，并且请求中的主体发生变化，则在重新认证之前将使用户的HTTP会话作废。如果为假，会话将保持不变——请注意，这可能会引入安全风险。
    | `true` |'
- en: Table 8.1 – Properties available on X509AuthenticationFilter
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – `X509AuthenticationFilter` 上可用的属性
- en: 'The `PreAuthenticatedAuthenticationProvider` implementation has a couple of
    interesting properties available to us, which are listed in the following table:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreAuthenticatedAuthenticationProvider` 实现提供了一些有趣的属性，如下表所示：'
- en: '| **Property** | **Description** | **Default** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **默认** |'
- en: '| `preAuthenticated UserDetailsService` | This property is used to build a
    full `UserDetails` object from the username extracted from the certificate. |
    None |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `preAuthenticated UserDetailsService` | 此属性用于从证书中提取的用户名构建完整的 `UserDetails`
    对象。 | 无 |'
- en: '| `throwExceptionWhen` `TokenRejected` | If true, a `BadCredentialsException`
    exception will be thrown when the token is not constructed properly (does not
    contain a username or certificate). It is typically set to `true` in environments
    where certificates are used exclusively. | None |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `throwExceptionWhen` `TokenRejected` | 如果为真，当令牌构建不正确（不包含用户名或证书）时，将抛出 `BadCredentialsException`
    异常。通常在仅使用证书的环境中设置为 `true`。 | 无 |'
- en: Table 8.2 – Properties available on PreAuthenticatedAuthenticationProvider
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – `PreAuthenticatedAuthenticationProvider` 上可用的属性
- en: In addition to these properties, there are a number of other opportunities for
    implementing interfaces or extending classes involved in certificate authentication
    to further customize your implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性之外，还有许多其他机会来实现接口或扩展参与证书认证的类，以进一步自定义您的实现。
- en: Considerations when implementing client certificate authentication
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施客户端证书认证时的注意事项
- en: Client certificate authentication, while highly secure, isn’t for everyone and
    isn’t appropriate for every situation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管客户端证书认证非常安全，但它并不适合每个人，也不适合所有情况。
- en: 'The pros of client certificate authentication are listed, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证的优点如下列出：
- en: Certificates establish a framework of mutual trust and verifiability that both
    parties (client and server) are who they say they are
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书建立了一个相互信任和可验证的框架，确保双方（客户端和服务器）都是他们所声称的身份
- en: Certificate-based authentication, if implemented properly, is much more difficult
    to spoof or tamper with than other forms of authentication
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正确实施，基于证书的认证比其他形式的认证更难伪造或篡改
- en: If a well-supported browser is used and configured correctly, client certificate
    authentication can effectively act as a single sign-on solution, enabling transparent
    login to all certificate-secured applications
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用并正确配置了支持良好的浏览器，客户端证书认证可以有效地充当单点登录解决方案，使所有证书保护的应用程序登录透明化。
- en: 'The cons of client certificate authentication are listed, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证的缺点如下：
- en: The use of certificates typically requires the entire user population to have
    them. This can lead to both a user training burden and an administrative burden.
    Most organizations deploying certificate-based authentication on a large scale
    must have sufficient self-service and helpdesk support for certificate maintenance,
    expiration tracking, and user assistance.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的使用通常要求整个用户群体都拥有它们。这可能导致用户培训负担和行政负担。大多数在大规模部署基于证书的认证的组织必须为证书维护、到期跟踪和用户支持提供足够的自助和帮助台支持。
- en: The use of certificates is generally an all-or-nothing affair, meaning that
    mixed-mode authentication and offering support for non-certificated users is not
    provided due to the complexity of web server configuration or poor application
    support.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的使用通常是一种全有或全无的事情，这意味着由于网络服务器配置的复杂性或应用支持不佳，不支持混合模式认证和为非证书用户提供支持。
- en: The use of certificates may not be well supported by all users in your user
    population, including the ones who use mobile devices.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的使用可能不会得到您用户群体中所有用户的良好支持，包括使用移动设备的用户。
- en: The correct configuration of the infrastructure required to support certificate-based
    authentication may require advanced IT knowledge.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确配置支持基于证书的认证所需的基础设施可能需要高级IT知识。
- en: As you can see, there are both benefits and drawbacks to client certificate
    authentication. When implemented correctly, it can be a very convenient mode of
    access for your users and has extremely attractive security and non-repudiation
    properties. You will need to determine your particular situation to see whether
    or not this type of authentication is appropriate.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，客户端证书认证既有优点也有缺点。当正确实施时，它可以成为用户非常方便的访问模式，并且具有非常吸引人的安全和不可否认属性。你需要确定你的具体情况，看看这种认证方式是否合适。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the architecture, flow, and Spring Security support
    for client certificate-based authentication. We have covered the concepts and
    overall flow of client certificate (mutual) authentication. We explored the important
    steps required to configure Apache Tomcat for a self-signed SSL and client certificate
    scenario.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基于客户端证书的认证的架构、流程和Spring Security支持。我们涵盖了客户端证书（相互）认证的概念和整体流程。我们探讨了配置Apache
    Tomcat以实现自签名SSL和客户端证书场景所需的重要步骤。
- en: We also learned about configuring Spring Security to understand certificate-based
    credentials presented by clients. We covered the architecture of Spring Security
    classes related to certificate authentication. We also know how to configure a
    Spring bean-style client certificate environment. We also covered the pros and
    cons of this type of authentication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何配置Spring Security以了解客户端提供的基于证书的凭证。我们涵盖了与证书认证相关的Spring Security类架构。我们还知道了如何配置Spring
    bean风格的客户端证书环境。我们还讨论了这种认证方式的优缺点。
- en: It’s quite common for developers unfamiliar with client certificates to be confused
    by many of the complexities of this type of environment. We hope that this chapter
    has made this complicated subject a bit easier to understand and implement!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉客户端证书的开发者来说，这种环境中的许多复杂性可能会让他们感到困惑。我们希望这一章能让这个复杂主题更容易理解和实施！
- en: In the next chapter, we will discuss **Open Authorization** (**OAuth 2**) protocol
    and how you can accomplish single sign-on with **OpenID** **Connect** (**OIDC**).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论**开放授权**（**OAuth 2**）协议以及如何使用**OpenID** **连接**（**OIDC**）实现单点登录。
- en: 'Part 3: Exploring OAuth 2 and SAML 2'
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：探索OAuth 2和SAML 2
- en: This part focuses on OAuth 2, which is a widely adopted method for trusted identity
    management, empowering users to centrally manage their identities through a single
    trusted provider. Users benefit from the convenience of securely storing their
    passwords and personal information with the trusted OAuth 2 provider while retaining
    the option to disclose personal information as needed. Websites implementing OAuth
    2 authentication can trust that users presenting OAuth 2 credentials are authenticated
    individuals.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分重点介绍OAuth 2，这是一种广泛采用的可信身份管理方法，使用户能够通过单个可信提供者集中管理他们的身份。用户可以从使用可信的OAuth 2提供者安全存储他们的密码和个人信息中受益，同时保留在需要时披露个人信息的选项。实施OAuth
    2身份验证的网站可以信任展示OAuth 2凭证的用户是经过身份验证的个人。
- en: In the exploration of SAML 2 support, we delve into the intricacies of integrating
    **Security Assertion Markup Language** (**SAML 2.0**) into Spring Security applications.
    SAML 2.0, an XML-based standard, facilitates the exchange of authentication and
    authorization data between **Identity Providers** (**IdP**) and **Service Providers**
    (**SP**), offering seamless integration within Spring Security frameworks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索SAML 2支持的过程中，我们深入探讨了将**安全断言标记语言**（**SAML 2.0**）集成到Spring Security应用程序的复杂性。SAML
    2.0是一种基于XML的标准，它促进了**身份提供者**（**IdP**）和**服务提供者**（**SP**）之间认证和授权数据的交换，在Spring Security框架内提供无缝集成。
- en: 'This part has the following chapters:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B21757_09.xhtml#_idTextAnchor295), *Opening* *up* *to OAuth 2*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21757_09.xhtml#_idTextAnchor295), *开启OAuth 2*'
- en: '[*Chapter 10*](B21757_10.xhtml#_idTextAnchor314), *SAML 2 Support*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21757_10.xhtml#_idTextAnchor314), *SAML 2支持*'
