- en: MicroProfile OpenAPI and Type-Safe REST Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI和类型安全的REST客户端
- en: Eclipse MicroProfile has a rich set of specifications for Java microservices.
    Two of these, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client,
    help with the API documentation for your microservices and provide an API for
    type-safe invocation on REST endpoints, respectively. OpenAPI simplifies the documentation
    for microservice endpoints and makes this metadata available for perusal by third-party
    developers. A type-safe REST client simplifies the marshalling and unmarshalling
    of objects to HTTP or JSON.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile为Java微服务提供了一系列丰富的规范。其中两个，Eclipse MicroProfile OpenAPI和Eclipse
    MicroProfile REST Client，分别帮助您微服务的API文档化，并为REST端点提供类型安全的调用API。OpenAPI简化了微服务端点的文档化，并使此元数据可供第三方开发者查阅。类型安全的REST客户端简化了对象到HTTP或JSON的编解码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The capabilities offered by each of these specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个这些规范提供的能力。
- en: Simple code examples of some of these capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些这些能力的简单代码示例
- en: How to obtain further information about each of these specifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取关于这些规范的更多信息
- en: Introduction to MicroProfile OpenAPI and its capabilities
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI及其能力的介绍
- en: The mobile force that fuels the digital economy led to the need for businesses
    to establish an omni-channel approach to development in order to optimize costs,
    increase efficiencies, and improve customer experience. A facilitator of this
    approach was APIs, which led to the API economy and concepts such as API-led or
    API-first development practices. In addition, the microservices architecture has
    become the architecture of choice for modern development. API-based (that is,
    RESTful) communication among microservices has been adopted as the *de facto*
    standard because it is a good fit for the *smart endpoints and dumb pipes*, *decentralized
    governance*, and *decentralized data management* characteristics of microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 推动数字经济的移动力量导致企业需要建立一个全渠道开发方法，以优化成本、提高效率和改善客户体验。这种方法的促进者是API，这导致了API经济和API引导或API优先的开发实践等概念。此外，微服务架构已成为现代开发的架构选择。微服务之间的API（即RESTful）通信已被采用为事实上的标准，因为它与微服务的*智能端点和大管道*、*去中心化治理*和*去中心化数据管理*特征相契合。
- en: However, as the number of microservices increases in a microservices architecture,
    their management can become unwieldy. However, you can manage your microservices
    via their APIs. You can apply management, security, load balancing, and throttling
    policies to the APIs that are fronting your microservices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着微服务数量的增加，微服务架构的管理可能会变得难以控制。然而，您可以通过API管理您的微服务。您可以将管理、安全、负载均衡和节流策略应用于面向您的微服务的API。
- en: 'Eclipse MicroProfile OpenAPI provides Java interfaces to developers for generating
    OpenAPI v3 documents from their Java RESTful Web Services (JAX-RS) applications.
    The specification requires that a fully processed OpenAPI document be available
    at the root URL, `/openapi`, as an HTTP `GET` operation, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile OpenAPI为开发者提供Java接口，用于从他们的Java RESTful Web Services (JAX-RS)应用程序生成OpenAPI
    v3文档。规范要求在根URL `/openapi` 上提供一个完全处理的OpenAPI文档，作为HTTP `GET`操作，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The required protocol is `http`. However, implementors of the specification
    are strongly encouraged to also support the `https` protocol for secure connectivity
    to the OpenAPI endpoint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的协议是`http`。然而，规范的实现者强烈鼓励也支持`https`协议，以便安全地连接到OpenAPI端点。
- en: 'There are three sources from which the OpenAPI document is created. These three
    sources (described in later sections in this chapter) are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI文档是从以下三个来源创建的。这三个来源（在本章后面的部分中介绍）如下：
- en: Generated by processing the JAX-RS annotations (and optional OpenAPI annotations)
    found in the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理应用程序中发现的JAX-RS注解（和可选的OpenAPI注解）生成。
- en: Programmatically built by an application by providing a Java class that implements
    `OasModelReader`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供一个实现`OasModelReader`的Java类，应用程序程序化地构建。
- en: A static OpenAPI document included in application deployment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序部署中包含的静态OpenAPI文档。
- en: These three sources (any combination) are combined to produce a single OpenAPI
    document, which can be filtered (by providing a Java class that implements the
    `OasFilter` interface) and then served at the preceding `/openapi` endpoint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个来源（任意组合）结合产生一个OpenAPI文档，该文档可以通过提供实现`OasFilter`接口的Java类进行过滤，然后在前面的`/openapi`端点提供服务。
- en: Configuration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: The MicroProfile OpenAPI specification makes use of the MicroProfile configuration
    specification to configure its parameters and values. For example, for injecting
    configuration values, MicroProfile OpenAPI can use the default and custom ConfigSources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI规范利用MicroProfile配置规范来配置其参数和值。例如，用于注入配置值，MicroProfile OpenAPI可以使用默认和自定义ConfigSources。
- en: For more information on ConfigSources, you can visit [https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ConfigSources的更多信息，你可以访问[https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc)。
- en: 'There are many configurable items. The following table contains a subset of
    them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可配置的项目。以下表格包含它们的子集：
- en: '| **Configuration item** | **Description** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **配置项** | **描述** |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mp.openapi.scan.di sable` | Configuration property to disable annotation
    scanning. The default value is `false`. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `mp.openapi.scan.disable` | 禁用注解扫描的配置属性。默认值是`false`。 |'
- en: '| `mp.openapi.servers` | Configuration property to specify the list of global
    servers that ... |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `mp.openapi.servers` | 指定全局服务器列表的配置属性，用于... |'
- en: Generating the OpenAPI document
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成OpenAPI文档
- en: As already described, the MicroProfile OpenAPI specification requires that an
    OpenAPI document be generated from a combination of three sources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MicroProfile OpenAPI规范要求从三个来源的组合生成OpenAPI文档。
- en: 'You then have a number of choices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有几个选择：
- en: Extend the OpenAPI document generated by the JAX-RS annotations using the MicroProfile
    OpenAPI annotations.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile OpenAPI注解扩展由JAX-RS注解生成的OpenAPI文档。
- en: Leverage the initial output from `/openapi`, which you can use as a reference
    to start documenting your APIs. In this case, you can write static OpenAPI files
    (described in a later section in this chapter) before any code is written, which
    is a usual approach adopted by organizations to lock-in the contract of the API,
    that is, it is an API-first development practice.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用从`/openapi`的初始输出，你可以将其作为参考开始记录你的API。在这种情况下，你可以在编写任何代码之前编写静态OpenAPI文件（在本章后面的部分介绍），这是组织通常采用的方法来锁定API的合同，即它是API优先的开发实践。
- en: Bootstrap or complete the OpenAPI model tree by coding using the programming
    model, covered later in this chapter.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编程使用编程模型来启动或完成OpenAPI模型树。这部分内容将在本章后面介绍。
- en: Additionally, you can use a filter to update the OpenAPI model after it has
    been built.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用一个过滤器在构建OpenAPI模型后更新它。
- en: MicroProfile OpenAPI annotations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI注解
- en: Probably the most common source of OpenAPI information is the set of annotations
    that make up the definition of a standard JAX-RS application. These annotations,
    along with additional (optional) annotations defined by the MicroProfile OpenAPI
    specification, can be scanned and processed by the MicroProfile platform to produce
    an OpenAPI document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是OpenAPI信息最常见来源的是组成标准JAX-RS应用程序定义的一组注解。这些注解，加上由MicroProfile OpenAPI规范定义的额外（可选）注解，可以被MicroProfile平台扫描和处理，以产生一个OpenAPI文档。
- en: The MP OpenAPI specification requires the generation of a valid OpenAPI document
    from pure JAX-RS 2.0 applications. If you are new to OpenAPI, you can simply deploy
    your existing JAX-RS application to a MicroProfile OpenAPI runtime and check out
    the output from `/openapi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MP OpenAPI规范要求从纯JAX-RS 2.0应用程序生成有效的OpenAPI文档。如果你对OpenAPI不熟悉，你可以简单地将你的现有JAX-RS应用程序部署到MicroProfile
    OpenAPI运行时，并查看`/openapi`的输出。
- en: To fill out additional details of the generated OpenAPI document, you may further
    annotate your ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填写生成的OpenAPI文档的额外详细信息，你可以进一步注解你的...
- en: Usage examples
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Some usage examples of MicroProfile OpenAPI annotations are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MicroProfile OpenAPI注解的一些使用示例：
- en: 'Example 1 – Simple operation description (abbreviated):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1 – 简单操作描述（缩写）：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output for example 1:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例1的输出：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Example 2 – Operation with different responses (abbreviated):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2 – 具有不同响应的操作（简化）：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output for example 2:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例2的输出：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more examples, please refer to the MicroProfile OpenAPI specification wiki
    at [https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，请参考MicroProfile OpenAPI规范的wiki页面：[https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki)。
- en: Static OpenAPI files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态OpenAPI文件
- en: As mentioned earlier in the chapter, static OpenAPI files are one of the three
    sources from which the OpenAPI document can be created. In the following, we give
    you a short introductory description of how you could generate one and how to
    include it in your deployment. Many organizations use an API-first development
    practice, which entails defining static OpenAPI files even before any code is
    implemented for them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，静态OpenAPI文件是创建OpenAPI文档的三个来源之一。在下面，我们给你一个简短的介绍，告诉你如何生成一个以及如何将其包含在你的部署中。许多组织使用API优先的开发实践，这涉及到在为它们实现任何代码之前，甚至定义静态OpenAPI文件。
- en: 'First, you can create an OpenAPI document by using an open source editor such
    as Swagger Editor ([https://editor.swagger.io](https://editor.swagger.io)). The
    following is a screenshot shows this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过使用开源编辑器如Swagger Editor（[https://editor.swagger.io](https://editor.swagger.io)）来创建一个OpenAPI文档。下面是一个显示这个过程的屏幕截图：
- en: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
- en: Using this editor, you can start with sample ...
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个编辑器，你可以从样本...开始。
- en: Programming model
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程模型
- en: You can provide OpenAPI elements via Java POJOs (Plain Old Java Objects) by
    using the MicroProfile OpenAPI programming model. The complete set of models is
    described in the `org.eclipse.microprofile.openapi.models` package. You can read
    more about it at [https:](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)[//github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用MicroProfile OpenAPI编程模型，通过Java POJOs（Plain Old Java Objects）提供OpenAPI元素。完整的模型集在`org.eclipse.microprofile.openapi.models`包中描述。你可以在[https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)了解更多。
- en: 'You can create an OpenAPI tree by using `OASFactory`. Refer to the following
    code block by way of an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`OASFactory`创建一个OpenAPI树。以下是一个示例的代码块：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To bootstrap the OpenAPI model tree, you can use the `OASModelReader` interface.
    You can then create an implementation of this interface and register it using
    the `mp.openapi.model.reader` configuration key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引导OpenAPI模型树，你可以使用`OASModelReader`接口。然后，你可以创建这个接口的一个实现，并使用`mp.openapi.model.reader`配置键进行注册。
- en: 'The following is globally an example of what its definition would look like
    in `META-INF/microprofile-config.properties`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全局地在`META-INF/microprofile-config.properties`中它的定义示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like static files, the model reader can be used to provide either complete or
    partial model trees. To provide a complete OpenAPI model tree, you should set
    the `mp.openapi.scan.disable` configuration to `true`. Otherwise, this partial
    model will be assumed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态文件类似，模型读取器可以用来提供完整的或部分的模型树。要提供一个完整的OpenAPI模型树，你应该将`mp.openapi.scan.disable`配置设置为`true`。否则，将假设这是部分模型。
- en: Using a filter for updates
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器进行更新
- en: To update or remove certain elements and fields of the OpenAPI document, you
    can use a filter. The OASFilter ([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))
    interface allows you to receive callbacks for various OpenAPI elements. It allows
    you to override the methods you care about. You can create an implementation of
    this interface and register it using the `mp.openapi.filter` configuration key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新或删除OpenAPI文档的某些元素和字段，你可以使用一个过滤器。OASFilter([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))接口允许你为各种OpenAPI元素接收回调。它允许你覆盖你关心的方法。你可以创建这个接口的一个实现，并使用`mp.openapi.filter`配置键来注册它。
- en: 'Here''s an example of what its definition would look like in `META-INF/microprofile-config.properties`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在`META-INF/microprofile-config.properties`中其定义的样子：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A registered filter is called once for each model element. For example, the
    `filterPathItem` method is ...
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 已注册的过滤器对每个模型元素调用一次。例如，`filterPathItem`方法是...
- en: Introduction to the MicroProfile REST Client and its capabilities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MicroProfile REST Client及其功能
- en: The **MicroProfile REST Client** (**MP-RC**) provides an API for type-safe invocation
    on REST endpoints. It can be used from applications to perform remote invocations
    on other services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile REST Client**（**MP-RC**）提供了一个API，用于对REST端点的类型安全调用。它可以被应用程序用来执行对其他服务的远程调用。'
- en: It leverages JAX-RS annotations on Java interfaces to describe the actual contract
    with remotes services. These interfaces are then used to create client proxies
    that hide much of the underlying HTTP communication.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它利用Java接口上的JAX-RS注解来描述与远程服务实际的合同。这些接口随后被用来创建客户端代理，隐藏了大部分底层的HTTP通信。
- en: The MP-RC specification defines the requirements for leveraging the JAX-RS annotations
    on the Java interface, as well as MP-RC-specific annotations to augment behavior,
    including how incoming request headers should be propagated, how to augment JAX-RS
    behaviors using providers, exception mapping, CDI support, and integration with
    other MicroProfile specifications. We will look at MP-RC in more detail by starting
    with the definition of a type-safe endpoint interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC规范定义了在Java接口上使用JAX-RS注解的要求，以及MP-RC特定的注解来增强行为，包括如何传播进入请求头，如何使用提供者增强JAX-RS行为，异常映射，CDI支持，与其他MicroProfile规范的集成。我们从定义一个类型安全的端点接口开始，更详细地查看MP-RC。
- en: Defining the endpoint Interface
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义端点接口
- en: 'To define the type-safe interface for an endpoint, we create a Java interface
    that leverages JAX-RS annotations to map interface methods to the REST endpoint
    they proxy. A basic example is illustrated in the following `WorldClockApi` interface:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义一个类型安全的端点接口，我们创建一个Java接口，利用JAX-RS注解将接口方法映射到它们代理的REST端点。一个基本的示例在下述的`WorldClockApi`接口中说明：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: MicroProfile REST Client programmatic API usage
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile REST Client编程API使用
- en: 'MP-RC supports both programmatic lookup and CDI injection approaches for usage.
    An example of a REST service making use of `org.eclipse.microprofile.rest.client.RestClientBuilder`
    to create a type-safe client for the `WorldClockApi` interface is listed in the
    following as `WorldClockUser.java`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC支持编程查找和CDI注入两种使用方法。以下是一个使用`org.eclipse.microprofile.rest.client.RestClientBuilder`的REST服务示例，它创建了一个类型安全的客户端，用于`WorldClockApi`接口，作为`WorldClockUser.java`列出：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `baseUri()` method is used to specify the server URI against which the
    `WorldClockApi` method paths are to be resolved. The `build()` method takes the
    Java interface of the type-safe client that is to be built. Additional `RestClientBuilder`
    methods include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseUri()`方法用于指定与`WorldClockApi`方法路径解析相对的服务器URI。`build()`方法接收要构建的类型安全客户端的Java接口。`RestClientBuilder`的其他方法包括以下内容：'
- en: '`baseUrl(URL)`: Similar to `baseUri`, but takes a `java.net.URL` type.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseUrl(URL)`：与`baseUri`类似，但接受`java.net.URL`类型。'
- en: '`connectTimeout(long timeout, TimeUnit unit)`: The amount of time to wait to
    connect to the remote server. A value of 0 indicates having to wait forever.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectTimeout(long timeout, TimeUnit unit)`：等待连接到远程服务器的时长。值为0表示需要无限等待。'
- en: '`readTimeout(long timeout, TimeUnit unit)`: The amount of time to wait on reads
    of the remote server connection. A value of 0 indicates having to wait forever.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readTimeout(long timeout, TimeUnit unit)`：在远程服务器连接的读取上等待的时间量。0的值表示需要无限等待。'
- en: '`executorService(ExecutorService executor)`: Used for async requests. We will
    return to this in the async section.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executorService(ExecutorService executor)`：用于异步请求。我们将在异步部分回到这个。'
- en: MicroProfile REST Client CDI usage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile REST Client CDI使用
- en: 'MP-RC type-safe interfaces may be injected as CDI beans. The runtime must create
    a CDI bean for each interface annotated with `@RegisterRestClient`. A CDI client
    injects bean created will include a qualifier, `@RestClient` , to differentiate
    use as an MP-RC injection point. The following update to our `WorldClockApi` interface
    illustrates the use of the `@RegisterRestClient` annotation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC类型安全的接口可以作为CDI bean注入。运行时必须为每个用`@RegisterRestClient`注解标记的接口创建一个CDI bean。CDI客户端注入创建的bean将包括一个限定符，`@RestClient`，以区分作为MP-RC注入点的使用。以下是我们`WorldClockApi`接口的更新示例，使用了`@RegisterRestClient`注解：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: MicroProfile Config integration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Config集成
- en: 'For CDI-defined interfaces, it is possible to use MicroProfile Config properties
    to define additional behaviors that are available via the `RestClientBuilder`
    API. Given our `io.pckt.restc.contract.WorldClockApi` interface, the following
    MicroProfile Config properties are available to control the generated proxy behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CDI定义的接口，可以使用MicroProfile Config属性来定义通过`RestClientBuilder` API可用的附加行为。给定我们的`io.pckt.restc.contract.WorldClockApi`接口，以下MicroProfile
    Config属性可用于控制生成的代理行为：
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`: The base URL to use for
    this service, the equivalent of the `RestClientBuilder#baseUrl` method.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`：用于此服务的基URL，相当于`RestClientBuilder#baseUrl`方法。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`: The fully qualified class
    name to a CDI scope to use for injection; it defaults to `javax.enterprise.context.Dependent`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`：用于注入的CDI作用域的全限定类名；默认为`javax.enterprise.context.Dependent`。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`: A comma-separated
    list of fully qualified provider class names to include in the client, the equivalent
    of the `RestClientBuilder#register` method or the `@RegisterProvider` annotation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`：一个由逗号分隔的全限定提供者类名列表，用于包含在客户端中，相当于`RestClientBuilder#register`方法或`@RegisterProvider`注解。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`:
    This will override the priority of the `com.mycompany.MyProvider` provider for
    this interface.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`：这将覆盖`com.mycompany.MyProvider`提供者在此接口上的优先级。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`: The timeout
    specified in milliseconds to wait to connect to the remote endpoint.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`：等待连接到远程端点的超时时间，以毫秒为单位。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`: The timeout specified
    in milliseconds to wait for a response from the remote endpoint.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`：等待远程端点响应的超时时间，以毫秒为单位。'
- en: Simplifying configuration keys
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化配置键
- en: 'Since the default MP Config property names for a CDI interface can be quite
    long due to the inclusion of the interface package name, the MP-RC specification
    supports a way to simplify the property name prefix using the `configKey` attribute
    of the `@RegisterRestClient` annotation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的MP Config属性名由于包含接口包名而可能较长，MP-RC规范支持使用`@RegisterRestClient`注解的`configKey`属性来简化属性名前缀：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the `worldClock` configKey, the previous list of property names simplifies
    to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`worldClock`配置键，之前的属性名列表简化为以下内容：
- en: '`worldClock/mp-rest/url`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/url`'
- en: '`worldClock/mp-rest/uri`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/uri`'
- en: '`worldClock/mp-rest/scope`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/scope`'
- en: '`worldClock/mp-rest/providers`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/providers`'
- en: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
- en: Dealing with client headers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理客户端头
- en: Let's say you want to specify credentials in the HTTP authorization header to
    a secure remote service, but you do not want to have a string `authHeader` parameter
    in the client interface method. The MP-RC `@ClientHeaderParam` annotation can
    be used to specify HTTP headers that should be sent without altering the client
    interface method signature.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要在HTTP授权头中为安全的远程服务指定凭据，但不想在客户端接口方法中有一个`authHeader`字符串参数。MP-RC的`@ClientHeaderParam`注解可以用来指定应该发送而不改变客户端接口方法签名的HTTP头部。
- en: 'The following example illustrates two uses of the `@ClientHeaderParam` annotation
    to provide a `User-Agent` HTTP header in a variation of the `WorldClockApi` interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用`@ClientHeaderParam`注解提供`User-Agent` HTTP头的`WorldClockApi`接口的两种用法：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also possible to add or propagate headers in bulk using a `ClientHeadersFactory`
    implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`ClientHeadersFactory`实现批量添加或传播头部：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, the `incomingHeaders` and `clientOutgoingHeaders`
    parameters are used as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`incomingHeaders`和`clientOutgoingHeaders`参数的使用方式如下：
- en: '`incomingHeaders`: Represents the map of headers for the inbound request'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incomingHeaders`：表示入站请求的头部映射'
- en: '`clientOutgoingHeaders`: Represents the read-only map of header values specified
    on the client interface, the union of header values from `@ClientHeaderParam`,
    `@HeaderParam`, and so on'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientOutgoingHeaders`：代表在客户端接口上指定的只读头部值映射，是`@ClientHeaderParam`、`@HeaderParam`等头部值的并集'
- en: The `update` method should return a `MultivaluedMap` that contains the headers
    to merge with the `clientOutgoingHeaders` map for the complete map of headers
    to be sent to the outbound request. Providers such as filters, interceptors, and
    message body writers could still modify the final map of headers prior to sending
    the HTTP request.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法应该返回一个`MultivaluedMap`，其中包含要与`clientOutgoingHeaders`映射合并的头部，以便将完整的头部映射发送到出站请求。提供者（如过滤器、拦截器和消息体写入器）仍然可以在发送HTTP请求之前修改最终的头部映射。'
- en: To enable a `ClientHeadersFactory`, the client interface must be annotated with
    the `@RegisterClientHeaders` annotation. If this annotation specifies a value,
    the client implementation must invoke an instance of the specified `ClientHeadersFactory`
    implementation class. If no value is specified, then the client implementation
    must invoke `DefaultClientHeadersFactoryImpl`. This default factory will propagate
    specified headers from the inbound JAX-RS request to the outbound request – these
    headers are specified with a comma-separated list using the MicroProfile Config
    property, `org.eclipse.microprofile.rest.client.propagateHeaders`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`ClientHeadersFactory`，客户端接口必须用`@RegisterClientHeaders`注解标注。如果此注解指定了一个值，客户端实现必须调用指定`ClientHeadersFactory`实现类的实例。如果没有指定值，那么客户端实现必须调用`DefaultClientHeadersFactoryImpl`。这个默认工厂将把从入站JAX-RS请求中指定的头部传播到出站请求——这些头部是用逗号分隔的列表在MicroProfile
    Config属性`org.eclipse.microprofile.rest.client.propagateHeaders`中指定的。
- en: Provider registration for advanced usage
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级用法的提供商注册
- en: The `RestClientBuilder` interface extends the `Configurable` interface from
    JAX-RS, allowing a user to register custom providers while it is being built.
    The behavior of the providers supported is defined by the JAX-RS Client API specification.
    An MP-RC implementation will support `ClientResponseFilter`, `ClientRequestFilter`,
    `MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ReaderInterceptor`,
    and `WriterInterceptor` from JAX-RS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestClientBuilder`接口扩展了来自JAX-RS的`Configurable`接口，允许用户在构建过程中注册自定义提供商。支持的提供者的行为由JAX-RS客户端API规范定义。MP-RC实现将支持JAX-RS的`ClientResponseFilter`、`ClientRequestFilter`、`MessageBodyReader`、`MessageBodyWriter`、`ParamConverter`、`ReaderInterceptor`和`WriterInterceptor`。'
- en: For the `ClientResponseFilter` and `ClientRequestFilter` interfaces that have
    a `ClientRequestContext` parameter in their `filter` method, MP-RC implementations
    add an `org.eclipse.microprofile.rest.client.invokedMethod` property, the value
    of which is the `java.lang.reflect.Method` object ...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`ClientRequestContext`参数的`filter`方法的`ClientResponseFilter`和`ClientRequestFilter`接口，MP-RC实现添加了一个名为`org.eclipse.microprofile.rest.client.invokedMethod`的属性，其值是一个`java.lang.reflect.Method`对象...
- en: Provider priority
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供商优先级
- en: Providers may be registered via both annotations and `RestClientBuilder`. Providers
    registered via a builder will take precedence over the `@RegisterProvider` annotation.
    The `@RegisterProvider` annotation priority value takes precedence over any `@javax.annotation.Priority`
    annotation on the class. Provider priorities can be overridden when using the
    register methods on the `RestClientBuilder` interface as it allows for priority.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者可以通过注解和`RestClientBuilder`进行注册。通过构建器注册的提供者将优先于`@RegisterProvider`注解。`@RegisterProvider`注解的优先级值优先于类上的任何`@javax.annotation.Priority`注解。使用`RestClientBuilder`接口上的注册方法可以覆盖提供者优先级，因为它允许优先级设置。
- en: Feature registration
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性注册
- en: If the type of provider registered is a JAX-RS `Feature`, then the priority
    set by that `Feature` will be part of the builder as well. Implementations maintain
    the overall priority of registered providers, regardless of how they are registered.
    `Feature` will be used to register additional providers at runtime, and may be
    registered via `@RegisterProvider`, configuration, or via `RestClientBuilder`.
    `Feature` will be executed immediately. As a result, its priority is not taken
    into account (features are always executed).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册的提供者类型是JAX-RS`特性`，那么该`特性`设置的优先级也将作为构建器的一部分。实现维护注册提供者的总体优先级，无论它们是如何注册的。`特性`用于在运行时注册附加提供者，可以通过`@RegisterProvider`、配置或通过`RestClientBuilder`进行注册。`特性`将立即执行。因此，不考虑其优先级（特性总是执行）。
- en: Default providers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认提供者
- en: 'MP-RC implementations must provide a minimum set of providers, including the
    following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC实现必须提供一组最小提供者，包括以下内容：
- en: '`*/json` types:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*/json`类型：'
- en: JSON-P, `javax.json.JsonValue`
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P, `javax.json.JsonValue`
- en: JSON-B, `javax.json.bind`
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-B, `javax.json.bind`
- en: '`*` types:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`类型：'
- en: '`byte[]`'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`'
- en: '`java.lang.String`'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`'
- en: '`java.io.InputStream`'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.InputStream`'
- en: '`java.io.Reader`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.Reader`'
- en: '`text/plain` types:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/plain`类型：'
- en: '`java.lang.Number and subtypes`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Number和其子类型`'
- en: '`int, long, float and double`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int, long, float和double`'
- en: '`java.lang.Character and char`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character和char`'
- en: '`java.lang.Boolean and boolean`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Boolean和boolean`'
- en: Exception mapping
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常映射
- en: 'MP-RC provides support for mapping an invocation response into an exception
    via the `org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper` interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC为通过`org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper`接口将调用响应映射到异常提供支持：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Consider the following ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况...
- en: Default exception mapping
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认异常映射
- en: 'Each implementation provides a default `ResponseExceptionMapper` implementation
    that will map and invoke a response to `javax.ws.rs.WebApplicationException` when
    the response status code is >= 400\. It has a priority of `Integer.MAX_VALUE`,
    and is meant to be used as a fallback whenever an error is encountered. This mapper
    will be registered by default to all client interfaces, but this can be disabled
    by setting an MP Config property, `microprofile.rest.client.disable.default.mapper`,
    to `true`. It can also be disabled on a per-client basis by using the same property
    when building the client:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现提供了一个默认的`ResponseExceptionMapper`实现，当响应状态码 >= 400时，它会将响应映射并调用`javax.ws.rs.WebApplicationException`。它的优先级为`Integer.MAX_VALUE`，旨在用作遇到错误时的回退。此映射器默认注册到所有客户端接口，但可以通过将MP配置属性`microprofile.rest.client.disable.default.mapper`设置为`true`来禁用它。它还可以通过在构建客户端时使用相同属性来在每个客户端上禁用：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Async support
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步支持
- en: 'MP-RC supports asynchronous method invocations. A client interface method is
    asynchronous when the return type of the method is of the `java.util.concurrent.CompletionStage<?>`
    type. An alternative version, called `WorldClockApiAsync.java`, of the `WorldClockApi`
    interface that declares an asynchronous method is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC支持异步方法调用。当客户端接口方法返回类型为`java.util.concurrent.CompletionStage<?>`类型时，该方法是异步的。`WorldClockApi`接口的异步方法声明的替代版本，称为`WorldClockApiAsync.java`，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about two Eclipse MicroProfile specifications,
    namely, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client. The
    former provides a specification for generating OpenAPI-compliant documentation
    for your microservices, and the latter supplies a specification for calling REST
    endpoints in a type-safe manner. In this chapter, we covered the specific capabilities
    of these specifications, provided some example code, and supplied pointers on
    how to get further information about these specifications. You have learned the
    features and capabilities of the Eclipse MicroProfile OpenAPI and Eclipse MicroProfile
    REST Client specifications, how to use their annotations and programmatic interfaces,
    and how you could incorporate them into your applications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了两个Eclipse MicroProfile规范，分别是Eclipse MicroProfile OpenAPI和Eclipse MicroProfile
    REST Client。前者提供了一个规范，用于生成符合OpenAPI的微服务文档，后者提供了一个规范，用于以类型安全的方式调用REST端点。在本章中，我们介绍了这些规范的具体功能，提供了一些示例代码，并指出了如何获取关于这些规范的更多信息。您已经学习了Eclipse
    MicroProfile OpenAPI和Eclipse MicroProfile REST Client规范的功能和能力，如何使用它们的注解和程序化接口，以及如何将它们集成到您的应用程序中。
- en: In the next chapter, we will discuss and delve into the open source implementations
    of Eclipse MicroProfile that currently exist on the market.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并深入研究市场上目前存在的Eclipse MicroProfile的开源实现。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do you need to do anything to get information supplied to the `/openapi` endpoint?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要对提供给`/openapi`端点的信息做任何事情吗？
- en: Can I enhance OpenAPI output with just one or two extra annotations?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我能否仅通过添加一两个额外的注解来增强OpenAPI输出？
- en: What is the point of using static OpenAPI files?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态OpenAPI文件有什么意义？
- en: Do I need the REST endpoint microservice I want to use to provide the MP-REST
    interface?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我是否需要我想要使用的REST端点微服务来提供MP-REST接口？
- en: How do you externalize the base URL for a type-safe interface?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何为类型安全的接口外部化基础URL？
- en: What if I need to propagate incoming request headers?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要传播传入请求头，该怎么办？
