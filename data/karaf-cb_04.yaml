- en: Chapter 4. Hosting a Web Server with Pax Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用Pax Web托管Web服务器
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing Pax modules in Apache Karaf
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装Pax模块
- en: Installing extended Http Service in Apache Karaf
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装扩展Http服务
- en: Configuring Pax Web modules deployed in Apache Karaf
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中配置部署的Pax Web模块
- en: Building a Http Service project to host in Apache Karaf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可在Apache Karaf中托管的Http服务项目
- en: Building a Http Service with the Whiteboard pattern in Apache Karaf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中使用白板模式构建Http服务
- en: Building an application with custom HttpContext with Apache Karaf
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Karaf自定义HttpContext构建应用程序
- en: Building a standard web project to host in Apache Karaf
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中构建一个标准Web项目以托管
- en: Configuring security for a web application in Apache Karaf
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中配置Web应用程序的安全
- en: Binding a web project to a specific host in Apache Karaf
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中将Web项目绑定到特定主机
- en: Building a Servlet 3.0 annotated web application with Apache Karaf
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Karaf构建带有Servlet 3.0注解的Web应用程序
- en: Creating a CDI web application with Apache Karaf
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Karaf创建CDI Web应用程序
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter explains how to enhance your Apache Karaf with Pax Web to serve
    as a web container. The OPS4j Pax Web project is an OSGi R4 Http Service and Web
    Application (refer to *Chapter 128*, *OSGi Enterprise Release 4*) implementation.
    It extends the Http Service with better support for servlet, filters, listeners,
    error pages, JavaServer Pages (JSPs), and more in order to support the latest
    Java Servlet spec.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何通过Pax Web增强您的Apache Karaf以作为Web容器。OPS4j Pax Web项目是一个OSGi R4 Http服务和Web应用程序（参考*第128章*，*OSGi企业发布4*）的实现。它通过更好的servlet、过滤器、监听器、错误页面、JavaServer
    Pages（JSPs）等支持扩展Http服务，以支持最新的Java Servlet规范。
- en: 'The standard features of Karaf contain a set of options to install Pax Web
    in different flavors. There are options for:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf的标准功能包含一组选项，用于以不同风味安装Pax Web。有如下选项：
- en: A basic Http Service
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Http服务
- en: An enhanced Http Service with support for the Whiteboard pattern and JSPs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持白板模式和JSPs的增强Http服务
- en: A full-blown web container configuration with support for **Web Application
    Archive** (**WAR**) and **Web Application Bundle** (**WAB**) files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持**Web应用程序存档**（**WAR**）和**Web应用程序包**（**WAB**）文件的完整Web容器配置
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Readers interested in obtaining a deeper understanding of Apache Karaf in combination
    with Pax Web should consult the OPS4j community. You'll find a lot more samples
    concerning the usage of Pax Web in general and Apache Karaf specialties as a whole.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对Apache Karaf和Pax Web结合使用有更深入理解兴趣的读者应咨询OPS4j社区。您将找到更多关于Pax Web通用用法和Apache Karaf特长的示例。
- en: Installing Pax modules in Apache Karaf
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装Pax模块
- en: To start with Http Service, you will need to install one of the features mentioned
    earlier. This recipe will guide you through the installation of the different
    extensions of Pax Web and how it works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Http服务，您需要安装前面提到的功能之一。本食谱将指导您安装Pax Web的不同扩展以及它是如何工作的。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To install the basic Http Service, start your Apache Karaf server and install
    the Http Service feature via the console using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装基本Http服务，启动您的Apache Karaf服务器，并通过控制台使用以下命令安装Http服务功能：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'After installing this feature, list the bundles with an `la` command. This
    will show you the following additional bundles to your Karaf instance:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此功能后，使用`la`命令列出捆绑包。这将向您显示以下附加捆绑包到您的Karaf实例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, it will install the needed Jetty server to serve the web content
    and the four basic Pax Web bundles needed to have a minimal Http Service. These
    four bundles contain the API, Services SPI, runtime, and the Jetty server wrapper,
    which takes care of starting the underlying Jetty instance. All of these bundles
    installed by the HTTP feature give you a few possible ways to use the Http Service,
    but nothing else. This scenario is usually good enough for running simple servlets
    and the Felix Web Console.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它将安装所需的Jetty服务器以服务Web内容，以及四个基本的Pax Web捆绑包，以拥有最小的Http服务。这四个捆绑包包含API、服务SPI、运行时和Jetty服务器包装器，它负责启动底层的Jetty实例。所有这些由HTTP功能安装的捆绑包为您提供了使用Http服务的一些可能方式，但没有其他。这种场景通常足够用于运行简单的servlet和Felix
    Web控制台。
- en: 'On top of this basic installation, Karaf already provides a simple command
    to inspect the currently installed servlets. It will give you an overview of the
    servlets and the registered aliases. The following is the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基本安装之上，Karaf已经提供了一个简单的命令来检查当前安装的servlet。它将为您提供servlet和注册别名的概览。以下是该命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Building a Http Service project to host in Apache Karaf* recipe
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中托管Http Service项目的构建配方
- en: Installing extended Http Service in Apache Karaf
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装扩展的Http服务
- en: Usually, just using the basic Http Service is not enough anymore these days,
    especially when it comes to serving JSP or complete web applications. So, a better
    usable container is needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅仅使用基本的Http服务已经不再足够，尤其是在需要服务JSP或完整的Web应用程序时。因此，需要一个更好用的容器。
- en: How to do it…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To install the HTTP Whiteboard feature, start your Apache Karaf server and
    install the HTTP Whiteboard feature via the console using the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装HTTP白板功能，启动您的Apache Karaf服务器，并通过控制台使用以下命令安装HTTP白板功能：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Transform your Apache Karaf server into a full-featured web container using
    the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将Apache Karaf服务器转换为一个功能齐全的Web容器：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Whiteboard feature installs another two Pax Web bundles. These bundles
    give you JSP and Whiteboard support. These two bundles are shown in the following
    command-line output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 白板功能安装了另外两个Pax Web bundle。这两个bundle为您提供了JSP和白板支持。这两个bundle在以下命令行输出中显示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This enables Pax Web to deploy and serve JSPs registered to the now available
    WebContainer interface. This interface is an extension to the standardized Http
    Service. The Whiteboard extender is another approach to register services in OSGi.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Pax Web能够部署并服务于现在可用的WebContainer接口注册的JSP。该接口是标准化Http Service的扩展。白板扩展器是另一种在OSGi中注册服务的方法。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More details about the Whiteboard pattern can be found at [http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf](http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于白板模式的详细信息可以在[http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf](http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf)找到。
- en: 'With the WAR feature, the installation of Pax Web is complete. This includes
    the WAR extender, which is used to install OSGi WAB files, and the Pax URL WAR
    handler, which takes care of transforming WAR archives into WAB files. These additional
    bundles are listed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WAR功能，Pax Web的安装就完成了。这包括用于安装OSGi WAB文件的WAR扩展器，以及负责将WAR存档转换为WAB文件的Pax URL WAR处理器。以下列出了这些附加的bundle：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the Karaf WAR feature comes another command; the `web:*` commands help
    to analyze the state of the installed WARs. An example command is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf WAR功能带来了另一个命令；`web:*`命令有助于分析已安装WAR的状态。以下是一个示例命令：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These commands also help to control the status of a web bundle. Consider the
    following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令也有助于控制web bundle的状态。考虑以下命令：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `web:list` command shows a list of the installed WAR files and gives a listing
    of the state and `Web-ContextPath`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`web:list`命令显示已安装WAR文件列表，并列出状态和`Web-ContextPath`。'
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Building a Http Service with the Whiteboard pattern in Apache Karaf* recipe
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中使用白板模式构建Http Service的配方
- en: The *Building a standard web project to host in Apache Karaf* recipe
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中托管标准Web项目的构建配方
- en: For more details on how the WAR URL handler works, visit [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于WAR URL处理器如何工作的详细信息，请访问[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4)
- en: Configuring Pax Web modules deployed in Apache Karaf
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置在Apache Karaf中部署的Pax Web模块
- en: Pax Web uses Jetty as the underlying web container. The OSGi Http Service specification
    defines a set of parameters for configuration of the Http Service. In addition
    to these standard configuration parameters, the Pax Web-specific parameters are
    configurable. On top of those configuration parameters, it's also possible to
    configure Jetty itself for further needs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web使用Jetty作为底层的Web容器。OSGi Http Service规范定义了一组用于配置Http服务的参数。除了这些标准配置参数之外，Pax
    Web特定的参数也是可配置的。在这些配置参数之上，还可以根据进一步的需求配置Jetty本身。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The configuration of the Http Service is done through the Configuration Admin
    service. During the installation of the Http Service, the configuration is also
    set for the service PID `org.ops4j.pax.web`, as shown in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Http Service 的配置是通过配置管理服务完成的。在安装 Http Service 期间，配置也会为服务 PID `org.ops4j.pax.web`
    设置，如下代码片段所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This basic set of configuration defines the HTTP port the Jetty server is listening
    to, the servlet `temp` directory to create JSP servlet files, and the location
    of the optional `jetty.xml` file for enhanced Jetty configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的配置集定义了 Jetty 服务器监听的 HTTP 端口，创建 JSP 服务器文件的 `temp` 目录，以及可选的 `jetty.xml` 文件的位置，用于增强
    Jetty 配置。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Documentation on how to configure the `jetty.xml` file can be found at [http://wiki.eclipse.org/Jetty/Reference/jetty.xml](http://wiki.eclipse.org/Jetty/Reference/jetty.xml).
    Make sure that you also take a look at the specialties of running Jetty with Pax
    Web at [https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration](https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文档说明如何配置 `jetty.xml` 文件，可以在 [http://wiki.eclipse.org/Jetty/Reference/jetty.xml](http://wiki.eclipse.org/Jetty/Reference/jetty.xml)
    找到。请确保您还查看使用 Pax Web 运行 Jetty 的特性，请参阅 [https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration](https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration)。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Additionally, a configuration file for all configuration parameters can be placed
    in the `etc` folder. It's named like the service PID appended by the `.cfg` suffix.
    The following is an excerpt from the `org.ops4j.pax.web.cfg` configuration file.
    This complete configuration file and also the `jetty.xml` file can be found at
    [https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以将所有配置参数的配置文件放置在 `etc` 文件夹中。文件名类似于服务 PID，后缀为 `.cfg`。以下是从 `org.ops4j.pax.web.cfg`
    配置文件中的摘录。完整的配置文件和 `jetty.xml` 文件可以在 [https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2)
    找到。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code configures extra JSP parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码配置了额外的 JSP 参数：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the configuration for the NCSA log format:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 NCSA 日志格式设置的配置：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For details about the NCSA log format, refer to [http://en.wikipedia.org/wiki/Common_Log_Format](http://en.wikipedia.org/wiki/Common_Log_Format).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 NCSA 日志格式的详细信息，请参阅 [http://en.wikipedia.org/wiki/Common_Log_Format](http://en.wikipedia.org/wiki/Common_Log_Format)。
- en: 'The following configuration is used to have different virtual hosts and connectors:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置用于拥有不同的虚拟主机和连接器：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For more details, see the *Binding a web project to a specific host in Apache
    Karaf* recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息，请参阅 *《在 Apache Karaf 中将 Web 项目绑定到特定主机》* 菜谱。
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This configuration excerpt shows you the default configuration that is already
    internally used by Pax Web. If needed, some or all of these configuration parameters
    can be set either in the Karaf shell or be placed in the `org.ops4j.pax.web.cfg`
    file in the `etc` folder. A quick example of how to set the HTTP port via shell
    commands is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置摘录显示了 Pax Web 内部已使用的默认配置。如果需要，可以在 Karaf shell 中设置一些或所有这些配置参数，或者将它们放置在 `etc`
    文件夹中的 `org.ops4j.pax.web.cfg` 文件中。以下是如何通过 shell 命令设置 HTTP 端口的快速示例：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More details on how to use the `config` commands can be found in *Learning Apache
    Karaf*, *Jamie Goodyear, Johan Edstrom, and Heath Kesler*, *Packt Publishing*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用 `config` 命令的更多详细信息，请参阅 *《学习 Apache Karaf》*，作者：*Jamie Goodyear, Johan
    Edstrom, 和 Heath Kesler*，*Packt Publishing*。
- en: 'It is best practice to use the `karaf.data` environment variable when referencing
    external directories, for example, when enabling the NCSA logger by switching
    the `org.ops4j.pax.web.log.ncsa.enabled` option to `true`. It is necessary to
    also configure the directory to a specific folder, as described in the following
    code line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用外部目录时，最好使用 `karaf.data` 环境变量，例如，通过切换 `org.ops4j.pax.web.log.ncsa.enabled`
    选项到 `true` 来启用 NCSA 记录器。还需要将目录配置到特定的文件夹中，如下代码行所述：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same is true for the `scratch` directory for JSP compilation—it is best
    to be configured as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSP 编译的 `scratch` 目录也是如此——最好配置如下：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building a Http Service project to host in Apache Karaf
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Http Service 项目以在 Apache Karaf 中托管
- en: 'Building web applications only with the Http Service also means a reduction
    to servlet only services, as Http Service supports only servlets and no further
    web elements like filters and JSPs. With this reduced set, it is still possible
    to build modern web applications. For example, it just needs some JavaScript code
    and a servlet generating JSON to build a modern web application. Using these elements,
    along with OSGi, you get the perfect mixture for µ-services. The focus of this
    recipe, and the following ones, lies only on the usage of the Http Service; so,
    don''t expect to create a fancy web application. After you''re through, you will
    be able to build a single servlet application like the one in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 Http 服务构建 Web 应用程序也意味着将服务减少到仅 servlet，因为 Http 服务只支持 servlet，不支持其他 Web 元素，如过滤器
    JSP。在这个简化的集合中，仍然可以构建现代 Web 应用程序。例如，只需要一些 JavaScript 代码和一个生成 JSON 的 servlet 就可以构建一个现代
    Web 应用程序。使用这些元素，结合 OSGi，你就可以得到 µ 服务完美的混合体。本食谱和以下食谱的重点仅在于 Http 服务的使用；因此，不要期望创建一个花哨的
    Web 应用程序。完成之后，你将能够构建一个像下面截图所示的单一 servlet 应用程序：
- en: '![Building a Http Service project to host in Apache Karaf](img/5081OS_04_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个 Http 服务项目以在 Apache Karaf 中托管](img/5081OS_04_04.jpg)'
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To precondition the Http Service installed in Apache Karaf, see the *Installing
    Pax modules in Apache Karaf* recipe. The sources can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要预配置 Apache Karaf 中安装的 Http 服务，请参阅 *在 Apache Karaf 中安装 Pax 模块* 食谱。源代码可以在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3)
    找到。
- en: 'It is best to always have a look at the complete sources, due to the limited
    amount of pages for this book and to spare you of the boilerplate code. This is
    why only the critical section is referenced here in this recipe. The example application
    used in this recipe can be installed and started with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书页面有限，最好总是查看完整的源代码，以避免样板代码。这就是为什么在这里只引用了本食谱中的关键部分。本食谱中使用的示例应用程序可以使用以下命令安装和启动：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'As we are using Http Service with this recipe, we need to get hold of the `HttpService`
    service. For this, it is very common to use a ServiceTracker mechanism. The steps
    are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个食谱中使用 Http 服务，我们需要获取 `HttpService` 服务。为此，通常使用 ServiceTracker 机制。步骤如下：
- en: 'The first step is referencing the Http Service. In the activator of our sample
    application, a `ServiceTracker` object is created with a reference to the bundle
    creating this tracker and declaring the class of the service to be tracked. The
    third parameter is an implementation of the ServiceTrackerCustomizer interface.
    A default implementation is provided by the ServiceTracker itself, and therefore
    we use it as is. All of this takes place in the bundle activator code as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是引用 Http 服务。在我们的示例应用程序的激活器中，创建了一个 `ServiceTracker` 对象，该对象引用创建此跟踪器的包，并声明要跟踪的服务类。第三个参数是
    ServiceTrackerCustomizer 接口的实现。ServiceTracker 本身提供了一个默认实现，因此我们直接使用它。所有这些都在包激活器代码中完成，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second step is registering the servlet as a service. The moment the service
    is available, the ServiceTracker will kick in and the `addingService` method of
    the bundle activator will be called. Here, the `HttpContext` function for the
    servlet is created together with the `init` parameter for the servlet to register,
    as shown in the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是注册 servlet 作为服务。当服务可用时，ServiceTracker 将启动，并调用包激活器的 `addingService` 方法。在这里，与
    servlet 注册一起创建了 `HttpContext` 函数和 servlet 的 `init` 参数，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this, we are ready to register the servlet as a service with the Http
    Service. This is done by the following simple API call:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们就可以使用 Http 服务注册 servlet 作为服务了。这通过以下简单的 API 调用完成：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Http Service also supports registering of resources, for example, images
    and CSS files. The Felix Web Console is based on these two mechanisms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Http 服务也支持资源的注册，例如图像和 CSS 文件。Felix 网络控制台基于这两种机制。
- en: 'To register resources, the Http Service API provides another method for registration,
    as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册资源，Http 服务 API 提供了另一种注册方法，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The image should be contained within a JAR file in the `images` folder (as
    shown in the following screenshot), which is used when registering the image''s
    alias:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图片应包含在`images`文件夹中的JAR文件中（如下面的截图所示），在注册图片别名时使用：
- en: '![How to do it…](img/5081OS_04_13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_04_13.jpg)'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The corresponding API can be found at [http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html](http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的API可以在[http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html](http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html)找到。
- en: 'To use this image, create a second servlet that uses this image and register
    it with a different alias, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此图片，创建一个使用此图片的第二个servlet，并使用不同的别名注册它，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The servlet refers to the image as a resource from the root context, as shown
    in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: servlet将图片作为根上下文中的资源引用，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Http Service configures and registers the HelloServlet with the underlying
    Jetty server. From this point on, it is regarded as a classic servlet and handled
    accordingly. The resources take some extra handling, as the ResourceServlet needs
    to be aware of the OSGi class loading, and thus needs to know where to look for
    the resources in the bundle's class path.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Http Service配置并注册HelloServlet到底层Jetty服务器。从这一点开始，它被视为一个经典的servlet并相应地处理。资源需要额外的处理，因为ResourceServlet需要了解OSGi类加载，因此需要知道在哪里查找包的类路径中的资源。
- en: See also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The Http Service only provides basic HTTP services, such as to serve servlets
    and resources. If you want to serve dynamic content like JSPs, you'll need the
    Pax Web extension to the OSGi Http Service—the Pax Web web container. This is
    available together with the Whiteboard extender and is used in the *Building a
    Http Service with the Whiteboard pattern in Apache Karaf* recipe.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Http Service仅提供基本的HTTP服务，例如服务servlet和资源。如果您想服务动态内容，如JSPs，则需要Pax Web扩展OSGi Http
    Service——Pax Web web容器。这可以与Whiteboard扩展一起使用，并在Apache Karaf中使用*Building a Http
    Service with the Whiteboard pattern*配方。
- en: Building a Http Service with the Whiteboard pattern in Apache Karaf
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中使用Whiteboard模式构建Http Service
- en: The Whiteboard pattern is a much easier approach to registering servlets, resources,
    JSPs, or filters. With the Whiteboard extender, the registration of services works
    in the opposite way to the last recipe. The bundle activator doesn't wait for
    the Http Service to show up; it just registers the servlets and the other resources
    as services while the Whiteboard extender picks up those services and makes sure
    that everything is ready to be served. With the Whiteboard feature, it is possible
    to use all web technologies available to the underlying Jetty server, as we are
    not bound to the restricted Http Service interface anymore. This recipe will guide
    you through this by using two different technologies; first, the standard way,
    which is via a bundle activator, and second, via Blueprint.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Whiteboard模式是一种注册servlet、资源、JSP或过滤器的方法。使用Whiteboard扩展，服务的注册方式与上一个配方相反。bundle
    activator不需要等待Http Service出现；它只是注册servlet和其他资源作为服务，同时Whiteboard扩展拾取这些服务并确保一切准备就绪以供服务。使用Whiteboard功能，可以使用底层Jetty服务器提供的所有Web技术，因为我们不再受限于受限的Http
    Service接口。本配方将通过使用两种不同的技术来指导您完成这个过程；首先，标准方式，即通过bundle activator，其次，通过Blueprint。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first step is registering a servlet as a service. First, register your servlet
    via the activator using the bundle context. As the servlet is registered as an
    OSGi service, the alias needs to be placed in the service properties. These properties
    are interpreted and partially used for a servlet's `init` parameters.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是注册一个servlet作为服务。首先，通过bundle上下文使用activator注册您的servlet。由于servlet被注册为OSGi服务，别名需要放在服务属性中。这些属性被解释并部分用于servlet的`init`参数。
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The servlet itself is registered as any usual OSGi service, as shown in the
    following code:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: servlet本身被注册为任何常规的OSGi服务，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second step is registering resources. As this is not a standardized OSGi
    Http Service, a special Pax Web `ResourceMapping` class is needed to register
    a resource as a service, as shown in the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是注册资源。由于这不是一个标准化的OSGi Http Service，需要一个特殊的Pax Web `ResourceMapping`类来将资源注册为服务，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After the registration, it is possible to use these resources by the servlet,
    as follows:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注册后，可以通过servlet使用这些资源，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This pattern to register web components as services will repeat itself.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将Web组件注册为服务的这种模式会重复出现。
- en: 'The next step is registering a servlet with Blueprint. Instead of using an
    activator for registration, the Whiteboard pattern also gives you the freedom
    to use other means of registering services, like Blueprint or DS. With a Blueprint
    XML file, it is now only a configuration for the wiring of services, instead of
    creating the boilerplate code contained in the activator:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用Blueprint注册servlet。与使用激活器进行注册不同，Whiteboard模式也允许您使用其他注册服务的方式，例如Blueprint或DS。使用Blueprint
    XML文件，现在只需配置服务的连接，而不是创建激活器中包含的样板代码：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This registers the servlet with the alias `/filtered`, which is used as the
    URL pattern for the matching filter.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将servlet注册为别名`/filtered`，该别名用作匹配filter的URL模式。
- en: 'The last step is registering the filter with Blueprint. Registering a filter
    is just as easy as registering a servlet. Using Blueprint for this kind of registration
    uses less boilerplate code. This can be done using the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用Blueprint注册filter。注册filter与注册servlet一样简单。使用Blueprint进行此类注册使用的样板代码更少。这可以通过以下代码完成：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As a result, the filtered call of Hello Servlet can be seen when navigating
    to `/filtered`, as shown in the following screenshot:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，当导航到`/filtered`时，可以看到Hello Servlet的过滤调用，如下面的截图所示：
- en: '![How to do it…](img/5081OS_04_05.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_04_05.jpg)'
- en: There is more to the Whiteboard approach. It is possible to configure a complete
    web application just by registering services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Whiteboard方法还有更多内容。只需注册服务即可配置完整的Web应用程序。
- en: Registering error pages
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册错误页面
- en: 'Registering `DefaultErrorPageMapping`, for example, easily configures an error
    page. The corresponding class is provided by Pax Web and is available through
    the Apache Karaf Http Whiteboard feature. Consider the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，注册`DefaultErrorPageMapping`可以轻松配置错误页面。相应的类由Pax Web提供，并通过Apache Karaf Http
    Whiteboard功能可用。考虑以下代码：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This error page mapping defines that any exception thrown in the container
    will result in serving the `uncaughtException.html` page, as shown here in the
    following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误页面映射定义了在容器中抛出的任何异常都将导致服务`uncaughtException.html`页面，如下面的截图所示：
- en: '![Registering error pages](img/5081OS_04_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![注册错误页面](img/5081OS_04_06.jpg)'
- en: Defining error page mapping
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义错误页面映射
- en: 'While at it, a custom 404 error code handling page can be registered with extra
    mapping, which again is registered as a service, as shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，可以通过额外的映射注册自定义404错误代码处理页面，该映射再次作为服务注册，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`DefaultErrorPageMapping` provided by Pax Web just needs the HTTP error code
    and the location of the custom error code page.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web提供的`DefaultErrorPageMapping`只需要HTTP错误代码和自定义错误代码页面的位置。
- en: Registering a welcome page
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册欢迎页面
- en: 'The configuration and registration of a service for welcome pages is as easy
    as the previous registrations have been. Consider the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为欢迎页面配置和注册服务的配置和注册与之前的注册一样简单。考虑以下代码：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Whiteboard extender bundle provides a default implementation of `WelcomeFileMapping`.
    The following screenshot shows the welcome page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Whiteboard扩展器bundle提供了`WelcomeFileMapping`的默认实现。以下截图显示了欢迎页面：
- en: '![Registering a welcome page](img/5081OS_04_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![注册欢迎页面](img/5081OS_04_07.jpg)'
- en: Register JSPs
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册JSP
- en: 'The registration of a JSP is as simple as all the previous recipes. You just
    need to register `DefaultJspMapping` with the corresponding URL patterns. After
    this is done, you are set to serve JSPs right away. Consider the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSP的注册与所有之前的食谱一样简单。您只需将`DefaultJspMapping`与相应的URL模式注册即可。完成此操作后，您就可以立即提供JSP服务。考虑以下代码：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you are set to serve the JSP, the following screen will appear:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好提供JSP时，将出现以下屏幕：
- en: '![Register JSPs](img/5081OS_04_08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![注册JSPs](img/5081OS_04_08.jpg)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The now available Whiteboard extender starts a ServiceListener that registers
    any incoming new service such as a servlet, filter, and JSP and hands them over
    to either the standard Http Service or the extended Http Service (the WebContainer
    interface).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可用的Whiteboard扩展器启动一个ServiceListener，该Listener注册任何传入的新服务，如servlet、filter和JSP，并将它们交给标准Http
    Service或扩展的Http Service（WebContainer接口）。
- en: Using the direct service approach has only one downside—all of the registered
    servlet services use the same `ServletContextPath`. This is due to the fact that
    the Http Service registered servlets neglect a way to register the servlet with
    a specialized ServletContextPath, and therefore are bound to`/`with an extra URL
    path for the servlet. For example, the first two servlets of this recipe register
    with `/whiteboard` and `/whiteboard/logo`, where the ServletContextPath is `/`.
    To distinguish between different ServletContextPaths, a WAB is needed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接服务方法只有一个缺点——所有注册的servlet服务都使用相同的`ServletContextPath`。这是因为注册的Http Service
    servlet忽略了注册servlet时使用专门的ServletContextPath的方法，因此绑定到了`/`，并为servlet添加了额外的URL路径。例如，这个配方中的前两个servlet注册为`/whiteboard`和`/whiteboard/logo`，其中ServletContextPath是`/`。为了区分不同的ServletContextPaths，需要一个WAB。
- en: 'All of the previous samples have one thing in common: all of them are registered
    within the same bundle. To separate servlets from filters, you need to make sure
    that you have the same HttpContext in use; this is handled in a later recipe.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的示例都有一个共同点：它们都是在同一个bundle中注册的。为了将servlet与过滤器分开，你需要确保使用相同的HttpContext；这将在后面的配方中处理。
- en: Building an application with custom HttpContext with Apache Karaf
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache Karaf构建具有自定义HttpContext的应用程序
- en: All previous recipes have covered how to register servlets and filters, and
    all from within the same bundle bound to a default HttpContext. If no other HttpContext
    is defined, DefaultHttpContext is created while registering a servlet or resource.
    With this recipe, we will work with a custom HttpContext.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的配方都涵盖了如何注册servlet和过滤器，并且都是在绑定到默认HttpContext的同一个个bundle中完成的。如果没有定义其他HttpContext，则在注册servlet或资源时创建DefaultHttpContext。在这个配方中，我们将使用自定义的HttpContext。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As this recipe is a specialization of the previous recipes, you'll find the
    source code for it in the *Building a Http Service with the Whiteboard pattern
    in Apache Karaf* recipe. As usual, the recipe demands the successful installation
    of the `http-whiteboard` feature; how this can be achieved is explained in the
    *Installing extended Http Service in Apache Karaf* recipe. The source code in
    this recipe is reduced to the important sections. The full sources can be found
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个配方是之前配方的特殊化，你可以在*在Apache Karaf中使用Whiteboard模式构建Http服务*的配方中找到它的源代码。像往常一样，这个配方要求成功安装`http-whiteboard`功能；如何实现这一点在*在Apache
    Karaf中安装扩展Http服务*的配方中有解释。这个配方中的源代码被缩减到了重要的部分。完整的源代码可以在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4)找到。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The first step is defining properties. As with servlets, registering an HttpContext
    requires configuring a name for the HttpContext, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是定义属性。与servlet类似，注册HttpContext需要为HttpContext配置一个名称，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step is registering, HttpContext. This will register the custom WhiteboardContext
    as HttpContext with a specialized ID `forbidden`. This way, other services are
    able to select this HttpContext. This is shown in the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注册，HttpContext。这将使用专门的ID `forbidden` 将自定义的WhiteboardContext注册为HttpContext。这样，其他服务就可以选择这个HttpContext。这在上面的代码中有所展示：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next step is registering the servlet. The servlet using this HttpContext
    is referencing the HttpContext by just being registered using the same HttpContext
    ID. Consider the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注册servlet。使用这个HttpContext的servlet通过使用相同的HttpContext ID进行注册来引用HttpContext。考虑以下代码：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The custom HttpContext returns `false` for the `handleSecurity` method. Therefore,
    the request will return a 401 error as HTTP return code. Consider the following
    code:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义HttpContext对`handleSecurity`方法返回`false`。因此，请求将返回401错误作为HTTP返回代码。考虑以下代码：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following screenshot shows the HTTP error window:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了HTTP错误窗口：
- en: '![How to do it…](img/5081OS_04_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_04_09.jpg)'
- en: There's more…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Till now, the registration of servlets, filters, and other resources always
    took place from the same bundle. How does this fit into the OSGi world? Doesn''t
    it make sense to split this apart? It actually does, but it isn''t easy and the
    OSGi spec doesn''t require it to be possible. With Pax Web 3, it is possible to
    have this working but requires some specialties. First of all, it needs a shared
    HttpContext (its description and how to work with it you will find in the next
    set of steps). The following is a component diagram to give you an idea of the
    setup:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，servlet、过滤器和其他资源的注册总是来自同一个包。这在 OSGi 世界中是如何适应的？这不是将它们分开更有意义吗？实际上确实如此，但这并不容易，OSGi
    规范也没有要求它必须可行。使用 Pax Web 3，可以实现这一点，但需要一些特殊处理。首先，它需要一个共享 HttpContext（其描述和如何使用它将在下一步骤中找到）。以下是一个组件图，以帮助您了解设置：
- en: '![There''s more…](img/5081OS_04_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/5081OS_04_14.jpg)'
- en: 'This can be done as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样做：
- en: 'The first step is registering the SharedWebContainerContext. For the shared
    HttpContext, it is essential to have the SharedWebContainerContext, which is a
    specialized HttpContext. At this point, the WebContainer interface is our friend
    and helps us by providing a method for the creation of the SharedWebContainerContext,
    which is the `getDefaultSharedHttpContext` method. This is described in the following
    code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是注册 SharedWebContainerContext。对于共享 HttpContext，拥有 SharedWebContainerContext（这是一个专门的
    HttpContext）是至关重要的。在此阶段，WebContainer 接口是我们的朋友，并通过提供创建 SharedWebContainerContext
    的方法来帮助我们，即 `getDefaultSharedHttpContext` 方法。这将在以下代码中描述：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This freshly created SharedWebContainerContext needs to be registered as a
    service, as the filter from the other bundle needs to refer to it. Consider the
    following code:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新创建的 SharedWebContainerContext 需要注册为服务，因为来自其他包的过滤器需要引用它。考虑以下代码：
- en: '[PRE39]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next step is registering the servlet with the shared context. As we want
    to add a filter from a different bundle, we need to add a servlet first. We will
    do this using the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注册与共享上下文关联的 servlet。由于我们想要添加来自不同包的过滤器，我们需要先添加一个 servlet。我们将使用以下代码来完成：
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At this point, the first bundle is set in our recipe, and we need to take care
    of the second bundle that only contains the filter.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，我们的配方中已经设置了第一个包，我们需要注意只包含过滤器的第二个包。
- en: The next step is referencing the shared HttpContext. We need to get the *shared*
    HttpContext first, though this time we don't create a new one; we just need to
    reference the one that the first bundle registered.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是引用共享 HttpContext。我们需要首先获取 *shared* HttpContext，尽管这次我们不创建一个新的，我们只需要引用第一个包注册的那个。
- en: 'Find the service reference for the HttpContext service that matches the given
    LDAP filter `(httpContext.id=shared)`. Also, see step 1, where we registered the
    service with this property. Consider the following code:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查找与给定 LDAP 过滤器 `(httpContext.id=shared)` 匹配的 HttpContext 服务的服务引用。同时，参见步骤 1，我们在那里使用此属性注册了服务。考虑以下代码：
- en: '[PRE41]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From this service reference, we acquire the HttpContext instance, which in our
    case is the SharedWebContainerContext at this point.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个服务引用中，我们获取到 HttpContext 实例，在我们的例子中，此时是 SharedWebContainerContext。
- en: The next step is registering the filter for the shared context. From here on,
    it's quite simple. The registration of the servlet filter is done in the usual
    way.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注册共享上下文的过滤器。从现在开始，这相当简单。servlet 过滤器的注册是以通常的方式进行。
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create the properties needed for registration and register the filter with the
    WebContainer service. It is important that the properties contain the reference
    to the right HttpContext, `shared` at this point. The most important part is that
    it needs to actually register the filter with the preregistered HttpContext.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建注册所需的属性，并将过滤器与 WebContainer 服务注册。重要的是属性中包含对正确 HttpContext 的引用，此时为 `shared`。最重要的是，它需要实际上将过滤器与已预注册的
    HttpContext 注册。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Can''t this be done easier?**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**这难道不能更简单吗？**'
- en: The not-yet-released version of Pax Web 4 helps with the sharing of contexts.
    It will especially help in working with the Whiteboard pattern. Since the release
    of Karaf 3 (which uses Pax Web 3), the `features.xml` file of Pax Web is maintained
    and released in the Pax Web release cycle. This will help to upgrade just this
    feature while Karaf itself might stay on another version.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web 4 的尚未发布版本有助于共享上下文。它将特别有助于使用 Whiteboard 模式。自从 Karaf 3（使用 Pax Web 3）发布以来，Pax
    Web 的 `features.xml` 文件在 Pax Web 发布周期中维护和发布。这将有助于仅升级此功能，而 Karaf 本身可能停留在另一个版本上。
- en: Building a standard web project to host in Apache Karaf
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Apache Karaf 中托管标准 Web 项目
- en: As building a standard web application and WAR isn't really in the scope of
    this book, the focus of this recipe lies on the *transformation* of a standard
    WAR into a WAB.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建标准 Web 应用程序和 WAR 并不在本书的范围内，本菜谱的重点在于将标准 WAR 转换为 WAB。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The sample code for this recipe is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例代码可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6)
    找到。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Transforming a standard WAR project into a WAB is simple. So, let's take a look
    at the specialties around WAR and WAB files. For simplicity, let's call this project
    web project from here on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准 WAR 项目转换为 WAB 简单。所以，让我们看看 WAR 和 WAB 文件的特殊之处。为了简单起见，从现在起让我们称这个项目为 Web 项目。
- en: Contrasting with a standard bundle project, where the classes reside directly
    in the JAR file, the classes of a web project should be contained in the `classes`
    folder under the `WEB-INF` folder. The same is true for embedded libraries; in
    a web project, these libraries are required to be placed in the `lib` folder under
    the `WEB-INF` folder.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接位于 JAR 文件中的类的标准包项目相比，Web 项目的类应包含在 `WEB-INF` 文件夹下的 `classes` 文件夹中。对于嵌入式库也是如此；在
    Web 项目中，这些库需要放置在 `WEB-INF` 文件夹下的 `lib` 文件夹中。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Beware—embedding other JAR files should be done only if the JAR file is needed
    internally. Referencing other bundles should be your first choice.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 警告——仅当需要内部使用 JAR 文件时才应嵌入其他 JAR 文件。引用其他包应该是你的首选。
- en: 'The good news is that `maven-bundle-plugin` is capable of taking care of this
    special placement of classes and libraries. The `<_wab>` section takes care of
    this. Here, you define the base path of your web application folder. As this is
    a Maven project, the web application path resides in the `webapp` folder in the
    `src/main` folder. Consider the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 `maven-bundle-plugin` 能够处理这种特殊放置的类和库。`<_wab>` 部分负责这一点。在这里，你定义你的 Web 应用程序文件夹的基本路径。由于这是一个
    Maven 项目，Web 应用程序路径位于 `src/main` 文件夹中的 `webapp` 文件夹。考虑以下代码：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As it is required for a web application bundle to have a `Web-ContextPath` manifest
    entry, this is set to `packt-sample` in this recipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要为 Web 应用程序包有一个 `Web-ContextPath` 清单条目，因此在本菜谱中将其设置为 `packt-sample`。
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The WAR feature installs the Pax Web War extender. The WAR extender waits for
    bundles containing the `Web-ContextPath` header and will scan this bundle for
    the `web.xml` and `jetty-web.xml` configuration files. It also takes care of the
    annotated servlet's classes. For each WAR file, there will be a unique servlet
    context with the path defined in the `Web-ContextPath` manifest header. This is
    different from registering servlets via the Http Service (with or without the
    Whiteboard extender), where it is all about the alias.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: WAR 功能安装了 Pax Web War 扩展器。WAR 扩展器等待包含 `Web-ContextPath` 标头的包，并将扫描此包中的 `web.xml`
    和 `jetty-web.xml` 配置文件。它还负责注解的 servlet 类。对于每个 WAR 文件，将有一个唯一的 servlet 上下文，其路径由
    `Web-ContextPath` 清单头中定义。这与通过 Http 服务（带或不带 Whiteboard 扩展器）注册 servlet 不同，那里一切都关于别名。
- en: There's more…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The only downside of the previously created WAB file is that it is not a WAR
    file anymore. As the POM file declares the resulting package to be of type bundle,
    the artifact is packaged as a JAR file. This surely will cause issues in the case
    of a WAR file that is supposed to be run on Apache Karaf or a non-OSGi container.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的 WAB 文件唯一的缺点是它不再是 WAR 文件了。由于 POM 文件声明生成的包类型为 bundle，因此该工件被打包为 JAR 文件。这无疑会在需要在
    Apache Karaf 或非 OSGi 容器上运行的 WAR 文件中引起问题。
- en: To make this work, the Maven POM file of the project needs to be adapted. First,
    set the packaging to WAR. This will use `maven-war-plugin` to package this bundle,
    and in turn, the WAR file is not a WAB file anymore, as it lacks a valid OSGi
    manifest.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，项目的 Maven POM 文件需要做出调整。首先，将打包设置为 WAR。这将使用 `maven-war-plugin` 打包此包，而 WAR
    文件不再是 WAB 文件，因为它缺少有效的 OSGi 清单。
- en: 'It''s necessary to combine the two plugins to create a valid OSGi WAB file.
    For this, we need to configure `maven-bundle-plugin` in the following manner:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 必须结合两个插件来创建一个有效的 OSGi WAB 文件。为此，我们需要以下方式配置 `maven-bundle-plugin`：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The plugin is configured just to produce a manifest file, and as the packaging
    is of the type WAR, `maven-bundle-plugin` needs to be configured to support the
    WAR format as valid packaging.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 插件配置仅为生成manifest文件，由于打包类型为WAR，因此需要配置`maven-bundle-plugin`以支持WAR格式作为有效的打包格式。
- en: 'The manifest file generated from the preceding code will be merged into the
    WAR bundle explicitly using the `manifestFile` attribute, as shown in the following
    code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成的manifest文件将显式地使用`manifestFile`属性合并到WAR包中，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With these configurations, you'll generate a web application that can run in
    Apache Karaf and outside of OSGi.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些配置，您将生成一个可以在Apache Karaf和OSGi外部运行的网络应用程序。
- en: For a complete sample, take a look at the source code at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6).
    Here, you will find a special POM file, `pom.war_xml`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个完整的示例，请查看[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6)中的源代码。在这里，您将找到一个特殊的POM文件，`pom.war_xml`。
- en: Configuring security for a web application in Apache Karaf
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中配置网络应用程序的安全
- en: This recipe will handle how to build a web application with authentication enabled.
    As we are running within Apache Karaf and Karaf supports **Java Authentication
    and Authorization Service** (**JAAS**) out of the box, we will show you everything
    that is needed to run a basic authentication with JAAS on Karaf.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将处理如何构建启用身份验证的网络应用程序。由于我们在Apache Karaf中运行，并且Karaf默认支持**Java身份验证和授权服务**（**JAAS**），我们将向您展示运行Karaf上基本身份验证所需的一切。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite is to install the WAR feature. The source code for this recipe
    is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件是安装WAR功能。此配方的源代码可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7)中找到。
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step is configuring the user/password combination in Karaf. Let''s
    start with the user configuration. Let''s make sure that the `users.properties`
    file in the `/etc` folder contains the following setup (it''s the default configuration):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在Karaf中配置用户/密码组合。让我们从用户配置开始。让我们确保`/etc`文件夹中的`users.properties`文件包含以下设置（这是默认配置）：
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `users.properties` file follows the following syntax:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`users.properties`文件遵循以下语法：'
- en: '[PRE47]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It can also have the following syntax:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它也可以有以下的语法：
- en: '[PRE48]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next step is configuring JAAS in Jetty. The `jetty.xml` file used by Pax
    Web needs to contain a valid authentication realm. This realm needs to be configured
    for the usage of JAAS. Configuration of the `JAASLoginService` class will look
    like the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置Jetty中的JAAS。Pax Web使用的`jetty.xml`文件需要包含一个有效的认证领域。此领域需要配置为使用JAAS。`JAASLoginService`类的配置如下所示：
- en: '[PRE49]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The key to accessing the realm of Karaf is to define the `loginModuleName` value
    to `karaf` and define the right principal. As we are running within Karaf, we
    need as configure the `roleClassNames` value to be `org.apache.karaf.jaas.boot.principal.RolePrincipal`.
    With this, the security handshake configuration between Jetty and Karaf is complete.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问Karaf领域的关键是定义`loginModuleName`值为`karaf`并定义正确的主体。由于我们在Karaf中运行，我们需要配置`roleClassNames`值为`org.apache.karaf.jaas.boot.principal.RolePrincipal`。这样，Jetty和Karaf之间的安全握手配置就完成了。
- en: 'The last step is configuring the web application to use JAAS. To use it from
    within the web application, the `web.xml` file needs to have security enabled
    and configured, as shown in the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将网络应用程序配置为使用JAAS。要在网络应用程序内部使用它，`web.xml`文件需要启用并配置安全设置，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The security for this application is set to secure the secured URL for both
    the `GET` and `POST` methods. The required role has to be of the name `admin`,
    as was configured in step 1\. Consider the following code:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此应用程序的安全设置是为了保护`GET`和`POST`方法的安全URL。所需的角色名称必须是`admin`，正如步骤1中配置的那样。请考虑以下代码：
- en: '[PRE51]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The login configuration is set to be of the type `BASIC`, so the container takes
    care of the authentication and it's configured to use the default realm. This
    configuration points to the defined `JAASLoginService` class with the name `default`
    (configured in step 2).
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 登录配置设置为`BASIC`类型，因此容器负责身份验证，并配置为使用默认域。此配置指向已定义的`JAASLoginService`类，其名称为`default`（在第2步中配置）。
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The key for authentication in a web application is the JAAS security mechanism
    provided by Karaf. It's just a matter of configuration to make sure all parts
    are connected appropriately.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中进行身份验证的密钥是Karaf提供的JAAS安全机制。这只是一个配置问题，以确保所有部分都适当地连接。
- en: When working with Karaf and JAAS security realms, it might be of interest to
    know which realms are currently available. There is a shell command available
    to list all realms—the `jaas:realm-list` command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Karaf和JAAS安全域一起工作时，了解当前可用的域可能会有所帮助。有一个shell命令可以列出所有域——`jaas:realm-list`命令。
- en: 'This command will show us the available realms, as shown in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示可用的域，如下面的屏幕截图所示：
- en: '![How it works…](img/5081OS_04_10.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_04_10.jpg)'
- en: There's more…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now that we have configured security in the web application, the only thing
    missing is a way of addressing the application in a secure way. To enable SSL,
    we need to take parts of the configuration from the *Configuring Pax Web modules
    deployed in Apache Karaf* recipe and enable certain values that are off by default.
    All this is done to the `org.ops4j.pax.web.cfg` configuration file, as shown in
    the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Web应用程序中配置了安全设置，唯一缺少的是一种安全地访问应用程序的方法。为了启用SSL，我们需要从*配置在Apache Karaf中部署的Pax
    Web模块*的配置中提取部分内容，并启用默认情况下关闭的某些值。所有这些操作都是在`org.ops4j.pax.web.cfg`配置文件中完成的，如下面的代码片段所示：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this configuration, we enable listening on the secure port, which is `8443`
    in our case. The `keystore` value is stored at a location relative to the Karaf
    base directory.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，我们启用了对安全端口的监听，在我们的例子中是`8443`。`keystore`值存储在相对于Karaf基本目录的位置。
- en: The `clientauthwanted` and `clientauthneeded` properties are set to `true` if
    the client should send a certificate for authentication instead of login credentials.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端应发送证书进行身份验证而不是登录凭据，则将`clientauthwanted`和`clientauthneeded`属性设置为`true`。
- en: Once the configurations have been saved, they will be picked up by the FileInstaller
    bundle and applied to running Jetty server through Pax Web.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 保存配置后，它们将被FileInstaller包获取并应用于通过Pax Web运行的Jetty服务器。
- en: 'For a fully working SSL, you''ll need a certificate, and so we need to create
    one. The following steps will work on the Linux and Mac environments and most
    likely on Windows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现完全工作的SSL，你需要一个证书，因此我们需要创建一个。以下步骤将在Linux和Mac环境中工作，并且很可能会在Windows上工作：
- en: The first step is the `keystore` setup. First of all, create the directory to
    contain the keystore that will be used with Karaf. It has to match the `org.ops4j.pax.web.ssl.keystore`
    property configured in the `org.ops4j.pax.web.cfg` file. This is shown in the
    following screenshot:![There's more…](img/5081OS_04_11.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是`keystore`设置。首先，创建用于包含与Karaf一起使用的keystore的目录。它必须与`org.ops4j.pax.web.ssl.keystore`属性在`org.ops4j.pax.web.cfg`文件中配置的值相匹配。如下面的屏幕截图所示：![还有更多…](img/5081OS_04_11.jpg)
- en: 'On the system shell, not the Karaf shell, you will need to use a tool to create
    SSH keys. We will be using the Java tool named **keytool** to create keys and
    certificates. First, create the key to sign the certificate. Make sure that you''re
    doing this in the `keystore` directory (`etc/keystore`). This can be done as follows:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在系统shell中，而不是Karaf shell中，你需要使用工具来创建SSH密钥。我们将使用名为**keytool**的Java工具来创建密钥和证书。首先，创建用于签名证书的密钥。确保你在`keystore`目录（`etc/keystore`）中执行此操作。可以按照以下方式完成：
- en: '[PRE53]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We use a simple password as the password, as this is an example, but you shouldn''t
    actually do this in production. As password, we use server. Have a look at the
    following screenshot:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这是一个示例，我们使用简单的密码作为密码，但在生产环境中实际上不应该这样做。我们将使用`server`作为密码。请查看以下屏幕截图：
- en: '![There''s more…](img/5081OS_04_12.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![还有更多…](img/5081OS_04_12.jpg)'
- en: Once you see the previous screenshot, you are already set to use SSL in your
    application. You will need to navigate your browser to the application with the
    SSL port configured previously; in our example, it is `8443`. Your browser will
    complain about an unsigned certificate of an unknown source. After accepting it,
    you'll have the login prompt from your authentication WAR file.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦您看到前面的截图，您就已经设置好可以在应用程序中使用SSL了。您需要将浏览器导航到配置了SSL端口的先前应用程序；在我们的例子中，它是`8443`。您的浏览器将抱怨来自未知来源的未签名证书。接受它后，您将收到来自您的认证WAR文件的登录提示。
- en: 'The next step is importing the client certificate. It is also possible to connect
    to the server with a signed client certificate. The client needs to do the same
    as has been done for the server—create a self-signed certificate. This certificate
    needs to be imported to the keystore of the server so that the server knows which
    certificate to accept. This can be done as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是导入客户端证书。也可以使用带有签名的客户端证书连接到服务器。客户端需要执行与服务器相同的事情——创建一个自签名证书。此证书需要导入到服务器的密钥库中，以便服务器知道要接受哪个证书。可以按照以下方式操作：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This client certificate needs to be transmitted by the HTTP client software,
    which may be a browser or some other means of communicating software.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此客户端证书需要通过HTTP客户端软件传输，这可能是一个浏览器或其他通信软件的方式。
- en: Binding a web project to a specific host in Apache Karaf
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中将Web项目绑定到特定主机
- en: With Karaf 3 and Pax Web 3, it is possible to bind a web application to a specific
    HTTP connector. This is a feasible solution to separate internal and external
    applications on the same server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Karaf 3和Pax Web 3，可以将Web应用程序绑定到特定的HTTP连接器。这是在相同服务器上分离内部和外部应用程序的可行解决方案。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The sample code for this recipe is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8).
    Here, you will find a `jetty.xml` file at the `src/main/etc` location. It can
    be used to add an extra connector. Two extra recipes are available to show how
    to use this with a standard WAB file or the Whiteboard extender.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例代码可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8)找到。在这里，您将在`src/main/etc`位置找到一个`jetty.xml`文件。它可以用来添加额外的连接器。有两个额外的菜谱可以展示如何使用标准WAB文件或Whiteboard扩展器。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First of all, the server needs to be configured to support different HTTP connectors.
    Therefore, it is necessary to configure the Jetty server by editing the `jetty.xml`
    file found in the `etc` folder, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器需要配置以支持不同的HTTP连接器。因此，有必要通过编辑`etc`文件夹中找到的`jetty.xml`文件来配置Jetty服务器，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Changes to the `jetty.xml` file will take effect only on the restart of the
    server and will not be picked up by FileInstaller and applied at runtime.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对`jetty.xml`文件的更改仅在服务器重启时生效，并且不会被FileInstaller拾取并在运行时应用。
- en: The second connector is bound to port `8282` and named `alternateConnector`.
    This will be referenced by the application to be bound to this connector.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个连接器绑定到端口`8282`，并命名为`alternateConnector`。这将由绑定到此连接器的应用程序引用。
- en: 'To do so, the WAB file needs two additional manifest entries, which are as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，WAB文件需要两个额外的清单条目，如下所示：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The extra connector configured in the `jetty.xml` file is interpreted by Pax
    Web and is added to Jetty. With the special manifest entries, the web application
    bundle is bound to the configured HTTP connector. The number of connectors and
    applications bound to them are not limited.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jetty.xml`文件中配置的额外连接器被Pax Web解释并添加到Jetty中。通过特殊的清单条目，Web应用程序包绑定到配置的HTTP连接器。连接器的数量以及绑定到它们的应用程序数量没有限制。
- en: There's more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With Pax Web 3, and therefore with Apache Karaf 3, it is not only possible to
    bind the WAB file to the web connector, but also to a normal bundle. This needs
    some special handling, as there is no `Web-ContextPath` manifest header to define
    the context path.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pax Web 3，因此使用Apache Karaf 3，不仅可以将WAB文件绑定到Web连接器，还可以绑定到普通包。这需要一些特殊处理，因为没有`Web-ContextPath`清单头可以定义上下文路径。
- en: 'The best way to achieve this is to use the Whiteboard extender. For this, we
    need to register a specialized HttpContext, as shown in the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的最佳方式是使用Whiteboard扩展器。为此，我们需要注册一个专门的HttpContext，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The registered servlet just needs to use the following HttpContext:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的 servlet 只需使用以下 HttpContext：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That's it. Now you need to call the servlet with the `http://localhost:8282/whiteboard/connector`
    URL.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在你需要使用 `http://localhost:8282/whiteboard/connector` URL 调用 servlet。
- en: The servlet is registered with the alias/connector, but the HttpContext takes
    care of the Whiteboard context path.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 使用别名/连接器进行注册，但 HttpContext 负责处理 Whiteboard 上下文路径。
- en: Building a Servlet 3.0 annotated web application with Apache Karaf
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 构建 Servlet 3.0 注解 Web 应用程序
- en: With the Servlet 3.0 API, it's possible to have web archives only with annotated
    servlets and omit a `web.xml` file, or at least omit the configuration of the
    application within a `web.xml` file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Servlet 3.0 API，可以只使用注解的 servlet 而不包含 `web.xml` 文件，或者至少在 `web.xml` 文件中省略应用程序的配置。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, you will find the code for this recipe at the GitHub location at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你可以在 GitHub 上的位置找到这个菜谱的代码：[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9)。
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As with the *Building a standard web project to host in Apache Karaf* recipe,
    we just build another WAB bundle. Only this time, we have a `web.xml` file containing
    only the definition for the `welcome-file-list` method and annotated servlets:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 Apache Karaf 中托管的标准 Web 项目菜谱一样，我们只是构建另一个 WAB 包。但这一次，我们有一个只包含 `welcome-file-list`
    方法定义和注解 servlet 的 `web.xml` 文件：
- en: 'The first step is defining the `web.xml` file. This can be done as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是定义 `web.xml` 文件。可以按照以下方式完成：
- en: '[PRE59]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next step is annotating the servlet. The servlet is simple and consists
    only of the usual servlet code and annotation. Consider the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注解 servlet。servlet 简单，只包含常规的 servlet 代码和注解。考虑以下代码：
- en: '[PRE60]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is annotating the filter. The filter also consists of the annotation
    to declare it to be a filter together with the `init` parameters, as shown in
    the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注解过滤器。过滤器也包含声明它为过滤器的注解以及 `init` 参数，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: With this assembly, you are all set to run Servlet 3.0 API applications in Apache
    Karaf.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个组件，你就可以在 Apache Karaf 中运行 Servlet 3.0 API 应用程序了。
- en: There's more…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Pax Web does go a step further. As long as the bundle contains a `Web-ContextPath`
    in its `MANIFEST.MF` file, it's considered as a WAB file, and therefore, the Pax
    Web WAR extender handles it as such.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web 还更进一步。只要包在其 `MANIFEST.MF` 文件中包含 `Web-ContextPath`，它就被视为 WAB 文件，因此 Pax
    Web WAR 扩展器会将其作为此类文件处理。
- en: 'Make sure that you have a `Web-ContextPath` in your manifest, as shown in the
    following line of code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的清单中有一个 `Web-ContextPath`，如下面的代码行所示：
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, make sure that you have an annotated servlet contained in your bundle,
    as shown in the following line of code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保你的包中包含注解的 servlet，如下面的代码行所示：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Pointing the browser to `http://localhost:8181/packt-sample/test` will return
    the desired web content.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向 `http://localhost:8181/packt-sample/test` 将返回所需的 Web 内容。
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Pax Web WAR extender usually looks for bundles containing a `Web-ContextPath`
    in the manifest and for a `web.xml` file to publish the web archive. From Pax
    Web 3.0 on, the WAR extender also accepts bundles containing a `Web-ContextPath`
    in their manifest only.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web WAR 扩展器通常会查找包含在清单中的 `Web-ContextPath` 以及 `web.xml` 文件以发布 Web 存档。从 Pax
    Web 3.0 开始，WAR 扩展器也接受只包含其清单中的 `Web-ContextPath` 的包。
- en: Creating a CDI web application with Apache Karaf
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 创建 CDI Web 应用程序
- en: Nowadays, modern web applications use **Contexts and Dependency Injection**
    (**CDI**) to wire the application. In the context of OSGi, it would be nice to
    have this working together with OSGi services. Pax Web, together with Pax CDI,
    takes care of this scenario.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，现代 Web 应用程序使用 **上下文和依赖注入**（**CDI**）来连接应用程序。在 OSGi 的环境中，能够与 OSGi 服务一起工作会很好。Pax
    Web 与 Pax CDI 一起处理这种情况。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Besides the installation of the WAR feature, it is required to install Pax
    CDI. Use the following commands to install them:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装 WAR 功能外，还需要安装 Pax CDI。使用以下命令安装它们：
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Alternatively, you can use the `weld` command as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下 `weld` 命令：
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The source code for this recipe can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码可以在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10)找到。
- en: This recipe needs the bundle and web submodules. The bundle submodule contains
    the OSGi service, and the web submodule contains the CDI web application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要包和Web子模块。包子模块包含OSGi服务，而Web子模块包含CDI Web应用程序。
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's start with the web application. The `web.xml` file can either be empty
    or can contain the entry for a `welcome-file-list` method, as the application
    is a Servlet 3.0 application. For a CDI application, it is required to have a
    `beans.xml` definition in the class path. As this is a web application, the `beans.xml`
    file is expected to be in the `WEB-INF` folder. For our use, it is sufficient
    to keep an empty `beans.xml` file in this directory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Web应用程序开始。`web.xml`文件可以是空的，也可以包含`welcome-file-list`方法的条目，因为该应用程序是一个Servlet
    3.0应用程序。对于CDI应用程序，需要在类路径中有一个`beans.xml`定义。由于这是一个Web应用程序，`beans.xml`文件预计将位于`WEB-INF`文件夹中。对于我们的使用，在这个目录中保留一个空的`beans.xml`文件就足够了。
- en: 'The servlet needs to be annotated with the `@WebServlet` annotation to be picked
    up by Pax Web. This is shown in the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet需要使用`@WebServlet`注解来被Pax Web拾取。如下代码所示：
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The servlet uses an OSGi service to retrieve simple quotes. This service is
    referenced via an injection, as shown in the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet使用OSGi服务来检索简单的引语。这个服务通过注入引用，如下代码所示：
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The specialty of Pax CDI is the `@OsgiService` annotation. This annotation will
    wire the corresponding OSGi service to this servlet. The `dynamic = true` property
    makes sure that the dynamism of OSGi services is used.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Pax CDI的特色是`@OsgiService`注解。这个注解会将相应的OSGi服务连接到这个Servlet。`dynamic = true`属性确保使用OSGi服务的动态性。
- en: 'For a smooth interaction between Pax Web and Pax CDI, a few more configurations
    are required. These are handled in the POM file, as shown in the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了Pax Web和Pax CDI之间顺畅的交互，还需要一些额外的配置。这些配置在以下代码中的POM文件中处理：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Other than the already-known instructions such as `<_wab>` and `<Web-ContextPath>`,
    a CDI bundle requires the `<Require-Capability>` instruction. With this instruction,
    the resolver is informed of the fact that the web bundle requires the capability
    of the CDI bundle.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已知指令如`<_wab>`和`<Web-ContextPath>`之外，CDI包还需要`<Require-Capability>`指令。有了这个指令，解析器会被告知Web包需要CDI包的能力。
- en: How it works…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Pax Web registers all of the servlets of a CDI web application. These servlets
    wait for the initialization of the context through Pax CDI. The service is provided
    by another bundle. As long as this service isn't available, the servlet will not
    start. The other important part is the `<Require-Capability>` manifest entry.
    It helps the resolver to wire the WAR bundle to the Pax CDI extension bundle.
    This way, the Pax CDI extender is capable of taking care of the injections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Web注册了CDI Web应用程序的所有Servlet。这些Servlet通过Pax CDI等待上下文的初始化。服务由另一个包提供。只要这个服务不可用，Servlet就不会启动。另一个重要部分是`<Require-Capability>`清单条目。它帮助解析器将WAR包连接到Pax
    CDI扩展包。这样，Pax CDI扩展器就能够处理注入。
- en: 'This `<Require-Capability>` header can also be bound to a specific version.
    To do so, the following needs to be configured instead:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`<Require-Capability>`头也可以绑定到特定版本。为此，需要配置以下内容：
- en: '[PRE69]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: See also
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Although this recipe gave you a brief overview of how to use CDI to wire services
    in OSGi, a lot more is possible. You can use CDI not only to wire an application
    within the same bundle but also to provide services through CDI and use it in
    another bundle. For more details about Pax CDI and the possibilities, refer to
    the Pax CDI project page at [https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation](https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation).
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这个菜谱给了你如何使用CDI在OSGi中连接服务的简要概述，但还有更多可能。你不仅可以使用CDI在同一个包内连接应用程序，还可以通过CDI提供服务并在另一个包中使用它。有关Pax
    CDI和可能性的更多详细信息，请参阅Pax CDI项目页面[https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation](https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation)。
- en: Some more samples can be found at [https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples](https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多示例可以在[https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples](https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples)找到。
