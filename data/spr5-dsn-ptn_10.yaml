- en: Implementing the MVC Pattern in a Web Application using Spring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring 中使用 MVC 模式实现 Web 应用程序
- en: In the last couple of chapters in the book, we have seen that all examples were
    based on a standalone application using the Spring Framework. We have seen how
    Spring works to provide important features, such as the dependency injection pattern,
    bean life cycle management, AOP, cache management, and Spring, in the backend
    using the JDBC and ORM modules. In this chapter, we will see how Spring works
    in the web environment to address some common problems of any web application,
    such as workflow, validations, and state management.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一两个章节中，我们看到了所有示例都是基于使用 Spring 框架的独立应用程序。我们看到了 Spring 如何工作以提供重要功能，例如依赖注入模式、bean
    生命周期管理、AOP、缓存管理，以及使用 JDBC 和 ORM 模块在后台的 Spring。在本章中，我们将看到 Spring 在网络环境中是如何工作的，以解决任何
    Web 应用程序的一些常见问题，如工作流程、验证和状态管理。
- en: Like other modules in the Spring Framework, Spring has introduced its own web
    framework, known as Spring Web MVC. It is based on the **Model-View-Controller**
    (**MVC**) pattern. Spring Web MVC supports the presentation tier, and helps you
    to build a flexible and loosely coupled web-based application. The Spring MVC
    module addresses the problem of testing the web components in the enterprise application.
    It allows you to write the test case without using request and response objects
    in the application. Here, we will discuss more about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spring 框架中的其他模块一样，Spring 引入了它自己的网络框架，称为 Spring Web MVC。它基于 **模型-视图-控制器**（**MVC**）模式。Spring
    Web MVC 支持表示层，并帮助您构建灵活且松散耦合的基于 Web 的应用程序。Spring MVC 模块解决了企业应用程序中测试 Web 组件的问题。它允许您在不使用应用程序中的请求和响应对象的情况下编写测试用例。在这里，我们将进一步讨论它。
- en: 'In this chapter, we will not only discuss the internals of Spring MVC, but
    also about the different layers of a web application. We will see here the implementation
    of the MVC pattern including what it is, and why we should use it. We will explore
    the following topics in this chapter about Spring''s MVC web framework:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将讨论 Spring MVC 的内部结构，还将讨论 Web 应用程序的不同层。我们将在这里看到 MVC 模式的实现，包括它是什么，以及为什么我们应该使用它。在本章中，我们将探讨关于
    Spring MVC 网络框架的以下主题：
- en: Implementing MVC patterns on a web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Web 应用程序上实现 MVC 模式
- en: Implementing controllers patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MVC 模式
- en: Configuring `DispatcherServlet` as the Front Controller pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `DispatcherServlet` 配置为前端控制器模式
- en: Enabling Spring MVC and proxying
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Spring MVC 和代理
- en: Accepting request parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受请求参数
- en: Processing the forms of a web page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理网页的表单
- en: Implementing a view in the MVC pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MVC 模式中实现视图
- en: Creating JSP views in a web application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中创建 JSP 视图
- en: The View Helper pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图助手模式
- en: The Composite View pattern with Apache Tiled ViewResolver
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apache Tiled ViewResolver 的组合视图模式
- en: Let's look at all the aforementioned topics in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看上述所有主题。
- en: Implementing the MVC pattern in a web application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中实现 MVC 模式
- en: 'The **Model View Controller pattern** (**MVC pattern**) is a J2EE design pattern.
    It was first introduced by Trygve Reenskaug in his own project to separate the
    different components of the application. That time, he used this pattern on a
    desktop-based application. The main approach of this pattern is to promote the
    separation of concerns principle of the software industry. The MVC pattern divides
    the system into three kinds of components. Each component in the system has specific
    responsibilities. Let''s see these three components of this pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图控制器模式**（**MVC 模式**）是一个 J2EE 设计模式。它最初由 Trygve Reenskaug 在他自己的项目中引入，以分离应用程序的不同组件。当时，他在基于桌面的应用程序上使用了这种模式。这种模式的主要方法是促进软件行业关注点分离的原则。MVC
    模式将系统划分为三种类型的组件。系统中的每个组件都有特定的职责。让我们看看这个模式中的这三个组件：'
- en: '**Model**: The model in the MVC pattern is responsible for maintaining data
    for the view so that it can be rendered in any view template. In short, we can
    say that the model is a data object, such as a `SavingAccount` in the banking
    system, and list of accounts of a branch of any bank.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：在 MVC 模式中，模型负责维护视图所需的数据，以便在任何视图模板中渲染。简而言之，我们可以这样说，模型是一个数据对象，例如银行系统中的
    `SavingAccount`，或者任何银行分支的账户列表。'
- en: '**View**: The view in the MVC pattern is responsible for rendering the model
    to itself in a web application for representation of a page. It presents the data
    of the model in a readable format to the user. There are several technologies
    that provide the view, such as JSP, JSF page, PDF, XML, and so on.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：在MVC模式中，视图负责在Web应用程序中将模型渲染到自身，以表示页面。它以可读的格式向用户展示模型数据。有几种技术可以提供视图，例如JSP、JSF页面、PDF、XML等。'
- en: '**Controller**: This is an actual actionable component in the MVC pattern.
    In Software, the controller code controls the interaction between the view and
    model. Interactions such as form submission or clicking a link are part of the
    controller in an enterprise application. The controller is also responsible for
    creating and updating the model, and forwarding this model to the view for rendering.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是MVC模式中的一个实际可操作的组件。在软件中，控制器代码控制视图和模型之间的交互。例如，表单提交或点击链接等交互都是企业应用程序中控制器的一部分。控制器还负责创建和更新模型，并将此模型转发到视图进行渲染。'
- en: 'Take a look at the following diagram to understand more about the MVC pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图，以了解更多关于MVC模式的信息：
- en: '![](img/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png)'
- en: As you can see in the preceding diagram, there are three components in an application,
    and each component has its own responsibility. As we've already said, the MVC
    pattern is all about separation of concerns. In a software system, separation
    of concerns is very important to make the components flexible and easy to test
    with a clean code structure. In the MVC pattern, the **User** interacts with the
    **Controller** component through the **View** component, and the **Controller**
    component triggers the actual action to prepare the **Model** component. That
    **Model** component propagates the changes to the **View**, and finally, the **View**
    component renders the model in front of the **User**. This is the whole idea behind
    the implementation of the MVC pattern. This approach of MVC pattern properly fits
    most of the applications, especially, desktop applications. This MVC pattern is
    also known as Model 1 architecture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的图中看到的那样，应用程序中有三个组件，每个组件都有自己的职责。正如我们之前所说的，MVC模式就是关注点的分离。在软件系统中，关注点的分离对于使组件灵活且易于通过干净的代码结构进行测试非常重要。在MVC模式中，**用户**通过**视图**组件与**控制器**组件交互，而**控制器**组件触发实际操作以准备**模型**组件。那个**模型**组件将更改传播到**视图**，最终，**视图**组件在**用户**面前渲染模型。这就是MVC模式实现背后的整个理念。这种MVC模式的方法非常适合大多数应用程序，尤其是桌面应用程序。这种MVC模式也被称为Model
    1架构。
- en: But in case you are working with an enterprise web application, things will
    be slightly different from a desktop application, because keeping a model across
    the request life cycle can be quite difficult due to the stateless nature of an
    HTTP protocol. Let's see another modified version of the MVC pattern in the following
    section, and how the Spring framework adopts it to create the enterprise web application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你正在使用企业级Web应用程序，事情将略不同于桌面应用程序，因为由于HTTP协议的无状态特性，在请求生命周期中保持模型可能会相当困难。让我们在下一节中看看MVC模式的另一个修改版本，以及Spring框架如何采用它来创建企业级Web应用程序。
- en: Model 2 architecture MVC pattern with Spring
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Spring的Model 2架构MVC模式
- en: The Model 1 architecture is not very straightforward for a web application.
    Model 1 also has decentralized navigation control, because in this architecture,
    each user contains a separate controller and also different logic to determine
    the next page. That time for web application, Model 1 architecture has Servlet
    and JSP as the main technologies to develop the web applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Model 1架构对于Web应用程序来说并不非常直接。Model 1也有分散的导航控制，因为在这个架构中，每个用户都有一个单独的控制器，以及不同的逻辑来确定下一页。那时对于Web应用程序，Model
    1架构使用Servlet和JSP作为开发Web应用程序的主要技术。
- en: 'For a web application, the MVC pattern is implemented as a Model 2 architecture.
    This pattern provides centralized navigation control logics to easily test and
    maintain the web application, and it also provides better separation of concerns
    than Model 1 architecture for web applications. The difference between the MVC
    pattern based on Model 1 Architecture and the modified MVC pattern based on Model
    2 architecture is that the latter incorporates a front controller that dispatches
    all incoming requests to other controllers. These controllers handle the incoming
    request, return the model, and select the view. take a look at the following diagram
    to better understand the Model 2 architecture MVC pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，MVC模式作为模型2架构实现。这个模式提供了集中的导航控制逻辑，以便轻松测试和维护Web应用程序，并且它还比模型1架构的Web应用程序提供了更好的关注点分离。基于模型1架构的MVC模式和基于模型2架构修改的MVC模式之间的区别在于后者包含一个前端控制器，该控制器将所有传入的请求委派给其他控制器。这些控制器处理传入的请求，返回模型，并选择视图。查看以下图示以更好地理解模型2架构的MVC模式：
- en: '![](img/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png)'
- en: As you can see in the preceding diagram, a new component is introduced for the
    MVC pattern, that is, the front controller. It is implemented as a `javax.servlet.Servlet`
    servlet such as `ActionServlet` in struts, `FacesServlet` in JSF, and `DispatcherServlet`
    in Spring MVC. It handles the incoming requests, and delegates the requests to
    the specific application controller. That application controller creates and updates
    the model, and delegates it to the front controller for rendering. Finally, the
    **Front Controller** determines the specific view, and renders that model data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，为MVC模式引入了一个新的组件，即前端控制器。它实现为一个`javax.servlet.Servlet`，例如struts中的`ActionServlet`，JSF中的`FacesServlet`和Spring
    MVC中的`DispatcherServlet`。它处理传入的请求，并将请求委派给特定的应用程序控制器。该应用程序控制器创建和更新模型，并将其委派给前端控制器进行渲染。最后，**前端控制器**确定特定的视图，并渲染该模型数据。
- en: The Front Controller design pattern
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端控制器设计模式
- en: 'The Front Controller design pattern is a J2EE pattern; it provides solutions
    for the following application design problems:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器设计模式是一个J2EE模式；它为以下应用程序设计问题提供了解决方案：
- en: In a web application based on the Model 1 architecture, too many controllers
    are required to handle too many requests. It is difficult to maintain and reuse
    them.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于模型1架构的Web应用程序中，需要太多的控制器来处理太多的请求。维护和重用它们都很困难。
- en: Each request has its own point of entry in the web application; it should be
    a single point of entry for each request.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求在Web应用程序中都有自己的入口点；每个请求应该有一个单一的入口点。
- en: JSP and Servlet are the main components of the Model 1 MVC pattern, so, these
    components handle both action and view, violating the *Single Responsibility*
    principle.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP和Servlet是模型1 MVC模式的主要组件，因此，这些组件处理动作和视图，违反了*单一职责*原则。
- en: 'The Front Controller provides the solution to the aforementioned design problems
    of the web application. In a web application, it works as the main component which
    routes all requests into framework control. This means that too many requests
    land on a single controller (Front Controller), and then, these requests are delegated
    to the specific controllers. Front Controller provides centralized control, and
    improves the reusability and manageability, because, typically, only the resource
    is registered with the web container. This controller not only handles too many
    requests, but also has following responsibilities:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器为Web应用程序上述的设计问题提供了解决方案。在Web应用程序中，它作为主组件，将所有请求路由到框架控制。这意味着太多的请求都落在单个控制器（前端控制器）上，然后，这些请求被委派给特定的控制器。前端控制器提供集中控制，提高了可重用性和可管理性，因为通常只有资源注册在Web容器中。这个控制器不仅处理太多的请求，还有以下职责：
- en: It initializes the framework to cater to the requests
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它初始化框架以适应请求
- en: It loads the map of all URLs and the components responsible for handling the
    request
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它加载所有URL的映射以及处理请求的组件
- en: It prepares the map for the views
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为视图准备映射
- en: 'Let''s see the following diagram for **Front Controller**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于**前端控制器**的图示：
- en: '![](img/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg)'
- en: As you can see in the preceding diagram, all application requests land at the
    **Front Controller**, and it delegates these requests to the configured application
    controllers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到的，所有应用请求都落在**前端控制器**上，并且它将这些请求委派给配置的应用控制器。
- en: The Spring Framework provides a module based on the MVC pattern, that is, Model
    2 architecture implementation. The Spring MVC module provides out-of-the-box front
    controller pattern implementation by introducing the `org.springframework.web.servlet.DispatcherServlet`
    class. This is a simple `servlet` class, and the backbone of the Spring MVC framework.
    And this Servlet is integrated with the Spring IoC container to benefit the Spring's
    dependency pattern. Spring's web framework uses Spring for its own configuration,
    and all controllers are Spring beans; these controllers are testable artifacts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了一个基于MVC模式的模块，即Model 2架构实现。Spring MVC模块通过引入`org.springframework.web.servlet.DispatcherServlet`类提供了开箱即用的前端控制器模式实现。这是一个简单的`servlet`类，是Spring
    MVC框架的骨干。而且这个Servlet与Spring IoC容器集成，以利用Spring的依赖注入模式。Spring的Web框架使用Spring进行其自身的配置，所有控制器都是Spring
    Bean；这些控制器是可测试的工件。
- en: Let's dive into the internals of Spring MVC in this Chapter, and have a closer
    look at `org.springframework.web.servlet.DispatcherServlet` in the Spring MVC
    framework, and how it handles all incoming requests to the web application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们深入Spring MVC的内部，并更仔细地观察Spring MVC框架中的`org.springframework.web.servlet.DispatcherServlet`，以及它是如何处理Web应用的所有传入请求的。
- en: Processing the life of a request
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求的生命周期
- en: 'Have you ever played a *wooden labyrinth board game, a maze puzzle with a steel
    ball bearing*? You might have played it in your childhood. It was a very crazy
    game. The goal of this game is to send all the steel ball bearings to the center
    of the wooden labyrinth board through interlinked curvy paths, and these curvy
    paths have cuts leading to a second curve near the center. All the balls need
    to navigate to the center of the wooden labyrinth board through these cuts between
    the curvy paths. If one steel ball reaches the center, then we have to be careful
    about this ball so that it does not move away from the center when trying to move
    another ball to the center. You can see this in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经玩过一款*木质迷宫棋盘游戏，一种带有钢球轴承的迷宫谜题*？您可能在童年时玩过。这是一款非常疯狂的游戏。这个游戏的目标是通过相互连接的弯曲路径将所有钢球轴承发送到木质迷宫棋盘的中心，这些弯曲路径在中心附近有切口，通向第二个弯曲路径。所有球都需要通过这些弯曲路径之间的切口导航到木质迷宫棋盘的中心。如果一个钢球到达中心，那么我们必须小心这个球，以确保在尝试将另一个球移动到中心时，它不会离开中心。您可以在以下图中看到这一点：
- en: '![](img/5c9421b7-9fbb-4547-909c-fd02a540e216.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c9421b7-9fbb-4547-909c-fd02a540e216.png)'
- en: The Spring MVC framework is similar to this Wooden Labyrinth board game at first
    glance. Instead of the moving the steel ball bearings through various curvy paths
    and cuts, the Spring MVC framework moves web application requests through various
    components such as the Front Controller, that is, the dispatcher Servlet, handler
    mappings, controllers, and view resolvers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从直观上看，Spring MVC框架与这款木质迷宫棋盘游戏相似。Spring MVC框架不是通过移动钢球轴承通过各种弯曲路径和切口，而是通过各种组件如前端控制器（即分发Servlet）、处理器映射、控制器和视图解析器来移动Web应用请求。
- en: 'Let''s see the request processing flow in the Spring MVC Framework for a web
    application. The request processing workflow of the Spring Web MVC `DispatcherServlet`
    is illustrated in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring MVC框架中Web应用的请求处理流程。Spring Web MVC的`DispatcherServlet`的请求处理工作流程在以下图中展示：
- en: '![](img/5a0220b4-5457-4167-b2ac-809ee99cb479.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a0220b4-5457-4167-b2ac-809ee99cb479.png)'
- en: 'As you already know, the front controller plays a very important role in the
    Model 2 MVC pattern, because it has the responsibility to handle all incoming
    requests to the web application, and prepare the response to the browser. In the
    Spring MVC framework, `org.springframework.web.servlet.DispatcherServlet` plays
    the role of the Front Controller of the Model 2 MVC pattern. As you can see in
    the last diagram, this `DispatcherServlet` uses many other components to fulfill
    its own role. Let''s see the step-by-step request processing in the Spring MVC
    framework:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，前端控制器在Model 2 MVC模式中扮演着非常重要的角色，因为它负责处理所有传入的Web应用请求，并为浏览器准备响应。在Spring MVC框架中，`org.springframework.web.servlet.DispatcherServlet`
    扮演着Model 2 MVC模式的前端控制器角色。正如您在最后一张图中可以看到的，这个`DispatcherServlet` 使用了许多其他组件来履行其自身角色。让我们看看Spring
    MVC框架中逐步的请求处理过程：
- en: A user clicks on the browser or submits a web form of the application. The request
    leaves the browser, either with some additional information or with common information.
    This request lands at Spring's `DispatcherServlet`, which is a simple `servlet`
    class as other java-based web applications. It is a Front Controller of the Spring
    MVC framework, and funnels all the incoming requests through the single point.
    The Spring MVC framework centralizes the request flow control by using this Front
    Controller.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击浏览器或提交应用程序的Web表单。请求离开浏览器，可能带有一些附加信息或常见信息。这个请求到达Spring的`DispatcherServlet`，它是一个简单的`servlet`类，与其他基于Java的Web应用程序类似。它是Spring
    MVC框架的前端控制器，将所有传入的请求通过单一点进行集中处理。Spring MVC框架通过使用这个前端控制器来集中控制请求流程。
- en: After landing a request at Spring's `DispatcherServlet`, it delegates that request
    to the Spring MVC controller, that is, application controller. Although, , there
    may be several controllers in a Spring web application, but each request must
    be delegated to the specific controller. For that, Spring's `DispatcherServlet`
    takes help of the handler mappings configured in the web application. Handler
    mapping decides the particular controller by using the URL and request parameters.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求到达Spring的`DispatcherServlet`后，它将请求委托给Spring MVC控制器，即应用程序控制器。尽管在一个Spring Web应用程序中可能有多个控制器，但每个请求都必须委托给特定的控制器。为此，Spring的`DispatcherServlet`借助在Web应用程序中配置的处理映射来提供帮助。处理映射通过使用URL和请求参数来确定特定的控制器。
- en: Once a particular application controller is decided by Spring's `DispatcherServlet`
    with the help of the handler mapping configuration, `DispatcherServlet` dispatches
    that request to the selected controller. This is the actual controller responsible
    for processing information according to the user's request and its parameters.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Spring的`DispatcherServlet`借助处理映射配置确定了特定的应用程序控制器，`DispatcherServlet`将请求调度到所选控制器。这是负责根据用户的请求及其参数处理信息的实际控制器。
- en: Spring MVC's controller executes the business logic by using business services
    of the application, and it creates the model which wraps the information to be
    carried back to the user, and is displayed in the browser. This model carries
    information according to the user's request. But this model is not formatted,
    and we can use any view template technology to render the model information in
    the browser. That is why Spring MVC's controller also returns a logic view name
    along with the model. Why does it return a logic view name? This is because Spring
    MVC's controller is not tied to any specific view technology such as JSP, JSF,
    Thymeleaf, and so on.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring MVC的控制器通过使用应用程序的业务服务来执行业务逻辑，并创建一个模型，该模型封装了要返回给用户并显示在浏览器中的信息。这个模型根据用户的请求携带信息。但是，这个模型尚未格式化，我们可以使用任何视图模板技术来在浏览器中渲染模型信息。这就是为什么Spring
    MVC的控制器还返回一个逻辑视图名称以及模型。为什么它返回一个逻辑视图名称？这是因为Spring MVC的控制器并未绑定到任何特定的视图技术，如JSP、JSF、Thymeleaf等。
- en: Once again, Spring MVC's `DispatcherServlet` takes the help of the view resolver;
    it is configured in the web application to resolve the view. According to the
    configured `ViewResolver`, it resolves the actual view name instead of the logic
    view name. Now `DispatcherServlet` has the view as well to render the model information.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，Spring MVC的`DispatcherServlet`借助视图解析器；该解析器在Web应用程序中配置，用于解析视图。根据配置的`ViewResolver`，它解析实际的视图名称，而不是逻辑视图名称。现在`DispatcherServlet`也有了视图，可以渲染模型信息。
- en: Spring MVC's `DispatcherServlet` renders the model to the view, and generates
    a user-readable format of the model's information.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring MVC的`DispatcherServlet`将模型渲染到视图中，并生成用户可读的模型信息格式。
- en: Finally, that information creates a response, and returns it to the user's browser
    by `DispatcherServlet`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这些信息生成一个响应，并通过`DispatcherServlet`返回给用户的浏览器。
- en: As you can see, there are several steps and components involved in serving a
    request of the application. Most of these components are related to the Spring
    MVC framework, and these components have their own specific responsibility to
    serve a request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理应用程序请求涉及多个步骤和组件。其中大部分组件与Spring MVC框架相关，并且每个组件都有其特定的职责来处理请求。
- en: 'Till now, you have learned that `DispatcherServlet` is a key component in processing
    requests with Spring MVC. It is the heart of the Spring Web MVC. It is a front
    controller that coordinates all request handling activities analogous to Struts
    `ActionServlet` / JSF `FacesServlet`. It delegates to the web infrastructure beans,
    and invokes user web components. It is also highly flexible, configurable, and
    fully customizable. It is very flexible, because all the components used by this
    servlet are interfaces for all the infrastructure beans. The following table lists
    some of the involved interfaces provided by the Spring MVC Framework:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解到`DispatcherServlet`是使用Spring MVC处理请求的关键组件。它是Spring Web MVC的核心。它是一个前端控制器，类似于Struts的`ActionServlet`
    / JSF的`FacesServlet`，协调所有请求处理活动。它委托给Web基础设施bean，并调用用户Web组件。它也非常灵活、可配置和完全可定制。它非常灵活，因为该servlet使用的所有组件都是所有基础设施bean的接口。以下表格列出了Spring
    MVC框架提供的部分涉及接口：
- en: '| **Spring MVC Component** | **Role in request processing** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Spring MVC 组件** | **在请求处理中的作用** |'
- en: '| `org.springframework.web.multipart.MultipartResolver` | It handles multipart
    requests such as file uploads |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.multipart.MultipartResolver` | 它处理多部分请求，例如文件上传 |'
- en: '| `org.springframework.web.servlet.LocaleResolver` | It handles locale resolution
    and modification |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.LocaleResolver` | 它处理区域解析和修改 |'
- en: '| `org.springframework.web.servlet.ThemeResolver` | It handles theming resolution
    and modification |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.ThemeResolver` | 它处理主题解析和修改 |'
- en: '| `org.springframework.web.servlet.HandlerMapping` | It maps all incoming requests
    to the handler objects. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerMapping` | 它将所有传入请求映射到处理器对象。 |'
- en: '| `org.springframework.web.servlet.HandlerAdapter` | It is based on the Adapter
    pattern, and is used for the handler object type to execute the handler |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerAdapter` | 它基于适配器模式，用于执行处理器对象 |'
- en: '| `org.springframework.web.servlet.HandlerExceptionResolver` | It handles the
    exceptions thrown during handler execution |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerExceptionResolver` | 它处理处理器执行过程中抛出的异常
    |'
- en: '| `org.springframework.web.servlet.ViewResolver` | It translates the logical
    view name to an actual view implementation |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.ViewResolver` | 它将逻辑视图名称转换为实际的视图实现 |'
- en: The components listed in the preceding table work on the Spring MVC Framework
    for the request processing life cycle in a web application. In the upcoming section,
    we'll see how to configure the Spring MVC's main component, that is, `DispatcherServlet`.
    We'll also take a closer look at the different ways of implementation and configuration
    based on either Java or XML.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格中列出的组件在Web应用程序的请求处理生命周期中工作于Spring MVC框架。在下一节中，我们将看到如何配置Spring MVC的主要组件，即`DispatcherServlet`。我们还将更详细地了解基于Java或XML的不同实现和配置方式。
- en: Configuring DispatcherServlet as the Front Controller
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DispatcherServlet配置为前端控制器
- en: In a Java-based web application, all servlets are defined in the `web.xml` file.
    It is loaded in a web container at the bootstrap, and maps each servlet to a particular
    URL pattern. Similarly, the `org.springframework.web.servlet.DispatcherServlet`
    is the centerpiece of the Spring MVC; it needs to be configured in the same file--`web.xml`,
    and it is loaded at the bootstrap of the web application. At the time of bootstrapping,
    `DispatcherServlet` is invoked to create Spring's `org.springframework.web.context.WebApplicationContext`
    by loading the beans' configuration through Java, XML, or annotation-based. The
    servlet tries to fetch all the required components from this web application context.
    It has the responsibility to route the request through all the other components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Java的Web应用程序中，所有servlet都在`web.xml`文件中定义。它在启动时由Web容器加载，并将每个servlet映射到特定的URL模式。同样，`org.springframework.web.servlet.DispatcherServlet`是Spring
    MVC的核心；它需要在同一文件`web.xml`中进行配置，并在Web应用的启动时加载。在启动时，`DispatcherServlet`被调用以通过Java、XML或基于注解的方式加载bean的配置来创建Spring的`org.springframework.web.context.WebApplicationContext`。servlet试图从这个Web应用程序上下文中获取所有必需的组件。它有责任通过所有其他组件路由请求。
- en: '`WebApplicationContext` is a web version of the `ApplicationContext`, as discussed
    in previous chapters of this book. It has some additional capabilities necessary
    for web applications other than the `ApplicationContext`, such as servlet-specific
    scope request, session, and so on. The `WebApplicationContext` is bound in the
    `ServletContext`; you can also access it by using the static method of the `RequestContextUtils`
    class. Let''s see the following code snippet for this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplicationContext` 是 `ApplicationContext` 的Web版本，如本书前几章所述。它具有一些额外的能力，对于Web应用来说，除了
    `ApplicationContext` 之外，如特定于servlet的作用域请求、会话等。`WebApplicationContext` 绑定在 `ServletContext`
    中；你也可以通过使用 `RequestContextUtils` 类的静态方法来访问它。让我们看看以下代码片段：'
- en: '`ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);`'
- en: Defined by XML configuration
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由XML配置定义
- en: 'As you know, `web.xml` is the root file of any web application, placed in the
    `WEB-INF` directory. It has a servlet specification, and contains all the servlet
    configuration to be bootstrapped. Let''s see the required code of the `DispatcherServlet`
    configuration in the web application, which is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`web.xml` 是任何Web应用的根文件，位于 `WEB-INF` 目录中。它包含一个servlet规范，并包含所有需要启动的servlet配置。让我们看看Web应用中
    `DispatcherServlet` 配置所需的代码，如下所示：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is the minimum required code to configure the `DispatcherServlet`
    in a Spring web application using XML-based configuration.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码是使用基于XML的配置在Spring Web应用中配置 `DispatcherServlet` 所需的最小代码。
- en: There is nothing is special in the `web.xml` file; typically, it defines only
    one servlet configuration very similar to the traditional Java web application.
    But DispatcherServlet loads a file which contains the spring beans configuration
    for the application. By default, it loads a file named `[servletname]-servlet.xml`
    from the WEB-INF directory. In our case, the file name should be `bankapp-servlet.xml`
    in the WEB-INF directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `web.xml` 文件中没有什么特别之处；通常，它只定义一个与传统的Java Web应用非常相似的servlet配置。但是，DispatcherServlet会加载一个包含应用spring
    beans配置的文件。默认情况下，它会从 `WEB-INF` 目录加载一个名为 `[servletname]-servlet.xml` 的文件。在我们的例子中，文件名应该是
    `bankapp-servlet.xml`，位于 `WEB-INF` 目录中。
- en: Defined by Java configuration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由Java配置定义
- en: 'In this chapter, instead of the XML configuration, we will use Java to configure
    `DispatcherServlet` in the servlet container for our web application. Servlet
    3.0 and later supports java-based bootstrapping, so, we can avoid using the web.xml
    file. Instead of this, we can create a java class that implements the `javax.servlet.ServletContainerInitializer`
    interface. Spring MVC provides the `WebApplicationInitializer` interface to ensure
    that your spring configuration is loaded and initialized in any Servlet 3 container.
    But the Spring MVC framework makes it even easier by providing an abstract class
    implementation of the `WebApplicationInitializer` interface. By using this abstract
    class, you just map your servlet mapping, and provide the root and MVC configuration
    classes. I, personally, prefer this way of configuration in my web application.
    The following is the code for this configuration class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Java而不是XML来配置我们的Web应用在servlet容器中的 `DispatcherServlet`。Servlet 3.0及以后的版本支持基于Java的启动，因此，我们可以避免使用
    `web.xml` 文件。相反，我们可以创建一个实现 `javax.servlet.ServletContainerInitializer` 接口的Java类。Spring
    MVC提供了一个 `WebApplicationInitializer` 接口，以确保你的Spring配置在任何Servlet 3容器中都被加载和初始化。但是，Spring
    MVC框架通过提供一个 `WebApplicationInitializer` 接口的抽象类实现，使这个过程变得更加简单。通过使用这个抽象类，你只需映射你的servlet映射，并提供根和MVC配置类。我个人更喜欢在我的Web应用中使用这种方式进行配置。以下是这个配置类的代码：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As seen in the preceding code, the `SpringApplicationInitializer` class extends
    the `AbstractAnnotationConfigDispatcherServletInitializer` class. It asks only
    the required information from the developer, and all configurations related to
    the `DispatcherServlet` are configured by this class using the servlet container
    interfaces. Take a look at the following diagram to understand more about the
    `AbstractAnnotationConfigDispatcherServletInitializer` class and its implementation
    to configure the `DispatcherServlet` in the application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`SpringApplicationInitializer` 类扩展了 `AbstractAnnotationConfigDispatcherServletInitializer`
    类。它只从开发者那里获取所需的信息，并且所有与 `DispatcherServlet` 相关的配置都由这个类使用Servlet容器接口来配置。请查看以下图表，以了解更多关于
    `AbstractAnnotationConfigDispatcherServletInitializer` 类及其在应用程序中配置 `DispatcherServlet`
    的实现：
- en: '![](img/523eec9d-ebde-4091-84cc-2153ce838e82.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/523eec9d-ebde-4091-84cc-2153ce838e82.png)'
- en: You have seen that the `SpringApplicationInitilizer` class overrides three methods
    of the `AbstractAnnotationConfigDispatcherServletInitializer` class, that is,
    `getServletMappings()`, `getServletConfigClasses()`, and `getRootConfigClasses()`.
    The method `getServletMappings()` defines the servlet mapping-in our application,
    it's mapped to "`/`"**.** The method `getServletConfigClasses()` asks `DispatcherServlet`
    to load its application context with the beans defined in the `SpringMvcConfig`
    configuration class. This configuration file has bean definitions related to the
    web components such as controllers, view resolvers, and handler mappings. A Spring
    web application has another application context, and it is created by `ContextLoaderListener`.
    So, another method, `getRootConfigClasses()`, loads the other beans such as services,
    repositories, data-source, and other application beans typically required in the
    middle-tier and data-tier of the application defined in the `AppConfig` configuration
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 `SpringApplicationInitilizer` 类覆盖了 `AbstractAnnotationConfigDispatcherServletInitializer`
    类的三个方法，即 `getServletMappings()`、`getServletConfigClasses()` 和 `getRootConfigClasses()`。`getServletMappings()`
    方法定义了 servlet 映射--在我们的应用程序中，它映射到 "`/`"**。**`getServletConfigClasses()` 方法要求 `DispatcherServlet`
    使用在 `SpringMvcConfig` 配置类中定义的 bean 加载其应用程序上下文。此配置文件包含与 Web 组件（如控制器、视图解析器和处理器映射）相关的
    bean 定义。Spring Web 应用程序还有一个应用程序上下文，它是由 `ContextLoaderListener` 创建的。因此，另一个方法 `getRootConfigClasses()`
    加载了其他 bean，如服务、存储库、数据源以及其他在 `AppConfig` 配置类中定义的应用程序中间层和数据层所需的 bean。
- en: The Spring Framework provides a listener class--`ContextLoaderListener`. It
    is responsible for bootstrapping the backend application context.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了一个监听器类--`ContextLoaderListener`。它负责启动后端应用程序上下文。
- en: 'Let''s see the following diagram to understand more about the Spring web application
    design after starting up the servlet container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下图表，以了解在启动 servlet 容器后关于 Spring Web 应用程序设计的更多信息：
- en: '![](img/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png)'
- en: As you can see in the last diagram, the web component beans definitions configuration
    classes returned by the `getServletConfigClasses()` method are loaded by the `DispatcherServlet`,
    and the other application beans definition configuration classes returned by the
    `getRootConfigClasses()` method are loaded by the `ContextLoaderListener`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在最后一张图中看到的，`getServletConfigClasses()` 方法返回的 Web 组件 bean 定义配置类由 `DispatcherServlet`
    加载，而 `getRootConfigClasses()` 方法返回的其他应用程序 bean 定义配置类由 `ContextLoaderListener`
    加载。
- en: A Java-based web configuration will only work when deploying to a server that
    supports **Servlet 3.0**, such as **Apache Tomcat 7 or higher.**
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Java 的 Web 配置仅在部署到支持 **Servlet 3.0** 的服务器上时才有效，例如 **Apache Tomcat 7 或更高版本**。
- en: Let's see how to enable more features of the Spring MVC Framework in the coming
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在下一节中如何启用 Spring MVC 框架的更多功能。
- en: Enabling the Spring MVC
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Spring MVC
- en: There are many ways to configure the `DispatcherServlet` and other web components.
    There are many features of the Spring MVC framework which are not enabled by default,
    such as `HttpMessageConverter`, Support for validating `@Controller` inputs with
    `@Valid`, and so on. So, we can enable these features by using either a Java-based
    configuration or XML configuration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以配置 `DispatcherServlet` 以及其他 Web 组件。Spring MVC 框架有许多默认未启用的功能，例如 `HttpMessageConverter`，支持使用
    `@Valid` 验证 `@Controller` 输入，等等。因此，我们可以通过使用基于 Java 的配置或 XML 配置来启用这些功能。
- en: 'To enable the MVC Java config, add the annotation `@EnableWebMvc` to one of
    your `@Configuration` classes, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 MVC Java 配置，将注解 `@EnableWebMvc` 添加到你的 `@Configuration` 类之一，如下所示：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In XML configuration, we can use MVC namespace, there is an `<mvc:annotation-driven>`
    element that you can use to enable the annotation-driven Spring MVC.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 配置中，我们可以使用 MVC 命名空间，其中有一个 `<mvc:annotation-driven>` 元素，你可以使用它来启用基于注解的
    Spring MVC。
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Spring MVC advanced feature can be enabled in a Spring web application
    either by using the `@EnableWebMvc` annotation, or by using the XML namespace
    `<mvc:annotation-driven/>`. The Spring MVC Framework also allows you to customize
    the default configuration in Java by extending the `WebMvcConfigurerAdapter` class,
    or by implementing the `WebMvcConfigurer` interface. Let''s see the modified configuration
    file after adding a bit more configuration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 的高级功能可以在 Spring Web 应用程序中通过使用 `@EnableWebMvc` 注解或使用 XML 命名空间 `<mvc:annotation-driven/>`
    来启用。Spring MVC 框架还允许您通过扩展 `WebMvcConfigurerAdapter` 类或实现 `WebMvcConfigurer` 接口来在
    Java 中自定义默认配置。让我们看看添加更多配置后的修改后的配置文件：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the preceding code, the configuration class `SpringMvcConfig` is
    annotated with `@Configuration`, `@ComponentScan`, and `@EnableWebMvc`. Here,
    the `com.packt.patterninspring.chapter10.bankapp.web.controller` package will
    be scanned for components. This class extends the `WebMvcConfigurerAdapter` class,
    and overrides the `configureDefaultServletHandling()` method. We have also configured
    a `ViewResolver` bean.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，配置类 `SpringMvcConfig` 被注解为 `@Configuration`、`@ComponentScan` 和 `@EnableWebMvc`。在这里，`com.packt.patterninspring.chapter10.bankapp.web.controller`
    包将被扫描以查找组件。这个类扩展了 `WebMvcConfigurerAdapter` 类，并重写了 `configureDefaultServletHandling()`
    方法。我们还配置了一个 `ViewResolver` bean。
- en: Till now, you have learned what is the MVC pattern and architecture, and how
    to set up `DispatcherServlet` and enable the essential Spring MVC components for
    a Spring web application. In the upcoming section, we'll discuss how to implement
    controllers in a Spring application, and how these controllers handle web requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了 MVC 模式和架构是什么，以及如何设置 `DispatcherServlet` 并启用 Spring Web 应用程序的基本
    Spring MVC 组件。在下一节中，我们将讨论如何在 Spring 应用程序中实现控制器，以及这些控制器如何处理 Web 请求。
- en: Implementing controllers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制器
- en: As we have seen in the MVC pattern, controllers are also one of the crucial
    components of the MVC pattern. They are responsible for executing the actual request,
    preparing the model, and sending this model along with logical view name to the
    front controller. In a web application, the controllers work between the web layer
    and the core application layer. In the Spring MVC framework, controllers are also
    more like POJO classes with methods; these methods are known as handlers, because
    these are annotated with the `@RequestMapping` annotation. Let's see how to define
    controller classes in a Spring web application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 MVC 模式中所见，控制器也是 MVC 模式中的关键组件之一。它们负责执行实际请求、准备模型，并将此模型连同逻辑视图名称发送到前端控制器。在
    Web 应用程序中，控制器在 Web 层和核心应用程序层之间工作。在 Spring MVC 框架中，控制器更像是有方法的 POJO 类；这些方法被称为处理器，因为它们被
    `@RequestMapping` 注解所标记。让我们看看如何在 Spring Web 应用程序中定义控制器类。
- en: Defining a controller with @Controller
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @Controller 定义控制器
- en: 'Let''s create a controller class for our bank application. `HomeController`
    is a controller class that handles requests for `/` and renders the homepage of
    the bank application:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的银行应用程序创建一个控制器类。`HomeController` 是一个控制器类，它处理 `/` 的请求并渲染银行应用程序的首页：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the preceding code, the `HomeController` class contains the
    `home()` method. It is a handler method, because it is annotated with the `@RequestMapping`
    annotation. It specifies that this method handles all the requests that are mapped
    to the `/` URL. Another thing to notice is that our controller class, `HomeController`,
    is also annotated with the `@Controller` annotation. As we know, `@Controller`
    is a stereotype annotation, and it is also used to create the bean in the Spring
    IoC container similar to the other Meta annotations of the `@Component` annotation
    such as `@Service` and `@Repository.` Yes, this annotation specifies any class
    as the controller, and adds some more capability of Spring MVC to that class.
    You could also use the `@Component` annotation instead of `@Controller` to create
    Spring beans in a web application, but in this case, that bean does not have the
    capability of the Spring MVC framework such as exception handling at web layer,
    handler mapping, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`HomeController`类包含`home()`方法。它是一个处理器方法，因为它被`@RequestMapping`注解标记。它指定此方法处理所有映射到`/`
    URL的请求。另一个需要注意的事情是我们的控制器类`HomeController`也被`@Controller`注解标记。正如我们所知，`@Controller`是一个
    stereotypes 注解，它也被用来在 Spring IoC 容器中创建 bean，类似于`@Component`注解的其他元注解，如`@Service`和`@Repository`。是的，这个注解指定任何类作为控制器，并给这个类添加一些
    Spring MVC 的更多功能。你也可以使用`@Component`注解代替`@Controller`来在 Web 应用程序中创建 Spring beans，但在这个情况下，那个
    bean 没有像在 Web 层的异常处理、处理器映射等功能一样的 Spring MVC 框架的能力。
- en: Let's take a closer look at the `@RequestMapping` annotation, and also the composed
    variants of the `@RequestMapping` annotation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`@RequestMapping`注解，以及`@RequestMapping`注解的复合变体。
- en: Mapping requests with @RequestMapping
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@RequestMapping`映射请求
- en: 'The previously defined `HomeController` class has only one handler method,
    and this method is annotated with the `@RequestMapping` annotation. Here, I have
    used two attributes of this annotation--one is value to map the HTTP request to
    the `/` pattern, and the other attribute is a method for supporting the HTTP `GET`
    method. We can define multiple URL mappings with one handler method. Let''s see
    this in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`HomeController`类只有一个处理器方法，此方法被`@RequestMapping`注解标记。在这里，我使用了这个注解的两个属性——一个是value属性，用于将
    HTTP 请求映射到`/`模式，另一个属性是一个支持 HTTP `GET`方法的方法。我们可以使用一个处理器方法定义多个 URL 映射。让我们在以下代码片段中看看这个例子：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, the `@RequestMapping` annotation has an array of string
    values for the value attribute of this annotation. Now, this handler method is
    mapped with two URL patterns, such as `/` and `/index`. The Spring MVC''s `@RequestMapping`
    annotation supports several HTTP methods such as `GET`, `POST`, `PUT`, `DELETE`,
    and so on. As of version 4.3, Spring composed `@RequestMapping` variants, and
    now provides simple methods for the mapping of common HTTP methods, as shown in
    the following expressions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@RequestMapping`注解的value属性有一个字符串值数组。现在，这个处理器方法被映射到两个 URL 模式，例如`/`和`/index`。Spring
    MVC 的`@RequestMapping`注解支持多种 HTTP 方法，如`GET`、`POST`、`PUT`、`DELETE`等。截至版本 4.3，Spring
    组合了`@RequestMapping`变体，现在提供了映射常见 HTTP 方法的简单方法，如下所示的表达式：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the modified version of `HomeController` with composed annotation mappings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的`HomeController`，带有复合注解映射：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use the `@RequestMapping` annotation at both locations: at the class
    level, and at the method level. Let''s see examples for this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在两个位置使用`@RequestMapping`注解：在类级别，以及在方法级别。让我们看看这个例子：
- en: '@RequestMapping at method level'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法级别的`@RequestMapping`
- en: 'Spring MVC allows you to use the `@RequestMapping` annotation at the method
    level to make this method as handler method in the Spring web application. Let''s
    see how to use it in the following class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 允许你在方法级别使用`@RequestMapping`注解，将此方法作为 Spring 网络应用程序中的处理器方法。让我们看看如何在以下类中使用它：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the preceding code, I have used the `@RequestMapping` annotation
    with three methods `home()`, `create()`, and `saveUser()`. Here I have also used
    the attributes "value" and "method" of this annotation. The "value" attribute
    has the request mapping with request URL and "method" attribute is used to define
    the HTTP request methods such GET or POST. Mapping rules are, typically, URL-based,
    and, optionally, use wild cards, as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，我使用了`@RequestMapping`注解，并带有三个方法`home()`、`create()`和`saveUser()`。在这里，我还使用了这个注解的“value”和“method”属性。其中，“value”属性包含请求映射和请求URL，“method”属性用于定义HTTP请求方法，如GET或POST。映射规则通常是基于URL的，并且可选地使用通配符，如下所示：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the handler methods have some arguments as well, so
    we can pass any number of arguments of any type. The Spring MVC will handle these
    arguments as request parameters. Let's see first how to define `@RequestMapping`
    at the class level, then we will discuss the request parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，处理方法有一些参数，因此我们可以传递任何类型和数量的参数。Spring MVC将这些参数作为请求参数处理。让我们首先看看如何在类级别上定义`@RequestMapping`，然后我们将讨论请求参数。
- en: '@RequestMapping at the class level'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类级别的`@RequestMapping`
- en: 'The Spring MVC allows you to use the `@RequestMapping` annotation at the class
    level. This means we can annotate the controller class with `@RequestMapping`,
    as shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC允许您在类级别上使用`@RequestMapping`注解。这意味着我们可以使用`@RequestMapping`注解控制器类，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you have seen in the preceding code, the `HomeController` class is annotated
    with the `@RequestMapping` and `@Controller` annotations. But the HTTP method
    is still defined above the handler methods. Class-level mapping is applied with
    all the handler methods defined under this controller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，`HomeController`类被注解了`@RequestMapping`和`@Controller`注解。但是HTTP方法仍然定义在处理方法之上。类级别的映射应用于此控制器下定义的所有处理方法。
- en: 'After the Spring MVC configuration, we created a controller class with the
    handler methods. Let''s test this controller before moving ahead with more details.
    In this book, I haven''t use any JUnit test cases, so here, I will just run this
    web application on the Tomcat container. You can see the output on the browser
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC配置之后，我们创建了一个控制器类，其中包含处理方法。在深入更多细节之前，让我们测试这个控制器。在这本书中，我没有使用任何JUnit测试用例，所以在这里，我将在Tomcat容器上运行这个Web应用程序。您可以在浏览器中看到以下输出：
- en: '![](img/f4c6014d-f22c-4a85-91a5-0799fb2c7d8b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4c6014d-f22c-4a85-91a5-0799fb2c7d8b.png)'
- en: The last image is the homepage of our **Bank Management System** web application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一张图片是我们**银行管理系统**Web应用程序的首页。
- en: Before Spring 3.1, the Spring MVC mapped the requests to handler methods using
    two steps. First, the controller was selected by `DefaultAnnotationHandlerMapping`,
    and then, the actual method was mapped with the incoming requests by the `AnnotationMethodHandlerAdapter`.
    But as of Spring 3.1, Spring MVC maps the requests, in one step, directly to the
    handler methods by using `RequestMappingHandlerMapping`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring 3.1之前，Spring MVC使用两步将请求映射到处理方法。首先，通过`DefaultAnnotationHandlerMapping`选择控制器，然后通过`AnnotationMethodHandlerAdapter`将实际方法映射到传入的请求。但是从Spring
    3.1开始，Spring MVC通过使用`RequestMappingHandlerMapping`直接一步将请求映射到处理方法。
- en: In the next section, we'll see how to define the handler methods, and the return
    type and parameters allowed for the handler methods in Spring MVC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何定义处理方法，以及Spring MVC中处理方法的允许返回类型和参数。
- en: Defining @RequestMapping handler methods
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`@RequestMapping`处理方法
- en: 'In the Spring MVC Framework, the `@RequestMapping` handler methods are very
    flexible in defining signatures. You can pass any number of arguments in any order.
    These methods support most type of arguments, and are also very flexible in the
    return type as well. It can have several return types, some of which are listed
    next:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC框架中，`@RequestMapping`处理方法在定义签名方面非常灵活。您可以在任何顺序中传递任意数量的参数。这些方法支持大多数类型的参数，并且在返回类型方面也非常灵活。它可以有多个返回类型，其中一些如下列出：
- en: Supported method argument types
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的方法参数类型
- en: Request or response objects (Servlet API)
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求或响应对象（Servlet API）
- en: Session object (Servlet API)
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话对象（Servlet API）
- en: '`java.util.Locale`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Locale`'
- en: '`java.util.TimeZone`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.TimeZone`'
- en: '`java.io.InputStream` / `java.io.Reader`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.InputStream` / `java.io.Reader`'
- en: '`java.io.OutputStream` / `java.io.Writer`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.OutputStream` / `java.io.Writer`'
- en: '`java.security.Principal`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.security.Principal`'
- en: '`@PathVariable`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathVariable`'
- en: '`@RequestParam`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestParam`'
- en: '`@RequestBody`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestBody`'
- en: '`@RequestPart`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestPart`'
- en: '`java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`'
- en: '`org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`'
- en: 'Supported method return types:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的方法返回类型：
- en: '`ModelAndView`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelAndView`'
- en: '`Model`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`'
- en: '`Map`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`'
- en: '`View`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`'
- en: '`String`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`void`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`HttpEntity<?>` or `ResponseEntity<?>`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpEntity<?>` 或 `ResponseEntity<?>`'
- en: '`HttpHeaders`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpHeaders`'
- en: '`Callable<?>`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable<?>`'
- en: '`DeferredResult<?>`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeferredResult<?>`'
- en: I have listed some of the supported return types and method argument types.
    It seems that Spring MVC is very flexible and customizable in the nature of defining
    the request handler methods unlike other MVC frameworks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出了一些支持的返回类型和方法参数类型。看起来 Spring MVC 在定义请求处理方法方面非常灵活和可定制，与其他 MVC 框架不同。
- en: 'In the Spring MVC framework, even the handler method can have any ordering
    of the arguments, but in case of Errors or `BindingResult` parameters, we have
    to put these parameters first, followed by the model object for being bound immediately,
    because the handler method might have any number of model objects, and Spring
    MVC creates separate instances of the Errors or `BindingResult` for each of them.
    For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring MVC 框架中，处理方法甚至可以以任何顺序传递参数，但在 Errors 或 `BindingResult` 参数的情况下，我们必须将这些参数放在前面，然后是模型对象，以便立即绑定，因为处理方法可能有任意数量的模型对象，Spring
    MVC 为每个对象创建单独的 Errors 或 `BindingResult` 实例。例如：
- en: '**Invalid location** `@PostMapping`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**无效位置** `@PostMapping`'
- en: '`public String saveUser(@ModelAttribute ("user") User user, ModelMap model,
    BindingResult result){...}`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`public String saveUser(@ModelAttribute ("user") User user, ModelMap model,
    BindingResult result){...}`'
- en: '**Valid location** `@PostMapping`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效位置** `@PostMapping`'
- en: '`public String saveUser(@ModelAttribute ("user") User user, BindingResult result,
    ModelMap model){...}`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`public String saveUser(@ModelAttribute ("user") User user, BindingResult result,
    ModelMap model){...}`'
- en: Let's see how to pass model data to the view layer in the upcoming section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中如何将模型数据传递到视图层。
- en: Passing model data to the view
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型数据传递到视图
- en: 'As of now, we have implemented a very simple `HomeCotroller`, and tested it.
    But in the web application, we have also passed model data to the view layer.
    That model data we passed in the model (in a simple word, it is `Map`), and that
    model is returned by the controller along with logical view name. As you already
    know, Spring MVC supports several return types of the handler method. Let''s see
    the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个非常简单的 `HomeCotroller` 并对其进行了测试。但在网络应用程序中，我们也向视图层传递了模型数据。我们传递到模型中的模型数据（简单来说，它是一个
    `Map`），控制器与逻辑视图名称一起返回该模型。正如你所知道的那样，Spring MVC 支持处理方法的多种返回类型。让我们看看以下示例：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding example, the `AccountController` class has three
    handler methods. Two handler methods return the model data along with the logical
    view name. But in this example, I am using Spring MVC's `ModelMap`, so, we don't
    need to forcefully return as logical view, it binds automatically with the response.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`AccountController` 类有三个处理方法。两个处理方法返回模型数据和逻辑视图名称。但在这个例子中，我正在使用 Spring
    MVC 的 `ModelMap`，因此，我们不需要强制返回逻辑视图，它将自动与响应绑定。
- en: Next you'll learn how to accept request parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何接受请求参数。
- en: Accepting request parameters
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受请求参数
- en: 'In a Spring web application, sometimes, we just read the data from the server
    side like in our example. Reading data for all the accounts was a simple read
    call, and no request parameter was required. But in case you want to fetch data
    for a particular account, then you have to pass the account ID with the request
    parameters. Similarly, for creating a new Account in the bank, you have to pass
    an account object as a parameter. In Spring MVC, we can accept the request parameters
    in the following ways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 网络应用程序中，有时我们只是从服务器端读取数据，就像我们的例子一样。读取所有账户的数据是一个简单的读取调用，不需要请求参数。但如果你想要获取特定账户的数据，你必须将账户
    ID 与请求参数一起传递。同样，为了在银行创建新的账户，你必须将账户对象作为参数传递。在 Spring MVC 中，我们可以以下方式接受请求参数：
- en: Taking query parameters
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取查询参数
- en: Taking request parameters via path variables
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过路径变量获取请求参数
- en: Taking form parameters
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取表单参数
- en: Let's look at each of these ways one by one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些方法。
- en: Taking query parameters
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取查询参数
- en: 'In a web application, we can fetch the request parameters from the request-the
    account ID in our example if you want to access the details of a particular account.
    Let''s fetch the account ID from the request parameter using the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，我们可以从请求中获取请求参数——在我们的例子中是账户ID，如果你想要访问特定账户的详细信息。让我们使用以下代码从请求参数中获取账户ID：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, I have used the traditional way to access the
    request parameters. The Spring MVC framework provides an annotation, `@RequestParam`,
    to access the request parameters. Let''s use the `@RequestParam` annotation to
    bind the request parameters to a method parameter in your controller. The following
    code snippet shows the usage of the `@RequestParam` annotation. It extracts the
    parameter from the request, and performs type conversion as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我使用了传统的访问请求参数的方式。Spring MVC框架提供了一个注解`@RequestParam`来访问请求参数。让我们使用`@RequestParam`注解将请求参数绑定到控制器中的方法参数。以下代码片段展示了`@RequestParam`注解的使用。它从请求中提取参数，并执行类型转换：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we access the request parameter by using the `@RequestParam`
    annotation, and you can also notice that I didn't use the type conversion from
    `String` to `Long`, it will be done automatically by this annotation. One more
    thing to note here is that parameters using this annotation are required by default,
    but Spring allows you to override this behavior by using the `required` attribute
    of the `@RequestParam` annotation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过使用`@RequestParam`注解来访问请求参数，你也可以注意到我没有使用从`String`到`Long`的类型转换，这将由这个注解自动完成。这里还有一个需要注意的事项，即使用这个注解的参数默认是必需的，但Spring允许你通过使用`@RequestParam`注解的`required`属性来覆盖这个行为。
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's see how to use path variables to take input as part of the request
    path.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用路径变量来获取请求路径的一部分作为输入。
- en: Taking request parameters via path variables
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过路径变量获取请求参数
- en: 'Spring MVC allows you to pass parameters in the URI instead of passing them
    through request parameters. The passed values can be extracted from the request
    URLs. It is based on URI templates. It is not a Spring-specific concept, and is
    used in many frameworks by using `{...}` placeholders and the `@PathVariable`
    annotation. It allows clean URLs without request parameters. The following is
    an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC允许你通过URI传递参数，而不是通过请求参数传递。传递的值可以从请求URL中提取。它基于URI模板。这不是Spring特有的概念，许多框架通过使用`{...}`占位符和`@PathVariable`注解来实现这一点。它允许创建没有请求参数的干净URL。以下是一个示例：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous handler, the method can handle the request like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个处理器中，方法可以像这样处理请求：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/ea3b22a3-5441-481c-aed4-8f39359f9b3c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea3b22a3-5441-481c-aed4-8f39359f9b3c.png)'
- en: 'But in the preceding example, the handler method can handle the request such
    as:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但在前面的示例中，处理器方法可以处理如下请求：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/788b5f14-6d7c-4ad5-9af7-c6d175d5155a.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/788b5f14-6d7c-4ad5-9af7-c6d175d5155a.png)'
- en: We have seen in the preceding code and images how to pass a value either by
    using request parameters or using path parameters. Both ways are fine if you are
    passing small amounts of data on a request. But in some cases, we have to pass
    a lot of data to the server, such as form submission. Let's see how to write controller
    methods that handle form submissions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码和图像中已经看到了如何通过使用请求参数或路径参数来传递一个值。如果你在请求中传递少量数据，这两种方式都是可行的。但在某些情况下，我们必须向服务器传递大量数据，例如表单提交。让我们看看如何编写处理表单提交的控制器方法。
- en: Processing forms of a web page
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理网页的表单形式
- en: As you know, in any web application, we can send and receive data from the server.
    In a web application, we send the data by filling out forms, and submitting this
    form to the server. Spring MVC also provides support for form handling of the
    client end by displaying the form, validating the form data, and submitting this
    form data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，在任何Web应用程序中，我们都可以从服务器发送和接收数据。在Web应用程序中，我们通过填写表单并提交这个表单到服务器来发送数据。Spring
    MVC也通过显示表单、验证表单数据以及提交这些表单数据来为客户端提供表单处理的支持。
- en: 'Basically, Spring MVC handles the form displaying and form processing first.
    In the Bank management application, you will need to create a new user, and open
    a new account in the bank, so, let''s create a controller class, AccountController,
    with a single request-handling method for displaying the account open form, as
    follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Spring MVC首先处理表单显示和表单处理。在银行管理应用程序中，你需要创建一个新的用户，并在银行中开设一个新的账户，因此，让我们创建一个控制器类，AccountController，它包含一个用于显示开户表单的单个请求处理方法，如下所示：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `openAccountForm()` method's `@GetMapping` annotation declares that it will
    handle the HTTP GET requests for /open-account. It's a simple method, taking no
    input and only returning a logical view named `accountForm`. We have configured
    `InternalResourceViewResolver`, which means that the JSP at `/WEB-INF/views/accountForm.jsp`
    will be called on to render the open account form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`openAccountForm()`方法的`@GetMapping`注解声明它将处理对`/open-account`的HTTP GET请求。这是一个简单的方法，没有输入，只返回一个名为`accountForm`的逻辑视图。我们已经配置了`InternalResourceViewResolver`，这意味着将调用`/WEB-INF/views/accountForm.jsp`中的JSP来渲染开户表单。'
- en: 'Here''s the JSP you''ll use for now:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您现在将使用的JSP代码：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see in the preceding code, we have an open account form. It has
    some fields such as `AccountId`, `Account Name`, and `Initial Balance`. This JSP
    page has the `<form>` tag for the form, and this `<form>` tag doesn''t have any
    action parameter. This means that when we submit this form, it will post the form
    data to the same URI `/open-account` with the `POST` HTTP method call. The following
    screenshot displays the account form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中可以看到，我们有一个开户表单。它包含一些字段，例如`AccountId`、`Account Name`和`Initial Balance`。这个JSP页面有一个用于表单的`<form>`标签，而这个`<form>`标签没有任何action参数。这意味着当我们提交这个表单时，它将使用`POST`
    HTTP方法调用将表单数据发送到相同的URI `/open-account`。以下截图显示了账户表单：
- en: '![](img/22c32b1b-53cf-4171-8577-146ea46a1bf5.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22c32b1b-53cf-4171-8577-146ea46a1bf5.png)'
- en: Let's add another method to handle the call for the HTTP `POST` method with
    the same URI, `/open-account`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个方法来处理对HTTP `POST`方法具有相同URI `/open-account`的调用。
- en: Implementing a form handling controller
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现表单处理控制器
- en: 'Let''s see the same `AccountController` class by adding another handler method
    to handle the HTTP `POST` request for the URI `/open-account` in the web application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Web应用程序中为URI `/open-account`添加另一个处理方法来查看相同的`AccountController`类：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in the preceding code, we have added two more handler methods
    in the `AccountController` method, and also injected the service `AccountService`
    with this controller to save the account details in the database. Whenever we
    process the `POST` request from the open account form, the controller accepts
    the account form data, and saves it to the database by using the injected account
    service. It will accept the account form data as an Account object. You may also
    notice here that after processing the form data using the HTTP `POST` method,
    the handler method redirects to the account details page. It is also a better
    practice to redirect after `POST` submission to prevent accidentally submitting
    the form twice. The following screen is displayed after submission of the request:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中可以看到，我们在`AccountController`方法中添加了两个额外的处理方法，并且将服务`AccountService`注入到这个控制器中，以便将账户详情保存到数据库中。每当处理来自开户表单的`POST`请求时，控制器接受账户表单数据，并通过注入的账户服务将其保存到数据库中。它将账户表单数据作为账户对象接受。您可能也会注意到，在通过HTTP
    `POST`方法处理表单数据后，处理方法将重定向到账户详情页面。在`POST`提交后重定向也是一个更好的实践，以防止意外地两次提交表单。以下是在提交请求后显示的屏幕截图：
- en: '![](img/ba094c31-5de1-41f8-a501-baf17624c557.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba094c31-5de1-41f8-a501-baf17624c557.png)'
- en: 'As you can see in the preceding output on the browser, this page is rendered
    after submitting the account form. Because we have added one request handler method,
    this handler method handles the request, and renders another web page including
    the account details. The following JSP page is rendered as the view of the preceding
    output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在浏览器的前面输出中可以看到，提交账户表单后，这个页面被渲染。因为我们添加了一个请求处理方法，这个处理方法处理了请求，并渲染了包含账户详情的另一个网页。以下JSP页面作为前面输出的视图被渲染：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this last code, the handler method sends the `Account` object to the model,
    and also returns the logical view name. This JSP page renders the `Account` object
    taken from the response.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段最后的代码中，处理方法将`Account`对象发送到模型，并返回逻辑视图名称。这个JSP页面渲染从响应中获取的`Account`对象。
- en: One thing to be noticed here is that the Account object has ID, name, and balance
    properties, which will be populated from the request parameters of the same name
    as the field name in the account form. If any object property name matches the
    field name of the HTML form, then this property will be initialized with a NULL
    value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，账户对象有ID、名称和余额属性，这些属性将从与账户表单中字段名称相同的请求参数中填充。如果任何对象属性名称与HTML表单的字段名称匹配，则此属性将使用NULL值初始化。
- en: Data binding with Command Design pattern
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令设计模式进行数据绑定
- en: Encapsulate a request as an object, thereby letting you parameterize clients
    with different requests, queue or log requests, and support undoable operations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求封装为一个对象，从而让您可以使用不同的请求参数化客户端，排队或记录请求，并支持可撤销操作。
- en: '- GOF Design Pattern'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF 设计模式'
- en: You learned about the Command Design pattern in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*. It is a part of the Behavioral
    pattern family of the GOF pattern. It is a very simple data-driven pattern. It
    allows you to encapsulate your request data into an object, and pass that object
    as a command to the invoker method, and that method returns the command as another
    object to the caller.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 [第 3 章](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml) 中学习了命令设计模式，*考虑结构性和行为模式*。它是
    GOF 模式行为模式家族的一部分。它是一个非常简单的数据驱动模式。它允许您将请求数据封装到对象中，并将该对象作为命令传递给调用者方法，该方法将命令作为另一个对象返回给调用者。
- en: 'Spring MVC implements the Command Design pattern to bind the request data from
    the web form as an Object, and passes that object to the request handler method
    in the controller class. Here, we will explore how to use this pattern to bind
    the request data to the Object, and also explore the benefits and possibilities
    of using data binding. In the following class, the `Account` java bean is a simple
    object with three properties--`id`, `name`, and `balance`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 实现了命令设计模式（Command Design pattern），将来自网页表单的请求数据作为一个对象绑定，并将该对象传递给控制器类中的请求处理器方法。在这里，我们将探讨如何使用此模式将请求数据绑定到对象，并探讨使用数据绑定的好处和可能性。在以下类中，`Account`
    Java Bean 是一个具有三个属性（`id`、`name` 和 `balance`）的简单对象：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Either we submit the web form with the input text fields' names the same as
    the Object properties' name, or we receive the request as `http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?id=10000`.
    In both cases, behind the scenes, Spring calls the setter methods of the Account
    class to bind the request data or web form data to the object. Spring also allows
    you to bind indexed collections such as List, Map, and others.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要么我们提交与对象属性名称相同的输入文本字段名称的网页表单，要么我们以 `http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?id=10000`
    的形式接收请求。在这两种情况下，在幕后，Spring 调用 `Account` 类的设置方法来绑定请求数据或网页表单数据到对象。Spring 还允许您绑定索引集合，如
    List、Map 等。
- en: 'We can also customize data binding. Spring provides these two ways to customize
    data binding:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以自定义数据绑定。Spring 提供了两种自定义数据绑定的方式：
- en: '**Global Customization**: It customizes the data-binding behavior across the
    web application for a particular Command Object'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局自定义**：它为特定的命令对象在整个 Web 应用程序中自定义数据绑定行为'
- en: '**Per Controller Customization**: It customizes the data-binding behavior per
    controller class for a particular Command Object'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按控制器自定义**：它为特定命令对象针对每个控制器类自定义数据绑定行为'
- en: 'Here, I will discuss only the per controller customization. Let''s see the
    following code snippet for customizing data binding for the `Account` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将仅讨论针对特定控制器的自定义。让我们看看以下代码片段，用于自定义 `Account` 对象的数据绑定：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the preceding code, `AccountController` has a `initBinder(WebDataBinder
    binder)` annotated with the `@InitBinder` annotation. This method must have a
    void return type, and have an `org.springframework.web.bind.WebDataBinder` as
    a method argument. The `WebDataBinder` object has several methods; we have used
    some them in the preceding code. `WebDataBinder` is used to customize the data
    binding.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`AccountController` 有一个 `initBinder(WebDataBinder binder)` 方法，该方法被 `@InitBinder`
    注解标记。此方法必须具有 void 返回类型，并且有一个 `org.springframework.web.bind.WebDataBinder` 作为方法参数。`WebDataBinder`
    对象有多个方法；我们在前述代码中使用了其中一些。`WebDataBinder` 用于自定义数据绑定。
- en: Using @ModelAttributes for customizing data binding
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `@ModelAttributes` 自定义数据绑定
- en: 'Spring MVC provides one more annotation, `@ModelAttributes`, for binding data
    to the `Command` object. It is another way to bind the data and to customize the
    data binding. This annotation allows you to control the creation of the `Command`
    object. In a Spring MVC application, this annotation can be used on a method and
    on method arguments. Let''s see the following examples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 提供了一个额外的注解 `@ModelAttributes`，用于将数据绑定到 `Command` 对象。这是绑定数据并自定义数据绑定的一种方法。此注解允许您控制
    `Command` 对象的创建。在 Spring MVC 应用程序中，此注解可以用于方法和方法参数。让我们看看以下示例：
- en: Using `@ModelAttribute` on methods
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法上使用 `@ModelAttribute`
- en: 'We can use the `ModelAttribute` annotation on methods to create an object to
    be used in our form, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方法上使用`ModelAttribute`注解来创建一个用于我们表单的对象，如下所示：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using `@ModelAttribute` on method arguments
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法参数上使用`@ModelAttribute`
- en: 'We can also use this annotation on a method argument. In this case, the handler
    method''s arguments are looked up from the model object. If these are not available
    in the model, then they are created by using the default constructor:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在方法参数上使用这个注解。在这种情况下，处理方法的方法参数是从模型对象中查找的。如果它们在模型中不可用，则将使用默认构造函数创建：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see in the last code snippet, the `@ModelAttribute` annotation is
    used on the method argument. This means that the `Account` object fetches from
    the model object. If it is not there, it will be created by using the default
    constructor.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在最后的代码片段中所看到的，`@ModelAttribute`注解被用于方法参数上。这意味着`Account`对象是从模型对象中获取的。如果它不存在，它将使用默认构造函数创建。
- en: When the `@ModelAttribute` annotation is put on a method, this method will be
    called before the request handling method is called.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@ModelAttribute`注解放在一个方法上时，这个方法将在请求处理方法被调用之前被调用。
- en: Till now, we have seen how Spring MVC handles requests and request parameters
    either in the traditional way or by using the `@RequestParam`, `@PathVariable`
    annotations. We have also seen how to process the form web page and handle the
    `POST` request with the form data binding to an object in the controller layers.
    Now let's move to see how to validate if the submitted form data is valid or invalid
    for the business.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Spring MVC如何以传统方式或通过使用`@RequestParam`、`@PathVariable`注解来处理请求和请求参数。我们还看到了如何处理表单网页，并在控制器层中将表单数据绑定到对象来处理`POST`请求。现在让我们来看看如何验证提交的表单数据对于业务是否有效或无效。
- en: Validating forms input parameters
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证表单输入参数
- en: In a web application, validation of the web form data is very important, because
    end users can submit any thing. Suppose in an application, a user submits the
    account form by filling in the account name, then it could create the new account
    in the bank with account holder name. So, we have to ensure the validity of the
    form data before creating the new record in the database. You do not need to handle
    the validation logic in the handler method. Spring provides support for the JSR-303
    API. As of Spring 3.0, Spring MVC supports this Java Validation API. There isn't
    much configuration required to configure the Java Validation API in your Spring
    web application-you just add the implementation of this API in your application
    class path such as Hibernate Validator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Web应用程序中，验证表单数据非常重要，因为最终用户可以提交任何内容。假设在一个应用程序中，用户通过填写账户名称提交账户表单，那么它可以在银行创建新的账户，账户持有人名称。因此，我们必须在数据库中创建新记录之前确保表单数据的有效性。您不需要在处理方法中处理验证逻辑。Spring提供了对JSR-303
    API的支持。从Spring 3.0开始，Spring MVC支持这个Java验证API。在您的Spring Web应用程序中配置Java验证API不需要太多配置——您只需将此API的实现添加到您的应用程序类路径中，例如Hibernate
    Validator。
- en: 'The Java Validation API has several annotations to validate the properties
    of the `Command` object. We can place constraints on the value of the properties
    of the `Command` object. In this chapter, I have not explored all these annotations,
    but let''s see the following examples with some of these annotations:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Java验证API有几个注解来验证`Command`对象的属性。我们可以对`Command`对象属性的值施加约束。在本章中，我没有探索所有这些注解，但让我们看看以下使用一些这些注解的示例：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the preceding code, the properties of the Account class are
    now annotated with `@NotNull` to ensure that the value must not be null, and some
    properties are also annotated with the `@Size` annotation to ensure the count
    of characters between the minimum and maximum lengths.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面代码中所看到的，Account类的属性现在被注解为`@NotNull`，以确保值不能为null，并且一些属性也被注解为`@Size`，以确保字符数在最小和最大长度之间。
- en: 'Only annotating the properties of the `Account` object is not enough. We have
    to annotate the save() method argument of the `AccountController` class as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 仅注解`Account`对象的属性是不够的。我们必须注解`AccountController`类的save()方法参数，如下所示：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see in the preceding code, the `Account` parameter is now annotated
    with `@Valid` to indicate to Spring that the command object has validation constraints
    that should be enforced. Let''s see the output when we submit the web open account
    form while filling invalid data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`Account` 参数现在被注解为 `@Valid`，以指示 Spring 命令对象具有应强制执行的验证约束。让我们看看在提交带有无效数据的
    Web 开户表单时的输出：
- en: '![](img/de979414-1011-4428-bd1d-f2e349800dc7.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de979414-1011-4428-bd1d-f2e349800dc7.png)'
- en: As I had submitted this form without data, it has been redirected to the same
    page with validation errors. Spring also allows you to customize these validation
    messages by configuring these messages into the properties file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在提交此表单时没有填写数据，它已被重定向到同一页面，并显示验证错误。Spring 还允许你通过将这些消息配置到属性文件中来自定义这些验证消息。
- en: As of now, in this chapter, you have learned about the controller component
    of the MVC pattern. You also learned how to create and configure in a web application.
    Let's explore another component of the MVC pattern, view, in the upcoming section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经了解了 MVC 模式的控制器组件。你还学习了如何在 Web 应用程序中创建和配置它。让我们在下一节中探索 MVC 模式的另一个组件，视图。
- en: Implementing View in the MVC pattern
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MVC 模式中实现视图
- en: 'View is the most important component of the MVC pattern. The controller returns
    the model to the front controller along with the logical view name. The front
    controller resolves to the actual view by using the configured view resolver.
    Spring MVC provides several view resolvers to support multiple view technologies,
    such as JSP, Velocity, FreeMarker, JSF, Tiles, Thymeleaf, and so on. You have
    to configure the view resolver according to the view technology that you use in
    your web application. Take a look at the following figure to understand more about
    the view pattern in Spring MVC:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是 MVC 模式中最重要的组件。控制器将模型和逻辑视图名称一起返回给前端控制器。前端控制器使用配置的视图解析器解析到实际视图。Spring MVC
    提供了多个视图解析器来支持多种视图技术，如 JSP、Velocity、FreeMarker、JSF、Tiles、Thymeleaf 等。你必须根据你在 Web
    应用程序中使用的视图技术来配置视图解析器。请查看以下图表，以了解 Spring MVC 中视图模式的相关信息：
- en: '![](img/a948ab9b-14a7-4fc2-9647-eea78f448711.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a948ab9b-14a7-4fc2-9647-eea78f448711.jpg)'
- en: As you can see in the diagram, Spring MVC's Front Controller has several view
    resolvers according to the different view technologies. But in this chapter, we
    will use only JSP as the view technology, and so, we will explore only the JSP-related
    view resolver, `InternalResourveViewResolver`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Spring MVC 的前端控制器根据不同的视图技术有多个视图解析器。但本章中，我们将只使用 JSP 作为视图技术，因此，我们将只探索与 JSP
    相关的视图解析器，即 `InternalResourveViewResolver`。
- en: A View renders the web output. There are many built-in views available for JSPs,
    XSLT, templating approaches (Velocity, FreeMarker), and others. Spring MVC also
    has view support classes for creating PDFs, Excel spreadsheets, and so on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 视图渲染 Web 输出。对于 JSP、XSLT、模板方法（Velocity、FreeMarker）等，都有许多内置视图可用。Spring MVC 还提供了用于创建
    PDF、Excel 工作表等的视图支持类。
- en: Controllers, typically, return a *logical view name* in String MVC, but Spring's
    `ViewResolvers` select a View based on the view name. Let's see how to configure
    the `ViewResolver` in a Spring MVC application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器通常在 String MVC 中返回一个 *逻辑视图名称*，但 Spring 的 `ViewResolvers` 会根据视图名称选择视图。让我们看看如何在
    Spring MVC 应用程序中配置 `ViewResolver`。
- en: Defining ViewResolver in the Spring MVC
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring MVC 中定义 ViewResolver
- en: In Spring MVC, the `DispatcherServlet` delegates to a `ViewResolver` to obtain
    the View implementation based on the view name. The default `ViewResolver` treats
    the view name as a web application-relative file path, that is, a JSP--`/WEB-INF/views/account.jsp`.
    We can override this default by registering a `ViewResolver` bean with the `DispatcherServlet`.
    In our web application, we have used `InternalResourceViewResolver`, because it
    is related to the JSP view, but there are several other options available in Spring
    MVC, as mentioned in the previous section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring MVC 中，`DispatcherServlet` 会委托给 `ViewResolver` 来根据视图名称获取视图实现。默认的 `ViewResolver`
    将视图名称视为一个相对于 Web 应用的文件路径，即一个 JSP--`/WEB-INF/views/account.jsp`。我们可以通过向 `DispatcherServlet`
    注册一个 `ViewResolver` 实例来覆盖这个默认设置。在我们的 Web 应用程序中，我们使用了 `InternalResourceViewResolver`，因为它与
    JSP 视图相关，但在 Spring MVC 中还有其他几个选项，如前文所述。
- en: Implement the View
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现视图
- en: 'The following code renders the view in the MVC pattern:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 MVC 模式中的视图渲染：
- en: '`accountDetails.jsp`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`accountDetails.jsp`:'
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see in the preceding code, Spring MVC renders this view when the
    controller will be returned `accountDetails` as the logical view name. But how
    is it resolved by Spring MVC? Let's see the configuration of the `ViewResolver`
    in the Spring configuration file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，当控制器返回`accountDetails`作为逻辑视图名称时，Spring MVC将渲染此视图。但是它是如何被Spring MVC解析的呢？让我们看看Spring配置文件中`ViewResolver`的配置。
- en: Register ViewResolver with Spring MVC
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring MVC中注册视图解析器
- en: 'Let''s register the JSP-related `ViewResolver`, that is, configure `InternalResourceViewResolver`
    in the Spring web application, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注册与JSP相关的`ViewResolver`，即在Spring Web应用程序中配置`InternalResourceViewResolver`，如下所示：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As in the preceding code, suppose the controller returns with the logical view
    name, `accountDetails`. All the JSP files for views are placed in the `/WEB-INF/views/`
    directory of the web application. The `accountDetails.jsp` view file for account
    details. As per the preceding configuration file, the actual view name is derived
    by adding the prefix `/WEB-INF/views/` and the postfix `.jsp` to the logical view
    name returned by the application controller. If the application controller returns
    `accountDetails` as the logical view name, then `ViewResolver` changes it to the
    physical by adding a prefix and postfix to the logical view name; finally, it
    is changed to `/WEB-INF/views/accountDetails.jsp` in the our application. The
    following diagram illustrates how Spring MVC''s Front Controller resolves the
    view in a Spring web application:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，假设控制器返回逻辑视图名称，`accountDetails`。所有视图的JSP文件都放置在Web应用程序的`/WEB-INF/views/`目录中。`accountDetails.jsp`视图文件用于显示账户详情。根据前面的配置文件，实际视图名称是通过将前缀`/WEB-INF/views/`和后缀`.jsp`添加到应用程序控制器返回的逻辑视图名称中得到的。如果应用程序控制器返回`accountDetails`作为逻辑视图名称，那么`ViewResolver`通过添加前缀和后缀将其转换为物理视图名称；最后，在我们的应用程序中变为`/WEB-INF/views/accountDetails.jsp`。以下图示说明了Spring
    MVC的前端控制器如何在Spring Web应用程序中解析视图：
- en: '![](img/51101b57-a465-4d07-b31e-943299cc7c69.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51101b57-a465-4d07-b31e-943299cc7c69.png)'
- en: This last diagram illustrates the whole picture of the Spring MVC request flow
    with all the components (**Model**, **View**, and **Controllers**) of the MVC
    pattern, and the Front controller pattern. Any request, either HTTP `GET` or `POST`,
    lands at the Front Controller first, which is, actually, the `DispatcherServlet`
    in Spring MVC. The controllers in a Spring web application are responsible for
    generating and updating the **Model**, and the **Model** is another component
    of the MVC pattern. Finally, the controller returns that model along with the
    logical view name to the `DispatcherServlet`. It consults with the configured
    view resolver, and resolves the physical path of the view. The **View** is another
    component of the MVC pattern.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个图示展示了Spring MVC请求流程的全貌，包括MVC模式的所有组件（**模型**、**视图**和**控制器**）以及前端控制器模式。任何请求，无论是HTTP
    `GET`还是`POST`，首先到达前端控制器，实际上在Spring MVC中是`DispatcherServlet`。Spring Web应用程序中的控制器负责生成和更新**模型**，而**模型**是MVC模式中的另一个组件。最后，控制器将模型以及逻辑视图名称返回给`DispatcherServlet`。它将与配置的视图解析器协商，解析视图的物理路径。**视图**是MVC模式中的另一个组件。
- en: In the next section, we'll elaborate on the View Helper pattern, and how Spring
    support the pattern in a Spring web application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细阐述视图助手模式，以及Spring如何在Spring Web应用程序中支持该模式。
- en: The View Helper pattern
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图助手模式
- en: 'The View Helper pattern separates the static view, such as JSP, from the processing
    of the business model data. The View Helper pattern is used in the presentation
    layer by adapting the model data and the View components. The View Helper can
    format the model data according to the business requirement, but it cannot generate
    model data for the business. The following diagram illustrates the View Helper
    pattern:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 视图助手模式将静态视图，如JSP，与业务模型数据的处理分离。视图助手模式通过适配模型数据和视图组件在表示层中使用。视图助手可以根据业务需求格式化模型数据，但不能为业务生成模型数据。以下图示说明了视图助手模式：
- en: '![](img/386581b5-f6f4-479c-b017-501fd2e43358.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/386581b5-f6f4-479c-b017-501fd2e43358.png)'
- en: 'We know that View is the a static and formatted component of the MVC pattern,
    but sometimes, we need some business processing the presentation layer. If you
    are using JSPs, then you could use a scriptlet for the business processing at
    the the view layer, but using a scriptlet is not a best practice, because it promotes
    tight coupling between the view and business logic. But some View Helper classes
    based on the View Helper pattern take over that responsibility of business processing
    at the presentation layer. Some of the technologies based on the View Helper pattern
    areas follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道视图是 MVC 模式中的一个静态和格式化的组件，但有时我们需要在表示层进行一些业务处理。如果你使用 JSP，那么你可以在视图层使用脚本片段进行业务处理，但使用脚本片段并不是最佳实践，因为它促进了视图和业务逻辑之间的紧密耦合。但是，一些基于视图助手模式的视图助手类接管了在表示层进行业务处理的职责。基于视图助手模式的一些技术包括以下内容：
- en: The JavaBeans `View` helper
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaBeans `View` 助手
- en: The tag `LibraryView` helper
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LibraryView` 助手标签'
- en: Using JSTL tags
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSTL 标签
- en: Using spring tags
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 spring 标签
- en: Using third-party tag Library
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方标签库
- en: 'The following tag libraries are used in our web application in this chapter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用的以下标签库：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the preceding code, I have used the JSTL tag library for the
    check not empty account in the model, and the Spring tag library to create the
    open account form in the web application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，我使用了 JSTL 标签库来检查模型中的账户是否为空，并使用 Spring 标签库在 Web 应用程序中创建开户表单。
- en: In the next section, you'll learn about the Composite View pattern, and how
    Spring MVC supports it to implement it in the web application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解组合视图模式，以及 Spring MVC 如何支持它在 Web 应用程序中实现。
- en: Composite View pattern using Apache tile view resolver
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache tile 视图解析器的组合视图模式
- en: 'In a web application, the View is one of the most important components. Developing
    this component is not as easy as seems. It is very complicated to maintain, and
    a daunting task. Whenever we create the view for a web application, we always
    focus on the reusability of the view components. We can define some static templates
    that can be reused in other view pages in the same web application. According
    to the Composite Design pattern of the GOF pattern, we compose sub-view components
    for a particular view component. The Composite View pattern promotes reusability
    of views, and is easy to maintain due to the multiple sub-views instead of creating
    a large and complicated view. The following diagram illustrates the Composite
    View pattern:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，视图是最重要的组件之一。开发这个组件并不像看起来那么简单。维护它非常复杂，是一项艰巨的任务。每次我们为 Web 应用程序创建视图时，我们总是关注视图组件的可重用性。我们可以定义一些静态模板，这些模板可以在同一
    Web 应用程序的其他视图页面中重用。根据 GOF 模式的组合设计模式，我们为特定的视图组件组合子视图组件。组合视图模式促进了视图的可重用性，由于有多个子视图而不是创建一个庞大而复杂的视图，因此易于维护。以下图表说明了组合视图模式：
- en: '>![](img/003641b6-a597-4d9d-91f0-269c14dc2824.png)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/003641b6-a597-4d9d-91f0-269c14dc2824.png)'
- en: As you can see in the previous diagram, we can create multiple sub-views to
    create the view in a web application, and these sub-views will be reused across
    the web application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们可以创建多个子视图来在 Web 应用程序中创建视图，并且这些子视图将在整个 Web 应用程序中重用。
- en: Spring MVC provides support for implementation of the Composite View pattern
    through frameworks such as SiteMesh and Apache tiles. Here we will explore Apache
    Tiles with a Spring MVC application. Let's see how to configure the Apache Tiles
    `ViewResolver`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 通过 SiteMesh 和 Apache Tiles 等框架提供对组合视图模式实现的支持。在这里，我们将使用 Spring MVC
    应用程序来探索 Apache Tiles。让我们看看如何配置 Apache Tiles 的 `ViewResolver`。
- en: Configuring a Tiles ViewResolver
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Tiles 视图解析器
- en: 'Let''s configure Apache Tiles in the Spring MVC application. In order to configure
    it, we have to configure two beans in the Spring configuration file as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Spring MVC 应用程序中配置 Apache Tiles。为了配置它，我们必须在 Spring 配置文件中配置两个 Bean，如下所示：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding configuration file, we configured two beans, `TilesConfigurer`
    and the `TilesViewResolver` bean. The first bean, `TilesConfigurer`, has the responsibility
    to locate and load tile definitions, and, generally, coordinate Tiles. The second
    bean, `TilesViewResolver`, is responsible for resolving logical view names to
    tile definitions. The XML file `tiles.xml` has the tile definitions in the application.
    Let''s see the following code for the tiles configuration file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在此先前的配置文件中，我们配置了两个bean，`TilesConfigurer`和`TilesViewResolver` bean。第一个bean，`TilesConfigurer`，负责定位和加载tile定义，并且通常协调Tiles。第二个bean，`TilesViewResolver`，负责将逻辑视图名称解析为tile定义。应用程序中的`tiles.xml`
    XML文件包含了tile定义。让我们看看以下代码，用于tiles配置文件：
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the `<tiles-definitions>` element has multiple `<definition>`
    elements. Each `<definition>` element defines a tile, and each tile references
    a JSP template. Some `<definition>` elements extend the base tile definition,
    because the base tile definition has the common layout for all the views in the
    web application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，`<tiles-definitions>`元素有多个`<definition>`元素。每个`<definition>`元素定义一个tile，每个tile引用一个JSP模板。一些`<definition>`元素扩展了基本tile定义，因为基本tile定义具有网络应用程序中所有视图的通用布局。
- en: 'Let''s see the base definition template, that is, `mainTemplate.jsp`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基本定义模板，即`mainTemplate.jsp`：
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this preceding JSP file, I have used the `<tiles:insertAttribute>` JSP tag
    from the `tiles` tag library to insert other templates.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此先前的JSP文件中，我使用了`tiles`标签库中的`<tiles:insertAttribute>` JSP标签来插入其他模板。
- en: Let's now see some best practices used to design and develop a web application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些用于设计和开发网络应用程序的最佳实践。
- en: Best practices for web application design
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序设计的最佳实践
- en: 'The following are some of the best practices that must be considered while
    designing and developing a web application:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和开发网络应用程序时，以下是一些必须考虑的最佳实践：
- en: Spring MVC is the best choice to design and develop a web application because
    of the Spring DI pattern and the very flexible MVC pattern with Spring. Spring's
    `DispatcherServlet`, too, is very flexible and customizable.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Spring DI模式和Spring的非常灵活的MVC模式，Spring MVC是设计和开发网络应用程序的最佳选择。Spring的`DispatcherServlet`也非常灵活和可定制。
- en: In any web application using the MVC pattern, the front controller should be
    generic and as lightweight as possible.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何使用MVC模式的网络应用程序中，前端控制器应该是通用的，并且尽可能轻量。
- en: It is important to maintain a clear separation of concerns across the layers
    of the web application. Separating layers improves the clean design of the application.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络应用程序的各个层级之间保持清晰的关注点分离非常重要。分离层级可以改善应用程序的整洁设计。
- en: If an application layer has too many dependencies with the other layers, as
    a best approach, introduce another layer to reduce the dependency of that layer.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用层与其他层有太多的依赖关系，作为一个最佳做法，引入另一个层以减少该层的依赖性。
- en: Never inject a DAO object to the controllers in the web application; always
    inject a services object to the controller. The DAO objects must be injected with
    the service layers so that the service layer talks to the data access layer, and
    the presentation layer talks to the service layer.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将DAO对象注入到网络应用程序的控制器中；始终将服务对象注入到控制器中。DAO对象必须通过服务层注入，以便服务层与数据访问层通信，而表示层与服务层通信。
- en: Application layers such service, DAO, and presentation layers must be pluggable,
    and must not be bound with the implementation, that is, using interfaces reduces
    the actual coupling to concrete implementations, as we know that loosely coupled
    layered applications are easier to test and maintain.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层，如服务、DAO和表示层，必须是可插拔的，并且不能与实现绑定，也就是说，使用接口可以减少与具体实现的实际耦合，因为我们知道松耦合的分层应用程序更容易测试和维护。
- en: It is strongly recommended to place JSP files in the WEB-INF directory, because
    this location is not accessed by any client.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈建议将JSP文件放置在WEB-INF目录中，因为这个位置不会被任何客户端访问。
- en: Always specify the name of the command object in the JSP file.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在JSP文件中指定命令对象的名字。
- en: JSP files must not have any business logic and business processing. For such
    a requirement, we strongly recommend the use of View helper classes such as tags,
    libraries, JSTL, and so on.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP文件不得有任何业务逻辑和业务处理。对于此类需求，我们强烈建议使用视图辅助类，如标签、库、JSTL等。
- en: Remove the programming logic from template-based views like JSP.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基于模板的视图（如JSP）中移除编程逻辑。
- en: Create reusable components that can be used to combine model data across views.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的组件，这些组件可以用于在视图之间组合模型数据。
- en: Each component of the MVC pattern must have a consistent behavior for which
    the MVC introduced it. This means that the controller should follow the Single
    Responsibility Principle. Controllers are responsible only for delegating business
    logic invocation and view selection.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC模式的每个组件都必须有一个一致的行为，这是MVC引入它的原因。这意味着控制器应该遵循单一职责原则。控制器只负责委托业务逻辑调用和视图选择。
- en: Finally, be consistent with naming of the configuration files. For example,
    web beans such as controllers, interceptors, and view resolvers must be defined
    in separate configuration files. Other application beans such as services, repositories,
    and so on must be defined into another, separate file. Similarly for security
    concerns.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，保持配置文件命名的统一性。例如，控制器、拦截器和视图解析器等Web组件必须在单独的配置文件中定义。其他应用程序组件，如服务、存储库等，必须定义在另一个单独的文件中。同样，对于安全考虑也是如此。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you've seen how the Spring Framework allows you to develop
    a flexible and loosely coupled web-based application. Spring employs annotations
    for near-POJO development model in your web application. You learned that with
    Spring MVC, you can create a web-based application by developing controllers that
    handle requests, and these controllers are very easy to test. In this chapter,
    we covered the MVC pattern, including its origins and what problems it solves.
    The Spring Framework has implemented MVC patterns, which means that for any web
    application, there are three components--Model, View, and Controller.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解到Spring框架如何让您开发一个灵活且松散耦合的基于Web的应用程序。Spring在您的Web应用程序中使用了注解来实现接近POJO的开发模型。您了解到，使用Spring
    MVC，您可以通过开发处理请求的控制器来创建基于Web的应用程序，而这些控制器非常容易测试。在本章中，我们介绍了MVC模式，包括其起源和解决的问题。Spring框架实现了MVC模式，这意味着对于任何Web应用程序，都有三个组件——模型（Model）、视图（View）和控制器（Controller）。
- en: Spring MVC implements the Application Controller and Front Controller patterns.
    Spring's dispatcher servlet (`org.springframework.web.servlet.DispatcherServlet`)
    works as a Front Controller in a web-based application. This dispatcher or front
    controller routes all requests to the application controller by using handler
    mapping. In Spring MVC, the controller classes have extremely flexible request
    handler methods. And these handler methods handle all the requests of a web application.
    There several ways, as we explained in this chapter, to handle request parameters.
    The `@RequestParam` annotation is one of the ways to handle request parameters,
    and it is also very easy to test without using the http request object in test
    cases.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC实现了应用程序控制器和前端控制器模式。Spring的调度器Servlet（`org.springframework.web.servlet.DispatcherServlet`）在基于Web的应用程序中充当前端控制器。这个调度器或前端控制器通过使用处理器映射将所有请求路由到应用程序控制器。在Spring
    MVC中，控制器类具有极其灵活的请求处理方法。这些处理方法处理Web应用程序的所有请求。正如我们在本章中解释的那样，有几种处理请求参数的方法。`@RequestParam`注解是处理请求参数的一种方法，而且在不使用测试用例中的http请求对象的情况下也非常容易测试。
- en: In this chapter, we explored the request processing workflow, and discussed
    all the components which play a role in this workflow. The `DispatcherServlet`
    can be considered the main component in Spring MVC; it plays the role of a front
    controller in Spring MVC. Another main component is the view resolver, which has
    the responsibility to render the model data to any view template such JSP, Thymeleaf,
    FreeMarker, velocity, pdf, xml and so on depending om the configured view resolver
    in the web application. Spring MVC provides support for several view technologies,
    but, in this chapter, we briefly looked at how to write views for your controllers
    using JSPs. We can also add consistent layouts to your views using Apache tiles.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了请求处理工作流程，并讨论了在这个工作流程中扮演角色的所有组件。`DispatcherServlet`可以被认为是Spring MVC中的主要组件；它在Spring
    MVC中扮演前端控制器的角色。另一个主要组件是视图解析器，它负责将模型数据渲染到任何视图模板，如JSP、Thymeleaf、FreeMarker、velocity、pdf、xml等，这取决于Web应用程序中配置的视图解析器。Spring
    MVC为几种视图技术提供了支持，但在这个章节中，我们简要地介绍了如何使用JSP为您的控制器编写视图。我们还可以使用Apache tiles添加一致的布局到您的视图中。
- en: And finally, we covered the web application architecture, and discussed the
    different layers in a web application such as domain, user interface, web, service,
    and data access. We created a small bank management web application, and deployed
    it to the tomcat server.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Web应用架构，并探讨了Web应用中的不同层次，如领域、用户界面、Web、服务和数据访问。我们创建了一个小型银行管理Web应用，并将其部署到Tomcat服务器上。
