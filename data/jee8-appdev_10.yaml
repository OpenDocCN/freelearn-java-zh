- en: RESTful Web Services with JAX-RS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAX-RS的RESTful网络服务
- en: '**Representational State Transfer** (**REST**) is an architectural style in
    which web services are viewed as resources and can be identified by **Uniform
    Resource Identifiers** (**URIs**).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是一种架构风格，在这种风格中，网络服务被视为资源，并且可以通过**统一资源标识符**（**URIs**）来识别。'
- en: Web services developed using this styles are known as RESTful web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种风格开发的网络服务被称为RESTful网络服务。
- en: JAX-RS became part of Java EE in version 6 of the Java EE specification, although
    it had been available as a standalone API before then. In this chapter, we will
    cover how to develop RESTful web services through the JAX-RS API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS在Java EE规范的第6版中成为Java EE的一部分，尽管在此之前它已经作为一个独立的API提供。在本章中，我们将介绍如何通过JAX-RS
    API开发RESTful网络服务。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to RESTful web services and JAX-RS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful网络服务和JAX-RS简介
- en: Developing a simple RESTful web service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个简单的RESTful网络服务
- en: Developing a RESTful web service client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发RESTful网络服务客户端
- en: Path parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径参数
- en: Query parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数
- en: Server-Sent events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端发送事件
- en: An introduction to RESTful web services and JAX-RS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful网络服务和JAX-RS简介
- en: RESTful web services are very flexible. They can consume several types of different
    MIME types, although they are typically written to consume and/or produce XML
    or **JSON** (**JavaScript Object Notation**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络服务非常灵活。它们可以消费多种不同类型的MIME类型，尽管它们通常被编写为消费和/或生成XML或**JSON**（**JavaScript对象表示法**）。
- en: 'Web services must support one or more of the following four HTTP methods:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务必须支持以下四种HTTP方法之一：
- en: '**GET** - By convention, a `GET` request is used to retrieve an existing resource'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET** - 按照惯例，`GET`请求用于检索现有资源'
- en: '**POST** - By convention, a `POST` request is used to update an existing resource'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST** - 按照惯例，`POST`请求用于更新现有资源'
- en: '**PUT** - By convention, a `PUT` request is used to create a new resource'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT** - 按照惯例，`PUT`请求用于创建新资源'
- en: '**DELETE** - By convention, a `DELETE` request is used to delete an existing
    resource'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE** - 按照惯例，`DELETE`请求用于删除现有资源'
- en: We develop a RESTful web service with JAX-RS by creating a class with annotated
    methods that are invoked when our web service receives one of the above HTTP requests.
    Once we have developed and deployed our RESTful web service, we need to develop
    a client that will send requests to our service. JAX-RS includes a standard client-side
    API that we can use to develop RESTful web service clients.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个带有注解方法的类来开发一个RESTful网络服务，这些方法在收到上述HTTP请求之一时将被调用。一旦我们开发和部署了我们的RESTful网络服务，我们需要开发一个客户端来向我们的服务发送请求。JAX-RS包括一个标准的客户端API，我们可以使用它来开发RESTful网络服务客户端。
- en: Developing a simple RESTful web service
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的RESTful网络服务
- en: In this section, we will develop a simple web service to illustrate how we can
    make methods in our service respond to different HTTP request methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的网络服务来展示我们如何使服务中的方法响应不同的HTTP请求方法。
- en: Developing a RESTful web service using JAX-RS is simple and straightforward.
    Each of our RESTful web services needs to be invoked via its **Unique Resource
    Identifier** (**URI**). This URI is specified by the `@Path` annotation, which
    we need to use to decorate our RESTful web service resource class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JAX-RS开发RESTful网络服务简单直接。我们的每个RESTful网络服务都需要通过其**唯一资源标识符**（**URI**）来调用。这个URI由`@Path`注解指定，我们需要使用它来装饰我们的RESTful网络服务资源类。
- en: 'When developing RESTful web services, we need to develop methods that will
    be invoked when our web service receives an HTTP request. We need to implement
    methods to handle one or more of the four types of request that RESTful web services
    handle: `GET`, `POST`, `PUT`, and/or `DELETE`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发RESTful网络服务时，我们需要开发当我们的网络服务接收到HTTP请求时将被调用的方法。我们需要实现方法来处理RESTful网络服务处理的四种类型之一或多种请求：`GET`、`POST`、`PUT`和/或`DELETE`。
- en: The JAX-RS API provides four annotations that we can use to decorate methods
    in our web service. These annotations are appropriately named `@GET`, `@POST`,
    `@PUT`, and `@DELETE`. Decorating a method in our web service with one of these
    annotations will make it respond to the corresponding HTTP method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS API提供了四个注解，我们可以使用这些注解来装饰我们的网络服务中的方法。这些注解的名称分别是`@GET`、`@POST`、`@PUT`和`@DELETE`。在我们的网络服务中用其中一个注解装饰方法，将使其能够响应相应的HTTP方法。
- en: Additionally, each method in our service must produce and/or consume a specific
    MIME type. The MIME type to be produced needs to be specified with the `@Produces`
    annotation. Similarly, the MIME type to be consumed must be specified with the
    `@Consumes` annotation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们服务中的每个方法都必须产生和/或消费特定的MIME类型。需要产生的MIME类型需要使用`@Produces`注解进行指定。同样，需要消费的MIME类型必须使用`@Consumes`注解进行指定。
- en: 'The following example illustrates the concepts we have just explained:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们刚刚解释的概念：
- en: Please note that this example does not *really* do anything; the purpose of
    the example is to illustrate how to make different methods in our RESTful web
    service resource class respond to different HTTP methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例实际上并没有做什么；示例的目的是说明如何使我们的RESTful Web服务资源类中的不同方法响应不同的HTTP方法。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that this class is annotated with the `@Path` annotation. This annotation
    designates the Uniform Resource Identifier (URI) for our RESTful web service.
    The complete URI for our service will include the protocol, server name, port,
    context root, the REST resources path (see the next subsection), and the value
    passed to this annotation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类使用了`@Path`注解。这个注解指定了我们的RESTful Web服务的统一资源标识符（URI）。我们服务的完整URI将包括协议、服务器名、端口、上下文根、REST资源路径（见下一小节），以及传递给此注解的值。
- en: 'Assuming that our web service was deployed to a server called example.com using
    the HTTP protocol on port 8080, has a context root of `jaxrsintro`, and a REST
    resources path of `"resources"`, then the complete URI for our service would be:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的Web服务已部署到名为example.com的服务器上，使用HTTP协议在8080端口，上下文根为`jaxrsintro`，REST资源路径为`"resources"`，那么我们服务的完整URI将是：
- en: '[http://example.com:8080/jaxrsintro/resources/customer](http://example.com:8080/jaxrsintro/resources/customer)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://example.com:8080/jaxrsintro/resources/customer](http://example.com:8080/jaxrsintro/resources/customer)'
- en: Since web browsers generate a `GET` request when pointed to a URL, we can test
    the GET method of our service simply by pointing the browser to our service's
    URI.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web浏览器在指向URL时会生成一个`GET`请求，因此我们可以通过将浏览器指向我们服务的URI来简单地测试我们服务的GET方法。
- en: Notice that each of the methods in our class is annotated with one of the `@GET`,
    `@POST`, `@PUT`, or `@DELETE` annotations. These annotations make our methods
    respond to the corresponding HTTP method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们课程中的每个方法都使用`@GET`、`@POST`、`@PUT`或`@DELETE`中的一个注解进行标注。这些注解使得我们的方法能够响应相应的HTTP方法。
- en: Additionally, if our method returns data to the client, we declare the MIME
    type of the data to be returned in the `@Produces` annotation. In our example,
    only the `getCustomer()` method returns data to the client. We wish to return
    data in XML format, therefore we set the value of the `@Produces` annotation to
    the JAX-RS provided constant `MediaType.TEXT_XML`, which has a value of `"text/xml"`.
    Similarly, if our method needs to consume data from the client, we need to specify
    the MIME type of the data to be consumed. This is done via the `@Consumes` annotation.
    All methods except `getCustomer()` in our service consume data. In all cases,
    we expect the data to be in XML format, therefore, we again specify `MediaType.TEXT_XML`
    as the MIME type to be consumed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的方法需要向客户端返回数据，我们将在`@Produces`注解中声明返回数据的MIME类型。在我们的示例中，只有`getCustomer()`方法向客户端返回数据。我们希望以XML格式返回数据，因此我们将`@Produces`注解的值设置为JAX-RS提供的常量`MediaType.TEXT_XML`，其值为`"text/xml"`。同样，如果我们的方法需要从客户端消费数据，我们需要指定要消费的数据的MIME类型。这是通过`@Consumes`注解完成的。在我们的服务中，除了`getCustomer()`之外的所有方法都消费数据。在所有情况下，我们期望数据以XML格式存在，因此我们再次指定`MediaType.TEXT_XML`作为要消费的MIME类型。
- en: Configuring the REST resources path for our application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置REST资源路径
- en: As briefly mentioned in the previous section, before successfully deploying
    a RESTful web service developed using JAX-RS, we need to configure the REST resources
    path for our application. We can do this by developing a class that extends `javax.ws.rs.core.Application`
    and decorating it with the `@ApplicationPath`, annotation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节简要提到的，在成功部署使用JAX-RS开发的RESTful Web服务之前，我们需要为我们的应用程序配置REST资源路径。我们可以通过开发一个扩展`javax.ws.rs.core.Application`的类，并用`@ApplicationPath`注解来装饰它来实现这一点。
- en: Configuring via the @ApplicationPath annotation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过`@ApplicationPath`注解进行配置
- en: When developing applications against modern versions of Java EE, in many cases,
    it isn't necessary to write a `web.xml` deployment descriptor; JAX-RS is no different.
    We can configure the REST resources path in Java code via an annotation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发针对Java EE现代版本的程序时，在许多情况下，编写`web.xml`部署描述符并不是必需的；JAX-RS也不例外。我们可以通过注解在Java代码中配置REST资源路径。
- en: To configure our REST resources path without having to rely on a `web.xml` deployment
    descriptor, all we need to do is write a class that extends `javax.ws.ApplicationPath`,
    and decorate it with the `@ApplicationPath` annotation. The value passed to this
    annotation is the REST resources `path` for our services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的REST资源路径，而无需依赖于`web.xml`部署描述符，我们只需要编写一个扩展`javax.ws.ApplicationPath`的类，并用`@ApplicationPath`注解装饰它。传递给此注解的值是我们服务的REST资源`path`。
- en: 'The following code sample illustrates this process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了这个过程：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the class does not have to implement any methods; it simply needs
    to extend `javax.ws.rs.Application` and be decorated with the `@ApplicationPath`
    annotation. The class must be public, may have any name, and may be placed in
    any package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类不需要实现任何方法；它只需要扩展`javax.ws.rs.Application`并用`@ApplicationPath`注解装饰。该类必须是公共的，可以具有任何名称，并且可以放在任何包中。
- en: Testing our web service
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的Web服务
- en: 'As we mentioned earlier, web browsers send a `GET` request to any URLs we point
    them to. Therefore, the easiest way to test `GET` requests to our service is to
    simply point the browser to our service''s URI:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，网络浏览器会将`GET`请求发送到我们指向的任何URL。因此，测试我们对服务发出的`GET`请求的最简单方法就是直接将浏览器指向我们的服务URI：
- en: '![](img/f4476141-c883-415b-8b84-e561692feee1.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4476141-c883-415b-8b84-e561692feee1.png)'
- en: Web browsers only support `GET` and `POST` requests. To test a `POST` request
    through the browser, we would have to write a web application containing an HTML
    form having an action attribute value of our service's URI. Although trivial for
    a single service, it can become cumbersome to do this for every RESTful web service
    we develop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器只支持`GET`和`POST`请求。要通过浏览器测试`POST`请求，我们必须编写一个包含具有我们的服务URI作为action属性值的HTML表单的Web应用程序。虽然对于一个单一的服务来说这很简单，但对我们开发的每个RESTful
    Web服务都这样做可能会变得繁琐。
- en: Thankfully, there is an open source command-line utility called curl we can
    use to test our web services. curl is included with most Linux distributions,
    and can be easily downloaded for Windows, mac OS X, and several other platforms,
    at [http://curl.haxx.se/](http://curl.haxx.se/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为curl的开源命令行工具，我们可以用它来测试我们的Web服务。curl包含在大多数Linux发行版中，并且可以轻松地下载到Windows、mac
    OS X和几个其他平台，详情请访问[http://curl.haxx.se/](http://curl.haxx.se/)。
- en: 'curl can send all four request method types (`GET`, `POST`, `PUT`, and `DELETE`)
    to our service. Our server''s response will simply be displayed on the command-line
    console. Curl takes an `-X` command-line option, which allows us to specify which
    request method to send. To send a `GET` request, we simply need to type the following
    into the command line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: curl可以向我们的服务发送所有四种请求方法（`GET`、`POST`、`PUT`和`DELETE`）。我们的服务器响应将简单地显示在命令行控制台上。Curl有一个`-X`命令行选项，允许我们指定要发送哪种请求方法。要发送`GET`请求，我们只需在命令行中输入以下内容：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Which results in the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Which, unsurprisingly, is the same output we saw when we pointed our browser
    to the service's URI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这，不出所料，是我们将浏览器指向服务URI时看到的相同输出。
- en: 'The default request method for curl is `GET`, therefore, the `-X` parameter
    in our example above is redundant; we could have achieved the same result by invoking
    the following command from the command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: curl的默认请求方法是`GET`，因此，我们上面示例中的`-X`参数是多余的；我们可以通过从命令行调用以下命令来达到相同的结果：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After submitting either of the above two commands and examining the application
    server log, we should see the output of the `System.out.println()` statements
    we added to the `getCustomer()` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提交上述两个命令之一并检查应用程序服务器日志后，我们应该看到我们添加到`getCustomer()`方法中的`System.out.println()`语句的输出：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For all other request method types, we need to send some data to our service.
    This can be accomplished with the `--data` command-line argument to `curl`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他请求方法类型，我们需要向我们的服务发送一些数据。这可以通过curl的`--data`命令行参数来完成：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As can be seen in the preceding example, we need to specify the MIME type via
    curl's `-H` command-line argument using the format seen in the preceding example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们需要通过curl的`-H`命令行参数指定MIME类型，格式如前例所示。
- en: 'We can verify that the preceding command worked as expected by inspecting the
    application server log:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查应用服务器日志来验证前面的命令是否按预期工作：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can test other `request` method types just as easily:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样容易地测试其他`request`方法类型：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Which results in the following output in the application server log:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用服务器日志中产生以下输出：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can test the `delete` method by executing the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来测试`delete`方法：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Resulting in the following output in the application server log:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在应用服务器日志中产生以下输出：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Converting data between Java and XML with JAXB
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAXB在Java和XML之间转换数据
- en: In our previous example, we were processing "raw" XML received as a parameter,
    as well as returning "raw" XML to our client. In a real application, we would
    more than likely parse the XML received from the client and use it to populate
    a Java object. Additionally, any XML that we need to return to the client would
    have to be constructed from a Java object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们处理了作为参数接收到的“原始”XML，以及返回给客户端的“原始”XML。在实际应用中，我们更有可能解析从客户端接收到的XML，并使用它来填充一个Java对象。此外，我们需要返回给客户端的任何XML都必须从一个Java对象构建。
- en: Converting data from Java to XML and back is such a common use case that the
    Java EE specification provides an API to do it. This API is the **Java API for
    XML Binding** (**JAXB**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从Java转换为XML然后再转换回来是一个非常常见的用例，Java EE规范提供了一个API来完成这个任务。这个API就是**Java API for
    XML Binding**（**JAXB**）。
- en: 'JAXB makes converting data from Java to XML transparent and trivial; all we
    need to do is decorate the class we wish to convert to XML with the `@XmlRootElement`
    annotation. The following code example illustrates how to do this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JAXB使得将数据从Java转换为XML变得透明且简单；我们所需做的只是用`@XmlRootElement`注解装饰我们希望转换为XML的类。以下代码示例说明了如何进行此操作：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, other than the `@XmlRootElement` annotation at the class level,
    there is nothing unusual about the above Java class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，除了在类级别上的`@XmlRootElement`注解之外，上述Java类并没有什么异常之处。
- en: 'Once we have a class that we have decorated with the `@XmlRootElement` annotation,
    we need to change the parameter type of our web service from `String` to our custom
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个装饰了`@XmlRootElement`注解的类，我们需要将我们的Web服务的参数类型从`String`更改为我们的自定义类：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the difference between this version of our RESTful web service
    and the previous one is that all parameter types and return values have been changed
    from `String` to `Customer`. JAXB takes care of converting our parameters and
    return types to and from XML as appropriate. When using JAXB, an object of our
    custom class is automatically populated with data from the XML data sent from
    the client, similarly, return values are transparently converted to XML.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们这个版本的RESTful Web服务与之前的版本之间的区别在于，所有参数类型和返回值都已经从`String`更改为`Customer`。JAXB负责将我们的参数和返回类型适当地转换为XML。当使用JAXB时，我们的自定义类对象会自动用从客户端发送的XML数据填充，同样，返回值会透明地转换为XML。
- en: Developing a RESTful web service client
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful Web服务客户端
- en: Although curl allows us to quickly test our RESTful web services and it is a
    developer-friendly tool, it is not exactly user-friendly; we shouldn't expect
    to have our user enter curl commands in their command line to use our web service.
    For this reason, we need to develop a client for our services. JAX-RS includes
    a standard client-side API that we can use to easily develop RESTful web service
    clients.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然curl允许我们快速测试我们的RESTful Web服务，并且它是一个对开发者友好的工具，但它并不完全对用户友好；我们不应该期望用户在命令行中输入curl命令来使用我们的Web服务。因此，我们需要为我们的服务开发一个客户端。JAX-RS包括一个标准的客户端API，我们可以使用它来轻松地开发RESTful
    Web服务客户端。
- en: 'The following example illustrates how to use the JAX-RS client API:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用JAX-RS客户端API：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing we need to do is create an instance of `javax.ws.rs.client.Client`
    by invoking the static `newClient()` method on the `javax.ws.rs.client.ClientBuilder`
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是通过在`javax.ws.rs.client.ClientBuilder`类上调用静态的`newClient()`方法来创建一个`javax.ws.rs.client.Client`实例。
- en: We then invoke the `target()` method on our `Client` instance, passing the URI
    of our RESTful web service as a parameter. The `target()` method returns an instance
    of a class implementing the `javax.ws.rs.client.WebTarget` interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Client`实例上调用`target()`方法，将我们的RESTful Web服务的URI作为参数传递。`target()`方法返回一个实现`javax.ws.rs.client.WebTarget`接口的类的实例。
- en: At this point, we invoke the `request()` method on our `WebTarget` instance.
    This method returns an implementation of the `javax.ws.rs.client.Invocation.Builder`
    interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们在`WebTarget`实例上调用`request()`方法。此方法返回`javax.ws.rs.client.Invocation.Builder`接口的实现。
- en: In this particular example, we are sending an HTTP `PUT` request to our RESTful
    web service, therefore, at this point, we invoke the `put()` method of our `Invocation.Builder`
    implementation. The first parameter of the `put()` method is an instance of `javax.ws.rs.client.Entity`
    . We can create one on the fly by invoking the static `entity()` method on the
    `Entity` class. The first parameter for this method is the object we wish to pass
    to our RESTful web service, and the second parameter is the string representation
    of the MIME type of the data we will be passing to the RESTful web service. The
    second parameter of the `put()` method is the type of response the client expects
    from the service. After we invoke the `put()` method, an HTTP `PUT` request is
    sent to our RESTful web service and the method we decorated with the `@Put` annotation
    ( `createCustomer()`, in our example) is invoked. There are similar `get()`, `post()`,
    and `delete()` methods which we can invoke to send the corresponding HTTP requests
    to our RESTful web service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们正在向我们的RESTful网络服务发送一个HTTP `PUT`请求，因此，在这个时候，我们调用`Invocation.Builder`实现的`put()`方法。`put()`方法的第一参数是`javax.ws.rs.client.Entity`的实例。我们可以通过在`Entity`类上调用静态的`entity()`方法来创建一个。此方法的第一参数是我们希望传递给我们的RESTful网络服务的对象，第二个参数是我们将传递给RESTful网络服务的数据的MIME类型的字符串表示。`put()`方法的第二个参数是客户端期望从服务中得到的响应类型。在调用`put()`方法后，一个HTTP
    `PUT`请求被发送到我们的RESTful网络服务，并且带有`@Put`注解的方法（在我们的例子中是`createCustomer()`）被调用。还有类似的`get()`、`post()`和`delete()`方法，我们可以调用以向我们的RESTful网络服务发送相应的HTTP请求。
- en: Query and path parameters
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和路径参数
- en: In our previous examples, we were working with a RESTful web service to manage
    a single customer object. In real life, this would obviously not be very helpful.
    A common case is to develop a RESTful web service to handle a collection of objects
    (customers, in our example). To determine which specific object in the collection
    we are working with, we can pass parameters to our RESTful web services. There
    are two types of parameters we can use, **Query** and **Path** parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们正在使用一个RESTful网络服务来管理单个客户对象。在现实生活中，这显然不会很有帮助。一个常见的案例是开发一个RESTful网络服务来处理一组对象（在我们的例子中是客户）。为了确定我们在集合中处理的是哪个特定对象，我们可以向我们的RESTful网络服务传递参数。我们可以使用两种类型的参数，**查询**和**路径**参数。
- en: Query parameters
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询参数
- en: We can add parameters to methods that will handle HTTP requests in our web service.
    Parameters decorated with the `@QueryParam` annotation will be retrieved from
    the request URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在处理我们的网络服务中的HTTP请求的方法中添加参数。带有`@QueryParam`注解的参数将从请求URL中检索。
- en: 'The following example illustrates how to use query parameters in our JAX-RS
    RESTful web services:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在我们的JAX-RS RESTful网络服务中使用查询参数：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that all we had to do was decorate the parameters with the `@QueryParam`
    annotation. This annotation allows JAX-RS to retrieve any query parameters matching
    the value of the annotation and assign its value to the parameter variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要用`@QueryParam`注解装饰参数。这个注解允许JAX-RS检索任何与注解值匹配的查询参数，并将其值分配给参数变量。
- en: 'We can add a parameter to the web service''s URL, just as we pass parameters
    to any URL:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在网络服务的URL中添加一个参数，就像我们向任何URL传递参数一样：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sending query parameters via the JAX-RS client API
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API发送查询参数
- en: 'The JAX-RS client API provides an easy and straightforward way of sending query
    parameters to RESTful web services. The following example illustrates how to do
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS客户端API提供了一个简单直接的方式来向RESTful网络服务发送查询参数。以下示例说明了如何做到这一点：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, all we need to do to pass a parameter is to invoke the `queryParam()`
    method on the instance of `javax.ws.rs.client.WebTarget` returned by the `target()`
    method invocation on our `Client` instance. The first argument to this method
    is the parameter name and must match the value of the `@QueryParam` annotation
    on the web service. The second parameter is the value that we need to pass to
    the web service. If our web service accepts multiple parameters, we can chain
    `queryParam()` method invocations, using one for each parameter our RESTful web
    service expects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需要在`Client`实例上调用`target()`方法返回的`javax.ws.rs.client.WebTarget`实例上调用`queryParam()`方法来传递参数。此方法的第一参数是参数名称，必须与网络服务上的`@QueryParam`注解的值匹配。第二个参数是我们需要传递给网络服务的值。如果我们的网络服务接受多个参数，我们可以链式调用`queryParam()`方法，每个参数使用一个`queryParam()`方法。
- en: Path parameters
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径参数
- en: 'Another way we can pass parameters to our RESTful web services is via `path`
    parameters. The following example illustrates how to develop a JAX-RS RESTful
    web service that accepts `path` parameters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`path`参数将参数传递给我们的RESTful网络服务。以下示例说明了如何开发一个接受`path`参数的JAX-RS RESTful网络服务：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Any method that accepts a `path` parameter must be decorated with the `@Path`
    annotation. The value attribute of this annotation must be formatted as `"{paramName}/"`,
    where `paramName` is the parameter the method expects to receive. Additionally,
    method parameters must be decorated with the `@PathParam` annotation. The value
    of this annotation must match the parameter name declared in the `@Path` annotation
    for the method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接受`path`参数的方法都必须用`@Path`注解装饰。此注解的值属性必须格式化为`"{paramName}/"`，其中`paramName`是方法期望接收的参数。此外，方法参数必须用`@PathParam`注解装饰。此注解的值必须与方法上`@Path`注解中声明的参数名称匹配。
- en: 'We can pass `path` parameters from the command line by adjusting our web service''s
    URI as appropriate. For example, to pass an `"id"` parameter of `1` to the `getCustomer()`
    method above (which handles HTTP `GET` requests), we could do so from the command
    line, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整我们的网络服务的URI来从命令行传递`path`参数。例如，要将`1`这个`"id"`参数传递给上面的`getCustomer()`方法（它处理HTTP
    `GET`请求），我们可以在命令行中这样做，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Which returns the expected output of an XML representation of the `Customer`
    object returned by the `getCustomer()` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回由`getCustomer()`方法返回的`Customer`对象的XML表示形式的预期输出：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sending path parameters via the JAX-RS client API
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API发送路径参数
- en: 'Sending path parameters to a web service via the JAX-RS client API is easy
    and straightforward; all we need to do is add a couple of method invocations to
    specify the path parameter and its value. The following example illustrates how
    to do this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API将路径参数发送到网络服务既简单又直接；我们只需要添加几个方法调用来指定路径参数及其值。以下示例说明了如何做到这一点：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we invoke the `path()` method on the instance of `WebTarget`
    returned by `client.target()`. This method appends the specified `path` to our
    `WebTarget` instance. The value of this method must match the value of the `@Path`
    annotation in our RESTful web service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`client.target()`返回的`WebTarget`实例上调用`path()`方法。此方法将指定的`path`追加到我们的`WebTarget`实例。此方法的价值必须与我们的RESTful网络服务中`@Path`注解的值匹配。
- en: After invoking the `path()` method on our `WebTarget` instance, we then need
    to invoke `resolveTemplate()`. The first parameter for this method is the name
    of the parameter (without the curly braces), and the second parameter is the value
    we wish to pass as a parameter to our RESTful web service.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`WebTarget`实例上调用`path()`方法后，我们需要调用`resolveTemplate()`。此方法的第一参数是参数的名称（不带花括号），第二个参数是我们希望作为参数传递给我们的RESTful网络服务的值。
- en: 'If we need to pass more than one parameter to one of our web services, we simply
    need to use the following format for the `@Path` parameter at the method level:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将多个参数传递给我们的某个网络服务，我们只需在方法级别的`@Path`参数中使用以下格式：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, annotate the corresponding method arguments with the `@PathParam` annotation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用`@PathParam`注解标注相应的方法参数：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The web service can then be invoked by modifying the web service''s URI to
    pass the parameters in the order specified in the `@Path` annotation. For example,
    the following URI would pass the values `1` and `2` for `paramName1` and `paramName2`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过修改网络服务的URI来传递参数，按照`@Path`注解中指定的顺序调用网络服务。例如，以下URI将传递`paramName1`和`paramName2`的值`1`和`2`：
- en: '`http://localhost:8080/contextroot/resources/customer/1/2`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/contextroot/resources/customer/1/2`'
- en: The above URI will work both from the command line or through a web service
    client we develop with the JAX-RS client API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述URI既可以通过命令行使用，也可以通过我们使用JAX-RS客户端API开发的Web服务客户端使用。
- en: Server-sent events
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端发送事件
- en: Typically, every interaction between a web service and its client is initiated
    by the client; the client sends a request (`GET`, `POST`, `PUT`, or `DELETE`),
    then receives a response from the server. Server-sent events technology allows
    RESTful web services to "take the initiative" to send messages to a client, that
    is, to send data that is not a response to a client request. Server-sent events
    are useful for sending data continuously to a client, for applications such as
    stock tickers, news feeds, sports scores, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web服务和其客户端之间的每次交互都是由客户端发起的；客户端发送一个请求（`GET`、`POST`、`PUT`或`DELETE`），然后从服务器接收响应。服务器端发送事件技术允许RESTful
    Web服务“主动”向客户端发送消息，即发送不是响应客户端请求的数据。服务器端发送事件对于向客户端连续发送数据非常有用，例如股票行情、新闻源、体育比分等。
- en: 'JAX-RS 2.1 introduces server-sent event support. The following example illustrates
    how to implement this functionality into our JAX-RS RESTful web services:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.1引入了服务器端发送事件支持。以下示例演示了如何将此功能实现到我们的JAX-RS RESTful Web服务中：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example simulates sending stock prices for a fictitious company
    to the client. To send server-sent events to the client, we need to utilize instances
    of the `SseEventSink` and `Sse` classes, as illustrated in our example. Both of
    these classes are injected into our RESTful web service via the `@Context` annotation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例模拟了向客户端发送虚构公司的股票价格。为了向客户端发送服务器端发送的事件，我们需要利用`SseEventSink`和`Sse`类的实例，正如我们在示例中所展示的那样。这两个类都通过`@Context`注解注入到我们的RESTful
    Web服务中。
- en: To send an event, we first need to build an instance of `OutboundSseEvent` via
    the `newEventBuilder()` method of our `Sse` instance. This method creates an instance
    of `OutboundSseEvent.Builder`, which is then used to create the necessary `OutboundSseEvent`
    instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送一个事件，我们首先需要通过`Sse`实例的`newEventBuilder()`方法构建一个`OutboundSseEvent`实例。此方法创建一个`OutboundSseEvent.Builder`实例，然后用于创建必要的`OutboundSseEvent`实例。
- en: 'We give our event a name by invoking the `name()` method on our `OutboundSseEvent.Builder`
    instance, then set the data to be sent to the client via its `data()` method.
    The `data()` method takes two arguments: the first one is the type of data we
    are sending to the client (`String`, in our case), and the second one is the actual
    data we send to the client.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`OutboundSseEvent.Builder`实例上调用`name()`方法给我们的事件命名，然后通过其`data()`方法设置要发送给客户端的数据。`data()`方法接受两个参数：第一个是我们发送给客户端的数据类型（在我们的例子中是`String`），第二个是我们实际发送给客户端的数据。
- en: Once we have set our event's name and data via the corresponding method, we
    build an instance of `OutboundSseEvent` by invoking the `build()` method on `OutboundSseEvent.Builder`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过相应的方法设置了事件名称和数据，我们就通过在`OutboundSseEvent.Builder`上调用`build()`方法来构建一个`OutboundSseEvent`实例。
- en: Once we have built our instance of `OutboundSseEvent`, we send it to the client
    by passing it as a parameter to the `send()` method of `SseEventSink`. In our
    example, we loop through the simulated stock prices and send it to the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了`OutboundSseEvent`实例，我们就通过将其作为参数传递给`SseEventSink`的`send()`方法将其发送到客户端。在我们的示例中，我们遍历模拟的股票价格并将其发送到客户端。
- en: JavaScript Server-sent events client
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript服务器端发送事件客户端
- en: 'So far, all of our client examples have either used the curl command-line utility
    or the JAX-RS RESTful web server client API. It is very common to use JavaScript
    code running on a browser as a RESTful web service client, therefore, in this
    section, we will take that approach. The following example illustrates an HTML/JavaScript
    client receiving server-sent events:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的客户端示例要么使用了curl命令行工具，要么使用了JAX-RS RESTful Web服务客户端API。使用在浏览器上运行的JavaScript代码作为RESTful
    Web服务客户端是非常常见的，因此，在本节中，我们将采用这种方法。以下示例演示了一个HTML/JavaScript客户端接收服务器端发送的事件：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `getStockTickerValues()` JavaScript function creates an `EventSource` object.
    This constructor takes a `String` representing the URL of the server sending the
    events as a parameter. In our case, we used a relative URL, since the preceding
    HTML/JavaScript code is hosted on the same server as the server code. If this
    wasn't the case, we would have needed to use a full URL.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStockTickerValues()` JavaScript 函数创建了一个 `EventSource` 对象。这个构造函数接受一个表示发送事件的服务器
    URL 的 `String` 作为参数。在我们的例子中，我们使用了一个相对 URL，因为前面的 HTML/JavaScript 代码托管在与服务器代码相同的服务器上。如果不是这种情况，我们就需要使用一个完整的
    URL。'
- en: We implement the functionality to be executed when the client receives an event
    by adding an event listener to our `EventSource` instance via its `addEventListener()`
    function. This function takes the event name (notice that the value matches the
    name we sent in the Java code for our RESTful web service), and a function to
    be executed when an event is received. In our example, we simply update the contents
    of a `<span>` tag with the data of the received message.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向我们的 `EventSource` 实例添加事件监听器来执行客户端接收到事件时要执行的功能。这个函数接受事件名称（注意，该值与我们在 Java
    代码中为我们的 RESTful 网络服务发送的名称相匹配），以及一个在接收到事件时要执行的功能。在我们的例子中，我们只是简单地更新一个 `<span>` 标签的内容，以显示接收到的消息数据。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to easily develop RESTful web services using
    JAX-RS, a new addition to the Java EE specification.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用 JAX-RS，Java EE 规范的新增内容，轻松地开发 RESTful 网络服务。
- en: We covered how to develop a RESTful web service by adding a few simple annotations
    to our code. We also explained how to automatically convert data between Java
    and XML by taking advantage of the **Java API for XML Binding** (**JAXB**).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在我们的代码中添加几个简单的注解来开发 RESTful 网络服务。我们还解释了如何利用 **Java API for XML Binding**（**JAXB**）自动在
    Java 和 XML 之间转换数据。
- en: Additionally, we covered how to pass parameters to our RESTful web services
    via the `@PathParam` and `@QueryParam` annotations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了如何通过 `@PathParam` 和 `@QueryParam` 注解将参数传递给我们的 RESTful 网络服务。
- en: Finally, we discussed how to develop web services that are able to send server-sent
    events to all of their clients, utilizing the new JAX-RS 2.1 Server-Sent event
    support.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何开发能够向所有客户端发送服务器端事件的网络服务，利用新的 JAX-RS 2.1 服务器端事件支持。
