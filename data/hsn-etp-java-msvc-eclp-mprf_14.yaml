- en: Reactive Programming and Future Developments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程与未来发展
- en: Event-driven architectures have been around for a long time, and asynchronous
    method invocations, message-driven beans, event control logic, and so on are constructs
    that developers are familiar with. However, with the popularity and adoption of
    cloud resources and on-demand scalability, organizations have a renewed interest
    in reactive programming approaches that can exploit serverless and function as
    service-type environments. Eclipse MicroProfile also includes specifications related
    to reactive programming in projects that currently live outside the Eclipse MicroProfile
    umbrella/platform release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构已经存在很长时间，异步方法调用、消息驱动bean、事件控制逻辑等是开发者熟悉的构造。然而，随着云资源和按需可扩展性的普及和采用，组织对可以利用无服务器和函数即服务类型环境的反应式编程方法重新产生了兴趣。Eclipse
    MicroProfile还包括目前不在Eclipse MicroProfile伞/平台发布中的反应式编程相关项目规范。
- en: 'In addition to these, there are also projects in the Eclipse MicroProfile sandbox
    that the community is currently discussing, implementing, and evaluating to decide
    whether or not they should be promoted to official MicroProfile projects. This
    chapter will help you learn about the current MicroProfile specifications related
    to reactive programming as well as give you a glimpse into what is already in
    motion and what is upcoming in relation to the projects that sit outside the umbrella/platform
    release and in the MicroProfile sandbox. The following topics will be covered
    in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，Eclipse MicroProfile沙盒中还有社区目前正在讨论、实施和评估的项目，以决定它们是否应升级为正式的MicroProfile项目。本章将帮助您了解与反应式编程相关的当前MicroProfile规范，并为您提供一些已经在进行中和即将到来的项目，这些项目位于伞下/平台发布之外以及MicroProfile沙盒中。本章将涵盖以下主题：
- en: An overview of what reactive messaging is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式消息传递的概述
- en: An explanation of the reactive messaging architecture within Eclipse MicroProfile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Eclipse MicroProfile内的反应式消息传递架构
- en: A description of the Eclipse MicroProfile specifications related to reactive
    programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述与反应式编程相关的Eclipse MicroProfile规范
- en: Examples of how to use the reactive message specification of Eclipse MicroProfile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse MicroProfile反应式消息规范的示例
- en: An overview of MicroProfile projects/specifications that sit outside the umbrella
    or platform release
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述不在Eclipse MicroProfile伞下或平台发布中的MicroProfile项目/规范
- en: A description of projects that sit within the Eclipse MicroProfile sandbox
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述位于Eclipse MicroProfile沙盒中的项目
- en: An insight into the current relationship between Eclipse MicroProfile and Jakarta
    EE and an analysis of their possible futures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Eclipse MicroProfile与Jakarta EE当前的关系以及它们可能的未来分析
- en: Reactive programming work in Eclipse MicroProfile
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile中的响应式编程工作
- en: At the time of writing, the reactive-related specifications that are part of
    Eclipse MicroProfile are Reactive Streams Operators, Reactive Messaging, and Context
    Propagation. Reactive work within the MicroProfile community continues to evolve,
    and new specifications may surface in the future as well as newer releases of
    existing reactive-related ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，属于Eclipse MicroProfile的反应式相关规范包括Reactive Streams Operators、Reactive Messaging和Context
    Propagation。Eclipse MicroProfile社区内的反应式工作仍在不断发展，未来可能会有新的规范出现，同时现有反应式相关规范也会有新的版本发布。
- en: An overview of Reactive Messaging
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式消息传递概述
- en: 'The [Reactive Manifesto](https://www.reactivemanifesto.org/) defines the characteristics
    of reactive systems to including an asynchronous messaging core that is used to
    build elastic, resilient systems. This is typically illustrated via a diagram
    such as the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 《反应式宣言](https://www.reactivemanifesto.org/)定义了反应式系统的特性，包括一个用于构建弹性、恢复性系统的异步消息核心。这通常通过以下图表进行说明：
- en: '![](img/a5e7920f-3372-4247-a4d6-a9e52c974d3f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e7920f-3372-4247-a4d6-a9e52c974d3f.png)'
- en: The idea is that interaction via asynchronous messages promotes resilience,
    elasticity, and, in turn, responsiveness.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是通过异步消息交互促进弹性、弹性，进而提高响应性。
- en: The **MicroProfile Reactive Messaging** (**MP-RM**) specification aims to enable
    microservice-based applications with the characteristics of reactive systems via
    event-driven microservices. The specification focuses on versatility and is suitable
    for building different types of architecture and applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile 反应式消息**（**MP-RM**）规范旨在通过事件驱动的微服务使基于微服务的应用程序具有反应式系统的特性。该规范关注多样性，适用于构建不同类型的架构和应用程序。'
- en: Asynchronous interactions with different services and resources can be implemented
    using reactive messaging. Typically, asynchronous database drivers can be used
    in conjunction with reactive messaging to read and write into a data store in
    a non-blocking and asynchronous manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用反应式消息实现与不同服务和资源的不对称交互。通常，异步数据库驱动可以与反应式消息一起使用，以非阻塞和非同步的方式读写数据存储。
- en: When building microservices, **Command Query Responsibility Segregation** (**CQRS**)
    and event-sourcing patterns provide an answer to data sharing between microservices
    ([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)).
    Reactive messaging can also be used as the foundation for CQRS and the event-sourcing
    mechanism, as these patterns embrace message-passing as a core communication pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，**命令查询责任分离**（**CQRS**）和事件源模式为微服务之间的数据共享提供了答案([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html))。反应式消息也可以作为
    CQRS 和事件源机制的基础，因为这些模式拥抱消息传递作为核心通信模式。
- en: MicroProfile reactive messaging architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 反应式消息架构
- en: 'An application using reactive messaging is composed of CDI beans that consume,
    produce, and process messages. The messages can be internal to the application,
    or can be sent and received via external message brokers, as illustrated in the
    following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式消息的应用程序由消费、生产和处理消息的 CDI Bean 组成。这些消息可以是应用程序内部的，也可以是通过外部消息代理发送和接收的，如下面的图表所示：
- en: '![](img/8aec63b4-925c-414e-97b0-409c29421e65.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aec63b4-925c-414e-97b0-409c29421e65.png)'
- en: This figure shows a Kafka topic publishing messages to a first bean, which does
    some processing and publishes it to a second bean, which does its own processing/filtering,
    and finally publishes the message as an AMQP topic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表展示了一个 Kafka 主题向第一个 Bean 发布消息，该 Bean 进行一些处理后又将其发布给第二个 Bean，第二个 Bean 进行自己的处理/过滤，最后将消息作为
    AMQP 主题发布。
- en: As we will see when we look into MP-RM examples, application beans contain methods
    annotated with `@Incoming` and/or `@Outgoing ...`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在查看 MP-RM 示例时将看到的，应用 Bean 包含用 `@Incoming` 和/或 `@Outgoing ...` 注解的方法。
- en: Message shapes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息形状
- en: 'The MP-RM specification defines a number of supported signature types that
    beans can use to define publish and subscriber behaviors. These signatures depend
    on a few key types that are outlined in the following list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RM 规范定义了许多受支持的签名类型，Bean 可以使用它们来定义发布和订阅行为。这些签名依赖于以下列表中概述的几个关键类型：
- en: '`org.reactivestreams.Publisher`: A Reactive Streams `Publisher<T>` is a provider
    of a potentially unlimited number of sequenced elements, publishing them according
    to the demand received from its link subscriber(s).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Publisher`：一个 Reactive Streams `Publisher<T>` 是提供潜在无限数量序列元素的提供者，根据从其链接订阅者接收的需求发布它们。'
- en: '`org.reactivestreams.Subscriber`: A Reactive Stream `Subscriber<T>` interface
    that is used to signal demand to `Publisher`. It provides events for subscription
    information, zero or more data events, and error and completion events.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Subscriber`：一个用于向 `Publisher` 信号需求的 Reactive Stream `Subscriber<T>`
    接口。它提供了订阅信息事件、零个或多个数据事件以及错误和完成事件。'
- en: '`org.reactivestreams.Processor`: This Reactive Stream `Processor<T,R>` interface
    simply extends both `Subscriber<T>` and `Publisher<R>`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Processor`：这个 Reactive Stream `Processor<T,R>` 接口简单地扩展了
    `Subscriber<T>` 和 `Publisher<R>` 两个接口。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`: The
    MP Reactive Streams Operators `PublisherBuilder` interface allows you to build
    up a Reactive Streams `Publisher` from various sources and apply operations to
    transform/filter ultimately published messages.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`：MP Reactive
    Streams 操作符 `PublisherBuilder` 接口允许你从各种源构建 Reactive Streams `Publisher` 并应用操作来转换/过滤最终发布的消息。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Processor` from various sources and apply operations to transform/filter
    ultimately published messages.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`：微Profile反应流操作符`ProcessorBuilder`接口允许你从各种来源构建反应流`Processor`并应用操作来转换/过滤最终发布的消息。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Subscriber` from various sources and apply operations to transform/filter
    ultimately published messages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`：微Profile反应流操作符`SubscriberBuilder`接口允许你从各种来源构建反应流`Subscriber`并应用操作来转换/过滤最终发布的消息。'
- en: '`java.util.concurrent.CompletionStage`: This JDK concurrent `util` package
    interface defines a stage of computation that is typically asynchronous, and computes
    an action or value. `CompletionStage` can be combined so that a graph of stages
    may be executed to produce the final result.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.CompletionStage`：这个JDK并发`util`包接口定义了一个通常是异步的计算阶段，并计算一个动作或值。`CompletionStage`可以组合使用，以便执行阶段图以产生最终结果。'
- en: '`org.eclipse.microprofile.reactive.messaging.Message<T>`: An MP-RM interface
    that provides a wrapper around the payload of type `T` and an `ack` method to
    acknowledge receipt of the message.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.messaging.Message<T>`：一个提供类型为`T`的载荷包装器并有一个`ack`方法来确认收到消息的MP-RM接口。'
- en: 'With these types defined, we can look at the various types of method that produce
    data by pushing messages onto outgoing channels that MP-RM supports. The publisher
    method types of methods all have an `@Outgoing("channel-name")` annotation and
    support signatures as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些类型后，我们可以查看MP-RM支持的各种方法，这些方法通过将消息推送到出站通道来产生数据。所有发布者方法类型都有`@Outgoing("channel-name")`注解，并支持如下签名：
- en: '`Publisher<Message<T>> method()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<T>> 方法()`'
- en: '`Publisher<T> method()`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<T> 方法()`'
- en: '`PublisherBuilder<Message<T>> method()`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<T>> 方法()`'
- en: '`PublisherBuilder<T> method()`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<T> 方法()`'
- en: '`T method()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T 方法()`'
- en: '`CompletionStage<T> method()`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<T> 方法()`'
- en: 'Consumer methods all have an `@Incoming("channel-name")` annotation and support
    signatures as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者方法都有一个`@Incoming("channel-name")`注解，并支持如下签名：
- en: '`Subscriber<Message<T>> method()`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber<Message<T>> 方法()`'
- en: '`Subscriber<T> method()`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber<T> 方法()`'
- en: '`SubscriberBuilder<Message<T>>`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberBuilder<Message<T>>`'
- en: '`SubscriberBuilder<T>`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberBuilder<T>`'
- en: '`void method(Message<T> payload)`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void 方法(Message<T> 载荷)`'
- en: '`void method(T payload)`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void 方法(T 载荷)`'
- en: '`CompletionStage<?> method(Message<T> payload)`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<?> 方法(Message<T> 载荷)`'
- en: '`CompletionStage<?> method(T payload)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<?> 方法(T 载荷)`'
- en: 'Methods that both consume and produce data are known as processors, and will
    have both an `@Incoming("channel-in")` and `@Outgoing("channel-out")` annotation.
    Supported signatures are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既消耗数据又产生数据的方法被称为处理器，并将具有`@Incoming("channel-in")`和`@Outgoing("channel-out")`注解。支持的签名如下：
- en: '`Processor<Message<I>, Message<O>> method()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor<Message<I>, Message<O>> 方法()`'
- en: '`Processor<I, O> method();`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor<I, O> 方法();`'
- en: '`ProcessorBuilder<Message<I>, Message<O>>method()`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessorBuilder<Message<I>, Message<O>>方法()`'
- en: '`ProcessorBuilder<I, O> method();`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessorBuilder<I, O> 方法();`'
- en: '`Publisher<Message<O>> method(Message<I> msg)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> 方法(Message<I> msg)`'
- en: '`Publisher<O> method(I payload)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<O> 方法(I 载荷)`'
- en: '`PublisherBuilder<Message<O>> method(Message<I> msg)`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> 方法(Message<I> msg)`'
- en: '`PublisherBuilder<O> method(I payload)`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<O> 方法(I 载荷)`'
- en: '`Message<O> method(Message<I> msg)`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message<O> 方法(Message<I> msg)`'
- en: '`O method(I payload)`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O 方法(I 载荷)`'
- en: '`CompletionStage<Message<O>> method(Message<I> msg)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<Message<O>> 方法(Message<I> msg)`'
- en: '`CompletionStage<O> method(I payload)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<O> 方法(I 载荷)`'
- en: '`Publisher<Message<O>> method(Publisher<Message<I>> pub)`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> 方法(Publisher<Message<I>> pub)`'
- en: '`PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> 方法(PublisherBuilder<Message<I>> pub)`'
- en: '`Publisher<O> method(Publisher<I> pub)`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<O> 方法(Publisher<I> pub)`'
- en: '`PublisherBuilder<O> method(PublisherBuilder<I> pub)`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<O> 方法(PublisherBuilder<I> pub)`'
- en: Now, we will look at some examples of using beans with these signatures to build
    up message processing chains.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一些使用这些签名构建消息处理链的示例。
- en: MicroProfile Reactive Streams operators
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微Profile反应流操作符
- en: Reactive Streams requires more than just plumbing publishers to subscribers.
    Typically, a stream needs to be manipulated in some way, such as applying operations
    including `map`, `filter`, and `flatMap`. Neither Reactive Streams nor the JDK
    provide an API for performing these manipulations. Since users are not meant to
    implement Reactive Streams themselves, this means the only way to do these manipulations
    currently is to depend on a third-party library providing operators, such as Akka
    Streams, RxJava, or Reactor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流不仅仅是将发布者连接到订阅者。通常，一个流需要以某种方式进行操作，比如应用包括 `map`、`filter` 和 `flatMap` 的操作。反应式流和
    JDK 都没有提供执行这些操作的 API。由于用户不需要自己实现反应式流，这意味着目前进行这些操作的唯一方式是依赖于第三方库提供操作符，如 Akka Streams、RxJava
    或 Reactor。
- en: The MicroProfile Reactive Streams Operators API seeks to fill that gap so that
    MicroProfile application developers can manipulate Reactive Streams without bringing
    in a third-party dependency. ...
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 反应式流操作符 API 旨在填补这一空白，使得 MicroProfile 应用开发者能够无需引入第三方依赖即可操作反应式流。...
- en: MicroProfile Context Propagation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 上下文传播
- en: This specification, which sits outside the MicroProfile umbrella of platform
    release, is still in the proposed or draft state. We will discuss this specification
    in more detail in the *MicroProfile Future Developments* section later in this
    chapter, but we would like to give you a high-level introduction here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范位于 MicroProfile 平台发布之外的范畴，目前仍处于提议或草稿状态。我们将在本章后面的 *MicroProfile 未来发展趋势* 部分更详细地讨论这个规范，但在这里我们先给出一个高层次的介绍。
- en: The MicroProfile Context Propagation specification introduces APIs for propagating
    contexts across units of work that are thread-agnostic. It makes it possible to
    propagate context that was traditionally associated with the current thread across
    various types of units of work, such as `CompletionStage`, `CompletableFuture`,
    `Function`, and `Runnable`, regardless of which particular thread ends up executing
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 上下文传播规范引入了 API，用于在无线程关联的工作单元之间传播上下文。它使得能够将传统与当前线程相关联的上下文传播到各种工作单元，如
    `CompletionStage`、`CompletableFuture`、`Function` 和 `Runnable`，无论最终是哪个特定的线程执行它们。
- en: MicroProfile reactive messaging examples
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 反应式消息示例
- en: In this section, we will cover some examples of using MP-RM to create CDI beans
    that produce and consume messages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些使用 MP-RM 创建产生和消费消息的 CDI 豆子的示例。
- en: 'Let''s say you want a CDI bean to act as a source of a `Message<String>` such
    that whenever its `publishMessage(String)` method is called, an MP-RM message
    is posted to some MP-RM channel. To do this, we need to define a connector that
    bridges between the CDI bean and the MP-RM layer. An example of an incoming message
    connector that does this is shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想让一个 CDI 豆子作为 `Message<String>` 的来源，这样每当调用其 `publishMessage(String)` 方法时，就会向某个
    MP-RM 通道发布 MP-RM 消息。为此，我们需要定义一个连接器，它将 CDI 豆子与 MP-RM 层连接起来。下面代码示例展示了一个实现此功能的传入消息连接器：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: MicroProfile future developments
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 未来发展趋势
- en: As mentioned in [Chapter 2](0f9d569f-1ffb-4662-8cea-c8b230a4d627.xhtml), *Governance
    and Contributions*, new ideas brought to the Eclipse MicroProfile project are
    first tried in the MicroProfile sandbox following an implementation-first approach
    to innovation. The sandbox exercise gives the opportunity for the implementor
    and the community to discuss, analyze, and evaluate how this new idea fits in
    with the MicroProfile project. If, at the end of the sandbox exercise, the community
    deems that this new idea is worth adding to the project, a specific MicroProfile
    sub-project is created for it. The sub-project must issue at least one release
    before it can be considered for addition to a MicroProfile umbrella/platform release.
    At a very high-level, this is the process that new ideas and future developments
    follow under the MicroProfile project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 [2 章](0f9d569f-1ffb-4662-8cea-c8b230a4d627.xhtml) *治理和贡献* 中所述，带到 Eclipse
    MicroProfile 项目的新想法首先在 MicroProfile 沙箱中尝试，遵循实现优先的创新方法。沙箱练习为实施者和社区提供了讨论、分析和评估新想法如何融入
    MicroProfile 项目的机会。如果在沙箱练习结束时，社区认为这个新想法值得添加到项目中，就会为它创建一个特定的 MicroProfile 子项目。子项目在至少发布一个版本之前，才能考虑加入到
    MicroProfile 伞/平台发布中。在非常高层次上，这是新想法和未来发展趋势在 MicroProfile 项目下遵循的过程。
- en: In the next sections, we will discuss two types of projects those globally that
    are currently MicroProfile sub-projects that presebtly sit outside the MicroProfile
    umbrella/platform release (think of these as projects that have already graduated
    out of the MicroProfile sandbox), and the ones that are still in the MicroProfile
    sandbox. Lastly, we will discuss the current relationship between Eclipse MicroProfile
    and Jakarta EE and how their roadmaps may or may not meet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论两种类型的项目，这些项目目前是MicroProfile的子项目，目前不在MicroProfile伞下/平台发布（将这些视为已经从MicroProfile沙箱毕业的项目），以及仍在MicroProfile沙箱中的项目。最后，我们将讨论Eclipse
    MicroProfile和Jakarta EE之间的当前关系，以及它们的路线图可能满足也可能不满足。
- en: Projects outside the umbrella
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伞下项目
- en: 'In this section, we will cover projects that sit outside the Eclipse MicroProfile
    umbrella release, at the time of writing, of course. These are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Eclipse MicroProfile伞下发布之外的项目，当然，在撰写本文时。这些如下：
- en: Reactive Streams Operators
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式流操作符
- en: Reactive Messaging
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式消息传递
- en: Long Running Actions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期运行动作
- en: Context Propagation
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播
- en: GraphQL
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL
- en: Reactive Streams Operators and Reactive Messaging projects were already discussed
    in the previous sections of this chapter, so in this section we will cover only
    Long Running Actions, Context Propagation, and GraphQL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前几节已经讨论了响应式流操作符和响应式消息传递项目，因此在本节中我们只覆盖长期运行动作、上下文传播和GraphQL。
- en: Long Running Actions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长期运行动作
- en: 'In a loosely-coupled service environment, the motivation behind the **Long
    Running Actions** (**LRA**) specification is to provide consistent outcomes by
    business processes comprised of calls to many microservices without the need to
    lock data. One way to think about LRA is as *transactions for microservices*.
    Examples of situations when you need LRA include the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在松耦合的服务环境中，**长期运行动作**（**LRA**）规范背后的动机是为许多微服务的调用组成的业务流程提供一致的结果，而无需锁定数据。思考LRA的一种方式是将其视为*微服务的事务*。需要LRA的情况包括以下几种：
- en: Ordering a book online will require the retirement of a book from the inventory,
    the processing of a payment, and finally shipping of the book. All these tasks
    need to happen atomically, in other words, they need to be processed all together,
    in that, if any of the tasks fail, then all tasks must be undone.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网上订购一本书将需要从库存中退役一本书，处理支付，最后是发货。所有这些任务都需要原子性地完成，换句话说，它们需要一起处理，也就是说，如果任何任务失败，那么所有任务都必须被撤销。
- en: Making a flight reservation will require the removal of a seat from the airplane's
    list of available seats, the selection and assignment of a specific seat to the
    traveler, processing the payment, and the creation of a record locator. Again,
    all these tasks have to happen within the same long running action.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订航班将需要从飞机可用的座位列表中移除一个座位，为旅客选择并分配一个特定的座位，处理支付，以及创建一个记录定位器。同样，所有这些任务必须在同一个长期运行动作中完成。
- en: Not only do the preceding examples have to happen atomically, but they also
    have to generate a result where the data is consistent, even if any of their intermediate
    steps failed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅上述示例需要原子性地完成，而且它们还需要生成一个结果，即使它们的中间步骤中有任何失败，数据也是一致的。
- en: The current proposed solution for MicroProfile LRA has taken its inspiration
    from the *OASIS Web Services Composite Application Framework Technical Committee* ([https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf)),
    namely, the *Web Services **Long Running Action transaction model* ([https://www.oasis-open.org/committees/document.php?document_id=12794](https://www.oasis-open.org/committees/document.php?document_id=12794)),
    but has been updated to be more suited for use in microservice-based architectures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 微概要LRA当前提出的解决方案受到了*OASIS Web服务组合应用框架技术委员会*的启发（[https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf)），即*Web服务**长期运行动作事务模型*（[https://www.oasis-open.org/committees/document.php?document_id=12794](https://www.oasis-open.org/committees/document.php?document_id=12794)），但已更新以更适用于微服务架构。
- en: For further information on the MicroProfile LRA specification, refer to [https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc](https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MicroProfile LRA规范的更多信息，请参考[https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc](https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc)。
- en: 'The MicroProfile Long Running Actions specification model includes three main entities:
    compensators, a logical coordinator, and a client. A client can explicitly start
    a new LRA in two different ways:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile长期运行动作规范模型包括三个主要实体：补偿器、逻辑协调器和客户端。客户端可以通过两种不同的方式显式启动新的LRA：
- en: Via an annotation, or
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注解，或者
- en: Via an API call
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API调用
- en: Either one creates a new LRA. If a service does something that may need to be
    later undone, then the client needs to register a compensator with the LRA. If
    the client chooses to close or cancel the LRA, the compensator will undo the work
    the service performed within the scope of the LRA or compensate for any uncompleted
    work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要么创建一个新的LRA。如果一个服务可能需要稍后撤销某事，那么客户端需要为LRA注册一个补偿器。如果客户端选择关闭或取消LRA，补偿器将撤销服务在LRA范围内执行的工作，或者对未完成的工作进行补偿。
- en: 'The following are globally some of the main LRA annotations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些主要的LRA注解：
- en: '`@LRA` controls the life cycle of an LRA.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@LRA`控制LRA的生命周期。'
- en: '`@Compensate` indicates that the method should be invoked if the LRA is canceled.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Compensate`表示如果LRA被取消，则应调用该方法。'
- en: '`@Complete` indicates that the method should be invoked if the LRA is closed.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Complete`表示如果LRA关闭，则应调用该方法。'
- en: '`@Forget` indicates that the method may release any resources that were allocated
    for this LRA.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Forget`表示该方法可能释放为这次LRA分配的任何资源。'
- en: '`@Leave` indicates that this class is no longer interested in this LRA.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Leave`表示这个类不再对这次LRA感兴趣。'
- en: '`@Status` reports the status when the annotated method is invoked.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Status`在调用注解方法时报告状态。'
- en: You can use these annotations with JAX-RS and non-JAX-RS methods. In addition,
    this specification supports asynchronous and reactive features of JAX-RS, LRA
    nesting, and timeouts. Finally, it is worth mentioning that the LRA specification
    ensures atomicity and eventual consistency by placing certain requirements on
    the entities that participate in the protocol. As a MicroProfile project, the
    MicroProfile LRA specification, at the time of writing, is in a proposed or draft
    state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些注解与JAX-RS和非JAX-RS方法一起使用。此外，该规范支持JAX-RS的异步和反应式特性，LRA嵌套和超时功能。最后，值得一提的是，LRA规范通过对接口参与实体提出某些要求，确保事务性和最终一致性。作为一个MicroProfile项目，MicroProfile
    LRA规范，在撰写本文时，处于提议或草稿状态。
- en: Context Propagation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文传播
- en: The goal of the MicroProfile Context Propagation specification is to propagate
    context across units of work that are thread-agnostic. In a reactive model, the
    execution of logic is split into units of work that are chained together to assemble
    a reactive pipeline. Each unit of work executes within a context, which is often
    unpredictable and depends on the particular reactive engine being used. Some units
    might run with the context of a thread awaiting completion, or the context of
    a previous unit that completed and triggered the dependent unit, or with no context
    at all. The MicroProfile Context Propagation specification makes it possible for
    thread context propagation to easily be done in a type-safe manner, keeping boilerplate
    ...
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播规范的目标是在线程无关的工作单元之间传播上下文。在一个反应式模型中，逻辑的执行被拆分为相互链式组装的反应式流水线的工作单元。每个工作单元在上下文中执行，这通常是不可预测的，并取决于正在使用的特定反应式引擎。一些单元可能在与线程等待完成上下文的情况下运行，或者在完成并触发依赖单元的前一个单元的上下文中运行，或者根本没有任何上下文。MicroProfile上下文传播规范使得线程上下文传播可以轻松地以类型安全的方式完成，保持了样板代码...
- en: GraphQL
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL
- en: GraphQL is an open source data query and manipulation language for APIs, and
    a runtime for fulfilling queries with existing data. It interprets strings from
    the client and returns data in an understandable, predictable, and predefined
    manner. GraphQL is an alternative to REST, though not necessarily a replacement. The
    goal of the MicroProfile GraphQL specification is to provide a set of APIs to
    enable users to quickly develop portable GraphQL-based applications in Java. As
    a MicroProfile project, the MicroProfile GraphQL specification is currently, at
    the time of writing, in a proposed or draft state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一个开源的数据查询和操作语言，用于API，以及用于用现有数据满足查询的运行时。它解释客户端的字符串并以可理解、可预测和预定义的方式返回数据。GraphQL是REST的替代方案，但不一定是替代品。MicroProfile
    GraphQL规范的目标是为用户提供一套API，使用户能够快速在Java中开发可移植的GraphQL基础应用程序。作为一个MicroProfile项目，MicroProfile
    GraphQL规范在撰写本文时，处于提议或草稿状态。
- en: GraphQL is based on a Facebook specification. For more information on this, please
    refer to `https://graphql.github.io/graphql-spec`. A more general overview of
    GraphQL can be found on [https://graphql.org/](https://graphql.org/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL基于Facebook的规范。关于这一点，请参阅`https://graphql.github.io/graphql-spec`。有关GraphQL的更全面概述，请访问[https://graphql.org/](https://graphql.org/)。
- en: GraphQL and REST have many similarities and are both widely used in modern microservice-based applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL和REST有许多相似之处，都在现代微服务应用中得到广泛使用。
- en: Differences between GraphQL and REST
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL与REST的区别
- en: 'Here are the main differentiating features of GraphQL when compared to REST:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与REST相比GraphQL的主要区别性特征：
- en: '**Schema-driven**: The schema acts as a contract between the server and its
    clients.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于架构**：架构作为服务器及其客户端之间的合同。'
- en: '**Single HTTP endpoint**: A single endpoint and access to data and operations
    are achieved through the query language.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一HTTP端点**：通过查询语言实现单一端点和数据及操作的访问。'
- en: '**Flexible data retrieval**: Enables the client to select data in the response
    with a fine level of granularity, thereby avoiding over- or under-fetching data.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的数据检索**：允许客户端以细粒度的方式选择响应中的数据，从而避免过度或不足地获取数据。'
- en: '**Reduction of server requests**: The language allows the client to aggregate
    the expected data into a single request.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少服务器请求**：该语言允许客户端将预期的数据聚合成单个请求。'
- en: '**Easier version management**: Enables the creation of new data while deprecating
    old ones.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的版本管理**：在创建新数据的同时，使旧数据过时。'
- en: '**Partial results**: A result is made up of data and errors. Clients are responsible
    ...'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分结果**：结果由数据和错误组成。客户端负责...'
- en: GraphQL and databases
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL和数据库
- en: GraphQL is not a database technology. Instead, it is a data query and manipulation
    tool for APIs and is agnostic to any database or storage technologies. However,
    it can be used in front of any backend and is capable of aggregating data from
    multiple backend data sources with a single API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL不是数据库技术。相反，它是用于API的数据查询和操作工具，不依赖于任何数据库或存储技术。但是，它可以用于任何后端之前，并能够通过单个API从多个后端数据源聚合数据。
- en: Projects in the sandbox
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙盒中的项目
- en: The MicroProfile Project sandbox is where the community can come up with ideas
    by trying out an implementation of features and capabilities to elicit feedback,
    discussion, and evaluation from members within the community with the goal of
    deciding whether or not the idea should become a new API/specification for the
    MicroProfile project.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile项目沙盒是社区可以提出想法的地方，通过尝试实现功能和特性的实现，从社区成员那里获得反馈、讨论和评估，以决定是否将想法变成MicroProfile项目的新API/规范。
- en: The MicroProfile sandbox is located at [https://github.com/eclipse/microprofile-sandbox](https://github.com/eclipse/microprofile-sandbox).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile沙盒位于[https://github.com/eclipse/microprofile-sandbox](https://github.com/eclipse/microprofile-sandbox)。
- en: Past project proposals that graduated from the sandbox into official MicroProfile
    projects were GraphQL and Reactive Streams Operators. At the time of writing,
    there is only one proposal project in the sandbox, Boost.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从沙盒毕业成为正式MicroProfile项目的过去项目建议包括GraphQL和Reactive Streams Operators。在撰写本文时，沙盒中只有一个建议项目，即Boost。
- en: MicroProfile Boost
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Boost
- en: At the time of writing, the MicroProfile Boost is under community evaluation
    in the MicroProfile sandbox. Boost is a Maven plugin that enhances builds for
    your MicroProfile applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，MicroProfile Boost在MicroProfile沙盒中处于社区评估阶段。Boost是一个Maven插件，可增强为您的MicroProfile应用程序构建的过程。
- en: For more information on Boost, go to [https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Boost的更多信息，请访问[https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost)。
- en: Boost defines Maven dependencies, known as **boosters**, for MicroProfile APIs,
    for example `mpConfig` for MicroProfile Config, as well as for Java EE APIs. In
    addition, it defines dependencies for the runtimes that implement the different
    MicroProfile APIs, for example `openliberty`. One more Boost-defined maven dependency
    specified as a BOM (Bill-of-Material) indicates the version of the MicroProfile
    umbrella project to use for the maven build with respect to the MicroProfile APIs.
    The BOM contents are managed by the plugin. As a user of Boost, you include these
    dependencies in your `pom.xml` file to ease the build process of your MicroProfile
    application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Boost为MicroProfile API定义了Maven依赖项，称为**启动器**，例如为MicroProfile Config定义的`mpConfig`，以及为Java
    EE API。此外，它还为实现不同MicroProfile API的运行时定义了依赖项，例如`openliberty`。还有一个作为BOM（物料清单）指定的Boost定义的Maven依赖项，它指示在构建有关MicroProfile
    API的maven时使用MicroProfile伞项目的哪个版本。BOM内容由插件管理。作为Boost的用户，您将把这些依赖项包含在您的`pom.xml`文件中，以简化MicroProfile应用程序的构建过程。
- en: Eclipse MicroProfile and Jakarta EE
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile和Jakarta EE
- en: 'What is the relationship between the Eclipse Jakarta Enterprise Java project
    and the Eclipse MicroProfile project? Short answer: it remains to be seen. Long
    answer: let''s begin.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Jakarta Enterprise Java项目和Eclipse MicroProfile项目之间的关系是什么？简而言之：尚未可知。详细答案：让我们开始。
- en: The Eclipse MicroProfile project was initiated to address a lack of progress
    in the Java EE specifications under the **Java Community Process** (**JCP**).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile项目旨在解决在**Java Community Process**（**JCP**）下Java EE规范缺乏进展的问题。
- en: For more information on the Java Community Process, please visit `https://jcp.org/en/home/index`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Java社区过程的更多信息，请访问`https://jcp.org/en/home/index`。
- en: It has been over two years since the MicroProfile project moved to the Eclipse
    Foundation. Approximately one year later, Oracle announced its intention to move
    Java EE over to the Eclipse Foundation and rename it Jakarta EE. The move to Jakarta
    has been a long drawn-out process that is still ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自MicroProfile项目移至Eclipse基金会以来已经过去了两年多时间。大约一年后，Oracle宣布计划将Java EE移至Eclipse基金会并将其重命名为Jakarta
    EE。移至Jakarta的过程是一个漫长的过程，而且还在继续...
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned about future developments in the MicroProfile specification
    with the Long Running Actions, Context Propagation, and GraphQL projects outside
    the umbrella release, and the Boost project that''s still in the MicroProfile
    sandbox. In addition, you learned about reactive messaging concepts, the MicroProfile
    reactive messaging architecture, and how to implement reactive microservices using
    Eclipse MicroProfile reactive constructs via code examples. You also gained some
    knowledge of the background of each of these projects, their capabilities, annotations,
    and code examples when applicable, as well as their current state. Lastly, we
    presented the relationship between two similar but different projects: Eclipse
    MicroProfile and Jakarta EE, and discussed how their possible relationship could
    evolve in the future.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了MicroProfile规范的未来发展，包括Long Running Actions、Context Propagation和GraphQL项目，它们都不在伞发布之外，以及仍在MicroProfile沙箱中的Boost项目。此外，您还了解了反应式消息传递的概念、MicroProfile反应式消息传递架构，以及如何使用代码示例通过Eclipse
    MicroProfile反应式构件实现反应式微服务。您还获得了这些项目的背景知识、它们的 capabilities、注解（annotation）和在适用情况下的代码示例，以及它们当前的状态。最后，我们介绍了两个类似但不同的项目：Eclipse
    MicroProfile和Jakarta EE之间的关系，并讨论了它们可能在未来如何发展。
- en: In the next chapter, we will learn about Eclipse MicroProfile in multi-cloud
    environments and deployments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习在多云环境和部署中关于Eclipse MicroProfile的知识。
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If I have a source of messages, how do I integrate this into my MicroProfile
    applications?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个消息源，我该如何将其集成到我的MicroProfile应用程序中？
- en: Which of the existing MicroProfile specifications will MicroProfile Context
    Propagation best support?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MicroProfile Context Propagation最佳支持现有MicroProfile规范中的哪一个？
- en: What are the current MicroProfile specifications that support reactive programming?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前支持反应式编程的MicroProfile规范有哪些？
- en: What are the MicroProfile specifications that currently sit outside the umbrella/platform
    MicroProfile release?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前哪些MicroProfile规范位于伞/平台MicroProfile发布之外？
- en: What is the purpose of having a MicroProfile sandbox?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要有MicroProfile沙盒呢？
- en: What are the projects that currently sit in the MicroProfile sandbox?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前哪些项目位于MicroProfile沙盒中？
- en: What is the current relationship between Eclipse MicroProfile and Jakarta EE?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前Eclipse MicroProfile与Jakarta EE之间的关系是什么？
- en: What will the future relationship between Eclipse MicroProfile and Jakarta EE
    look like?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未来Eclipse MicroProfile与Jakarta EE之间的关系将如何发展？
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For MicroProfile reactive messaging, the [http://reactivex.io/](http://reactivex.io/)
    site provides motivation, tutorials, language bindings, and more.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于MicroProfile响应式消息传递，[http://reactivex.io/](http://reactivex.io/)网站提供了动机、教程、语言绑定等内容。
- en: A good starting point for GraphQL is the [https://graphql.org/](https://graphql.org/)
    site, which provides more background on the motivation behind it, as well as many
    resources for exploring how to put it to use.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习GraphQL的一个好起点是[https://graphql.org/](https://graphql.org/)网站，该网站提供了更多关于其背后的动机，以及许多用于探索如何使用它的资源。
