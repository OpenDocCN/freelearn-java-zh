- en: Building a Commercial Web Application Using REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST构建商业Web应用
- en: We were playing around till now, but Java is not a toy. We want to use Java
    for something real and serious, commercial and professional. In this chapter,
    we will do that. The example is not something that is only interesting to play
    with, such as Mastermind in the previous three chapters, but rather a real commercial
    application. Not a real-life application actually. You should not expect anything
    like that in a book. It would be too long and not educating enough. However, the
    application that we will develop in this chapter can be extended and can be used
    as a core for a real-life application in case you decided to do so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在玩弄，但Java不是玩具。我们希望用Java做一些真实和严肃的事情，商业和专业的事情。在本章中，我们将这样做。示例不仅仅是有趣的玩具，比如前三章中的Mastermind，而是一个真正的商业应用。实际上，它不是一个真实生活的应用。你不应该期望在书中看到这样的东西。那会太长，而且教育意义不足。然而，在本章中我们将开发的应用可以扩展，并且可以作为你决定这样做时真实生活应用的核心。
- en: In the previous chapter, we created servlets. To do so, we used the servlet
    specification, and we hand-implemented servlets. That is something you will rarely
    do these days. Instead, we will use a readily available framework, this time,
    Spring. It is the most widely used framework for Java commercial applications,
    and I dare say it is the de facto standard. It will do all the tedious work that
    we had to do (at least to understand and learn how a servlet works) in the previous
    chapter. We will also use Spring for dependency injection (why use two frameworks
    when one does it all?), and we will use Tomcat.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了servlets。为了做到这一点，我们使用了servlet规范，并且手动实现了servlets。这在当今时代是非常少见的。相反，我们将使用一个现成的框架，这次是Spring。它是Java商业应用中最广泛使用的框架，我敢说它已经成为事实上的标准。它将完成我们在上一章中必须做的所有繁琐工作（至少是理解和学习servlet是如何工作的）。我们还将使用Spring进行依赖注入（为什么使用两个框架，当其中一个就能完成所有工作的时候？），并且我们将使用Tomcat。
- en: In the previous chapter, we used Guice as a DI framework and Jetty as a servlet
    container. They can be a perfectly good choice for some projects. For other projects,
    other frameworks do better. To have the opportunity to look at different tools
    in this book, we will use different frameworks even though all the examples could
    be created by simply using Tomcat and Spring.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了Guice作为DI框架和Jetty作为servlet容器。它们对于某些项目来说可能是一个完美的选择。对于其他项目，其他框架可能做得更好。为了有机会在本书中查看不同的工具，我们将使用不同的框架，尽管所有示例都可以简单地使用Tomcat和Spring来创建。
- en: The commercial application we will develop will be an ordering system targeting
    resellers. The interface we will provide to the users will not be a web browser;
    rather, it will be REST. The users will themselves develop applications that communicate
    with our system and place orders for different products. The structure of the
    application we will develop will be microservices architecture, and we will use
    soapUI to test the application, in addition to the standard Chrome developer tool
    features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的商业应用将是一个面向分销商的订购系统。我们将提供给用户的接口将不是一个网络浏览器；而是一个REST。用户将自行开发与我们的系统通信并订购不同产品的应用程序。我们将开发的应用的结构将是微服务架构，我们将使用soapUI来测试应用程序，除了标准的Chrome开发者工具功能之外。
- en: The MyBusiness web shop
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyBusiness网络商店
- en: Imagine that we have a huge trading and logistics company. There are tens of
    thousands of different products on the shelves; hundreds of lorries come to our
    warehouse bringing new goods, and hundreds of lorries deliver goods to our customers.
    To manage the information, we have an inventory system that keeps track of the
    goods every day, hour, and minute to know what we actually have in the warehouse.
    We serve our customers without humans managing the warehouse information. Formerly,
    there were phones, fax machines, and even telex, but today, all we use is the
    Internet and web services. We do not provide a website for our customers. We have
    never directly served the end users in our imagined business, but these days,
    we have a subsidiary that we started off as a separate company to do just that.
    They have a website, and it is totally independent from us. They are just one
    of our hundreds of registered partners who each use a web service interface to
    see the products we have, order products, and track the order status.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个庞大的贸易和物流公司。货架上有着成千上万种不同的产品；数百辆卡车来到我们的仓库运送新商品，还有数百辆卡车将商品运送到我们的客户那里。为了管理信息，我们有一个库存系统，每天、每小时、每分钟跟踪商品，以便知道我们实际上在仓库里有什么。我们不通过人工管理仓库信息来服务我们的客户。以前，我们有电话、传真机，甚至电传，但今天，我们只使用互联网和Web服务。我们不为我们客户提供网站。在我们想象中的业务中，我们从未直接为最终用户服务，但如今，我们有一个子公司，我们最初将其作为一个独立公司来开展这项业务。他们有一个网站，并且完全独立于我们。他们只是我们数百个注册合作伙伴之一，每个合作伙伴都使用Web服务接口查看我们拥有的产品、订购产品以及跟踪订单状态。
- en: Sample business architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本业务架构
- en: Our partners are also large companies with automated administration, with several
    programs running on several machines. We have no interest in their architecture
    and the technology they use, but we want to integrate their operations. We want
    to serve them in a way that doesn't require any human interaction for the administration
    to order goods on either of our sides. To do so, a web service interface is provided
    that can be utilized no matter what IT infrastructure they use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的合作伙伴也是拥有自动化管理的大型公司，在多台机器上运行着几个程序。我们对他们的架构和他们使用的科技没有兴趣，但我们想整合他们的运营。我们希望以不需要任何人为交互的方式为他们提供服务，以便在我们的任何一方订购商品。为此，提供了一个可以无论他们使用什么IT基础设施都可以利用的Web服务接口。
- en: On our side, as we imagine the example, we recently replaced our monolithic
    application with microservices architecture, and though there are still some SOAP-based
    solutions in the system, most of the backend modules communicate using HTTPS and
    REST protocols. Some of the modules still rely on asynchronous file transfers
    done on a daily basis using FTP started from a UNIX `cron` job. The General Ledger
    system was programmed in COBOL. Fortunately, we do not need to deal with these
    dinosaurs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想象一下，我们最近将我们的单体应用替换成了微服务架构，尽管系统中仍然有一些基于SOAP的解决方案，但大多数后端模块都是通过HTTPS和REST协议进行通信的。一些模块仍然依赖于每天通过UNIX
    `cron`作业启动的FTP异步文件传输。总账系统是用COBOL编写的。幸运的是，我们不需要处理这些恐龙。
- en: All this structure is an imagined setup but a realistic one. I made up and described
    these parts to give you a picture of how you may see mixed technologies in a large
    enterprise. What I described here is a very simple setup. There are companies
    that have more than a thousand software modules in their systems using different
    technologies and totally different interfaces, all interconnected with each other.
    This is not because they like the mess, but that is the way it becomes after 30
    years of continuous IT development. New technologies come and old technologies
    fade out. The business changes and you cannot stick to the old technologies if
    you want to stay competitive. At the same time, you just cannot replace the entire
    infrastructure instantaneously. The result is that we see in an enterprise fairly
    old technologies still running and, many times, new technologies. Old technologies
    get rolled out by time. They do not stay forever, and still, we are surprised
    sometimes when a dinosaur comes in front of us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些结构都是一个想象中的但却是现实的设置。我编造并描述了这些部分，以便您了解在一个大型企业中您可能会看到混合技术的样子。我在这里描述的是一个非常简单的设置。有些公司在其系统中使用超过一千个软件模块，这些模块使用不同的技术和完全不同的接口，所有这些模块相互连接。这并不是因为他们喜欢混乱，而是在经过30年的持续IT发展之后，新技术出现而旧技术逐渐消失。业务在变化，如果您想保持竞争力，就不能坚持使用旧技术。同时，您也不能立即替换整个基础设施。结果是，我们在企业中看到相当老旧的技术仍在运行，很多时候还有新技术。旧技术随着时间的推移而被淘汰。它们不会永远存在，而且有时当一种“恐龙”出现在我们面前时，我们还是会感到惊讶。
- en: 'What we have to deal with is the two frontend components that we will develop.
    These are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的是我们将要开发的两个前端组件。具体如下：
- en: Product Information
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品信息
- en: Order Placement and Tracking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单放置和跟踪
- en: 'In the following image, you can see the architectural UML diagram of the structure
    that we look at. The parts we will have interaction with are only the frontend
    components, but it helps understand the working and their role if we have a bigger
    picture:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，您可以查看我们所查看的结构体系结构的UML图。我们将与之交互的部分仅限于前端组件，但如果有一个更大的图景，这有助于理解其工作方式和它们的作用：
- en: '![](img/00049.gif)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.gif)'
- en: Product Information delivers information about a single product, but it can
    also deliver a list of products based on the query criteria. Order Placement and
    Tracking provides functions to place an order and also lets the client to query
    the state of past orders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 产品信息提供有关单个产品的信息，但它也可以根据查询标准提供产品列表。订单放置和跟踪提供放置订单的功能，并允许客户查询过去订单的状态。
- en: To provide product information, we need access to the Product Catalog module
    that holds the actual product details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供产品信息，我们需要访问包含实际产品详情的产品目录模块。
- en: 'There can be a lot of other tasks that the Product Catalog does, and that is
    the reason it is a separate module. It can have, for example, a workflow and approval
    engine that lets product administrators to enter product data and managers to
    check and approve the data. Approval is usually a complex process, considering
    typos and legal questions (we do not want to trade unlicensed drugs, explosives,
    and so on), and checking the quality and approval state of the source of the goods.
    Many complex tasks are included that make it a backend module. In large enterprise
    applications, the frontend systems rarely do anything else other than the very
    basic functionality of serving the outside parties. But this is good for us; we
    can focus on the service that we have to deliver. And this is also good for the
    architecture. It is the same principle as in object-oriented programming: single
    responsibility.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 产品目录可能还有许多其他任务，这也是它成为一个独立模块的原因。例如，它可以有一个工作流和审批引擎，允许产品管理员输入产品数据，经理检查和批准数据。审批通常是一个复杂的过程，考虑到拼写错误和法律问题（我们不希望交易未经许可的药物、爆炸物等），以及检查商品来源的质量和审批状态。包含了许多复杂任务，使其成为一个后端模块。在大型的企业应用程序中，前端系统很少执行除了为外部各方提供非常基本的功能之外的其他任何事情。但这对我们来说是个好事；我们可以专注于我们必须提供的服务。这对架构来说也是好事。这与面向对象编程中的原则相同：单一责任。
- en: The Product Information module also has to consult with the Access Control module
    to see if a certain product can be delivered to the actual customer, and with
    the inventory to see if there is any product left, so we do not offer a product
    that is out of stock.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 产品信息模块还必须咨询访问控制模块，以查看是否可以将某种产品实际交付给客户，以及与库存查看是否有任何产品剩余，这样我们就不提供缺货的产品。
- en: The Order Placement and Tracking also needs access to Product Inventory and
    Access Control modules to check whether the order can be fulfilled. At the same
    time, it also needs services from the Pricing module, which can calculate the
    price for the order, and from the Logistics module, which triggers the collection
    of goods from the inventory locations and shipment to the customer. Logistics
    also has a connection to invoicing, which has a connection to the General Ledger,
    but these are on the picture only to show that the travel of information does
    not end there. There are many other modules that run the company, all of which
    are none of our interest at the moment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 订单放置和跟踪也需要访问产品库存和访问控制模块，以检查订单是否可以履行。同时，它还需要来自定价模块的服务，该模块可以计算订单的价格，以及来自物流模块的服务，该模块从库存位置触发货物的收集并运送给客户。物流还与开票系统相连，而开票系统与总账相连，但这些只是为了说明信息的流动并没有结束。还有许多其他模块在运行公司，所有这些目前都不是我们的兴趣所在。
- en: Microservices
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: The architecture described in the previous chapter is not a clean microservice
    architecture. You will never meet one in its pure form in any enterprise. It is
    more like something that we really meet in a real company moving from monolithic
    to microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中描述的架构并不是一个干净的微服务架构。在任何企业中，你永远都不会遇到其纯粹的形式。它更像是我们在从单体架构迁移到微服务架构的真正公司中遇到的东西。
- en: We talk about the microservice architecture when the application is developed
    in the form of many small services that communicate with each other using some
    simple API, usually over HTTP and REST. The services implement business functionalities
    and can be deployed independently. Many times, it is desirable that the service
    deployment is automated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用以许多小型服务的形式开发，这些服务通过一些简单的API（通常是通过HTTP和REST）相互通信时，我们谈论微服务架构。这些服务实现业务功能，并且可以独立部署。很多时候，自动化服务部署是可取的。
- en: The individual services can be developed using different programming languages,
    can use different data storage, and can run on different operating systems; thus,
    they are highly independent of each other. They can be, and usually are, developed
    by different teams. The important requirement is that they can cooperate; thus,
    the API one service implements is usable by the other services that build upon
    it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单个服务可以使用不同的编程语言开发，可以使用不同的数据存储，并可以在不同的操作系统上运行；因此，它们彼此之间高度独立。它们可以，并且通常是由不同的团队开发的。重要的要求是它们可以合作；因此，一个服务实现的API可以被构建在其上的其他服务使用。
- en: The microservice architecture is not the Holy Grail of all architectures. It
    gives different answers to some problems from monolithic architectures, and many
    times, these answers work better using modern tools. The applications still have
    to be tested and debugged, performance has to be managed, and bugs and issues
    have to be addressed. The difference is that testing can be separated along different
    technologies; debugging may need more network-related work. These may be good,
    bad, or both at the same time. For the developers, however, the advantage is clear.
    They can work on a smaller unit independently and can see the result of their
    work faster. When developing a single module of a monolithic application, the
    result can be seen when the entire application gets deployed. In the case of a
    large application, that may be rare. A typical deployment cycle in a large corporate
    developing monolithic is every few months, say 3, but it is not rare to see the
    release development twice or even once a year. Developing microservices, the new
    module can be deployed as soon as it is ready and tested.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构并不是所有架构的圣杯。它对一些问题给出了与单体架构不同的答案，而且很多时候，这些答案使用现代工具效果更好。应用仍然需要测试和调试，性能需要管理，并且需要解决错误和问题。区别在于测试可以沿着不同的技术分离；调试可能需要更多的网络相关工作。这些可能是好的，坏的，或者同时是两者。然而，对于开发者来说，优势是明显的。他们可以独立地在更小的单元上工作，并且可以更快地看到他们工作的结果。在开发单体应用的单一模块时，结果只有在整个应用部署后才能看到。在大型应用的情况下，这可能很少见。在大型企业中，单体应用的典型部署周期是每几个月一次，比如3个月，但每年发布两次或一次并不罕见。开发微服务时，新模块可以在准备好并测试后立即部署。
- en: If you want to read more on microservices, the first and the most authentic
    source is the article by Martin Fowler ([http://www.martinfowler.com/articles/microservices.html](http://www.martinfowler.com/articles/microservices.html)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于微服务的信息，最原始和最权威的来源是Martin Fowler的文章（[http://www.martinfowler.com/articles/microservices.html](http://www.martinfowler.com/articles/microservices.html))。
- en: Service interface design
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务接口设计
- en: 'We design the two interfaces that we will implement. When we design interfaces,
    we focus on the functionality first. Formatting and protocol come later. Interfaces
    generally should be simple and, at the same time, should accommodate the future
    change. This is a hard problem because we cannot see the future. Business, logistics,
    and all other experts may see some part of the future: how the world will change
    and what it will impose on the operation of the company and, especially, on the
    interface we provide for our partners.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了我们将要实现的两个接口。当我们设计接口时，我们首先关注功能。格式化和协议随后考虑。接口通常应该是简单的，同时应该适应未来的变化。这是一个难题，因为我们无法预知未来。商业、物流以及所有其他专家可能看到未来的一部分：世界将如何变化，以及它将对公司的运营，尤其是对我们为合作伙伴提供的接口施加什么影响。
- en: The stability of an interface is of utmost importance because the partners are
    outside entities. We cannot refactor the code they use. When we change a Java
    interface in our code, the compiler will complain at all the code locations where
    the change should be followed. In case of an interface that is used outside of
    our realm, this is not the case. Even if it is only a Java interface that we publish
    as open source on *GitHub*, we should be prepared that our users will face issues
    if we change the library in an incompatible way. In that case, their software
    will not compile and work with our library. In the case of an ordering system,
    it means that they will not order from us and we will soon be out of business.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的稳定性至关重要，因为合作伙伴是外部实体。我们无法重构他们使用的代码。当我们更改代码中的Java接口时，编译器会在所有需要跟随更改的代码位置发出警告。对于在领域外使用的接口，情况并非如此。即使它只是一个我们在*GitHub*上发布的开源Java接口，我们也应该准备好，如果以不兼容的方式更改库，我们的用户将面临问题。在这种情况下，他们的软件将无法编译并与我们的库一起工作。在订单系统的例子中，这意味着他们不会从我们这里订购，我们很快就会失去业务。
- en: This is one of the reasons why interfaces should be simple. Although this is
    generally true for most of the things in life, it is extremely important for such
    interfaces. It is tempting to provide convenience features for the partners because
    they are easy to implement. In the long run, however, these features may become
    very expensive as they need maintenance, should be kept backward compatible, and,
    in the long run, may not gain as much as they cost.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口应该简单的一个原因。尽管这在生活中大多数事情上都是普遍适用的，但对于这样的接口来说，这一点尤为重要。提供便利功能给合作伙伴是有吸引力的，因为这些功能易于实现。然而，从长远来看，这些功能可能会变得非常昂贵，因为它们需要维护，应该保持向后兼容，而且从长远来看，可能不会带来与成本相匹配的收益。
- en: 'To access product information, we need two functions. One of them lists certain
    products and another returns the details of a specific product. If it were a Java
    API, it would look as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问产品信息，我们需要两个函数。其中一个列出某些产品，另一个返回特定产品的详细信息。如果它是一个Java API，它看起来如下：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, order placement may look as shown in the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，订单放置可能看起来如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We provide these functionalities in our application via a web service interface
    and, more specifically, REST using JSON. We will discuss these technologies in
    a bit more detailed manner along with the Spring framework and Model View Controller
    design pattern, but first let''s look at the product information controller to
    get some feeling of how our program will look:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Web服务接口提供这些功能，更具体地说，是通过使用JSON的REST。我们将更详细地讨论这些技术，包括Spring框架和模型-视图-控制器设计模式，但首先让我们看看产品信息控制器，以了解我们的程序将如何看起来：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you compare the code of the servlet with the preceding code, you can see
    that this is much simpler. We do not need to deal with the `HttpServletRequest`
    object, call an API to get a parameter, or create an HTML output and write it
    to the response. The framework does this. We annotate the `@RestController` class,
    telling Spring that this is a controller that utilizes the *REST* web services;
    thus, it will by default create a **JSON** response from the object we return.
    We do not need to care about the conversion of the object to *JSON*, although
    we can if there is really a need. The object will automatically be converted to
    *JSON* using the field names used in the class and the field values of the instance
    we return. If the object contains more complex structures than just plain `String`,
    `int`, and `double` values, then the converter is prepared for nested structures
    and the most common data types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将servlet的代码与前面的代码进行比较，你可以看到这要简单得多。我们不需要处理`HttpServletRequest`对象，调用API获取参数，或者创建HTML输出并将其写入响应。框架会做这些。我们注解`@RestController`类，告诉Spring这是一个利用*REST*网络服务的控制器；因此，它将默认从我们返回的对象创建**JSON**响应。我们不需要关心对象到*JSON*的转换，尽管如果真的需要，我们也可以这样做。对象将自动使用类中使用的字段名和返回实例的字段值转换为*JSON*。如果对象包含比简单的`String`、`int`和`double`值更复杂的结构，则转换器已准备好嵌套结构和最常见的数据类型。
- en: To have different code handling and different URLs on the servlet, all we need
    to do is to annotate the method with `@RequestMapping`, providing the path part
    of the URL. The `{productId}` notation inside the mapping string is readable and
    easy to maintain. Spring just cuts the value from there and puts it for us in
    the `productId` variable, as requested by the `@PathVariable` annotation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在servlet上实现不同的代码处理和不同的URL，我们只需要注解方法为`@RequestMapping`，提供URL的路径部分。映射字符串中的`{productId}`表示法是可读的，易于维护。Spring将从那里剪切值并将其放入我们请求的`productId`变量中，正如`@PathVariable`注解所要求的。
- en: The actual lookup of the product is not implemented in the controller. That
    is not the function of the controller. The controller only decides what business
    logic to invoke and what view to use. A part of it is implemented in the framework,
    and the very small part you can see the preceding code. The business logic is
    implemented in a service class. An instance of this class is injected to the `lookup`
    field. This is also done by Spring. The actual work we have to do is to invoke
    the business logic, which this time, since we have only one, is fairly easy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，产品的查找并没有在控制器中实现。这不是控制器的功能。控制器只决定调用什么业务逻辑以及使用什么视图。其中一部分是在框架中实现的，你可以看到前面代码中的非常小的一部分。业务逻辑是在一个服务类中实现的。这个类的实例被注入到`lookup`字段中。这也是Spring做的。我们实际上需要做的工作是调用业务逻辑，这次，因为我们只有一个，所以相当简单。
- en: 'Most of these things seem magic without some more details about what the framework
    does for us. Therefore, before going on, we will have a look at the building blocks:
    JSON, REST, MVC, and a bit of the Spring framework.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有更多关于框架为我们做了什么的具体细节的情况下，这些事情看起来像是魔法。因此，在继续之前，我们将查看构建块：JSON、REST、MVC以及Spring框架的一些内容。
- en: JSON
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JSON** stands for **JavaScript Object Notation**. It is defined on the site,
    [http://www.json.org/](http://www.json.org/). This is a textual notation in the
    same way as the object literals are defined in JavaScript . An object representation
    starts with the `{` character and ends with the `}` character. The text in between
    defines the fields of the objects in the form, `string : value`. The string is
    the name of the field, and since JSON wants to be language agnostic, it allows
    any characters to be a part of the name of a field, and thus this string (as well
    as any string in JSON) should start and end with the `"` characters.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**。它在[http://www.json.org/](http://www.json.org/)网站上定义。这是一种与JavaScript中对象字面量定义相同的文本表示法。对象表示法以`{`字符开始，以`}`字符结束。之间的文本定义了对象的字段，形式为`string
    : value`。字符串是字段的名称，由于JSON希望是语言无关的，它允许任何字符成为字段名称的一部分，因此这个字符串（以及JSON中的任何字符串）应该以`"`字符开始和结束。'
- en: 'This may seem strange and, many times, when you start working with JSON, it
    is easy to forget and write `{ myObject : "has a string" }` instead of the correct
    `{ "myObject" : "has a string" }` notation.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '这可能看起来很奇怪，很多时候，当你开始使用JSON时，很容易忘记，并写成`{ myObject : "has a string" }`而不是正确的`{
    "myObject" : "has a string" }`表示法。'
- en: Commas separate the fields. You can also have arrays in JSON. They start and
    end with `[` and `]` characters, respectively, and they contain comma-separated
    values. The value in an object field or in an array can be a string, a number,
    an object, an array, or one of the constants, `true`, `false`, and `null`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字段之间用逗号分隔。在JSON中也可以有数组。它们分别以`[`和`]`字符开始和结束，并包含逗号分隔的值。对象字段或数组中的值可以是字符串、数字、对象、数组或常量之一，如`true`、`false`和`null`。
- en: 'Generally speaking, JSON is a very simple notation to describe data that can
    be stored in an object. It is easy to write using text editors and easy to read,
    and thus it is easier to debug any communication that uses JSON instead of more
    complex formats. Ways to convert JSON to a Java object and the other way round,
    are readily available in libraries that we will use in this chapter. A sample
    JSON object that describes a product from our sample code is also available in
    the source code of the program, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，JSON是一种非常简单的表示法，可以用来描述可以存储在对象中的数据。使用文本编辑器编写它很容易，而且阅读起来也很方便，因此使用JSON而不是更复杂的格式进行通信时，调试起来更容易。在本章中我们将使用的库中，提供了将JSON转换为Java对象以及相反方向的转换方法。描述我们示例代码中产品的JSON对象样本也包含在程序的源代码中，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the formatting of JSON does not require a new line, but at the same
    time, this is also possible. Program-generated JSON objects are usually compact
    and are not formatted. When we edit some object using a text editor, we tend to
    format the indentation of the fields in the same way as we usually do in Java
    programming.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON的格式不需要换行，但同时也可能这样做。程序生成的JSON对象通常很紧凑，并且没有格式化。当我们使用文本编辑器编辑某些对象时，我们倾向于以与我们在Java编程中通常所做的方式相同的方式来格式化字段的缩进。
- en: REST
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: There is no exact definition of the **REST** protocol. It stands for **Representational
    state transfer**, which probably does not mean a thing to someone who has never
    heard of it. When we program the REST API, we use the HTTP(S) protocol. We send
    simple requests to the server, and we get simple answers that we program. This
    way, the client of the web server is also a program (by the way, the browser is
    also a program) that consumes the response from the server. The format of the
    response, therefore, is not HTML formatted using CSS and enriched by client-side
    functionalities by JavaScript**,** but rather some data descriptive format such
    as JSON. REST does not set restrictions on the actual format, but these days,
    JSON is the most widely used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: REST协议没有确切的定义。它代表**表示状态转移**，这可能对从未听说过它的人来说没有什么意义。当我们编写REST API时，我们使用HTTP(S)协议。我们向服务器发送简单的请求，并得到我们编程的简单回答。这样，Web服务器的客户端也是一个程序（顺便说一句，浏览器也是一个程序），它消耗来自服务器的响应。因此，响应的格式不是使用CSS格式化的HTML，也不是通过JavaScript增强客户端功能，而是某种数据描述格式，如JSON。REST不对实际格式设置限制，但如今，JSON是最广泛使用的。
- en: The wiki page that describes REST is available at [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).
    REST interfaces are usually made simple. The HTTP requests almost always use the
    `GET` method. It also makes the testing of REST services simple since nothing
    is easier than issuing a `GET` request from a browser. `POST` requests are only
    used when the service performs some transaction or change on the server, and that
    way, the request is sending data to the server rather than getting some data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 描述REST的维基页面可在[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)找到。REST接口通常很简单。HTTP请求几乎总是使用`GET`方法。这也使得测试REST服务变得简单，因为没有什么比从浏览器发出`GET`请求更容易了。`POST`请求仅在服务在服务器上执行某些事务或更改时使用，这样请求就是向服务器发送数据，而不是获取某些数据。
- en: In our application, we will use the `GET` method to query a list of products
    and get information about a product, and we will only use `POST` to order products.
    The application that serves these requests will run in a servlet container. You
    have learnt how to create a naked servlet without the use of a framework. In this
    chapter, we will use the Spring framework, which offloads many of the tasks from
    the developer. There are many program constructs in servlet programming that are
    just the same most of the time. They are called boilerplate code. The Spring framework
    utilizes the Model View Controller design pattern to develop web applications;
    thus, we will look at it in brief, before discussing Spring in general.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将使用`GET`方法查询产品列表并获取有关产品的信息，我们只使用`POST`来订购产品。处理这些请求的应用程序将在servlet容器中运行。你已经学会了如何在不使用框架的情况下创建裸露的servlet。在本章中，我们将使用Spring框架，它将许多任务从开发者那里卸载。在servlet编程中有很多程序结构，大多数时候都是相同的。它们被称为样板代码。Spring框架利用模型-视图-控制器设计模式来开发Web应用程序；因此，在讨论Spring的一般情况之前，我们将简要地看看它。
- en: Model View Controller
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: '**Model View Controller** (**MVC**) is a design pattern. Design patterns are
    programming constructs: simple structures that give some hint on how to solve
    some specific problems. The term, **design pattern** was coined and formally described
    in the book, *Design Patterns, Elements of Reusable Object-Oriented Software*,
    written by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. The book
    defines a design pattern as a structure with a *name*, a *problem*, and a *solution*.
    The *name* describes the pattern and gives the vocabulary for the developer community
    to use when talking about these patterns. It is important that different developers
    use the same language terminology in order to understand each other. The *problem*
    describes the situation, that is, the design problem where the pattern can be
    applied. The *solution* describes classes and objects and the relations between
    them, which contribute to a good design.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种设计模式。设计模式是编程结构：一些简单的结构，为解决某些特定问题提供了一些提示。术语“设计模式”是由Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides在他们的著作《设计模式：可复用面向对象软件元素》中提出并正式描述的。这本书将设计模式定义为具有*名称*、*问题*和*解决方案*的结构。*名称*描述了模式，并为开发者在讨论这些模式时提供了词汇。重要的是，不同的开发者使用相同的语言术语以便相互理解。*问题*描述了情况，即模式可以应用的设计问题。*解决方案*描述了类和对象及其之间的关系，这些关系有助于良好的设计。'
- en: One of them is MVC, which is suitable for programming web applications but generally
    for any application that has a user interface. In our case, we do not have a classical
    user interface because the client is also a program; still, MVC can be and is
    a good choice to use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是MVC，它适合于编程Web应用程序，但通常适用于任何具有用户界面的应用程序。在我们的情况下，我们没有传统的用户界面，因为客户端也是一个程序；尽管如此，MVC可以并且是一个好的选择。
- en: '![](img/00050.gif)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.gif)'
- en: 'The MVC pattern, as the name also indicates, has three parts: a model, a view,
    and a controller. This separation follows the single responsibility principle,
    requiring one part for each distinct responsibility. The controller is responsible
    for handling the inputs of the system, and it decides what model and view to use.
    It controls the execution but usually does not do any business logic. The model
    does the business logic and contains the data. View converts the model data to
    a representation that is consumable by the client.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名称所暗示的，MVC模式有三个部分：一个模型、一个视图和一个控制器。这种分离遵循单一责任原则，要求每个部分对应一个不同的责任。控制器负责处理系统的输入，并决定使用哪个模型和视图。它控制执行，但通常不执行任何业务逻辑。模型执行业务逻辑并包含数据。视图将模型数据转换为客户端可消费的表示形式。
- en: MVC is a well-known and widely used design pattern, and it is directly supported
    by Spring in such a way that when you create a web application, you program the
    controller built into the framework, using annotations; thus, you essentially
    configure it. You can program the view, but it is more likely that you will use
    one that is built into the framework. You will want to send data to the client
    in XML, JSON**,** or HTML. If you are very exotic, you may want to send YAML,
    but generally, that is it. You do not want to implement a new format that needs
    to be programmed on the server and, since this is new, also on the client.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一个众所周知且广泛使用的架构模式，Spring 直接支持它，这样当您创建一个 Web 应用程序时，您可以通过使用注解来编程框架内构建的控制器，从而本质上对其进行配置。您可以编程视图，但更有可能的是您将使用框架内构建的视图。您希望将数据以
    XML、JSON**、**或 HTML 的形式发送到客户端。如果您非常独特，您可能希望发送 YAML，但通常就是这样。您不希望实现一个需要在服务器上编程的新格式，而且由于这是新的，也需要在客户端上编程。
- en: We create the model, and this time, we also program it. After all, that is the
    business logic. Frameworks can do many things for us, mainly the things that are
    the same for most of the applications but for the business logic. Business logic
    is the code that distinguishes our code from other programs. That is what we have
    to program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建模型，这次我们还对它进行编程。毕竟，那是业务逻辑。框架可以为我们做很多事情，主要是大多数应用程序都相同的事情，但对于业务逻辑。业务逻辑是区分我们的代码与其他程序的代码。这正是我们必须编写的代码。
- en: On the other hand, that is what we like to do. Focus on the business code and
    avoid all boilerplate provided by the framework.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这正是我们所希望的。专注于业务代码，避免框架提供的所有样板代码。
- en: Now that we know what JSON, REST, and the general Model View Controller design
    pattern are, let's look at how these are managed by Spring and how we can put
    these technologies into action.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 JSON、REST 以及通用的模型视图控制器设计模式，让我们看看 Spring 如何管理这些技术，以及我们如何将这些技术付诸实践。
- en: Spring framework
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架
- en: The Spring framework is a huge one with several modules. The first version of
    the framework was released in 2003, and since then, there have been four major
    releases delivering new and enhanced features. Currently, Spring is the de facto
    enterprise framework used, perhaps more widely than the standard **EJB 3.0**
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架是一个庞大的框架，包含多个模块。该框架的第一个版本于 2003 年发布，自那时起，已有四个主要版本发布，提供了新的和增强的功能。目前，Spring
    是事实上的企业级框架，可能比标准的 **EJB 3.0** 更广泛地被使用。
- en: Spring supports dependency injection, **Aspect-Oriented Programmin**g (**AOP**),
    persistence for **SQL** and **NoSQL** databases in a conventional and Object Relational
    Mapping way, transactional support, messaging, web programming, and many other
    features. You can configure it using **XML** configuration files, annotations,
    or Java classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 支持依赖注入、**面向切面编程（AOP**）、以传统和对象关系映射方式对 **SQL** 和 **NoSQL** 数据库进行持久化、事务支持、消息传递、Web
    编程以及许多其他功能。您可以使用 **XML** 配置文件、注解或 Java 类来配置它。
- en: Architecture of Spring
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 架构
- en: Spring is not monolithic. You can use a part of it, or only some of the features.
    You can include some of the modules of Spring that you need and leave out others.
    Some modules depend on some others, but Gradle, Maven, or some other build tool
    handles that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 不是单体架构。您可以使用它的一部分，或者只使用一些功能。您可以包含 Spring 需要的一些模块，并排除其他模块。一些模块依赖于其他模块，但
    Gradle、Maven 或其他构建工具会处理这一点。
- en: 'The following image shows you the modules of the Spring framework for version
    4:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 Spring 框架版本 4 的模块：
- en: '![](img/00051.gif)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.gif)'
- en: Spring is constantly developing since its first release, and it is still considered
    as a modern framework. The core of the framework is a dependency injection container
    similar to the one we saw in the previous chapter. As the framework developed,
    it also supported AOP and many other enterprise functionalities, such as message
    oriented patterns and web programming with an implementation of Model View Controller,
    supporting not only servlets but also portlets and WebSockets. Since Spring targets
    the enterprise application arena, it also supports database handling in many different
    ways. It supports JDBC using templates, **Object Relational Mapping** (**ORM**),
    and transaction management.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 自从首次发布以来一直在不断发展，它仍然被视为一个现代框架。框架的核心是一个类似于我们在上一章中看到的依赖注入容器。随着框架的发展，它还支持
    AOP 和许多其他企业功能，例如面向消息的模型和基于 Model View Controller 的 Web 编程，不仅支持 servlets，还支持 portlets
    和 WebSockets。由于 Spring 面向企业应用领域，它还支持多种数据库处理方式。它支持使用模板的 JDBC、**对象关系映射**（**ORM**）和事务管理。
- en: 'In the sample program, we use a fairly recent module: Spring boot. This module
    makes it extremely easy to start writing and running applications, assuming a
    lot of configurations that are usually the same for many programs. It contains
    an embedded servlet container that it configures for default settings and configures
    Spring wherever it is possible, so we can focus on the programming aspect rather
    than on the Spring configuration.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例程序中，我们使用了一个相当新的模块：Spring Boot。这个模块使得开始编写和运行应用程序变得极其容易，假设了很多通常对许多程序都相同的配置。它包含一个嵌入的
    servlet 容器，它为默认设置进行配置，并在可能的地方配置 Spring，这样我们就可以专注于编程方面，而不是 Spring 配置。
- en: Spring core
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 核心
- en: The central element of the core module is the context. When a Spring application
    starts, the container needs a context in which the container can create different
    beans. This is very general and true for any dependency injection container. If
    we programmatically create two different contexts, they may live independent of
    each other in the same **JVM**. If there is a bean declared as a singleton so
    that there should be only one single instance of it, then the container will create
    a single instance of it for a context when we need one instance. The objects representing
    the context have a reference to the object that we have already created. If there
    are multiple contexts, however, they will not know that there is another context
    in the JVM that already has an instance, and the container will create a new instance
    of the singleton bean for the other context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块的核心元素是上下文。当 Spring 应用程序启动时，容器需要一个上下文，以便容器可以在其中创建不同的 bean。这对于任何依赖注入容器来说都是非常通用和真实的。如果我们以编程方式创建两个不同的上下文，它们可能独立存在于同一个
    **JVM** 中。如果声明了一个作为单例的 bean，那么应该只有一个实例，那么容器在需要时将为上下文创建一个单例 bean 的实例。代表上下文的对象引用了我们已经创建的对象。然而，如果有多个上下文，它们将不知道
    JVM 中已经存在另一个上下文，并且已经有一个实例，容器将为另一个上下文创建单例 bean 的新实例。
- en: Usually, we do not use more than one context in a program, but there are numerous
    examples of there being many contexts in a single JVM. When different servlets
    run in the same servlet container, they run in the same JVM separated by the class
    loader and they may each use Spring. In this case, the context will belong to
    the servlet and each will have a new context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会在程序中使用超过一个上下文，但在单个 JVM 中存在多个上下文的例子却很多。当不同的 servlet 在同一个 servlet 容器中运行时，它们在同一个
    JVM 中运行，由类加载器分隔，并且它们可能各自使用 Spring。在这种情况下，上下文将属于 servlet，并且每个 servlet 都将有一个新的上下文。
- en: In the previous chapter, we used Guice. The Spring context is similar to the
    Guice injector. In the previous chapter, I was cheating a bit because I was programming
    Guice to create a new injector for each request. This is far from optimal, and
    Guice provides an injector implementation that can handle servlet environments.
    The reason for cheating was that I wanted to focus more on the DI architecture
    essentials, and I did not want to complicate the code by introducing a complex
    (well, more complex) implementation of the injector.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了 Guice。Spring 上下文类似于 Guice 注入器。在上一章中，我有点作弊，因为我正在编程 Guice 以为每个请求创建一个新的注入器。这远远不是最优的，Guice
    提供了一个可以处理 servlet 环境的注入器实现。作弊的原因是我想要更多地关注 DI 架构的基本要素，并且我不想通过引入复杂的（好吧，更复杂的）注入器实现来使代码复杂化。
- en: In the Spring context behavior, what it does, is defined by the interface `ApplicationContext`.
    There are two extensions of this interface and many implementations. `ConfigurableApplicationContext`
    extends `ApplicationContext`, defining setters, and `ConfigurableWebApplicationContext`
    defines methods needed in the web environment. When we program web applications,
    we usually do not need to interfere directly with the context. The framework configures
    the servlet container programmatically, and it contains servlets that create the
    context and invoke our methods. This is all boilerplate code created for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring上下文行为中，它所执行的操作由`ApplicationContext`接口定义。这个接口有两个扩展和许多实现。`ConfigurableApplicationContext`扩展了`ApplicationContext`，定义了设置器，而`ConfigurableWebApplicationContext`定义了在Web环境中需要的方
    法。当我们编程Web应用程序时，我们通常不需要直接与上下文交互。框架以编程方式配置servlet容器，并包含创建上下文和调用我们方法的servlet。这些都是为我们创建的样板代码。
- en: The context keeps track of the beans created, but it does not create them. To
    create beans, we need bean factories (at least one). The topmost interface of
    bean factories in Spring is `BeanFactory`. The difference between an object and
    a bean is that a bean factory creates the bean, it is registered in the context,
    and it has a `String` name. This way, the program can refer to the bean by the
    name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文跟踪创建的豆，但它不会创建它们。要创建豆，我们需要豆工厂（至少一个）。Spring中豆工厂的最顶层接口是`BeanFactory`。对象和豆之间的区别在于，豆工厂创建豆，它在上下文中注册，并且有一个`String`名称。这样，程序可以通过名称引用豆。
- en: Different beans can be configured in several different ways in Spring. The oldest
    approach is to create an XML file that describes the different beans, specifying
    the names, the class that has to be instantiated to create the bean, and fields
    in case the bean needs other beans to be injected for its creation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，不同的豆（bean）可以以几种不同的方式配置。最古老的方法是创建一个XML文件来描述不同的豆，指定名称、需要实例化的类以创建豆，以及如果豆需要注入其他豆以进行创建的字段。
- en: The motivation behind this approach is that this way, the bean wiring and configuration
    can be totally independent of the application code. It becomes a configuration
    file that can be maintained separately. If we have a large application that may
    work in several different environments, the access to inventory data may be available
    in multitude ways. In one environment, the inventory is available by calling SOAP
    services. In another environment, the data is accessible in an SQL database. In
    the third environment, it can be available in some NoSQL store. Each of these
    accesses is implemented as a separate class, implementing a common inventory access
    interface. The application code depends only on the interface, and it is the container
    that has to provide one or the other implementation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的动机在于，这样豆的连接和配置可以完全独立于应用程序代码。它变成一个可以单独维护的配置文件。如果我们有一个可能在不同环境中运行的大型应用程序，库存数据的访问可能有多种方式。在一个环境中，库存可以通过调用SOAP服务来获取。在另一个环境中，数据可以通过SQL数据库访问。在第三个环境中，它可以在某些NoSQL存储中可用。每种访问都作为实现一个公共库存访问接口的单独类来实现。应用程序代码只依赖于接口，而容器必须提供一种或另一种实现。
- en: When the configuration of the bean wiring is in XML, then only this XML file
    is to be edited, and the code can be started with the implementation of the interface
    that is suitable for that environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当豆连接配置在XML中时，则只需编辑此XML文件，并且可以使用适合该环境的接口实现来启动代码。
- en: 'The next possibility is to configure the beans using annotations. Many times,
    we use beans and Spring not because there are many implementations for a bean
    functionality, but because we want to separate the creation of the object instance
    from the functionality. This is a good style: separation of the concerns even
    if the implementation is single without alternatives. However, in this case, creating
    the XML configuration is redundant. If there is an interface and a single implementation
    of it in our code, then why should I specify in an XML that by creating an object
    with a class that implements that interface, I should use the class that implements
    that interface? Quite obvious, isn''t it? We do not like programming things that
    can be automated.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可能性是使用注解来配置豆（Beans）。很多时候，我们使用豆和Spring并不是因为存在许多针对豆功能的实现，而是因为我们想将对象实例的创建与功能分离。这是一种良好的风格：即使实现是单一的，没有替代方案，也要分离关注点。然而，在这种情况下，创建XML配置是多余的。如果我们的代码中有一个接口以及它的单一实现，那么为什么我要在XML中指定通过创建一个实现该接口的类的对象，我应该使用实现该接口的类呢？这显然是很明显的，不是吗？我们不喜欢编程那些可以被自动化的东西。
- en: To signal that a class can be used as a bean, and to possibly provide a name,
    we can use the `@Component` annotation. We do not need to provide a name as an
    argument. In that case, the name will be an empty string, but why have a name
    if we do not refer to it? Spring scans all the classes that are on the classpath
    and recognizes the classes annotated, and it knows that they are the candidates
    to be used for bean creation. When a component needs another bean to be injected,
    the field can be annotated with `@Autowired` or `@Inject`. The `@Autowired` annotation
    is a Spring annotation and existed before the `@Inject` annotation was standardized.
    If you intend to use your code outside of the Spring container, it is recommended
    to use standard annotations. Functionally, they are equivalent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个类可以用作豆，并且可能提供名称，我们可以使用`@Component`注解。我们不需要提供名称作为参数。在这种情况下，名称将是一个空字符串，但如果我们不引用它，为什么要有一个名称呢？Spring扫描类路径上的所有类，并识别注解的类，并且知道它们是用于创建豆的候选者。当一个组件需要注入另一个豆时，字段可以注解为`@Autowired`或`@Inject`。`@Autowired`注解是Spring注解，在`@Inject`注解标准化之前就已经存在。如果你打算在Spring容器之外使用你的代码，建议使用标准注解。功能上，它们是等效的。
- en: In our code, when Spring creates an instance of the `ProductInformationController`
    component, it sees that it needs an instance of `ProductLookup`. This is an interface,
    and thus, Spring starts to look for some class that implements this interface,
    creates an instance of it, possibly first creating other beans, and then injects
    it, setting the field. You can decide to annotate the setter of the field instead
    of the field itself. In such a case, Spring will invoke the setter even if the
    setter is private. You can inject dependencies through constructor arguments.
    The major difference between the setter, field injection, and constructor injection
    is that you cannot create a bean without dependency in case you use constructor
    injection. When the bean is instantiated, it should and will have all other beans
    injected so that it depends on using the constructor injection. At the same time,
    the dependencies that need to be injected through the setter injection, or directly
    into a field, could be instantiated later by the container sometime between instantiating
    the class and readying the bean.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，当Spring创建`ProductInformationController`组件的实例时，它会看到需要一个`ProductLookup`的实例。这是一个接口，因此Spring开始寻找实现这个接口的某个类，创建它的实例，可能首先创建其他豆，然后注入它，设置字段。你可以选择注解字段的setter而不是字段本身。在这种情况下，即使setter是私有的，Spring也会调用setter。你可以通过构造函数参数注入依赖项。setter注入、字段注入和构造函数注入之间的主要区别是，如果你使用构造函数注入，你不能在没有依赖项的情况下创建豆。当豆被实例化时，它应该并且将会注入所有其他豆，以便它依赖于使用构造函数注入。同时，需要通过setter注入或直接注入字段的依赖项，可以在容器在实例化类和准备豆之间某个时间点实例化。
- en: This slight difference may not seem interesting or important until your constructor
    code may become more complex than the simple dependency settings or until the
    dependencies become complex. In the case of a complex constructor, the code should
    pay attention to the fact that the object is not fully created. This is generally
    true for any constructor code, but in the case of beans created by a dependency
    injection container, it is even more important. Thus, it may be advisable to use
    constructor injection. In that case, the dependencies are there; if a programmer
    makes a mistake, forgetting that the object is not fully initialized, and uses
    it in the constructor or a method that is called from a constructor, the dependency
    is there. Also, it is clean and well-structured to use the constructor to initialize
    the dependencies and have those fields declared `final`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种细微的差异可能在你构造函数代码可能比简单的依赖设置更复杂或依赖变得复杂之前，看起来并不有趣或不重要。在复杂构造函数的情况下，代码应该注意对象尚未完全创建的事实。这通常适用于任何构造函数代码，但在由依赖注入容器创建的bean的情况下，这一点尤为重要。因此，可能建议使用构造函数注入。在这种情况下，依赖项已经存在；如果程序员犯了一个错误，忘记了对象尚未完全初始化，并在构造函数或从构造函数调用的方法中使用它，那么依赖项就在那里。此外，使用构造函数初始化依赖项并将这些字段声明为`final`是干净且结构良好的。
- en: On the other hand, constructor injection has its downsides.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，构造函数注入有其缺点。
- en: If different objects depend on each other and there is a ring in the dependency
    graph, then Spring will face a hard time if you use constructor dependencies.
    When class *A* needs class *B* and the other way round, as the simplest circle,
    then neither *A* nor *B* can be created without the other if the dependency injection
    is constructor dependency. In situations like this, the constructor injection
    cannot be used, and the circle should be broken at least as a single dependency.
    In situations like this, setter injection is inevitable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同的对象相互依赖，并且依赖图中存在环，那么如果你使用构造函数依赖，Spring将面临困难。当类*A*需要类*B*，反之亦然，作为最简单的循环，如果依赖注入是构造函数依赖，那么没有另一个类*A*或*B*可以创建。在这种情况下，构造函数注入不能使用，至少应该打破一个依赖的环。在这种情况下，setter注入是不可避免的。
- en: Setter injection may also be better when there are optional dependencies. Many
    times, some class may not need all its dependencies at the same time. Some class
    may use a database connection or a NoSQL database handle but not both at the same
    time. Although it may also be a code smell and probably a sign of poor OO design,
    it may happen. It may be a deliberate decision to do that because the pure OO
    design would result in too deep object hierarchies and too many classes, beyond
    the maintainable limit. If such is the situation, the optional dependencies may
    be better handled using setter injection. Some are configured and set; some are
    left with default values, usually `null`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在可选依赖时，setter注入可能也更好。很多时候，某个类可能不需要同时使用所有依赖。有些类可能同时使用数据库连接或NoSQL数据库句柄，但不是同时使用。尽管这也可能是一个代码异味，可能是糟糕的OO设计的迹象，但这种情况可能发生。这可能是出于故意，因为纯OO设计会导致对象层次结构太深，类太多，超出了可维护的极限。如果这种情况发生，可选依赖可能更适合使用setter注入。一些被配置并设置；一些保留默认值，通常是`null`。
- en: 'Last but not least, we can configure the container using Java classes in case
    the annotations are not enough. For example, there are multiple implementations
    of the `ProductLookup` interface, as it is, in our code base. (Don''t worry if
    you did not recognize that; I have not told you about that yet.) There is a `ResourceBasedProductLookup`
    class that reads properties files from the package and is mainly to test the application,
    and there is `RestClientProductLookup`, which is a production-like implementation
    of the interface. If I have no other configuration than annotating the `lookup`
    field with `@Autowired`, Spring will not know which implementation to use and
    will reward the use during startup with the following error message:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，如果注解不够用，我们可以使用Java类来配置容器。例如，在我们的代码库中，`ProductLookup`接口有多个实现，正如它现在所做的那样。（如果你没有认出这一点，不用担心；我还没有告诉你。）有一个`ResourceBasedProductLookup`类，它从包中读取属性文件，主要用于测试应用程序，还有一个`RestClientProductLookup`，它是接口的生产型实现。如果我没有其他配置，只是用`@Autowired`注解`lookup`字段，Spring将不知道使用哪个实现，并在启动时返回以下错误信息：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a fairly self-explanatory error message; it tells a lot. Now is the
    time when we can configure the bean in XML, but at the same time, we can also
    configure it using Java.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直白的错误消息；它告诉了我们很多。现在是我们可以在XML中配置bean的时候，但与此同时，我们也可以使用Java来配置它。
- en: Many developers do not get the point the first time. I did not get it either.
    The whole XML configuration was to separate the configuration from the code. It
    was to create the possibility that a system administrator changes the configuration
    and is free to select one or the other implementation of some interface, wiring
    the application together. Now Spring tells me that it is better to return to the
    programmatic way?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者第一次没有理解这个要点。我自己也没有理解。整个XML配置是为了将配置与代码分离。是为了创建系统管理员更改配置并自由选择某个接口的一个或另一个实现，将应用程序连接起来的可能性。现在Spring告诉我，返回到程序化方式更好？
- en: At the same time, I could hear concerns for many years that XML is not really
    any better than Java code. XML writing is essentially programming, except that
    the tooling and IDE support is not as good for XML as it is for Java code (the
    latter developed a lot in recent years, although for Spring XML configuration).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，多年来我听到很多人对XML并不比Java代码更好的担忧。XML编写本质上是一种编程，只是工具和IDE对XML的支持不如Java代码（尽管后者在近年来发展了很多，尽管对于Spring
    XML配置）。
- en: To understand the concept of returning to Java code from XML, we have to get
    back to the pure reason and aim of the XML way of configuration. The main advantage
    of XML Spring configuration is not that the format is not programmatic but rather
    that the configuration code is separated from application code. If we write the
    configuration in Java and keep those configuration classes to the bare minimum,
    and they stay as they should, then the separation of application versus configuration
    code still stands. It is only the format of the configuration that we change from
    XML to Java. The advantages are numerous. One is that the names of the classes
    are recognized by the IDE as we edit and we can have autocomplete in Java (note
    that this also works using XML in some of the IDEs utilizing some of the extensions
    of plugins). In the case of Java, IDE support is ubiquitous. Java is more readable
    than XML. Well, this is a matter of taste, but most of us like Java more than
    XML.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解从XML返回Java代码的概念，我们必须回到XML配置方式的纯粹原因和目标。XML Spring配置的主要优势不在于格式不是程序性的，而在于配置代码与应用程序代码的分离。如果我们用Java编写配置并保持那些配置类尽可能少，并且它们保持应有的状态，那么应用程序代码与配置代码的分离仍然存在。我们只是将配置的格式从XML改为Java。优势众多。其中之一是，当我们编辑时，IDE会识别类名，我们可以在Java中实现自动完成（注意，这也在一些IDE中使用插件扩展的情况下使用XML实现）。在Java的情况下，IDE支持无处不在。Java比XML更易读。好吧，这是一个口味问题，但大多数人更喜欢Java而不是XML。
- en: System administrators can also edit Java code. When they edit the XML configuration,
    they usually have to extract it from a JAR or WAR file, edit it, and then package
    the archive again. In the case of Java editing, they also have to issue a `gradle
    war` command or something similar. This should not be a showstopper for a system
    manager who runs Java applications on a server. And again, it is not Java programming.
    It is only editing some Java code files and replacing some class name literals
    and string constants.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员也可以编辑Java代码。当他们编辑XML配置时，通常需要从JAR或WAR文件中提取它，编辑它，然后再次打包存档。在Java编辑的情况下，他们还必须发出`gradle
    war`命令或类似命令。这对于在服务器上运行Java应用程序的系统管理员来说不应该是一个阻止因素。再次强调，这并不是Java编程。这只是编辑一些Java代码文件和替换一些类名字面量和字符串常量。
- en: 'We follow this approach in our sample application code. We have two configuration
    files in the application: one for local deployment and testing and another for
    production. The `@Profile` annotation specifies which profile the configuration
    should use. The profile, when the code is executed, can be specified on the command
    line as a system property, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的示例应用程序代码中遵循这种方法。在应用程序中我们有两个配置文件：一个用于本地部署和测试，另一个用于生产。`@Profile`注解指定了配置应该使用哪个配置文件。当代码执行时，配置文件可以在命令行上指定为一个系统属性，如下所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The configuration class is annotated with `@Configuration`. The methods that
    are bean factories are annotated with `@Bean`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类被注解为`@Configuration`。作为bean工厂的方法被注解为`@Bean`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The bean factory simply returns a new instance of the `ResourceBasedProductLookup`
    class that implements the `ProductLookup` interface. This implementation can be
    used to run the application for local testing when there are no external services
    to rely on. This implementation reads the product data from local resource files
    packaged into the JAR application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Bean工厂简单地返回一个实现了`ProductLookup`接口的`ResourceBasedProductLookup`类的新实例。这个实现可以在没有外部服务可依赖的情况下用于本地测试应用程序。这个实现从打包到JAR应用程序中的本地资源文件中读取产品数据。
- en: 'The production version of the configuration is not much different, but as it
    may be expected, there are a few more things to configure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的生产版本与之前没有太大不同，但正如预期的那样，有一些更多的事情需要配置：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This version of the `ProductLookup` service class uses an external REST service
    to retrieve the data that it will present to the clients. To do so, it needs the
    URLs of these services. Such URLs should usually be configured. In our example,
    we implement a solution where these URLs can be computed on the fly. I tried to
    make up a situation where it may be needed in real life, but all reasoning was
    contorted and I gave up. The real reason is that, this way, we can see code that
    contains a bean that needs another bean to be injected. For now, note that the
    `ProductInformationServiceUrlBuilder` instance bean is defined in the same way
    as the `ProductLookup` bean, and when it has to be injected into the constructor
    of the `ProductLookup` bean, its defining bean method is used and not the following
    expression directly:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`ProductLookup`服务类使用外部REST服务来检索它将向客户端展示的数据。为此，它需要这些服务的URL。这些URL通常应该进行配置。在我们的例子中，我们实现了一个解决方案，这些URL可以即时计算。我试图构造一个可能在实际生活中需要的情况，但所有推理都变得扭曲，我放弃了。真正的理由是，这样我们可以看到包含需要另一个Bean注入的Bean的代码。现在，请注意，`ProductInformationServiceUrlBuilder`实例Bean的定义方式与`ProductLookup`Bean相同，当它需要注入到`ProductLookup`Bean的构造函数中时，使用的是定义Bean的方法，而不是直接使用下面的表达式：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The latter may work, but not in all situations and we should not use it. For
    the reasons, we will return when we discuss AOP with Spring in a subsequent section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可能工作，但并非在所有情况下都适用，我们不应该使用它。关于原因，我们将在后续章节讨论Spring的AOP时再返回。
- en: Also note that there is no need to define an interface to define a bean. The
    type that the bean method returns can also be a class. The context will use the
    method that fits the needed type, and if there are more than one suitable types
    and the configuration is not precise enough, as we saw, the container will log
    an error and will not work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，没有必要定义一个接口来定义一个Bean。Bean方法返回的类型也可以是一个类。上下文将使用适合所需类型的那个方法，如果有多个合适的类型并且配置不够精确，就像我们看到的，容器将记录一个错误并且不会工作。
- en: In the configuration that serves the local profile, we create a `null` value
    for `ProductInformationServiceBuilder`. This is because we do not need it when
    we use local testing. Also, if any method from this class is invoked, it will
    be an error. Errors should be detected as soon as possible; thus, a `null` value
    is a good choice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在为本地配置文件提供服务的配置中，我们为`ProductInformationServiceBuilder`创建了一个`null`值。这是因为我们在使用本地测试时不需要它。此外，如果调用这个类的任何方法，它将是一个错误。错误应该尽快被发现；因此，`null`值是一个不错的选择。
- en: 'The `ProductInformationServiceUrlBuilder` class is very simple:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductInformationServiceUrlBuilder`类非常简单：'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This bean also needs a constructor parameter, and we used a string constant
    in the configuration. This clearly shows that it is possible to use a simple object
    to initialize some of the dependencies (what would stop us, it is pure Java after
    all), but it may hinder the working of some Spring features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也需要一个构造函数参数，我们在配置中使用了字符串常量。这清楚地表明，可以使用简单的对象来初始化一些依赖项（毕竟，这还是纯Java），但它可能会妨碍某些Spring特性的工作。
- en: Service classes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类
- en: 'We have two service classes. These classes serve the controllers with data
    and implement the business logic, no matter how simple they are. One of the service
    class implementations calls REST-based services, while the other one reads data
    from properties files. The latter can be used to test the application offline.
    The one that calls REST services is used in the production environment. Both of
    them implement the `ProductLookup` interface:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个服务类。这些类为控制器提供数据并实现业务逻辑，无论它们多么简单。其中一个服务类实现调用基于REST的服务，而另一个从属性文件中读取数据。后者可以用于离线测试应用程序。调用REST服务的那个用于生产环境。它们都实现了`ProductLookup`接口：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ResourceBasedProductLookup` stores the whole database in a map called products.
    It is filled from the properties files when one of the service methods is invoked.
    The `private` method `loadProducts` is invoked from each of the service methods
    when they start, but it loads the data only if it is not loaded yet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceBasedProductLookup` 将整个数据库存储在一个名为 `products` 的映射中。当调用其中一个服务方法时，它会从属性文件中填充。当服务方法开始时，会从每个服务方法中调用
    `private` 方法 `loadProducts`，但只有当数据尚未加载时才会加载数据：'
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class is annotated using `@Service`. This annotation is practically equivalent
    to the `@Component` annotation. This is only an alternative name to the same annotation.
    Spring also handles the `@Component` annotation such that if an annotation interface
    is annotated using the `@Component` annotation, the annotation can also be used
    to signal that a class is a Spring component. You can write your own annotation
    interfaces if you want to signal for better readability that a class is not a
    simple component but some other special type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用 `@Service` 注解。这个注解实际上等同于 `@Component` 注解。这仅仅是相同注解的另一个名称。Spring 也处理 `@Component`
    注解，使得如果一个注解接口被 `@Component` 注解，那么这个注解也可以用来表示一个类是 Spring 组件。如果你想表示一个类不是简单的组件而是其他特殊类型，以便提高可读性，你可以编写自己的注解接口。
- en: 'For example, start up your IDE and navigate to the source code of the `org.springframework.stereotype.Service`
    interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，启动你的 IDE 并导航到 `org.springframework.stereotype.Service` 接口的源代码：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `fromProperties` method creates an instance of `ProductInformation` and
    fills it from the parameters given in the `Properties` object. The `Properties`
    class is an old and widely used type. Although there are more modern formats and
    classes, this is still widely used and it is likely that you will meet this class.
    This is the very reason we use it here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromProperties` 方法创建一个 `ProductInformation` 实例，并从 `Properties` 对象中提供的参数填充它。`Properties`
    类是一个古老且广泛使用的类型。尽管有更多现代的格式和类，但它仍然被广泛使用，你可能会遇到这个类。这正是我们在这里使用它的原因。'
- en: '`ProductInformation` is a simple **Data Transfer Object** (**DTO**) that contains
    no logic, only fields, setters, and getters. It also contains a constant, `emptyProductInformation`,
    holding a reference to an instance of the class with empty values.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductInformation` 是一个简单的 **数据传输对象**（**DTO**），它不包含任何逻辑，只有字段、setter 和 getter。它还包含一个常量，`emptyProductInformation`，它持有具有空值的类实例的引用。'
- en: 'A `Properties` object is similar to a `Map` object. It contains `String` values
    assigned to `String` keys. There are methods, as we will see in our examples,
    that help the programmer to load a `Properties` object from a so-called properties
    file. Such a file usually has the `.properties` extension, and it contains key
    value pairs in the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Properties` 对象类似于一个 `Map` 对象。它包含用 `String` 键分配的 `String` 值。正如我们将在示例中看到的那样，有一些方法可以帮助程序员从一个所谓的属性文件中加载
    `Properties` 对象。这样的文件通常具有 `.properties` 扩展名，并且包含以下格式的键值对：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For example, the `123.properties` file contains the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`123.properties` 文件包含以下内容：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `properties` files are used to store simple configuration values and are
    almost exclusively used to contain language-specific constants. This is a very
    contorted use because `properties` files are **ISO Latin-1** encoded files, and
    in case you need to use some special UTF-8 characters, you have to type them using
    the  `\uXXXX` format or using the native2ascii converter program. You cannot save
    them simply as UTF-8\. Nevertheless, this is the file format used for language-specific
    strings used for program internationalization (also abbreviated as i18n because
    there are 18 characters between the starting i and the last n).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`properties` 文件用于存储简单的配置值，并且几乎仅用于包含特定语言的常量。这是一个非常扭曲的使用，因为 `properties` 文件是
    **ISO Latin-1** 编码的文件，如果你需要使用一些特殊的 UTF-8 字符，你必须使用 `\uXXXX` 格式或使用 native2ascii
    转换程序来输入它们。你不能简单地以 UTF-8 格式保存它们。尽管如此，这是用于程序国际化的特定语言字符串所使用的文件格式（也简称为 i18n，因为从起始的
    i 到最后的 n 之间有 18 个字符）。'
- en: To get the `Properties` object, we have to read the files in the project and
    get them packaged into a JAR file. The Spring class, `PathMatchingResourcePatternResolver`,
    helps us in doing so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `Properties` 对象，我们必须读取项目中的文件，并将它们打包成一个 JAR 文件。Spring 类 `PathMatchingResourcePatternResolver`
    帮助我们这样做。
- en: Gosh, yes, I know! We have to get used to these long names when we use Spring.
    Anyway, such long and descriptive names are widely used in an enterprise environment
    and they are needed to explain the functionality of the classes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，是的，我知道！当我们使用Spring时，我们必须习惯这些长名称。无论如何，在企业环境中广泛使用这样的长且描述性的名称，它们是解释类功能所必需的。
- en: 'We declare a map that will contain all the products during the testing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个将包含所有产品的映射，在测试期间：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The key is the product ID, which is a string in our example. The values are
    the `ProductInformation` objects that we fill up using the `fromProperties` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 键是产品ID，在我们的例子中是一个字符串。值是我们使用`fromProperties`方法填充的`ProductInformation`对象：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next field signals that the products are not loaded:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段表示产品尚未加载：
- en: Novice programmers usually use the opposite value with the name `productsAreLoaded`
    and set to `false` by default. In that case, the only place where we will read
    a value will negate the value, or the main branch of the `if` command becomes
    the do nothing part. Neither is a best practice.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 新手程序员通常使用名为`productsAreLoaded`的相反值，并将其默认设置为`false`。在这种情况下，我们只会在否定值的地方读取值，或者`if`命令的主分支成为不执行部分。这两种做法都不是最佳实践。
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `getResources` method returns all the resources (files) that are on the
    classpath under the `products` directory and that have a`.properties` extension:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`getResources`方法返回所有位于`products`目录下且具有`.properties`扩展名的资源（文件）：'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The product ID is given by the name of the file. This is calculated using simple
    string manipulation, cutting off the extension. The `Resource` can also provide
    an input stream that the `Properties` class's `load` method can use to load all
    the properties at once from the file. Finally, we save the new `ProductInformation`
    object in the map.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 产品ID由文件名给出。这是通过简单的字符串操作计算的，切除了扩展名。`Resource`也可以提供一个输入流，`Properties`类的`load`方法可以使用它一次性从文件中加载所有属性。最后，我们将新的`ProductInformation`对象保存到映射中。
- en: 'We also have a special `noProduct` list that is empty. This is returned if
    there is no product for the query when we want to search for products:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个特殊的空`noProduct`列表。当我们想要搜索产品但没有产品时，会返回这个列表：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The product lookup service just takes a product from the `Map` and returns
    it, or if it does not exist, it returns an empty product:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 产品查找服务只是从`Map`中取一个产品并返回它，或者如果不存在，则返回一个空产品：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The query is a bit more complex. It implements searching for a product by title.
    Real-life implementations may implement a more complex logic, but this version
    is for local testing only; thus, the search by title is enough, perhaps even more
    complex than would be really necessary:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 查询要复杂一些。它实现了通过标题搜索产品的功能。现实生活中的实现可能实现更复杂的逻辑，但这个版本仅用于本地测试；因此，通过标题搜索就足够了，可能甚至比实际必要的还要复杂：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The service class that implements the production functionality is much simpler.
    Strange, but many times the test code is more complex than the production code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现生产功能的服务类要简单得多。奇怪的是，但很多时候测试代码比生产代码复杂：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The constructor is used to inject the URL builder bean and this is all the
    auxiliary code the class has. The rest are the two service methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数用于注入URL构建器bean，这就是该类所有的辅助代码。其余的是两个服务方法：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `byId` method first calls the inventory service to see if there are any
    products on the inventory. This REST service returns a JSON that has the format,
    `{ amount : nnn }`; thus, we need a class (so simple that we do not list here)
    that has the `int amount` field, the setter, and the getter.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`byId`方法首先调用库存服务以查看库存中是否有任何产品。这个REST服务返回一个具有以下格式的JSON，`{ amount : nnn }`；因此，我们需要一个具有`int
    amount`字段、setter和getter的类（如此简单，我们在此不列出）。'
- en: The Spring `RestTemplate` provides an easy way to access a REST service. All
    it needs is the URL template, a type that is used to convert the result, and a
    `Map` object with the parameters. The URL template string may contain parameters
    in the same way as the request mapping in the Spring controllers, the name of
    the parameter being between the `{` and `}` characters. The template class provides
    simple methods to access REST services. It automatically does marshaling, sending
    parameters, and un-marshaling, receiving the response. In the case of a `GET`
    request, the marshaling is not needed. The data is in the request URL, and the
    `{xxx}` placeholders are replaced with the values from the map supplied as a third
    argument. The un-marshaling is readily available for most of the formats. In our
    application, the REST service sends JSON data, and it is indicated in the response
    `Content-Type` HTTP header. `RestTemplate` converts the JSON to the type provided
    as argument. If ever the server decides to send the response in XML, and it will
    also be indicated in the HTTP header, `RestTemplate` will handle the situation
    automatically. As a matter of fact, looking at the code, we cannot tell how the
    response is encoded. This is also nice because it makes the client flexible and
    at the same time, we do not need to deal with such technical details. We can focus
    on the business logic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`RestTemplate`提供了一个访问REST服务的简单方法。它只需要URL模板、用于转换结果的类型以及一个带有参数的`Map`对象。URL模板字符串可以像Spring控制器中的请求映射一样包含参数，参数名称位于`{}`字符之间。模板类提供了访问REST服务的简单方法。它自动执行序列化、发送参数和反序列化、接收响应。在`GET`请求的情况下，不需要序列化。数据在请求URL中，`{xxx}`占位符被作为第三个参数提供的映射中的值替换。对于大多数格式，反序列化都是现成的。在我们的应用程序中，REST服务发送JSON数据，并在响应的`Content-Type`
    HTTP头中指示。`RestTemplate`将JSON转换为作为参数提供的类型。如果服务器决定以XML格式发送响应，并且它也会在HTTP头中指示，`RestTemplate`将自动处理这种情况。实际上，查看代码，我们无法知道响应是如何编码的。这也是一件好事，因为它使客户端变得灵活，同时我们也不需要处理这些技术细节。我们可以专注于业务逻辑。
- en: At the same time, the class also provides configuration parameters in the case
    of marshaling or some other functionality so that it automatically needs that.
    You can, for example, provide marshaling methods, though I recommend that you
    use whatever is available by default. In most cases, when a developer thinks that
    there is a need for a special version of any of these functions, the original
    design of their code is flawed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在序列化或其他一些功能需要配置参数的情况下，该类也提供了配置参数，以便它自动需要这些参数。例如，您可以提供序列化方法，尽管我建议您使用默认可用的任何方法。在大多数情况下，当开发者认为需要任何这些函数的特殊版本时，他们的代码原始设计是有缺陷的。
- en: The business logic is very simple. We first ask the inventory if there is any
    product in stock. If there is (more than zero), then we query the product information
    service and return the details. If there is none, then we return an empty record.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 商业逻辑非常简单。我们首先询问库存是否有任何产品在库存中。如果有（超过零），那么我们查询产品信息服务并返回详细信息。如果没有，则返回一个空记录。
- en: 'The other service is even simpler. It simply calls the underpinning service
    and returns the result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个服务甚至更简单。它只是调用基础服务并返回结果：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compiling and running the application
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行应用程序
- en: 'We use `gradle` to compile and run the application. Since the application does
    not have any specific configuration that would not appear in most similar applications,
    it is wise to use the Spring boot. The Spring boot makes it extremely simple to
    create and run a web application. We need a Java standard `public static void
    main` method that starts up the application via Spring:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gradle`来编译和运行应用程序。由于应用程序没有在大多数类似应用程序中出现的特定配置，因此使用Spring Boot是明智的。Spring
    Boot使得创建和运行Web应用程序变得极其简单。我们需要一个Java标准的`public static void main`方法，通过Spring启动应用程序：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The method does nothing but start the `StringApplication` class's `run` method.
    It passes the original arguments and also the class that the application is in.
    Spring uses this class to read the annotation. The `@SpringBootApplication` annotation
    signals that this class is a Spring boot application and provides arguments to
    configure the packages that contain the application. To do so, you can provide
    the name of the package that contains the classes, but you can also provide a
    class in the base package that contains all the classes that Spring has to be
    aware of. You may not be able to use the class version of the annotation parameter
    because the root package may not contain any class, only sub-packages. At the
    same time, providing the name of the root package as `String`, will not reveal
    any typo or misalignment during compile time. Some *IDE* may recognize that the
    parameter is supposed to be a package name, or it may scan the strings of the
    program for package names when you refactor or rename a package and give you support
    for that, but this is more heuristics only. It is a common practice to create
    a placeholder class that does nothing in the root package in case there is no
    class there. This class can be used to specify `scanBasePackageClasses` as an
    annotation parameter instead of `scanBasePackages` that needs `String`. In our
    example, we have an empty interface, `SpringScanBase`, as a placeholder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是启动`StringApplication`类的`run`方法。它传递原始参数以及应用程序所在的类。Spring使用这个类来读取注解。`@SpringBootApplication`注解表示这个类是一个Spring
    Boot应用程序，并提供配置包含应用程序的包的参数。为此，你可以提供包含类的包的名称，但你也可以提供一个位于基础包中的类，该基础包包含Spring需要了解的所有类。你可能无法使用注解参数的类版本，因为根包可能不包含任何类，只有子包。同时，将根包的名称作为`String`提供，在编译时不会揭示任何错误或错位。一些*IDE*可能认识到参数应该是包名，或者在你重构或重命名包时，它可能会扫描程序中的字符串以查找包名，并为你提供支持，但这只是启发式方法。通常的做法是在根包中创建一个什么也不做的占位符类，以防那里没有类。这个类可以用作将`scanBasePackageClasses`作为注解参数而不是需要`String`的`scanBasePackages`。在我们的例子中，我们有一个空的接口`SpringScanBase`作为占位符。
- en: Spring scans all the classes that are on the classpath, recognizes the components
    and field annotations that it can interpret, and uses this knowledge to create
    beans without configuration when needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring扫描类路径上的所有类，识别它可以解释的组件和字段注解，并使用这些知识在需要时创建配置为无配置的bean。
- en: Note that the abstract class, `ClassLoader`, included in the JDK does not provide
    any class scanning method. Since Java environments and frameworks can implement
    their own `ClassLoaders`, it is possible (but very unlikely) that some implementation
    does not provide the scanning functionality provided by the `URLClassLoader`.
    `URLClassLoader` is a non-abstract implementation of the class loading functionality
    and is a part of the *JDK* just as well as `ClassLoader`. We will discuss the
    intricacies of the class loading mechanism in the subsequent chapters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包含在JDK中的抽象类`ClassLoader`不提供任何类扫描方法。由于Java环境和框架可以实施自己的`ClassLoaders`，因此有可能（但非常不可能）某些实现没有提供`URLClassLoader`提供的扫描功能。`URLClassLoader`是类加载功能的非抽象实现，就像`ClassLoader`一样，也是JDK的一部分。我们将在后续章节中讨论类加载机制的复杂性。
- en: 'The `gradle` build file contains the usual things. It specifies the repositories,
    the plugins for Java, the IDEs, and also for Spring boot. It also specifies the
    name of the JAR file that it generates during build. The most important part is
    the dependency list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradle`构建文件包含通常的东西。它指定了仓库、Java插件、IDE以及Spring Boot插件。它还指定了在构建过程中生成的JAR文件的名称。最重要的部分是依赖列表：'
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We depend on Spring boot packages, some test packages, AOP support (which we
    will look at soon), and also on Spring boot devtools.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于Spring Boot包，一些测试包，AOP支持（我们很快将探讨），以及Spring Boot devtools。
- en: 'Spring boot devtools make it possible to restart a web application whenever
    it is recompiled, without restarting the built-in Tomcat server. Suppose, we start
    the application using the following command line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot devtools使得在重新编译时能够重新启动Web应用程序，而无需重新启动内置的Tomcat服务器。假设我们使用以下命令行启动应用程序：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Gradle starts up the application and whenever it sees that the classes it
    runs are modified, it reloads them, and we can test the modified application within
    a few seconds.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle启动应用程序，并且每当它看到它运行的类被修改时，它会重新加载它们，我们可以在几秒钟内测试修改后的应用程序。
- en: The `-Dspring.profiles.active=production` argument specifies that the production
    profile should be active. To be able to use this command line parameter, we will
    also need the `bootRun{}` configuration closure in the build file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Dspring.profiles.active=production`参数指定生产配置文件应该处于活动状态。为了能够使用此命令行参数，我们还需要在构建文件中包含`bootRun{}`配置闭包。'
- en: Testing the application
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: The application should have unit tests for each and every class it has except,
    perhaps, for the DTO classes that contain no functionality. The setters and getters
    are created by the IDE and are not typed in by the programmer, so it is unlikely
    that there will be any errors in those. If there is some error related to those
    classes, it is more likely that it is some integration problem that cannot be
    discovered using unit tests. Since we discussed unit tests in the previous chapters
    in detail, we will focus more on integration tests and application tests here.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该为每个类编写单元测试，除了可能不包含任何功能的DTO类。设置器和获取器是由IDE创建的，而不是由程序员输入的，因此在这些设置中不太可能出现错误。如果有与这些类相关的错误，更有可能是一些无法通过单元测试发现的集成问题。由于我们在前面的章节中详细讨论了单元测试，因此我们将更多地关注集成测试和应用测试。
- en: Integration test
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are very similar to unit tests, and many times, novice programmers
    claim they do unit testing when they actually do integration testing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试与单元测试非常相似，很多时候，新手程序员声称他们在进行单元测试，而实际上他们正在进行集成测试。
- en: Integration tests drive the code but do not test the individual classes (units)
    in isolation, mocking everything that the class may use. Rather, they test the
    functionality of most of the classes that are needed to perform a test. This way,
    the integration test does test that the classes are able to work together and
    not only satisfy their own specifications but also ensure that these specifications
    work together.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试驱动代码，但不单独测试单个类（单元），模拟类可能使用的所有内容。相反，它们测试了执行测试所需的大多数类的功能。这样，集成测试确实测试了类能够协同工作，不仅满足它们自己的规范，而且确保这些规范能够协同工作。
- en: In integration test, the external world (like external services) and access
    to database are mocked only. That is because the integration tests are supposed
    to run on integration servers, in the same environment where the unit tests are
    executed, and there these external interfaces may not be available. Many times,
    databases are mocked using in-memory SQL, and external services are mocked using
    some mock classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，外部世界（如外部服务）和数据库的访问仅进行模拟。这是因为集成测试应该在集成服务器上运行，在执行单元测试的相同环境中，在这些外部接口可能不可用。很多时候，数据库使用内存SQL进行模拟，外部服务使用一些模拟类进行模拟。
- en: 'Spring provides a nice environment to execute such integration tests. In our
    project, we have a sample integration test:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个很好的环境来执行此类集成测试。在我们的项目中，我们有一个示例集成测试：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is far from being a complete and full-fledged integration test. There are
    many situations that are not tested, but here it is good as an example. To have
    all the support for the Spring environment, we have to use the `SpringRunner`
    class. The `@RunWith` annotation is handled by the JUnit framework, all other
    annotations are for Spring. When the JUnit framework sees that there is a `@RunWith`
    annotation and a runner class specified, it starts that class instead of the standard
    runner. `SpringRunner` sets up a Spring context for the test and handles the annotations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非一个完整且功能齐全的集成测试。有许多情况没有被测试，但在这里它作为一个例子是很好的。为了支持Spring环境，我们必须使用`SpringRunner`类。`@RunWith`注解由JUnit框架处理，所有其他注解都是针对Spring的。当JUnit框架看到存在一个`@RunWith`注解和一个指定的运行器类时，它将启动该类而不是标准运行器。`SpringRunner`为测试设置Spring上下文并处理注解。
- en: '`@SpringBootTest` specifies the applications that we need to test. This helps
    Spring to read that class and the annotation on that class, identifying the packages
    to be scanned.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootTest`指定了我们需要测试的应用程序。这有助于Spring读取该类及其上的注解，识别要扫描的包。'
- en: '`@AutoConfigureMockMvc` tells Spring to configure a mock version of the Model
    View Controller framework, which can be executed without a servlet container and
    web protocol. Using that, we can test our REST services without really going to
    the network.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AutoConfigureMockMvc`告诉Spring配置一个模拟的模型视图控制器框架版本，可以在没有servlet容器和Web协议的情况下执行。使用它，我们可以测试我们的REST服务而无需真正进入网络。'
- en: '`@ActiveProfiles` tells Spring that the active profile is local and that Spring
    has to use the configuration that is denoted by the annotation, `@Profile("local")`.
    This is a version that uses the .`properties` files instead of external HTTP services;
    thus, this is appropriate for integration testing.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ActiveProfiles`告诉Spring活动配置是本地配置，并且Spring必须使用由注解`@Profile("local")`表示的配置。这是一个使用`.properties`文件而不是外部HTTP服务的版本；因此，这对于集成测试是合适的。'
- en: The test performs `GET` requests inside the mocking framework, executes the
    code in the controller, and tests the returned value using the mocking framework
    and fluent API in a very readable way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在模拟框架内部执行`GET`请求，执行控制器中的代码，并使用模拟框架和流畅API以非常可读的方式测试返回的值。
- en: Note that using the properties files and having the service implementation based
    on properties file is a bit of an overkill. I created this so that it is possible
    to start up the application interactively without any real backing service. Consider
    the following command: `gradle -Dspring.profiles.active=local bootRun` .
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用属性文件并且服务实现基于属性文件有点过度。我创建这个是为了能够交互式地启动应用程序而不需要任何真实的服务支持。考虑以下命令：`gradle -Dspring.profiles.active=local
    bootRun`。
- en: If we issue the preceding command, then the server starts up using this local
    implementation. If we only aim for integration testing, then the local implementation
    of the service classes should be under the `test` directory and should be much
    simpler, mainly only returning constant responses for any expected request and
    throwing errors if any non-expected request comes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发出前面的命令，那么服务器将使用这个本地实现启动。如果我们只是为了进行集成测试，那么服务类的本地实现应该位于`test`目录下，并且应该非常简单，主要只对任何预期的请求返回常量响应，如果收到任何非预期的请求则抛出错误。
- en: Application test
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序测试
- en: 'Consider the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下命令：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we start up the application issuing the preceding command and fire up the
    browser to the URL, `http://localhost:8080/pi/123`, we will get a fat error message
    on the browser screen. Ouch...
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发出前面的命令启动应用程序，并打开浏览器到URL `http://localhost:8080/pi/123`，我们将在浏览器屏幕上看到一个巨大的错误消息。哎呀...
- en: It says `Internal Server Error, status=500` or something similar. That is because
    our code wants to connect to the backing services, but we do not have any yet.
    To have some to test the application on this level, we should create the backing
    services or at least something that mocks them. The easiest way is to use the
    soapUI program.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示`Internal Server Error, status=500`或类似错误。这是因为我们的代码想要连接到支持服务，但我们还没有。为了在这个级别上测试应用程序，我们应该创建支持服务或者至少是它们的模拟。最简单的方法是使用soapUI程序。
- en: The soapUI is a Java program available from [https://www.soapui.org/](https://www.soapui.org/).
    There is an open source and free version of it, and there is a commercial version.
    For our purposes, the free version is enough. We can install it in the simplest
    click-forward way as it has a setup wizard. After that, we can start it up and
    use the graphical user interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: soapUI是一个可以从[https://www.soapui.org/](https://www.soapui.org/)获取的Java程序。它有一个开源免费版本和一个商业版本。对于我们的目的，免费版本就足够了。我们可以通过简单的点击下一步的方式安装它，因为它有一个设置向导。安装后，我们可以启动它并使用图形用户界面。
- en: 'We create a new test project, Catalog and inventory, and set up two REST mock
    services in it: Catalog and Inventory, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的测试项目，目录和库存，并在其中设置两个REST模拟服务：目录和库存，如下面的截图所示：
- en: '![](img/00052.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.jpeg)'
- en: We set up, for each of the mock services, requests to be matched and responses.
    The content of the response is text and can be typed into the text field on the
    user interface. It is important that we do not forget to set the media type of
    the response to `application/json` (the default is XML).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个模拟服务设置请求匹配和响应。响应的内容是文本，可以输入到用户界面的文本字段中。重要的是我们不要忘记将响应的媒体类型设置为`application/json`（默认是XML）。
- en: '![](img/00053.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00053.jpeg)'
- en: Before starting the services, we have to set the port numbers by clicking on
    the cogwheel to something that is available on the server. Since 8080 is used
    by the Tomcat server executed by Gradle, and 8082 is used by soapUI to list the
    mock services that are currently running, I set the catalog to listen on 8081
    and inventory on 8083\. You can also see these port numbers in the listing of
    the `ProductInformationServiceUrlBuilder` class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动服务之前，我们必须通过点击齿轮图标来设置端口号，使其在服务器上可用。由于8080被Gradle执行的Tomcat服务器使用，而8082被soapUI用于列出当前运行的模拟服务，我将目录设置为监听8081，库存设置为8083。您也可以在`ProductInformationServiceUrlBuilder`类的列表中看到这些端口号。
- en: The soapUI saves the project in an XML file, and it is available for you on
    GitHub in the `project` directory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: soapUI将项目保存为XML文件，并且该项目在GitHub的`project`目录中可供您使用。
- en: 'After starting the mock services, the error message disappears from the browser
    screen when we press refresh:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动模拟服务后，当我们点击刷新时，错误信息会从浏览器屏幕上消失：
- en: '![](img/00054.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: What we see is exactly what we typed into soapUI.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的就是我们在soapUI中输入的内容。
- en: 'If now I change the inventory mock service to return 0 instead of 100, as in
    the original version, what I get is the following empty record:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我现在将库存模拟服务更改为返回0而不是100，就像原始版本一样，我得到的是以下空记录：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The testing even on this level can be automated. Now, we were playing around
    using the browser and this is something nice. Somehow, I feel I am producing something
    when there is a program that is really doing something, when I can see that there
    is some response in the browser window. However, after a while, this becomes boring
    and testing manually that the application is still working is cumbersome. It is
    especially boring for those functions that were not changed. The fact is that
    they do change miraculously many times even when we do not touch the code that
    influences them. We touch the code that does influence the function except that
    we are not aware of it. Poor design, poor coding, or maybe we just forgot, but
    it happens. Regression test is inevitable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个层面上，测试也可以自动化。现在，我们使用浏览器进行了一些实验，这是件好事。不知何故，我觉得当有一个真正在做事的程序时，当我能在浏览器窗口中看到一些响应时，我好像在创造些什么。然而，过了一会儿，这变得无聊了，手动测试应用程序是否仍然工作变得繁琐。对于那些没有改变的功能来说，这尤其无聊。事实上，即使我们没有触摸影响它们的代码，它们也会奇迹般地多次改变。我们触摸了影响功能的代码，只是我们没有意识到这一点。糟糕的设计、糟糕的编码，或者也许我们只是忘记了，但事情就是这样发生了。回归测试是不可避免的。
- en: 'Although browser testing user interfaces can also be automated, this time,
    we are having a REST service that we can test and that is what soapUI is for.
    We have already installed the tool, we have already started it, and we have some
    mock services running in it. The next thing is to add a New REST service from
    URI to the project and specify the URL, `http://localhost:8080/pi/{id}`, exactly
    the same way as we did for Spring:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然浏览器测试用户界面也可以自动化，但这次我们有一个可以测试的REST服务，这正是soapUI的作用。我们已经安装了该工具，已经启动它，并且其中运行了一些模拟服务。接下来，我们需要从URI添加一个新的REST服务到项目中，并指定URL，`http://localhost:8080/pi/{id}`，这与我们为Spring所做的方式完全相同：
- en: '![](img/00055.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.jpeg)'
- en: 'When we have a REST service defined in the project, we can create a new Test
    Suite and a Test Case inside the suite. We can then add a step to the Test Case
    that will call the REST service using the parameter `123` if we modify the default
    value, which is the same as the name of the parameter, in this case, `id`. We
    can run the test step using the green triangle on the upper-left corner of the
    window, and since we have the tested application and the soapUI mock services
    running, we should get an answer in JSON. We have to select JSON on the response
    side; otherwise, soapUI tries to interpret the response as XML, and since we have
    a JSON response, it is not too fruitful. What we see is the following window:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目中定义了一个REST服务时，我们可以在套件内创建一个新的测试套件和一个测试用例。然后我们可以向测试用例中添加一个步骤，该步骤将使用参数`123`调用REST服务，如果我们修改默认值，该默认值与参数名称相同，在这种情况下，`id`。我们可以通过在窗口左上角使用绿色三角形来运行测试步骤，并且由于我们正在运行测试应用程序和soapUI模拟服务，我们应该得到一个JSON格式的答案。我们必须在响应侧选择JSON；否则，soapUI会尝试将响应解释为XML，而由于我们有JSON响应，这并不是很有成效。我们看到的是以下窗口：
- en: '![](img/00056.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: It is the same response that we saw in the browser. There are no miracles when
    we program computers. Sometimes, we do not understand what happens, and some things
    are so complex that they seem to be a miracle, but they are actually not. There
    is an explanation for everything, it may just not be known to us. In this case,
    we certainly know what is happening, but why is it any better to see the JSON
    on the screen of soapUI than it is on the browser? The reason is that soapUI can
    execute assertions and in some cases, further test steps based on the result of
    the REST invocation, and the final result is a simple YES or NO. The test is OK,
    or it FAILS.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在浏览器中看到的相同响应。编程计算机时没有奇迹。有时，我们不理解发生了什么，有些事情非常复杂，似乎是个奇迹，但实际上并不是。每件事都有解释，可能只是我们不知道。在这种情况下，我们当然知道发生了什么，但为什么在
    soapUI 的屏幕上看到 JSON 比在浏览器上更好呢？原因在于 soapUI 可以执行断言，在某些情况下，基于 REST 调用的结果进一步执行测试步骤，最终结果是简单的
    YES 或 NO。测试是 OK，或者它失败。
- en: To add an assertion, click on the Assertions text on the lower-left corner of
    the window. As you can see in the preceding screenshot, I have already added one
    that compares the `"title"` field of the returned JSON with the text `"Bar Stool"`.
    When we add the assertion, the default value it suggests is the one that was actually
    returned, which is just a very handy feature.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个断言，请点击窗口左下角的“断言”文本。正如你在前面的屏幕截图中所见，我已经添加了一个比较返回 JSON 的 `"title"` 字段与文本 `"Bar
    Stool"` 的断言。当我们添加断言时，它建议的默认值是实际返回的值，这只是一个非常方便的功能。
- en: 'After this, running the whole test suite again will run all the test cases
    (we have only one), and all the test steps, one after the other (we again have
    only one), and finally it will display a green FINISHED bar on the UI, as shown
    in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次运行整个测试套件将运行所有测试用例（我们只有一个），然后依次运行所有测试步骤（我们再次只有一个），最后它将在 UI 上显示一个绿色的“完成”条，如下面的屏幕截图所示：
- en: '![](img/00057.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: This is not all that soapUI can do. This is a well-developed test tool that
    has been in the market for many years. soapUI can test SOAP services and REST
    services, and it can handle JMS messages. You can create tests of many steps with
    these calls, loops, and assertions in calls or in separate tests, and in case
    all else fails, you can do just anything by creating programmed steps in the Groovy
    language or creating extensions in Java.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是 soapUI 能做的全部。这是一个经过良好发展的测试工具，已经在市场上存在很多年了。soapUI 可以测试 SOAP 服务和 REST 服务，并且它可以处理
    JMS 消息。你可以使用这些调用、循环和断言在调用或单独的测试中创建多步骤的测试，如果所有其他方法都失败了，你还可以通过在 Groovy 语言中创建程序步骤或在
    Java 中创建扩展来做到任何事情。
- en: Servlet filters
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet 过滤器
- en: The services work fine by now and anyone can query the details of our products.
    That may be a problem. The details of the products are not necessarily public
    information. We have to ensure that we serve the data only to partners who are
    eligible to see it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在运行良好，任何人都可以查询我们产品的详细信息。这可能会成为一个问题。产品的详细信息不一定是公开信息。我们必须确保我们只向有资格查看这些数据的合作伙伴提供数据。
- en: To ensure that, we need something in the request that proves that the request
    comes from a partner. This information is typically a password or some other secret.
    It could be placed into the `GET` request parameters or into the HTTP request
    header. It is better to put it into the header because the information is secret
    and not to be seen by anybody.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这一点，我们需要在请求中包含一些信息来证明请求来自合作伙伴。这种信息通常是密码或其他秘密。它可以被放置在 `GET` 请求参数中或 HTTP 请求头中。将其放入头中更好，因为信息是秘密的，不应该被任何人看到。
- en: The GET parameters are a part of the URL, and the browser history remembers
    that. It is also very easy to enter this information into the browser location
    window, copy paste it, and send it over a chat channel or over e-mail. This way,
    a user of the application, who is not so educated and concerned about security,
    may disclose secret information. Although it is not impossible to do the same
    with information that is sent in an HTTP header, it is not likely to happen. If
    the information is in the header and somebody sends the information in an e-mail,
    they probably know what they are doing; they cross a security border willingly
    and not by simple negligence.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: GET参数是URL的一部分，浏览器历史记录会记住这一点。也很容易将此信息输入到浏览器的位置窗口中，复制粘贴，并通过聊天频道或电子邮件发送。这样，应用程序的用户，如果他们对安全不太了解且不关心，可能会泄露秘密信息。尽管使用发送在HTTP头中的信息做同样的事情并非不可能，但这种情况不太可能发生。如果信息在头中，并且有人通过电子邮件发送信息，他们可能知道自己在做什么；他们自愿跨越安全边界，而不是简单的疏忽。
- en: To send authentication information along the HTTP request, Spring provides a
    security module that can easily be configured with annotations and configuration
    XMLs and/or classes. This time, we will do it a bit differently to introduce servlet
    filters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在HTTP请求中发送认证信息，Spring提供了一个可以通过注解和配置XMLs以及/或类轻松配置的安全模块。这次，我们将采取不同的方法来介绍servlet过滤器。
- en: We will require that the vendors insert the `X-PartnerSecret` header into the
    request. This is a non-standard header, and thus it must have the `X-` prefix.
    Following this approach is also some extra security feature. This way, we can
    prevent the user from reaching the service using a simple browser. There is, at
    least, a need for some extra plugin that can insert a custom header or some other
    program such as soapUI. This way, it will ensure that our partners will use the
    interface programmatically, or if ever they need to test the interface ad hoc,
    only users with a certain level of technology can do so. This is important to
    keep the support costs controlled.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要求供应商在请求中插入`X-PartnerSecret`头。这是一个非标准头，因此它必须具有`X-`前缀。遵循这种方法还有一些额外的安全功能。这样，我们可以防止用户通过简单的浏览器访问服务。至少，需要一些额外的插件来插入自定义头或肥皂UI等程序。这样，将确保我们的合作伙伴将程序化地使用接口，或者如果他们需要临时测试接口，只有具备一定技术水平的人才能够这样做。这对于控制支持成本非常重要。
- en: Since this secret has to be checked in the case of each and every service, we
    better not insert the checking code into each and every service controller. Even
    if we create the code properly and factor the check for the secret into a separate
    class, the invocation of the method asserting that the secret is there and is
    correct will have to be inserted in each and every controller. The controller
    does the service; checking the client authenticity is an infrastructure issue.
    They are different concerns, and thus, they have to be separated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个秘密需要在每个服务的情况下进行检查，所以我们最好不要将检查代码插入到每个服务控制器中。即使我们正确地创建了代码并将对秘密的检查分解为单独的类，也必须在每个控制器中插入断言秘密存在且正确的方法的调用。控制器执行服务；检查客户端的真实性是一个基础设施问题。它们是不同的关注点，因此必须分离。
- en: The best way that the servlet standard provides for us is a servlet filter.
    A servlet filter is a class invoked by the servlet container before the servlet
    itself if the filter is configured. The filter can be configured in the `web.xml`
    configuration file of the servlet container or by using an annotation when we
    use the Spring boot. The filter does not only get the request and response as
    parameters but also a third argument of the `FilterChain` type that it should
    use to call the servlet or the next filter in the chain.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端过滤器标准为我们提供的最佳方式是servlet过滤器。servlet过滤器是一个在配置了过滤器的情况下由servlet容器在servlet本身之前调用的类。过滤器可以在servlet容器的`web.xml`配置文件中配置，或者在我们使用Spring
    Boot时使用注解。过滤器不仅接收请求和响应作为参数，还接收一个`FilterChain`类型的第三个参数，它应该使用该参数来调用servlet或链中的下一个过滤器。
- en: There can be more than one filter defined and they get chained up. The filter
    may, at its discretion, decide to call or not to call the next in the chain.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义多个过滤器，并且它们会被链式调用。过滤器可以自行决定是否调用链中的下一个。
- en: '![](img/00058.gif)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.gif)'
- en: 'We put our servlet filter into the `auth` sub-package of our application:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的servlet过滤器放入应用程序的`auth`子包中：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The filter implements the `Filter` interface that defines three methods. In
    our case, we do not have any parameters to consider in the filter, and we do not
    allocate any resources to release; thus, both `init` and `destroy` methods are
    empty. The main work of the filter is the `doFilter` method. It has three parameters,
    two of them are the same as the parameters of a servlet and the third is `FilterChain`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器实现了定义了三个方法的`Filter`接口。在我们的情况下，我们在过滤器中没有要考虑的任何参数，也没有分配任何资源来释放；因此，`init`和`destroy`方法都是空的。过滤器的主要工作是`doFilter`方法。它有三个参数，其中两个与servlet的参数相同，第三个是`FilterChain`。
- en: The request is converted to `HttpServletRequest`, so we can get access to the
    `X-PartnerSecret` header through the `getHeader` method. If the value sent in
    this header field is good, we call the next in the chain. In our application,
    there are no more filters configured; therefore, the next in the chain is the
    servlet. If the secret is not acceptable, then we do not call the next in the
    chain. Instead, we return the *401 Not Authorized* HTTP error to the client.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请求被转换为`HttpServletRequest`，这样我们就可以通过`getHeader`方法访问`X-PartnerSecret`头。如果这个头字段发送的值是好的，我们就调用链中的下一个。在我们的应用程序中，没有配置更多的过滤器；因此，链中的下一个是servlet。如果秘密不可接受，那么我们不调用链中的下一个。相反，我们向客户端返回*401未授权*的HTTP错误。
- en: In this application, the secret is very simple. This is the constant string
    `packt`. This is not really a big secret, especially now that it is published
    in this book. A real-life application would require something more cryptic and
    less known. It is very probable that each partner would use different secrets
    and that the secret has to change from time to time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，秘密非常简单。这是一个常量字符串`packt`。这并不是一个真正的秘密，尤其是在它被发表在这本书之后。一个现实生活中的应用需要更隐秘且不太为人所知的秘密。很可能每个合作伙伴都会使用不同的秘密，而且秘密需要不时地更改。
- en: When there is an error condition in a servlet that our program handles, it is
    a good practice to use the HTTP error handling mechanism. Instead of sending back
    a message with the status code *200 OK* and explaining, for example, in a JSON
    format that the authentication was not successful, we have to send back the *401
    code*. This is defined by the standard and does not need any further explanation
    or documentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序处理的servlet中出现错误条件时，使用HTTP错误处理机制是一个好的做法。而不是发送带有状态代码*200 OK*的消息并解释，例如，以JSON格式说明认证未成功，我们必须发送回*401*代码。这是由标准定义的，不需要任何进一步的解释或文档。
- en: There is one thing left in our program, and that is audit logging.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，还剩下一点，那就是审计日志。
- en: Audit logging and AOP
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计日志和AOP
- en: We have logging in our sample code and for that we use slf4j, which we covered
    in the previous chapter. Logging is more or less the decision of the developer
    and supports technical levels of operation. There, we also touched on a few sentence
    audit loggings. This type of logging is usually explicitly required in a functional
    requirement.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们使用了slf4j进行日志记录，这在上一章中已经介绍过。日志记录基本上是开发者的决定，并支持技术操作级别。在那里，我们也提到了一些句子审计日志。这种类型的日志通常在功能需求中明确要求。
- en: Generally, AOP is separating the different aspects of code functionality into
    separate code fragments, and implementing them independent of each other. This
    is very much the single responsibility principle. This time, it is implemented
    in a way that not only the different functionalities are implemented separately
    but also how we connect them together is defined separately. What is executed
    before and after what other parts are encoded separately gets to the Spring configuration.
    We have seen something similar already. The dependencies that a class needs to
    properly operate are defined in a separate segment (XML or Java code). It is not
    a surprise that in the case of AOP, the same is done using Spring. Aspects are
    configured in the configuration file or class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，面向切面编程（AOP）是将代码功能的不同方面分离成独立的代码片段，并独立实现它们。这非常符合单一责任原则。这次，它是以一种不仅不同的功能是独立实现的，而且连接它们的方式也是独立定义的方式实现的。在执行其他部分之前和之后执行的操作被单独编码到Spring配置中。我们已经看到过类似的情况。一个类为了正确运行所需的依赖关系被定义在单独的段（XML或Java代码）中。在AOP的情况下，同样也是使用Spring来实现的。方面是在配置文件或类中配置的。
- en: A typical aspect is audit logging, and we will use this as an example. There
    are many topics that can be implemented using aspects, and some of them are even
    worth implementing that way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的方面是审计日志，我们将以此为例。有许多主题可以使用方面实现，其中一些甚至值得那样实现。
- en: We do not want to implement the audit logging code in each business method or
    class that needs it. Instead, we implement a general aspect and configure the
    wiring such that whenever a bean method that needs audit logging is invoked, Spring
    invokes the audit logging.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在需要审计日志的每个业务方法或类中实现审计日志代码。相反，我们实现一个通用方面，并配置连接，使得每当需要审计日志的bean方法被调用时，Spring都会调用审计日志。
- en: There are other important terminologies that we should understand for AOP and
    especially how AOP can be configured in Spring.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他一些重要的术语我们需要理解，特别是关于AOP如何在Spring中配置。
- en: The first and most important is the aspect. This is the functionality that we
    want to implement, in our example, the audit logging.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件也是最重要的事情是方面。这是我们想要实现的功能，在我们的例子中，是审计日志。
- en: Join point is the point in execution when an aspect is invoked. When using a
    full-scale aspect solution in Java that modifies the byte code of the generated
    class, a join point can be almost anything. It can be access to a field, read
    or write; it can be the invocation of a method or exception throwing. In the case
    of Spring, the class byte code is not modified; thus, Spring is not able to identify
    the access of a field or an exception throwing. Using Spring, a join point is
    always used when a method is invoked.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是方面被调用的执行点。当在Java中使用全功能的方面解决方案修改生成的类的字节码时，连接点可以是几乎任何东西。它可以是对字段的访问、读取或写入；它可以是方法的调用或异常抛出。在Spring的情况下，类字节码没有被修改；因此，Spring无法识别字段的访问或异常抛出。使用Spring时，连接点总是在方法被调用时使用。
- en: An advice is how the aspect is invoked at the join point. It can be before advice,
    after advice, or around advice. When the advice is before, the aspect is invoked
    before the method is called. When the advice is after, the aspect is invoked after
    the method is invoked. Around means that the aspect is invoked before the method
    call, and the aspect also has an argument to call the method and still perform
    some actions after the method is called. This way, the around advice is very similar
    to servlet filters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是方面在连接点被调用的方式。它可以是前置通知、后置通知或环绕通知。当通知是前置时，方面在方法调用之前被调用。当通知是后置时，方面在方法调用之后被调用。环绕意味着方面在方法调用之前被调用，并且方面还有一个调用方法并在方法调用之后执行一些操作的参数。这样，环绕通知非常类似于servlet过滤器。
- en: The before advice is called before the method call, and after it returns, the
    framework will invoke the method. There is no way for the aspect to prevent the
    invocation of the original method. The only exception is when the aspect, well,
    throws an exception.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用之前调用前置通知，并在它返回后，框架将调用方法。方面没有阻止原始方法调用的方法。唯一的例外是当方面抛出异常时。
- en: The after advice is also affected by exceptions. There can be an after returning
    advice that is invoked when the method is returning. The after throwing is invoked
    only if the method were throwing an exception. After finally is invoked in the
    case of an exception or return.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 后置通知也会受到异常的影响。当方法返回时，可以有一个返回后通知被调用。只有当方法抛出异常时，才会调用抛出异常通知。在异常或返回的情况下，最终通知会被调用。
- en: Pointcut is a special string expression that identifies join points. A pointcut
    expression may match zero, one, or more join points. When the aspect is associated
    with a pointcut expression, the framework will know the join points and when and
    where to invoke the aspect. In other words, pointcut is the string that tells
    when and for which method to invoke the aspect.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点是一个特殊的字符串表达式，用于标识连接点。切入点表达式可以匹配零个、一个或多个连接点。当方面与切入点表达式关联时，框架将知道连接点以及何时何地调用方面。换句话说，切入点是告诉何时以及为哪个方法调用方面的字符串。
- en: Even though Spring implementation of AOP does not use AspectJ and does not modify
    the byte code that was created for the classes, it supports the pointcut expression
    language. Although this expression language provides more features than what Spring
    implements, it is a well-established and widely used and accepted expression language
    to describe pointcuts, and it just would not make sense to invent something new.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring的AOP实现不使用AspectJ，也不修改为类创建的字节码，但它支持切点表达式语言。尽管这种表达式语言提供的功能比Spring实现的功能更多，但它是一个经过良好建立、广泛使用并被接受的用于描述切点的表达式语言，因此发明新的东西是没有意义的。
- en: '*Introduction* is adding methods or fields to a type that already exists and
    doing it during runtime. Spring allows this AOP functionality to add an interface
    to an existing type and add an implementation of the interface in the form of
    an advice class. In our example, we do not use this functionality.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*引入*是在运行时向已存在的类型添加方法或字段，并在运行时完成。Spring允许这种AOP功能向现有类型添加一个接口，并以建议类的形式添加接口的实现。在我们的例子中，我们没有使用这个功能。'
- en: '*Target object* is the object that is being advised by the aspect. This is
    the bean that contains the method around the aspect, that is, before or after
    the aspect is invoked.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标对象*是被切面建议的对象。这是包含切面方法（即切面之前或之后）的bean。'
- en: 'That was just a condensed set of definitions, almost like in a math book. If
    you did not get the point just reading it, don''t worry. I did not understand
    it either. That is why we have the following example, after which all we just
    covered will make more sense:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简化的定义集合，几乎就像在数学书中一样。如果你只是阅读它而没有理解，不要担心。我也没有理解。这就是为什么我们有了以下示例，之后我们刚刚覆盖的所有内容都会更有意义：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The class is annotated with the `@Configuration` annotation so that Spring knows
    that this class contains the configuration. The `@Aspect` annotation denotes that
    this configuration may also contain aspect definitions. The `@Around` annotation
    on the methods gives the type of advice, and the argument string for the annotation
    is the pointcut expression. If the type of advice is different, one of the annotations,
    `@Before`, `@After`, `@AfterReturning`, or `@AfterThrowing`, should be used.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该类被`@Configuration`注解标记，这样Spring就知道这个类包含配置。`@Aspect`注解表示这个配置也可能包含切面定义。方法上的`@Around`注解给出了建议的类型，注解的参数字符串是切点表达式。如果建议的类型不同，应使用以下注解之一：`@Before`、`@After`、`@AfterReturning`或`@AfterThrowing`。
- en: In our example, we use the `@Around` aspect to demonstrate the most complex
    scenario. We log the execution of the target method before and after the execution
    of the method, and we also call the original method through the `ProceedingJoinPoint`
    object. Because the two objects return different types and we want to log differently,
    we define two aspect methods.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用`@Around`切面来演示最复杂的场景。我们在方法执行前后记录目标方法的执行情况，并且通过`ProceedingJoinPoint`对象调用原始方法。由于这两个对象返回不同的类型，而我们希望以不同的方式记录，因此我们定义了两个切面方法。
- en: The argument of the advice annotation is the pointcut string. In this case,
    it is a simple one. The first one, `execution(* byId(..))`, says that the aspect
    should be invoked for any execution of any method that has the name byId and has
    any arguments. The second is very similar, except the name of the method is different.
    These are simple pointcut expressions, but in a large application that heavily
    uses AOP, they can be very complex.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 建议注解的参数是切点字符串。在这种情况下，它很简单。第一个是`execution(* byId(..))`，表示对于任何名为byId且具有任何参数的方法的执行，都应该调用切面。第二个与第一个非常相似，只是方法名不同。这些都是简单的切点表达式，但在一个大量使用AOP的大型应用程序中，它们可能非常复杂。
- en: 'The pointcut expression syntax in Spring mainly follows the syntax used by
    AspectJ. The expression uses the notion of **point cut designator** (**PCD**)
    that is usually execution. It is followed by the pattern that defines which method
    to intercept. The general format is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Spring中切点表达式语法主要遵循AspectJ使用的语法。该表达式使用**切点设计符**（**PCD**）的概念，通常是execution。它后面跟着定义要拦截哪个方法的模式。一般格式如下：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Except for the return type part, all other parts are optional. For example,
    we can write the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回类型部分外，其他所有部分都是可选的。例如，我们可以写出以下内容：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will intercept all `public` methods. The following expression intercepts
    all methods that have a name starting with set:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拦截所有`public`方法。以下表达式拦截所有以set开头的方法名：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can use the `*` character as a joker in the same way as we can use it on
    the command line in Windows or Unix shell. The argument matching definition is
    a bit more complex. `(..)` means any arguments, `()` means no arguments, and `(*)`
    means exactly one argument of any type. The last one can also be used when there
    are more arguments; for example, `(*,Integer)` means that there are two arguments,
    the second being an `Integer`, and we just do not care what the type of the first
    one is.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`*`字符作为通配符，就像在Windows或Unix shell的命令行中一样使用。参数匹配定义稍微复杂一些。`(..)`表示任何参数，`()`表示没有参数，而`(*)`表示恰好一个任意类型的参数。当有更多参数时，最后一个也可以使用；例如，`(*,Integer)`表示有两个参数，第二个是`Integer`类型，而我们并不关心第一个参数的类型。
- en: Pointcut expressions can be more complex, joining together match expressions
    with the `&&` (and) and `||` (or) logical operators, or using the `!` (negation)
    unary operator.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点表达式可以更复杂，通过`&&`（和）和`||`（或）逻辑运算符将匹配表达式连接起来，或者使用`!`（否定）一元运算符。
- en: 'Using the `@Pointcut()` annotation, the configuration can define pointcuts
    putting the annotations on methods. For example, consider the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Pointcut()`注解，配置可以定义带有方法注解的切入点。例如，考虑以下：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will define a join point for any method that is implemented in any class
    in the `packt.java.9.by.example.service` package. This merely defines the pointcut
    expression and assigns it to the name `businessService`, which is given by the
    name of the method. Later, we can refer to this expression in aspect annotations,
    for example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为`packt.java.9.by.example.service`包中任何实现的任何方法定义一个连接点。这仅仅定义了切入点表达式并将其分配给名为`businessService`的名称，该名称由方法的名称给出。稍后，我们可以在方面注解中引用此表达式，例如：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that the use of the method is purely for its name. This method is not
    invoked by Spring. It is only used to borrow its name to the expression that is
    defined on it using the `@Pointcut` annotation. There is a need for something,
    such as a method, to put this annotation on, and since methods have names, why
    not use it: Spring does it. When it scans the configuration classes and sees the
    annotation, it assigns it in its internal structures to the name of the method,
    and when that name (along with the parenthesis, to confuse the novice programmer
    mimicking a method call) is used, it looks up the expression for that name.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用该方法纯粹是为了它的名称。这个方法不是由Spring调用的。它仅用于将`@Pointcut`注解定义在其上的表达式的名称借用过来。需要某种东西，比如一个方法，来放置这个注解，并且由于方法有名称，为什么不使用它：Spring就是这样做的。当它扫描配置类并看到注解时，它将其内部结构分配给方法的名称，当使用该名称（连同括号，以混淆模仿方法调用的初学者程序员）时，它会查找该名称的表达式。
- en: AspectJ defines other designators. Spring AOP recognizes some of them, but it
    throws `IllegalArgumentException` because Spring implements only method execution
    pointcuts. AspectJ, on the other hand, can also intercept object creation for
    which the PCD is initialization, as an example. Some other PCDs, in addition to
    execution, can limit an execution PCD. For example, the PCD, `within`, can be
    used to limit the aspect to join points belonging to classes within certain packages,
    or the `@target` PCD can be used to limit the matching to methods in objects that
    have the annotation given between `(` and `)` after the keyword `@target` in the
    pointcut expression.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: AspectJ定义了其他设计符。Spring AOP识别其中的一些，但它会抛出`IllegalArgumentException`，因为Spring只实现了方法执行切入点。另一方面，AspectJ还可以拦截对象创建，其中PCD是初始化，例如。除了执行之外，一些其他PCD可以限制执行PCD。例如，PCD
    `within` 可以用来限制方面到属于某些包的类的连接点，或者`@target` PCD 可以用来限制匹配到具有在`@target`关键字之后`(`和`)`之间给出的注解的对象中的方法。
- en: There is a PCD that Spring uses that does not exist in AspectJ. This is a bean.
    You can define a pointcut expression that contains `bean(name pattern)` to limit
    the join point to method executions that are in the named bean. The pattern can
    be the entire name or it can be, as almost any PCD expression matching, `*` as
    a joker character.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Spring使用的一个PCD在AspectJ中不存在。这是一个bean。你可以定义一个包含`bean(name pattern)`的切入点表达式，以限制连接点到命名bean中的方法执行。该模式可以是整个名称，也可以像几乎任何PCD表达式匹配一样，使用`*`作为通配符。
- en: Dynamic proxy-based AOP
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于动态代理的AOP
- en: Spring AOP, when first presented to Java programmers, seems like magic. How
    does it happen that we have a variable of `class``X` and we call some method on
    that object, but instead, it executes some aspect before or after the method execution,
    or even around it, intercepting the call
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring AOP首次向Java程序员介绍时，看起来像是魔法。我们是如何拥有一个`class` `X`的变量，并在该对象上调用某个方法，但结果却是在方法执行之前或之后，甚至围绕它执行某些方面，拦截调用
- en: 'The technique that Spring does is called dynamic proxy. When we have an object,
    which implements an interface, we can create another object—the proxy object—that
    also implements that interface, but each and every method implementation invokes
    a different object called handler, implementing the JDK interface, `InvocationHandler`.
    When a method of the interface is invoked on the proxy object, it will call the
    following method on the handler object:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Spring所使用的技术称为动态代理。当我们有一个实现接口的对象时，我们可以创建另一个对象——代理对象，它也实现了该接口，但每个方法实现都会调用一个不同的对象，称为处理者，实现JDK接口`InvocationHandler`。当在代理对象上调用接口的方法时，它将在处理者对象上调用以下方法：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method is free to do anything, even calling the original method on the
    target object with the original or modified argument.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以自由地做任何事情，甚至可以调用目标对象上的原始方法，使用原始或修改后的参数。
- en: '![](img/00059.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: When we do not have an interface at hand that the class to be proxied implements,
    we cannot use JDK methods. Luckily, there are widely used libraries, such as `cglib`,
    which are also used by Spring and that can do something similar. `Cglib` can create
    a proxy object that extends the original class and implements its methods, invoking
    the handler object's invoke method in a way similar to how the JDK version does
    for the interface methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有可用的接口，该接口是即将被代理的类实现的，我们无法使用JDK方法。幸运的是，有一些广泛使用的库，例如`cglib`，Spring也使用这些库，并且可以执行类似操作。`Cglib`可以创建一个代理对象，它扩展了原始类并实现了其方法，以类似于JDK版本对接口方法的方式调用处理对象的`invoke`方法。
- en: These technologies create and load classes into the Java memory during runtime,
    and they are very deep technical tools. They are advanced topics. I do not say
    not to play with them while being a novice Java programmer. After all, what can
    happen? Java is not a loaded gun. It is, however, important that you do not lose
    your interest when you do not understand some of the details or something does
    not work first. Or second. Or third... Keep swimming.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术会在Java运行时创建和加载类到内存中，它们是非常深入的技术工具。它们是高级主题。我并不说作为一个初学者Java程序员不应该玩弄它们。毕竟，会发生什么？Java不是一把装满子弹的枪。然而，当你不理解一些细节或者某些事情一开始（或者第二次、第三次）不工作时，不要失去兴趣是很重要的。继续前进。
- en: AOP implementation in Spring works by generating proxy objects for the target
    objects, and the handlers invoke the aspects that we define in the Spring configuration.
    This is the reason you cannot put aspects on `final` classes or on `final` methods.
    Also, you cannot configure aspects on `private` or `protected` methods. The `protected`
    methods could be proxied in principle, but this is not a good practice, and thus
    Spring AOP does not support it. Similarly, you cannot put aspects on classes that
    are not Spring beans. They are created by the code directly and not through Spring
    and have no chance to return a proxy instead of the original object when the object
    is created. Simply put, if Spring is not asked to create the object, it cannot
    create a custom one. The last thing we want to do is to execute the program and
    see how the aspects perform. The implementation of our audit logging is extremely
    simple. We use the standard logging, which is not really sufficient for a real-life
    application of audit logging. The only special thing we do is that we use a logger
    identified by the name, `AUDIT_LOG` and not by the name of a class. This is a
    legitimate use of the loggers in most of the logging frameworks. In spite of the
    fact that we usually use the class to identify the logger, it is absolutely possible
    to use a string to identify a logger. In the case of our logging, this string
    will also be printed on the console in the log lines, and it will visually stand
    out.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Spring中的AOP实现是通过为目标对象生成代理对象来工作的，处理器调用我们在Spring配置中定义的方面。这就是为什么你不能在`final`类或`final`方法上放置方面。同样，你也不能在`private`或`protected`方法上配置方面。原则上，`protected`方法可以被代理，但这不是好的做法，因此Spring
    AOP不支持它。同样，你也不能在不是Spring bean的类上放置方面。它们是由代码直接创建的，而不是通过Spring，并且当对象被创建时，没有机会返回一个代理而不是原始对象。简单来说，如果我们不要求Spring创建对象，它就不能创建一个自定义的。我们最不想做的事情就是执行程序并看到方面是如何表现的。我们审计日志的实现非常简单。我们使用标准的日志记录，这实际上并不足以用于实际的审计日志应用。我们唯一特别做的事情是使用名为`AUDIT_LOG`的记录器，而不是类的名称。这是大多数日志框架中记录器的合法使用。尽管我们通常使用类来识别记录器，但绝对可以使用字符串来识别记录器。在我们的日志记录中，这个字符串也将打印在日志行中的控制台上，并且它将视觉上突出显示。
- en: 'Consider the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下命令：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we again start the application with the preceding command, start soapUI
    for the project, start the mock services, and execute the test, we will see on
    the console the following log lines that the aspects print:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次使用前面的命令启动应用程序，启动项目的soapUI，启动模拟服务，并执行测试，我们将在控制台上看到以下方面打印的日志行：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we built a simple business application that supports business-to-business
    transactions. We implemented a REST service in a microservices (almost) architecture
    using the features that are provided by the de facto standard enterprise framework:
    Spring. Looking back at the chapter, it is amazing how few lines of code we wrote
    to achieve all the functionality, and that is good. The less code we need to develop
    what we want, the better. This proves the power of the framework.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个简单的业务应用程序，支持企业间交易。我们使用事实上的企业框架标准特性：Spring，在微服务（几乎）架构中实现了REST服务。回顾本章，令人惊讶的是我们只写了很少的代码就实现了所有功能，这是很好的。我们需要编写的代码越少，我们想要实现的东西就越好。这证明了框架的力量。
- en: We discussed microservices, HTTP, REST, JSON, and how to use them using the
    MVC design pattern. We learned how Spring is built up, what modules are there,
    how dependency injection works in Spring, and we even touched a bit of AOP. This
    was very important because along with AOP, we discovered how Spring works using
    dynamic proxy objects, and this is something that is very valuable when you need
    to debug Spring or some other framework that uses a similar solution (and there
    are a few frequently used).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了微服务、HTTP、REST、JSON以及如何使用MVC设计模式来使用它们。我们学习了Spring是如何构建的，有哪些模块，Spring中依赖注入的工作原理，甚至我们还稍微接触了一点AOP。这非常重要，因为随着AOP，我们发现了Spring是如何使用动态代理对象来工作的，这在需要调试Spring或使用类似解决方案的其他框架时非常有价值（而且有一些是经常使用的）。
- en: We started to test our code using a simple browser, but after that we realized
    that REST services are better tested using some professional testing tool, and
    for that we used soapUI and built up a simple REST test suite with REST test steps
    and mock services.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始使用简单的浏览器测试我们的代码，但之后我们意识到使用一些专业的测试工具来测试REST服务会更好，为此我们使用了soapUI，并构建了一个简单的REST测试套件，包括REST测试步骤和模拟服务。
- en: Having learnt all that, nothing will stop us from extending this application
    using very modern and advanced Java technologies, such as reflection (which we
    have already touched on a bit when we discussed the JDK dynamic proxy), Java streams,
    lambda expressions, and scripting on the server side.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了这一切，没有什么能阻止我们利用非常现代和先进的Java技术来扩展这个应用，例如反射（在我们讨论JDK动态代理时已经稍微涉及过），Java流，lambda表达式，以及服务器端的脚本编写。
