- en: Chapter 2. A Look at Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 概览响应式扩展
- en: Reactive Extensions—or Rx—is a Reactive Programming library from Microsoft to
    build complex asynchronous programs. It models time-varying values and events
    as observable sequences and is implemented by extending the Observer design pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式扩展或Rx是微软的一个响应式编程库，用于构建复杂的异步程序。它将时间变化的值和事件建模为可观察序列，并通过扩展观察者设计模式来实现。
- en: Its first target platform was .NET, but Netflix has ported Rx to the JVM under
    the name RxJava. Microsoft also develops and maintains a port of Rx to JavaScript
    called RxJS, which is the tool we used to build the sine-wave application. The
    two ports work a treat for us since Clojure runs on the JVM and ClojureScript
    in JavaScript environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个目标平台是.NET，但Netflix已经将Rx移植到JVM，命名为RxJava。微软还开发和维护了一个名为RxJS的JavaScript版本的Rx，这是我们用来构建正弦波应用的工具。这两个移植对我们来说效果很好，因为Clojure运行在JVM上，ClojureScript在JavaScript环境中运行。
- en: As we saw in [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive
    Programming?"), *What is Reactive Programming?*, Rx is inspired by Functional
    Reactive Programming but uses different terminology. In FRP, the two main abstractions
    are behaviors and events. Although the implementation details are different, observable
    sequences represent events. Rx also provides a behavior-like abstraction through
    another data type called `BehaviorSubject`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](part0015_split_000.html#page "第1章. 什么是响应式编程？")中看到的，*什么是响应式编程？*，Rx受到了函数式响应式编程的启发，但使用了不同的术语。在FRP中，两个主要的抽象是行为和事件。尽管实现细节不同，可观察序列代表事件。Rx还通过另一种称为`BehaviorSubject`的数据类型提供了类似行为的抽象。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: 'Explore Rx''s main abstraction: observables'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Rx的主要抽象：可观察的
- en: Learn about the duality between iterators and observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解迭代器和可观察之间的双重性
- en: Create and manipulate observable sequences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作可观察序列
- en: The Observer pattern revisited
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式再探
- en: 'In [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive Programming?"),
    *What is Reactive Programming?*, we saw a brief overview of the Observer design
    pattern and a simple implementation of it in Clojure using watches. Here''s how
    we did it:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0015_split_000.html#page "第1章. 什么是响应式编程？")中，*什么是响应式编程？*，我们简要概述了观察者设计模式及其在Clojure中使用watch的简单实现。这是我们的做法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, our observable subject is the var, `numbers`. The
    observer is the `adder` watch. When the observable changes, it *pushes* its changes
    to the observer *synchronously*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们的可观察主题是变量`numbers`，观察者是`adder` watch。当可观察的内容发生变化时，它会*同步地*将变化推送到观察者。
- en: 'Now, contrast this to working with sequences:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对比一下处理序列的工作方式：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This time around, the vector is the subject being observed and the functions
    processing it can be thought of as the observers. However, this works in a pull-based
    model. The vector doesn't push any elements down the sequence. Instead, `map`
    and friends ask the sequence for more elements. This is a synchronous operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，向量是被观察的主题，处理它的函数可以被视为观察者。然而，这在一个基于拉取的模型中工作。向量不会将任何元素推送到序列中。相反，`map`和其他函数会向序列请求更多元素。这是一个同步操作。
- en: Rx makes sequences—and more—behave like observables so that you can still map,
    filter, and compose them just as you would compose functions over normal sequences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rx使序列以及更多内容表现得像可观察的，这样你仍然可以像对普通序列进行函数组合一样对它们进行映射、过滤和组合。
- en: Observer – an Iterator's dual
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者 – Iterator的对立面
- en: 'Clojure''s sequence operators such as map, filter, reduce, and so on support
    Java Iterables. As the name implies, an Iterable is an object that can be iterated
    over. At a low level, this is supported by retrieving an Iterator reference from
    such object. Java''s Iterator interface looks like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的序列操作符，如map、filter、reduce等，支持Java的Iterable。正如其名所示，Iterable是一个可以迭代的对象。在底层，这是通过从这样的对象中检索Iterator引用来支持的。Java的Iterator接口看起来如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When passed in an object that implements this interface, Clojure's sequence
    operators pull data from it by using the `next` method, while using the `hasNext`
    method to know when to stop.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入实现此接口的对象时，Clojure的序列操作符通过使用`next`方法从它那里拉取数据，同时使用`hasNext`方法知道何时停止。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `remove` method is required to remove its last element from the underlying
    collection. This in-place mutation is clearly unsafe in a multithreaded environment.
    Whenever Clojure implements this interface for the purposes of interoperability,
    the `remove` method simply throws `UnsupportedOperationException`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`remove`方法从底层集合中移除其最后一个元素。这种就地修改在多线程环境中显然是不安全的。每当Clojure为了互操作性实现此接口时，`remove`方法简单地抛出`UnsupportedOperationException`。
- en: 'An observable, on the other hand, has observers subscribed to it. Observers
    have the following interface:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可观察对象有观察者订阅它。观察者有以下接口：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, an Observer implementing this interface will have its `onNext`
    method called with the next value available from whatever observable it's subscribed
    to. Hence, it being a *push*-based notification model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，实现此接口的观察者将使用从其订阅的任何可观察对象中可用的下一个值调用其`onNext`方法。因此，它是一个基于*推送*的通知模型。
- en: 'This duality [4] becomes clearer if we look at both the interfaces side by
    side:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们并排查看接口，这种二重性[4]会变得更加清晰：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Observables provide the ability to have producers push items *asynchronously*
    to consumers. A few examples will help solidify our understanding.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象提供了让生产者异步地将项目推送到消费者的能力。一些例子将有助于巩固我们的理解。
- en: Creating Observables
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可观察对象
- en: 'This chapter is all about Reactive Extensions, so let''s go ahead and create
    a project called `rx-playground` that we will be using in our exploratory tour.
    We will use RxClojure (see [https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)),
    a library that provides Clojure bindings for `RxJava()` (see [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于响应式扩展，所以让我们创建一个名为`rx-playground`的项目，我们将在我们的探索之旅中使用它。我们将使用RxClojure（见[https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)），这是一个提供`RxJava()`（见[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)）Clojure绑定的库：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open the project file and add a dependency on RxJava''s Clojure bindings:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目文件，并添加对RxJava的Clojure绑定的依赖项：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, fire up a REPL in the project''s root directory so that we can start creating
    some observables:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录中启动一个REPL，这样我们就可以开始创建一些可观察对象了：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first thing we need to do is import RxClojure, so let''s get this out of
    the way by typing the following in the REPL:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导入RxClojure，让我们在REPL中输入以下内容来解决这个问题：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The simplest way to create a new observable is by calling the `justreturn`
    function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新可观察对象的最简单方法是调用`justreturn`函数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can subscribe to it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以订阅它：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will print the string `"Got value: 10"` to the REPL.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '这将在REPL中打印字符串`"Got value: 10"`。'
- en: 'The `subscribe` function of an observable allows us to register handlers for
    three main things that happen throughout its life cycle: new values, errors, or
    a notification that the observable is done emitting values. This corresponds to
    the `onNext`, `onError`, and `onCompleted` methods of the Observer interface,
    respectively.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象的`subscribe`函数允许我们为其生命周期中的三个主要事件注册处理程序：新值、错误或通知可观察对象已完成值发射。这分别对应于观察者接口的`onNext`、`onError`和`onCompleted`方法。
- en: In the preceding example, we are simply subscribing to `onNext`, which is why
    we get notified about the observable's only value, 10.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是订阅了`onNext`，这就是为什么我们只收到了可观察对象的唯一值，即10。
- en: 'A single-value Observable isn''t terribly interesting though. Let''s create
    and interact with one that emits multiple values:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单值可观察对象并不特别有趣。让我们创建并交互一个发射多个值的可观察对象：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, this doesn't yet present any advantages to working with raw values
    or sequences in Clojure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这还没有在Clojure中使用原始值或序列方面展现出任何优势。
- en: 'But what if we need an observable that emits an undefined number of integers
    at a given interval? This becomes challenging to represent as a sequence in Clojure,
    but Rx makes it trivial:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们需要一个在给定间隔内发射未定义数量整数的可观察对象怎么办？在Clojure中将这表示为一个序列变得具有挑战性，但Rx使其变得简单：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: RxClojure doesn't yet provide bindings to all of RxJava's API. The `interval`
    method is one such example. We're required to use interoperability and call the
    method directly on the `Observable` class from RxJava.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RxClojure尚未提供对RxJava API的所有绑定。`interval`方法就是这样一个例子。我们需要使用互操作性并直接在RxJava的`Observable`类上调用该方法。
- en: 'Observable/interval takes as arguments a number and a time unit. In this case,
    we are telling it to emit an integer—starting from zero—every 100 milliseconds.
    If we type this in an REPL-connected editor, however, two things will happen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象的 `interval` 方法接受一个数字和一个时间单位作为参数。在这种情况下，我们告诉它每 100 毫秒发出一个整数——从零开始。如果我们在一个连接到
    REPL 的编辑器中输入这个命令，然而，会发生两件事：
- en: We will not see any output (depending on your REPL; this is true for Emacs)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看不到任何输出（取决于你的 REPL；这在 Emacs 中是正确的）
- en: We will have a rogue thread emitting numbers indefinitely
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将有一个无限期发出数字的流氓线程
- en: Both issues arise from the fact that `Observable/interval` is the first factory
    method we have used that doesn't emit values synchronously. Instead, it returns
    an Observable that defers the work to a separate thread.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都源于 `Observable/interval` 是我们使用的第一个不同步发出值的工厂方法。相反，它返回一个可观察对象，将工作推迟到另一个线程。
- en: The first issue is simple enough to fix. Functions such as `prn` will print
    to whatever the dynamic var `*out*` is bound to. When working in certain REPL
    environments such as Emacs', this is bound to the REPL stream, which is why we
    can generally see everything we print.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题很容易解决。像 `prn` 这样的函数会打印到动态变量 `*out*` 绑定的任何内容。当在某些 REPL 环境中（如 Emacs）工作时，这绑定到
    REPL 流，这就是为什么我们通常能看到我们打印的所有内容。
- en: 'However, since Rx is deferring the work to a separate thread, `*out*` isn''t
    bound to the REPL stream anymore so we don''t see the output. In order to fix
    this, we need to capture the current value of `*out*` and bind it in our subscription.
    This will be incredibly useful as we experiment with Rx in the REPL. As such,
    let''s create a helper function for it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Rx 将工作推迟到另一个线程，`*out*` 已经不再绑定到 REPL 流，所以我们看不到输出。为了解决这个问题，我们需要捕获 `*out*`
    的当前值并在我们的订阅中绑定它。这将在我们实验 Rx 的 REPL 中非常有用。因此，让我们为它创建一个辅助函数：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we do is create a var `repl-out` that contains the current REPL
    stream. Next, we create a function `prn-to-repl` that works just like `prn`, except
    it uses the `binding` macro to create a new binding for `*out*` that is valid
    within that scope.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个变量 `repl-out`，它包含当前的 REPL 流。接下来，我们创建一个函数 `prn-to-repl`，它的工作方式与 `prn`
    类似，但它使用 `binding` 宏创建一个新的绑定，该绑定对 `*out*` 在该范围内有效。
- en: This still leaves us with the rogue thread problem. Now is the appropriate time
    to mention that the `subscribe` method from an Observable returns a subscription
    object. By holding onto a reference to it, we can call its `unsubscribe` method
    to indicate that we are no longer interested in the values produced by that observable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然留下了流氓线程的问题。现在正是提到从可观察对象的 `subscribe` 方法返回的订阅对象的时候。通过保留对该对象的引用，我们可以调用它的 `unsubscribe`
    方法来表示我们不再对那个可观察对象产生的值感兴趣。
- en: 'Putting it all together, our interval example can be rewritten like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们的间隔示例可以重写如下：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create a new interval observable and immediately subscribe to it, just as
    we did before. This time, however, we assign the resulting subscription to a local
    var. Note that it now uses our helper function `prn-to-repl`, so we will start
    seeing values being printed to the REPL straight away.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的间隔可观察对象，并立即订阅它，就像我们之前做的那样。然而，这次，我们将结果订阅分配给一个局部变量。注意，它现在使用我们的辅助函数 `prn-to-repl`，所以我们将立即看到值被打印到
    REPL。
- en: Next, we sleep the current—the REPL—thread for a second. This is enough time
    for the Observable to produce numbers from 0 to 9\. That's roughly when the REPL
    thread wakes up and unsubscribes from that observable, causing it to stop emitting
    values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们让当前的——REPL——线程休眠一秒钟。这足以让可观察对象从 0 到 9 生成数字。大约在这个时候，REPL 线程会醒来并取消订阅该可观察对象，导致它停止发出值。
- en: Custom Observables
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义可观察对象
- en: Rx provides many more factory methods to create Observables (see [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)),
    but it is beyond the scope of this book to cover them all.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 提供了许多其他工厂方法来创建可观察对象（见 [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)），但本书的范围不包括它们的所有内容。
- en: Nevertheless, sometimes, none of the built-in factories is what you want. For
    such cases, Rx provides the `create` method. We can use it to create a custom
    observable from scratch.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有时，内置的工厂方法都不是你想要的。对于这种情况，Rx 提供了 `create` 方法。我们可以用它从头开始创建一个自定义的可观察对象。
- en: 'As an example, we''ll create our own version of the just observable we used
    earlier in this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将创建我们在这个章节中早期使用的 just 可观察对象的自定义版本：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While creating custom observables is fairly straightforward, we should make
    sure we exhaust the built-in factory functions first, only then resorting to creating
    our own.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建自定义可观察对象相对直接，但我们应确保首先使用内置的工厂函数，只有在必要时才创建自己的。
- en: Manipulating Observables
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作可观察对象
- en: Now that we know how to create observables, we should look at what kinds of
    interesting things we can do with them. In this section, we will see what it means
    to treat Observables as sequences.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建可观察对象，我们应该看看我们可以用它们做什么有趣的事情。在本节中，我们将了解将可观察对象视为序列的含义。
- en: 'We''ll start with something simple. Let''s print the sum of the first five
    positive even integers from an observable of all integers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的事情开始。让我们从一个包含所有整数的可观察对象中打印出前五个正偶数的和：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is starting to look awfully familiar to us. We create an interval that
    will emit all positive integers starting at zero every 1 microsecond. Then, we
    filter all even numbers in this observable. Obviously, this is too big a list
    to handle, so we simply take the first five elements from it. Finally, we reduce
    the value using `+`. The result is 20.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始看起来对我们来说非常熟悉。我们创建了一个间隔，它将以每1微秒从零开始发射所有正整数。然后，我们过滤出这个可观察对象中的所有偶数。显然，这是一个太大的列表来处理，所以我们只需从其中取出前五个元素。最后，我们使用`+`来减少值。结果是20。
- en: 'To drive home the point that programming with observables really is just like
    operating on sequences, we will look at one more example where we will combine
    two different Observable sequences. One contains the names of musicians I''m a
    fan of and the other the names of their respective bands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调使用可观察对象编程实际上就像操作序列一样，我们将再举一个例子，我们将结合两个不同的可观察序列。一个包含我喜欢的音乐家的名字，另一个是他们各自乐队的名字：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We would like to print to the REPL a string of the format `Musician name –
    from: band name`. An added requirement is that the band names should be printed
    in uppercase for impact.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望向REPL打印一个格式为`Musician name – from: band name`的字符串。附加的要求是，乐队名称应该以大写形式打印，以产生冲击力。'
- en: 'We''ll start by creating another observable that contains the uppercased band
    names:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建另一个包含大写乐队名称的可观察对象：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While not strictly necessary, this makes a reusable piece of code that can be
    handy in several places of the program, thus avoiding duplication. Subscribers
    interested in the original band names can keep subscribing to the `bands` observable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是严格必要的，但这使代码变得可重用，可以在程序中的几个地方使用，从而避免重复。对原始乐队名称感兴趣的订阅者可以继续订阅`bands`可观察对象。
- en: 'With the two observables in hand, we can proceed to combine them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这两个可观察对象后，我们可以继续将它们组合起来：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once more, this example should feel familiar. The solution we were after was
    a way to zip the two observables together. RxClojure provides `zip` behavior through
    map, much like Clojure''s core `map` function does. We call it with three arguments:
    the two observables to `zip` and a function that will be called with both elements,
    one from each observable, and should return an appropriate representation. In
    this case, we simply turn them into a vector.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个例子应该感觉熟悉。我们追求的解决方案是将两个可观察对象一起zip的方法。RxClojure通过map提供`zip`行为，就像Clojure的核心`map`函数一样。我们用三个参数调用它：要zip的两个可观察对象以及一个函数，该函数将使用每个可观察对象中的一个元素调用，并返回适当的表示。在这种情况下，我们只是将它们转换成一个向量。
- en: 'Next, in our subscriber, we simply destructure the vector in order to access
    the musician and band names. We can finally print the final result to the REPL:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的订阅者中，我们简单地解构向量以访问音乐家和乐队名称。我们最终可以将最终结果打印到REPL：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Flatmap and friends
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平铺映射及其相关
- en: In the previous section, we learned how to transform and combine observables
    with operations such as map, reduce, and `zip`. However, the two observables above—musicians
    and bands—were perfectly capable of producing values on their own. They did not
    need any extra input.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用诸如map、reduce和`zip`之类的操作来转换和组合可观察对象。然而，上述两个可观察对象——音乐家和乐队——完全能够独立产生值。它们不需要任何额外的输入。
- en: 'In this section, we examine a different scenario: we''ll learn how we can combine
    observables, where the output of one is the input of another. We encountered `flatmap`
    before in [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive
    Programming?"), *What is Reactive Programming?* If you have been wondering what
    its role is, this section addresses exactly that.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考察一个不同的场景：我们将学习如何组合可观察量，其中一个可观察量的输出是另一个可观察量的输入。我们之前在[第1章](part0015_split_000.html#page
    "第1章。什么是响应式编程？")中遇到了`flatmap`，*什么是响应式编程？*如果你一直在想它的作用是什么，本节将正好解答这个问题。
- en: 'Here''s what we are going to do: given an observable representing a list of
    all positive integers, we''ll calculate the factorial for all even numbers in
    that list. Since the list is too big, we''ll take five items from it. The end
    result should be the factorials of 0, 2, 4, 6, and 8, respectively.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的：给定一个表示所有正整数列表的可观察量，我们将计算该列表中所有偶数的阶乘。由于列表太大，我们将从中取五个元素。最终结果应该是0、2、4、6和8的阶乘，分别对应。
- en: 'The first thing we need is a function to calculate the factorial of a number
    *n*, as well as our observable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个函数来计算数字*n*的阶乘，以及我们的可观察量：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using some type of visual aid will be helpful in this section, so we''ll start
    with a marble diagram representing the previous observable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，使用某种视觉辅助工具将会有所帮助，所以我们将从一个代表之前可观察量的弹珠图开始：
- en: '![Flatmap and friends](img/00005.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Flatmap 和朋友](img/00005.jpeg)'
- en: The middle arrow represents time and it flows from left to right. This diagram
    represents an infinite Observable sequence, as indicated by the use of ellipsis
    at the end of it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的箭头代表时间，它从左到右流动。这个图表代表一个无限的Observable序列，正如其末尾使用省略号所指示的那样。
- en: 'Since we''re combining all the observables now, we''ll create one that, given
    a number, emits its factorial using the helper function defined earlier. We''ll
    use Rx''s `create` method for this purpose:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在正在组合所有可观察量，我们将创建一个可观察量，给定一个数字，它将使用之前定义的辅助函数发出其阶乘。我们将使用Rx的`create`方法来完成这个目的：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is very similar to the `just-obs` observable we created earlier in this
    chapter, except that it calculates the factorial of its argument and emits the
    result/factorial instead, ending the sequence immediately thereafter. The following
    diagram illustrates how it works:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在本章早期创建的`just-obs`可观察量非常相似，不同之处在于它计算其参数的阶乘，并发出结果/阶乘，然后立即结束序列。以下图表说明了它是如何工作的：
- en: '![Flatmap and friends](img/00006.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Flatmap 和朋友](img/00006.jpeg)'
- en: We feed the number 5 to the observable, which in turn emits its factorial, 120\.
    The vertical bar at the end of the time line indicates the sequence terminates
    then.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数字5喂给可观察量，它反过来发出其阶乘，即120。时间线末尾的垂直线表示序列随后终止。
- en: 'Running the code confirms that our function is correct:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码确认我们的函数是正确的：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So far so good. Now, we need to combine both observables in order to achieve
    our goal. This is where `flatmap` of Rx comes in. We''ll first see it in action
    and then get into the explanation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在，我们需要将两个可观察量结合起来以实现我们的目标。这就是Rx中的`flatmap`发挥作用的地方。我们首先将看到它的实际应用，然后进行解释：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the preceding code, it will print the factorials for 0, 2, 4, 6,
    and 8, just like we wanted:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，它将打印出0、2、4、6和8的阶乘，正如我们所希望的那样：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Flatmap and friends](img/00007.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Flatmap 和朋友](img/00007.jpeg)'
- en: Much like `all-positive-integers`, this, too, is an infinite observable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`所有正整数`类似，这同样是一个无限的可观察量。
- en: However, the next line of our code looks a little odd. We call `flatmap` and
    give it the `fact-obs` function. A function we know itself returns another observable.
    `flatmap` will call `fact-obs` with each value it emits. `fact-obs` will, in turn,
    return a single-value observable for each number. However, our subscriber doesn't
    know how to deal with observables! It's simply interested in the factorials!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们代码的下一行看起来有点奇怪。我们调用`flatmap`并给它`fact-obs`函数。我们已知该函数本身返回另一个可观察量。`flatmap`将使用它发出的每个值调用`fact-obs`。`fact-obs`将反过来为每个数字返回一个单值可观察量。然而，我们的订阅者不知道如何处理可观察量！它只是对阶乘感兴趣！
- en: 'This is why, after calling `fact-obs` to obtain an observable, `flatmap` flattens
    all of them into a single observable we can subscribe to. This is quite a mouthful,
    so let''s visualize what this means:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在调用`fact-obs`以获取一个可观察量之后，`flatmap`将它们全部扁平化为一个我们可以订阅的单个可观察量。这听起来有点复杂，所以让我们可视化一下这意味着什么：
- en: '![Flatmap and friends](img/00008.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Flatmap 和朋友](img/00008.jpeg)'
- en: As you can see in the preceding diagram, throughout the execution of `flatmap`,
    we end up with a list of observables. However, we don't care about each observable
    but rather about the values they emit. `Flatmap`, then, is the perfect tool as
    it combines—*flattens*—all of them into the observable sequence shown at the bottom
    of the figure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图中可以看到的，在整个`flatmap`执行过程中，我们最终得到一个可观察对象的列表。然而，我们并不关心每个可观察对象，而是关心它们发出的值。因此，`Flatmap`是完美的工具，因为它将它们——*扁平化*——组合成图底部所示的可观察对象序列。
- en: You can think of `flatmap` as *mapcat* for observable sequences.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`flatmap`视为可观察序列的*mapcat*。
- en: The rest of the code is straightforward. We simply take the first five elements
    from this observable and subscribe to it, as we have been doing so far.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是直接的。我们只需从这个可观察对象中取出前五个元素并订阅它，就像我们迄今为止所做的那样。
- en: One more flatmap for the road
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道路上的另一个flatMap
- en: You might be wondering what would happen if the observable sequence we're *flatmapping*
    emitted more than one value. What then?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如果我们正在*flatMap*的可观察序列发出多个值会发生什么。那么呢？
- en: We'll see one last example before we begin the next section in order to illustrate
    the behavior of `flatMap` in such cases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始下一节之前，我们将看到一个最后的例子，以说明在这种情况下`flatMap`的行为。
- en: 'Here''s an observable that emits its argument twice:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个发出其参数两次的可观察对象：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using it is straightforward:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它是直接的：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As previously, we'll now combine this observable with the one we created earlier,
    `all-positive-integers`. Before reading on, think about what you expect the output
    to be for, say, the first three positive integers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在将这个可观察对象与我们之前创建的`all-positive-integers`可观察对象结合起来。在继续阅读之前，想想对于前三个正整数，你期望的输出是什么。
- en: 'The code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And the output is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result might be unexpected for some readers. Let''s have a look at the
    marble diagram for this example and make sure we understand how it works:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些读者来说，结果可能是不预期的。让我们看看这个例子的水滴图，确保我们理解它是如何工作的：
- en: '![One more flatmap for the road](img/00009.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![道路上的另一个flatMap](img/00009.jpeg)'
- en: Each time `repeat-obs` gets called, it emits two values and terminates. `flatmap`
    then combines them all in a single observable, making the previous output clearer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`repeat-obs`时，它都会发出两个值并终止。然后`flatmap`将它们全部组合成一个单一的可观察对象，使之前的输出更清晰。
- en: One last thing worth mentioning about `flatmap`—and the title of this section—is
    that its "friends" refer to the several names by which `flatmap` is known.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`flatmap`——以及本节标题——最后值得一提的一点是，它的“朋友”指的是`flatmap`的几个名称。
- en: For instance, Rx.NET calls it `selectMany`. RxJava and Scala call it `flatMap`—though
    RxJava has an alias for it called `mapMany`. The Haskell community calls it *bind*.
    Though they have different names, these functions semantics are the same and are
    part of a higher-order abstraction called a Monad. We don't need to know anything
    about Monads to proceed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Rx.NET称其为`selectMany`。RxJava和Scala称其为`flatMap`——尽管RxJava有一个名为`mapMany`的别名。Haskell社区称其为*bind*。尽管它们有不同的名称，但这些函数的语义是相同的，并且是称为Monad的高阶抽象的一部分。我们不需要了解任何关于Monad的知识来继续。
- en: The important thing to keep in mind is that when you're sitting at the bar talking
    to your friends about **Compositional Event Systems**, all these names mean the
    same thing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要一点是，当你坐在酒吧和朋友讨论**组合事件系统**时，所有这些名称意味着相同的事情。
- en: Error handling
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: A very important aspect of building reliable applications is knowing what to
    do when things go wrong. It is naive to assume that the network is reliable, that
    hardware won't fail, or that we, as developers, won't make mistakes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可靠应用程序的一个非常重要的方面是知道当事情出错时应该做什么。认为网络是可靠的、硬件不会失败，或者我们作为开发者不会犯错误是幼稚的。
- en: RxJava embraces this fact and provides a rich set of combinators to deal with
    failure, a few of which we examine here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava接受这个事实，并提供了一套丰富的组合器来处理失败，其中一些我们将在此处进行考察。
- en: OnError
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnError
- en: 'Let''s get started by creating a badly behaved observable that always throws
    an exception:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个表现不佳的可观察对象开始，该对象总是抛出异常：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s watch what happens if we subscribe to it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们订阅它会发生什么：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The exception thrown by `exceptional-obs` isn't caught anywhere so it simply
    bubbles up to the REPL. If this was a web application our users would be presented
    with a web server error such as the **HTTP code 500 – Internal Server Error**.
    Those users would probably not use our system again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptional-obs`抛出的异常没有被捕获，所以它简单地冒泡到REPL。如果这是一个Web应用程序，我们的用户将看到一个Web服务器错误，例如**HTTP代码500
    – 内部服务器错误**。这些用户可能不会再使用我们的系统。'
- en: Ideally, we would like to get a chance to handle this exception gracefully,
    possibly rendering a friendly error message that will let ours users know we care
    about them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有机会优雅地处理这个异常，可能是一个友好的错误消息，让我们的用户知道我们在乎他们。
- en: 'As we have seen earlier in the chapter, the `subscribe` function can take up
    to 3 functions as arguments:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所见，`subscribe`函数可以接受最多3个函数作为参数：
- en: The first, or the `onNext` handler, is called when the observable emits a new
    value
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，或者说是`onNext`处理器，当可观察对象发出新值时被调用
- en: The second, or `onError`, is called whenever the observable throws an exception
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，或者说是`onError`，每当可观察对象抛出异常时被调用
- en: The third and last function, or `onComplete`, is called when the observable
    has completed and will not emit any new items
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个也是最后一个函数，或者说是`onComplete`，当可观察对象完成并且不会发出任何新项目时被调用
- en: 'For our purposes we are interested in the `onError` handler, and using it is
    straightforward:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们感兴趣的是`onError`处理器，使用它是直接的：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This time, instead of throwing the exception, our error handler gets called
    with it. This gives us the opportunity to display an appropriate message to our
    users.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不是抛出异常，而是错误处理器被调用并传递给它。这给了我们向用户显示适当消息的机会。
- en: Catch
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获
- en: The use of `onError` gives us a much better experience overall but it isn't
    very flexible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`onError`的使用让我们整体上有了更好的体验，但它并不灵活。'
- en: Let's imagine a different scenario where we have an observable retrieving data
    from the network. What if, when this observer fails, we would like to present
    the user with a cached value instead of an error message?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个不同的场景，其中有一个可观察对象从网络中检索数据。如果这个观察者失败，我们希望向用户展示一个缓存值而不是错误消息？
- en: This is where the `catch` combinator comes in. It allows us to specify a function
    to be invoked when the observable throws an exception, much like `OnError` does.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`catch`组合子发挥作用的地方。它允许我们指定一个函数，当可观察对象抛出异常时调用，这与`OnError`的作用类似。
- en: 'Differently from `OnError`, however, `catch` has to return a new Observable
    that will be the new source of items from the moment the exception was thrown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与`onError`不同，`catch`必须返回一个新的可观察对象，该对象将从异常抛出的那一刻起成为新项目的新来源：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous example, we are essentially specifying that, whenever `exceptional-obs`
    throws, we should return the value `10`. We are not limited to single values,
    however. In fact, we can use any Observable we like as the new source:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们实际上指定了，每当`exceptional-obs`抛出时，我们应该返回值`10`。我们不仅限于单个值。实际上，我们可以使用任何我们喜欢的可观察对象作为新来源：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Retry
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试
- en: The last error handling combinator we'll examine is `retry`. This combinator
    is useful when we know an error or exception is only transient so we should probably
    give it another shot by resubscribing to the Observable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个是`retry`错误处理组合子。当我们知道错误或异常只是暂时性的，我们应该给它另一个尝试的机会，通过重新订阅可观察对象。
- en: 'First, we''ll create an observable that fails when it is subscribed to for
    the first time. However, the next time it is subscribed to, it succeeds and emits
    a new item:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个可观察对象，当它第一次被订阅时将失败。然而，下次被订阅时，它将成功并发出一个新项目：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s see what happens if we simply subscribe to it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们简单地订阅它会发生什么：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As expected, the exception simply bubbles up as in our first example. However
    we know—for the purposes of this example—that this is a transient failure. Let''s
    see what changes if we use `retry`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，异常就像我们的第一个例子一样简单地冒泡。然而，我们知道——为了这个例子，这是一个暂时性的失败。让我们看看如果我们使用`retry`会发生什么变化：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, our code is responsible for retrying the Observable and as expected we
    get the correct output.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码负责重试可观察对象，并且正如预期的那样，我们得到了正确的输出。
- en: It's important to note that `retry` will attempt to resubscribe indefinitely
    until it succeeds. This might not be what you want so Rx provides a variation,
    called `retryWith`, which allows us to specify a predicate function that controls
    when and if retrying should stop.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`retry`将无限期地尝试重新订阅，直到成功。这可能不是你想要的，所以Rx提供了一个变体，称为`retryWith`，它允许我们指定一个谓词函数，以控制何时以及是否应该停止重试。
- en: 'All these operators give us the tools we need to build reliable reactive applications
    and we should always keep them in mind as they are, without a doubt, a great addition
    to our toolbox. The RxJava wiki on the subject should be referred to for more
    information: [https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators](https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些算子都为我们提供了构建可靠反应式应用程序所需的工具，我们应当始终牢记它们，毫无疑问，它们是我们工具箱中的一大补充。关于这方面的更多信息，请参考RxJava的维基页面：[https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators](https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators)。
- en: Backpressure
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背压
- en: Another issue we might be faced with is the one of observables that produce
    items faster than we can consume. The problem that arises in this scenario is
    what to do with this ever-growing backlog of items.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还会遇到的问题是，可观察对象生成项目比我们消费得快。在这种情况下出现的问题是如何处理这个不断增长的项的积压。
- en: As an example, think about zipping two observables together. The `zip` operator
    (or `map` in RxClojure) will only emit a new value when all observables have emitted
    an item.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将两个可观察对象一起压缩。`zip`操作符（或在RxClojure中的`map`）只有在所有可观察对象都发出一个项目时才会发出新的值。
- en: 'So if one of these observables is a lot faster at producing items than the
    others, `map` will need to buffer these items and wait for the others, which will
    most likely cause an error, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果其中一个可观察对象在生成项目方面比其他项目快得多，`map`将需要缓冲这些项目并等待其他项目，这很可能会引起错误，如下所示：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As seen in the preceding code, we have a fast producing observable that emits
    items 500 times faster than the slower Observable. Clearly, we can't keep up with
    it and surely enough, Rx throws `MissingBackpressureException`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们有一个快速生成的可观察对象，其发出项目比较慢的可观察对象快500倍。显然，我们无法跟上它，Rx确实会抛出`MissingBackpressureException`。
- en: What this exception is telling us is that the fast producing observable doesn't
    support any type of backpressure—what Rx calls *Reactive pull backpressure*—that
    is, consumers can't tell it to go slower. Thankfully Rx provides us with combinators
    that are helpful in these scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常告诉我们的是，快速生成的可观察对象不支持任何类型的背压——Rx称之为*反应式拉背压*——也就是说，消费者不能让它放慢速度。幸运的是，Rx为我们提供了在这些场景中有用的组合器。
- en: Sample
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本
- en: 'One such combinator is `sample`, which allows us to sample an observable at
    a given interval, thus throttling the source observable''s output. Let''s apply
    it to our previous example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个组合器是`sample`，它允许我们在给定的时间间隔内采样一个可观察对象，从而限制源可观察对象的输出。让我们将其应用到之前的例子中：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The only change is that we call `sample` on our fast producing Observable before
    calling `map`. We will sample it every 200 milliseconds.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是我们先在快速生成的可观察对象上调用`sample`，然后再调用`map`。我们将每200毫秒采样一次。
- en: By ignoring all other items emitted in this time slice, we have mitigated our
    initial problem, even though the original Observable doesn't support any form
    of backpressure.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过忽略在这个时间片中发出的所有其他项目，我们已经减轻了最初的问题，即使原始的可观察对象不支持任何形式的背压。
- en: The sample combinator is only one of the combinators useful in such cases. Others
    include `throttleFirst`, `debounce`, `buffer`, and `window`. One drawback of this
    approach, however, is that a lot of the items generated end up being ignored.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 样本组合器只是在这种情况下有用的组合器之一。其他还包括`throttleFirst`、`debounce`、`buffer`和`window`。然而，这种方法的一个缺点是，很多生成的项目最终都被忽略了。
- en: Depending on the type of application we are building, this might be an acceptable
    compromise. But what if we are interested in all items?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们构建的应用程序类型，这可能是一个可接受的折衷方案。但如果我们对所有项目都感兴趣呢？
- en: Backpressure strategies
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背压策略
- en: If an Observable doesn't support backpressure but we are still interested in
    all items it emits, we can use one of the built-in backpressure combinators provided
    by Rx.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个可观察对象不支持背压，但我们仍然对其发出的所有项目感兴趣，我们可以使用Rx提供的内置背压组合器之一。
- en: 'As an example we will look at one such combinator, `onBackpressureBuffer`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将查看一个这样的组合器，`onBackpressureBuffer`：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The example is very similar to the one where we used `sample`, but the output
    is fairly different. This time we get all items emitted by both observables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与使用`sample`的例子非常相似，但输出却相当不同。这次我们得到了两个可观察对象发出的所有项目。
- en: The `onBackpressureBuffer` strategy implements a strategy that simply buffers
    all items emitted by the slower Observable, emitting them whenever the consumer
    is ready. In our case, that happens every 500 milliseconds.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBackpressureBuffer`策略实现了一种简单的策略，即缓冲所有由较慢的Observable发出的项目，并在消费者准备好时发出它们。在我们的例子中，这每500毫秒发生一次。'
- en: Other strategies include `onBackpressureDrop` and `onBackpressureBlock`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其他策略包括`onBackpressureDrop`和`onBackpressureBlock`。
- en: 'It''s worth noting that Reactive pull backpressure is still work in progress
    and the best way to keep up to date with progress is on the RxJava wiki on the
    subject: [https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，响应式拉回压力（Reactive pull backpressure）仍在开发中，要了解最新进展的最佳方式是查看RxJava主题的wiki页面：[https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a deep dive into RxJava, a port form Microsoft's Reactive
    Extensions from .NET. We learned about its main abstraction, the observable, and
    how it relates to iterables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了RxJava，它是微软从.NET的响应式扩展移植过来的。我们了解了其主要抽象，即可观察对象（observable），以及它与可迭代对象的关系。
- en: We also learned how to create, manipulate, and combine observables in several
    ways. The examples shown here were contrived to keep things simple. Nevertheless,
    all concepts presented are extremely useful in real applications and will come
    in handy for our next chapter, where we put them to use in a more substantial
    example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何以多种方式创建、操作和组合可观察对象。这里展示的例子是为了保持简单而设计的。尽管如此，所有提出的概念在现实应用中都非常有用，并将在我们下一章中派上用场，那时我们将在一个更实际的例子中使用它们。
- en: Finally, we finished by looking at error handling and backpressure, both of
    which are important characteristics of reliable applications that should always
    be kept in mind.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看错误处理和回压（backpressure），这两者都是可靠应用程序的重要特性，应该始终牢记。
