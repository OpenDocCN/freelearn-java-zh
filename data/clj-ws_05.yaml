- en: '5\. Many to One: Reducing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 多对一：减少
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn new techniques for dealing with sequential data.
    You will learn how to use the `reduce` function, as well as other reducing techniques
    that provide greater flexibility for transforming or extracting data from a sequence.
    We will use the simple form of `reduce`, use `reduce` with an initializer and
    an accumulator, and solve problems requiring a variable-length "window" over a
    sequence. We will also reduce sequences with functions other than `reduce`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习处理序列数据的新技术。你将学习如何使用`reduce`函数，以及其他提供更多灵活性的减少技术，以便从序列中转换或提取数据。我们将使用`reduce`的简单形式，使用带有初始化器和累加器的`reduce`，并解决需要序列可变长度“窗口”的问题。我们还将使用除`reduce`以外的函数来减少序列。
- en: By the end of this chapter, you will be able to use `reduce` with complex accumulators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用具有复杂累加器的`reduce`。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter is about using Clojure''s `reduce` function and about *reducing*
    in general. By that, we mean starting with a sequence and *boiling it down* to
    a single thing. ("Reducing" is also cooking term, after all.) `map` and `filter`
    were about taking the sequence you have and turning it into the sequence you want:
    *sequence in, sequence out*. But that''s not always what we want. Even simple
    operations on a sequence, such as calculating an average, a sum, or a maximum,
    cannot be directly calculated this way. That''s where `reduce`, as well as a wider
    family of functions and patterns, comes in: *sequence in, something else out*.
    It''s "something else" because the result might be a number, a string, a map,
    or even another sequence.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用Clojure的`reduce`函数，以及一般意义上的*减少*。通过这一点，我们是指从一个序列开始，将其*简化*为一个单一的事物。（“减少”也是一个烹饪术语，毕竟。）`map`和`filter`是关于将你拥有的序列转换为你想要的序列：*输入序列，输出序列*。但那并不总是我们想要的。即使是序列上的简单操作，如计算平均值、总和或最大值，也无法直接这样计算。这就是`reduce`以及更广泛的函数和模式发挥作用的地方：*输入序列，其他输出*。这是因为结果可能是一个数字、一个字符串、一个映射，甚至另一个序列。
- en: 'In the previous chapter, we saw that functions such as `map` and `filter` only
    look at one element at a time: how should we transform this item? Should we discard
    this item, or keep it? This is a powerful approach because it creates a clear
    scope for the action of the functions we write, which helps us to write simpler
    code, and it allows lazy evaluation. There is a limit to this approach, however,
    when we need to look at a sequence as a whole, or at least as more than just the
    current item. This is why `map` and `filter` are only partial replacements for
    a `for` loop.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了`map`和`filter`之类的函数一次只查看一个元素：我们应该如何转换这个项目？我们应该丢弃这个项目，还是保留它？这是一种强大的方法，因为它为我们的函数操作创建了一个清晰的范围，这有助于我们编写更简单的代码，并允许惰性求值。然而，当我们需要将序列作为一个整体查看，或者至少是查看比当前项目更多的内容时，这种方法是有局限性的。这就是为什么`map`和`filter`只是`for`循环的部分替代品。
- en: In Clojure, the `reduce` function is not the only way to generate a result from
    an entire sequence. Even the simple `count` function is a way of reducing a sequence
    down to a single value. Some core functions actually use `reduce` themselves so
    that we don't have to. The recursion and looping techniques that we'll discuss
    in the next chapter can do this as well. The patterns we are going to look at
    here should, in general, be what you consider first, after you've decided that
    `map` and `filter` are not enough. `reduce` and other similar functions provide
    a clear way of solving a certain kind of problem, which is why they are an important
    part of your mental Clojure toolkit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，`reduce`函数并不是从整个序列生成结果的唯一方法。即使是简单的`count`函数，也是将序列减少到单个值的一种方式。一些核心函数实际上会使用`reduce`，这样我们就不必自己做了。我们将在下一章讨论的递归和循环技术也可以做到这一点。这里将要探讨的模式，在一般情况下，应该是你在决定`map`和`filter`不足以解决问题后首先考虑的。`reduce`和其他类似函数提供了一种清晰解决问题的方法，这也是为什么它们是你心智中的Clojure工具箱的重要组成部分。
- en: The Basics of reduce
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`reduce`的基本原理'
- en: 'To understand how `reduce` works, the best place to start is with a simple
    example. Let''s try to find the sum of a list of integers. In an imperative language
    such as JavaScript, we might do something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`reduce`是如何工作的，最好的起点是一个简单的例子。让我们尝试计算一个整数列表的总和。在像JavaScript这样的命令式语言中，我们可能会这样做：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `sum` variable here accumulates information found in previous iterations
    of the loop. This is exactly what `reduce` does. Here''s a Clojure version of
    the same thing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `sum` 变量累积了循环前几次迭代中找到的信息。这正是 `reduce` 所做的。以下是一个 Clojure 版本的相同内容：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the first iteration, `sum-so-far` refers to `0` and `item` refers to `8`.
    In subsequent iterations, `sum-so-far` refers to the result of evaluating the
    function with the previous item in the collection and `item` refers to the current
    item of the collection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`sum-so-far` 指的是 `0`，而 `item` 指的是 `8`。在后续的迭代中，`sum-so-far` 指的是使用集合中前一个元素评估函数的结果，而
    `item` 指的是集合的当前元素。
- en: 'How does this work? This expression looks a lot like some of the uses of `map`
    or `filter` in the previous chapter. The layout of the s-expression should be
    very familiar by now:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？这个表达式看起来很像前一章中 `map` 或 `filter` 的一些用法。s-表达式的布局现在应该非常熟悉了：
- en: A function
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数
- en: An anonymous function
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匿名函数
- en: A vector of integers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数向量
- en: And yet, you can probably already tell that this expression is quite different
    from using `map` or `filter`. First of all, there is only one sequence supplied,
    yet the anonymous function takes two arguments, `sum-so-far` and `item`. And,
    of course, the biggest surprise is the result, which is not a sequence at all,
    but a single integer. This isn't `map` territory anymore.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经能看出这个表达式与使用 `map` 或 `filter` 的表达式相当不同。首先，只有一个序列被提供，但匿名函数接受两个参数，`sum-so-far`
    和 `item`。当然，最大的惊喜是结果，它根本不是一个序列，而是一个单一的整数。这不再是 `map` 的领域了。
- en: Obviously, this expression simply adds up integers in the sequence provided.
    To do that, it iterates over the integers in the sequence, seemingly like `map`
    would. The key difference is that with `reduce`, the function *"remembers"* the
    result of evaluating the previous calculations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个表达式只是将序列中提供的整数相加。为了做到这一点，它遍历序列中的整数，看起来就像 `map` 会做的那样。关键的区别在于，使用 `reduce`
    时，函数会“记住”评估前一次计算的结果。
- en: Let's break down the operations here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这里的操作。
- en: 'The first time `reduce` calls the function we''ve provided, `(fn [sum-so-far
    item] (+ sum-so-far item))`, the arguments are the first two items in the list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次 `reduce` 调用我们提供的函数 `(fn [sum-so-far item] (+ sum-so-far item))` 时，参数是列表中的前两个元素：
- en: '![Figure 5.1: sum-so-far and item are the first two items in the list (call
    1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1：`sum-so-far` 和 `item` 是列表中的前两个元素（调用 1）'
- en: '](img/B14502_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_05_01.jpg)'
- en: 'Figure 5.1: sum-so-far and item are the first two items in the list (call 1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：`sum-so-far` 和 `item` 是列表中的前两个元素（调用 1）
- en: 'For each of the next calls, `sum-so-far` is the result of the previous calculation,
    and `item` is the next integer in the list:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的每次调用，`sum-so-far` 是前一次计算的结果，而 `item` 是列表中的下一个整数：
- en: '![Figure 5.2: Calls 2 and 3: each call builds on the result of the previous
    calls'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2：调用 2 和 3：每个调用都基于前一个调用的结果'
- en: '](img/B14502_05_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_05_02.jpg)'
- en: 'Figure 5.2: Calls 2 and 3: each call builds on the result of the previous calls'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：调用 2 和 3：每个调用都基于前一个调用的结果
- en: 'We could simplify this expression by replacing the anonymous function with
    Clojure''s `+` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用 Clojure 的 `+` 函数替换匿名函数来简化这个表达式：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And we could even use `apply` and avoid using `reduce` altogether:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用 `apply` 并完全避免使用 `reduce`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, with `(apply + …)`, we haven''t really escaped from `reduce`: internally,
    the `+` function, when called with more than two arguments, uses a version of
    `reduce` to move through the list.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `(apply + …)`，我们并没有真正摆脱 `reduce`：内部，当 `+` 函数被调用时，如果参数超过两个，它将使用 `reduce`
    的一个版本来遍历列表。
- en: 'Exercise 5.01: Finding the Day with the Maximum Temperature'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：寻找最高温度的日期
- en: 'Clojure''s `max` function is useful when dealing with a list of numbers, but
    what do you do when the numbers you want to compare are part of a more complex
    data structure? Suppose we have the following weather data:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 的 `max` 函数在处理数字列表时很有用，但当你想比较的数字是更复杂的数据结构的一部分时，你该怎么办？假设我们有以下天气数据：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to be able to write functions that return the entire map for the day
    with the highest maximum temperature, the lowest minimum, and so on:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够编写返回最高温度日期的整个映射、最低温度等函数：
- en: 'Start a REPL and copy the `weather-days` variable from the book GitHub''s repository
    and paste it into your REPL. You''ll find the file here: [https://packt.live/2SXw372](https://packt.live/2SXw372).'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个 REPL 并将书 GitHub 存储库中的 `weather-days` 变量复制并粘贴到你的 REPL 中。你可以在以下位置找到文件：[https://packt.live/2SXw372](https://packt.live/2SXw372)。
- en: 'Use `map` and `max` to find the highest temperature:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`和`max`找到最高温度：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This could be useful, but it doesn't tell us what day had this temperature,
    or whether it was sunny or cloudy that day, or what the minimum temperature was
    that day.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能很有用，但它没有告诉我们哪一天有这个温度，或者那天是晴天还是多云，或者那天的最低温度是多少。
- en: 'Find the maximum `:max` temperature with `reduce`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`reduce`找到最高的`:max`温度：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the maximum temperature of a given day is higher than `max-day-so-far`, that
    day replaces `max-day-so-far` until another day with a higher temperature dethrones
    it.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果某天的最高温度高于`max-day-so-far`，那么那一天就会取代`max-day-so-far`，直到有更高温度的一天将其推翻。
- en: 'Find the day that had the lowest maximum temperature:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到具有最低最高温度的那一天：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Returning the *item* with the maximum value, rather than returning the maximum
    itself, can be useful when working with complex data structures. You will probably
    never be confronted with this exact problem. The important thing is to be able
    to quickly write a specialized version of `max`, `min`, a comparator, or whatever
    other function you need that is adapted to the needs of your particular data.
    Because of its power and flexibility, knowing how to use `reduce` can be extremely
    useful in those situations. It's no accident either that, internally, many core
    Clojure functions use `reduce` themselves. This is true of `take-while`, `set`,
    `into`, and `map`, for example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有最大值的*项*，而不是返回最大值本身，当与复杂的数据结构一起工作时可能很有用。你可能永远不会遇到这个确切的问题。重要的是能够快速编写一个专门版本的`max`、`min`、比较器或任何其他适应你特定数据需要的函数。由于它的强大和灵活性，了解如何使用`reduce`在这些情况下可能非常有用。这也并非巧合，许多核心Clojure函数在内部也使用`reduce`。例如，`take-while`、`set`、`into`和`map`都是如此。
- en: Initializing reduce
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化reduce
- en: 'Tasks such as adding integers or finding maximum values have a common thread:
    the input values and the accumulated values are of the same type. When two numbers
    are added, the result is a number; when a maximum or a minimum is chosen between
    two numbers, the result is still a number. When we use `reduce` to add numbers
    together, the running total is a number just like all the other inputs. In the
    examples so far, the first function call that `reduce` makes takes the first two
    items in the sequence. We can break a `reduce` call into its successive function
    calls:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 添加整数或查找最大值等任务有一个共同点：输入值和累积值是同一类型。当两个数字相加时，结果是数字；当在两个数字之间选择最大值或最小值时，结果仍然是数字。当我们使用`reduce`将数字相加时，累积总和就像所有其他输入一样是数字。在迄今为止的例子中，`reduce`第一次调用的函数取序列中的前两个项目。我们可以将`reduce`调用分解为其连续的函数调用：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We actually don''t need the anonymous function that we used in the previous
    examples, because `+` takes numbers as arguments, and returns a number:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们不需要在之前的例子中使用的匿名函数，因为`+`接受数字作为参数，并返回一个数字：
- en: '![Figure 5.3: The arguments and the return value are all of the same type'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：参数和返回值都是同一类型](img/B14502_05_03.jpg)'
- en: '](img/B14502_05_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：参数和返回值都是同一类型](img/B14502_05_03.jpg)'
- en: 'Figure 5.3: The arguments and the return value are all of the same type'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：参数和返回值都是同一类型
- en: 'In each of our examples so far, three different things are all of the same
    type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的每个例子中，三件事都是同一类型的：
- en: The values in the sequence
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中的值
- en: Both arguments to `+`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`的两个参数'
- en: The return value of `+`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`的返回值'
- en: 'In the previous exercise, we returned a map rather than a single number. That
    was possible because the same kinds of maps were used in these three places: the
    maps we iterate over as well as the current "best" map that we are comparing the
    others to.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们返回了一个映射而不是单个数字。这是可能的，因为这三个地方都使用了相同类型的映射：我们迭代的映射以及我们正在比较的当前“最佳”映射。
- en: If this was all we could do with `reduce`, however, it would be rather restrictive.
    Not all problems can be expressed by this kind of function. Often, we want to
    compute and accumulate some other kind of value. We might need more complex summary
    statistics, or to merge individual values together in a specific way, or to divide
    a sequence into segments based on special criteria. Just because you have a sequence
    of `matches`, to take up our tennis examples again, doesn't mean that the result
    you want can also be expressed as a tennis `match`. Maybe we want to iterate over
    a list of matches and accumulate some other kind of information. At the end of
    this chapter, in fact, we are going to do just that. At the beginning of this
    chapter, we said that `reduce` can turn a sequence into *anything* else, but so
    far, this hasn't really been true.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`reduce`只能做到这些，那么它的限制会相当大。并不是所有问题都可以用这种函数表达。通常，我们想要计算和累积其他类型的值。我们可能需要更复杂的汇总统计，或者以特定方式合并单个值，或者根据特殊标准将序列分成段。仅仅因为你有`matches`序列，以我们的网球例子来说，并不意味着你想要的结果也可以用网球`match`表达。也许我们想要遍历一个`matches`列表并累积其他类型的信息。实际上，在本书的结尾，我们将做这件事。在本章的开头，我们说`reduce`可以将序列转换为*任何其他东西*，但到目前为止，这并不完全正确。
- en: This is why there is a second form of `reduce` that takes an additional argument.
    When the additional argument is present, it becomes the first argument to the
    reducing function. On that initial function call, the first item in the sequence
    is the second argument. This is a crucial improvement because the reducing function's
    return value no longer has to be the same kind of thing that is in the sequence.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么存在第二种形式的`reduce`，它接受一个额外的参数。当存在额外参数时，它成为归约函数的第一个参数。在初始函数调用中，序列中的第一个元素是第二个参数。这是一个关键改进，因为归约函数的返回值不再必须是序列中相同类型的对象。
- en: 'Consider the following snippet, where we supply an empty map as an initial
    value for our reduction. As it moves through the sequence, the reducing function
    updates the `:maximum` and `:minimum` fields when new values are discovered. The
    expression returns a function at the end:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中我们为归约提供一个空的映射作为初始值。随着它通过序列，当发现新值时，归约函数会更新`:maximum`和`:minimum`字段。表达式最终返回一个函数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding expression finds both the minimum and the maximum value in a sequence.
    Calling `reduce` like this might be useful if, for some reason, it was difficult
    to loop over a list twice, if it were very, very long, or perhaps there was a
    stream that was not being retained. To return two values, we'll place them in
    a map. Without the initializing argument for `reduce`, this would already have
    been impossible. This is a case where "numbers in, numbers out" is not sufficient.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式在一个序列中找到最小值和最大值。以这种方式调用`reduce`可能很有用，如果由于某种原因，很难对列表进行两次循环，如果列表非常非常长，或者可能有一个没有被保留的流。为了返回两个值，我们将它们放在一个映射中。如果没有`reduce`的初始化参数，这已经是不可能的了。这是一个“输入数字，输出数字”不足以应对的情况。
- en: Here, we supply an empty map as an initial value for our reduction. As it moves
    through the sequence, the reducing function updates the `:maximum` and `:minimum`
    fields when new values are discovered. The expression returns a function at the
    end.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供一个空的映射作为我们归约的初始值。随着它通过序列，当发现新值时，归约函数会更新`:maximum`和`:minimum`字段。表达式最终返回一个函数。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another common pattern in a case like this would be to return a two-item vector
    (a tuple) instead of a map: `[minimum maximum]`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，另一种常见的模式是返回一个包含两个元素的向量（一个元组），而不是映射：`[minimum maximum]`。
- en: On each call of the reducing function, the first argument is always a map, and
    the second argument is always an integer from the sequence.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在归约函数的每次调用中，第一个参数始终是一个映射，第二个参数始终是序列中的一个整数。
- en: This difference makes `reduce` much more useful. Now, we can extract whatever
    data we like from each item in the sequence and insert it and carry it forward
    as the context for the subsequent iterations. Most of the time, we can think of
    this context as an `acc`. Later, when we look at some of Clojure's other looping
    constructs, the idea of an explicit context will reappear.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异使得`reduce`更加有用。现在，我们可以从序列中的每个元素中提取我们喜欢的数据，并将其作为后续迭代的上下文插入和传递。大多数时候，我们可以将这个上下文视为一个`acc`。稍后，当我们查看Clojure的其他循环结构时，显式上下文的概念将再次出现。
- en: Partitioning with reduce
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`reduce`进行分区
- en: Partitioning a sequence into smaller sequences is a common problem and there
    are many ways to solve it. When the simpler solutions aren't enough, `reduce`
    can be a useful alternative.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列分割成更小的序列是一个常见问题，有多种解决方法。当简单的解决方案不够用时，`reduce`可以是一个有用的替代方案。
- en: 'First, let''s take a look at some of the other possibilities. If sub-sequences
    of a fixed length are required, then there is `partition` or `partition-all`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看其他一些可能性。如果需要固定长度的子序列，那么有`partition`或`partition-all`：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The difference between the two is that `partition` stops when it has filled
    its last group, while `partition-all` continues, even if this means the final
    sub-sequence won't contain the same number of items.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的区别在于，`partition`在填满最后一个组时停止，而`partition-all`即使这意味着最终的子序列不会包含相同数量的项目也会继续。
- en: There is also `partition-by`, which offers more flexibility. In addition to
    the sequence to break apart, `partition-by` takes a function that will be called
    on each item. `partition-by` will then start a new subsequence whenever the return
    value changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`partition-by`，它提供了更多的灵活性。除了要拆分的序列外，`partition-by`还接受一个将在每个项目上调用的函数。`partition-by`将在返回值改变时开始一个新的子序列。
- en: 'Here, we break a sequence into sub-sequences depending on whether the integers
    are greater than or less than 10:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据整数是大于还是小于10来将序列分割成子序列：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because `partition-by` allows you to write your own partitioning function, this
    can be a rather useful function when used creatively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`partition-by`允许你编写自己的分区函数，因此当创造性地使用时，这可以是一个相当有用的函数。
- en: However, just like `map` and `filter` themselves, none of these functions can
    look at more than one item at a time. What if, for example, we wanted to partition
    a sequence of integers into sequences whose sum was less than 20? To solve this
    kind of problem, we need to be able to consider more than one item at a time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像`map`和`filter`本身一样，这些函数都不能一次查看超过一个项目。例如，如果我们想将整数序列分割成总和小于20的序列，该怎么办？为了解决这类问题，我们需要能够一次考虑多个项目。
- en: 'When using `reduce` for this, the key is to use a map as an initializer and
    accumulator, with at least two different fields: one for the accumulated sequences
    and one for the current sequence. The accumulator might look as follows, mid-way
    through a reduction, if we are trying to make sequences whose sum is less than
    20:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`reduce`进行此操作时，关键是使用映射作为初始化器和累加器，至少有两个不同的字段：一个用于累积的序列，一个用于当前序列。累加器可能如下所示，在减少过程中间，如果我们试图创建总和小于20的序列：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The vectors in `segments` are complete: if one more item was added, their sums
    would exceed 20\. The `:current` vector adds up to 15 right now. If the next item
    in the main sequence is 4 or more, we won''t be able to add it to this vector
    and we''ll move `[5 10]` over to `segments`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`segments`中的向量是完整的：如果再添加一个项目，它们的总和将超过20。当前的`:current`向量目前的总和是15。如果主序列中的下一个项目是4或更多，我们就无法将它添加到这个向量中，并将`[5
    10]`移动到`segments`中。'
- en: 'Here is how this would work in practice:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在实际中的工作方式：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s take a closer look. For convenience, we start by extracting the segments
    and current bindings from the accumulator. Then, we set up a couple of useful
    bindings: `current-with-n` is the current sequence plus the current item, `n`.
    At this point, we don''t know if this is a valid sequence. Its total might go
    beyond the limit of 20\. To check this, we assign another binding (for clarity),
    `total-with-n`, and we compare that to 20.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看。为了方便起见，我们首先从累加器中提取段和当前绑定。然后，我们设置几个有用的绑定：`current-with-n`是当前序列加上当前项目`n`。在这个时候，我们还不知道这是一个有效的序列。它的总和可能会超过20的限制。为了检查这一点，我们分配另一个绑定（为了清晰起见），`total-with-n`，并将其与20进行比较。
- en: If `current-with-n` adds up to more than 20, this means that `current` is a
    valid sub-sequence. In that case, we add it as is (without `n`) to our list of
    accumulated segments, and we place `n` as the first item in a brand new `:current`
    vector. On the other hand, if `current-with-n` does not add up to 20 yet, we just
    append `n` to `current` and keep going.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`current-with-n`的总和超过20，这意味着`current`是一个有效的子序列。在这种情况下，我们将其（不带`n`）添加到我们累积的段列表中，并将`n`作为新`:current`向量的第一个项目。另一方面，如果`current-with-n`的总和还没有达到20，我们只需将`n`追加到`current`中并继续进行。
- en: 'You''ll notice that the final result is not exactly what we want: the last
    item, `[18]`, is still stuck in `:current`. To present a clean result, we should
    probably wrap our call to `reduce` in a function that will take care of this last
    bit of housekeeping:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到最终的结果并不完全符合我们的预期：最后一个元素`[18]`仍然卡在`:current`中。为了呈现一个干净的结果，我们可能需要将我们的`reduce`调用包裹在一个函数中，该函数将处理这个最后的清理工作：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we''ve made our function a little bit more versatile by adding a `limit`
    parameter so that we can choose other values besides 20\. We also create a binding
    for the result of the call to `reduce` that we then use, at the last line of the
    function, to append the final value of `:current` to the accumulated segments.
    Now we get the result we want:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过添加一个`limit`参数使我们的函数更加灵活，这样我们就可以选择除了20以外的其他值。我们还为`reduce`调用的结果创建了一个绑定，然后在函数的最后几行中使用它来将`:current`的最终值追加到累积段中。现在我们得到了我们想要的结果：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This common pattern will allow you to do lots of interesting things with `reduce`.
    In the next two exercises, we will use variations of it to solve two rather different
    kinds of problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种常见的模式将允许你使用`reduce`做很多有趣的事情。在接下来的两个练习中，我们将使用它的变体来解决两种相当不同的问题。
- en: Looking Back with reduce
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾使用reduce
- en: As we saw in the previous chapter, Clojure's `map` function is extremely useful
    and versatile. The key to understanding `map` is the idea of the one-to-one *mapping*
    (there's that word!) between each item in the input sequence and each item in
    the output sequence. Sometimes, this isn't what we need. The windowing pattern
    we used in *Chapter 4*, *Mapping and Filtering*, is one way to work around this,
    but it has its own limitations. Often, we don't know how "wide" the window needs
    to be. It might depend on the data itself and vary as we move through the input
    sequence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，Clojure的`map`函数非常有用且灵活。理解`map`的关键在于输入序列中的每个元素与输出序列中的每个元素之间的一对一*映射*（又是这个词！）的想法。有时，这并不是我们需要的。我们在*第4章*中使用的窗口模式是解决这个问题的一种方法，但它也有自己的局限性。通常，我们不知道窗口需要有多“宽”。它可能取决于数据本身，并且在我们通过输入序列移动时变化。
- en: 'We can solve this problem quite easily with `reduce` and an accumulator that
    retains a certain number of items. To start with a simple example, let''s suppose
    we have a list of integers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`reduce`和一个保留一定数量项的累加器轻松解决这个问题。为了从一个简单的例子开始，让我们假设我们有一个整数列表：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For each integer in the list, we want to return a two-item tuple containing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个整数，我们希望返回一个包含两个元素的元组：
- en: The integer itself
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数本身
- en: If the integer is odd, the sum of the consecutive odd integers preceding it;
    if it's even, the sum of the consecutive even integers
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果整数是奇数，则它之前连续奇数的和；如果是偶数，则它之前连续偶数的和
- en: Following this logic, the first `9` in the list should be replaced with `[9
    0]`, since it is preceded by an even integer. The second `9`, on the other hand,
    should be replaced with `[9 10]`, since it is preceded by a `3` and a `7`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个逻辑，列表中的第一个`9`应该被替换为`[9 0]`，因为它之前是一个偶数。另一方面，第二个`9`应该被替换为`[9 10]`，因为它之前是`3`和`7`。
- en: 'And here is a function that solves this with `reduce`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`reduce`解决这个问题的函数：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a closer look, starting with the accumulator, a map with two keys
    referencing empty vectors: `:current`, for the current series of integers with
    the same parity; and `:ret`, for the list of values that will be returned. (The
    entire `reduce` expression is wrapped by a `(:ret…)` expression to extract this
    value.)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看，从累加器开始，这是一个包含两个键的映射，这两个键引用空向量：`:current`，用于当前具有相同奇偶性的整数序列；`:ret`，用于将要返回的值列表。（整个`reduce`表达式被一个`(:ret…)`表达式包裹，以提取这个值。）
- en: The reducing function starts with some destructuring to give us easy access
    to `:current`; now, `n`, of course, is the current integer in the list. Inside
    the function, the structure is quite simple. The `if` expression has a somewhat
    elaborate set of nested logical operators. First, we use `(seq current)` to check
    whether `current` is empty, which would be the case on the first iteration. The
    `seq` function returns `false` if a vector or list is empty. Then, since we know
    `(last current)` will return an integer, we can test to see whether `n` and the
    previous value in the list are both odd or both even.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 减少函数开始时进行一些解构，以便我们能够轻松访问`:current`；现在，`n`当然是我们列表中的当前整数。在函数内部，结构相当简单。`if`表达式有一组相当复杂的嵌套逻辑运算符。首先，我们使用`(seq
    current)`来检查`current`是否为空，这在第一次迭代时是这种情况。如果向量或列表为空，`seq`函数返回`false`。然后，由于我们知道`(last
    current)`将返回一个整数，我们可以测试`n`和列表中的前一个值是否都是奇数或都是偶数。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because we are using vectors here, `conj` appends new items to the end of the
    vector. To get the most recent item, we use `last`. If we were using lists instead
    of vectors, `conj` would append to the front of the list and we would have to
    use `first` to get the most recent item. When using `conj`, it's important to
    make sure the underlying data structure is what you think it is. Otherwise, your
    results could easily be backward.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里使用向量，`conj`将新项目追加到向量的末尾。要获取最新项目，我们使用`last`。如果我们使用列表而不是向量，`conj`将追加到列表的前面，并且我们必须使用`first`来获取最新项目。当使用`conj`时，重要的是要确保底层数据结构是您所认为的那样。否则，您的结果可能会很容易出错。
- en: 'Depending on which branch of the `if` statement we end up in, we update `acc`
    differently. In the first case, the current integer has the same parity as the
    contents of `current`. We thread `acc` through two calls to `update`. As you remember
    from *Chapter 2*, *Data types and Immutability*, `update` takes a function as
    its second argument, `conj` in this case, because we are adding to the vector,
    and applies it to the value associated with the key provided as the first value.
    We add an additional argument, `[n (apply + current)]`. This will be the second
    argument to `conj`. Altogether, it''s as though we were calling `conj` like this:
    `(conj (:ret acc) [n (apply + current)])`. The second call to `update` adds `n`
    to our running list of integers.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们最终进入的`if`语句的哪个分支，我们更新`acc`的方式不同。在第一种情况下，当前整数与`current`的内容具有相同的奇偶性。我们通过两次调用`update`将`acc`传递下去。如您在*第二章*，*数据类型和不可变性*中记得的，`update`将其第二个参数（函数）作为其第二个参数，在这种情况下是`conj`，因为我们是在向向量中添加，它将应用于作为第一个值提供的键关联的值。我们添加一个额外的参数，`[n
    (apply + current)]`。这将作为`conj`的第二个参数。总的来说，这就像我们这样调用`conj`：`(conj (:ret acc) [n
    (apply + current)])`。第二次调用`update`将`n`添加到我们的整数运行列表中。
- en: In the other case, when we are at the beginning of the list or because of a
    change from odd to even or even to odd, we know that the current total is zero.
    Instead of `update`, we can use `assoc` here because we're starting over with
    a fresh list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，当我们处于列表的起始位置或由于奇数变为偶数或偶数变为奇数而发生变化时，我们知道当前总和为零。在这种情况下，我们可以使用`assoc`而不是`update`，因为我们正在从头开始使用一个全新的列表。
- en: 'Running the function on our sequence of integers gives us this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的整数序列上运行该函数，我们得到以下结果：
- en: '![Figure 5.4: The original inputs are followed by the sum of the preceding,
    consecutive integers of the same parity'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：原始输入后面跟着相同奇偶性的前一个连续整数的和'
- en: '](img/B14502_05_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_04.jpg)'
- en: 'Figure 5.4: The original inputs are followed by the sum of the preceding, consecutive
    integers of the same parity'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：原始输入后面跟着相同奇偶性的前一个连续整数的和
- en: This would be impossible with `map` because, unlike the windowing technique
    we used, the `:current` vector in the accumulator here can contain as many items
    as necessary, depending on the input. This also shows the flexibility of `reduce`
    when using an accumulator. Now, we can practice using it on a real problem.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`是不可能的，因为与我们所使用的窗口技术不同，累加器中的`:current`向量可以包含所需数量的项目，这取决于输入。这也显示了使用累加器时`reduce`的灵活性。现在，我们可以练习在真实问题上使用它。
- en: 'Exercise 5.02: Measuring Elevation Differences on Slopes'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：在斜坡上测量高程差异
- en: 'The organizers of a bicycle race in a mountainous region want to improve the
    signs they place on the side of the road. Currently, each sign simply indicates
    the distance from the start of the race. The race organizers would like to add
    two more numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个山地地区的自行车赛的组织者希望改善他们在路边放置的标志。目前，每个标志只是指示从比赛开始处的距离。比赛组织者希望添加两个额外的数字：
- en: The distance to the top or bottom of the current slope, depending on whether
    that part of the racecourse is gaining or losing elevation
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达当前斜坡顶部或底部的距离，这取决于比赛场地的这部分是上升还是下降海拔
- en: The remaining elevation gain or loss until the end of the current slope
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达当前斜坡末尾之前剩余的海拔上升或下降
- en: 'Here is an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![Figure 5.5: Racecourse sign indicating the remaining distance and elevation
    until'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：赛马场标志，指示到达当前小山顶部的剩余距离和海拔'
- en: the top of the current hill
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当前小山顶部
- en: '](img/B14502_05_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_05.jpg)'
- en: 'Figure 5.5: Racecourse sign indicating the remaining distance and elevation
    until the top of the current hill'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：赛马场标志，指示到达当前小山顶部的剩余距离和海拔
- en: 'The data you have is a list of tuples: the first value is the distance from
    the start of the race, and the second is the elevation at that point. You can
    copy the data from [https://packt.live/38IcEvx](https://packt.live/38IcEvx):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有的数据是一个元组的列表：第一个值是比赛起点的距离，第二个值是该点的海拔。你可以从[https://packt.live/38IcEvx](https://packt.live/38IcEvx)复制数据：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will solve this problem using `reduce` and the "looking back" pattern. There
    is, however, a difficulty we need to resolve first. If we are looking *back*,
    how do we know how far we are from the *next* peak or the *next* valley? Simple:
    we''ll reverse the racecourse data so that when we''re looking back, we''re actually
    looking forward!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`reduce`和“回顾”模式来解决此问题。然而，我们首先需要解决一个困难。如果我们正在“回顾”，我们如何知道我们离下一个山峰或下一个山谷有多远？简单：我们将赛马场数据反转，这样当我们回顾时，我们实际上是在向前看！
- en: 'In the following figure, as we descend the slopes, we can "see" forward and
    compare our current position with the peaks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，当我们下坡时，我们可以“看到”前方，并将我们的当前位置与山峰进行比较：
- en: '![Figure 5.6: The descent slopes'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：下坡道'
- en: '](img/B14502_05_06.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_06.jpg)'
- en: 'Figure 5.6: The descent slopes'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：下坡道
- en: By reversing the direction, we traverse the data; when we look "back," we are
    looking forward geographically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反转方向，我们遍历数据；当我们“回顾”时，我们在地理上是向前看的。
- en: 'Now we can start writing some code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写一些代码：
- en: 'Start a fresh REPL in an empty directory and open a new file, `bike_race.clj`.
    Add the corresponding namespace declaration:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空目录中启动一个新的REPL，并打开一个新文件，`bike_race.clj`。添加相应的命名空间声明：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Clojure namespaces use hyphens between words (sometimes referred to as "kebab
    case") but, because of Clojure's Java origins, the corresponding filenames use
    underscores instead (or "snake case"). That's why the `bike-race` namespace is
    in a file named `bike_race.clj`. In *Chapter 8*, *Namespaces, Libraries and Leiningen*
    you will learn more about namespaces.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clojure命名空间在单词之间使用连字符（有时称为“kebab case”），但由于Clojure的Java起源，相应的文件名使用下划线（或“snake
    case”）。这就是为什么`bike-race`命名空间在一个名为`bike_race.clj`的文件中。在*第8章*，*命名空间、库和Leiningen*中，你将了解更多关于命名空间的信息。
- en: Copy the `distance-elevation` var from the book's GitHub repository at [https://packt.live/38IcEvx](https://packt.live/38IcEvx).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从书籍的GitHub仓库[https://packt.live/38IcEvx](https://packt.live/38IcEvx)复制`distance-elevation`变量。
- en: 'Set up the skeleton for this function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此函数设置骨架：
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are only a couple of notable differences with the basic "looking back"
    pattern described above. First of all, there is more destructuring for easy access
    to the `distance` and `elevation` values inside the incoming tuple. Secondly,
    the entire call to `reduce` is wrapped inside a `->` threading macro. This is,
    of course, equivalent to `(reverse (:calculated (reduce…)))` but has the advantage
    of organizing the code according to how the data flows through the function. This
    is a fairly common idiom with accumulators when only one of the fields will ultimately
    be returned.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上面描述的基本“回顾”模式相比，只有几个显著的不同。首先，有更多的解构，以便轻松访问元组内的`distance`和`elevation`值。其次，整个`reduce`调用都被`->`线程宏包裹。这当然等同于`(reverse
    (:calculated (reduce…)))`，但优点是按照数据通过函数的方式组织代码。这是一个相当常见的累加器习语，当最终只返回一个字段时。
- en: 'Otherwise, the general approach is the same: the `:current` field will contain
    all the points on the path up to the *previous* (but geographically *next*) peak
    or valley. The `:calculated` field will store the calculated values so they can
    be returned at the end.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，一般方法相同：`:current`字段将包含到达上一个（但在地理上下一个）山峰或山谷的所有路径点。`:calculated`字段将存储计算值，以便在最后返回。
- en: 'We will need to know whether the new position is on the same slope as the positions
    stored in `current`. Are we still going up, or down, or have we gone over a peak,
    or across the lowest part of a valley? To simplify our code, we''ll write a helper
    function, taking `current` and the new elevation. This will return `true` or `false`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要知道新的位置是否与存储在`current`中的位置处于同一斜坡上。我们还在上升，还是在下降，或者我们已经越过了山顶，或者穿过了山谷的最低点？为了简化我们的代码，我们将编写一个辅助函数，该函数接受`current`和新的海拔。这将返回`true`或`false`：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we check whether there is only one value in `current`. If so, we know
    the answer to our question because, with only two points, we know we are on the
    same slope. This also protects our next tests from errors since we can now be
    sure that there are at least two items in `current`. (We still have to be careful
    not to call this function with an empty list.)
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们检查`current`中是否只有一个值。如果是这样，我们就知道我们的问题的答案，因为只有两个点，我们知道我们处于同一斜坡上。这也保护了我们的下一个测试免受错误的影响，因为我们现在可以确信`current`中至少有两个项目。（我们仍然必须小心不要用空列表调用这个函数。）
- en: 'Now that we know that we have at least two items, we can do some destructuring.
    This destructuring is doubly nested: first, we take the last two elements in `current`,
    using the `take-last` function, and then we extract and name the second part of
    those tuples. To destructure the tuples, we use an underscore, `_`, as a placeholder
    to indicate that we are not interested in the first value. This use of an underscore
    here is simply a Clojure convention that means essentially "don''t pay attention
    to this value."'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 既然我们知道我们至少有两个项目，我们就可以进行一些解构。这种解构是双层嵌套的：首先，我们使用`take-last`函数取出`current`中的最后两个元素，然后我们提取并命名这些元组的第二部分。为了解构元组，我们使用下划线`_`作为占位符，表示我们对该第一个值不感兴趣。这里使用下划线的做法仅仅是Clojure的惯例，其含义基本上是“不要关注这个值。”
- en: Note
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We named the binding `the-last` instead of simply `last`. This is because of
    Clojure's `last` function. Since we don't use `last` in this scope, we *could*
    have named the binding `last` without a problem. However, it is a good practice
    to avoid using names that coincide with standard Clojure functions. The danger
    is that your local binding might "shadow" a core Clojure function, resulting in
    a confusing bug.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将绑定命名为`the-last`而不是简单地命名为`last`。这是因为Clojure的`last`函数。由于我们在这个作用域中不使用`last`，我们可以没有问题地将绑定命名为`last`。然而，避免使用与标准Clojure函数重名的名称是一个好习惯。危险在于你的局部绑定可能会“遮蔽”一个核心Clojure函数，从而导致令人困惑的错误。
- en: Now we have three values and we want to see whether they are either all increasing
    or all decreasing. This turns out to be quite simple with Clojure's comparison
    functions, which accept more than two arguments. `(>= next-to-last the-last elevation)`
    will return `true` if `next-to-last` is greater than or equal to `the-last` ,
    and if `the-last` is greater than or equal to `elevation`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有三个值，我们想知道它们是否都是递增的或者都是递减的。这实际上与Clojure的比较函数相当简单，这些函数可以接受超过两个参数。`(>= next-to-last
    the-last elevation)`如果`next-to-last`大于或等于`the-last`，并且如果`the-last`大于或等于`elevation`，则返回`true`。
- en: 'At the REPL, move to the `bike-race` namespace as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中，按照以下方式移动到`bike-race`命名空间：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Test the `same-slope-as-current?` function:![Figure 5.7: Testing the program'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`same-slope-as-current?`函数：![图5.7：测试程序
- en: '](img/B14502_05_07.jpg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_05_07.jpg)'
- en: 'Figure 5.7: Testing the program'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：测试程序
- en: It seems to work as expected, including when there is only one value in `current`.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它似乎按预期工作，包括当`current`中只有一个值时。
- en: 'The rest of the function will be structured around a `cond` expression with
    three branches to handle the three possible cases: the initial case where `current`
    is empty; the continuing case, when we are on the same slope as what is in `current`;
    and the slope change case, when we have passed a peak or a valley and we need
    to reset `current`.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的其余部分将围绕一个有三个分支的`cond`表达式来构建，以处理三种可能的情况：`current`为空的初始情况；当我们处于与`current`中相同的斜坡上时的持续情况；以及当我们越过一个山顶或山谷并需要重置`current`的斜坡变化情况。
- en: 'Here is the reducing function:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是减少函数：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In what we referred to above as the "continuing case," when we are at a position
    that prolongs the slope in `current`, we simply subtract the current elevation
    and distance from the first item in `current`. The "slope change" case is slightly
    more complex because we have to reset `current`, taking care to include the latest
    "peak-or-valley." A figure might make this clearer:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们上面提到的“持续情况”中，当我们处于一个延长`current`中斜率的位置时，我们只需从`current`中的第一个项目减去当前的高度和距离。而“斜率变化”的情况稍微复杂一些，因为我们必须重置`current`，并注意包括最新的“峰值或谷值”。一个图可能使这一点更清晰：
- en: '![Figure 5.8: The new current starts at the top of the previous peak'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.8：新的当前值从上一个峰值开始]'
- en: '](img/B14502_05_08.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_05_08.jpg]'
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because we are starting over with a new value in `:current`, instead of `update`,
    we use `assoc`, which replaces the old value entirely.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们在`:current`中重新开始使用新的值，而不是`update`，所以我们使用`assoc`，它完全替换了旧值。
- en: 'Test the function using the following command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令测试函数：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.9: A partial view of the results'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.9：结果的部分视图]'
- en: '](img/B14502_05_09.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_05_09.jpg]'
- en: 'Figure 5.9: A partial view of the results'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：结果的部分视图
- en: In this problem, the most important part of the data is the relationship between
    the items. Problems like this require an approach that allows us to "see" more
    than one item at a time. Unlike the windowing technique we used with map in the
    last chapter, in this problem, we don't know beforehand how far we need to look.
    This is where `reduce` can really shine, because it allows us to shape the accumulator
    to suit the needs of the problem.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，数据最重要的部分是项目之间的关系。这类问题需要一种方法，使我们能够一次“看到”多个项目。与我们在上一章中使用map的窗口技术不同，在这个问题中，我们事先不知道需要查看多远。这正是`reduce`能够大放异彩的地方，因为它允许我们根据问题的需求来调整累加器的形状。
- en: 'Exercise 5.03: Winning and Losing Streaks'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：胜负连串
- en: 'In this exercise, we will start with a vector of all the matches that Serena
    Williams played in 2015\. Each match is represented by a map:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从一个向量开始，这个向量包含了塞雷娜·威廉姆斯在2015年所参加的所有比赛。每一场比赛都由一个映射表示：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You don''t need this data to perform this exercise, but if you''d like to play
    around with the data, it is available here: [https://packt.live/37HKOyC](https://packt.live/37HKOyC).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要这些数据来完成这个练习，但如果你想要玩一下这些数据，它在这里可用：[https://packt.live/37HKOyC](https://packt.live/37HKOyC)。
- en: 'The goal is to add a `:current_streak` field to each match that would say "Lost
    3," if Williams was struggling and had lost her last three matches, or "Won 5":'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是为每一场比赛添加一个`:current_streak`字段，如果威廉姆斯表现不佳并且连续输了三场比赛，它会显示“Lost 3”，或者如果她赢了五场，它会显示“Won
    5”：
- en: 'In a convenient directory, open a REPL and a file called `tennis_reduce.clj`
    with the corresponding namespace definition:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个方便的目录中，打开一个REPL和一个名为`tennis_reduce.clj`的文件，其中包含相应的命名空间定义：
- en: '[PRE27]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Clojure, when a namespace contains more than one word, the words are joined
    by hyphens. The corresponding file, however, must use underscores instead.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Clojure中，当一个命名空间包含多个单词时，这些单词由连字符连接。然而，相应的文件必须使用下划线。
- en: Note
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We'll use this file and namespace for the rest of the tennis-related exercises
    in this chapter.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用这个文件和命名空间来完成本章剩余的与网球相关的练习。
- en: From the course's GitHub repository, in [https://packt.live/2sPo4hv](https://packt.live/2sPo4hv),
    copy the `serena-williams-2015` var into your file.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从课程的GitHub仓库中，在[https://packt.live/2sPo4hv](https://packt.live/2sPo4hv)，将`serena-williams-2015`变量复制到你的文件中。
- en: 'Set up the skeleton of a function based on a call to `reduce`, and provide
    an initializer map:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于对`reduce`的调用设置函数的骨架，并提供一个初始化映射：
- en: '[PRE28]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The map that we provide as an initial value here shows us the form of the data
    we need for each iteration. The counters for current wins and current losses are
    self-explanatory: we''ll just need to update those values depending on what happens
    in each successive match. `:matches` may seem strange at first, though. It is
    there because we want to return the entire sequence of matches, decorated with
    the new `:current-streak` field. Because of Clojure''s immutability, we can''t
    just modify the matches "in place" as we go along. As we move through the items
    in the `matches` list, we add some data to each match and then place it in the
    `:matches` vector in the accumulator.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里提供的映射作为初始值显示了我们需要为每次迭代的数据形式。当前胜利和当前失败的计数器是自解释的：我们只需根据每场连续比赛发生的情况更新这些值。`:matches`
    可能一开始看起来很奇怪。它存在是因为我们希望返回整个匹配序列，并带有新的 `:current-streak` 字段。由于 Clojure 的不可变性，我们不能像通常那样“就地”修改匹配项。当我们遍历
    `matches` 列表中的项时，我们为每个匹配项添加一些数据，然后将其放置在累加器中的 `:matches` 向量中。
- en: 'Extract the matches from the call to `reduce`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对 `reduce` 的调用中提取匹配项：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `:current-wins` and `:current-losses` fields aren't useful outside of the
    function, so we want to only return the newly decorated matches.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:current-wins` 和 `:current-losses` 字段在函数外部没有用，所以我们只想返回新装饰的匹配项。'
- en: 'Write a helper function that formats a string for presenting the current streak:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个辅助函数，用于格式化字符串以展示当前连胜：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are three possible situations: a winning streak (at least one win, zero
    losses), a losing streak (at least one loss, zero wins) or no matches played yet
    (zero wins, zero losses). This is a good time to use `cond`, which allows us to
    have multiple conditions without using nested `if` statements. The test for the
    final catch-all condition could be anything at all, except `false` or `nil`. We
    use the `:otherwise` keyword because it is easy to read. And finally, `pos?` is
    a handy and commonly used predicate for determining whether a number is above
    zero, rather than writing `(> current-wins 0)`.'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有三种可能的情况：连胜（至少一场胜利，零场失败）、连败（至少一场失败，零场胜利）或尚未进行任何比赛（零场胜利，零场失败）。现在是使用 `cond` 的好时机，它允许我们拥有多个条件而不需要嵌套的
    `if` 语句。最终通配条件测试可以是任何东西，除了 `false` 或 `nil`。我们使用 `:otherwise` 关键字因为它易于阅读。最后，`pos?`
    是一个方便且常用的谓词，用于确定一个数字是否大于零，而不是编写 `(> current-wins 0)`。
- en: This logic could have been part of the main reducing function. Breaking it out
    into its own, very simple function makes for easier-to-read code.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种逻辑原本可以是主减少函数的一部分。将其拆分为一个独立的、非常简单的函数可以使代码更容易阅读。
- en: 'Write a skeleton for the reducing function. As usual, it takes two arguments:
    the accumulator, `acc`, and the current match. All we do here is some destructuring
    so that we''ll have easy access to this context inside the function. We also keep
    references to the original maps, `acc` and `match`, because our function will
    end up returning modified versions of them:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为减少函数编写一个骨架。像往常一样，它接受两个参数：累加器 `acc` 和当前匹配项。我们在这里所做的只是进行一些解构，以便在函数内部轻松访问此上下文。我们还保留了原始映射
    `acc` 和 `match` 的引用，因为我们的函数最终将返回它们的修改版本：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Introduce a `let` binding for the current match and insert it into the `:matches`
    vector in the accumulator:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为当前匹配项引入一个 `let` 绑定并将其插入累加器中的 `:matches` 向量：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even though our function isn't complete yet, this is the most important part
    of the data flow. The `match` argument is "decorated" with the current streak
    information formatted by the `streak-string` helper function and then inserted
    into the `:matches` vector that the function will return at the end. We don't
    have the contextual information yet, so that is the next step.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们的函数还没有完成，但这是最重要的数据流部分。`match` 参数被 `streak-string` 辅助函数格式化的当前连胜信息“装饰”，然后插入到函数最终将返回的
    `:matches` 向量中。我们还没有上下文信息，所以这是下一步。
- en: 'The final step here is to produce the contextual information: we need to update
    `:current-wins` and `:current-losses` in the accumulator so that we''re ready
    for the next iteration. The logic here is that if Williams won the current match,
    then we need to add 1 to the current streak and set the losing streak to zero.
    These will be used for calculating the winning and losing streaks for the next
    match. Conversely, if Williams lost the previous match, we set the current winning
    streak to zero and add 1 to the losing streak.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是生成上下文信息：我们需要更新累加器中的 `:current-wins` 和 `:current-losses`，以便我们为下一次迭代做好准备。这里的逻辑是，如果威廉姆斯赢得了当前比赛，那么我们需要将当前连胜数加
    1 并将输球数重置为零。这些将用于计算下一场比赛的胜利和失败连败。相反，如果威廉姆斯输掉了上一场比赛，我们将当前胜利连败数设为零，并将输球连败数加 1。
- en: 'To translate this logic into code, we''ll start by adding another `let` binding,
    `serena-victory?`, that we will refer to later:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了将这个逻辑转换为代码，我们首先添加另一个 `let` 绑定，`serena-victory?`，稍后我们将引用它：
- en: '[PRE33]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now all that remains is updating `:current-wins` and `:current-losses` in `acc`.
    We''ll use the `->` threading macro because there are several things that need
    to be done to our accumulator:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在剩下的只是更新 `acc` 中的 `:current-wins` 和 `:current-losses`。我们将使用 `->` 连接宏，因为需要对累加器做一些事情：
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The calls to `assoc` just apply the conditional logic discussed above, incrementing
    the counters or resetting them to zero. Here is the complete function when we
    put all the parts back together:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`assoc` 的调用只是应用了上面讨论的条件逻辑，增加计数器或将它们重置为零。以下是当我们把所有部分放在一起时的完整函数：'
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Try the function on the data. You should see something like this:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在数据上尝试这个函数。你应该会看到类似这样的结果：
- en: '![Figure 5.10: Using the function on data'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：在数据上使用函数'
- en: '](img/B14502_05_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_10.jpg)'
- en: 'Figure 5.10: Using the function on data'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：在数据上使用函数
- en: This example shows us a couple of different interesting things about using `reduce`.
    The first point is that we are free to create whatever kind of context we would
    like to pass on to each successive iteration of the reducing function. To make
    things simple in this case, we just counted the number of wins or losses, but
    the context can be just as complex as you need it to be.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了使用 `reduce` 的几个有趣之处。首先，我们可以自由地创建任何类型的上下文，并将其传递给减少函数的每一次迭代。为了使事情简单起见，我们只是计算了胜利或失败的数量，但上下文可以像你需要的那样复杂。
- en: 'The second point is that the ultimate return value can also be whatever we
    need it to be. The function in this example actually looks like something you
    might do with `map`: it takes a sequence and returns a sequence of the same length.
    Yet, by building up data from previous calls to the reducing function, it does
    something that `map` would be unable to do.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是指最终返回值也可以是我们需要的任何值。在这个例子中的函数实际上看起来像是你可以用 `map` 做的事情：它接受一个序列并返回一个长度相同的序列。然而，通过从之前对减少函数的调用中构建数据，它做了
    `map` 无法做到的事情。
- en: Reducing without reduce
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用 reduce 的减少
- en: Before we go any further, it's important to point out that sometimes there are
    other, better options than `reduce` for taking a sequence and turning it into
    something non-sequential. Often, this is because Clojure provides functions that
    do the hard work for us. Sometimes, clever use of Clojure's "sequence-to-sequence"
    functions can get you the data you need.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，重要的是要指出，有时在将序列转换为非序列时，除了 `reduce` 之外，还有其他更好选择。这通常是因为 Clojure 提供了为我们做艰苦工作的函数。有时，巧妙地使用
    Clojure 的“序列到序列”函数可以让你得到所需的数据。
- en: As a general rule, it is usually preferable to do as much as possible with functions
    that can handle lazy sequences before turning to `reduce`. In some cases, this
    can be for performance reasons, and in nearly all cases, your code will be easier
    to write, and, more importantly, *to read*, if you can stay in the realm of sequences.
    That said, most solutions will require a little of both. Knowing how to combine
    the two is an important skill.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，在转向 `reduce` 之前，通常最好尽可能多地使用可以处理惰性序列的函数。在某些情况下，这可能是因为性能原因，在几乎所有情况下，如果你的代码可以保持在序列的领域，你的代码将更容易编写，更重要的是，*更容易阅读*。尽管如此，大多数解决方案都需要两者都有一点。知道如何结合两者是一项重要的技能。
- en: zipmap
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zipmap
- en: Clojure's `zipmap` function is a tool for building a map from two sequences.
    The first sequence becomes the keys for the new map and the second becomes the
    values. This is often useful for building a lookup table. Lookup tables can be
    convenient when you need to repeatedly access data in a sequence based on its
    content rather than its position in the list.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 的 `zipmap` 函数是一个从两个序列构建映射的工具。第一个序列成为新映射的键，第二个序列成为值。这通常用于构建查找表。当需要根据内容而不是列表中的位置重复访问序列中的数据时，查找表会非常方便。
- en: It's easy to imagine a scenario where this would be useful. Maybe at one step
    in a program, you have a list of maps, each one containing contact data for a
    person. Later, you discover that you often have a telephone number and need to
    find the corresponding user. If you have a lookup table where the keys are telephone
    numbers, you can find a user with a simple `(get users-by-phone "+44 011 1234
    5678")`. Maps provide easy access, as long as you have meaningful and unique keys.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象一个这样的场景，这会很有用。也许在程序的一个步骤中，你有一个包含个人联系数据的映射列表。后来，你发现你经常需要电话号码并需要找到相应的用户。如果你有一个键为电话号码的查找表，你可以通过简单的
    `(get users-by-phone "+44 011 1234 5678")` 找到用户。只要你有有意义且唯一的键，映射就可以提供方便的访问。
- en: 'The basic operation of `zipmap` is to align two sequences, one for the keys
    and one for the values, which `zipmap` will "zip" together:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipmap` 的基本操作是对齐两个序列，一个用于键，一个用于值，`zipmap` 将它们“压缩”在一起：'
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Often, you will only have the second list, the values. You will derive values
    from the list and use them as the keys. Just be careful that the keys are unique
    to avoid collisions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只有第二个列表，即值。你将从列表中推导出值并将它们用作键。只是要小心，键必须是唯一的，以避免冲突。
- en: 'Exercise 5.04: Creating a Lookup Table with zipmap'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04：使用 zipmap 创建查找表
- en: Maps are an extremely useful and flexible way to quickly access data. Often,
    however, the data you have is sequential and you find that you would like to be
    able to access an individual item without having to walk the entire sequence.
    If you know the criteria that you'll use to look up the item you need, building
    a lookup table from your data can be an interesting solution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种极其有用且灵活的方法，可以快速访问数据。然而，通常你拥有的数据是顺序的，你可能会发现你希望能够访问单个项目而不必遍历整个序列。如果你知道你将使用的查找所需项目的标准，从你的数据中构建查找表可以是一个有趣的解决方案。
- en: 'In this exercise, you have a list of some of the matches that Petra Kvitova
    played in 2014\. Let''s suppose you need to be able to quickly access the matches
    by date, perhaps to be able to plug them into a calendar of some kind or to test
    which players were playing on the same day. Whatever the reason, you need to build
    a map where the keys are dates and the values are the individual matches. Because
    the same player never plays two matches on the same day, we can be sure that the
    date keys are unique. Here''s how to build the lookup table:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你有一些 Petra Kvitova 在 2014 年参加的匹配列表。假设你需要能够快速通过日期访问匹配项，可能需要将它们插入某种类型的日历或测试同一天有哪些选手在比赛。无论原因如何，你需要构建一个映射，其中键是日期，值是单个匹配项。因为同一个选手永远不会在同一天打两场比赛，我们可以确信日期键是唯一的。以下是构建查找表的方法：
- en: 'Copy the following var into your REPL from the book''s GitHub repository: [https://packt.live/39Joc2H](https://packt.live/39Joc2H):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变量从书的 GitHub 仓库复制到你的 REPL 中：[https://packt.live/39Joc2H](https://packt.live/39Joc2H)：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use `map` to create a sequence with a date from each match:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `map` 创建一个包含每个匹配项日期的序列：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Combine both sequences into a single map:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个序列合并成一个映射：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the map to look up a match by date:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用映射通过日期查找匹配项：
- en: '[PRE40]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In a single line of code, you've created a way to quickly find a match for a
    given day. Because it's so concise, this pattern can easily be integrated into
    a more complex function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行代码中，你已经创建了一种快速找到给定日期匹配的方法。因为它非常简洁，这种模式可以很容易地集成到更复杂的函数中。
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Building a lookup table like this might seem wasteful in terms of memory resources.
    Aren't we doubling the amount of data in memory? Actually, we aren't. Clojure's
    immutable data structures efficiently share data, which is possible without conflict
    because the data cannot be modified. This means that, in this example, the original
    sequence and the lookup table we've created are basically two ways of accessing
    the same data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 建立这样的查找表在内存资源方面可能看起来是浪费的。我们不是在内存中加倍数据量吗？实际上，我们并没有。Clojure的不可变数据结构有效地共享数据，这是在不冲突的情况下实现的，因为数据不能被修改。这意味着在这个例子中，原始序列和我们创建的查找表基本上是访问相同数据的方式。
- en: Maps to Sequences, and Back Again
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射到序列，再回到映射
- en: 'One of the most useful techniques is one that we mentioned briefly in the last
    chapter: using `into` to build a map from a list of paired items. This pattern
    is so versatile that it''s worth taking a closer look.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中简要提到的一种最有用的技术是使用`into`从成对的项列表构建映射。这种模式非常灵活，值得仔细研究。
- en: 'In its simplest form, the pattern looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，这个模式看起来是这样的：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Maps, after all, are really just data pairs, and Clojure knows how to convert
    between the two. It''s just as easy to make a sequence of tuples from a map:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，映射实际上只是数据对，Clojure知道如何在这两者之间进行转换。从映射中创建元组序列同样简单：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Use a map as a map when that makes sense, but don't hesitate to use it as a
    sequence whenever that's easier.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用映射作为映射有意义时，请使用它，但不要犹豫，当使用它作为序列更容易时，就使用它。
- en: 'When you need to "modify" a map (in the Clojure sense of not actually modifying,
    but creating a new map with modified data), you may be tempted to use the `keys`
    function to iterate through the values in the map:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要“修改”一个映射（在Clojure中不是真正修改，而是创建一个新的映射，其中包含修改后的数据）时，你可能倾向于使用`keys`函数来遍历映射中的值：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we''ve used `reduce` to multiply each of the values by 10\. This works,
    but it adds complexity and mental overhead to a problem that can be solved more
    easily:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`reduce`将每个值乘以10。这可行，但它增加了问题的复杂性和心理负担，而这个问题可以更容易地解决：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We simply interpret the map, `letters-and-numbers`, as a list of key-value pairs.
    In the function supplied to `map`, we've used destructuring to assign `k` and
    `v` to the key and value inside the tuple, which we then wrap up again in a two-item
    vector. Thanks to `into`, we get a map back again in the end.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将映射`letters-and-numbers`解释为键值对的列表。在提供给`map`的函数中，我们使用了解构来将`k`和`v`分配给元组内的键和值，然后我们再次将其包装在两个元素的向量中。多亏了`into`，我们最终又得到了一个映射。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For convenience, there is another version of `reduce` specifically for iterating
    through the key-value pairs in a map, called `reduce-kv`. The main difference
    is that with `reduce-kv`, the reducing function that you provide takes three arguments,
    instead of two: the first is the same as `reduce`, but the next two are the key
    and the corresponding value in the map.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，还有一个专门用于遍历映射中的键值对的`reduce`版本，称为`reduce-kv`。主要区别在于，使用`reduce-kv`时，你提供的减少函数接受三个参数，而不是两个：第一个与`reduce`相同，但下一个是映射中的键和相应的值。
- en: group-by
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: group-by
- en: Summarizing data in Clojure doesn't always mean calling `reduce` directly. The
    language provides functions that are built on top of `reduce` that are sometimes
    more convenient. `group-by` is one of those functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中总结数据并不总是意味着直接调用`reduce`。该语言提供了构建在`reduce`之上的函数，有时这些函数更方便。`group-by`就是其中之一。
- en: The `group-by` function takes a sequence, calls a function on each item, and
    uses whatever the function call returns as a key in a map. The value of the key
    will be a list of all the items that returned the same key.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`group-by`函数接受一个序列，对每个项目调用一个函数，并使用函数调用返回的任何内容作为映射中的键。键的值将是返回相同键的所有项目的列表。'
- en: 'Let''s say that we have a list of maps where each map represents a dish, with
    a `:name` key for the dish''s name, and a `:course` field that tells us what part
    of the meal the dish is served at:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个映射列表，其中每个映射代表一道菜，有一个`:name`键用于菜名，还有一个`:course`字段告诉我们这道菜是在餐的哪个部分上提供的：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With `group-by`, we can organize this list by category. The function we call
    on each item will just be the `:course` keyword, to extract the corresponding
    value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`group-by`，我们可以按类别组织这个列表。我们对每个项目调用的函数只是`:course`关键字，以提取相应的值：
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For most of our examples, we use keywords as map keys. This is usually more
    readable and provides the convenience of using keywords as functions. However,
    Clojure allows us to use any value as map keys. Just like we''ve been using strings
    for the names of tennis players, you can also use any Clojure value as a map key:
    integers, vectors, maps, even functions!'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的大部分示例，我们使用关键字作为映射键。这通常更易于阅读，并提供了使用关键字作为函数的便利性。然而，Clojure允许我们使用任何值作为映射键。就像我们一直使用字符串作为网球运动员的名字一样，你也可以使用任何Clojure值作为映射键：整数、向量、映射，甚至是函数！
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With *very* little coding, we have a nicely organized map. `group-by` uses
    `reduce` under the hood and really just encapsulates a fairly simple pattern.
    We could write a simplified version of `group-by` like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*非常*少的编码，我们得到了一个组织良好的映射。`group-by`在底层使用`reduce`，实际上只是封装了一个相当简单的模式。我们可以像这样编写`group-by`的简化版本：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we call `our-group-by` on the list of dishes, we get the same results:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在菜肴列表上调用`our-group-by`，我们会得到相同的结果：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The official version will have better performance, but the real advantage of
    a function like `group-by` is that it frees us from thinking about the details.
    Any time you have a list and some categories, `group-by` is ready to help.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 官方版本将具有更好的性能，但像`group-by`这样的函数真正的优势是它使我们从细节中解放出来。任何时候你有一个列表和一些类别，`group-by`都准备好帮助你。
- en: 'Exercise 5.05: Quick Summary Statistics with group-by'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：使用group-by进行快速汇总统计
- en: 'In this exercise, we''ll use `group-by` to quickly count the number of matches
    played in different tournaments in our tennis match data:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`group-by`来快速统计我们网球比赛数据中不同锦标赛进行的比赛数量：
- en: 'In the same directory as *Exercise 5.03*, *Winning and Losing Streaks*, create
    a `deps.edn` file with the following content:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与*练习5.03*，*赢和输的连败*相同的目录下创建一个`deps.edn`文件，内容如下：
- en: '[PRE49]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Change the namespace declaration in `tennis_reduce.clj` so that it references
    these two new libraries:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`tennis_reduce.clj`中的命名空间声明更改，使其引用这两个新库：
- en: '[PRE50]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Start a REPL in the same directory as the previous exercise, with the same `deps.edn`,
    and then open and evaluate `tennis_reduce.clj`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与上一个练习相同的目录下启动一个REPL，使用相同的`deps.edn`文件，然后打开并评估`tennis_reduce.clj`。
- en: 'In your REPL, move to the `packt-clj.tennis-reduce` namespace as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的REPL中，移动到`packt-clj.tennis-reduce`命名空间，如下所示：
- en: '[PRE51]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Make sure that you have the `match_scores_1968-1990_unindexed_csv.csv` file
    in the same directory. This is the same data file we used in *Chapter 4*, *Mapping
    and Filtering*. You can find it here: [https://packt.live/36k1o6X](https://packt.live/36k1o6X).'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你有一个`match_scores_1968-1990_unindexed_csv.csv`文件在相同的目录下。这是我们*第4章*，*映射和过滤*中使用的相同数据文件。你可以在这里找到它：[https://packt.live/36k1o6X](https://packt.live/36k1o6X)。
- en: 'Set up the now familiar `with-open` macro that we''ve used before, and give
    your function an expressive name:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置现在熟悉的`with-open`宏，并给你的函数一个有表达力的名字：
- en: '[PRE52]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write a call to `group-by` that builds a map where the keys are the `:tourney_slug`
    instances and the values are the lists of matches played there. To make the output
    more manageable, temporarily remove all but a few keys in the match maps by mapping
    over the list with `select-keys`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个调用`group-by`的代码，构建一个键为`:tourney_slug`实例，值为在该地进行的比赛列表的映射。为了使输出更易于管理，可以通过`select-keys`映射列表来临时移除比赛映射中的所有但少数键：
- en: '[PRE53]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Evaluate the source file and then try calling this function. Define a var so
    that your screen doesn''t fill up with tennis match data:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估源文件，然后尝试调用此函数。定义一个变量，这样你的屏幕就不会充满网球比赛数据：
- en: '[PRE54]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Examine some of the data, first by using the `keys` function, to see all the
    tournament names:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一些数据，首先使用`keys`函数，以查看所有锦标赛的名称：
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Look at a single tournament. Once again, limit the data returned, this time
    by using `take`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一个单独的锦标赛。再次限制返回的数据，这次使用`take`：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use `count` to obtain the number of matches played in a single tournament:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`count`来获取单个锦标赛进行的比赛数量：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Calculate the total number of matches played in each tournament using `count`
    in the original function:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始函数中的`count`计算每个锦标赛进行的总比赛数：
- en: '[PRE58]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that `select-keys` is gone. Since we are reducing the lists of matches
    to a single integer, there is no point in removing any fields. Here, we use a
    pattern that you have seen before: the call to `map` treats the Clojure map as
    if it were a sequence of key-value pairs. The function passed to `map` then returns
    a two-item vector with the keyword and the newly calculated total. And finally,
    `into` repackages the sequence back into a map.'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`select-keys`已经消失了。由于我们将比赛列表减少为一个单一整数，删除任何字段都没有意义。在这里，我们使用了一个你之前见过的模式：`map`的调用将Clojure映射视为键值对的序列。传递给`map`的函数然后返回一个包含关键字和新生成的总数的两项向量。最后，`into`将序列重新包装成一个映射。
- en: 'Evaluate the file again and call `tennis-csv→tournament-match-counts` again:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次评估文件并再次调用`tennis-csv→tournament-match-counts`：
- en: '[PRE59]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inspect the data:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数据：
- en: '[PRE60]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here we see that the Grand Slam tournaments have the exact same number of matches
    over the same period, because these seven-round tournaments are structured identically.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到大满贯赛事在同一时期内拥有相同数量的比赛，因为这些七轮赛事的结构是完全相同的。
- en: In this exercise, we were able to extract the data we wanted in a few short
    lines of code. Beyond illustrating the power of `group-by`, this is a good example
    of how mapping and reducing can work together. We used `group-by` to structure
    our data, and then `map` to shape it some more. It's easy to imagine using `filter`
    as well, if we wanted to limit the scope of our inquiry to certain players or
    certain tournaments, for example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够用几行简短的代码提取我们想要的数据。除了展示`group-by`的强大功能外，这也是映射和减少如何一起工作的一个好例子。我们使用`group-by`来结构我们的数据，然后使用`map`来进一步塑造它。如果我们想限制调查的范围为某些球员或某些赛事，例如，使用`filter`也很容易想象。
- en: Summarizing Tennis Scores
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结网球比分
- en: In the previous chapter, we were able to generate some summary data from the
    tennis scores, using `filter`. If we wanted to know how many matches a particular
    player had won, we could filter out that player's victories and call `count`.
    While this approach works well when we are only interested in one player, it becomes
    cumbersome if we want more complete data. For example, if we needed to know the
    number of matches played or won by *each* of the players in the dataset, we would
    have to filter, for each query, the entire history of all the matches. The `map`
    and `filter` functions are extremely useful in many situations, but reducing a
    large collection down into a more compact report is not what they are best for.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们能够使用`filter`从网球比分中生成一些总结数据。如果我们想知道特定球员赢得了多少场比赛，我们可以过滤掉该球员的胜利并调用`count`。虽然当我们的兴趣仅限于一个球员时这种方法效果很好，但如果我们需要更完整的数据，它就会变得繁琐。例如，如果我们需要知道数据集中每位球员参加或赢得的比赛数量，我们就必须为每个查询过滤所有比赛的整个历史。`map`和`filter`函数在许多情况下非常有用，但将大量集合减少为一个更紧凑的报告并不是它们最擅长的。
- en: Let's suppose that for each player, we need to know the number of matches played,
    won, and lost. We'll walk through two different ways to solve the problem in Clojure,
    the first using `reduce` and the second using `group-by`, one of Clojure's many
    convenient `reduce`-based functions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于每位球员，我们需要知道他们所参加的比赛数量、赢得的比赛数量和输掉的比赛数量。我们将通过两种不同的方式在Clojure中解决这个问题，第一种是使用`reduce`，第二种是使用`group-by`，这是Clojure众多方便的基于`reduce`的功能之一。
- en: In the first exercise, we will use a common reducing pattern to build up our
    data, row by row, from the CSV file. Of course, we'll use the three-argument version
    of `reduce` with a map as the accumulator.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，我们将使用一种常见的减少模式，逐行从CSV文件构建我们的数据。当然，我们将使用带有映射作为累加器的三参数版本的`reduce`。
- en: 'Exercise 5.06: Complex Accumulation with reduce'
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.06：使用reduce进行复杂累积
- en: 'For each row of CSV in the tennis dataset we''ve been using, the work we need
    to do is rather simple: count the wins and losses. In an imperative language,
    the most common approach would be to loop over the results, and for each line
    do something like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们一直在使用的网球数据集中的每一行CSV，我们需要完成的工作相当简单：计算胜利和失败的数量。在命令式语言中，最常见的方法是遍历结果，并对每一行执行类似以下操作：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will do essentially the same thing in Clojure, but within the scope of a
    function passed to `reduce`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Clojure中做同样的事情，但这是在传递给`reduce`的函数的作用域内：
- en: 'Open `tennis_reduce.clj`, start your REPL, evaluate the file, and move to the
    `packt-`Copy in the `with-open` pattern that we''ve used before and prepare the
    skeleton of a call to `reduce`. We''ll call this function `win-loss-by-player`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `tennis_reduce.clj`，启动你的 REPL，评估文件，然后移动到 `with-open` 模式中的 `packt-`Copy，并准备对
    `reduce` 的调用框架。我们将把这个函数称为 `win-loss-by-player`：
- en: '[PRE62]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We won't need the call to `sc/cast-with` this time, since the only values we
    need are strings. And we don't need to call `doall` either, because `reduce` is
    not lazy.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次我们不需要调用 `sc/cast-with`，因为我们只需要字符串值。而且我们也不需要调用 `doall`，因为 `reduce` 不是惰性的。
- en: 'Write the function to pass to `reduce`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写传递给 `reduce` 的函数：
- en: '[PRE63]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we use `->` to thread the accumulator, `acc`, through two calls to `update-in`.
    This function, like `assoc-in`, allows us to access the content of a nested data
    structure by providing a vector as a second argument. Each call in this example
    would look like this:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `->` 来将累加器 `acc` 通过两次调用 `update-in`。这个函数，就像 `assoc-in` 一样，允许我们通过提供一个向量作为第二个参数来通过访问嵌套数据结构的内容。这个例子中的每个调用看起来会是这样：
- en: '[PRE64]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'By repeatedly calling this on the accumulator as `reduce` moves through the
    list of matches, we end up with a large map of player "slugs" mapped to small
    maps each containing a `:wins` key and a `:losses` key:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在 `reduce` 遍历比赛列表时重复调用累加器，我们最终得到一个大型映射，将玩家 "slugs" 映射到包含 `:wins` 键和 `:losses`
    键的小映射：
- en: '[PRE65]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Evaluate your file and try running the function on the CSV data. Put the results
    in a var to avoid filling up your screen with all the data:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估你的文件并尝试在 CSV 数据上运行该函数。将结果放入变量中，以避免在屏幕上填充所有数据：
- en: '[PRE66]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Look up a player, using the "slug":'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 "slug" 查找玩家：
- en: '[PRE67]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use `get` here because the keys in our map are strings. If we had
    used the `keyword` function to convert the player "slugs" when building up the
    map, we could access a player's data with `(:roger-federer w-l)` instead.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里需要使用 `get`，因为我们的映射中的键是字符串。如果我们使用 `keyword` 函数在构建映射时转换玩家的 "slugs"，我们可以使用
    `(:roger-federer w-l)` 来访问玩家的数据。
- en: Introduction to Elo
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elo 介绍
- en: In the rest of this chapter, and in some of the following chapters, we are going
    to be working with the Elo Rating System to develop player ratings and predict
    match outcomes. The algorithm itself is quite simple and it will allow us to demonstrate
    how Clojure can be used as a data analysis tool. Since we'll be referring to it
    a lot, it's worth taking a closer look at how it works. The Elo Rating System
    was developed by Arpad Elo to rate chess players. The United States Chess Federation
    began using it in 1960.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分以及接下来的几章中，我们将使用 Elo 评分系统来开发玩家评分并预测比赛结果。该算法本身相当简单，它将允许我们展示 Clojure 可以用作数据分析工具。由于我们将大量引用它，因此值得仔细看看它是如何工作的。Elo
    评分系统是由 Arpad Elo 为棋手评分而开发的。美国棋艺联合会从 1960 年开始使用它。
- en: Elo ratings work by establishing a score for each player. This score is used
    to calculate the probable outcome of a match. When the real outcome of the match
    is known, a player's rating is raised or lowered depending on their performance
    relative to the probable outcome. In other words, if a beginner with a low rating
    loses to a higher-rated player, the beginner's rating will not suffer by much,
    since that outcome was expected. If they defeat the higher-rated player, on the
    other hand, their rating will increase by a much greater margin, and the higher-rated
    player's rating will be diminished accordingly.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Elo 评分通过为每个玩家建立一个分数来实现。这个分数用于计算比赛的预期结果。当比赛的真实结果已知时，玩家的评分会根据他们的表现相对于预期结果而上升或下降。换句话说，如果一个低评分的新手输给了高评分的玩家，新手的评分不会下降太多，因为这种结果是可以预见的。另一方面，如果他们击败了高评分的玩家，他们的评分将大幅上升，而高评分玩家的评分将相应地降低。
- en: 'The obvious question is, of course, how do we know a player''s rating to start
    with? This requires looking at their previous matches, and the rating of their
    opponents, which, in turn, are determined by the ratings of *their* opponents,
    and so on. If that sounds recursive, it''s because it is. Our strategy will take
    the form of a complex reduction: starting at the earliest match, we will accumulate
    player ratings, which we will then use to calculate the scores for each successive
    match:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 显然的问题当然是，我们最初是如何知道一个玩家的评分的？这需要查看他们的先前比赛，以及对手的评分，而这些对手的评分反过来又是由他们的对手的评分决定的，以此类推。如果这听起来像是递归的，那是因为它确实是。我们的策略将采取复杂简化的形式：从最早的比赛开始，我们将累积玩家的评分，然后我们将使用这些评分来计算每场后续比赛的分数：
- en: '![Figure 5.11: Reducing from match to match: each result improves the ratings
    for the next match'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：从一场比赛到下一场比赛的评分降低：每次结果都会提高下一场比赛的评分'
- en: '](img/B14502_05_11.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_11.jpg)'
- en: 'Figure 5.11: Reducing from match to match: each result improves the ratings
    for the next match'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：从一场比赛到下一场比赛的评分降低：每次结果都会提高下一场比赛的评分
- en: 'Does this look familiar? It might, because we are doing the same thing as in
    the previous reductions: calculating a context, moving it forward, and using it
    again for the next calculation. The difference with this project is that the context
    is much more complex. Our method for moving through the data is fundamentally
    the same.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？可能是因为我们正在做与之前减少相同的事情：计算上下文，将其向前移动，并再次用于下一次计算。与这个项目不同的是，上下文要复杂得多。我们通过数据的方法在本质上是一样的。
- en: 'Before we can perform this reduction, we need to build a few key pieces of
    the Elo implementation. At the heart of the Elo system is a simple formula for
    determining the probability of a player winning a given match. It looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够执行这个降低操作之前，我们需要构建 Elo 实现的一些关键部分。Elo 系统的核心是一个简单的公式，用于确定玩家赢得特定比赛的概率。它看起来是这样的：
- en: '![Figure 5.12: Calculating the probability of outcomes for a given match'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12：计算给定比赛的结局概率'
- en: '](img/B14502_05_12.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_12.jpg)'
- en: 'Figure 5.12: Calculating the probability of outcomes for a given match'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：计算给定比赛的结局概率
- en: '*P*1 and *P*2 here are the probabilities of winning for player one and player
    two. *R*1 and *R*2 are their respective ratings before the match.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*1 和 *P*2 这里是玩家一和玩家二获胜的概率。*R*1 和 *R*2 是他们在比赛前的相应评分。'
- en: 'If we fill in the values for a match between a player, rated at 700, and a
    stronger player, rated at 1,000, we get the following results:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为一名评分为 700 的玩家和一名评分为 1,000 的更强玩家之间的匹配填充值，我们得到以下结果：
- en: '![Figure 5.13: Example Elo calculation for a single match'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13：单场比赛的 Elo 计算示例'
- en: '](img/B14502_05_13.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_13.jpg)'
- en: 'Figure 5.13: Example Elo calculation for a single match'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：单场比赛的 Elo 计算示例
- en: The *P*1 value indicates that there is a 15% chance that the weaker player will
    win the match and an 85% chance that the stronger player will win. The reliability
    of these percentages depends, of course, on the quality of the ratings. Before
    we look at how the ratings are calculated, though, let's translate these equations
    into Clojure functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*1 值表示较弱玩家赢得比赛的概率为 15%，较强玩家赢得比赛的概率为 85%。这些百分比的可靠性当然取决于评分的质量。然而，在我们查看评分是如何计算之前，让我们将这些方程式转换为
    Clojure 函数。'
- en: 'Exercise 5.07: Calculating Probabilities for a Single Match'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.07：计算单场比赛的概率
- en: 'In this exercise, we''ll set up one of the building blocks for our implementation
    of the Elo system, the formula for calculating the probabilities of victory for
    each of the two players in a match, based on their current ratings:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们的 Elo 系统实现设置一个构建块，即计算两名玩家在比赛中获胜概率的公式，基于他们当前的评分：
- en: 'In the same folder as in the previous exercises, add `math.numeric-tower`,
    which is Clojure''s standard `math` library, to your `deps.edn` file. It should
    look like this now:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与之前练习相同的文件夹中，将 `math.numeric-tower`，这是 Clojure 的标准 `math` 库，添加到您的 `deps.edn`
    文件中。现在它应该看起来像这样：
- en: '[PRE68]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In `tennis_reduce.clj`, update the namespace declaration:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `tennis_reduce.clj` 中更新命名空间声明：
- en: '[PRE69]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Open a REPL session, evaluate `tennis_reduce.clj`, and move to the `packt-clj.tennis-reduce`
    namespace.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 REPL 会话，评估 `tennis_reduce.clj`，并移动到 `packt-clj.tennis-reduce` 命名空间。
- en: 'Write a function implementing the formula for calculating the probability of
    a player defeating another player:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来实现计算玩家击败另一名玩家概率的公式：
- en: '[PRE70]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Try your function with players of different strengths:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用不同强度的玩家尝试你的函数：
- en: '[PRE71]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When the match is finally played, if the strong player wins, their rating will
    increase modestly (and their opponent's rating will go down slightly) because
    the result was not a surprise. If the weaker player wins, on the other hand, the
    change to the ratings will be much more significant.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当比赛最终进行时，如果强手获胜，他们的评分将适度增加（而对手的评分将略有下降），因为结果并不令人惊讶。另一方面，如果弱手获胜，评分的变化将更加显著。
- en: 'This equation shows how the player''s score is updated after a match:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程式显示了比赛后玩家分数是如何更新的：
- en: '![Figure 5.14: Equation to calculate the player’s score'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14：计算玩家分数的方程式'
- en: '](img/B14502_05_14.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_14.jpg)'
- en: 'Figure 5.14: Equation to calculate the player''s score'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：计算选手得分的方程
- en: A player's new rating (*R'*) is based on their previous rating (*R*), the match
    score (*S*), the expected score (*ES*), and the *K* factor.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 选手的新评级（*R'*）基于他们的前一个评级（*R*），比赛得分（*S*），预期得分（*ES*）和*K*因子。
- en: The score (*S*) of a tennis match is either 0, for a loss, or 1, for a victory.
    If a player is expected to win by a probability of 0.75 and they go on to win
    their match, then the (*S* - *ES*) part of the equation works out to 1 - 0.75
    = 0.25\. This result gets multiplied by what the Elo system calls the "*K* factor."
    The *K* factor determines the impact of a match result on a player's overall rating.
    A high *K* factor means ratings will move around a lot; a low *K* factor means
    they will be more stable. If we use a *K* factor of 32, that gives us 32 * 0.25
    = 8, so the player's rating in this example would go up by eight points. If the
    player had lost instead, we would get 32 * (0 - 0.75) = -24\. Once again, unexpected
    results thus have a much greater impact on ratings.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 网球比赛的得分（*S*）要么为0（输球），要么为1（胜利）。如果一个选手预计以0.75的概率获胜，并且他们最终赢得了比赛，那么方程中的(*S* - *ES*)部分计算为1
    - 0.75 = 0.25。这个结果会被Elo系统称为"*K*因子"的乘数。*K*因子决定了比赛结果对选手整体评级的影响。高*K*因子意味着评级会有很大的波动；低*K*因子意味着它们会更稳定。如果我们使用*K*因子为32，那么我们得到32
    * 0.25 = 8，所以在这个例子中，选手的评级将上升8分。如果选手输了，我们会得到32 * (0 - 0.75) = -24。再次强调，意外结果对评级的影响要大得多。
- en: 'Exercise 5.08: Updating Player Ratings'
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.08：更新选手评级
- en: 'In this exercise, we will update the player ratings:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新选手评级：
- en: 'In the same file and REPL session as the previous exercise, define a `k-factor`
    var and a function that encapsulates the equation for updating a player''s rating
    after a match:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与上一个练习相同的文件和REPL会话中，定义一个`k-factor`变量和一个封装更新选手评级方程的函数：
- en: '[PRE72]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, let's test the equation with some outputs from the `match-probability`
    function that we defined earlier.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们用之前定义的`match-probability`函数的一些输出测试这个方程。
- en: 'A player rated 1,500 loses to a slightly weaker player (1,400):'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评级为1,500分的选手输给了略弱一些的选手（1,400分）：
- en: '[PRE73]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The player's rating has gone down by almost 21 points.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选手的评级下降了近21分。
- en: 'A player with a low rating, 400, scores an upset victory against a strong player (1,000):'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评级较低的选手，400分，击败了强大的选手（1,000分）：
- en: '[PRE74]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, the supposedly weaker player gains 31 points, which is close
    to the maximum possible gain per match when *K* is 32\. This shows how *K* determines
    the importance of a single match.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，理论上较弱的选手获得了31分，这接近于当*K*为32时的每场比赛可能获得的最大分数。这显示了*K*如何决定单场比赛的重要性。
- en: These two equations are all the math we need. That's it! The beauty of the Elo
    system is that the actual calculations are quite simple. Now, it's time to start
    using the functions we've written on some real data.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方程就是我们所需要的所有数学。就是这样！Elo系统的美妙之处在于实际的计算相当简单。现在，是时候开始使用我们编写的函数处理一些真实数据了。
- en: 'Activity 5.01: Calculating Elo Ratings for Tennis'
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：计算网球Elo评级
- en: A sports journalism website has asked you to provide improved ratings for the
    men's professional tennis circuit. They want to know the relative strengths of
    current players, as well as the strength of a given player during a given year
    in the past. Most of all, the journalists want high-quality predictions for future
    matches.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一家体育新闻网站要求你提供男子职业网球巡回赛的改进评级。他们想知道当前选手的相对实力，以及过去某一年特定选手的实力。最重要的是，记者们希望得到未来比赛的优质预测。
- en: Your assignment is to build the prototype for this new system. A REPL-based
    implementation is fine for now, but it's important to be able to demonstrate the
    accuracy of your results based on past match data.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是构建这个新系统的原型。目前基于REPL的实现是可以的，但重要的是能够根据过去的比赛数据展示结果的准确性。
- en: To do this, you'll need to write a function that parses the CSV file that we've
    been working with, using `reduce`. The function will not only calculate player
    ratings. It will also keep track of its own success rate in predicting match results.
    This will allow you to show the journalists how well your algorithm works, and
    before that, it will allow you to tweak your code to obtain the best possible
    predictions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要编写一个函数，使用`reduce`解析我们一直在使用的CSV文件。这个函数不仅会计算选手评级，还会跟踪其预测比赛结果的成功率。这将允许你向记者展示你的算法效果如何，在此之前，它将允许你调整代码以获得最佳可能的预测。
- en: 'Your accumulator map will need to build up the following information:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您的累加器映射需要构建以下信息：
- en: '**Player ratings**: This is the most important part: a huge map linking each
    player to his rating. The map will be updated with the new ratings for the two
    players in the match being analyzed.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家评分**：这是最重要的部分：一个巨大的映射，将每个玩家与其评分相关联。该映射将更新为正在分析的比赛中的两位玩家的新评分。'
- en: '**Success count**: For each match where one of the two players has a better
    than 50% chance of winning, did the expected winner actually win? By counting
    successes, you''ll be able to divide by the total number of match predictions
    to determine the precision of your predictions.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功次数**：对于每一场比赛，其中两位选手中有一位有超过50%的胜率，预期的赢家实际上是否获胜？通过计算成功次数，您将能够除以总的比赛预测次数，以确定您预测的精确度。'
- en: '**Total match count**: The total number of matches that have been considered.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总比赛次数**：已考虑的比赛总数。'
- en: '**Prediction count**: The number of matches where a winner could be predicted
    – that is, matches where the forecast was not 50-50\. Since we''re excluding those
    matches from the success count, we need to exclude them from the prediction count.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测次数**：可以预测赢家（即预测不是50-50的比赛）的比赛数量。由于我们从成功次数中排除了这些比赛，因此我们也需要从预测次数中排除它们。'
- en: 'These steps will help you complete the activity:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成活动：
- en: Set up your project with a `deps.edn` file containing the necessary references
    to the Clojure libraries you will use and include the tennis data files from [https://packt.live/37DCkZn](https://packt.live/37DCkZn).
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包含您将使用的 Clojure 库的必要引用的 `deps.edn` 文件设置您的项目，并包括来自 [https://packt.live/37DCkZn](https://packt.live/37DCkZn)
    的网球数据文件。
- en: Place your work in a new file and namespace. Include the `recalculate-rating`
    and `match-probability` functions from the previous exercises.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件和命名空间中放置您的作品。包括来自前一个练习的 `recalculate-rating` 和 `match-probability` 函数。
- en: 'Write the skeleton for a new function. It should accept two arguments: the
    path to the CSV file and a *K* factor.'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的函数编写骨架。它应该接受两个参数：CSV 文件的路径和 *K* 因子。
- en: Adapt the pattern based around `with-open` used in previous activities and exercises
    for reading the file, mappifying each line and converting useful fields to integers.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据之前活动和练习中使用的 `with-open` 模式调整，用于读取文件、映射每一行并将有用的字段转换为整数。
- en: Prepare a call to `reduce` that will encompass most of the remaining logic you
    need to write.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个 `reduce` 调用，它将包含您需要编写的剩余逻辑的大部分。
- en: Design an initializer/accumulator map as the second argument to `reduce` that
    will adequately keep track of all the information you need to pass on from one
    iteration to the next.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计一个初始化器/累加器映射，作为 `reduce` 的第二个参数，以便充分跟踪您需要从一个迭代传递到下一个迭代的所有信息。
- en: Write the code to update the accumulator after each match. Use the functions
    you already have to predict a winner and adjust the ratings according to the actual
    result of the match.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以在每个比赛后更新累加器。使用您已经拥有的函数来预测赢家并根据比赛的实际情况调整评分。
- en: Test your function on the tennis datasets.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网球数据集上测试您的函数。
- en: When testing, the results will be huge, so remember to assign them to a var.
    Check your results in the REPL by querying the result map.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试时，结果将会很大，所以请记住将它们分配给一个变量。通过查询结果映射来检查您的结果。
- en: 'You should be able to query your results like this:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够像这样查询您的结果：
- en: '![Figure 5.15: Expected query results'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15：预期的查询结果'
- en: '](img/B14502_05_15.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_15.jpg)'
- en: 'Figure 5.15: Expected query results'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：预期的查询结果
- en: 'You should also be able to check how often the match predictions were correct:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该能够检查比赛预测的正确率：
- en: '![Figure 5.16: Checking the match prediction'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16：检查比赛预测'
- en: '](img/B14502_05_16.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_05_16.jpg)'
- en: 'Figure 5.16: Checking the match prediction'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：检查比赛预测
- en: Note
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 693.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 693 页找到。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'With this chapter, we''ve taken another important step forward in our exploration
    of Clojure''s collections and how to use them to solve problems. Techniques involving
    collections will always be at the heart of your Clojure programming experience:
    they will inform how you organize your code, as well as how you choose and design
    your data structures.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们在探索 Clojure 的集合以及如何使用它们解决问题的过程中又迈出了重要的一步。涉及集合的技术将始终是您 Clojure 编程体验的核心：它们将指导您如何组织代码，以及您如何选择和设计数据结构。
- en: In the next chapter, we will take a look at flexible ways to work with the collections
    in Clojure.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在Clojure中灵活处理集合的方法。
