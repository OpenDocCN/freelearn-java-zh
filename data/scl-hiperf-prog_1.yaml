- en: Chapter 1.  The Road to Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 性能之路
- en: We welcome you on a journey to learning pragmatic ways to use the Scala programming
    language and the functional programming paradigm to write performant and efficient
    software. Functional programming concepts, such as pure and higher-order functions,
    referential transparency, and immutability, are desirable engineering qualities.
    They allow us to write composable elements, maintainable software, and expressive
    and easy-to-reason-about code. However, in spite of all its benefits, functional
    programming is too often wrongly associated with degraded performance and inefficient
    code. It is our goal to convince you otherwise! This book explores how to take
    advantage of functional programming, the features of the Scala language, the Scala
    standard library, and the Scala ecosystem to write performant software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们欢迎你踏上学习实用方法使用Scala编程语言和函数式编程范式的旅程，以编写性能和高效的软件。函数式编程概念，如纯函数和高级函数、引用透明性和不可变性，是理想化的工程品质。它们使我们能够编写可组合的元素、可维护的软件，以及易于理解和推理的代码。然而，尽管功能编程具有所有这些优点，但它往往被错误地与性能下降和低效的代码联系起来。我们的目标是说服你相反的观点！本书探讨了如何利用函数式编程、Scala语言的功能、Scala标准库和Scala生态系统来编写性能软件。
- en: Scala is a statically and strongly typed language that tries to elegantly blend
    both functional and object-oriented paradigms. It has experienced growing popularity
    in the past few years as both an appealing and pragmatic choice to write production-ready
    software in the functional paradigm. Scala code compiles to bytecode and runs
    on the **Java Virtual Machine** (**JVM**), which has a widely-understood runtime,
    is configurable, and provides excellent tooling to introspect and debug correctness
    and performance issues. An added bonus is Scala's great interoperability with
    Java, which allows you to use all the existing Java libraries. While the Scala
    compiler and the JVM receive constant improvements and already generate well-optimized
    bytecode, the onus remains on you, the developer, to achieve your performance
    goals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种静态和强类型语言，它试图优雅地融合函数式和面向对象范式。在过去几年中，它因其吸引力和实用性而越来越受欢迎，成为在函数式范式下编写生产级软件的选择。Scala代码编译成字节码，在**Java虚拟机**（**JVM**）上运行，该虚拟机具有广泛理解的运行时环境，可配置，并提供出色的工具来检查和调试正确性和性能问题。一个额外的优势是Scala与Java的出色互操作性，这允许你使用所有现有的Java库。虽然Scala编译器和JVM不断得到改进，并且已经生成良好的优化字节码，但实现性能目标的责任仍然在你，即开发者身上。
- en: Before diving into the Scala and JVM specifics, let's first develop an intuition
    for the holy grail that we seek: performance. In this first chapter, we will cover
    performance basics that are agnostic to the programming language. We will present
    and explain the terms and concepts that are used throughout this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Scala和JVM的具体细节之前，让我们首先培养对所追求的圣杯——性能——的直觉。在本章中，我们将介绍与编程语言无关的性能基础知识。我们将展示并解释本书中使用的术语和概念。
- en: 'In particular, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下主题：
- en: Defining performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义性能
- en: Summarizing performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结性能
- en: Collecting measurements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集度量
- en: We will also introduce our case study, a fictitious application based on real-world
    problems that will help us illustrate techniques and patterns that are presented
    later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍我们的案例研究，这是一个基于现实世界问题的虚构应用程序，它将帮助我们说明后面将要介绍的技巧和模式。
- en: Defining performance
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义性能
- en: A performance vocabulary arms you with a way to qualify the type of issues at-hand
    and often helps guide you towards a resolution. Particularly when time is of the
    essence, a strong intuition and a disciplined strategy are assets to resolve performance
    problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个性能词汇表为你提供了一种评估手头问题类型的方法，并常常帮助你找到解决方案。尤其是在时间紧迫的情况下，强烈的直觉和纪律性的策略是解决性能问题的资产。
- en: Let's begin by forming a common understanding of the term, performance. This
    term is used to qualitatively or quantitatively evaluate the ability to accomplish
    a goal. The goal at-hand can vary significantly. However, as a professional software
    developer, the goal ultimately links to a business goal. It is paramount to work
    with your business team to characterize business domain performance sensitivities.
    For a consumer-facing shopping website, agreeing upon the number of concurrent
    app users and acceptable request response times is relevant. In a financial trading
    company, trade latency might be the most important because speed is a competitive
    advantage. It is also relevant to keep in mind nonfunctional requirements, such
    as "trade executions can never be lost," because of industry regulations and external
    audits. These domain constraints will also impact your software's performance
    characteristics. Building a clear and agreed upon picture of the domain that you
    operate in is a crucial first step. If you cannot define these constraints, an
    acceptable solution cannot be delivered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从形成对“性能”这一术语的共同理解开始。这个术语用于定性或定量地评估实现目标的能力。当前的目标可能会有很大的不同。然而，作为一名专业的软件开发人员，目标最终会与商业目标相联系。与您的业务团队合作，确定业务领域性能敏感性至关重要。对于一个面向消费者的购物网站，就同时在线应用用户数量和可接受的请求响应时间达成一致是相关的。在一家金融交易公司，交易延迟可能是最重要的，因为速度是竞争优势。同时，也要考虑到非功能性需求，例如“交易执行永远不会丢失”，这是由于行业法规和外部审计。这些领域约束也会影响您软件的性能特征。构建一个清晰且达成共识的领域图景是至关重要的第一步。如果您无法定义这些约束，就无法提供可接受的解决方案。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Gathering requirements is an involved topic outside the scope of this book.
    If you are interested in delving deeper into this topic, we recommend two books
    by Gojko Adzic: *Impact Mapping: Making a big impact with software products and
    projects* ([http://www.amazon.com/Impact-Mapping-software-products-projects-ebook/dp/B009KWDKVA](http://www.amazon.com/Impact-Mapping-software-products-projects-ebook/dp/B009KWDKVA))
    and Fifty Quick Ideas to Improve Your User Stories ([http://www.amazon.com/Fifty-Quick-Ideas-Improve-Stories-ebook/dp/B00OGT2U7M](http://www.amazon.com/Fifty-Quick-Ideas-Improve-Stories-ebook/dp/B00OGT2U7M)).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 收集需求是本书范围之外的一个复杂话题。如果您想深入了解这个话题，我们推荐Gojko Adzic的两本书：《影响映射：用软件产品和项目产生重大影响》（[http://www.amazon.com/Impact-Mapping-software-products-projects-ebook/dp/B009KWDKVA](http://www.amazon.com/Impact-Mapping-software-products-projects-ebook/dp/B009KWDKVA)）和《五十个快速提高您的用户故事的想法》（[http://www.amazon.com/Fifty-Quick-Ideas-Improve-Stories-ebook/dp/B00OGT2U7M](http://www.amazon.com/Fifty-Quick-Ideas-Improve-Stories-ebook/dp/B00OGT2U7M)）。
- en: Performant software
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能软件
- en: 'Designing performant software is one of our goals as software engineers. Thinking
    about this goal leads to a commonly asked question, "What performance is good
    enough?" We use the term performant to characterize performance that satisfies
    the minimally-accepted threshold for "good enough." We aim to meet and, if possible,
    exceed the minimum thresholds for acceptable performance. Consider this: without
    an agreed upon set of criteria for acceptable performance, it is by definition
    impossible to write performant software! This statement illustrates the overwhelming
    importance of defining the desired outcome as a prerequisite to writing performant
    software.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设计性能良好的软件是我们作为软件工程师的一个目标。思考这个目标会导致一个常见的问题：“什么样的性能才算足够好？”我们使用“性能良好”这个术语来描述满足“足够好”的最小可接受阈值的性能。我们的目标是达到并尽可能超过可接受性能的最小阈值。考虑这一点：如果没有一个关于可接受性能的协议标准，那么定义性能良好的软件在定义上就是不可能的！这个陈述说明了定义期望结果作为编写性能良好软件的先决条件的压倒性重要性。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a moment to reflect on the meaning of performant for your domain. Have
    you had struggles maintaining software that meets your definition of performant?
    Consider the strategies that you applied to solve performance dilemmas. Which
    ones were effective and which ones were ineffective? As you progress through the
    book, keep this in mind so that you can check which techniques can help you meet
    your definition of performant more effectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间思考一下性能对您领域含义。您是否在维护符合您定义的性能良好的软件时遇到过困难？考虑一下您用来解决性能困境的策略。哪些是有效的，哪些是无效的？随着您阅读本书的进展，请记住这一点，以便您可以检查哪些技术可以帮助您更有效地达到您对性能的定义。
- en: Hardware resources
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件资源
- en: 'In order to define criteria for performant software, we must expand the performance
    vocabulary. First, become aware of your environment''s resources. We use the term
    resource to cover all the infrastructure that your software uses to run. Refer
    to the following resource checklist, which lists the resources that you should
    collect prior to engaging in any performance tuning exercise:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义高性能软件的标准，我们必须扩展性能词汇。首先，了解你环境中的资源。我们使用“资源”这个术语来涵盖你的软件运行所需的所有基础设施。参考以下资源清单，它列出了在进行任何性能调优练习之前你应该收集的资源：
- en: 'Hardware type: physical or virtualized'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件类型：物理或虚拟化
- en: 'CPUs:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU：
- en: Number of cores
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心数量
- en: L1, L2, and L3 cache sizes
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: L1, L2, 和 L3 缓存大小
- en: NUMA zones
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUMA 区域
- en: RAM (for example, 16 GB)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM（例如，16 GB）
- en: Network connectivity rating (for example, 1GbE or 10GbE)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络连接评级（例如，1GbE 或 10GbE）
- en: OS and kernel versions
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统和内核版本
- en: Kernel settings (for example, TCP socket receive buffer size)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核设置（例如，TCP 套接字接收缓冲区大小）
- en: JVM version
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 版本
- en: Itemizing the resource checklist forces you to consider the capabilities and
    limitations of your operating environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列出资源清单迫使你考虑你操作环境的性能和限制。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Excellent resources for kernel optimization include Red Hat Performance Tuning
    Guide ([https://goo.gl/gDS5mY](https://goo.gl/gDS5mY)) and presentations and tutorials
    by Brendan Gregg ([http://www.brendangregg.com/linuxperf.html](http://www.brendangregg.com/linuxperf.html)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 核心优化方面的优秀资源包括 Red Hat 性能调优指南([https://goo.gl/gDS5mY](https://goo.gl/gDS5mY))以及布伦丹·格雷格([http://www.brendangregg.com/linuxperf.html](http://www.brendangregg.com/linuxperf.html))的演示和教程。
- en: Latency and throughput
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟和吞吐量
- en: 'Latency and throughput define two types of performance, which are often used
    to establish the criteria for performant software. The illustration of a highway,
    like the following photo of the German Autobahn, is a great way to develop an
    intuition of these types of performance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟和吞吐量定义了两种性能类型，这些类型通常用于建立高性能软件的标准。以下德国高速公路的照片，就像以下照片，是培养对这些类型性能直觉的好方法：
- en: '![Latency and throughput](img/image_01_001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![延迟和吞吐量](img/image_01_001.jpg)'
- en: The Autobahn helps us think about latency and throughput. (image wikimedia,
    [https://en.wikipedia.org/wiki/Highway#/media/File:Blick_auf_A_2_bei_Rastst%C3%A4tte_Lehrter_See_(2009).jpg](https://en.wikipedia.org/wiki/Highway#/media/File:Blick_auf_A_2_bei_Rastst%C3%A4tte_Lehrter_See_(2009).jpg).
    License Creative Commons CC BY-SA 3.0)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Autobahn 帮助我们思考延迟和吞吐量。（图片来源维基媒体，[https://en.wikipedia.org/wiki/Highway#/media/File:Blick_auf_A_2_bei_Rastst%C3%A4tte_Lehrter_See_(2009).jpg](https://en.wikipedia.org/wiki/Highway#/media/File:Blick_auf_A_2_bei_Rastst%C3%A4tte_Lehrter_See_(2009).jpg)。许可
    Creative Commons CC BY-SA 3.0）
- en: Latency describes the amount of time that it takes for an observed process to
    be completed. Here, the process is a single car driving down one lane of the highway.
    If the highway is free of congestion, then the car is able to drive down the highway
    quickly. This is described as a low-latency process. If the highway is congested,
    the trip time increases, which is characterized as a high-latency or latent process.
    Performance optimizations that are within your control are also captured by this
    analogy. You can imagine that reworking an expensive algorithm from polynomial
    to linear execution time is similar to either improving the quality of the highway
    or the car's tires to reduce road friction. The reduction in friction allows the
    car to cross the highway with lower latency. In practice, latency performance
    objectives are often defined in terms of a maximum tolerable latency for your
    business domain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟描述了观察到的过程完成所需的时间量。在这里，过程是一辆车在高速公路的单车道上行驶。如果高速公路没有拥堵，那么汽车能够快速行驶在高速公路上。这被描述为低延迟过程。如果高速公路拥堵，行程时间增加，这被描述为高延迟或潜伏过程。这个类比也捕捉了你可控的性能优化。你可以想象将一个昂贵的算法从多项式时间优化到线性执行时间，类似于改善高速公路的质量或汽车的轮胎以减少路面摩擦。摩擦的减少使得汽车能够以更低的延迟穿越高速公路。在实践中，延迟性能目标通常以你业务域可容忍的最大延迟来定义。
- en: 'Throughput defines the observed rate at which a process is completed. Using
    the highway analogy, the number of cars traveling from point A to point B per
    unit of time is the highway''s throughput. For example, if there are three traffic
    lanes and cars travel in each lane at a uniform rate, then the throughput is:
    (the number of cars per lane that traveled from point A to point B during the
    observation period) * 3\. Inductive reasoning may suggest that there is a strong
    negative correlation between throughput and latency. That is, as latency increases,
    throughput decreases. As it turns out, there are a number of cases where this
    type of reasoning does not hold true. Keep this in mind as we continue expanding
    our performance vocabulary to better understand why this happens. In practice,
    throughput is often defined by the maximum number of transactions per second your
    software can support. Here, a transaction means a unit of work in your domain
    (for example, orders processed or trades executed).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量定义了完成一个过程观察到的速率。使用高速公路的类比，单位时间内从A点到B点行驶的汽车数量是高速公路的吞吐量。例如，如果有三个车道，汽车在每个车道上以均匀的速度行驶，那么吞吐量就是：（在观察期间从A点到B点行驶的每个车道的汽车数量）*
    3。归纳推理可能会暗示吞吐量和延迟之间存在强烈的负相关关系。也就是说，随着延迟的增加，吞吐量会减少。实际上，有许多情况下这种推理并不成立。在我们继续扩展性能词汇以更好地理解为什么会发生这种情况时，请记住这一点。在实践中，吞吐量通常定义为你的软件每秒可以支持的最多事务数。在这里，一个事务意味着你领域中的一个工作单元（例如，处理的订单或执行的交易）。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thinking back to the recent performance issues that you faced, how would you
    characterize them? Did you have a latency or a throughput problem? Did your solution
    increase throughput while lowering latency?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你最近遇到的性能问题，你会如何描述它们？你遇到了延迟还是吞吐量问题？你的解决方案是否在降低延迟的同时提高了吞吐量？
- en: Bottlenecks
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓶颈
- en: A bottleneck refers to the slowest part of the system. By definition, all systems,
    including well-tuned ones, have a bottleneck because there is always one processing
    step that is measured to be the slowest. Note that the latency bottleneck may
    not be the throughput bottleneck. That is, multiple types of bottleneck can exist
    at the same time. This is another illustration of why it is important to understand
    whether you are combating a throughput or a latency performance issue. Use the
    process of identifying your system's bottlenecks to provide you with a directed
    focus to attack your performance dilemmas.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个瓶颈指的是系统中最慢的部分。按照定义，所有系统，包括调优良好的系统，都有一个瓶颈，因为总有一个处理步骤被测量为最慢的。请注意，延迟瓶颈可能不是吞吐量瓶颈。也就是说，可能同时存在多种类型的瓶颈。这是说明为什么理解你是在对抗吞吐量还是延迟性能问题很重要的另一个例子。通过识别你系统瓶颈的过程，为你提供一个有针对性的焦点来攻击你的性能难题。
- en: From personal experience, we have seen how time is wasted when the operating
    environment checklist is ignored. Once, while working in the advertising domain
    on a high-throughput **real-time bidding** (**RTB**) platform, we chased a throughput
    issue for several days without success. After bootstrapping an RTB platform, we
    began optimizing for a higher request throughput goal because request throughput
    is a competitive advantage in our industry. Our business team identified an increase
    from 40,000 requests per second (RPS) to 75,000 RPS as a major milestone. Our
    tuning efforts consistently yielded about 60,000 RPS. This was a real head scratcher
    because the system did not appear to exhaust system resources. CPU utilization
    was well under 100%, and previous experiments to increase heap space did not yield
    improvements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从个人经验来看，我们看到了当操作环境清单被忽视时，时间是如何被浪费的。有一次，在我们为一个高吞吐量**实时竞价**（**RTB**）平台工作的时候，我们追查了一个多天的吞吐量问题，但都没有成功解决。在启动了一个RTB平台之后，我们开始优化以提高更高的请求吞吐量目标，因为请求吞吐量是我们行业的一个竞争优势。我们的业务团队将每秒40,000次请求（RPS）增加到75,000
    RPS视为一个重要的里程碑。我们的调整工作一直稳定在约60,000 RPS。这真是一个令人挠头的问题，因为系统似乎并没有耗尽系统资源。CPU利用率远低于100%，而之前增加堆空间实验并没有带来改进。
- en: The "aha!" moment came when we realized that the system was deployed within
    AWS with the default network connectivity configured to 1 Gigabit Ethernet. The
    requests processed by the system are about 2KB per request. We performed some
    basic arithmetic to identify the theoretical maximum throughput rate. 1 Gigabit
    is equivalent to 125,000 kilobytes. 125,000 kilobytes / 2 kilobytes per request
    translates to a theoretical maximum of 62,500 RPS. This arithmetic was confirmed
    by running a test of our network throughput with a tool named iPerf. Sure enough,
    we had maxed out our network connectivity!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们意识到系统是在AWS上部署的，并且默认的网络连接配置为1千兆以太网时，我们有了“啊哈！”的时刻。系统处理的请求大约为每个请求2KB。我们进行了一些基本的算术运算，以确定理论上的最大吞吐量率。1千兆等于125,000千字节。125,000千字节除以每个请求2千字节等于理论上的最大RPS为62,500。这个算术运算通过使用名为iPerf的工具进行网络吞吐量测试得到了证实。果然，我们已经达到了我们的网络连接极限！
- en: Summarizing performance
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结性能
- en: We properly defined some of the main concepts around performance, namely latency
    and throughput, but we still lack a concrete way to quantify our measurements.
    To continue with our example of cars driving down a highway, we want to find a
    way to answer the question, "How long a drive should I expect to go from point
    A to point B?" The first step is to measure our trip time on multiple occasions
    to collect empirical information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正确地定义了一些关于性能的主要概念，即延迟和吞吐量，但我们仍然缺乏一个具体的量化测量方法。继续我们的例子，即汽车在高速公路上行驶，我们希望找到一种方法来回答“从A点到B点我应该期望多长时间的驾驶？”这个问题。第一步是在多次旅行中测量我们的旅行时间以收集经验信息。
- en: 'The following table catalogs our observations. We still need a way to interpret
    these data points and summarize our measurements to give an answer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了我们的观察结果。我们仍然需要一种方法来解释这些数据点并总结我们的测量结果以给出答案：
- en: '| **Observed trip** | **Travel time in minutes** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **观察到的旅行** | **旅行时间（分钟**） |'
- en: '| Trip 1 | 28 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 旅行1 | 28 |'
- en: '| Trip 2 | 37 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 旅行2 | 37 |'
- en: '| Trip 3 | 17 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 旅行3 | 17 |'
- en: '| Trip 4 | 38 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 旅行4 | 38 |'
- en: '| Trip 5 | 18 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 旅行5 | 18 |'
- en: The problem with averages
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均值的问题
- en: A common mistake is to rely on averages to measure the performance of a system.
    An arithmetic average is fairly easy to calculate. This is the sum of all collected
    values divided by the number of values. Using the previous sample of data points,
    we can infer that on average we should expect a drive of approximately 27 minutes.
    With this simple example, it is easy to see what makes the average such a poor
    choice. Out of our five observations, only Trip 1 is close to our average while
    all the other trips are quite different. The fundamental problem with averages
    is that it is a lossy summary statistic. Information is lost when moving from
    a series of observations to the average because it is impossible to retain all
    the characteristics of the original observations in a single data point.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是依赖于平均值来衡量系统的性能。算术平均值很容易计算。这是所有收集到的值的总和除以值的数量。使用之前的数据点样本，我们可以推断出平均来说，我们应该期望驾驶时间大约为27分钟。在这个简单的例子中，很容易看出为什么平均值是一个如此糟糕的选择。在我们的五个观察值中，只有第1次旅行接近我们的平均值，而其他所有旅行都相当不同。平均值的基本问题在于它是一个有损的汇总统计量。当从一系列观察值移动到平均值时，信息会丢失，因为不可能在单个数据点中保留原始观察的所有特征。
- en: 'To illustrate how an average loses information, consider the three following
    datasets that represent the measured latency required to process a request to
    a web service:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明平均值如何丢失信息，考虑以下三个代表处理对Web服务请求所需测量延迟的数据集：
- en: '![The problem with averages](img/image_01_002.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![平均值的问题](img/image_01_002.jpg)'
- en: 'In the first dataset, there are four requests that take between 280 ms and
    305 ms to be completed. Compare these latencies with the latencies in the second
    dataset, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个数据集中，有四个请求需要280毫秒到305毫秒的时间才能完成。将这些延迟与第二个数据集中的延迟进行比较，如下所示：
- en: '![The problem with averages](img/image_01_003.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![平均值的问题](img/image_01_003.jpg)'
- en: 'The second dataset shows a more volatile mixture of latencies. Would you prefer
    to deploy the first or the second service into your production environment? To
    add more variety into the mix, a third dataset is shown, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据集显示了更易变的延迟混合。你更愿意将第一个还是第二个服务部署到你的生产环境中？为了增加更多的多样性，显示了第三个数据集，如下所示：
- en: '![The problem with averages](img/image_01_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![平均值的问题](img/image_01_004.jpg)'
- en: Although each of these datasets has a vastly different distribution, the averages
    are all the same, and equal 292 ms! Imagine having to maintain the web service
    that is represented by dataset 1 with the goal of ensuring that 75% of clients
    receive a response in less than 300 ms. Calculating the average out of dataset
    3 will give you the impression that you are meeting your objective, while in reality
    only half of your clients actually experience a fast enough response (requests
    with IDs 1 and 2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些数据集的分布差异很大，但平均值都是相同的，等于 292 毫秒！想象一下，你必须维护代表数据集 1 的网络服务，目标是确保 75% 的客户在 300
    毫秒内收到响应。从数据集 3 中计算平均值会给你一种你正在达到目标的印象，而实际上只有一半的客户实际上体验到了足够快的响应（ID 为 1 和 2 的请求）。
- en: Percentiles to the rescue
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分位数拯救了困境
- en: 'The key term in the previous discussion is "distribution." Measuring the distribution
    of a system''s performance is the most robust way to ensure that you understand
    the behavior of the system. If an average is an ineffective choice to take into
    account the distribution of our measurements, then we need to find a different
    tool. In the field of statistics, a percentile meets our criteria to interpret
    the distribution of observations. A percentile is a measurement indicating the
    following value into which a given percentage of observations in a group of observations
    falls. Let''s make this definition more concrete with an example. Going back to
    our web service example, imagine that we observe the following latencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上次讨论中的关键词是“分布”。测量系统性能的分布是确保你理解系统行为的最稳健的方法。如果我们认为平均值不是一个有效的选择来考虑我们测量的分布，那么我们需要找到一个不同的工具。在统计学领域，百分位数符合我们解释观察值分布的标准。百分位数是一个测量值，表示在观察值组中，给定百分比的观察值落入的值。让我们用一个例子来使这个定义更具体。回到我们的网络服务示例，假设我们观察到以下延迟：
- en: '| **Request** | **Latency in milliseconds** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | **毫秒延迟** |'
- en: '| Request 1 | 10 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 请求 1 | 10 |'
- en: '| Request 2 | 12 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 请求 2 | 12 |'
- en: '| Request 3 | 13 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 请求 3 | 13 |'
- en: '| Request 4 | 13 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 请求 4 | 13 |'
- en: '| Request 5 | 9 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 请求 5 | 9 |'
- en: '| Request 6 | 27 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 请求 6 | 27 |'
- en: '| Request 7 | 12 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 请求 7 | 12 |'
- en: '| Request 8 | 7 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 请求 8 | 7 |'
- en: '| Request 9 | 75 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 请求 9 | 75 |'
- en: '| Request 10 | 80 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 请求 10 | 80 |'
- en: 'The 20^(th) percentile is defined as the observed value that represents 20%
    of all the observations. As there are ten observed values, we want to find the
    value that represents two observations. In this example, the 20^(th) percentile
    latency is 9 ms because two values (that is, 20% of the total observations) are
    less than or equal to 10 ms (9 ms and 7 ms). Contrast this latency with the 90th
    percentile. The value representing 90% of the observations: 75 ms (as nine observations
    out of ten are less than or equal to 75 ms).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第 20 个百分位数定义为表示所有观察值 20% 的观察值。由于有十个观察值，我们想要找到表示两个观察值的值。在这个例子中，第 20 个百分位数的延迟是
    9 毫秒，因为有两个值（即，总观察值的 20%）小于或等于 10 毫秒（9 毫秒和 7 毫秒）。将这个延迟与第 90 个百分位数进行对比。表示 90% 的观察值的值：75
    毫秒（因为十个观察值中有九个小于或等于 75 毫秒）。
- en: Where the average hides the distribution of our measurements, the percentile
    provides us with deeper insight and highlights that tail-end observations (the
    observations near the 100th percentile) experience extreme latencies.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当平均值隐藏了我们的测量值的分布时，百分位数为我们提供了更深入的洞察，并突出了尾部观察值（接近第 100 个百分位数的观察值）经历了极端的延迟。
- en: If you remember the beginning of this section, we were trying to answer the
    question, "How long a drive should I expect to go from point A to point B?" After
    spending some time exploring the tools available, we realized that the original
    question is not the one we are actually interested in. A more pragmatic question
    is, "How long do 90% of the cars take to go from point A to point B?"
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得本节的开头，我们试图回答的问题是，“从 A 点到 B 点的驾驶时间应该是多长？”在花了一些时间探索可用的工具之后，我们意识到原始问题并不是我们真正感兴趣的。一个更实际的问题是，“90%
    的汽车从 A 点到 B 点需要多长时间？”
- en: Collecting measurements
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集测量值
- en: Our performance measurement toolkit is already filled with useful information.
    We defined a common vocabulary to talk about and explore performance. We also
    agreed on a pragmatic way to summarize performance. The next step in our journey
    is to answer the question, "In order to summarize them, how do I collect performance
    measurements?" This section introduces you to techniques to collect measurements.
    In the next chapter, we dive deeper and focus on collecting data from Scala code.
    We will show you how to use various tools and libraries designed to work with
    the JVM and understand your programs better.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的性能测量工具包已经充满了有用的信息。我们定义了一个共同词汇表来讨论和探索性能。我们还达成了一项实用的方法来总结性能。我们旅程的下一步是回答问题：“为了总结它们，我如何收集性能测量数据？”本节介绍了收集测量的技术。在下一章中，我们将更深入地探讨，专注于从Scala代码中收集数据。我们将向你展示如何使用旨在与JVM一起工作并更好地理解你的程序的各种工具和库。
- en: Using benchmarks to measure performance
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基准测试来衡量性能
- en: Benchmarks are a black-box kind of measurement. Benchmarks assess a whole system's
    performance by submitting various kinds of load as input and measuring latency
    and throughput as system outputs. As an example, imagine that we are working on
    a typical shopping cart web application. To benchmark this application, we can
    write a simple HTTP client to query our service and record the time taken to complete
    a request. This client can be used to send an increasing number of requests per
    second and output a summary of the recorded response times.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是一种黑盒测量方式。基准测试通过提交各种类型的负载作为输入，并测量延迟和吞吐量作为系统输出，来评估整个系统的性能。例如，假设我们正在开发一个典型的购物车Web应用程序。为了基准测试这个应用程序，我们可以编写一个简单的HTTP客户端来查询我们的服务并记录完成请求所需的时间。这个客户端可以用来发送每秒增加的请求数量，并输出记录的响应时间摘要。
- en: Multiple kinds of benchmark exist to answer different questions about your system.
    You can replay historical production data to make sure that your application is
    meeting the expected performance goals when handling realistic load. Load and
    stress test benchmarks identify the breaking points of your application, and they
    exercise its robustness when receiving exceptionally high load for an extended
    period of time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的基准测试，用以回答关于你系统不同问题的答案。你可以回放历史生产数据，以确保在处理实际负载时，你的应用程序能够达到预期的性能目标。负载和压力测试基准测试可以识别你应用程序的故障点，并在长时间内接收异常高负载时测试其鲁棒性。
- en: Benchmarks are also a great tool to compare different iterations of the same
    application and either detect performance regression or confirm improvements.
    By executing the same benchmark against two versions of your code, you can actually
    prove that your recent changes yielded better performance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试也是比较同一应用程序不同版本并检测性能回归或确认改进的强大工具。通过针对你代码的两个版本执行相同的基准测试，你实际上可以证明你最近的变化带来了更好的性能。
- en: For all their usefulness, benchmarks do not provide any insight into how each
    part of the software performs; hence, they are black-box tests. Benchmarks do
    not help us identify bottlenecks or determine which part of the system should
    be improved to yield better overall performance. To look into the black box, we
    turn to profiling.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基准测试非常有用，但它们并不提供关于软件每个部分如何表现的信息；因此，它们是黑盒测试。基准测试不能帮助我们识别瓶颈或确定系统哪个部分应该改进以获得更好的整体性能。为了深入了解黑盒，我们转向分析。
- en: Profiling to locate bottlenecks
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析以定位瓶颈
- en: 'As opposed to benchmarking, profiling is intended to be used to analyze the
    internal characteristics of your application. A profiler enables white-box testing
    to help you identify bottlenecks by capturing the execution time and resource
    consumption of each part of your program. By examining your application at runtime,
    a profiler provides you with great details about the behavior of your code, including
    the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与基准测试相反，分析是旨在用于分析你应用程序内部特性的。分析器允许白盒测试，帮助你通过捕获程序每个部分的执行时间和资源消耗来识别瓶颈。通过在运行时检查你的应用程序，分析器为你提供了关于你的代码行为的详细信息，包括以下内容：
- en: Where CPU cycles are spent
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU周期在哪里消耗
- en: How memory is used, and where objects are instantiated and released (or not,
    if you have a memory leak!)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用内存，以及对象在哪里实例化、释放（或者如果你有内存泄漏，则不会释放！）
- en: Where IO operations are performed
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IO操作执行的位置
- en: Which threads are running, blocked, or idle
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些线程正在运行、阻塞或空闲
- en: Most profilers instrument the code under observation, either at compile time
    or runtime, to inject counters and profiling components. This instrumentation
    imposes a runtime cost that degrades system throughput and latency. For this reason,
    profilers should not be used to evaluate the expected throughput and latency of
    a system in production (as a reminder, this is a use case for a benchmark).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数分析器在编译时或运行时对观察到的代码进行仪器化，以注入计数器和分析组件。这种仪器化在运行时产生成本，降低了系统吞吐量和延迟。因此，分析器不应用于评估生产环境中系统的预期吞吐量和延迟（提醒一下，这是一个基准测试用例）。
- en: In general, you should always profile your application before deciding to do
    any performance-driven improvement. You should make sure that the part of the
    code you are planning to improve actually is a bottleneck.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您在决定进行任何性能驱动型改进之前，应该始终对应用程序进行性能分析。您应该确保您计划改进的代码部分实际上是一个瓶颈。
- en: Pairing benchmarks and profiling
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将基准测试和分析配对
- en: 'Profilers and benchmarks have different purposes, and they help us answer different
    questions. A typical workflow to improve performance should take advantage of
    both these techniques and leverage their strengths to optimize the code improvement
    process. In practice, this workflow looks like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器和基准测试有不同的目的，它们帮助我们回答不同的问题。提高性能的典型工作流程应该利用这两种技术，并利用它们的优势来优化代码改进过程。在实践中，这个工作流程看起来如下：
- en: Run a benchmark against the current version of the code to establish a performance
    baseline.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对当前版本的代码运行基准测试，以建立性能基线。
- en: Use a profiler to analyze the internal behavior and locate a bottleneck.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分析器分析内部行为并定位瓶颈。
- en: Improve the section causing a bottleneck.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进造成瓶颈的部分。
- en: Run the same benchmark from step 1 against the new code.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对新代码运行与步骤1相同的基准测试。
- en: Compare the results from the new benchmark against the baseline benchmark to
    determine the effectiveness of your changes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新基准测试的结果与基线基准测试结果进行比较，以确定您所做更改的有效性。
- en: Keep in mind, it is important to run all benchmarking and profiling sessions
    in the same environment. Consult your resource checklist to ensure that your environment
    remains constant across tests. Any change in your resources invalidates your test
    results. Just like a science experiment, you must be careful to change only one
    part of the experiment at a time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，运行所有基准测试和分析会话在相同的环境中非常重要。查阅您的资源清单，以确保您的环境在测试中保持一致。任何资源的变化都会使您的测试结果无效。就像科学实验一样，您必须小心地一次只改变实验的一部分。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What roles do benchmarking and profiling play in your development process? Do
    you always profile your application before deciding on the next part of the code
    to improve? Does your definition of "done" include benchmarking? Are you able
    to benchmark and profile your application in an environment as close to production
    as possible?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试和分析在您的开发过程中扮演什么角色？您在决定改进代码的下一部分之前，是否总是对应用程序进行性能分析？您的“完成”定义是否包括基准测试？您能否在尽可能接近生产环境的环境中基准测试和分析应用程序？
- en: A case study
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Throughout this book, we will provide code examples to illustrate the topics
    that are covered. To make the techniques that were described previously as useful
    as possible in your professional life, we are relating our examples to a fictitious
    financial trading company, named MV Trading. The company name originates from
    the combination of the first name initials of your dear authors. Coincidentally,
    the initials also form the Unix file move command, symbolizing that the company
    is on-the-move! Since inception one year ago, MV Trading has operated successful
    stock trading strategies for a small pool of clients. Software infrastructure
    has been rapidly built in the last twelve months to support various arms of the
    business. MV Trading built software to support real-time trading (that is, buying
    and selling) on various stock market exchanges, and it also built a historical
    trade execution analysis to create better performing trading algorithms. If you
    do not have financial domain knowledge, do not worry. With each example, we also
    define key parts of the domain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将提供代码示例来阐述所涵盖的主题。为了使之前描述的技术在您的专业生活中尽可能有用，我们将我们的示例与一家虚构的金融交易公司相关联，该公司名为MV
    Trading。公司名称来源于作者名字首字母的组合。巧合的是，这些首字母也形成了Unix文件移动命令，象征着公司正在不断发展！自一年前成立以来，MV Trading已为少量客户提供成功的股票交易策略。在过去十二个月中，软件基础设施迅速建立，以支持业务的各个方面。MV
    Trading开发了支持在各个股票交易所进行实时交易（即买卖）的软件，并且还建立了一个历史交易执行分析，以创建表现更好的交易算法。如果您没有金融领域的知识，请不要担心。在每个示例中，我们也会定义该领域的关键部分。
- en: Tooling
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'We recommend that you install all the necessary tooling up-front so that you
    can work through these examples without setup time. The installation instructions
    are brief because detailed installation guides are available on the websites that
    accompany each required tool. The following software is needed for all upcoming
    chapters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您提前安装所有必要的工具，这样您就可以在没有设置时间的情况下完成这些示例。安装说明简短，因为每个所需工具的配套网站上都有详细的安装指南。以下软件是所有即将到来的章节所需的：
- en: Oracle JDK 8+ using v1.8 u66 at the time of writing
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写时使用Oracle JDK 8+，版本为v1.8 u66
- en: sbt v0.13+, using v0.13.11 at the time of writing, which is available at [http://www.scala-sbt.org/](http://www.scala-sbt.org/)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sbt v0.13+，编写时使用v0.13.11，可在[http://www.scala-sbt.org/](http://www.scala-sbt.org/)找到，该版本在编写时使用
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look at it. The code bundle for the book is also hosted on
    GitHub at [https://github.com/PacktPublishing/Scala-High-Performance-Programming](https://github.com/PacktPublishing/Scala-High-Performance-Programming).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关下载代码包的详细步骤，请参阅本书的序言。请查看它。本书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Scala-High-Performance-Programming](https://github.com/PacktPublishing/Scala-High-Performance-Programming)。我们还有其他来自我们丰富的图书和视频目录的代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)找到。请查看它们！
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on understanding how to talk about performance.
    We built a vocabulary to discuss performance, determined the best way to summarize
    performance with percentiles, and developed an intuition to measure performance.
    We introduced our case study, and then we installed the required tools to run
    the code samples and the source code provided with this book. In the next chapter,
    we will look at available tools to measure JVM performance and analyze the performance
    of our Scala applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于了解如何讨论性能。我们建立了一个词汇表来讨论性能，确定了用百分位数总结性能的最佳方式，并培养了对性能的直觉。我们介绍了我们的案例研究，然后安装了所需的工具来运行本书提供的代码示例和源代码。在下一章中，我们将探讨可用的工具来衡量JVM性能和分析我们的Scala应用程序的性能。
