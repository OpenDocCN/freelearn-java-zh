- en: Migrating Applications to Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序迁移到 Java 9
- en: In the previous chapter, we took a close look at the structure of Java modules
    as specified by Project Jigsaw and examined how Project Jigsaw was implemented
    to improve the Java platform. We also reviewed key internal changes to the Java
    platform with specific focus on the new modular system. We started with a modular
    primer where we learned about Java 9's modular system in terms of benefits and
    requirements. Next, we explored how Java 9 introduced modularity to the JDK. This
    included a look at how the source code was reorganized for Java 9\. We also explored
    the JDK's seven primary tool categories and learned that Java 9 modularity extends
    to runtime images resulting in more maintainability, better performance, and increased
    security. The concept of **link time** was introduced as an optional phase between
    compile-time and runtime. We concluded the chapter with a look at the **Java linker**
    and how Java 9 encapsulates internal APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细研究了 Project Jigsaw 规定的 Java 模块结构，并检查了 Project Jigsaw 如何实施以改进 Java
    平台。我们还回顾了 Java 平台的关键内部更改，特别关注新的模块化系统。我们从模块入门开始，了解了 Java 9 的模块化系统在优势和需求方面的内容。接下来，我们探讨了
    Java 9 如何将模块化引入 JDK。这包括查看 Java 9 的源代码是如何重新组织的。我们还探讨了 JDK 的七个主要工具类别，并了解到 Java 9
    的模块化扩展到运行时镜像，从而提高了可维护性、性能和安全性。**链接时间**的概念被引入为编译时间和运行时间之间可选的阶段。我们以查看**Java 链接器**和
    Java 9 如何封装内部 API 来结束本章。
- en: In this chapter, we will explore how to migrate our existing applications to
    the Java 9 platform. We will look at both manual and semi-automated migration
    processes. Java 9 is a major release with numerous changes to the JDK so developers
    should not be surprised if their Java 8 code no longer works with Java 9\. This
    chapter aims to provide you with insights and processes to get your Java 8 code
    working with Java 9.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将现有的应用程序迁移到 Java 9 平台。我们将查看手动和半自动化的迁移过程。Java 9 是一个重大版本，对 JDK 进行了众多更改，因此如果开发者的
    Java 8 代码不再与 Java 9 兼容，他们不应该感到惊讶。本章旨在为您提供深入了解和过程，以便使您的 Java 8 代码能够在 Java 9 上运行。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Quick review of Project Jigsaw
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Jigsaw 快速回顾
- en: How modules fit into the Java landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块如何在 Java 生态系统中定位
- en: Migration planning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移规划
- en: Advice from Oracle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Oracle 的建议
- en: Useful tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的工具
- en: Quick review of Project Jigsaw
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Jigsaw 快速回顾
- en: 'Project Jigsaw is the Java project that encompasses several change recommendations
    to the Java platform. As you have read in earlier chapters, Java 9''s greatest
    changes involve modules and modularity. The initiative to move to modules in Java
    was driven by Project Jigsaw. The need for modularity stemmed from two major challenges
    with Java:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Project Jigsaw 是一个包含对 Java 平台多个更改建议的 Java 项目。正如您在前面章节中读到的，Java 9 的最大变化涉及模块和模块化。将
    Java 移向模块的倡议是由 Project Jigsaw 驱动的。模块化的需求源于 Java 的两个主要挑战：
- en: Classpath
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径
- en: JDK
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK
- en: Next, we will review both of those challenges and see how they were addressed
    and overcome with the new release to the Java platform, Java 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾这两个挑战，并看看它们是如何在 Java 平台的新版本 Java 9 中得到解决和克服的。
- en: Classpath
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径
- en: 'Prior to Java 9, the classpath was problematic and the source of developer
    anguish. This was evident in the numerous developer forums and, fortunately, Oracle
    was paying attention. Here are the several instances in which the classpath can
    be problematic; here are two primary cases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，类路径存在问题，是开发者痛苦的来源。这在众多开发者论坛中很明显，幸运的是，Oracle 在关注。以下是一些类路径可能成为问题的实例；以下是两个主要案例：
- en: The first case involves having two or more versions of a library on your development
    computer. The way this was previously handled by the Java system was inconsistent.
    Which library was used during the class loading process was anyone's guess. This
    resulted in an undesired lack of specificity--not enough details regarding which
    library was loaded.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个案例涉及在您的开发计算机上拥有两个或更多版本的库。以前，Java 系统处理这种方式的办法不一致。在类加载过程中使用哪个库是任何人都可以猜测的。这导致了一个不希望出现的缺乏具体性——关于加载了哪个库的细节不足。
- en: The second case is in exercising the most advanced features of the class loader.
    Often times, this type of class loader usage resulted in the most errors and bugs.
    These were not always easy to detect and resulted in a lot of extra work for developers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个案例是在使用类加载器的最先进功能。这种类型的类加载器使用往往会导致最多的错误和漏洞。这些问题并不总是容易检测到，并给开发者带来了大量的额外工作。
- en: Classpaths, before Java 9, were almost always very lengthy. Oracle, in a recent
    presentation, shared a classpath that contained 110 JAR files. This type of unwieldy
    classpath makes it difficult to detect conflicts or even determine if anything
    was missing and if so, what might be missing. The re-envisioning of the Java platform
    as a modular system made these classpath issues a thing of the past.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，类路径几乎总是非常长。在最近的一次演讲中，Oracle分享了一个包含110个JAR文件的类路径。这种难以管理的类路径使得检测冲突或确定是否缺少某些内容变得困难，如果缺少，可能缺少什么。将Java平台重新构想为模块化系统使得这些类路径问题成为过去式。
- en: Modules solve the pre-Java 9 classpath problem by providing reliable configuration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过提供可靠的配置解决了Java 9之前的类路径问题。
- en: The monolithic nature of the JDK
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK的单体特性
- en: 'Java has continually evolved in an impressive fashion since 1995 and with each
    evolutionary step, the JDK grew larger. As with Java 8, the JDK had become prohibitively
    large. Prior to Java 9, there were several problematic issues stemming from the
    monolithic nature of the JDK, including:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自1995年以来，Java一直在令人印象深刻地不断发展，并且随着每一次的进化步骤，JDK变得越来越大。与Java 8一样，JDK已经变得过于庞大。在Java
    9之前，由于JDK的单体特性，存在几个问题，包括：
- en: Because the JDK is so large, it does not fit on very small devices. In some
    development sectors this is enough reason to find a non-Java solution for software
    engineering problems.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JDK非常大，它不适合非常小的设备。在一些开发领域，这足以成为寻找非Java解决方案来解决软件工程问题的理由。
- en: The oversized JDK resulted in waste. It was wasteful in terms of processing
    and memory when running on devices, networks, and the cloud. This stems from the
    fact that the entire JDK is loaded, even when only a small subset of the JDK is
    required.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过大的JDK导致了浪费。在设备、网络和云上运行时，在处理和内存方面都造成了浪费。这源于整个JDK被加载，即使只需要JDK的一小部分。
- en: While the Java platform has great performance when running, the startup performance,
    in terms of load and launch times, leaves much to be desired.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Java平台在运行时具有出色的性能，但在加载和启动时间方面，启动性能还有很大的提升空间。
- en: The vast number of internal APIs has also been a pain point. Because so many
    internal APIs existed and were used by developers, the system has been difficult
    to evolve.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量庞大的内部API也是一个痛点。由于存在许多内部API并被开发者使用，系统难以进化。
- en: The existence of internal APIs has made it difficult to make the JDK secure
    and scalable. With so many internal dependencies, isolating security and scalability
    issues has been overly problematic.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部API的存在使得使JDK安全且可扩展变得困难。由于存在许多内部依赖，隔离安全和可扩展性问题变得过于复杂。
- en: The answer to the monolithic woes of the JDK is the module. Java 9 introduced
    the module and its own modular system. One of the great updates to the platform
    is that only the modules needed are compiled, as opposed to the entire JDK. This
    modular system is covered throughout this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决JDK单体问题的答案是模块。Java 9引入了模块及其自身的模块化系统。平台的一个重大更新是，只需编译所需的模块，而不是整个JDK。这个模块化系统在本书中进行了全面介绍。
- en: Modules solve the pre-Java 9 JDK monolithic issue by providing strong encapsulation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过提供强封装解决了Java 9之前的JDK单体问题。
- en: How modules fit into the Java landscape
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块如何融入Java生态
- en: As you can see from the following illustration, packages are comprised of classes
    and interfaces, and modules are comprised of packages. Modules are a container
    of packages. This is the basic premise, at a very high level, of Java 9's new
    modular system. It is important to view modules as part of the modular system
    and not simply as a new level of abstraction above packages, as the illustration
    might suggest.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下插图中所见，包由类和接口组成，模块由包组成。模块是包的容器。这是Java 9新模块化系统的一个非常基本的原理，从非常高的层面来看。重要的是将模块视为模块化系统的一部分，而不仅仅是包之上的一个新抽象级别，如图表可能暗示的那样。
- en: '![](img/882b9ebe-d7f3-4148-9877-d30761fcc485.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/882b9ebe-d7f3-4148-9877-d30761fcc485.png)'
- en: 'So, modules are new to Java 9 and they, as you would expect, require declaration
    before they can be used. A module''s declaration includes names of other modules
    in which it has a dependency. It also exports packages for other modules that
    have dependencies to it. Modular declarations are arguably the most important
    modular issue to address as you start developing with Java 9\. Here is an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块是Java 9的新特性，并且正如你所预期的，在使用之前需要声明。模块的声明包括它所依赖的其他模块的名称。它还导出其他模块依赖的包。模块声明可能是你开始使用Java
    9进行开发时需要解决的最重要模块问题之一。以下是一个示例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When programming a Java 9 application, your module declarations will be placed
    in a `module-info.java` file. Once this file is completed, you simply run `javac`,
    the Java Compiler, to generate the `module-info.class` Java class file. You accomplish
    this task in the same manner that you currently compile your `.java` files into
    `.class` files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程一个Java 9应用程序时，你的模块声明将被放置在一个`module-info.java`文件中。一旦这个文件完成，你只需运行`javac`，Java编译器，来生成`module-info.class`
    Java类文件。你将以与当前将`.java`文件编译成`.class`文件相同的方式完成这项任务。
- en: You can also create modular JAR files that have your `module-info.class` file
    at its root. This represents a great level of flexibility.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建具有根目录中的`module-info.class`文件的模块化JAR文件。这代表了一个很高的灵活性。
- en: Base module
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础模块
- en: 'When programming Java 9 applications, or porting existing applications programmed
    with older versions of Java, the base module (`java.base`) must be used. Every
    module requires the `java.base` module because it defines the critical, or foundational,
    Java platform APIs. Here are the contents of the `java.base` module:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程Java 9应用程序或移植使用较旧版本的Java编写的现有应用程序时，必须使用基本模块（`java.base`）。每个模块都需要`java.base`模块，因为它定义了关键的或基础性的Java平台API。以下是`java.base`模块的内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `java.base` module does not require any modules and it exports
    numerous packages. It can be useful to have a list of these exports handy so you
    know what is available to you as you start creating applications using the new
    Java platform, Java 9.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`java.base`模块不需要任何模块，并导出许多包。在开始使用新的Java平台，Java 9创建应用程序时，有一个这些导出包的列表会很有用。
- en: 'You will notice that in the previous section, we did not include the `requires
    java.base;` line of code in our declaration of our `com.three19.irisScan` module.
    The updated code is provided as follows and now includes the `requires java.base;`
    line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前一节中，我们没有在我们的`com.three19.irisScan`模块声明中包含`requires java.base;`代码行。更新后的代码如下，并现在包含了`requires
    java.base;`代码行：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you do not include the `requires java.base;` line of code in your module
    declarations, the Java Compiler will automatically include it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在你的模块声明中包含`requires java.base;`代码行，Java编译器将自动包含它。
- en: Reliable configuration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠的配置
- en: As suggested earlier in this chapter, modules provide a reliable configuration
    of our Java 9 applications that solves the classpath problem in earlier versions
    of the Java platform.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所建议的，模块为我们提供了Java 9应用程序的可靠配置，解决了Java平台早期版本中的类路径问题。
- en: 'Java reads and interprets modular declarations making the modules readable.
    These readable modules permit the Java platform to determine if any modules are
    missing, if there are duplicate libraries declared, or there are any other conflicts.
    In Java 9, very specific error messages will be generated and output by the compiler
    or at runtime. Here is an example of a compile-time error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Java读取并解释模块声明，使得模块可读。这些可读的模块允许Java平台确定是否有任何模块缺失，是否有重复声明的库，或者存在其他冲突。在Java 9中，编译器或运行时会生成并输出非常具体的错误信息。以下是一个编译时错误的示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an example of a runtime error that would occur if the module `com.three19.isrisCore`
    was not found, but required by the `com.three19.irisScan` app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，如果找不到模块`com.three19.isrisCore`但该模块被`com.three19.irisScan`应用程序所需要，将会发生运行时错误：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Strong encapsulation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强封装
- en: 'Earlier in this chapter, you read that Java 9''s strong encapsulation remedied
    the monolithic JDK issue. Encapsulation, in Java 9, is driven by the information
    in the `module-info.java` file. The information in this file lets Java know what
    modules are dependent upon others and what each of them exports. This underscores
    the importance of ensuring our `module-info-java` files are properly configured.
    Let''s look at an example written with standard Java code, nothing new in Java
    9 in the way this was coded:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，您了解到Java 9的强封装解决了JDK的单一问题。在Java 9中，封装是由 `module-info.java` 文件中的信息驱动的。该文件中的信息让Java知道哪些模块依赖于其他模块，以及每个模块导出了什么。这强调了确保我们的
    `module-info-java` 文件正确配置的重要性。让我们看看一个用标准Java代码编写的示例，这种方式在Java 9中并没有什么新变化：
- en: '![](img/d158dbd8-12a3-4967-8461-1f43137bd878.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d158dbd8-12a3-4967-8461-1f43137bd878.png)'
- en: 'In the preceding example, the `com.three19.irisScan` module has an `irisScanner`
    package intended for internal use and an `irisScanResult` class. If the `com.three19.access`
    application tries to import and use the `irisScanResult` class, the following
    error message will be produced by the Java Compiler:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`com.three19.irisScan` 模块有一个用于内部使用的 `irisScanner` 包和一个 `irisScanResult`
    类。如果 `com.three19.access` 应用程序尝试导入和使用 `irisScanResult` 类，Java编译器将产生以下错误信息：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If for some reason the compiler does not catch this error, although it would
    be very unlikely, the following runtime error would occur:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因编译器没有捕获这个错误，尽管这非常不可能，将会发生以下运行时错误：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The detailed error messages will make debugging and troubleshooting much easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 详细错误信息将使调试和故障排除变得更加容易。
- en: Migration planning
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移规划
- en: The changes to the Java platform are significant and Java 9 is considered a
    major release. It would be naive to think our current Java applications will work
    seamlessly on Java 9\. While that might be the case, at least for simple programs,
    it is prudent to plan ahead and consider the issues you are most likely to encounter.
    Before we look at these issues, let's test a simple Java application in the next
    section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台的变化是显著的，Java 9被认为是一个重大版本。认为我们的当前Java应用程序将在Java 9上无缝运行是过于天真的。虽然这可能适用于简单的程序，但至少在简单程序中，提前规划和考虑您最可能遇到的问题是很明智的。在我们查看这些问题之前，让我们在下一节测试一个简单的Java应用程序。
- en: Testing a simple Java application
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个简单的Java应用程序
- en: 'The following code consists of a single Java class, `GeneratePassword.` This
    class prompts the user for a desired password length and then generates a password
    based on the user''s requested length. If the user asks for a length shorter than
    8, the default length of 8 will be used. This code was written with the Java SE
    1.7 JRE System Library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码由一个单独的Java类 `GeneratePassword.` 组成。该类提示用户输入所需的密码长度，然后根据用户的请求长度生成密码。如果用户请求的长度小于8，则将使用默认长度8。此代码是用Java
    SE 1.7 JRE系统库编写的：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following screenshot, we test the `GeneratePassword` app on a Mac running
    Java 8\. As you can see, we start by querying Java to verify the current version.
    In this test, Java `1.8.0_121` was used. Next, we compile the `GeneratePassword`
    Java file using the `javac` utility. Lastly, we run the app:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们在运行Java 8的Mac上测试了 `GeneratePassword` 应用程序。如您所见，我们首先查询Java以验证当前版本。在这个测试中，使用了Java
    `1.8.0_121`。接下来，我们使用 `javac` 工具编译 `GeneratePassword` Java 文件。最后，我们运行了应用程序：
- en: '![](img/25190f7c-a461-46e7-b135-5fd939b71b8f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25190f7c-a461-46e7-b135-5fd939b71b8f.png)'
- en: As you can see from the preceding test, `GeneratePassword.java` was successfully
    compiled with the `GeneratePassword.class` file resulting. The application was
    run using the `java GeneratePassword` command. The user was prompted for a desired
    password length and `32` was entered. The application then successfully generated
    a 32-character random password and provided the appropriate output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文测试所示，`GeneratePassword.java` 编译成功，生成了 `GeneratePassword.class` 文件。应用程序通过
    `java GeneratePassword` 命令运行。用户被提示输入所需的密码长度，并输入了 `32`。然后应用程序成功生成了一个32位的随机密码并提供了适当的输出。
- en: This test demonstrated the example application works successfully using JDK
    1.8\. Next, let's test the same application using JDK 9.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试证明了示例应用程序在JDK 1.8上成功运行。接下来，让我们使用JDK 9测试同一个应用程序。
- en: 'We start with the `java -version` command to show that we are using JDK 9 on
    this computer. The following screenshot shows that we successfully compiled the
    `.java` file to a `.class` file. When the application was run, it functioned as
    expected and provided the proper results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `java -version` 命令开始，以表明我们在这台计算机上使用 JDK 9。以下截图显示我们成功将 `.java` 文件编译成 `.class`
    文件。当应用程序运行时，它按预期工作并提供了正确的结果：
- en: '![](img/45ce0b95-2ac2-48f6-bd2c-879dbf413f7a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ce0b95-2ac2-48f6-bd2c-879dbf413f7a.png)'
- en: As you can see, we clearly demonstrated that a pre-Java 9 application has the
    potential to successfully run on Java 9 without having to make any modifications.
    This is a simple case study and featured a very basic Java program. This is, of
    course, the best case scenario, and cannot be assumed. You will want to test your
    applications to ensure they run as expected on the Java 9 platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们明确地证明了在 Java 9 之前的应用程序有可能在不进行任何修改的情况下成功运行在 Java 9 上。这是一个简单的案例研究，涉及一个非常基础的
    Java 程序。这当然是最好的情况，但不能假设。您将想要测试您的应用程序，以确保它们在 Java 9 平台上按预期运行。
- en: In the next section, we will review some potential issues you might encounter
    when testing your pre-Java 9 applications using the new Java platform with JDK
    9.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾在测试您的 Java 9 之前的应用程序时可能会遇到的一些潜在问题，我们将使用新的 Java 平台和 JDK 9。
- en: Potential migration issues
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的迁移问题
- en: The potential migration issues featured in this section include direct access
    to the JRE, access to internal APIs, accessing internal JARs, JAR URL depreciation,
    the extension mechanism, and the JDK's modularization. Let's look at each of these
    potential migration issues.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到的潜在迁移问题包括直接访问 JRE、访问内部 API、访问内部 JAR、JAR URL 废弃、扩展机制以及 JDK 的模块化。让我们逐一查看这些潜在的迁移问题。
- en: The JRE
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JRE
- en: 'Creating the Java 9''s modular system resulted in some simplification in respect
    to the number and location of development and utility tools. One such example
    is the JDK''s consumption of the JRE. In all pre-Java 9 versions, the Java platform
    included the JDK and JRE as two separate components. In Java 9, these components
    have been combined. This is a significant change and one that developers should
    be keenly aware of. If you have an application that specifically points to the
    JRE directory, you will need to make changes to avoid problems. The JRE contents
    are shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Java 9 的模块化系统在开发工具和实用工具的数量和位置方面带来了一些简化。一个例子是 JDK 对 JRE 的消耗。在所有 Java 9 之前的版本中，Java
    平台包括 JDK 和 JRE 作为两个单独的组件。在 Java 9 中，这些组件已经被合并。这是一个重大的变化，开发者应该密切关注。如果您有一个指向 JRE
    目录的应用程序，您将需要做出更改以避免问题。JRE 内容如下所示：
- en: '![](img/b3777984-93a8-40e6-8b2b-f30cdef4c8aa.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3777984-93a8-40e6-8b2b-f30cdef4c8aa.png)'
- en: Access to internal APIs
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部 API 的访问
- en: The Java 9 platform has encapsulated internal APIs to increase security of the
    platform and applications written in Java. Applications that you program in Java
    9 will not have default access to the JDK's internal APIs, unlike with previous
    versions of the Java platform. Oracle has identified some internal APIs as critical;
    those APIs remain accessible via the `jdk.unsupported` JDK module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 平台已经封装了内部 API 以提高平台和用 Java 编写的应用程序的安全性。与 Java 平台之前的版本不同，用 Java 9 编写的应用程序将无法默认访问
    JDK 的内部 API。Oracle 已经将一些内部 API 识别为关键；这些 API 通过 `jdk.unsupported` JDK 模块保持可访问。
- en: 'The aforementioned critical APIs (internal to the JDK) are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关键 API（JDK 内部）包括：
- en: '`sun.misc`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc`'
- en: '`sun.misc.Unsafe`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`'
- en: '`sun.reflect.Reflection`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.Reflection`'
- en: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
- en: If you have pre-Java 9 applications that implement any `sun.*` or `com.sun.*`
    package, you will likely run into problems migrating your applications to Java
    9\. In order to address this issue, you should review your class files for use
    of `sun.*` and `com.sun.*` packages. Alternatively, you can use the Java dependency
    analysis tool, `jdeps`, to help determine if your Java program has any dependencies
    on JDK internal APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有在 Java 9 之前实现任何 `sun.*` 或 `com.sun.*` 包的应用程序，您在迁移应用程序到 Java 9 时可能会遇到问题。为了解决这个问题，您应该检查您的类文件以确定是否使用了
    `sun.*` 和 `com.sun.*` 包。或者，您可以使用 Java 依赖分析工具 `jdeps` 来帮助确定您的 Java 程序是否依赖于 JDK
    内部 API。
- en: The `jdeps` tool is the Java dependency analysis tool, that can be used to help
    determine if your Java program has any dependencies on JDK internal APIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps` 工具是 Java 依赖分析工具，可用于帮助确定您的 Java 程序是否依赖于 JDK 内部 API。'
- en: Accessing internal JARs
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问内部JAR文件
- en: 'Java 9 does not permit access to internal JARs such as `lib/ant-javax.jar`,
    `lib/dt.jar`, and others listed in the `lib` directory shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9不允许访问内部JAR文件，如`lib/ant-javax.jar`、`lib/dt.jar`以及在此处显示的`lib`目录中列出的其他文件：
- en: '![](img/d6eaf16e-597f-46c8-a855-be49e3df00e1.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6eaf16e-597f-46c8-a855-be49e3df00e1.png)'
- en: The key thing to note here is that if you have Java applications that are dependent
    on one of these tools residing in the `lib` folder, you will need to modify your
    code accordingly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的关键点是，如果你有依赖于这些工具之一的Java应用程序，这些工具位于`lib`文件夹中，你需要相应地修改你的代码。
- en: It is recommended that you test your IDE once you start using Java 9 to ensure
    the IDE is updated and officially supports Java 9\. If you use more than one IDE
    for Java development, test each one to avoid surprises.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在开始使用Java 9后测试一次你的IDE，以确保IDE已更新并官方支持Java 9。如果你使用多个IDE进行Java开发，测试每一个以避免意外。
- en: JAR URL depreciation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAR URL弃用
- en: 'JAR file URLs were, prior to Java 9, used by some APIs to identify specific
    files in the runtime image. These URLs contain a `jar:file:` prefix with two paths;
    one to the `jar` and one to the specific resource file within the `jar`. Here
    is the syntax for the pre-Java 9 JAR URL:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，JAR文件URL被一些API用来标识运行时图像中的特定文件。这些URL包含一个`jar:file:`前缀和两个路径；一个指向`jar`，另一个指向`jar`内部的具体资源文件。以下是Java
    9之前JAR URL的语法：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the advent of Java 9''s modular system, containers will house resource
    files instead of individual JARs. The new syntax for accessing resource files
    is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 9模块系统的出现，容器将容纳资源文件而不是单个JAR文件。访问资源文件的新语法如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A new URL schema, `jrt`, is now in place for naming resources within a runtime
    image. These resources include classes and modules. The new schema allows for
    the identification of a resource without introducing a security risk to the runtime
    image. This increased security ensures that the runtime image''s form and structure
    remain concealed. Here is the new schema:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新的URL模式`jrt`用于在运行时图像内命名资源。这些资源包括类和模块。新的模式允许在不引入对运行时图像的安全风险的情况下识别资源。这种增强的安全性确保了运行时图像的形式和结构保持隐蔽。以下是新的模式：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Interestingly, a `jrt` URL''s structure determines its meaning, suggesting
    that the structure can take one of several forms. Here are three examples of different
    `jrt` URL structures:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`jrt` URL的结构决定了其含义，表明结构可以采取几种形式之一。以下是三种不同`jrt` URL结构的示例：
- en: '`jrt:/$MODULE/$PATH`: This structure provides access to the resource file,
    identified with the `$PATH` parameter, within the module specified with the `$MODULE`
    parameter'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/$MODULE/$PATH`：这种结构提供了对由`$PATH`参数指定的资源文件的访问，该资源文件位于由`$MODULE`参数指定的模块中'
- en: '`jrt:/$MODULE`: This structure provides reference to all resource files within
    the module specified with the `$MODULE` parameter'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/$MODULE`：这种结构提供了对由`$MODULE`参数指定的模块中所有资源文件的引用'
- en: '`jrt:/`: This structure provides reference to all resource files in the runtime
    image'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/`：这种结构提供了对运行时图像中所有资源文件的引用'
- en: If you have preexisting code that uses URL instances, returned by APIs, you
    should not have any problems. On the other hand, if your code is dependent on
    the `jar` URL structure, you will have problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有的现有代码使用API返回的URL实例，你应该不会有任何问题。另一方面，如果你的代码依赖于`jar` URL结构，你将会有问题。
- en: Extension mechanism
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展机制
- en: 'The Java platform previously had an extension mechanism that gave developers
    the ability to make custom APIs available to all applications. As you can see
    in the following illustration, extensions are plugins of sorts, or add-ons to
    the Java platform. The APIs and classes in each extension are, by default, automatically
    available:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，Java平台之前有一个扩展机制，它允许开发者将自定义API提供给所有应用程序。正如您在下面的插图中所看到的，扩展是某种插件，或者是Java平台的附加组件。每个扩展中的API和类默认情况下都是自动可用的：
- en: '![](img/ab617175-aee5-44af-9913-b458652c65a7.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab617175-aee5-44af-9913-b458652c65a7.png)'
- en: As the illustration suggests, Java applications have access both to the Java
    platform and extensions without requiring classpaths. This feature was depreciated
    in Java 8 and no longer exists in Java 9.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如插图所示，Java应用程序可以访问Java平台和扩展，而无需要求类路径。这个特性在Java 8中被弃用，并且在Java 9中不再存在。
- en: The JDK's modularization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK的模块化
- en: 'By now, you have a firm appreciation of Java 9''s modularization. The old adage
    in Java, and other object-oriented programming language, is *everything is a class*.
    Now, with Java 9, *everything is a module* is the new adage. There are three type
    of modules as explained as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经对Java 9的模块化有了深刻的理解。Java及其它面向对象编程语言中的古老谚语是“万物皆类”。现在，随着Java 9的推出，“万物皆模块”成为了新的谚语。有三种类型的模块，如下所述：
- en: '| **Module type** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **模块类型** | **描述** |'
- en: '| Automatic | When a JAR is placed on a new module path, modules are automatically
    created |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 自动 | 当JAR文件放置在新的模块路径上时，模块会自动创建 |'
- en: '| Explicit/Named | These modules are manually defined by editing the `module-info.java`
    file |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 显式/命名 | 这些模块通过编辑 `module-info.java` 文件手动定义 |'
- en: '| Unnamed | When a JAR is placed on a classpath, unnamed modules are created
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 无名 | 当JAR文件放置在类路径上时，会创建无名模块 |'
- en: When you migrate your applications to Java 9, your application and its libraries
    become unnamed modules. So, you will need to ensure all the modules are in the
    module path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将应用程序迁移到Java 9时，您的应用程序及其库将变为无名称模块。因此，您需要确保所有模块都在模块路径中。
- en: 'Another thing to be aware of is that your runtime image will not contain the
    entire JDK. Instead, it will only contain the modules your application requires.
    It is worth reviewing how the JDK is modularized in Java 9\. The following table
    contains the API specification for the JDK in Java 9:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，您的运行时映像将不会包含整个JDK。相反，它将只包含应用程序所需的模块。值得回顾Java 9中JDK的模块化方式。以下表格包含Java
    9中JDK的API规范：
- en: '| `jdk.accessibility` | `jdk.attach` | `jdk.charsets` | `jdk.compiler` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.accessibility` | `jdk.attach` | `jdk.charsets` | `jdk.compiler` |'
- en: '| `jdk.crypto.cryptoki` | `jdk.crypto.ec` | `jdk.dynalink` | `jdk.editpad`
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.crypto.cryptoki` | `jdk.crypto.ec` | `jdk.dynalink` | `jdk.editpad`
    |'
- en: '| `jdk.hotspot.agent` | `jdk.httpserver` | `jdk.incubator.httpclient` | `jdk.jartool`
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.hotspot.agent` | `jdk.httpserver` | `jdk.incubator.httpclient` | `jdk.jartool`
    |'
- en: '| `jdk.javadoc` | `jdk.jcmd` | `jdk.jconsole` | `jdk.jdeps` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.javadoc` | `jdk.jcmd` | `jdk.jconsole` | `jdk.jdeps` |'
- en: '| `jdk.jdi` | `jdk.jdwp.agent` | `jdk.jlink` | `jdk.jshell` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.jdi` | `jdk.jdwp.agent` | `jdk.jlink` | `jdk.jshell` |'
- en: '| `jdk.jsobject` | `jdk.jstatd` | `jdk.localedata` | `jdk.management` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.jsobject` | `jdk.jstatd` | `jdk.localedata` | `jdk.management` |'
- en: '| `jdk.management.agent` | `jdk.naming.dns` | `jdk.naming.rmi` | `jdk.net`
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.management.agent` | `jdk.naming.dns` | `jdk.naming.rmi` | `jdk.net`
    |'
- en: '| `jdk.pack` | `jdk.packager.services` | `jdk.policytool` | `jdk.rmic` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.pack` | `jdk.packager.services` | `jdk.policytool` | `jdk.rmic` |'
- en: '| `jdk.scripting.nashorn` | `jdk.sctp` | `jdk.security.auth` | `jdk.security.jgss`
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.scripting.nashorn` | `jdk.sctp` | `jdk.security.auth` | `jdk.security.jgss`
    |'
- en: '| `jdk.snmp` | `jdk.xml.dom` | `jdk.zipfs` |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.snmp` | `jdk.xml.dom` | `jdk.zipfs` |  |'
- en: 'The following table contains the API specification for Java SE in Java 9:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含Java 9中Java SE的API规范：
- en: '| `java.activation` | `java.base` | `java.compiler` | `java.cobra` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `java.activation` | `java.base` | `java.compiler` | `java.cobra` |'
- en: '| `java.datatransfer` | `java.desktop` | `java.instrument` | `java.logging`
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `java.datatransfer` | `java.desktop` | `java.instrument` | `java.logging`
    |'
- en: '| `java.management` | `java.management.rmi` | `java.naming` | `java.prefs`
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `java.management` | `java.management.rmi` | `java.naming` | `java.prefs`
    |'
- en: '| `java.rmi` | `java.scripting` | `java.se` | `java.se.ee` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `java.rmi` | `java.scripting` | `java.se` | `java.se.ee` |'
- en: '| `java.security.jgss` | `java.security.sasi` | `java.sql` | `java.sql.rowset`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `java.security.jgss` | `java.security.sasi` | `java.sql` | `java.sql.rowset`
    |'
- en: '| `java.transaction` | `java.xml` | `java.xml.bind` | `java.xml.crypto` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `java.transaction` | `java.xml` | `java.xml.bind` | `java.xml.crypto` |'
- en: '| `java.xml.ws` | `java.xml.ws` | `java.xml.ws.annotation` |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `java.xml.ws` | `java.xml.ws` | `java.xml.ws.annotation` |  |'
- en: Remember, all applications will have access to `java.base` as it is in the module
    path by default.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有应用程序都将默认通过模块路径访问 `java.base`。
- en: 'The following table contains the API specification for JavaFX in Java 9:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含Java 9中JavaFX的API规范：
- en: '| `javafx.base` | `javafx.controls` | `javafx.fxml` | `javafx.graphics` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `javafx.base` | `javafx.controls` | `javafx.fxml` | `javafx.graphics` |'
- en: '| `javafx.media` | `javafx.swing` | `javafx.web` |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `javafx.media` | `javafx.swing` | `javafx.web` |  |'
- en: 'There are two additional modules:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个额外的模块：
- en: '`java.jnlp` defines the API for **JNLP** (**Java Network Launch Protocol**)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.jnlp` 定义了**JNLP**（**Java网络启动协议**）的API'
- en: '`java.smartcardio` defines the API for the Java Smart Card Input/Output'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.smartcardio` 定义了Java智能卡输入/输出的API'
- en: 'For details on any of these modules, visit Oracle''s *Java® Platform, Standard
    Edition & Java Development Kit Version 9 API Specification* website: [http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些模块的详细信息，请访问Oracle的*Java®平台，标准版和Java开发工具包版本9 API规范*网站：[http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html)。
- en: Advice from Oracle
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自Oracle的建议
- en: Oracle has done a great job in bringing us this major update, version 9, to
    the Java platform. Their insights into getting ready for Java 9 and how to migrate
    to the new JDK is worth reviewing. In this section, we will look at preparatory
    steps, breaking encapsulation, changes to the runtime image, components such as
    tools and APIs that have been removed, changes to garbage collection, and deployment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在将这个主要更新，版本9，带到Java平台方面做得非常出色。他们对准备Java 9和如何迁移到新JDK的见解值得回顾。在本节中，我们将探讨准备步骤、打破封装、运行时图像的变化、已删除的工具和API组件、垃圾收集的变化以及部署。
- en: Preparatory steps
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备步骤
- en: 'Oracle provides a five-step process to help developers migrate their Java applications
    to version 9\. These steps are listed as follows and then covered in subsequent
    sections:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle提供了一套五步流程，以帮助开发者将他们的Java应用程序迁移到版本9。这些步骤如下，并在后续章节中进行详细说明：
- en: Get the JDK 9 early access build.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取JDK 9的早期访问构建版本。
- en: Run your program before recompiling.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新编译之前运行你的程序。
- en: Update third-party libraries and tools.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新第三方库和工具。
- en: Compile your application.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的应用程序。
- en: Run `jdeps` on your code.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码上运行`jdeps`。
- en: Getting the JDK 9 early access build
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取JDK 9早期访问构建版本
- en: If you are reading this book before Java 9 is officially released, then you
    can obtain a JDK 9 early access build from here--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    Early release builds are available for Windows (32 and 64), macOS (64), Linux
    (32 and 64) and various Linux ARM, Solaris, and Alpine Linux versions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Java 9正式发布之前阅读这本书，你可以从这里获取JDK 9的早期访问构建版本——[http://jdk.java.net/9/](http://jdk.java.net/9/)。早期发布版本适用于Windows（32位和64位）、macOS（64位）、Linux（32位和64位）以及各种Linux
    ARM、Solaris和Alpine Linux版本。
- en: Taking the time to test your applications for Java 9 and get them migrated before
    Java 9 is officially released, helps ensure you will not experience any downtime
    for services that rely on your Java applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9正式发布之前，花时间测试你的应用程序并迁移它们，有助于确保你不会因为依赖于你的Java应用程序的服务而经历任何停机时间。
- en: Running your program before recompiling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在重新编译之前运行你的程序
- en: As indicated earlier in this chapter, there is a chance that your existing Java
    applications will run without modification on the Java 9 platform. So, before
    you make any changes, try running your current application on the Java 9 platform.
    If your application works fine on Java 9, that is great, but your work is not
    complete. Review the next three sections on updating third-party libraries and
    tools, compiling your application, and running `jdeps` on your code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，你的现有Java应用程序有可能在Java 9平台上无需修改即可运行。因此，在你做出任何更改之前，尝试在Java 9平台上运行你的当前应用程序。如果你的应用程序在Java
    9上运行良好，那很好，但你的工作还没有完成。请回顾下一节关于更新第三方库和工具、编译你的应用程序以及在代码上运行`jdeps`的内容。
- en: Updating third-party libraries and tools
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新第三方库和工具
- en: Third-party libraries and tools can help extend our applications and shorten
    development time. For Java 9 compatibility, it is important to ensure that each
    third-party library and tool you use is compatible with and supports version 9
    of the JDK. Running your application on Java 9 will not provide you with the level
    of insight you need to ensure you do not have compatibility issues down the road.
    It is recommended that you review the official website for each library and tool
    to verify compatibility with and support of JDK 9.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库和工具可以帮助扩展我们的应用程序并缩短开发时间。为了Java 9的兼容性，确保你使用的每个第三方库和工具都与JDK 9兼容并支持该版本非常重要。在Java
    9上运行你的应用程序不会为你提供确保未来没有兼容性问题的洞察力。建议你查看每个库和工具的官方网站，以验证其与JDK 9的兼容性和支持情况。
- en: If a library or tool that you use does have a version that supports JDK 9, download
    and install it. If you find one that does not yet support JDK 9, consider finding
    a replacement for it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的库或工具有一个支持JDK 9的版本，请下载并安装它。如果你找到一个还不支持JDK 9的版本，考虑寻找替代品。
- en: 'In our context, tools includes **Integrated Development Environments** (**IDE**).
    NetBeans, Eclipse, and IntelliJ all have IDE versions that support JDK 9\. Links
    to those sites are provided as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，工具包括**集成开发环境**（**IDE**）。NetBeans、Eclipse 和 IntelliJ 都有支持 JDK 9 的 IDE
    版本。以下提供那些网站的链接：
- en: '**NetBeans**: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetBeans**: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)'
- en: '**Eclipse**: [https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php](https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse**: [https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php](https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php)'
- en: '**IntelliJ**: [https://www.jetbrains.com/idea/nextversion/](https://www.jetbrains.com/idea/nextversion/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ**: [https://www.jetbrains.com/idea/nextversion/](https://www.jetbrains.com/idea/nextversion/)'
- en: Compiling your application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译您的应用程序
- en: Your next step is to compile your application using JDK 9's `javac`. This is
    important, even if your app works fine on JDK 9\. You might not receive compiler
    errors, but watch for warnings too. Here are the most common reasons your applications
    might not compile with JDK 9, assuming they compiled fine prior to Java 9.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一步是使用 JDK 9 的 `javac` 编译您的应用程序。即使您的应用程序在 JDK 9 上运行正常，这也是很重要的。您可能不会收到编译器错误，但也要注意警告。以下是您的应用程序可能无法使用
    JDK 9 编译的最常见原因，假设它们在 Java 9 之前可以编译。
- en: First, as indicated earlier in this chapter, most of the JDK 9 internal APIs
    are not accessible by default. Your indication will be an `IllegalAccessErrors`
    error at runtime or compile time. You will need to update your code so that you
    are using accessible APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如本章前面所述，大多数 JDK 9 内部 API 默认情况下不可访问。您的指示将是在运行时或编译时出现的 `IllegalAccessErrors`
    错误。您需要更新您的代码，以便使用可访问的 API。
- en: 'A second reason your pre-Java 9 applications might not compile with JDK 9 is
    if you use the underscore character as a single character identifier. According
    to Oracle, this practice generates a warning in Java 8 and an error in Java 9\.
    Let''s look at an example. The following Java class instantiates an Object named
    `_` and prints a singular message to the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因可能是您的 Java 9 之前的程序无法使用 JDK 9 编译，如果您使用了下划线字符作为单个字符标识符。根据 Oracle 的说法，这种做法在
    Java 8 中会生成警告，在 Java 9 中会生成错误。让我们看一个例子。以下 Java 类实例化了一个名为 `_` 的对象，并向控制台打印了一条单数消息：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we compile this program with Java 8, we receive a warning that use of
    ''`_`'' as an identifier might not be supported in releases after Java SE 8:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Java 8 编译此程序时，我们会收到一个警告，表明使用 '`_`' 作为标识符可能在 Java SE 8 之后的版本中不受支持：
- en: '![](img/186dc2c5-1bf0-48fc-a3a8-f717c0a30117.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186dc2c5-1bf0-48fc-a3a8-f717c0a30117.png)'
- en: 'As you can see in the following screenshot, that is just a warning and the
    application runs fine:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下面的屏幕截图中所见，这只是一个警告，应用程序运行正常：
- en: '![](img/54bfa604-00e6-4f34-ae21-9b0d281ed85c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54bfa604-00e6-4f34-ae21-9b0d281ed85c.png)'
- en: 'Now, let''s try compiling the same class using JDK 9:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用 JDK 9 编译相同的类：
- en: '![](img/48d8afd2-2a44-4906-adcf-36a7b8c45c16.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48d8afd2-2a44-4906-adcf-36a7b8c45c16.png)'
- en: 'As you can see, use of the underscore as a single character identifier still
    only resulted in a warning and not an error. The application ran successfully.
    This test was run when JDK 9 was still in early release. It is assumed that running
    this test once JDK 9 has been officially released will result in an error instead
    of just a warning. The error that would likely be thrown is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用下划线作为单个字符标识符仍然只会产生警告，而不会产生错误。应用程序运行成功。这次测试是在 JDK 9 仍处于早期发布阶段时运行的。假设一旦
    JDK 9 正式发布，运行此测试将产生错误而不是仅仅警告。可能会抛出的错误如下：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if this issue is not resolved with the formal release of JDK 9, use of
    an underscore as a single character identifier is not good programming practice,
    so you should steer away from using it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个问题在 JDK 9 的正式发布中没有解决，使用下划线作为单个字符标识符也不是好的编程实践，因此您应该避免使用它。
- en: A third potential reason for your pre-Java 9 programmed application not to compile
    with JDK 9 is if you are using the `-source` and `-target` compiler options. Let's
    take a look at the `-source` and `-target` compiler options pre-Java 9 and with
    Java 9.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个可能导致您的 Java 9 之前的程序无法使用 JDK 9 编译的可能原因是您正在使用 `-source` 和 `-target` 编译器选项。让我们看看
    Java 9 之前和 Java 9 中的 `-source` 和 `-target` 编译器选项。
- en: Pre-Java 9 -source and -target options
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 之前的 -source 和 -target 选项
- en: 'The `-source` option specifies the Java SE version and has the following acceptable
    values:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`-source`选项指定了Java SE版本，并具有以下可接受的值：'
- en: '| **Value** | **Description** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| 1.3 | `javac` does not support features introduced after Java SE 1.3. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 1.3 | `javac`不支持Java SE 1.3之后引入的特性。 |'
- en: '| 1.4 | `javac` accepts code with language features introduced in Java SE 1.4.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 1.4 | `javac`接受Java SE 1.4中引入的语言特性。 |'
- en: '| 1.5 or 5 | `javac` accepts code with languages features introduced in Java
    SE 1.5. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 或 5 | `javac`接受Java SE 1.5中引入的语言特性。 |'
- en: '| 1.6 or 6 | `javac` reports encoding errors as errors instead of warnings.
    Of note, no new language features were intruded with Java SE 1.6. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 1.6 或 6 | `javac`将编码错误报告为错误而不是警告。值得注意的是，Java SE 1.6中没有引入新的语言特性。 |'
- en: '| 1.7 or 7 | `javac` accepts code with language features introduced in Java
    SE 1.7\. This is the default value if the `-source` option is not used. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1.7 或 7 | `javac`接受Java SE 1.7中引入的语言特性。如果没有使用`-source`选项，这是默认值。 |'
- en: 'The `-target` option tells `javac` what version of the JVM to target. The acceptable
    values for the `-target` option are--`1.1`, `1.2`, `1.3`, `1.4`, `1.5` or `5`,
    `1.6` or `6` and `1.7` or `7`. If the `-target` option is not used, the default
    JVM target is dependent on the value used with the `-source` option. Here is a
    table of `-source` values with their associated `-target`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`-target`选项告诉`javac`要针对哪个版本的JVM。`-target`选项的可接受值是`1.1`、`1.2`、`1.3`、`1.4`、`1.5`或`5`、`1.6`或`6`和`1.7`或`7`。如果没有使用`-target`选项，默认的JVM目标是依赖于与`-source`选项一起使用的值。以下是`-source`值及其相关`-target`的表格：'
- en: '| **-source value** | **default -target** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **-source值** | **默认-target** |'
- en: '| unspecified | 1.7 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 未指定 | 1.7 |'
- en: '| 1.2 | 1.4 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 1.2 | 1.4 |'
- en: '| 1.3 | 1.4 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1.3 | 1.4 |'
- en: '| 1.4 | 1.4 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 1.4 | 1.4 |'
- en: '| 1.5 or 5 | 1.7 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 或 5 | 1.7 |'
- en: '| 1.6 or 6 | 1.7 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 1.6 或 6 | 1.7 |'
- en: '| 1.7 | 1.7 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 1.7 | 1.7 |'
- en: Java 9 -source and -target options
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 -source和-target选项
- en: 'In Java 9, the supported values are shown as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，支持值如下所示：
- en: '| **Supported values** | **Remarks** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **支持值** | **备注** |'
- en: '| 9 | This is the default, should no value be specified |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 这是默认值，如果没有指定值 |'
- en: '| 8 | Sets support to 1.8 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 设置支持为1.8 |'
- en: '| 7 | Sets support to 1.7 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 设置支持为1.7 |'
- en: '| 6 | Sets support to 1.6 and generates a warning (not an error) to indicate
    JDK 6 is depreciated |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 设置支持为1.6并生成一个警告（不是错误）来指示JDK 6已过时 |'
- en: Running jdeps on your code
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的代码上运行jdeps
- en: The `jdeps` class dependency analysis tool is not new to Java 9, but perhaps
    has never been as important to developers with the advent of Java 9\. An important
    step to migrating your applications to Java 9 is to run the `jdeps` tool to determine
    the dependencies your applications and its libraries have. The `jdeps` tool does
    a great job of suggesting replacements if your code has dependencies on any internal
    APIs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`类依赖分析工具对Java 9来说并不陌生，但也许随着Java 9的到来，它对开发者来说从未如此重要。将你的应用程序迁移到Java 9的重要一步是运行`jdeps`工具，以确定你的应用程序及其库的依赖关系。如果代码依赖于任何内部API，`jdeps`工具会很好地建议替代方案。'
- en: 'The following screenshot shows the options available to you when using the
    `jdeps` analyzer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用`jdeps`分析器时你可以使用的选项：
- en: '![](img/9b466a2c-1863-4887-b1e0-f5084237790f.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b466a2c-1863-4887-b1e0-f5084237790f.png)'
- en: 'Let''s take a look at an example. Here is a simple Java class called `DependencyTest`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。这里有一个简单的Java类，名为`DependencyTest`：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s use `javac` to compile this class using Java 8:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`javac`来使用Java 8编译这个类：
- en: '![](img/e19fbeb0-d819-4916-941f-7ec2c2e68c2c.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e19fbeb0-d819-4916-941f-7ec2c2e68c2c.png)'
- en: 'As you can see, Java 8 successfully compiled the class and the application
    ran. The compiler did give us a `DependencyTest.java:6: warning: BASE64Encoder
    is internal proprietary API and may be removed in a future release` warning. Now,
    let''s see what happens when we try to compile this class using Java 9:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所见，Java 8成功编译了这个类，并且应用程序运行正常。编译器确实给出了一个`DependencyTest.java:6: warning:
    BASE64Encoder 是内部专有API，可能在未来的版本中删除`警告。现在，让我们看看当我们尝试使用Java 9编译这个类时会发生什么：'
- en: '![](img/82447d64-8290-4dfb-bec6-2ca32da76141.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82447d64-8290-4dfb-bec6-2ca32da76141.png)'
- en: 'In this case, with Java 9, the compiler gave us two warnings instead of one.
    The first warning is for the `import sun.misc.BASE64Encoder;` statement and the
    second for the `BASE64Encoder.class.newInstance();` method call. As you can see,
    these are just warnings and not errors, so the `DependencyTest.java` class file
    is successfully compiled. Next, let''s run the application:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 Java 9，编译器给出了两个警告而不是一个。第一个警告是针对 `import sun.misc.BASE64Encoder;` 语句，第二个是针对
    `BASE64Encoder.class.newInstance();` 方法调用。正如你所见，这些只是警告而不是错误，所以 `DependencyTest.java`
    类文件成功编译。接下来，让我们运行应用程序：
- en: '![](img/c8eeaa15-c61c-48f2-9b06-651c9babb345.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8eeaa15-c61c-48f2-9b06-651c9babb345.png)'
- en: 'Now, we can clearly see that Java 9 will not allow us to run the application.
    Next, let''s run a dependency test using the `jdeps` analyzer tool. We will use
    the following command line syntax--`jdeps DependencyTest.class`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到 Java 9 不会允许我们运行应用程序。接下来，让我们使用 `jdeps` 分析器工具运行一个依赖性测试。我们将使用以下命令行语法——`jdeps
    DependencyTest.class`：
- en: '![](img/11dc7d02-3df6-48cf-a67f-a5b060e09c36.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dc7d02-3df6-48cf-a67f-a5b060e09c36.png)'
- en: 'As you can see, we have three dependencies: `java.io`, `java.lang`, and `sun.misc`.
    Here we are given the suggestion to replace our `sun.misc` dependency with `rt.jar`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有三个依赖项：`java.io`、`java.lang` 和 `sun.misc`。在这里，我们被建议将我们的 `sun.misc` 依赖项替换为
    `rt.jar`。
- en: Breaking encapsulation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏封装
- en: The Java 9 platform is more secure than its predecessor versions due to, in
    part, the increased encapsulation that resulted from the modular reorganization.
    That being said, you might have a requirement to break through the modular system's
    encapsulation. Breaking through these access control boundaries is permitted by
    Java 9.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块重组带来的封装性增强，Java 9 平台比其前辈版本更安全。尽管如此，你可能需要突破模块系统的封装。Java 9 允许突破这些访问控制边界。
- en: As you read earlier in this chapter, most internal APIs are strongly encapsulated.
    As previously suggested, you might look for replacement APIs when updating your
    source code. Of course, that is not always feasible. There are three additional
    approaches you can take--using the `--add-opens` option at runtime; employing
    the `--add-exports` option; and `--permit-illegal-access` command-line option.
    Let's look at each of those options.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你在本章前面所读到的，大多数内部 API 都被强封装。正如之前所建议的，在更新源代码时，你可能需要寻找替代 API。当然，这并不总是可行的。你可以采取三种额外的做法——在运行时使用
    `--add-opens` 选项；使用 `--add-exports` 选项；以及 `--permit-illegal-access` 命令行选项。让我们看看这些选项中的每一个。
- en: The --add-opens option
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --add-opens 选项
- en: 'You can use the `--add-opens` runtime option to allow your code to access non-public
    members. This can be referred to as deep reflection. Libraries that do this deep
    reflection are able to access all members, private and public. To grant this type
    of access to your code, you use the `--add-opens` option. Here is the syntax:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `--add-opens` 运行时选项来允许你的代码访问非公共成员。这可以被称为深度反射。执行深度反射的库能够访问所有成员，包括私有和公共成员。为了授予这种访问权限给你的代码，你使用
    `--add-opens` 选项。以下是语法：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows the given module to open the specified package. The compiler will
    not produce any errors or warnings when this is used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许指定的模块打开指定的包。当使用此选项时，编译器不会产生任何错误或警告。
- en: The --add-exports option
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --add-exports 选项
- en: 'You can use `--add-exports` to break encapsulation so that you can use an internal
    API whose default is to be inaccessible. Here is the syntax:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `--add-exports` 来破坏封装，以便你可以使用默认不可访问的内部 API。以下是语法：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command-line option gives code in the `<target-module>` access to types
    in the `<source-module>` package.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令行选项允许 `<target-module>` 中的代码访问 `<source-module>` 包中的类型。
- en: 'Another method of breaking encapsulation is with a JAR file''s manifest. Here
    is an example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏封装的另一种方法是使用 JAR 文件的清单。以下是一个示例：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `--add-exports` command-line option should only be used if deemed absolutely
    necessary. It is not advisable to use this option except for short-term solutions.
    The danger of using it routinely is that any updates to referenced Internal APIs
    could result in your code not working properly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 应仅在认为绝对必要时使用 `--add-exports` 命令行选项。不建议除了短期解决方案之外使用此选项。常规使用此选项的危险在于，任何对引用内部 API
    的更新都可能导致你的代码无法正常工作。
- en: The --permit-illegal-access option
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --permit-illegal-access 选项
- en: A third option for breaking encapsulation is to use the `--permit-illegal-access`
    option. Of course, it is prudent to check with third-party library creators to
    see if they have an updated version. If that is not an option, you use `--permit-illegal-access`
    to gain illegal access to operations to be implemented on the classpath. Due to
    the significantly illegal operation here, you will receive warnings each time
    one of these operations occurs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打破封装的第三种方法是使用`--permit-illegal-access`选项。当然，与第三方库创建者联系以查看他们是否有更新的版本是明智的。如果没有这个选项，您可以使用`--permit-illegal-access`来获取对类路径上要实现的操作的非法访问。由于这里的操作明显非法，每次这些操作发生时，您都会收到警告。
- en: Runtime image changes
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时图像更改
- en: Java 9 represents a major change to the JDK and the JRE. Much of these changes
    are related to modularity and have been covered in other chapters. There are still
    a few more things you should consider.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9对JDK和JRE进行了重大更改。其中许多更改与模块化相关，已在其他章节中介绍。还有一些其他事情您应该考虑。
- en: Java version schema
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java版本架构
- en: 'With Java 9, the way the Java platform''s version is displayed has changed.
    Here is an example of a pre-Java 9 version format:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 9，Java平台版本显示的方式已更改。以下是一个Java 9之前的版本格式的示例：
- en: '![](img/54f8b3ec-7246-42ea-90fc-624045f063da.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54f8b3ec-7246-42ea-90fc-624045f063da.png)'
- en: 'Now, let''s look at how Java 9 reports its version:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Java 9如何报告其版本：
- en: '![](img/d132fdc1-85d2-4ba6-8809-4b4cde084688.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d132fdc1-85d2-4ba6-8809-4b4cde084688.png)'
- en: As you can see, with Java 9, the version schema is now `$MAJOR.$MINOR.$SECURITY.$PATCH`.
    This is markedly different than with previous versions of Java. This will only
    impact your applications if you have code that parses the string returned by the
    `java -version` command and option.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，随着Java 9的发布，版本架构现在为`$MAJOR.$MINOR.$SECURITY.$PATCH`。这与Java的先前版本有显著不同。这只会影响您的应用程序，如果您有解析`java
    -version`命令返回的字符串的代码。
- en: JDK and JRE layout
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK和JRE布局
- en: 'How files are organized in the JDK and the JRE have changed in the new version
    of Java. It is worth your time to familiarize yourself with the new filesystem
    layout. The following screenshot shows the file structure of the JDK''s `/bin`
    folder:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的新版本中，JDK和JRE中的文件组织方式已经发生了变化。花时间熟悉新的文件系统布局是值得的。以下截图显示了JDK的`/bin`文件夹的文件结构：
- en: '![](img/fc9d9d4e-6c5c-4874-b740-c09ce1d1091c.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc9d9d4e-6c5c-4874-b740-c09ce1d1091c.png)'
- en: 'Here is the layout of the `lib` folder:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`lib`文件夹的布局：
- en: '![](img/97375e98-a2ab-4a00-b8fd-2e6f1908f103.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97375e98-a2ab-4a00-b8fd-2e6f1908f103.png)'
- en: What has been removed
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已移除的内容
- en: Another area of change for the new version of the Java platform is that many
    platform components have been removed. The following sections represent the most
    significant components.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java平台的新版本，另一个变化领域是许多平台组件已被移除。以下各节表示最显著的组件。
- en: Notably, the `rt.jar` and `tools.jar` and `dt.jar` have been removed. These
    JAR files contained class and other resources files and all resided in the `/lib`
    directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`rt.jar`、`tools.jar`和`dt.jar`已被移除。这些JAR文件包含类和其他资源文件，并且都位于`/lib`目录中。
- en: The e*ndorsed standards override mechanism* has been removed. In Java 9, both
    `javac` and `java` will exit if they detect that mechanism. The mechanism was
    used for application servers to override some JDK components. In Java 9, you can
    use upgradeable modules to achieve the same result.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`e*ndorsed standards override mechanism`已被移除。在Java 9中，如果`javac`和`java`检测到该机制，它们都会退出。该机制被用于应用程序服务器以覆盖一些JDK组件。在Java
    9中，您可以使用可升级的模块来实现相同的结果。'
- en: As previously covered in this chapter, the e*xtension mechanism* has also been
    removed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章先前所述，`e*xtension mechanism`机制也已移除。
- en: 'The following listed APIs were previously depreciated and have been removed
    and are not accessible in Java 9\. Removal of these APIs is the result of the
    modularization of the Java platform:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的API先前已被弃用，并已移除，在Java 9中不可访问。这些API的移除是Java平台模块化的结果：
- en: '`apple.applescript`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apple.applescript`'
- en: '`com.apple.concurrent`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.apple.concurrent`'
- en: '`com.sun.image.codec.jpeg`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.image.codec.jpeg`'
- en: '`java.awt.dnd.peer`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.dnd.peer`'
- en: '`java.awt.peer`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.peer`'
- en: '`java.rmi.server.disableHttp`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.rmi.server.disableHttp`'
- en: '`java.util.logging.LogManager.addPropertyChangeListener`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging.LogManager.addPropertyChangeListener`'
- en: '`java.util.logging.LogManager.removePropertyChangeListener`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging.LogManager.removePropertyChangeListener`'
- en: '`java.util.jar.Pack200.Packer.addPropertyChangeListener`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Packer.addPropertyChangeListener`'
- en: '`java.util.jar.Pack200.Packer.removePropertyChangeListener`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Packer.removePropertyChangeListener`'
- en: '`java.util.jar.Pack200.Unpacker.addPropertyChangeListener`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Unpacker.addPropertyChangeListener`'
- en: '`java.util.jar.Pack200.Unpacker.removePropertyChangeListener`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Unpacker.removePropertyChangeListener`'
- en: '`javax.management.remote.rmi.RMIIIOPServerImpl`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.management.remote.rmi.RMIIIOPServerImpl`'
- en: '`sun.misc.BASE64Encoder`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.BASE64Encoder`'
- en: '`sun.misc.BASE64Decoder`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.BASE64Decoder`'
- en: '`` `sun.rmi.transport.proxy.connectTimeout` ``'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `sun.rmi.transport.proxy.connectTimeout` ``'
- en: '`sun.rmi.transport.proxy.eagerHttpFallback`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.rmi.transport.proxy.eagerHttpFallback`'
- en: '`sun.rmi.transport.proxy.logLevel`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.rmi.transport.proxy.logLevel`'
- en: '`sun.rmi.transport.tcp.proxy`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.rmi.transport.tcp.proxy`'
- en: 'The following listed tools have been removed. In each case, the tool was previously
    depreciated or its functionality superseded by better alternatives:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的一些工具已被删除。在每种情况下，该工具之前已被淘汰或其功能被更好的替代品所取代：
- en: '`hprof`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hprof`'
- en: '`java-rmi.cgi`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java-rmi.cgi`'
- en: '`java-rmi.exe`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java-rmi.exe`'
- en: '`JavaDB`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JavaDB`'
- en: '`jhat`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhat`'
- en: '`native2ascii`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native2ascii`'
- en: 'Two additional things that have been removed in Java 9 are:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中删除的两个额外功能是：
- en: AppleScript engine. This engine was deemed as unusable and is dropped without
    replacement.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppleScript引擎。这个引擎被认为不可用，并且没有替代品而被删除。
- en: Windows 32-bit client virtual machine. JDK 9 does support a 32-bit server JVM,
    but not a 32-bit client VM. This change was made to focus on the increased performance
    of 64-bit systems.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 32位客户端虚拟机。JDK 9支持32位服务器JVM，但不支持32位客户端VM。这个变化是为了关注64位系统的性能提升。
- en: Updated garbage collection
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新的垃圾收集
- en: 'Garbage collection has been one of Java''s great claims to fame. In Java 9,
    the **Garbage-First** (**G1**) garbage collector is now the default garbage collector
    on both 32- and 64-bit servers. In Java 8, the default garbage collector was the
    parallel garbage collector. Oracle reports that there are three garbage collection
    combinations that will prohibit your application from starting in Java 9\. Those
    combinations are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集一直是Java的伟大成就之一。在Java 9中，**垃圾-首次**（**G1**）垃圾收集器现在是32位和64位服务器上的默认垃圾收集器。在Java
    8中，默认的垃圾收集器是并行垃圾收集器。Oracle报告称，有三种垃圾收集组合将在Java 9中阻止你的应用程序启动。这些组合是：
- en: DefNew + CMS
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DefNew + CMS
- en: Incremental CMS
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量CMS
- en: ParNew + SerialOld
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ParNew + SerialOld
- en: We will take an in-depth look at Java 9 garbage collection in Chapter 7, *Leveraging
    the New Default G1 Garbage Collector*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第7章“利用新的默认G1垃圾收集器”中深入探讨Java 9的垃圾收集。
- en: Deployment
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: There are three issues that you should be aware of, in the context of migrating
    to Java 9, when you are deploying your applications. These issues are JRE version
    selection, serialized applets, and the update to the JNLP.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序迁移到Java 9的背景下，你应该注意三个问题，这些问题是在部署你的应用程序时出现的。这些问题是JRE版本选择、序列化小程序和JNLP的更新。
- en: '**JNLP** is the acronym for **Java Network Launch Protocol** and is covered
    in a later section of this chapter.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**JNLP**是**Java网络启动协议**的缩写，将在本章的后续部分中介绍。'
- en: JRE version selection
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JRE版本选择
- en: 'Prior to Java 9, developers could request a JRE version other than the version
    being launched when launching an application. This could be accomplished with
    a command-line option or with a proper JAR file manifest configuration. This feature
    has been removed in JDK 9 because of the way we typically deploy applications.
    Here are the three primary methods:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，开发人员可以在启动应用程序时请求除正在启动的版本之外的JRE版本。这可以通过命令行选项或适当的JAR文件清单配置来实现。由于我们通常部署应用程序的方式，这个特性在JDK
    9中被删除。以下是三种主要方法：
- en: Active installers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活安装程序
- en: '**Java Web Start** using JNLP'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Web Start**使用JNLP'
- en: Native OS packaging systems
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生操作系统打包系统
- en: Serialized applets
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化小程序
- en: Java 9 does not support the ability to deploy applets as serialized objects.
    In the past, applets were deployed as serialized objects to compensate for slow
    compression and JVM performance issues. With Java 9, compression techniques are
    advanced and the JVM has great performance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9不支持将小程序作为序列化对象部署的能力。在过去，小程序作为序列化对象部署以补偿缓慢的压缩和JVM性能问题。随着Java 9的推出，压缩技术更加先进，JVM性能也更好。
- en: If you attempt to deploy your applets as serialized objects, your object attributes
    and parameter tags will simply be ignored when your applet launches. Starting
    with Java 9, you can deploy your applets using standard deployment strategies.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将你的小程序作为序列化对象部署，当你的小程序启动时，你的对象属性和参数标签将被简单地忽略。从Java 9开始，你可以使用标准的部署策略来部署你的小程序。
- en: JNLP update
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JNLP更新
- en: The JNLP is used for launching applications on a desktop client using resources
    located on a web server. JNLP clients include Java Web Start and Java Plug-in
    software because they are able to launch applets that are remotely hosted. This
    protocol is instrumental in launching RIAs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: JNLP 用于在桌面客户端使用位于 Web 服务器上的资源启动应用程序。JNLP 客户端包括 Java Web Start 和 Java Plug-in
    软件，因为它们能够启动远程托管的小程序。此协议对于启动 RIAs 至关重要。
- en: '**RIAs** are **Rich Internet Applications** and when launched with JNLP have
    access to the various JNLP APIs that, with user permission, can access the user''s
    desktop.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**RIAs** 是 **富互联网应用程序**，当使用 JNLP 启动时，可以访问各种 JNLP API，在用户许可的情况下，可以访问用户的桌面。'
- en: In Java 9, the JNLP specification has been updated. There are four specific
    updates as detailed in the next sections.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，JNLP 规范已更新。以下几节详细介绍了四个具体的更新。
- en: Nested resources
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套资源
- en: 'The ability to use component extensions with nest resources in Java or j2se
    elements was previously supported, but not documented in the specification. The
    specification has now been updated to reflect this support. The previous specification
    read:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 或 j2se 元素中使用具有嵌套资源的组件扩展之前已被支持，但在规范中未进行记录。规范现已更新以反映这一支持。之前的规范如下：
- en: No java elements can be specified as part of the resources.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 不能将任何 java 元素指定为资源的一部分。
- en: 'The updated specification for Java 9 now reads:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 的更新规范现在如下所示：
- en: A java element in a component extension will not govern what version of java
    is used, but may be used containing nested resource elements, and then those resources
    may be used only when using a Java version that matches the given version as specified
    in section 4.6
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 组件扩展中的 java 元素不会控制使用哪个版本的 java，但可以包含嵌套资源元素，然后只有在使用与第 4.6 节中指定的版本匹配的 Java 版本时，才能使用这些资源。
- en: This specific change ensures that extension JLP files must have `java` or `j2se`
    resources and those resources will not dictate what JRE is used. Nested resources
    are permitted when using the specified version.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的更改确保扩展 JLP 文件必须包含 `java` 或 `j2se` 资源，并且这些资源不会决定使用哪个 JRE。当使用指定版本时，允许嵌套资源。
- en: FX XML extension
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FX XML 扩展
- en: 'When using the JNLP, you create a JNLP file. Here is an example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 JNLP 时，你创建一个 JNLP 文件。以下是一个示例：
- en: '[PRE17]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Two changes have been made to the `<application-desc>` element. First, the
    optional `type` attribute has been added so the type of application can be annotated.
    The default type is `Java`, so if your program is a Java app, you need not include
    the `type` attribute. Alternatively, you can specify `Java` as your type as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `<application-desc>` 元素进行了两项更改。首先，添加了可选的 `type` 属性，以便可以对应用程序类型进行注释。默认类型是 `Java`，因此如果你的程序是
    Java 应用程序，你不需要包含 `type` 属性。或者，你可以如下指定 `Java` 作为你的类型：
- en: '[PRE18]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can indicate other application types to include `JavaFX` as shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指示其他应用类型，例如在此处所示包含 `JavaFX`：
- en: '[PRE19]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you indicate an application type that is not supported by the JNLP client,
    your application launch will fail. For more information about JNLP, you can consult
    the official documentation: [http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html](http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了一个 JNLP 客户端不支持的应用程序类型，你的应用程序启动将失败。有关 JNLP 的更多信息，你可以查阅官方文档：[http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html](http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html)。
- en: 'The second change to the `<application-desc>` element in Java 9 is the addition
    of the `param` sub-element. This allows us to provide the name of parameters along
    with their value using the `value` attribute. Here is an example of how an `<application-desc>`
    element of a JNLP file looks with the `param` sub-element and the `value` attribute
    included. This example shows three sets of parameters:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中 `<application-desc>` 元素的第二个更改是添加了 `param` 子元素。这允许我们使用 `value` 属性提供参数的名称及其值。以下是一个包含
    `param` 子元素和 `value` 属性的 `<application-desc>` 元素的 JNLP 文件示例。此示例显示了三组参数：
- en: '[PRE20]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the application `type` is Java, then any `param` sub-elements you use will
    be ignored.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用的 `type` 是 Java，那么你使用的任何 `param` 子元素都将被忽略。
- en: JNLP file syntax
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JNLP 文件语法
- en: JNLP file syntax is now in complete compliance with XML specifications. Prior
    to Java 9, you could use `&` to create complex comparisons. That is not supported
    with standard XML. You can still create complex comparisons in JNLP files. Now
    you will use `&amp;` instead of `&`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: JNLP 文件语法现在完全符合 XML 规范。在 Java 9 之前，你可以使用 `&` 来创建复杂的比较。这不被标准 XML 支持。你仍然可以在 JNLP
    文件中创建复杂的比较。现在你将使用 `&amp;` 而不是 `&`。
- en: Numeric version comparison
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字版本比较
- en: The JNLP specification has been changed to reflect how numeric version elements
    were compared against non-numeric version elements. Previous to the change, version
    elements were compared lexicographically by ASCII value. With Java 9 and this
    JNLP specification change, elements are still compared lexicographically by ASCII
    value. The change is evident when the two strings have different lengths. In new
    comparisons, the shorter string will be padded with leading zeros to match the
    length of the longer string.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: JNLP 规范已被更改，以反映数字版本元素与非数字版本元素之间的比较方式。在更改之前，版本元素通过 ASCII 值进行字典序比较。在 Java 9 和这个
    JNLP 规范更改之后，元素仍然通过 ASCII 值进行字典序比较。当两个字符串长度不同时，这种变化是明显的。在新比较中，较短的字符串将被前导零填充，以匹配较长的字符串长度。
- en: Lexicographical comparisons use a mathematical model that is based on alphabetical
    order.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 字典序比较使用基于字母顺序的数学模型。
- en: Useful tools
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的工具
- en: 'The first thing you will need to do before migrating your applications to Java
    9 is to download JDK 9\. You can download the early access builds at this URL--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    You will need to accept the license agreement and then select which build to download.
    As you can see in the following screenshot, there are several options based on
    your operating system:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的应用程序迁移到 Java 9 之前，你需要做的第一件事是下载 JDK 9。你可以通过这个网址下载早期访问版本--[http://jdk.java.net/9/](http://jdk.java.net/9/)。你需要接受许可协议，然后选择要下载的构建版本。正如你在以下截图中所看到的，根据你的操作系统，有几个选项：
- en: '![](img/ad5ae026-64d1-4c22-a76d-19c56266be94.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad5ae026-64d1-4c22-a76d-19c56266be94.png)'
- en: Now that you have JDK 9 installed on your development computer, let's look at
    a couple of tools that can help facilitate migrating your applications to Java
    9.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在你的开发计算机上安装了 JDK 9，让我们看看一些可以帮助你将应用程序迁移到 Java 9 的工具。
- en: Java environment - jEnv
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 环境 - jEnv
- en: If you develop on a computer with Linux or macOS, you might consider using `jEnv`,
    an open source Java environment management tool. This is a command-line tool,
    so do not expect a GUI. You can download the tool at this URL--[https://github.com/gcuisinier/jenv](https://github.com/gcuisinier/jenv).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个运行 Linux 或 macOS 的计算机上开发，你可能考虑使用 `jEnv`，这是一个开源的 Java 环境管理工具。这是一个命令行工具，所以不要期待有图形用户界面。你可以通过这个网址下载这个工具--[https://github.com/gcuisinier/jenv](https://github.com/gcuisinier/jenv)。
- en: 'Here is the installation command for Linux:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Linux 的安装命令：
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To download using macOS with Homebrew, use this command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 macOS 和 Homebrew 下载，请使用以下命令：
- en: '[PRE22]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also install on Linux or macOS using `Bash` as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下方式在 Linux 或 macOS 上使用 `Bash` 安装：
- en: '[PRE23]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can install on Linux or macOS using `Zsh` as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下方式在 Linux 或 macOS 上使用 `Zsh` 安装：
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you have `jEnv` installed, you will need to configure it on your system
    as shown here. You will need to modify the script to reflect your actual path:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在你安装了 `jEnv` 之后，你需要按照以下方式在你的系统上配置它。你需要修改脚本以反映你的实际路径：
- en: '[PRE25]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will want to repeat the `jenv add` command for each version of the JDK
    on your system. With each `jenv add` command, you will receive confirmation that
    the specific JDK version was added to `jEnv` as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要为系统上的每个 JDK 版本重复执行 `jenv add` 命令。对于每个 `jenv add` 命令，你将收到确认，具体 JDK 版本已被添加到
    `jEnv`，如下所示：
- en: '[PRE26]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check to see what JDK versions you have added to your `jEnv` by using
    `$ jenv versions` at the Command Prompt. This will result in an output list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令提示符中使用 `$ jenv versions` 来检查你添加到 `jEnv` 的 JDK 版本。这将生成一个输出列表。
- en: 'Here are three additional `jEnv` commands:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三个额外的 `jEnv` 命令：
- en: '`jenv global <version>`: this sets the global version'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenv global <version>`：这将为全局设置版本'
- en: '`jenv local <version>`: this sets the local version'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenv local <version>`：这将为本地设置版本'
- en: '`jenv shell <version>`: this sets the instance version for the shell'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenv shell <version>`：这将为 shell 设置实例版本'
- en: Maven
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven
- en: 'Maven is an open source tool that can be used for building and managing Java-based
    projects. It already supports Java 9 and is part of the *Apache Maven Project*.
    If you are not already using Maven and you do a lot of Java development you might
    be enticed by the following Maven objectives:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是一个开源工具，可用于构建和管理基于Java的项目。它已经支持Java 9，并作为*Apache Maven项目*的一部分。如果您尚未使用Maven，并且进行大量Java开发，您可能会被以下Maven目标所吸引：
- en: Making the build process easy
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使构建过程变得简单
- en: Providing a uniform build system
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供统一的构建系统
- en: Providing quality project information
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供高质量的项目信息
- en: Providing guidelines for best practices development
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供最佳实践开发的指南
- en: Allowing transparent migration to new features
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许透明迁移到新功能
- en: You can read more specifics about each of the Maven objectives at this site--[https://maven.apache.org/what-is-maven.html](https://maven.apache.org/what-is-maven.html).
    To download Maven, visit this site--[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
    Installation instructions for Windows, macOS, Linux, and Solaris are available
    here--[https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此站点阅读有关每个Maven目标的更多详细信息--[https://maven.apache.org/what-is-maven.html](https://maven.apache.org/what-is-maven.html)。要下载Maven，请访问此站点--[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)。Windows、macOS、Linux和Solaris的安装说明可在以下位置找到--[https://maven.apache.org/install.html](https://maven.apache.org/install.html)。
- en: 'Maven can be integrated with Eclipse (M2Eclipse), JetBrains IntelliJ IDEA,
    and the Netbeans IDE. The M2Eclipse IDE, as an example, provides rich integration
    with Apache Maven and boasts the following features:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Maven可以与Eclipse（M2Eclipse）、JetBrains IntelliJ IDEA和Netbeans IDE集成。以M2Eclipse
    IDE为例，它提供了丰富的Apache Maven集成，并具有以下功能：
- en: You can launch Maven builds from within Eclipse
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从Eclipse内部启动Maven构建
- en: Manage your dependencies for the Eclipse build path
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理Eclipse构建路径的依赖项
- en: Easily resolve Maven dependencies (you can do this directly from Eclipse and
    not have to install a local Maven repository)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易解决Maven依赖项（您可以直接从Eclipse操作，而无需安装本地Maven仓库）
- en: Automatically download required dependencies (from remote Maven repositories)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动下载所需的依赖项（从远程Maven仓库）
- en: Use software wizards to create new Maven projects, create `pom.xml` files, and
    to enable Maven support for your plain Java projects
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用软件向导创建新的Maven项目，创建`pom.xml`文件，并启用对您的纯Java项目的Maven支持
- en: Rapid dependency search of Maven remote repositories
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven远程仓库的快速依赖项搜索
- en: Obtaining the M2Eclipse IDE
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取M2Eclipse IDE
- en: 'To obtain the M2Eclipse IDE, you must first have Eclipse installed. Here are
    the steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取M2Eclipse IDE，您必须首先安装Eclipse。以下是步骤：
- en: 'Start by opening your current Eclipse IDE. Next, select Preferences | Install/Update
    | Available Software Sites as shown in the following screenshot:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您的当前Eclipse IDE。接下来，选择首选项 | 安装/更新 | 可用软件站点，如以下截图所示：
- en: '![](img/2ba63e52-cdb6-41ec-a3ea-3f03c64989ba.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba63e52-cdb6-41ec-a3ea-3f03c64989ba.png)'
- en: 'The next task is to add the M2Eclipse repository site to your list of Available
    Software Sites. To accomplish this, click the Add button and enter values in the
    Name and Location text input boxes. For Name, enter something to help you remember
    that M2Eclipse is available at this site. For Location, enter the URL--`http://download.eclipse.org/technology/m2e/releases`.
    Then, click the OK button:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个任务是向您的可用软件站点列表中添加M2Eclipse仓库站点。为此，请点击“添加”按钮，并在名称和位置文本输入框中输入值。对于名称，输入一些可以帮助您记住M2Eclipse位于此站点的信息。对于位置，输入URL--`http://download.eclipse.org/technology/m2e/releases`。然后，点击“确定”按钮：
- en: '![](img/265485fa-f472-4fad-8b9a-aeb1a2074ef0.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/265485fa-f472-4fad-8b9a-aeb1a2074ef0.png)'
- en: 'You should now see the M2Eclipse site listed in your list of Available Software
    Sites as shown in the following screenshot. Your final step is to click the OK
    button:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该看到M2Eclipse站点列在您的可用软件站点列表中，如以下截图所示。您的最后一步是点击“确定”按钮：
- en: '![](img/b4d352e8-46d9-43f7-8cb2-5ed6810d3da3.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4d352e8-46d9-43f7-8cb2-5ed6810d3da3.png)'
- en: 'Now, when you start a new project, you will see `Maven Project` as an option:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您开始一个新项目时，您将看到“Maven项目”作为选项：
- en: '![](img/850c5e6f-e1a4-4c01-8892-93abd6f12262.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/850c5e6f-e1a4-4c01-8892-93abd6f12262.png)'
- en: 'Maven is a proven tool for Java developers. You might consider obtaining additional
    information on Maven with one of the following resources:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是Java开发者证明有效的工具。您可以考虑通过以下资源之一获取有关Maven的更多信息：
- en: '*Apache Maven Project*: [https://maven.apache.org/index.html](https://maven.apache.org/index.html)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Maven项目*：[https://maven.apache.org/index.html](https://maven.apache.org/index.html)'
- en: '*Apache Maven Cookbook*: [https://www.packtpub.com/application-development/apache-maven-cookbook](https://www.packtpub.com/application-development/apache-maven-cookbook)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Maven 烹饪书*: [https://www.packtpub.com/application-development/apache-maven-cookbook](https://www.packtpub.com/application-development/apache-maven-cookbook)'
- en: '*Apache Maven 3.o Cookbook*: [https://www.packtpub.com/application-development/apache-maven-3-cookbook](https://www.packtpub.com/application-development/apache-maven-3-cookbook)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Maven 3.0 烹饪书*: [https://www.packtpub.com/application-development/apache-maven-3-cookbook](https://www.packtpub.com/application-development/apache-maven-3-cookbook)'
- en: '*Getting Started with Apache Maven [Video]*: [https://www.packtpub.com/application-development/getting-started-apache-maven-video](https://www.packtpub.com/application-development/getting-started-apache-maven-video)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Maven 入门 [视频]*: [https://www.packtpub.com/application-development/getting-started-apache-maven-video](https://www.packtpub.com/application-development/getting-started-apache-maven-video)'
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored potential issues involved in migrating our existing
    applications to the Java 9 platform. We looked at both manual and semi-automated
    migration processes. This chapter provided you with insights and processes to
    get your Java 8 code working with Java 9\. Specifically, we conducted a quick
    review of Project Jigsaw, looked at how modules fit into the Java landscape, provided
    tips for migration planning, shared advice from Oracle regarding migration, and
    shared tools that you can use to help you as you get started with Java 9.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了将现有应用程序迁移到 Java 9 平台可能涉及的问题。我们考虑了手动和半自动迁移过程。本章为您提供了使您的 Java 8 代码与
    Java 9 兼容的见解和流程。具体来说，我们对 Project Jigsaw 进行了快速回顾，探讨了模块如何融入 Java 生态系统，提供了迁移规划的建议，分享了
    Oracle 关于迁移的建议，并分享了您在开始使用 Java 9 时可以使用的工具。
- en: In the next chapter, we will take a close look at the Java shell and the JShell
    API. We demonstrate the JShell API and the JShell tool's ability to interactively
    evaluate declarations, statements, and expressions of the Java programming language.
    We will demonstrate features and use of this command-line tool.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将仔细研究 Java Shell 和 JShell API。我们将展示 JShell API 和 JShell 工具交互式评估 Java
    编程语言的声明、语句和表达式的功能。我们将演示这个命令行工具的功能和使用方法。
