- en: Chapter 7. Playing with Globals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。玩转全局变量
- en: 'Sometimes web applications require application-wide objects that live beyond
    the request-response life cycle, such as database connections, application configuration,
    shared objects, and cross-cutting concerns (authentication, error handling, and
    so on). Consider the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时网络应用程序需要生存期超出请求-响应生命周期的应用程序范围内的对象，例如数据库连接、应用程序配置、共享对象和横切关注点（如身份验证、错误处理等）。考虑以下情况：
- en: Ensuring that the database used by the application is defined and accessible.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序使用的数据库已定义且可访问。
- en: Notify through e-mail or any other service when the application is receiving
    unexpected heavy traffic.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序接收意外的大量流量时，通过电子邮件或任何其他服务进行通知。
- en: Logging the different requests served by the application. These logs can later
    be used to analyze user behavior.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录应用程序服务的不同请求。这些日志可以稍后用于分析用户行为。
- en: Restricting certain facilities on the web application by time. For example,
    some food ordering apps take orders only between 11 a.m. to 8 p.m., while all
    requests to build orders at any other time will be blocked and a message about
    the timings will be displayed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过时间限制网络应用程序上的某些功能。例如，一些食品订购应用程序仅在上午 11 点到晚上 8 点之间接收订单，而任何其他时间对构建订单的请求都将被阻止，并显示关于时间的信息。
- en: Generally, when a user sends an e-mail and the recipient's email ID is incorrect
    or not in use, the sender is notified about the failure in delivering the e-mail
    only after 12 to 24 hrs. In this duration, further attempts are made to send the
    e-mail.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，当用户发送电子邮件且收件人的电子邮件 ID 错误或未使用时，发送者只有在 12 到 24 小时后才会被通知电子邮件发送失败。在此期间，会尝试再次发送电子邮件。
- en: Applications with in-app sales allow users to retry with the same or different
    payment options when payment has been declined for various reasons.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户在支付因各种原因被拒绝时，使用相同的或不同的支付选项重试的应用程序。
- en: In a Play Framework app, by convention, all of these various concerns can be
    managed through GlobalSettings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Play 框架应用程序中，按照惯例，所有这些各种关注点都可以通过 GlobalSettings 来管理。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: GlobalSettings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlobalSettings
- en: Application life cycle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序生命周期
- en: Request-response life cycle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应生命周期
- en: GlobalSettings
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlobalSettings
- en: Every Play application has a global object which can be used to define application-wide
    objects. It can also be used to customize the application's life cycle and the
    request-response life cycle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Play 应用程序都有一个全局对象，可以用来定义应用程序范围内的对象。它还可以用来自定义应用程序的生命周期和请求-响应生命周期。
- en: 'The global object for an application can be defined by extending the trait
    `GlobalSettings`. By default, the name of the object is expected to be `Global`
    and it is assumed to be in the `app` directory. This can be changed by updating
    `application.global` in the `conf/application.conf` property. For example, if
    we wish to use a file with `AppSettings` in the `app/com/org` name:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的全局对象可以通过扩展 `GlobalSettings` 特质来定义。默认情况下，对象的名称预期为 `Global`，并且假定它位于 `app`
    目录中。这可以通过更新 `conf/application.conf` 属性中的 `application.global` 来更改。例如，如果我们希望使用
    `app/com/org` 命名空间中的 `AppSettings` 文件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `GlobalSettings` trait has methods that can be used to interrupt both the
    application's life cycle and the request-response life cycle. We will see its
    methods as and when required in the following sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalSettings` 特质具有可以用来中断应用程序生命周期和请求-响应生命周期的方法。我们将在以下章节中根据需要查看其方法。'
- en: Now, let's see how this works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是如何工作的。
- en: An app developed through the Play Framework is represented by an instance of
    the `Application` trait, since its creation and the build is to be handled by
    the framework itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Play 框架开发的应用程序由 `Application` 特质的实例表示，因为其创建和构建将由框架本身处理。
- en: 'The `Application` trait is extended by `DefaultApplication` and `FakeApplication`.
    `FakeApplication` is a helper that tests Play applications and we will see more
    of it in [Chapter 9](ch09.html "Chapter 9. Testing"), *Testing*. `DefaultApplication`
    is defined as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 特质由 `DefaultApplication` 和 `FakeApplication` 扩展。`FakeApplication`
    是一个用于测试 Play 应用程序的帮助程序，我们将在第 9 章[测试](ch09.html "第 9 章。测试")中看到更多关于它的内容。`DefaultApplication`
    定义如下：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `WithDefaultConfiguration` and `WithDefaultPlugins` traits are used to
    initialize the application''s configuration and plugin objects, respectively.
    The `WithDefaultGlobal` trait is the one responsible for setting the correct global
    object for the application. It is defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDefaultConfiguration`和`WithDefaultPlugins`特质分别用于初始化应用程序的配置和插件对象。`WithDefaultGlobal`特质负责为应用程序设置正确的全局对象。它定义如下：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `globalInstance` object is the `global` object to be used for this application.
    It is set to `javaGlobal` or `scalaGlobal`, whichever is applicable to the application.
    If the application does not have custom Global object configured for the application,
    the application''s `global` is set to `DefaultGlobal`. It is defined as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalInstance`对象是用于此应用程序的`global`对象。它设置为`javaGlobal`或`scalaGlobal`，具体取决于应用程序。如果应用程序没有为应用程序配置自定义的Global对象，则应用程序的`global`设置为`DefaultGlobal`。它定义如下：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The life cycle of an application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的生命周期
- en: 'An application''s life cycle has two states: **running** and **stopped**. These
    are times when the state of the application changes. At times, we need to perform
    some operations right before or after a state change has occurred or is about
    to occur.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的生命周期有两个状态：**运行**和**停止**。这些是应用程序状态发生变化的时间。有时，我们需要在状态变化之前或之后立即执行某些操作。
- en: 'Play applications use a Netty server. For this, a class with the same name
    is used. It is defined as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Play应用程序使用Netty服务器。为此，使用具有相同名称的类。它定义如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class is responsible for binding or bootstrapping the application to the
    server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此类负责将应用程序绑定或引导到服务器。
- en: 'The `ApplicationProvider` trait is defined as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationProvider`特质定义如下：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An implementation of `ApplicationProvider` must create and initialize an application.
    Currently, there are three different implementations of `ApplicationProvider`.
    They are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationProvider`的实现必须创建并初始化一个应用程序。目前，有三种不同的`ApplicationProvider`实现。它们如下：'
- en: '`StaticApplication`: This is to be used in the production mode (the mode where
    code changes do not affect an already running application).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaticApplication`：这个用于生产模式（代码更改不会影响已运行的应用程序的模式）。'
- en: '`ReloadableApplication`: This is to be used in the development mode (this is
    a mode where continuous compilation is enabled so that developers can see the
    impact of changes in an application as and when they are saved, if the application
    is up and running).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReloadableApplication`：这个用于开发模式（这是一个启用了连续编译的模式，以便开发者可以在保存时看到应用程序更改的影响，如果应用程序正在运行的话）。'
- en: '`TestApplication`: This is to be used in the testing mode (the mode where a
    fake application is started through the tests).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestApplication`：这个用于测试模式（通过测试启动一个模拟应用程序的模式）。'
- en: '`StaticApplication` and `ReloadableApplication` both initialize a `DefaultApplication`.
    `StaticApplication` is used in the production mode and is defined as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticApplication`和`ReloadableApplication`都初始化一个`DefaultApplication`。`StaticApplication`用于生产模式，定义如下：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ReloadableApplication` is used in the development mode but, since the class
    definition is huge, let''s see the relevant lines of code where `DefaultApplication`
    is used:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReloadableApplication`用于开发模式，但由于类定义很大，让我们看看使用`DefaultApplication`的相关代码行：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For `StaticApplication`, the application is created and started just once whereas,
    in the case of `ReloadableApplication`, the existing application is stopped and
    a new one is created and started. The `ReloadableApplication` is for the development
    mode, so as to allow developers to make changes and see them reflected without
    the hassle of reloading the application manually every time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`StaticApplication`，应用程序只创建和启动一次，而`ReloadableApplication`则会停止现有应用程序，创建并启动一个新的应用程序。`ReloadableApplication`用于开发模式，以便开发者可以做出更改并看到它们的效果，而无需每次都手动重新加载应用程序。
- en: 'The usage of `ApplicationProvider` and `NettyServer` is similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationProvider`和`NettyServer`的使用与此类似：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the following section, we will discuss the methods available in GlobalSettings,
    which enable us to hook into the application's life cycle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论GlobalSettings中可用的方法，这些方法使我们能够挂钩到应用程序的生命周期。
- en: Meddling with an application's life cycle
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 干预应用程序的生命周期
- en: 'Consider that our application has the following specifications:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的应用程序有以下规格：
- en: Prior to starting the application, we need to ensure that the `/opt/dev/appName`
    directory exists and is accessible by the application. A method in our application
    called `ResourceHandler.initialize` does this task.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始应用程序之前，我们需要确保 `/opt/dev/appName` 目录存在并且可以被应用程序访问。我们应用程序中的一个名为 `ResourceHandler.initialize`
    的方法来完成这个任务。
- en: Create the required schema on startup using the `DBHandler.createSchema` method.
    This method does not drop the schema if it already exists. This ensures that the
    application's data is not lost on restarting the application and the schema is
    generated only when the application is first started.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DBHandler.createSchema` 方法在启动时创建所需的模式。此方法不会删除已存在的模式。这确保了在重新启动应用程序时应用程序的数据不会丢失，并且模式仅在应用程序首次启动时生成。
- en: Create e-mail application logs when the application is stopped using the `Mailer.sendLogs`
    method. This method sends the application logs as an attachment in an e-mail to
    the `emailId` set in a configuration file as `adminEmail`. This is used to track
    the cause for the application's shutdown.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `Mailer.sendLogs` 方法停止应用程序时，创建电子邮件应用程序日志。此方法将应用程序日志作为附件通过电子邮件发送到配置文件中设置为
    `adminEmail` 的 `emailId`。这用于追踪应用程序关闭的原因。
- en: Play provides methods that allow us to hook into the application's life cycle
    and complete such tasks. The `GlobalSettings` trait has methods that assist in
    doing so. These can be overridden by the `Global` object, if required.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Play 提供了允许我们挂钩到应用程序的生命周期并完成此类任务的方法。`GlobalSettings` 特性具有辅助执行这些任务的方法。如果需要，这些方法可以通过
    `Global` 对象进行覆盖。
- en: 'To cater to the specifications of the application described earlier, all we
    need to do in a Play application is define a `Global` object, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足前面描述的应用程序规范，在 Play 应用程序中我们只需要定义一个 `Global` 对象，如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ResourceHandler.initialize`, `DBHandler.createSchema`, and `Mailer.sendLogs`
    methods are specific to our application and are defined by us, not provided by
    Play.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceHandler.initialize`、`DBHandler.createSchema` 和 `Mailer.sendLogs` 方法是针对我们的应用程序特定的，由我们定义，而不是由
    Play 提供。'
- en: Now that we know how to hook into the application's life cycle, let's scrutinize
    how it works.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何挂钩到应用程序的生命周期，让我们仔细看看它是如何工作的。
- en: 'Digging deeper into the application''s life cycle we can see that all the implementations
    of `ApplicationProvider` use the `Play.start` method to initialize an application.
    The `Play.start` method is defined as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘应用程序的生命周期，我们可以看到所有 `ApplicationProvider` 的实现都使用 `Play.start` 方法来初始化一个应用程序。`Play.start`
    方法定义如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method ensures that each plugin''s `onStart` method is called right after
    the application is set as `_currentApp`. `GlobalPlugin`, is added by default to
    all the Play applications, and is defined as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法确保在将应用程序设置为 `_currentApp` 之后立即调用每个插件的 `onStart` 方法。`GlobalPlugin` 默认添加到所有
    Play 应用程序中，并定义为：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, `app.global` refers to the GlobalSettings defined
    for the application. Therefore, the GlobalPlugin ensures that the appropriate
    methods of the application's GlobalSettings are called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`app.global` 指的是为应用程序定义的 `GlobalSettings`。因此，`GlobalPlugin` 确保调用应用程序
    `GlobalSettings` 的适当方法。
- en: The `beforeStart` method is called on initialization of the plugin.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件初始化时调用 `beforeStart` 方法。
- en: 'Now, we just need to figure out how `onStop` is called. Once an application
    is stopped, `ApplicationProvider` does not have control, so the Java runtime shutdown
    hook is used to ensure that certain tasks are executed once the application is
    stopped. Here is a look at the relevant lines from the `NettyServer.createServer`
    method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要弄清楚 `onStop` 是如何被调用的。一旦应用程序停止，`ApplicationProvider` 就没有控制权了，因此使用 Java
    运行时关闭钩子来确保应用程序停止后执行某些任务。以下是 `NettyServer.createServer` 方法中的相关代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, runtime is java.lang.Runtime (Java docs for the same are available at
    [http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html))
    and the `server` is an instance of NettyServer. NettyServer''s `stop` method is
    defined as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，运行时是 `java.lang.Runtime`（有关相同内容的 Java 文档可在 [http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html)
    查找），而 `server` 是 `NettyServer` 的一个实例。`NettyServer` 的 `stop` 方法定义如下：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `Invoker.lazySystem.close()` call is used to shut down the ActorSystem
    used internally within a Play application. The `Execution.lazyContext.close()`
    call is to shut down Play's internal `ExecutionContext`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `Invoker.lazySystem.close()` 调用来关闭 Play 应用程序内部使用的 ActorSystem。`Execution.lazyContext.close()`
    调用是为了关闭 Play 的内部 `ExecutionContext`。
- en: 'The `Play.stop` method is defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play.stop` 方法定义如下：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method calls the `onStop` method of all the registered plugins in reverse
    order, so the GlobalPlugin's `onStop` method is called and it eventually calls
    the `onStop` method of the `GlobalSetting` defined for the application. Any errors
    encountered in this process are logged as warnings since the application is going
    to be stopped.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法以相反的顺序调用所有已注册插件的 `onStop` 方法，因此 GlobalPlugin 的 `onStop` 方法被调用，并最终调用为应用程序定义的
    `GlobalSetting` 的 `onStop` 方法。在这个过程中遇到的任何错误都被记录为警告，因为应用程序即将停止。
- en: We can now add any task within the application's life cycle, such as creating
    database schemas before starting, initializing global objects, or scheduling jobs
    (using Akka Scheduler or Quartz, and so on) on starting and cleaning temporary
    data when stopping.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在应用程序的生命周期中添加任何任务，例如在启动前创建数据库模式，初始化全局对象，或者在停止时清理临时数据。
- en: We've covered the application's life cycle, now let's look into the request-response
    life cycle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了应用程序的生命周期，现在让我们看看请求-响应生命周期。
- en: The request-response life cycle
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应生命周期
- en: The Play Framework uses Netty by default, so requests are received by NettyServer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Play 框架默认使用 Netty，因此请求由 NettyServer 接收。
- en: Netty allows a variety of actions including custom coding through handlers.
    We can define a handler that transforms a request into a desired response and
    provides it to Netty when bootstrapping the application. To integrate a Play app
    with Netty, `PlayDefaultUpstreamHandler` is used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Netty 允许执行各种操作，包括通过处理器进行自定义编码。我们可以定义一个处理器，将请求转换为所需的响应，并在启动应用程序时将其提供给 Netty。为了将
    Play 应用程序与 Netty 集成，使用 `PlayDefaultUpstreamHandler`。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For additional information on requests used in Netty, refer to Netty docs at
    [http://netty.io/wiki/user-guide-for-4.x.html](http://netty.io/wiki/user-guide-for-4.x.html)
    and Netty ChannelPipeline docs at [http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html](http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Netty 中使用的请求的更多信息，请参阅 Netty 文档[http://netty.io/wiki/user-guide-for-4.x.html](http://netty.io/wiki/user-guide-for-4.x.html)和
    Netty ChannelPipeline 文档[http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html](http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html)。
- en: '`PlayDefaultUpstreamHandler` extends `org.jboss.netty.channel.SimpleChannelUpstreamHandler`
    to handle both HTTP and WebSocket requests. It is used when bootstrapping the
    application to Netty in the following way:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayDefaultUpstreamHandler` 扩展了 `org.jboss.netty.channel.SimpleChannelUpstreamHandler`
    以处理 HTTP 和 WebSocket 请求。它在以下方式启动应用程序到 Netty 时使用：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `messageReceived` method of `SimpleChannelUpStreamHandler` is responsible
    for acting on the received request. `PlayDefaultUpstreamHandler` overwrites this
    so that requests are sent to our application. This method is too long (around
    260 lines, including comments and blank lines), so we will only look at relevant
    blocks here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleChannelUpStreamHandler` 的 `messageReceived` 方法负责对收到的请求采取行动。`PlayDefaultUpstreamHandler`
    覆盖了此方法，以便将请求发送到我们的应用程序。此方法太长（包括注释和空白行约为 260 行），所以我们在这里只查看相关块。'
- en: 'First, a Play `RequestHeader` is created for the message received and its corresponding
    action is found:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为接收到的消息创建一个 Play `RequestHeader`，并找到其对应的行为：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding snippet, the `tryToCreateRequest` method results in `RequestHeader`
    and any exceptions encountered in this process are handled. The action for the
    `RequestHeader rh` is then fetched through `server.getHandlerFor(rh)`. Here, a
    `server` is an instance of the server trait and the `getHandlerFor` method utilizes
    the application''s `global` object and its `onRequestReceived` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`tryToCreateRequest` 方法生成了 `RequestHeader`，并且在这个过程中遇到的任何异常都被处理了。然后通过
    `server.getHandlerFor(rh)` 获取 `RequestHeader rh` 的动作。在这里，一个 `server` 是服务器特质的实例，而
    `getHandlerFor` 方法利用了应用程序的 `global` 对象及其 `onRequestReceived` 方法：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `messageReceived` method of `PlayDefaultUpstreamHandler`, the action
    obtained from `server.getHandlerFor` is eventually called, resulting in a response.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlayDefaultUpstreamHandler` 的 `messageReceived` 方法中，从 `server.getHandlerFor`
    获取的动作最终被调用，从而产生响应。
- en: Most of the interactions of `PlayDefaultUpStreamHandler` with the application
    are through its global object. In the following section, we will see the methods
    available in GlobalSettings related to the request-response life cycle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayDefaultUpStreamHandler` 与应用程序的大部分交互都是通过其全局对象进行的。在下一节中，我们将看到与请求-响应生命周期相关的
    GlobalSettings 中的可用方法。'
- en: Fiddling with the request-response life cycle
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩弄请求-响应生命周期
- en: The `GlobalSettings` trait has methods related to different stages of the application's
    life cycle as well as its request-response life cycle. Using the request-related
    hooks, we can define business logic when a request is received, when an action
    is not found for the request, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalSettings` 特性包含与应用程序生命周期不同阶段以及其请求-响应生命周期相关的各种方法。使用请求相关的钩子，我们可以在接收到请求、找不到请求的操作等情况下定义业务逻辑。'
- en: 'The request-related methods are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与请求相关的各种方法：
- en: '`onRouteRequest`: This uses a router to identify the action for a given `RequestHeader`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRouteRequest`：此方法使用路由器来识别给定 `RequestHeader` 的操作'
- en: '`onRequestReceived`: This results in `RequestHeader` and its action. Internally,
    it calls the `onRouteRequest` method'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRequestReceived`：这会产生 `RequestHeader` 和其操作。内部，它调用 `onRouteRequest` 方法'
- en: '`doFilter`: This adds a filter to the application'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFilter`：这向应用程序添加了一个过滤器'
- en: '`onError`: This is a method that handles exceptions when processing'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：这是一个处理处理过程中异常的方法'
- en: '`onHandlerNotFound`: This is used when a RequestHeader''s corresponding action
    cannot be found'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onHandlerNotFound`：当找不到 RequestHeader 对应的操作时使用'
- en: '`onBadRequest`: This is used internally when the request body is incorrect'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBadRequest`：当请求体不正确时内部使用'
- en: '`onRequestCompletion`: This is used to perform operations after a request has
    been processed successfully'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRequestCompletion`：用于在请求成功处理之后执行操作'
- en: Manipulating requests and their responses
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作请求及其响应
- en: 'In some applications, it is mandatory to filter, modify, redirect requests,
    and their responses. Consider these examples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，强制过滤、修改、重定向请求及其响应是必要的。考虑以下示例：
- en: Requests for any service must have headers that contain session details and
    user identities except for instances, such as logins, registers, and forgetting
    passwords
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何服务的请求都必须包含包含会话详情和用户身份的头，除非是登录、注册和忘记密码等实例
- en: All requests made for a path starting with `admin` must be restricted by the
    user role
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以 `admin` 开头的路径请求都必须受到用户角色的限制
- en: Redirect requests to regional sites if possible (such as Google)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，将请求重定向到区域站点（例如 Google）
- en: Add additional fields to the request or response
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向请求或响应添加额外的字段
- en: The `onRequestReceived`, `onRouteRequest`, `doFilter`, and `onRequestCompletion`
    methods can be used to intercept the request or its response and manipulate them
    as per requirements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `onRequestReceived`、`onRouteRequest`、`doFilter` 和 `onRequestCompletion`
    方法来拦截请求或其响应，并根据要求对其进行操作。
- en: 'Let''s look at the `onRequestReceived` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `onRequestReceived` 方法：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It fetches the corresponding handler for a given `RequestHeader` using the `onRouteRequest`
    and `doFilter` methods. If no handler is found, the result from `onHandlerNotFound`
    is sent.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `onRouteRequest` 和 `doFilter` 方法获取给定 `RequestHeader` 对应的处理程序。如果没有找到处理程序，则发送
    `onHandlerNotFound` 的结果。
- en: Since the `onRequestReceived` method plays a critical role in how the requests
    are processed, sometimes it may be simpler to override the `onRouteRequest` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `onRequestReceived` 方法在请求处理方式中起着关键作用，有时可能更简单的是覆盖 `onRouteRequest` 方法。
- en: 'The `onRouteRequest` method is defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRouteRequest` 方法定义如下：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the router is the application's `router` object. By default, it is the
    generated object created from `conf/routes` on compilation. A router extends the
    `Router.Routes` trait and the `handlerFor` method is defined in this trait.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，路由器是应用程序的 `router` 对象。默认情况下，它是编译时从 `conf/routes` 生成的对象。路由器扩展了 `Router.Routes`
    特性，并且 `handlerFor` 方法定义在这个特性中。
- en: 'Let''s try to implement a solution for blocking requests to services other
    than `login`, `forgotPassword`, and `register` if the request header does not
    have the session and user details. We can do so by overriding `onRouteRequest`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现一个解决方案，以阻止对 `login`、`forgotPassword` 和 `register` 之外的服务进行请求，如果请求头没有会话和用户详情。我们可以通过覆盖
    `onRouteRequest` 来做到这一点：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we check if the requested path has restricted access. If so, we check
    if the necessary headers are available and valid. Only then is the corresponding
    `Handler` returned, else `Handler` for an invalid session is returned. A similar
    approach can be followed if we need to control the access based on the user's
    role.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查请求的路径是否有受限访问。如果有，我们检查必要的头是否可用且有效。只有在这种情况下，才会返回相应的 `Handler`，否则返回无效会话的
    `Handler`。如果需要根据用户的角色来控制访问，可以遵循类似的方法。
- en: 'We can also use the `onRouteRequest` method to provide compatibility for older
    deprecated services. For example, if the older version of the application had
    a `GET /user/:userId` service that has now been modified to `/api/user/:userId`,
    and there are other applications that rely on this application, our application
    should support requests for both the paths. However, the routes file only lists
    the new paths and services, which means that we should handle these before attempting
    to access the application''s supported routes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `onRouteRequest` 方法为旧版已弃用的服务提供兼容性。例如，如果旧版应用程序有一个 `GET /user/:userId`
    服务，现在已被修改为 `/api/user/:userId`，并且有其他应用程序依赖于这个应用程序，那么我们的应用程序应该支持这两个路径的请求。然而，路由文件只列出了新路径和服务，这意味着在尝试访问应用程序支持的路径之前，我们应该处理这些请求：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `getSupportedPath` is a custom method that gives a new path for a given
    old path. We create a new `RequestHeader` with the updated fields and forward
    this to the following methods instead of the original `RequestHeader`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSupportedPath` 是一个自定义方法，它为给定的旧路径提供一个新路径。我们创建一个新的 `RequestHeader` 并带有更新后的字段，然后将这个新
    `RequestHeader` 传递给后续的方法，而不是使用原始的 `RequestHeader`。'
- en: Similarly, we could add/modify the headers or any other field(s) of `RequestHeader`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以添加/修改 `RequestHeader` 的头部或任何其他字段。
- en: 'The `doFilter` method can be used to add filters, similar to those shown in
    [Chapter 2](ch02.html "Chapter 2. Defining Actions"), *Defining Actions*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`doFilter` 方法可以用来添加过滤器，类似于在[第2章](ch02.html "第2章。定义动作") *定义动作* 中展示的：'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, we can extend the `WithFilters` class instead of `GlobalSettings`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以扩展 `WithFilters` 类而不是 `GlobalSettings`：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `WithFilters` class extends `GlobalSettings` and overrides the `doFilter`
    method with the `Filter` passed in its constructor. It is defined as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithFilters` 类扩展了 `GlobalSettings` 并用构造函数中传入的 `Filter` 覆盖了 `doFilter` 方法。它定义如下：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `onRequestCompletion` method can be used to perform specific tasks after
    a request has been processed. For example, suppose that the application needs
    a requirement to persist data from specific GET requests, such as Search. This
    can come in handy to understand and analyze what the users are looking for in
    our application. Persisting information from requests prior to fetching data can
    considerably increase the response time and hamper user experience. Therefore,
    it will be better if this is done after the response has been sent:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRequestCompletion` 方法可以在请求被处理后执行特定任务。例如，假设应用程序需要从特定的GET请求（如搜索）中持久化数据。这有助于理解和分析用户在我们的应用程序中寻找什么。在获取数据之前从请求中持久化信息可以显著增加响应时间并损害用户体验。因此，在发送响应之后进行此操作会更好：'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tackling errors and exceptions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: 'An application cannot exist without handling errors and exceptions. Based on
    the business logic, the way they are handled may differ from application to application.
    Play provides certain standard implementations which can be overridden in the
    application''s global object. The `onError` method is called when an exception
    occurs and is defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序如果不能处理错误和异常是无法存在的。根据业务逻辑，它们被处理的方式可能因应用程序而异。Play提供了一些标准实现，这些实现可以在应用程序的全局对象中被覆盖。当发生异常时，会调用
    `onError` 方法，定义如下：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`UsefulException` is an abstract class, which extends `RuntimeException`. It
    is extended by the `PlayException` helper. The default implementation of `onError`
    (in the previous code snippet) simply checks whether the application is in the
    production mode or in the development mode and sends the corresponding view as
    `Result`. This method results in the `defaultpages.error` or `defaultpages.devError`
    view.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsefulException` 是一个抽象类，它扩展了 `RuntimeException`。它由 `PlayException` 辅助类扩展。`onError`
    的默认实现（在之前的代码片段中）简单地检查应用程序是否处于生产模式或开发模式，并发送相应的视图作为 `Result`。这种方法会导致 `defaultpages.error`
    或 `defaultpages.devError` 视图。'
- en: 'Suppose we want to send a response with a status 500 and the exception instead.
    We can easily do so by overriding the `onError` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要发送一个状态为500的响应，并包含异常。我们可以通过覆盖 `onError` 方法轻松实现：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `onHandlerNotFound` method is called when a user sends a request with a
    path that is not defined in `conf/routes`. It is defined as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发送一个在 `conf/routes` 中未定义路径的请求时，会调用 `onHandlerNotFound` 方法。它定义如下：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It sends a view as a response, depending on the mode in which the application
    was started. In the development mode, the view contains an error message, which
    tells us that an action is defined for the route and the list of supported paths
    with the request type. We can override this, if required.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它会根据应用启动的模式发送一个视图作为响应。在开发模式下，视图包含一个错误消息，告诉我们为该路由定义了一个动作，以及带有请求类型的支持路径列表。如果需要，我们可以覆盖这个行为。
- en: 'The `onBadRequest` method is called in the following situations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下会调用`onBadRequest`方法：
- en: The request is sent and its corresponding action has a different content type
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求被发送，并且其对应动作具有不同的内容类型
- en: Some of the parameters are missing in the request sent and, when parsing, the
    request throws an exception
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中缺少一些参数，并且在解析时请求抛出异常
- en: 'It is defined as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它被定义为如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This method also sends a view in response but, in most applications, we would
    like to send `BadRequest` with the error message and not the view. This can be
    achieved by overriding the default implementation, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也会发送一个视图作为响应，但在大多数应用中，我们希望发送带有错误消息的`BadRequest`而不是视图。这可以通过覆盖默认实现来实现，如下所示：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the features provided to a Play application through
    a global plugin. By extending `GlobalSettings`, we can hook into the application's
    life cycle and perform various tasks at different phases. Apart from hooks used
    for the application life cycle, we have also discussed hooks for the request-response
    life cycle, through which we can intercept requests and responses and modify them,
    if required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了通过全局插件提供给Play应用的特性。通过扩展`GlobalSettings`，我们可以挂钩到应用的生命周期，并在不同阶段执行各种任务。除了用于应用生命周期的钩子外，我们还讨论了用于请求-响应生命周期的钩子，通过这些钩子我们可以拦截请求和响应，并在必要时修改它们。
