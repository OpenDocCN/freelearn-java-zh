- en: Chapter 4. Projectiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。投射物
- en: '|   | *"Flying is learning how to throw yourself at the ground and miss."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"飞行就是学会将自己扔向地面并错过。" |   |'
- en: '|   | --*Douglas Adams* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*道格拉斯·亚当斯* |'
- en: Actors in creative Greenfoot applications, such as games and animations, often
    have movement that can best be described as *being launched*. For example, a soccer
    ball, bullet, laser, light ray, baseball, and firework are examples of this type
    of object. One common method of implementing this type of movement is to create
    a set of classes that model real-world physical properties (mass, velocity, acceleration,
    friction, and so on) and have game or simulation actors inherit from these classes.
    Some refer to this as creating a *physics engine* for your game or simulation.
    However, this course of action is complex and often overkill. As you learned in
    [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, there are often
    simple heuristics we can use to approximate realistic motion. This is the approach
    we will take here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在创意Greenfoot应用中，如游戏和动画，演员通常具有最佳描述为**发射**的运动。例如，足球、子弹、激光、光束、棒球和烟花都是这类物体的例子。实现这种运动的一种常见方法是为一组模拟现实世界物理属性（质量、速度、加速度、摩擦等）的类创建一个集合，并让游戏或模拟演员从这些类中继承。有些人把这称为为你的游戏或模拟创建一个**物理引擎**。然而，这种方法复杂且往往过度。正如你在[第二章](part0017.xhtml
    "第二章。动画")中学习的，*动画*，我们通常可以使用一些简单的启发式方法来近似现实运动。这就是我们将采取的方法。
- en: 'In this chapter, you will learn about the basics of projectiles, how to make
    an object bounce, and a little about particle effects. We will apply what you
    learn to a small platform game that we will build up over the course of this chapter.
    In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解投射物的基础知识，如何使物体弹跳，以及一些关于粒子效果的知识。我们将把所学知识应用到我们将在本章中构建的小型平台游戏中。在本章中，我们将涵盖以下主题：
- en: Gravity and jumping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力和跳跃
- en: Bouncing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹跳
- en: Particle effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果
- en: Bullets and turrets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹和炮塔
- en: Creating realistic flying objects is not simple, but we will cover this topic
    in a methodical, step-by-step approach, and when we are done, you will be able
    to populate your creative scenarios with a wide variety of flying, jumping, and
    launched objects. It's not as simple as Douglas Adams makes it sound in his quote,
    but nothing worth learning ever is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建逼真的飞行物体并不简单，但我们将以系统、分步骤的方法来介绍这个主题，当我们完成时，你将能够用各种飞行、跳跃和发射物体来丰富你的创意场景。这并不像道格拉斯·亚当斯在他的引语中所说的那么简单，但任何值得学习的东西都不简单。
- en: Cupcake Counter
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛋糕计数器
- en: It is beneficial to the learning process to discuss topics in the context of
    complete scenarios. Doing this forces us to handle issues that might be elided
    in smaller, one-off examples. In this chapter, we will build a simple platform
    game called **Cupcake Counter** (shown in *Figure 1*). We will first look at a
    majority of the code for the **World** and **Actor** classes in this game without
    showing the code implementing the topic of this chapter, that is, the different
    forms of projectile-based movement. We will then present and explain the missing
    code in subsequent sections. This is the same approach we took in the preceding
    chapter, in order to study collision detection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整场景的背景下讨论主题对学习过程有益。这样做迫使我们处理在较小、一次性示例中可能被省略的问题。在本章中，我们将构建一个简单的平台游戏，称为**蛋糕计数器**（如图1所示）。我们将首先查看游戏中**世界**和**演员**类的大多数代码，而不展示实现本章主题的代码，即基于投射物的不同形式。然后，在随后的章节中，我们将展示并解释缺失的代码。这与前一章中我们采取的方法相同，以便研究碰撞检测。
- en: '![Cupcake Counter](img/image00287.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![蛋糕计数器](img/image00287.jpeg)'
- en: 'Figure 1: This is a screenshot of Cupcake Counter'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是蛋糕计数器的截图
- en: How to play
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩
- en: The goal of **Cupcake Counter** is to collect as many cupcakes as you can before
    being hit by either a ball or a fountain. The left and right arrow keys move your
    character left and right and the up arrow key makes your character jump. You can
    also use the space bar key to jump. After touching a cupcake, it will disappear
    and reappear randomly on another platform. Balls will be fired from the turret
    at the top of the screen and fountains will appear periodically. The game will
    increase in difficulty as your cupcake count goes up. The game requires good jumping
    and avoiding skills.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cupcake Counter** 的目标是收集尽可能多的纸杯蛋糕，在被球或喷泉击中之前。左右箭头键控制角色左右移动，上箭头键使角色跳跃。您还可以使用空格键跳跃。触摸纸杯蛋糕后，它将消失并随机出现在另一个平台上。球将从屏幕顶部的炮塔发射出来，喷泉会定期出现。随着纸杯蛋糕数量的增加，游戏难度将增加。游戏需要良好的跳跃和躲避技巧。'
- en: Implementing Cupcake Counter
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现纸杯蛋糕计数器
- en: 'Create a scenario called `Cupcake Counter` and add each class to it as they
    are discussed. If you prefer, you can download the initial version of Cupcake
    Counter from: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Cupcake Counter` 的场景，并将每个类按讨论的顺序添加到其中。如果您愿意，您可以从以下链接下载纸杯蛋糕计数器的初始版本：[http://www.packtpub.com/support](http://www.packtpub.com/support)
- en: The CupcakeWorld class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CupcakeWorld 类
- en: 'This subclass of `World` sets up all the actors associated with the scenario,
    including a score. It is also responsible for generating periodic enemies, generating
    rewards, and increasing the difficulty of the game over time. The following is
    the code for this class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `World` 子类设置了与场景相关的所有演员，包括得分。它还负责生成周期性敌人，生成奖励，并随着时间的推移增加游戏的难度。以下是这个类的代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's discuss the methods in this class in order. First, we have the class constructor
    `CupcakeWorld()`. After calling the constructor of the superclass, it calls `setPaintOrder()`
    to set the actors that will appear in front of other actors when displayed on
    the screen. You were introduced to `setPaintOrder()` in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. The main reason why we use it here, is so
    that no actor will cover up the `Counter` class, which is used to display the
    score. Next, the constructor method calls `prepare()` to add and place the initial
    actors into the scenario. We will discuss the `prepare()` method later in this
    section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序讨论这个类中的方法。首先，我们有类构造函数 `CupcakeWorld()`。在调用超类构造函数之后，它调用 `setPaintOrder()`
    来设置在屏幕上显示时将出现在其他演员前面的演员。您在 [第 2 章](part0017.xhtml "第 2 章。动画") *动画* 中介绍了 `setPaintOrder()`。我们在这里使用它的主要原因是为了确保没有任何演员会覆盖用于显示得分的
    `Counter` 类。接下来，构造函数方法调用 `prepare()` 来添加并将初始演员放置到场景中。我们将在本节后面讨论 `prepare()` 方法。
- en: Inside the `act()` method, we will only call the function `checkLevel()`. As
    the player scores points in the game, the `level` variable of the game will also
    increase. The `checkLevel()` function will change the game a bit according to
    its `level` variable. When our game first starts, no enemies are generated and
    the player can easily get the cupcake (the reward). This gives the player a chance
    to get accustomed to jumping on platforms. As the cupcake count goes up, balls
    and fountains will be added. As the level continues to rise, `checkLevel()` reduces
    the delay between creating balls (`BCOUNT`) and fountains (`FCOUNT`). The `level`
    variable of the game is increased in the `addCupcakeCount()` method, which we
    will discuss in detail soon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `act()` 方法内部，我们只会调用 `checkLevel()` 函数。随着玩家在游戏中获得分数，游戏的 `level` 变量也会增加。`checkLevel()`
    函数将根据其 `level` 变量稍微改变游戏。当我们的游戏第一次开始时，不会生成敌人，玩家可以轻松地得到纸杯蛋糕（奖励）。这给了玩家一个熟悉在平台上跳跃的机会。随着纸杯蛋糕数量的增加，球和喷泉将被添加。随着级别的持续上升，`checkLevel()`
    减少了创建球 (`BCOUNT`) 和喷泉 (`FCOUNT`) 之间的延迟。游戏 `level` 变量在 `addCupcakeCount()` 方法中增加，我们将在下面详细讨论。
- en: The `generateFountains()` method adds a `Fountain` actor to the scenario. The
    rate at which we create fountains is controlled by the delay variable (refer to,
    [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation* to review) `fountainContainer`.
    After the delay, we create a fountain on a randomly chosen `Brick` (the platforms
    in our game). The `getObjects()` method returns all of the actors of a given class
    presently in the scenario. We then use `getRandomNumber()` to randomly choose
    a number between one and the number of `Brick` actors. Next, we use `addObject()`
    to place the new `Fountain` object on the randomly chosen `Brick` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateFountains()`方法向场景中添加一个`Fountain`演员。我们创建喷泉的速度由延迟变量（参考，[第二章](part0017.xhtml
    "第二章。动画")，“动画”）`fountainContainer`控制。延迟后，我们在随机选择的`Brick`（我们游戏中的平台）上创建一个喷泉。`getObjects()`方法返回场景中给定类的所有演员。然后我们使用`getRandomNumber()`随机选择一个介于1和`Brick`演员数量之间的数字。接下来，我们使用`addObject()`将新的`Fountain`对象放置在随机选择的`Brick`对象上。'
- en: Generating balls using the `generateBalls()` method is a little easier than
    generating fountains. All balls are created in the same location as the `turret`
    at the top of the screen and sent from there with a randomly chosen trajectory.
    The rate at which we generate new `Ball` actors is defined by the delay variable
    `ballCounter`. Once we create a `Ball` actor, we rotate the `turret` based on
    its *x* velocity. By doing this, we create the illusion that the turret is aiming
    and then firing `Ball Actor`. Last, we place the newly created `Ball` actor into
    the scenario using the `addObject()` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`generateBalls()`方法生成球体比生成喷泉要简单一些。所有球体都是在屏幕顶部的`turret`所在位置创建的，并从那里以随机选择的轨迹发送出去。我们生成新的`Ball`演员的速度由延迟变量`ballCounter`定义。一旦我们创建了一个`Ball`演员，我们就根据其*x*速度旋转`turret`。通过这样做，我们创造了一种错觉，即`turret`正在瞄准然后发射`Ball
    Actor`。最后，我们使用`addObject()`方法将新创建的`Ball`演员放入场景中。
- en: The `addCupcakeCount()` method is called by the actor representing the player
    (`Bob`) every time the player collides with `Cupcake`. In this method, we increase
    `score` and then call `generateNewCupcake()` to add a new `Cupcake` actor to the
    scenario. The `generateNewCupcake()` method is very similar to `generateFountains()`,
    except for the lack of a delay variable, and it randomly places `Cupcake` on one
    of the bricks instead of a `Fountain` actor. In [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, we demonstrated how to create a game
    score using the `Counter` class, a class you can import into your scenario. Please
    refer to that chapter for more details.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家（鲍勃）每次与`Cupcake`碰撞时，都会调用代表玩家的演员的`addCupcakeCount()`方法。在这个方法中，我们增加`scores`然后调用`generateNewCupcake()`来向场景中添加一个新的`Cupcake`演员。`generateNewCupcake()`方法与`generateFountains()`方法非常相似，只是没有延迟变量，并且它随机将`Cupcake`放置在一块砖上而不是`Fountain`演员上。在[第一章](part0014.xhtml
    "第一章。让我们直接进入…")，“让我们直接进入…”，我们展示了如何使用`Counter`类创建游戏分数，这是一个你可以导入到你的场景中的类。请参阅该章节以获取更多详细信息。
- en: In all of our previous scenarios, we used a `prepare()` method to add actors
    to the scenario. The major difference between this `prepare()` method and the
    previous ones, is that we use the `addObjectNudge()` method instead of `addObject()`
    to place our platforms. The `addObjectNudge()` method simply adds a little randomness
    to the placement of the platforms, so that every new game is a little different.
    The random variation in the platforms will cause the `Ball` actors to have different
    bounce patterns and require the player to jump and move a bit more carefully.
    In the call to `addObjectNudge()`, you will notice that we used the numbers `85`
    and `62`. These are simply numbers that spread the platforms out appropriately,
    and they were discovered through trial and error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的先前场景中，我们使用`prepare()`方法向场景中添加演员。这个`prepare()`方法和之前的方法的主要区别在于，我们使用`addObjectNudge()`方法而不是`addObject()`来放置我们的平台。`addObjectNudge()`方法只是给平台的放置增加了一点随机性，使得每次新游戏都略有不同。平台中的随机变化会导致`Ball`演员具有不同的弹跳模式，并要求玩家更加小心地跳跃和移动。在调用`addObjectNudge()`时，你会注意到我们使用了数字`85`和`62`。这些数字只是适当分散平台的数字，它们是通过试错发现的。
- en: I created a blue gradient background to use for the image of `CupcakeWorld`.
    Feel free to use this from the sample code you can download, create your own background
    image, or use one of the background images provided that come with Greenfoot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我为`CupcakeWorld`的图片创建了一个蓝色渐变背景，你可以随意使用这个背景，从你可以下载的示例代码中，创建你自己的背景图片，或者使用Greenfoot附带提供的背景图片之一。
- en: Enemies
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人
- en: In Cupcake Counter, all of the actors that can end the game if collided with
    are subclasses of the `Enemy` class. Using inheritance is a great way to share
    code and reduce redundancy for a group of similar actors. However, we often will
    create class hierarchies in Greenfoot solely for *polymorphism*. Polymorphism
    refers to the ability of a class in an object-orientated language to *take on
    many forms*. We are going to use it, so that our player actor only has to check
    for collision with an `Enemy` class and not every specific type of `Enemy`, such
    as `Ball` or `RedBall`. Also, by coding this way, we are making it very easy to
    add code for additional enemies, and if we find that our enemies have redundant
    code, we can easily move that code into our `Enemy` class. In other words, we
    are making our code extensible and maintainable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cupcake Counter中，所有可以与游戏结束相关的演员都是`Enemy`类的子类。使用继承是共享代码并减少一组类似演员冗余的好方法。然而，我们通常会在Greenfoot中仅为了*多态性*创建类层次结构。多态性指的是面向对象语言中一个类能够*采取多种形式*的能力。我们将使用它，这样我们的玩家演员只需要检查与`Enemy`类的碰撞，而不需要检查每个具体的`Enemy`类型，例如`Ball`或`RedBall`。此外，通过这种方式编码，我们使添加额外敌人的代码变得非常容易，如果我们发现我们的敌人有冗余代码，我们可以轻松地将该代码移动到我们的`Enemy`类中。换句话说，我们正在使我们的代码可扩展和可维护。
- en: 'Here is the code for our `Enemy` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Enemy`类的代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Ball` class extends the `Enemy` class. Since `Enemy` is solely used for
    polymorphism, the `Ball` class contains all of the code necessary to implement
    bouncing and an initial trajectory. Here is the code for this class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ball`类扩展了`Enemy`类。由于`Enemy`仅用于多态性，`Ball`类包含实现弹跳和初始轨迹所需的所有代码。以下是这个类的代码：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The implementation of `Ball` is missing the code to handle moving and bouncing.
    As we stated earlier, we will go over all the projectile-based code after providing
    the code we are using as the starting point for this game. In the `Ball` constructor,
    we randomly choose a speed in the *x* direction and save it in the `speedX` instance
    variable. We have included one accessory method to return the value of `speedX`
    (`getXVelocity()`). Last, we include `checkOffScreen()` to remove `Ball` once
    it goes off screen. If we do not do this, we would have a form of memory leak
    in our application because Greenfoot will continue to allocate resources and manage
    any actor until it is removed from the scenario. For the `Ball` class, I choose
    to use the `ball.png` image, which comes with the standard installation of Greenfoot.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ball`类的实现缺少处理移动和弹跳的代码。正如我们之前所述，在提供作为本游戏起点使用的代码之后，我们将回顾所有基于投射物的代码。在`Ball`构造函数中，我们在*x*方向随机选择一个速度并将其保存在`speedX`实例变量中。我们包含了一个辅助方法来返回`speedX`的值（`getXVelocity()`）。最后，我们包括`checkOffScreen()`来移除屏幕外的`Ball`。如果我们不这样做，我们的应用程序将会有一种内存泄漏的形式，因为Greenfoot将继续分配资源并管理任何演员，直到它们从场景中移除。对于`Ball`类，我选择使用随Greenfoot标准安装提供的`ball.png`图像。'
- en: 'In this chapter, we will learn how to create a simple particle effect. Creating
    an effect is more about the use of a particle as opposed to its implementation.
    In the following code, we create a generic particle class, `Particles`, that we
    will extend to create a `RedBall` particle. We have organized the code in this
    way to easily accommodate adding particles in the future. Here is the code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建一个简单的粒子效果。创建效果更多的是关于粒子使用而非其实施。在下面的代码中，我们创建了一个通用的粒子类，`Particles`，我们将扩展它来创建一个`RedBall`粒子。我们以这种方式组织代码，以便于将来轻松添加粒子。以下是代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our particles are implemented to move up and slightly turn each call of the
    `act()` method. A particle will move `lifeSpan` times and then remove itself.
    As you might have guessed, `lifeSpan` is another use of a delay variable. The
    `turnRate` property can be either positive (to turn slightly right) or negative
    (to turn slightly left).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的粒子被实现为向上移动并在每次调用`act()`方法时稍微转向。一个粒子将移动`lifeSpan`次然后移除自己。正如你可能猜到的，`lifeSpan`是延迟变量的另一种使用。`turnRate`属性可以是正的（稍微向右转）或负的（稍微向左转）。
- en: 'We only have one subclass of `Particles`, `RedBall`. This class supplies the
    correct image for `RedBall`, supplies the required input for the `Particles` constructor,
    and then scales the image according to the parameters `scaleX` and `scaleY`. Here''s
    the implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个`Particles`的子类，`RedBall`。这个类提供了`RedBall`的正确图像，提供了`Particles`构造函数所需的要求，并根据`scaleX`和`scaleY`参数缩放图像。以下是其实施：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For `RedBall`, I used the Greenfoot-supplied image `red-draught.png`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RedBall`，我使用了Greenfoot提供的图像`red-draught.png`。
- en: Fountains
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 喷泉
- en: In this game, fountains add a unique challenge. After reaching level five (see
    the `World` class `CupcakeWorld`), `Fountain` objects will be generated and randomly
    placed in the game. *Figure 2* shows a fountain in action. A `Fountain` object
    continually spurts `RedBall` objects into the air like water from a fountain.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，喷泉增加了独特的挑战。在达到五级（见`World`类`CupcakeWorld`）后，`Fountain`对象将被生成并在游戏中随机放置。*图2*显示了喷泉在动作中的样子。一个`Fountain`对象会不断地将`RedBall`对象喷向空中，就像喷泉喷水一样。
- en: '![Fountains](img/image00288.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![喷泉](img/image00288.jpeg)'
- en: 'Figure 2: This is a close-up of a Fountain object in the game Cupcake Counter'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这是游戏Cupcake Counter中喷泉对象的特写
- en: 'Let''s take a look at the code that implements the `Fountain` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现`Fountain`类的代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The constructor for `Fountain` creates a new blue, semitransparent square and
    sets that to be its image. We start with a blue square to give the player of the
    game a warning that a fountain is about to erupt. Since fountains are randomly
    placed at any location, it would be unfair to just drop one on our player and
    instantly end the game. This is also why `RedBall` is a subclass of `Enemy` and
    `Fountain` is not. It is safe for the player to touch the blue square. The `startDelay`
    delay variable is used to pause for a short amount of time, then remove the blue
    square (using the function `wipeView()`), and then start the `RedBall` shower
    (using the `createRedBallShower()` function). We can see this in the `act()` method.
    The implementation for `createRedBallShower()` is given and explained in the *Particle
    effects* section to come ahead in the chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fountain`的构造函数创建一个新的蓝色半透明正方形，并将其设置为它的图像。我们从一个蓝色正方形开始，给游戏玩家一个警告，喷泉即将爆发。由于喷泉被随机放置在任何位置，如果直接在我们的玩家身上放下一个喷泉并立即结束游戏，那就太不公平了。这也是为什么`RedBall`是`Enemy`的子类，而`Fountain`不是。玩家触摸蓝色正方形是安全的。`startDelay`延迟变量用于暂停一段时间，然后使用`wipeView()`函数移除蓝色正方形，然后开始`RedBall`淋浴（使用`createRedBallShower()`函数）。我们可以在`act()`方法中看到这一点。`createRedBallShower()`的实现和解释将在本章后面的*粒子效果*部分给出。'
- en: Turrets
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 炮塔
- en: 'In the game, there is a turret in the top-middle of the screen that shoots
    purple bouncy balls at the player. It is shown in *Figure 1*. Why do we use a
    bouncy-ball shooting turret? *Because this is our game and we can!* The implementation
    of the `Turret` class is very simple. Most of the functionality of rotating the
    turret and creating `Ball` to shoot is handled by `CupcakeWorld` in the `generateBalls()`
    method already discussed. The main purpose of this class is to just draw the initial
    image of the turret, which consists of a black circle for the base of the turret
    and a black rectangle to serve as the cannon. Here is the code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，屏幕顶部中间有一个炮塔，它会向玩家发射紫色弹跳球。它在*图1*中显示。我们为什么使用弹跳球发射炮塔？*因为这是我们自己的游戏，我们可以!* `Turret`类的实现非常简单。炮塔旋转和创建要发射的`Ball`的大部分功能由前面讨论过的`CupcakeWorld`中的`generateBalls()`方法处理。这个类的主要目的是只绘制炮塔的初始图像，它由炮塔底座的黑色圆圈和一个作为炮管的黑色矩形组成。以下是代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We previously talked about the `GreenfootImage` class and how to use some of
    its methods to do custom drawing. One new function we introduced is `drawImage()`.
    This method allows you to draw one `GreenfootImage` into another. This is how
    you compose images, and we used it to create our turret from a rectangle image
    and a circle image.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了`GreenfootImage`类以及如何使用其一些方法进行自定义绘图。我们介绍的一个新功能是`drawImage()`。此方法允许你在另一个`GreenfootImage`中绘制一个`GreenfootImage`。这就是你组合图像的方式，我们用它从矩形图像和圆形图像创建我们的炮塔。
- en: Rewards
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奖励
- en: 'We create a `Reward` class for the same reason we created an `Enemy` class.
    We are setting ourselves up to easily add new rewards in the future. (later in
    the chapter, we will assign this as an exercise). Here is the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Reward`类，原因和创建`Enemy`类一样。我们是为了方便将来轻松添加新的奖励而做的准备。（在章节的后面，我们将将其作为练习）。以下是代码：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Cupcake` class is a subclass of the `Reward` class and represents the
    object on the screen the player is constantly trying to collect. However, cupcakes
    have no actions to perform or state to keep track of; therefore, its implementation
    is simple:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cupcake`类是`Reward`类的子类，代表玩家不断试图收集的屏幕上的对象。然而，纸杯蛋糕没有要执行的动作或需要跟踪的状态；因此，其实现很简单：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When creating this class, I set its image to be `muffin.png`. This is an image
    that comes with Greenfoot. Even though the name of the image is a muffin, it still
    looks like a cupcake to me.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个类时，我将它的图像设置为`muffin.png`。这是一张随Greenfoot一起提供的图片。尽管图片的名称是松饼，但它对我来说看起来更像纸杯蛋糕。
- en: Jumpers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳跃者
- en: 'The `Jumper` class is a class that will allow all subclasses of it to jump
    when pressing either the up arrow key or the spacebar. Most of the body of this
    class will be implemented in the *Gravity and jumping* section to come ahead in
    the chapter. At this point, we just provide a placeholder implementation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jumper`类是一个允许其所有子类在按下上箭头键或空格键时跳跃的类。这个类的大部分内容将在本章后面的*重力和跳跃*部分实现。在此阶段，我们只提供一个占位符实现：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next class we are going to present is the `Bob` class. The `Bob` class
    extends the `Jumper` class and then adds functionality to let the player move
    it left and right. It also uses animation techniques discussed in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation* to make it look as though it is actually
    walking. Here is the code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍的是`Bob`类。`Bob`类扩展了`Jumper`类，并添加了让玩家左右移动的功能。它还使用了在第2章*动画*中讨论的动画技术，使其看起来像是在实际行走。以下是代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like `CupcakeWorld`, this class is substantial. We will discuss each method
    it contains sequentially. First, the constructor's main duty is to set up the
    images for the walking animation. This type of animation was discussed in [Chapter
    2](part0017.xhtml "Chapter 2. Animation"), *Animation* in the *Hurting the avatar*
    section and again in [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"),
    *Collision Detection* in the *Detecting a collision with multiple objects* section.
    The images came from [www.wikia.com](http://www.wikia.com) and were supplied,
    in the form of a sprite sheet, by the user Mecha Mario. A direct link to the sprite
    sheet is [http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG](http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG).
    Note that I manually copied and pasted the images I used from this sprite sheet
    using my favorite image editor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CupcakeWorld`类一样，这个类相当复杂。我们将按顺序讨论它包含的每个方法。首先，构造函数的主要任务是设置行走动画的图像。这种类型的动画在第2章*动画*的*伤害角色*部分和第3章*碰撞检测*的*检测与多个对象的碰撞*部分中都有讨论。这些图像来自[www.wikia.com](http://www.wikia.com)，由用户Mecha
    Mario以精灵图集的形式提供。精灵图集的直接链接是[http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG](http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG)。请注意，我手动使用我最喜欢的图像编辑器从这张精灵图集中复制并粘贴了我使用的图像。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Free Internet resources**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费互联网资源**'
- en: Unless you are also an artist or a musician in addition to being a programmer,
    you are going to be hard pressed to create all of the assets you need for your
    Greenfoot scenario. If you look at the credits for AAA video games, you will see
    that the number of artists and musicians actually equal or even outnumber the
    programmers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你除了是程序员之外还是一名艺术家或音乐家，否则你将很难为你的Greenfoot场景创建所有需要的资源。如果你查看AAA级视频游戏的致谢部分，你会发现艺术家和音乐家的数量实际上等于甚至超过了程序员。
- en: Luckily, the Internet comes to the rescue. There are a number of websites that
    supply legally free assets you can use. For example, the website I used to get
    the images for the `Bob` class supplies free content under the Creative Commons
    Attribution-Share Alike License 3.0 (Unported) (CC-BY-SA) license. It is very
    important that you check the licensing used for any asset you download off the
    Internet and follow those user agreements carefully. In addition, make sure that
    you fully credit the source of your assets. For games, you should include a *Credits*
    screen to cite all the sources for the assets you used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，互联网伸出援手。有许多网站提供合法的免费资源，你可以使用。例如，我用来获取`Bob`类图片的网站在Creative Commons Attribution-Share
    Alike License 3.0 (Unported) (CC-BY-SA)许可下提供免费内容。检查你从互联网下载的任何资源的许可使用情况并仔细遵守那些用户协议非常重要。此外，确保你完全注明了资源的来源。对于游戏，你应该包含一个*致谢*屏幕，列出你使用的所有资源的来源。
- en: 'The following are some good sites for free, online assets:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些提供免费在线资源的优秀网站：
- en: '[www.wikia.com](http://www.wikia.com)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.wikia.com](http://www.wikia.com)'
- en: '[newgrounds.com](http://newgrounds.com)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[newgrounds.com](http://newgrounds.com)'
- en: '[http://incompetech.com](http://incompetech.com)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://incompetech.com](http://incompetech.com)'
- en: '[opengameart.org](http://opengameart.org)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[opengameart.org](http://opengameart.org)'
- en: '[untamed.wild-refuge.net/rpgxp.php](http://untamed.wild-refuge.net/rpgxp.php)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[untamed.wild-refuge.net/rpgxp.php](http://untamed.wild-refuge.net/rpgxp.php)'
- en: Next, we have the `act()` method. It first calls the `act()` method of its superclass.
    It needs to do this so that we get the jumping functionality that is supplied
    by the `Jumper` class. Then, we call `checkDead()` and `eatReward()`. The `checkDead()`method
    ends the game if this instance of the `Bob` class touches an enemy, and `eatReward()`
    adds one to our score, by calling the `CupcakeWorld` method `addCupcakeCount()`,
    every time it touches an instance of the `Cupcake` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`act()`方法。它首先调用其超类的`act()`方法。它需要这样做，以便我们获得由`Jumper`类提供的跳跃功能。然后，我们调用`checkDead()`和`eatReward()`。`checkDead()`方法如果`Bob`类的实例接触到敌人，则结束游戏，而`eatReward()`方法通过调用`CupcakeWorld`方法的`addCupcakeCount()`，每次接触到`Cupcake`类的实例时，将我们的分数加一。
- en: The rest of the class implements moving left and right. The main method for
    this is `handleKeyPresses()`. Like in `act()`, the first thing we do, is call
    `handleKeyPresses()` contained in the `Jumper` superclass. This runs the code
    in `Jumper` that handles the spacebar and up arrow key presses. The key to handling
    key presses is the Greenfoot method `isKeyDown()` (see the following information
    box). We use this method to check if the left arrow or right arrow keys are presently
    being pressed. If so, we check whether or not the actor can move left or right
    using the methods `canMoveLeft()` and `canMoveRight()`, respectively. If the actor
    can move, we then call either `moveLeft()` or `moveRight()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分实现了左右移动。主要方法是`handleKeyPresses()`。像在`act()`中一样，我们首先做的事情是调用`Jumper`超类中的`handleKeyPresses()`。这运行了`Jumper`中的代码，处理空格键和上箭头键的按下。处理按键的关键是Greenfoot方法`isKeyDown()`（见以下信息框）。我们使用这个方法来检查是否按下了左箭头键或右箭头键。如果是这样，我们分别使用`canMoveLeft()`和`canMoveRight()`方法检查演员是否可以向左或向右移动。如果演员可以移动，我们就调用`moveLeft()`或`moveRight()`。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Handling key presses in Greenfoot**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Greenfoot中的按键处理**'
- en: 'In the preface of the book, we explained that we assumed that you have some
    experience with Greenfoot and have, minimally, completed the tutorials located
    on the page: [http://www.greenfoot.org/doc](http://www.greenfoot.org/doc)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的序言中，我们解释说，我们假设您对Greenfoot有一些经验，并且至少完成了位于页面上的教程：[http://www.greenfoot.org/doc](http://www.greenfoot.org/doc)
- en: The second tutorial explains how to control actors with the keyboard. To refresh
    your memory, we are going to present some information on the keyboard control
    here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个教程解释了如何使用键盘控制演员。为了刷新您的记忆，我们将在下面提供一些关于键盘控制的信息。
- en: 'The primary method we use in implementing keyboard control is `isKeyDown()`.
    This method provides a simple way to check whether a certain key is being pressed.
    Here is an excerpt from Greenfoot''s documentation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实现键盘控制时主要使用的方法是`isKeyDown()`。这个方法提供了一种简单的方式来检查是否按下了某个键。以下是Greenfoot文档中的一段摘录：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we will discuss `canMoveLeft()`, `moveLeft()`, and `animateLeft()`. The
    `canMoveRight()`, `moveRight()`, and `animateRight()`methods mirror their functionality
    and will not be discussed. The sole purpose of `canMoveLeft()` is to prevent the
    actor from walking off the left-hand side of the screen. The `moveLeft()` method
    moves the actor using `setLocation()` and then animates the actor to look as though
    it is moving to the left-hand side. It uses a delay variable to make the walking
    speed look natural (not too fast). The `animateLeft()` method sequentially displays
    the walking-left images. This is the same animation strategy we saw in [Chapter
    2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论`canMoveLeft()`、`moveLeft()`和`animateLeft()`。`canMoveRight()`、`moveRight()`和`animateRight()`方法的功能与之类似，将不会进行讨论。`canMoveLeft()`的唯一目的是防止演员走出屏幕的左侧。`moveLeft()`方法使用`setLocation()`移动演员，然后使演员看起来像是在向左侧移动。它使用一个延迟变量来使行走速度看起来更自然（不要太快）。`animateLeft()`方法依次显示行走左侧的图像。这与我们在[第2章](part0017.xhtml
    "第2章。动画")中看到的动画策略相同，*动画*。
- en: Platforms
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台
- en: 'The game contains several platforms that the player can jump or stand on. The
    platforms perform no actions and only serve as placeholders for images. We use
    inheritance to simplify collision detection. Here is the implementation of `Platform`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏包含几个玩家可以跳跃或站立的平台。平台不执行任何操作，仅作为图像的占位符。我们使用继承来简化碰撞检测。以下是`Platform`的实现：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s the implementation of `BrickWall`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`BrickWall`的实现：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the implementation of `Brick`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Brick`的实现：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Test it out
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一下
- en: You should now be able to compile and test Cupcake Counter. Make sure you handle
    any typos or other errors you introduced while inputting the code. For now, you
    can only move left and right. Check out `Bob` walking. *Pretty cool!* Everything
    else depends on some of the code we left out of the preceding implementations.
    We will fill out that missing code next. Let's launch some actors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够编译和测试 Cupcake Counter。确保你处理了在输入代码时引入的任何错误，如拼写错误或其他错误。目前，你只能左右移动。看看 `Bob`
    正在行走。*非常酷!* 其他一切取决于我们之前实现中省略的一些代码。我们将在下一部分补全这些缺失的代码。让我们启动一些演员。
- en: Your assignment
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的作业
- en: Consider one of the locations we left out of the previous code. Try to supply
    the code yourself. How would you start? My suggestion would be to start with pencil
    and paper. Draw some figures and imagine the steps that you would need to perform
    to implement the functionality. Translate these steps to Java code and try them
    out. Doing this will help you better understand and process the upcoming solutions,
    even if your solution was incorrect.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前代码中省略的一个位置。尝试自己提供代码。你将如何开始？我的建议是先从铅笔和纸开始。画一些图形，想象你需要执行哪些步骤来实现功能。将这些步骤转换为
    Java 代码并尝试运行。这样做将帮助你更好地理解和处理即将到来的解决方案，即使你的解决方案是错误的。
- en: Launching actors
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动演员
- en: We are going to take the preceding incomplete implementation and turn it into
    a game by adding jumping, bouncing, a particle effect, and bullets fired from
    a turret.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把之前的不完整实现转变为一个游戏，通过添加跳跃、弹跳、粒子效果和从炮塔发射的子弹。
- en: Gravity and jumping
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重力和跳跃
- en: 'Presently, our player character is stuck at the bottom of the screen. We are
    going to fill in the missing code in the `Jumper` class and the `Bob` class to
    enable our character to jump and finally have a way to reach the cupcake reward
    at the top of the screen. Jumping is applying a force to move an object upwards.
    We are also going to need a downwards force operating on the object, in order
    for it to fall back down. As in real life, we are going to call this force *gravity*.
    The changes to the `Jumper` class are so extensive that we are going to first
    look at the complete implementation and then discuss it afterwards. Here''s the
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的玩家角色被卡在屏幕底部。我们将补全 `Jumper` 类和 `Bob` 类中的缺失代码，使我们的角色能够跳跃，并最终有办法到达屏幕顶部的蛋糕奖励。跳跃是施加向上的力以移动一个物体。我们还需要一个作用于物体的向下力，以便它能够落回地面。就像现实生活中一样，我们将这个力称为
    *重力*。`Jumper` 类的更改非常广泛，因此我们将首先查看完整的实现，然后进行讨论。以下是代码：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please note that we have added two new instance variables (`fallSpeed` and `jumping`)
    and two static constants (`GRAVITY` and `JUMPSTRENGTH`). These new variables will
    be used throughout our code. In our `act()` method, we added the `standOrFall()`
    method. This method is responsible for applying gravity and detecting collisions
    (both for the head and feet of the actor). Before looking at that method further,
    let's look at the completed implementation of `handleKeyPresses()`. In this method,
    we detect whether the space bar or up arrow key was pressed and call `jump()`
    if it was. You will notice that the `if` statement also contains a check to see
    whether the `Boolean` variable `jumping` is `false`. We need this check to prevent
    double jumping (jumping again while in the middle of a jump). The `jump()` method
    changes `fallSpeed` to a negative value. This applies a force in the up direction
    on the actor. We set `jumping` to `true` (as we are now in a jumping state) and
    then call `fall()`. The `fall()` method applies gravity to an actor. In this method,
    we can see how a negative value of `fallSpeed` will propel the actor upwards.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们添加了两个新的实例变量（`fallSpeed` 和 `jumping`）和两个静态常量（`GRAVITY` 和 `JUMPSTRENGTH`）。这些新变量将贯穿我们的代码。在我们的
    `act()` 方法中，我们添加了 `standOrFall()` 方法。这个方法负责应用重力和检测碰撞（对于演员的头和脚）。在进一步查看该方法之前，让我们看看
    `handleKeyPresses()` 方法的完整实现。在这个方法中，我们检测是否按下了空格键或上箭头键，如果是，则调用 `jump()`。你会注意到 `if`
    语句还包含一个检查 `Boolean` 变量 `jumping` 是否为 `false` 的条件。我们需要这个检查来防止双重跳跃（在跳跃过程中再次跳跃）。`jump()`
    方法将 `fallSpeed` 改为负值。这会在演员上施加向上的力。我们将 `jumping` 设置为 `true`（因为我们现在处于跳跃状态），然后调用
    `fall()`。`fall()` 方法将重力应用于演员。在这个方法中，我们可以看到负值的 `fallSpeed` 将推动演员向上移动。
- en: The value of `fallSpeed` has `GRAVITY` added to it until it becomes positive.
    This will create a parabola-like motion, as shown in *Figure 3*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`fallSpeed` 的值会持续加上 `GRAVITY`，直到它变为正值。这将产生类似抛物线的运动，如图 *图 3* 所示。'
- en: '![Gravity and jumping](img/image00289.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![重力和跳跃](img/image00289.jpeg)'
- en: 'Figure 3: This is the implementation of falling'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这是坠落实现的示例
- en: Let's look at the implementation of `standOrFall()`. The first thing we need
    to check is whether or not we are presently standing on a `Platform` object. We
    use the method `inAir()` to do this check. This method uses `getOneObjectAtOffset()`
    (see [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*) to check whether the bottom of the actor is touching a `Platform`
    object and returns `false` if it is. In `standOrFall()`, we do three things if
    we have determined that we are in the air. We check to see whether the top or
    bottom of the actor is colliding with `Platform` and call the `fall()` method
    if it is. The methods `checkHead()` and `checkLanding()` are similar. They are
    both used in border-based collision detection, as discussed in [Chapter 3](part0024.xhtml
    "Chapter 3. Collision Detection"), *Collision Detection*, to detect at exactly
    which pixel location the collision occurred. They then change the value of `fallSpeed,`
    so that the actor stops at the point of collision. If we detect that we are not
    in the air in `standOrFall()`, then we are standing on a platform and can set
    `fallSpeed` to `0` (not falling) and `jumping` to `false` (not jumping).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`standOrFall()`函数的实现。首先我们需要检查我们是否目前正站在一个`Platform`对象上。我们使用`inAir()`方法来进行这个检查。这个方法使用`getOneObjectAtOffset()`（见[第3章](part0024.xhtml
    "第3章。碰撞检测"), *碰撞检测*)来检查角色的底部是否接触到了`Platform`对象，如果接触到了则返回`false`。在`standOrFall()`中，如果我们确定自己在空中，我们会做三件事情。我们会检查角色的顶部或底部是否与`Platform`发生碰撞，如果发生碰撞则调用`fall()`方法。`checkHead()`和`checkLanding()`方法类似。它们都用于基于边界的碰撞检测，如[第3章](part0024.xhtml
    "第3章。碰撞检测"), *碰撞检测*中所述，以检测碰撞发生的确切像素位置。然后它们会改变`fallSpeed`的值，使角色在碰撞点停止。如果我们检测到在`standOrFall()`中我们不在空中，那么我们就站在平台上，可以将`fallSpeed`设置为`0`（不坠落）并将`jumping`设置为`false`（不跳跃）。
- en: Bouncing
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹跳
- en: 'Bouncing actors look great and really add a nice dimension to any game. In
    the mind of the player, they propel your game from a flat arrangement of pixels
    to a rich world in which objects obey the natural laws of physics. In Cupcake
    Counter, the balls shot from the turret bounce. Bouncing is implemented in the
    `Ball` class. First, add the following instance variables to your existing `Ball`
    class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 弹跳角色看起来很棒，并且真的为任何游戏增添了很好的维度。在玩家的心中，它们将你的游戏从像素的平面排列推进到一个丰富的世界，在这个世界中，物体遵循物理的自然法则。在Cupcake
    Counter中，从炮塔射出的球会弹跳。弹跳在`Ball`类中实现。首先，将以下实例变量添加到现有的`Ball`类中：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to add code to the `act()` method that will cause an instance
    of the class to fall or bounce if it hits an object. Change your `act()` method
    to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向`act()`方法中添加代码，使类的实例在撞击到对象时能够坠落或弹跳。将你的`act()`方法更改为以下内容：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `fallOrBounce()` method is going to be complex, but we are going to use
    functional decomposition (break it up into smaller methods) to manage the complexity
    and make our code more readable. Here is its implementation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`fallOrBounce()`方法将会很复杂，但我们将使用功能分解（将其分解成更小的方法）来管理复杂性，并使我们的代码更易于阅读。以下是它的实现：'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have reduced the implementation of `fallOrBounce()` to checking whether
    we are about to hit our head or checking whether we are about to land on a platform.
    We choose between the two checks based on the value of `fallSpeed`. If `fallSpeed`
    is negative, then we are moving upwards and there is no need to check for landing
    at this point. Here is the implementation of `checkHead()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`fallOrBounce()`的实现简化为检查我们是否即将撞头或即将落在平台上。我们根据`fallSpeed`的值在这两个检查之间进行选择。如果`fallSpeed`是负数，那么我们正在向上移动，此时不需要检查是否即将着陆。以下是`checkHead()`的实现：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `checkHead()` method uses border-based collision detection (discussed in
    [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision Detection*)
    to detect exactly when the top of the object touches a platform. If `step` ends
    up being greater than `fallSpeed`, then no collision occurred and we can continue
    letting gravity affect our trajectory by calling `fall()`. If `step` is less than
    `fallSpeed`, then we hit our head on a platform and we need to handle bouncing
    off this platform by calling `handleBounce()`. Here is the implementation of `handleBounce()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkHead()` 方法使用基于边界的碰撞检测（在第 3 章[碰撞检测](part0024.xhtml "第 3 章。碰撞检测")中讨论），来检测物体的顶部何时接触到平台。如果
    `step` 最终大于 `fallSpeed`，则没有发生碰撞，我们可以继续通过调用 `fall()` 让重力影响我们的轨迹。如果 `step` 小于 `fallSpeed`，则我们的头部撞到了平台，我们需要通过调用
    `handleBounce()` 来处理从这个平台上弹跳的情况。以下是 `handleBounce()` 的实现。'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method handles a bounce by breaking it up into two main phases. The first
    phase handles the motion between the actor and the platform. The second phase
    handles travelling from the platform to the end location. The phases are shown
    in *Figure 4*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过将其分为两个主要阶段来处理弹跳。第一阶段处理角色与平台之间的运动。第二阶段处理从平台到最终位置的运动。阶段在 *图 4* 中显示。
- en: '![Bouncing](img/image00290.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![弹跳](img/image00290.jpeg)'
- en: 'Figure 4: This shows the two main phases in handling a bounce. Phase 1 is the
    motion leading up to the impact and Phase 2 is the motion after impact'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：这显示了处理弹跳的两个主要阶段。阶段 1 是碰撞前的运动，阶段 2 是碰撞后的运动
- en: In the first phase, we move the ball to the point of collision by setting `fallSpeed`
    to `step` and calling `fall(0)`. We will look at the implementation of `fall()`
    soon. For now, it is enough to know that `fall(0)` calls `setLocation()` to move
    the ball and updates `fallSpeed` by applying the affects of gravity. In the second
    phase of `handleBounce()`, we multiply by `0.7` in order to simulate the loss
    of energy that occurs in an impact. There is nothing magical or scientific about
    `0.7`. It just looked right when tested. We then move the remaining distance of
    our inertia (`step` – `oldFallSpeed`) by calling `fall(0)` again. The bounce has
    changed our falling direction, so the last thing we do is update `fallSpeed` to
    reflect this change.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，我们将球移动到碰撞点，通过将 `fallSpeed` 设置为 `step` 并调用 `fall(0)` 来实现。我们很快就会看到 `fall()`
    的实现。现在，只需知道 `fall(0)` 调用 `setLocation()` 来移动球，并通过应用重力的效果来更新 `fallSpeed` 就足够了。在
    `handleBounce()` 的第二阶段，我们乘以 `0.7` 以模拟碰撞中发生的能量损失。`0.7` 没有什么神奇或科学的地方。它只是在测试时看起来合适。然后我们通过再次调用
    `fall(0)` 来移动剩余的惯性距离（`step` – `oldFallSpeed`）。弹跳改变了我们的下落方向，所以我们最后要做的就是更新 `fallSpeed`
    以反映这种变化。
- en: 'Since we just used the `fall()` method, let us look at that next:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚使用了 `fall()` 方法，让我们来看看它：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned earlier, `fall()` moves the actor using `setLocation()` according
    to its speed in the *x* direction and how fast it is falling. The instance variable
    `fallSpeed` is updated to account for the slowing (or accelerating) effects of
    gravity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`fall()` 方法使用 `setLocation()` 根据其在 *x* 方向上的速度和下落速度来移动角色。实例变量 `fallSpeed`
    被更新以考虑重力（减速或加速）的影响。
- en: 'The only method left to complete the implementation of the `Ball` class is
    `checkLanding()`. Here it is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要完成 `Ball` 类实现的唯一方法是 `checkLanding()`。下面是它的实现：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The implementation of `checkLanding()` exactly mirrors the implementation of
    `checkHead()` except that it handles moving downwards instead of moving upwards.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkLanding()` 函数的实现与 `checkHead()` 函数的实现完全相同，只是它处理的是向下移动而不是向上移动。'
- en: Bouncing is a great effect and can be applied to a wide variety of actors. You
    could combine the implementation of bouncing with the implementation of jumping
    we discussed in the previous section and make a bouncing, jumping hero for your
    game.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 弹跳是一个很好的效果，可以应用于各种角色。你可以将弹跳的实现与我们在上一节中讨论的跳跃实现结合起来，为你的游戏制作一个会弹跳、会跳跃的英雄。
- en: Particle effects
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子效果
- en: 'Particle effects work by creating a bunch of small actors to make an animation.
    Previously, you learned to do animations mainly by rapid image swapping. You could
    imagine creating a water fountain by creating 4-6 images of a fountain shooting
    upwards and switching between those images. Instead of doing that, we will create
    a fountain using a particle effect. Conveniently, you already have all the information
    you need to create particle effects. Particles are simply small actors that you
    assign a pattern of motion to. You then create a lot of them to provide the desired
    effect. We will do this to complete our implementation of the `Fountain` class.
    The only part of the implementation we left out was the code for the `createRedBallShower()`
    method. Here is that missing code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果是通过创建许多小演员来制作动画的。之前，您学习了主要通过快速图像交换来制作动画。您可以想象通过创建4-6个向上喷射的喷泉图像并在这之间切换来创建一个喷泉。而不用这样做，我们将使用粒子效果来创建喷泉。方便的是，您已经拥有了创建粒子效果所需的所有信息。粒子只是您分配了运动模式的小演员。然后，您创建很多它们来提供所需的效果。我们将这样做来完成`Fountain`类的实现。我们唯一没有实现的部分是`createRedBallShower()`方法的代码。以下是缺失的代码：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The instance variable `lifespan` is a delay variable that we use to determine
    how long the fountain will exist. Once `lifespan` is less than zero, we remove
    this fountain from the scenario. Otherwise, we create `RedBall` anew with a random
    lifespan and rate of turn and speed. These parameters to the constructor of the
    `RedBall` class were discussed in the *Enemies* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量`lifespan`是一个延迟变量，我们用它来确定喷泉存在的时间。一旦`lifespan`小于零，我们就从场景中移除这个喷泉。否则，我们用随机的生命周期和转向速度重新创建`RedBall`。这些参数在*敌人*部分讨论过。
- en: Creating `RedBall` anew for every call of the `act()` method with slightly different
    attributes creates a really interesting fountain effect, as shown in *Figure 2*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用`act()`方法时重新创建`RedBall`，并赋予其略微不同的属性，可以创建一个非常有趣的喷泉效果，如*图2*所示。
- en: Bullets and turrets
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子弹和炮塔
- en: We have already fully implemented bullets and turrets. The `Turret` class was
    complete and we finished the `Ball` class (our bullet) in the *Bouncing* section.
    What we will discuss here, are the basic steps to create a turret and a bullet
    and explain how what we have already done gives you the information you need to
    create a machine gun, cannon, tank, or other type of turret.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完全实现了子弹和炮塔。`Turret`类已经完成，我们在*弹跳*部分完成了`Ball`类（我们的子弹）。在这里，我们将讨论创建炮塔和子弹的基本步骤，并解释我们之前所做的工作如何为您提供创建机枪、大炮、坦克或其他类型炮塔所需的信息。
- en: First, you need a turret with an image. You can dynamically create the image
    just as we did in the `Turret` class, or you can set it using `setImage()`. Then,
    turrets only need to be rotated in the direction they are firing. That is what
    we did in the `generateBalls()` method in `CupcakeWorld`. Bullets are just actors
    that are rotated in a certain direction and then continually call `move()` to
    move in that direction. If you rotate the turret and bullet by the same angle,
    place the bullet at the same starting location as the turret, and let the bullet
    move forward, then it will appear as if the turret fired the bullet. Does this
    make sense? *Figure 5* summarizes this strategy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个带有图像的炮塔。您可以像我们在`Turret`类中做的那样动态创建图像，或者使用`setImage()`来设置它。然后，炮塔只需要旋转到它们射击的方向。这就是我们在`CupcakeWorld`中的`generateBalls()`方法中所做的。子弹只是旋转到某个方向并不断调用`move()`以在该方向移动的演员。如果您将炮塔和子弹旋转相同的角，将子弹放置在炮塔相同的起始位置，并让子弹向前移动，那么它就会看起来像炮塔发射了子弹。这说得通吗？*图5*总结了这一策略。
- en: '![Bullets and turrets](img/image00291.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![子弹和炮塔](img/image00291.jpeg)'
- en: 'Figure 5: These are the steps necessary to create a turret firing a bullet'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：创建发射子弹的炮塔所需的步骤
- en: Your assignment
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的作业
- en: Now, compile all of the code we just gave you and play Cupcake Counter for a
    while. You might start to notice why we started by having the platforms have some
    randomness to their placement. If we didn't, the player would quickly adapt to
    the falling patterns of the balls.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译我们刚刚给您的所有代码，并玩一会儿蛋糕计数器。您可能会开始注意到为什么我们一开始让平台的位置具有一些随机性。如果我们没有这样做，玩家会很快适应球体的下落模式。
- en: Your assignment for this section, is to code another random variation in the
    game. You could further randomize the platforms, mess with the ball speed or size,
    or change the power of the player's jump.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的任务是为游戏编写另一个随机变体。你可以进一步随机化平台，玩弄球的速度或大小，或者改变玩家跳跃的力量。
- en: Challenge
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: We have created a fairly functional game. We have a score, cool animations,
    collision detection, and levels in our game. After playing it, what would be the
    first thing you would improve? Let your friend play it. What did he/she think?
    Try to come up with a change that improves the game based on your experience playing
    it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个相当功能齐全的游戏。我们的游戏中有一个得分、酷炫的动画、碰撞检测和关卡。在玩过它之后，你会首先想改进什么？让你的朋友也来玩。他/她觉得怎么样？尝试根据你玩游戏的经验提出一些改进游戏的改变。
- en: In addition, we designed our game so that it would be easy to add new rewards,
    enemies, and platforms. Add one of each to the game and add your own twist to
    them. For example, you could create a super cupcake that is worth five points
    but only lasts a short time. This will require the player to make some quick,
    meaningful decisions during the game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们设计游戏使其易于添加新的奖励、敌人和平台。为游戏添加每种各一个，并给它们添加你自己的特色。例如，你可以创建一个价值五分的超级纸杯蛋糕，但它只持续很短的时间。这将要求玩家在游戏中做出一些快速而有意义的决策。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While we did not create a full physics engine, we did go over some simple techniques
    to give actors interesting movement. Our discussion was focused on projectile-based
    movement and included bouncing, jumping, firing, and particle effects. Until now,
    we acquired a number of creative program techniques that enable us to create a
    wide variety of animations, simulations, and games. However, creating a fun interactive
    experience is not trivial. In the next chapter, we are going to learn about game
    design and a process for game development that will help us create amazing interactive
    experiences.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有创建一个完整的物理引擎，但我们确实介绍了一些简单的技术来为演员提供有趣的动作。我们的讨论集中在基于抛射物的动作上，包括弹跳、跳跃、射击和粒子效果。到目前为止，我们已经掌握了一系列创造性的编程技术，使我们能够创建各种动画、模拟和游戏。然而，创建一个有趣的交互式体验并非易事。在下一章中，我们将学习游戏设计和游戏开发的过程，这将帮助我们创建令人惊叹的交互式体验。
