- en: Implementing Kubernetes Features as an Alternative
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为Spring Cloud Gateway的替代品实现Kubernetes特性
- en: The current microservice landscape contains a number of supportive services
    that implement important design patterns required in a large-scale microservice
    landscape; for example an edge, config, and authorization server, and a service
    for distributed tracing. For details, see [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, and refer to the *Design patterns for microservices*
    section. In the previous chapter, we replaced the implementation of the design
    pattern for service discovery, based on Netflix Eureka, with the built-in discovery
    service in Kubernetes. In this chapter, we will further simplify the microservice
    landscape by reducing the number of supportive services required to be deployed.
    Instead, the corresponding design patterns will be handled by built-in capabilities
    in Kubernetes. The Spring Cloud Config Server will be replaced with Kubernetes
    config maps and secrets. The Spring Cloud Gateway will be replaced by a Kubernetes
    ingress resource, which can act as an edge server in the same way as Spring Cloud
    Gateway.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当前微服务架构包含许多实现大规模微服务架构中所需的重要设计模式的支撑服务；例如边缘、配置和授权服务器，以及分布式跟踪服务。详情请见[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)，*微服务简介*，并参考*微服务设计模式*小节。在前一章中，我们用Kubernetes内置的发现服务替换了基于Netflix
    Eureka的服务发现设计模式。在本章中，我们将通过减少需要部署的支撑服务数量来进一步简化微服务架构。相反，相应的设计模式将由Kubernetes内置功能处理。Spring
    Cloud Config Server将被Kubernetes配置映射和机密替换。Spring Cloud Gateway将被Kubernetes入口资源替换，后者可以像Spring
    Cloud Gateway一样充当边缘服务器。
- en: In [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), S*ecuring Access
    to APIs*, refer to the *Protecting the external communication with HTTPS* section,
    where we use certificates to protect the external API. Manual handling of certificates
    is both time-consuming and error-prone. As an alternative, we will be introduced
    to the Cert Manager, which can automatically provide new certificates and replace
    expired ones for the external HTTPS endpoint exposed by the ingress. We will configure `cert-manager`
    to use **Let's Encrypt** to issue the certificates. Let's Encrypt is a free Certificate
    Authority that can be used to automatically issue certificates. Let's Encrypt
    must be able to verify that we own the DNS name that the certificate will be issued
    for. Since our Kubernetes cluster runs locally in Minikube, we have to make it
    possible for Let's Encrypt to access our cluster during the provisioning. We will
    use `ngrok` to create a temporary HTTP tunnel from the internet to our local Kubernetes
    cluster to be used by Let's Encrypt.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)中，关于*保护API访问安全*，参考*使用HTTPS保护外部通信*小节，我们使用证书来保护外部API。手动处理证书既耗时又容易出错。作为替代方案，我们将介绍Cert
    Manager，它可以自动为入口暴露的外部HTTPS端点提供新证书并替换已过期的证书。我们将配置`cert-manager`使用**Let's Encrypt**发行证书。Let's
    Encrypt是一个可以用来自动颁发证书的免费证书授权机构。Let's Encrypt必须能够验证我们拥有将发行证书的DNS名称。由于我们的Kubernetes集群在Minikube中本地运行，我们必须让Let's
    Encrypt在配置过程中能够访问我们的集群。我们将使用`ngrok`创建一个从互联网到我们本地Kubernetes集群的临时HTTP隧道，供Let's Encrypt使用。
- en: When using more and more features in a platform such as Kubernetes, it is important
    to ensure that the source code of the microservices isn't dependent on the platform;
    that is, should ensure that the microservices can still be used without Kubernetes.
    To ensure that we can still use the microservices outside Kubernetes, the chapter
    will conclude by deploying the microservice landscape using Docker Compose and
    executing the `test-em-all.bash` test script to verify that the microservices
    still work without using Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像Kubernetes这样的平台越来越多的特性时，确保微服务的源代码不依赖于该平台是很重要的；也就是说，应该确保微服务在没有Kubernetes的情况下仍然可以使用。为了确保我们可以在没有Kubernetes的情况下使用微服务，本章将通过使用Docker
    Compose部署微服务架构并以执行`test-em-all.bash`测试脚本结束，验证微服务在没有Kubernetes的情况下仍然可以工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Replacing Spring Cloud Config Server with Kubernetes config maps and secrets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes配置映射和机密替换Spring Cloud Config Server
- en: Replacing Spring Cloud Gateway with a Kubernetes ingress resource
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes入口资源替换Spring Cloud Gateway
- en: Adding the Cert Manager to automatically provide certificates issued by Let's
    Encrypt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Cert Manager以自动提供由Let's Encrypt签发的证书
- en: Using `ngrok` to establish an HTTP tunnel from the internet to our local Kubernetes
    cluster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ngrok`从互联网建立到我们本地Kubernetes集群的HTTP隧道。
- en: Deploying and testing the microservice landscape using Docker Compose to ensure
    that the source code in the microservices isn't locked into Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose部署和测试微服务架构，以确保微服务中的源代码不会锁定在Kubernetes上。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying this so that it can run on other platforms, such as Linux or Windows,
    should be straightforward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但修改后可以在其他平台，如Linux或Windows上运行，应该是很简单的。
- en: 'The only new tool required for this chapter is the command-line `ngrok` tool
    used for establishing an HTTP tunnel from the internet to our local environment.
    It can be installed using Homebrew with the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的新工具是命令行`ngrok`工具，用于建立从互联网到我们本地环境的HTTP隧道。它可以通过Homebrew使用以下命令安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use `ngrok`, a free account has to be created and an authorization token
    also has to be registered by taking the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ngrok`，必须创建一个免费账户并注册一个授权令牌，具体步骤如下：
- en: 'Sign up here: [https://dashboard.ngrok.com/signup](https://dashboard.ngrok.com/signup).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里注册：[https://dashboard.ngrok.com/signup](https://dashboard.ngrok.com/signup)。
- en: 'After the account is created, run the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户创建后，运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `<YOUR_AUTH_TOKEN>` is replaced with the authorization token found on
    the following page—[https://dashboard.ngrok.com/auth](https://dashboard.ngrok.com/auth).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<YOUR_AUTH_TOKEN>`用以下页面找到的授权令牌替换——[https://dashboard.ngrok.com/auth](https://dashboard.ngrok.com/auth)。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17)。
- en: 'To be able to run the commands as described in the book, you need to download
    the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Sample commands are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照书中描述运行命令，你需要将源代码下载到一个文件夹中，并设置一个环境变量，`$BOOK_HOME`，指向那个文件夹。示例命令如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1, SR2 (also known as the **Greenwich** release), Spring Boot
    2.1.6, and Spring 5.1.8—the latest available versions of the Spring components
    at the time of writing this chapter. The source code has been tested using Kubernetes
    v1.15.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用了Spring Cloud 2.1, SR2（也称为**Greenwich**版本），Spring
    Boot 2.1.6和Spring 5.1.8——这些是编写本章时可用的Spring组件的最新版本。源代码已经使用Kubernetes v1.15进行了测试。
- en: All source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter17` but
    have been edited in several cases to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有源代码示例均来自`$BOOK_HOME/Chapter17`的源代码，但在某些情况下进行了编辑，去除了源代码中不相关的内容，例如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing
    Kubernetes Features as an Alternative*, that is, the changes required to replace
    the Spring Cloud Config Server and Spring Cloud Gateway with corresponding features
    in Kubernetes, you can compare it with the source code for [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*.  You can use your favorite `diff`
    tool and compare the `$BOOK_HOME/Chapter16` and `$BOOK_HOME/Chapter17` folders.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看对[第17章](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml)中源代码所做的更改，即替换Spring
    Cloud Config Server和Spring Cloud Gateway以便使用Kubernetes中对应特性的更改，你可以将其与[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)的源代码进行比较，《将我们的微服务部署到Kubernetes》。你可以使用你喜欢的`diff`工具，比较`$BOOK_HOME/Chapter16`和`$BOOK_HOME/Chapter17`文件夹。
- en: Replacing the Spring Cloud Config Server
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Config Server。
- en: As we have seen in the previous chapter, [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*, in the *Deploying to Kubernetes*
    section, config maps and secrets can be used to hold configuration information
    for our microservices. The Spring Cloud Config Server adds values such as keeping
    all configuration in one place, optional version control using Git, and the ability
    to encrypt sensitive information on the disk. But it also consumes a non-negligible
    amount of memory (as with any Java and Spring-based application) and adds significant
    overhead during startup. For example, when running automated integration tests
    such as the test script we are using in this book, `test-em-all.bash`, all microservices
    are started up at the same time, including the configuration server. Since the
    other microservices must get their configuration from the configuration server
    before they can start up, they all have to wait for the configuration server to
    be up and running before they can start up. This leads to a significant delay
    when running integration tests. If we use Kubernetes config maps and secrets instead,
    this delay is eliminated, making automated integration tests run faster. To me,
    it makes sense to use the Spring Cloud Config Server where the underlying platform
    doesn't provide a similar capability, but when deploying to Kubernetes, it is
    better to use config maps and secrets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章看到的，[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)，*将我们的微服务部署到Kubernetes*，在*部署到Kubernetes*部分，配置映射和秘钥可用于持有我们微服务的配置信息。Spring
    Cloud Config Server增加了诸如将所有配置放在一个地方、可选的Git版本控制以及加密磁盘上的敏感信息等价值。但它也消耗了相当大的内存（就像任何基于Java和Spring的应用程序一样）并在启动时增加了显著的开销。例如，当运行本书中使用的自动化集成测试，如测试脚本`test-em-all.bash`时，所有微服务都会同时启动，包括配置服务器。由于其他微服务必须在启动之前从配置服务器获取其配置，它们都必须等待配置服务器启动并运行后才能启动。这导致集成测试运行时出现显著延迟。如果我们使用Kubernetes的配置映射和秘钥，则消除了这个延迟，使自动化集成测试运行得更快。在我看来，在底层平台不提供类似功能时使用Spring
    Cloud Config Server是有意义的，但在部署到Kubernetes时，最好使用配置映射和秘钥。
- en: 'Using Kubernetes config maps and secrets instead of the Spring Cloud Config
    Server will make the microservice landscape start up faster and it will require
    less memory. It will also simplify the microservice landscape by eliminating one
    supportive service, the configuration server. This is illustrated by the following
    diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes的配置映射和秘钥，而不是Spring Cloud Config Server，可以加快微服务架构的启动速度，并减少所需内存。它还将通过消除一个支持服务，即配置服务器，简化微服务架构。如下图所示：
- en: '![](img/7ab391b2-00bd-4930-8d8f-371cd083215a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ab391b2-00bd-4930-8d8f-371cd083215a.png)'
- en: Let's see what is required to replace the Spring Cloud Config Server with Kubernetes
    config maps and secrets!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看替换Spring Cloud Config Server所需的步骤！
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只更改了配置；也就是说，不需要更改Java源代码！
- en: Changes in the source code to replace the Spring Cloud Config Server
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码中的更改，以替换Spring Cloud Config Server
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Config Server with Kubernetes config maps and
    secrets:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 已应用于源代码配置的以下更改，以替换Spring Cloud Config Server与Kubernetes配置映射和秘钥：
- en: 'Removed the project `spring-cloud/config-server`, also including:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了项目`spring-cloud/config-server`，还包括：
- en: Removed the project in the `settings.gradle` build file.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了`settings.gradle`构建文件中的项目。
- en: Removed the configuration server YAML files and its declaration in the `kustomization.yml`
    files in the `kubernetes/services/base` and `kubernetes/services/overlays/prod` folders.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了`config-server`的YAML文件及其在`kubernetes/services/base`和`kubernetes/services/overlays/prod`文件夹中的声明。
- en: 'Removed configuration from all microservices:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了所有微服务中的配置：
- en: Removed the `spring-cloud-starter-config` dependency in the `build.gradle` build
    files
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了`build.gradle`构建文件中的`spring-cloud-starter-config`依赖项。
- en: Removed the `bootstrap.yml` files in the `src/main/resource` folders in each
    project
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了每个项目`src/main/resource`文件夹中的`bootstrap.yml`文件。
- en: Removed the  `spring.clod.config.enabled=false` property setting in integration
    tests
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了集成测试中的`spring.clod.config.enabled=false`属性设置。
- en: 'Changes in the configuration files in the `config-repo` folder:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo`文件夹中的配置文件更改：'
- en: Removed properties with sensitive information, that is, credentials for MongoDB,
    MySQL, RabbiMQ, and the password for the TLS certificate used by the edge server.
    They will be replaced by Kubernetes secrets.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了包含敏感信息的属性，也就是说，MongoDB、MySQL、RabbitMQ的凭据以及边缘服务器使用的TLS证书的密码。它们将被Kubernetes密钥替换。
- en: The route to the configuration server API is removed in the configuration of
    the edge server
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边缘服务器的配置中移除了对配置服务器API的路径
- en: 'Changes in the Kubernetes definition files for deployment resources in the `kubernetes/services/base` folder:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base`文件夹中部署资源定义文件的变化：'
- en: Config maps are mounted as volumes, that is, as folders in the filesystem of
    the container.  Each microservice gets its own config maps, which contain the
    configuration files applicable for the specific microservice.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置映射作为卷挂载，也就是说，作为容器文件系统中的文件夹。每个微服务都有自己的配置映射，包含适用于特定微服务的配置文件。
- en: Define the `SPRING_CONFIG_LOCATION` environment variable to point out the configuration
    files in the volume.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`SPRING_CONFIG_LOCATION`环境变量以指出卷中的配置文件。
- en: Define credentials for access to resource managers using secrets.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥定义访问资源管理器的凭据。
- en: 'Most changes are in the Kubernetes definitions files for the deployment resources.
    Let''s look at the definition of the deployment resource for the `product` microservice
    as an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分变化都在Kubernetes部署资源的定义文件中。让我们以`product`微服务的部署资源定义为例来看一下：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that parts of the definition that have not been affected by the changes
    are left out for improved readability. See `kubernetes/services/base/product.yml`
    for the full source code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于变化未影响到的定义部分被省略以提高可读性。完整的源代码请查看`kubernetes/services/base/product.yml`。
- en: 'The following explains the preceding source code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了前面的源代码：
- en: The `config-repo-product` config map is mapped in a volume named `config-repo-volume`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo-product`配置映射映射在一个名为`config-repo-volume`的卷中。'
- en: The `config-repo-volume` volume is mounted in the filesystem at `/config-repo`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo-volume`卷挂载在文件系统的`/config-repo`目录下。'
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml` files.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_CONFIG_LOCATION`环境变量告诉Spring在哪里可以找到属性文件，在这个例子中，是`/config-repo/application.yml`和`/config-repo/product.yml`文件。'
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `rabbitmq-credentials` and `mongodb-credentials` secrets.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问RabbitMQ和MongoDB的凭据是基于`rabbitmq-credentials`和`mongodb-credentials`密钥的内容设置为环境变量的。
- en: The Kubernetes config maps and secrets will be created in the *Testing with
    ConfigMaps, secrets, and ingress* section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用ConfigMaps、密钥和ingress进行测试*节中创建Kubernetes配置映射和密钥。
- en: That is what is required to replace the configuration server with Kubernetes
    config maps and secrets. In the next section, we will learn about how we can replace
    the Spring Cloud Gateway with a Kubernetes ingress resource.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 替换配置服务器需要的就是这些，接下来的一节中，我们将学习如何用Kubernetes的ingress资源替换Spring Cloud Gateway。
- en: Replacing the Spring Cloud Gateway
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Gateway
- en: In this section, we will further simplify the microservice landscape by replacing
    the Spring Cloud Gateway with the built-in ingress resource in Kubernetes, reducing
    the number of supportive services required to be deployed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过用Kubernetes内置的ingress资源替换Spring Cloud Gateway，进一步简化微服务架构，减少需要部署的支持服务数量。
- en: As introduced in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction
    to Kubernetes*, an ingress resource can be used in Kubernetes to act as an edge
    server in the same way as a Spring Cloud Gateway. The Spring Cloud Gateway comes
    with a richer routing functionality compared to an ingress resource. But the ingress
    feature is part of the Kubernetes platform and can also be extended using the
    Cert Manager to automatically provide certificates, as we will see later on in
    this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)、*Kubernetes简介*中介绍的，Kubernetes中的ingress资源可以像Spring
    Cloud Gateway一样作为边缘服务器使用。Spring Cloud Gateway带有比ingress资源更丰富的路由功能。但是ingress特性是Kubernetes平台的一部分，也可以使用Cert
    Manager自动提供证书，如我们在本章后面所看到的。
- en: We have also used the Spring Cloud Gateway to protect our microservices from
    unauthenticated requests; that is, the microservices require a valid OAuth 2.0/OIDC
    access token from a trusted OAuth Authorization Server or OIDC Provider. See [Chapter
    11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Securing Access to APIs*, if
    a recap is required. Generally, Kubernetes ingress resources do not have support
    for that. Specific implementations of the ingress controller might, however, support
    it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用Spring Cloud Gateway保护我们的微服务免受未经验证的请求；也就是说，微服务需要一个来自可信OAuth授权服务器或OIDC提供者的有效OAuth
    2.0/OIDC访问令牌。如果需要回顾，请参见[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)，*保护API访问*。通常，Kubernetes入口资源不支持这一点。然而，入口控制器的特定实现可能会支持它。
- en: Finally, the composite health check we added to the gateway in [Chapter 10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml),
    *Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server* can be
    replaced by the Kubernetes liveness and readiness probes defined in each microservices
    deployment resource. To me, it makes sense to use the Spring Cloud Gateway where
    the underlying platform doesn't provide a similar capability, but when deploying
    to Kubernetes, it is better to use ingress resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)，*使用Spring Cloud Gateway将微服务隐藏在边缘服务器后面*中向网关添加的综合健康检查可以被每个微服务部署资源中定义的Kubernetes存活和就绪探针所替换。对我来说，在底层平台不提供类似功能时使用Spring
    Cloud Gateway是有意义的，但在部署到Kubernetes时，最好使用入口资源。
- en: In this chapter, we will delegate the responsibility for validating that the
    request contains a valid access token to the `product-composite` microservice.
    The next chapter will introduce the concept of a Service Mesh, where we will see
    an alternate implementation of an ingress that fully supports validating JWT-encoded
    access tokens, that is, the type of access tokens that we are using in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将验证请求是否包含有效访问令牌的责任委托给`product-composite`微服务。下一章将介绍服务网格的概念，我们将看到一个完全支持验证JWT编码访问令牌的入口的替代实现，即我们在本书中使用的访问令牌类型。
- en: In the *Verifying that the microservices work without Kubernetes* section, we
    will still use the Spring Cloud Gateway together with Docker Compose, so we will
    not remove the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*验证微服务在没有Kubernetes的情况下是否工作*部分，我们仍然将使用Spring Cloud Gateway和Docker Compose，所以我们将不会移除项目。
- en: 'The following diagram shows how to remove the Spring Cloud Gateway from the
    microservice landscape when deploying to Kubernetes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了在将Spring Cloud Gateway部署到Kubernetes时，如何将其从微服务架构中移除：
- en: '![](img/d19dde2e-6974-428d-a6e3-ba564833e00a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d19dde2e-6974-428d-a6e3-ba564833e00a.png)'
- en: Let's see what is required to replace the Spring Cloud Gateway with a Kubernetes
    ingress resource!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看替换Spring Cloud Gateway为Kubernetes入口资源需要什么！
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只更改了配置；也就是说，不需要更改Java源代码！
- en: Changes in the source code for Spring Cloud Gateway
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway源代码的变化
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Gateway with a Kubernetes ingress resource:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改已应用于源代码配置，以将Spring Cloud Gateway替换为Kubernetes入口资源：
- en: Changes in the Kubernetes definition files for deployment resources in the `kubernetes/services` folder.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services`文件夹中部署资源的变化。'
- en: Removed the gateway YAML files and its declaration in the `kustomization.yml` files
    in the `base` and `overlays/prod` folders
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了网关的YAML文件及其在`base`和`overlays/prod`文件夹中的声明。
- en: Added the ingress resource in `base/ingress-edge-server.yml` and added a reference
    to it in `base/kustomization.yml`
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`base/ingress-edge-server.yml`中添加了入口资源，并在`base/kustomization.yml`中对其进行了引用
- en: 'The definition of the ingress resource looks like the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 入口资源的定义如下代码所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following are the explanations for the preceding source code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面源代码的解释：
- en: The ingress resource is named `edge`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口资源的名称为`edge`。
- en: The `tls` section specifies that the ingress will require the use of HTTPS and
    that it will use a certificate issued for the `minikube.me` hostname.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`部分指定了入口将需要使用HTTPS，并且它将使用为`minikube.me`主机名发行的证书。'
- en: The certificate is stored in a secret named `tls-certificate`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书存储在一个名为`tls-certificate`的秘密中
- en: The `tls-certificate` secret will be created in *step 4* in the *Testing with
    Kubernetes ConfigMaps, secrets, and ingress resource* section.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*使用 Kubernetes ConfigMaps、secrets 和 ingress 资源进行测试*部分的*步骤 4*中创建`tls-certificate`密钥。
- en: Routing rules are defined for requests to the `minikube.me` hostname.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为请求到`minikube.me`主机名定义路由规则。
- en: The DNS name `minikube.me` will be mapped to the IP address of the Minikube
    instance in the next topic.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一主题中，DNS 名称`minikube.me`将被映射到 Minikube 实例的 IP 地址。
- en: 'Routes are defined for the following:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为以下内容定义路由：
- en: The `auth-server` on the `/oauth` path
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/oauth`路径上的`auth-server`。
- en: The `product-composite` microservice on the `/product-composite` path
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/product-composite`路径上的`product-composite`微服务。
- en: The `health` endpoint in the `product-composite` microservice on the `/actuator/health` path
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite`微服务中的`/actuator/health`路径上的`health`端点。'
- en: The Kubernetes ingress resource will be created in the next section where we
    will test the microservice landscape together with Kubernetes config maps, secrets,
    and an ingress resource.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建 Kubernetes 的 ingress 资源，并一起测试微服务架构，包括 Kubernetes 的 config maps、secrets
    和 ingress 资源。
- en: Testing with Kubernetes ConfigMaps, secrets, and ingress resource
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes ConfigMaps、secrets 和 ingress 资源进行测试。
- en: 'With the preceding changes described, we are ready to test the system landscape
    with the Spring Cloud Config Server and the Spring Cloud Gateway replaced by Kubernetes
    config maps, secrets, and an ingress resource.  As before, when we used the Spring
    Cloud Gateway as the edge server, the external API will be protected by HTTPS.
    With this deployment, we will configure the ingress resource to reuse the self-signed
    certificate we used with the Spring Cloud Gateway for HTTPS. This is illustrated
    by the following diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述更改描述之后，我们准备测试使用 Spring Cloud Config Server 和 Spring Cloud Gateway 替换 Kubernetes
    config maps、secrets 和 ingress 资源的系统架构。与之前一样，当我们使用 Spring Cloud Gateway 作为边缘服务器时，外部
    API 将通过 HTTPS 保护。在此部署中，我们将配置 ingress 资源以重用我们与 Spring Cloud Gateway 一起用于 HTTPS
    的自签名证书。以下图表展示了这一点：
- en: '![](img/5eb38462-0a35-4944-a8e6-0e6ff5e338b1.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eb38462-0a35-4944-a8e6-0e6ff5e338b1.png)'
- en: In the next section, we will enhance the certificate usage and replace the self-signed
    certificate with certificates issued by Let's Encrypt.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将增强证书使用，并将自签名证书替换为 Let's Encrypt 发行的证书。
- en: 'The ingress will be exposed on the default HTTPS port, `443`, on the Minikube
    instance. This is handled by the ingress controller that was installed when we
    performed the `minikube addons enable ingress` command; see [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes *and refer to the *Creating a Kubernetes cluster*
    section for a recap. The ingress controller consists of a deployment, `nginx-ingress-controller`,
    in the `kube-system` namespace. The deployment configures its pod using a `hostPort`
    to map port `443` in the host, that is, the Minikube instance, to port `443` in
    the container that runs in the pod. The central parts in the definition of the
    deployment look like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ingress 将在 Minikube 实例的默认 HTTPS 端口`443`上暴露。这由我们在执行`minikube addons enable ingress`命令时安装的
    ingress 控制器处理；参见[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)*Kubernetes
    简介*，并参考*创建 Kubernetes 集群*部分进行回顾。ingress 控制器由在`kube-system`命名空间中的部署`nginx-ingress-controller`组成。部署使用`hostPort`将其端口`443`映射到宿主机上，即
    Minikube 实例中的端口`443`，该端口在容器中运行。部署的定义中的主要部分如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This setup works for a single-node Kubernetes cluster used for development and
    testing. In a multi-node Kubernetes cluster, external load balancers are used
    to expose an ingress controller for high availability and scalability.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置适用于用于开发和测试的单节点 Kubernetes 集群。在多节点 Kubernetes 集群中，外部负载均衡器用于暴露高可用性和可伸缩性的 ingress
    控制器。
- en: The deployment uses the same type of commands as we used in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*; refer to the *Deploying to Kubernetes
    for development and test* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 部署使用了与我们在[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)*部署我们的微服务到 Kubernetes*中使用的相同类型的命令；参考*部署到
    Kubernetes 以进行开发和测试*部分。
- en: 'The major differences are that this deployment will:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别是，此部署将：
- en: Create one config map for each microservice instead of one config map for the configuration
    server
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个微服务创建一个 config map，而不是为配置服务器创建一个 config map。
- en: Create secrets for credentials to the resource managers and a secret for the
    TLS certificate used by the ingress instead of creating secrets for the credentials
    to the configuration server
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于资源管理器凭据的秘密和用于ingress的TLS证书的秘密，而不是创建用于配置服务器凭据的秘密
- en: Create one ingress instead of using Spring Cloud Gateway
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Ingress，而不是使用Spring Cloud Gateway
- en: To simplify the deployment, deploy scripts for the development and production environments
    have been added to the source code. Let's go through the deploy script for the development environment
    that we will use in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化部署，已将开发和生产环境的部署脚本添加到源代码中。让我们来看看我们将在此部分使用的开发环境的部署脚本。
- en: Walking through the deploy script
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览部署脚本
- en: 'The `kubernetes/scripts/deploy-dev-env.bash` script, contains the necessary
    commands for performing the deployment. The script will perform the following
    steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes/scripts/deploy-dev-env.bash`脚本包含了执行部署所需的所有命令。该脚本将执行以下步骤：'
- en: 'It will create config maps, one per microservice. For example, for the `product`
    microservice, we have the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将创建一个配置文件，每个微服务一个。例如，对于`product`微服务，我们有以下内容：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, it will create the required secrets. For example, credentials for accessing
    RabbitMQ are created with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将创建所需的秘密。例如，使用以下命令创建访问RabbitMQ的凭据：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Secrets are also created for the resource managers; their names are suffixed
    with `server-credentials`. They are used in the Kubernetes definitions files in
    the `kubernetes/services/overlays/dev` folder. For example, credentials used by
    RabbitMQ are created with the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也为资源管理器创建了秘密；它们的名称以`server-credentials`结尾。它们在`kubernetes/services/overlays/dev`文件夹的Kubernetes定义文件中使用。例如，使用以下命令创建RabbitMQ的凭据：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The secret that contains the TLS certificate for the ingress, `tls-certificate`,
    is based on the already existing self-signed certificate in the `kubernetes/cert` folder.
    It is created with the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含ingress的TLS证书的秘密`tls-certificate`基于`kubernetes/cert`文件夹中已经存在的自签名证书。它使用以下命令创建：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The self-signed certificate has been created with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令创建了自签名证书：
- en: '`openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout kubernetes/cert/tls.key
    -out kubernetes/cert/tls.crt -subj "/CN=minikube.me/O=minikube.me"`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout kubernetes/cert/tls.key
    -out kubernetes/cert/tls.crt -subj "/CN=minikube.me/O=minikube.me"`'
- en: 'Deploy the microservices for the development environment, based on the `dev` overlay,
    using the `-k` switch to activate Kustomize:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`dev`覆盖层部署开发环境的微服务，使用`-k`开关激活Kustomize：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Wait for the deployment and its pods to be up and running:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待部署及其pods运行：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After this walkthrough, we are ready to run the commands required for deploying
    and testing!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本指南后，我们就可以运行部署和测试所需的命令了！
- en: Running commands for deploying and testing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试命令的运行
- en: 'Before we can perform the deployment, we need to make the following preparations:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够执行部署之前，需要做以下准备工作：
- en: Map the DNS name used by the ingress, `minikube.me`, to the IP address of the
    Minikube instance
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ingress使用的DNS名称`minikube.me`映射到Minikube实例的IP地址
- en: Build Docker images from source
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建Docker镜像
- en: Create a namespace in Kubernetes
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中创建一个命名空间
- en: 'Run the following commands to prepare, deploy, and test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以准备、部署和测试：
- en: 'Map `minikube.me` to the IP address of the Minikube instance by adding a line
    to the file `/etc/hosts` with the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`minikube.me`映射到Minikube实例的IP地址，通过在`/etc/hosts`文件中添加以下命令的行来实现：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify the result with the `cat /etc/hosts` command. Expect a line that contains
    the IP address of your Minikube instance followed by `minikube.me` as shown in
    the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cat /etc/hosts`命令验证结果。预期会出现包含Minikube实例IP地址后跟`minikube.me`的行，如下所示：
- en: '![](img/e620ccae-5f94-4d2f-a0cc-9c5b94ffb268.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e620ccae-5f94-4d2f-a0cc-9c5b94ffb268.png)'
- en: 'Build Docker images from source with the following commands:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从源代码构建Docker镜像：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Recreate the namespace, `hands-on`, and set it as the default namespace:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建命名空间`hands-on`，并将其设置为默认命名空间：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Execute the deployment by running the script with the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令执行部署脚本：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the deployment is complete, start the tests with the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署完成后，使用以下命令启动测试：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Expect the normal output that we have seen from the previous chapters as shown
    in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 期待我们看到前几章中的正常输出，如下面的屏幕截图所示：
- en: '![](img/2029adbf-aead-45bf-b8a5-78f258baa0f6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2029adbf-aead-45bf-b8a5-78f258baa0f6.png)'
- en: 'You can try out the APIs manually by performing the same steps as in the earlier
    chapters: just replace the host and port with `minikube.me`. Get an OAuth/OIDC
    access token and use it to call an API with the following commands:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以尝试手动执行早期章节中的相同步骤来测试 API：只需将主机和端口替换为 `minikube.me`。获取 OAuth/OIDC 访问令牌，并使用它调用具有以下命令的
    API：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Expect the requested product ID, `2`, in the response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 期待在响应中收到请求的产品 ID，`2`。
- en: The deployment we have set up in this section is based on an environment aimed
    at developing and testing. If you want to set up an environment aimed at staging
    and production, such as the one described in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*, refer to the *Deploying to Kubernetes
    for staging and production* section. For this, you can use the `./kubernetes/scripts/deploy-prod-env.bash` script.
    Use it in *step 4* as previously outlined instead of the `deploy-dev-env.bash` script.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中设置的部署是基于一个用于开发和测试的环境。如果您想要建立一个用于 staging 和生产的环境，例如在第 [16 章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)《将我们的微服务部署到
    Kubernetes》中描述的那样，请参考“为 staging 和生产部署到 Kubernetes”部分。为此，您可以使用 `./kubernetes/scripts/deploy-prod-env.bash`
    脚本。在第 4 步中像以前概述的那样使用它，而不是 `deploy-dev-env.bash` 脚本。
- en: Note that the `deploy-prod-env.bash` script will launch the three resource managers
    for MySQL, MongoDB, and RabbitMQ using Docker Compose; that is, they will run as
    Docker containers outside Kubernetes (in the same way as in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`deploy-prod-env.bash` 脚本将使用 Docker Compose 启动 MySQL、MongoDB 和 RabbitMQ 的三个资源管理器；也就是说，它们将作为
    Docker 容器在 Kubernetes 外运行（正如在[第 16 章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)《将我们的微服务部署到
    Kubernetes》中所描述的那样）。
- en: This deployment uses a self-signed certificate that was exposed by the Kubernetes
    ingress and that requires manual provisioning. Manual handling of certificates
    is both time-consuming and error-prone. It is, for example, very easy to forget
    to renew a certificate in time. In the next section, we will learn how to use
    the Cert Manager and Let's Encrypt to automate this provisioning process!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署使用了一个由 Kubernetes ingress 暴露的自签名证书，该证书需要手动提供。手动处理证书既耗时又容易出错。例如，很容易忘记及时续签一个证书。在下一节中，我们将学习如何使用
    Cert Manager 和 Let's Encrypt 来自动化这个提供过程！
- en: Automating the provision of certificates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化证书的提供
- en: As mentioned in the introduction to this chapter, we will use the Cert Manager
    to automate the provision of certificates used by the external HTTPS endpoint
    exposed by the ingress. The Cert Manager will run as an add-on in Kubernetes and
    will be configured to request the issuing of certificates from Let's Encrypt with
    a free Certificate Authority that can be used to automate the issuing of certificates.
    To be able to verify that we own the DNS name that the certificate shall be issued
    for, Let's Encrypt requires access to the endpoint we want to issue the certificate
    for. Since our Kubernetes cluster runs locally in Minikube, we must make it possible
    for Let's Encrypt to access our cluster during the provisioning. We will use the ngrok
    tool to create a temporary HTTP tunnel from the internet to our local Kubernetes
    cluster to be used by Let's Encrypt.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章介绍中提到的，我们将使用 Cert Manager 来自动化由 ingress 暴露的外部 HTTPS 端点所使用的证书的提供。Cert Manager
    将在 Kubernetes 中作为一个附加组件运行，并配置为从 Let's Encrypt 请求免费证书颁发机构的证书，以自动化证书的颁发。为了能够验证我们拥有证书将要颁发的
    DNS 名称，Let's Encrypt 要求访问我们要为其颁发证书的端点。由于我们的 Kubernetes 集群在本地运行 Minikube，我们必须让
    Let's Encrypt 在证书提供期间能够访问我们的集群。我们将使用 ngrok 工具创建一个从互联网到我们的本地 Kubernetes 集群的临时 HTTP
    隧道，供 Let's Encrypt 使用。
- en: 'For more information on each product, see the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每个产品的更多信息，请参阅以下内容：
- en: Cert Manager: [http://docs.cert-manager.io/en/latest/index.html](http://docs.cert-manager.io/en/latest/index.html)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cert Manager: [http://docs.cert-manager.io/en/latest/index.html](http://docs.cert-manager.io/en/latest/index.html)'
- en: Let's Encrypt: [https://letsencrypt.org/docs/](https://letsencrypt.org/docs/)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Let''s Encrypt: [https://letsencrypt.org/docs/](https://letsencrypt.org/docs/)'
- en: ngrok: [https://ngrok.com/docs](https://ngrok.com/docs)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ngrok: [https://ngrok.com/docs](https://ngrok.com/docs)'
- en: 'All this together might seem a bit overwhelming, so let''s take it step by
    step:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切可能看起来有些令人望而却步，所以让我们一步一步来：
- en: Deploy the Cert Manager and define issuers in Kubernetes based on Let's Encrypt.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署证书管理器并在 Kubernetes 中基于 Let's Encrypt 定义发行者。
- en: Create an HTTP tunnel using ngrok.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ngrok 创建 HTTP 隧道。
- en: Provision certificates with the Cert Manager and Let's Encrypt.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用证书管理器（Cert Manager）和让我们加密（Let's Encrypt）提供证书。
- en: Verify that we got certificates from Let's Encrypt.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们是否从 Let's Encrypt 获取了证书。
- en: Clean up.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理。
- en: The HTTP tunnel is only required if your Kubernetes cluster isn't reachable
    on the internet. If its ingress resource can be accessed directly from the internet,
    the use of ngrok can be skipped.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你的 Kubernetes 集群无法通过互联网访问时，才需要 HTTP 隧道。如果其入口资源可以直接从互联网访问，则可以跳过使用 ngrok。
- en: Deploying the Cert Manager and defining Let's Encrypt issuers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署证书管理器并定义 Let's Encrypt 发行者
- en: 'To deploy the Cert Manager, we can execute a single Kubernetes definition file
    that will create a namespace, `cert-manager`, and then deploy the Cert Manager
    into the namespace. We will install version 0.8.1, the latest available version
    when writing this chapter. Run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署证书管理器（Cert Manager），我们可以执行一个 Kubernetes 定义文件，这将创建一个名为 `cert-manager` 的命名空间，然后将证书管理器部署到该命名空间中。我们将安装编写本章时的最新版本
    0.8.1。运行以下命令：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you get an error message such as `unable to recognize "https://github.com/jetstack/cert-manager/releases/download/v0.8.1/cert-manager.yaml":
    no matches for kind "Issuer" in version "certmanager.k8s.io/v1alpha1"`, then simply
    rerun the command again.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到类似“无法识别 "https://github.com/jetstack/cert-manager/releases/download/v0.8.1/cert-manager.yaml"：在版本
    "certmanager.k8s.io/v1alpha1" 中没有找到 "Issuer" 种类”的错误消息，那么只需重新运行命令即可。
- en: 'Wait for the deployment and its pods to be available:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 等待部署及其 Pod 可用：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Expect output similar to the following from the command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 预期从命令中输出与以下类似的结果：
- en: '![](img/196e1fc3-83ec-4d71-84dc-18e5f84a59ed.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/196e1fc3-83ec-4d71-84dc-18e5f84a59ed.png)'
- en: With the Cert Manager in place, we can define issuers in Kubernetes that are
    based on Let's Encrypt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了证书管理器（Cert Manager）之后，我们可以在 Kubernetes 中定义基于 Let's Encrypt 的发行者。
- en: 'Let''s Encrypt exposes the following issuers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加密（Let's Encrypt）暴露了以下发行者：
- en: '**Staging environment**, to be used during development and test phases where
    it can be expected that a lot of short-lived certificates are requested. The staging
    environment allows for the creation of many certificates but the root **CA** *(*short
    for **Certificate Authority**) in the certificate is not trusted. This means that
    certificates from the staging environment can''t be used to protect web pages
    or APIs used by a web browser. A web browser won''t trust its root CA and will
    complain when a user opens a web page protected by certificates from the staging
    environment.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和测试阶段使用的暂存环境**，可以预期在这一阶段会请求很多短期证书。暂存环境允许创建许多证书，但证书中的根**CA**（证书授权中心）不被信任。这意味着来自暂存环境的证书不能用于保护由网页浏览器使用的网页或
    API。当用户打开由暂存环境中的证书保护的网页时，网页浏览器不会信任其根 CA 并抱怨。'
- en: '**Production environment**, it uses a trusted root CA to issue certificates.
    It can, therefore, be used to issue certificates that are trusted by web browsers.
    The production environment limits the number of certificates that can be issued.
    For example, only 50 new certificates per week can be issued per registered domain,
    for instance, in case `ngrok.io`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**，它使用一个受信任的根 CA 来颁发证书。因此，它可以用来颁发被网页浏览器信任的证书。生产环境限制了可以颁发的证书数量。例如，每个注册域名每周只能发行
    50 个新证书，例如在 `ngrok.io` 的情况下。'
- en: We will register two issuers in Kubernetes, one for the staging environment
    and one for the production environment. Issuers can be registered either globally
    in the cluster or locally in a namespace. To keep things together, we will use
    namespace local issuers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Kubernetes 中注册两个发行者，一个用于暂存环境，一个用于生产环境。发行者可以在集群全局或命名空间局部注册。为了保持一致性，我们将使用命名空间局部发行者。
- en: 'Communication between the Cert Manager and Let''s Encrypt during the provision
    of certificates is based on a standard protocol, **Automated Certificate Management
    Environment v2**, or **ACME v2** for short. Let''s Encrypt will act as a CA and
    the Cert Manager will act as an ACME client. To validate the ownership of a DNS
    name, the ACME protocol specifies two types of challenge that a CA can use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在证书提供过程中，证书管理器（Cert Manager）和让我们加密（Let's Encrypt）之间的通信基于一个标准协议，即**自动化证书管理环境
    v2**（**ACME v2**）。让我们加密将充当证书授权中心（CA），而证书管理器将充当 ACME 客户端。为了验证 DNS 名称的所有权，ACME 协议规定了
    CA 可以使用两种类型的挑战：
- en: '`http-01`: The CA asks the ACME client for a randomly named file to be made
    available under the following URL: `http://<domainname>/.well-known/acme-challenge/<randomfilename>`.
    If the CA succeeds in accessing the file using this URL, the ownership of the
    domain is validated.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-01`: 认证机构（CA）要求ACME客户端在以下URL下创建一个随机命名的文件：`http://<domainname>/.well-known/acme-challenge/<randomfilename>`。如果CA能够使用这个URL成功访问该文件，那么域名所有权得到验证。'
- en: '`dns-01`: The CA asks the ACME client for a specified value to be placed in
    a TXT record, `_acme-challenge.<YOUR_DOMAIN>`, under the domain in the DNS server.
    This is typically achieved by using an API of the DNS provider. If the CA succeeds
    in accessing the specified content in the TXT record in the DNS server, the ownership
    of the domain is validated.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns-01`: 认证机构（CA）要求ACME客户端在DNS服务器下的域名`_acme-challenge.<YOUR_DOMAIN>`放置一个指定的值。这通常通过DNS提供商的API来实现。如果CA能够在DNS服务器中的TXT记录中访问到指定的内容，那么域名所有权得到验证。'
- en: Automating a `dns-01` based challenge is harder to achieve than automating an
    `http-01` challenge in most cases; however, it is preferred, for example, if the
    HTTP endpoint isn't available on the internet. A `dns-01` challenge also supports
    issuing wildcard certificates, which an `http-01` challenge can't be used for.
    In this chapter, we will configure the Cert Manager to use an `http-01`—based
    challenge.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化`dns-01`挑战通常比自动化`http-01`挑战要困难，但在HTTP端点不可通过互联网的情况下，它是更优的选择。`dns-01`挑战还支持发行通配符证书，这是`http-01`挑战无法使用的。在本章中，我们将配置Cert
    Manager以使用基于`http-01`的挑战。
- en: 'The definition of the issuer for the Let''s Encrypt staging environment looks
    like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Let's Encrypt测试环境的发行者定义如下：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following explains the preceding source code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了前面的源代码：
- en: The `name` of the issuer, `letsencrypt-issuer-staging`, will be used in the
    ingress when referring to the issuer to be used when provisioning certificates
    for the ingress.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行者的`name`，`letsencrypt-issuer-staging`，将在负载均衡器中引用发行者时使用，以提供证书。
- en: The `email` must be filled in with your email address. Let's Encrypt will use
    the email address to contact you about expiring certificates and issues, if any,
    related to your account.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`必须填写您的电子邮件地址。Let''s Encrypt将使用该电子邮件地址联系您关于到期的证书和与您账户相关的问题。'
- en: The `server` field points out the URL for the Let's Encrypt staging environment.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`字段指出了Let''s Encrypt测试环境的URL。'
- en: The `privateKeySecretRef` field contains the name of a secret. This secret will
    be created by the Cert Manager and will contain an ACME/Let's Encrypt `account
    private key`. This key identifies you (or your company) as a user of the ACME
    service, that is, Let's Encrypt. It is used to sign requests sent to Let's Encrypt
    to validate your identity.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privateKeySecretRef`字段包含一个密钥的名字。这个密钥将由Cert Manager创建，并将包含一个ACME/Let''s Encrypt
    `account private key`。这个密钥用来识别您（或您的公司）作为ACME服务的用户，即Let''s Encrypt。它用于签署发送到Let''s
    Encrypt的请求，以验证您的身份。'
- en: The `solver` definition declares that an `http-01` challenge shall be used to
    verify the ownership of the domain name.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solver`定义声明使用`http-01`挑战来验证域名所有权。'
- en: The definition of the issuer for the Let's Encrypt production environment looks
    the same, the major difference is the ACME server URL used: [https://acme-v02.api.letsencrypt.org/directory](https://acme-v02.api.letsencrypt.org/directory).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Let's Encrypt生产环境的发行者定义看起来是一样的，主要区别在于使用的ACME服务器URL：[https://acme-v02.api.letsencrypt.org/directory](https://acme-v02.api.letsencrypt.org/directory)。
- en: 'Edit the following files and replace `<your email address>` with your email
    address:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑以下文件，并将`<your email address>`替换为您的电子邮件地址：
- en: '`kubernetes/services/base/letsencrypt-issuer-staging.yaml`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base/letsencrypt-issuer-staging.yaml`'
- en: '`kubernetes/services/base/letsencrypt-issuer-prod.yaml`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base/letsencrypt-issuer-prod.yaml`'
- en: 'Apply the definitions with the following commands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用定义：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have the Cert Manager in place and have registered issuers for the Let's
    Encrypt staging and production environment. The next step is to create an HTTP
    tunnel using `ngrok`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Cert Manager，并注册了Let's Encrypt测试环境和生产环境的发行者。下一步是使用`ngrok`创建一个HTTP隧道。
- en: Creating an HTTP tunnel using ngrok
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngrok创建HTTP隧道
- en: 'The free subscription to `ngrok` can be used to create an HTTP tunnel where
    `ngrok` terminates the HTTPS traffic using its own wildcard certificate for `***.ngrok.io`,
    that is, before the HTTP requests reach the ingress resource in Kubernetes. The
    client that sends the HTTPS request will only see the `ngrok` certificate and
    not the certificate exposed by the ingress resource in Kubernetes. This means
    that we can''t use the HTTP tunnel to test a certificate that has been issued
    by Let''s Encrypt and is used by the ingress resource in Kubernetes. This is illustrated
    in the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngrok`的免费订阅可以用来创建一个HTTP隧道，其中`ngrok`使用其自己的通配符证书`***.ngrok.io`来终止HTTPS流量，也就是说，在HTTP请求到达Kubernetes中的ingress资源之前。发送HTTPS请求的客户端只能看到`ngrok`证书，而看不到Kubernetes中ingress资源暴露的证书。这意味着我们不能使用HTTP隧道来测试由Let''s
    Encrypt发行并由Kubernetes中的ingress资源使用的证书。这在以下图表中有所说明：'
- en: '![](img/a5583460-7ef4-4f1a-a566-507395d3be49.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5583460-7ef4-4f1a-a566-507395d3be49.png)'
- en: 'But the HTTP tunnel can be used during the provisioning phase where Let''s
    Encrypt needs to verify that the ACME client owns the DNS name it is requested
    to issue a certificate for. The DNS name will be the hostname that `ngrok` assigns
    to the HTTP tunnel, for example, `6cc09528.ngrok.io`. Once the provisioning is
    performed, we can shut down the HTTP tunnel and redirect the hostname to the IP
    address of the Minikube instance (using the local `/etc/hosts` file). This is
    illustrated in the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在提供证书的过程中，可以让HTTP隧道来使用，这时Let's Encrypt需要验证ACME客户端是否拥有它请求颁发证书的DNS名称。DNS名称将是HTTP隧道分配给的主机名，例如，`6cc09528.ngrok.io`。一旦完成提供证书的过程，我们可以关闭HTTP隧道并将主机名重定向到Minikube实例的IP地址（使用本地的`/etc/hosts`文件）。这在以下图表中有所说明：
- en: '![](img/d42306ac-0d80-43ca-bbc8-f783f35353ed.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d42306ac-0d80-43ca-bbc8-f783f35353ed.png)'
- en: For paying customers, `ngrok` provides a TLS tunnel that passes through HTTPS
    traffic instead of terminating it; that is, a client that sends an HTTPS request
    will be able to see and verify the certificate exposed by the ingress resource
    in Kubernetes. Using a TLS tunnel instead of the HTTP tunnel should make this
    extra step unnecessary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于付费客户，`ngrok`提供了一个TLS隧道，它通过HTTPS流量而不是终止它；也就是说，发送HTTPS请求的客户端能够看到并验证Kubernetes中ingress资源暴露的证书。使用TLS隧道而不是HTTP隧道应该使这一额外步骤变得
    unnecessary。
- en: 'Perform the following steps to create the HTTP tunnel:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建HTTP隧道：
- en: 'Create the HTTP tunnel with the following command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建HTTP隧道：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Expect output similar to the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望输出类似于以下屏幕截图：
- en: '![](img/cc23906d-f9c7-44e8-aa0d-da848bd6e750.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc23906d-f9c7-44e8-aa0d-da848bd6e750.png)'
- en: 'Pick up the hostname for the HTTP tunnel, `6cc09528.ngrok.io` in the preceding
    example, and save it in an environment variable such as the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起HTTP隧道的主机名，例如前面的示例中的`6cc09528.ngrok.io`，并将其保存在一个环境变量中，如下所示：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the HTTP tunnel in place, we can prepare the definition of the ingress
    resource for automatic provisioning of its certificate using the Cert Manager
    and Let's Encrypt!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP隧道就位的情况下，我们可以为使用Cert Manager和Let's Encrypt自动提供其证书的ingress资源的定义做好准备！
- en: Provisioning certificates with the Cert Manager and Let's Encrypt
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cert Manager和Let's Encrypt提供证书
- en: 'Before configuring the ingress resource, it might be good to have a high level
    understanding of how the provisioning is performed. The automated provisioning of
    a certificate using the Cert Manager and Let''s Encrypt looks like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置ingress资源之前，了解提供证书的高级过程可能会有所帮助。使用Cert Manager和Let's Encrypt自动提供证书的过程如下：
- en: '![](img/ed4a016d-32e6-4381-af09-0f5d93641c42.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed4a016d-32e6-4381-af09-0f5d93641c42.png)'
- en: 'The following steps will be taken during the provisioning:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将在提供过程中进行：
- en: 'An ingress is created annotated with `certmanager.k8s.io/issuer: "name of a
    Let''s Encrypt issuer"`.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建了一个注有`certmanager.k8s.io/issuer: "name of a Let''s Encrypt issuer"`的ingress。'
- en: This annotation will trigger the Cert Manager to start to provide a certificate
    for the ingress using Let's Encrypt.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个注解将触发Cert Manager开始使用Let's Encrypt为ingress提供证书。
- en: During the provisioning process, Let's Encrypt will perform an `http-01` challenge
    and use the HTTP tunnel to verify that the Cert Manager owns the DNS name.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供证书的过程中，Let's Encrypt将执行一个`http-01`挑战，并使用HTTP隧道来验证Cert Manager拥有DNS名称。
- en: Once the provisioning is complete, the Cert Manager will store the certificate
    in Kubernetes and create a secret with the name specified by the ingress.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦配置完成，Cert Manager将在Kubernetes中存储证书，并创建一个由入口指定的名称的秘密。
- en: 'We will add a new ingress, `edge-ngrok`, defined in the `ingress-edge-server-ngrok.yml` file, which will
    route requests to the hostname of the HTTP tunnel. This ingress will have the
    same routing rules as the existing ingress. The part that differs looks like the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新的入口`edge-ngrok`，定义在`ingress-edge-server-ngrok.yml`文件中，它将路由请求到HTTP隧道的主机名。这个入口将具有与现有入口相同的路由规则。不同的部分看起来像以下这样：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is an explanation for the preceding source code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面源代码的解释：
- en: 'Using the `certmanager.k8s.io/issuer: "letsencrypt-issuer-staging"` annotation, 
    we ask the Cert Manager to provision a certificate for this ingress using the
    issuer named `letsencrypt-issuer-staging`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`certmanager.k8s.io/issuer: "letsencrypt-issuer-staging"`注解，我们请求Cert Manager使用名为`letsencrypt-issuer-staging`的发行版为这个入口配置证书。'
- en: The `xxxxxxxx.ngrok.io` hostname in the `tls` and `rules` declarations must
    be replaced with the actual hostname of your HTTP tunnel.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`和`rules`声明中的`xxxxxxxx.ngrok.io`主机名必须用你的HTTP隧道实际主机名替换。'
- en: The secret with the name `tls-ngrok-letsencrypt-certificate` is where the certificate
    will be stored once the provisioning is complete.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦配置完成，证书将被存储在名为`tls-ngrok-letsencrypt-certificate`的秘密中。
- en: With this high level of understanding of the provisioning process and an ingress
    resource prepared for using it in place, we can start to provision certificates
    using the two environments that Let's Encrypt supports. Let's start with the staging
    environment, suitable for development and test activities.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解配置过程的高级层面并准备好使用它的入口资源之后，我们可以开始使用Let's Encrypt支持的两个环境来配置证书。首先从适合开发和测试活动的staging环境开始。
- en: Using Let's Encrypt's staging environment
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt的staging环境
- en: 'Perform the following steps to provision a certificate from Let''s Encrypt
    staging environment and verify that it works:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤从Let's Encrypt的staging环境配置证书并验证它是否工作：
- en: Edit the `kubernetes/services/base/ingress-edge-server-ngrok.yml` file and replace `xxxxxxxx.ngrok.io` with
    the hostname of your HTTP tunnel in two places!
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`kubernetes/services/base/ingress-edge-server-ngrok.yml`文件，并将`xxxxxxxx.ngrok.io`用你的HTTP隧道的主机名替换两次！
- en: (`6cc09528.ngrok.io` in the preceding example.)
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （之前的示例中的`6cc09528.ngrok.io`。）
- en: 'Before starting up the provisioning, run a watch command in a separate Terminal
    window to monitor the provisioning of the certificate. Run the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动配置之前，在另一个终端窗口中运行一个watch命令来监控证书的配置。运行以下命令：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Initiate the provisioning by applying the new ingress definition with the following
    command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令应用新的入口定义来启动配置：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Cert Manager will now detect the new ingress and start to provide a certificate
    with Let's Encrypt staging environment as the issuer using the ACME v2 protocol
    via the HTTP tunnel set up by `ngrok`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cert Manager现在将检测到新的入口并开始使用由`ngrok`设置的HTTP隧道通过ACME v2协议提供Let's Encrypt staging环境的证书。
- en: 'After a while, you should notice the `http-01` challenge in the Terminal window
    where the HTTP tunnel runs. Expect a request like the following in the output:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过了一会儿，你应该注意到在运行HTTP隧道的终端窗口中出现了`http-01`挑战。预期输出中将有一个像以下的请求：
- en: '![](img/48532285-e42c-41b8-87c5-953c433986d2.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48532285-e42c-41b8-87c5-953c433986d2.png)'
- en: 'A `tls-ngrok-letsencrypt-certificate` certificate will be created and it will
    be stored in the `tls-ngrok-letsencrypt-certificate` secret, as specified in the
    ingress. Expect output from the `kubectl get cert --watch` command similar to
    the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个`tls-ngrok-letsencrypt-certificate`证书，并将其存储在`tls-ngrok-letsencrypt-certificate`秘密中，如入口指定。预期`kubectl
    get cert --watch`命令的输出将与以下类似：
- en: '![](img/75548aa6-b6b1-4b86-b7f3-24a40a679869.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75548aa6-b6b1-4b86-b7f3-24a40a679869.png)'
- en: After a while the `READY` state of the certificate will be changed to `True`,
    meaning that the certificate is provisioned and we are ready to try it out!
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过了一会儿，证书的`READY`状态将变为`True`，这意味着证书已经配置好，我们可以尝试使用它！
- en: 'To try out the certificate provisioned by Let''s Encrypt, we need to redirect
    the `ngrok` hostname to point directly to the Minikube IP address. We will add
    the hostname of the HTTP tunnel to the `/etc/hosts` file resolved to the IP address
    of the Minikube instance. This will result in local requests sent to the hostname
    of the HTTP tunnel being directed to the Minikube instance as illustrated by the
    following diagram:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了尝试由Let's Encrypt提供的证书，我们需要将`ngrok`主机名重定向以直接指向Minikube IP地址。我们将向`/etc/hosts`文件中添加HTTP隧道的主机名，使其解析到Minikube实例的IP地址。这将导致本地请求发送到HTTP隧道的主机名被引导到Minikube实例，如下所示图所示：
- en: '![](img/e82140ea-df2b-41c7-9abd-a64f465ec373.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e82140ea-df2b-41c7-9abd-a64f465ec373.png)'
- en: 'Edit the `/etc/hosts` file and add the hostname of your HTTP tunnel after `minikube.me`
    in the line we added earlier in the chapter. After the edit, the line should look
    similar to the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/hosts`文件，在我们在本章早些时候添加的行中添加HTTP隧道的主机名在`minikube.me`之后。编辑后，该行应类似于以下内容：
- en: '![](img/bc8718bb-49a9-4a2d-835a-7a07a6b48936.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc8718bb-49a9-4a2d-835a-7a07a6b48936.png)'
- en: 'Use the `keytool` command to see what certificate the hostname of the HTTP
    tunnel exposes:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`keytool`命令查看HTTP隧道主机名暴露的证书：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Expect a response such as the following:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望收到如下响应：
- en: '![](img/02d1d310-1b40-4966-ab53-2a8b2a6dd43a.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d1d310-1b40-4966-ab53-2a8b2a6dd43a.png)'
- en: If your `keytool` is localized, that is, it prints its output in another language
    rather than English, you will need to change the `Owner:|Issuer:` string used
    by the preceding `grep` command, to the localized version.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`keytool`是本地化的，也就是说，它将其输出打印成除英语外的其他语言，您将需要更改前面`grep`命令使用的`Owner:|Issuer:`字符串，以使用本地化版本。
- en: The certificate is issued for the hostname of the HTTP tunnel (`6cc09528.ngrok.io` in
    the preceding example) and it is issued by `Fake LE Intermediate X1` using `Fake
    LE Root X1` as its Root CA. This verifies that the ingress uses the Let's Encrypt
    staging certificate!
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证书是为HTTP隧道的主机名（在前一个示例中为`6cc09528.ngrok.io`）签发的，并由`Fake LE Intermediate X1`使用`Fake
    LE Root X1`作为其根CA签发。这证明ingress使用了Let's Encrypt的测试证书！
- en: 'Wrap up by running the `test-em-all.bash` test script using the same command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用相同的命令运行`test-em-all.bash`测试脚本总结：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Expect the usual output from the test script; check that it concludes with
    the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 期望测试脚本输出通常的结果；检查它以如下结论结束：
- en: '![](img/b922e10e-eac0-41a4-8ca6-c714f34b08e5.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b922e10e-eac0-41a4-8ca6-c714f34b08e5.png)'
- en: Certificates provisioned by Let's Encrypt staging environment are, as mentioned
    previously, good for development and test activities. But since its root CA is
    not trusted by web browsers, they can't be used in production scenarios. Let's
    also try out Let's Encrypt's production environment, which is capable of provisioning
    trusted certificates, albeit in limited numbers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由Let's Encrypt测试环境提供的证书，如前所述，适合开发和测试活动。但由于其根CA不被网络浏览器信任，因此它们不能用于生产场景。让我们也尝试使用Let's
    Encrypt的生产环境，该环境能够提供可信的证书，尽管数量有限。
- en: Using Let's Encrypt's production environment
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt的生产环境
- en: 'To provision a certificate from Let''s Encrypt production environment, instead
    of the staging environment, we have to change the issuer in the ingress definition
    and then apply the updated definition. Perform the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Let's Encrypt的生产环境获取证书，而不是测试环境，我们必须在ingress定义中更改发行者，然后应用更新后的定义。执行以下步骤：
- en: 'Edit the `kubernetes/services/base/ingress-edge-server-ngrok.yml`  file and
    change the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`kubernetes/services/base/ingress-edge-server-ngrok.yml`文件，并更改以下代码：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code should now be as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码现在应该如下所示：
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Apply the change by running the following command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用更改：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Monitor the output from the `kubectl get cert --watch` command and wait for
    the new certificate to be provisioned. Its ready state will change to `False`
    immediately after the apply command, and after a short while it will go back to
    `True`. This means that the Cert Manager has provisioned a certificate issued
    by Let's Encrypt production environment!
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控`kubectl get cert --watch`命令的输出，并等待新证书被提供。在应用命令后立即，其就绪状态将更改为`False`，然后过一会儿将回到`True`。这意味着Cert
    Manager已经提供了由Let's Encrypt生产环境签发的证书！
- en: 'Check the certificate with the following `keytool` command:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`keytool`命令检查证书：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Expect output such as the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/5d0e1392-a7d9-469e-9b9e-6c49555ebdcb.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d0e1392-a7d9-469e-9b9e-6c49555ebdcb.png)'
- en: The new certificate is like the one previously issued for the hostname of the
    HTTP tunnel (`6cc09528.ngrok.io` in the preceding example), but this time the
    issuer and Root CA are from the production environment. This means that the certificate
    should be trusted by a web browser.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新证书就像之前为 HTTP 隧道的主机名发行的证书（在前一个示例中为 `6cc09528.ngrok.io`），但这次发行者和根 CA 来自生产环境。这意味着证书应该被网页浏览器信任。
- en: 'Open the `https://6cc09528.ngrok.io/actuator/health` URL (replace `6cc09528.ngrok.io`
    with the hostname of your HTTP tunnel) in a local web browser. If you use Google
    Chrome and click on the certificate icon (the padlock in front of the URL) you
    should see something like the following output:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地网络浏览器中打开 `https://6cc09528.ngrok.io/actuator/health` URL（将 `6cc09528.ngrok.io`
    替换为你的 HTTP 隧道的主机名）。如果你使用 Google Chrome 并点击证书图标（URL前的锁），你应该会看到如下输出：
- en: '![](img/152c06f8-df1e-4c52-b633-84ac22f7717e.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/152c06f8-df1e-4c52-b633-84ac22f7717e.png)'
- en: 'As seen in the preceding screenshot Chrome reports: This certificate is valid!'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Chrome 报告：此证书有效！
- en: 'Wrap up by verifying that the `test-em-all.bash` test script also works with
    this certificate as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式验证 `test-em-all.bash` 测试脚本是否也与此证书一起工作：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Expect the usual output from the test script; check that it concludes with
    the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 期望测试脚本输出通常的结果；检查它是否以以下输出结束：
- en: '![](img/6d63d35e-1728-4d39-a779-d1f4424d0918.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d63d35e-1728-4d39-a779-d1f4424d0918.png)'
- en: You can switch back to the staging issuer by following the same procedure but
    also change back to the staging issuer in the ingress definition.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照相同的过程返回 staging 发行者，同时在ingress定义中也将回到staging发行者。
- en: Cleaning up
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'When you are done, clean up the resources created in Kubernetes (and optionally
    in Docker) using Docker Compose by running the following commands:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成后，使用 Docker Compose 运行以下命令清理在 Kubernetes 中（可选在 Docker 中）创建的资源：
- en: Stop the `kubectl get cert --watch` command with *Ctrl + C.*
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl + C* 停止 `kubectl get cert --watch` 命令。
- en: Stop the HTTP tunnel with *Ctrl* *+* *C.*
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* *+* *C.* 停止 HTTP 隧道。
- en: 'Delete the namespace in Kubernetes with the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在 Kubernetes 中删除命名空间：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you tried out the production environment deployment using the `./kubernetes/scripts/deploy-prod-env.bash`
    script, you also need to stop the resource managers that were launched as Docker
    containers using Docker Compose. Run the following command to stop them:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `./kubernetes/scripts/deploy-prod-env.bash` 脚本部署生产环境，你还需要停止使用 Docker
    Compose 启动的资源管理器。运行以下命令停止它们：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we are done automating the certificates to provision them, let's see
    how to verify that microservices work without Kubernetes. Let's see how this is
    done.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经自动化了证书的发放，让我们看看如何在没有 Kubernetes 的情况下验证微服务是否工作。让我们看看这是如何完成的。
- en: Verifying that microservices work without Kubernetes
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证在没有 Kubernetes 的情况下微服务是否工作
- en: In this chapter and the previous one, we have seen how features in the Kubernetes
    platform, such as config maps, secrets, services, and ingress resources, can simplify
    the effort of developing a landscape of cooperating microservices. But it is important
    to ensure that the source code of the microservices doesn't get dependent on the
    platform from a functional perspective. Avoiding such a lock-in makes it possible
    to change to another platform in the future, if required, with minimal effort.
    Changing the platform should not require changes in the source code but only in
    the configuration of the microservices.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一章中，我们看到了 Kubernetes 平台上的特性，如 config maps、secrets、服务以及ingress资源，如何简化开发合作微服务的景观的努力。但重要的是确保微服务的源代码在功能上不依赖于平台。避免此类锁定使得未来如果需要，可以以最小的努力切换到另一个平台。切换平台不应该需要更改源代码，而只需要更改微服务的配置。
- en: Testing the microservices using Docker Compose and the `test-em-all.bash` test
    script will ensure that they work from a functional perspective, meaning that
    they will verify that the functionality in the microservice source code still
    works without Kubernetes. When running microservices without Kubernetes, we will
    lack the non-functional features that Kubernetes provides us with, for example,
    monitoring, scaling, and restarting containers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 和 `test-em-all.bash` 测试脚本测试微服务，可以确保从功能角度来说它们是工作的，这意味着它们将验证微服务源代码中的功能在没有
    Kubernetes 的情况下仍然有效。在没有 Kubernetes 的情况下运行微服务时，我们将失去 Kubernetes 为我们提供的非功能性特性，例如监控、扩展和重启容器。
- en: 'When using Docker Compose, we will map the following Kubernetes features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Docker Compose时，我们将映射以下Kubernetes特性：
- en: Instead of config maps, we use volumes that map the configuration files directly
    from the host filesystem.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用配置图，我们使用卷，直接从宿主文件系统映射配置文件。
- en: Instead of using secrets, we keep sensitive information such as credentials
    in the `.env` file.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用密钥，我们将敏感信息（如凭据）保存在`.env`文件中。
- en: Instead of an ingress, we will use the Spring Cloud Gateway.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是入口，我们将使用Spring Cloud Gateway。
- en: Instead of services, we will map hostnames used by the clients directly to the
    hostnames of the containers, meaning that we will not have any service discovery
    in place and will not be able to scale containers.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代替服务，我们将将客户端使用的主机名直接映射到容器的主机名，这意味着我们将不实施任何服务发现，并且无法扩展容器。
- en: Using Docker Compose this way will result in significant disadvantages from
    a non-functional perspective compared to using Kubernetes. But it is acceptable,
    given that Docker Compose will only be used to run functional tests.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式的Docker Compose将在非功能性方面与使用Kubernetes相比具有显著劣势。但是，鉴于Docker Compose只用于运行功能测试，这是可以接受的。
- en: Let's go through the code changes in the `docker-compose*.yml` files before
    we run the tests using Docker Compose.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Docker Compose运行测试之前，让我们查看一下`docker-compose*.yml`文件中的代码更改。
- en: Changes in the source code for Docker Compose
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose源代码的变化
- en: 'To run microservices outside Kubernetes, using Docker Compose, the following
    changes have been applied to the `docker-compose*.yml` files:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kubernetes之外使用Docker Compose运行微服务，对`docker-compose*.yml`文件应用了以下更改：
- en: Removed the configuration server definition
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了配置服务器定义
- en: Removed the use of the following configuration server environment variables: `CONFIG_SERVER_USR` and `CONFIG_SERVER_PWD`
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了以下配置服务器环境变量的使用：`CONFIG_SERVER_USR`和`CONFIG_SERVER_PWD`
- en: Mapped the `config-repo` folder as a volume in each container that needs to
    read configuration files from the configuration repository
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要从配置仓库读取配置文件的每个容器中，将`config-repo`文件夹作为卷映射。
- en: Defined the `SPRING_CONFIG_LOCATION` environment variable to point to the configuration
    files in the configuration repository
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了`SPRING_CONFIG_LOCATION`环境变量，以指向配置仓库中的配置文件。
- en: Stored sensitive information such as credentials and passwords in TLS certificates
    in the Docker Compose `.env` file
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将敏感信息如凭据和密码存储在Docker Compose的`.env`文件中的TLS证书中
- en: Defined environment variables with credentials for access to resource managers
    using the variables defined in the `.env` file
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在`.env`文件中定义的变量，为访问资源管理器的凭据定义环境变量。
- en: 'For example, the configuration of the `product` microservice looks like the
    following in `docker-compose.yml`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`docker-compose.yml`中，`product`微服务的配置如下所示：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is an explanation for the preceding source code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: The `config-repo` folder is mapped as a volume into the container at `/config-repo`.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo`文件夹作为卷映射到容器的`/config-repo`。'
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml` files.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_CONFIG_LOCATION`环境变量告诉Spring在哪里找到属性文件，在本例中，是`/config-repo/application.yml`和`/config-repo/product.yml`文件。'
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `.env` file.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`.env`文件的内容，设置访问RabbitMQ和MongoDB的凭据作为环境变量。
- en: 'The credentials referred to in the preceding source code are defined in the `.env` file
    as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前述源代码中提到的凭据在`.env`文件中定义为：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Testing with Docker Compose
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行测试
- en: 'To test with Docker Compose, we will use Docker Desktop (earlier named Docker
    for macOS) instead of Minikube. Perform the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要用Docker Compose进行测试，我们将使用Docker Desktop（以前称为Docker for macOS）而不是Minikube。执行以下步骤：
- en: 'To direct the Docker client to use Docker Desktop instead of Minikube run the
    following command:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以Docker Desktop而不是Minikube运行Docker客户端，请运行以下命令：
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To save memory, you might want to stop the Minikube instance:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省内存，您可能想要停止Minikube实例：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Start Docker Desktop (if not already running).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Docker Desktop（如果尚未运行）。
- en: 'Build the Docker images in Docker Desktop with the following command:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在Docker Desktop中构建Docker镜像：
- en: '[PRE40]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the tests using RabbitMQ (with one partition per topic):'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RabbitMQ（每个主题一个分区）运行测试：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The tests should begin by starting all the containers, run the tests, and finally
    stop all the containers. Expect output like the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该从启动所有容器开始，运行测试，最后停止所有容器。预期输出如下：
- en: '![](img/949cd3b9-d551-4336-a25d-a256cae5ad6e.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/949cd3b9-d551-4336-a25d-a256cae5ad6e.png)'
- en: 'Optionally, run the tests using RabbitMQ with multiple partitions per topic:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用具有多个分区的RabbitMQ运行测试：
- en: '[PRE42]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Expect output that's similar to the preceding test.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出应该与前面的测试类似。
- en: 'Alternatively, run the test using Kafka with multiple partitions per topic:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，使用具有多个分区的Kafka运行测试：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Expect output that's similar to the preceding test.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出应该与前面的测试类似。
- en: Stop Docker Desktop to save memory.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止Docker Desktop以节省内存。
- en: 'Start the Minikube instance, if it was stopped previously, and set the default
    namespace to `hands-on`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前停止了Minikube实例，请启动它，并将默认命名空间设置为`hands-on`：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Point the Docker client back to the Kubernetes cluster in the Minikube instance:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker客户端指向Minikube实例中的Kubernetes集群：
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the successful execution of these tests, we have verified that the microservices
    work without Kubernetes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试的成功执行，我们验证了在没有Kubernetes的情况下微服务也能正常工作。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how capabilities in Kubernetes can be used to
    simplify a microservice landscape, meaning that we reduce the number of support
    services to be developed and deployed together with the microservices. We have
    seen how Kubernetes config maps and secrets can be used to replace the Spring
    Cloud Config Server and how a Kubernetes ingress can replace an edge service based
    on Spring Cloud Gateway.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Kubernetes的功能如何简化微服务架构，这意味着我们需要开发的支撑服务数量减少了，这些服务原本需要和微服务一起部署。我们看到了如何使用Kubernetes的配置映射（config
    maps）和机密（secrets）来替代Spring Cloud Config Server，以及如何使用Kubernetes入口（ingress）来替代基于Spring
    Cloud Gateway的边缘服务。
- en: Using the Cert Manager together with Let's Encrypt allowed us to automatically
    provision certificates for HTTPS endpoints exposed by the ingress, eliminating
    the need for manual and cumbersome work. Since our Kubernetes cluster running
    in a local Minikube instance isn't available from the internet, we used `ngrok`
    to establish an HTTP tunnel from the internet to the Minikube instance. The HTTP
    tunnel was used by Let's Encrypt to verify that we are the owner of the DNS name
    we requested a certificate for.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cert Manager和Let's Encrypt允许我们自动为ingress暴露的HTTPS端点提供证书，从而消除了手动且繁琐的工作。由于我们运行在本地Minikube实例中的Kubernetes集群无法从互联网访问，我们使用了`ngrok`来建立从互联网到Minikube实例的HTTP隧道。HTTP隧道被Let's
    Encrypt用来验证我们是否是请求证书的DNS名的所有者。
- en: To verify that the source code of the microservices can run on other platforms,
    that is, isn't locked into Kubernetes, we deployed the microservices using Docker
    Compose and ran the `test-em-all.bash` test script.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证微服务的源代码可以在其他平台上运行，也就是说不是锁定在Kubernetes上，我们使用Docker Compose部署了微服务并运行了`test-em-all.bash`测试脚本。
- en: In the next chapter, we will be introduced to the concept of a service mesh
    and learn how a service mesh product, **Istio**, can be used to improve observability,
    security, resilience, and routing in a landscape of cooperating microservices
    that are deployed on Kubernetes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍服务网格（service mesh）的概念，并学习如何使用服务网格产品**Istio**来改善部署在Kubernetes上的合作微服务景观的可观测性、安全性、弹性和路由。
- en: Head over to the next chapter!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前往下一章！
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How was the Spring Cloud Config Server replaced by Kubernetes resources?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server是如何被Kubernetes资源替代的？
- en: How was the Spring Cloud Gateway replaced by Kubernetes resources?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway是如何被Kubernetes资源替代的？
- en: What does ACME stand for and what is it used for?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ACME代表什么，它有什么用途？
- en: What role does the Cert Manager and Let's Encrypt play in automating the provision
    of certificates?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cert Manager和Let's Encrypt在自动化提供证书中扮演什么角色？
- en: What Kubernetes resources are involved in automating the provision of certificates?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自动化证书提供过程中涉及哪些Kubernetes资源？
- en: Why did we use `ngrok` and what is required to be added to remove the use of
    ngrok?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用`ngrok`，以及如何修改以去除对`ngrok`的使用？
- en: Why did we run the tests using Docker Compose?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用Docker Compose运行测试？
