- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Sealed and Hidden Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封和隐藏类
- en: This chapter includes 13 problems covering sealed and hidden classes. The first
    11 recipes will cover sealed classes, a very cool feature introduced in JDK 17
    (JEP 409) to sustain *closed hierarchies*. The last two problems cover hidden
    classes, a JDK 15 (JEP 371) feature that allows frameworks to create and use runtime
    (dynamic) classes hidden in the JVM’s internal linkages of bytecode, and to the
    explicit usage of class loaders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括13个问题，涵盖了密封和隐藏类。前11个食谱将涵盖密封类，这是JDK 17（JEP 409）引入的一个非常酷的特性，用于维持*封闭层次结构*。最后两个问题涵盖了隐藏类，这是JDK
    15（JEP 371）的一个特性，允许框架在JVM的字节码内部链接中创建和使用运行时（动态）类，以及显式使用类加载器。
- en: You’ll be skilled in both topics by the end of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章结束时掌握这两个主题。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess in manipulating
    sealed classes and hidden classes in Java. I strongly encourage you to give each
    problem a try before you turn to the solutions and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java中操作密封类和隐藏类的编程能力。我强烈建议你在查看解决方案并下载示例程序之前尝试每个问题：
- en: '**Creating an electrical panel (hierarchy of classes)**: Write the stub of
    a Java application that shapes an electrical panel. You can assume that the electrical
    panel is made of several types of electrical components (for instance, resistors,
    transistors, and so on), and electrical circuits (for instance, parallel circuits,
    series circuits, and so on).'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个电气面板（类层次结构）**：编写一个Java应用程序的存根，用于构建电气面板。你可以假设电气面板由多种类型的电气元件（例如，电阻器、晶体管等）和电路（例如，并联电路、串联电路等）组成。'
- en: '**Closing the electrical panel before JDK 17**: Use the Java features (for
    instance, the `final` keyword and *package-private* hacks) to close this hierarchy
    (close to extension).'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在JDK 17之前关闭电气面板**：使用Java特性（例如，`final`关键字和*包私有*技巧）来关闭这个层次结构（接近扩展）。'
- en: '**Introducing JDK 17 sealed classes**: Provide a brief introduction to JDK
    17 sealed classes. Exemplify how to write closed hierarchies in a single source
    file via sealed classes.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍JDK 17密封类**：简要介绍JDK 17密封类。举例说明如何通过密封类在单个源文件中编写封闭层次结构。'
- en: '**Introducing the permits clause**: Explain and exemplify the role of the `permits`
    clause in sealed classes. Exemplify sealed classes in different source files (same
    package) and in different packages.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍许可条款**：解释并举例说明`permits`子句在密封类中的作用。举例说明在不同源文件（同一包）和不同包中密封类的使用。'
- en: '**Closing the electrical panel after JDK 17**: Use sealed classes to completely
    close the electrical panel hierarchy developed in problems 172 and 173.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在JDK 17之后关闭电气面板**：使用密封类完全关闭在问题172和173中开发的电气面板层次结构。'
- en: '**Combining sealed classes and records**: Exemplify the usage of Java records
    in combination with sealed classes.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合密封类和记录**：展示如何将Java记录与密封类结合使用。'
- en: '**Hooking sealed classes and instanceof**: Write an application that highlights
    how sealed classes help the compiler to better handle the `instanceof` operator.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在switch中使用密封类和instanceof**：编写一个应用程序，突出密封类如何帮助编译器更好地处理`instanceof`运算符。'
- en: '**Hooking sealed classes in switch**: Write an application that exemplifies
    how sealed classes help the compiler to sustain exhaustive switch expressions/statements.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在switch中使用密封类**：编写一个应用程序，展示密封类如何帮助编译器维持详尽的switch表达式/语句。'
- en: '**Reinterpreting the Visitor pattern via sealed classes and type pattern matching
    for switch**: Provide a quick sample of the traditional Visitor pattern implementation
    and transform it via sealed classes into simpler and more accessible code.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过密封类和类型模式匹配重解访客模式**：提供一个传统访客模式实现的快速示例，并通过密封类将其转换为更简单、更易访问的代码。'
- en: '**Getting info about sealed classes (using reflection)**: Explain and exemplify
    how we can access sealed classes via Java Reflection.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取密封类信息（使用反射）**：解释并举例说明我们如何通过Java反射访问密封类。'
- en: '**Listing the top three benefits of sealed classes**: Provide what you think
    are the top three benefits of sealed classes with a few explanations and arguments.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列出密封类的三大好处**：提供你认为密封类的三大好处，并附上一些解释和论据。'
- en: '**Briefly introducing hidden classes**: Provide a brief, crystal-clear, and
    meaningful explanation of hidden classes. List their main characteristics.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简要介绍隐藏类**：提供一个简明、清晰且富有意义的隐藏类解释。列出它们的主要特征。'
- en: '**Creating a hidden class**: Provide a regular example of creating and using
    a hidden class.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建隐藏类**：提供一个创建和使用隐藏类的常规示例。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并实验[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08)中的程序。
- en: 172\. Creating an electrical panel (hierarchy of classes)
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 172. 创建电气面板（类层次结构）
- en: Let’s assume that we want to model in code lines an electrical panel. Of course,
    we are not electricians, so for our purposes, an electric panel means a box with
    some internal circuits made of electrical components and a breaker that turns
    on/off the electrical panel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要用代码行来模拟一个电气面板。当然，我们不是电工，所以对我们来说，电气面板意味着一个带有一些内部电路的盒子，这些电路由电气元件组成，并有一个断路器来打开/关闭电气面板。
- en: '![Figure 8.1.png](img/B19665_08_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.1.png](img/B19665_08_01.png)'
- en: 'Figure 8.1: Electrical panel components'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：电气面板组件
- en: 'Everything in an electrical panel can be considered an electrical component,
    so we can start our code by defining an interface that must be implemented by
    everything in this panel:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 电气面板中的所有东西都可以被认为是电气元件，因此我们可以从定义一个接口开始，这个接口必须由面板中的所有东西实现：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before continuing, let’s look at a diagram of the electric panel interfaces
    and classes that will help you to follow what comes after more easily:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看电气面板接口和类的图，这将帮助你更容易地理解接下来的内容：
- en: '![Figure 8.2.png](img/B19665_08_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.2.png](img/B19665_08_02.png)'
- en: 'Figure 8.2: A model of the electrical panel'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：电气面板模型
- en: 'An electrical panel consists of more electrical circuits that interact (or
    do not interact) with each other. We can represent such a circuit via an `abstract`
    class as follows (this acts as a base class for its subclasses):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 电气面板由更多相互交互（或不交互）的电气电路组成。我们可以通过以下`abstract`类来表示这样的电路（这充当其子类的基础类）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s assume that our electrical panel is made of three types of circuits.
    We have short circuits, series circuits, and parallel circuits. So, we can define
    the proper class for each type of circuit by extending the `abstract ElectricCircuit`
    (we’ll show here only the `ShortCircuit`, while the `ParallelCircuit` and `SeriesCircuit`
    are available in the bundled code):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的电气面板由三种类型的电路组成。我们有短路、串联电路和并联电路。因此，我们可以通过扩展`abstract ElectricCircuit`（我们在这里只展示`ShortCircuit`，而`ParallelCircuit`和`SeriesCircuit`在捆绑的代码中可用）为每种类型的电路定义适当的类：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check out the constructor of the `ShortCircuit` class. It gets a `varargs`
    argument of the type `ElectricComponent`. This means that we can build a bigger
    circuit from smaller circuits and other components such as capacitors, transistors,
    resistors, and so on. Each such electrical component can be shaped via an `abstract`
    class. For instance, a capacitor is a base class that can be expressed as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`ShortCircuit`类的构造函数。它接收一个类型为`ElectricComponent`的`varargs`参数。这意味着我们可以从较小的电路和其他组件（如电容器、晶体管、电阻等）构建更大的电路。每个这样的电气元件都可以通过一个`abstract`类来表示。例如，电容器是一个基类，可以表示如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need two types of capacitors (ceramic capacitors and electrolytic capacitors).
    A ceramic capacitor can be shaped as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两种类型的电容器（陶瓷电容器和电解电容器）。一个陶瓷电容器的形状可以是以下这样：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Following the same logic, we can express other electrical components such as
    transistors (`Transistor` (`abstract`), `BipolarTransistor`, and `FieldEffectTransistor`)
    and resistors (`Resistor` (`abstract`), `CarbonResistor`, and `MetalResistor`,
    and its two subtypes, `MetalFilmResistor` and `MetalOxideResistor`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑，我们可以表达其他电气元件，如晶体管（`Transistor`（`abstract`），`BipolarTransistor`和`FieldEffectTransistor`）和电阻（`Resistor`（`abstract`），`CarbonResistor`和`MetalResistor`，以及其两个子类型`MetalFilmResistor`和`MetalOxideResistor`）。
- en: 'We almost have all the electrical components required for building our panel.
    We just need the breaker, which is just another electrical component with the
    particularity that it exposes two methods for turning on/off the electrical panel:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎拥有了构建面板所需的所有电气组件。我们只需要断路器，它只是另一个具有特定性的电气组件，它公开了两个用于开启/关闭电气面板的方法：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And, finally, we can materialize the electrical panel as follows (we assume
    that we have three circuits, a central circuit, a peripheral circuit, and an auxiliary
    circuit):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将电气面板具体化为以下形式（我们假设有三个电路，一个中心电路，一个外围电路和一个辅助电路）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Done! Now, a client of our panel can operate it via the `switchOn()`/`switchOff()`
    methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们的面板客户端可以通过`switchOn()`/`switchOff()`方法来操作它：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next problem, we will see how we can close this hierarchy of classes
    in order to increase encapsulation and avoid accidental/non-accidental extensions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将看到如何关闭这个类的层次结构，以增加封装并避免意外的/非意外的扩展。
- en: 173\. Closing the electrical panel before JDK 17
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 173. 在 JDK 17 之前关闭电气面板
- en: By its nature, an electrical panel is a closed unit of work. But our code from
    the previous problem is far from being a closed hierarchy. We can extend and implement
    almost any class/interface from inside or outside the hierarchy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，电气面板是一个封闭的工作单元。但我们的前一个问题中的代码远远不是一个封闭的层次结构。我们可以在层次结构的内部或外部扩展和实现几乎任何类/接口。
- en: Using anything before JDK 17, closing a hierarchy of classes and interfaces
    can be done using several tools.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 17 之前使用任何东西，关闭类和接口的层次结构可以使用几种工具。
- en: Applying the final modifier
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用`final`修饰符
- en: For instance, we have the powerful `final` modifier. Once we declare a class
    as `final`, it cannot be extended, so it is completely closed to extension. Obviously,
    we cannot apply this technique consistently across a hierarchical model because
    it will lead to a non-hierarchical model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有强大的`final`修饰符。一旦我们将一个类声明为`final`，它就不能被扩展，因此它完全封闭了对扩展。显然，我们不能在层次模型中一致地应用这种技术，因为这会导致非层次模型。
- en: 'If we scan our electrical panel model, then we can use the `final` modifier
    in several places. First, we eliminate interfaces (`ElectricComponent` and `ElectricBreaker`)
    since interfaces cannot be declared as `final`. Next, we can look at the `ElectricCircuit`
    class and its subclasses (`ParallelCircuit`, `SeriesCircuit`, and `ShortCircuit`).
    Obviously, since `ElectricCircuit` has subclasses, it cannot be `final`. However,
    its subclasses are modeling notions that shouldn’t be extended, so they can be
    `final`. This is our first step in obtaining a closed hierarchical model:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扫描我们的电气面板模型，那么我们可以在几个地方使用`final`修饰符。首先，我们消除了接口（`ElectricComponent`和`ElectricBreaker`），因为接口不能声明为`final`。接下来，我们可以查看`ElectricCircuit`类及其子类（`ParallelCircuit`、`SeriesCircuit`和`ShortCircuit`）。显然，由于`ElectricCircuit`有子类，它不能是`final`。然而，它的子类正在建模不应该扩展的概念，因此它们可以是`final`。这是我们获得封闭层次模型的第一步：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other classes that model well-defined notions that shouldn’t be extended are
    the classes that model capacitors, transistors, and resistors. So, the following
    classes can be `final` as well:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其他建模了明确概念且不应该扩展的类是建模电容器、晶体管和电阻的类。因此，以下类也可以是`final`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we have the `ElectricPanel` class. It doesn’t make sense to derive
    something from an electrical panel, so this class can be `final` as well:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ElectricPanel`类。从电气面板派生东西是没有意义的，所以这个类也可以是`final`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So far, we managed to close some parts of the hierarchy. There are no other
    places where the `final` modifier can help us, so we can go further and try another
    technique.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功关闭了层次结构的一些部分。没有其他地方可以使用`final`修饰符帮助我们，因此我们可以更进一步，尝试另一种技术。
- en: Defining package-private constructors
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义包私有构造函数
- en: Next, we can use the hack of defining *package-private* constructors (a constructor
    with no visible modifier). The classes having *package-private* constructors can
    be instantiated and extended only inside that package – from a readability point
    of view, this technique is far away from expressing its intentions. However, in
    complex designs, we can apply this technique sporadically since we cannot simply
    put everything in a single package. Nevertheless, it can be considered as a solution
    for increasing the hierarchical model closing level.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用定义`包私有`构造函数的技巧（一个没有可见修饰符的构造函数）。具有`包私有`构造函数的类只能在包内部实例化和扩展——从可读性的角度来看，这种技术远远没有表达其意图。然而，在复杂的设计中，我们可以偶尔应用这种技术，因为我们不能简单地将所有内容放入一个单独的包中。尽管如此，它可以被认为是一种提高层次模型封闭级别的解决方案。
- en: 'For instance, we can focus on our `abstract` classes. They cannot be instantiated
    (being `abstract`) but they can be extended from anywhere. However, some of them
    should be extended only in the package where they are defined. The `ElectricCircuit`
    class is `abstract` and it should be extended only by `ParallelCircuit`, `SeriesCircuit`,
    and `ShortCircuit`. These subclasses live in the same package as `ElectricCircuit`,
    so it makes sense to use this hack of declaring a *package-private* constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以关注我们的`抽象`类。它们不能被实例化（因为它们是`抽象`的），但可以从任何地方扩展。然而，其中一些类只应该在它们定义的包中扩展。`ElectricCircuit`类是`抽象`的，它只能由`ParallelCircuit`、`SeriesCircuit`和`ShortCircuit`扩展。这些子类与`ElectricCircuit`类位于同一个包中，因此使用这种声明为`包私有`的构造函数的做法是有意义的：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the `ElectricCircuit` class is closed to any extension attempt coming from
    outside of its package. Of course, it is still open to extension attempts from
    inside of its package.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ElectricCircuit`类对外部包的任何扩展尝试都是封闭的。当然，它仍然对其包内部的扩展尝试是开放的。
- en: Declaring classes/interfaces as non-public
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类/接口声明为非公开
- en: 'Going further, we can declare interfaces/classes as non-public (by skipping
    the `public` keyword from the class/interface definition, it becomes non-public
    and is set by default in the so-called *package-private* access mode). This way,
    those classes and interfaces are visible (can be used/extended) only inside their
    packages. We cannot apply this technique to the `ElectricComponent` interface.
    This interface has to be `public` because it is implemented by most of our classes.
    However, we can apply this technique to the `ElectricBreaker` interface, since
    this interface should be implemented only by the `ElectricPanel` class, which
    is in the same package as it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们可以将接口/类声明为非公开（通过从类/接口定义中省略`public`关键字，它变为非公开，并默认设置为所谓的`包私有`访问模式）。这样，这些类和接口只能在它们的包内部可见（可以使用/扩展）。我们不能将这种技术应用于`ElectricComponent`接口。这个接口必须被声明为`public`，因为它被我们的大多数类实现。然而，我们可以将这种技术应用于`ElectricBreaker`接口，因为这个接口应该只由位于同一包中的`ElectricPanel`类实现：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, `ElectricBreaker` cannot be extended/implemented outside its package.
    Moreover, we can apply this technique to the `abstract` classes `Transistor`,
    `Resistor`, and `Capacitor`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ElectricBreaker`不能在其包外部被扩展/实现。此外，我们可以将这种技术应用于`抽象`类`Transistor`、`Resistor`和`Capacitor`：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we cannot apply this technique to the `ElectricCircuit` class. This
    class is `abstract` but it is used in the `ElectricPanel` class, so it cannot
    be non-public. However, it cannot be extended thanks to the *package-private*
    constructor added previously.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能将这种技术应用于`ElectricCircuit`类。这个类是`抽象`的，但它被`ElectricPanel`类使用，因此它不能是非公开的。然而，由于之前添加了`包私有`的构造函数，它不能被扩展。
- en: Throwing everything in a module
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容放入模块中
- en: In addition, we can place the whole hierarchy inside a Java module and export/expose
    to our client only a small part of it. However, this practice will not affect
    the closing level from inside the module, so we will skip it (that is, we will
    not exemplify it).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将整个层次结构放置在一个Java模块中，并将其中的一小部分导出/暴露给我们的客户端。然而，这种做法不会影响模块内部的封闭级别，所以我们将其跳过（也就是说，我们不会举例说明它）。
- en: At this moment almost the entire hierarchy is closed to extension/implementation.
    The exceptions are the `MetalResistor` class and the `ElectricComponent` interface,
    which can be extended/implemented from anywhere inside/outside the model, and
    the `ElectricCircuit`, `Capacitor`, `Transistor`, and `Resistor` classes, which
    can be extended from inside of their packages. By placing the model in a Java
    module, we can block these actions from outside the module, but they are still
    possible from inside the module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，几乎整个层次结构都对扩展/实现关闭。例外的是`MetalResistor`类和`ElectricComponent`接口，它们可以从模型内部/外部任何地方进行扩展/实现，以及`ElectricCircuit`、`Capacitor`、`Transistor`和`Resistor`类，它们可以从它们的包内部进行扩展。通过将模型放置在Java模块中，我们可以阻止模块外部的这些操作，但它们仍然可以从模块内部进行。
- en: Conclusion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: From this point forward (prior to JDK 17), there are no more techniques, tricks,
    or hacks that we can apply. We can reconsider the model design, but this will
    be too costly and will basically mean redesigning the model entirely, which may
    affect the model structure and logic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始（在 JDK 17 之前），我们不能再应用任何技术、技巧或黑客手段。我们可以重新考虑模型设计，但这将过于昂贵，基本上意味着完全重新设计模型，这可能会影响模型结构和逻辑。
- en: For the sake of discussion and in the context of redesigning, we may consider
    Java enums. Java enums give us a nice closed hierarchy and are transformed internally
    in regular Java classes. Nevertheless, using enums to design a closed model and
    shape arbitrary classes can be really weird, unwieldy, and inconvenient.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论和重新设计的上下文，我们可能会考虑 Java 枚举。Java 枚举为我们提供了一个很好的封闭层次结构，并且在内部被转换为常规 Java 类。尽管如此，使用枚举来设计封闭模型和塑造任意类可能会非常奇怪、难以驾驭且不方便。
- en: In conclusion, before JDK 17, we had the radical `final` modifier and some control
    at the package level via *package-private* access.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在 JDK 17 之前，我们有激进的全局`final`修饰符和一些通过*包私有*访问在包级别上的控制。
- en: It is obvious that what’s missing here is something in between, something to
    give us more granularity and control. Fortunately, JDK 17 can help us to achieve
    a 100% closed hierarchy via sealed classes. This is the topic of some of the next
    problems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里缺失的是介于两者之间的一些东西，一些可以给我们更多粒度和控制的东西。幸运的是，JDK 17 可以通过密封类帮助我们实现 100% 封闭的层次结构。这是一些后续问题的主题。
- en: 174\. Introducing JDK 17 sealed classes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 174. 引入 JDK 17 密封类
- en: Among the cool features of JDK 17, we have JEP 409 (sealed classes). This JEP
    provides an explicit, intuitive, crystal-clear solution for nominating who will
    extend a class/interface or will implement an interface. In other words, sealed
    classes can control inheritance at a finer level. Sealed classes can affect classes,
    `abstract` classes, and interfaces and sustain the readability of the code – you
    have an easy and expressive solution to tell your colleagues who can extend/implement
    your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 17 的酷炫特性中，我们有 JEP 409（密封类）。这个 JEP 提供了一个明确、直观、清晰易懂的解决方案，用于指定谁将扩展一个类/接口或实现一个接口。换句话说，密封类可以在更细的级别上控制继承。密封类可以影响类、`abstract`类和接口，并保持代码的可读性——你有一个简单且易于表达的方法来告诉你的同事谁可以扩展/实现你的代码。
- en: '![Figure 8.3.png](img/B19665_08_03.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.3.png](img/B19665_08_03.png)'
- en: 'Figure 8.3: JDK 17, JEP 409'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：JDK 17，JEP 409
- en: Via sealed classes, we have finer control over a hierarchy of classes. As you
    can see from the previous figure, sealed classes are the missing piece of the
    puzzle sitting between `final` and *package-private*. In other words, sealed classes
    provide a granularity that we cannot obtain via the `final` modifier and *package-private*
    access.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过密封类，我们对类层次结构有了更精细的控制。如图 8.3 所示，密封类是介于`final`和*包私有*之间的缺失拼图。换句话说，密封类提供了我们通过`final`修饰符和*包私有*访问无法获得的粒度。
- en: '**Important note**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Sealed classes don’t affect the semantics of the `final` and `abstract` keywords.
    They still act exactly as they have for years. A sealed class cannot be `final`
    and vice versa.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类不会影响`final`和`abstract`关键字的语义。它们仍然像过去几年一样精确地起作用。一个密封类不能是`final`，反之亦然。
- en: 'Let’s consider the following class (`Truck.java`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下类（`Truck.java`）：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We know that, in principle, this class can be extended by any other class.
    But we have only three types of trucks: semi-trailer, tautliner, and refrigerated.
    So, only three classes should extend the `Truck` class. Any other extension should
    not be allowed. In order to achieve this goal, we seal the class `Truck` by adding
    in its declaration the `sealed` keyword, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，原则上，这个类可以被任何其他类扩展。但我们只有三种类型的卡车：半挂车、厢式货车和冷藏车。因此，只有三个类应该扩展`Truck`类。任何其他扩展都不应该被允许。为了实现这个目标，我们在`Truck`类的声明中添加了`sealed`关键字，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By adding the `sealed` keyword, the compiler will automatically scan for all
    the extensions of `Truck` predefined in `Truck.java`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`sealed`关键字，编译器将自动扫描在`Truck.java`中预定义的所有`Truck`的扩展。
- en: Next, we have to specify the subclasses of `Truck` (`SemiTrailer`, `Tautliner`,
    and `Refrigerated`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须指定`Truck`的子类（`SemiTrailer`、`Tautliner`和`Refrigerated`）。
- en: '**Important note**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: A `sealed` class (`abstract` or not) must have at least a subclass (otherwise
    there is no point in declaring it `sealed`). A `sealed` interface must have at
    least a subinterface or an implementation (again, otherwise there is no point
    declaring it `sealed`). If we don’t follow these rules, then the code will not
    compile.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`sealed`类（无论是`abstract`还是不是）必须至少有一个子类（否则声明它为`sealed`就没有意义）。一个`sealed`接口必须至少有一个子接口或实现（同样，否则声明它为`sealed`就没有意义）。如果我们不遵循这些规则，那么代码将无法编译。
- en: 'If we declare the subclasses of `Truck` in the same source file (`Truck.java`),
    then we can do so as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在同一个源文件（`Truck.java`）中声明`Truck`的子类，可以这样做：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After checking this code, we have to push another important note.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完这段代码后，我们必须再提出另一个重要提示。
- en: '**Important note**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: A subclass of a `sealed` class must be declared `final`, `sealed`, or `non-sealed`.
    A subinterface of a `sealed` interface must be declared `sealed` or `non-sealed`.
    If the subclass (subinterface) of a `sealed` class (interface) is declared as
    `sealed`, then it must have its own subclasses (subinterfaces). The `non-sealed`
    keyword indicates that the subclass (subinterface) can be freely extended further
    with no restrictions (the hierarchy containing a `non-sealed` class/interface
    is not closed). And, a `final` subclass cannot be extended.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`sealed`类的子类必须声明为`final`、`sealed`或`non-sealed`。一个`sealed`接口的子接口必须声明为`sealed`或`non-sealed`。如果一个`sealed`类（接口）的子类（子接口）被声明为`sealed`，那么它必须有自己的子类（子接口）。`non-sealed`关键字表示子类（子接口）可以无限制地进一步扩展（包含`non-sealed`类/接口的层次结构不是封闭的）。此外，`final`子类不能被扩展。
- en: Since our subclasses (`SemiTrailer`, `Tautliner`, and `Refrigerated`) are declared
    `final`, they cannot be extended further. So, the `Truck` class can be extended
    only by `SemiTrailer`, `Tautliner`, and `Refrigerated`, and these classes are
    non-extendable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的子类（`SemiTrailer`、`Tautliner`和`Refrigerated`）被声明为`final`，它们不能进一步扩展。因此，`Truck`类只能被`SemiTrailer`、`Tautliner`和`Refrigerated`扩展，而这些类是不可扩展的。
- en: 'In the case of interfaces, we do the same. For instance, a `sealed` interface
    looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口的情况下，我们做同样的事情。例如，一个`sealed`接口看起来像这样：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By adding the `sealed` keyword, the compiler will automatically scan for all
    the implementations/extensions of `Melon` predefined in `Melon.java`. So, in the
    same source file (`Melon.java`), we declare the extensions and implementations
    of this interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`sealed`关键字，编译器将自动扫描在`Melon.java`中预定义的所有`Melon`的实现/扩展。因此，在同一个源文件（`Melon.java`）中，我们声明这个接口的扩展和实现：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Pumpkin` interface can be further freely implemented/extended since it
    is declared as `non-sealed`. The implementations/extensions of `Pumpkin` don’t
    need to be declared `sealed`, `non-sealed`, or `final` (but we can still make
    this declaration).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pumpkin`接口可以进一步自由实现/扩展，因为它被声明为`non-sealed`。`Pumpkin`的实现/扩展不需要声明为`sealed`、`non-sealed`或`final`（但我们仍然可以做出这样的声明）。'
- en: 'Next, let’s look at a more complex example. Let’s name this model the *Fuel*
    model. Here, all classes and interfaces are placed in the same source file, `Fuel.java`
    (the `com.refinery.fuel` package). Take your time and analyze each class/interface
    to understand how `sealed`, `non-sealed`, and `final` work together in this hierarchal
    model:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个更复杂的例子。让我们把这个模型命名为*Fuel*模型。在这里，所有类和接口都放在同一个源文件中，`Fuel.java`（`com.refinery.fuel`包）。花点时间分析每个类/接口，了解`sealed`、`non-sealed`和`final`在这个层次模型中是如何一起工作的：
- en: '![Figure 8.4.png](img/B19665_08_04.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4.png](img/B19665_08_04.png)'
- en: 'Figure 8.4: A hierarchical model using sealed, non-sealed, and final'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：使用`sealed`、`non-sealed`和`final`的层次模型
- en: 'In code lines, this model can be expressed as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，这个模型可以表示如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Placing all the classes/interfaces in the same source file allows us to express
    closed hierarchical models like the previous one. However, placing all classes
    and interfaces in the same file is rarely a useful approach – maybe when the model
    contains a few small classes/interfaces.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类/接口放在同一个源文件中允许我们表达像之前那样的封闭层次模型。然而，将所有类和接口放在同一个文件中通常不是一个有用的方法——也许当模型包含几个小的类/接口时。
- en: In reality, we like to separate classes and interfaces into their own source
    files. It is more natural and intuitive to have each class/interface in its own
    source file. This way, we avoid large sources and it is much easier to follow
    the best practices of OOP. So, the goal of our next problem is to rewrite the
    *Fuel* hierarchical model by using a source file per class/interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，我们喜欢将类和接口分开到它们自己的源文件中。每个类/接口在自己的源文件中更自然、更直观。这样，我们避免了大型源文件，并且更容易遵循面向对象编程的最佳实践。因此，我们下一个问题的目标是使用每个类/接口一个源文件的方式重写`Fuel`层次模型。
- en: 175\. Introducing the permits clause
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 175. 引入`permits`子句
- en: In the previous problem, you saw how to write a closed hierarchical model in
    a single source file. Next, let’s use the `Fuel.java` source file to rewrite this
    model by using separate sources and separate packages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，你看到了如何在单个源文件中编写一个封闭的层次模型。接下来，让我们使用`Fuel.java`源文件，通过使用单独的源文件和单独的包来重写这个模型。
- en: Working with sealed classes in separate sources (same package)
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单独的源文件中（同一包）使用密封类
- en: 'Let’s consider the `sealed Fuel` interface from `Fuel.java` in package `com.refinery.fuel`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`Fuel.java`包中的`sealed Fuel`接口：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We know that this interface is extended by three other interfaces: `SolidFuel`,
    `LiquidFuel`, and `SolidFuel`. Let’s define `SolidFuel` in the `SolidFuel.java`
    source (same package), as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个接口被三个其他接口扩展：`SolidFuel`、`LiquidFuel`和`SolidFuel`。让我们在`SolidFuel.java`源文件（同一包）中定义`SolidFuel`，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you’ll see, this code will not compile (it is like the compiler is asking:
    *hey, what’s the point of a sealed interface without any implementation/extension?*).
    This time, we have to explicitly nominate the interfaces that can extend/implement
    the `Fuel` interface. For this, we use the `permits` keyword. Since `Fuel` is
    implemented by three interfaces, we just list their names via `permits` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你将看到的，这段代码将无法编译（这就像编译器在问：嘿，没有实现/扩展的密封接口有什么意义呢？）。这次，我们必须明确指定可以扩展/实现`Fuel`接口的接口。为此，我们使用`permits`关键字。由于`Fuel`由三个接口实现，我们只需通过`permits`列出它们的名称，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The list provided via `permits` is exhaustive. The `SolidFuel` is also a `sealed`
    interface, so it has to define its `permits` as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`permits`提供的列表是详尽的。`SolidFuel`也是一个`sealed`接口，因此它必须定义自己的`permits`：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`LiquidFuel` and `GaseousFuel` work the same way as `SolidFuel`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiquidFuel`和`GaseousFuel`与`SolidFuel`的工作方式相同：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Coke` (`Coke.java`) and `Charcoal` (`Charcoal.java`) are `final` implementations
    of `SolidFuel`, so they don’t use the `permits` keyword:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Coke`（`Coke.java`）和`Charcoal`（`Charcoal.java`）是`final`的`SolidFuel`实现，因此它们不使用`permits`关键字：'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Petroleum` class (`Petroleum.java`) is `sealed` and allows three extensions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Petroleum` 类（`Petroleum.java`）是`密封`的，并允许三种扩展：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Diesel` (`Diesel.java`), `Gasoline` (`Gasoline.java`), and `Ethanol` (`Ethanol.java`)
    classes are `final`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Diesel`（`Diesel.java`）、`Gasoline`（`Gasoline.java`）和`Ethanol`（`Ethanol.java`）类是`final`的：'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `NaturalGas` interface (`NaturalGas.java`) is a `sealed` extension of `GaseousFuel`,
    while `Propane` (`Propane.java`) is a `final` implementation of `GaseousFuel`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaturalGas`接口（`NaturalGas.java`）是`GaseousFuel`的`sealed`扩展，而`Propane`（`Propane.java`）是`GaseousFuel`的`final`实现：'
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, the `NaturalGas` interface permits two extensions. The `Hydrogen`
    class is a `final` extension, while `Methane` is a `sealed` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个接口允许两个扩展。`Hydrogen`类是一个`final`扩展，而`Methane`是一个`sealed`类：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Chloromethane` class is `final`, and `Dichloromethane` is `sealed`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chloromethane`类是`final`的，而`Dichloromethane`是`sealed`的：'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we have the `Trichloromethane` class. This is a `final` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`Trichloromethane`类。这是一个`final`类：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Done! The hierarchical model is closed and complete. Any attempt to extend/implement
    any member of this hierarchy will lead to an exception. If we want to add a new
    extension/implementation to a `sealed` class/interface, then we have to add it
    to the `permits` list as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！层次模型已关闭并完整。尝试扩展/实现这个层次结构中的任何成员都将导致异常。如果我们想向`密封`类/接口添加新的扩展/实现，那么我们还需要将其添加到`permits`列表中。
- en: Working with sealed classes in separate packages
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同的包中处理密封类
- en: 'In the previous example, we expressed the classes/interfaces in separate sources
    but in the same package, `com.refinery.fuel`. Next, let’s consider that we spread
    these classes and interfaces across different packages as in the following figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在同一个包`com.refinery.fuel`中分别表达了类/接口，但它们位于同一个包中。接下来，让我们考虑将这些类和接口分散到不同的包中，如下面的图所示：
- en: '![Figure 8.4.png](img/B19665_08_05.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4.png](img/B19665_08_05.png)'
- en: 'Figure 8.5: Sealed hierarchy in different packages'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：不同包中的密封层次结构
- en: 'As long as the related `sealed` classes/interfaces live in the same package,
    we can use the JDK 9 *unnamed* special module (no explicit module). Otherwise,
    we have to use a *named* module. For instance, if we express our model as in *Figure
    8.5*, then we have to add everything in a module via `module-info.java`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只要相关的`密封`类/接口位于同一个包中，我们就可以使用 JDK 9 的 *unnamed* 特殊模块（没有显式模块）。否则，我们必须使用 *named*
    模块。例如，如果我们像 *图8.5* 中那样表达我们的模型，那么我们必须通过`module-info.java`将模块中的所有内容添加到模块中：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Without a *named* module, the code will not compile. In the bundled code, you
    can find both examples from this problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没有命名模块，代码将无法编译。在捆绑的代码中，你可以找到这个问题的两个示例。
- en: 176\. Closing the electrical panel after JDK 17
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 176. 在 JDK 17 之后关闭电气面板
- en: Do you remember our electrical panel model introduced earlier in *Problems 172*
    and *173*? In *Problem 173*, we closed this model as much as possible by using
    the Java capabilities available before JDK 17\. Now, we can revisit that model
    (*Problem 173*) and close it completely via JDK 17 sealed classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在 *问题172* 和 *173* 中早期引入的电气面板模型吗？在 *问题173* 中，我们尽可能使用 JDK 17 之前可用的 Java
    功能关闭了这个模型。现在，我们可以重新审视这个模型（*问题173*），并通过 JDK 17 密封类完全关闭它。
- en: 'We start with the `ElectricComponent` interface, which is declared as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ElectricComponent`接口开始，该接口声明如下：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this moment, this interface is not closed. It can be extended/implemented
    from any other point of the application. But we can close it by transforming it
    into a `sealed` interface with the proper `permits` clause, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，这个接口还没有关闭。它可以从应用的任何其他点扩展/实现。但我们可以通过将其转换为带有适当`permits`子句的`密封`接口来关闭它，如下所示：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, let’s focus on the semi-closed `ElectricCircuit` class. This is an `abstract`
    class that uses a *package-private* constructor to block any extension from outside
    its package. However, it can still be extended from inside the package. We can
    close it completely by transforming it into a `sealed` class with the proper `permits`
    clause (the *package-private* constructor can be safely removed):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于半封闭的`ElectricCircuit`类。这是一个`抽象`类，它使用`包私有`构造函数来阻止其包外部的任何扩展。然而，它仍然可以从包内部扩展。我们可以通过将其转换为带有适当`permits`子句的`密封`类来完全关闭它（`包私有`构造函数可以安全地移除）：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ParallelCircuit`, `SeriesCircuit`, and `ShortCircuit` were declared as
    `final`, so they remain unchanged. We don’t want to permit any extension of these
    classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelCircuit`、`SeriesCircuit`和`ShortCircuit`被声明为`final`，所以它们保持不变。我们不希望允许这些类的任何扩展。'
- en: 'Next, let’s focus on the `Capacitor`, `Transistor`, and `Resistor` classes.
    These classes are also `abstract` and use *package-private* constructors to avoid
    any extension attempts coming from outside of their packages. So, we can remove
    these constructors and transform them into `sealed` classes exactly as we did
    with `ElectricCircuit`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于`电容器`、`晶体管`和`电阻器`类。这些类也是`抽象`的，并使用`包私有`构造函数来避免任何来自它们包外部的扩展尝试。因此，我们可以移除这些构造函数，并将它们转换为`密封`类，就像我们对`ElectricCircuit`所做的那样：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check out the `Resistor` class. It permits only `MetalResistor` and `CarbonResistor`
    classes. Next, the `MetalResistor` class needs special attention. So far, this
    class is `public` and can be extended from any other point of the application:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`电阻器`类。它只允许`MetalResistor`和`CarbonResistor`类。接下来，`MetalResistor`类需要特别注意。到目前为止，这个类是`public`的，可以从应用的任何其他点扩展：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Closing this class can be done by sealing it as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式密封这个类可以关闭它：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `MetalFilmResistor` and `MetalOxideResistor` classes are `final` and remain
    unchanged:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetalFilmResistor`和`MetalOxideResistor`类是`final`的，保持不变：'
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The same statement applies to the `CeramicCapacitor`, `ElectrolyticCapacitor`,
    `BipolarTransistor`, and `FieldEffectTransistor` classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的声明也适用于`CeramicCapacitor`、`ElectrolyticCapacitor`、`BipolarTransistor`和`FieldEffectTransistor`类。
- en: 'Next, let’s focus on the `ElectricBreaker` interface. This interface lives
    in the `modern.circuit.panel` package and was implemented only by `ElectricPanel`,
    so it was declared *package-private* (it cannot be extended/implemented from outside
    the package):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们关注`ElectricBreaker`接口。这个接口位于`modern.circuit.panel`包中，并且只由`ElectricPanel`实现，因此它被声明为*包私有*（它不能从包外部扩展/实现）：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to completely close this interface, we transform it into a `sealed`
    interface, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全封闭这个接口，我们将其转换为`sealed`接口，如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we added the `public` modifier as well. This is needed because `ElectricBreaker`
    must occur in the `permits` list of the `ElectricComponent` interface, so it has
    to be available outside its package.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还添加了`public`修饰符。这是必要的，因为`ElectricBreaker`必须出现在`ElectricComponent`接口的`permits`列表中，因此它必须在其包外部可用。
- en: 'Finally, the `ElectricPanel` remains unchanged (a `final` class implementing
    `ElectricBreaker`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ElectricPanel`保持不变（一个实现`ElectricBreaker`的`final`类）：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Mission accomplished! The electric panel hierarchical model is completely closed
    to extension. We put everything in a *named* module (since we have `sealed` artifacts
    that interact across different packages) and we are done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！电面板分层模型完全封闭，无法扩展。我们将所有内容放入一个*命名*模块中（因为我们有在不同包之间交互的`sealed`组件），任务完成。
- en: 177\. Combining sealed classes and records
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 177. 结合密封类和记录
- en: As you know from *Chapter 4*, Java records are `final` classes that cannot be
    extended and cannot extend other classes. This means that records and `sealed`
    classes/interfaces can team up to obtain a closed hierarchy.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第4章*中所知，Java记录是`final`类，不能被扩展，也不能扩展其他类。这意味着记录和`sealed`类/接口可以组合起来获得一个封闭的层次结构。
- en: 'For instance, in the following figure, we can identify the classes that can
    be good candidates to become Java records in the *Fuel* model:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下图中，我们可以识别出在*Fuel*模型中可以成为Java记录的良好候选类的类：
- en: '![Figure 8.6.png](img/B19665_08_06.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.6.png](img/B19665_08_06.png)'
- en: 'Figure 8.6: Identify classes that can become Java records'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：识别可以成为Java记录的类
- en: 'As you can see, we have four classes that can become Java records: `Coke`,
    `Charcoal`, `Hydrogen`, and `Propane`. Technically speaking, these classes can
    be Java records since they are `final` classes and don’t extend other classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有四个可以成为Java记录的类：`Coke`、`Charcoal`、`Hydrogen`和`Propane`。从技术上讲，这些类可以成为Java记录，因为它们是`final`类，并且没有扩展其他类：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Of course, the technical aspect is important but it is not enough. In other
    words, you don’t have to transform all classes into Java records just because
    it works and the code compiles. You also have to take into account the logic and
    the context of the application. Sometimes, a `final` class is all you need; otherwise,
    you may need an esoteric model made of a `sealed` interface with a few records
    and classes in the same source file (`A.java`):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，技术方面很重要，但不足以满足要求。换句话说，你不必将所有类都转换为Java记录，仅仅因为它们可以工作并且代码可以编译。你还必须考虑应用程序的逻辑和上下文。有时，一个`final`类就足够了；否则，你可能需要一个由`sealed`接口和一些同一源文件（`A.java`）中的记录和类组成的神秘模型：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to add the `permits` clause to `A`, then you can do it as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将`permits`子句添加到`A`中，你可以这样做：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Done! Next, let’s see how sealed classes can help the compiler to better handle
    `instanceof` checks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！接下来，让我们看看密封类如何帮助编译器更好地处理`instanceof`检查。
- en: 178\. Hooking sealed classes and instanceof
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 178. 将密封类与instanceof挂钩
- en: Sealed classes influence how the compiler understands the `instanceof` operator
    and, implicitly, how it performs internal cast and conversion operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类影响编译器对`instanceof`操作符的理解，以及隐式地影响其内部类型转换和转换操作。
- en: 'Let’s consider the following snippet of code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, we have here an interface (`Quadrilateral`) and a class that doesn’t implement
    this interface. In this context, does the following code compile?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们这里有一个接口（`Quadrilateral`）和一个没有实现这个接口的类。在这个上下文中，以下代码是否可以编译？
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We wrote `if (t instanceof Quadrilateral) {…}` but we know that `Triangle`
    doesn’t implement `Quadrilateral`, so at first sight, we may think that the compiler
    will complain about this. But, actually, the code compiles because, at runtime,
    we may have a class `Rectangle` that extends `Triangle` and implements `Quadrilateral`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了`if (t instanceof Quadrilateral) {…}`，但我们知道`Triangle`没有实现`Quadrilateral`，所以乍一看，我们可能会认为编译器会对此提出抱怨。但实际上，代码可以编译，因为在运行时，我们可能有一个扩展`Triangle`并实现`Quadrilateral`的`Rectangle`类：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, our `instanceof` makes sense and is perfectly legal. Next, let’s close
    the `Triangle` class via the `final` keyword:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`instanceof`是有意义的，并且完全合法。接下来，让我们通过`final`关键字关闭`Triangle`类：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since `Triangle` is `final`, `Rectangle` cannot extend it, but it can still
    implement `Quadrilateral`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Triangle`是`final`的，`Rectangle`不能扩展它，但它仍然可以实现`Quadrilateral`：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This time, the `if (t instanceof Quadrilateral) {…}` code will not compile.
    The compiler knows that a `final` class cannot be extended, so a `Triangle` will
    never be a `Quadrilateral`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`if (t instanceof Quadrilateral) {…}`代码将无法编译。编译器知道`final`类不能被扩展，所以`Triangle`永远不会是`Quadrilateral`。
- en: 'So far, so good! Now, let’s restore the `Triangle` class as a non-`final` class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们将`Triangle`类恢复为非`final`类：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And let’s seal the `Quadrilateral` interface to permit only `Rectangle`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们密封`Quadrilateral`接口，只允许`Rectangle`：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And, the `Rectangle` class is `final`, as follows (this time, it doesn’t extend
    `Triangle`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Rectangle`类是`final`的，如下所示（这次，它没有扩展`Triangle`）：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Again, the compiler will complain about this check, `if (t instanceof Quadrilateral)
    {…}`. It is obvious that `Triangle` cannot be an instance of `Quadrilateral` since
    `Quadrilateral` is `sealed` and `permits` only `Rectangle`, not `Triangle`. However,
    if we modify the `Rectangle` to extend `Triangle`, then the code compiles:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，编译器将对此检查提出抱怨，`if (t instanceof Quadrilateral) {…}`。很明显，`Triangle`不能是`Quadrilateral`的实例，因为`Quadrilateral`是密封的，并且只允许`Rectangle`，不允许`Triangle`。然而，如果我们修改`Rectangle`以扩展`Triangle`，则代码可以编译：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So, in conclusion, sealed classes can help the compiler to better understand
    `instanceof` checks and to signal us when it doesn’t make sense.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，密封类可以帮助编译器更好地理解`instanceof`检查，并在它没有意义时向我们发出信号。
- en: 179\. Hooking sealed classes in switch
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 179. 在`switch`中挂钩密封类
- en: This is not the first time in this book that we’ve presented an example of sealed
    classes and `switch` expressions. In *Chapter 2*, *Problem 66*, we briefly introduced
    such an example via the `sealed Player` interface with the goal of covering completeness
    (type coverage) in pattern labels for `switch`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中不是第一次介绍密封类和`switch`表达式的示例。在*第二章*，*问题66*中，我们通过`sealed Player`接口简要介绍了这样一个示例，目的是为了覆盖`switch`模式标签中的完整性（类型覆盖率）。
- en: 'If, at that time, you found this example confusing, I’m pretty sure that now
    it is clear. However, let’s keep things fresh and see another example starting
    from this `abstract` base class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当时你发现这个例子令人困惑，我非常确信现在它已经清晰了。然而，让我们保持新鲜感，并从这个`abstract`基类开始看另一个示例：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And, we have three converters available, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有三个转换器可用，如下所示：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can write a `switch` expression to match these `TextConverter` instances,
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个`switch`表达式来匹配这些`TextConverter`实例，如下所示：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Check out the highlighted lines of code. After the three cases (`case Utf8`,
    `case Utf16`, and `case Utf32`), we must have one of the `case TextConverter`
    or the `default` case. In other words, after matching `Utf8`, `Utf16`, and `Utf32`,
    we must have a total type pattern (unconditional pattern) to match any other `TextConverter`
    or a `default` case, which typically means that we are facing an unknown converter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 查看高亮显示的代码行。在三个案例（`case Utf8`、`case Utf16`和`case Utf32`）之后，我们必须有一个`case TextConverter`或`default`案例。换句话说，在匹配`Utf8`、`Utf16`和`Utf32`之后，我们必须有一个总类型模式（无条件模式）来匹配任何其他`TextConverter`或`default`案例，这通常意味着我们面临的是一个未知的转换器。
- en: If both the total type pattern and the `default` label are missing, then the
    code doesn’t compile. The `switch` expression doesn’t cover all the possible cases
    (input values), therefore it is not exhaustive. This is not allowed, since `switch`
    expressions and `switch` statements that use `null` and/or pattern labels should
    be exhaustive.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总类型模式和`default`标签都缺失，则代码无法编译。`switch`表达式没有涵盖所有可能的案例（输入值），因此它不是详尽的。这是不允许的，因为使用`null`和/或模式标签的`switch`表达式和`switch`语句应该是详尽的。
- en: 'The compiler will consider our `switch` as non-exhaustive because we can freely
    extend the base class (`TextConverter`) with uncovered cases. An elegant solution
    is to seal the base class (`TextConverter`) as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将我们的 `switch` 视为非穷尽性，因为我们可以自由地扩展基类（`TextConverter`）而不覆盖所有情况。一个优雅的解决方案是将基类（`TextConverter`）密封如下：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And now the `switch` can be expressed as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`switch` 可以表达如下：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This time, the compiler knows all the possible `TextConverter` types and sees
    that they are all covered in the `switch`. Since `TextConverter` is `sealed`,
    there are no surprises; no uncovered cases can occur. Nevertheless, if we later
    decide to add a new `TextConverter` (for instance, we add `Utf7` by extending
    `TextConverter` and adding this extension in the `permits` clause), then the compiler
    will immediately complain that the `switch` is non-exhaustive, so we must take
    action and add the proper `case` for it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，编译器知道所有可能的 `TextConverter` 类型，并看到它们都在 `switch` 中被覆盖。由于 `TextConverter` 是密封的，所以没有惊喜；不会出现未覆盖的情况。尽管如此，如果我们后来决定添加一个新的
    `TextConverter`（例如，通过扩展 `TextConverter` 并在 `permits` 子句中添加此扩展来添加 `Utf7`），那么编译器将立即抱怨
    `switch` 是非穷尽性的，因此我们必须采取行动并为其添加适当的 `case`。
- en: 'At this moment, `Utf8`, `Utf16`, and `Utf32` are declared as `final`, so they
    cannot be extended. Let’s assume that `Utf16` is modified to become `non-sealed`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，`Utf8`、`Utf16` 和 `Utf32` 被声明为 `final`，因此不能被扩展。假设我们将 `Utf16` 修改为 `non-sealed`：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can extend `Utf16` as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以扩展 `Utf16` 如下：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Even if we added two subclasses to the `Utf16` class, our `switch` is still
    exhaustive because the case `Utf16` will cover `Utf16be` and `Utf16le` as well.
    Nevertheless, we can explicitly add cases for them, as long as we add these cases
    before `case Utf16`, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在 `Utf16` 类中添加了两个子类，我们的 `switch` 仍然是穷尽性的，因为 `Utf16` 的情况将同时覆盖 `Utf16be` 和
    `Utf16le`。尽管如此，我们仍然可以明确地添加它们的情况，只要我们在 `case Utf16` 之前添加这些情况，如下所示：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We have to add `case Utf16be` and `case Utf16le` before `case Utf16` to avoid
    dominance errors (see *Chapter 2*, *Problem 65*).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 `case Utf16` 之前添加 `case Utf16be` 和 `case Utf16le` 以避免优先级错误（参见 *第2章*，*问题65*）。
- en: 'Here is another example of combining sealed classes, pattern matching for switch,
    and Java records to compute the sum of nodes in a binary tree of integers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结合密封类、模式匹配的 `switch` 和 Java 记录来计算整数二叉树节点总和的另一个示例：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And here is an example of calling `sumNode()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用 `sumNode()` 的一个示例：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the result is `19`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，结果是 `19`。
- en: 180\. Reinterpreting the Visitor pattern via sealed classes and type pattern
    matching for switch
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 180. 通过密封类和类型模式匹配的 `switch` 重新解释访问者模式
- en: 'The Visitor pattern is part of the **Gang of Four** (**GoF**) design patterns
    and its goal is to define a new operation on certain classes without the need
    to modify those classes. You can find many excellent resources on this topic on
    the Internet, so for the classical implementation, we will provide here only the
    class diagram of our example, while the code is available on GitHub:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是 **Gang of Four**（**GoF**）设计模式的一部分，其目标是定义对某些类的新操作，而无需修改这些类。您可以在互联网上找到许多关于这个主题的优秀资源，因此对于经典实现，我们在这里只提供我们示例的类图，而代码可在
    GitHub 上找到：
- en: '![Figure 8.7.png](img/B19665_08_07.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7.png](img/B19665_08_07.png)'
- en: 'Figure 8.7: Visitor pattern class diagram (use case)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：访问者模式类图（用例）
- en: In a nutshell, we have a bunch of classes (`Capacitor`, `Transistor`, `Resistor`,
    and `ElectricCircuit`) that are used to create electrical circuits. Our operation
    is shaped in `XmlExportVisitor` (an implementation of `ElectricComponentVisitor`)
    and consists of printing an XML document containing the electrical circuit specifications
    and parameters.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们有一系列类（`Capacitor`、`Transistor`、`Resistor` 和 `ElectricCircuit`），它们用于创建电路。我们的操作在
    `XmlExportVisitor`（`ElectricComponentVisitor` 的实现）中形成，包括打印包含电路规格和参数的 XML 文档。
- en: Before continuing, consider getting familiar with the traditional implementation
    and output of this example available in the bundled code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请考虑熟悉捆绑代码中可用的传统实现和输出。
- en: 'Next, let’s assume that we want to transform this traditional implementation
    via sealed classes and type pattern matching for `switch`. The expected class
    diagram is simpler (has fewer classes) and it looks as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想要通过密封类和类型模式匹配的 `switch` 转换这个传统实现。预期的类图更简单（类更少），如下所示：
- en: '![Figure 8.8.png](img/B19665_08_08.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8.png](img/B19665_08_08.png)'
- en: 'Figure 8.8: Visitor pattern reinterpreted via sealed classes and switch patterns'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：通过密封类和switch模式重新解释的访问者模式
- en: 'Let’s start the transformation with the `ElectricComponent` interface. We know
    that this interface is implemented only by `Capacitor`, `Resistor`, `Transistor`,
    and `ElectricCircuit`. So, this interface is a good candidate to become `sealed`,
    as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ElectricComponent`接口开始转换。我们知道这个接口只由`Capacitor`、`Resistor`、`Transistor`和`ElectricCircuit`实现。因此，这个接口是一个很好的候选者，可以成为`sealed`，如下所示：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that we deleted the `accept()` method from this interface. We no longer
    need this method. Next, the `Capacitor`, `Resistor`, `Transistor`, and `ElectricCircuit`
    become `final` classes and the `accept()` implementation is deleted as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经从这个接口中删除了`accept()`方法。我们不再需要这个方法。接下来，`Capacitor`、`Resistor`、`Transistor`和`ElectricCircuit`变成了`final`类，并且`accept()`实现也被删除了。
- en: Since we don’t rely on the traditional Visitor pattern, we can safely remove
    its specific artifacts such as `ElectricComponentVisitor` and `XmlComponentVisitor`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不依赖于传统的访问者模式，我们可以安全地移除其特定的组件，例如`ElectricComponentVisitor`和`XmlComponentVisitor`。
- en: 'Pretty clean, right? We remained with a `sealed` interface and four `final`
    classes. Next, we can write a `switch` that visits each component of a circuit,
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很干净，对吧？我们保留了一个`sealed`接口和四个`final`类。接下来，我们可以编写一个`switch`语句来遍历电路的每个组件，如下所示：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `export(StringBuilder sb, ElectricComponent... comps)` is the effective
    visitor:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`export(StringBuilder sb, ElectricComponent... comps)`是有效的访问者：'
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Mission accomplished! You can find the complete example in the bundled code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！你可以在捆绑的代码中找到完整的示例。
- en: 181\. Getting info about sealed classes (using reflection)
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 181. 使用反射获取密封类信息
- en: 'We can inspect `sealed` classes via two methods added as part of the Java Reflection
    API. First, we have `isSealed()`, which is a flag method useful to check if a
    class is or isn’t `sealed`. Second, we have `getPermittedSubclasses()`, which
    returns an array containing the permitted classes. Based on these two methods,
    we can write the following helper to return the permitted classes of a `sealed`
    class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过Java反射API中添加的两个方法来检查`sealed`类。首先，我们有`isSealed()`，这是一个标志方法，用于检查一个类是否是`sealed`。其次，我们有`getPermittedSubclasses()`，它返回一个包含允许的类的数组。基于这两个方法，我们可以编写以下辅助工具来返回`sealed`类的允许类：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can easily test our helper via the `Fuel` model as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Fuel`模型轻松测试我们的辅助工具，如下所示：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I think you got the idea!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你已经明白了这个想法！
- en: 182\. Listing the top three benefits of sealed classes
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 182. 列出密封类的三大好处
- en: Maybe you have your own top three sealed class benefits that don’t match the
    following list. That’s OK, they are still benefits after all!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你有自己的三大密封类好处，这与以下列表不匹配。没关系，它们仍然是好处！
- en: '**Sealed classes sustain better design and clearly expose their intentions**:Before
    using sealed classes, we have to rely only on the `final` keyword (which is expressive
    enough), and *package-private* classes/constructors. Obviously, *package-private*
    code requires some reading between the lines to understand its intention since
    it is not easy to spot a closed hierarchy modeled via this hack. On the other
    hand, sealed classes expose their intentions very clearly and expressively.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类支持更好的设计和清楚地暴露其意图**：在使用密封类之前，我们只能依赖于`final`关键字（它已经足够表达），以及*包私有*类/构造函数。显然，*包私有*代码需要一些推理来理解其意图，因为通过这种技巧建立封闭层次结构并不容易识别。另一方面，密封类非常清楚地表达了它们的意图。'
- en: '**The compiler can rely on sealed classes to perform finer checks on our behalf**:
    Nobody can sneak a class into a hierarchy closed via sealed classes. Any such
    attempt is rejected via a clear and meaningful message. The compiler is guarding
    for us and acts as the first line of defense against any accidental/non-accidental
    attempt to use our closed hierarchies in an improper way.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器可以依赖密封类为我们执行更细粒度的检查**：没有人可以悄悄地将一个类放入通过密封类关闭的层次结构中。任何此类尝试都会通过一个清晰且有意义的信息被拒绝。编译器在保护我们，并作为防止任何意外/非意外尝试以不适当的方式使用我们的封闭层次结构的第一道防线。'
- en: '**Sealed classes help the compiler to provide better pattern matching:** You
    experimented with this benefit in *Problem 179*. The compiler can rely on sealed
    classes to determine if a `switch` is covering all the possible input values and
    therefore is exhaustive. And this is just the beginning of what sealed classes
    can do for pattern matching.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类有助于编译器提供更好的模式匹配**：您在*问题179*中实验了这一好处。编译器可以依赖密封类来确定`switch`是否覆盖了所有可能的输入值，因此是穷尽的。而这只是密封类在模式匹配中能做的事情的开始。'
- en: 183\. Briefly introducing hidden classes
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 183. 简要介绍隐藏类
- en: Hidden classes were introduced in JDK 15 under JEP 371\. Their main goal is
    to be used by frameworks as dynamically generated classes. They are runtime-generated
    classes with a short lifespan that are used by frameworks via reflection.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏类是在JDK 15中通过JEP 371引入的。它们的主要目标是作为框架动态生成的类使用。它们是生命周期短的运行时生成的类，通过反射由框架使用。
- en: '**Important note**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Hidden classes cannot be used directly by bytecode or other classes. They are
    not created via a class loader. Basically, a hidden class has the class loader
    of the lookup class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏类不能直接通过字节码或其他类使用。它们不是通过类加载器创建的。基本上，隐藏类具有查找类的类加载器。
- en: 'Among other characteristics of hidden classes, we should consider that:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐藏类的其他特性中，我们应该考虑以下几点：
- en: They are not discoverable by the JVM internal linkage of bytecode or by the
    explicit usage of class loaders (they are invisible to methods such as `Class.forName()`,
    `Lookup.findClass()`, or `ClassLoader.findLoadedClass()`). They don’t appear in
    stack traces.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能通过JVM的字节码内部链接或通过显式使用类加载器（它们对`Class.forName()`、`Lookup.findClass()`或`ClassLoader.findLoadedClass()`等方法不可见）被发现。它们不会出现在堆栈跟踪中。
- en: They extend **Access Control Nest** (**ACN**) with classes that cannot be discovered.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过无法发现的类扩展**访问控制巢**（**ACN**）。
- en: Frameworks can define hidden classes, as many as needed, since they benefit
    from aggressive unloading. This way, a large number of hidden classes shouldn’t
    have a negative impact on performance. They sustain efficiency and flexibility.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架可以定义所需的隐藏类，因为它们可以从积极的卸载中受益。这样，大量隐藏类不应该对性能产生负面影响。它们保持了效率和灵活性。
- en: They cannot be used as a field/return/parameter type. They cannot be superclasses.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能用作字段/返回/参数类型。它们不能作为超类。
- en: They can access their code directly without the presence of a class object.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以直接访问其代码，而无需存在类对象。
- en: They can have `final` fields, and those fields cannot be modified regardless
    of their accessible flags.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有`final`字段，并且无论其可访问标志如何，这些字段都不能被修改。
- en: They deprecated the `misc.Unsafe::defineAnonymousClass`, which is a non-standard
    API. Starting with JDK 15, lambda expressions use hidden classes instead of anonymous
    classes.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们弃用了`misc.Unsafe::defineAnonymousClass`，这是一个非标准API。从JDK 15开始，lambda表达式使用隐藏类而不是匿名类。
- en: Next, let’s see how we can create and use a hidden class.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何创建和使用隐藏类。
- en: 184\. Creating a hidden class
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 184. 创建隐藏类
- en: 'Let’s assume that our hidden class is named `InternalMath` and is as simple,
    as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的隐藏类名为`InternalMath`，如下所示非常简单：
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we mentioned in the previous problem, hidden classes have the same class
    loader as the lookup class, which can be obtained via `MethodHandles.lookup()`,
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个问题中提到的，隐藏类与查找类具有相同的类加载器，可以通过`MethodHandles.lookup()`获得，如下所示：
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, we must know that `Lookup` contains a method named `defineHiddenClass(byte[]
    bytes, boolean initialize, ClassOption... options)`. The most important argument
    is represented by the array of bytes that contain the class data. The `initialize`
    argument is a flag specifying if the hidden class should be initialized or not,
    while the `options` argument can be `NESTMATE` (the created hidden class becomes
    a nestmate of the lookup class and has access to all the private members in the
    same nest) or `STRONG` (the created hidden class can be unloaded only if its defining
    loader is not reachable).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须知道`Lookup`包含一个名为`defineHiddenClass(byte[] bytes, boolean initialize,
    ClassOption... options)`的方法。其中最重要的参数是由包含类数据的字节数组表示。`initialize`参数是一个标志，用于指定是否应该初始化隐藏类，而`options`参数可以是`NESTMATE`（创建的隐藏类成为查找类的巢穴伙伴，并可以访问同一巢穴中的所有私有成员）或`STRONG`（只有当其定义加载器不可达时，创建的隐藏类才能被卸载）。
- en: 'So, our goal is to obtain the array of bytes that contains the class data.
    For this, we rely on `getResourceAsStream()` and JDK 9’s `readAllBytes()`, as
    follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是获取包含类数据的字节数组。为此，我们依赖于 `getResourceAsStream()` 和 JDK 9 的 `readAllBytes()`，如下所示：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Having `clazzBytes` in our hands, we can create the hidden class as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 `clazzBytes` 后，我们可以按照以下方式创建隐藏类：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Done! Next, we can use the hidden class from inside our framework, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！接下来，我们可以在我们的框架内部使用隐藏类，如下所示：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see, we use the hidden class via reflection. The interesting part
    here is represented by the fact that we cannot cast the hidden class to `InternalMath`,
    so we use `Object obj = …`. So, this will not work:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过反射使用隐藏类。这里有趣的部分在于我们无法将隐藏类转换为 `InternalMath`，所以我们使用 `Object obj = …`。所以，这不会起作用：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'However, we can define an interface implemented by the hidden class:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以定义一个由隐藏类实现的接口：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And, now we can cast to `Math`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将它们转换为 `Math`：
- en: '[PRE77]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Starting with JDK 16, the `Lookup` class was enriched with another method for
    defining a hidden class named `defineHiddenClassWithClassData(byte[] bytes, Object
    classData, boolean initialize, ClassOption... options)`. This method needs the
    class data obtained via `MethodHandles.classData(Lookup caller, String name, Class<T>
    type)` or `MethodHandles.classDataAt(Lookup caller, String name, Class<T> type,
    int index)`. Take your time to explore this further.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 16 开始，`Lookup` 类增加了一个名为 `defineHiddenClassWithClassData(byte[] bytes,
    Object classData, boolean initialize, ClassOption... options)` 的隐藏类定义方法。此方法需要通过
    `MethodHandles.classData(Lookup caller, String name, Class<T> type)` 或 `MethodHandles.classDataAt(Lookup
    caller, String name, Class<T> type, int index)` 获取到的类数据。请花时间进一步探索。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 13 problems. Most of them were focused on the sealed classes
    feature. The last two problems provided brief coverage of hidden classes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 13 个问题。其中大部分都集中在密封类功能上。最后两个问题简要介绍了隐藏类。
- en: Leave a review!
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评价！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评价来帮助像你这样的读者。扫描下面的二维码获取 20% 的折扣码。
- en: '![](img/Leave_Reivew_QR.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_Reivew_QR.png)'
- en: '**Limited Offer*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
