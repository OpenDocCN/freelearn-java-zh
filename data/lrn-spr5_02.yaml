- en: Chapter 2. Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章：依赖注入
- en: The previous chapter gave us over view of what is Spring framework and how it
    helps the developers to make the development faster and easier. But the question
    "how to use the framework?" is still unanswered. In this chapter we will discuss
    the answer in all perspectives and try to find out all the probable answers for
    it. The chapter is full of configuration and alternatives for the configuration.
    It all depends on how the developer looks forward with these solutions in available
    conditions and environmental setup of the application. We are aiming to cover
    following points in depth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章概述了Spring框架是什么以及它如何帮助开发者加快开发速度和简化开发。但是，“如何使用这个框架？”的问题仍然没有答案。在本章中，我们将从所有角度讨论答案，并尝试找出所有可能的答案。本章充满了配置和配置的替代方案。这取决于开发者如何在这些解决方案和应用程序的可用条件及环境设置中展望。我们旨在深入探讨以下几点：
- en: We will start with Bean Life cycle management with custom initialization, InitializingBean,
    DisposableBean, and Aware Interfaces, Use of annotations like @PostConstruct and
    @PreDestroy in bean life cycle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从自定义初始化的豆子生命周期管理开始，探讨InitializingBean、DisposableBean和Aware接口，以及在豆子生命周期中使用@PostConstruct和@PreDestroy注解。
- en: The dependency injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Setter and constructor Dependency injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器和构造函数依赖注入
- en: DI for references, inner beans, Inheritance and Collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入（DI）用于参考、内部豆子、继承和集合
- en: Bean scope and configuring scopes as Singleton or Prototype
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 豆子作用域以及将作用域配置为单例或原型
- en: Auto wiring and ways of achieving auto wiring
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装配及实现自动装配的方法
- en: Problems occurring while auto wiring and ways to overcome
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装配过程中发生的问题及解决方法
- en: Lot many things to cover, so let's start with the very first 'the life of a
    bean'.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖的内容很多，所以我们从“豆子的生命周期”开始。
- en: The life of a bean
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 豆子的生命周期
- en: '* * *'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The Spring IoC container hides the complex communication between the container
    and the beans. The following figure gives an idea about the steps which container
    follows to maintain the life of every bean:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spring IoC容器隐藏了容器与豆子之间复杂的通信。以下图表给出了容器维护每个豆子生命周期的步骤的一个大致概念：
- en: '![](img/image_02_001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: Bean life cycle
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 豆子生命周期
- en: Loading the configuration
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载配置
- en: This is the most important phase in bean life cycle which initiates the life
    cycle process. The container loads and reads the metadata information from the
    bean configuration file and starts the next phase 'instantiation'.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是豆子生命周期中最重要的阶段，它启动生命周期过程。容器加载并从豆子配置文件中读取元数据信息，然后开始下一阶段“实例化”。
- en: Object creation
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象创建
- en: Using Java Reflection API the Spring container creates an instance of a bean.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器使用Java反射API创建一个豆子的实例。
- en: Setting the bean name
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置豆子名称
- en: Each bean contains a unique name configured in the configuration. This name
    can be made available to the bean class by `setBeanName()`. If the bean class
    implements `BeanNameAware` interface, its `setBeanName()` method gets invoked
    to set the bean name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个豆子都在配置中包含一个独特的名称。这个名称可以通过`setBeanName()`方法提供给豆子类。如果豆子类实现了`BeanNameAware`接口，那么它的`setBeanName()`方法会被调用以设置豆子名称。
- en: Setting bean factory
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置豆子工厂
- en: Sometimes the bean class may need to get information about the factory which
    loaded it. If the bean class implements `BeanFactoryAware` its `setBeanFactory()`
    method will get invoked passing the instance of the `BeanFactory` to it which
    is may be an instance of `ApplicationContext` , `WebApplicationContext` ,etc.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时豆子类可能需要获取有关加载它的工厂的信息。如果豆子类实现了`BeanFactoryAware`，那么它的`setBeanFactory()`方法将被调用，传递`BeanFactory`实例给它，这可能是一个`ApplicationContext`、`WebApplicationContext`等实例。
- en: Bean post processing with postProcessBeforeInitialization
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`postProcessBeforeInitialization`进行豆子后处理
- en: In some of the scenarios before the values of the objects gets populated some
    pre initialization is required which cannot be done in the configuration files.
    In such cases, if an object of BeanPostProcessor does this task. The BeanPostProcessors
    are special kind of beans which get instantiates before any other beans are instantiate.
    These BeanPostProcessor beans interact with new instance created by the container.
    But, it will be done in two steps, once before the properties are set and second
    once the properties got set. In this phase, BeanPostProcessor which is associated
    with BeanFactory, it's PostProcessorBeforeInitiallization will be called to do
    the pre initialization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，在对象的值得到填充之前需要进行一些预初始化，这无法在配置文件中完成。在这种情况下，如果 BeanPostProcessor 对象执行这个任务。BeanPostProcessor
    是一种特殊的 bean，在实例化任何其他 bean 之前被实例化。这些 BeanPostProcessor bean 与容器创建的新实例交互。但是，这将分为两个步骤进行，一次是在属性设置之前，第二次是在属性设置之后。在这个阶段，与
    BeanFactory 关联的 BeanPostProcessor，它的 PostProcessorBeforeInitiallization 方法将被调用进行预初始化。
- en: Property population
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性填充
- en: The bean configuration may be specified with some bean properties. In this phase
    all the values will get associated to the instance initialized in the previous
    phase.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: bean 配置可能指定一些 bean 属性。在这个阶段，所有值都将与在前一阶段初始化的实例相关联。
- en: Initializing bean with
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 bean 进行初始化
- en: The afterPropertiesSet() method
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 afterPropertiesSet() 方法
- en: It may happen that, the bean configured in the configuration hasn''t set values
    of all the properties. And once the properties get populated, using some business
    logic or in some other way rest of the properties need to be set. `InitializingBean`
    interface helps in the task. If the class implements `InitializingBean` interface,
    its `afterPropertiesSet()` method will be called to set such properties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可能发生的情况是，配置中的 bean 没有设置所有属性的值。一旦属性得到填充，使用某些业务逻辑或其他方式设置剩余的属性。`InitializingBean`
    接口在任务中提供帮助。如果类实现了 `InitializingBean` 接口，其 `afterPropertiesSet()` 方法将调用以设置这些属性。
- en: The Custom init() method
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义 init() 方法
- en: Though the `afterProperties()` helps to do initialization of properties based
    on some logic, the code gets strongly coupled with the Spring API. To overcome
    this drawback there is a way to initialize the bean using custom initialization
    method. If the developer has written custom `init` method and configured it for
    the bean in the bean configuration as an '`init-method`' attribute, it will get
    called by the container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `afterProperties()` 有助于根据某些逻辑对属性进行初始化，但代码与 Spring API 紧密耦合。为了克服这个缺点，有一种方法可以使用自定义初始化方法来初始化
    bean。如果开发者编写了自定义 `init` 方法并在 bean 配置中将其配置为 '`init-method`' 属性，容器会调用它。
- en: Bean post processing with postProcessAfterInitialization
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 postProcessAfterInitialization 进行 bean 后处理
- en: BeanPostProcessor''s `postProcessAfterInitialization()` will be called to do
    the `postProcessing` once the properties got initialized.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性初始化完成后，BeanPostProcessor 的 `postProcessAfterInitialization()` 方法将被调用进行 `postProcessing`。
- en: Use the bean
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 bean
- en: Thank god!!!! Yes now the object is perfectly ready for use with its state defined.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 谢天谢地！！！现在对象的状态定义完美，完全准备好使用。
- en: Destruct bean with
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用销毁 bean 的方法
- en: The developers used the objects and the objects have completed their tasks.
    Now we don't need them anymore. To release the memory occupied by the bean can
    be destroyed by,
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用了对象，对象已经完成了它们的任务。现在我们不再需要它们了。为了释放 bean 占用的内存，可以通过以下方式销毁 bean，
- en: Dispose bean with destroy()
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 destroy() 方法销毁 bean
- en: If the bean class implements DisposableBean interface, its destroy() method
    will be getting called to release memory. It has the same drawback as that of
    InitializingBean. To overcome we do have custom destroy method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 bean 类实现了 DisposableBean 接口，其 destroy() 方法将被调用以释放内存。它具有与 InitializingBean
    相同的缺点。为了克服这个问题，我们确实有自定义的销毁方法。
- en: Destruction with custom destroy()
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自定义 destroy() 方法进行销毁
- en: It is also possible to write a custom method to release memory. It will be called
    when the attribute 'destroy-method' has been configured in the bean configuration
    definition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以编写一个自定义方法来释放内存。当在 bean 配置定义中配置了 'destroy-method' 属性时，它将被调用。
- en: After knowing the lifecycle, let''s now do some implementation to know the implementation
    perspective.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在了解了生命周期之后，让我们现在做一些实现，以了解实现观点。
- en: 'Case1: Using Custom initialization and destruction methods'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例1：使用自定义初始化和销毁方法
- en: As we already discussed in bean life cycle, these two methods will leverage
    the developer to write their own methods for initialization and destruction. As
    developers are not coupled with Spring API, they can take advantage of choosing
    their own method signature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在bean生命周期中已经讨论过的，这两个方法将使开发者能够编写自己的初始化和销毁方法。由于开发者不受Spring API的耦合，他们可以利用这一点选择自己的方法签名。
- en: 'Let''s have a look on how to hook these methods in order to be used by Spring
    container step by step:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何逐步将这些方法钩入以供Spring容器使用：
- en: Create a Java Application as Ch02_Bean_Life_Cycle and add to it jar which we
    did in previous project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch02_Bean_Life_Cycle的Java应用程序，并添加我们在之前项目中完成的jar。
- en: 'Create a class Demo_Custom_Init under the package com.ch02.beans as shown below:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包下创建一个名为Demo_Custom_Init的类，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the class a method myInit() with the following code to do initialization.
    Here we are shifting ''''name'''' to uppercase:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加一个名为myInit()的方法，并使用以下代码进行初始化。在这里，我们将'name'转换为大写：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create bean_lifecycle.xml in class path to configure the bean similar to the
    previous project(refer to beans_classpath.xml from Ch01_Container_Initizatization)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径创建bean_lifecycle.xml文件，以配置类似于之前项目的bean（参考Ch01_Container_Initizatization中的beans_classpath.xml）。
- en: 'Add to it bean definition as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此基础上添加bean定义如下：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '* Each bean has to be configured within <bean> tag.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个bean必须在`<bean>`标签内配置。
- en: '* A <bean> tag contains many attributes we need to configure minimum two of
    them which are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* `<bean>`标签包含许多我们需要配置的属性，其中至少需要两个，如下所示：'
- en: 'a. id : Specifies the reference name on which the container recognises whose
    object he is managing. ''id'' must be unique within the container. Naming the
    ''id'' is similar to the reference in Java application.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. id：指定容器识别其正在管理的对象的确切名称。'id'必须在容器内唯一。命名'id'与Java应用程序中的引用类似。
- en: 'b. class: Specifies whose object container is creating and managing. The value
    of the class attribute must be fully qualified class name as we did in above configuration.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. class：指定容器正在创建和管理哪个对象。class属性的值必须是完全限定类名，正如我们在上面的配置中所做的那样。
- en: 'The syntax to configure a bean definition in XML is as shown as follows:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML中配置bean定义的语法如下所示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The XML configuration is equivalent to the Java Code as,
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML配置与Java代码相当，
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are few more attributes which developer can use in configuration. We will
    see them one by one according to the scenarios in upcoming chapters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在配置中使用一些其他属性。我们将在接下来的章节中根据场景逐一介绍它们。
- en: 'The configuration shown in Step 5 is the very basic configuration without providing
    any information to the container about how to initialize the property ''name''.
    Let''''s modify the configuration by adding the attribute ''init-method'' to specify
    the method name which is to be invoked to initialize the property after instantiation.
    The modified code as shown below:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤5中显示的配置是非常基本的配置，没有向容器提供关于如何初始化属性'name'的信息。让我们通过添加'init-method'属性来修改配置，以指定在实例化后调用以初始化属性的方法名。修改后的代码如下：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The way we perform initialize, in the same way we can release the resource
    as well. To do the release with custom destruct method we need to first add it
    to the code as:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行初始化的方式，同样我们也可以释放资源。要使用自定义的销毁方法释放资源，我们首先需要在代码中添加如下内容：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Configure the destruct method in bean configuration by specifying destroy-method
    as shown in the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean配置中通过指定destroy-method来配置销毁方法，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create `Test_Demo_Custom_Init` with main function. Initialize the container
    as we did earlier in chapter 1\. And get the instance of `Demo_Custom_Init` using
    `getBean()` as shown below:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Test_Demo_Custom_Init`的Java程序，并添加main函数。像我们在第1章中一样初始化容器。并使用`getBean()`获取`Demo_Custom_Init`的实例，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The execution of the code gives the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的执行给出了以下输出：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output clearly shows life cycle phases as construction, initialization,
    use and then destruction of the bean.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了bean的生命周期阶段，包括构造、初始化、使用和销毁。
- en: 'Don''''t be surprised by the absence of ''destroy called'' statement. We can
    use the following code to elegantly shut down the container:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对缺少'destroy called'语句感到惊讶。我们可以使用以下代码优雅地关闭容器：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On addition of the above line to the main function even the 'destroy called'
    will be seen as a console output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在main函数中添加上述代码后，甚至'destroy called'也会作为控制台输出出现。
- en: 'Case2: Using InitializingBean to provide initialization'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例2：使用InitializingBean提供初始化
- en: We will use the same project Ch02_Bean_Life_Cycle which we develop in the Case1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与案例1中开发相同的项目Ch02_Bean_Life_Cycle。
- en: 'Follow the steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Add a class Demo_InitializingBean in com.ch02.beans package which is implementing
    InitializingBean interface as shown below:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中添加一个实现InitializingBean接口的Demo_InitializingBean类，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Override the method afterPropertiesSet() method for processing properties as
    follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，覆盖afterPropertiesSet()方法以处理属性：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add one more bean to the bean_lifecycle.xml as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean_lifecycle.xml中再添加一个bean，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can observe that we don''t have to override any init-method attribute here
    as we did in Case1 as afterPropertiesSet() get a call by callback mechanism once
    properties got set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们在这里不需要重写任何init-method属性，正如我们在案例1中所做的那样，因为afterPropertiesSet()通过回调机制在属性设置后得到调用。
- en: 'Create a class Test_InitializingBean with main method as shown in the following
    code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有main方法的Test_InitializingBean类，如以下代码所示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The execution of output is as shown below:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出执行结果如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the above out put the underlined statements are not related to the newly
    configured bean. But as container does initialization of all the beans configured,
    it will initialize the `Demo_Custom_Init` bean as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中，下划线的语句与新配置的bean无关。但是，由于容器对所有配置的bean进行初始化，它也会初始化`Demo_Custom_Init`bean。
- en: 'Case3: Using DisposableBean to provide release of memory'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例3：使用DisposableBean提供内存释放
- en: We will use the same project Ch02_Bean_Life_Cycle which we develop in the Case1.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与案例1中开发相同的项目Ch02_Bean_Life_Cycle。
- en: 'Follow the steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Add a class Demo_DisposableBean.in com.ch02.beans package which is implementing
    DisposableBean interface as shown below:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中添加一个实现DisposableBean接口的Demo_DisposableBean类，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Override the method destroy()method for memory release as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示覆盖destroy()方法以释放内存：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add one more bean to the bean_lifecycle.xml as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean_lifecycle.xml中再添加一个bean，如下所示：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can observe that we don''t have to override any destroy-method attribute
    here as we did in Case1\. The `destroy()` get a callback once the container containing
    the bean getting shut down.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们在这里不需要重写任何destroy-method属性，正如我们在案例1中所做的那样。当包含bean的容器关闭时，`destroy()`将得到回调。
- en: 'Create a class Test_DisposableBean with following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有以下代码的Test_DisposableBean类：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will get the following code on execution of the main:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行主程序后将会得到以下代码：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The underlined line is from the destroy() from Disposable demo but as there
    is custom `destroy()` method for `Demo_Custom_Init` class as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线行来自Disposable demo的destroy()，但正如您所见的，对于Demo_Custom_Init类也有自定义的destroy()方法。
- en: 'Case4: Making the bean aware of Container'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例4：使bean意识到容器
- en: We will use the same project Ch02_Bean_Life_Cycle which we develop in the Case1.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与案例1中开发相同的项目Ch02_Bean_Life_Cycle。
- en: 'Follow the steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Add a class MyBean in com.ch02.contextaware package which is implementing ApplicationContextAware
    interface.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.contextaware包中添加一个实现ApplicationContextAware接口的MyBean类。
- en: Add a data member to the bean class of type ApplicationContext.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向bean类中添加一个ApplicationContext类型的数据成员。
- en: Override the method setApplicationContext()method.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖setApplicationContext()方法。
- en: 'Add display () to get one of the bean and display its properties. The class
    will be as shown below:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加display()方法以获取一个bean并显示其属性。类将如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we are accessing one of the other bean who is not a data member of the
    class and not injected. But the code shows we still cab access their properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们访问了一个不是类数据成员且未注入的其他bean。但代码显示我们仍然可以访问其属性。
- en: 'Add one more bean to the `bean_lifecycle.xml` as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bean_lifecycle.xml`中再添加一个bean，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a class Test_MyBean with main method as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有main方法的Test_MyBean类，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On execution we will get the following output as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，我们将得到以下输出：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Case4: Using BeanPostProcessor.'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例4：使用BeanPostProcessor。
- en: We will use the same project Ch02_Bean_Life_Cycle which we develop in the Case1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与案例1中开发相同的项目Ch02_Bean_Life_Cycle。
- en: 'Follow the steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Add a bean class Demo_BeanpostProcessor in com.ch02.beans package which implement
    BeanPostProcessor.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中添加一个实现BeanPostProcessor的bean类Demo_BeanpostProcessor。
- en: Override the method postProcessBeforeInitialization ()method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖postProcessBeforeInitialization()方法。
- en: Override the method postProcessAfterInitialization()method.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖postProcessAfterInitialization()方法。
- en: The complete class definition is as shown below,
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的类定义如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add one more bean to the bean_lifecycle.xml as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean_lifecycle.xml中再添加一个bean，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a class `TestBeanPostProcessor` with main method. We don''t have to ask
    bean for ''`beanPostProcessor''` as its methods are called before and after init
    method for each bean in the container.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有main方法的`TestBeanPostProcessor`类。我们不必向bean请求`beanPostProcessor`，因为它的方法在容器中的每个bean的init方法前后被调用。
- en: 'Write the test code to find the order of methods called in initialization process
    as shown below:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试代码，找出初始化过程中调用方法的顺序，如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as shown below:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The underlined statements are for the bean which we asked from the container.
    But find the order which has been followed as constructor, `postProcessBeforeInitialization`
    method, custom-init method, `postProcessAfterInitialization`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的陈述是为了从容器中获取我们请求的bean。但是找出遵循的顺序，如构造函数、`postProcessBeforeInitialization`方法、自定义初始化方法、`postProcessAfterInitialization`。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: In an application more than one `BeanPostProcessors` can be configured. The
    order of their execution can be managed by setting ''order'' property if the bean
    implements Ordered interface. The scope of each `PostBeanProcessor` is per container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用中，可以配置多个`BeanPostProcessors`。如果bean实现了Ordered接口，可以通过设置`order`属性来管理它们的执行顺序。每个`PostBeanProcessor`的作用域是每个容器。
- en: Using JSR-250 annotations for bean lifecycle
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSR-250注解进行bean生命周期管理
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: JSR-250 annotations plays a vital role in bean life cycle but we won''t directly
    jump and discover them. Doing so may lead us skipping some of very important concepts.
    So relax we will discuss them at the time of JSR based annotations. But if you
    already known Spring, use of annotations in Spring and so eager to go for @PreDestroy
    or @PostConstruct you may directly go to the topic JSR annotations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JSR-250注解在bean生命周期中起着至关重要的作用，但我们不会直接跳过去发现它们。这样做可能会导致我们忽略一些非常重要的概念。所以放心，我们会在讨论基于JSR的注解时讨论它们。但是，如果您已经了解Spring，知道Spring中注解的使用，并且急于了解@PreDestroy或@PostConstruct，您可以直接跳到JSR注解的主题。
- en: 'In huge development of Java Enterprise application is simplified by writing
    smaller units of codes generally, classes. Then developers reuse them by calling
    the methods of each other. This is very complex and difficult to maintain architecture.
    In order to invoke the method of another class, its knowledge is important. The
    class which holds the object of another class is called as container. And the
    object which container holds is called as contained object. Now the container
    is well aware of the contained object. The developers will be more than happy
    as now they can easily reuse the contained object which simplifies their development.
    But now there is a very major flaw in the designing. This can be well explained
    with two very famous terminologies as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型Java企业应用的开发中，通过编写较小的代码单元，通常为类，可以简化开发。然后，开发者通过调用彼此的方法来重复使用它们。这种架构非常复杂且难以维护。为了调用另一个类的实例方法，理解其知识是重要的。持有另一个类对象的类被称为容器。容器持有的对象称为被包含对象。现在容器对被包含对象了如指掌。开发者现在会非常高兴，因为现在他们可以轻松地重复使用被包含对象，这简化了他们的开发工作。但现在设计中有一个非常重大的缺陷。这可以通过下面介绍的两个非常著名的术语来很好地解释：
- en: '**Loose coupling**: The container class will not be affected even though there
    is a change in the contained object. The container in such scenario is called
    as loosely coupled object. The developers always try to write down the code which
    follows loose coupling. In Java loose coupling can be well achieved with the help
    of interface programming. The interface states what the contract is? But it doesn''''t
    specify who and how the contract will be implemented. The container class will
    have less of the knowledge of the dependency making it more flexible.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：即使被包含对象发生了变化，容器类也不会受到影响。在这种场景下，容器被称为松耦合对象。开发者总是试图编写遵循松耦合的代码。在Java中，可以通过接口编程来实现松耦合。接口规定了什么是合同？但它并没有指定谁和如何实现这个合同。容器类对依赖的知识了解较少，使其更加灵活。'
- en: '**Tight coupling**: the container class need to change whenever there is a
    code change in contained objects. The container is tightly coupled with the container
    object which makes development difficult.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：当被包含对象有代码更改时，容器类需要进行更改。容器与被包含对象紧密耦合，这使得开发变得困难。'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: Try to avoid writing tightly coupled classes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免编写紧密耦合的类。
- en: 'Whether it''''s loose coupling or tight coupling we get reusable objects. Now
    the question is how these objects will be created. In Java the object creation
    can happen with two major ways as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是松耦合还是紧耦合，我们都能得到可重用的对象。现在的问题是这些对象将如何创建。在Java中，对象创建可以通过两种主要方式实现，如下所示：
- en: Constructor invocation.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数调用。
- en: Factory to give objects
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂提供对象
- en: As an abstract level both of these ways looks alike as the end user is going
    to get an object for use. But these are not the same. In factory the dependant
    classes have the responsibility of creating the object and in constructor the
    constructor gets invoked directly. The Java application is centric and revolving
    around objects. The very first thing every developer tries to get object properly
    initialized so that handling of data and performing operations can be done in
    sophisticated way. The instance creation and state initialization are the two
    steps in creating every properly initialised object. As container will be involving
    in both of these processes we should have a good knowledge of both of them. So
    let's start with instance creation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象层面上，这两种方式看起来很相似，因为最终用户将获得一个对象进行使用。但这并不相同。在工厂中，依赖类负责创建对象，而在构造函数中，构造函数直接被调用。Java应用程序以对象为中心，围绕对象进行。每个开发者尝试做的第一件事就是正确初始化对象，以便以优雅的方式处理数据和执行操作。创建每个正确初始化的对象有两个步骤：实例创建和状态初始化。由于容器将涉及这两个过程，我们应该对它们有很好的了解。所以让我们从实例创建开始。
- en: Instance creation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例创建
- en: '* * *'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'In java, following are the two ways to create an instance:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在java中，创建实例有以下两种方式：
- en: Using constructor
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: Using factory method
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂方法
- en: I will not go in detail the scenarios when to use which way as we all are from
    Java background and had done or read the reasons number of times. We will directly
    start with how to use them in Spring framework one by one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细说明何时使用哪种方法，因为我们都是Java背景，已经读过或听过很多次原因。我们将直接开始讲解如何在Spring框架中逐一使用它们。
- en: Using Constructor
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: 'Let''''s take an example of a Car to make it crystal clear how the container
    will create the object of Car with the help of following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以汽车为例，来清晰地了解容器是如何通过以下步骤创建汽车对象的：
- en: Create Java application Ch02_Instance_Creation and add jars which we added in
    previous project.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Java应用程序Ch02_Instance_Creation并添加我们在上一个项目中添加的jar文件。
- en: 'Create a class Car in com.ch02.beans package with chesis number, it''s color,
    fuel type, price, average as data members. The code is as shown below:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建一个Car类，具有车牌号、颜色、燃料类型、价格、平均值等数据成员。代码如下：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add show() in Car as shown below:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Car中添加show()，如下所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the developer tries to create the object the code will be as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当开发者尝试创建对象时，代码如下：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we need to configure `BeanDefination` in XML file which represents a bean
    instance so that the bean will be managed by the Spring container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在XML文件中配置`BeanDefination`，它代表一个bean实例，以便bean将由Spring容器管理。
- en: 'Create `instance.xml` in `Classpath` to configure our Car `BeanDefination`
    we need to configure it as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Classpath`中创建`instance.xml`以配置我们的Car`BeanDefination`，我们需要按照如下方式进行配置：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create TestCar with main function in default package to get the bean to use
    business logic.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认包中创建带有main函数的TestCar，以获取bean并使用业务逻辑。
- en: '* Get Spring container instance. We will Use ClassPathXmlApplicationContext
    as discussed in container initialization.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '* 获取Spring容器的实例。我们将使用ClassPathXmlApplicationContext，如容器初始化中所讨论的。'
- en: '* Get the bean instance from the container.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '* 从容器中获取bean实例。'
- en: 'The code will be as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as shown in snapshot below:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/image_02_002.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.png)'
- en: Figure 02
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图02
- en: 'It''s pretty clear from the output that the container have used default constructor
    to define the values. Let''s prove it by adding default constructor in Car following
    code as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，容器使用了默认构造函数来定义值。让我们通过在Car中添加默认构造函数来证明它，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The updated output will be as shown in the below snapshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的输出将如下所示：
- en: '![](img/image_02_003.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: Using factory method
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工厂方法
- en: The bean is configured in the Spring container whose object is created through
    either instance or static factory method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring容器中配置的bean，其对象是通过实例或静态工厂方法创建的。
- en: Using instance factory method
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用实例工厂方法
- en: The instance creation will be done through a non static method of a bean. To
    use the method for instance creation an attribute ''factory-method'' has to be
    configured. Sometimes some other class may also be used to create the instance.
    The ''factory-bean'' attribute will be configured along with ''factory-method''
    to be used by the container for instance creation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实例创建将通过一个非静态bean的方法完成。要使用该方法进行实例创建，必须配置一个 ''factory-method'' 属性。有时，也可能使用其他类来创建实例。
    ''factory-bean'' 属性将与 ''factory-method'' 一起配置，以便容器用于实例创建。
- en: Let''s follow the steps to use factory-method for instance creation. We will
    use the same Ch02_Instance_Creation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤使用工厂方法进行实例创建。我们将使用相同的Ch02_Instance_Creation。
- en: 'Create class CarFactory in com.ch02.factory as shown in the code below:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.factory中创建一个名为CarFactory的类，代码如下：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `buildCar()` method will build an instance of Car and return it. Now the
    task of making the Container aware of using the above code will be done by the
    bean definition.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildCar()`方法将构建一个Car实例并返回它。现在，使容器了解使用上述代码的任务将由bean定义完成。'
- en: 'In instance.xml file add two beans, one bean for CarFactory and second for
    Car as shown below:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在instance.xml文件中添加两个bean，一个用于CarFactory，另一个用于Car，如下所示：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The attribute factory-method specifies `buildCar` as the method to be used from
    `car_factory` specified by factory-bean attribute to used for instance creation.
    No need to specify class attribute here.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 属性factory-method指定了`buildCar`作为从factory-bean属性指定的`car_factory`中用于实例创建的方法。这里不需要指定class属性。
- en: 'Create TestCarFactory with main function with the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建TestCarFactory带有main函数：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On the execution the following snapshot will be shown,
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，将显示以下快照，
- en: '![](img/image_02_004.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004.png)'
- en: Using static factory method
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用静态工厂方法
- en: We can define static method in the class which returns the object. The attribute
    'factory-method' is used to specify the method name who does instance creation.
    Let's use Ch02_Instance_Creation project to use factory-method attribute with
    the help of following steps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中定义静态方法，该方法返回对象。使用 'factory-method' 属性来指定进行实例创建的方法名称。让我们使用Ch02_Instance_Creation项目来使用factory-method属性，按照以下步骤进行。
- en: 'Create class CarService in com.ch02.service package as shown below:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.service包中创建一个名为CarService的类，如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the configuration in XML as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XML中添加以下配置：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The **'factory-method'** specifies the method who returns the instance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**''factory-method''**指定了返回实例的方法。'
- en: 'Write the test code in TestCarService as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TestCarService中编写测试代码，如下所示：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The execution of the code give the following output as snapshot shown below:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行后，将给出以下快照所示的输出：
- en: '![](img/image_02_005.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005.png)'
- en: 'Once the instance is created, now it''''s time to initialize the state. The
    Java developers initialization state as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实例创建完成后，现在是初始化状态的时候了。Java开发人员如下初始化状态：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, if we change the values of the data members the state also gets changed.
    So it''s pretty clear that the car is dependent on data member values. But as
    here we have set them the values are part of the code, any change in them need
    to change the code or redeployment of the code. In Dependency injection, the design
    is done in such a way that the object is achieved its state externally instead
    of hard coding them from a piece of the code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果我们改变了数据成员的值，状态也会随之改变。所以很明显，汽车依赖于数据成员的值。但因为我们已经设置了它们的值，它们是代码的一部分，任何更改都需要更改代码或重新部署代码。在依赖注入中，设计是以这种方式完成的，即对象
    externally 实现其状态，而不是从一段代码中硬编码它们。
- en: Dependency Injection
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '* * *'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Dependency Inversion Principle states two modules should not be tightly coupled
    with each other. The modules should be depends using abstraction where the details
    of dependency are not specified. Dependency Inversion Principle(DIP) helps in
    ensuring loosely coupled modular programming. Dependency Injection is the implementation
    of the DIP. To know what is dependency injection we first have to clearly understand
    what is dependency?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则指出两个模块之间不应该紧密耦合。模块应该通过抽象依赖，其中不指定依赖的详细信息。依赖倒置原则（DIP）有助于确保松耦合的模块化编程。依赖注入是DIP的实现。要了解什么是依赖注入，我们首先必须清楚地了解什么是依赖？
- en: The state of an object is given by the values of its data members. These data
    members as we all are aware can be of primitive or secondary type. If the data
    members are primitive they get their values directly and in secondary data type,
    the value is dependent on state of that object. That means whenever an object
    initialization happens the data member initialization plays a very important role.
    In other words we can say the data members are the dependency in object initialization.
    To insert or set the values of the dependency onto the object is Dependency Injection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态由其数据成员的值给出。正如我们所知，这些数据成员可以是原始类型或次要类型。如果数据成员是原始类型，它们直接获得它们的值，而在次要数据类型中，值依赖于该对象的状态。这意味着每当对象初始化发生时，数据成员初始化起着非常重要的作用。换句话说，我们可以说数据成员是对象初始化的依赖关系。将依赖关系的值插入或设置到对象中是依赖注入。
- en: The dependency injection helps in achieving loosely coupled architecture. The
    loose coupling helps in easy testing of the modules. The code and the values which
    the code uses are separated and can be controlled by central configuration, which
    make easy code maintenance. The code remains unaffected as the values are in external
    configuration making it easy to migrate with minimum changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入有助于实现松耦合的架构。松耦合有助于轻松测试模块。代码及其使用的值被分离，并可以通过中心配置来控制，这使得代码维护变得容易。由于值在外部配置中，代码不受影响，这使得迁移变得容易，且更改最小。
- en: In Spring framework the dependency injection can be achieved by,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，可以通过以下方式实现依赖注入：
- en: Setter injection
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器注入
- en: Constructor injection
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: The above two are the ways which we can use for DI but these can be achieved
    with number of ways which are
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上面提到的两种方法是我们可以用于DI的方式，但这些可以通过许多其他方式来实现，其中包括：
- en: XML based configuration
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML基础配置
- en: XML based configuration with namespace ''p''
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间 ''p'' 的XML基础配置
- en: Annotation based configuration
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解基础配置
- en: So let's start exploring them one by one
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始逐一探索它们
- en: XML based configuration
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML基础配置
- en: Setter Injection
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置器注入
- en: 'The dependencies of an object are fulfilled by the setter methods in setter
    injection. So the very important thing is when we do setter injection is to have
    a bean whose data members will be set through setter methods. The steps to use
    setter injection are:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的依赖关系通过setter注入中的setter方法来满足。因此，当我们进行setter注入时，非常重要的一点是要有一个bean，其数据成员将通过setter方法进行设置。使用setter注入的步骤如下：
- en: Declare a class and its properties using standard java naming convention.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的Java命名约定声明一个类及其属性。
- en: 'Configure the bean in bean definition XML as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下配置bean定义XML中的bean：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The bean in above configuration create the instance. It has to be updated to
    configure the properties.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的配置中的bean创建实例。它必须更新以配置属性。
- en: '* Each <property> tag will configure a data member'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '* 每个<property>标签将配置一个数据成员'
- en: '* Each <property> tag accepts two values'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '* 每个<property>标签接受两个值'
- en: '1\. name : The ''''name'''' attribute specifies the name of the data member
    whose value the developer wants to configure.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '1. name: ''''name''''属性指定了开发者想要配置的数据成员的名称。'
- en: '2\. value: The ''''value'''' specifies the value to be given to the data member.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '2. value: ''''value''''指定了要给数据成员的值。'
- en: 'The updated configuration will be as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的配置如下：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we have more than one data member whose values to set we need to use more
    than one <property> tags.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个数据成员的值需要设置，我们需要使用多个<property>标签。
- en: Get the bean from the Spring container and you are ready to use it.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Spring容器中获取bean，然后您就可以使用它。
- en: 'Let''''s first of all find out how to configure a bean with setter injection
    with the help of following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们找出如何通过以下步骤使用setter注入配置bean：
- en: Create Ch02_Dependency_Injection as Java project.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch02_Dependency_Injection作为Java项目。
- en: Add to it all core Spring jars which we already had used in previous chapter.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有我们在上一章中已经使用的核心Spring库。
- en: Create a class Car in com.ch2.beans. You can refer the code from previous project(Ch02_Instance_Creation).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch2.beans中创建一个Car类。您可以参考之前项目（Ch02_Instance_Creation）中的代码。
- en: '* As we are going to inject the dependencies using setter injection, create
    setter methods as well.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '* 由于我们打算使用setter注入来注入依赖项，因此也创建setter方法。'
- en: '* Add show() method as well.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '* 添加show()方法。'
- en: 'The code will be as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you should follow Bean naming convention whenever you create a class
    to configure in Spring Container.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在创建用于在Spring容器中配置的类时始终遵循Bean命名约定。
- en: 'The state of object can be obtained using getter methods. So normally the developers
    add both getters and setter. Adding getters always depends on business logic of
    the application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过getter方法获取对象的状态。因此，开发者通常会添加getter和setter。添加getter总是取决于应用程序的业务逻辑：
- en: 'Now we need to configure bean definition in beans.xml in classpath which represents
    a bean definition so that the bean will be managed by the Spring container. The
    configuration will be as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在classpath中的beans.xml中配置bean定义，表示一个bean定义，以便该bean将由Spring容器管理。配置如下：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the previous step, only instance has been created we now want to set the
    properties of it also, which is injecting dependencies using setter. The code
    will be as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步骤中，只创建了一个实例，现在我们想要设置它的属性，并通过setter注入依赖。代码如下：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we don't want to set the values of any dependency, the simple thing is not
    to add it in the configuration.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想设置任何依赖的值，简单的事情就是不在配置中添加它。
- en: 'Now we are ready to use the bean. We have to ask the container to give the
    object of the bean. Create class TestCar in default package with main function.
    We don''''t have to change anything in the main code which we already done in
    TestCar in Ch02_Instance_Creation due to externalization of dependencies the code
    remains intact. The code will look as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备使用bean。我们需要要求容器提供一个bean对象。在默认包中创建一个TestCar类，带有main函数。由于依赖的外部化，我们不需要更改已经在上面的TestCar中完成的main代码。代码如下：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On execution of the code we will get the following output:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码后，我们将得到以下输出：
- en: '![](img/image_02_006.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_006.png)'
- en: The values shown in the figure are the same which we set from the configuration.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图中所示的值与我们从配置中设置的相同。
- en: Constructor Injection
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: In constructor injection the dependencies will be fulfilled by parameters of
    the constructor or simple parameterized . Let''s develop an application to use
    constructor based dependency injection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数注入中，依赖关系将通过构造函数的参数或简单的参数化来实现。让我们开发一个应用程序来使用基于构造函数的依赖注入。
- en: 'Way 1: Without ambiguities'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 方法1：没有模糊性
- en: 'We will use the same project Ch02_Dependency_Injection with the help of following
    steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤的同一个项目Ch02_Dependency_Injection：
- en: 'Add a parameterized constructor to Car which has the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Car添加一个参数化构造函数，代码如下：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are adding parameterized constructor and you want to use both setter,
    as well as constructor injection, you must add default constructor
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了一个参数化构造函数，并且你想要同时使用setter和构造函数注入，你必须添加一个默认构造函数
- en: 'Add one more bean in beans.xml file but this time instead of using <property>
    tag we will use <constructor-arg> to use constructor DI. The code will look like:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在beans.xml文件中再添加一个bean，但这次我们不再使用<property>标签，而是使用<constructor-arg>来实现构造函数DI。代码如下：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a class TestCarConstructorDI in default package which will take Car
    object from container. The code will be as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认包中创建一个TestCarConstructorDI类，该类将从容器中接收Car对象。代码如下：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here the container is happy to have each parameters of constructor with distinguished
    data type. But same is not the case every time. We may come across the codes where
    the constructor will have more than one parameter which are ambiguous in their
    data types. Sometimes we do have more than one constructor in class and due to
    auto up casting the unexpected constructor may get invoked by container. It may
    also happen that developer just missed the order of arguments.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器对于每个参数具有不同的数据类型感到满意。但并非每次都是这样。我们可能会遇到构造函数具有多个模糊数据类型的代码。有时我们确实在类中有一个以上的构造函数，并且由于自动向上转型，容器可能会调用意外的构造函数。也可能会发生开发人员只是漏掉了参数的顺序。
- en: 'Way2: with ambiguities'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：带有模糊性
- en: 'Let''s add one more bean definition in the beans.xml as shown below:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在beans.xml中添加一个如下的bean定义：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The number of arguments are matching to the constructor definition but, the
    third argument instead of passing average we passed fuel_type value. Dont''t worry
    just continue your journey and have faith!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数量与构造函数定义相匹配，但第三个参数传递的是fuel_type值，而不是平均值。不用担心，继续你的旅程，保持信念！
- en: 'Create TestConstructor_Ambiguity to find what happens on mismatching arguments.
    The code is as shown below:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建TestConstructor_Ambiguity以找出参数不匹配时会发生什么。代码如下：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The execution of main function gives exception as shown in the snapshot below:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行main函数时会给出异常，如下快照所示：
- en: '![](img/image_02_007.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_007.png)'
- en: 'The underline line expressed the ambiguity of the values of arguments. We can
    have two Solutions as:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线行表达了参数值的歧义。我们可以有两个解决方案：
- en: '* You can change the order of configuration so as to match to the constructor
    argument.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以改变配置的顺序，以便与构造函数参数相匹配。**'
- en: '* Spring provides handy way by providing ''''index'''' attribute to resolve
    the order of constructor arguments.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring 通过提供“index”属性提供了便捷的方法来解决构造函数参数的顺序。**'
- en: One more way Spring gives to configure ''type'' attribute.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 给出的配置“type”属性的另一种方法。
- en: 'Let''s try out configuring ''''index'''' by updating bean definition from Step
    1 as shown below:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试通过更新 Step 1 的 bean 定义来配置“index”，如下所示：
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can find one more extra attribute we configure this time as ''index'' which
    will tell the container which value is for which argument. The ''index'' always
    starts with ''0''. We haven''t changed the order of the properties in configuration.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们这次配置了一个额外的属性作为“index”，这将告诉容器哪个值对应哪个参数。“index”总是从“0”开始。我们没有改变配置中属性的顺序。
- en: Run the same TestConstructor_Ambiguity. And you will get your instance without
    any problem.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行相同的 TestConstructor_Ambiguity。你将没有任何问题地得到你的实例。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Specifying the index is the safest way to overcome ambiguity but even we can
    specify ''type'' instead of index to overcome the situation. But if the constructor
    has more than one argument with the same data type ''type'' will not help us out.
    To use type in our previous code we need to change the bean definition in XML
    file as,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 指定索引是克服歧义的最安全方式，但即使我们可以用“类型”代替索引来解决问题。但是，如果构造函数有两个以上相同数据类型“类型”将无法帮助我们。要在我们的
    previous code 中使用 type，我们需要在 XML 文件中更改 bean 定义，如下所示：
- en: Here we have explored the way by which bean properties to set. But if you keenly
    observe all the properties which we set here are primitive but even we can have
    secondary data as data member. Let''s find out how to set the properties of secondary
    data type with the help of following demo.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们探讨了设置豆子属性的方法。但是，如果你敏锐地观察我们在这里设置的所有属性都是原始的，但我们甚至可以将次要数据作为数据成员。让我们找出如何借助以下示例来设置次要数据类型的属性。
- en: 'Let''''s develop an example of Customer who has Address as one of the data
    member. For better understanding follow the steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个 Customer 的示例，它有一个 Address 作为数据成员。为了更好地理解，请按照以下步骤操作：
- en: Create Java Application,''Ch02_Reference_DI'' and add to it the jars as we did
    in previous example.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Java 应用程序，“Ch02_Reference_DI”，并添加与之相关的 jar 文件，就像之前的示例一样。
- en: 'Create Address class in com.ch02.beans package having city_name, build_no,
    pin_code as data members. Add to it setter methods as well. The code will be as
    follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.beans 包中创建 Address 类，具有 city_name、build_no、pin_code 作为数据成员。也为它添加
    setter 方法。代码如下：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create Customer in com.ch02.beans package with cust_name, cust_id, cust_address.
    Add getter and setter methods. The code will as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.beans 包中创建 Customer，具有 cust_name、cust_id、cust_address。添加 getter 和
    setter 方法。代码如下：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can easily find that cus_address is of secondary data.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地发现 cus_address 是次要数据。
- en: For configuration create customer.xml in Classpath.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于配置，在 Classpath 中创建 customer.xml。
- en: 'We have two beans to be configured in the XML. First bean for Address and second
    for Customer. Let''''s first off all configure bean for Address as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XML 中我们需要配置两个 bean。第一个 bean 是 Address，第二个是 Customer。首先让我们如下配置 Address bean：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note the id for Address which we use here is ''cust_address''. But if you want
    you can use your own.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里使用的 Address 的 id 是“cust_address”，但如果你愿意，你可以使用自己的。
- en: 'Now, add the configuration for Customer as shown in the code below:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请按照以下代码添加 Customer 的配置：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The cust_id and cust_name will have the value attribute directly. But, the cust_address
    is not primitive so instead of using ''value'' as an attribute we need to use
    ''ref'' here.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: cust_id 和 cust_name 将直接具有值属性。但是，cust_address 不是原始数据，因此我们在这里需要使用“ref”而不是“value”作为属性。
- en: '* **ref**: The ''''ref'''' attribute is used to refer to the object we need
    to inject. The value of ''''ref'''' is value of ''''id'''' from the container.
    Here we use ref value as ''''cust_address'''' as we already had declared one bean
    with the similar id for the Address data type.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**ref**: “ref”属性用于引用我们需要注入的对象。 “ref”的值是容器中“id”的值。这里我们使用 ref 值作为“cust_address”，因为我们已经为
    Address 数据类型声明了一个具有相似 id 的 bean。'
- en: 'Now it''''s time to test how the code is working. Add TestCustomer in default
    package with main method to get object of Customer from the container with the
    help of following code:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是测试代码运行情况的时候了。在默认包中添加TestCustomer，带有main方法，使用以下代码从容器中获取Customer对象：
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of directly using data members developers normally invoke business logic
    method of the bean.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常会调用bean的业务逻辑方法，而不是直接使用数据成员。
- en: On execution we will get customer id and customer name on the console.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，我们将在控制台上得到客户id和客户名称。
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We even can use here constructor injection by adding parameterized constructor
    and using <constructor-arg> instead of <property>tag. As seen above the ''value''
    attribute has to be replaced by ''ref''. You can find the code from Customer_Constructor_DI.java
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在这里使用构造函数注入，通过添加参数化构造函数，并使用<constructor-arg>代替<property>标签。如上所述，'value'属性必须替换为'ref'。您可以从Customer_Constructor_DI.java找到代码。
- en: Namespace ''p'' for property
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间'p'用于属性
- en: 'In one of the previous example we had used <property>tag for injecting values
    of the properties in the instance. The framework have provided more sophisticated
    way and alternative for<property> with the help of ''''p'''' namespace. To use
    ''''p'''' namespace the developers have to add schema URI [http://www.springframework.org/schema/p](http://www.springframework.org/schema/p)
    in the configuration file as shown below:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的某个例子中，我们曾经使用<property>标签来注入属性的值。框架提供了更复杂且替代<property>的'p'命名空间方式。要使用'p'命名空间，开发者必须在配置文件中添加模式URI
    [http://www.springframework.org/schema/p](http://www.springframework.org/schema/p)，如下所示：
- en: '[PRE59]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The syntax to use ''''p'''' for setting the primitive values of the properties
    is:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用'p'设置属性基本值的语法如下：
- en: '[PRE60]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In case of setting more than one properties separate them with spaces.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 设置多个属性时，用空格将它们分隔开。
- en: 'The syntax changes for reference data types as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 引用数据类型的语法如下变化：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''''s use the new configuration in the XML. We will use the same project
    structure as that of Ch02_Dependency_Injection and just modify the beans.xml.
    Let''''s create a new application with the help of following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在XML中使用新的配置。我们将使用与Ch02_Dependency_Injection相同的项目结构，只需修改beans.xml。让我们按照以下步骤创建一个新的应用程序：
- en: Create a new Java Project named Ch02_DI_using_namespce and add the jars to it.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch02_DI_using_namespce的Java项目，并将其中的jar文件添加进去。
- en: Create or copy Car class in com.ch02.beans package. You can refer the code from
    Ch02_Dependency_Injection.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建或复制Car类。您可以参考Ch02_Dependency_Injection的代码。
- en: 'Create beans.xml file and update it for the declaration of namespace ''''p''''
    as shown above. The configuration file will be as shown below:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建beans.xml文件并更新它，以声明命名空间'p'，如下所示。配置文件将如下所示：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the bean definition using namespace ''p'' as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名空间'p'添加bean定义，如下所示：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Create class TestCar to get instance of Car from container and execute the code.
    You can refer to the same TestCar.Java from Ch02_Dependency_Injection project.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个TestCar类，以从容器中获取Car实例并执行代码。您可以参考Ch02_Dependency_Injection项目中的TestCar.Java。
- en: 'Once we know how to set primitives let''s do the coding for reference configuration
    as well. We will use the same DI_using-namespce project to develop the further
    code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何设置基本类型，接下来让我们也为引用配置编写代码。我们将使用同一个DI_using-namespce项目来开发后续的代码：
- en: Copy or Create class Address . (refer to the code from Ch02_Reference_DI) in
    com.ch02.beans package.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建Address类。（参考Ch02_Reference_DI中的代码）在com.ch02.beans包中。
- en: Copy or Create class Customer . (refer to the code from Ch02_Reference_DI) in
    com.ch02.beans package.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建Customer类。（参考Ch02_Reference_DI中的代码）在com.ch02.beans包中。
- en: Add a bean for Address using setter DI in bean.xml.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean.xml中使用setter DI添加一个Address bean。
- en: 'Add a bean for Customer using namespace ''''p'''' and the configuration will
    look like:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名空间'p'添加一个Customer的bean，配置将如下所示：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can observe here the customer address is not primitive so instead of using
    value we use reference as p:cust_address ="cust_address" where ''cust_address''
    is the id representing Address bean.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这里客户的地址不是基本类型，因此我们不是使用值，而是使用引用作为p:cust_address ="cust_address"，其中'cust_address'是表示Address
    bean的id。
- en: 'Create TestCustomer with main function containing the following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个TestCustomer类，其中包含以下代码：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The execution of code will show the following output:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码执行将显示以下输出：
- en: '![](img/image_02_008.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_008.png)'
- en: Configuring the inner beans
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置内部bean
- en: 'The bean definition file has more than one beans which are managed by the container.
    As we are well aware these beans are reusable by each other. At one point this
    reusability is amazing thing but along with it a problem comes. Let''s take an
    example of Customer''''s Address. The configuration can be done for Address as
    well as Customer. Can we use address bean for the another Customer? Yes, we can.
    But.....what if the Customer don''''t want to share his address and to keep it
    personal? With the current configuration it''''s not possible. But we can have
    an alternative configuration which gives the facility to keep the address personal.
    The configuration of customer bean from Ch02_Reference_DI can be modified for
    using inner as shown below:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: bean定义文件中有多个由容器管理的bean。我们都知道这些bean可以互相复用。这一点令人惊叹，但随之而来的问题是。让我们以顾客的地址为例。可以为地址和顾客进行配置。我们可以使用地址bean为另一个顾客吗？是的，我们可以。但是......如果顾客不想分享他的地址并将其保留为私人信息呢？当前的配置是不可能的。但我们有一个替代配置，可以保留地址的私人信息。从Ch02_Reference_DI中修改顾客bean的配置以使用内部如下：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The address bean is inner been whose instance will be created and wired with
    the address property of the Cutomer instance. This is similar to Java inner classes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 地址bean是一个内部bean，其实例将由Customer实例的address属性创建并连接。这与Java内部类相似。
- en: 'As setter injection supports inner beans, they are supported by the constructor
    injection as well. The configuration will be:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于setter注入支持内部bean，它们也由构造函数注入支持。配置如下：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can find the complete code in Ch02_InnerBeans project.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在中国 Ch02_InnerBeans 项目中找到完整的代码。
- en: Inheritance mapping
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承映射
- en: 'Inheritance is the major pillar of Java. Spring supports for bean definitions
    to configure in XML. The inheritance support is provided by ''''parent'''' attribute
    which says the missing properties can be used from the parent bean. Using ''''parent''''
    gives similarity with parent class in inheritance when we develop Java code. Even
    it''''s possible to override the properties from the parent bean. Let''s find
    out how to use practically with the help of following steps:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是Java的支柱。Spring支持在XML中配置bean定义。继承支持是由'parent'属性提供的，它表示缺少的属性可以从父bean中使用。使用'parent'在继承中开发Java代码时与父类相似。即使它也允许覆盖父bean的属性。让我们通过以下步骤找出如何实际使用：
- en: Create Ch02_Inheritance as Java project.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch02_Inheritance的Java项目。
- en: Add the jars.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加jar文件。
- en: 'Create class Student in com.ch02.beans package with following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建一个Student类，代码如下：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create class `EnggStudent` inherited from Student as:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建一个继承自Student的`EnggStudent`类：
- en: '[PRE69]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create the student.xml in classpath to configure bean for student as:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建student.xml，以配置student的bean，如下所示：
- en: '[PRE70]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now it''s time to configure bean for EnggStudent. First off all an ordinary
    configuration which we don''''t want to use:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在该为EnggStudent配置bean了。首先是一个我们不想要使用的普通配置：
- en: '[PRE71]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It''''s very clear that we repeated the configuration for rollNo and name.
    We don''''t have to repeat the configuration by configuring ''''parent'''' attribute
    as shown below:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们重复了rollNo和name的配置。我们不需要通过配置'parent'属性来重复配置，如下所示：
- en: '[PRE72]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Though here we skip configuring name and rollNo and reusing it from ''''student''''
    bean, it''''s possible to override any one of them as shown below:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里我们跳过了配置name和rollNo并从'student'bean中重用它，但如下所示，重写其中的任何一个都是可能的：
- en: '[PRE73]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The choice is yours, which one to use!!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你，使用哪一个！！
- en: 'Write TestStudent with main function as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有main函数的TestStudent如下：
- en: '[PRE74]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The below snapshot show the console output as follows:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的快照显示了控制台输出如下：
- en: '![](img/image_02_009.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_009.png)'
- en: 'The developers can able to obtain Student instance as well as EnggStudent.
    In some cases we don''''t want anybody to use Student instance or nobody should
    able to get Student instance. In such situations configure attribute ''''abstract''''
    on the bean whose instance developers don''''t want to make publically available.
    By default the value of abstract=false which states anybody can obtain instance
    of bean. We will configure abstract=""true"" making it unavailable. The updated
    configuration of the Student will be as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者可以获得Student实例以及EnggStudent实例。在某些情况下，我们不希望任何人使用Student实例，或者没有人应该能够获得Student实例。在这种情况下，在不想公开可用的bean实例上配置属性'abstract'。默认情况下，abstract的值为false，表示任何人都可以获得bean的实例。我们将配置abstract为"true"，使其不可用。Student的更新配置如下：
- en: '[PRE75]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, whenever someone ask for student bean BeanIsAbstractException will be
    thrown. You can try out the code by adding following lines in TestStudent:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，无论何时有人要求student bean，BeanIsAbstractException将被抛出。您可以通过在TestStudent中添加以下行来尝试代码：
- en: '[PRE76]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On execution we will get the following stack trace which specifies bean creation
    exception occur while obtaining Student bean:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行时，我们将得到以下堆栈跟踪，它指定了在获取Student bean时发生的bean创建异常：
- en: '![](img/image_02_010.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_010.png)'
- en: Configuring the null values
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置空值
- en: 'In Java unless if any the values of the data member is not set each will get
    their default ones. The reference properties will be defined as null and primitive
    integers to ''''0'''' respectively. These nulls later on will be overridden by
    the set values by either constructor injection or setter injection. It may also
    be possible that developers want to keep it null until some business logic won''t
    give the calculated value or get it from some external resource. Whatever the
    reason, we want to configure the value as null simply use ''''<null/>''''. The
    Customer''''s address will be set to null as shown below:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，除非任何数据成员的值没有被设置，否则每个都会得到它们的默认值。引用属性将被定义为null，基本整数属性将分别被设置为'0'。这些null稍后将通过构造函数注入或setter注入被覆盖。也可能是开发人员希望保持它为null，直到某些业务逻辑不会给出计算值或从某些外部资源获取它。无论什么原因，我们想要配置值为null，只需使用'<null/>'。如以下所示，将Customer的地址设置为null：
- en: '[PRE77]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can find the configuration in customer.xml of Ch02_InnerBeans.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Ch02_InnerBeans的customer.xml中找到配置。
- en: Up till now, we had seen the mapping of primitives, references, null or inner
    beans. We are more than happy, but wait a very important fundamental concepts
    of Java is Collection framework. Yes, we have to discuss mapping of collection
    as well.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了基本数据类型、引用、空值或内部bean的映射。我们非常高兴，但等待一个非常重要的Java基本概念——集合框架。是的，我们还需要讨论集合的映射。
- en: Configuring Collection
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置集合
- en: The Collection framework in Java facilitates handling objects to perform various
    operations as addition, removal, searching, sorting of objects in simplified way.
    The interfaces Set, List, Map, Queue are the interfaces has many implementation
    like HashSet, ArrayList, TreeMap, PriorityQueue and many more which gives means
    for handling data. We will not go in detail which one to choose for the operations
    but, we will be discussing different configurations supported by Spring in injecting
    the Collection.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的集合框架使得以简化方式处理对象以执行各种操作成为可能，如添加、删除、搜索、排序对象。Set、List、Map、Queue等接口有许多实现，如HashSet、ArrayList、TreeMap、PriorityQueue等，为处理数据提供了手段。我们不会详细讨论选择哪种操作，但我们将会讨论Spring支持的不同配置，以注入集合。
- en: '**Mapping List**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射列表**'
- en: 'List is ordered collection which offers handling of data in order of data insertion
    . It maintains the insertion, removal, fetching of data by indices where duplicate
    elements are allowed. ArrayList, LinkedList are some of its implementations. The
    framework supports List configuration with help of <list> tag. Let''''s develop
    an application to configure List by following steps:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的集合，它按数据插入顺序处理数据。它维护插入、删除、通过索引获取数据，其中允许重复元素。ArrayList、LinkedList是其一些实现。框架支持使用<list>标签配置List。让我们按照以下步骤开发一个应用程序来配置List：
- en: Create Ch02_DI_Collection as Java project and add Spring jars to it.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch02_DI_Collection作为Java项目，并添加Spring jars。
- en: Create POJO class Book in com.ch02.beans package.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建一个POJO类Book。
- en: '* Add isbn, book_name,price and publication as data members.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '* 添加isbn、book_name、price和publication作为数据成员。'
- en: '* Add default and parameterised constructors.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '* 添加默认和参数化构造函数。'
- en: '* Write .getter and setter methods.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '* 编写.getter和setter方法。'
- en: '* As we are handling collection add `equals()` and `hashCode()`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '* 由于我们正在处理集合，所以添加`equals()`和`hashCode()`'
- en: '* To display object add `toString()`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '* 为了显示对象，添加`toString()`'
- en: The Book will be as shown in the code below,
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的内容将如下面的代码所示，
- en: '[PRE78]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create Library_List in com.ch02.beans who has List of Books. Write displayBooks()
    to display list of the books. The code will be as:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans中创建Library_List，它有一个Book列表。编写displayBooks()以显示书籍列表。代码将是：
- en: '[PRE79]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create books.xml in ClassPath. Add to it four Book beans. I am trying following
    three configurations:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ClassPath中创建books.xml，并向其中添加四个Book bean。我尝试了以下三种配置：
- en: '* book bean with setter DI.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用setter DI创建book bean。'
- en: '* book bean with constructor DI.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用构造函数DI创建book bean。'
- en: '* book bean using ''''p'''' namespace.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用''''p''''命名空间创建book bean。'
- en: 'No need to try out all combination, you can follow any one of them. We already
    have used all of them in the previous Demos. The configuration will be as shown
    below:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 无需尝试所有组合，你可以跟随其中任何一个。我们已经在之前的演示中使用了它们全部。配置将如下所示：
- en: '[PRE80]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Intentionally the fourth book is second copy of one of the first three books,
    we in couple of steps discover the reason. Just wait and watch!!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 故意第四本书是前三本书中的其中一本的第二份，我们在接下来的几个步骤中发现原因。敬请期待！
- en: 'Add a Library bean with <list> configuration as:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 <list> 配置中添加一个 Library bean：
- en: '[PRE81]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The <list> contains list of <ref> of the beans to be injected for list of books
    where 'book1','book2','book3','book4' are the id's of beans which we created in
    Step 4.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: <list> 包含 <ref> 的列表，用于注入书的列表，其中 'book1'、'book2'、'book3'、'book4' 是我们在第 4 步创建的
    bean 的 id。
- en: 'Create TestLibrary_List with main function to get instance of Library and list
    of Books it has. The code is as follows:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 main 函数的 TestLibrary_List 以获取 Library 实例和它包含的 Book 列表。代码如下：
- en: '[PRE82]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Execute it to get the output displaying list of books. Find last two entries
    which indicate List allows duplicate elements:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行它以显示书目列表的输出。找到最后两个条目，这表明 List 允许重复元素：
- en: '![](img/image_02_011.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_011.png)'
- en: '**Mapping Set**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射集**'
- en: 'The Set interface is an unordered collection, which doesn''''t allow duplicate
    entries in the collection. HashSet, TreeSet are the implementations of Set. Spring
    provides <set> tag to configure Set. Let''''s use Ch02_DI_Collection project to
    add Set of Books by following steps:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Set 接口是一个无序集合，该集合不允许集合中有重复条目。HashSet、TreeSet 是 Set 的实现。Spring 提供了 <set> 标签来配置
    Set。让我们使用 Ch02_DI_Collection 项目按照以下步骤添加书的 Set：
- en: 'Add Library_Set class in com.ch02.beans package and declare Set of Books as
    Data member. Add getters and setters for it. The code is as shown below:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.beans 包中添加 Library_Set 类并声明 Set 的书作为数据成员。为它添加 getter 和 setter。代码如下所示：
- en: '[PRE83]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add a bean for Library_Set in beans.xml with <set> configuration as shown below:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 beans.xml 中为 Library_Set 添加一个 bean，并使用如下 <set> 配置：
- en: '[PRE84]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create TestLibrary_Set with main function as shown below:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 main 函数的 TestLibrary_Set，如下所示：
- en: '[PRE85]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output of execution is as shown below:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行结果如下所示：
- en: '![](img/image_02_012.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_012.png)'
- en: We injected four objects of books but got only three in output so it''s crystal
    clear that Set doesn''t allow duplicates.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入了四本图书的对象，但输出中只有三本，所以很明显 Set 不允许重复项。
- en: '**Mapping Map**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射 Map**'
- en: Map handles collection of objects having key and value pair. Map can have duplicate
    values but duplicate keys are not allowed. It has implementations as `TreeMap`,
    `HashMap` and `LinkedHashMap`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Map 处理具有键值对的对象集合。Map 可以有重复的值，但不允许重复的键。它的实现包括 `TreeMap`、`HashMap` 和 `LinkedHashMap`。
- en: 'Let''''s explore configuring Map with the help of following steps:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤探索配置 Map：
- en: We will use the same Ch02_DI_Collection project. Create class Library_Map in
    com.ch02.beans package.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用同一个 Ch02_DI_Collection 项目。在 com.ch02.beans 包中创建 Library_Map 类。
- en: 'Add|Map<String,Book> books as data member in it along with getters and setters.
    Don''''t forget to add `displayBooks()` in it. The code will be as shown below:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加一个 `<Map<String,Book>` 类型的 `books` 数据成员，并添加相应的 getter 和 setter。不要忘记在其中添加
    `displayBooks()`。代码如下所示：
- en: '[PRE86]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Configure the Map in beans.xml as shown below:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下配置 Map 在 beans.xml 中：
- en: '[PRE87]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Unlike List and Set the Map will take extra attribute of ''key'' to specify
    the key. We used here name of the book as key but if you want you can declare
    something else as well. Just don''''t forget that key is always unique in Map:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 与 List 和 Set 不同，Map 需要一个额外的 'key' 属性来指定键。我们这里用书名作为键，但如果你愿意，也可以声明其他东西。只是不要忘记在
    Map 中键总是唯一的：
- en: 'Write TestLibrary_Map with main function as follows:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像下面这样编写 TestLibrary_Map 主函数：
- en: '[PRE88]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Execute the code to get book details displayed on console.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码以在控制台上显示书目详情。
- en: 'Here we configure single object as per entry. But in practice an entry may
    contain List or Set of books. In such cases instead of having <entry> with ''''value-ref''''
    the configuration will contain <entry> with <list> as shown below:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们为每个条目配置单个对象。但在实际中，一个条目可能包含 List 或 Set 的书。在这种情况下，配置将包含 <entry> 与 <list> 如下：
- en: '[PRE89]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the above configuration each ''entry'' has name of books containing ''<list>''
    of books which is but obvious if we are talking about Library of books. The complete
    code of Library_Map1.java and TestLibrary_Map1.java can be refer from Ch02_DI_Collection.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，每个 ''条目'' 都有一个包含 ''<list>'' 的书名，这显然是我们谈论的是图书目录。Library_Map1.java 和 TestLibrary_Map1.java
    的完整代码可以在 Ch02_DI_Collection 中查阅。
- en: '**Mapping Properties**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射属性**'
- en: Properties also hold the collection of elements in key-value pair, but unlike
    Map here the key and value both are of String types only. The Properties can be
    saved or read from stream.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也包含键值对的集合，但与Map不同，这里键和值都是String类型。属性可以从流中保存或读取。
- en: 'Let''''s consider a Country who has multiple States as Properties. Follow the
    steps to find out how to configure Properties in `beans.xml`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个拥有多个州作为属性的国家。按照以下步骤找出如何在`beans.xml`中配置属性：
- en: Create a class Country in com.ch02.beans package.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建一个Country类。
- en: 'Declare name, continent and state_capital as data members. Add getters and
    setters as well. To display state capitals add printCapital(). The code is as
    shown below:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将name, continent和state_capital声明为数据成员。添加getters和setters。为了显示州首府，添加printCapital()。代码如下所示：
- en: '[PRE90]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In beans.xml configure the definition of Country as shown below:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在beans.xml中如下配置Country的定义：
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The 'state_capitals' contains '<props>' configuration to hold name of state
    as 'key' and its capital as 'value'.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '''state_capitals''包含`<props>`配置，以''key''状态名称和''value''其首府作为键值对。'
- en: Write TestProperties with main function having the below code,
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有以下代码的TestProperties主函数，
- en: '[PRE92]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output will be as shown in the snapshot:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如快照所示：
- en: '![](img/image_02_013.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_013.png)'
- en: 'The ''util'' namespace provides a means to the developers for configuring collections
    in XML file elegantly. Using ''util'' namespace one can configure List, Map,Set,
    Properties. To use ''''util'''' namespace the schema has to updated for [www.springframework.org/schma/util](http://www.springframework.org/schma/util)
    URI as shown in snapshot below:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '''util''命名空间为开发者在XML文件中优雅地配置集合提供了一种手段。使用''util''命名空间，可以配置List、Map、Set、Properties。要使用''util''命名空间，必须更新[www.springframework.org/schma/util](http://www.springframework.org/schma/util)
    URI的架构，如下快照所示：'
- en: '![](img/image_02_014.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_014.png)'
- en: The underlined lines have to be added for suing 'util' namespace in the configuration.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的行必须添加以在配置中使用'util'命名空间。
- en: 'The configuration of List using ''''util'''' namespace will be as shown below:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用''util''命名空间的List配置将如下所示：
- en: '[PRE93]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can find the updated configuration in books.xml.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在books.xml中找到更新的配置。
- en: We know how to get the bean and how to fulfill different types of dependencies
    it has. The bean configuration defines the way by which instances created and
    its state will be defined by injecting the dependencies. At any point of time
    for business logic requirement the state of bean can be changed. But we yet don''t
    know how many instances Spring container creates or what if developers want single
    instance to serve every request? Or what is every operation needs different instances.
    Actually we are talking about ''scope''
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何获取bean以及如何满足它具有的不同类型的依赖关系。bean配置定义了实例的创建方式及其状态将由注入依赖项来定义。在任何时刻，根据业务逻辑需求，bean的状态可以更改。但我们还不知道Spring容器创建了多少实例，或者如果开发者希望每个请求都使用单个实例该怎么办？或者每个操作都需要不同的实例。实际上我们在谈论“作用域”
- en: Bean Scope
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Bean作用域
- en: The scope of bean defines how many instances will be created by the Spring container
    and make it available for application to use. Use ''scope'' attribute of <bean>
    to provide information about number of instances. We cannot move before discovering
    the default process of creating and providing instances. It will make the term
    ''scope'' clear as well it will define why understanding 'scope' is so important.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: bean的作用域定义了Spring容器将创建多少实例，并使其可供应用程序使用。使用`<bean>`的`scope`属性提供关于实例数量的信息。在了解创建和提供实例的默认过程之前，我们无法前进。这将使“作用域”一词变得清晰，并且还将定义为什么理解“作用域”如此重要。
- en: Let''s use Ch02_Dependency_Injection project to find how many instances the
    container creates by default. You can use the same project or can create a new
    copy of it as we are doing in following steps.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Ch02_Dependency_Injection项目来找出容器默认创建多少实例。您可以使用同一个项目，或者可以创建一个新的副本，如下步骤所示。
- en: Create Ch02_Bean_Scope as Java project.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch02_Bean_Scope作为Java项目。
- en: Add Spring jars to it.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加Spring jar。
- en: Create or copy Car in com.ch02.beans package.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans包中创建或复制Car类。
- en: Create beans.xml in class path and configure ''car'' bean as shown below,
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建beans.xml，并如下配置'car' bean，
- en: '[PRE94]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The scope is no where related to how the bean has been configured.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域与bean是如何配置的无关。
- en: 'Create TestCar to request for ''car'' bean twice as shown below. Don''t be
    surprise. We want to find out how many instances created. So let''s start:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建TestCar以如下的方式请求两次'car' bean。不要感到惊讶。我们想找出创建了多少实例。所以让我们开始吧：
- en: '[PRE95]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The execution of the code will give the following output,
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行将给出以下输出，
- en: '![](img/image_02_015.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_015.png)'
- en: Yes both the object has the same value. And why not? We configure them in XML.
    This won''t lead us to any conclusion. Let''s move ahead for second step.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，两个对象有相同的值。为什么不呢？我们在XML中配置它们。这不会导致我们得出任何结论。让我们进行第二步。
- en: '* Use the same TestCar code but, this time change the state of any one car
    object. We will change for ''''car_one'''' and observe what happens to car_two?
    Will car_two contains changed values or configured values ? The changed code will
    be as below:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用相同的TestCar代码，但这次改变任意一个car对象的状态。我们将为“car_one”进行更改，并观察car_two会发生什么？car_two将包含更改后的值还是配置的值？更改后的代码如下：'
- en: '[PRE96]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: On execution you will get the following out put.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，你将得到以下输出。
- en: '![](img/image_02_016.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_016.png)'
- en: We just changed state of car_one but the output shows even state of car_two
    got changed which proves no matter how many time you ask the container for the
    instance every time the same instance will be given back to us.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是改变了car_one的状态，但输出显示car_two的状态也发生了变化，这证明无论你多少次向容器请求实例，每次都会返回同一个实例。
- en: Note
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '''''singleton'''' is the default scope of bean means a single instance per
    Spring container.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleton`是bean的默认作用域，意味着每个Spring容器有一个实例。'
- en: '* Keep TestCarNew as it is and configure ''''scope'''' attribute in car bean
    as shown below,'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '* 保持TestCarNew不变，并在car bean中配置`scope`属性，如下所示，'
- en: '[PRE97]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Execute TestCarNew and you will get the following output:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 执行TestCarNew，你将得到以下输出：
- en: '![](img/image_02_017.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_017.png)'
- en: The output shows change state of car_one doesn''t change state of car_two. Which
    means, on every request for instance of car from the container, the container
    creates and give a new instance.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，car_one的状态变化不会改变car_two的状态。这意味着，每次从容器中请求car实例时，容器都会创建并给予一个新的实例。
- en: Note
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '''''prototype'''' specifies a new instance per request for instance from the
    container.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype`指定每次从容器请求实例时都创建一个新的实例。'
- en: The following are few more scopes given by Spring framework,
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些由Spring框架给出的作用域，
- en: '**request** : By default in web application all HTTP request get served by
    the same instance which may lead to the problems in handling data or consistency
    of data. To make sure each request get its own new fresh instance ''''request''''
    scope will be helpful.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：在Web应用程序中，默认情况下所有HTTP请求都由同一个实例处理，这可能导致处理数据或数据一致性问题。为了确保每个请求都能获得自己全新的实例，请求作用域将会有帮助。'
- en: '**session**: We are well aware of handling session in web application. ''''request''''
    creates instance per request but when multiple request are bound to the same session
    then instance per request become clumsy and so do managing the data. The ''''session''''
    scope is the rescue in such situation where the developers needs instance per
    session.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：我们很清楚在Web应用程序中处理会话。每个请求创建一个实例，但当多个请求绑定到同一个会话时，每个请求的实例变得杂乱无章，管理数据也是如此。在需要按会话创建实例的情况下，会话作用域是拯救之策。'
- en: '**application**: Each web application has its own ServletContext. The ''''application''''
    scope creates instance per ServletContext.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：每个Web应用程序都有自己的ServletContext。应用程序作用域创建每个ServletContext的实例。'
- en: '**globalSession**: In protletContext the Spring configuration provides instance
    per global HTTPSession.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局会话**：在protletContext中，Spring配置提供每个全局HTTPSession的实例。'
- en: '**websocket**: The ''''websocket'''' scope specifies instance creation per
    WebSocket''''.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSocket**：WebSocket作用域指定每个WebSocket创建一个实例。'
- en: Annotation Based Configuration
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于注解的配置
- en: From Spring 2.5 onwards Spring started supporting Annotation based configuration.
    We already have discussed the concepts in Java and how to configure them in XML?
    While doing the annotation based configuration we come across two types of configuration
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring 2.5开始，Spring开始支持基于注解的配置。我们已经讨论了在Java中的概念以及如何在XML中进行配置？在执行基于注解的配置时，我们会遇到两种类型的配置
- en: Spring based annotations
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Spring的注解
- en: JSR based annotations.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于JSR的注解。
- en: Spring based annotations
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于Spring的注解
- en: 'Number of annotations has been provided by Spring which may be categories as
    managing life cycle, creating bean instance, wiring annotations any many more.
    Let''''s find them one by one. But before that we need to know one very important
    thing. The bean definition has to be registered by configuring it in XML. Now
    to have annotation based configuration the bean registration has to be done using
    context namespace as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了许多注解，可以分为管理生命周期、创建bean实例、注解配置等类别。让我们逐一找到它们。但在那之前，我们需要知道一个非常重要的事情。bean定义必须通过在XML中配置来注册。现在，为了实现基于注解的配置，bean注册必须使用context命名空间如下进行：
- en: '[PRE98]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `<context:annotation-config/>` asks the container to consider the annotations
    on the bean.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`<context:annotation-config/>` 使容器考虑bean上的注解。'
- en: Instead of the above configuration one can even go with the following configuration,
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: instead of the above configuration one can even go with the following configuration,
- en: '[PRE99]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Let us start with using annotations one by one for different scenarios as follows,
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始逐一使用注解来处理不同的场景，如下所示，
- en: Stereotype annotations
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注解配置
- en: 'These annotations are class level annotations which get registered with Spring
    container. The following figure shows stereotype annotations:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注解是类级注解，它们与Spring容器一起注册。以下图表显示了典型注解：
- en: '![](img/image_02_018.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_018.png)'
- en: 'Let''''s use @Component in the application. We will use Ch02_Reference_DI as
    base project and use the following steps:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中使用@Component注解。以 Ch02_Reference_DI 为基础项目，按照以下步骤操作：
- en: Create Ch02_Demo_Annotation and all the jars which we have added earlier , along
    with them add spring-aop.jar to it as well.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Ch02_Demo_Annotation 文件夹以及我们之前添加的所有jar文件，然后将 spring-aop.jar 也添加进去。
- en: Create or copy Address.java in com.ch02.beans package.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.beans 包中创建或复制 Address.java 文件。
- en: Create or copy Customer.java in com.ch02.stereotype.annotation package. Rename
    it to Customer_Component.java
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.stereotype.annotation 包中创建或复制 Customer.java 文件。将其重命名为 Customer_Component.java
- en: 'Add to it default constructor as the code we are refereeing is not having any
    default constructor. The code can be as below:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其添加默认构造函数，因为我们要参考的代码中没有默认构造函数。代码可以如下所示：
- en: '[PRE100]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Annotate the class with @Component as shown below:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式用 @Component 注解类：
- en: '[PRE101]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here we had configured a component which is auto scanable. By default the id
    of this component will be decaptitalized class name. In our case it''s ''customer_Component''.
    If we want to use customized id we can modify the configuration to use ''myObject''
    as bean id will be,
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们配置了一个可自动扫描的组件。默认情况下，这个组件的id将是首字母小写的类名。在我们的例子中是 ''customer_Component''。如果我们想要使用自定义的id，我们可以修改配置以使用
    ''myObject'' 作为bean id，
- en: '[PRE102]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: And there is no need to configure it in XML as we did earlier. But we still
    need XML for some other configurations.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中配置它是不必要的，正如我们之前所做的那样。但是我们仍然需要XML来进行一些其他配置。
- en: Create or copy customer.xml in classpath.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建或复制 customer.xml 文件。
- en: 'Add the following code to consider the annotations:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以考虑注解：
- en: '[PRE103]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We already had seen how to configure ''context'' namespace.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何配置“context”命名空间。
- en: 'Create TestCustomer_Component to get the bean of Customer_Component as show
    below to find out what is the out put of our configuration:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 TestCustomer_Component 组件以获取 Customer_Component 组件的bean，如下所示，以找出我们配置的输出是什么：
- en: '[PRE104]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: On execution we will get the following stack trace of exception,
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将得到以下异常堆栈跟踪，
- en: '[PRE105]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If we did everything then why we still are getting exception. The reason made
    component auto scan able but forgot to tell the container where to scan for annotations?
    Let''''s configure where to scan for components as:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已经做了所有的事情，为什么我们仍然得到异常。原因是使组件自动扫描可用，但忘记告诉容器在哪里扫描注解？让我们配置在哪里扫描组件：
- en: '[PRE106]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here all the subpackages of com.ch02.streotype will be scanned to find out bean
    having id as ''customer_Component''.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将扫描 com.ch02.streotype 的所有子包，以查找具有 ''customer_Component'' id 的bean。
- en: 'After adding the configuration we will get the following out put displaying
    the data member values as:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加配置后，我们将得到以下输出，显示数据成员值：
- en: '[PRE107]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In the same way we can use the other annotations but we will discuss them one
    by one in the upcoming chapters.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用其他注解，但我们将逐一在接下来的章节中讨论它们。
- en: Wiring annotations
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注解配置
- en: We already had discussed in depth about ''auto wiring'' which gives us the facility
    to reduce the configuration and automatically discover which object to inject
    as the dependency in the bean. Following are the annotations which help in auto
    wiring and to sort out the problems which occur in auto wiring.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入讨论了 ''auto wiring''，它为我们提供了减少配置和自动发现要注入哪个对象作为 bean 依赖项的便利。 以下是帮助自动注入和解决自动注入问题的注解：
- en: '![](img/image_02_019.png)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_019.png)'
- en: Let''s use Cho2_Demo_Annotation project to demonstrate the above annotations.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Cho2_Demo_Annotation 项目来演示上述注解。
- en: Case1\. Using @Autowired
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Case1. 使用 @Autowired
- en: Create class Customer_Autowired in com.ch02.autowiring.annotation. This is similar
    to Customer_Component which we has created in stereotype annotations. Don''t forget
    to add default customer if you don''t have one.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch02.autowiring.annotation 中创建 Customer_Autowired 类。这与我们之前在 stereotype
    annotations 中创建的 Customer_Component 类似。如果你没有默认客户，不要忘记添加。
- en: 'Add @Autowired annotations on the field cust_address as shown below:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在如下所示的 cust_address 字段上添加 @Autowired 注解：
- en: '[PRE108]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In customer_new.xml configure a bean for Address as shown below,
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 customer_new.xml 中如下配置 Address bean：
- en: '[PRE109]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create TestCustomer_Autowired to get the bean with ''''customer_Autowired''''
    as id:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 TestCustomer_Autowired 以获取 id 为 ''customer_Autowired'' 的 bean：
- en: '[PRE110]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We will get the following console output on execution:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行时，我们将得到以下控制台输出：
- en: '[PRE111]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Case2\. Using autowired=false
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Case2. 使用 autowired=false
- en: Whatever the care developers take we always come across scenarios where the
    dependency is not available or doesn''t get injected due to some reason. It''s
    quite obvious to get exception here. In order to get rid of such forceful injection
    add `'autowired=false`' to `@Autowired`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开发者多么小心，我们总是遇到依赖项不可用或由于某种原因而没有注入的情况。 这里出现异常是很明显的。 为了摆脱这种强制注入，请将 `'autowired=false`'
    添加到 `@Autowired`。
- en: 'You can try this out by deleting cust_address from customer.xml in previous
    project. On execution of main we will get exception as:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过删除 customer.xml 中的 cust_address 来尝试这个，运行主程序我们将得到异常：
- en: '[PRE112]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Change @Autowired annotation to:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 @Autowired 注解更改为：
- en: '[PRE113]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Again rerun main where we get the following output:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重新运行主要功能，我们得到以下输出：
- en: '[PRE114]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The value null denotes no address has been injected but we haven''t got any
    bean creation exception here.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: null 值表示没有注入地址，但我们这里没有bean创建异常。
- en: Note
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once you finished the demonstration of required=false undo all the changed we
    just made in this demo.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 required=false 的演示，请撤销我们在这个演示中刚刚所做的所有更改。
- en: Case3\. Using @Qualifier
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Case3. 使用 @Qualifier
- en: 'In some situations we may have more than one bean of the same type configures
    in the container. To have more than one bean is not a problem unless developers
    control the dependency injection. It may also be possible to have different id
    of the dependency and having more than one bean of the same type but none of the
    id is matching. Let''''s use `@Qualifier` to overcome these problems. We will
    use the same class `Customer_Autowired` from previous step:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能容器中配置了同一类型的多个 bean。 有一个以上的 bean 不是一个问题，除非开发者控制依赖注入。 也可能有不同 id 的依赖项，以及同一类型的多个
    bean，但没有匹配的 id。 让我们使用 `@Qualifier` 来解决这些问题。 我们将使用上一步骤中的相同类 `Customer_Autowired`：
- en: Rename the id of bean cust_address to cust_address1 which we created earlier.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前创建的 bean cust_address 的 id 重命名为 cust_address1。
- en: 'Add one more bean of type Address in it as shown below:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像下面这样添加一个 Address 类型的另一个 bean：
- en: '[PRE115]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create TestCustomer_Autowiring1 to get the customer instance as shown below:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 TestCustomer_Autowiring1 以获取以下所示的客户实例：
- en: '[PRE116]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'On execution we will get the following exception specifying there are multiple
    instances of type Address available for injection leading to ambiguity:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行时，我们将得到以下异常，指定存在多个可注入的 Address 实例，导致不明确性：
- en: '[PRE117]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Update the annotation of data member cust_address with @Qualifier as shown
    below:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据成员 cust_address 的注解为 @Qualifier，如下所示：
- en: '[PRE118]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We are specifying the id of bean which we want to inject to fulfill the dependency.
    In our case the bean whose id is ''address'' will be injected.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定要注入以满足依赖关系的 bean 的 id。 在我们的案例中，id 为 ''address'' 的 bean 将被注入。
- en: 'Execute main function which we had created in step 2 to get the following output
    which shows beans with id as ''address'' gets injected in `Customer_Autowried`:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们在第 2 步创建的主要功能，以获得以下输出，显示 id 为 'address' 的 bean 注入到 `Customer_Autowried`
    中：
- en: '[PRE119]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Case 3\. Using @Required
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Case 3. 使用 @Required
- en: While developing the code the business logic will fail if the correct values
    have not been provided or if those are absent. So it''s must to have dependency
    injected and whatever happened it should not be failed. To make sure the dependency
    has been injected and ready for use apply `@Required` after `@Autowired` annotation.
    It works in the same way '`autowired=true`'. But in contrast to it, the annotation
    can be applied only to the setter methods. If the dependency is not available
    `BeanInitializationException` will be thrown.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，如果未提供正确值或缺少这些值，业务逻辑将失败。因此，必须注入依赖项，无论如何都不能失败。为确保已注入依赖项并准备好使用，请在`@Autowired`注解之后应用`@Required`。它的工作方式与'`autowired=true`'相同。但与它相比，注解只能应用于setter方法。如果依赖项不可用，将抛出`BeanInitializationException`。
- en: 'Following is the code which gives the clear understanding of the use of `@Required`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清楚地说明了`@Required`的使用：
- en: '[PRE120]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Case 4 Scope management annotations
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 案例4：作用域管理注解
- en: Few pages back we had discussed in depth about the scopes and their use. We
    also had seen how to manage scope according to the requirements in the XML. Usually
    the `@Scope` is class level annotation. But it also can be used with Bean annotation
    to a method which indicates the Scope of the instance returned from it.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 几页前我们深入讨论了作用域及其使用。我们还看到了如何在XML中根据需求管理作用域。通常`@Scope`是类级注解。但它也可以与Bean注解一起使用，指示返回实例的作用域。
- en: 'Following is the code indicates use of @Scope:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示使用@Scope：
- en: '[PRE121]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You can use the following code to check whether each time a new instance is
    been provided or not:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码来检查每次是否提供了新的实例：
- en: '[PRE122]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You can refer the complete code form Ch02_Demo_Annotation.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考Ch02_Demo_Annotation中的完整代码。
- en: JSR standard Annotation
  id: totrans-579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSR标准注解
- en: The Spring 2.5 supports JSR-250 and 3.0 onwards the framework started supporting
    JSR-330 standard annotations whose discovery is been done in the same way as that
    of Spring based annotations. JSR provides annotations for lifecycle management,
    bean configuration, auto wiring and for many more such requirements. Let's discuss
    them one by one.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 2.5支持JSR-250，而从3.0开始，框架开始支持JSR-330标准注解，其发现方式与基于Spring的注解相同。JSR提供了用于生命周期管理、bean配置、自动注入和许多其他需求的注解。让我们逐一讨论它们。
- en: Annotations for Life cycle
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生命周期注解
- en: We had discussed enough about the life cycle of a bean and what are different
    ways to achieve it by XML configurations? But we haven''t discussed about annotation
    based. Spring 2.5 onward support the life cycle management by `@PostConstruct`
    and `@PreDestroy` which gives an alternative to `InitializingBean` and Disposable
    interfaces respectively.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经足够讨论了bean的生命周期以及通过XML配置实现它的不同方式。但我们还没有讨论基于注解的。从Spring 2.5开始，支持通过`@PostConstruct`和`@PreDestroy`进行生命周期管理，分别提供了`InitializingBean`和Disposable接口的替代方案。
- en: '**@PostConstruct:**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**@PostConstruct：**'
- en: The method which has been annotated with @PostConstruct get called after the
    bean which has been instantiated using the default constructor by the container.
    This method is called just before the instance is returned.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 被@PostConstruct注解标注的方法将在容器使用默认构造函数实例化bean之后调用。这个方法在实例返回之前调用。
- en: '**@PreDestroyed:**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**@PreDestroyed：**'
- en: The method annotated with @PreDestroy will be invoked just before the bean is
    getting destroyed which allows taking the values back up of the values from the
    resource which may get lost if the object is destroyed.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 被@PreDestroy注解标注的方法将在bean被销毁之前调用，这允许从可能因对象销毁而丢失的资源中恢复值。
- en: 'Let''''s follow the steps to use it to understand bean lifecycle:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤使用它来了解bean的生命周期：
- en: In Ch02_Bean_Life_Cycle java project which we already had used while discussing
    bean life add Car_JSR class in com.ch02.beans package.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们已经在使用讨论bean生命周期的Ch02_Bean_Life_Cycle java项目中添加Car_JSR类，位于com.ch02.beans包中。
- en: 'Add a method init_car for initiliazation of Car and annotate it with @PostConstruct
    as shown below:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Car类中添加一个init_car方法用于初始化汽车，并用@PostConstruct注解标注，如下所示：
- en: '[PRE123]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Add to the class a method which will has the code of destruction of car which
    is nothing but resource release as shown below:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个方法，该方法包含汽车销毁的代码，这实际上是资源释放，如下所示：
- en: '[PRE124]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Add beans_new.xml to configure the bean and don''''t forget the rule of using
    annotations in the application. The XML will look like:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加beans_new.xml以配置bean，不要忘记在应用程序中使用注解的规则。XML将如下所示：
- en: '[PRE125]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Add a main method in TestCar as shown below:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TestCar中添加一个main方法，如下所示：
- en: '[PRE126]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'On execution of the code we will get the following out put which shows the
    init_car() got invoked:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码后，我们将得到以下输出，显示调用了init_car()：
- en: '[PRE127]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'As the destroy method will get after context got switch the output will not
    be shown on console. We can use the following code to elegantly shut down of the
    container:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于销毁方法将在上下文切换后执行，所以控制台上将不会显示输出。我们可以使用以下代码优雅地关闭容器：
- en: '[PRE128]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**@Named**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**@Named**'
- en: '@Named annotation is used instead of @Component which is applied to the class
    level. @Named annotation doesn''''t provide composable model but the scanning
    of it is in the same way as that of @Component:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Named`注解用于代替应用于类级别的`@Component`。`@Named`注解不提供组合模型，但其扫描方式与`@Component`相同：'
- en: '[PRE129]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '**@Inject**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**@Inject**'
- en: '@Inject is used for auto wiring the dependencies in the same way as we do for
    @Autowired. But it won''''t has attribute ''''required'''' to specify the dependency
    is optional. The following code shows the implementation:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Inject`用于自动注入依赖项，就像我们为`@Autowired`做的那样。但它不会有`required`属性来指定依赖是可选的。以下代码显示了实现方式：'
- en: '[PRE130]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '**@Configuration**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**@Configuration**'
- en: The class level @Configuration annotation is used to indicate the class as source
    of the bean definition the same way as we do in XML file within <beans></beans>
    tags.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@Configuration`注解用于指示类作为bean定义的来源，就像我们在`<beans></beans>`标签中的XML文件中做的那样。
- en: '[PRE131]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The Spring annotations as @Component, @Repository needs registration with the
    framework. In XML scanning of these annotation is enabled by providing <context:component-scan>
    with an attribute base-package. @Component-Scan is an alternative to enable scanning
    of Spring stereotype annotations. The syntax is as shown below:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Spring注解如`@Component`、`@Repository`需要注册到框架中。在XML中，通过提供一个`<context:component-scan>`属性base-package来启用这些注解的扫描。`@Component-Scan`是启用Spring
    stereotypes注解扫描的替代方案。语法如下所示：
- en: '[PRE132]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '**@Bean**'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**@Bean**'
- en: 'The @Bean is used with @Configuration to declare bean definition as we usually
    do in `<bean></bean>` tag in XML. It''''s applicable to the method who has the
    bean definition. The code can be as follow:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Bean`与`@Configuration`一起使用，用来声明bean定义，就像我们通常在XML中的`<bean></bean>`标签中做的那样。它适用于有bean定义的方法。代码可以如下所示：'
- en: '[PRE133]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To define a bean returned from `myCustomer()` can also have customised bean
    id which can be given by:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义从`myCustomer()`返回的bean，也可以有自定义的bean id，可以通过：
- en: '[PRE134]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The XML has been replaced by the annotation based configuration. The `AnnotationConfigApplicationContext`
    class helps in loading the configuration in the same way we were doing by `ClasspathXmlApplicationContext`.
    The test class can be written as:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注解配置已经取代了XML。`AnnotationConfigApplicationContext`类帮助以与`ClasspathXmlApplicationContext`相同的方式加载配置。测试类可以写成：
- en: '[PRE135]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You can refer the complete code from Ch02_Demo_JSR_Annot.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考Ch02_Demo_JSR_Annot中的完整代码。
- en: Note
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XML provides centralized way to do the bean configurations. As the dependencies
    are kept out of source code the change in them will not affect the source code.
    Also in XML configuration the source code doesn''t need to be recompiled. But
    annotation based configuration is directly a part of source code and scattered
    throughout the application. It becomes decentralised which ultimately become difficult
    to control. Annotation based injected values will be overridden by the XML injection
    as annotation based injections take place before the XML injection.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: XML提供了一种集中进行bean配置的方式。由于依赖项被保持在源代码之外，它们的更改不会影响源代码。此外，在XML配置中，源代码不需要重新编译。但是，基于注解的配置直接是源代码的一部分，并且散布在整个应用程序中。这变得去中心化，最终变得难以控制。基于注解注入的值将被XML注入覆盖，因为基于注解的注入发生在XML注入之前。
- en: Spring Expression Language (SpEL)
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring表达式语言（SpEL）
- en: Up till now we configured the values which are secondary types. For wiring the
    beans we used the XML configuration which we wrote and available at compile time.
    But using it we cannot able to configure the runtime values. Spring Expression
    provides the required solution whose values will be evaluated at runtime.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们配置了次要类型的值。对于bean的连接，我们使用了我们在编译时编写并可用的XML配置。但是使用它我们无法配置运行时值。Spring表达式提供了所需的解决方案，其值将在运行时进行评估。
- en: Using SpEL the developers can reference to other beans using id''s and set literal
    values as well. It provides a means to invoke methods and properties of the objects.
    SpEL unable evaluation values using mathematical, relational and logical operators.
    It also supports and injection of Collection. It is somewhat similar to using
    EL in JSP. The sysntax to use SpEL is ''#{value}''. Let''s find out how to use
    SpEL in the application one by one.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以使用SpEL引用其他bean并设置字面量值。它提供了一种调用对象的方法和属性的手段。SpEL可以评估使用数学、关系和逻辑运算符的值。它还支持集合的注入。这与在JSP中使用EL有些相似。使用SpEL的语法是'#{value}'。让我们逐一找出如何在应用程序中使用SpEL。
- en: Using Literals
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用字面量
- en: Using literals in SpEL unable the developers to set primitive values for the
    properties of the bean. Though using literals in configuration doesn''t interesting
    but to know how to use in expression certainly help us to go for the complex expressions.
    Follow the steps to understand use of literals,
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在SpEL中使用字面量允许开发人员为bean的属性设置原始值。虽然在配置中使用字面量并不有趣，但了解如何在表达式中使用确实帮助我们走向复杂的表达式。按照以下步骤了解字面量的使用，
- en: Create Ch02_SpringEL as Java application and add to it Spring jars.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Ch02_SpringEL创建为Java应用程序，并添加Spring库。
- en: 'Define Customer.java in com.ch02.beans as shown below:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch02.beans中定义Customer.java，如下所示：
- en: '[PRE136]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create beans.xml in class path to configure Customer bean as shown below:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建beans.xml文件，以如下方式配置客户bean：
- en: '[PRE137]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: You can observe the values for cust_id, prod_price configured using SpEL syntax
    as ''#{ value}'' and we use single quote to specify the value for prod_name. You
    even can use double quotes for specifying String values. The cust_name has been
    configured in old style. Yes, it''s still possible to use old style and SpEL together
    to set the values.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到cust_id、prod_price使用SpEL语法配置为'#{ value}'，并为prod_name使用单引号指定值。你甚至可以使用双引号指定字符串值。cust_name已使用旧风格配置。是的，仍然可以同时使用旧风格和SpEL设置值。
- en: 'Add TestCustomer.java as shown in the code below:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面的代码添加TestCustomer.java：
- en: '[PRE138]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'We will get the output as:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将得到如下输出：
- en: '[PRE139]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Using bean reference
  id: totrans-637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用bean引用
- en: Each bean configured in the XML has its unique bean id. This is can be used
    to refer for value or for auto wiring using SpEL. Use the following steps to understand
    how to use bean reference.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中配置的每个bean都有其唯一的bean id。这可以用于引用值或使用SpEL进行自动装配。按照以下步骤了解如何使用bean引用。
- en: 'In the above Ch02_SpringEL project add new POJO class as Address and Customer_Reference
    in com.ch02.beans as shown below:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的Ch02_SpringEL项目中添加新的POJO类Address和Customer_Reference，如下所示：
- en: '[PRE140]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Add Address and Customer_Reference beans in beans.xml as shown below:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在beans.xml中添加Address和Customer_Reference bean，如下所示：
- en: '[PRE141]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Observe the way cust_address has been initialized. The customer''s address is
    placed value as cust_address which is the id of the bean defined for Address.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 注意cust_address的初始化方式。将客户地址赋值给cust_address，这是为Address定义的bean的id。
- en: Define TestCustomer_Reference as we did in Step 4 of previous case to get the
    bean 'cust_ref'.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第4步的方法定义TestCustomer_Reference，以获取'cust_ref'bean。
- en: 'On execution we will get the out put as shown below:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，我们将得到如下输出：
- en: '[PRE142]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Sometimes instead of using the bean we may want to inject only one of the property
    of the bean as shown below:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，我们可能希望注入bean的某个属性，而不是使用整个bean，如下所示：
- en: '[PRE143]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We injected cust_name by borrowing it from bean 'cust_ref' and converting it
    to upper case.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从bean 'cust_ref'借用cust_name并将其转换为大写来注入它。
- en: Using mathematical, logical, relational operators
  id: totrans-650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用数学、逻辑、关系运算符
- en: In some of the scenarios the values of the dependencies needs mathematical,
    logical or relational operators to define and place values of the dependencies.
    You can find how to use them in the following demo.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，依赖项的值需要使用数学、逻辑或关系运算符来定义和放置。你可以找到如何使用它们的演示。
- en: We will use the same project Ch02_SpringEL defined in previous case.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用前面案例中定义的同一个项目Ch02_SpringEL。
- en: 'Define a bean for Customer in beans.xml as shown below:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在beans.xml中定义Customer bean，如下所示：
- en: '[PRE144]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The value of prod_price is calculated at runtime with the help of mathematical
    operator and value for ''second_handed'' evaluated by relational operator.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: prod_price的值通过数学运算符在运行时计算，并通过关系运算符评估'second_handed'的值。
- en: 'Write TestCustomer_Cal to get cust_calculation and display its properties as
    follows:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写TestCustomer_Cal以获取cust_calculation并如下显示其属性：
- en: '[PRE145]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Throughout this chapter we had seen how to do the configuration. But we missed
    a very important point ''loose coupling''. Everywhere we use classes which leads
    for tight coupling and we know programming by contract gives developers the facility
    to write loosely coupled modules. We avoid use of interfaces for above all demos
    because it may make them unnecessarily complex. But in the real time applications
    you will find use of interfaces on each stage in Spring. From next chapter onwards
    we will use standard way of writing Spring based applications.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们都看到了如何进行配置。但我们忽略了一个非常重要的点——“松耦合”。我们使用的类导致了紧密耦合，而我们知道，通过合同编程可以给开发者提供编写松耦合模块的便利。我们避免在上面的所有示例中使用接口，因为它可能会使它们变得不必要复杂。但在实际的应用程序中，您会在Spring的每个阶段发现接口的使用。从下一章节开始，我们将使用编写Spring应用程序的标准方式。
- en: Summary
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: （此处原文为三个星号，表示空白行）
- en: This chapter is full of configurations, different ways and alternative to do
    the same thing. This chapter helps throughout your journey with Spring no matters
    whether its 5.0 or below versions. In this chapter we explore range of ways to
    do instance creation and initializing it. We are now aware of almost all kind
    of Java Concepts with how to do their configuration both using XML and annotation
    based. We also seen ways like auto wiring , SpEL to minimise the configuration.
    We demonstrate Spring provided as well as JSR annotations.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 本章充满了各种配置，不同的方法和替代方案，它们都可以用来完成同一件事情。无论您使用的是Spring的5.0版本还是更低版本，本章都会在您的学习旅程中提供帮助。在本章中，我们探讨了实例创建和初始化的各种方法。现在，我们已经了解了几乎所有的Java概念以及如何使用XML和基于注解的方式来配置它们。我们还看到了诸如自动注入、SpEL等减少配置的方法。我们展示了Spring提供的以及JSR注解。
- en: Now we are set to implement all these in our application. Let''s start with
    database handling. In next chapter we will find how to handle database using Spring
    and how Spring helps us doing faster development.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将这些内容应用到我们的应用程序中。让我们从数据库处理开始。在下一章节中，我们将了解如何使用Spring来处理数据库，以及Spring如何帮助我们进行更快的开发。
