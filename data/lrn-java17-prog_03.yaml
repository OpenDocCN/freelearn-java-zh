- en: '*Chapter 2*: Java Object-Oriented Programming (OOP)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：Java 面向对象编程（OOP）'
- en: '**Object-Oriented Programming** (**OOP**) was born out of the necessity for
    better control over the concurrent modification of shared data, which was the
    curse of pre-OOP programming. The core of the idea was not to allow direct access
    to data and instead, do it only through a dedicated layer of code. Since data
    needs to be passed around and modified in the process, the concept of an object
    was conceived. In the most general sense, an *object* is a set of data that can
    be passed around and accessed only through the set of methods passed along too.
    This data is said to compose an **object state**, while the methods constitute
    the **object behavior**. The object state is hidden (**encapsulated**) from direct
    access.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）的诞生源于更好地控制共享数据并发修改的必要性，这是面向对象编程之前的诅咒。这个想法的核心不是允许直接访问数据，而是只通过一个专门的代码层来访问。由于数据需要在过程中传递和修改，因此产生了对象的概念。在最一般的意义上，一个**对象**是一组可以传递和通过传递的方法访问的数据。这些数据被称为**对象状态**，而方法构成了**对象行为**。对象状态被隐藏（**封装**）以防止直接访问。'
- en: Each object is constructed based on a certain template called a **class**. In
    other words, a class defines a class of objects. Each object has a certain **interface**,
    a formal definition of the way other objects can interact with it. Originally,
    one object would send a message to another object by calling its method. But this
    terminology did not hold, especially after actual message-based protocols and
    systems were introduced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都是基于称为**类**的特定模板构建的。换句话说，类定义了一类对象。每个对象都有一个特定的**接口**，这是其他对象如何与之交互的正式定义。最初，一个对象会通过调用另一个对象的方法来向另一个对象发送消息。但这个术语并不适用，尤其是在引入了基于消息的协议和系统之后。
- en: To avoid code duplication, a parent-child relationship between objects was introduced
    – one class can inherit behavior from another class. In such a relationship, the
    first class is called a **child class**, or **subclass**, while the second is
    called a **parent**, **base class**, or **superclass**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免代码重复，引入了对象之间的父子关系——一个类可以从另一个类继承行为。在这种关系中，第一个类被称为**子类**或**子类**，而第二个类被称为**父类**、**基类**或**超类**。
- en: Another form of relationship was defined between classes and interfaces – a
    class can *implement* an interface. Since an interface describes how you can interact
    with an object but not how an object responds to the interaction, different objects
    can behave differently while implementing the same interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之间定义了另一种形式的关系——一个类可以**实现**一个接口。由于接口描述了如何与对象交互，但没有描述对象如何响应交互，因此不同的对象在实现相同接口时可以表现出不同的行为。
- en: In Java, a class can have only one direct parent but can implement many interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，一个类只能有一个直接父类，但可以实现多个接口。
- en: The ability to behave like any of its ancestors and adhere to multiple interfaces
    is called **polymorphism**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 能够像其任何祖先一样表现并遵守多个接口的能力称为**多态性**。
- en: 'In this chapter, we will look at these OOP concepts and how they are implemented
    in Java. The topics discussed include the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这些 OOP 概念以及它们如何在 Java 中实现。讨论的主题包括以下内容：
- en: OOP concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）概念
- en: Class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Overloading, overriding, and hiding
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超载、重写和隐藏
- en: The final variable, method, and class
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终变量、方法和类
- en: Record and sealed classes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和密封类
- en: Polymorphism in action
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性实例
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，您需要以下条件：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高
- en: An IDE or code editor that you prefer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您偏好的 IDE 或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, of this book. The files with the code examples for this chapter are
    available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch02_oop` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书[第1章](B18388_01_ePub.xhtml#_idTextAnchor015)，“Java 17入门”，提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的代码示例文件可在GitHub仓库[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)的`examples/src/main/java/com/packt/learnjava/ch02_oop`文件夹中找到。
- en: OOP concepts
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程概念
- en: 'As we have already stated in the introduction, the main OOP concepts are as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在引言中已经所述，主要的面向对象编程（OOP）概念如下：
- en: '**Class**: This defines the properties and behavior (methods) of objects that
    are created based on this class.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：这定义了基于此类的对象的属性和行为（方法）。'
- en: '**Object**: This defines a state (data) as values of its properties, adds behavior
    (methods) taken from a class, and holds them together.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：这定义了状态（数据）为其属性的值，添加了从类中取出的行为（方法），并将它们组合在一起。'
- en: '**Inheritance**: This propagates behavior down the chain of classes connected
    via parent-child relationships.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：这通过父-child关系将行为传播到类链中。'
- en: '**Interface**: This describes how object data and behavior can be accessed.
    It isolates (abstracts) an object’s appearance from its implementations (behavior).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：这描述了如何访问对象数据和行为。它将对象的（外观）与其实现（行为）隔离开来（抽象化）。'
- en: '**Encapsulation**: This hides the state and details of the implementation.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：这隐藏了状态和实现的细节。'
- en: '**Polymorphism**: This allows an object to assume an appearance of implemented
    interfaces and behave like any of the ancestor classes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：这允许对象假设实现接口的外观并表现出任何祖先类的行为。'
- en: Object/class
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象/类
- en: In principle, you can create a very powerful application with minimal usage
    of classes and objects. It became even easier to do this after functional programming
    was added to Java 8, to a JDK, which allowed you to pass around behavior as a
    function. Yet passing data (state) still requires classes/objects. This means
    that the position of Java as an OOP language remains intact.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，你可以通过最小化使用类和对象来创建一个非常强大的应用程序。在Java 8中添加了函数式编程之后，这变得更加容易，因为JDK允许你将行为作为一个函数传递。然而，传递数据（状态）仍然需要类/对象。这意味着Java作为面向对象编程语言的地位仍然保持不变。
- en: A class defines the types of all internal object properties that hold the object
    state. A class also defines object behavior expressed by the code of the methods.
    It is possible to have a class/object without a state or behavior. Java also has
    a provision for making the behavior accessible statically – without creating an
    object. But these possibilities are no more than just additions to the object/class
    concept that was introduced for keeping the state and behavior together.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类定义了所有内部对象属性的类型，这些属性持有对象状态。一个类还定义了由方法代码表达的对象行为。可能存在没有状态或行为的类/对象。Java还有一个静态访问行为的条款——无需创建对象。但这些可能性不过是向为了保持状态和行为在一起而引入的对象/类概念中添加的补充。
- en: To illustrate this concept, a `Vehicle` class, for example, defines the properties
    and behavior of a vehicle in principle. Let’s make the model simple and assume
    that a vehicle has only two properties – weight and engine of a certain power.
    It also can have a certain behavior – it can reach a certain speed in a certain
    period of time, depending on the values of its two properties. This behavior can
    be expressed in a method that calculates the speed the vehicle can reach in a
    certain period of time. Every object of the `Vehicle` class will have a specific
    state (the values of its properties) and the speed calculation will result in
    a different speed in the same time period.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，例如，一个`Vehicle`类在原则上定义了车辆的性质和行为。让我们使模型简单化，并假设一个车辆只有两个属性——重量和一定功率的引擎。它还可以具有某种行为——在特定时间内达到一定的速度，这取决于其两个属性的价值。这种行为可以通过一个方法来表达，该方法计算车辆在特定时间内可以达到的速度。`Vehicle`类的每个对象都将具有特定的状态（其属性值）和速度计算将在相同的时间段内产生不同的速度。
- en: All Java code is contained inside methods. A **method** is a group of statements
    that have (optional) input parameters and a return a value (also optional). In
    addition, each method can have side effects – it can display a message or write
    data into the database, for example. Class/object behavior is implemented in the
    methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Java代码都包含在方法中。**方法**是一组具有（可选的）输入参数并返回一个值（也是可选的）的语句集合。此外，每个方法都可以有副作用——它可以显示一条消息或将数据写入数据库，例如。类/对象的行为是在方法中实现的。
- en: To follow our example, speed calculations can reside in a `double calculateSpeed(float
    seconds)` method, for instance. As you can guess, the name of the method is `calculateSpeed`.
    It accepts a number of seconds (with a fractional part) as a parameter and returns
    the speed value as `double`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循我们的示例，速度计算可以放在一个`double calculateSpeed(float seconds)`方法中，例如。正如你可以猜到的，方法的名字是`calculateSpeed`。它接受一个带有小数部分的秒数作为参数，并返回速度值作为`double`类型。
- en: Inheritance
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: As we have mentioned already, objects can establish a parent-child relationship
    and share properties and behavior this way. For example, we can create a `Car`
    class that inherits properties (weight, for example) and behavior (speed calculation)
    of the `Vehicle` class. In addition, the `child` class can have its own properties
    (the number of passengers, for example) and car-specific behavior (soft shock
    absorption, for example). But if we create a `Truck` class as the vehicle’s child,
    its additional truck-specific property (payload, for example) and behavior (hard
    shock absorption) will be different.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，对象可以通过这种方式建立父子关系并共享属性和行为。例如，我们可以创建一个继承自`Vehicle`类的`Car`类，继承其属性（例如重量）和行为（例如速度计算）。此外，`子`类可以有自己的属性（例如乘客数量）和特定于汽车的行为（例如软冲击吸收）。但是，如果我们创建一个作为车辆子类的`Truck`类，它的附加特定于卡车的属性（例如载重）和行为（例如硬冲击吸收）将是不同的。
- en: It is said that each object of the `Car` or `Truck` class has a parent object
    of the `Vehicle` class. But objects of the `Car` and `Truck` class do not share
    the specific `Vehicle` object (every time a child object is created, a new parent
    object is created first). They share only the parent’s behavior. That is why all
    child objects can have the same behavior but different states. This is one way
    to achieve code reusability, but it may not be flexible enough when object behavior
    has to change dynamically. In such cases, object composition (bringing behavior
    from other classes) or functional programming is more appropriate (see [*Chapter
    13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 据说`Car`或`Truck`类的每个对象都有一个`Vehicle`类的父对象。但是`Car`和`Truck`类的对象并不共享特定的`Vehicle`对象（每次创建子对象时，首先创建一个新的父对象）。它们只共享父的行为。这就是为什么所有子对象都可以有相同的行为但不同的状态。这是实现代码重用的一种方式，但当对象行为需要动态变化时，可能不够灵活。在这种情况下，对象组合（从其他类引入行为）或函数式编程更为合适（参见[*第13章*](B18388_13_ePub.xhtml#_idTextAnchor281)，*函数式编程*）。
- en: It is possible to make a child behave differently than the inherited behavior
    would do. To achieve it, the method that captures the behavior can be re-implemented
    in the `child` class. It is said that a child can *override* inherited behavior.
    We will explain how to do it shortly (see the *Overloading, overriding, and hiding*
    section). If, for example, the `Car` class has its own method for speed calculation,
    the corresponding method of the `Vehicle` parent class is not inherited, and the
    new speed calculation, implemented in the `child` class, is used instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能使子对象的行为与继承的行为不同。为了实现这一点，捕获该行为的可以在`子`类中重新实现该方法。据说子对象可以*重写*继承的行为。我们将在稍后解释如何做到这一点（参见*重载、重写和隐藏*部分）。例如，如果`Car`类有自己的速度计算方法，则`Vehicle`父类的相应方法不会被继承，而是使用在`子`类中实现的新的速度计算方法。
- en: Properties of a parent class can be inherited (but not overridden) too. However,
    class properties are typically declared private; they cannot be inherited – that’s
    the point of encapsulation. See the description of various access levels – `public`,
    `protected`, `default`, and `private` – in the *Access modifiers* section of [*Chapter
    3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 父类属性也可以被继承（但不能被重写）。然而，类属性通常声明为私有；它们不能被继承——这就是封装的目的。请参阅[*第3章*](B18388_03_ePub.xhtml#_idTextAnchor079)中关于各种访问级别——`public`、`protected`、`default`和`private`——的描述，*访问修饰符*部分。
- en: If the parent class inherits some behavior from another class, the `child` class
    acquires (inherits) this behavior too, unless, of course, the parent class overrides
    it. There is no limit to how long the chain of inheritance can be.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父类从另一个类继承了一些行为，那么 `child` 类也会获得（继承）这种行为，除非，当然，父类重写了它。继承链的长度没有限制。
- en: 'The parent-child relationship in Java is expressed using the `extends` keyword:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中使用 `extends` 关键字表达父子关系：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, the `A`, `B`, `C`, and `D` classes have the following relationships:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`A`、`B`、`C` 和 `D` 类有以下关系：
- en: The `D` class inherits from the `A`, `B`, and `C` classes.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D` 类继承自 `A`、`B` 和 `C` 类。'
- en: The `C` class inherits from the `A` and `B` classes.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C` 类继承自 `A` 和 `B` 类。'
- en: The `B` class inherits from the `A` class.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B` 类继承自 `A` 类。'
- en: All non-private methods of the `A` class are inherited (if not overridden) by
    the `B`, `C`, and `D` classes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 类的所有非私有方法都被 `B`、`C` 和 `D` 类继承（如果未被重写）。'
- en: All non-private methods of the `B` class are inherited (if not overridden) by
    the `C` and `D` classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 类的所有非私有方法都被 `C` 和 `D` 类继承（如果未被重写）。'
- en: All non-private methods of the `C` class are inherited (if not overridden) by
    the `D` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 类的所有非私有方法都被 `D` 类继承（如果未被重写）。'
- en: Abstraction/interface
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象/接口
- en: The name of a method and the list of its parameter types is called a `Car` or
    `Truck`, in our example) can be accessed. Such a description together with a `return`
    type is presented as an interface. It does not say anything about the code that
    does calculations – only about the method name, the parameters’ types, their position
    in the parameter list, and the result type. All the implementation details are
    hidden (encapsulated) within the class that *implements* this interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称及其参数类型列表被称为 `Car` 或 `Truck`（在我们的例子中），可以访问。这样的描述与 `return` 类型一起呈现为一个接口。它并没有说关于执行计算的代码——只关于方法名称、参数类型、它们在参数列表中的位置以及结果类型。所有实现细节都被隐藏（封装）在实现此接口的类中。
- en: As we have mentioned already, a class can implement many different interfaces.
    But two different classes (and their objects) can behave differently even when
    they implement the same interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，一个类可以实现许多不同的接口。但即使两个不同的类（及其对象）实现了相同的接口，它们的行为也可能不同。
- en: 'Similarly to classes, interfaces can have a parent-child relationship using
    the `extends` keyword too:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于类，接口也可以使用 `extends` 关键字建立父子关系：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code, the `A`, `B`, `C`, and `D` interfaces have the following relationships:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`A`、`B`、`C` 和 `D` 接口有以下关系：
- en: The `D` interface inherits from the `A`, `B`, and `C` interfaces.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D` 接口继承自 `A`、`B` 和 `C` 接口。'
- en: The `C` interface inherits from the `A` and `B` interfaces.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C` 接口继承自 `A` 和 `B` 接口。'
- en: The `B` interface inherits from the `A` interface.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B` 接口继承自 `A` 接口。'
- en: All non-private methods of the `A` interface are inherited by the `B`, `C`,
    and `D` interfaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 接口的所有非私有方法都被 `B`、`C` 和 `D` 接口继承。'
- en: All non-private methods of the `B` interface are inherited by the `C` and `D`
    interfaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 接口的所有非私有方法都被 `C` 和 `D` 接口继承。'
- en: All non-private methods of the `C` interface are inherited by the `D` interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 接口的所有非私有方法都被 `D` 接口继承。'
- en: Abstraction/interface also reduces dependency between different sections of
    the code, thus increasing its maintainability. Each class can be changed without
    the need to coordinate it with its clients, as long as the interface stays the
    same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象/接口还可以减少代码不同部分之间的依赖性，从而提高其可维护性。只要接口保持不变，每个类都可以更改，而无需与其客户端协调。
- en: Encapsulation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** is often defined either as data hiding or a bundle of publicly
    accessible methods and privately accessible data. In a broad sense, encapsulation
    is controlled access to an object’s properties.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**通常被定义为数据隐藏或一组公开可访问的方法和私有可访问的数据。在广义上，封装是对对象属性访问的控制。'
- en: 'The snapshot of values of object properties is called an **object state**.
    This is data that is encapsulated. So, encapsulation addresses the main issue
    that motivated the creation of object-oriented programming – better management
    of concurrent access to shared data, such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性值的快照称为 **对象状态**。这是封装的数据。因此，封装解决了推动面向对象编程创建的主要问题——更好地管理对共享数据的并发访问，例如以下内容：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, to read or modify the value of the `prop` property, we cannot
    access it directly because of the `private` access modifier. Instead, we can do
    it only via the `setProp(String value)` and `getProp()`methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于`private`访问修饰符，我们不能直接访问`prop`属性的值来读取或修改它。相反，我们只能通过`setProp(String value)`和`getProp()`方法来执行它。
- en: Polymorphism
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is the ability of an object to behave as an object of a different
    class or as an implementation of a different interface. It owes its existence
    to all the concepts that have been mentioned previously – inheritance, interface,
    and encapsulation. Without them, polymorphism would not be possible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是对象以不同类或不同接口的实现的行为的能力。它归功于之前提到的所有概念——继承、接口和封装。没有它们，多态将不可能存在。
- en: Inheritance allows an object to acquire or override the behaviors of all its
    ancestors. An interface hides from the client code the name of the class that
    implemented it. The encapsulation prevents exposing the object state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许一个对象获取或覆盖其所有祖先的行为。接口隐藏了实现它的类的名称。封装防止暴露对象状态。
- en: In the following sections, we will demonstrate all these concepts in action
    and look at the specific usage of polymorphism in the *Polymorphism in action*
    section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将演示所有这些概念的实际应用，并在*多态的实际应用*部分查看多态的具体用法。
- en: Class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A Java program is a sequence of statements that express an executable action.
    The statements are organized in methods, and methods are organized in classes.
    One or more classes are stored in `.java` files. They can be compiled (transformed
    from the Java language into a bytecode) by the `javac` Java compiler and stored
    in `.class` files. Each `.class` file contains one compiled class only and can
    be executed by JVM.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序是一系列表达可执行动作的语句。这些语句组织在方法中，方法组织在类中。一个或多个类存储在`.java`文件中。它们可以通过`javac` Java编译器编译（从Java语言转换为字节码），并存储在`.class`文件中。每个`.class`文件只包含一个编译后的类，并且可以被JVM执行。
- en: A `java` command starts JVM and tells it which class is the `main` one, the
    class that has the method called `main()`. The `main` method has a particular
    declaration – it has to be `public static`, must return `void`, has the name `main`,
    and accepts a single parameter of an array of a `String` type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`java`命令启动JVM并告诉它哪个类是`main`类，即具有名为`main()`的方法的类。`main`方法有特定的声明——它必须是`public
    static`，必须返回`void`，名称为`main`，并接受一个`String`类型数组的单个参数。'
- en: JVM loads the main class into memory, finds the `main()` method, and starts
    executing it, statement by statement. The `java` command can also pass parameters
    (arguments) that the `main()` method receives as an array of `String` values.
    If JVM encounters a statement that requires the execution of a method from another
    class, that class (its `.class` file) is loaded into the memory too and the corresponding
    method is executed. So, a Java program flow is all about loading classes and executing
    their methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将主类加载到内存中，找到`main()`方法，并逐句执行它。`java`命令还可以传递参数（参数）给`main()`方法，这些参数作为`String`值数组的参数接收。如果JVM遇到需要执行另一个类中方法的语句，那么该类（其`.class`文件）也会被加载到内存中，并执行相应的方法。因此，Java程序流程完全是关于加载类和执行它们的方法。
- en: 'Here is an example of the `main` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`main`类的一个示例：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It represents a very simple application that receives any number of parameters
    and passes them, one by one, into the `display()` method of the `AnotherClass`
    class. As JVM starts, it loads the `MyApp` class from the `MyApp.class` file first.
    Then, it loads the `AnotherClass` class from the `AnotherClass.class` file, creates
    an object of this class using the `new` operator (which we will talk about shortly),
    and calls the `display()` method on it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表了一个非常简单的应用，该应用接收任意数量的参数并将它们逐个传递到`AnotherClass`类的`display()`方法中。当JVM启动时，它首先从`MyApp.class`文件中加载`MyApp`类。然后，它从`AnotherClass.class`文件中加载`AnotherClass`类，使用`new`运算符（我们将在稍后讨论）创建该类的对象，并在其上调用`display()`方法。
- en: 'Here is the `AnotherClass` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`AnotherClass`类：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the `display()` method is used for its side effect only – it
    prints out the passed-in value and returns nothing (`void`). The `AnotherClass`
    class has other two methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`display()`方法仅用于其副作用——它打印出传入的值，并返回空（`void`）。`AnotherClass`类还有其他两个方法：
- en: The `process()` method doubles the input integer, stores it in its `result`
    property, and returns the value to the caller.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process()` 方法将输入整数加倍，将其存储在其 `result` 属性中，并将值返回给调用者。'
- en: The `getResult()` method allows you to get the result from the object at any
    time later.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getResult()` 方法允许你在任何时间之后从对象中获取结果。'
- en: These two methods are not used in our demo application. We have shown them just
    to show that a class can have properties (`result`, in this case) and many other
    methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法在我们的演示应用程序中没有被使用。我们展示了它们只是为了表明一个类可以具有属性（在这种情况下是 `result`）和许多其他方法。
- en: The `private` keyword makes the value accessible only from inside the class,
    from its methods. The `public` keyword makes a property or a method accessible
    by any other class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 关键字使得值仅可以从类内部，从其方法中访问。`public` 关键字使得属性或方法可以被任何其他类访问。'
- en: Method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'As we have stated already, Java statements are organized as methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，Java语句被组织成方法：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have seen a few examples already. A method has a name, a set of input parameters
    or no parameters at all, a body inside `{}` brackets, and a return type or `void`
    keyword that indicates that the method does not return any value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些例子。一个方法有一个名称，一组输入参数或者根本没有参数，一个在 `{}` 括号内的主体，以及一个返回类型或 `void` 关键字，表示该方法不返回任何值。
- en: The method name and the list of parameter types together are called the **method
    signature**. The number of input parameters is called an **arity**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称和参数类型列表一起被称为**方法签名**。输入参数的数量被称为**参数数量**。
- en: Important Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Two methods have the same *signature* if they have the same name, the same arity,
    and the same sequence of types in the list of input parameters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个方法具有相同的名称、相同的参数数量和输入参数列表中相同类型的顺序，则它们具有相同的**签名**。
- en: 'The following two methods have the same signature:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个方法具有相同的签名：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The code inside the methods may be different even if the signature is the same.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 即使签名相同，方法内的代码也可能不同。
- en: 'The following two methods have different signatures:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个方法具有不同的签名：
- en: '[PRE47]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Just a change in the sequence of parameters makes the signature different, even
    if the method name remains the same.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只需改变参数的顺序就会使签名不同，即使方法名称保持不变。
- en: Varargs
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变参数
- en: One particular type of parameter requires a mention because it is quite different
    from all the others. It is declared a type followed by three dots. It is called
    **varargs**, which stands for **variable arguments**. But, first, let’s briefly
    define what an array is in Java.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的参数类型需要特别提及，因为它与其他所有参数类型都相当不同。它通过三个点声明为一个类型。它被称为**可变参数（varargs**），代表**可变参数**。但是，首先，让我们简要地定义一下在Java中数组是什么。
- en: An **array** is a data structure that holds elements of the same type. The elements
    are referenced by a numerical index. That’s all we need to know, for now. We will
    talk about arrays in more detail in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是一种数据结构，它包含相同类型的元素。元素通过一个数值索引来引用。这就是我们现在需要知道的所有内容。我们将在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*中更详细地讨论数组。'
- en: 'Let’s start with an example. Let’s declare method parameters using `varargs`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。让我们使用 `varargs` 声明方法参数：
- en: '[PRE53]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When the `someMethod` method is called, the Java compiler matches the arguments
    from left to right. Once it gets to the last `varargs` parameter, it creates an
    array of the remaining arguments and passes it to the method. Here is a demo code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `someMethod` 方法时，Java编译器从左到右匹配参数。一旦它到达最后一个 `varargs` 参数，它就会创建一个剩余参数的数组并将其传递给方法。以下是一个演示代码：
- en: '[PRE56]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, the `varargs` parameter acts like an array of the specified
    type. It can be listed as the last or the only parameter of a method. That is
    why, sometimes, you can see the `main` method declared, as in the preceding example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`varargs` 参数类似于指定类型的数组。它可以作为方法的最后一个或唯一参数列出。这就是为什么有时您会看到像前面示例中那样的 `main`
    方法被声明。
- en: Constructor
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: When an object is created, JVM uses a `0` for integral types, `0.0` for floating-point
    types, and `false` for Boolean types. For other Java reference types (see [*Chapter
    3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*), the default
    value is `null`, which means that the property of a reference type is not assigned
    any value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个对象时，JVM为整型使用 `0`，为浮点型使用 `0.0`，为布尔型使用 `false`。对于其他Java引用类型（见[*第3章*](B18388_03_ePub.xhtml#_idTextAnchor079)，*Java基础*），默认值是
    `null`，这意味着引用类型的属性没有被分配任何值。
- en: Important Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When there is no constructor declared in a class, it is said that the class
    has a default constructor without parameters provided by the JVM.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类中没有声明构造函数时，我们说该类具有由JVM提供的无参数默认构造函数。
- en: 'If necessary, it is possible to declare any number of constructors explicitly,
    each taking a different set of parameters to set the initial state. Here is an
    example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以显式声明任意数量的构造函数，每个构造函数接受不同的一组参数来设置初始状态。以下是一个示例：
- en: '[PRE65]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If a property is not set by a constructor, the default value of the corresponding
    type is going to be assigned to it automatically.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数没有设置属性，则将自动分配相应类型的默认值。
- en: 'When several classes are related along the same line of succession, the parent
    object is created first. If the parent object requires the setting of non-default
    initial values to its properties, its constructor must be called as the first
    line of the child constructor using the `super` keyword, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当几个类沿着相同的继承线相关联时，首先创建父对象。如果父对象需要为其属性设置非默认的初始值，则必须在子构造函数的第一行使用`super`关键字调用其构造函数，如下所示：
- en: '[PRE80]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding code example, we added two constructors to `TheChildClass`
    – one that always passes `42` to the constructor of `TheParentClass`, and another
    that accepts two parameters. Note that the `x` property is declared but not initialized
    explicitly. It is going to be set to value `0`, the default value of the `int`
    type, when an object of `TheChildClass` is created. Also, note that the `anotherProp`
    property is initialized explicitly to the value of `"abc"`. Otherwise, it would
    be initialized to the `null` value, the default value of any reference type, including
    `String`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们向`TheChildClass`添加了两个构造函数——一个总是将`42`传递给`TheParentClass`的构造函数，另一个接受两个参数。请注意，`x`属性已声明但未显式初始化。当创建`TheChildClass`的对象时，它将被设置为`int`类型的默认值`0`。另外，请注意，`anotherProp`属性被显式初始化为值`"abc"`。否则，它将被初始化为`null`值，这是任何引用类型的默认值，包括`String`。
- en: 'Logically, there are three cases when an explicit definition of a constructor
    in the class is not required:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，当在类中不需要显式定义构造函数时，存在三种情况：
- en: When neither the object nor any of its parents have properties that need to
    be initialized
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象及其任何父类都没有需要初始化的属性时
- en: When each property is initialized along with the type declaration (`int x =
    42`, for example)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个属性都随着类型声明一起初始化时（例如`int x = 42`）
- en: When default values for the properties’ initialization are good enough
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性的初始化默认值足够好时
- en: Nevertheless, it is possible that a constructor is still implemented even when
    all three conditions (mentioned in the list) are met. For example, you may want
    to execute some statements that initialize some external resource – a file or
    another database – that the object will need as soon as it is created.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使满足上述三个条件（列出的条件），仍然可能实现构造函数。例如，你可能想要执行一些初始化外部资源的语句——一个文件或另一个数据库——对象创建时将需要这些资源。
- en: 'As soon as an explicit constructor is added, the default constructor is not
    provided and the following code generates an error:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了显式构造函数，就不会提供默认构造函数，以下代码会生成错误：
- en: '[PRE101]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To avoid the error, either add a constructor without parameters to `TheParentClass`
    or call an explicit constructor of the parent class as the first statement of
    the child’s constructor. The following code does not generate an error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，可以向`TheParentClass`添加一个无参数的构造函数，或者在子构造函数的第一行显式调用父类的构造函数。以下代码不会生成错误：
- en: '[PRE116]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: One important aspect to note is that constructors, although they look like methods,
    are not methods or even members of the class. A constructor doesn’t have a return
    type and always has the same name as the class. Its only purpose is to be called
    when a new instance of the class is created.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要方面是，尽管构造函数看起来像方法，但它们既不是方法也不是类的成员。构造函数没有返回类型，并且总是与类的名称相同。它的唯一目的是在创建类的新实例时被调用。
- en: The new operator
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新操作符
- en: 'The `new` operator creates an object of a class (it also can be said that it
    **instantiates a class** or **creates an instance of a class**) by allocating
    memory for the properties of the new object and returning a reference to that
    memory. This memory reference is assigned to a variable of the same type as the
    class used to create the object or the type of its parent:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符通过为新对象的属性分配内存来创建一个类的对象（也可以说它是**实例化一个类**或**创建一个类的实例**），并返回对该内存的引用。这个内存引用被分配给一个与创建对象的类或其父类相同类型的变量：'
- en: '[PRE131]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Here is an interesting observation. In the code, both the `ref1` and `ref2`
    object references provide access to the methods of `TheChildClass` and `TheParentClass`.
    For example, we can add methods to these classes, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的观察。在代码中，`ref1`和`ref2`这两个对象引用都可以访问`TheChildClass`和`TheParentClass`的方法。例如，我们可以向这些类添加方法，如下所示：
- en: '[PRE133]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Then, we can call them using any of the following references:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下任何一种引用来调用它们：
- en: '[PRE148]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Note that, to access the child’s methods using the parent’s type reference,
    we had to cast it to the child’s type. Otherwise, the compiler generates an error.
    That is possible because we have assigned the reference to the child’s object
    to the parent’s type reference. That is the power of polymorphism. We will talk
    more about it in the *Polymorphism in action* section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使用父类的类型引用来访问子类的方法，我们必须将其转换为子类的类型。否则，编译器会生成错误。这是可能的，因为我们已经将子类对象的引用分配给了父类的类型引用。这就是多态的力量。我们将在*多态实践*部分更多地讨论它。
- en: 'Naturally, if we had assigned the parent’s object to the variable of the parent’s
    type, we would not be able to access the child’s method even with casting, as
    the following example shows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果我们把父类的对象分配给父类类型的变量，即使进行类型转换，我们也不能访问子类的方法，如下例所示：
- en: '[PRE154]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The area where memory for the new object is allocated is called **heap**. The
    JVM has a process called **garbage collection** that watches for the usage of
    this area and releases memory for usage as soon as an object is not needed anymore.
    For example, look at the following method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为新对象分配内存的区域称为**堆**。JVM有一个名为**垃圾收集**的过程，它会监视这个区域的用法，并在对象不再需要时立即释放内存。例如，看看以下方法：
- en: '[PRE157]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: As soon as the execution of the `someMethod()` method is completed, the object
    of `SomeClass` is not accessible anymore. That’s what the garbage collector notices,
    and it releases the memory occupied by this object. We will talk about the garbage
    collection process in [*Chapter 9*](B18388_09_ePub.xhtml#_idTextAnchor205), *JVM
    Structure and Garbage Collection*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`someMethod()`方法的执行完成，`SomeClass`的对象就不再可访问了。这就是垃圾收集器所注意到的，它会释放这个对象占用的内存。我们将在[*第9章*](B18388_09_ePub.xhtml#_idTextAnchor205)中讨论垃圾收集过程，*JVM结构和垃圾收集*。
- en: Class java.lang.Object
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类`java.lang.Object`
- en: In Java, all classes are children of the `Object` class by default, even if
    you do not specify it implicitly. The `Object` class is declared in the `java.lang`
    package of the standard JDK library. We will define what a *package* is in the
    *Packages, importing, and access* section and describe libraries in [*Chapter
    7*](B18388_07_ePub.xhtml#_idTextAnchor169), *Java Standard and External Libraries*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，所有类默认都是`Object`类的子类，即使你没有显式地指定。`Object`类声明在标准JDK库的`java.lang`包中。我们将在*包、导入和访问*部分定义什么是*包*，并在[*第7章*](B18388_07_ePub.xhtml#_idTextAnchor169)中描述库，*Java标准库和外部库*。
- en: 'Let’s look back at the example we provided in the *Inheritance* section:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在*继承*部分提供的示例：
- en: '[PRE162]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'All classes, `A`, `B`, `C`, and `D`, are children of the `Object` class, which
    has 10 methods that every class inherits:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类，`A`、`B`、`C`和`D`，都是`Object`类的子类，它有10个方法，每个类都会继承：
- en: '`public String toString()`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String toString()`'
- en: '`public int hashCode()`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int hashCode()`'
- en: '`public boolean equals (Object obj)`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean equals (Object obj)`'
- en: '`public Class getClass()`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Class getClass()`'
- en: '`protected Object clone()`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected Object clone()`'
- en: '`public void notify()`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void notify()`'
- en: '`public void notifyAll()`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void notifyAll()`'
- en: '`public void wait()`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait()`'
- en: '`public void wait(long timeout)`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait(long timeout)`'
- en: '`public void wait(long timeout, int nanos)`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait(long timeout, int nanos)`'
- en: 'The first three, `toString()`, `hashCode()`, and `equals()`, are the most-used
    methods and often re-implemented (overridden). The `toString()` method is typically
    used to print the state of the object. Its default implementation in JDK looks
    like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个，`toString()`、`hashCode()`和`equals()`，是最常用的方法，通常会被重新实现（重写）。`toString()`方法通常用于打印对象的状态。在JDK中的默认实现看起来像这样：
- en: '[PRE166]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'If we use it on the object of the `TheChildClass` class, the result will be
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`TheChildClass`类的对象上使用它，结果将如下所示：
- en: '[PRE170]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: By the way, there is no need to call `toString()` explicitly while passing an
    object into the `System.out.println()` method and similar output methods because
    they do it inside the method anyway, and `System.out.println(ref1)`, in our case,
    produces the same result.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在将对象传递给`System.out.println()`方法以及类似的输出方法时，没有必要显式调用`toString()`，因为它们在方法内部已经做了这件事，在我们的例子中，`System.out.println(ref1)`会产生相同的结果。
- en: 'So, as you can see, such an output is not human-friendly, so it is a good idea
    to override the `toString()` method. The easiest way to do it is by using an IDE.
    For example, in IntelliJ IDEA, right-click inside `TheChildClass` code, as shown
    in the following screenshot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，这样的输出不是面向人类的，所以重写`toString()`方法是个好主意。最简单的方法是使用IDE。例如，在IntelliJ IDEA中，在`TheChildClass`代码内部右键单击，如图下截图所示：
- en: '![](img/B18388_Figure_2.1.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_2.1.jpg)'
- en: 'Select and click **Generate...**, and then select and click **toString()**,
    as shown in the following screenshot:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 选择并点击**生成...**，然后选择并点击**toString()**，如图下截图所示：
- en: '![](img/B18388_Figure_2.2.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_2.2.jpg)'
- en: 'The new pop-up window will enable you to select the properties you wish to
    include in the `toString()` method. Select only the properties of `TheChildClass`,
    as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 新弹出的窗口将允许你选择你希望在`toString()`方法中包含的属性。只选择`TheChildClass`的属性，如下所示：
- en: '![](img/B18388_Figure_2.3.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_2.3.jpg)'
- en: 'After you click the **OK** button, the following code will be generated:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮后，将生成以下代码：
- en: '[PRE174]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'If there were more properties in the class and you had selected them, more
    properties and their values would be included in the method output. If we print
    the object now, the result will be this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类中有更多属性并且你选择了它们，方法输出中将会包含更多属性及其值。如果我们现在打印对象，结果将是这样的：
- en: '[PRE180]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: That is why the `toString()` method is often overridden and even included in
    the services of an IDE.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`toString()`方法经常被重写，甚至被包含在IDE的服务中。
- en: We will talk about the `hashCode()` and `equals()` methods in more detail in
    [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)中更详细地讨论`hashCode()`和`equals()`方法，*数据结构、泛型和常用工具*。
- en: The `getClass()` and `clone()` methods are not used as often. The `getClass()`
    method returns an object of the `Class` class that has many methods that provide
    various system information. The most used method is the one that returns the name
    of the class of the current object. The `clone()` method can be used to copy the
    current object. It works just fine as long as all the properties of the current
    object are of primitive types. But, if there is a reference type property, the
    `clone()` method has to be re-implemented so that the copy of the reference type
    can be done correctly. Otherwise, only the reference will be copied, not the object
    itself. Such a copy is called a `protected` keyword indicates that only children
    of the class can access it. See the *Packages, importing, and access* section.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`getClass()`和`clone()`方法使用得不太频繁。`getClass()`方法返回一个`Class`类的对象，该对象有许多提供各种系统信息的方法。最常用的方法是返回当前对象类名的那个方法。`clone()`方法可以用来复制当前对象。只要当前对象的所有属性都是基本类型，它就能正常工作。但是，如果存在引用类型属性，`clone()`方法必须被重新实现，以便正确地复制引用类型。否则，只会复制引用，而不是对象本身。这种复制被称为`protected`关键字表示只有类的子类可以访问它。请参阅*包、导入和访问*部分。'
- en: The last five of the class `Object` methods are used for communication between
    threads – the lightweight processes for concurrent processing. They are typically
    not re-implemented.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Object`的最后一个五个方法用于线程之间的通信——轻量级进程用于并发处理。它们通常不会被重新实现。
- en: Instance and static properties and methods
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例和静态属性和方法
- en: 'So far, we have seen mostly methods that can be invoked only on an object (instance)
    of a class. Such methods are called `static` and invoked without creating an object.
    An example of such a method is the `main()` method. Here is another example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要看到的方法只能在一个类的（实例）对象上调用。这类方法被称为`静态`方法，并且可以在不创建对象的情况下调用。一个这样的方法的例子是`main()`方法。下面是另一个例子：
- en: '[PRE183]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'This method can be called as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以这样调用：
- en: '[PRE188]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Important Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Static methods can be called on an object too, but it is considered bad practice,
    as it hides the static nature of the method from a human trying to understand
    the code. Besides, it raises a compiler warning and, depending on the compiler
    implementation, may even generate a compiler error.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法也可以在对象上调用，但这被认为是不良的实践，因为它隐藏了方法对试图理解代码的人的静态性质。此外，它还会引发编译器警告，并且根据编译器的实现，甚至可能生成编译器错误。
- en: 'Similarly, a property can be declared static and thus accessible without creating
    an object, such as the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个属性也可以被声明为静态，因此可以在不创建对象的情况下访问，例如以下内容：
- en: '[PRE189]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'This property can be accessed directly via class too, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性可以通过类直接访问，如下所示：
- en: '[PRE192]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Having such a static property works against the idea of state encapsulation
    and may cause all the problems of concurrent data modification because it exists
    as a single copy in JVM memory, and all the methods that use it share the same
    value. That is why a static property is typically used for two purposes:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的静态属性与状态封装的理念相悖，并可能导致并发数据修改的所有问题，因为它在JVM内存中作为一个单独的副本存在，并且所有使用它的方法共享相同的值。这就是为什么静态属性通常用于两个目的：
- en: To store a constant – a value that can be read but not modified (also called
    a **read-only value**)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一个常量——一个可以读取但不能修改的值（也称为**只读值**）
- en: To store a stateless object that is expensive to create or that keeps read-only
    values
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一个创建成本高昂或保持只读值的无状态对象
- en: 'A typical example of a constant is a name of a resource:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的常量例子是一个资源的名称：
- en: '[PRE193]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Note the `final` keyword in front of the static property. It tells the compiler
    and JVM that this value, once assigned, cannot change. An attempt to do it generates
    an error. It helps to protect the value and express clearly the intent to have
    this value as a constant. When a human tries to understand how the code works,
    such seemingly small details make the code easier to understand.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意静态属性前面的`final`关键字。它告诉编译器和JVM，这个值一旦分配，就不能改变。尝试这样做会生成错误。它有助于保护值并清楚地表达将此值作为常量的意图。当人类试图理解代码的工作方式时，这样的看似微小的细节使代码更容易理解。
- en: That said, consider using interfaces for such a purpose. Since Java 1.8, all
    the fields declared in an interface are implicitly static and final, so there
    is less chance you’ll forget to declare a value to be final. We will talk about
    interfaces shortly.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，考虑使用接口来达到这样的目的。自从Java 1.8以来，接口中声明的所有字段都是隐式静态和最终的，因此你忘记声明一个值是最终的几率更小。我们很快就会谈到接口。
- en: When an object is declared a static final class property, it does not mean all
    its properties become final automatically. It only protects the property from
    assigning another object of the same type. We will discuss the complicated procedure
    of concurrent access of an object property in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187),
    *Multithreading and Concurrent Processing*. Nevertheless, programmers often use
    static final objects to store the values that are read-only just by the way they
    are used in the application. A typical example would be application configuration
    information. Once created after reading from a disk, it is not changed, even if
    it could be. Also, caching of data is obtained from an external resource.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被声明为静态最终类属性时，并不意味着它的所有属性都会自动变为最终。它只保护属性不被分配相同类型的另一个对象。我们将在[*第8章*](B18388_08_ePub.xhtml#_idTextAnchor187)中讨论对象属性并发访问的复杂过程，*多线程和并发处理*。尽管如此，程序员经常使用静态最终对象来存储只通过它们在应用程序中的使用方式读取的值。一个典型的例子就是应用程序配置信息。一旦从磁盘读取后创建，即使可以改变，也不会改变。此外，从外部资源获取的数据缓存。
- en: Again, before using such a class property for this purpose, consider using an
    interface that provides more default behavior that supports a read-only functionality.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在将此类属性用于此目的之前，考虑使用提供更多默认行为以支持只读功能的接口。
- en: 'Similar to static properties, static methods can be invoked without creating
    an instance of the class. Consider, for example, the following class:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态属性类似，静态方法可以在不创建类实例的情况下调用。例如，考虑以下类：
- en: '[PRE196]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We can call the preceding method by using just a class name:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类名直接调用前面的方法：
- en: '[PRE201]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Interface
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In the *Abstraction/interface* section, we talked about an interface in general
    terms. In this section, we are going to describe a Java language construct that
    expresses it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在*抽象/接口*部分，我们一般性地讨论了接口。在本节中，我们将描述一个Java语言结构，它表达了接口的概念。
- en: 'An interface presents what can be expected of an object. It hides the implementation
    and exposes only method signatures with return values. For example, here is an
    interface that declares two abstract methods:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接口展示了对象可以期望的行为。它隐藏了实现细节，只暴露带有返回值的方法签名。例如，以下是一个声明了两个抽象方法的接口：
- en: '[PRE202]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Here is a class that implements it:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个实现它的类：
- en: '[PRE206]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'An interface cannot be instantiated. An object of an interface type can be
    created only by creating an object of a class that *implements* this interface:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不能被实例化。只能通过创建实现此接口的类的对象来创建接口类型的对象：
- en: '[PRE215]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: If not all of the abstract methods of the interface have been implemented, the
    class must be declared abstract and cannot be instantiated. See the *Interface
    versus abstract class* section.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口的所有抽象方法都没有被实现，则该类必须被声明为抽象类，并且不能被实例化。请参阅*接口与抽象类*部分。
- en: An interface does not describe how the object of the class can be created. To
    discover that, you must look at the class and see what constructors it has. An
    interface also does not describe the static class methods. So, an interface is
    a public face of a class instance (object) only.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不描述如何创建类的对象。要发现这一点，您必须查看类并查看它有哪些构造函数。接口也不描述静态类方法。因此，接口只是类实例（对象）的公共面孔。
- en: With Java 8, an interface acquired the ability to have not just abstract methods
    (without a body) but really implemented ones. According to the Java Language Specification,
    “*the body of an interface may declare members of the interface, that is, fields,
    methods, classes, and interfaces*.” Such a broad statement brings up the question,
    what is the difference between an interface and a class? One principal difference
    that we have pointed out already is this – an interface cannot be instantiated;
    only a class can be instantiated.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，接口不仅获得了具有抽象方法（没有方法体）的能力，还获得了真正实现的方法的能力。根据Java语言规范，“*接口的主体可以声明接口的成员，即字段、方法、类和接口*。”这样的广泛声明引发了一个问题，接口和类之间的区别是什么？我们已经指出的一个主要区别是——接口不能被实例化；只有类可以被实例化。
- en: Another difference is that a non-static method implemented inside an interface
    is declared `default` or `private`. By contrast, a `default` declaration is not
    available for the class methods.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，接口内部实现的非静态方法被声明为`default`或`private`。相比之下，类方法中不可用`default`声明。
- en: Also, fields in an interface are implicitly public, static, and final. By contrast,
    class properties and methods are not static or final by default. The implicit
    (default) access modifier of a class itself, its fields, methods, and constructors
    are package-private, which means it is visible only within its own package.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，接口中的字段默认是公共的、静态的和最终的。相比之下，类属性和方法默认不是静态或最终的。类的隐式（默认）访问修饰符，包括其字段、方法和构造函数，是包私有的，这意味着它只在其自己的包内可见。
- en: Default methods
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认方法
- en: 'To get an idea about the function of default methods in an interface, let’s
    look at an example of an interface and a class that implements it, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解接口中默认方法的功能，让我们看看以下接口及其实现类的示例：
- en: '[PRE216]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'We can now create an object of the `SomeClass` class and make the following
    call:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建`SomeClass`类的对象并执行以下调用：
- en: '[PRE232]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: As you can see, `method3()` is not implemented in the `SomeClass` class, but
    it looks as if the class has it. That is one way to add a new method to an existing
    class without changing it – by adding the default method to the interface the
    class implements.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`method3()`在`SomeClass`类中没有实现，但看起来类好像有它。这是在不更改现有类的情况下向现有类添加新方法的一种方式——通过向类实现的接口添加默认方法。
- en: 'Let’s now add the `method3()` implementation to the class too, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也将`method3()`的实现添加到类中，如下所示：
- en: '[PRE238]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Now, the interface implementation of `method3()` will be ignored:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将忽略`method3()`的接口实现：
- en: '[PRE250]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Important Note
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The purpose of the default method in an interface is to provide a new method
    to the classes (that implement this interface) without changing them. But the
    interface implementation is ignored as soon as a class implements the new method
    too.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的默认方法的目的在于向实现此接口的类提供新的方法，而无需更改它们。但是，一旦类实现了新方法，接口实现就会被忽略。
- en: Private methods
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有方法
- en: 'If there are several default methods in an interface, it is possible to create
    private methods accessible only by the default methods of the interface. They
    can be used to contain common functionality, instead of repeating it in every
    default method:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口中有多个默认方法，则可以创建仅由接口的默认方法可访问的私有方法。它们可以用来包含通用功能，而不是在每个默认方法中重复：
- en: '[PRE255]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: This concept of private methods is not different from private methods in classes
    (see the *Packages, importing, and access* section). The private methods cannot
    be accessed from outside the interface.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这种私有方法的概念与类中的私有方法没有区别（参见*包、导入和访问*部分）。私有方法不能从接口外部访问。
- en: Static fields and methods
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态字段和方法
- en: Since Java 8, all the fields declared in an interface are implicitly public,
    static, and final constants. That is why an interface is a preferred location
    for the constants. You do not need to add `public static final` to their declarations.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，接口中声明的所有字段都是隐式公共的、静态的和最终的常量。这就是为什么接口是常量的首选位置。你不需要在它们的声明中添加`public
    static final`。
- en: 'As for the static methods, they function in an interface in the same way as
    in a class:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 至于静态方法，它们在接口中的功能与在类中相同：
- en: '[PRE268]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Note that there is no need to mark the interface method as `public`. All non-private
    interface methods are public by default.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有必要将接口方法标记为`public`。所有非私有接口方法默认都是公共的。
- en: 'We can call the preceding method by using just an interface name:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用接口名称来调用前面的方法：
- en: '[PRE273]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Interface versus abstract class
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口与抽象类
- en: We have mentioned already that a class can be declared `abstract`. It may be
    a regular class that we do not want to be instantiated, or it may be a class that
    contains (or inherits) abstract methods. In the last case, we must declare such
    a class as `abstract` to avoid a compilation error.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，一个类可以被声明为`abstract`。它可能是一个我们不希望实例化的常规类，或者它可能是一个包含（或继承）抽象方法的类。在后一种情况下，我们必须将此类声明为`abstract`以避免编译错误。
- en: In many respects, an abstract class is very similar to an interface. It forces
    every `child` class that extends it to implement the abstract methods. Otherwise,
    the child cannot be instantiated and has to be declared abstract itself.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，抽象类与接口非常相似。它强制每个扩展它的`子`类实现抽象方法。否则，子类无法实例化，必须将其声明为抽象。
- en: 'However, a few principal differences between an interface and abstract class
    make each of them useful in different situations:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接口与抽象类之间的一些主要差异使它们在不同的场景中都有用：
- en: An abstract class can have a constructor, while an interface cannot.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以有构造函数，而接口则不能。
- en: An abstract class can have a state, while an interface cannot.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以有状态，而接口则不能。
- en: The fields of an abstract class can be `public`, `private`, or `protected`,
    `static` or not, and `final` or not, while, in an interface, fields are always
    `public`, `static`, and `final`.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类的字段可以是`public`、`private`或`protected`，可以是`static`也可以不是，可以是`final`也可以不是，而在接口中，字段始终是`public`、`static`和`final`。
- en: The methods in an abstract class can be `public`, `private`, or `protected`,
    while the interface methods can be `public` or `private` only.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类中的方法可以是`public`、`private`或`protected`，而接口方法只能是`public`或`private`。
- en: If the class you would like to amend extends another class already, you cannot
    use an abstract class, but you can implement an interface because a class can
    extend only one other class but can implement multiple interfaces.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要修改的类已经扩展了另一个类，你不能使用抽象类，但你可以实现一个接口，因为一个类只能扩展一个其他类，但可以实现多个接口。
- en: You will see an example of abstract usage in the *Polymorphism in action* section.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在*多态的实际应用*部分看到一个抽象使用的例子。
- en: Overloading, overriding, and hiding
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资重载、覆盖和隐藏
- en: We have already mentioned overriding in the *Inheritance* and *Abstraction/interface*
    sections. It is a replacement of a non-static method implemented in a parent class
    with the method of the same signatures in the `child` class. The default method
    of an interface also can be overridden in the interface that extends it. Hiding
    is similar to overriding but applies only to static methods and static, as well
    as properties of the instance.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*继承*和*抽象/接口*章节中提到了覆盖。它是在父类中实现的非静态方法与子类中具有相同签名的方法的替换。接口的默认方法也可以在扩展它的接口中被覆盖。隐藏与覆盖类似，但仅适用于静态方法和静态属性以及实例属性。
- en: Overloading is creating several methods with the same name and different parameters
    (thus, different signatures) in the same class or interface.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值重载是指在同一个类或接口中创建具有相同名称但参数不同（因此，签名不同）的多个方法。
- en: In this section, we will discuss all these concepts and demonstrate how they
    work for classes and interfaces.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论所有这些概念，并演示它们在类和接口中的应用方式。
- en: Overloading
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值重载
- en: 'It is not possible to have two methods in the same interface or a class with
    the same signature. To have a different signature, the new method has to have
    either a new name or a different list of parameter types (and the sequence of
    the type does matter). Having two methods with the same name but a different list
    of parameter types constitutes overloading. Here are a few examples of a legitimate
    method of overloading in an interface:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个接口或类中不可能有两个具有相同签名的不同方法。为了有不同的签名，新方法必须具有新的名称或不同的参数类型列表（参数类型的顺序也很重要）。具有相同名称但参数类型列表不同的两个方法构成了赋值重载。以下是一些在接口中合法的赋值重载方法的示例：
- en: '[PRE274]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Note that no two of the preceding methods have the same signature, including
    the default and static methods. Otherwise, a compiler’s error would be generated.
    Neither designation as default nor static plays any role in the overloading. A
    return type does not affect the overloading either. We use `int` as a return type
    everywhere just to make the examples less cluttered.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面提到的任何两种方法都没有相同的签名，包括默认和静态方法。否则，编译器将生成错误。无论是默认还是静态的指定都不会影响赋值重载。返回类型也不会影响赋值重载。我们在这里使用`int`作为返回类型，只是为了使示例更简洁。
- en: 'Method overloading is done similarly in a class:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法重载方式类似：
- en: '[PRE280]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'And it does not matter where the methods with the same name are declared. The
    following method overloading is not different from the previous example, as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，方法具有相同名称的位置并不重要。以下的方法重载与前面的示例没有区别，如下所示：
- en: '[PRE285]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: A private non-static method can be overloaded only by a non-static method of
    the same class.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 私有非静态方法只能由同一类中的非静态方法重载。
- en: Important Note
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Overloading happens when methods have the same name but a different list of
    parameter types and belong to the same interface (or class) or to different interfaces
    (or classes), one of which is an ancestor to another. A private method can be
    overloaded only by a method in the same class.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法具有相同的名称但不同的参数类型列表，并且属于同一个接口（或类）或不同的接口（或类），其中一个接口（或类）是另一个的祖先时，就会发生赋值重载。私有方法只能由同一类中的方法重载。
- en: Overriding
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖
- en: In contrast to overloading, which happens with the static and non-static methods,
    method overriding happens only with non-static methods and only when they have
    *exactly the same signature* and *belong to different interfaces (or classes)*,
    one of which is an ancestor to another.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 与赋值重载不同，赋值重载发生在静态和非静态方法中，而方法覆盖仅发生在非静态方法中，并且只有当它们具有*完全相同的签名*并且*属于不同的接口（或类）*时才会发生，其中一个接口（或类）是另一个的祖先。
- en: Important Note
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The overriding method resides in the child interface (or class), while the overridden
    method has the same signature and belongs to one of the ancestor interfaces (or
    classes). A private method cannot be overridden.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的方法位于子接口（或类）中，而被覆盖的方法具有相同的签名，并属于祖先接口（或类）之一。私有方法不能被覆盖。
- en: 'The following are examples of a method overriding an interface:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个方法覆盖接口的示例：
- en: '[PRE300]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'If we call the `method()` using the `C` class instance, the result will be
    as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`C`类实例调用`method()`，结果如下：
- en: '[PRE312]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Please note the usage of the `@Override` annotation. It tells the compiler
    that the programmer thinks that the annotated method overrides a method of one
    of the ancestor interfaces. This way, the compiler can make sure that the overriding
    does happen and generates an error if it doesn’t. For example, a programmer may
    misspell the name of the method, as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`@Override`注解的使用。它告诉编译器程序员认为注解的方法覆盖了祖先接口中的一个方法。这样，编译器可以确保确实发生了覆盖，如果没有，则生成错误。例如，程序员可能会拼错方法名，如下所示：
- en: '[PRE314]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'If that happens, the compiler generates an error because there is no `metod()`
    method to override. Without the `@Overrride` annotation, this mistake may go unnoticed
    by the programmer, and the result would be quite different:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，编译器会生成一个错误，因为没有`metod()`方法可以覆盖。如果没有`@Override`注解，程序员可能不会注意到这个错误，结果会完全不同：
- en: '[PRE320]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'The same rules of overriding apply to the class instance methods. In the following
    example, the `C2` class overrides a method of the `C1` class:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的规则同样适用于类实例方法。在以下示例中，`C2`类覆盖了`C1`类的一个方法：
- en: '[PRE322]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'The result is as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE333]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'It does not matter how many ancestors are between the class or interface with
    the overridden method and the class or interface with the overriding method:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 不论重写方法所在的类或接口与重写方法所在的类或接口之间有多少祖先，这都没有关系：
- en: '[PRE335]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: The result of the preceding method’s overriding will still be the same.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法重写的结果仍然相同。
- en: Hiding
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏
- en: '**Hiding** is considered by many to be a complicated topic, but it should not
    be, and we will try to make it look simple.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏**对于许多人来说是一个复杂的话题，但它不应该如此复杂，我们将尝试让它看起来很简单。'
- en: The name *hiding* came from the behavior of static properties and methods of
    classes and interfaces. Each static property or method exists as a single copy
    in the JVM’s memory because they are associated with the interface or class, not
    with an object. An interface or class exists as a single copy. That is why we
    cannot say that the child’s static property or method overrides the parent’s static
    property or method with the same name. All static properties and methods are loaded
    into the memory only once when the class or interface is loaded and stay there,
    not being copied anywhere. Let’s look at an example.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: “隐藏”这个名字来源于类和接口的静态属性和方法的行为。每个静态属性或方法在JVM的内存中只存在一个副本，因为它们与接口或类相关联，而不是与对象相关联。接口或类作为一个单独的副本存在。这就是为什么我们不能说子类的静态属性或方法会覆盖父类的同名静态属性或方法。所有静态属性和方法仅在类或接口加载时加载到内存中，并保持在那里，不会被复制到任何地方。让我们看一个例子。
- en: 'Let’s create two interfaces that have a parent-child relationship and static
    fields and methods with the same name:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个具有父子关系的接口，它们具有相同名称的静态字段和方法：
- en: '[PRE351]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: Please note the capital case for an identifier of an interface field. That’s
    the convention often used to denote a constant, whether it is declared in an interface
    or a class. Just to remind you, a constant in Java is a variable that, once initialized,
    cannot be re-assigned another value. An interface field is a constant by default
    because any field in an interface is *final* (see the *Final properties, methods,
    and classes* section).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意接口字段标识符的大小写。这是通常用来表示常量的约定，无论它是在接口中还是类中声明。只是为了提醒你，Java中的常量是一个变量，一旦初始化，就不能重新分配另一个值。接口字段默认是常量，因为接口中的任何字段都是*final*（参见“*最终属性、方法和类*”部分）。
- en: 'If we print `NAME` from the `B` interface and execute its `method()`, we get
    the following result:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`B`接口打印`NAME`并执行其`method()`，我们会得到以下结果：
- en: '[PRE363]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: It looks very much like overriding, but, in fact, it is just that we call a
    particular property or a method associated with this particular interface.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很像重写，但实际上，我们只是调用与这个特定接口相关联的特定属性或方法。
- en: 'Similarly, consider the following classes:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，考虑以下类：
- en: '[PRE365]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'If we try to access the static members of the `D` class using the class itself,
    we will get what we asked for:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`D`类本身来访问其静态成员，我们会得到我们请求的结果：
- en: '[PRE379]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'The confusion appears only when a property or a static method is accessed using
    an object:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当通过对象访问属性或静态方法时，才会出现混淆：
- en: '[PRE381]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: The `obj` variable refers to the object of the `D` class, and the casting proves
    it, as you can see in the preceding example. But, even if we use an object, trying
    to access a static property or method brings us the members of the class that
    was used as the declared variable type. As for the instance property in the last
    two lines of the example, the properties in Java do not conform to polymorphic
    behavior, and we get the `name1` property of the parent `C` class, instead of
    the expected property of the child `D` class.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`变量指向`D`类的对象，正如前例所示，类型转换证明了这一点。但是，即使我们使用对象，尝试访问静态属性或方法也会带来用作声明变量类型的类的成员。至于示例最后两行中的实例属性，Java中的属性并不符合多态行为，我们得到的是父`C`类的`name1`属性，而不是预期的子`D`类的属性。'
- en: Important Note
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To avoid confusion with static members of a class, always access them using
    the class, not an object. To avoid confusion with instance properties, always
    declare them private and access them via methods.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与类的静态成员混淆，始终使用类而不是对象来访问它们。为了避免与实例属性混淆，始终将它们声明为私有，并通过方法访问它们。
- en: 'To illustrate the last tip, consider the following classes:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明最后一条建议，考虑以下类：
- en: '[PRE388]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: 'If we run the same test for the instance properties as we did for the `C` and
    `D` classes, the result will be this:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对实例属性运行与`C`和`D`类相同的测试，结果将是这样的：
- en: '[PRE406]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: Now, we access instance properties using methods, which are subjects for an
    overriding effect and do not have unexpected results anymore.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过方法访问实例属性，这些方法是重写效应的主题，并且不再有意外结果。
- en: 'To conclude the discussion of hiding in Java, we would like to mention another
    type of hiding, namely when a local variable hides the instance or static property
    with the same name. Here is a class that does it:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束对Java中隐藏特性的讨论后，我们想提及另一种隐藏类型，即当局部变量与同名实例或静态属性隐藏时。以下是一个实现此功能的类：
- en: '[PRE409]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: As you can see, the `name1` local variable hides the static property with the
    same name, while the `name2` local variable hides the instance property. It is
    possible still to access the static property using the class name (see `HidingProperty.name1`).
    Please note that, despite being declared `private`, it is accessible from inside
    the class.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`name1`局部变量隐藏了同名的静态属性，而`name2`局部变量隐藏了实例属性。仍然可以使用类名访问静态属性（见`HidingProperty.name1`）。请注意，尽管它被声明为`private`，但仍然可以从类内部访问。
- en: The instance property can always be accessed by using the `this` keyword, which
    means the **current object**.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性始终可以通过使用`this`关键字来访问，这意味着**当前对象**。
- en: The final variable, method, and classes
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`final`变量、方法和类'
- en: We have mentioned a `final` property several times in relation to the notion
    of a constant in Java, but that is only one case of using the `final` keyword.
    It can be applied to any variable in general. Also, a similar constraint can be
    applied to a method and even a class too, thus preventing the method from being
    overridden and the class from being extended.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次提到`final`属性与Java中常量的概念相关，但这只是使用`final`关键字的一个例子。它可以应用于任何变量。类似地，可以将类似约束应用于方法甚至类，从而防止方法被重写和类被扩展。
- en: The final variable
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`final`变量'
- en: 'The `final` keyword placed in front of a variable declaration makes this variable
    immutable after the initialization, such as the following:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明前放置`final`关键字使得该变量在初始化后不可变，例如以下所示：
- en: '[PRE423]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'The initialization can even be delayed:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化甚至可以延迟：
- en: '[PRE424]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'In the case of an `object` property, this delay can last only until the object
    is created. This means that the property can be initialized in the constructor,
    such as the following:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`object`属性，这种延迟只能持续到对象被创建。这意味着属性可以在构造函数中初始化，如下所示：
- en: '[PRE426]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: Note that, even during the object construction, it is not possible to initialize
    the property twice – during declaration and in the constructor. It is also interesting
    to note that a final property has to be initialized explicitly. As you can see
    from the preceding example, the compiler does not allow the initialization of
    the final property to a default value.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使在对象构造过程中，也无法对属性进行两次初始化——一次在声明时，一次在构造函数中。值得注意的是，必须显式初始化`final`属性。正如前例所示，编译器不允许将`final`属性初始化为默认值。
- en: 'It is also possible to initialize a `final` property in an initialization block:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在初始化块中初始化`final`属性：
- en: '[PRE436]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'In the case of a `static` property, it is not possible to initialize it in
    a constructor, so it has to be initialized either during its declaration or in
    a static initialization block:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态属性，无法在构造函数中初始化它，因此必须在声明期间或静态初始化块中初始化：
- en: '[PRE444]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'In an interface, all fields are always final, even if they are not declared
    as such. Since neither a constructor nor an initialization block is not allowed
    in an interface, the only way to initialize an interface field is during declaration.
    Failing to do it results in a compilation error:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，所有字段始终是最终的，即使它们没有被声明为最终。由于接口中不允许有构造函数或初始化块，初始化接口字段的唯一方法是在声明期间。未能这样做会导致编译错误：
- en: '[PRE452]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: Final method
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终方法
- en: 'A method declared `final` cannot be overridden in a `child` class or hidden
    in the case of a static method. For example, the `java.lang.Object` class, which
    is the ancestor of all classes in Java, has some of its methods declared `final`:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为`final`的方法不能在`子`类中重写，或者在静态方法的情况下隐藏。例如，Java中所有类的祖先`java.lang.Object`类，其中一些方法被声明为`final`：
- en: '[PRE456]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: All the private methods and uninherited methods of a `final` class are effectively
    final because you cannot override them.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`类的所有私有方法和非继承方法实际上是最终的，因为你不能重写它们。'
- en: Final class
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终类
- en: A `final` class cannot be extended. It cannot have children, which makes all
    the methods of the class effectively `final` too. This feature is used for security
    or when a programmer would like to make sure the class functionality cannot be
    overridden, overloaded, or hidden because of some other design considerations.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`类不能被扩展。它不能有子类，这使得类的所有方法实际上也是`final`。这个特性用于安全或当程序员想要确保类功能不能因为其他设计考虑而被重写、覆盖或隐藏。'
- en: The record class
  id: totrans-725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录类
- en: 'The `record` class was added to the SDK in Java 16\. It was a long-awaited
    Java feature. It allows you to avoid writing boilerplate code in a case when you
    need an immutable class (with getters only), which looks similar to the following
    `Person` class (see the `Record` class in the `ch02_oop` folder):'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`类是在Java 16中添加到SDK的。这是一个长期期待的功能。它允许你在需要不可变类（只有getters）的情况下避免编写样板代码，如下面的`Person`类所示（请参阅`ch02_oop`文件夹中的`Record`类）：'
- en: '[PRE464]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: Please note that the getters in the preceding above do not have the `get` prefix.
    It is done deliberately because, in the case of immutable class, there is no need
    to distinguish between getters and setters, as setters do not and should not exist
    if we want to have the class truly immutable. And that is the principal difference
    between such a class and JavaBeans, which are mutable and have both – setters
    and getters.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面上面的getters没有`get`前缀。这是故意为之，因为在不可变类的情况下，没有必要区分getters和setters，因为如果我们想使类真正不可变，那么setters既不应该也不应该存在。这就是此类与JavaBeans之间的主要区别，JavaBeans是可变的，既有setters也有getters。
- en: 'The `record` class allows you to replace the preceding implementation with
    the following one line only:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`类允许你只用一行代码替换前面的实现：'
- en: '[PRE485]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'We can demonstrate it with the following code:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码来演示：
- en: '[PRE486]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'In addition to being `final` (not extendable) and immutable, `record` cannot
    extend another class because it already extends `java.lang.Record`, but it can
    implement another interface, as shown in the following example:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是`final`（不可扩展）和不可变之外，`record`不能扩展另一个类，因为它已经扩展了`java.lang.Record`，但它可以实现另一个接口，如下面的示例所示：
- en: '[PRE501]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'It is possible to add a `static` method to `record`, as shown in the following
    code snippet:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向`record`添加一个`static`方法，如下面的代码片段所示：
- en: '[PRE508]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: A `static` method does not and cannot access instance properties and can utilize
    only the values passed into it as parameters.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法既不能也不能访问实例属性，只能利用传递给它的参数值。
- en: '`record` can have another constructor, which can be added, for example, as
    follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`可以有一个额外的构造函数，例如可以添加如下：'
- en: '[PRE513]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: As you may have noticed, it is not possible to add another property or a setter
    to `record`, while all additional getters have to use only getters provided already
    by `record`.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，无法向`record`添加另一个属性或setter，而所有额外的getters都必须只使用`record`已提供的getters。
- en: Sealed classes and interfaces
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封类和接口
- en: A `final` class cannot be extended, while a non-public class or interface has
    limited access. Yet, there are times when a class or interface needs to be accessible
    from anywhere but be extendable only by a certain class or interface, or, in the
    case of an interface, be implemented only by certain classes. That was the motivation
    for `sealed` classes and interfaces being added to the SDK in Java 17.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`final`类不能被扩展，而非公共类或接口的访问权限有限。然而，有时一个类或接口需要从任何地方都可以访问，但只能由某个特定的类或接口扩展，或者在接口的情况下，只能由某些类实现。这就是在Java
    17中向SDK添加`密封`类和接口的动机。
- en: The difference between a `sealed` class or interface and a `final` one is that
    a `sealed` class or interface always has a `permits` keyword, followed by the
    list of the existing direct subtypes that are allowed to extend the `sealed` class
    or interface, or, in the case of the interface, implement it. Please note the
    word *existing*. The subtypes listed after the `permits` keyword must exist at
    compilation time in the same module as the sealed class or in the same package
    if in the default (unnamed) module.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '`密封`类或接口与`final`类或接口之间的区别在于，`密封`类或接口总是有一个`permits`关键字，后面跟着允许扩展`密封`类或接口的现有直接子类列表，或者在接口的情况下，实现它的类。请注意，这里的词*existing*。在`permits`关键字后面的子类必须在编译时存在于与密封类相同的模块中，或者在默认（未命名的）模块中，如果是在同一个包中。'
- en: A subtype of a `sealed` class must be marked either `sealed`, `final`, or `non-sealed`.
    A subtype of a `sealed` interface must be marked either `sealed` or `non-sealed`,
    since an interface cannot be `final`.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`密封`类的子类必须标记为`sealed`、`final`或`non-sealed`。`密封`接口的子类必须标记为`sealed`或`non-sealed`，因为接口不能是`final`。'
- en: 'Let’s look at an example of a `sealed` interface first:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一个`密封`接口的例子：
- en: '[PRE518]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'As you can see, the `EngineBrand` interface extends the `Engine` interface
    and allows (permits) the `Vehicle` implementation. Alternatively, we can allow
    the `Vehicle` class to implement the `Engine` interface directly, as shown in
    the following example:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`EngineBrand`接口扩展了`Engine`接口，并允许（允许）`Vehicle`实现。或者，我们也可以允许`Vehicle`类直接实现`Engine`接口，如下面的例子所示：
- en: '[PRE539]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: 'Now, let’s look at an example of a `sealed` class:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个`密封`类的例子：
- en: '[PRE546]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'The following is an example of the `Car` and `Truck` permitted subtypes of
    the `Vehicle` `sealed` class:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`Car`和`Truck`作为`Vehicle` `密封`类允许的子类的例子：
- en: '[PRE558]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'In support `sealed` classes, the Java Reflections API in Java 17 has two new
    methods, `isSealed()` and `getPermittedSubclasses()`. The following is an example
    of their usage:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`密封`类，Java 17中的Java Reflections API有两个新方法，`isSealed()`和`getPermittedSubclasses()`。以下是他们使用的一个例子：
- en: '[PRE576]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: The `sealed` interface integrates well with `record` because `record` is `final`
    and can be listed as a permittable implementation.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`密封`接口与`record`很好地集成，因为`record`是`final`的，可以被列为允许的实现。'
- en: Polymorphism in action
  id: totrans-868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态的实际应用
- en: Polymorphism is the most powerful and useful feature of OOP. It uses all the
    other OOP concepts and features we have presented so far. It is the highest conceptual
    point on the way to mastering Java programming. After discussing it, the rest
    of the book will be mostly about Java language syntax and JVM functionality.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是面向对象编程（OOP）中最强大和最有用的特性。它使用了我们迄今为止所展示的所有其他OOP概念和特性。它是掌握Java编程道路上的最高概念点。在讨论完它之后，本书的其余部分将主要关于Java语言语法和JVM功能。
- en: As we stated in the *OOP concepts* section, polymorphism is the ability of an
    object to behave as an object of different classes or as an implementation of
    different interfaces. If you search the word *polymorphism* on the internet, you
    will find that it is *the condition of occurring in several different forms*.
    Metamorphosis is *a change of the form or nature of a thing or person into a completely
    different one, by natural or supernatural means*. So, **Java polymorphism** is
    the ability of an object to behave as if going through a metamorphosis and to
    exhibit completely different behaviors under different conditions.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*OOP概念*部分所提到的，多态是对象能够表现为不同类或不同接口的实现的能力。如果你在网上搜索单词*polymorphism*，你会发现它是*以几种不同形式出现的状态*。变形是*通过自然或超自然手段将事物或人的形式或本质改变为完全不同的一种形式*。所以，**Java多态**是对象能够表现为好像经历变形，并在不同条件下表现出完全不同的行为的能力。
- en: We will present this concept in a practical hands-on way, using an **object
    factory** – a specific programming implementation of a factory, which is a *method
    that returns objects of a varying prototype or class* ([https://en.wikipedia.org/wiki/Factory_(object-oriented_programming](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实际动手的方式来展示这个概念，使用一个**对象工厂**——工厂模式的具体编程实现，它是一个*返回不同原型或类的对象的方法*（[https://en.wikipedia.org/wiki/Factory_(object-oriented_programming](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming))）。
- en: The object factory
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象工厂
- en: 'The idea behind the object factory is to create a method that returns a new
    object of a certain type under certain conditions. For example, look at the `CalcUsingAlg1`
    and `CalcUsingAlg2` classes:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 对象工厂背后的理念是创建一种方法，在特定条件下返回某种类型的新对象。例如，看看`CalcUsingAlg1`和`CalcUsingAlg2`类：
- en: '[PRE587]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: 'As you can see, they both implement the same interface, `CalcSomething`, but
    use different algorithms. Now, let’s say that we decided that the selection of
    the algorithm used will be done in a `property` file. Then, we can create the
    following object factory:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们都实现了相同的接口`CalcSomething`，但使用了不同的算法。现在，假设我们决定算法的选择将在`属性`文件中完成。然后，我们可以创建以下对象工厂：
- en: '[PRE600]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: 'The factory selects which algorithm to use based on the value returned by the
    `getAlgValueFromPropertyFile()` method. In the case of the second algorithm, it
    also uses the `getAlg2Prop1FromPropertyFile()` methods and `getAlg2Prop2FromPropertyFile()`
    to get the input parameters for the algorithm. But this complexity is hidden from
    the client:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂根据`getAlgValueFromPropertyFile()`方法返回的值来选择使用哪个算法。对于第二个算法，它还使用`getAlg2Prop1FromPropertyFile()`方法和`getAlg2Prop2FromPropertyFile()`来获取算法的输入参数。但这种复杂性对客户端是隐藏的：
- en: '[PRE616]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: We can add new algorithm variations, and change the source for the algorithm
    parameters or the process of the algorithm selection, but the client will not
    need to change the code. And that is the power of polymorphism.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加新的算法变体，改变算法参数的来源或算法选择的过程，但客户端不需要更改代码。这就是多态的力量。
- en: 'Alternatively, we can use inheritance to implement polymorphic behavior. Consider
    the following classes:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用继承来实现多态行为。考虑以下类：
- en: '[PRE618]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'Then, our factory may look as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的工厂可能看起来如下：
- en: '[PRE630]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: 'But the client code does not change:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 但客户端代码并没有改变：
- en: '[PRE646]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: Given a choice, an experienced programmer uses a common interface for the implementation.
    It allows for a more flexible design, as a class in Java can implement multiple
    interfaces but can extend (inherit from) one class.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 在有选择的情况下，经验丰富的程序员会使用一个通用的接口来实现。这允许有更灵活的设计，因为Java中的一个类可以实现多个接口，但只能扩展（继承自）一个类。
- en: The instanceof operator
  id: totrans-942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instanceof运算符
- en: Unfortunately, life is not always that easy, and once in a while, a programmer
    has to deal with code that is assembled from unrelated classes, even coming from
    different frameworks. In such a case, using polymorphism may be not an option.
    However, you can hide the complexity of an algorithm selection and even simulate
    polymorphic behavior using the `instanceof` operator, which returns `true` when
    an object is an instance of a certain class.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，生活并不总是那么简单，有时候程序员不得不处理由不相关的类组装的代码，甚至来自不同的框架。在这种情况下，使用多态可能不是一个选择。然而，你可以使用`instanceof`运算符来隐藏算法选择复杂性，甚至模拟多态行为，当对象是某个类的实例时，它会返回`true`。
- en: 'Let’s assume we have two unrelated classes:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个不相关的类：
- en: '[PRE648]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: 'Each of the classes expects as an input an object of a certain type:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都期望输入一个特定类型的对象：
- en: '[PRE658]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'And let’s assume that the method we implement receives such an object:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们实现的方法接收这样一个对象：
- en: '[PRE673]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: We still use polymorphism here because we describe our input as the `Object`
    type. We can do it because the `Object` class is the base class for all Java classes.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里仍然使用多态，因为我们把我们的输入描述为`Object`类型。我们可以这样做，因为`Object`类是所有Java类的基类。
- en: 'Now, let’s look at how the `Calculator` class is implemented:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Calculator`类是如何实现的：
- en: '[PRE677]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: As you can see, it uses the `instanceof` operator for selecting the appropriate
    algorithm. By using the `Object` class as an input type, the `Calculator` class
    takes advantage of polymorphism too, but most of its implementation has nothing
    to do with it. Yet, from the outside, it looks polymorphic, and it is, but only
    to a degree.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用`instanceof`运算符来选择合适的算法。通过使用`Object`类作为输入类型，`Calculator`类也利用了多态性，但它的实现大部分与此无关。然而，从外部看，它看起来是多态的，确实如此，但只是程度不同。
- en: Summary
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduced you to the concepts of OOP and how they are implemented
    in Java. It provided an explanation of each concept and demonstrated how to use
    it in specific code examples. The Java language constructs of `class` and `interface`
    were discussed in detail. You also learned what overloading, overriding, and hiding
    are and how to use the `final` keyword to protect methods from being overridden.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了面向对象的概念以及它们如何在Java中实现。它解释了每个概念，并通过具体的代码示例演示了如何使用它们。详细讨论了`class`和`interface`的Java语言构造。您还学习了什么是重载、重写和隐藏，以及如何使用`final`关键字来保护方法不被重写。
- en: In the *Polymorphism in action* section, you learned about the powerful Java
    feature of polymorphism. This section brought all the presented material together
    and showed how polymorphism stays at the center of OOP.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 在*多态性实践*部分，您了解了Java强大的多态特性。本节将所有展示的材料汇总在一起，展示了多态性如何成为面向对象的核心。
- en: In the next chapter, you will become familiar with the Java language syntax,
    including packages, importing, access modifiers, reserved and restricted keywords,
    and some aspects of Java reference types. You will also learn how to use the `this`
    and `super` keywords, what widening and narrowing conversions of primitive types
    are, boxing and unboxing, primitive and reference type assignment, and how the
    `equals()` method of a reference type works.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将熟悉Java语言的语法，包括包、导入、访问修饰符、保留和限制性关键字，以及Java引用类型的一些方面。您还将学习如何使用`this`和`super`关键字，了解原始类型宽化和窄化转换、装箱和拆箱、原始类型和引用类型赋值，以及引用类型`equals()`方法的工作原理。
- en: Quiz
  id: totrans-995
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Select all the correct OOP concepts from the following list:'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的面向对象概念：
- en: Encapsulation
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装
- en: Isolation
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隔离
- en: Pollination
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传粉
- en: Inheritance
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承
- en: 'Select all the correct statements from the following list:'
  id: totrans-1001
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: A Java object has status.
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象有状态。
- en: A Java object has behavior.
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象有行为。
- en: A Java object has state.
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象有状态。
- en: A Java object has methods.
  id: totrans-1005
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象有方法。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1006
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: A Java object behavior can be inherited.
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象的行为可以被继承。
- en: A Java object behavior can be overridden.
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象的行为可以被重写。
- en: A Java object behavior can be overloaded.
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象的行为可以被重载。
- en: A Java object behavior can be overwhelmed.
  id: totrans-1010
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java对象的行为可以被覆盖。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1011
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Java objects of different classes can have the same behavior.
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同类的Java对象可以具有相同的行为。
- en: Java objects of different classes share a parent object state.
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同类的Java对象共享父对象的状态。
- en: Java objects of different classes have as a parent an object of the same class.
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同类的Java对象有一个相同类的父对象。
- en: Java objects of different classes can share behavior.
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同类的Java对象可以共享行为。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: The method signature includes the return type.
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法签名包括返回类型。
- en: The method signature is different if the return type is different.
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果返回类型不同，方法签名会不同。
- en: The method signature changes if two parameters of the same type switch positions.
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个相同类型的参数交换位置，方法签名会改变。
- en: The method signature changes if two parameters of different types switch positions.
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个不同类型的参数交换位置，方法签名会改变。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Encapsulation hides the class name.
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装隐藏了类名。
- en: Encapsulation hides behavior.
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装隐藏了行为。
- en: Encapsulation allows access to data only via methods.
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装允许仅通过方法访问数据。
- en: Encapsulation does not allow direct access to the state.
  id: totrans-1025
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装不允许直接访问状态。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1026
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: The class is declared in the `.java` file.
  id: totrans-1027
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类在`.java`文件中声明。
- en: The class bytecode is stored in the `.class` file.
  id: totrans-1028
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的字节码存储在`.class`文件中。
- en: The parent class is stored in the `.base` file.
  id: totrans-1029
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父类存储在`.base`文件中。
- en: The `child` class is stored in the `.sub` file.
  id: totrans-1030
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`child`类存储在`.sub`文件中。'
- en: 'Select all the correct statements from the following list:'
  id: totrans-1031
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: A method defines an object state.
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法定义了对象的状态。
- en: A method defines object behavior.
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法定义了对象的行为。
- en: A method without parameters is marked as `void`.
  id: totrans-1034
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有参数的方法标记为`void`。
- en: A method can have many `return` statements.
  id: totrans-1035
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法可以有多个`return`语句。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: '`Varargs` is declared as a `var` type.'
  id: totrans-1037
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varargs`声明为`var`类型。'
- en: '`Varargs` stands for *various arguments*.'
  id: totrans-1038
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varargs`代表*各种参数*。'
- en: '`Varargs` is a `String` array.'
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varargs`是一个`String`数组。'
- en: '`Varargs` can act as an array of the specified type.'
  id: totrans-1040
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varargs`可以作为指定类型的数组。'
- en: 'Select all the correct statements from the following list:'
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: A constructor is a method that creates a state.
  id: totrans-1042
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数是一个创建状态的方法。
- en: The primary responsibility of a constructor is to initialize a state.
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的主要责任是初始化状态。
- en: JVM always provides a default constructor.
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM始终提供默认构造函数。
- en: The parent class constructor can be called using the `parent` keyword.
  id: totrans-1045
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`parent`关键字调用父类构造函数。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1046
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: The `new` operator allocates memory to an object.
  id: totrans-1047
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new`运算符为对象分配内存。'
- en: The `new` operator assigns default values to the object properties.
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new`运算符为对象属性分配默认值。'
- en: The `new` operator creates a parent object first.
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new`运算符首先创建一个父对象。'
- en: The `new` operator creates a child object first.
  id: totrans-1050
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new`运算符首先创建一个子对象。'
- en: 'Select all the correct statements from the following list:'
  id: totrans-1051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: An `Object` class belongs to the `java.base` package.
  id: totrans-1052
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`类属于`java.base`包。'
- en: An `Object` class belongs to the `java.lang` package.
  id: totrans-1053
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`类属于`java.lang`包。'
- en: An `Object` class belongs to a package of the Java Class Library.
  id: totrans-1054
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`类属于Java类库的包。'
- en: An `Object` class is imported automatically.
  id: totrans-1055
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`类自动导入。'
- en: 'Select all the correct statements from the following list:'
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: An instance method is invoked using an object.
  id: totrans-1057
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例方法使用对象调用。
- en: A static method is invoked using a class.
  id: totrans-1058
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法使用类调用。
- en: An instance method is invoked using a class.
  id: totrans-1059
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例方法使用类调用。
- en: A static method is invoked using an object.
  id: totrans-1060
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法使用对象调用。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Methods in an interface are implicitly `public`, `static`, and `final`.
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口中的方法隐式为`public`、`static`和`final`。
- en: An interface can have methods that can be invoked without being implemented
    in a class.
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以有方法可以在不实现于类的情况下调用。
- en: An interface can have fields that can be used without any class.
  id: totrans-1064
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以有字段可以在没有任何类的情况下使用。
- en: An interface can be instantiated.
  id: totrans-1065
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以被实例化。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1066
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: The default method of an interface is always invoked by default.
  id: totrans-1067
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口的默认方法始终默认调用。
- en: The private method of an interface can be invoked only by the default method.
  id: totrans-1068
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口中的私有方法只能通过默认方法调用。
- en: The interface static method can be invoked without being implemented in a class.
  id: totrans-1069
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口静态方法可以在不实现于类的情况下调用。
- en: The default method can enhance a class that implements the interface.
  id: totrans-1070
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认方法可以增强实现接口的类。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1071
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: An `Abstract` class can have a default method.
  id: totrans-1072
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`抽象`类可以有一个默认方法。
- en: An `Abstract` class can be declared without an `abstract` method.
  id: totrans-1073
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`抽象`类可以声明而没有`抽象`方法。
- en: Any class can be declared abstract.
  id: totrans-1074
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何类都可以声明为抽象。
- en: An interface is an `abstract` class without a constructor.
  id: totrans-1075
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口是一个没有构造函数的`抽象`类。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1076
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Overloading can be done only in an interface.
  id: totrans-1077
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只能在接口中重载。
- en: Overloading can be done only when one class extends another.
  id: totrans-1078
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在有一个类扩展另一个类时才能重载。
- en: Overloading can be done in any class.
  id: totrans-1079
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在任何类中重载。
- en: The overloaded method must have the same signature.
  id: totrans-1080
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载的方法必须有相同的签名。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1081
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Overriding can be done only in a `child` class.
  id: totrans-1082
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只能在`child`类中重写。
- en: Overriding can be done in an interface.
  id: totrans-1083
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在接口中重载。
- en: The overridden method must have the same name.
  id: totrans-1084
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被重写的方法必须具有相同的名称。
- en: No method of an `Object` class can be overridden.
  id: totrans-1085
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`类的任何方法都不能被重写。'
- en: 'Select all the correct statements from the following list:'
  id: totrans-1086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Any method can be hidden.
  id: totrans-1087
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何方法都可以被隐藏。
- en: A variable can hide a property.
  id: totrans-1088
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以隐藏属性。
- en: A static method can be hidden.
  id: totrans-1089
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法可以被隐藏。
- en: A public instance property can be hidden.
  id: totrans-1090
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共实例属性可以被隐藏。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Any variable can be declared final.
  id: totrans-1092
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何变量都可以被声明为final。
- en: A public method cannot be declared final.
  id: totrans-1093
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共方法不能被声明为final。
- en: A protected method can be declared final.
  id: totrans-1094
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护的可以声明为final。
- en: A class can be declared protected.
  id: totrans-1095
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类可以被声明为protected。
- en: 'Select all the correct statements from the following list:'
  id: totrans-1096
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有正确的陈述：
- en: Polymorphic behavior can be based on inheritance.
  id: totrans-1097
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态行为可以基于继承。
- en: Polymorphic behavior can be based on overloading.
  id: totrans-1098
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态行为可以基于重载。
- en: Polymorphic behavior can be based on overriding.
  id: totrans-1099
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态行为可以基于重写。
- en: Polymorphic behavior can be based on an interface.
  id: totrans-1100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态行为可以基于接口。
