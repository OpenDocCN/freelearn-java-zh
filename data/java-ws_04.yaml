- en: 4\. Collections, Lists and Java's Built-In APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 集合、列表和Java的内置API
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the powerful Java collections framework, which
    is used to store, sort, and filter data. It will first take you through the structure
    of the built-in Collections **Application Programming Interface** (**API**), the
    Java collections framework, which will simplify your dealings with complex data
    structures and allow you to use and create APIs with minimal effort. Through this
    framework, you will examine the relationship between lists and arrays, and learn
    to populate lists from arrays. Finally, in this chapter's final activity, you
    will create and complete a program in which you will be asked to perform standard
    operations on data stored in sets, lists, and maps in preparation for future chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍强大的Java集合框架，该框架用于存储、排序和过滤数据。它将首先带您了解内置的集合**应用程序编程接口**（**API**），即Java集合框架，这将简化您与复杂数据结构的交互，并允许您以最小的努力使用和创建API。通过这个框架，您将检查列表和数组之间的关系，并学习如何从数组中填充列表。最后，在本章的最后一个活动中，您将创建并完成一个程序，在这个程序中，您将被要求对存储在集合、列表和映射中的数据进行标准操作，为未来的章节做准备。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Java comes with a built-in Collections API, allowing you to manipulate data
    structures with very little effort. A collection is an object that contains multiple
    elements. Collections are used to store, share, process, and communicate aggregated
    data. We call this system the **Java collections framework**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java自带内置的集合API，允许你以极少的努力操作数据结构。集合是一个包含多个元素的对象。集合用于存储、共享、处理和通信聚合数据。我们称这个系统为**Java集合框架**。
- en: 'As part of this framework, there are different components that are used to
    optimize our interaction with the actual data:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个框架的一部分，有不同组件用于优化我们与实际数据的交互：
- en: '**Interfaces**: Abstract data types that represent collections'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：表示集合的抽象数据类型'
- en: '**Implementations**: Specific implementations of the collection interfaces'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：集合接口的具体实现'
- en: '**Algorithms**: Polymorphic methods used to process the data within a collection
    for operations such as sorting and searching'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：用于在集合中处理数据的多态方法，例如排序和搜索操作'
- en: Note
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Other programming languages have their own collection frameworks. For example,
    C++ has the **Standard Template Library** (**STL**). Java boasts simplicity when
    it comes to its collection framework.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他编程语言也有自己的集合框架。例如，C++有**标准模板库**（**STL**）。Java在集合框架方面以简单著称。
- en: Using the collections framework has many benefits, including a reduction in
    the complexity of creating programs that deal with data structures, an increase
    in the performance of programs, a simplification of API creation and use, and
    an increase in the reuse of functioning software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合框架有许多好处，包括减少处理数据结构程序的复杂性、提高程序性能、简化API创建和使用，以及增加功能软件的重用。
- en: The collections framework is relevant even when handling data that can be accessed
    by several processes simultaneously, as this would be the case in multithreaded
    programming scenarios. However, it is not the intention of this chapter to deal
    with concurrent programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在可以由多个进程同时访问数据的情况下，集合框架也是相关的，例如在多线程编程场景中。然而，本章的目的并不是处理并发编程。
- en: 'The Collections API comes with five main interfaces:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 集合API包含五个主要接口：
- en: '`Set`: A collection that contains no duplicates'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`集合`：不包含重复元素的集合'
- en: '`List`: An ordered collection or sequence, allowing for duplicates'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`列表`：一个有序集合或序列，允许有重复元素'
- en: '`Queue`: A collection that sorts data in the order of its arrival, typically
    handled as a **First In First Out** (**FIFO**) process'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`队列`：按到达顺序排序数据的集合，通常作为**先进先出**（**FIFO**）过程处理'
- en: '`Deque`: Essentially a queue that allows for data insertion at both ends, meaning
    that it can be handled both as FIFO and **Last In First Out** (**LIFO**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`双端队列`：本质上是一个允许在两端插入数据的队列，这意味着它可以作为**先进先出**（**FIFO**）和**后进先出**（**LIFO**）处理'
- en: '`Map`: Relates keys—which must be unique—to values'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`映射`：将键（必须是唯一的）与值相关联'
- en: In this chapter, we will define the main interfaces (lists, sets, and maps),
    and explore examples of their respective uses. The framework has even more interfaces
    than the ones listed previously, but the others are either just variations of
    those listed or are outside the scope of this chapter. Furthermore, we will look
    at how arrays work in much more depth than we have previously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义主要接口（列表、集合和映射），并探讨它们各自的使用示例。该框架比之前列出的接口更多，但其他接口要么是那些列出的变体，要么超出了本章的范围。此外，我们将比以前更深入地探讨数组的工作原理。
- en: 'The definition of a simple collection—in this case, a specific type of set
    would be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简单集合的定义——在这种情况下，特定类型的集合的定义如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The different available classes for sets, lists, queues, deques, and maps are
    named after the interfaces. The different classes present different properties,
    as we will see later in the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的不同集合类（集合、列表、队列、双端队列和映射）以接口命名。不同的类具有不同的属性，我们将在本章后面看到。
- en: Arrays
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are part of the collections framework. There are some static methods
    that can be used to manipulate arrays. The operations you can perform are creating,
    sorting, searching, comparing, streaming, and transforming arrays. You were introduced
    to arrays in *Chapter 2*, *Learning the Basics*, where you saw how they can be
    used to store data of the same type. The declaration of an array is quite straightforward.
    Let''s see what an array of strings would look like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是集合框架的一部分。有一些静态方法可以用来操作数组。您可以执行的操作包括创建、排序、搜索、比较、流式传输和转换数组。您在*第二章*，*学习基础知识*中介绍了数组，您看到了它们如何用于存储相同类型的数据。数组的声明相当简单。让我们看看字符串数组会是什么样子：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running operations on an array is as easy as calling some of the methods contained
    in the `java.util.Arrays` package. For example, sorting the previous array would
    require calling the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上运行操作与调用`java.util.Arrays`包中包含的一些方法一样简单。例如，对前面的数组进行排序需要调用以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The methods dedicated to handling arrays include one method that could be used
    to print out full arrays as if they were strings. This can be very handy when
    debugging a program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于处理数组的函数包括一个可以用来打印完整数组的方法，就像它们是字符串一样。这在调试程序时非常有用：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will print the arrays and display each element separated by commas and
    within square brackets, `[]`. If you executed the previous command after sorting
    the declared array of strings, the outcome would be:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印数组并显示每个元素，用逗号分隔，并用方括号括起来，`[]`。如果您在排序声明的字符串数组之后执行前面的命令，结果将是：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the array has been sorted in ascending alphabetical order.
    There is a difference between that way of printing out an array and using a `for`
    loop to iterate throughout an array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数组已按升序字母顺序排序。打印数组的方式与使用`for`循环遍历数组的方式不同：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This would give the following as the result:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下结果：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to write your code in a slightly cleaner way, you could import
    the whole `java.util.Arrays` API at the beginning of your program, which would
    allow you to call the methods by omitting the `java.util` part of the command.
    See the following example highlighting this technique:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以稍微干净一些的方式编写代码，可以在程序开始时导入整个`java.util.Arrays` API，这将允许您通过省略命令中的`java.util`部分来调用方法。以下示例突出了这一技术：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The outcome will be:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to make a new array that you wanted to be filled up with the same
    data for all cells, there is the possibility of calling the `java.util.Arrays.fill()`
    method, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要创建一个新数组，希望所有单元格都填充相同的数据，可以使用`java.util.Arrays.fill()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Such a command would create an array filled with zeros:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令将创建一个填充为零的数组：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating arrays with prefilled data can also be done with a copy of a preexisting
    array. It is possible to create an array by copying part of one array, or by instantiating
    a larger one where the old one would just be part of it. Both methods are shown
    in the following example, which you can test in your editor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有数组的副本也可以创建带有预填充数据的数组。可以通过复制一个数组的部分来创建一个数组，或者实例化一个更大的数组，其中旧数组只是它的一部分。以下示例展示了这两种方法，您可以在您的编辑器中测试：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example will print the `numbers`, `shortNumbers` (which is shorter), and
    `longNumbers` (which is longer) arrays. The newly added positions in the array
    will be filled with zeros. If it was an array of strings, they would be filled
    up with `null`. The outcome of this example is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将打印`numbers`、`shortNumbers`（较短）和`longNumbers`（较长）数组。数组中新添加的位置将被零填充。如果它是一个字符串数组，它们将被`null`填充。此示例的结果是：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can compare arrays by calling the `java.utils.Arrays.equals()` or `java.util.Arrays.deepEquals()`
    methods. The difference between them is that the latter can look through nested
    arrays. A simple comparison example of the former method in use follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`java.utils.Arrays.equals()`或`java.util.Arrays.deepEquals()`方法来比较数组。它们之间的区别在于后者可以查看嵌套数组。以下是一个使用前者的简单比较示例：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we create four arrays: `numbers1`, `numbers2`, `numbers3`,
    and `numbers4`. Only two of them are the same, containing three instances of `1`.
    In the example, you can see how the last three arrays are compared to the first
    one. You can also see how the last array differs not in content, but in size.
    The outcome of this code is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了四个数组：`numbers1`、`numbers2`、`numbers3`和`numbers4`。其中只有两个数组相同，包含三个`1`的实例。在示例中，您可以看到最后三个数组是如何与第一个数组进行比较的。您还可以看到最后一个数组在内容上没有区别，但大小不同。此代码的结果是：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since this chapter is not looking into such a complex data structure as nested
    arrays, we will not show an example of `java.util.Arrays.deepEquals()`. If you're
    interested, you should consider checking the Java reference at [https://packt.live/2MuRrNa](https://packt.live/2MuRrNa).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章没有探讨像嵌套数组这样复杂的数据结构，因此我们不会展示`java.util.Arrays.deepEquals()`的示例。如果您感兴趣，应该考虑查阅[https://packt.live/2MuRrNa](https://packt.live/2MuRrNa)上的Java参考文档。
- en: 'Searching within arrays is done through different algorithms behind the scenes.
    It is obviously a lot faster to perform searches on sorted arrays than on unsorted
    ones. The method to be invoked to run such a search on a sorted array is `Arrays.binarySearch()`.
    As it has many possible parameter combinations, it is recommended to visit the
    official documentation for the method. The following example illustrates how it
    works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中进行搜索是通过后台的不同算法完成的。显然，在排序数组上执行搜索比在未排序数组上要快得多。要在排序数组上运行此类搜索，应调用`Arrays.binarySearch()`方法。由于它有许多可能的参数组合，建议访问该方法的官方文档。以下示例说明了它是如何工作的：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code is going to search for the word `the` inside the array text. The
    result is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在数组text中搜索单词`the`。结果是：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is wrong! `binarySearch` is an optimized search algorithm within the collections
    framework, but it is not optimal when used with unsorted arrays. This means that
    `binarySearch` is mainly very useful for determining whether an object can be
    found within an array (by sorting it first). At the same time, we will need a
    different algorithm when we must search through unsorted arrays and when there
    are multiple occurrences of a value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的！`binarySearch`是集合框架内的优化搜索算法，但与未排序数组一起使用时并不最优。这意味着`binarySearch`主要用于确定是否可以在数组中找到对象（通过先对其进行排序）。同时，当我们必须搜索未排序的数组或存在多个值时，我们需要不同的算法。
- en: 'Try the following modification of the previous example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下对先前示例的修改：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The outcome, since the array is sorted, will be:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组已排序，结果将是：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is only a coincidence in this case that "`is`" happens to be in the same
    place in the unsorted and the sorted versions of the array. Making use of the
    tools you've been learning about, it should be possible for you to create an algorithm
    that can iterate throughout an array and count all the existing items, even if
    they are repeated, as well as locating their positions within the array. See *Activity
    1*, *Searching for Multiple Occurrences in an Array* in this chapter, where we
    challenge you to write such a program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，"`is`"恰好出现在未排序和排序数组版本中的相同位置只是一个巧合。利用您一直在学习的工具，您应该能够创建一个算法，该算法可以遍历数组并计算所有现有项目，即使它们是重复的，以及它们在数组中的位置。请参阅本章中的*活动1*，*在数组中搜索多个出现*，其中我们挑战您编写这样的程序。
- en: You can also transform objects of the `java.util.Arrays` class into strings
    with the `Arrays.toString()` method, as we saw at the beginning of this section,
    into a list with `Arrays.asList()` (we will see this in a later section, as well
    as in `Example05`) or into a set with `Arrays.setAll()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`java.util.Arrays`类的`Arrays.toString()`方法将对象转换为字符串，就像我们在本节开头看到的那样，使用`Arrays.asList()`（我们将在后面的章节中看到，以及`Example05`）或使用`Arrays.setAll()`转换为集合。
- en: 'Arrays and collections play important roles in software development. This section
    of the chapter dives into the differences between them as well as how they can
    be used together. If you search the internet for the relationship between these
    two constructs, most references you find will be focused on the differences, such
    as:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和集合在软件开发中扮演着重要的角色。本章的这一部分深入探讨了它们之间的区别以及它们如何一起使用。如果你在网上搜索这两个构造之间的关系，你找到的大多数参考资料都将集中在它们的区别上，例如：
- en: Arrays have fixed sizes, while collections have variable sizes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组有固定的大小，而集合有可变的大小。
- en: Arrays can hold objects of any kind, but also primitives; collections cannot
    contain primitives.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以持有任何类型的对象，也可以持有原始数据类型；集合不能包含原始数据类型。
- en: Arrays will hold homogeneous elements (elements that are all the same nature),
    while collections can hold heterogeneous elements.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组将持有同质元素（所有元素性质相同），而集合可以持有异质元素。
- en: Arrays have no underlying data structure, while collections are implemented
    using standard structures.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组没有底层的数据结构，而集合使用标准结构实现。
- en: If you know the amount of data you are going to be dealing with, arrays are
    the preferred tool, mainly because arrays perform better than lists or sets in
    such cases. However, there will be countless occasions when you don't know the
    amount of data you will be dealing with, which is where lists will be handy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你将要处理的数据量，数组是首选的工具，主要是因为在这种情况下数组的表现优于列表或集合。然而，会有无数的情况，你不知道你将要处理的数据量，这时候列表就会变得很有用。
- en: 'Also, arrays can be used to programmatically populate collections. We will
    be doing this throughout this chapter as a way of saving you the time of having
    to manually type all the data that will end up inside a collection, for example.
    The following example shows how to populate a set using an array:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数组还可以用于以编程方式填充集合。我们将在本章中这样做，以节省你手动输入最终将存储在集合中的所有数据的时间，例如。以下示例显示了如何使用数组填充一个集合：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this program, there is an array of `Integer` used to initialize an object
    of the `HashSet` class, which is later printed out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，有一个`Integer`类型的数组被用来初始化`HashSet`类的一个对象，这个对象随后被打印出来。
- en: 'The outcome of this example is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果是：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code listing shows a couple of interesting things. First of all,
    you will notice that the output to the program is sorted; that is because the
    conversion of the array to a list using `Arrays.asList()` will make the dataset
    inherit the properties of a list, which means that it will be sorted. Also, since
    the data has been added to a set and sets do not include duplicates, duplicate
    number two is left out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例显示了几个有趣的事情。首先，你会注意到程序输出的结果是排序的；这是因为使用`Arrays.asList()`将数组转换为列表会使数据集继承列表的性质，这意味着它将是排序的。此外，由于数据已经添加到集合中，而集合不包含重复项，所以第二个重复的数字被省略了。
- en: 'It is important to note that with collections, you can specify the type to
    be stored. As such, there would be a difference between the declaration in the
    previous example, where we displayed a generic declaration, and what follows.
    The type is declared here using the name given within angle brackets, `<>`. In
    this case, it is `<Integer>`. You could rewrite the instantiation of the object
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用集合，你可以指定要存储的类型。因此，在之前的示例中，我们展示了泛型声明，以及接下来的声明之间会有所不同。类型在这里使用尖括号内的名称声明，即`<>`。在这种情况下，它是`<Integer>`。你可以将对象的实例化重写如下：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will see that the result of executing the program will be the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现程序执行的结果将是相同的。
- en: 'Activity 1: Searching for Multiple Occurrences in an Array'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1：在数组中搜索多个出现
- en: 'Write a program that will search for multiple occurrences of a certain word
    in an array of strings, where each one of the objects is a single word. Use the
    following array, a famous quote by Frank Zappa, as a point of departure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，用于在字符串数组中搜索某个单词的多个出现，其中每个对象都是一个单独的单词。以下是一个著名的弗兰克·扎帕语录的数组，作为出发点：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The word to search for is `so`. but you will have to consider that it shows
    up twice and that one instance is not in lowercase. As a hint, the method to compare
    two strings without looking at the specific casing of any of the letters in them
    is `text1.compareToIgnoreCase(text2)`. To do so, perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索的单词是 `so`，但您必须考虑到它出现了两次，并且其中一个实例不是小写。作为一个提示，比较两个字符串而不看它们中任何字母的具体大小写的方方法是
    `text1.compareToIgnoreCase(text2)`。为此，请执行以下步骤：
- en: Create the `text` array.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `text` 数组。
- en: 'Create the variable that contains the word to be searched for: `so`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含要搜索的单词的变量：`so`
- en: Initialize the variable `occurrence` to -1.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量 `occurrence` 初始化为 -1。
- en: Create a for loop to iterate through the array to check for the occurrence.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来遍历数组以检查出现。
- en: 'That will give the following result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下结果：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 538.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 538 页找到。
- en: Sets
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Sets within the collections framework are the programmatic equivalent of mathematical
    sets. This means that they can store objects of a specific type while avoiding
    duplicates. In the same way, sets offer methods that will let you handle data
    as you would in mathematics. You can add objects to a set, check whether a set
    is empty, combine the elements of two sets to add all their elements into a single
    set, see what objects coincide with each other between two sets, and calculate
    the difference between two sets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中的集合是数学集合的程序等效。这意味着它们可以存储特定类型的对象，同时避免重复。同样，集合提供的方法将允许您以数学的方式处理数据。您可以将对象添加到集合中，检查集合是否为空，将两个集合的元素合并以将所有元素添加到单个集合中，查看两个集合之间有什么对象是相同的，以及计算两个集合之间的差异。
- en: 'In the `java.util.Sets` class, we find three interfaces used to represent sets:
    `HashSet`, `TreeSet`, and `LinkedHashSet`. The differences between them are straightforward:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.Sets` 类中，我们发现有三个接口用于表示集合：`HashSet`、`TreeSet` 和 `LinkedHashSet`。它们之间的区别是直接的：
- en: '`HashSet` will store data without guaranteeing the order of iteration.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet` 将存储数据，但不保证迭代顺序。'
- en: '`TreeSet` orders a set by value.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeSet` 按值对集合进行排序。'
- en: '`LinkedHashSet` orders a set by arrival time.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedHashSet` 按到达时间对集合进行排序。'
- en: 'Each of these interfaces is meant to be used under specific circumstances.
    Let''s look at a couple of examples of sets, departing from the one in `Example05`,
    and look at how we can add other methods to check how to operate sets. The first
    step is populating a set from an array. There are several methods for doing so;
    let''s use the one that is probably the quickest to implement:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口都旨在在特定情况下使用。让我们从 `Example05` 中的集合出发，看看我们如何添加其他方法来检查如何操作集合。第一步是从数组中填充集合。有几种方法可以做到这一点；让我们使用最快速实现的方法：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The above line of code shows how to add all the elements of the array to the
    set; when printing the results, we get:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行显示了如何将数组的所有元素添加到集合中；当打印结果时，我们得到：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Please note that the order of the resulting print may vary for you. As explained
    earlier, `HashSet`, because of the way it is implemented, cannot guarantee any
    sorting of the content. If you performed the following example using `Integer`
    instead of `String` for the data, it would end up being sorted:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出的顺序可能因您而异。如前所述，`HashSet` 由于其实现方式，无法保证内容的任何排序。如果您使用 `Integer` 而不是 `String`
    作为数据执行以下示例，最终结果将是排序的：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of this program is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的结果如下：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that the results end up being sorted, even if we don't request it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结果最终是排序的，即使我们没有请求它。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that the set in this example is sorted is a mere coincidence. Please
    be aware that this may not be the case in other situations. `Example08` will show
    the union operation between two sets, and there the data will not be sorted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，集合是排序的只是一个巧合。请意识到在其他情况下可能并非如此。`Example08` 将展示两个集合之间的并集操作，那里的数据将不会排序。
- en: 'Working with sets involves working with packages of data and performing operations
    with them. The union operation for two sets is displayed in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一起工作涉及处理数据包并对其执行操作。以下示例显示了两个集合的并集操作：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This program will print, as its output, the resulting set from the union of
    the two sets described by the two arrays at the beginning of the main method of
    the example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将打印出两个数组在示例主方法开头描述的集合的并集的结果：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Besides `HashSet`, we also find `TreeSet`, and here is where data will be sorted
    by value. Let''s simply change the types of the sets in the previous example and
    see the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`HashSet`，我们还发现`TreeSet`，在这里数据将按值排序。让我们简单地改变上一个例子中集合的类型，看看结果：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This, when changed in the previous example, will give the following sorted
    set as a result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当在上一个例子中改变时，这将给出以下排序后的集合作为结果：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You might be wondering about the pros and cons of using each type of set. When
    sorting, you are trading speed for tidiness. Therefore, if you are working with
    large sets of data and speed is a concern, you will have to decide whether it
    is more convenient to have the system operate faster, or have the results sorted,
    which would allow faster binary searches through the dataset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道使用每种类型集合的优缺点。在排序时，你是在速度和整洁之间做权衡。因此，如果你正在处理大量数据且速度是一个问题，你必须决定是让系统运行得更快，还是让结果排序，这样就可以更快地通过数据集进行二分搜索。
- en: 'Given this last modification, we could perform other operations with the data,
    such as the intersection operation, which is invoked with the `set1.retainAll(set2)`
    method. Let''s see it in action:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 给了最后一个修改，我们可以对数据进行其他操作，例如交集操作，该操作通过`set1.retainAll(set2)`方法调用。让我们看看它的实际效果：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the output, given that the arrays are used to populate the arrays, we will
    get only those numbers that exist in both arrays; in this case, it is just the
    number `79`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出，由于数组被用来填充数组，我们只会得到存在于两个数组中的那些数字；在这种情况下，只是数字`79`：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The third type of set, `LinkedHashSet`, will sort the objects in order of their
    arrival. To demonstrate this behavior, let's make a program that will add elements
    to the set one by one using the `set.add(element)` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型的集合，`LinkedHashSet`，将按对象到达的顺序对对象进行排序。为了演示这种行为，让我们编写一个程序，该程序将使用`set.add(element)`命令逐个向集合中添加元素。
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When running this example, the result will be sorted by the way the data arrived
    in the set:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个例子时，结果将按数据到达集合的方式排序：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the sake of experimentation, use the next 2 minutes to chalk out the set
    construction into `HashSet` once more:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验，请用接下来的2分钟再次将集合构造为`HashSet`：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result of this modified program is uncertain. For example, we get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改后的程序的结果是不确定的。例如，我们得到：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is, again, an unsorted version of the same set of data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是同一组数据的未排序版本。
- en: To close our explanation of the possible methods that you can use with sets,
    let's use `LinkedHashSet` to run an experiment where we will find the difference
    between two sets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对你可以与集合一起使用的可能方法的解释，让我们使用`LinkedHashSet`运行一个实验，我们将找到两个集合之间的差异。
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, both sets are slightly different, and by determining the difference,
    the algorithm behind `set1.removeAll(set2)` will look for the occurrences of each
    item in `set2` within `set1` and eliminate them. The result of this program is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个集合略有不同，通过确定差异，`set1.removeAll(set2)`算法背后的算法将在`set1`中查找`set2`中每个项目的出现，并将它们消除。这个程序的结果是：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, if you just want to check whether the whole of a set is contained within
    another set, you can call the `set1.containsAll(set2)` method. We'll leave that
    for you to explore – just be aware that the method simply responds with a Boolean
    stating whether the statement is true or false.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只想检查一个集合是否完全包含在另一个集合中，你可以调用`set1.containsAll(set2)`方法。我们将把这个留给你去探索——只需注意，该方法简单地返回一个布尔值，表示该语句是真是假。
- en: Lists
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are ordered collections of data. Unlike sets, lists can have repeated
    data. Having data contained within lists allows you to perform searches that will
    give the locations of certain objects within a given list. Given a position, it
    is possible to directly access an item in a list, add new items, remove items,
    and even add full lists. Lists are sequential, which makes them easy to navigate
    using iterators, a feature that will be explored in full in a later section in
    the chapter. There are also some methods for performing range-based operations
    on sublists.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的数据集合。与集合不同，列表可以有重复的数据。在列表中包含数据允许你执行搜索，这将给出给定列表中某些对象的位置。给定一个位置，你可以直接访问列表中的项目，添加新项目，删除项目，甚至添加完整的列表。列表是顺序的，这使得它们很容易通过迭代器进行导航，这一特性将在本章后面的部分中详细探讨。还有一些方法可以对子列表执行基于范围的操作。
- en: 'There are two different list implementations: `ArrayList` and `LinkedList`.
    Each of them is ideal depending on the circumstances. Here, we will work with
    `ArrayList` mainly. Let''s start by creating and populating an instance, then
    search for a certain value, and given its location within the list, we''ll print
    out the value.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的列表实现：`ArrayList`和`LinkedList`。根据情况，每个都是理想的。在这里，我们将主要使用`ArrayList`。让我们首先创建并填充一个实例，然后搜索列表中的某个值，并根据其在列表中的位置打印出该值。
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this example is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `indexOf` method informs you about the location of an object passed to the
    method as a parameter. It's sibling method, `lastIndexOf`, reports the location
    of the last occurrence of an object in the list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法会告诉你传递给方法的对象的位置。它的兄弟方法`lastIndexOf`报告列表中对象的最后一个出现位置。'
- en: You should look at a list as a series of nodes connected by links. If one of
    the nodes is eliminated, the link that used to point to it will be redirected
    to the following item in the list. When adding nodes, they will be attached by
    default at the end of the list (if they are not duplicated). As all the nodes
    in the collection are of the same type, it should be possible to exchange the
    locations of two nodes in a list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将列表视为由链接连接的一系列节点。如果一个节点被消除，曾经指向它的链接将被重定向到列表中的下一个项目。当添加节点时，它们默认附加到列表的末尾（如果它们不是重复的）。由于集合中的所有节点都是同一类型，因此应该可以在列表中交换两个节点的位置。
- en: 'Let''s experiment with removing an item from a list and ascertaining the locations
    for objects located immediately before and after the removed item:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实验一下从列表中删除一个项目，并确定删除项目前后立即定位的对象的位置：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This program creates a list, prints it out, looks for a node in the list, and
    prints its location. Then, it removes an item in the list and repeats the previous
    process to show that the node has been removed from the list. This is a clear
    difference from the case with arrays, where it is not possible to remove items
    from them, and thus it is not possible to change their size. Observe the output
    of the previous example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个列表，将其打印出来，然后在列表中查找一个节点并打印其位置。然后，它从列表中删除一个项目，并重复之前的步骤以显示该节点已从列表中删除。这与数组的情况明显不同，在数组中无法删除项目，因此无法更改其大小。观察前一个示例的输出：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is also possible to change the content of a node. In the previous example,
    instead of removing a node, change `list.remove(index-1);` to the following and
    check the outcome:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以更改节点的内容。在前面的示例中，不是删除节点，而是将`list.remove(index-1);`更改为以下内容并检查结果：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The final array will have substituted `11` for `99`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终数组将用`11`替换`99`。
- en: 'If instead of deleting one node, you wanted to empty the whole list, the command
    to the issue would be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想删除一个节点，而是想清空整个列表，那么向其发出的命令将是：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using `subList()`, an operator that generates lists from lists, it is possible
    to, for example, delete a range of cells within a list. See the following example,
    which deletes part of a string array, changing its meaning when printing it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subList()`操作符，可以从列表生成列表，例如，可以删除列表中一系列单元格。请看以下示例，它删除了字符串数组的一部分，在打印时改变了其含义：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Look at the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下结果：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `list` object has been modified by running the example code so that it becomes
    shorter. The two index numbers used in the `subList()` method is the places in
    the list where the method starts and stops. The result of `subList()` can also
    be assigned to a different variable of the same `List` type, resulting in a reduced
    copy of the list in the code, after performing the `subList()` operation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行示例代码修改了`list`对象，使其变短。`subList()`方法中使用的两个索引数字是列表中方法开始和停止的位置。`subList()`的结果也可以分配给相同类型的另一个变量，在执行`subList()`操作后，代码中的列表将减少一个副本。
- en: 'Look at the following modification in the latest code listing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最新代码列表中的以下修改：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will print out the list that was made of the nodes that were deleted in
    the previous example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出由前一个示例中删除的节点组成的列表。
- en: 'There are a lot of interesting algorithms within the collections framework
    that offers relevant functionality for operating with lists:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中有许多有趣的算法，提供了操作列表的相关功能：
- en: '`sort`: Put the elements of a list in a certain order.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`：将列表的元素按特定顺序排列。'
- en: '`shuffle`: Randomize the locations of all objects in a list.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle`：随机化列表中所有对象的位置。'
- en: '`reverse`: Invert the order of a list.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`：反转列表的顺序。'
- en: '`rotate`: Move objects to the end of a list, and when they reach the end, have
    them show up at the other end.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`：将对象移动到列表的末尾，当它们到达末尾时，在另一端显示。'
- en: '`swap`: Swap two elements with one another.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`：交换两个元素。'
- en: '`replaceAll`: Replace all occurrences of an element in a list using a parameter.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceAll`：使用参数替换列表中所有元素的出现。'
- en: '`fill`: Fill the content of a list with one value.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`：使用一个值填充列表的内容。'
- en: '`copy`: Make more instances of a list.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`：创建列表的更多实例。'
- en: '`binarySearch`: Perform optimized searches within a list.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binarySearch`：在列表中执行优化的搜索。'
- en: '`indexOfSubList`: Search for the occurrence of a piece (a set of consecutive
    nodes) of a list.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOfSubList`：搜索列表中某个片段（一组连续节点）的出现。'
- en: '`lastIndexOfSubList`: Search for the last occurrence of a piece of a list.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOfSubList`：搜索列表中某个片段的最后一个出现位置。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Lists generated from arrays using `Arrays.asList()` do not behave in the same
    way as the objects of the `List` class described in this section. The lists coming
    from arrays have a fixed length, which means that elements cannot be removed from
    the array. The reason for this is that `java.util.Arrays` implement its own `ArrayList`
    class inside the package, one that is different from the one in the collections
    framework. Confusing, isn't it?
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `Arrays.asList()` 从数组生成的列表与本章中描述的 `List` 类对象的行为不同。来自数组的列表具有固定长度，这意味着无法从数组中删除元素。这是因为
    `java.util.Arrays` 在包内部实现了自己的 `ArrayList` 类，它与集合框架中的类不同。这不是很令人困惑吗？
- en: 'Exercise 1: Creating the AnalyzeInput Application'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：创建 AnalyzeInput 应用程序
- en: 'In this exercise, we will create a new application that will respond to the
    CLI by storing whatever strings are provided to it, then run some statistical
    operations on the data, such as word counting (determining the most frequent word
    or the most frequent letter, and so on). The intent is to give you an idea of
    how to use the collections framework instead of other tools to do such operations.
    This time, we will do something special; instead of getting the data from the
    CLI as arguments to the script, we will use the `java.io.Console` API, which allows
    the reading of different types of strings from the terminal, such as usernames
    (plain strings) and passwords. The goal of this application is to read the input
    until a line with only the "`*`" symbol (asterisk) is captured. Once the termination
    symbol is entered, the text will be processed, and the statistics will be delivered
    to the terminal:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的应用程序，该应用程序将通过存储提供给它的任何字符串来响应 CLI，然后对数据进行一些统计操作，例如单词计数（确定最频繁的单词或最频繁的字母等）。目的是让你了解如何使用集合框架而不是其他工具来完成此类操作。这次，我们将做一些特别的事情；而不是从
    CLI 作为脚本的参数获取数据，我们将使用 `java.io.Console` API，它允许从终端读取不同类型的字符串，例如用户名（普通字符串）和密码。这个应用程序的目标是读取输入，直到捕获到只有
    "`*`" 符号（星号）的行。一旦输入了终止符号，文本将被处理，并将统计结果发送到终端：
- en: Open IntelliJ and create a new Java program using the CLI template. Name the
    project `AnalyzeInput`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IntelliJ 并使用 CLI 模板创建一个新的 Java 程序。将项目命名为 `AnalyzeInput`。
- en: 'Start by creating a simple program that can read a line from the terminal and
    printing it out:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个简单的程序，可以从终端读取一行并将其打印出来：
- en: '[PRE49]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Execute the program from the CLI by calling `java AnalyzeInput` from the right
    folder and interact with it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 CLI 中执行程序，通过在正确的文件夹中调用 `java AnalyzeInput` 来与之交互：
- en: '[PRE50]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You must import `java.io.Console`, which allows you to instantiate objects of
    the `Console` class. You can also see the call to `cons = System.console()`, which
    will make sure that the terminal is ready for you to read the data, and `line
    = cons.readLine()`, which will ensure that when hitting the *Enter* key on the
    keyboard, the resulting data is not empty.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须导入 `java.io.Console`，这允许您实例化 `Console` 类的对象。您还可以看到对 `cons = System.console()`
    的调用，这将确保终端已准备好供您读取数据，以及 `line = cons.readLine()`，这将确保在按下键盘上的 *Enter* 键时，结果数据不为空。
- en: 'The next step is storing the data we are capturing in a collection. Since we
    don''t know the size this could be, we should be using `ArrayList <String>` to
    store the data. Also, to store data for as long as we want, we can modify the
    `if` statement and make it into a `while` loop. Finally, use the `add` method
    to add the lines into a list (note that the following code listing will never
    exit, so bear with us and do not execute it yet):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们正在捕获的数据存储在集合中。由于我们不知道这个大小，我们应该使用`ArrayList <String>`来存储数据。此外，为了存储我们想要存储的数据，我们可以修改`if`语句并将其改为`while`循环。最后，使用`add`方法将行添加到列表中（请注意，以下代码列表永远不会退出，所以请耐心等待，不要现在执行它）：
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Modify the `while` loop to include the condition we established for finishing
    the data capture process – the arrival of a line with only an asterisk symbol:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`while`循环，包括我们为完成数据捕获过程设定的条件——只有星号符号的一行：
- en: '[PRE52]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The outcome will happen only when you type the asterisk symbol alone in a line,
    as seen in this log while interacting with the program:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果只有在你在一行中单独输入星号符号时才会发生，就像在与程序交互时的这个日志中看到的那样：
- en: '[PRE53]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since we used `ArrayList` to store the different strings, you could be typing
    until you exhaust the computer''s memory. Now it is possible to execute some commands
    to work with the strings. The first step will be turning the whole of the text
    into a list. This will require going through the different strings and splitting
    them into parts that will be added to a larger list. The easiest trick is to use
    the `split()` method using a whitespace character as a separator. Modify the `main`
    method to look like the following, and you will see that the result is now a list
    with all the words separated as single nodes in the list:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用了`ArrayList`来存储不同的字符串，你可能需要一直输入，直到耗尽计算机的内存。现在，我们可以执行一些命令来处理字符串。第一步是将整个文本转换成一个列表。这需要遍历不同的字符串并将它们分割成将要添加到更大列表中的部分。最简单的技巧是使用`split()`方法，以空格字符作为分隔符。修改`main`方法，使其看起来如下，你就会看到结果现在是一个列表，其中所有的单词都作为单独的节点分开：
- en: '[PRE54]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Having all the data stored in this way allows for the use of a lot of the methods
    available in the collections framework that will let you do operations with data.
    Let''s start by counting all the words in the text (including the closing symbol,
    "`*`"). Just add the following at the end of the `main` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式存储所有数据允许使用集合框架中可用的许多方法，这将让你能够对数据进行操作。让我们从计算文本中的所有单词（包括关闭符号，“`*`”）开始。只需在`main`方法的末尾添加以下内容：
- en: '[PRE55]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result of this exercise is a program that is ready to be used for further
    analysis of the data. But in order to continue doing so, we need to make use of
    a tool that has not yet been introduced—the iterator. We will come back to this
    example later in the chapter and finish off the application by adding some extra
    functionality to it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的结果是一个可以用于进一步分析数据的程序。但是，为了继续这样做，我们需要使用一个尚未介绍的工具——迭代器。我们将在本章的后面回到这个例子，并通过添加一些额外的功能来完成应用程序。
- en: Maps
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: The collections framework offers one more interface, `java.util.Map`, which
    can be used when dealing with data that is stored as key-value pairs. This type
    of data storage is becoming more and more relevant as data formats such as JSON
    are slowly taking over the internet. JSON is a data format that is based on having
    data stored in the form of nested arrays that always respond to the key-value
    structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架提供了一个额外的接口，`java.util.Map`，当处理以键值对形式存储的数据时可以使用。这种类型的数据存储越来越相关，因为像JSON这样的数据格式正逐渐接管互联网。JSON是一种基于嵌套数组形式存储数据的数据格式，这些数组总是响应键值结构。
- en: 'Having data organized in this way offers the possibility of having a very simple
    way to look for data – by means of the keys instead of using, for example, an
    index, as we would do in an array. Keys are the way we can identify the block
    of data we are looking for within a map. Let''s look at a simple example of a
    map before looking at alternatives to maps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组织数据提供了通过键而不是，例如，使用索引（就像我们在数组中做的那样）来查找数据的一种非常简单的方法。键是我们可以在映射中识别我们正在寻找的数据块的方式。在我们查看映射的替代方案之前，让我们先看看一个简单的映射示例：
- en: 'The following example shows how to create a simple map and how to print some
    messages based on the information available within it. The first thing that you
    will notice in comparison to other interfaces in the collections framework is
    that we do not *add* elements to the map – we *put* elements in the map. Also,
    elements have two parts: the **key** (in our case, we are using strings) and the
    **value** (which can be heterogeneous in nature):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建一个简单的映射以及如何根据映射中可用的信息打印一些消息。与其他集合框架中的接口相比，你首先会注意到的是，我们不是向映射中*添加*元素，而是将元素*放入*映射中。此外，元素有两个部分：**键**（在我们的例子中，我们使用字符串）和**值**（其本质可以是异质的）：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This program will give the following result:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将给出以下结果：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since there is no key named "`bytes`" in the code, the `maps.containsKey()`
    method will answer accordingly, and the program will inform the user about it.
    The main methods available in this interface are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码中没有名为"`bytes`"的键，`maps.containsKey()`方法将相应地回答，程序将通知用户这一点。此接口中可用的主要方法有：
- en: '`put` (Object key, Object value)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put` (Object key, Object value)'
- en: '`putAll` (Map map)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putAll` (Map map)'
- en: '`remove` (Object key)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove` (Object key)'
- en: '`get` (Object key)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` (Object key)'
- en: '`containsKey` (Object key)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsKey` (Object key)'
- en: '`keySet()`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keySet()`'
- en: '`entrySet()`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrySet()`'
- en: 'All but the last two are self-explanatory. Let''s focus on augmenting our previous
    example to see what those two methods do. Make the following addition to the code
    to see what `keySet()` and `entrySet()` have to offer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后两个之外，其他都是不言自明的。让我们关注增强我们之前的示例，看看这两个方法的作用。在代码中添加以下内容以查看`keySet()`和`entrySet()`能提供什么：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The outcome of the modified code listing will be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的代码列表的结果将是：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In other words, `entrySet()` will print the whole map using the key = value
    formula, while `keySet()` will respond with the set of keys within the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`entrySet()`将使用键 = 值公式打印整个映射，而`keySet()`将返回映射中的键集合。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might have realized this by now: keys must be unique – there cannot be
    two of the same keys in a map.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在已经意识到了：键必须是唯一的——映射中不能有两个相同的键。
- en: 'We will not go deeper into maps at this point because they are, to an extent,
    a repetition of what we saw with sets. There are three different classes for maps:
    `HashMap`, `TreeMap`, and `LinkedHashMap`. The last two are put in order, while
    the first one is neither sorted nor arranged in order of arrival. You should use
    these classes according to your needs.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处不会深入探讨映射，因为它们在一定程度上是集合的重复。映射有三个不同的类：`HashMap`、`TreeMap`和`LinkedHashMap`。后两者是有序的，而第一个既没有排序也没有按到达顺序排列。你应该根据你的需求使用这些类。
- en: Iterating through Collections
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的迭代
- en: Earlier in this chapter, when working with *Exercise 01, Creating the AnalyzeInput
    Application* we stopped when we were about to make searches through the data.
    We made it to the point where we had to iterate through the data and look for
    characteristics such as word frequency.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，当我们正在处理*练习 01，创建 AnalyzeInput 应用程序*时，我们停止了搜索数据的操作。我们做到了必须遍历数据并查找诸如词频等特征的程度。
- en: Iterators are used in Java to browse through collections. Let's look at a simple
    example that involves extracting the elements from a simple list one by one and
    printing them out.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器用于Java遍历集合。让我们看看一个简单的例子，该例子涉及逐个提取简单列表中的元素并打印它们。
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of this program is:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结果是：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Iterators such as this one are the most generic ones in the collections framework
    and can be used with lists, sets, queues, and even maps. There are other less-broad
    implementations of the iterators that allow for different ways to browse through
    data, for example, in lists. As you saw in the latest code listing, the `iterator.hasNext()`
    method checks whether there is a node after the one we are at in the list. When
    starting the iterator, the object points to the first element in the list. Then,
    `hasNext()` responds with a Boolean stating whether there are more nodes hanging
    from it. The `iterator.next()` method will move the iterator to the following
    node in the collection. This kind of iterator does not have the possibility of
    going back in the collection; it can only move forward. There is one final method
    in the iterator, called `remove()`, which will eliminate the current element that
    the iterator is pointing to from the collection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的迭代器是集合框架中最通用的，可以与列表、集合、队列以及甚至映射一起使用。还有其他更窄的迭代器实现，允许以不同的方式浏览数据，例如在列表中。正如你在最新的代码列表中看到的，`iterator.hasNext()`方法检查列表中我们所在节点之后的节点是否存在。当启动迭代器时，对象指向列表中的第一个元素。然后，`hasNext()`会响应一个布尔值，表示是否有更多的节点悬挂在其上。`iterator.next()`方法将迭代器移动到集合中的下一个节点。这种迭代器没有在集合中回退的可能性；它只能向前移动。迭代器中还有一个最终的方法，称为`remove()`，它将从集合中删除迭代器所指向的当前元素。
- en: 'If we used `listIterator()` instead, we would have had a lot more options for
    navigating collections, such as adding new elements and changing elements. The
    following code listing demonstrates how to go through a list, add elements, and
    modify them. `listIterator` works only with lists:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`listIterator()`，我们将有更多的选项来导航集合，例如添加新元素和修改元素。以下代码示例演示了如何遍历列表，添加元素并修改它们。`listIterator`仅与列表一起工作：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this example, we create a list of `Double`, iterate through the list, and
    round up each of the numbers. The outcome of this program is:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`Double`列表，遍历列表，并对每个数字进行四舍五入。这个程序的输出是：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By calling `listIterator.set()`, we modify each of the items in the list and
    the second `System.out.println()` command shows where the numbers have been rounded
    up or down.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`listIterator.set()`，我们修改列表中的每个项目，第二个`System.out.println()`命令显示了数字是如何被四舍五入或向下取整的。
- en: 'The final iterator example we are going to see in this section is a trick to
    iterate through a map. This could come in handy in scenarios where you want to
    perform some operations on data within a map. By using the `entrySet()` method
    – which returns a list – it is possible to have an iterator over a map. See the
    following example to understand how this works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将看到的最后一个迭代器示例是一个遍历映射的技巧。这可能在需要在对映射中的数据进行某些操作的场景中很有用。通过使用`entrySet()`方法——它返回一个列表——可以有一个映射的迭代器。请看以下示例以了解这是如何工作的：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This program will iterate through a map and print the contents as they were
    stored in `HashMap`. Remember that these types of objects are not sorted in any
    specific way. You can expect an output like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将遍历一个映射，并按它们在`HashMap`中存储的内容打印出来。请记住，这些类型的对象没有按任何特定的方式进行排序。你可以期待以下输出：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Given that we now have ways to iterate through collections, we can move on
    to an exercise that picks up where we left off: iterating through a list for data
    analysis.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有了遍历集合的方法，我们可以继续进行一个练习，即迭代列表进行数据分析。
- en: 'Exercise 2: Bringing Analytics into the AnalyzeInput Application'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：将分析功能引入AnalyzeInput应用程序
- en: 'We are going to start from where we left off at the end of *Exercise 1*, *Creating
    the AnalyzeInput Application*. We managed to capture the text typed in the terminal
    and store it as a list of strings. This time, we are going to use a method from
    the collections framework called `frequency`, which will respond with the number
    of times a certain object can be found inside a list. As words could be repeated
    in a sentence, we first need to figure out a way to extract the unique elements
    in a list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*练习1*，*创建AnalyzeInput应用程序*的结尾开始。我们成功捕获了在终端中输入的文本，并将其存储为字符串列表。这次，我们将使用集合框架中的一个方法，称为`frequency`，它将返回一个对象在列表中可以找到的次数。由于句子中的单词可能会重复，我们首先需要找出一种方法来提取列表中的唯一元素：
- en: 'Sets are objects in the collections framework that keep only one copy of each
    element. We saw an example of this earlier in the chapter. We will create a `HashSet`
    instance and copy all the elements from the list into it. This will automatically
    eliminate duplicates:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合是集合框架中的对象，它只保留每个元素的一个副本。我们在本章的早期看到了一个例子。我们将创建一个`HashSet`实例，并将列表中的所有元素复制到其中。这将自动消除重复项：
- en: '[PRE66]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The next step, now that we have the set, is to create an iterator that will
    check how many copies of each element from the set can be found in the list:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了集合，下一步是创建一个迭代器，它会检查集合中的每个元素在列表中可以找到多少个副本：
- en: '[PRE67]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Using the same technique that we saw in previous examples for how to iterate
    through a set, we will find the next node in the set and check in the list for
    the frequency of the string stored in the node:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在前面的例子中看到的技术，即如何遍历一个集合，我们将找到集合中的下一个节点，并在列表中检查节点中存储的字符串的频率：
- en: '[PRE68]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The final code can be referred at: [https://packt.live/2BrplvS](https://packt.live/2BrplvS).'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的代码可以参考：[https://packt.live/2BrplvS](https://packt.live/2BrplvS)。
- en: 'The outcome will depend on the kind of text you type. For the sake of testing,
    try the following (we will stick to this data entry for the rest of the chapter
    – you can copy and paste it to the terminal each time you call the application):'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将取决于你输入的文本类型。为了测试，请尝试以下内容（我们将在本章的其余部分坚持使用这个数据输入 – 你每次调用应用程序时都可以将其复制并粘贴到终端中）：
- en: '[PRE69]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The full outcome of this input will be:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个输入的完整结果将是：
- en: '[PRE70]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: While the result is correct, it is not easy to read through. Ideally, results
    should be sorted. For example, by descending values of frequency, so that it is
    easy to see at a glance the most and least frequent words. This is the time to
    make yet another stop in the exercise as we need to introduce the idea of sorting
    before we move on with it.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然结果是正确的，但阅读起来并不容易。理想情况下，结果应该按顺序排序。例如，按频率的降序排列，这样就可以一眼看出最频繁和最不频繁的单词。这是我们在继续前进之前再次停下来进行练习的时候，因为我们需要在继续之前介绍排序的概念。
- en: Sorting Collections
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序集合
- en: As we have seen, there are some classes in the collections framework that force
    the items within them to be sorted. Examples of that are `TreeSet` and `TreeMap`.
    The aspect to explore in this section is how to use existing sorting mechanisms
    for lists, but also for cases that have datasets with more than one value per
    data point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在集合框架中有些类强制其内部的项进行排序。例如`TreeSet`和`TreeMap`。本节要探讨的方面是如何使用现有的排序机制对列表进行排序，以及对于每个数据点有多个值的数据集的情况。
- en: 'The exercise we are doing throughout this chapter is a good example of a case
    where there are data points with more than one value. For each data point, we
    need to store the word for which we are calculating the frequency and the frequency
    itself. You might think that a good technique to sort that out is by storing the
    information in the form of maps. The unique words could be the keys, while the
    frequencies could be the values. This could be achieved by modifying the final
    part of the previous program to look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中进行的练习是一个很好的例子，其中存在具有多个值的点。对于每个数据点，我们需要存储我们正在计算频率的单词以及频率本身。你可能认为一个好的技术是将信息以映射的形式存储。独特的单词可以是键，而频率可以是值。这可以通过修改上一个程序的最后一部分来实现，如下所示：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'While this is an interesting and simple approach to sorting (copying the data
    into a structure that is sorted by nature), it presents the problem that data
    is sorted by key and not by value, as the following result of the previous code
    highlights:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有趣且简单的方法来排序（将数据复制到按自然排序的结构中），但它提出了一个问题，即数据是按键排序而不是按值排序，正如以下代码的输出所强调的：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, if we want to sort these results by value, we need to figure out a different
    strategy.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想按值对这些结果进行排序，我们需要找出一种不同的策略。
- en: 'But let''s step back for a second and analyze what tools are offered in the
    collections framework for sorting. There is a method called `sort()` that can
    be used to sort lists. An example of this is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们退一步，分析一下集合框架中提供的哪些工具用于排序。有一个名为`sort()`的方法可以用来排序列表。以下是一个例子：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The result of this program is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结果是：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Given a list, we could sort it this way just fine; it would even be possible
    to navigate through it backward using `listIterator` to sort a list in descending
    order. However, these methods do not solve the issue of sorting data points with
    multiple values. In such a case, we would need to create a class to store our
    own key-value pair. Let's see how to implement this by continuing with the exercise
    we have been dealing with throughout the chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个列表，我们可以这样排序它；甚至可以使用`listIterator`向后导航，以降序排序列表。然而，这些方法并不能解决对具有多个值的数据点进行排序的问题。在这种情况下，我们需要创建一个类来存储我们自己的键值对。让我们通过继续我们在本章中一直在处理的练习来看看如何实现它。
- en: 'Exercise 3: Sort the Results from the AnalyzeInput Application'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3：从AnalyzeInput应用程序中排序结果
- en: 'We now have a program that, given some input text, identifies some basic characteristics
    of the text, such as the number of words in the text or the frequency of each
    of the words. Our goal is to be able to sort the results in descending order to
    make them easier to read. The solution will require the implementation of a class
    that will store our key-value pairs and make a list of objects from that class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个程序，给定一些输入文本，可以识别文本的一些基本特征，例如文本中的单词数量或每个单词的频率。我们的目标是能够按降序排序结果，使其更容易阅读。这个解决方案需要实现一个类来存储我们的键值对，并从这个类中创建一个对象列表：
- en: 'Create a class containing the two data points: the word and its frequency.
    Implement a constructor that will take values and pass them to class variables.
    This will simplify the code later:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个数据点的类：单词及其频率。实现一个构造函数，它将接受值并将它们传递给类变量。这将简化后面的代码：
- en: '[PRE75]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When calculating the frequency for each word, store the results in a newly
    created list of objects of the new class:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算每个单词的频率时，将结果存储在新创建的新类的对象列表中：
- en: '[PRE76]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Sorting is going to require the creation of a new class using the `Comparator`
    interface, which we are just introducing now. This interface should implement
    a method that will be used to run comparisons within the objects in the array.
    This new class must implement `Comparator <DataPoint>` and include a single method
    called `compare()`. It should have two objects of the class being sorted as parameters:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序需要创建一个新的类，使用`Comparator`接口，我们现在刚刚介绍。这个接口应该实现一个方法，该方法将在数组中的对象内运行比较。这个新类必须实现`Comparator
    <DataPoint>`并包含一个名为`compare()`的单个方法。它应该有两个参数，即正在排序的类的对象：
- en: '[PRE77]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The way we call the `Collections.sort()` algorithm using this new comparator
    is by adding an object of that class as a parameter to the `sort` method. We instantiate
    it directly in the call:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用这个新比较器调用`Collections.sort()`算法的方式是将该类的对象作为参数添加到`sort`方法中。我们直接在调用中实例化它：
- en: '[PRE78]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will sort the frequencies list in ascending order. To print the results,
    it is no longer valid to make a direct call to `System.out.println(frequencies)`
    because it is now an array of objects and it will not print the contents of the
    data points to the terminal. Iterate through the list in the following way instead:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将按升序排序频率列表。要打印结果，不再可以直接调用`System.out.println(frequencies)`，因为它现在是一个对象数组，它不会将数据点的内容打印到终端。而是以以下方式遍历列表：
- en: '[PRE79]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you run the program using the same input that we have been using for the
    last couple of examples, the outcome will be:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用我们之前在几个示例中使用过的相同输入运行程序，结果将是：
- en: '[PRE80]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our goal is to sort the results in descending order and, to do that, we will
    need to add one more thing to the call to the `sort` algorithm. When instantiating
    the `SortByValue()` class, we need to tell the compiler that we want the list
    to be sorted in reverse order. The collections framework already has a method
    for this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目的是按降序排序结果，为此，我们需要在调用`sort`算法时添加一个额外的元素。在实例化`SortByValue()`类时，我们需要告诉编译器我们希望列表按逆序排序。集合框架已经有一个方法可以做到这一点：
- en: '[PRE81]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the sake of clarity, the final code can be referred at: [https://packt.live/2W5qhzP](https://packt.live/2W5qhzP).'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了清晰起见，最终代码可以参考：[https://packt.live/2W5qhzP](https://packt.live/2W5qhzP)。
- en: 'A full interaction path with this program, from the moment we call it to include
    the data entry, would be as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与这个程序的全交互路径，从我们调用它到包括数据输入，如下所示：
- en: '[PRE82]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Properties
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties in the collections framework are used to maintain lists of key-value
    pairs where both are of the `String` class. Properties are relevant when obtaining
    environmental values from the operating system, for example, and are the grounding
    class for many other classes. One of the main characteristics of the `Properties`
    class is that it allows the definition of a default response in the case of a
    search for a certain key not being satisfactory. The following example highlights
    the basics of this case:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合框架中，`Properties` 用于维护键值对列表，其中两者都是 `String` 类。当从操作系统获取环境值时，`Properties` 是相关的，并且是许多其他类的基类。`Properties`
    类的一个主要特征是，它允许在搜索某个键不满意的情况下定义默认响应。以下示例突出了这种情况的基本原理：
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Before diving into the results, you will notice that in properties, we put rather
    than add new elements/nodes. This is the same as we saw with maps. Also, you will
    have noticed that to iterate, we used the `keySet()` technique that we saw when
    iterating through maps earlier. Finally, the particularity of `Properties` is
    that you can set a default response in the case of the searched-for property not
    being found. This is what happens in the example when searching for `getProperty()`
    method will answer with its default message without crashing the program.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究结果之前，您会注意到在属性中，我们使用 `put` 而不是 `add` 新元素/节点。这与我们之前看到的映射相同。此外，您会注意到，为了迭代，我们使用了
    `keySet()` 技术，这是我们之前在遍历映射时看到的。最后，`Properties` 的特殊性在于，您可以在找不到搜索属性的情况下设置默认响应。这就是在示例中搜索
    `getProperty()` 方法将返回其默认消息而不会使程序崩溃的原因。
- en: 'The result of this program is:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结果是：
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Another interesting method to be found in the `Properties` class is the `list()`;
    it comes with two different implementations that allow you to send the contents
    of a list to different data handlers. We can stream the whole properties list
    to a `PrintStreamer` object, such as `System.out`. This offers a simple way of
    displaying what is in a list without having to iterate through it. An example
    of this follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Properties` 类中还可以找到另一个有趣的方法，即 `list()`；它提供了两种不同的实现，允许您将列表的内容发送到不同的数据处理程序。我们可以将整个属性列表流式传输到
    `PrintStreamer` 对象，例如 `System.out`。这提供了一种简单的方式来显示列表中的内容，而无需遍历它。以下是一个示例：
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That will result in:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `propertyNames()` method returns an `Enumeration` list, and by iterating
    through it, we will obtain the keys to the whole list. This is an alternative
    to creating a set and running the `keySet()` method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyNames()` 方法返回一个 `Enumeration` 列表，通过遍历它，我们将获得整个列表的键。这是创建集合并运行 `keySet()`
    方法的替代方法。'
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'That will result in:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致：
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The final method we will introduce you to from `Properties` at this point is
    `setProperty()`. It will modify the value of an existing key, or will eventually
    create a new key-value pair if the key is not found. The method will answer with
    the old value if the key exists, and answer with `null` otherwise. The next example
    shows how it works:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将从“属性”部分介绍给您的方法是 `setProperty()`。它将修改现有键的值，或者在找不到键的情况下最终创建一个新的键值对。如果键存在，该方法将返回旧值，否则返回
    `null`。下一个示例将展示它是如何工作的：
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is the outcome:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结果：
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are more methods in the `Properties` class that deals with storing and
    retrieving lists of properties to/from files. While this is a very powerful feature
    from the Java APIs, as we haven't yet introduced the use of files in this book,
    we will not discuss those methods here. For more information at this point, please
    refer to Java's official documentation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Properties` 类中还有更多方法用于处理从文件中存储和检索属性列表。虽然这是 Java API 中的一个非常强大的功能，但由于我们尚未在本书中介绍文件的使用，所以我们不会在这里讨论这些方法。有关更多信息，请参阅
    Java 的官方文档。'
- en: 'Activity 2: Iterating through Large Lists'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二：遍历大型列表
- en: In contemporary computing, we deal with large sets of data. The purpose of this
    activity is to create a random-sized list of random numbers to perform some basic
    operations on data, such as obtaining the average.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在当代计算中，我们处理大量数据集。这个活动的目的是创建一个随机大小的随机数列表，以便对数据进行一些基本操作，例如获取平均值。
- en: To start, you should create a random list of numbers.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你应该创建一个随机数字列表。
- en: To compute the average, you could create an iterator that will go through the
    list of values and add the weighted value corresponding to each element.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算平均值，你可以创建一个迭代器，它会遍历值列表，并为每个元素添加相应的加权值。
- en: The value coming from the `iterator.next()` method must be cast into a `Double`
    before it can be weighed against the total number of elements.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`iterator.next()`方法返回的值必须在与其总元素数进行比较之前转换为`Double`类型。
- en: 'If you''ve implemented everything properly, the results of the averaging should
    similar to:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确实现了所有内容，平均的结果应该类似于：
- en: '[PRE91]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or, it could be:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可能是：
- en: '[PRE92]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 539.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第539页找到。
- en: If you managed to make this program work, you should think about how to take
    advantage of being able to simulate large sets of data like this one. This data
    could represent the amount of time between different arrivals of data in your
    application, temperature data from the nodes in an Internet of Things network
    being captured every second. The possibilities are endless. By using lists, you
    can make the size of the dataset as endless as their working possibilities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法使这个程序运行起来，你应该考虑如何利用能够模拟如此大量数据的能力。这些数据可能代表你的应用程序中不同数据到达之间的时间间隔，或者每秒从物联网网络中的节点捕获的温度数据。可能性是无限的。通过使用列表，你可以使数据集的大小像它们的可能性一样无限。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the Java collections framework, which is a very
    powerful tool within the Java language that can be used to store, sort, and filter
    data. The framework is massive and offers tools in the form of interfaces, classes,
    and methods, some of which are beyond the scope of this chapter. We have focused
    on `Arrays`, `Lists`, `Sets`, `Maps`, and `Properties`. But there are others,
    such as queues and dequeues, that are worth exploring on your own.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Java集合框架，这是Java语言中一个非常强大的工具，可以用来存储、排序和过滤数据。该框架非常庞大，提供了接口、类和方法等工具，其中一些超出了本章的范围。我们专注于`Arrays`、`Lists`、`Sets`、`Maps`和`Properties`。但还有其他一些，如队列和双端队列，值得你自己去探索。
- en: Sets, like their mathematical equivalents, store unique copies of items. Lists
    are like arrays that can be extended endlessly and support duplicates. Maps are
    used when dealing with key-value pairs, something very common in contemporary
    computing, and do not support the use of two of the same keys. Properties work
    very much like `HashMap` (a specific type of `Map`) but offer some extra features,
    such as the listing of all their contents to streams, which simplifies the printing
    out of the contents of a list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与它们的数学等价物类似，集合存储唯一的项目副本。列表类似于可以无限扩展的数组，并支持重复项。当处理键值对时使用映射，这在当代计算中非常常见，并且不支持使用两个相同的键。属性的工作方式非常类似于`HashMap`（`Map`的一种特定类型），但提供了一些额外功能，例如将所有内容列出到流中，这简化了列表内容的打印。
- en: Some of the classes offered in the framework are sorted by design, such as `TreeHash`
    and `TreeMap`, while others are not. Depending on how you want to handle data,
    you will have to decide which is the best collection.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 框架中提供的某些类按设计排序，例如`TreeHash`和`TreeMap`，而其他类则不是。根据你想要如何处理数据，你必须决定哪种集合是最好的。
- en: There are standard techniques for looking through data with iterators. These
    iterators, upon creation, will point to the first element in a list. Iterators
    offer some basic methods, such as `hasNext()` and `next()`, that state whether
    there is more data in the list and extract data from the list, respectively. While
    those two are common to all iterators, there are others, such as `listIterator`,
    that are much more powerful and allow, for example, the addition of new elements
    to a list while browsing through it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器遍历数据有一些标准技术。这些迭代器在创建时将指向列表中的第一个元素。迭代器提供了一些基本方法，如`hasNext()`和`next()`，分别用于判断列表中是否有更多数据以及从列表中提取数据。虽然这两个方法对所有迭代器都是通用的，但还有一些其他方法，如`listIterator`，功能更强大，例如，在遍历列表的同时向列表中添加新元素。
- en: We have looked at a chapter-long example that used many of these techniques,
    and we have introduced the use of the console to read data through the terminal.
    In the next chapter, we will cover exceptions and how to handle them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一章长度的示例，其中使用了这些技术中的许多，并且我们介绍了如何通过终端使用控制台读取数据。在下一章中，我们将介绍异常及其处理方法。
