- en: Chapter 9. JSF State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. JSF状态管理
- en: Commonly, the JSF applications' performance is directly related to CPU memory,
    serialization/deserialization tasks, and network bandwidth. When these variables
    start to become the source of headache, or errors of type `ViewExpiredException`
    or `NotSerializableException` occur, it is time to find out about JSF's managing
    view state feature and how it can be finely tuned to increase the performance.
    Therefore, in this chapter, we will discuss about JSF saving the view state (JSF's
    partial saving view state feature, JSF saving the view state on server/client,
    logical and physical views, and so on) and JSF 2.2 stateless views.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JSF应用程序的性能与CPU内存、序列化/反序列化任务和网络带宽直接相关。当这些变量开始成为头痛的来源，或者出现`ViewExpiredException`或`NotSerializableException`类型的错误时，就是了解JSF管理视图状态功能及其如何精细调整以提高性能的时候了。因此，在本章中，我们将讨论JSF保存视图状态（JSF的部分保存视图状态功能、JSF在服务器/客户端保存视图状态、逻辑视图和物理视图等）以及JSF
    2.2无状态视图。
- en: JSF saving the view state
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF保存视图状态
- en: First, you have to know that JSF saves and restores the view state between requests
    using the `ViewHandler`/`StateManager` API. JSF does this during its lifecycle,
    the view state is saved in the session (or on the client machine) at the end of
    a request and is restored at the beginning of a request.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须知道JSF使用`ViewHandler`/`StateManager` API在请求之间保存和恢复视图状态。JSF在其生命周期中这样做，视图状态在请求结束时保存在会话中（或在客户端机器上），并在请求开始时恢复。
- en: JSF uses this technique because it needs to preserve the views state over the
    HTTP protocol, which is a stateless protocol. Since JSF is stateful, it needs
    to save the state of views in order to perform the JSF lifecycle over multiple
    requests from the same user. Each page has a view state that acts as a ping-pong
    ball between the client and the server. A view is basically a component tree that
    may be dynamically changed (altered) during HTTP GET and POST requests. Each request
    will successfully go through the JSF lifecycle only if the component tree was
    previously saved and is fully capable to provide the needed information, that
    is, Faces Servlet succeeds to call the needed view handler implementations to
    restore or build the view. So, when the component tree is programmatically changed
    (for example, from backing beans or static components) it can't be successfully
    recreated from scratch (or rebuilt). The only solution is to use the existing
    state saved at the *Render Response* phase. Trying to recreate it from scratch
    will make the programmatic changes useless, since they would no longer be available.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JSF使用这种技术是因为它需要在HTTP协议上保留视图状态，而HTTP协议是无状态的。由于JSF是有状态的，它需要保存视图的状态，以便在来自同一用户的多个请求上执行JSF生命周期。每个页面都有一个视图状态，它在客户端和服务器之间充当乒乓球。视图基本上是一个组件树，它可能在HTTP
    GET和POST请求期间动态更改（修改）。只有当组件树之前已保存并且完全能够提供所需信息时，每个请求才能成功通过JSF生命周期，也就是说，Faces Servlet成功调用所需的视图处理实现来恢复或构建视图。因此，当组件树被程序性地更改（例如，从后端bean或静态组件）时，它不能从零开始成功重建（或重新构建）。唯一的解决方案是使用在*渲染响应*阶段保存的现有状态。尝试从头开始重建它将使程序性更改无效，因为它们将不再可用。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the component tree is just a hand of UI components hierarchically
    and logically related. The view state maintains the tree structure and the components
    state (selected/deselected, enabled/disabled, and so on). Therefore, the component
    tree contains only references to backing beans properties/actions through EL expressions,
    and does not store the model values.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，组件树只是UI组件的层次结构和逻辑关系的手。视图状态维护树结构和组件状态（选中/未选中、启用/禁用等）。因此，组件树只包含通过EL表达式引用后端bean属性/操作的引用，并不存储模型值。
- en: JSF partial saving view state
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF部分保存视图状态
- en: 'Starting with JSF 2.0, the performance of managing the state was seriously
    increased by adding the partial state saving feature. Basically, JSF will not
    save the entire component tree, only a piece of it. Obviously this will require
    less memory. In other words, this means that instead of saving the entire component
    tree (the whole view, `<html>`), now, for every request during restore view, JSF
    will recreate the entire component tree from scratch and initialize the components
    from their tag attributes. In this way, JSF will save only the things that are
    deserved to be saved. These are the things that are susceptible to changes (for
    example, `<h:form>`) that cannot be recreated from scratch and/or represent inland
    details of components. These details are: dynamic (programmatic) changes that
    alter the component tree, different kinds of values that were determined for some
    components (usually at first postback), and values that were changed for components
    but have not been submitted (for example, moving a slider or checking a checkbox).
    On the other hand, the things that cannot be changed by the client will not be
    saved.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.0 开始，通过添加部分状态保存功能，管理状态的性能得到了显著提高。基本上，JSF 不会保存整个组件树，而只保存其中的一部分。显然，这将需要更少的内存。换句话说，这意味着现在，在恢复视图的每个请求中，JSF
    将从头开始重新创建整个组件树，并从它们的标签属性初始化组件。这样，JSF 将只保存值得保存的东西。这些是容易变化的东西（例如，`<h:form>`），不能从头开始重新创建，或者代表组件的内联细节。这些细节包括：动态（程序性）更改，这些更改会改变组件树；为某些组件确定的不同类型的值（通常在第一次回发时），以及已更改但尚未提交的组件的值（例如，移动滑块或勾选复选框）。另一方面，客户端无法更改的东西将不会被保存。
- en: Partial state saving and tree visiting
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分状态保存和树遍历
- en: 'In JSF 2.0, the JSF partial state saving feature raised a question similar
    to how a JSF implementation should visit all the components in the component tree
    and ask them for their state (partial)? The answer in JSF 2.1 (and earlier versions)
    was specific to this implementation: Mojarra used a tree visiting algorithm, while
    MyFaces used a so-called "facets + children" traversal. But, technically speaking,
    these two approaches are pretty different, because Mojarra provides a pluggable
    algorithm, while MyFaces doesn''t. Moreover, the Mojarra approach is in context
    (before children are visited, the parent component can choose to use a context/scope),
    while the MyFaces approach follows a pointer design. Furthermore, the Mojarra
    algorithm can visit virtual components. (These kinds of components are obtained
    by looping components such as `UIData`.) On the other hand, from the saving state
    perspective, using a context/scope and looping virtual components is not desirable,
    even if affecting the visiting process can be major and useful.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 中，JSF 部分状态保存功能引发了一个问题，类似于 JSF 实现应该如何遍历组件树并询问它们的状态（部分）。JSF 2.1（以及更早的版本）的答案是针对这个特定实现的：Mojarra
    使用了树遍历算法，而 MyFaces 使用了所谓的“面 + 子”遍历。但从技术上来说，这两种方法相当不同，因为 Mojarra 提供了一个可插拔的算法，而
    MyFaces 则没有。此外，Mojarra 方法是在上下文中（在访问子组件之前，父组件可以选择使用上下文/作用域），而 MyFaces 方法遵循指针设计。此外，Mojarra
    算法可以遍历虚拟组件。（这些组件是通过循环组件如 `UIData` 获得的。）另一方面，从保存状态的角度来看，使用上下文/作用域和循环虚拟组件是不理想的，即使影响遍历过程可能是主要和有用的。
- en: In order to solve this problem, JSF 2.1 offers some hints, which can be considered
    deprecated starting with JSF 2.2\. Starting with JSF 2.2, tree visiting is fully
    capable of partial state saving; thanks to the `StateManagementStrategy.saveView`
    and `StateManagementStrategy.restoreView` methods. These two methods are meant
    to replace their counterparts from the `StateManager` class, and their implementations
    are now mandatory to use the visit API. (A good point to start studying may be
    the `UIComponent.visitTree` method.) As a JSF developer, you will probably never
    interact with this feature, but for the sake of completeness, it may be good to
    be aware of it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，JSF 2.1 提供了一些提示，这些提示从 JSF 2.2 开始可能被认为是过时的。从 JSF 2.2 开始，树遍历完全能够实现部分状态保存；归功于
    `StateManagementStrategy.saveView` 和 `StateManagementStrategy.restoreView` 方法。这两个方法旨在替换
    `StateManager` 类中的对应方法，并且它们的实现现在是使用访问 API 的强制要求。（一个开始学习的好点可能是 `UIComponent.visitTree`
    方法。）作为一个 JSF 开发者，你可能永远不会与这个特性交互，但为了完整性，了解它可能是个好主意。
- en: JSF saving view state on the server or client
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF 在服务器或客户端保存视图状态
- en: 'Saving the view state can be accomplished on the server that hosts the application,
    or on the client machine. We can easily choose between the client and the server
    by adding the context parameter named `javax.faces.STATE_SAVING_METHOD` to the
    `web.xml` file. The value of this method can be `server` or `client` as shown
    in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 视图状态的保存可以在托管应用程序的服务器上完成，也可以在客户端机器上完成。我们可以通过向 `web.xml` 文件中添加名为 `javax.faces.STATE_SAVING_METHOD`
    的上下文参数来轻松地在客户端和服务器之间进行选择。此方法的有效值可以是 `server` 或 `client`，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Starting with JSF 2.2, the values of this context parameter are case insensitive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 开始，此上下文参数的值不区分大小写。
- en: 'Saving the state on the server means to save it in a session with a special
    ID known as the view state ID that refers to the state stored in the server memory.
    This is sent to the client as the value of a hidden input field named, `javax.faces.ViewState`.
    This can be easily tested by running the `ch9_1_1` application, which produces
    the HTML code that contains this field, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上保存状态意味着将其保存在一个具有特殊 ID 的会话中，这个 ID 被称为视图状态 ID，它引用存储在服务器内存中的状态。这作为名为 `javax.faces.ViewState`
    的隐藏输入字段的值发送到客户端。这可以通过运行 `ch9_1_1` 应用程序来轻松测试，该应用程序产生包含此字段的 HTML 代码，如下面的截图所示：
- en: '![JSF saving view state on the server or client](img/6466EN_09_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 在服务器或客户端保存视图状态](img/6466EN_09_01.jpg)'
- en: 'If the state is saved on the client, JSF stores it as the value of the same
    hidden input field. This value is a base64 encrypted string representing the serialization
    of the state. Running the `ch9_1_2` application will produce the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态保存在客户端，JSF 会将其存储为相同隐藏输入字段的值。这个值是一个表示状态序列化的 base64 加密字符串。运行 `ch9_1_2` 应用程序将产生以下输出：
- en: '![JSF saving view state on the server or client](img/6466EN_09_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 在服务器或客户端保存视图状态](img/6466EN_09_02.jpg)'
- en: 'Specifying where the view state will be saved is a piece of cake, but choosing
    between saving the view state on a client or on a server can be a difficult choice,
    because each has its own advantages and disadvantages. Both have a cost, and everybody
    wants to pay a lower price. Choosing the client will increase network traffic
    because the serialized state will generate a larger value for the `javax.faces.ViewState`
    input field. Moreover, encoding/decoding the view state and possible trespasser
    attacks are also important drawbacks of this approach. On the other hand, the
    server uses less memory because nothing is stored in the session. Moreover, storing
    the view state on the client will also be a good solution to prevent losing it
    when the server is down, and to prevent `ViewExpiredException` that occurs when
    the session has expired, or when the maximum number of opened views was reached.
    Saving the state on the server has an opposite effect: the network traffic is
    lower, the usage of memory by the server increases, and the server failures will
    result in loss of the state and possible `ViewExpiredException` instances.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 指定视图状态将保存的位置是一件轻而易举的事情，但选择在客户端或服务器上保存视图状态可能是一个困难的抉择，因为每种方法都有其自身的优缺点。两者都有成本，每个人都希望支付更低的代价。选择客户端会增加网络流量，因为序列化的状态将为
    `javax.faces.ViewState` 输入字段生成更大的值。此外，对视图状态进行编码/解码以及可能的越界攻击也是这种方法的重要缺点。另一方面，服务器使用更少的内存，因为会话中没有存储任何内容。此外，在客户端存储视图状态也将是一个防止服务器宕机时丢失状态以及防止会话过期或达到已打开视图的最大数量时发生的
    `ViewExpiredException` 的好方法。在服务器上保存状态会产生相反的效果：网络流量更低，服务器使用的内存增加，服务器故障将导致状态丢失和可能的
    `ViewExpiredException` 实例。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, developers prefer to have a lower network traffic and use more memory
    on the server, because memory is easy to provide to an application server. But
    this is not a rule; you just have to think what's cheaper for you. Some heavy
    benchmarks can also provide compelling indications about storing the state on
    the client or on the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者更喜欢降低网络流量并在服务器上使用更多内存，因为内存容易提供给应用程序服务器。但这并不是一条规则；你只需考虑对你来说什么更便宜。一些重型基准测试也可以提供关于在客户端或服务器上存储状态的令人信服的指示。
- en: 'In order to make the right choice, do not forget that JSF 2.0 comes, by default,
    with partial state saving, which will be reflected in a smaller size of the `javax.faces.ViewState`
    input field (the state saved on the client) or in less memory needed (the state
    saved on the server). You can disable partial state saving by adding the following
    `context` parameter in `web.xml`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出正确的选择，不要忘记JSF 2.0默认带有部分状态保存，这将在`javax.faces.ViewState`输入字段（客户端保存的状态）的大小减小或所需的内存减少中体现出来。你可以在`web.xml`中添加以下`context`参数来禁用部分状态保存：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For a simple visual test, you can choose to save the state on the client and
    run the same application twice (you can use the application named, `ch9_1_2`):
    first time, enable partial state saving, and second time, disable it—the result
    shown in the following screenshot speaks for itself:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的视觉测试，你可以选择在客户端保存状态并运行同一个应用两次（你可以使用名为`ch9_1_2`的应用）：第一次，启用部分状态保存，第二次，禁用它——下面的截图所示的结果不言自明：
- en: '![JSF saving view state on the server or client](img/6466EN_09_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![JSF在服务器或客户端保存视图状态](img/6466EN_09_03.jpg)'
- en: 'Furthermore, in the same application, you can use partial state saving for
    some views and full state saving for other views. Skip the `javax.faces.PARTIAL_STATE_SAVING`
    context parameter and use the `javax.faces.FULL_STATE_SAVING_VIEW_IDS` context
    parameter. The value of this context parameter contains a list of view IDs for
    which the partial state saving will be disabled. The IDs should be comma separated,
    as shown in the following code (suppose you have three pages: `index.xhtml`, `done.xhtml`,
    and `error.xhtml`, partial state saving is used only for `index.xhtml`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一个应用中，你可以为某些视图使用部分状态保存，而为其他视图使用完整状态保存。跳过`javax.faces.PARTIAL_STATE_SAVING`上下文参数，并使用`javax.faces.FULL_STATE_SAVING_VIEW_IDS`上下文参数。此上下文参数的值包含一个视图ID列表，对于这些视图，将禁用部分状态保存。ID应以逗号分隔，如下面的代码所示（假设你有三个页面：`index.xhtml`、`done.xhtml`和`error.xhtml`，仅对`index.xhtml`使用部分状态保存）：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Programmatically, you can check if the state is saved on the client as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程方式，你可以如下检查状态是否在客户端保存：
- en: 'In view/page the code is as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图/页面中的代码如下：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In backing bean, the code is as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端Bean中，代码如下：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JSF logical and physical views
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF逻辑视图和物理视图
- en: 'So far, so good! We know that JSF can store a full or partial view state on
    server or on client with some advantages and disadvantages. Further, you have
    to know that JSF differentiates views in logical views (specific to the GET requests)
    and physical views (specific to the POST requests). Each GET request generates
    a new logical view. By default, JSF Mojarra (the reference implementation of JSF)
    manages 15 logical views, but this number can be adjusted through the context
    parameter, `com.sun.faces.numberOfLogicalViews`, as shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！我们知道JSF可以在服务器或客户端存储完整或部分视图状态，并具有一些优点和缺点。进一步来说，你必须知道JSF区分逻辑视图（特定于GET请求）和物理视图（特定于POST请求）。每个GET请求都会生成一个新的逻辑视图。默认情况下，JSF
    Mojarra（JSF的参考实现）管理15个逻辑视图，但这个数字可以通过上下文参数`com.sun.faces.numberOfLogicalViews`进行调整，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can easily perform a test of this setting by starting the browser and opening
    the `ch9_2` application three times, in three different browser tabs. Afterwards,
    come back to the first tab and try to submit the form. You will see a `ViewExpiredException`
    because the first logical view was removed from the logical views map, as shown
    in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过启动浏览器并打开`ch9_2`应用三次，在三个不同的浏览器标签页中轻松进行此设置的测试。之后，回到第一个标签页并尝试提交表单。你会看到一个`ViewExpiredException`异常，因为第一个逻辑视图已被从逻辑视图映射中移除，如下面的截图所示：
- en: '![JSF logical and physical views](img/6466EN_09_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![JSF逻辑视图和物理视图](img/6466EN_09_04.jpg)'
- en: If you open the application in one or two tabs, this error will not occur.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个或两个标签页中打开应用，这个错误将不会发生。
- en: There is another story with the POST requests (non-AJAX), because, in this case,
    JSF (Mojarra implementation) will store every single form in the session until
    the maximum size is reached. A `POST` request creates a new physical view (except
    AJAX requests which use the same physical view repeatedly) and JSF Mojarra can
    store 15 physical views per logical view (`Map<LogicalView`, `Map<PhysicalView`,
    and `ViewState>>`). Obviously, a physical view can contain multiple forms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于POST请求（非AJAX），还有一个故事，因为在这种情况下，JSF（Mojarra实现）会存储每个单独的表单，直到达到最大大小。一个 `POST`
    请求创建一个新的物理视图（除了重复使用相同物理视图的AJAX请求外），JSF Mojarra可以每个逻辑视图存储15个物理视图（`Map<LogicalView,
    Map<PhysicalView, and ViewState>>`）。显然，一个物理视图可以包含多个表单。
- en: 'You can control the number of physical views through the context parameter
    named `com.sun.faces.numberOfViewsInSession`. For example, you can decrease its
    value to `4` as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名为 `com.sun.faces.numberOfViewsInSession` 的上下文参数来控制物理视图的数量。例如，你可以将其值减少到
    `4`，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This small value allows you to perform a quick test. Open the application named
    `ch9_3` in the browser and submit that form four times. Afterwards, press the
    browser's back button four times, to return to the first form and try to submit
    it again. You will see an exception, because this physical view was removed from
    the physical view's map. This will not happen if you submit the form less than
    four times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小值允许你进行快速测试。在浏览器中打开名为 `ch9_3` 的应用程序，并提交该表单四次。之后，按四次浏览器的后退按钮，返回到第一个表单并再次尝试提交。你会看到一个异常，因为此物理视图已被从物理视图的映射中移除。如果你提交表单少于四次，这种情况不会发生。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you need more than 15 logical/physical views, then you can increase
    their number or choose to save the state on the client. Saving the state on the
    client is recommended since it will totally eliminate this problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要超过15个逻辑/物理视图，你可以增加它们的数量或选择在客户端保存状态。在客户端保存状态是推荐的，因为它将完全消除这个问题。
- en: In case of navigation between pages, JSF doesn't store anything in the session
    for the GET requests, but will save the state of forms for the POST requests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面导航的情况下，JSF不会为GET请求在会话中存储任何内容，但会为POST请求保存表单的状态。
- en: Saving the state in a database – an experimental application
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据库中保存状态——一个实验性应用程序
- en: Combining the client saving state and complex views can really stress up the
    network bandwidth. The root of this drawback is represented by the size of the
    serialized state that should be passed between the client and the server at each
    request-response cycle. Usually, this string increases the server's response size
    significantly. An interesting idea is to save the view state in a database and
    send to the client only an identifier to the corresponding record. In this section,
    you will see how to accomplish this task using a MongoDB database and a custom
    implementation of saving the client view state. The implementation is tight coupled
    to JSF Mojarra (there are `com.sun.faces.*` specific dependencies requiring Mojarra).
    So, since it is not utilizing the standard API methods, this approach won't work
    in MyFaces.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将客户端保存状态和复杂视图结合起来确实会加大网络带宽的压力。这种缺点的根源在于每个请求-响应周期中客户端和服务器之间应该传递的序列化状态的大小。通常，这个字符串会显著增加服务器的响应大小。一个有趣的想法是将视图状态保存在数据库中，只向客户端发送对应记录的标识符。在本节中，你将看到如何使用MongoDB数据库和自定义的保存客户端视图状态实现这一任务。该实现与JSF
    Mojarra紧密耦合（存在 `com.sun.faces.*` 特定的依赖项，需要Mojarra）。因此，由于它没有使用标准API方法，这种方法在MyFaces中不可行。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with MongoDB (or NoSQL database systems), you can use
    SQL RDBMSs (for example, MySQL) and plain JDBC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉MongoDB（或NoSQL数据库系统），你可以使用SQL RDBMS（例如，MySQL）和平凡的JDBC。
- en: In order to pass the client view state into a database, you have to be aware
    of how JSF deals with it by default, and perform the corresponding adjustments.
    The magic of saving the state begins in the `ViewHandler`/`StateManager` pair
    of classes, which guides the tasks of saving/restoring the views between requests.
    Both of them use a helper class, named `ResponseStateManager`, which knows how
    to determine where the state should be saved (based on the default settings or
    on `web.xml` explicit settings) and delegates the saving/restoring task to one
    of the two helper classes, named `ClientSideStateHelper` and `ServerSideStateHelper`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将客户端视图状态传递到数据库，你必须了解JSF默认如何处理它，并执行相应的调整。保存状态的魔法从 `ViewHandler`/`StateManager`
    类对开始，它们指导请求之间保存/恢复视图的任务。它们都使用一个名为 `ResponseStateManager` 的辅助类，该类知道如何确定状态应该保存的位置（基于默认设置或
    `web.xml` 明确设置），并将保存/恢复任务委托给两个辅助类之一，即 `ClientSideStateHelper` 和 `ServerSideStateHelper`。
- en: Getting more in details, when the view state should be saved, the `StateManager.writeState`
    method is called from the `ViewHandler.renderView` method. In the `StateManager.writeState`
    method, JSF will obtain an instance of `ResponseStateManager`. This object can
    inspect each rendering-technology-specific request, because it knows the rendering
    technology used. The instance of `ResponseStateManager` comes from the `RenderKit`
    class (by calling the `RenderKit` method, named `getResponseStateManager`) and
    delegates the writing task to the `ResponseStateManager.writeState` method. In
    the `ResponseStateManager` constructor, JSF will determine where the view state
    should be saved (on the client or the server), and indicates that the writing
    task should happen in one of the two helper classes, which are responsible for
    effectively writing the view state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，当视图状态应该被保存时，`StateManager.writeState` 方法从 `ViewHandler.renderView` 方法中被调用。在
    `StateManager.writeState` 方法中，JSF将获取一个 `ResponseStateManager` 实例。此对象可以检查每个渲染技术特定的请求，因为它知道使用的渲染技术。`ResponseStateManager`
    实例来自 `RenderKit` 类（通过调用名为 `getResponseStateManager` 的 `RenderKit` 方法）并将写入任务委托给
    `ResponseStateManager.writeState` 方法。在 `ResponseStateManager` 构造函数中，JSF将确定视图状态应该保存的位置（在客户端或服务器上），并指示写入任务应该在两个辅助类之一中发生，这两个类负责有效地写入视图状态。
- en: On the way back, during restore view, the `ViewHandler` uses the `ResponseStateManager`
    class to test if the request is an initial request or a postback request. In case
    of a postback request, JSF will call the `ViewHandler.restoreView` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回过程中，在恢复视图时，`ViewHandler` 使用 `ResponseStateManager` 类来测试请求是否是初始请求或回发请求。如果是回发请求，JSF将调用
    `ViewHandler.restoreView` 方法。
- en: 'Since we are interested in saving view state on the client, we will focus on
    the `ClientSideStateHelper` class, which defines the following important methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注在客户端保存视图状态，我们将关注定义以下重要方法的 `ClientSideStateHelper` 类：
- en: '`writeState`: This method generates the hidden input field and populates its
    value with the encrypted version of the serialization view state'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeState`: 此方法生成隐藏的输入字段，并使用序列化视图状态加密版本填充其值'
- en: '`getState`: This method inspects the incoming request parameters for the standardized
    state parameter name and decrypts the string'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState`: 此方法检查传入的请求参数中是否有标准的状态参数名称，并解密字符串'
- en: 'So, we need to write our helper class, named `CustomClientSideStateHelper`.
    The `writeState` method is a convenient point to start. The idea is to modify
    the default method for sending the encrypted state into a MongoDB database, instead
    of sending it to the client. The client will receive the primary key used for
    storing the state in the database. The modifications are highlighted in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写我们的辅助类，命名为 `CustomClientSideStateHelper`。`writeState` 方法是一个方便的起点。想法是修改默认方法，将加密状态发送到MongoDB数据库，而不是发送到客户端。客户端将接收到用于在数据库中存储状态的键。以下代码中的修改被突出显示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Further, a subsequent client request will pass the primary key to the default
    `getState` method. Therefore, you need to write a custom `getState` method that
    will extract the corresponding state from the database by its ID (primary key):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，后续客户端请求将传递主键到默认的 `getState` 方法。因此，你需要编写一个自定义的 `getState` 方法，通过其ID（主键）从数据库中提取相应的状态：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing the custom ResponseStateManager class
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自定义 `ResponseStateManager` 类
- en: 'At this point, we can save/restore the client view state using a MongoDB database.
    Looking forward, we need to tell JSF to use our `CustomClientSideStateHelper`
    class instead of the default `ClientSideStateHelper` class. This task can be easily
    accomplished if we write a custom implementation of the `ResponseStateManager`
    class. This will be almost the same as the Mojarra implementation, but with a
    small adjustment in the constructor (notice how we slipped the `CustomClientSideStateHelper`
    class here) as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用MongoDB数据库来保存/恢复客户端视图状态。展望未来，我们需要告诉JSF使用我们的`CustomClientSideStateHelper`类而不是默认的`ClientSideStateHelper`类。如果我们编写一个`ResponseStateManager`类的自定义实现，这项任务可以轻松完成。这将几乎与Mojarra实现相同，但在构造函数中有一个小的调整（注意我们在这里巧妙地引入了`CustomClientSideStateHelper`类），如下面的代码所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Following the same reasoning, we need to tell JSF to use our custom `ResponseStateManager`
    class. Remember that JSF obtains an instance of this class through the default
    `RenderKit` class; therefore, we can easily write our custom `RenderKit` class
    and override the `getResponseStateManager` method, which is responsible for creating
    an instance of the `ResponseStateManager` class. In order to write a custom `RenderKit`
    class, we will extend the wrapper class, `RenderKitWrapper`, which represents
    a simple implementation of the `RenderKit` abstract class and spares us the implementation
    of all the methods as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照同样的推理，我们需要告诉JSF使用我们的自定义`ResponseStateManager`类。记住，JSF通过默认的`RenderKit`类获取这个类的实例；因此，我们可以轻松地编写我们的自定义`RenderKit`类，并重写`getResponseStateManager`方法，该方法负责创建`ResponseStateManager`类的实例。为了编写一个自定义的`RenderKit`类，我们将扩展包装类`RenderKitWrapper`，它代表`RenderKit`抽象类的一个简单实现，并省去了我们实现所有方法的麻烦，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The custom `RenderKit` class must be appropriately configured in the `faces-config.xml`
    file as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的`RenderKit`类必须在`faces-config.xml`文件中适当配置，如下所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Done! Now, the default `StateManager` class will require a `ResponseStateManager`
    instance from our `RenderKit` class, which will provide an instance of the `CustomResponseStateManager`
    class. Further, the `CustomResponseStateManager` class will use `CustomClientSideStateHelper`
    for saving/restoring the client state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，默认的`StateManager`类将需要从我们的`RenderKit`类中获取一个`ResponseStateManager`实例，该实例将提供一个`CustomResponseStateManager`类的实例。进一步，`CustomResponseStateManager`类将使用`CustomClientSideStateHelper`来保存/恢复客户端状态。
- en: Adding MongoDB in equation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在等式中添加MongoDB
- en: 'The missing part of the preceding section is the `WriteStateInDB` class. This
    is a class capable of writing/reading data from a MongoDB (Version 2.2.2 or later)
    database using the MongoDB Java Driver (Version 2.8.0 or later), and is listed
    in the following code (for those who are familiar with the MongoDB Java Driver,
    this is a very simple code):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节缺失的部分是`WriteStateInDB`类。这是一个能够使用MongoDB Java Driver（版本2.8.0或更高）从MongoDB（版本2.2.2或更高）数据库中写入/读取数据的类，并在以下代码中列出（对于那些熟悉MongoDB
    Java Driver的人来说，这是一段非常简单的代码）：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Moreover, this class exploits a great facility of MongoDB, named TTL ([http://docs.mongodb.org/manual/tutorial/expire-data/](http://docs.mongodb.org/manual/tutorial/expire-data/)),
    which is capable of automatically removing the data after a specified number of
    seconds or at a specific clock time. This is useful for cleaning up the database
    for the expired sessions (orphans). In this demo, each state will be deleted after
    60 seconds from the insertion of data into the database, but setting the time
    to 30 minutes can be more realistic. Of course, even so, you are under the risk
    of deleting the states that are currently active; therefore, supplementary checks
    or an alternative solution is needed. Unfortunately, we can''t provide more details
    regarding MongoDB, since this is beyond the scope of this book. Therefore you
    have to go for a research ([http://www.mongodb.org/](http://www.mongodb.org/)).
    In the following screenshots, you can see a simple test that reveals the page
    size difference between the default client view state saving (1.3 KB) and the
    customized client view state. The default approach is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个类利用了 MongoDB 的一个强大功能，名为 TTL ([http://docs.mongodb.org/manual/tutorial/expire-data/](http://docs.mongodb.org/manual/tutorial/expire-data/))，它能够在指定秒数或特定时钟时间后自动删除数据。这对于清理已过期的会话（孤儿会话）的数据库非常有用。在这个演示中，每个状态将在数据插入数据库后
    60 秒被删除，但将时间设置为 30 分钟可能更符合实际情况。当然，即便如此，你仍然面临删除当前活跃状态的风险；因此，需要额外的检查或备选方案。不幸的是，我们无法提供更多有关
    MongoDB 的详细信息，因为这超出了本书的范围。因此，你必须进行调研 ([http://www.mongodb.org/](http://www.mongodb.org/))。在下面的屏幕截图，你可以看到一个简单的测试，揭示了默认客户端视图状态保存（1.3
    KB）和自定义客户端视图状态之间的页面大小差异。默认方法如下：
- en: '![Adding MongoDB in equation](img/6466EN_09_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![在等式中添加 MongoDB](img/6466EN_09_05.jpg)'
- en: 'The custom approach is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义方法如下：
- en: '![Adding MongoDB in equation](img/6466EN_09_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![在等式中添加 MongoDB](img/6466EN_09_06.jpg)'
- en: Of course, this approach brings into discussion the main drawback represented
    by the need of hitting the database for each save/restore state (caching can solve
    this).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法引发了一个主要缺点，即每次保存/恢复状态都需要击中数据库（缓存可以解决这个问题）。
- en: The complete application is named `ch9_9`. In order for it to work, you need
    to install MongoDB 2.2.2 (or later). The application comes with the MongoDB Java
    Driver Version 2.8.0, but you can provide a more recent one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch9_9`。为了使其工作，你需要安装 MongoDB 2.2.2（或更高版本）。应用程序附带 MongoDB Java 驱动程序版本
    2.8.0，但你也可以提供更新版本的驱动程序。
- en: 'As a final note to this section, keep in mind that a custom `StateManager`
    class can be written by extending the wrapper class, `StateManagerWrapper`, as
    shown in the following code (starting with JSF 2.0, we can use this wrapper class
    to easily decorate the `StateManager` class):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一点，请记住，可以通过扩展包装类 `StateManagerWrapper` 来编写自定义的 `StateManager` 类，如下面的代码所示（从
    JSF 2.0 开始，我们可以使用这个包装类轻松地装饰 `StateManager` 类）：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The custom state manager should be configured in the `faces-config.xml` file
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义状态管理器应在 `faces-config.xml` 文件中按如下方式配置：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Handling ViewExpiredException
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 `ViewExpiredException`
- en: 'When a user session expires (for any reason) `ViewExpiredException` occurs.
    The scenario behind this exception is based on the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户会话过期（任何原因）时，将发生 `ViewExpiredException`。这个异常背后的场景基于以下步骤：
- en: The user view state is saved on the server (the `javax.faces.STATE_SAVING_METHOD`
    context parameter's value is server).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户视图状态保存在服务器上（`javax.faces.STATE_SAVING_METHOD` 上下文参数的值是 server）。
- en: The user receives the view state ID as the value of the hidden input field,
    `javax.faces.ViewState`. This points out the view state saved on the server.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将视图状态 ID 作为隐藏输入字段 `javax.faces.ViewState` 的值接收，这指向服务器上保存的视图状态。
- en: The user session expires (for example, timeout session) and the view state is
    removed from the server session, but the user still has the view state ID.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户会话过期（例如，超时会话）并且视图状态从服务器会话中删除，但用户仍然拥有视图状态 ID。
- en: The user sends a POST request, but the view state ID indicates an unavailable
    view state; therefore, `ViewExpiredException` occurs.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户发送 POST 请求，但视图状态 ID 指示不可用的视图状态；因此，发生 `ViewExpiredException`。
- en: 'In order to deal with this exception, you have two choices: to avoid it or
    to treat it. Suppose that you are in view **A** and you click on the **Logout**
    button that invalidates the session and redirects control to view **B** (when
    the session is invalidated the state is automatically removed from the session).
    Since this is a POST non-AJAX request, the user can press the browser back button,
    which will load the view **A** again. Now, he can click on the **Logout** button
    again, but this time, instead of view **B**, he/she will see `ViewExpiredException`,
    because, most probably, view **A** is not requested to the server again, and is
    loaded from the browser cache. Since it is loaded from the cache, the `javax.faces.ViewState`
    view state ID is the same as it was at first logout; therefore, the associated
    state is not available anymore. The flow is shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个异常，你有两个选择：避免它或处理它。假设你正在查看**视图A**，然后点击**注销**按钮，这将使会话无效并将控制权重定向到视图**B**（当会话无效时，状态会自动从会话中移除）。由于这是一个非AJAX的POST请求，用户可以按下浏览器后退按钮，这将再次加载视图**A**。现在，他可以再次点击**注销**按钮，但这次，他/她将看到`ViewExpiredException`，因为，很可能是视图**A**没有再次请求服务器，而是从浏览器缓存中加载的。由于是从缓存中加载的，所以`javax.faces.ViewState`视图状态ID与第一次注销时相同；因此，相关的状态不再可用。流程如下面的截图所示：
- en: '![Handling ViewExpiredException](img/6466EN_09_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![处理ViewExpiredException](img/6466EN_09_07.jpg)'
- en: 'Obviously, this is not the desired behavior. You have to tell the browser to
    make a new request to the server instead of loading the view **A** from the cache.
    This can be accomplished by a filter that sets the right headers in order to disable
    browser caching. The filter will be applied to the `Faces Servlet` class as shown
    in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是期望的行为。你必须告诉浏览器向服务器发送新的请求，而不是从缓存中加载视图**A**。这可以通过设置正确头部的过滤器来实现，以禁用浏览器缓存。该过滤器将应用于`Faces
    Servlet`类，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, repeat the scenario and note that instead of `ViewExpiredException`, view
    **A** receives a new view state ID in `javax.faces.ViewState`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重复上述场景，注意，这次不是`ViewExpiredException`，视图**A**在`javax.faces.ViewState`中接收一个新的视图状态ID。
- en: You can see two examples in the code bundle of this chapter. One is named `ch9_4_1`,
    and the other one is named `ch9_4_2`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的代码包中看到两个示例。一个是名为`ch9_4_1`，另一个是名为`ch9_4_2`。
- en: 'The preceding solution may be a little bit confusing to the user, since it
    doesn''t provide any explicit information about what is happening. Moreover, a
    session may expire for many other reasons; therefore it would be a better idea
    to display an error page to the user instead of using a filter to prevent browser
    cache. The error page can be the login page or just an intermediary page containing
    a link to the login page. This can be accomplished by adding in the `web.xml`
    file as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案可能对用户来说有点困惑，因为它没有提供任何关于正在发生什么的明确信息。此外，会话可能因许多其他原因而过期；因此，显示一个错误页面给用户，而不是使用过滤器来防止浏览器缓存，会更好。错误页面可以是登录页面，或者只是一个包含登录页面链接的中间页面。这可以通过在`web.xml`文件中添加以下代码来实现：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A simple `expired.xhtml` will be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`expired.xhtml`将如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete example is named `ch9_5` and is available in the code bundle of
    this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例名为`ch9_5`，可在本书的代码包中找到。
- en: 'There is at least one more approach that comes from JSF 1.2 that works in JSF
    2.2 also. You can try to set the following `context` parameter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 至少还有另一种来自JSF 1.2的方法，在JSF 2.2中也可以使用。你可以尝试设置以下`context`参数：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Well, this can be interpreted as: when the current view expires, generate a
    brand new one and do not throw `ViewExpiredException`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这可以解释为：当当前视图过期时，生成一个新的视图，并且不要抛出`ViewExpiredException`。
- en: The complete example is named `ch9_6` and is available in the code bundle of
    this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例名为`ch9_6`，可在本书的代码包中找到。
- en: More details about this exception (including how you can deal with it in AJAX
    environments) are available in the *Configuring the view handler* and *Configuring
    the global exception handler* sections in [Chapter 5](ch05.html "Chapter 5. JSF
    Configurations Using XML Files and Annotations – Part 2"), *JSF Configurations
    Using XML Files and Annotations – Part 2*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这个异常的详细信息（包括如何在AJAX环境中处理它）可以在[第5章](ch05.html "第5章。使用XML文件和注解配置JSF – 第2部分")的*配置视图处理器*和*配置全局异常处理器*部分中找到，*使用XML文件和注解配置JSF
    – 第2部分*。
- en: Server-state serialization in a session
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话中的服务器状态序列化
- en: On the server side, the state can be stored as a shallow copy or as a deep copy.
    In a shallow copy, the state is not serialized in the session (JSF stores only
    pointers to the state in a session and only the container deals with serialization
    stuff), which requires less memory and allows you to inject EJBs in the view scoped
    beans (use this technique carefully, since the changes that affect objects in
    one copy will be reflected in the rest of the copies). The deep copy represents
    a full serialization of the state in a session, which requires more memory and
    doesn't allow injecting EJBs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，状态可以存储为浅拷贝或深拷贝。在浅拷贝中，状态不会在会话中序列化（JSF在会话中仅存储状态指针，并且只有容器处理序列化相关事宜），这需要更少的内存，并允许你在视图作用域的Bean中注入EJB（请谨慎使用此技术，因为影响一个拷贝中对象的更改将反映在其他拷贝中）。深拷贝表示在会话中完全序列化状态，这需要更多的内存，并且不允许注入EJB。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, JSF Mojarra uses shallow copy, while JSF MyFaces uses deep copy.
    Anyway, perform a quick test to be sure which is the default.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JSF Mojarra使用浅拷贝，而JSF MyFaces使用深拷贝。无论如何，进行快速测试以确保默认值。
- en: 'We can easily alter the default behavior by explicitly setting the `javax.faces.SERIALIZE_SERVER_STATE`
    context parameter in `web.xml`. This context parameter was introduced starting
    with JSF 2.2 and represents the standard context parameter for setting the server
    state serialization in Mojarra and MyFaces. You can indicate that the shallow
    copy should be used as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`web.xml`中显式设置`javax.faces.SERIALIZE_SERVER_STATE`上下文参数来轻松更改默认行为。此上下文参数从JSF
    2.2开始引入，代表在Mojarra和MyFaces中设置服务器状态序列化的标准上下文参数。你可以如下指示使用浅拷贝：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to avoid exceptions of type, `java.io.NotSerializableException` (and
    warnings of type `Setting non-serializable attribute value ...`), keep in mind
    that serializing the state in a session implies serializable backing beans. (They
    import `java.io.Serializable` and their properties are serializable. Special attention
    to nested beans, EJBs, streams, JPA entities, connections, and so on.) This is
    also true when you are storing the view state in the client since the entire state
    should be serializable. When a bean property should not (or cannot) be serialized,
    just declare it `transient` and do not forget that it will be `null` at deserialization.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免类型异常，例如`java.io.NotSerializableException`（以及类型为`Setting non-serializable
    attribute value ...`的警告），请记住，在会话中序列化状态意味着需要序列化的后端Bean。（它们导入`java.io.Serializable`，并且它们的属性是可序列化的。特别关注嵌套Bean、EJB、流、JPA实体、连接等。）当你在客户端存储视图状态时也是如此，因为整个状态应该是可序列化的。当一个Bean属性不应该（或不能）被序列化时，只需将其声明为`transient`，并且不要忘记在反序列化时它将是`null`。
- en: In addition to the preceding note, a common case implies `java.io.NotSerializableException`,
    when the state is saved on the client. But when switching the state on the server,
    this exception miraculously disappears on Mojarra, while it is still present in
    MyFaces. This can be confusing, but is perfectly normal if you are using Mojarra
    implementation, the state should be fully serializable while saving it on the
    client (and it is not, since this exception occurred), while this is not true
    on the server, where Mojarra by default doesn't serialize the state in a session.
    On the other hand, MyFaces defaults to serialize the state; therefore, the exception
    persists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的注意之外，一个常见的情况是当状态在客户端保存时，会引发`java.io.NotSerializableException`。但是，当在服务器端切换状态时，这个异常在Mojarra中神奇地消失了，而在MyFaces中仍然存在。这可能令人困惑，但如果你在使用Mojarra实现时，这是完全正常的；在客户端保存状态时，状态应该是完全可序列化的（但实际上并不是，因为发生了这个异常），而在服务器端，Mojarra默认不会在会话中序列化状态。另一方面，MyFaces默认序列化状态；因此，异常仍然存在。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, you may optimize memory usage and save server resources by redesigning
    the application state, which contains view or session or application backing beans
    (don't cache the data that can be queried from a database and try to reduce the
    number of such beans). Besides managing the view state, this is also an important
    aspect that reflects directly in performance. When more memory is needed, the
    container may choose to serialize the parts of the application state, which means
    that you have to pay the price of deserialization also. While the price of saving
    in the session is represented by memory, the price of serialization/deserialization
    is represented by the time and insignificant disk space (at least it should be
    insignificant).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过重新设计应用程序状态（包含视图或会话或应用程序后端豆），您可以优化内存使用并节省服务器资源，这包含视图或会话或应用程序后端豆（不要缓存可以从数据库查询的数据，并尝试减少此类豆的数量）。除了管理视图状态外，这也是一个直接反映在性能上的重要方面。当需要更多内存时，容器可能会选择序列化应用程序状态的部分，这意味着您必须付出反序列化的代价。虽然将数据保存在会话中的代价是内存，但序列化/反序列化的代价是时间和微不足道的磁盘空间（至少应该是微不足道的）。
- en: JSF 2.2 is stateless
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2是无状态的
- en: The notion of being stateless is pretty confusing, because every application
    must maintain some kind of state (for example, for runtime variables). Generically
    speaking, a stateless application will follow the rule of a state per request,
    which means that a state's lifecycle is the same as the request-response lifecycle.
    This is an important issue in web applications, where we need to use session/application
    scope that, obviously, breaks down the notion of stateless.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态的概念相当令人困惑，因为每个应用程序都必须维护某种状态（例如，用于运行时变量）。一般来说，无状态应用程序将遵循每个请求一个状态的原则，这意味着状态的生命周期与请求-响应生命周期相同。这在Web应用程序中是一个重要的问题，因为我们需要使用会话/应用程序作用域，这显然破坏了无状态的概念。
- en: 'Even so, one of the most popular features of JSF 2.2 consists of stateless
    views (and is actually available starting with Version 2.1.19). The idea behind
    this concept assumes that JSF will not save/restore the view state between requests
    and will prefer to recreate the view state from the XHTML tags on every request.
    The goal is to seriously increase performances: the gain time used for the save/restore
    view state, more efficient usage of server memory, more support for clustered
    environments, and the prevention of `ViewExpiredException`s. So, JSF developers
    have certain requirements of the stateless feature.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，JSF 2.2最受欢迎的功能之一是无状态视图（实际上从版本2.1.19开始就可用）。这个概念背后的想法是假设JSF不会在请求之间保存/恢复视图状态，而会倾向于在每个请求中从XHTML标签中重新创建视图状态。目标是显著提高性能：节省/恢复视图状态所用的时间，更有效地使用服务器内存，更好地支持集群环境，以及防止`ViewExpiredException`。因此，JSF开发者对无状态功能有一定的要求。
- en: Nevertheless, it seems that the stateless feature doesn't affect too much of
    the time used for saving/restoring the view state (this is not expensive, especially
    when the state is saved on a server session and is not going to be serialized)
    and memory performances. On the other hand, when an application is deployed on
    several computers (in clustered environments), the stateless feature can be a
    real help because we don't need session replication (refers to replicating the
    data stored in a session across different instances) and/or sticky sessions (refers
    to the mechanism used by the load balancer to improve efficiency of persistent
    sessions in a clustered configuration) anymore. For stateless applications, the
    nodes do not need to share states, and client postback requests can be resolved
    by different nodes. This is a big achievement, because in order to resolve many
    requests, we can add new nodes without worrying about sharing the state. In addition,
    preventing `ViewExpiredException` is also a big advantage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，似乎无状态功能对保存/恢复视图状态所用的时间影响不大（这并不昂贵，尤其是当状态保存在服务器会话中且不需要序列化时）以及内存性能。另一方面，当一个应用程序部署在多台计算机上（在集群环境中）时，无状态功能可以真正提供帮助，因为我们不再需要会话复制（指在不同实例间复制会话中存储的数据）和/或粘性会话（指负载均衡器用来提高集群配置中持久会话效率的机制）。对于无状态应用程序，节点不需要共享状态，客户端回发请求可以由不同的节点解决。这是一个巨大的成就，因为为了解决许多请求，我们可以添加新的节点而不用担心共享状态。此外，防止`ViewExpiredException`也是一个很大的优势。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Stateless views can be used to postpone session creation or dealing with big
    (complex) component trees that implies an uncomfortable state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态视图可以用来推迟会话创建或处理大型（复杂）组件树，这可能导致不舒适的状态。
- en: Starting with JSF 2.2, the developers can choose between saving the view state
    and creating stateless views in the same application, which means that the application
    can use dynamic forms in some views (stateful) and create/recreate them for every
    request in other views (stateless). For a stateless view, the component tree cannot
    be dynamically generated/changed (for example, JSTL and bindings are not available
    in the stateless mode) and resubmitting forms will probably not work as expected.
    Moreover, some of the JSF components are stateful, which will lead to serious
    issues in a stateless view. But, it is not so easy to nominate those components
    and the issues, since their behavior is dependent on the environment (context).
    Some specific tests may be helpful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2开始，开发者可以在同一应用程序中选择保存视图状态或创建无状态视图，这意味着应用程序可以在某些视图中使用动态表单（有状态）并在其他视图中为每个请求创建/重新创建它们（无状态）。对于无状态视图，组件树不能动态生成/更改（例如，在无状态模式下不可用JSTL和绑定），并且重新提交表单可能不会按预期工作。此外，一些JSF组件是有状态的，这将在无状态视图中导致严重问题。但是，由于它们的行为依赖于环境（上下文），因此很难指定这些组件和问题。一些特定的测试可能会有所帮助。
- en: In order to write a JSF stateless application, you have to design everything
    to work only with the request scoped bean. In some cases, we can use different
    tricks to accomplish this task, like using hidden fields and special request parameters
    for emulating a session. While session and application beans will break down the
    idea of stateless (even if it is possible to use), the view bean will act as request
    beans.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个无状态的JSF应用程序，你必须设计一切仅与请求作用域的bean协同工作。在某些情况下，我们可以使用不同的技巧来完成这项任务，例如使用隐藏字段和特殊的请求参数来模拟会话。虽然会话和应用程序bean会破坏无状态的概念（即使使用它们是可能的），但视图bean将充当请求bean。
- en: 'Programmatically speaking, defining a view as stateless is a piece of cake:
    just add the attribute named, `transient` to the `<f:view>` tag and set its value
    to `true`. Note that in order to have a stateless view, the presence of `<f:view>`
    tag is mandatory, even if it doesn''t have any other use. Each stateless view
    of an application needs this setting because there isn''t a global setting for
    indicating that the stateless effect should be applied at the application level.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，将视图定义为无状态是非常简单的：只需向`<f:view>`标签添加名为`transient`的属性并将其值设置为`true`。请注意，为了有一个无状态视图，`<f:view>`标签的存在是强制性的，即使它没有其他用途。应用程序中的每个无状态视图都需要这个设置，因为没有全局设置来指示应在应用程序级别应用无状态效果。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When a view is stateless, the `javax.faces.ViewState` value will be `stateless`,
    as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图是无状态的，`javax.faces.ViewState`的值将是`stateless`，如下面的屏幕截图所示：
- en: '![JSF 2.2 is stateless](img/6466EN_09_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 2.2是无状态的](img/6466EN_09_08.jpg)'
- en: The view scoped beans and the stateless feature
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图作用域的bean和无状态特性
- en: 'In a stateless environment, the view scoped beans act as request scoped beans.
    Besides the fact that you can''t create/manipulate views dynamically, this is
    one of the big disadvantages that comes with the stateless feature, because it
    will affect AJAX-based applications that usually use view scoped beans. You can
    easily test this behavior with a set of beans with different scopes (the complete
    application is named `ch9_7`). The view scoped bean can be defined as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在无状态环境中，视图作用域的bean充当请求作用域的bean。除了你不能动态创建/操作视图的事实之外，这是无状态特性带来的一个重大缺点，因为它将影响通常使用视图作用域bean的基于AJAX的应用程序。你可以通过一组具有不同作用域的bean轻松测试这种行为（整个应用程序命名为`ch9_7`）。视图作用域bean可以定义如下：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Just change the scope to request, session, and application to obtain the other
    three beans.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将作用域更改为请求、会话和应用程序，就可以获得其他三个bean。
- en: 'Next, we will write a simple stateless view as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个简单的无状态视图，如下所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Afterwards, just submit this form several times (click on the **Generate Timestamp**
    button) and notice that the timestamp generated by the view scoped bean changes
    at every request as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，只需多次提交此表单（点击**生成时间戳**按钮）并注意，视图作用域bean生成的时间戳在每次请求时都会改变，如下面的屏幕截图所示：
- en: '![The view scoped beans and the stateless feature](img/6466EN_09_09.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![视图作用域的bean和无状态特性](img/6466EN_09_09.jpg)'
- en: The request, session, and application scopes work as expected!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请求、会话和应用程序作用域按预期工作！
- en: Detecting stateless views programmatically
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式检测无状态视图
- en: 'Programmatically speaking, you can detect if a view is stateless by using the
    following options:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式，您可以使用以下选项检测视图是否为无状态：
- en: 'In view or page, enter the following code:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图或页面中，输入以下代码：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In view or page, enter the following code. This works only for the `postback`
    requests:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图或页面中，输入以下代码。这仅适用于`postback`请求：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In backing bean, enter the following code:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端Bean中，输入以下代码：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the `isStateless` method can be used only on the `postback` requests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`isStateless`方法只能用于`postback`请求。
- en: The complete application is named `ch9_8`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch9_8`。
- en: JSF security notes
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF安全注意事项
- en: Dissertations about JSF saving state also imply some aspects regarding JSF security.
    It appears that saving the JSF state on the client is less secure than saving
    the JSF state on the server. For the most common security concerns (for example,
    XSS, CSRF, SQL injection, and phishing), JSF provides implicit protection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JSF保存状态的论文还暗示了一些关于JSF安全性的方面。看起来在客户端保存JSF状态比在服务器上保存JSF状态更不安全。对于最常见的安全担忧（例如，XSS、CSRF、SQL注入和钓鱼），JSF提供了隐式保护。
- en: Cross-site request forgery (CSRF)
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）
- en: CSRF and phishing attacks can be prevented by saving state on the server. JSF
    2.0 comes with implicit protection against CSRF attacks based on the value of
    the `javax.faces.ViewState` hidden field. Starting with JSF 2.2, this protection
    was seriously fortified by creating a powerful and robust value for this field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在服务器上保存状态，可以防止CSRF和钓鱼攻击。JSF 2.0自带基于`javax.faces.ViewState`隐藏字段的值的隐式保护来防止CSRF攻击。从JSF
    2.2开始，通过为该字段创建一个强大且健壮的值，这种保护得到了严重加强。
- en: Cross-site scripting (XSS)
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: 'XSS attacks are implicitly prevented by JSF through the `escape` attribute,
    which is set to `true` by default (`<h:outputText/>, <h:outputLabel/>`). The following
    are the examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`escape`属性，JSF隐式防止XSS攻击，该属性默认设置为`true`（`<h:outputText/>, <h:outputLabel/>`）。以下是一些示例：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding examples are XSS protected because they are both escaped.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例都是XSS受保护的，因为它们都经过了转义。
- en: 'But, if you write the following example, then an XSS attack is possible:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您编写以下示例，那么XSS攻击是可能的：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order to allow HTML tags, you have to focus on a specialized tool, which
    will be able to parse the HTML code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许HTML标签，您必须关注一个专门的工具，该工具将能够解析HTML代码。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the stateless mode, the `escape` attribute should always be set to `true`,
    because an XSS gap can facilitate an easy way for CSRF attacks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在无状态模式下，`escape`属性应始终设置为`true`，因为一个XSS漏洞可以提供一个方便的CSRF攻击方式。
- en: SQL injection
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入
- en: SQL injection is usually an attack that speculates SQL queries that are created
    based on user inputs/selections. JSF itself cannot prevent these kinds of attacks,
    because it is not implicated in generating and executing SQL transactions. On
    the other hand, you can use JSF to filter/validate user inputs or selections,
    which may prevent such attacks. Outside JSF, it is a good technique to prevent
    these attacks consisting of writing parameterized queries instead of embedding
    user inputs in the statements and be extra careful at filtering escape characters
    and type handling.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入通常是一种攻击，它推测基于用户输入/选择创建的SQL查询。JSF本身无法防止这类攻击，因为它不涉及生成和执行SQL事务。另一方面，您可以使用JSF来过滤/验证用户输入或选择，这可能防止此类攻击。在JSF之外，编写参数化查询而不是在语句中嵌入用户输入，并在过滤转义字符和类型处理上格外小心，这是一种很好的防止这些攻击的技术。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you found this as an interesting dissertation about the JSF state. This
    was a controversial subject for a long time, and starting with JSF 2.2, the stateless
    views pour more gas on the fire of this controversy. Nevertheless, choosing the
    right way of managing states is a serious decision that affects the applications'
    performance; therefore, choose wisely and try to be documented about the existing
    benchmarks and workarounds regarding the JSF state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您认为这是一篇关于JSF状态的有趣论文。这是一个长期有争议的主题，从JSF 2.2开始，无状态视图给这个争议之火增添了更多的燃料。然而，选择正确管理状态的方式是一个影响应用程序性能的重大决策；因此，明智地选择，并尝试记录有关JSF状态的现有基准和解决方案。
- en: See you in the next chapter, where we will discuss about custom and composite
    components in JSF.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在下一章中，我们将讨论JSF中的自定义和组合组件。
