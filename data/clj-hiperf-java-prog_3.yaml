- en: Part 3. Module 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分第3模块
- en: '**Mastering Clojure**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**精通Clojure**'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Understand the philosophy of the Clojure language and dive into its inner
    workings to unlock its advanced features, methodologies, and constructs*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*理解Clojure语言的哲学，深入其内部工作原理，以解锁其高级功能、方法和结构*'
- en: Chapter 1. Working with Sequences and Patterns
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：处理序列和模式
- en: 'In this chapter, we''ll revisit a few basic programming techniques, such as
    recursion and sequences, with Clojure. As we will see, Clojure focuses on the
    use of higher-order functions to abstract computation, like any other functional
    programming language. This design can be observed in most, if not all, of the
    Clojure standard library. In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些基本的编程技术，例如递归和序列，使用Clojure。正如我们将看到的，Clojure侧重于使用高阶函数来抽象计算，就像任何其他函数式编程语言一样。这种设计可以在Clojure标准库的大部分甚至所有部分中观察到。在本章中，我们将涵盖以下主题：
- en: Exploring recursion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索递归
- en: Learning about sequences and laziness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解序列和惰性
- en: Examining zippers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查zippers
- en: Briefly studying pattern matching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要研究模式匹配
- en: Defining recursive functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义递归函数
- en: '**Recursion** is one of the central methodologies of computer science. It allows
    us to elegantly solve problems that have cumbersome non-recursive solutions. Yet,
    recursive functions are discouraged in quite a few imperative programming languages
    in favor of non-recursive functions. Clojure does no such thing and completely
    embraces recursion along with all its pros and cons. In this section, we will
    explore how to define recursive functions.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**是计算机科学的核心方法之一。它使我们能够优雅地解决那些具有繁琐的非递归解决方案的问题。然而，在许多命令式编程语言中，递归函数是不被鼓励的，而是倾向于使用非递归函数。Clojure并没有这样做，而是完全拥抱递归及其所有优缺点。在本节中，我们将探讨如何定义递归函数。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c1/recur.clj` of the book's
    source code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/recur.clj`中找到。
- en: 'In general, a function can be made recursive by simply calling it again from
    within the body of the function. We can define a simple function to return the
    first `n` numbers of the Fibonacci sequence as shown in *Example 1.1*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个函数可以通过在函数体内再次调用自身来使其成为递归函数。我们可以定义一个简单的函数来返回斐波那契数列的前`n`个数字，如*示例1.1*所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Example 1.1: A simple recursive function*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.1：一个简单的递归函数*'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Fibonacci sequence is a series of numbers that can be defined as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是一系列可以定义为以下形式的数字：
- en: The first element *F[0]* is `0` and the second element *F[1]* is `1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素*F[0]*是`0`，第二个元素*F[1]*是`1`。
- en: The rest of the numbers are the sum of the previous two numbers, that is the
    nth Fibonacci number *F[n] = F[n-1] + F[n-2]*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的数字是前两个数字的和，即第n个斐波那契数*F[n] = F[n-1] + F[n-2]*。
- en: 'In the previously defined `fibo` function, the last two elements of the list
    are determined using the `nth` and `last` functions, and the sum of these two
    elements is appended to the list using the `conj` function. This is done in a
    recursive manner, and the function terminates when the length of the list, determined
    by the `count` function becomes equal to the supplied value `n`. Also, the values
    `0N` and `1N`, which represent `BigInteger` types, are used instead of the values
    `0` and `1`.This is done because using long or integer values for such a computation
    could result in an arithmetic overflow error. We can try out this function in
    the REPL shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的`fibo`函数中，列表的最后两个元素是通过使用`nth`和`last`函数确定的，然后使用`conj`函数将这两个元素的和附加到列表中。这是以递归方式完成的，当由`count`函数确定的列表长度等于提供的值`n`时，函数终止。此外，使用代表`BigInteger`类型的值`0N`和`1N`代替值`0`和`1`。这样做是因为使用长整型或整型值进行此类计算可能会导致算术溢出错误。我们可以在以下REPL中尝试这个函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `fibo` function returns a vector of the first `n` Fibonacci numbers as
    expected. However, for larger values of `n`, this function will cause a stack
    overflow:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo`函数返回一个包含前`n`个斐波那契数的向量，正如预期的那样。然而，对于较大的`n`值，此函数将导致栈溢出：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason for this error is that there were too many nested function calls.
    A call to any function requires an additional call stack. With recursion, we reach
    a point where all of the available stack space in a program is consumed and no
    more function calls can be performed. A *tail call* can overcome this limitation
    by using the existing call stack for a recursive call, which removes the need
    for allocating a new call stack. This is only possible when the return value of
    a function is the return value of a recursive call made by the function, in which
    case an additional call stack is not required to store the state of the function
    that performs the recursive call. This technique is termed as *tail call elimination*.
    In effect, a tail call optimized function consumes a constant amount of stack
    space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的原因是函数调用嵌套太多。对任何函数的调用都需要额外的调用栈。在递归中，我们会达到一个点，此时程序中所有可用的栈空间都被消耗，不能再执行更多的函数调用。通过使用现有的调用栈进行递归调用，*尾调用*可以克服这一限制，从而不需要分配新的调用栈。这只有在函数的返回值是函数执行的递归调用的返回值时才可能，在这种情况下，不需要额外的调用栈来存储执行递归调用的函数的状态。这种技术被称为*尾调用消除*。实际上，尾调用优化的函数消耗的栈空间是恒定的。
- en: 'In fact, the `fibo` function does indeed make a tail call, as the last expression
    in the body of the function is a recursive call. Still, it consumes stack space
    for each recursive call. This is due to the fact that the underlying virtual machine,
    the JVM, does not perform tail call elimination. In Clojure, tail call elimination
    has to be done explicitly using a `recur` form to perform a recursive call. The
    `fibo` function we defined earlier can be refined to be *tail recursive* by using
    a `recur` form, as shown in *Example 1.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`fibo`函数确实执行了尾调用，因为函数体中的最后一个表达式是一个递归调用。尽管如此，它仍然为每个递归调用消耗栈空间。这是因为底层虚拟机，即JVM，不执行尾调用消除。在Clojure中，必须显式地使用`recur`形式来执行递归调用以进行尾调用消除。我们之前定义的`fibo`函数可以通过使用`recur`形式来改进，使其成为*尾递归*，如*示例
    1.2*所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Effectively, the `fibo-recur` function can perform an infinite number of nested
    recursive calls. We can observe that this function does not blow up the stack
    for large values of `n`, shown as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`fibo-recur`函数可以执行无限次的嵌套递归调用。我们可以观察到，对于大的`n`值，该函数不会使栈爆炸，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should note that a call to `fibo-recur` can take quite a while to terminate
    for large values of `n`. We can measure the time taken for a call to `fibo-recur`
    to complete and return a value, using the `time` macro, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，对于大的`n`值，`fibo-recur`的调用可能需要相当长的时间才能终止。我们可以使用`time`宏来测量`fibo-recur`调用完成并返回值所需的时间，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `fibo-recur` function can also be expressed using the `loop` and `recur`
    forms. This eliminates the need for using a second function arity to pass the
    `[0N 1N]` value around, as shown in the `fibo-loop` function defined in *Example
    1.3*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo-recur`函数也可以使用`loop`和`recur`形式来表示。这消除了使用第二个函数参数传递`[0N 1N]`值的需求，如*示例 1.3*中定义的`fibo-loop`函数所示：'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Example 1.3: A recursive function defined using loop and recur*'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 1.3：使用循环和递归定义的递归函数*'
- en: 'Note that the `loop` macro requires a vector of bindings (pairs of names and
    values) to be passed as its first argument. The second argument to the `loop`
    form must be an expression that uses the `recur` form. This nested `recur` form
    calls the surrounding expression recursively by passing in the new values for
    the declared bindings in the `loop` form. The `fibo-loop` function returns a value
    that is equal to that returned by the `fibo-recur` function, from *Example 1.2*,
    shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`loop`宏需要将绑定（名称和值的对）的向量作为其第一个参数传递。`loop`形式的第二个参数必须是一个使用`recur`形式的表达式。这个嵌套的`recur`形式通过在`loop`形式中传递声明的绑定的新值来递归地调用周围的表达式。`fibo-loop`函数返回的值与*示例
    1.2*中`fibo-recur`函数返回的值相等，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another way to handle recursion is by using the `trampoline` function. The
    `trampoline` function takes a function as its first argument, followed by the
    values of the parameters to be passed to the supplied function. A `trampoline`
    form expects the supplied function to return another function, and in such a case,
    the returned function will be invoked. Thus, a `trampoline` form manages recursion
    by obtaining a return value, and invoking the returned value again if it''s a
    function. Thus, the `trampoline` function avoids using any stack space. Each time
    the supplied function is invoked, it returns and the result gets stored in the
    process heap. For example, consider the function in *Example 1.4* that calculates
    the first `n` numbers of the Fibonacci sequence using a `trampoline`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 处理递归的另一种方式是使用`trampoline`函数。`trampoline`函数将其第一个参数作为函数，然后是传递给该函数的参数值。`trampoline`形式期望提供的函数返回另一个函数，在这种情况下，将调用返回的函数。因此，`trampoline`形式通过获取返回值并再次调用该返回值（如果它是一个函数）来管理递归。因此，`trampoline`函数避免了使用任何栈空间。每次调用提供的函数时，它都会返回并将结果存储在进程堆中。例如，考虑*示例1.4*中的函数，该函数使用`trampoline`计算斐波那契数列的前`n`个数字：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Example 1.4: A recursive function defined using trampoline*'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.4：使用trampoline定义的递归函数*'
- en: 'In the `fib-trampoline` function, the internal `fibo-fn` function returns either
    a sequence, denoted by `xs`, or a closure that takes no arguments, represented
    by `#(fibo-fn xs'' n)`. This function is equivalent to the `fibo-recur` function
    we defined earlier, even in terms of performance, shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fib-trampoline`函数中，内部`fibo-fn`函数返回一个序列，表示为`xs`，或者一个不接受任何参数的闭包，表示为`#(fibo-fn
    xs' n)`。这个函数在性能上等同于我们之前定义的`fibo-recur`函数，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Mutual recursion* can also be handled effectively using a trampoline. In mutual
    recursion, two functions call each other in a recursive manner. For example, consider
    the function that utilizes two mutually recursive functions in *Example 1.5*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*相互递归*也可以通过使用`trampoline`函数有效地处理。在相互递归中，两个函数以递归方式相互调用。例如，考虑在*示例1.5*中利用两个相互递归函数的函数：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Example 1.5: A simple function that uses mutual recursion*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.5：使用相互递归的简单函数*'
- en: 'The `sqrt-div2-recur` function from *Example 1.5* defines two mutually recursive
    functions internally, namely `sqrt` and `div2`, that repeatedly square root and
    halve a given value `n` until the calculated value is less than 1\. The `sqrt-div2-recur`
    function declares these two functions using a `letfn` form and invokes the `sqrt`
    function. We can convert this to use a `trampoline` form as shown in *Example
    1.6*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1.5*中的`sqrt-div2-recur`函数在内部定义了两个相互递归的函数，即`sqrt`和`div2`，这两个函数会重复平方根和除以2给定的值`n`，直到计算出的值小于1。`sqrt-div2-recur`函数使用`letfn`形式声明这两个函数并调用`sqrt`函数。我们可以将其转换为使用*示例1.6*中所示的`trampoline`形式：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Example 1.6: A function that uses mutual recursion using trampoline*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.6：使用trampoline进行相互递归的函数*'
- en: 'In the previous `sqrt-div2-trampoline` function shown, the functions `sqrt`
    and `div2` return closures instead of calling a function directly. The `trampoline`
    form in the body of the function calls the `sqrt` function while supplying the
    value `n`. Both the `sqrt-div2-recur` and `sqrt-div2-trampoline` functions take
    about the same time to return a value for the given value of `n`. Hence, using
    a `trampoline` form does not have any additional performance overhead, shown as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前显示的`sqrt-div2-trampoline`函数中，函数`sqrt`和`div2`返回闭包而不是直接调用函数。函数体内的`trampoline`形式在提供值`n`的情况下调用`sqrt`函数。`sqrt-div2-recur`和`sqrt-div2-trampoline`函数在给定`n`的值时返回值所需的时间大致相同。因此，使用`trampoline`形式不会产生任何额外的性能开销，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the preceding examples demonstrate, there are various ways to define recursive
    functions in Clojure. Recursive functions can be optimized using tail call elimination,
    by using `recur`, and mutual recursion, which is done using the `trampoline` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，在Clojure中定义递归函数有多种方式。递归函数可以通过使用`recur`、尾调用消除以及相互递归（通过使用`trampoline`函数实现）进行优化。
- en: Thinking in sequences
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考序列
- en: A **sequence**, shortened as a **seq**, is essentially an abstraction of a list.
    This abstraction provides a unified model or interface to interact with a collection
    of items. In Clojure, all the primitive data structures, namely strings, lists,
    vectors, maps, and sets can be treated as sequences. In practice, almost everything
    that involves iteration can be translated into a sequence of computations. A collection
    is termed as **seqable** if it implements the abstraction of a sequence. We will
    learn everything there is to know about sequences in this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列**，简称为**seq**，本质上是对列表的抽象。这种抽象提供了一个统一的模型或接口，用于与一系列项目进行交互。在Clojure中，所有原始数据结构，即字符串、列表、向量、映射和集合，都可以被视为序列。在实践中，几乎所有涉及迭代的操作都可以转换为计算序列。如果一个集合实现了序列的抽象，则该集合被称为**seqable**。在本节中，我们将学习有关序列的所有知识。'
- en: Sequences can also be *lazy*. A lazy sequence can be thought of as a possibly
    infinite series of computed values. The computation of each value is deferred
    until it is actually needed. We should note that the computation of a recursive
    function can easily be represented as a lazy sequence. For example, the Fibonacci
    sequence can be computed by lazily adding the last two elements in the previously
    computed sequence. This can be implemented as shown in *Example 1.7*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 序列也可以是惰性的。一个惰性序列可以被视为一系列可能无限的计算值。每个值的计算被推迟到实际需要时。我们应该注意，递归函数的计算可以很容易地表示为惰性序列。例如，斐波那契序列可以通过惰性地添加先前计算序列中的最后两个元素来计算。这可以像*示例1.7*中所示的那样实现。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c1/seq.clj` of the book's
    source code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/seq.clj`中找到。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Example 1.7: A lazy Fibonacci sequence*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.7: 惰性斐波那契序列*'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The threading macro `->>` is used to pass the result of a given expression as
    the last argument to the next expression, in a repetitive manner for all expressions
    in its body. Similarly, the threading macro `->` is used to pass the result of
    a given expression as the first argument to the subsequent expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 线程宏`->>`用于将给定表达式的结果作为下一个表达式的最后一个参数传递，以重复的方式对其主体中的所有表达式进行传递。同样，线程宏`->`用于将给定表达式的结果作为后续表达式的第一个参数传递。
- en: The `fibo-lazy` function from *Example 1.7* uses the `iterate`, `map`, and `take`
    functions to create a lazy sequence. We will study these functions in more detail
    later in this section. The `fibo-lazy` function takes a single argument `n`, which
    indicates the number of items to be returned by the function. In the `fibo-lazy`
    function, the values `0N` and `1N` are passed as a vector to the `iterate` function,
    which produces a lazy sequence. The function used for this iteration creates a
    new pair of values `b` and `(+ a b)` from the initial values `a` and `b`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1.7*中的`fibo-lazy`函数使用`iterate`、`map`和`take`函数来创建一个惰性序列。我们将在本节的后面部分更详细地研究这些函数。`fibo-lazy`函数接受一个参数`n`，该参数表示函数返回的项目数量。在`fibo-lazy`函数中，值`0N`和`1N`被作为向量传递给`iterate`函数，该函数生成一个惰性序列。用于此迭代的函数从初始值`a`和`b`创建一个新的值对`b`和`(+
    a b)`。'
- en: 'Next, the `map` function applies the `first` function to obtain the first element
    in each resulting vector. A `take` form is finally applied to the sequence returned
    by the `map` function to retrieve the first `n` values in the sequence. The `fibo-lazy`
    function does not cause any error even when passed relatively large values of
    `n`, shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`map`函数应用`first`函数以获取每个结果向量的第一个元素。最后，对`map`函数返回的序列应用`take`形式，以检索序列中的前`n`个值。即使传递相对较大的`n`值，`fibo-lazy`函数也不会引起任何错误，如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Interestingly, the `fibo-lazy` function in *Example 1.7* performs significantly
    better than the recursive functions from *Example 1.2* and *Example 1.3*, as shown
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，*示例1.7*中的`fibo-lazy`函数在性能上显著优于*示例1.2*和*示例1.3*中的递归函数，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, binding the value returned by the `fibo-lazy` function to a variable
    does not really consume any time. This is because this returned value is lazy
    and not evaluated yet. Also, the type of the return value is `clojure.lang.LazySeq`,
    as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将`fibo-lazy`函数返回的值绑定到变量实际上并不消耗任何时间。这是因为这个返回值是惰性的，尚未被评估。此外，返回值的类型是`clojure.lang.LazySeq`，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can optimize the `fibo-lazy` function even further by using **memoization**,
    which essentially caches the value returned by a function for a given set of inputs.
    This can be done using the `memoize` function, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**记忆化**来进一步优化`fibo-lazy`函数，这本质上是为给定的一组输入缓存函数返回的值。这可以通过使用`memoize`函数来完成，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `fibo-mem` function is a memoized version of the `fibo-lazy` function.
    Hence, subsequent calls to the `fibo-mem` function for the same set of inputs
    will return values significantly faster, shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo-mem`函数是`fibo-lazy`函数的记忆化版本。因此，对于相同的一组输入，对`fibo-mem`函数的后续调用将返回值更快，如下所示：'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `memoize` function can be applied to any function, and it is not
    really related to sequences. The function we pass to `memoize` must be free of
    side effects, or else any side effects will be invoked only the first time the
    memoized function is called with a given set of inputs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`memoize`函数可以应用于任何函数，并且实际上与序列无关。传递给`memoize`的函数必须没有副作用，否则任何副作用都只会在使用给定一组输入调用记忆化函数时触发。
- en: Using the seq library
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用seq库
- en: 'Sequences are a truly ubiquitous abstraction in Clojure. The primary motivation
    behind using sequences is that any domain with sequence-like data in it can be
    easily modelled using the standard functions that operate on sequences. This infamous
    quote from the Lisp world reflects on this design:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 序列在Clojure中是一种真正无处不在的抽象。使用序列的主要动机是，任何包含类似序列数据的领域都可以通过操作序列的标准函数轻松建模。以下来自Lisp世界的著名引言反映了这种设计：
- en: '*"It is better to have 100 functions operate on one data abstraction than 10
    functions on 10 data structures."*'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"与其有10个函数操作10个数据结构，不如有100个函数操作一个数据抽象。"*'
- en: 'A sequence can be constructed using the `cons` function. We must provide an
    element and another sequence as arguments to the `cons` function. The `first`
    function is used to access the first element in a sequence, and similarly the
    `rest` function is used to obtain the other elements in the sequence, shown as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`cons`函数构建一个序列。我们必须向`cons`函数提供元素和另一个序列作为参数。`first`函数用于访问序列中的第一个元素，同样地，`rest`函数用于获取序列中的其他元素，如下所示：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `first` and `rest` functions in Clojure are equivalent to the `car` and
    `cdr` functions, respectively, from traditional Lisps. The `cons` function carries
    on its traditional name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的`first`和`rest`函数分别等同于传统Lisp中的`car`和`cdr`函数，`cons`函数保留了其传统名称。
- en: 'In Clojure, an empty list is represented by the literal `()`. An empty list
    is considered as a *truthy* value, anddoes not equate to `nil`. This rule is true
    for any empty collection. An empty list does indeed have a type – it''s a list.
    On the other hand, the `nil` literal signifies the absence of a value, of any
    type, and is not a truthy value. The second argument that is passed to `cons`
    could be empty, in which case the resulting sequence would contain a single element:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，空列表由字面量`()`表示。空列表被视为*真值*，并且不等于`nil`。这条规则适用于任何空集合。空列表确实有类型——它是一个列表。另一方面，`nil`字面量表示任何类型的值的缺失，并且不是一个真值。传递给`cons`的第二个参数可以是空的，在这种情况下，生成的序列将包含单个元素：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An interesting quirk is that `nil` can be treated as an empty collection, but
    the converse is not true. We can use the `empty?` and `nil?` functions to test
    for an empty collection and a `nil` value, respectively. Note that `(empty? nil)`
    returns `true`, shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的特性是`nil`可以被当作一个空集合处理，但反过来则不成立。我们可以使用`empty?`和`nil?`函数分别测试空集合和`nil`值。注意`(empty?
    nil)`返回`true`，如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By the *truthy* value, we mean to say a value that will test positive in a conditional
    expression such as an `if` or a `when` form.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*真值*，我们指的是在条件表达式（如`if`或`when`形式）中测试为正的值。
- en: 'The `rest` function will return an empty list when supplied an empty list.
    Thus, the value returned by `rest` is always truthy. The `seq` function can be
    used to obtain a sequence from a given collection. It will return `nil` for an
    empty list or collection. Hence, the `head`, `rest` and `seq` functions can be
    used to iterate over a sequence. The `next` function can also be used for iteration,
    and the expression `(seq (rest coll))` is equivalent to `(next coll)`, shown as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 `rest` 函数提供一个空列表时，它将返回一个空列表。因此，`rest` 函数返回的值始终为真值。`seq` 函数可以用来从一个给定的集合中获取序列。对于空列表或集合，它将返回
    `nil`。因此，`head`、`rest` 和 `seq` 函数可以用来遍历序列。`next` 函数也可以用来进行迭代，表达式 `(seq (rest coll))`
    等价于 `(next coll)`，如下所示：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `sequence` function can be used to create a list from a sequence. For example,
    `nil` can be converted into an empty list using the expression `(sequence nil)`.
    In Clojure, the `seq?` function is used to check whether a value implements the
    sequence interface, namely `clojure.lang.ISeq`. Only lists implement this interface,
    and other data structures such as vectors, sets, and maps have to be converted
    into a sequence by using the `seq` function. Hence, `seq?` will return `true`
    only for lists. Note that the `list?`, `vector?`, `map?`, and `set?` functions
    can be used to check the concrete type of a given collection. The behavior of
    the `seq?` function with lists and vectors can be described as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence` 函数可以用来从一个序列创建一个列表。例如，可以使用表达式 `(sequence nil)` 将 `nil` 转换为空列表。在 Clojure
    中，`seq?` 函数用来检查一个值是否实现了序列接口，即 `clojure.lang.ISeq`。只有列表实现了这个接口，而其他数据结构如向量、集合和映射必须通过使用
    `seq` 函数转换为序列。因此，`seq?` 只在列表上返回 `true`。请注意，`list?`、`vector?`、`map?` 和 `set?` 函数可以用来检查给定集合的具体类型。`seq?`
    函数在列表和向量上的行为可以描述如下：'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Only lists and vectors provide a guarantee of sequential ordering among elements.
    In other words, lists and vectors will store their elements in the same order
    or sequence as they were created. This is in contrast to maps and sets, which
    can reorder their elements as needed. We can use the `sequential?` function to
    check whether a collection provides sequential ordering:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只有列表和向量提供元素之间的顺序保证。换句话说，列表和向量将按照它们创建的顺序或序列存储它们的元素。这与映射和集合形成对比，映射和集合可以根据需要重新排序它们的元素。我们可以使用
    `sequential?` 函数来检查一个集合是否提供顺序：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `associative?` function can be used to determine whether a collection or
    sequence associates a key with a particular value. Note that this function returns
    `true` only for maps and vectors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`associative?` 函数可以用来确定一个集合或序列是否将一个键与特定的值关联起来。请注意，此函数仅在映射和向量上返回 `true`：'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The behavior of the `associative?` function is fairly obvious for a map since
    a map is essentially a collection of key-value pairs. The fact that a vector is
    also associative is well justified too, as a vector has an implicit key for a
    given element, namely the index of the element in the vector. For example, the
    `[:a :b]` vector has two implicit keys, `0` and `1`, for the elements `:a` and
    `:b` respectively. This brings us to an interesting consequence – vectors and
    maps can be treated as functions that take a single argument, that is a key, and
    return an associated value, shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射来说，`associative?` 函数的行为相当明显，因为映射本质上是一系列键值对。同样，向量也是关联的，这一点也得到了很好的证明，因为向量对于给定元素有一个隐含的键，即元素在向量中的索引。例如，`[:a
    :b]` 向量有两个隐含的键，分别是 `0` 和 `1`，分别对应元素 `:a` 和 `:b`。这引出了一个有趣的后果——向量与映射可以被当作接受单个参数（即键）并返回相关值的函数，如下所示：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although they are not associative by nature, sets are also functions. Sets
    return a value contained in them, or `nil`, depending on the argument passed to
    them, shown as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们本质上不是关联的，但集合也是函数。集合根据传递给它们的参数返回集合中包含的值或 `nil`，如下所示：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that we have familiarized ourselves with the basics of sequences, let's
    have a look at the many functions that operate over sequences.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了序列的基础知识，让我们来看看操作序列的许多函数。
- en: Creating sequences
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建序列
- en: 'There are several ways to create sequences other than using the `cons` function.
    We have already encountered the `conj` function in the earlier examples of this
    chapter. The `conj` function takes a collection as its first argument, followed
    by any number of arguments to add to the collection. We must note that `conj`
    behaves differently for lists and vectors. When supplied a list, the `conj` function
    adds the other arguments at the head, or start, of the list. In case of a vector,
    the `conj` function will insert the other arguments at the tail, or end, of the
    vector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `cons` 函数之外，还有几种创建序列的方法。我们在本章前面的例子中已经遇到了 `conj` 函数。`conj` 函数将其第一个参数作为集合，然后是任何要添加到集合中的参数。我们必须注意，`conj`
    对于列表和向量有不同的行为。当提供一个列表时，`conj` 函数将其他参数添加到列表的头部或开始处。在向量的情况下，`conj` 函数将其他参数插入到向量的尾部或结束处：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `concat` function can be used to join or *concatenate* any number of sequences
    in the order in which they are supplied, shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 函数可以用来按提供的顺序连接或 *连接* 任意数量的序列，如下所示：'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A given sequence can be reversed using the `reverse` function, shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `reverse` 函数来反转给定的序列，如下所示：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `range` function can be used to generate a sequence of values within a
    given integer range. The most general form of the `range` function takes three
    arguments—the first argument is the start of the range, the second argument is
    the end of the range, and the third argument is the step of the range. The step
    of the range defaults to `1`, and the start of the range defaults to `0`, as shown
    here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数可以用来生成给定整数范围内的值序列。`range` 函数最一般的形式接受三个参数——第一个参数是范围的开始，第二个参数是范围的结束，第三个参数是范围的步长。范围的步长默认为
    `1`，范围的开始默认为 `0`，如下所示：'
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We must note that the `range` function expects the start of the range to be
    less than the end of the range. If the start of the range is greater than the
    end of the range and the step of the range is positive, the `range` function will
    return an empty list. For example, `(range 15 10)` will return `()`. Also, the
    `range` function can be called with no arguments, in which case it returns a lazy
    and infinite sequence starting at `0`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，`range` 函数期望范围的开始小于范围的结束。如果范围的开始大于范围的结束，并且范围的步长是正数，`range` 函数将返回一个空列表。例如，`(range
    15 10)` 将返回 `()`。此外，`range` 函数可以不带参数调用，在这种情况下，它返回一个从 `0` 开始的懒加载和无限序列。
- en: 'The `take` and `drop` functions can be used to take or drop elements in a sequence.
    Both functions take two arguments, representing the number of elements to take
    or drop from a sequence, and the sequence itself, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 和 `drop` 函数可以用来在序列中取或丢弃元素。这两个函数都接受两个参数，表示从序列中取或丢弃的元素数量，以及序列本身，如下所示：'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To obtain an item at a particular position in the sequence, we should use the
    `nth` function. This function takes a sequence as its first argument, followed
    by the position of the item to be retrieved from the sequence as the second argument:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取序列中特定位置的项，我们应该使用 `nth` 函数。这个函数将其第一个参数作为序列，然后是第二个参数，即从序列中检索项的位置：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To repeat a given value, we can use the `repeat` function. This function takes
    two arguments and repeats the second argument the number of times indicated by
    the first argument:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复一个给定的值，我们可以使用 `repeat` 函数。这个函数接受两个参数，并按照第一个参数指示的次数重复第二个参数：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `repeat` function will evaluate the expression of the second argument and
    repeat it. To call a function a number of times, we can use the `repeatedly` function,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 函数将评估第二个参数的表达式并重复它。要多次调用一个函数，我们可以使用 `repeatedly` 函数，如下所示：'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the `repeat` form first evaluates the `(rand-int 100)` form,
    before repeating it. Hence, a single value will be repeated several times. Note
    that the `rand-int` function simply returns a random integer between `0` and the
    supplied value. On the other hand, the `repeatedly` function invokes the supplied
    function a number of times, thus producing a new value every time the `rand-int`
    function is called.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`repeat` 表达式首先评估 `(rand-int 100)` 表达式，然后再重复它。因此，一个值将被重复多次。请注意，`rand-int`
    函数简单地返回一个介于 `0` 和提供的值之间的随机整数。另一方面，`repeatedly` 函数调用提供的函数多次，因此每次调用 `rand-int` 函数时都会产生一个新的值。
- en: 'A sequence can be repeated an infinite number of times using the `cycle` function.
    As you might have guessed, this function returns a lazy sequence to indicate an
    infinite series of values. The `take` function can be used to obtain a limited
    number of values from the resulting infinite sequence, shown as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `cycle` 函数无限次地重复一个序列。正如你可能已经猜到的，这个函数返回一个惰性序列来表示一系列无限值。可以使用 `take` 函数从结果无限序列中获取有限数量的值，如下所示：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `interleave` function can be used to combine any number of sequences. This
    function returns a sequence of the first item in each collection, followed by
    the second item, and so on. This combination of the supplied sequences is repeated
    until the shortest sequence is exhausted of values. Hence, we can easily combine
    a finite sequence with an infinite one to produce another finite sequence using
    the `interleave` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`interleave` 函数可以用来组合任意数量的序列。这个函数返回一个序列，其中包含每个集合的第一个元素，然后是第二个元素，依此类推。这种组合重复进行，直到最短的序列耗尽值。因此，我们可以很容易地使用
    `interleave` 函数将有限序列与无限序列组合起来，以产生另一个有限序列：'
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another function that performs a similar operation is the `interpose` function.
    The `interpose` function inserts a given element between the adjacent elements
    of a given sequence:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个执行类似操作的功能是 `interpose` 函数。`interpose` 函数在给定序列的相邻元素之间插入一个给定的元素：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `iterate` function can also be used to create an infinite sequence. Note
    that we have already used the `iterate` function to create a lazy sequence in
    *Example 1.7*. This function takes a function `f` and an initial value `x` as
    its arguments. The value returned by the `iterate` function will have `(f x)`
    as the first element, `(f (f x))` as the second element, and so on. We can use
    the `iterate` function with any other function that takes a single argument, as
    follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 函数也可以用来创建一个无限序列。请注意，我们已经在 *示例 1.7* 中使用 `iterate` 函数创建了一个惰性序列。这个函数接受一个函数
    `f` 和一个初始值 `x` 作为其参数。`iterate` 函数返回的值将以 `(f x)` 作为第一个元素，`(f (f x))` 作为第二个元素，依此类推。我们可以使用
    `iterate` 函数与任何接受单个参数的其他函数一起使用，如下所示：'
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Transforming sequences
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列转换
- en: 'There are also several functions to convert sequences into different representations
    or values. One of the most versatile of such functions is the `map` function.
    This function *maps* a given function over a given sequence, that is, it applies
    the function to each element in the sequence. Also, the value returned by `map`
    is implicitly lazy. The function to be applied to each element must be the first
    argument to `map`, and the sequence on which the function must be applied is the
    next argument:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个函数可以将序列转换为不同的表示或值。其中最灵活的函数之一是 `map` 函数。这个函数 *映射* 给定函数到给定序列上，即它将函数应用于序列中的每个元素。此外，`map`
    返回的值是隐式惰性的。要应用于每个元素的函数必须是 `map` 的第一个参数，而函数必须应用的序列是下一个参数：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that `map` can accept any number of collections or sequences as its arguments.
    In this case, the resulting sequence is obtained by passing the first items of
    the sequences as arguments to the given function, and then passing the second
    items of the sequences to the given function, and so on until any of the supplied
    sequences are exhausted. For example, we can sum the corresponding elements of
    two sequences using the `map` and `+` functions, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`map` 可以接受任意数量的集合或序列作为其参数。在这种情况下，结果序列是通过将序列的第一个元素作为参数传递给给定函数，然后将序列的第二个元素传递给给定函数，依此类推，直到任何提供的序列耗尽。例如，我们可以使用
    `map` 和 `+` 函数对两个序列的对应元素求和，如下所示：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `mapv` function has the same semantics of map, but returns a vector instead
    of a sequence, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapv` 函数与 `map` 函数具有相同的语义，但返回一个向量而不是序列，如下所示：'
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another variant of the `map` function is the `map-indexed` function. This function
    expects that the supplied function will accept two arguments—one for the index
    of a given element and another for the actual element in the list:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数的另一个变体是 `map-indexed` 函数。这个函数期望提供的函数将接受两个参数——一个用于给定元素的索引，另一个用于列表中的实际元素：'
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, the function supplied to `map-indexed` simply returns its arguments
    as a vector. An interesting point that we can observe from the preceding example
    is that a string can be treated as a sequence of characters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，提供给 `map-indexed` 的函数简单地将其参数作为向量返回。从前面的例子中，我们可以观察到的一个有趣点是字符串可以被看作是一系列字符。
- en: 'The `mapcat` function is a combination of the `map` and `concat` function.
    This function maps a given function over a sequence, and applies the `concat`
    function on the resulting sequence:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapcat`函数是`map`和`concat`函数的组合。这个函数将给定的函数映射到序列上，并对结果序列应用`concat`函数：'
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we use the `split` function from the `clojure.string` namespace
    to split a string using a regular expression, shown as `#"\d"`. The `split` function
    will return a vector of strings, and hence the `mapcat` function returns a sequence
    of strings instead of a sequence of vectors like the `map` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`clojure.string`命名空间中的`split`函数，通过正则表达式`#"\d"`来分割字符串。`split`函数将返回一个字符串向量，因此`mapcat`函数返回的是一个字符串序列，而不是像`map`函数那样返回向量序列。
- en: 'The `reduce` function is used to combine or *reduce* a sequence of items into
    a single value. The `reduce` function requires a function as its first argument
    and a sequence as its second argument. The function supplied to `reduce` must
    accept two arguments. The supplied function is first applied to the first two
    elements in the given sequence, and then applied to the previous result and the
    third element in the sequence, and so on until the sequence is exhausted. The
    `reduce` function also has a second arity, which accepts an initial value, and
    in this case, the supplied function is applied to the initial value and the first
    element in the sequence as the first step. The `reduce` function can be considered
    equivalent to loop-based iteration in imperative programming languages. For example,
    we can compute the sum of all elements in a sequence using `reduce`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数用于将一系列项组合或*归约*为一个单一值。`reduce`函数需要将其第一个参数作为函数，第二个参数作为序列。提供给`reduce`的函数必须接受两个参数。该函数首先应用于给定序列中的前两个元素，然后应用于前一个结果和序列中的第三个元素，依此类推，直到序列耗尽。`reduce`函数还有一个接受初始值的第二个参数，在这种情况下，提供的函数首先应用于初始值和序列中的第一个元素。`reduce`函数可以被认为是命令式编程语言中基于循环的迭代的等价物。例如，我们可以使用`reduce`来计算序列中所有元素的总和，如下所示：'
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, when the `reduce` function is supplied an empty collection,
    it returns `0`, since `(+)` evaluates to `0`. When an initial value of `1` is
    supplied to the `reduce` function, it returns `1`, since `(+ 1)` returns `1`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`reduce`函数被提供一个空集合时，它返回`0`，因为`(+)`计算结果为`0`。当向`reduce`函数提供一个初始值`1`时，它返回`1`，因为`(+
    1)`返回`1`。
- en: 'A *list comprehension* can be created using the `for` macro. Note that a `for`
    form will be translated into an expression that uses the `map` function. The `for`
    macro needs to be supplied a vector of bindings to any number of collections,
    and an expression in the body. This macro binds the supplied symbol to each element
    in its corresponding collection and evaluates the body for each element. Note
    that the `for` macro also supports a `:let` clause to assign a value to a variable,
    and also a `:when` clause to filter out values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`for`宏创建一个*列表推导式*。请注意，`for`形式将被转换为一个使用`map`函数的表达式。`for`宏需要提供一个绑定到任意数量集合的绑定向量以及体中的表达式。这个宏将提供的符号绑定到其对应集合中的每个元素，并为每个元素评估体。请注意，`for`宏还支持一个`:let`子句来分配一个值给变量，以及一个`:when`子句来过滤值：
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `for` macro can also be used over a number of collections, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`宏也可以用于多个集合，如下所示：'
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `doseq` macro has semantics similar to that of `for`, except for the fact
    that it always returns a `nil` value. This macro simply evaluates the body expression
    for all of the items in the given bindings. This is useful in forcing evaluation
    of an expression with side effects for all the items in a given collection:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`doseq`宏的语义与`for`类似，除了它总是返回一个`nil`值。这个宏简单地评估给定绑定中所有项的体表达式。这在强制对给定集合中的所有项进行表达式求值时很有用，以便产生副作用：'
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in the preceding example, both the first and second `doseq` forms return
    `nil`. However, the second form prints the value of the expression `(* x x)`,
    which is a side effect, for all items in the sequence `(range 3 7)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，第一个和第二个`doseq`形式都返回`nil`。然而，第二个形式打印了表达式`(* x x)`的值，这是一个副作用，对于序列`(range
    3 7)`中的所有项。
- en: 'The `into` function can be used to easily convert between types of collections.
    This function requires two collections to be supplied to it as arguments, and
    returns the first collection filled with all the items in the second collection.
    For example, we can convert a sequence of vectors into a map, and vice versa,
    using the `into` function, shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`into` 函数可以用来轻松地在集合类型之间进行转换。此函数需要提供两个集合作为参数，并返回第一个集合，其中包含第二个集合中的所有项。例如，我们可以使用
    `into` 函数将向量序列转换为映射，反之亦然，如下所示：'
- en: '[PRE49]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should note that the `into` function is essentially a composition of the
    `reduce` and `conj` functions. As `conj` is used to fill the first collection,
    the value returned by the `into` function will depend on the type of the first
    collection. The `into` function will behave similar to `conj` with respect to
    lists and vectors, shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，`into` 函数实际上是 `reduce` 和 `conj` 函数的组合。由于 `conj` 用于填充第一个集合，`into` 函数返回的值将取决于第一个集合的类型。`into`
    函数在列表和向量方面将表现得类似于 `conj`，如下所示：
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A sequence can be partitioned into smaller ones using the `partition`, `partition-all`
    and `partition-by` functions. Both the `partition` and `partition-all` functions
    take two arguments—one for the number of items `n` in the partitioned sequences
    and another for the sequence to be partitioned. However, the `partition-all` function
    will also return the items from the sequence, which have not been partitioned
    as a separate sequence, shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `partition`、`partition-all` 和 `partition-by` 函数将序列分割成更小的部分。`partition`
    和 `partition-all` 函数都接受两个参数——一个用于分割序列中项目数量 `n` 的参数，另一个用于要分割的序列。然而，`partition-all`
    函数还将返回未分割的序列中的项，如下所示：
- en: '[PRE51]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `partition` and `partition-all` functions also accept a step argument,
    which defaults to the supplied number of items in the partitioned sequences, shown
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition` 和 `partition-all` 函数也接受一个步长参数，该参数默认为分割序列中提供的项目数量，如下所示：'
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `partition` function also takes a second sequence as an optional argument,
    which is used to pad the sequence to be partitioned in case there are items that
    are not partitioned. This second sequence has to be supplied after the step argument
    to the `partition` function. Note that the padding sequence is only used to create
    a single partition with the items that have not been partitioned, and the rest
    of the padding sequence is discarded. Also, the padding sequence is only used
    if there are any items that have not been partitioned. This can be illustrated
    in the following example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition` 函数还接受一个可选的第二个序列作为参数，该序列用于填充要分割的序列，以防有未分割的项。这个第二个序列必须在 `partition`
    函数的步骤参数之后提供。请注意，填充序列仅用于创建一个包含未分割项的单个分区，其余的填充序列将被丢弃。此外，只有当存在未分割的项时，才会使用填充序列。以下是一个示例来说明这一点：'
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we first provide a padding sequence in the second statement
    as `(range 11 12)`, which only comprises of a single element. In the next statement,
    we supply a larger padding sequence, as `(range 11 15)`, but only the first item
    `11` from the padding sequence is actually used. In the last statement, we also
    supply a padding sequence but it is never used, as the `(range 11)` sequence is
    partitioned into sequences of 3 elements each with a step of `4`, which will have
    no remaining items.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先在第二个语句中提供了一个填充序列 `(range 11 12)`，它只包含一个元素。在下一个语句中，我们提供了一个更大的填充序列
    `(range 11 15)`，但实际使用的只是填充序列中的第一个元素 `11`。在最后一个语句中，我们也提供了一个填充序列，但它从未被使用，因为 `(range
    11)` 序列被分割成每个序列包含 3 个元素，步长为 `4`，这将没有剩余的项。
- en: 'The `partition-by` function requires a higher-order function to be supplied
    to it as the first argument, and will partition items in the supplied sequence
    based on the return value of applying the given function to each element in the
    sequence. The sequence is essentially partitioned by `partition-by` whenever the
    given function returns a new value, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition-by` 函数需要提供一个高阶函数作为第一个参数，并将根据对序列中的每个元素应用给定函数的返回值来根据提供的序列分割项。每当给定函数返回一个新值时，序列实际上就会被
    `partition-by` 分割，如下所示：'
- en: '[PRE54]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, the second statement partitions the given sequence into sequences
    that each contain a single item as we have used the `identity` function, which
    simply returns its argument. For the `[-2 -1 0 1 2]` sequence, the `identity`
    function returns a new value for each item in the sequence and hence the resulting
    partitioned sequences all have a single element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第二条语句将给定的序列分割成包含单个项目的序列，因为我们使用了`identity`函数，它只是简单地返回其参数。对于`[-2 -1 0 1
    2]`序列，`identity`函数为序列中的每个项目返回一个新值，因此分割后的序列都只有一个元素。
- en: 'The `sort` function can be used to change the ordering of elements in a sequence.
    The general form of this function requires a function to compare items and a sequence
    of items to sort. The supplied function defaults to the `compare` function, whose
    behavior changes depending on the actual type of the items being compared:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数可以用来改变序列中元素的顺序。这个函数的一般形式需要一个比较项的函数和一个要排序的项的序列。提供的函数默认为`compare`函数，其行为取决于正在比较的项的实际类型：'
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we intend to apply a particular function to each item in a sequence before
    performing the comparison in a `sort` form, we should consider using the `sort-by`
    function for a more concise expression. The `sort-by` function also accepts a
    function to perform the actual comparison, similar to the `sort` function. The
    `sort-by` function can be demonstrated as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在以`sort`形式进行排序比较之前，对序列中的每个项目应用一个特定的函数，我们应该考虑使用`sort-by`函数以获得更简洁的表达式。`sort-by`函数也接受一个用于实际比较的函数，类似于`sort`函数。以下是如何演示`sort-by`函数的示例：
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, the first and second statements both compare items after applying
    the `first` function to each item in the given sequence. The last statement passes
    the `>` function to the `sort-by` function, which returns the reverse of the sequence
    returned by the first two statements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一条和第二条语句都在对给定序列中的每个项目应用`first`函数之后进行比较。最后一条语句将`>`函数传递给`sort-by`函数，它返回第一条和第二条语句返回的序列的逆序。
- en: Filtering sequences
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤序列
- en: 'Sequences can also be *filtered*, that is transformed by removing some elements
    from the sequence. There are several standard functions to perform this task.
    The `keep` function can be used to remove values from a sequence that produces
    a `nil` value for a given function. The `keep` function requires a function and
    a sequence to be passed to it. The `keep` function will apply the given function
    to each item in the sequence and remove all values that produce `nil`, as shown
    here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 序列也可以被*过滤*，即通过从序列中移除一些元素来转换。有几个标准函数可以执行此任务。`keep`函数可以用来移除序列中产生给定函数`nil`值的值。`keep`函数需要一个函数和一个要传递给它的序列。`keep`函数将对序列中的每个项目应用给定的函数，并移除所有产生`nil`的值，如下所示：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, the first statement removes all even numbers from the given
    sequence. In the second statement, the `seq` function is used to remove all empty
    collections from the given sequence.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一条语句从给定的序列中移除了所有偶数。在第二条语句中，使用了`seq`函数来移除给定序列中的所有空集合。
- en: 'A map or a set can also be passed as the first argument to the `keep` function
    since they can be treated as functions, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们可以被视为函数，因此可以将映射或集合作为`keep`函数的第一个参数传递，如下所示：
- en: '[PRE58]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `filter` function can also be used to remove some elements from a given
    sequence. The `filter` function expects a predicate function to be passed to it
    along with the sequence to be filtered. The items for which the predicate function
    does not return a truthy value are removed from the result. The `filterv` function
    is identical to the filter function, except for the fact that it returns a vector
    instead of a list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数也可以用来从给定的序列中移除一些元素。`filter`函数期望传递给它一个谓词函数以及要过滤的序列。那些谓词函数不返回真值（truthy
    value）的项目将从结果中移除。`filterv`函数与`filter`函数相同，只是它返回一个向量而不是列表：'
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Both the `filter` and `keep` functions have similar semantics. However, the
    primary distinction is that the `filter` function returns a subset of the original
    elements, whereas `keep` returns a sequence of non `nil` values that are returned
    by the function supplied to it, as shown in the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`和`keep`函数具有相似的语义。然而，主要区别在于`filter`函数返回原始元素的一个子集，而`keep`返回一个非`nil`值的序列，这些值是由提供给它的函数返回的，如下面的示例所示：'
- en: '[PRE60]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that in this example, if we passed the `odd?` function to the `keep` form,
    it would return a list of `true` and `false` values, as these values are returned
    by the `odd?` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，如果我们将 `odd?` 函数传递给 `keep` 形式，它将返回一个包含 `true` 和 `false` 值的列表，因为这些值是由
    `odd?` 函数返回的。
- en: 'Also, a `for` macro with a `:when` clause is translated into an expression
    that uses the `filter` function, and hence a `for` form can also be used to remove
    elements from a sequence:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，带有 `:when` 子句的 `for` 宏被翻译成使用 `filter` 函数的表达式，因此 `for` 形式也可以用来从序列中删除元素：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A vector can be *sliced* using the `subvec` function. By sliced, we mean to
    say that a smaller vector is selected from the original vector depending on the
    values passed to the `subvec` function. The `subvec` function takes a vector as
    its first argument, followed by the index indicating the start of the sliced vector,
    and finally another optional index that indicates the end of the sliced vector,
    as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `subvec` 函数来 *切片* 向量。所谓切片，就是根据传递给 `subvec` 函数的值从原始向量中选择一个较小的向量。`subvec`
    函数将其第一个参数作为向量，然后是表示切片向量起始索引的索引，最后是表示切片向量结束索引的可选索引，如下所示：
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Maps can be filtered by their keys using the `select-keys` function. This function
    requires a map as the first argument and a vector of keys as a second argument
    to be passed to it. The vector of keys passed to this function indicates the key-value
    pairs to be included in the resulting map, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `select-keys` 函数通过其键来过滤映射。此函数需要一个映射作为第一个参数，以及一个向量作为第二个参数传递给它。传递给此函数的键向量表示要包含在结果映射中的键值对，如下所示：
- en: '[PRE63]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another way to select key-value pairs from a map is to use the `find` function,
    as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从映射中选择键值对的另一种方法是使用 `find` 函数，如下所示：
- en: '[PRE64]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`take-while` and `drop-while` are analogous to the `take` and `drop` functions,
    and require a predicate to be passed to them, instead of the number of elements
    to take or drop. The `take-while` function takes elements as long as the predicate
    function returns a truthy value, and similarly the `drop-while` function will
    drop elements for the same condition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`take-while` 和 `drop-while` 与 `take` 和 `drop` 函数类似，需要传递一个谓词给它们，而不是要取或删除的元素数量。`take-while`
    函数在谓词函数返回真值时取元素，同样地，`drop-while` 函数将根据相同的条件删除元素：'
- en: '[PRE65]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Lazy sequences
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒序列
- en: '`lazy-seq` and `lazy-cat` are the most elementary constructs to create lazy
    sequences. The value returned by these functions will always have the type `clojure.lang.LazySeq`.
    The `lazy-seq` function is used to wrap a lazily computed expression in a `cons`
    form. This means that the rest of the sequence created by the `cons` form is lazily
    computed. For example, the `lazy-seq` function can be used to construct a lazy
    sequence representing the Fibonacci sequence as shown in *Example 1.8*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy-seq` 和 `lazy-cat` 是创建懒序列的最基本构造。这些函数返回的值类型总是 `clojure.lang.LazySeq`。`lazy-seq`
    函数用于将懒计算的表达式包装在 `cons` 形式中。这意味着 `cons` 形式创建的其余序列是懒计算的。例如，`lazy-seq` 函数可以用来构建表示斐波那契序列的懒序列，如
    *示例 1.8* 所示：'
- en: '[PRE66]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Example 1.8: A lazy sequence created using lazy-seq*'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 1.8：使用 lazy-seq 创建的懒序列*'
- en: 'The `fibo-cons` function requires two initial values, `a` and `b`, to be passed
    to it as the initial values, and returns a lazy sequence comprising the first
    value `a` and a lazily computed expression that uses the next two values in the
    sequence, that is, `b` and `(+ a b)`. In this case, the `cons` form will return
    a lazy sequence, which can be handled using the `take` and `last` functions, as
    shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibo-cons` 函数需要两个初始值，`a` 和 `b`，作为初始值传递给它，并返回一个包含第一个值 `a` 和一个使用序列中的下一个两个值（即
    `b` 和 `(+ a b)`）进行懒计算的懒序列。在这种情况下，`cons` 形式将返回一个懒序列，可以使用 `take` 和 `last` 函数来处理，如下所示：'
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the `fibo-cons` function from *Example 1.8* recursively calls itself
    without an explicit `recur` form, and yet it does not consume any stack space.
    This is because the values present in a lazy sequence are not stored in a call
    stack, and all the values are allocated on the process heap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 *示例 1.8* 中，`fibo-cons` 函数递归地调用自身而没有显式的 `recur` 形式，但它并没有消耗任何栈空间。这是因为懒序列中存在的值不是存储在调用栈中，所有值都是在进程堆上分配的。
- en: 'Another way to define a lazy Fibonacci sequence is by using the `lazy-cat`
    function. This function essentially concatenates all the sequences it is supplied
    in a lazy fashion. For example, consider the definition of the Fibonacci sequence
    in *Example 1.9*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定义惰性斐波那契数列的方法是使用 `lazy-cat` 函数。这个函数本质上是以惰性方式连接它所提供的所有序列。例如，考虑 *示例 1.9* 中斐波那契数列的定义：
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Example 1.9: A lazy sequence created using lazy-cat*'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 1.9：使用 lazy-cat 创建的惰性序列*'
- en: 'The `fibo-seq` variable from *Example 1.9* essentially calculates the Fibonacci
    sequence using a lazy composition of the `map`, `rest,` and `+` functions. Also,
    a sequence is required as the initial value, instead of a function as we saw in
    the definition of `fibo-cons` from *Example 1.8*. We can use the `nth` function
    to obtain a number from this sequence as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1.9* 中的 `fibo-seq` 变量本质上使用 `map`、`rest` 和 `+` 函数的惰性组合来计算斐波那契数列。此外，需要一个序列作为初始值，而不是像我们在
    *示例 1.8* 中定义 `fibo-cons` 时所看到的函数。我们可以使用 `nth` 函数从这个序列中获取一个数字，如下所示：'
- en: '[PRE69]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As shown previously, `fibo-cons` and `fibo-seq` are concise and idiomatic representations
    of the infinite series of numbers in the Fibonacci sequence. Both of these definitions
    return identical values and do not cause an error due to stack consumption.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`fibo-cons` 和 `fibo-seq` 是斐波那契数列中无限数列的简洁和惯用表示。这两个定义返回相同的值，并且不会因为栈消耗而导致错误。
- en: 'An interesting fact is that most of the standard functions that return sequences,
    such as `map` and `filter`, are inherently lazy. Any expression that is built
    using these functions is lazy, and hence never evaluated until needed. For example,
    consider the following expression that uses the `map` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实是，大多数返回序列的标准函数，如 `map` 和 `filter`，本质上都是惰性的。使用这些函数构建的任何表达式都是惰性的，因此只有在需要时才会进行评估。例如，考虑以下使用
    `map` 函数的表达式：
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, the `println` function is not called when we define the `xs`
    variable. However, once we try to print it in the REPL, the sequence is evaluated
    and the numbers are printed out by calling the `println` function. Note that `xs`
    evaluates to `(nil nil nil)` as the `println` function always returns `nil`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们定义 `xs` 变量时，并没有调用 `println` 函数。然而，一旦我们尝试在 REPL 中打印它，序列就会被评估，并通过调用
    `println` 函数打印出数字。请注意，`xs` 评估为 `(nil nil nil)`，因为 `println` 函数总是返回 `nil`。
- en: 'Sometimes, it is necessary to eagerly evaluate a lazy sequence. The `doall`
    and `dorun` functions are used for this exact purpose. The `doall` function essentially
    forces evaluation of a lazy sequence along with any side effects of the evaluation.
    The value returned by `doall` is a list of all the elements in the given lazy
    sequence. For example, let''s wrap the `map` expression from the previous example
    in a `doall` form, shown as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，有必要急切地评估一个惰性序列。`doall` 和 `dorun` 函数正是为此目的而设计的。`doall` 函数本质上强制评估一个惰性序列及其评估的任何副作用。`doall`
    返回的是给定惰性序列中所有元素的列表。例如，让我们将上一个示例中的 `map` 表达式用 `doall` 形式包装，如下所示：
- en: '[PRE71]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, the numbers are printed out as soon as `xs` is defined, as we force evaluation
    using the `doall` function. The `dorun` function has similar semantics as the
    `doall` function, but it always returns `nil`. Hence, we can use the `dorun` function
    instead of `doall` when we are only interested in the side effects of evaluating
    the lazy sequence, and not the actual values in it. Another way to call a function
    with some side effects over all values in a collection is by using the `run!`
    function, which must be passed a function to call and a collection. The `run!`
    function always returns `nil`, just like the `dorun` form.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦定义了 `xs`，数字就会立即打印出来，因为我们使用了 `doall` 函数强制评估。`dorun` 函数与 `doall` 函数具有类似的语义，但它总是返回
    `nil`。因此，当我们只对评估惰性序列的副作用感兴趣，而不是其中的实际值时，我们可以使用 `dorun` 函数代替 `doall`。另一种在集合中的所有值上调用具有一些副作用的功能的方法是使用
    `run!` 函数，它必须传递一个要调用的函数和一个集合。`run!` 函数总是返回 `nil`，就像 `dorun` 形式一样。
- en: Using zippers
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 zippers
- en: Now that we are well versed with sequences, let's briefly examine **zippers**.
    Zippers are essentially data structures that help in traversing and manipulating
    *trees*. In Clojure, any collection that contains nested collections is termed
    as a tree. A zipper can be thought of as a structure that contains location information
    about a tree. Zippers are not an extension of trees, but rather can be used to
    traverse and realize a tree.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了序列，让我们简要地考察一下**zippers**。Zippers本质上是一种数据结构，有助于遍历和操作*树*。在Clojure中，任何包含嵌套集合的集合都被称为树。可以将zippers视为包含有关树的位置信息的结构。Zippers不是树的扩展，而是可以用来遍历和实现树。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，必须在您的命名空间声明中包含以下命名空间：
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The following examples can be found in `src/m_clj/c1/zippers.clj` of the book's
    source code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/zippers.clj`中找到。
- en: 'We can define a simple tree using vector literals, as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用向量字面量定义一个简单的树，如下所示：
- en: '[PRE73]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The vector `tree` is a tree, comprised of the nodes `:a`, `[1 2 3]`, `:b`,
    and `:c`. We can use the `vector-zip` function to create a zipper from the vector
    `tree` as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 向量`tree`是一个树，由节点`:a`、`[1 2 3]`、`:b`和`:c`组成。我们可以使用`vector-zip`函数从向量`tree`创建一个zippers，如下所示：
- en: '[PRE74]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The variable `root` defined previously is a zipper and contains location information
    for traversing the given tree. Note that the `vector-zip` function is simply a
    combination of the standard `seq` function and the `seq-zip` function from the
    `clojure.zip` namespace. Hence, for trees that are represented as sequences, we
    should use the `seq-zip` function instead. Also, all other functions in the `clojure.zip`
    namespace expect their first argument to be a zipper.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的变量`root`是一个zippers，包含遍历给定树的位置信息。请注意，`vector-zip`函数仅仅是标准`seq`函数和`clojure.zip`命名空间中的`seq-zip`函数的组合。因此，对于表示为序列的树，我们应该使用`seq-zip`函数。此外，`clojure.zip`命名空间中的所有其他函数都期望它们的第一个参数是一个zippers。
- en: 'To traverse the zipper, we must use the `clojure.zip/next` function, which
    returns the next node in the zipper. We can easily iterate over all the nodes
    in the zipper using a composition of the `iterate` and `clojure.zip/next` functions,
    as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历zippers，我们必须使用`clojure.zip/next`函数，它返回zippers中的下一个节点。我们可以通过组合`iterate`和`clojure.zip/next`函数轻松地遍历zippers中的所有节点，如下所示：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As shown previously, the first node of the zipper represents the original tree
    itself. Also, the zipper will contain some extra information, other than the value
    contained in the current node, which is useful in navigating across the given
    tree. In fact, the return value of the `next` function is also a zipper. Once
    we have completely traversed the given tree, a zipper pointing to the root of
    the tree will be returned by the `next` function. Note that some information in
    a zipper has been truncated from the preceding REPL output for the sake of readability.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，zippers的第一个节点代表原始树本身。此外，zippers将包含一些额外的信息，除了当前节点包含的值之外，这些信息在导航给定树时很有用。实际上，`next`函数的返回值也是一个zippers。一旦我们完全遍历了给定的树，`next`函数将返回指向树根的zippers。请注意，为了可读性，zippers中的某些信息已被从先前的REPL输出中截断。
- en: 'To navigate to the adjacent nodes in a given zipper, we can use the `down`,
    `up`, `left`, and `right` functions. All of these functions return a zipper, as
    shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到给定zippers中的相邻节点，我们可以使用`down`、`up`、`left`和`right`函数。所有这些函数都返回一个zippers，如下所示：
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `down`, `up`, `left`, and `right` functions change the location of the
    `root` zipper in the `[:a [1 2 3] :b :c]` tree, as shown in the following illustration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`down`、`up`、`left`和`right`函数会改变`[:a [1 2 3] :b :c]`树中`root` zippers的位置，如下面的插图所示：'
- en: '![Using zippers](img/B05024_01_01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![使用zippers](img/B05024_01_01.jpg)'
- en: The preceding diagram shows a zipper at three different locations in the given
    tree. Initially, the location of the zipper is at the root of the tree, which
    is the entire vector. The `down` function moves the location to the first child
    node in the tree. The `left` and `right` functions move the location of the zipper
    to other nodes at the same level or depth in the tree. The `up` function moves
    the zipper to the parent of the node pointed to by the zipper's current location.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了 zipper 在给定树中的三个不同位置。最初，zipper 的位置在树的根处，即整个向量。`down` 函数将位置移动到树中的第一个子节点。`left`
    和 `right` 函数将 zipper 的位置移动到树中同一级别或深度的其他节点。`up` 函数将 zipper 移动到当前 zipper 指向节点的父节点。
- en: 'To obtain the node representing the current location of a zipper in a tree,
    we must use the `node` function, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取表示 zipper 在树中当前位置的节点，我们必须使用 `node` 函数，如下所示：
- en: '[PRE77]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To navigate to the extreme left or right of a tree, we can use the `leftmost`
    and `rightmost` functions, respectively, as shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到树的极端左侧或右侧，我们可以分别使用 `leftmost` 和 `rightmost` 函数，如下所示：
- en: '[PRE78]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `lefts` and `rights` functions return the nodes that are present to the
    left and right, respectively, of a given zipper, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`lefts` 和 `rights` 函数分别返回给定 zipper 左侧和右侧存在的节点，如下所示：'
- en: '[PRE79]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As the `:a` node is the leftmost element in the tree, the `rights` function
    will return all of the other nodes in the tree when passed a zipper that has `:a`
    as the current location. Similarly, the `lefts` function for the zipper at the
    `:a` node will return an empty value, that is `nil`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `:a` 节点是树中的最左侧元素，当传递一个当前位置为 `:a` 的 zipper 时，`rights` 函数将返回树中的所有其他节点。同样，`:a`
    节点的 `lefts` 函数将返回一个空值，即 `nil`。
- en: 'The `root` function can be used to obtain the root of a given zipper. It will
    return the original tree used to construct the zipper, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`root` 函数可以用来获取给定 zipper 的根。它将返回用于构建 zipper 的原始树，如下所示：'
- en: '[PRE80]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `path` function can be used to obtain the path from the root element of
    a tree to the current location of a given zipper, as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 函数可以用来获取从树的根元素到给定 zipper 当前位置的路径，如下所示：'
- en: '[PRE81]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the preceding example, the path of the `1` node in `tree` is represented
    by a vector containing the entire tree and the subtree `[1 2 3]`. This means that
    to get to the `1` node, we must pass through the root and the subtree `[1 2 3]`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`tree` 中的 `1` 节点的路径由包含整个树和子树 `[1 2 3]` 的向量表示。这意味着要到达 `1` 节点，我们必须通过根和子树
    `[1 2 3]`。
- en: 'Now that we have covered the basics of navigating across trees, let''s see
    how we can modify the original tree. The `insert-child` function can be used to
    insert a given element into a tree as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了在树之间导航的基础知识，让我们看看我们如何修改原始树。`insert-child` 函数可以用来将给定的元素插入到树中，如下所示：
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can also remove a node from the zipper using the `remove` function. Also,
    the `replace` function can be used to replace a given node in a zipper:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `remove` 函数从 zipper 中删除节点。同样，可以使用 `replace` 函数在 zipper 中替换给定的节点：
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: One of the most noteworthy examples of tree-like data is XML. Since zippers
    are great at handling trees, they also allow us to easily traverse and modify
    XML content. Note that Clojure already provides the `xml-seq` function to convert
    XML data into a sequence. However, treating an XML document as a sequence has
    many strange implications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 树形数据中最值得注意的例子之一是 XML。由于 zipper 在处理树形数据方面非常出色，它还允许我们轻松地遍历和修改 XML 内容。请注意，Clojure
    已经提供了 `xml-seq` 函数来将 XML 数据转换为序列。然而，将 XML 文档视为序列有许多奇怪的含义。
- en: One of the main disadvantages of using `xml-seq` is that there is no easy way
    to get to the root of the document from a node if we are iterating over a sequence.
    Also, `xml-seq` only helps us iterate over the XML content; it doesn't deal with
    modifying it. These limitations can be overcome using zippers, as we will see
    in the upcoming example.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `xml-seq` 的主要缺点之一是，如果我们正在遍历序列，则没有简单的方法从节点到达文档的根。此外，`xml-seq` 只帮助我们遍历 XML
    内容；它不处理修改。这些限制可以通过使用 zipper 来克服，正如我们将在下面的示例中看到的那样。
- en: 'For example, consider the following XML document:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 XML 文档：
- en: '[PRE84]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The document shown above contains countries and cities represented as XML nodes.
    Each country has a number of cities, and a single city as its capital. Some information,
    such as the name of the country and a flag indicating whether a city is a capital,
    is encoded in the XML attributes of the nodes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的文档包含表示为XML节点的国家和城市。每个国家都有若干个城市，一个城市作为其首都。一些信息，如国家名称和一个表示城市是否为首都的旗帜，被编码在节点的XML属性中。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following example expects the XML content shown previously to be present
    in the `resources/data/sample.xml` file, relative to the root of your Leiningen
    project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例期望之前显示的XML内容存在于相对于你的Leiningen项目根目录的`resources/data/sample.xml`文件中。
- en: 'Let''s define a function to find out all the capital cities in the document,
    as shown in *Example 1.10*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数来找出文档中的所有首都，如下所示 *示例1.10*：
- en: '[PRE85]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '*Example 1.10: Querying XML with zippers*'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.10：使用zippers查询XML*'
- en: Firstly, we must note that the `parse` function from the `clojure.xml` namespace
    reads an XML document and returns a map representing the document. Each node in
    this map is another map with the `:tag`, `:attrs`, and `:content` keys associated
    with the XML node's tag name, attributes, and content respectively.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须注意，来自`clojure.xml`命名空间的`parse`函数读取一个XML文档，并返回一个表示文档的映射。这个映射中的每个节点都是另一个映射，具有与XML节点的标签名、属性和内容相关的`:tag`、`:attrs`和`:content`键。
- en: In *Example 1.10*, we first define a simple function, `is-capital-city?`, to
    determine whether a given XML node has the `city` tag, represented as `:city`.
    The `is-capital-city?` function also checks whether the XML node contains the
    `capital` attribute, represented as `:capital`. If the value of the `capital`
    attribute of a given node is the `"true"` string, then the `is-capital-city?`
    function returns `true`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例1.10* 中，我们首先定义了一个简单的函数，`is-capital-city?`，用于确定给定的XML节点是否具有`city`标签，表示为`:city`。`is-capital-city?`
    函数还检查XML节点是否包含`capital`属性，表示为`:capital`。如果给定节点的`capital`属性值是字符串`"true"`，则`is-capital-city?`
    函数返回`true`。
- en: The `find-capitals` function performs most of the heavy lifting in this example.
    This function first parses XML documents present at the supplied path `file-path`,
    and then converts it into a zipper using the `xml-zip` function. We then iterate
    over the zipper using the `next` function until we arrive back at the root node,
    which is checked by the `take-while` function. We then map the `node` function
    over the resulting sequence of zippers using the `map` function, and apply the
    `filter` function to find the capital cities among all the nodes. Finally, we
    use the `mapcat` function to obtain the XML content of the filtered nodes and
    flatten the resulting sequence of vectors into a single list.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`find-capitals` 函数执行了大部分繁重的工作。这个函数首先使用`xml-zip`函数解析提供的路径`file-path`中的XML文档，并将其转换为zippers。然后我们使用`next`函数遍历zippers，直到回到根节点，由`take-while`函数进行检查。然后我们使用`map`函数将`node`函数映射到结果序列的zippers上，并使用`filter`函数在所有节点中找到首都城市。最后，我们使用`mapcat`函数获取过滤节点的XML内容，并将结果序列的向量扁平化成一个单一列表。
- en: 'When supplied a file containing the XML content we described earlier, the `find-capitals`
    function returns the names of all capital cities in the document:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供包含我们之前描述的XML内容的文件时，`find-capitals` 函数返回文档中所有首都的名称：
- en: '[PRE86]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As demonstrated previously, zippers are apt for dealing with trees and hierarchical
    data such as XML. More generally, sequences are a great abstraction for collections
    and several forms of data, and Clojure provides us with a huge toolkit for dealing
    with sequences. There are several more functions that handle sequences in the
    Clojure language, and you are encouraged to explore them on your own.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，zippers非常适合处理树形结构和如XML这样的分层数据。更普遍地说，序列是集合和数据多种形式的优秀抽象，Clojure为我们提供了处理序列的巨大工具集。Clojure语言中还有几个处理序列的函数，鼓励你自己去探索它们。
- en: Working with pattern matching
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式匹配
- en: In this section, we will examine *pattern matching* in Clojure. Typically, functions
    that use conditional logic can be defined using the `if`, `when`, or `cond` forms.
    Pattern matching allows us to define such functions by declaring patterns of the
    literal values of their parameters. While this idea may appear quite rudimentary,
    it is a very useful and powerful one, as we shall see in the upcoming examples.
    Pattern matching is also a foundational programming construct in other functional
    programming languages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Clojure中的*模式匹配*。通常，使用条件逻辑的函数可以使用`if`、`when`或`cond`形式定义。模式匹配允许我们通过声明参数的文本值模式来定义这样的函数。虽然这个想法可能看起来相当基础，但它是一个非常有用且强大的概念，正如我们将在接下来的示例中看到的那样。模式匹配也是其他函数式编程语言中的基础编程结构。
- en: In Clojure, there is no pattern matching support for functions and forms in
    the core language. However, it is a common notion among Lisp programmers that
    we can easily modify or extend the language using macros. Clojure takes this approach
    as well, and thus pattern matching is made possible using the `match` and `defun`
    macros. These macros are implemented in the `core.match` ([https://github.com/clojure/core.match](https://github.com/clojure/core.match))
    and `defun` ([https://github.com/killme2008/defun](https://github.com/killme2008/defun))
    community libraries. Both of these libraries are also supported on ClojureScript.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，核心语言中没有对函数和形式的模式匹配支持。然而，在Lisp程序员中有一个常见的观点，即我们可以通过宏轻松地修改或扩展语言。Clojure也采取了这种方法，因此模式匹配是通过`match`和`defun`宏实现的。这些宏在`core.match`
    ([https://github.com/clojure/core.match](https://github.com/clojure/core.match))
    和`defun` ([https://github.com/killme2008/defun](https://github.com/killme2008/defun))
    社区库中实现。这两个库也支持ClojureScript。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖项对于即将到来的示例是必需的：
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE88]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The following examples can be found in `src/m_clj/c1/match.clj` of the book's
    source code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c1/match.clj`中找到。
- en: 'Let''s consider a simple example that we can model using pattern matching.
    The XOR logic function returns a true value only when its arguments are exclusive
    of each other, that is, when they have differing values. In other words, the XOR
    function will return false when both of its arguments have the same values. We
    can easily define such a function using the `match` macro, as shown in *Example
    1.11*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，我们可以使用模式匹配来建模。XOR逻辑函数仅在它的参数互斥时返回true值，也就是说，当它们具有不同的值时。换句话说，当两个参数的值都相同时，XOR函数将返回false。我们可以很容易地使用`match`宏定义这样的函数，如*示例1.11*所示：
- en: '[PRE89]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*Example 1.11: Pattern matching using the match macro*'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.11：使用match宏进行模式匹配*'
- en: 'The `xor` function from *Example 1.11* simply matches its arguments, `x` and
    `y`, against a given set of patterns, such as `[true true]` and `[true false]`.
    If both the arguments are `true` or `false`, then the function returns `false`,
    or else it returns `true`. It''s a concise definition that relies on the values
    of the supplied arguments, rather than the use of conditional forms such as `if`
    and `when`. The `xor` function can be defined alternatively, and even more concisely,
    by the `defun` macro, as shown in *Example 1.12*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1.11*中的`xor`函数简单地将其参数`x`和`y`与给定的模式集（如`[true true]`和`[true false]`）进行匹配。如果两个参数都是`true`或`false`，则函数返回`false`，否则返回`true`。这是一个简洁的定义，它依赖于提供的参数的值，而不是使用`if`和`when`之类的条件形式。`xor`函数可以通过`defun`宏以不同的方式定义，甚至更加简洁，如*示例1.12*所示：'
- en: '[PRE90]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '*Example 1.12: Pattern match using the defun macro*'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例1.12：使用defun宏进行模式匹配*'
- en: 'The definition of the `xor` function that uses the `defun` macro simply declares
    the actual values as its arguments. The expression to be returned is thus determined
    by the values of its inputs. Note that the `defun` macro rewrites the definition
    of the `xor` function to use the `match` macro. Hence, all patterns supported
    by the `match` macro can also be used with the `defun` macro. Both the definitions
    of the `xor` function, from *Example 1.11* and *Example 1.12*, work as expected,
    as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defun`宏定义的`xor`函数简单地声明实际值作为其参数。因此，要返回的表达式由其输入值确定。请注意，`defun`宏重写了`xor`函数的定义，以使用`match`宏。因此，所有由`match`宏支持的模式也可以与`defun`宏一起使用。*示例1.11*和*示例1.12*中`xor`函数的定义都按预期工作，如下所示：
- en: '[PRE91]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `xor` function will throw an exception if we try to pass values that have
    not been declared as a pattern:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试传递未声明为模式的值给 `xor` 函数，它将抛出异常：
- en: '[PRE92]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can define a simple function to compute the *n^(th)* number of the Fibonacci
    sequence using the `defun` macro, as shown in *Example 1.13*:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `defun` 宏定义一个简单的函数来计算斐波那契序列的第 *n* 个数，如下所示 *示例 1.13*：
- en: '[PRE93]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Note the use of the variable `n` in the function''s pattern rules. This signifies
    that any value other than `0` and `1` will match with the pattern definition that
    uses `n`. The `fibo` function defined in *Example 1.13* does indeed calculate
    the *n^(th)* Fibonacci sequence, as shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数模式规则中变量 `n` 的使用。这表示除了 `0` 和 `1` 以外的任何值都将与使用 `n` 的模式定义相匹配。*示例 1.13* 中定义的
    `fibo` 函数确实计算了第 *n* 个斐波那契序列，如下所示：
- en: '[PRE94]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'However, the definition of `fibo`, shown in *Example 1.13*, cannot be optimized
    by tail call elimination. This is due to the fact that the definition of `fibo`
    is tree recursive. By this, we mean to say that the expression `(+ (fibo ...)
    (fibo ...))` requires two recursive calls in order to be evaluated completely.
    In fact, if we replace the recursive calls to the `fibo` function with `recur`
    expressions, the resulting function won''t compile. It is fairly simple to convert
    tree recursion into linear recursion, as shown in *Example 1.14*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*示例 1.13* 中显示的 `fibo` 的定义不能通过尾调用消除来优化。这是因为 `fibo` 的定义是树递归的。换句话说，表达式 `(+ (fibo
    ...) (fibo ...))` 需要两个递归调用才能完全评估。实际上，如果我们用 `recur` 表达式替换 `fibo` 函数的递归调用，得到的函数将无法编译。将树递归转换为线性递归相当简单，如
    *示例 1.14* 所示：
- en: '[PRE95]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '*Example 1.14: A tail recursive function with pattern matching*'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 1.14：具有模式匹配的尾递归函数*'
- en: 'It is fairly obvious from the definition of the `fibo-recur` function, from
    *Example 1.14*, that it is indeed tail recursive. This function does not consume
    any stack space, and can be safely called with large values of `n`, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `fibo-recur` 函数的定义，从 *示例 1.14* 中可以看出，它确实是尾递归的。这个函数不消耗任何栈空间，可以安全地用大的 `n` 值调用，如下所示：
- en: '[PRE96]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As the preceding examples show us, pattern matching is a powerful tool in functional
    programming. Functions that are defined using pattern matching are not only correct
    and expressive, but can also achieve good performance. In this respect, the `core.match`
    and `defun` libraries are indispensible tools in the Clojure ecosystem.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，模式匹配是函数式编程中的一个强大工具。使用模式匹配定义的函数不仅正确且具有表现力，而且可以取得良好的性能。在这方面，`core.match`
    和 `defun` 库是 Clojure 生态系统中的不可或缺的工具。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we introduced a few programming constructs that can be used
    in the Clojure language. We've explored recursion using the `recur`, `loop`, and
    `trampoline` forms. We've also studied the basics of sequences and laziness, while
    describing the various functions in the Clojure language that are used in creating,
    transforming, and filtering sequences. Next, we had a look at zippers, and how
    they can be used to idiomatically handle trees and hierarchical data such as XML.
    Finally, we briefly explored pattern matching using the `core.match` and `defun`
    libraries.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些可以在 Clojure 语言中使用的编程结构。我们探讨了使用 `recur`、`loop` 和 `trampoline` 形式进行递归。我们还研究了序列和惰性的基础知识，同时描述了在
    Clojure 语言中用于创建、转换和过滤序列的各种函数。接下来，我们查看了一下 zippers，以及它们如何被用来习惯性地处理树和如 XML 这样的层次数据。最后，我们简要探讨了使用
    `core.match` 和 `defun` 库进行模式匹配。
- en: In the next chapter, we will explore concurrency and parallelism. We will study
    the various data structures and functions that allow us to leverage these concepts
    in Clojure in ample detail.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨并发与并行。我们将详细研究各种数据结构和函数，这些函数允许我们在 Clojure 中充分利用这些概念。
- en: Chapter 2. Orchestrating Concurrency and Parallelism
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 编排并发与并行
- en: 'Let''s now examine how concurrent and parallel programming are supported in
    Clojure. The term *concurrent programming* refers to managing more than one task
    at the same time. *Parallel programming* or *parallelism*, on the other hand,
    deals with executing multiple tasks at the same time. The distinction between
    these two terms is that concurrency is about how we structure and synchronize
    multiple tasks, and parallelism is more about running multiple tasks in parallel
    over multiple cores. The main advantages of using concurrency and parallelism
    can be elaborated as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨Clojure如何支持并发和并行编程。术语*并发编程*指的是同时管理多个任务。另一方面，*并行编程*或*并行性*涉及同时执行多个任务。这两个术语的区别在于，并发是关于我们如何构建和同步多个任务，而并行性更多地涉及在多个核心上并行运行多个任务。使用并发和并行性的主要优势可以详细阐述如下：
- en: Concurrent programs can perform multiple tasks simultaneously. For example,
    a desktop application can have a single task for handling user interaction and
    another task for handling I/O and network communication. A single processor can
    be shared among several tasks. Processor utilization is thus more effective in
    concurrent programs.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发程序可以同时执行多个任务。例如，桌面应用程序可以有一个处理用户交互的单个任务，另一个处理I/O和网络通信的任务。单个处理器可以由多个任务共享。因此，在并发程序中，处理器利用率更为有效。
- en: Parallel programs take advantage of having multiple processor cores. This means
    that such programs can be made to run faster by executing them on a system with
    more processor cores. Also, tasks that are computationally expensive can be parallelized
    to complete in a lesser amount of time.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行程序可以利用多个处理器核心的优势。这意味着，通过在具有更多处理器核心的系统上执行这些程序，可以使此类程序运行得更快。此外，计算密集型任务可以通过并行化以更短的时间完成。
- en: 'In this chapter, we will:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Explore how we can create and synchronize tasks that run concurrently
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究如何创建和同步并发运行的任务
- en: See how to deal with a shared state between concurrent tasks
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何处理并发任务之间的共享状态
- en: Examine how computations can be parallelized and how we can control the amount
    of parallelism used to perform these computations
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨如何并行化计算以及如何控制用于这些计算的并行程度
- en: Managing concurrent tasks
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理并发任务
- en: Clojure has a couple of handy constructs that allow us to define concurrent
    tasks. A *thread* is the most elementary abstraction of a task that runs in the
    background. In the formal sense, a thread is simply a sequence of instructions
    that can be scheduled for execution. A task that runs in the background of a program
    is said to execute on a separate thread. Threads will be scheduled for execution
    on a specific processor by the underlying operating system. Most modern operating
    systems allow a process to have several threads of execution. The technique of
    managing multiple threads in a single process is termed as *multithreading*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有几个实用的构造，允许我们定义并发任务。*线程*是运行在后台的任务的最基本抽象。在正式意义上，线程只是一系列可以调度执行的指令。在程序的后台运行的任务被称为在单独的线程上执行。底层操作系统将负责将线程调度到特定的处理器上。大多数现代操作系统允许一个进程有多个执行线程。在单个进程中管理多个线程的技术被称为*多线程*。
- en: While Clojure does support the use of threads, concurrent tasks can be modeled
    in more elegant ways using other constructs. Let's explore the different ways
    in which we can define concurrent tasks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Clojure支持线程的使用，但可以使用其他构造以更优雅的方式对并发任务进行建模。让我们探索我们可以定义并发任务的不同方式。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The following examples can be found in `src/m_clj/c2/concurrent.clj` of the
    book's source code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c2/concurrent.clj`中找到。
- en: Using delays
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用延迟
- en: 'A *delay* can be used to define a task whose execution is delayed, or *deferred*,
    until it is necessary. A delay is only run once, and its result is cached. We
    simply need to wrap the instructions of a given task in a `delay` form to define
    a delay, as shown in *Example 2.1*:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*延迟*来定义一个执行被延迟，或*推迟*，直到必要时才执行的任务。延迟只运行一次，并且其结果被缓存。我们只需将给定任务的指令包裹在`delay`形式中，就可以定义一个延迟，如*示例
    2.1*所示：
- en: '[PRE97]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '*Example 2.1: A delayed value*'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.1：延迟值*'
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The static `Thread/sleep` method suspends execution of the current thread of
    execution for a given number of milliseconds, which is passed as the first argument
    to this method. We can optionally specify the number of nanoseconds by which the
    current thread must be suspended as the second argument to the `Thread/sleep`
    method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Thread/sleep` 方法暂停当前执行线程的执行，持续给定数量的毫秒，该数量作为此方法的第一个参数传递。我们可以选择性地指定当前线程必须暂停的纳秒数，作为
    `Thread/sleep` 方法的第二个参数。
- en: 'The `delay` form in *Example 2.1* simply sleeps for `3000` milliseconds, prints
    a string and returns the value `1`. However, it is not yet *realized*, in the
    sense that, it is has not been executed yet. The `realized?` predicate can be
    used to check whether a delay has been executed, as shown here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.1* 中的 `delay` 形式简单地暂停 `3000` 毫秒，打印一个字符串并返回值 `1`。然而，它尚未 *实现*，也就是说，它尚未被执行。可以使用
    `realized?` 谓词来检查延迟是否已执行，如下所示：
- en: '[PRE98]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can check whether a value is a delay using the `delay?` predicate.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `delay?` 谓词来检查一个值是否是延迟。
- en: 'The body expressions in a `delay` form will not be executed until the value
    returned by it is actually used. We can obtain the value contained in a delay
    by dereferencing it using the at-the-rate symbol (`@`):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `delay` 形式中的主体表达式将在其实际使用的值返回之前不会执行。我们可以通过使用 at-the-rate 符号 (`@`) 解引用延迟来获取延迟中包含的值：
- en: '[PRE99]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the at-the-rate symbol (`@`) to dereference a value is the same as using
    the `deref` function. For example, the expression `@x` is equivalent to `(deref
    x)`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 at-the-rate 符号 (`@`) 来解引用一个值与使用 `deref` 函数相同。例如，表达式 `@x` 等价于 `(deref x)`。
- en: The `deref` function also has a variant form that accepts three arguments—a
    value to dereference, the number of milliseconds to wait before timing out, and
    a value that will be returned in case of a timeout.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`deref` 函数还有一个接受三个参数的变体形式——一个要解引用的值、在超时前等待的毫秒数，以及在超时情况下返回的值。'
- en: 'As shown previously, the expression `@delayed-1` returns the value `1`, after
    a pause of 3 seconds. Now, the call to `realized?` returns `true`. Also, the value
    returned by the expression `@delayed-1` will be cached, as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，表达式 `@delayed-1` 在暂停 3 秒后返回值 `1`。现在，对 `realized?` 的调用返回 `true`。此外，表达式 `@delayed-1`
    返回的值将被缓存，如下所示：
- en: '[PRE100]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It is thus evident that the expression `@delayed-1` will be blocked for 3 seconds,
    will print a string, and return a value only once.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，表达式 `@delayed-1` 将被阻塞 3 秒，将打印一个字符串，并仅返回一个值。
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another way to execute a delay is by using the `force` function, which takes
    a delay as an argument. This function executes a given delay if needed, and returns
    the value of the delay's inner expression.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 执行延迟的另一种方式是使用 `force` 函数，该函数接受一个延迟作为参数。如果需要，此函数将执行给定的延迟，并返回延迟内部表达式的值。
- en: Delays are quite handy for representing values or tasks that need not be executed
    until required. However, a delay will always be executed in the same thread in
    which it is dereferenced. In other words, delays are *synchronous*. Hence, delays
    aren't really a solution for representing tasks that run in the background.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟对于表示不需要立即执行直到需要执行的价值或任务非常有用。然而，延迟将始终在它被解引用的同一线程中执行。换句话说，延迟是 *同步的*。因此，延迟并不是表示在后台运行的任务的真正解决方案。
- en: Using futures and promises
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未来和承诺
- en: 'As we mentioned earlier, threads are the most elementary way of dealing with
    background tasks. In Clojure, all functions implement the `clojure.lang.IFn` interface,
    which in turn extends the `java.lang.Runnable` interface. This means that any
    Clojure function can be invoked in a separate thread of execution. For example,
    consider the function in *Example 2.2*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，线程是处理后台任务的最基本方式。在 Clojure 中，所有函数都实现了 `clojure.lang.IFn` 接口，该接口反过来扩展了
    `java.lang.Runnable` 接口。这意味着任何 Clojure 函数都可以在单独的执行线程中调用。例如，考虑 *示例 2.2* 中的函数：
- en: '[PRE101]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '*Example 2.2: A function that waits for 3 seconds*'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.2：等待 3 秒的函数*'
- en: 'The `wait-3-seconds` function in *Example 2.2* waits for `3000` milliseconds
    and prints a new line and a string. We can execute this function on a separate
    thread by constructing a `java.lang.Thread` object from it using the `Thread.`
    constructor. The resulting object can then be scheduled for execution in the background
    by invoking its `.start` method, as shown here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.2* 中的 `wait-3-seconds` 函数等待 `3000` 毫秒并打印一个新行和一个字符串。我们可以通过使用 `Thread.`
    构造函数从它构造一个 `java.lang.Thread` 对象来在单独的线程中执行此函数。然后，可以通过调用其 `.start` 方法来安排该对象在后台执行，如下所示：
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The call to the `.start` method returns immediately to the REPL prompt. The
    `wait-3-seconds` function gets executed in the background, and prints to standard
    output in the REPL after 3 seconds. While using threads does indeed allow execution
    of tasks in the background, they have a couple shortcomings:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `.start` 方法会立即返回到 REPL 提示符。`wait-3-seconds` 函数在后台执行，并在 3 秒后在 REPL 的标准输出中打印。虽然使用线程确实允许在后台执行任务，但它们有几个缺点：
- en: There is no obvious way to obtain a return value from a function that is executed
    on a separate thread.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从在单独线程上执行的功能中获取返回值没有明显的方法。
- en: Also, using the `Thread.` and `.start` functions is essentially interop with
    the underlying JVM. Thus, using these functions in a program's code would mean
    that the program could be run only on the JVM. We essentially lock our program
    into a single platform, and the program can't be run on any of the other platforms
    that Clojure supports.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，使用 `Thread.` 和 `.start` 函数基本上是与底层 JVM 的互操作。因此，在程序代码中使用这些函数意味着程序只能在 JVM 上运行。我们实际上将程序锁定在单个平台上，程序不能在
    Clojure 支持的其他任何平台上运行。
- en: 'A *future* is a more idiomatic way to represent a task that is executed in
    a separate thread. Futures can be concisely defined as values that will be realized
    in the future. A future represents a task that performs a certain computation
    and returns the result of the computation. We can create a future using the `future`
    form, as shown in *Example 2.3*:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*future* 是表示在单独线程上执行的任务的更习惯用法。未来可以被简洁地定义为将在未来实现的值。未来表示执行特定计算并返回计算结果的任务。我们可以使用
    `future` 形式创建一个未来，如 *示例 2.3* 所示：'
- en: '[PRE103]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*Example 2.3: A future that sleeps for some time and returns a value*'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.3：一个等待一段时间并返回值的未来*'
- en: 'The `val-as-future` function defined in *Example 2.3* invokes a future that
    waits for the number of seconds specified by the argument `secs`, prints a new
    line and a string, and finally returns the supplied value `n`. A call to the `val-as-future`
    function will return a future immediately, and a string will be printed after
    the specified number of seconds, as shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.3* 中定义的 `val-as-future` 函数调用一个等待由参数 `secs` 指定秒数的未来，打印一个新行和一个字符串，并最终返回提供的值
    `n`。调用 `val-as-future` 函数将立即返回一个未来，并在指定秒数后打印一个字符串，如下所示：
- en: '[PRE104]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `realized?` and `future-done?` predicates can be used to check whether
    a future has completed, as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`realized?` 和 `future-done?` 谓词可以用来检查一个未来是否已完成，如下所示：'
- en: '[PRE105]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can check whether a value is a future using the `future?` predicate.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `future?` 谓词来检查一个值是否是未来。
- en: 'A future that is being executed can be stopped by using the `future-cancel`
    function, which takes a future as its only argument and returns a Boolean value
    indicating whether the supplied future was cancelled, as depicted here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `future-cancel` 函数停止正在执行的未来，该函数只接受一个未来作为其唯一参数，并返回一个布尔值，指示提供的未来是否被取消，如下所示：
- en: '[PRE106]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can check whether a future has been cancelled using the `future-cancelled?`
    function. Also, dereferencing a future after it has been cancelled will cause
    an exception, as shown here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `future-cancelled?` 函数来检查一个未来是否已被取消。此外，在取消一个未来之后对其进行解引用将引发异常，如下所示：
- en: '[PRE107]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now that we are familiar with the notion of representing tasks as futures,
    let''s talk about how multiple futures can be synchronized. Firstly, we can use
    *promises* to synchronize two or more futures. A promise, created using the `promise`
    function, is simply a value that can be set only once. A promise is set, or *delivered*,
    using the `deliver` form. Subsequent calls to the `deliver` form on a promise
    that has been delivered will not have any effect, and will return `nil`. When
    a promise is not delivered, dereferencing it using the `@` symbol or the `deref`
    form will block the current thread of execution. Hence, a promise can be used
    with a future in order to pause the execution of the future until a certain value
    is available. The `promise` and `deliver` forms can be quickly demonstrated as
    follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了将任务表示为未来的概念，让我们来谈谈如何同步多个未来。首先，我们可以使用 *promises* 来同步两个或多个未来。一个通过 `promise`
    函数创建的 *promise*，简单地说，是一个只能设置一次的值。使用 `deliver` 形式来设置或 *交付* 一个 *promise*。对一个已经交付的
    *promise* 再次调用 `deliver` 形式将不会有任何效果，并返回 `nil`。当一个 *promise* 没有交付时，使用 `@` 符号或 `deref`
    形式对其进行解引用将阻塞当前执行线程。因此，一个 *promise* 可以与一个未来一起使用，以便在某个值可用之前暂停未来的执行。以下是如何快速演示 `promise`
    和 `deliver` 形式的示例：
- en: '[PRE108]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As shown in the preceding output, the first call to the `deliver` form using
    the promise `p` sets the value of the promise to `100`, and the second call to
    the `deliver` form has no effect.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，使用承诺 `p` 调用 `deliver` 形式的第一次调用将承诺的值设置为 `100`，而第二次调用 `deliver` 形式没有效果。
- en: Note
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `realized?` predicate can be used to check whether a promise instance has
    been delivered.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `realized?` 断言来检查一个承诺实例是否已被交付。
- en: 'Another way to synchronize concurrent tasks is by using the `locking` form.
    The `locking` form allows only a single task to hold a lock variable, or a *monitor*,
    at any given point in time. Any value can be treated as a monitor. When a monitor
    is held, or *locked*, by a certain task, any other concurrent tasks that try to
    acquire the monitor are blocked until the monitor is available. We can thus use
    the `locking` form to synchronize two or more concurrent futures, as shown in
    *Example 2.4*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种同步并发任务的方法是使用 `locking` 形式。`locking` 形式允许在任何给定时间点只有一个任务持有锁变量，或监视器。任何值都可以被视为监视器。当某个任务持有或锁定监视器时，任何其他尝试获取监视器的并发任务都将被阻塞，直到监视器可用。因此，我们可以使用
    `locking` 形式来同步两个或多个并发未来，如 *示例 2.4* 所示：
- en: '[PRE109]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*Example 2.4: Using the locking form*'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.4：使用锁定形式*'
- en: 'The `lock-for-2-seconds` function in *Example 2.4* creates two functions, `task-1`
    and `task-2`, which both invoke futures that try to acquire a monitor, represented
    by the variable `lock`. In this example, we use a boring `java.lang.Object` instance
    as a monitor for synchronizing two futures. The future invoked by the `task-1`
    function sleeps for two seconds, whereas the future called by the `task-2` function
    sleeps for a single second. The future called by the `task-1` function is observed
    to complete first as the future invoked by the `task-2` function will not be executed
    until the `locking` form in the future obtains the monitor `lock`, as shown in
    the following output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.4* 中的 `lock-for-2-seconds` 函数创建了两个函数，`task-1` 和 `task-2`，这两个函数都调用了尝试获取一个由变量
    `lock` 表示的监视器的未来。在这个例子中，我们使用一个无聊的 `java.lang.Object` 实例作为同步两个未来的监视器。由 `task-1`
    函数调用的未来将睡眠两秒钟，而由 `task-2` 函数调用的未来将睡眠一秒钟。观察到由 `task-1` 函数调用的未来首先完成，因为由 `task-2`
    函数调用的未来将不会执行，直到未来的 `locking` 形式获得监视器 `lock`，如下面的输出所示：
- en: '[PRE110]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We can thus use the `locking` form to synchronize multiple futures. However,
    the `locking` form must be used sparingly as careless use of it could result in
    a deadlock among concurrent tasks. Concurrent tasks are generally synchronized
    to pass around a shared state. Clojure allows us to avoid using the `locking`
    form and any possible deadlocks through the use of reference types to represent
    shared state, as we will examine in the following section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `locking` 形式来同步多个未来。然而，必须谨慎使用 `locking` 形式，因为其不当使用可能导致并发任务之间的死锁。并发任务通常同步以传递共享状态。Clojure
    允许我们通过使用表示共享状态的引用类型来避免使用 `locking` 形式和任何可能的死锁，我们将在下一节中探讨这一点。
- en: Managing state
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理
- en: A program can be divided into several parts which can execute concurrently.
    It is often necessary to share data or state among these concurrently running
    tasks. Thus, we arrive at the notion of having multiple observers for some data.
    If the data gets modified, we must ensure that the changes are visible to all
    observers. For example, suppose there are two threads that read data from a common
    variable. This data gets modified by one thread, and the change must be propagated
    to the other thread as soon as possible to avoid inconsistencies.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可以被分成几个部分，这些部分可以并发执行。通常需要在这些并发运行的任务之间共享数据或状态。因此，我们得到了对某些数据有多个观察者的概念。如果数据被修改，我们必须确保更改对所有观察者都是可见的。例如，假设有两个线程从公共变量中读取数据。这个数据被一个线程修改，并且更改必须尽快传播到另一个线程，以避免不一致性。
- en: Programming languages that support mutability handle this problem by locking
    over a monitor, as we demonstrated with the `locking` form, and maintaining local
    copies of the data. In such languages, a variable is just a container for data.
    Whenever a concurrent task accesses a variable that is shared with other tasks,
    it copies the data from the variable. This is done in order to prevent unwanted
    overwriting of the variable by other tasks while a task is performing a computation
    on it. In case the variable is actually modified, a given task will still have
    its own copy of the shared data. If there are two concurrent tasks that access
    a given variable, they could simultaneously modify the variable and thus both
    of the tasks would have an inconsistent view of the data in the given variable.
    This problem is termed as a *race condition*, and must be avoided when dealing
    with concurrent tasks. For this reason, monitors are used to synchronize access
    to shared data. However, this methodology is not really *deterministic*, in the
    sense that we cannot easily reason about the actual data contained in a variable
    at a given point in time. This makes developing concurrent programs quite cumbersome
    in programming languages that use mutability.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 支持可变性的编程语言通过在监视器上锁定，正如我们通过`locking`形式所展示的，并维护数据的本地副本来处理这个问题。在这样的语言中，变量只是一个数据容器。每当并发任务访问与其他任务共享的变量时，它会从变量中复制数据。这是为了防止其他任务在任务对其执行计算时意外覆盖变量。如果变量实际上被修改，给定任务仍将拥有共享数据的副本。如果有两个并发任务访问给定的变量，它们可以同时修改该变量，因此这两个任务都会对给定变量中的数据有一个不一致的视图。这个问题被称为*竞争条件*，在处理并发任务时必须避免。因此，使用监视器来同步对共享数据的访问。然而，这种方法在本质上并不是*确定性的*，这意味着我们无法轻易地推理出在特定时间点变量中实际包含的数据。这使得在使用可变性的编程语言中开发并发程序变得相当繁琐。
- en: 'Like other functional programming languages, Clojure tackles this problem using
    *immutability*—all values are immutable by default and cannot be changed. To model
    mutable state, there is the notion of *identity*, *state*, and *time*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他函数式编程语言一样，Clojure通过使用*不可变性*来解决这个问题——所有值默认都是不可变的，不能更改。为了模拟可变状态，有*身份*、*状态*和*时间*的概念：
- en: An *identity* is anything that is associated with a changing state. At a given
    point in time, an identity has a single state.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份*是与变化状态相关联的任何事物。在特定时间点，一个身份具有单一的状态。'
- en: '*State* is the value associated with an identity at a given point in time.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态*是在特定时间点与身份相关联的值。'
- en: '*Time* defines an ordering between the states of an identity.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间*定义了身份状态之间的顺序。'
- en: Programs that actually use state can thus be divided into two layers. One layer
    is purely functional and has nothing to do with state. The other layer constitutes
    parts of the program that actually require the use of mutable state. This decomposition
    allows us to isolate the parts of a program that actually require the use of mutable
    state.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 实际使用状态的程序因此可以分为两层。一层是纯函数性的，与状态无关。另一层构成了程序中实际需要使用可变状态的部分。这种分解使我们能够隔离程序中实际需要使用可变状态的部分。
- en: 'There are several ways to define mutable state in Clojure, and the data structures
    used for this purpose are termed as *reference types*. A reference type is essentially
    a mutable reference to an immutable value. Hence, the reference has to be changed
    explicitly, and the actual value contained in a reference type cannot be modified
    in any way. Reference types can be characterized in the following ways:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中定义可变状态有几种方式，用于此目的的数据结构被称为*引用类型*。引用类型本质上是对不可变值的可变引用。因此，必须显式地更改引用，并且引用类型中包含的实际值不能以任何方式修改。引用类型可以以下列方式描述：
- en: The change of state in some reference types can either be *synchronous* or *asynchronous*.
    For example, suppose we are writing data to a file. A synchronous write operation
    would block the caller until all data is written to the file. On the other hand,
    an asynchronous write operation would start off a background task to write all
    data to the file and return to the caller immediately.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些引用类型的状态变化可以是*同步*的或*异步*的。例如，假设我们正在向文件写入数据。同步写入操作会阻塞调用者，直到所有数据都写入文件。另一方面，异步写入操作会启动一个后台任务将所有数据写入文件，并立即返回调用者。
- en: Mutation of a reference type can be performed in either a *coordinated* or an
    *independent* manner. By coordinated, we mean that state can only be modified
    within transactions that are managed by some underlying system, which is quite
    similar to the way a database works. A reference type that mutates independently,
    however, can be changed without the explicit use of a transaction.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型的修改可以以 *协调* 或 *独立* 的方式进行。通过协调，我们指的是状态只能在由某些底层系统管理的交易中修改，这与数据库工作的方式非常相似。然而，独立修改引用类型的引用类型可以不使用交易显式地更改。
- en: Changes in some state can be visible to only the thread in which the change
    occurs, or they could be visible to all threads in the current process.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些状态的变化可能只能对发生变化的线程可见，或者它们可能对所有当前进程中的线程可见。
- en: We will now explore the various reference types that can be used to represent
    mutable state in Clojure.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨在 Clojure 中可以用来表示可变状态的多种引用类型。
- en: Using vars
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变量
- en: '*Vars* are used to manage state that is changed within the scope of a thread.
    We essentially define vars that can have state, and then bind them to different
    values. The modified value of a var is only visible to the current thread of execution.
    Hence, vars are a form of the *thread-local* state.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 用于管理在线程作用域内发生变化的州。我们本质上定义了可以具有状态的变量，并将它们绑定到不同的值。变量的修改值仅对当前执行线程可见。因此，变量是一种
    *线程局部* 状态。'
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c2/vars.clj` of the book's
    source code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c2/vars.clj` 中找到。
- en: 'Dynamic vars are defined using the `def` form with the `:dynamic` meta keyword.
    If we omit the `:dynamic` metadata, it would be the same as defining an ordinary
    variable, or a static var, using a `def` form. It''s a convention that all dynamic
    var names must start and end with the asterisk character (`*`), but this is not
    mandatory. For example, let''s define a dynamic variable shown as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量使用带有 `:dynamic` 元关键字的 `def` 形式定义。如果我们省略 `:dynamic` 元数据，那么它将等同于使用 `def` 形式定义一个普通变量或静态变量。一个约定是所有动态变量名必须以星号字符
    (`*`) 开头和结尾，但这不是强制性的。例如，让我们定义一个如下所示的动态变量：
- en: '[PRE111]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `*thread-local-state*` variable defined in *Example 2.5* represents a thread-local
    var that can change dynamically. We have initialized the var `*thread-local-state*`
    with the vector `[1 2 3]`, but it's not really required. In case an initial value
    is not supplied to a `def` form, then the resulting variable is termed as an *unbound*
    var. While the state of a var is confined to the current thread, its declaration
    is global to the current namespace. In other words, a var defined with the `def`
    form will be visible to all threads invoked from the current namespace, but the
    state of the variable is local to the thread in which it is changed. Thus, vars
    using the `def` form are also termed as *global vars*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.5* 中定义的 `*thread-local-state*` 变量代表一个可以动态变化的线程局部变量。我们已将变量 `*thread-local-state*`
    初始化为向量 `[1 2 3]`，但这并不是必需的。如果未向 `def` 形式提供初始值，则生成的变量被称为 *未绑定* 变量。虽然变量的状态仅限于当前线程，但其声明对当前命名空间是全局的。换句话说，使用
    `def` 形式定义的变量将对从当前命名空间调用的所有线程可见，但变量的状态仅限于更改它的线程。因此，使用 `def` 形式的变量也被称为 *全局变量*。
- en: 'Normally, the `def` form creates a static var, which can only be redefined
    by using another `def` form. Static vars can also be redefined within a scope
    or context using the `with-redefs` and `with-redefs-fn` forms. A dynamic var,
    however, can be set to a new value after it has been defined by using the `binding`
    form, shown as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`def` 形式创建一个静态变量，只能通过使用另一个 `def` 形式来重新定义。静态变量也可以在作用域或上下文中使用 `with-redefs`
    和 `with-redefs-fn` 形式重新定义。然而，动态变量可以通过使用 `binding` 形式在定义后将其设置为新的值，如下所示：
- en: '[PRE112]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: In this example, the `binding` form changes the value contained in the `*thread-local-state*`
    var to the vector `[10 20]`. This causes the `map` form in the example to return
    a different value when called without a `binding` form surrounding it. Thus, the
    `binding` form can be used to temporarily change the state of the vars supplied
    to it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`binding` 形式将 `*thread-local-state*` 变量中包含的值更改为向量 `[10 20]`。这导致在未使用 `binding`
    形式包围的情况下调用示例中的 `map` 形式时返回不同的值。因此，`binding` 形式可以用来临时更改提供给它的变量的状态。
- en: 'The Clojure namespace system will resolve free symbols, or rather variable
    names, to their values. This process of resolving a variable name to a namespace
    qualified symbol is termed as *interning*. Also, a `def` form will first look
    for an existing global var depending on the symbol it is passed, and will create
    one if it hasn''t been defined yet. The `var` form can be used to obtain the fully
    qualified name of a variable, instead of its current value, as shown here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 的命名空间系统会将自由符号，或者说变量名解析为其值。将变量名解析为命名空间限定符号的过程称为 *内联*。此外，`def` 形式将首先根据传递给它的符号查找现有的全局变量，如果尚未定义，则创建一个。`var`
    形式可以用来获取变量的完全限定名，而不是其当前值，如下所示：
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `#'` symbol is the same as using the `var` form. For example, `#'x`
    is equivalent to `(var x)`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#'` 符号与使用 `var` 形式相同。例如，`#'x` 等同于 `(var x)`。
- en: 'The `with-bindings` form is another way to rebind vars. This form accepts a
    map of var and value pairs as its first argument, followed by the body of the
    form, shown as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-bindings` 形式是重新绑定变量的另一种方式。此形式接受一个包含变量和值对的映射作为其第一个参数，然后是表单的主体，如下所示：'
- en: '[PRE114]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can check if a var is bound to any value in the current thread of execution
    using the `thread-bound?` predicate, which requires a var to be passed as its
    only argument:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `thread-bound?` 断言来检查变量是否绑定到当前执行线程中的任何值，这需要一个变量作为其唯一参数：
- en: '[PRE115]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We can also define vars that are not interned, or *local vars*, using the `with-local-vars`
    form. These vars will not be resolved by the namespace system, and have to be
    accessed manually using the `var-get` and `var-set` functions. These functions
    can thus be used to create and access mutable variables, as shown in *Example
    2.5*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `with-local-vars` 形式定义非内联变量，或称为 *局部变量*。这些变量不会通过命名空间系统解析，必须使用 `var-get`
    和 `var-set` 函数手动访问。因此，这些函数可以用来创建和访问可变变量，如 *示例 2.5* 所示。
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the at-the-rate symbol (`@`) with a non-interned var is the same as using
    the `var-get` function. For example, if `x` is a non-interned var, `@x` is equivalent
    to `(var-get x)`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非内联变量与 `@` 符号相同，与使用 `var-get` 函数相同。例如，如果 `x` 是一个非内联变量，则 `@x` 等同于 `(var-get
    x)`。
- en: '[PRE116]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '*Example 2.5: Mutable variables using the with-local-vars form*'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.5：使用 with-local-vars 形式创建的可变变量*'
- en: The `factorial` function defined in *Example 2.5* calculated the factorial of
    `n` using two mutable local vars `i` and `acc`, which are initialized with the
    values `n` and `1` respectively. Note that the code in this function exhibits
    an imperative style of programming, in which the state of the variables `i` and
    `acc` is manipulated using the `var-get` and `var-set` functions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.5* 中定义的 `factorial` 函数使用两个可变局部变量 `i` 和 `acc` 来计算 `n` 的阶乘，分别初始化为 `n`
    和 `1`。请注意，此函数中的代码展示了命令式编程风格，其中使用 `var-get` 和 `var-set` 函数操纵变量 `i` 和 `acc` 的状态。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can check whether a value has been created through a `with-local-vars` form
    using the `var?` predicate.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `var?` 断言检查是否通过 `with-local-vars` 形式创建了值。
- en: Using refs
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用引用
- en: A **Software Transactional Memory** (**STM**) system can also be used to model
    mutable state. STM essentially treats mutable state as a tiny database that resides
    in a program's memory. Clojure provides an STM implementation through *refs*,
    and they can only be changed within a transaction. Refs are a reference type that
    represent *synchronous* and *coordinated* state.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件事务内存** (**STM**) 系统也可以用来模拟可变状态。STM 实质上将可变状态视为一个位于程序内存中的小型数据库。Clojure 通过
    *refs* 提供了 STM 实现，并且它们只能在事务中更改。Refs 是一种表示 *同步* 和 *协调* 状态的引用类型。'
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c2/refs.clj` of the book's
    source code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c2/refs.clj` 文件中找到。
- en: 'We can create a ref by using the `ref` function, which requires a single argument
    to indicate the initial state of the ref. For example, we can create a ref as
    follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ref` 函数创建一个引用，该函数需要一个参数来指示引用的初始状态。例如，我们可以创建一个引用如下：
- en: '[PRE117]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The variable `state` defined here represents a ref with the initial value of
    `0`. We can dereference `state` using `@` or `deref` to obtain the value contained
    in it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的变量 `state` 代表一个初始值为 `0` 的引用。我们可以使用 `@` 或 `deref` 来解引用 `state`，以获取其中包含的值。
- en: 'In order to modify a ref, we must start a transaction by using the `dosync`
    form. If two concurrent tasks invoke transactions using the `dosync` form simultaneously,
    then the transaction that completes first will update the ref successfully. The
    transaction which completes later will be retried until it completes successfully.
    Thus, I/O and other side-effects must be avoided within a `dosync` form, as it
    can be retried. Within a transaction, we can modify the value of a ref using the
    `ref-set` function. This function takes two arguments—a ref and the value that
    represents the new state of the ref. The `ref-set` function can be used to modify
    a ref as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改一个引用（ref），我们必须通过使用`dosync`形式启动一个事务。如果两个并发任务同时使用`dosync`形式调用事务，那么首先完成的事务将成功更新引用。较晚完成的事务将重试，直到成功完成。因此，在`dosync`形式内必须避免I/O和其他副作用，因为它可以被重试。在事务中，我们可以使用`ref-set`函数来修改引用的值。此函数接受两个参数——一个引用和表示引用新状态的值。`ref-set`函数可以用来修改引用，如下所示：
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Initially, the expression `@state` returns `0`, which is the initial state of
    the ref `state`. The value returned by this expression changes after the call
    to `ref-set` within the `dosync` form.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，表达式`@state`返回`0`，这是引用`state`的初始状态。在`dosync`形式内的`ref-set`调用之后，此表达式的返回值将发生变化。
- en: We can obtain the latest value contained in a ref by using the `ensure` function.
    This function returns the latest value of a ref, and has to be called within a
    transaction. For example, the expression `(ensure state)`, when called within
    a transaction initiated by a `dosync` form, will return the latest value of the
    ref `state` in the transaction.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ensure`函数来获取引用中包含的最新值。此函数返回引用的最新值，必须在事务中调用。例如，当在由`dosync`形式启动的事务中调用表达式`(ensure
    state)`时，将返回事务中引用`state`的最新值。
- en: 'A more idiomatic way to modify a given ref is by using the `alter` and `commute`
    functions. Both these functions require a ref and a function to be passed to it
    as arguments. The `alter` and `commute` functions will apply the supplied function
    to the value contained in a given ref, and save the resulting value into the ref.
    We can also specify additional arguments to pass to the supplied function. For
    example, we can modify the state of the ref `state` using `alter` and `commute`
    as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 修改给定引用的一个更自然的做法是使用`alter`和`commute`函数。这两个函数都需要一个引用和一个作为参数传递给它的函数。`alter`和`commute`函数将应用提供的函数到给定引用中包含的值，并将结果值保存到引用中。我们还可以指定传递给提供的函数的额外参数。例如，我们可以使用`alter`和`commute`修改`state`引用的状态，如下所示：
- en: '[PRE119]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The preceding transactions with the `alter` and `commute` forms will save the
    value `(+ @state 2)` into the ref `state`. The main difference between `alter`
    and `commute` is that a `commute` form must be preferred when the supplied function
    is *commutative*. This means two successive calls of the function supplied to
    a `commute` form must produce the same result regardless of the ordering among
    the two calls. Using the `commute` form is considered an optimization over the
    `alter` form in which we are not concerned with the ordering among concurrent
    transactions on a given ref.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`alter`和`commute`形式的前一个事务将值`(+ @state 2)`保存到引用`state`中。`alter`和`commute`之间的主要区别在于，当提供的函数是**交换律**时，必须优先选择`commute`形式。这意味着对`commute`形式提供的函数的连续两次调用必须产生相同的结果，无论这两次调用的顺序如何。使用`commute`形式被认为是相对于我们不在意给定引用上并发事务顺序的`alter`形式的优化。
- en: Note
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ref-set`, `alter`, and `commute` functions all return the new value contained
    in the supplied ref. Also, these functions will throw an error if they are not
    called within a `dosync` form.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref-set`、`alter`和`commute`函数都返回提供的引用中包含的新值。此外，如果它们不在`dosync`形式内调用，这些函数将抛出错误。'
- en: 'A mutation performed by the `alter` and `commute` forms can also be validated.
    This is achieved using the `:validator` key option when creating a ref, as shown
    here:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`alter`和`commute`形式执行的变异也可以进行验证。这是通过在创建引用时使用`:validator`键选项来实现的，如下所示：'
- en: '[PRE120]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As shown previously, the ref `r` throws an exception when we try to change its
    state to a negative value. This is because the `pos?` function is used to validate
    the new state of the ref. Note that the `:validator` key option can be used with
    other reference types as well. We can also set the validation function of a ref
    that was created without a `:validator` key option using the `set-validator!`
    function.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当我们尝试将引用`r`的状态更改为负值时，它会抛出异常。这是因为使用了`pos?`函数来验证引用的新状态。请注意，`:validator`键选项也可以用于其他引用类型。我们还可以使用`set-validator!`函数设置未使用`:validator`键选项创建的引用的验证函数。
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `:validator` key option and the `set-validator!` function can be used with
    *all* reference types. The supplied validation function must return `false` or
    throw an exception to indicate a validation error.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`:validator`键选项和`set-validator!`函数可以与所有引用类型一起使用。提供的验证函数必须返回`false`或抛出异常以指示验证错误。'
- en: 'The *dining philosophers problem* depicts the use of synchronization primitives
    to share resources. The problem can be defined as follows: five philosophers are
    seated on a round table to eat spaghetti, and each philosopher requires two forks
    to eat from his plate of spaghetti. There are five forks on the table, placed
    in between the five philosophers. A philosopher will first have to pick up a fork
    from his left side as well as one from his right side before he can eat. When
    a philosopher cannot obtain the two forks to his left and right side, he must
    wait until both the forks are available. After a philosopher is done eating his
    spaghetti, he will think for some time, thereby allowing the other philosophers
    to use the forks that he used. The solution to this problem requires that all
    philosophers share the forks among them, and none of the philosophers starve due
    to being unable to get two forks. The five philosophers'' plates and forks are
    placed on the table as illustrated in the following diagram:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*用餐哲学家问题*描述了使用同步原语来共享资源的使用。这个问题可以这样定义：五位哲学家围坐在一张圆桌旁吃意大利面，每位哲学家需要两根叉子才能从他的盘子里吃面。桌上有五根叉子，放在五位哲学家之间。哲学家必须首先从他的左边和右边各拿起一根叉子，然后才能开始吃饭。当一个哲学家无法获得他左右两侧的两个叉子时，他必须等待直到两个叉子都可用。当一个哲学家吃完他的意大利面后，他会思考一段时间，从而允许其他哲学家使用他使用的叉子。这个问题的解决方案要求所有哲学家共享叉子，并且没有哲学家因为无法获得两个叉子而饿死。五位哲学家的盘子和叉子按照以下图示放置在桌子上：'
- en: '![Using refs](img/B05024_02_01.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![使用引用](img/B05024_02_01.jpg)'
- en: A philosopher must obtain exclusive access to the forks on his left and right
    side before he starts eating. If both the forks are unavailable, the philosopher
    must wait for some time for either one of the forks to be free, and retry obtaining
    the forks. This way, each philosopher can access the forks in tandem with the
    other philosophers and avoid starvation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学家在开始吃饭之前必须获得他左右两侧叉子的独家访问权。如果两个叉子都不可用，哲学家必须等待一段时间，直到其中一个叉子变得空闲，然后重试获取叉子。这样，每个哲学家都可以与其他哲学家协同访问叉子，避免饿死。
- en: 'Generally, this solution can be implemented by using synchronization primitives
    to access the available forks. Refs allow us to implement a solution to the dining
    philosophers problem without the use of any synchronization primitives. We will
    now demonstrate how we can implement and simulate a solution to this problem in
    Clojure. Firstly, we will have to define the states of a fork and a philosopher
    as refs, as shown in *Example 2.6*:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个解决方案可以通过使用同步原语来访问可用的叉子来实现。引用允许我们实现一个无需任何同步原语的用餐哲学家问题的解决方案。现在，我们将展示如何在Clojure中实现并模拟这个问题的解决方案。首先，我们必须定义叉子和哲学家的状态为引用，如*示例
    2.6*所示：
- en: '[PRE121]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '*Example 2.6: The dining philosophers problem using refs*'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.6：使用引用的用餐哲学家问题*'
- en: 'The `make-fork` and `make-philosopher` functions create refs to represent the
    states of a fork and a philosopher, respectively. A fork is simply the state of
    a Boolean value, indicating whether it is available or not. And a philosopher,
    created by the `make-philosopher` function, is a map encapsulated as a state,
    which has the following keys:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-fork`和`make-philosopher`函数创建引用来表示叉子和哲学家的状态。一个叉子简单地表示一个布尔值的状态，指示它是否可用。而由`make-philosopher`函数创建的哲学家是一个封装为状态的映射，它具有以下键：'
- en: The `:name` key contains the name of a philosopher that is a string value.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:name`键包含一个哲学家的名字，它是一个字符串值。'
- en: The `:forks` key points to the forks on the left and the right side of a philosopher.
    Each fork will be a ref created by the `make-fork` function.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:forks` 键指向哲学家左右两侧的叉子。每个叉子都将由 `make-fork` 函数创建的引用（ref）表示。'
- en: The `:eating?` key indicates whether a philosopher is eating at the moment.
    It is a Boolean value.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:eating?` 键表示哲学家是否正在进食。它是一个布尔值。'
- en: The `:food` key represents the amount of food available to a philosopher. For
    simplicity, we will treat this value as an integer.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:food` 键表示哲学家可用的食物数量。为了简单起见，我们将此值视为一个整数。'
- en: 'Now, let''s define some primitive operations to help in handling forks, as
    shown in *Example 2.7*:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些原始操作来帮助处理叉子，如 *示例 2.7* 所示：
- en: '[PRE122]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '*Example 2.7: The dining philosophers problem using refs (continued)*'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.7: 使用引用解决就餐哲学家问题（继续）*'
- en: 'The `has-forks?` function defined previously checks whether both the forks
    that are placed to the left and right of a given philosopher ref `p` are available.
    The `update-forks` function will modify the state of both the associated forks
    of a philosopher ref `p` using a `commute` form, and returns the ref `p`. Obviously,
    these functions can only be called within a transaction created by the `dosync`
    form, since they use the `ensure` and `commute` functions. Next, we will have
    to define some functions to initiate transactions and invoke the `has-forks?`
    and `update-forks` functions for a given philosopher, as shown in *Example 2.8*:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `has-forks?` 函数检查放置在给定哲学家引用 `p` 左右两侧的叉子是否可用。`update-forks` 函数将使用 `commute`
    形式修改哲学家引用 `p` 相关的叉子的状态，并返回引用 `p`。显然，这些函数只能在由 `dosync` 形式创建的事务中调用，因为它们使用了 `ensure`
    和 `commute` 函数。接下来，我们将不得不定义一些函数来启动事务，并为给定的哲学家调用 `has-forks?` 和 `update-forks`
    函数，如 *示例 2.8* 所示：
- en: '[PRE123]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '*Example 2.8: The dining philosophers problem using refs (continued)*'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.8: 使用引用解决就餐哲学家问题（继续）*'
- en: The heart of the solution to the dining philosophers problem is the `start-eating`
    function in *Example 2.8*. This function will check whether both the forks on
    either side of a philosopher are available, using the `has-forks?` function. The
    `start-eating` function will then proceed to update the states of these forks
    by calling the `update-forks` function. The `start-eating` function will also
    change the state of the philosopher ref `p` by invoking `commute` with the `assoc`
    and `update-in` functions, which both return a new map. Since the `start-eating`
    function uses a `when` form, it will return `nil` when any of the philosophers'
    forks are unavailable. These few steps are the solution; in a nutshell, a philosopher
    will eat only when both his forks are available.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 解决就餐哲学家问题的核心是 *示例 2.8* 中的 `start-eating` 函数。此函数将使用 `has-forks?` 函数检查哲学家两侧的叉子是否可用。然后，`start-eating`
    函数将调用 `update-forks` 函数来更新这些叉子的状态。`start-eating` 函数还将通过调用 `assoc` 和 `update-in`
    函数（这两个函数都返回一个新的映射）来改变哲学家引用 `p` 的状态，从而使用 `commute`。由于 `start-eating` 函数使用了 `when`
    形式，当任何哲学家的叉子不可用时，它将返回 `nil`。这些步骤就是解决方案；简而言之，哲学家只有在他的两个叉子都可用时才会进食。
- en: The `stop-eating` function in *Example 2.8* reverses the state of a given philosopher
    ref after the `start-eating` function has been invoked on it. This function basically
    sets the `:eating` key of the map contained in the supplied philosopher ref `p`
    to `false` using a `commute` form, and then calls `update-forks` to reset the
    state of the associated forks of the philosopher ref `p`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.8* 中的 `stop-eating` 函数在 `start-eating` 函数被调用后反转给定哲学家引用的状态。此函数基本上使用 `commute`
    形式将提供的哲学家引用 `p` 中包含的映射的 `:eating` 键设置为 `false`，然后调用 `update-forks` 来重置哲学家引用 `p`
    相关的叉子的状态。'
- en: The `start-eating` and `stop-eating` function can be called repeatedly in a
    loop using a `while` form, as long as the `:food` key of a philosopher ref `p`,
    or rather the amount of available food, is a positive value. This is performed
    by the `dine` function in *Example 2.8*. This function will call the `start-eating`
    function on a philosopher ref `p`, and will wait for some time if the philosopher's
    forks are being used by any other philosophers. The amount of time that a philosopher
    waits for is indicated by the `retry-ms` argument that is passed to the dine function.
    If a philosopher's forks are available, he eats for a random amount of time, as
    indicated by the expression `(rand-int max-eat-ms)`. Then, the `stop-eating` function
    is called to reset the state of the philosopher ref `p` and the forks that it
    contains. Finally, the `dine` function waits for a random amount of time, which
    is represented by the `(rand-int max-think-ms)` expression, to indicate that a
    philosopher is thinking.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`start-eating` 和 `stop-eating` 函数可以通过 `while` 形式在循环中重复调用，只要哲学家的引用 `p` 的 `:food`
    键（或者说是可用的食物量）是一个正数。这是通过 *示例 2.8* 中的 `dine` 函数来执行的。该函数将在哲学家引用 `p` 上调用 `start-eating`
    函数，如果哲学家的叉子被其他哲学家使用，则等待一段时间。哲学家等待的时间由传递给 `dine` 函数的 `retry-ms` 参数指示。如果哲学家的叉子可用，他将吃一个随机的时间，如表达式
    `(rand-int max-eat-ms)` 所示。然后，调用 `stop-eating` 函数来重置哲学家引用 `p` 和它包含的叉子的状态。最后，`dine`
    函数等待一个随机的时间，这由 `(rand-int max-think-ms)` 表达式表示，以表示哲学家正在思考。'
- en: 'Let''s now define some function and actually create some refs representing
    philosophers and associated forks, as shown in *Example 2.9*:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些函数，并实际创建一些代表哲学家和相关叉子的引用，如 *示例 2.9* 所示：
- en: '[PRE124]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '*Example 2.9: The dining philosophers problem using refs (continued)*'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.9：使用引用的用餐哲学家问题（继续）*'
- en: The `init-forks` function from *Example 2.9* will simply invoke the `make-fork`
    function a number of times, as indicated by its argument `nf`. The `init-philosophers`
    function will create `np` number of philosophers and associate each of them with
    a vector of two forks and a certain amount of food. This is done by mapping the
    function `init-fn`, which is a function that matches the arity of the `make-philosopher`
    function in *Example 2.6*, over a range of philosopher names `p-names` and forks
    `p-forks`, and an infinite range `p-food` of the value `food`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.9* 中的 `init-forks` 函数将简单地根据其参数 `nf` 调用 `make-fork` 函数多次。`init-philosophers`
    函数将创建 `np` 个哲学家，并将每个哲学家与一个包含两个叉子和一定量食物的向量相关联。这是通过将函数 `init-fn`（该函数与 *示例 2.6* 中的
    `make-philosopher` 函数的阶数相匹配）映射到哲学家名称 `p-names` 和叉子 `p-forks` 的范围以及值 `food` 的无限范围
    `p-food` 来实现的。'
- en: 'We will now define a function to print the collective state of a sequence of
    philosophers. This can be done in a fairly simple manner using the `doseq` function,
    as shown in *Example 2.10*:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个函数来打印一系列哲学家的集体状态。这可以通过使用 `doseq` 函数以相当简单的方式进行，如 *示例 2.10* 所示：
- en: '[PRE125]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '*Example 2.10: The dining philosophers problem using refs (continued)*'
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.10：使用引用的用餐哲学家问题（继续）*'
- en: The `check-philosophers` function in *Example 2.10* iterates through all of
    its supplied philosopher refs, represented by `philosophers`, and associated forks,
    represented by `forks`, and prints their state. The `if-let` form is used here
    to check if a dereferenced ref from the collection `philosophers` is not `nil`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.10* 中的 `check-philosophers` 函数遍历其提供的所有哲学家引用，由 `philosophers` 表示，以及相关的叉子，由
    `forks` 表示，并打印它们的状态。这里使用 `if-let` 形式来检查集合 `philosophers` 中的解引用引用是否不是 `nil`。'
- en: 'Now, let''s define a function to concurrently invoke the `dine` function over
    a collection of philosopher. This function could also pass in values for the `retry-ms`,
    `max-eat-ms`, and `max-think-ms` arguments of the `dine` function. This is implemented
    in the `dine-philosophers` function in *Example 2.11*:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个函数来并发调用哲学家集合上的 `dine` 函数。这个函数也可以传递 `dine` 函数的 `retry-ms`、`max-eat-ms`
    和 `max-think-ms` 参数值。这在 *示例 2.11* 中的 `dine-philosophers` 函数中实现：
- en: '[PRE126]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '*Example 2.11: The dining philosophers problem using refs (continued)*'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.11：使用引用的用餐哲学家问题（继续）*'
- en: 'Finally, let''s define five instances of philosophers and five associated forks
    for our simulation, using the `init-forks`, `init-philosophers`, and `make-philosopher`
    functions, as shown in *Example 2.12* as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `init-forks`、`init-philosophers` 和 `make-philosopher` 函数定义五个哲学家的实例和五个相关的叉子，如
    *示例 2.12* 所示如下：
- en: '[PRE127]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '*Example 2.12: The dining philosophers problem using refs (continued)*'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.12：使用 refs 解决就餐哲学家问题（续）*'
- en: 'We can now use the `check-philosopher` function to print the state of the philosopher
    and fork refs created in *Example 2.12*, as shown here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `check-philosopher` 函数来打印在 *示例 2.12* 中创建的哲学家状态和叉子引用，如下所示：
- en: '[PRE128]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Initially, all of the forks are available and none of the philosophers are
    eating. To start the simulation, we must call the `dine-philosophers` function
    on the philosopher refs `all-philosophers` and the fork refs `all-forks`, as shown
    here:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，所有叉子都是可用的，没有哲学家在吃饭。为了开始模拟，我们必须在 `all-philosophers` 哲学家引用和 `all-forks` 叉子引用上调用
    `dine-philosophers` 函数，如下所示：
- en: '[PRE129]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'After invoking the `dine-philosophers` function, each philosopher is observed
    to consume the allocated food, as shown in the output of the previous `check-philosophers`
    function. At any given point of time, one or two philosophers are observed to
    be eating, and the other philosophers will wait until they complete using the
    available forks. Subsequent calls to the `check-philosophers` function also indicate
    the same output, and the philosophers will eventually consume all of the allocated
    food:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `dine-philosophers` 函数后，每个哲学家都会观察到他们消费分配的食物，如前一个 `check-philosophers` 函数的输出所示。在任何给定的时间点，都会观察到一位或两位哲学家在吃饭，其他哲学家将等待他们完成使用可用的叉子。随后的
    `check-philosophers` 函数调用也指示相同的输出，哲学家最终会消费所有分配的食物：
- en: '[PRE130]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We can pause the simulation by calling the `future-cancel` function, as shown
    here. Once the simulation is paused, it can be resumed by calling the `dine-philosophers`
    function again, as `(dine-philosophers all-philosophers)`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `future-cancel` 函数来暂停模拟，如下所示。一旦模拟被暂停，可以通过再次调用 `dine-philosophers` 函数来恢复，如
    `(dine-philosophers all-philosophers)`：
- en: '[PRE131]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: To summarize, the preceding example is a concise and working implementation
    of a solution to the dining philosophers problem using Clojure futures and refs.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，前面的示例是使用 Clojure 的 futures 和 refs 解决就餐哲学家问题的简洁且可行的实现。
- en: Using atoms
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原子
- en: '*Atoms* are used to handle state that changes atomically. Once an atom is modified,
    its new value is reflected in all concurrent threads. In this way, atoms represent
    *synchronous* and *independent* state. Let''s quickly explore the functions that
    can be used to handle atoms.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子* 用于处理原子性变化的州。一旦原子被修改，其新值将在所有并发线程中反映出来。这样，原子代表 *同步* 和 *独立* 的状态。让我们快速探索可以用来处理原子的函数。'
- en: Note
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c2/atoms.clj` of the book's
    source code.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c2/atoms.clj` 中找到。
- en: 'We can define an atom using the `atom` function, which requires the initial
    state of the atom to be passed to it as the first argument, as shown here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `atom` 函数定义一个原子，该函数需要将原子的初始状态作为第一个参数传递给它，如下所示：
- en: '[PRE132]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `reset!` and `swap!` functions can be used to modify the state of an atom.
    The `reset!` function is used to directly set the state of an atom. This function
    takes two arguments—an atom and the value that represents the new state of the
    atom, as shown here:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset!` 和 `swap!` 函数可以用来修改原子的状态。`reset!` 函数用于直接设置原子的状态。此函数接受两个参数——一个原子和表示原子新状态的值，如下所示：'
- en: '[PRE133]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `swap!` function requires a function and additional arguments to pass to
    the supplied function as arguments. The supplied function is applied to the value
    contained in the atom along with the other additional arguments specified to the
    `swap!` function. This function can thus be used to mutate an atom using a supplied
    function, as shown here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap!` 函数需要一个函数以及传递给该函数的额外参数。提供的函数将应用于原子中包含的值，以及传递给 `swap!` 函数的其他额外参数。因此，可以使用提供的函数来使用原子进行变异，如下所示：'
- en: '[PRE134]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The call to the preceding `swap!` function sets the state of the atom to the
    result of the expression `(+ @state 2)`. The `swap!` function may call the function
    `+` multiple times due to concurrent calls to the `swap!` function on the atom
    `state`. Hence, functions that are passed to the `swap!` function must be free
    of I/O and other side effects.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `swap!` 函数调用将原子的状态设置为表达式 `(+ @state 2)` 的结果。由于对原子 `state` 的 `swap!` 函数的并发调用，`swap!`
    函数可能会多次调用函数 `+`。因此，传递给 `swap!` 函数的函数必须是无 I/O 和其他副作用。
- en: Note
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `reset!` and `swap!` functions both return the new value contained in the
    supplied atom.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset!` 和 `swap!` 函数都返回所提供原子中包含的新值。'
- en: 'We can watch for any change in an atom, and other reference types as well,
    using the `add-watch` function. This function will call a given function whenever
    the state of an atom is changed. The `add-watch` function takes three arguments—a
    reference, a key and a *watch function*, that is, a function that must be called
    whenever the state of the supplied reference type is changed. The function that
    is supplied to the `add-watch` function must accept four arguments—a key, the
    reference that was changed, the old value of the reference, and the new value
    of the reference. The value of the key argument that is passed to the `add-watch`
    function gets passed to the `watch` function as its first argument. A `watch`
    function can also be unlinked from a given reference type using the `remove-watch`
    function. The `remove-watch` function accepts two arguments—a reference and a
    key that was specified while adding a `watch` function to the reference. *Example
    2.13* depicts how we can track the state of an atom using a `watch` function:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add-watch` 函数监视原子以及其他引用类型的任何变化。此函数会在原子状态改变时调用给定的函数。`add-watch` 函数接受三个参数——一个引用、一个键和一个
    *监视函数*，即每当提供的引用类型的状态改变时必须调用的函数。传递给 `add-watch` 函数的函数必须接受四个参数——一个键、被更改的引用、引用的旧值和引用的新值。传递给
    `add-watch` 函数的键的值作为第一个参数传递给 `watch` 函数。`watch` 函数还可以使用 `remove-watch` 函数从给定的引用类型中解除链接。`remove-watch`
    函数接受两个参数——一个引用和一个在向引用添加 `watch` 函数时指定的键。*示例 2.13* 展示了我们可以如何使用 `watch` 函数跟踪原子的状态：
- en: '[PRE135]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '*Example 2.13: Using the add-watch function*'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.13：使用 add-watch 函数*'
- en: 'The `make-state-with-watch` function defined in *Example 2.13* returns a vector
    of two atoms. The second atom in this vector initially contains the value `false`.
    Whenever the state of the first atom in the vector returned by the `make-state-with-watch`
    function is changed, the state of the second atom in this vector is changed to
    the value `true`. This can be verified in the REPL, as shown here:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 2.13* 中定义的 `make-state-with-watch` 函数返回一个包含两个原子的向量。在这个向量中，第二个原子最初包含的值是
    `false`。每当 `make-state-with-watch` 函数返回的向量中第一个原子的状态发生变化时，这个向量中第二个原子的状态就会变为 `true`。这可以在
    REPL 中验证，如下所示：
- en: '[PRE136]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Thus, watch functions can be used with the `add-watch` function to track the
    state of atoms and other reference types.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用 `add-watch` 函数与 watch 函数一起使用，以跟踪原子和其他引用类型的状态。
- en: Note
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `add-watch` function can be used with *all* reference types.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-watch` 函数可以与 *所有* 引用类型一起使用。'
- en: Using agents
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代理
- en: An *agent* is used to represent state that is associated with a queue of actions
    and a pool of worker threads. Any action that modifies the state of an agent must
    be sent to its queue, and the supplied function will be called by a thread selected
    from the agent's pool of worker threads. We can send actions asynchronously to
    agents as well. Thus, agents represent *asynchronous* and *independent* state.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*代理* 用于表示与动作队列和工作者线程池相关联的状态。任何修改代理状态的动作都必须发送到其队列中，并且提供的函数将由从代理的工作者线程池中选择的线程调用。我们也可以异步地向代理发送动作。因此，代理表示
    *异步* 和 *独立* 的状态。'
- en: Note
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c2/agents.clj` of the book's
    source code.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c2/agents.clj` 中找到。
- en: 'An agent is created using the `agent` function. For example, we can create
    an agent with an empty map as its initial value as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `agent` 函数创建代理。例如，我们可以创建一个代理，其初始值为空映射，如下所示：
- en: '[PRE137]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We can modify the state of an agent by using the `send` and `send-off` functions.
    The `send` and `send-off` functions will send a supplied action and its additional
    arguments to an agent's queue in an asynchronous manner. Both these functions
    return the agent they are passed immediately.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `send` 和 `send-off` 函数来修改代理的状态。`send` 和 `send-off` 函数将以异步方式将提供的动作及其附加参数发送到代理的队列中。这两个函数都会立即返回传递给它们的代理。
- en: The primary difference between the `send` and `send-off` functions is that the
    `send` function assigns actions to a thread selection from a pool of worker threads,
    whereas the `send-off` function creates a new dedicated thread to execute each
    action. Blocking actions that are sent to an agent using the `send` function could
    exhaust the agent's pool of threads. Thus, the `send-off` function is preferred
    for sending blocking actions to an agent.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 和 `send-off` 函数之间的主要区别在于，`send` 函数将动作分配给从工作线程池中选择的一个线程，而 `send-off`
    函数为每个动作创建一个新的专用线程来执行。使用 `send` 函数发送到代理的阻塞动作可能会耗尽代理的线程池。因此，对于发送阻塞动作到代理，`send-off`
    函数是首选。'
- en: 'To demonstrate the `send` and `send-off` functions, let''s first define a function
    that returns a closure that sleeps for a certain amount of time, and then, call
    the `assoc` function, as shown in *Example 2.14*:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `send` 和 `send-off` 函数，我们首先定义一个返回闭包的函数，该闭包会休眠一定的时间，然后调用 `assoc` 函数，如下所示
    *示例 2.14*：
- en: '[PRE138]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '*Example 2.14: A function that returns a closure which sleeps and calls assoc*'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.14：一个返回闭包的函数，该闭包会休眠并调用 assoc*'
- en: 'A closure returned by the `set-value-in-ms` function, in *Example 2.14*, can
    be passed as an action to the `send` and `send-off` functions, as shown here:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.14* 中 `set-value-in-ms` 函数返回的闭包可以作为动作传递给 `send` 和 `send-off` 函数，如下所示：'
- en: '[PRE139]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The calls to the preceding `send` and `send-off` functions will call the closures
    returned by the `set-value-in-ms` function, from *Example 2.14*, asynchronously
    over the agent `state`. The agent's state changes over a period of 10 seconds,
    which is required to execute the closures returned by the `set-value-in-ms` function.
    The new key-value pair `{:value 5}` is observed to be saved into the agent `state`
    after five seconds, and the state of the agent again changes to `{:value 10}`
    after another five seconds.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面的 `send` 和 `send-off` 函数的调用将异步地通过代理 `state` 调用 `set-value-in-ms` 函数（*示例 2.14*）返回的闭包。代理的状态在
    10 秒内发生变化，这是执行 `set-value-in-ms` 函数返回的闭包所必需的。观察到新的键值对 `{:value 5}` 在五秒后被保存到代理
    `state` 中，然后在另一个五秒后，代理的状态再次变为 `{:value 10}`。
- en: Any action that is passed to the `send` and `send-off` functions can use the
    `*agent*` var to access the agent through which the action will be executed.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `send` 和 `send-off` 函数的任何动作都可以使用 `*agent*` 变量通过执行动作的代理来访问。
- en: 'The `await` function can be used to wait for all actions in an agent''s queue
    to be completed, as shown here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `await` 函数等待代理队列中的所有动作完成，如下所示：
- en: '[PRE140]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The expression `(await state)` is observed to be blocked until the previous
    action that was sent to the agent `state` using the `send-off` function is completed.
    The `await-for` function is a variant of `await`, which waits for a certain number
    of milliseconds, indicated by its first argument, for all the actions on an agent,
    its second argument, to complete.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到表达式 `(await state)` 会在使用 `send-off` 函数将动作发送到代理 `state` 的上一个动作完成之前被阻塞。`await-for`
    函数是 `await` 的一个变体，它等待由其第一个参数指定的一定数量的毫秒数，以便完成代理（其第二个参数）上的所有动作。
- en: 'An agent also saves any error it encounters while performing the actions in
    its queue. An agent will throw the error it has encountered on any subsequent
    calls to the `send` and `send-off` functions. The error saved by an agent can
    be accessed using the `agent-error` function, and can be cleared using the `clear-agent-errors`
    function, as shown here:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 代理还会保存它在执行队列中的动作时遇到的任何错误。代理会在对 `send` 和 `send-off` 函数的任何后续调用中抛出它遇到的错误。代理保存的错误可以通过
    `agent-error` 函数访问，并且可以使用 `clear-agent-errors` 函数清除，如下所示：
- en: '[PRE141]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: An agent that has encountered an error can also be restarted using the `restart-agent`
    function. This function takes an agent as its first argument and the new state
    of the agent as its second argument. All actions that were sent to an agent while
    it was failed will be executed once the `restart-agent` is called on the agent.
    We can avoid this behavior by passing the `:clear-actions true` optional argument
    to the `restart-agent` function. In this case, any actions held in an agent's
    queue are discarded before it is restarted.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到错误的代理也可以使用 `restart-agent` 函数重新启动。此函数将其第一个参数作为代理，第二个参数作为代理的新状态。一旦在代理上调用 `restart-agent`，之前发送到代理的所有动作都将执行。我们可以通过将
    `:clear-actions true` 可选参数传递给 `restart-agent` 函数来避免这种行为。在这种情况下，在重新启动之前，代理队列中持有的任何动作都将被丢弃。
- en: 'To create a pool of threads, or a *threadpool*, to use with an agent, we must
    call the static `newFixedThreadPool` method of the `java.util.concurrent.Executors`
    class by passing the desired number of threads in the pool as an argument, as
    follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用于代理的线程池或*threadpool*，我们必须通过传递池中期望的线程数作为参数来调用`java.util.concurrent.Executors`类的静态`newFixedThreadPool`方法，如下所示：
- en: '[PRE142]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The pool of threads defined previously can be used to execute the actions of
    an agent by using the `send-via` function. This function is a variant of the `send`
    function that accepts a pool of threads, such as the `pool` defined previously,
    as its first argument, as shown here:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用之前定义的线程池通过`send-via`函数来执行代理的动作。这个函数是`send`函数的一个变体，它接受一个线程池作为其第一个参数，如以下所示：
- en: '[PRE143]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can also specify the thread pools to be used by all agents to execute actions
    sent to them using the `send` and `send-off` functions using the `set-agent-send-executor!`
    and `set-agent-send-off-executor!` functions respectively. Both of these functions
    accept a single argument representing a pool of threads.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`set-agent-send-executor!`和`set-agent-send-off-executor!`函数分别指定所有代理执行发送给它们的动作所使用的线程池。这两个函数都接受一个表示线程池的单个参数。
- en: All agents in the current process can be stopped by invoking the `(shutdown-agents)`.
    The `shutdown-agents` function should only be called before exiting a process,
    as there is no way to restart the agents in a process after calling this function.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`(shutdown-agents)`来停止当前进程中的所有代理。`shutdown-agents`函数应该在退出进程之前调用，因为在此函数调用之后无法重新启动进程中的代理。
- en: 'Now, let''s try implementing the dining philosophers problem using agents.
    We can reuse most of the functions from the previous implementation of the dining
    philosophers problem that was based on refs. Let''s define some functions to model
    this problem using agents, as shown in *Example 2.15*:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用代理实现 dining philosophers problem。我们可以重用之前基于refs的 dining philosophers
    problem 实现中的大多数函数。让我们定义一些函数来使用代理模拟这个问题，如*示例 2.15*所示：
- en: '[PRE144]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '*Example 2.15: The dining philosophers problem using agents*'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 2.15：使用代理的 dining philosophers problem*'
- en: In *Example 2.15*, the `make-philosopher-agent` function will create an agent
    representing a philosopher. The initial state of the resulting agent is a map
    of the keys `:name`, `:forks`, `:eating?`, and `:food`, as described in the previous
    implementation of the dining philosophers problem. Note that the forks in this
    implementation are still represented by refs.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 2.15*中，`make-philosopher-agent`函数将创建一个代表哲学家的代理。该代理的初始状态是一个包含键`:name`、`:forks`、`:eating?`和`:food`的映射，正如之前
    dining philosophers problem 的实现所描述。请注意，在这个实现中，叉子仍然由refs表示。
- en: The `start-eating` function in *Example 2.15* will start a transaction, check
    whether the forks placed to the left and right sides of a philosopher are available,
    changes the state of the forks and philosopher agent accordingly, and then suspends
    the current thread for some time to indicate that a philosopher is eating. The
    `stop-eating` function in *Example 2.15* will similarly update the state of a
    philosopher and the forks he had used, and then suspend the current thread for
    some time to indicate that a philosopher is thinking. Note that both the `start-eating`
    and `stop-eating` functions reuse the `has-forks?` and `update-forks` functions
    from *Example 2.7* of the previous implementation of the dining philosophers problem.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.15*中的`start-eating`函数将启动一个事务，检查哲学家左右两侧放置的叉子是否可用，相应地更改叉子和哲学家代理的状态，然后暂停当前线程一段时间以表示哲学家正在吃饭。*示例
    2.15*中的`stop-eating`函数将类似地更新哲学家的状态和他所使用的叉子的状态，然后暂停当前线程一段时间以表示哲学家正在思考。请注意，`start-eating`和`stop-eating`函数都重用了之前
    dining philosophers problem 实现的*示例 2.7*中的`has-forks?`和`update-forks`函数。'
- en: The `start-eating` and `stop-eating` functions are called by the `dine` function
    in *Example 2.15*. We can assume that this function will be passed as an action
    to a philosopher agent. This function checks the value of the `:eating?` key contained
    in a philosopher agent to decide whether it must invoke the `start-eating` or
    `stop-eating` function in the current call. Next, the `dine` function invokes
    itself again using the `send-off` function and dereferencing the agent returned
    by the `send-off` function. The `dine` function also checks the state of the atom
    `running?` and does not invoke itself through the `send-off` function in case
    the expression `@running` returns `false`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`start-eating` 和 `stop-eating` 函数由 *Example 2.15* 中的 `dine` 函数调用。我们可以假设这个函数将被传递给一个哲学家代理作为动作。这个函数检查哲学家代理中包含的
    `:eating?` 键的值，以决定是否必须在当前调用中调用 `start-eating` 或 `stop-eating` 函数。接下来，`dine` 函数再次使用
    `send-off` 函数调用自身，并取消引用 `send-off` 函数返回的代理。`dine` 函数还检查 `running?` 原子的状态，如果 `@running`
    返回 `false`，则不会通过 `send-off` 函数调用自身。'
- en: The `dine-philosophers` function in *Example 2.15* starts the simulation by
    setting the value of the `running?` atom to `true` and then invoking the `dine`
    function asynchronously through the `send-off` function for all the philosopher
    agents passed to it, represented by `philosophers`. The function `stop-philosophers`
    simply sets the value of the `running?` atom to `false`, thereby stopping the
    simulation.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*Example 2.15* 中的 `dine-philosophers` 函数通过将 `running?` 原子的值设置为 `true` 来启动模拟，然后通过
    `send-off` 函数异步调用 `dine` 函数，该函数为传递给它的所有哲学家代理执行，这些代理由 `philosophers` 表示。`stop-philosophers`
    函数简单地将 `running?` 原子的值设置为 `false`，从而停止模拟。'
- en: 'Finally, let''s define five instances of forks and philosophers using the `init-forks`
    and `init-philosophers` functions from *Example 2.9*, shown in *Example 2.16*
    as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 *Example 2.9* 中的 `init-forks` 和 `init-philosophers` 函数定义五个叉子和哲学家实例，如
    *Example 2.16* 中所示，如下所示：
- en: '[PRE145]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '*Example 2.16: The dining philosophers problem using agents (continued)*'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Example 2.16: 使用代理解决就餐哲学家问题（继续）*'
- en: 'We can now start the simulation by calling the `dine-philosophers` function.
    Also, we can print the collective state of the fork and philosopher instances
    in the simulation using the `check-philosophers` function defined in *Example
    2.10*, as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过调用 `dine-philosophers` 函数来启动模拟。此外，我们可以使用在 *Example 2.10* 中定义的 `check-philosophers`
    函数来打印模拟中叉子和哲学家实例的集体状态，如下所示：
- en: '[PRE146]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As shown in the preceding output, all philosopher agents share the fork instances
    among themselves. In effect, they work in tandem to ensure that each philosopher
    eventually consumes all of their allocated food.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，所有哲学家代理在彼此之间共享叉子实例。实际上，他们协同工作以确保每个哲学家最终消费掉分配给他们的所有食物。
- en: In summary, vars, refs, atoms, and agents can be used to represent mutable state
    that is shared among concurrently executing tasks.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，变量、引用、原子和代理可以用来表示在并发执行的任务之间共享的可变状态。
- en: Executing tasks in parallel
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行任务
- en: The simultaneous execution of several computations is termed as *parallelism*.
    The use of parallelism tends to increase the overall performance of a computation,
    since the computation can be partitioned to execute on several cores or processors.
    Clojure has a couple of functions that can be used for the parallelization of
    a particular computation or task, and we will briefly examine them in this section.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 同时执行多个计算被称为 *并行性*。使用并行性往往可以提高计算的总体性能，因为计算可以被分割以在多个核心或处理器上执行。Clojure 有几个函数可以用于特定计算或任务的并行化，我们将在本节中简要介绍它们。
- en: Note
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c2/parallel.clj` of the book's
    source code.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c2/parallel.clj` 中找到。
- en: 'Suppose we have a function that pauses the current thread for some time and
    then returns a computed value, as depicted in *Example 2.17*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数，该函数暂停当前线程一段时间，然后返回一个计算值，如 *Example 2.17* 所示：
- en: '[PRE147]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '*Example 2.17: A function that pauses the current thread*'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Example 2.17: 暂停当前线程的函数*'
- en: 'The function `square-slowly` in *Example 2.17* requires a single argument `x`.
    This function pauses the current thread for two seconds and returns the square
    of its argument `x`. If the function `square-slowly` is invoked over a collection
    of three values using the `map` function, it takes three times as long to complete,
    as shown here:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例2.17*中的`square-slowly`函数需要一个单个参数`x`。这个函数暂停当前线程两秒钟，并返回其参数`x`的平方。如果使用`map`函数在三个值的集合上调用`square-slowly`函数，它完成所需的时间是三倍，如下所示：'
- en: '[PRE148]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The previously shown `map` form returns a lazy sequence, and hence the `doall`
    form is required to realize the value returned by the map form. We could also
    use the `dorun` form to perform this realization of a lazy sequence. The entire
    expression is evaluated in about six seconds, which is thrice the time taken by
    the `square-slowly` function to complete. We can parallelize the application of
    the `square-slowly` function using the `pmap` function instead of `map`, as shown
    here:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的`map`形式返回一个惰性序列，因此需要使用`doall`形式来实现由`map`形式返回的值。我们也可以使用`dorun`形式来实现这个惰性序列的实例化。整个表达式大约在六秒内完成评估，这是`square-slowly`函数完成所需时间的三倍。我们可以使用`pmap`函数而不是`map`函数来并行化`square-slowly`函数的应用，如下所示：
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The entire expression now evaluates in the same amount of time required for
    a single call to the `square-slowly` function. This is due to the `square-slowly`
    function being called in parallel over the supplied collection by the `pmap` form.
    Thus, the `pmap` form has the same semantics as that of the `map` form, except
    that it applies the supplied function in parallel.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 整个表达式现在评估所需的时间与对`square-slowly`函数的单次调用所需的时间相同。这是由于`square-slowly`函数通过`pmap`形式在提供的集合上并行调用。因此，`pmap`形式与`map`形式具有相同的语义，除了它并行应用提供的函数。
- en: 'The `pvalues` and `pcalls` forms can also be used to parallelize computations.
    The `pvalues` form evaluates the expressions passed to it in parallel, and returns
    a lazy sequence of the resulting values. Similarly, the `pcalls` form invokes
    all functions passed to it, which must take no arguments, in parallel and returns
    a lazy sequence of the values returned by these functions:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`pvalues`和`pcalls`形式也可以用来并行化计算。`pvalues`形式并行评估传递给它的表达式，并返回一个包含结果的惰性序列。同样，`pcalls`形式并行调用传递给它的所有函数，这些函数必须不接受任何参数，并返回一个包含这些函数返回值的惰性序列：'
- en: '[PRE150]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: As shown in the preceding output, both expressions that use the `pvalues` and
    `pcalls` forms take the same amount of time to evaluate as a single call to the
    `square-slowly` function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，使用`pvalues`和`pcalls`形式的两个表达式评估所需的时间与对`square-slowly`函数的单次调用相同。
- en: Note
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `pmap`, `pvalues`, and `pcalls` forms *all* return lazy sequences that have
    to be realized using the `doall` or `dorun` form.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap`、`pvalues`和`pcalls`形式*都*返回需要使用`doall`或`dorun`形式来实现的惰性序列。'
- en: Controlling parallelism with thread pools
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线程池控制并行性
- en: The `pmap` form schedules parallel execution of the supplied function on the
    default threadpool. If we wish to configure or tweak the threadpool used by `pmap`,
    the `claypoole` library ([https://github.com/TheClimateCorporation/claypoole](https://github.com/TheClimateCorporation/claypoole))
    is a good option. This library provides an implementation of the `pmap` form that
    must be passed a configurable threadpool. We will now demonstrate how we can use
    this library to parallelize a given function.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap`形式在默认线程池上调度提供的函数的并行执行。如果我们希望配置或调整`pmap`使用的线程池，`claypoole`库([https://github.com/TheClimateCorporation/claypoole](https://github.com/TheClimateCorporation/claypoole))是一个不错的选择。这个库提供了一个必须传递可配置线程池的`pmap`形式的实现。我们现在将展示如何使用这个库来并行化给定函数。'
- en: Note
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖项对于即将到来的示例是必需的：
- en: '[PRE151]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE152]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `pmap` function from the `com.climate.claypoole` namespace is essentially
    a variant of the standard `pmap` function to which we supply a threadpool instance
    to be used in parallelizing a given function. We can also supply the number of
    threads to be used by this variant of the `pmap` function in order to parallelize
    a given function, as shown here:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`com.climate.claypoole`命名空间的`pmap`函数本质上是我们提供的用于并行化给定函数的线程池实例的标准`pmap`函数的一个变体。我们还可以为这个`pmap`函数的变体提供要使用的线程数，以便并行化给定函数，如下所示：
- en: '[PRE153]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: As previously shown, the `pmap` function from the `claypoole` library can be
    used to parallelize the `square-slowly` function that we defined earlier in *Example
    2.17* over a collection of three values. These three elements are computed over
    in two batches, in which each batch will parallely apply the `square-slowly` function
    over two elements in two separate threads. Since the `square-slowly` function
    takes two seconds to complete, the total time taken to compute over the collection
    of three elements is around four seconds.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`claypoole`库中的`pmap`函数可以用来并行化我们在*示例2.17*中定义的`square-slowly`函数，在三个值的集合上。这三个元素在两个批次中计算，每个批次将并行地在两个不同的线程中应用`square-slowly`函数。由于`square-slowly`函数需要两秒钟才能完成，计算三个元素集合所需的总时间大约是四秒钟。
- en: 'We can create an instance of a pool of threads using the `threadpool` function
    from the `claypoole` library. This threadpool instance can then be passed to the
    `pmap` function from the `claypoole` library. The `com.climate.claypoole` namespace
    also provides the `ncpus` function that returns the number of physical processors
    available to the current process. We can create a threadpool instance and pass
    it to this variant of the `pmap` function as shown here:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`claypoole`库中的`threadpool`函数创建一个线程池的实例。然后，这个线程池实例可以传递给`claypoole`库中的`pmap`函数。`com.climate.claypoole`命名空间还提供了一个`ncpus`函数，该函数返回当前进程可用的物理处理器数量。我们可以创建一个线程池实例并将其传递给这个`pmap`函数的变体，如下所示：
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Assuming that we are running the preceding code on a computer system that has
    two physical processors, the call to the `threadpool` function shown previously
    will create a threadpool of two threads. This threadpool instance can then be
    passed to the `pmap` function as shown in the preceding example.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在一个具有两个物理处理器的计算机系统上运行前面的代码，前面显示的`threadpool`函数调用将创建一个包含两个线程的线程池。然后，这个线程池实例可以像前面示例中那样传递给`pmap`函数。
- en: Note
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can fall back to the standard behavior of the `pmap` function by passing
    the `:builtin` keyword as the first argument to the `com.climate.claypoole/pmap`
    function. Similarly, if the keyword `:serial` is passed as the first argument
    to the `claypoole` version of the `pmap` function, the function behaves like the
    standard `map` function.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`:builtin`关键字作为`com.climate.claypoole/pmap`函数的第一个参数传递，来回退到`pmap`函数的标准行为。同样，如果将`:serial`关键字作为`claypoole`版本的`pmap`函数的第一个参数传递，该函数的行为将类似于标准的`map`函数。
- en: The `threadpool` function also supports a couple of useful key options. Firstly,
    we can create a pool of non-daemon threads using the `:daemon false` optional
    argument. Daemon threads are killed when the process exits, and all threadpools
    created by the `threadpool` function are pools of daemon threads by default. We
    can also name a threadpool using the `:name` key option of the `threadpool` function.
    The `:thread-priority` key option can be used to indicate the priority of the
    threads in the new threadpool.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`threadpool`函数还支持一些有用的关键选项。首先，我们可以使用`:daemon false`可选参数创建一个非守护线程池。守护线程在进程退出时会被终止，并且`threadpool`函数默认创建的线程池都是守护线程池。我们还可以使用`threadpool`函数的`:name`关键选项来命名一个线程池。`:thread-priority`关键选项可以用来指定新线程池中线程的优先级。'
- en: 'Tasks can also be prioritized using the `pmap`, `priority-threadpool`, and
    `with-priority` forms from the `claypoole` library. A priority threadpool is created
    using the `priority-threadpool` function, and this new threadpool can be used
    along with the `with-priority` function to assign a priority to a task that must
    be parallelized using `pmap`, as shown here:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`claypoole`库中的`pmap`、`priority-threadpool`和`with-priority`形式也可以对任务进行优先级排序。使用`priority-threadpool`函数创建一个优先级线程池，然后可以使用`with-priority`函数与这个新的线程池一起使用，为必须使用`pmap`并行化的任务分配一个优先级，如下所示：
- en: '[PRE155]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Tasks with higher priority are assigned to threads first. Hence, the task represented
    by `task-1` will be assigned to a thread of execution before the task represented
    by `task-2` in the previous output.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级较高的任务会首先分配给线程。因此，在先前的输出中，代表`task-1`的任务将先于代表`task-2`的任务分配给一个执行线程。
- en: 'To gracefully deallocate a given threadpool, we can call the `shutdown` function
    from the `com.climate.claypoole` namespace, which accepts a threadpool instance
    as its only argument. The `shutdown!` function from the same namespace will forcibly
    shut down the threads in a threadpool. The `shutdown!` function can also be called
    using the `with-shutdown!` macro. We specify the threadpools to be used for a
    series of computations as a vector of bindings to the `with-shutdown!` macro.
    This macro will implicitly call the `shutdown!` function on all of the threadpools
    that it has created once all the computations in the body of this macro are completed.
    For example, we can define a function to create a threadpool, use it for a computation,
    and finally, shut down the threadpool, using the `with-shutdown!` function as
    shown in *Example 2.18*:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优雅地释放给定的线程池，我们可以从`com.climate.claypoole`命名空间调用`shutdown`函数，该函数接受一个线程池实例作为其唯一参数。来自同一命名空间的`shutdown!`函数将强制关闭线程池中的线程。`shutdown!`函数也可以使用`with-shutdown!`宏来调用。我们指定用于一系列计算的线程池作为绑定到`with-shutdown!`宏的绑定向量。此宏将在此宏体中的所有计算完成后，隐式调用它所创建的所有线程池的`shutdown!`函数。例如，我们可以定义一个创建线程池的函数，用它进行计算，并最终使用`with-shutdown!`函数关闭线程池，如*示例2.18*所示：
- en: '[PRE156]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '*Example 2.18: Using a priority threadpool*'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例2.18：使用优先级线程池*'
- en: The `square-slowly-with-pool` function defined in *Example 2.18* will create
    a new threadpool, represented by `pool`, and then use it to call the `pmap` function.
    The `shutdown!` function is implicitly called once the `doall` form completely
    evaluates the lazy sequence returned by the `pmap` function.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例2.18*中定义的`square-slowly-with-pool`函数将创建一个新的线程池，表示为`pool`，然后使用它来调用`pmap`函数。一旦`doall`形式完全评估了`pmap`函数返回的惰性序列，就会隐式调用`shutdown!`函数。
- en: The `claypoole` library also supports *unordered parallelism*, in which results
    of individual threads of computation are used as soon as they are available in
    order to minimize latency. The `com.climate.claypoole/upmap` function is an unordered
    parallel version of the `pmap` function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`claypoole`库还支持*无序并行性*，其中计算线程的结果一旦可用就被用来最小化延迟。`com.climate.claypoole/upmap`函数是`pmap`函数的无序并行版本。'
- en: 'The `com.climate.claypoole` namespace also provides several other functions
    that use threadpools, as described here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.climate.claypoole`命名空间还提供了其他一些使用线程池的函数，如这里所述：'
- en: The `com.climate.claypoole/pvalues` function is a threadpool-based implementation
    of the `pvalues` function. It will evaluate its arguments in parallel using a
    supplied threadpool and return a lazy sequence.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.climate.claypoole/pvalues`函数是`pvalues`函数的基于线程池的实现。它将使用提供的线程池并行评估其参数，并返回一个惰性序列。'
- en: The `com.climate.claypoole/pcalls` function is a threadpool-based version of
    the `pcalls` function, which invokes several no-argument functions to return a
    lazy sequence.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.climate.claypoole/pcalls`函数是`pcalls`函数的基于线程池的版本，它调用几个无参数函数以返回一个惰性序列。'
- en: A future that uses a given threadpool can be created using the `com.climate.claypoole/future`
    function.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`com.climate.claypoole/future`函数创建使用给定线程池的未来。
- en: We can evaluate an expression in a parallel fashion over the items in a given
    collection using the `com.climate.claypoole/pfor` function.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`com.climate.claypoole/pfor`函数在给定集合的项上以并行方式评估一个表达式。
- en: The `upvalues`, `upcalls`, and `upfor` functions in the `com.climate.claypoole`
    namespace are unordered parallel versions of the `pvalues`, `pcalls`, and `pfor`
    functions, respectively, from the same namespace.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.climate.claypoole`命名空间中的`upvalues`、`upcalls`和`upfor`函数分别是来自同一命名空间的`pvalues`、`pcalls`和`pfor`函数的无序并行版本。'
- en: 'It is quite evident that the `pmap` function from the `com.climate.claypoole`
    namespace will eagerly evaluate the collection it is supplied. This may be undesirable
    when we intend to call `pmap` over an infinite sequence. The `com.climate.claypoole.lazy`
    namespace provides versions of `pmap` and other functions from the `com.climate.claypoole`
    namespace that preserve the laziness of a supplied collection. The lazy version
    of the `pmap` function can be demonstrated as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，来自`com.climate.claypoole`命名空间的`pmap`函数会急切地评估它提供的集合。当我们打算在无限序列上调用`pmap`时，这可能是不可取的。`com.climate.claypoole.lazy`命名空间提供了`pmap`和其他来自`com.climate.claypoole`命名空间的函数的版本，这些版本保留了提供的集合的惰性。`pmap`函数的惰性版本可以如下演示：
- en: '[PRE157]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The previously defined `lazy-pmap` sequence is a lazy sequence created by mapping
    the `square-slowly` function over the infinite sequence `(range)`. As shown previously,
    the call to the `pmap` function returns immediately, and the first four elements
    of the resulting lazy sequence are realized in parallel using the `doall` and
    `take` functions.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`lazy-pmap`序列是通过将`square-slowly`函数映射到无限序列`(range)`创建的惰性序列。如前所述，对`pmap`函数的调用会立即返回，并且结果惰性序列的前四个元素是通过`doall`和`take`函数并行实现的。
- en: To summarize, Clojure has the `pmap`, `pvalues`, and `pcalls` primitives to
    deal with parallel computations. If we intend to control the amount of parallelism
    utilized by these functions, we can use the `claypoole` library's implementations
    of these primitives. The `claypoole` library also supports other useful features
    such as prioritized threadpools and unordered parallelism.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Clojure有`pmap`、`pvalues`和`pcalls`原语来处理并行计算。如果我们打算控制这些函数使用的并行程度，我们可以使用`claypoole`库对这些原语的实现。`claypoole`库还支持其他有用的功能，如优先级线程池和无序并行性。
- en: Summary
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have explored various constructs that can be used to create concurrent and
    parallel tasks in Clojure. You learned to handle shared mutable state through
    the use of reference types, namely vars, refs, atoms and agents. As we described
    earlier, the dining philosophers problem can be easily implemented using refs
    and agents. You also studied how tasks can be executed in parallel. Lastly, we
    explored the `claypoole` library, which allows us to control the amount of parallelism
    used for a given computation.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了可以用来在Clojure中创建并发和并行任务的多种结构。你学习了如何通过使用引用类型，即vars、refs、atoms和agents来处理共享可变状态。正如我们之前所描述的，可以使用refs和agents轻松实现就餐哲学家问题。你还学习了如何并行执行任务。最后，我们探讨了`claypoole`库，它允许我们控制给定计算使用的并行程度。
- en: In the next chapter, we will continue our exploration of parallelism in Clojure
    through the use of reducers.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过使用归约器来探索Clojure中的并行性。
- en: Chapter 3. Parallelization Using Reducers
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 使用归约器并行化
- en: '*Reducers* are another way of looking at collections in Clojure. In this chapter,
    we will study this particular abstraction of collections, and how it is quite
    orthogonal to viewing collections as sequences. The motivation behind reducers
    is to increase the performance of computations over collections. This performance
    gain is achieved mainly through parallelization of such computations.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '*归约器*是另一种在Clojure中看待集合的方法。在本章中，我们将研究这种特定的集合抽象，以及它与将集合视为序列的视角是如何正交的。归约器的动机是提高集合计算的性能。这种性能提升主要是通过并行化这些计算来实现的。'
- en: As we have seen in [Chapter 1](ch16.html "Chapter 1. Working with Sequences
    and Patterns"), *Working with Sequences and Patterns*, sequences and laziness
    are a great way to handle collections. The Clojure standard library provides several
    functions to handle and manipulate sequences. However, abstracting a collection
    as a sequence has an unfortunate consequence; any computation performed over all
    the elements of a sequence is inherently sequential. Also, all of the standard
    sequence functions create a new collection that is similar to the collection passed
    to these functions. Interestingly, performing a computation over a collection
    without creating a similar collection, even as an intermediary result, is quite
    useful. For example, it is often required to reduce a given collection to a single
    value through a series of transformations in an iterative manner. This sort of
    computation does not necessarily require the intermediary results of each transformation
    to be saved.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第一章](ch16.html "第一章. 使用序列和模式")中看到的，*使用序列和模式*，序列和惰性是处理集合的绝佳方式。Clojure标准库提供了几个函数来处理和操作序列。然而，将集合抽象为序列有一个不幸的后果；对序列所有元素执行的计算本质上都是顺序的。此外，所有标准序列函数都会创建一个新的集合，它与传递给这些函数的集合相似。有趣的是，在没有创建类似集合的情况下，即使作为中间结果，对集合执行计算也是非常有用的。例如，通常需要通过一系列迭代转换将给定的集合缩减为一个单一值。这种计算不一定需要保存每个转换的中间结果。
- en: A consequence of iteratively computing values from a collection is that we cannot
    parallelize it in a straightforward way. Modern *MapReduce* frameworks handle
    this kind of computation by pipelining the elements of a collection through several
    transformations in parallel, and finally, reducing the results into a single result.
    Of course, the result could as well be a new collection. A drawback of this methodology
    is that it produces concrete collections as intermediate results of each transformation,
    which is rather wasteful. For example, if we wanted to filter out values from
    a collection, the MapReduce strategy would require creating empty collections
    to represent values that are left out of the reduction step to produce the final
    result.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合迭代计算值的一个后果是我们不能直接并行化它。现代*MapReduce*框架通过并行地将集合的元素通过几个转换进行管道传输来处理这类计算，最后将结果归约为一个单一结果。当然，结果也可以是一个新的集合。这种方法的一个缺点是它产生了每个转换的中间结果的实体集合，这相当浪费。例如，如果我们想从集合中过滤掉值，MapReduce策略将需要创建空集合来表示在归约步骤中未被包含的值，以产生最终结果。
- en: This incurs unnecessary memory allocation and also creates additional work for
    the reduction step, which produces the final result. Hence, there's a scope for
    optimizing these sorts of computations.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生不必要的内存分配，并为生成最终结果的归约步骤创建额外的工作。因此，优化这类计算是有空间的。
- en: 'This brings us to the notion of treating computations over collections as *reducers*
    to attain better performance. Of course, this doesn''t mean that reducers are
    a replacement for sequences. Sequences and laziness are great for abstracting
    computations that create and manipulate collections, while reducers are a specialized
    high-performance abstraction of collections in which a collection needs to be
    piped through several transformations, and finally, combined to produce the final
    result. Reducers achieve a performance gain in the following ways:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了将集合上的计算视为*归约器*以获得更好性能的概念。当然，这并不意味着归约器可以替代序列。序列和惰性对于抽象创建和操作集合的计算非常有用，而归约器是集合的专门高性能抽象，其中集合需要通过几个转换进行管道传输，最后合并以产生最终结果。归约器通过以下方式实现性能提升：
- en: Reducing the amount of memory allocated to produce the desired result
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少分配给产生所需结果的内存量
- en: Parallelizing the process of reducing a collection into a single result, which
    could be an entirely new collection
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化将集合归约为一个单一结果的过程，这个结果可能是一个全新的集合
- en: The `clojure.core.reducers` namespace provides several functions to process
    collections using reducers. Let's now examine how reducers are implemented and
    a few examples that demonstrate how reducers can be used.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.reducers`命名空间提供了几个函数，用于使用归约器处理集合。现在让我们来检查归约器的实现方式，以及一些演示如何使用归约器的示例。'
- en: Using reduce to transform collections
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用归约来转换集合
- en: Sequences and functions that operate on sequences preserve the sequential ordering
    between elements. Lazy sequences avoid the unnecessary realization of elements
    in a collection until they are required for a computation, but the realization
    of these values is still performed in a sequential manner. However, this characteristic
    of sequential ordering may not be desirable for all computations performed over
    it. For example, it's not possible to map a function over a vector and then lazily
    realize values in the resulting collection out of order; since the `map` function
    converts the supplied collection into a sequence. Also, functions such as `map`
    and `filter` are lazy, but still sequential by nature.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 序列以及操作序列的函数会保留元素之间的顺序。惰性序列在需要计算时才避免集合中元素的无效实现，但这些值的实现仍然以顺序方式进行。然而，这种顺序特性可能不是所有在它上执行的计算都希望拥有的。例如，不可能在向量上应用函数并按顺序惰性实现结果集合中的值；因为`map`函数将提供的集合转换为序列。此外，`map`和`filter`等函数虽然是惰性的，但本质上仍然是顺序的。
- en: What's wrong with sequences?
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列有什么问题？
- en: One of the limitations of sequences is that they are realized in *chunks*. Let's
    study a simple example to illustrate what this means. Consider a unary function,
    as shown in *Example 3.1*, which we intend to map over a given vector. The function
    must compute a value from the one it is supplied, and also perform a side effect
    so that we can observe its application over the elements in a collection.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的一个局限性是它们在 *块* 中实现。让我们通过一个简单的例子来研究这意味着什么。考虑一个一元函数，如 *示例 3.1* 所示，我们打算将其映射到给定的向量上。该函数必须从它提供的值中计算出一个值，并执行一个副作用，以便我们可以观察它在集合元素中的应用。
- en: Note
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c3/reducers.clj` of the book's
    source code.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c3/reducers.clj` 中找到。
- en: '[PRE158]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '*Example 3.1: A simple unary function*'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.1：一个简单的一元函数*'
- en: 'The `square-with-side-effect` function simply returns the square of a number
    `x` using the `*` function. This function also prints the value of `x` using a
    `println` form whenever it is called. Suppose this function is mapped over a given
    vector. The resulting collection would have to be realized completely if a computation
    has to be performed over it, even if all the elements from the resulting vector
    are not required. This can be demonstrated as follows:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`square-with-side-effect` 函数简单地使用 `*` 函数返回数字 `x` 的平方。每当这个函数被调用时，它也会使用 `println`
    形式打印 `x` 的值。假设这个函数被映射到给定的向量上。如果必须对它进行计算，结果集合必须完全实现，即使结果向量中的所有元素都不需要。这可以通过以下方式演示：'
- en: '[PRE159]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As shown previously, the `mapped` variable contains the result of mapping the
    `square-with-side-effect` function over a vector. If we try to sum the first three
    values in the resulting collection using the `reduce`, `take`, and `+` functions,
    all the values in the `[0 1 2 3 4 5]` vector are printed as a side effect, as
    shown in the preceding output. This means that the `square-with-side-effect` function
    was applied to all the elements in the initial vector, despite the fact that only
    the first three elements were actually required by the `reduce` form. Of course,
    this can be solved using the `seq` function to convert the vector to a sequence
    before mapping the `square-with-side-effect` function over it. But then, we lose
    the ability to efficiently access elements in a random order in the resulting
    collection.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`mapped` 变量包含了对 `square-with-side-effect` 函数在向量上映射的结果。如果我们尝试使用 `reduce`、`take`
    和 `+` 函数对结果集合中的前三个值求和，`[0 1 2 3 4 5]` 向量中的所有值都会作为副作用打印出来，如前面的输出所示。这意味着 `square-with-side-effect`
    函数被应用于初始向量的所有元素，尽管实际上 `reduce` 形式只需要前三个元素。当然，这可以通过使用 `seq` 函数在映射 `square-with-side-effect`
    函数之前将向量转换为序列来解决。但这样，我们就失去了在结果集合中以随机顺序高效访问元素的能力。
- en: 'To understand why this actually happens, we first need to understand how the
    standard `map` function is actually implemented. A simplified definition of the
    `map` function is shown in *Example 3.2*:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这实际上会发生，我们首先需要了解标准 `map` 函数是如何实际实现的。`map` 函数的简化定义如下所示 *示例 3.2*：
- en: '[PRE160]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '*Example 3.2: A simplified definition of the map function*'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.2：map 函数的简化定义*'
- en: The definition of `map` in *Example 3.2* is a simplified and rather incomplete
    one, as it doesn't check for an empty collections and cannot be used over multiple
    collections. That aside, this definition of `map` does indeed apply a function
    `f` to all the elements in a collection `coll`. This is implemented using a composition
    of the `cons`, `first`, `rest`, and `lazy-seq` forms.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3.2* 中 `map` 的定义是一个简化和相当不完整的定义，因为它没有检查空集合，并且不能用于多个集合。抛开这一点，这个 `map` 的定义确实将函数
    `f` 应用到集合 `coll` 中的所有元素。这是通过 `cons`、`first`、`rest` 和 `lazy-seq` 形式的组合来实现的。'
- en: 'This implementation can be interpreted as "applying the function `f` to the
    first element in the collection `coll`, and then mapping `f` over the rest of
    the collection in a lazy manner". An interesting consequence of this implementation
    is that the `map` function has the following characteristics:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可以解释为“将函数 `f` 应用于集合 `coll` 中的第一个元素，然后以懒方式将 `f` 映射到集合的其余部分”。这种实现的一个有趣后果是
    `map` 函数具有以下特性：
- en: The ordering among elements in the collection `coll` is preserved.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 `coll` 中元素的顺序被保留。
- en: This computation is performed recursively.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种计算是递归执行的。
- en: The `lazy-seq` form is used to perform the computation in a lazy manner.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lazy-seq` 形式以懒方式执行计算。
- en: The use of the `first` and `rest` forms indicate that `coll` must be a sequence,
    and the `cons` form will also produce a result that is a sequence. Hence, the
    `map` function accepts a sequence and builds a new one.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`first`和`rest`形式表明`coll`必须是一个序列，而`cons`形式也会产生一个序列的结果。因此，`map`函数接受一个序列并构建一个新的序列。
- en: 'However, none of these properties of sequences are needed to transform a given
    collection into a result that is not a sequence. Another characteristic of lazy
    sequences is how they are realized. By the term realized, we mean to say a given
    lazy sequence is evaluated to produce concrete values. Lazy sequences are realized
    in *chunks*. Each chunk is comprised of 32 elements, and this is done as an optimization.
    Sequences that behave this way are termed as *chunked sequences*. Of course, not
    all sequences are chunked, and we can check whether a given sequence is chunked
    using the `chunked-seq?` predicate. The `range` function returns a chunked sequence,
    as shown here:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将这些序列的性质转换为非序列的结果并不需要。懒序列的另一个特点是它们的实现方式。当我们说实现时，我们的意思是给定懒序列被评估以产生具体值。懒序列以*块*的形式实现。每个块包含32个元素，这是作为一个优化措施。以这种方式行为的序列被称为*块序列*。当然，并非所有序列都是块序列，我们可以使用`chunked-seq?`谓词来检查给定的序列是否是块序列。`range`函数返回一个块序列，如下所示：
- en: '[PRE161]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Both the statements in the preceding output select a single element from a sequence
    returned by the `map` function. The function passed to the `map` function in both
    the preceding statements prints the`!` character and returns the value supplied
    to it. In the first statement, the first 32 elements of the resulting sequence
    are realized even though only the first element is required. Similarly, the second
    statement is observed to realize the first 64 elements of the resulting sequence
    when the element at the 32nd position is obtained using the `nth` function. But
    again, realizing a collection in chunks isn't required to perform a computation
    over the elements in the collection.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中的两个语句都从`map`函数返回的序列中选择单个元素。在前面两个语句中传递给`map`函数的函数打印`!`字符并返回其提供的值。在第一个语句中，即使只需要第一个元素，结果序列的前32个元素也会被实现。同样，当使用`nth`函数获取第32个位置的元素时，第二个语句观察到结果序列的前64个元素被实现。但再次强调，在块中实现集合并不需要执行集合中元素的运算。
- en: Note
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Chunked sequences have been an integral part of Clojure since version 1.1.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 块序列自Clojure 1.1版本以来一直是其核心部分。
- en: 'If we are to handle such computations efficiently, we cannot build on functions
    that return sequences, such as `map` and `filter`. Incidentally, the `reduce`
    function does not necessarily produce a sequence. It also has a couple of other
    interesting properties:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要高效地处理此类计算，我们不能依赖于返回序列的函数，如`map`和`filter`。顺便提一下，`reduce`函数不一定产生序列。它还具有一些其他有趣的特性：
- en: The `reduce` function actually lets the supplied collection define how it is
    computed over or reduced. Thus, `reduce` is *collection independent*.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`函数实际上允许提供的集合定义它是如何被计算或归约的。因此，`reduce`是*集合无关*的。'
- en: Also, the `reduce` function is versatile enough to build a single value or an
    entirely new collection as well. For example, using `reduce` with the `*` or `+`
    functions will create a single valued result, while using it with the `cons` or
    `concat` functions can create a new collection as a result. Thus, `reduce` can
    *build anything*.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`reduce`函数足够灵活，可以构建单个值或全新的集合。例如，使用`*`或`+`函数与`reduce`一起使用将创建一个单值结果，而使用`cons`或`concat`函数可以创建一个新集合作为结果。因此，`reduce`可以*构建任何东西*。
- en: To summarize, the `reduce` function can be used as a premise to generalize any
    computation or transformation that has to be applied on a collection.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`reduce`函数可以用作前提来泛化任何必须应用于集合的计算或转换。
- en: Introducing reducers
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入reducers
- en: A collection is said to be *reducible* when it defines its behavior with the
    `reduce` function. The binary function used by the `reduce` function along with
    a collection is also termed as a *reducing function*. A reducing function requires
    two arguments—one to represent the accumulated result of the reduction, and another
    to represent an input value that has to be combined into the result. Several reducing
    functions can be composed into one, which effectively changes how the `reduce`
    function processes a given collection. This composition is done using *reducing
    function transformers*, or simply *reducers*.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个集合使用`reduce`函数定义其行为时，我们说这个集合是*可减少的*。`reduce`函数使用的二元函数以及集合也被称为*减少函数*。减少函数需要两个参数——一个用于表示减少的累积结果，另一个用于表示必须组合到结果中的输入值。可以将几个减少函数组合成一个，这实际上改变了`reduce`函数处理给定集合的方式。这种组合是通过*减少函数转换器*或简单地*reducer*来完成的。
- en: The use of sequences and laziness can be compared to using reducers to perform
    a given computation by Rich Hickey's infamous pie-maker analogy. Suppose a pie-maker
    has been supplied a bag of apples, with an intent to *reduce* the apples to a
    pie. There are a couple transformations needed to perform this task. First, the
    stickers on all the apples have to be removed, as in we *map* a function to "take
    the sticker off" over the apples in the collection. Also, all the rotten apples
    will have to be removed, which is analogous to using the `filter` function to
    remove elements from a collection. Instead of performing this work herself, the
    pie-maker delegates it to her assistant. The assistant could first take the stickers
    off of all the apples, thus producing a new collection, and then take out the
    rotten apples to produce another new collection, which illustrates the use of
    lazy sequences. But then, the assistant would be doing unnecessary work by removing
    the stickers from the rotten apples, which will have to be discarded later.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用序列和惰性可以与Rich Hickey著名的派制作类比中使用的reducer执行给定计算进行比较。假设一个派制作商已经得到了一袋苹果，目的是将苹果*减少*成派。需要几个转换来完成这个任务。首先，所有苹果上的标签都必须去掉，就像我们对集合中的苹果应用一个函数来“撕掉标签”。此外，所有坏苹果都必须去掉，这类似于使用`filter`函数从集合中删除元素。派制作商不会亲自做这项工作，而是委托给她的助手。助手可以先撕掉所有苹果上的标签，从而产生一个新的集合，然后取出坏苹果以产生另一个新的集合，这说明了惰性序列的使用。但是，助手通过从坏苹果上撕掉标签而做了不必要的工，这些苹果最终会被丢弃。
- en: On the other hand, the assistant could delay this work until the actual reduction
    of the processed apples into a pie is performed. Once the work is actually needed
    to be performed, the assistant will compose the two tasks of *mapping* and *filtering*
    the collection of apples, thus avoiding any unnecessary work. This case depicts
    the use of reducers to compose and transform the tasks needed to effectively reduce
    the collection of apples into a pie. Thus, the use of intermediary collections
    between each transformation is avoided, which is an optimization in terms of memory
    allocations performed to produce the result.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，助手可以将这项工作推迟到实际将处理过的苹果减少成派的时候。一旦实际需要执行这项工作，助手将组合两个任务：对苹果集合进行*映射*和*过滤*，从而避免任何不必要的工。这种情况描述了使用reducer来组合和转换将苹果集合有效减少成派所需的任务。因此，避免了在每个转换之间使用中间集合，这在内存分配方面是一个优化。
- en: Of course, a smart assistant would simply discard the rotten apples first, which
    is essentially filtering the apples before mapping them. However, not all recipes
    are that trivial, and moreover, we can achieve a more interesting optimization
    through the use of reducers—parallelism. By using reducers, we create a *recipe*
    of tasks to reduce a collection of apples into a pie that can be parallelized.
    Also, all processing is delayed until the final reduction, instead of dealing
    with collections as intermediary results of each task. This is the gist of how
    reducers achieve performance though function composition and parallelization.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个智能助手会首先丢弃坏苹果，这本质上是在映射之前过滤苹果。然而，并非所有食谱都是那么简单，而且，我们可以通过使用reducer（减少器）实现更有趣的优化——并行化。通过使用reducer，我们创建了一个*食谱*，将苹果集合减少成一个可以并行化的派。此外，所有处理都延迟到最终减少，而不是将集合作为每个任务的中间结果来处理。这就是reducer通过函数组合和并行化实现性能的精髓。
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，必须将以下命名空间包含在您的命名空间声明中：
- en: '[PRE162]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The `clojure.core.reducers` namespace requires Java 6 with the `jsr166y.jar`
    JAR or Java 7+ for fork/join support.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.reducers` 命名空间需要 Java 6 以及 `jsr166y.jar` JAR 或 Java 7+ 以支持 fork/join。'
- en: 'Let''s now briefly explore how reducers are actually implemented. Functions
    that operate on sequences use the `clojure.lang.ISeq` interface to abstract the
    behavior of a collection. In the case of reducers, the common interface that we
    must build upon is that of a reducing function. As we mentioned earlier, a reducing
    function is a two-arity function in which the first argument is the accumulated
    result so far and the second argument is the current input that has to be combined
    with the first argument. The process of performing a computation over a collection
    and producing some result can be generalized into three distinct cases. They can
    be described as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要探讨一下reducers是如何实际实现的。在序列上操作的函数使用 `clojure.lang.ISeq` 接口来抽象集合的行为。在reducers的情况下，我们必须构建的通用接口是归约函数的接口。正如我们之前提到的，归约函数是一个双参数函数，其中第一个参数是到目前为止的累积结果，第二个参数是要与第一个参数结合的当前输入。在集合上执行计算并产生一些结果的过程可以概括为三个不同的案例。它们可以描述如下：
- en: A new collection with the same number of elements as the collection it is supplied
    needs to be produced. This *one-to-one* case is analogous to using the `map` function.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要生成一个与提供的集合具有相同元素数量的新集合。这种 *一对一* 的情况类似于使用 `map` 函数。
- en: The computation *shrinks* the supplied collection by removing elements from
    it. This can be done using the `filter` function.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算通过从其中移除元素来 *缩小* 提供的集合。这可以使用 `filter` 函数来完成。
- en: The computation could also be *expansive*, in which case it produces a new collection
    that contains an increased number of elements. This is like what the `mapcat`
    function does.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算也可能是 *扩展的*，在这种情况下，它会产生一个包含更多元素的新集合。这就像 `mapcat` 函数所做的那样。
- en: 'These cases depict the different ways in which a collection can be transformed
    into the desired result. Any computation, or reduction, over a collection can
    be thought of as an arbitrary sequence of such transformations. These transformations
    are represented by *transformers*, which are essentially functions that transform
    a reducing function. They can be implemented as shown in *Example 3.3*:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案例描述了集合可以转换成所需结果的不同方式。任何在集合上进行的计算或归约都可以被视为一系列这样的变换的任意序列。这些变换由 *转换器* 表示，它们本质上是将归约函数进行转换的函数。它们可以像
    *Example 3.3* 中所示的那样实现：
- en: '[PRE163]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '*Example 3.3: Transformers*'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Example 3.3: 转换器*'
- en: The `mapping`, `filtering`, and `mapcatting` functions in *Example 3.3* represent
    the core logic of the `map`, `filter`, and `mapcat` functions respectively. All
    of these functions are transformers that take a single argument and return a new
    function. The returned function transforms a supplied reducing function, represented
    by `rf`, and returns a new reducing function, created using the expression `(fn
    [result input] ... )`. Functions returned by the `mapping`, `filtering`, and `mapcatting`
    functions are termed as *reducing function transformers*.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '*Example 3.3* 中的 `mapping`、`filtering` 和 `mapcatting` 函数分别代表了 `map`、`filter`
    和 `mapcat` 函数的核心逻辑。所有这些函数都是接受单个参数并返回一个新函数的转换器。返回的函数将一个表示为 `rf` 的提供的归约函数进行转换，并返回一个新的归约函数，该函数使用表达式
    `(fn [result input] ... )` 创建。由 `mapping`、`filtering` 和 `mapcatting` 函数返回的函数被称为
    *归约函数转换器*。'
- en: The `mapping` function applies the `f` function to the current input, represented
    by the `input` variable. The value returned by the function `f` is then combined
    with the accumulated result, represented by `result`, using the reducing function
    `rf`. This transformer is a frighteningly pure abstraction of the standard `map`
    function that applies a function `f` over a collection. The `mapping` function
    makes no assumptions of the structure of the collection it is supplied or how
    the values returned by the function `f` are combined to produce the final result.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping` 函数将 `f` 函数应用于当前输入，由 `input` 变量表示。然后，函数 `f` 返回的值与累积结果 `result` 结合，使用归约函数
    `rf`。这个转换器是对标准 `map` 函数应用函数 `f` 到集合的令人敬畏的纯抽象。`mapping` 函数对其提供的集合的结构或函数 `f` 返回的值如何结合以产生最终结果没有任何假设。'
- en: Similarly, the `filtering` function uses a predicate `p?` to check whether the
    current input of the reducing function `rf` must be combined into the final result,
    represented by `result`. If the predicate is not true, then the reducing function
    will simply return the value `result` without any modification. The `mapcatting`
    function uses the `reduce` function to combine the value `result` with the result
    of the expression `(f input)`. In this transformer, we can assume that the function
    `f` will return a new collection and the reducing function `rf` will somehow combine
    two collections.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`filtering` 函数使用谓词 `p?` 来检查当前输入的归约函数 `rf` 是否必须结合到最终结果中，该结果由 `result` 表示。如果谓词不为真，则归约函数将简单地返回值
    `result` 而不进行任何修改。`mapcatting` 函数使用 `reduce` 函数将值 `result` 与表达式 `(f input)` 的结果组合。在这个转换器中，我们可以假设函数
    `f` 将返回一个新的集合，而归约函数 `rf` 将以某种方式组合两个集合。
- en: 'One of the foundations of the `reducers` library is the `CollReduce` protocol
    defined in the `clojure.core.protocols` namespace. This protocol abstracts the
    behavior of a collection when it is passed as an argument to the `reduce` function,
    and is declared as shown in *Example 3.4*:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers` 库的一个基础是定义在 `clojure.core.protocols` 命名空间中的 `CollReduce` 协议。此协议抽象了集合在作为
    `reduce` 函数的参数传递时的行为，并声明如下 *示例 3.4*：'
- en: '[PRE164]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '*Example 3.4: The CollReduce protocol*'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.4：CollReduce 协议*'
- en: 'The `clojure.core.reducers` namespace defines a `reducer` function that creates
    a reducible collection by dynamically extending the `CollReduce` protocol, as
    shown in *Example 3.5*:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.reducers` 命名空间定义了一个 `reducer` 函数，该函数通过动态扩展 `CollReduce` 协议来创建一个可归约集合，如
    *示例 3.5* 所示：'
- en: '[PRE165]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '*Example 3.5: The reducer function*'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.5：归约函数*'
- en: The `reducer` function combines a collection `coll` and a reducing function
    transformer `xf`, which is returned by the `mapping`, `filtering`, and `mapcatting`
    functions, to produce a new reducible collection. When `reduce` is invoked on
    a reducible collection, it will ultimately ask the collection to reduce itself
    using the reducing function returned by the expression `(xf rf)`. Using this mechanism,
    several reducing functions can be composed into a single computation to be performed
    over a given collection. Also, the `reducer` function needs to be defined only
    once, and the actual implementation of `coll-reduce` is provided by the collection
    supplied to the `reducer` function.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducer` 函数将集合 `coll` 和归约函数转换器 `xf`（由 `mapping`、`filtering` 和 `mapcatting`
    函数返回）组合起来，以生成一个新的可归约集合。当在可归约集合上调用 `reduce` 时，它最终会要求集合使用由表达式 `(xf rf)` 返回的归约函数来归约自身。使用这种机制，可以将多个归约函数组合成单个计算，在给定的集合上执行。此外，`reducer`
    函数只需要定义一次，而 `coll-reduce` 的实际实现由提供给 `reducer` 函数的集合提供。'
- en: 'Now, we can redefine the `reduce` function to simply invoke the `coll-reduce`
    function implemented by a given collection, as shown in *Example 3.6*:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新定义 `reduce` 函数，使其简单地调用由给定集合实现的 `coll-reduce` 函数，如 *示例 3.6* 所示：
- en: '[PRE166]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '*Example 3.6: Redefining the reduce function*'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.6：重新定义 reduce 函数*'
- en: As shown in *Example 3.6*, the `reduce` function delegates the job of reducing
    a collection to the collection itself using the `coll-reduce` function. Also,
    the `reduce` function will use the reducing function `rf` to also supply the `init`
    argument when it is not specified. An interesting consequence of this definition
    of `reduce` is that the function `rf` must produce an *identity value* when supplied
    no arguments. The standard `reduce` function also uses the `CollReduce` protocol
    to delegate the job of reducing a collection to the collection itself, but will
    also fall back on the default definition of `reduce` in case the supplied collection
    does not implement the `CollReduce` protocol.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *示例 3.6* 所示，`reduce` 函数将归约集合的任务委托给集合本身，使用 `coll-reduce` 函数。此外，`reduce` 函数还将使用归约函数
    `rf` 来提供 `init` 参数，如果未指定。`reduce` 的这种定义的一个有趣后果是，当没有提供参数时，函数 `rf` 必须产生一个 *恒等值*。标准的
    `reduce` 函数也使用 `CollReduce` 协议将归约集合的任务委托给集合本身，但如果提供的集合没有实现 `CollReduce` 协议，它将回退到
    `reduce` 的默认定义。
- en: Note
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since Clojure 1.4, the `reduce` function allows a collection to define how it
    reduced using the `clojure.core.CollReduce` protocol. Clojure 1.5 introduced the
    `clojure.core.reducers` namespace that extends the use of this protocol.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Clojure 1.4 以来，`reduce` 函数允许集合通过 `clojure.core.CollReduce` 协议定义其归约方式。Clojure
    1.5 引入了 `clojure.core.reducers` 命名空间，该命名空间扩展了此协议的使用。
- en: 'All of the standard Clojure collections, namely lists, vectors, sets, and maps,
    implement the `CollReduce` protocol. The `reducer` function can be used to build
    a sequence of transformations to be applied to a collection when it is passed
    as an argument to the `reduce` function. This can be demonstrated as follows:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准的Clojure集合，即列表、向量、集合和映射，都实现了 `CollReduce` 协议。`reducer` 函数可用于构建在将集合作为参数传递给
    `reduce` 函数时应用于集合的转换序列。以下是如何演示：
- en: '[PRE167]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In the preceding output, the `mapping` function is used with the `inc` function
    to create a reducing function transformer that increments all the elements in
    a given collection. This transformer is then combined with a vector using the
    `reducer` function to produce a reducible collection. The call to `reduce` in
    both of the preceding statements is transformed into the expression `(reduce +
    [2 3 4 5])`, thus producing the result `14`. We can now redefine the `map`, `filter`,
    and `mapcat` functions using the `reducer` function, as shown in *Example 3.7*:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`mapping` 函数与 `inc` 函数一起使用，创建了一个用于增加给定集合中所有元素的减少函数转换器。然后，使用 `reducer`
    函数将该转换器与一个向量组合，以产生一个可减少的集合。在前面的两个语句中的 `reduce` 调用被转换成表达式 `(reduce + [2 3 4 5])`，从而产生结果
    `14`。现在，我们可以使用 `reducer` 函数重新定义 `map`、`filter` 和 `mapcat` 函数，如 *示例 3.7* 所示：
- en: '[PRE168]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '*Example 3.7: Redefining the map, filter and mapcat functions using the reducer
    form*'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.7：使用reducer形式重新定义map、filter和mapcat函数*'
- en: As shown in *Example 3.7*, the `map`, `filter`, and `mapcat` functions are now
    simply compositions of the `reducer` form with the `mapping`, `filtering`, and
    `mapcatting` transformers respectively.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *示例 3.7* 所示，`map`、`filter` 和 `mapcat` 函数现在是 `reducer` 形式与 `mapping`、`filtering`
    和 `mapcatting` 转换器分别的组合。
- en: Note
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The definitions of `CollReduce`, `reducer`, `reduce`, `map`, `filter`, and `mapcat`
    as shown in this section are simplified versions of their actual definitions in
    the `clojure.core.reducers` namespace.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中所示 `CollReduce`、`reducer`、`reduce`、`map`、`filter` 和 `mapcat` 的定义是它们在 `clojure.core.reducers`
    命名空间中实际定义的简化版本。
- en: 'The definitions of the `map`, `filter`, and `mapcat` functions shown in *Example
    3.7* have the same shape as the standard versions of these functions, as shown
    here:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 3.7* 中所示的 `map`、`filter` 和 `mapcat` 函数的定义与这些函数的标准版本具有相同的结构，如下所示：
- en: '[PRE169]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Hence, the `map`, `filter`, and `mapcat` functions from the `clojure.core.reducers`
    namespace can be used in the same way as the standard versions of these functions.
    The `reducers` library also provides a `take` function that can be used as a replacement
    for the standard `take` function. We can use this function to reduce the number
    of calls to the `square-with-side-effect` function (from *Example 3.1*) when it
    is mapped over a given vector, as shown here:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，来自 `clojure.core.reducers` 命名空间的 `map`、`filter` 和 `mapcat` 函数可以像这些函数的标准版本一样使用。`reducers`
    库还提供了一个 `take` 函数，它可以作为标准 `take` 函数的替代品。我们可以使用这个函数来减少在映射给定向量时对 `square-with-side-effect`
    函数（来自 *示例 3.1*）的调用次数，如下所示：
- en: '[PRE170]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Thus, using the `map` and `take` functions from the `clojure.core.reducers`
    namespace as shown here avoids applying the `square-with-side-effect` function
    to all five elements in the vector `[0 1 2 3 4 5]` as only the first three are
    required.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `clojure.core.reducers` 命名空间中的 `map` 和 `take` 函数，如这里所示，可以避免将 `square-with-side-effect`
    函数应用于向量 `[0 1 2 3 4 5]` 中的所有五个元素，因为只需要前三个。
- en: 'The `reducers` library also provides variants of the standard `take-while`,
    `drop`, `flatten`, and `remove` functions, which are based on reducers. Effectively,
    functions based on reducers will require a lesser number of allocations than sequence-based
    functions, thus leading to an improvement in performance. For example, consider
    the `process` and `process-with-reducer` functions shown in *Example 3.8*:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers` 库还提供了基于reducers的标准 `take-while`、`drop`、`flatten` 和 `remove` 函数的变体。实际上，基于reducers的函数将需要比基于序列的函数更少的分配，从而提高性能。例如，考虑
    *示例 3.8* 中所示的 `process` 和 `process-with-reducer` 函数：'
- en: '[PRE171]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '*Example 3.8: Functions to process a collection of numbers using sequences
    and reducers*'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.8：使用序列和reducers处理数字集合的函数*'
- en: 'The `process` function in *Example 3.8* applies the `inc` function over a collection
    of numbers represented by `nums` using the `map` function. The `process-with-reducer`
    function performs the same action, but uses the reducer variant of the `map` function.
    The `process-with-reducer` function will take a lesser amount of time to produce
    its result from a large vector when compared to the `process` function, as shown
    here:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3.8* 中的 `process` 函数使用 `map` 函数在由 `nums` 表示的数字集合上应用 `inc` 函数。`process-with-reducer`
    函数执行相同的操作，但使用 `map` 函数的归约器变体。与 `process` 函数相比，`process-with-reducer` 函数从大向量生成结果所需的时间会更少，如下所示：'
- en: '[PRE172]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The `process-with-reducer` function gets a slight performance boost as it requires
    a lesser number of memory allocations than the `process` function. We should note
    that the available memory should be large enough to load the entire file, or else
    we could run out of memory. The performance of this computation can be improved
    by a greater scale if we can somehow parallelize it, and we shall examine how
    this can be done in the following section.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`process-with-reducer` 函数由于需要的内存分配比 `process` 函数少而获得轻微的性能提升。我们应该注意，可用的内存应该足够大，能够加载整个文件，否则我们可能会耗尽内存。如果我们能够以某种方式并行化它，那么我们可以通过更大的规模来提高这种计算的性能，我们将在下一节中探讨如何实现这一点。'
- en: Using fold to parallelize collections
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用折叠并行化集合
- en: A collection that implements the `CollReduce` protocol is still sequential by
    nature. Using the `reduce` function with `CollReduce` does have a certain amount
    of performance gain, but it still processes elements in a collection in a sequential
    order. The most obvious way to improve the performance of a computation that is
    performed over a collection is parallelization. Such computations can be parallelized
    if we ignore the ordering of elements in a given collection to produce the result
    of the computation. In the reducers library, this is implemented based on the
    *fork/join model* of parallelization from the `java.util.concurrent` namespace.
    The fork/join model essentially partitions a collection over which a computation
    has to be performed into two halves and processes each partition in parallel.
    This halving of the collection is done in a recursive manner. The granularity
    of the partitions affects the overall performance of a computation modeled using
    fork/join. This means that if a fork/join strategy is used to recursively partition
    a collection into smaller collections that contain a single element each, the
    overhead of the mechanics of fork/join would actually bring down the overall performance
    of the computation.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了 `CollReduce` 协议的集合本质上仍然是顺序的。使用 `reduce` 函数与 `CollReduce` 结合确实有一定的性能提升，但它仍然按顺序处理集合中的元素。提高在集合上执行的计算性能的最明显方法是将计算并行化。如果忽略给定集合中元素的顺序以生成计算结果，则可以并行化此类计算。在
    reducers 库中，这是基于 `java.util.concurrent` 命名空间的 *fork/join* 并行化模型实现的。fork/join 模型本质上将需要执行计算的计算集合分成两半，并并行处理每个分区。这种集合的分割是以递归方式进行的。分区的粒度会影响使用
    fork/join 模型模拟的计算的整体性能。这意味着，如果使用 fork/join 策略递归地将集合分割成包含单个元素的更小的集合，那么 fork/join
    机制的开销实际上会降低计算的整体性能。
- en: Note
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A fork/join based method of parallelization is actually implemented in the `clojure.core.reducers`
    namespace using the `ForkJoinTask` and `ForkJoinPool` classes from the `java.util.concurrent`
    namespace in Java 7\. In Java 6, it is implemented in the `ForkJoinTask` and `ForkJoinPool`
    classes of the `jsr166y` namespace. For more information on the Java fork/join
    framework, visit [https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 基于fork/join的并行化方法实际上是在Java 7的`clojure.core.reducers`命名空间中实现的，使用了来自`java.util.concurrent`命名空间的`ForkJoinTask`和`ForkJoinPool`类。在Java
    6中，它在`jsr166y`命名空间的`ForkJoinTask`和`ForkJoinPool`类中实现。有关Java fork/join框架的更多信息，请访问[https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)。
- en: The parallelization of such computations using reducers is quite different from
    how it is handled in MapReduce-based libraries. In case of reducers, the elements
    are first reduced through a number of transformations into a smaller number of
    elements and then finally, combined to create the result. This contrasts with
    how a MapReduce strategy models such a computation, in which the elements of a
    collection are mapped through several transformations and a final reduction step
    is used to produce the final result. This distinguishes the MapReduce model of
    parallel computation with the *reduce-combine* model used by the `reducers` library.
    This methodology of parallelization using a reduce-combine strategy is implemented
    by the `fold` function in the `clojure.core.reducers` namespace.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 使用reducers进行此类计算的并行化与在基于MapReduce的库中处理的方式大不相同。在reducers的情况下，元素首先通过一系列转换减少到更少的元素数量，然后最终组合起来以创建结果。这与MapReduce策略如何模拟此类计算形成对比，其中集合的元素通过几个转换进行映射，并使用最终减少步骤来生成最终结果。这区分了MapReduce并行计算模型与`reducers`库使用的*reduce-combine*模型。这种使用reduce-combine策略的并行化方法是通过`clojure.core.reducers`命名空间中的`fold`函数实现的。
- en: Note
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, the `fold` function refers to a parallelizable computation, which
    is very different from the traditional fold left (`foldl`) and fold right (`foldr`)
    functions in other functional programming languages such as Haskell and Erlang.
    The `reduce` function in Clojure actually has the same sequential nature and semantics
    as the `foldl` function in other languages.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，`fold`函数指的是一个可并行化的计算，这与Haskell和Erlang等其他函数式编程语言中的传统fold left (`foldl`)
    和fold right (`foldr`) 函数非常不同。Clojure中的`reduce`函数实际上与其他语言中的`foldl`函数具有相同的顺序性质和语义。
- en: The `fold` function parallelizes a given computation over a collection using
    fork/join based threads. It implements the reduce-combine strategy that we previously
    described and executes the `reduce` function in parallel over equally partitioned
    segments of a given collection. The results produced by these parallel executions
    of the `reduce` function are finally combined using a *combining function*. Of
    course, if the supplied collection is too small to actually gain any performance
    through fork/join based parallelization, a `fold` form will simply call the `reduce`
    function on a single thread of execution. The `fold` function thus represents
    a *potentially parallelizable* computation over a collection. Due to this nature
    of `fold`, we should avoid performing IO and other side effects based on sequential
    ordering when using the `fold` form.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`函数通过基于fork/join的线程在集合上并行化给定的计算。它实现了我们之前描述的reduce-combine策略，并在给定集合的等分段上并行执行`reduce`函数。这些`reduce`函数的并行执行产生的结果最终通过一个*组合函数*进行组合。当然，如果提供的集合太小，实际上无法通过基于fork/join的并行化获得任何性能提升，`fold`形式将简单地在一个执行线程上调用`reduce`函数。因此，`fold`函数代表了一个集合上的*可能并行化*的计算。由于`fold`的这种性质，我们应该避免在使用`fold`形式时基于顺序执行进行IO和其他副作用。'
- en: 'The `fold` function allows a collection to define how it is *folded* into the
    result, which is similar to the semantics of the `reduce` function. A collection
    is said to be *foldable* if it implements the `CollFold` protocol from the `clojure.core.reducers`
    namespace. The `reducers` library extends the `CollFold` protocol for the standard
    vector and map collection types. The parallelization of these implementations
    of `CollFold` is done using fork/join based parallelism. The definition of the
    `CollFold` protocol is shown in *Example 3.9*:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`函数允许集合定义如何将其*折叠*到结果中，这与`reduce`函数的语义类似。如果一个集合实现了来自`clojure.core.reducers`命名空间的`CollFold`协议，则称该集合为*可折叠*。`reducers`库扩展了标准向量映射集合类型的`CollFold`协议。这些`CollFold`实现的并行化是通过基于fork/join的并行性完成的。`CollFold`协议的定义在*示例3.9*中展示：'
- en: '[PRE173]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '*Example 3.9: The CollFold protocol*'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例3.9：CollFold协议*'
- en: The `CollFold` protocol defines a `coll-fold` function, which requires four
    arguments—a collection `coll`, the number of elements `n` in each segment or partition
    of the collection, a combining function `cf`, and a reducing function `rf`. A
    foldable collection must implement this protocol, as well as the `clojure.core.protocols.CollReduce`
    protocol, as a call to `fold` on a given collection may fall back to a single-threaded
    execution of the `reduce` function.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollFold` 协议定义了一个 `coll-fold` 函数，它需要四个参数——一个集合 `coll`，集合中每个段或分区中的元素数量 `n`，一个组合函数
    `cf`，以及一个归约函数 `rf`。一个可折叠的集合必须实现此协议，以及 `clojure.core.protocols.CollReduce` 协议，因为对给定集合的
    `fold` 调用可能会回退到 `reduce` 函数的单线程执行。'
- en: 'To create a foldable collection from a collection and a reduction function
    transformer, the reducers library defines a `folder` function with similar semantics
    as the `reducer` function. This function is implemented as shown in *Example 3.10*:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合和归约函数转换器创建一个可折叠集合，reducers 库定义了一个与 `reducer` 函数具有相似语义的 `folder` 函数。此函数的实现方式如
    *示例 3.10* 所示：
- en: '[PRE174]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '*Example 3.10: The folder function*'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.10：folder 函数*'
- en: 'The `folder` function creates a new foldable and reducible collection from
    the collection `coll` and the reduction function transformer `xf`. This composition
    of the `xf` and `rf` functions is analogous to that performed by the `reducer`
    function described in *Example 3.5*. Apart from the `xf` and `rf` functions, the
    `coll-fold` function also requires a combining function `cf` with which the results
    of the potentially parallel executions of the `reduce` function are combined.
    Similar to the `reduce` function, the `fold` function passes on the responsibility
    of actually folding a given collection to the collections implementation of the
    `coll-fold` function. An implementation of the `fold` function is described in
    *Example 3.11*:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`folder` 函数从集合 `coll` 和归约函数转换器 `xf` 创建一个新的可折叠和可归约集合。这种 `xf` 和 `rf` 函数的组合类似于在
    *示例 3.5* 中描述的 `reducer` 函数所执行的操作。除了 `xf` 和 `rf` 函数外，`coll-fold` 函数还需要一个组合函数 `cf`，用于组合
    `reduce` 函数可能并行执行的结果。与 `reduce` 函数类似，`fold` 函数将折叠给定集合的实际责任传递给 `coll-fold` 函数的集合实现。`fold`
    函数的实现已在 *示例 3.11* 中描述：'
- en: '[PRE175]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '*Example 3.11: The fold function*'
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.11：折叠函数*'
- en: As shown in *Example 3.11*, the `fold` function calls the `coll-fold` function
    of the collection `coll` using the reducing function `rf` and the combining function
    `cf`. The `fold` function can also specify the number of elements `n` in each
    segment processed by the `reduce` function, which defaults to `512` elements.
    We can also avoid specifying the combining function `cf` to the `fold` function,
    in which case the reducing function `rf` itself will be used as the combining
    function.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *示例 3.11* 所示，`fold` 函数使用归约函数 `rf` 和组合函数 `cf` 调用集合 `coll` 的 `coll-fold` 函数。`fold`
    函数还可以指定 `reduce` 函数处理的每个段中的元素数量 `n`，默认为 `512` 个元素。我们还可以避免将组合函数 `cf` 指定给 `fold`
    函数，在这种情况下，归约函数 `rf` 本身将用作组合函数。
- en: 'An interesting aspect of the combining and reducing functions used by the `fold`
    form is that they must be *associative* in nature. This guarantees that the result
    of the `fold` function will be independent of the order in which the elements
    in a given collection are combined to produce the given result. This allows us
    to parallelize the execution of the `fold` function over segments of a given collection.
    Also, analogous to the reducing function required by the `reduce` form, the `fold`
    function requires the combining and reducing functions to produce an *identity
    value* when invoked with no arguments. In functional programming, a function that
    is both associative and provides an identity value is termed as a **monoid**.
    The `clojure.core.reducers` namespace provides the `monoid` function, described
    in *Example 3.12*, to create such a function that can be used as the combining
    function or the reducing function supplied to a `fold` form:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 形式中使用的组合和归约函数的一个有趣方面是，它们在本质上必须是 *结合律* 的。这保证了 `fold` 函数的结果将独立于给定集合中元素组合的顺序。这允许我们在给定集合的段上并行化
    `fold` 函数的执行。同样，类似于 `reduce` 形式所需的归约函数，`fold` 函数要求组合和归约函数在无参数调用时产生一个 *恒等值*。在函数式编程中，既是结合律又是提供恒等值的函数被称为
    **单例**。`clojure.core.reducers` 命名空间提供了在 *示例 3.12* 中描述的 `monoid` 函数，以创建可以用于 `fold`
    形式的组合函数或归约函数的函数：'
- en: '[PRE176]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '*Example 3.12: The monoid function*'
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.12：单例函数*'
- en: The `monoid` function shown in *Example 3.12* produces a function that calls
    a function `op` when supplied with two arguments `a` and `b`. When the function
    returned by the `monoid` function is called with no arguments, it will produce
    an identity value of the operation by simply calling the `ctor` function with
    no arguments. This function allows us to easily create a combining function to
    be used with the `fold` function from any arbitrary functions `ctor` and `op`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 3.12* 中显示的 `monoid` 函数产生一个函数，当提供两个参数 `a` 和 `b` 时，它会调用函数 `op`。当使用 `monoid`
    函数返回的函数不带参数调用时，它将通过不带参数调用 `ctor` 函数来简单地产生操作的身份值。这个函数使我们能够轻松地创建一个组合函数，用于与 `fold`
    函数一起使用，该函数可以是任何任意的 `ctor` 和 `op` 函数。
- en: 'We can now redefine the `map`, `filter`, and `mapcat` operations as compositions
    of the `folder` function and the `mapping`, `filtering`, and `mapcatting` transformers
    defined in *Example 3.3*, as shown in *Example 3.13*:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将 `map`、`filter` 和 `mapcat` 操作重新定义为 `folder` 函数和 *示例 3.3* 中定义的 `mapping`、`filtering`
    和 `mapcatting` 转换器的组合，如 *示例 3.13* 所示：
- en: '[PRE177]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '*Example 3.13: Redefining the map, filter and mapcat functions using the folder
    form*'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.13：使用 folder 形式重新定义 map、filter 和 mapcat 函数*'
- en: Note
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The definitions of `folder`, `fold`, `monoid`, `map`, `filter`, and `mapcat`
    as shown in this section are simplified versions of their actual definitions in
    the `clojure.core.reducers` namespace.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中显示的 `folder`、`fold`、`monoid`、`map`、`filter` 和 `mapcat` 的定义是它们在 `clojure.core.reducers`
    命名空间中实际定义的简化版本。
- en: The `reducers` library also defines the `foldcat` function. This function is
    a high-performance variant of the `reduce` and `conj` functions. In other words,
    the evaluation of the expression `(foldcat coll)` will be significantly faster
    than that of the expression `(reduce conj [] coll)`, where `coll` is a reducible
    or foldable collection. Also, the collection returned by the `foldcat` function
    will be a foldable collection.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers` 库还定义了 `foldcat` 函数。这个函数是 `reduce` 和 `conj` 函数的高性能变体。换句话说，表达式 `(foldcat
    coll)` 的评估将比表达式 `(reduce conj [] coll)`（其中 `coll` 是可还原或可折叠的集合）快得多。此外，`foldcat`
    函数返回的集合也将是一个可折叠的集合。'
- en: 'Let''s now use the `fold` and `map` functions to improve the performance of
    the `process` and `process-with-reducer` functions from *Example 3.8*. We can
    implement this as shown in *Example 3.14*:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在使用 `fold` 和 `map` 函数来提高 *示例 3.8* 中的 `process` 和 `process-with-reducer`
    函数的性能。我们可以像 *示例 3.14* 中所示那样实现这一点：
- en: '[PRE178]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '*Example 3.14: A function to process a collection of numbers using a fold form*'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.14：使用 fold 形式处理数字集合的函数*'
- en: 'The performance of the `process-with-folder` function with a large vector can
    be compared to the `process` and `process-with-reducer` functions, as shown here:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`process-with-folder` 函数在大向量上的性能可以与 `process` 和 `process-with-reducer`
    函数进行比较：
- en: '[PRE179]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: It is observed from the preceding output that the `process-with-folder` function
    performs significantly better than the `process` and `process-with-reducer` functions
    due to its inherent use of parallelism. In summary, reducers improve the performance
    of a computation that has to be performed over a collection using fork/join-based
    parallelism.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中观察到，`process-with-folder` 函数由于其固有的并行性使用，其性能显著优于 `process` 和 `process-with-reducer`
    函数。总之，reducer 通过基于 fork/join 的并行性提高了必须对集合执行的计算性能。
- en: Processing data with reducers
  id: totrans-700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 reducer 处理数据
- en: We will now study a simple example that depicts the use of reducers in efficiently
    processing large collections. For this example, we will use the `iota` library
    ([https://github.com/thebusby/iota](https://github.com/thebusby/iota)) to handle
    large memory-mapped files. The usage of the `iota` library with large files is
    encouraged as an efficient alternative to using concrete collections. For example,
    loading the records in a 1 GB TSV file as strings into a Clojure vector would
    consume over 10 GB of memory due to the inefficient storage of Java strings. The
    `iota` library avoids this by efficiently indexing and caching the contents of
    a large file, and this is done with much lower amount of memory overhead when
    compared to using concrete collections.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将研究一个简单示例，该示例描述了在高效处理大型集合中使用 reducer 的方法。为此示例，我们将使用 `iota` 库 ([https://github.com/thebusby/iota](https://github.com/thebusby/iota))
    来处理大型内存映射文件。鼓励使用 `iota` 库来处理大型文件，作为使用具体集合的高效替代方案。例如，将 1 GB 的 TSV 文件中的记录作为字符串加载到
    Clojure 向量中，由于 Java 字符串的低效存储，将消耗超过 10 GB 的内存。`iota` 库通过有效地索引和缓存大文件的 内容来避免这种情况，与使用具体集合相比，这需要更低的内存开销。
- en: Note
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例需要以下库依赖项：
- en: '[PRE180]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE181]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The following examples can be found in `src/m_clj/c3/io.clj` of the book's source
    code.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c3/io.clj` 中找到。
- en: 'Suppose we have a large TSV file that contains several thousands of records.
    Each record represents a person, and can be assumed to have five fields, as shown
    in the following data:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含数千条记录的大型 TSV 文件。每条记录代表一个人，可以假设它有五个字段，如下所示的数据：
- en: '[PRE182]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Each record contains two strings and three keywords. The first two string fields
    of a record represent the last and first name of a person, the third column is
    a keyword that indicates the gender of a person, and the fourth column is a keyword
    that identifies a person as a parent or a child. Finally, the fifth column is
    a keyword that represents an arbitrary direction.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 每条记录包含两个字符串和三个关键词。记录的前两个字符串字段代表一个人的姓和名，第三列是一个表示一个人性别的关键词，第四列是一个标识一个人为父母或孩子的关键词。最后，第五列是一个表示任意方向的关键词。
- en: Note
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following example expects the content shown previously to be present in
    the file `resources/data/sample.tsv`, relative to the root of your Leiningen project.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例期望之前显示的内容存在于相对于您的 Leiningen 项目的根目录的 `resources/data/sample.tsv` 文件中。
- en: 'The `seq` and `vec` functions from the `iota` library can be used to create
    a sequence and a vector representation of a memory-mapped file. These objects
    can then be used to access the file in a performant way. Both of the `seq` and
    `vec` functions require a file path to be passed to them as the first argument.
    The `vec` function will index the supplied file in *chunks*, and we can specify
    the size of each chunk as the second argument to the `vec` function. The `seq`
    function performs buffered reads of the supplied file as required, similar to
    the way a lazy sequence is realized. The size of the buffer used by this resulting
    sequence can be specified as the second argument to the `seq` function. Both the
    `seq` and `vec` functions split the contents of a file by a predefined byte-separator
    into records represented as strings. These functions also accept an optional third
    argument to indicate the byte separator between records in the supplied file.
    The `vec` function is slower than the `seq` function as it must index the records
    in the file, which can be demonstrated as follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `iota` 库中的 `seq` 和 `vec` 函数来创建内存映射文件的序列和向量表示。这些对象可以用来以高效的方式访问文件。`seq` 和
    `vec` 函数都需要将文件路径作为第一个参数传递给它们。`vec` 函数将以 *块* 的形式索引提供的文件，我们可以将每个块的大小作为 `vec` 函数的第二个参数指定。`seq`
    函数按需执行缓冲读取提供的文件，类似于实现懒序列的方式。该序列使用的缓冲区大小可以作为 `seq` 函数的第二个参数指定。`seq` 和 `vec` 函数将文件内容按预定义的字节分隔符分割成以字符串表示的记录。这些函数还接受一个可选的第三个参数，以指示提供的文件中记录之间的字节分隔符。由于
    `vec` 函数必须索引文件中的记录，因此它比 `seq` 函数慢，如下所示：
- en: '[PRE183]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Both the statements shown here load the `sample.tsv` file into Clojure data
    structures. As expected, the `vec` function takes a bit more time than the `seq`
    function to return a value. The values returned by `seq` and `vec` can be treated
    just like any other collection. Naturally, iterating over a vector returned by
    the `vec` function is much faster than using a sequence, as shown here:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的两个语句都将 `sample.tsv` 文件加载到 Clojure 数据结构中。正如预期的那样，`vec` 函数返回值所需的时间比 `seq`
    函数多。`seq` 和 `vec` 返回的值可以像任何其他集合一样处理。自然地，迭代由 `vec` 函数返回的向量比使用序列要快，如下所示：
- en: '[PRE184]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We will now demonstrate a couple of ways to query the data in the `sample.tsv`
    file using reducers and the `iota` library. We will need to first define a function
    that converts a collection of records into collections of columnar values from
    their string-based representations. This can be implemented using the reducer
    based `map` and `filter` functions, as shown in the `into-records` function in
    *Example 3.15*:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示几种使用 reducers 和 `iota` 库查询 `sample.tsv` 文件数据的方法。我们首先需要定义一个函数，该函数将记录集合转换为基于字符串表示的列值集合。这可以通过基于
    reducer 的 `map` 和 `filter` 函数实现，如 *示例 3.15* 中的 `into-records` 函数所示：
- en: '[PRE185]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '*Example 3.15: A function to convert a memory-mapped file into a reducible
    collection*'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 3.15：一个将内存映射文件转换为可减少集合的函数*'
- en: 'Now, let''s say we need to compute the total number of females from the records
    in the `sample.tsv` file. We can implement a function to perform this computation
    using the `map` and `fold` functions, as shown in the `count-females` function
    in *Example 3.16*:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要从 `sample.tsv` 文件中的记录中计算女性的总数。我们可以通过使用 `map` 和 `fold` 函数来实现一个执行此计算的函数，如下所示在
    *示例3.16* 中的 `count-females` 函数：
- en: '[PRE186]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'We can query the total number of females in the `file-as-seq` and `file-as-vec`
    collections by composing the `into-records` and `count-females` functions. This
    can be done using the `->` threading form, as shown here:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合 `into-records` 和 `count-females` 函数来查询 `file-as-seq` 和 `file-as-vec`
    集合中女性的总数。这可以使用 `->` 线程形式来完成，如下所示：
- en: '[PRE187]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Similarly, the reducer-based `map` and `filter` functions can be used to fetch
    the first names of all the children with the same last name or family in a given
    collection, as implemented by the `get-children-names-in-family` function in *Example
    3.17*:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，基于解决器的 `map` 和 `filter` 函数可以用来获取给定集合中具有相同姓氏或家族的所有孩子的名字，如 *示例3.17* 中的 `get-children-names-in-family`
    函数所实现的那样：
- en: '[PRE188]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '*Example 3.17: A function to get the first names of all children in a collection
    of persons*'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例3.17：一个获取人员集合中所有孩子名字的函数*'
- en: 'The `into-records` and `get-children-names-in-family` functions can be composed
    together to query the first names of all children with the last name `"brown"`
    from the available data, as shown here:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`into-records` 和 `get-children-names-in-family` 函数可以组合在一起，查询所有姓氏为 `"brown"`
    的孩子的名字，如下所示：'
- en: '[PRE189]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `iota` library provides a couple more useful functions to handle large
    text files:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota` 库提供了一些更有用的函数来处理大型文本文件：'
- en: The `numbered-vec` function will create a vector representing a memory-mapped
    file in which each string representing a record will be prepended with its position
    in the given file.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbered-vec` 函数将创建一个表示内存映射文件的向量，其中每个表示记录的字符串都将在其给定文件中的位置前添加。'
- en: The `subvec` function of the `iota` library can be used to *slice* records from
    a memory-mapped file returned by the `vec` and `numbered-vec` functions. Its semantics
    are identical to the standard `subvec` function that operates on vectors.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iota` 库的 `subvec` 函数可以用来从 `vec` 和 `numbered-vec` 函数返回的内存映射文件中 *切片* 记录。其语义与在向量上操作的标准
    `subvec` 函数相同。'
- en: Reducers and the `iota` library allow us to idiomatically and efficiently handle
    text files containing a large number of byte-separated records. There are also
    several other libraries and frameworks in the Clojure ecosystem that use reducers
    to handle large amounts of data, and the reader is encouraged to explore these
    libraries and frameworks on their own.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 解决器和 `iota` 库使我们能够以惯用和高效的方式处理包含大量字节分隔记录的文本文件。Clojure生态系统还有其他几个库和框架使用解决器来处理大量数据，鼓励读者自行探索这些库和框架。
- en: Summary
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the `clojure.core.reducers` library in detail.
    We had a look at how reducers are implemented and also how we can use reducers
    to handle large collections of data in an efficient manner. We also briefly studied
    the `iota` library that can be used with reducers to handle large amounts of data
    stored in text files.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了 `clojure.core.reducers` 库。我们查看了解决器的实现方式，以及如何高效地使用解决器处理大量数据。我们还简要研究了
    `iota` 库，该库可以与解决器一起使用，以处理存储在文本文件中的大量数据。
- en: In the following chapter, we will explore Clojure macros.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Clojure宏。
- en: Chapter 4. Metaprogramming with Macros
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用宏进行元编程
- en: Programmers often stumble into situations where they would like to add features
    or constructs to their programming language of choice. Generally, if a feature
    would have to be added to a language, the language's compiler or interpreter would
    need some modification. Alternatively, Clojure (and other Lisps as well) uses
    *macros* to solve this problem. The term *metaprogramming* is used to describe
    the ability to generate or manipulate a program's source code by using another
    program. Macros are a metaprogramming tool that allow programmers to easily add
    new features to their programming language.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常会遇到想要向他们选择的编程语言中添加功能或结构的情况。通常，如果必须向语言中添加功能，则语言的编译器或解释器需要进行一些修改。或者，Clojure（以及其他Lisp）使用
    *宏* 来解决这个问题。术语 *元编程* 用于描述通过使用另一个程序生成或操作程序源代码的能力。宏是元编程工具，允许程序员轻松地向他们的编程语言添加新功能。
- en: Lisps are not the only languages with support for macro-based metaprogramming.
    For example, in C and C++, macros are handled by the compiler's preprocessor.
    In these languages, before a program is compiled, all macro calls in the program's
    source code are replaced by their definitions. In this sense, macros are used
    to generate code through a form of text substitution during the compilation phase
    of a program. On the other hand, Lisps allow programmers to transform or rewrite
    code when macros are interpreted or compiled. Macros can thus be used to concisely
    encapsulate recurring patterns in code. Of course, this can be done in languages
    without macros, as well, without much hassle. But macros allow us to encapsulate
    patterns in code in a clean and concise manner. As we will see ahead in this chapter,
    there's nothing equivalent to Lisp macros in other programming languages in terms
    of clarity, flexibility, and power. Lisps are truly leaps ahead of other programming
    languages in terms of metaprogramming capabilities.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 语言并非唯一支持基于宏的元编程的语言。例如，在 C 和 C++ 语言中，宏由编译器的预处理器处理。在这些语言中，在程序编译之前，程序源代码中的所有宏调用都被它们的定义所替换。从这个意义上讲，宏在程序的编译阶段通过一种文本替换的形式生成代码。另一方面，Lisp
    允许程序员在宏被解释或编译时转换或重写代码。因此，宏可以用来简洁地封装代码中的重复模式。当然，在没有宏的语言中也可以这样做，而且不会太麻烦。但宏允许我们以干净和简洁的方式封装代码中的模式。正如我们将在本章后面看到的那样，在其他编程语言中，没有与
    Lisp 宏相当的东西，无论是从清晰度、灵活性还是功能上讲。在元编程能力方面，Lisp 真正领先于其他编程语言。
- en: 'The rabbit hole of macros in Lisps goes deep enough that there are entire books
    that talk about them. *Mastering Clojure Macros* by *Colin Jones* is one among
    these, and this publication describes the various patterns in which macros can
    be used in great detail. In this chapter, we will explore the foundational concepts
    behind macros and their usage. We will:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 中的宏有很深的“兔子洞”，以至于有整本书都在讨论它们。"Mastering Clojure Macros"（精通 Clojure 宏）由 "Colin
    Jones" 编著，这本书详细描述了宏可以使用的各种模式。在本章中，我们将探讨宏背后的基础概念及其用法。我们将：
- en: First, have a look at the basics of reading, evaluating, and transforming code
    in Clojure.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Clojure 中读取、评估和转换代码的基础知识。
- en: Later on, we will examine how macros can be defined and used, and also study
    several examples based on macros. We will also describe how we can handle platform-specific
    code using *reader conditionals*.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将研究如何定义和使用宏，并基于宏研究几个示例。我们还将描述如何使用 *reader conditionals* 来处理特定平台的代码。
- en: Understanding the reader
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解读者
- en: The reader is responsible for interpreting Clojure code. It performs several
    steps to translate source code in textual representation into executable machine
    code. In this section, we will briefly describe these steps performed by the reader
    to illustrate how the reader works.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 读者负责解释 Clojure 代码。它执行多个步骤将源代码在文本表示形式转换为可执行机器代码。在本节中，我们将简要描述读者执行的这些步骤，以说明读者是如何工作的。
- en: 'Clojure and other languages from the Lisp family are **homoiconic**. In a homoiconic
    language, the source code of a program is represented as a plain data structure.
    This means that all the code written in a Lisp language is simply a bunch of nested
    lists. Thus, we can manipulate programs'' code just like any other list of values.
    Clojure has a few more data structures, such as vectors and maps in its syntax,
    but they can be handled just as easily. In languages that are not homoiconic,
    any expression or statement in a program has to be translated into an internal
    data structure termed as a *parse tree*, or *syntax tree*, when the program is
    compiled or interpreted. In Lisps, however, an expression is already in the form
    of a syntax tree, since a tree is really just another name for a nested list.
    In other words, there is no distinction between an expression and the syntax tree
    it produces. One might also opine that this design tricks programmers into writing
    code directly as a syntax tree. This distinguishing aspect of Lisps is succinctly
    captured by the following axiom: *Code is Data*.'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure和其他Lisp家族的语言是**同构的**。在同构语言中，程序的源代码被表示为普通的数据结构。这意味着用Lisp语言编写的所有代码只是一系列嵌套的列表。因此，我们可以像操作任何其他值列表一样操作程序的代码。Clojure有几种更多的数据结构，如其语法中的向量和映射，但它们可以同样容易地处理。在非同构语言中，程序中的任何表达式或语句在编译或解释程序时都必须被转换为一个称为*解析树*或*语法树*的内部数据结构。然而，在Lisp中，一个表达式已经是以语法树的形式存在的，因为树实际上只是嵌套列表的另一个名称。换句话说，表达式和它产生的语法树之间没有区别。有人也可能认为这种设计让程序员直接以语法树的形式编写代码。Lisp的这个独特方面被以下公理简洁地概括：*代码即数据*。
- en: 'Let''s first take a look at the most rudimentary representation of code and
    data in Lisps—an **s-expression**. Any expression comprises of *values* and *symbols*,
    where the symbols represent variables being used. A nested list of symbols is
    known as a *symbolic expression*, *s-expression*, or *sexp*. All source code in
    Clojure is represented as s-expressions. A symbolic expression is formally defined
    as:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看Lisp中代码和数据的最基本表示——**s表达式**。任何表达式都由*值*和*符号*组成，其中符号代表正在使用的变量。符号的嵌套列表被称为*符号表达式*、*s表达式*或*sexp*。Clojure中的所有源代码都表示为s表达式。符号表达式正式定义为：
- en: An atom, which refers to a single symbol or literal value.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子，指的是单个符号或字面值。
- en: A combination of two s-expressions `x` and `y`, represented as `(x . y)`. Here,
    the dot (`.`) is used to signify a `cons` operation.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个s表达式`x`和`y`的组合，表示为`(x . y)`。在这里，点（`.`）用来表示`cons`操作。
- en: Using this recursive definition, a list of symbols `(x y z)` is represented
    by the s-expression, `(x . (y . (z . nil)))` or `(x . (y . z))`. When an s-expression
    is used to represent source code, the first element of the expression represents
    the function used, and the rest of the elements are the arguments to the function.
    Of course, this is just a theoretical representation and not really Clojure code.
    This representation is also called *prefix notation*. This recursive structure
    of s-expressions is flexible enough to represent both code as well as data. In
    fact, s-expressions are more-or-less the only form of syntax in Clojure (and other
    Lisps). For example, if we wanted to add two numbers, we would use an expression
    with the `+` function as the first symbol, followed by the values to be added.
    Similarly, if we wanted to define a function, we would have to write an expression
    with `defn` or `def` as the first symbol in the expression. In Clojure and other
    Lisps, we also represent data such as lists, vectors, and maps using s-expressions.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种递归定义，符号列表`(x y z)`被表示为s表达式`(x . (y . (z . nil)))`或`(x . (y . z))`。当s表达式用来表示源代码时，表达式的第一个元素代表使用的函数，其余元素是该函数的参数。当然，这只是一个理论上的表示，并不是真正的Clojure代码。这种表示也称为*前缀表示法*。s表达式的这种递归结构足够灵活，可以表示代码和数据。事实上，s表达式几乎是Clojure（和其他Lisp）中唯一的语法形式。例如，如果我们想加两个数，我们会使用一个以`+`函数作为第一个符号的表达式，后面跟着要加的值。同样，如果我们想定义一个函数，我们必须编写一个以`defn`或`def`作为表达式中第一个符号的表达式。在Clojure和其他Lisp中，我们使用s表达式表示数据，如列表、向量和映射。
- en: 'Let''s look at a simple example that depicts how Clojure code is interpreted.
    The expression `(-> [0 1 2] first inc)` that uses a threading macro (`->`) will
    be interpreted in three distinct steps. This expression will be read, *macroexpanded*,
    and evaluated to the value `1`, as illustrated here:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，说明 Clojure 代码是如何被解释的。使用线程宏 (`->`) 的表达式 `(-> [0 1 2] first inc)`
    将被解释为三个不同的步骤。这个表达式将被读取，*宏展开*，并计算为值 `1`，如下所示：
- en: '![Understanding the reader](img/B05024_04_01.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![理解读取器](img/B05024_04_01.jpg)'
- en: The reader will first parse textual representations of s-expressions from a
    Clojure program's source code. Once a program's source code is read into s-expressions,
    all macro calls in the code are replaced by their definitions. This transformation
    of macro calls in a program is called *macroexpansion*. Lastly, the resulting
    s-expressions from the macroexpansion phase are evaluated by the Clojure runtime.
    In the evaluation phase, bytecode is generated from the supplied expressions,
    loaded into memory, and executed. In short, code in a program's source code is
    read, transformed through macros, and finally evaluated. Also, macroexpansion
    happens immediately after a program's source code is parsed, thus allowing the
    program to internally transform itself before it is evaluated. This transformation
    of code is exactly what macros are used to achieve.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器首先从 Clojure 程序的源代码中解析 s-表达式的文本表示。一旦程序源代码被读取为 s-表达式，代码中的所有宏调用都将被它们的定义所替换。程序中宏调用的这种转换称为
    *宏展开*。最后，宏展开阶段产生的 s-表达式将由 Clojure 运行时进行评估。在评估阶段，从提供的表达式生成字节码，加载到内存中，并执行。简而言之，程序源代码中的代码被读取，通过宏进行转换，最终被评估。此外，宏展开在程序源代码解析后立即发生，因此允许程序在评估之前内部转换自身。这种代码的转换正是宏被用来实现的目的。
- en: Note
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, the reader only reads code and performs macroexpansion. The generation
    of bytecode is done by the analyzer and the emitter, and this generated bytecode
    is evaluated by the JVM.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，读取器只读取代码并执行宏展开。字节码的生成由分析器和生成器完成，并且这个生成的字节码由 JVM 进行评估。
- en: 'All Clojure code is translated to *reader forms* and *special forms* before
    it is evaluated. Special forms are constructs, such as `quote` and `let*`, that
    are implemented directly as bytecode for the underlying runtime, such as the JVM
    for Clojure or the Rhino JavaScript runtime for ClojureScript. Interestingly,
    Clojure source code is composed mostly of reader forms, and these reader forms
    are implemented in Clojure itself. The reader also transforms certain characters
    and forms called *reader macros* as soon as they are read. There are several reader
    macros in the Clojure language, as described in the following table:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Clojure 代码在评估之前都被转换为 *读取形式* 和 *特殊形式*。特殊形式是直接作为底层运行时（如 Clojure 的 JVM 或 ClojureScript
    的 Rhino JavaScript 运行时）的字节码实现的构造，例如 `quote` 和 `let*`。有趣的是，Clojure 源代码主要由读取形式组成，这些读取形式在
    Clojure 本身中得到实现。读取器还会在读取时立即转换某些字符和称为 *读取宏* 的形式。Clojure 语言中有几个读取宏，如下表所述：
- en: '| Reader macro | Usage |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| 读取宏 | 用法 |'
- en: '| --- | --- |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\x` | This is a character literal. |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| `\x` | 这是一个字符字面量。 |'
- en: '| `;` | This is used to comment. It ignores the rest of the line. |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 这用于注释。它忽略该行的其余部分。 |'
- en: '| `(.method o)` | This is a native method call. It is rewritten to a dot (`.`)
    form as `(. o method)`. Also, `o` must be a native object. |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| `(.method o)` | 这是一个本地方法调用。它被重写为点 (`.`) 形式，作为 `(. o method)`。此外，`o` 必须是一个本地对象。
    |'
- en: '| `@x` or `@( ... )` | This is the dereference operator. It is used with reference
    types and is rewritten to a `deref` form. |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| `@x` 或 `@( ... )` | 这是解引用运算符。它与引用类型一起使用，并被重写为 `deref` 形式。 |'
- en: '| `^{ ... }` | This is the metadata map to be used with a form. It is rewritten
    to a `with-meta` form. |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| `^{ ... }` | 这是与形式一起使用的元数据映射。它被重写为 `with-meta` 形式。 |'
- en: '| `''x` or `''( ... )` | This is a quote. |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| `''x` 或 `''( ... )` | 这是一个引用。 |'
- en: '| `` `x `` or `` `( ... ) `` | This is a syntax quote. |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| `` `x `` 或 `` `( ... ) `` | 这是一个语法引用。 |'
- en: '| `~x` or `~( ... )` | This is used to unquote. |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| `~x` 或 `~( ... )` | 这用于非引用。 |'
- en: '| `~@x` or `~@( ... )` | This is a splicing unquote. |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| `~@x` 或 `~@( ... )` | 这是一个切片非引用。 |'
- en: '| `#_x` or `#_( ... )` | This ignores the next form. `#_` should be preferred
    over the `comment` form to comment out code, since comment actually returns `nil`.
    |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| `#_x` 或 `#_( ... )` | 这忽略下一个形式。`#_` 应该比 `comment` 形式更优先用于注释代码，因为注释实际上返回 `nil`。
    |'
- en: '| `#''x` | This is a var quote. It is equivalent to `(var x)`. |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| `#''x` | 这是一个变量引用。它等同于 `(var x)`。 |'
- en: '| `#=x` or `#=( ... )` | This will read-evaluate an expression. |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| `#=x` 或 `#=( ... )` | 这将读取并评估一个表达式。|'
- en: '| `#?( ... )` | This is a reader conditional form. |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| `#?( ... )` | 这是一种读者条件形式。|'
- en: '| `#?@( ... )` | This is a reader conditional splicing form. |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| `#?@( ... )` | 这是一种读者条件拼接形式。|'
- en: We have encountered quite a few of the preceding reader macros in the previous
    chapters. We will demonstrate the usage of several reader forms that are used
    with macros in this chapter.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经遇到了很多前面的读取器宏。我们将在本章中演示与宏一起使用的几个读取形式的用法。
- en: Note
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, Clojure does not support user-defined reader
    macros.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Clojure不支持用户定义的读取器宏。
- en: Now that we have familiarized ourselves with the Clojure reader and how code
    is interpreted, let's explore the various metaprogramming constructs that help
    us read and evaluate code.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Clojure的读取器和代码的解析方式，让我们探索各种元编程结构，这些结构帮助我们读取和评估代码。
- en: Reading and evaluating code
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读和评估代码
- en: 'Let''s have a look at how code can be parsed and evaluated in Clojure. The
    most elementary way to convert text into an expression is by using the `read`
    function. This function accepts a `java.io.PushbackReader` instance as its first
    argument, as shown here:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Clojure中代码是如何被解析和评估的。将文本转换为表达式的最基本方法是通过使用`read`函数。该函数将其第一个参数作为`java.io.PushbackReader`实例接受，如下所示：
- en: '[PRE190]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples can be found in `src/m_clj/c4/read_and_eval.clj` of the book's
    source code.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在书籍源代码的`src/m_clj/c4/read_and_eval.clj`中找到。
- en: In this example, a string containing a valid expression is first converted into
    an instance of `java.io.PushbackReader` and then passed to the `read` function.
    It seems like a lot of unnecessary work to read a string, but it is due to the
    fact that the `read` function deals with streams and readers, and not strings.
    If no arguments are passed to the `read` function, it will create a reader from
    the standard input and prompt the user to enter an expression to be parsed. The
    `read` function has several other options as well, and you are encouraged to explore
    these options in the REPL on their own.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个包含有效表达式的字符串首先被转换为`java.io.PushbackReader`的实例，然后传递给`read`函数。读取字符串似乎是一个很多不必要的步骤，但这是因为`read`函数处理流和读取器，而不是字符串。如果没有向`read`函数传递任何参数，它将创建一个从标准输入创建的读取器，并提示用户输入要解析的表达式。`read`函数还有其他几个选项，鼓励您在REPL上自行探索这些选项。
- en: 'A simpler way to read an expression from a string is by using the `read-string`
    function. This function accepts a string as its only argument and converts the
    supplied string into an expression, as shown here:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串中读取表达式的更简单的方法是使用`read-string`函数。该函数接受一个字符串作为其唯一参数，并将提供的字符串转换为表达式，如下所示：
- en: '[PRE191]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The `read` and `read-string` forms can only convert strings into valid expressions.
    If we have to evaluate an expression, we must use the `eval` function, as shown
    here:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`和`read-string`形式只能将字符串转换为有效的表达式。如果我们必须评估一个表达式，我们必须使用`eval`函数，如下所示：'
- en: '[PRE192]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: In the first statement in the preceding output, we prevent the expression `(list
    1 2 3)` from being evaluated before it is passed to the `eval` function using
    the quote operator (`'`). This technique is termed as *quoting* and we shall explore
    more of it later in this chapter. The `eval` function evaluates the expression
    `(list 1 2 3)` to the list `(1 2 3)`. Similarly, in the second statement, the
    expression `(list + 1 2 3)` is first evaluated as `(+ 1 2 3)` by the reader, and
    then the `eval` function evaluates this list to the value `6`. In the third statement,
    the string `"(+ 1 2 3)"` is first parsed by the `read-string` function and then
    evaluated by the `eval` function.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中的第一行语句中，我们使用引号运算符（`'`）防止在传递给`eval`函数之前评估表达式`(list 1 2 3)`。这种技术被称为*引用*，我们将在本章后面进一步探讨。`eval`函数将表达式`(list
    1 2 3)`评估为列表`(1 2 3)`。同样，在第二行中，表达式`(list + 1 2 3)`首先被读取器评估为`(+ 1 2 3)`，然后`eval`函数将这个列表评估为值`6`。在第三行中，字符串`"(+
    1 2 3)"`首先被`read-string`函数解析，然后由`eval`函数评估。
- en: 'The read-evaluate macro (`#=`) can be used to force the `read` and `read-string`
    functions to evaluate an expression when it is parsed, as shown here:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`read-evaluate`宏（`#=`）可以用来强制`read`和`read-string`函数在解析时评估一个表达式，如下所示：'
- en: '[PRE193]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'In the preceding output, the `#=` reader macro evaluates the expression `(list
    1 2 3)` when it is read by the `read` and `read-string` functions. If the `#=`
    macro was not used, both statements would return the expression `(list 1 2 3)`
    in verbatim. We can also use the `#=` macro without using `read` or `read-string`,
    in which case it would be equivalent to calling the `eval` function. Also, the
    calls to the `#=` macro can be nested any number of times, as shown here:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`#=` 读取宏在由 `read` 和 `read-string` 函数读取时评估表达式 `(list 1 2 3)`。如果没有使用 `#=`
    宏，两个语句都会返回表达式 `(list 1 2 3)` 的字面值。我们也可以在不使用 `read` 或 `read-string` 的情况下使用 `#=`
    宏，在这种情况下，它将等同于调用 `eval` 函数。此外，对 `#=` 宏的调用可以嵌套任意次数，如下所示：
- en: '[PRE194]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The `#=` macro makes it easy to evaluate expressions while they are being read.
    Oh wait! This is a potential security hazard as the `read` and `read-string` functions
    are evaluating arbitrary strings, even if they contain any malicious code. Thus,
    evaluation of code while it is being parsed is deemed unsafe. As a solution to
    this problem, the `*read-eval*` var can be set to `false` to prevent usage of
    the `#=` macro, as shown here:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`#=` 宏使得在读取表达式时评估它们变得容易。哦，等等！这是一个潜在的安全隐患，因为 `read` 和 `read-string` 函数正在评估任意字符串，即使它们包含任何恶意代码。因此，在解析时评估代码被认为是不安全的。为了解决这个问题，可以将
    `*read-eval*` 变量设置为 `false` 以防止使用 `#=` 宏，如下所示：'
- en: '[PRE195]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Thus, use of the `#=` macro in strings passed to the `read` and `read-string`
    functions will throw an error if `*read-eval*` is set to `false`. Obviously, the
    default value of this var is `true`. For this reason, we must avoid using the
    `#=` macro, or set the `*read-eval*` var to `false`, while processing the user
    input.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 `*read-eval*` 设置为 `false` 时，在传递给 `read` 和 `read-string` 函数的字符串中使用 `#=`
    宏将会引发错误。显然，这个变量的默认值是 `true`。因此，我们必须避免使用 `#=` 宏，或者在处理用户输入时将 `*read-eval*` 变量设置为
    `false`。
- en: 'Another way to read and evaluate arbitrary strings is by using the `load-string`
    function. This function has the same arity as the `read-string` function, and
    is equivalent to calling the `eval` and `read-string` forms, as shown here:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种读取和评估任意字符串的方法是使用 `load-string` 函数。这个函数与 `read-string` 函数具有相同的arity，并且与调用
    `eval` 和 `read-string` 形式等价，如下所示：
- en: '[PRE196]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: There are a couple of semantic differences between using the `load-string` form
    and a composition of the `eval` and `read-string` forms. Firstly, the behavior
    of the `load-string` function is not affected by the changing `*read-eval*` var,
    and is thus unsafe for use with arbitrary user input.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `load-string` 形式与 `eval` 和 `read-string` 形式的组合之间存在一些语义上的差异。首先，`load-string`
    函数的行为不受 `*read-eval*` 变量的变化影响，因此对于任意用户输入的使用是不安全的。
- en: 'A more important difference is that the `read-string` function only parses
    the first expression it encounters in the string that it has passed. The `load-string`
    function will parse and evaluate all expressions passed to it, as shown here:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更重要的区别是，`read-string` 函数只解析它传递的字符串中遇到的第一个表达式。`load-string` 函数将解析并评估传递给它的所有表达式，如下所示：
- en: '[PRE197]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: In the preceding output, the `read-string` form skips the second `println` form
    in the string that it is passed, thus printing the value `1` only. The `load-string`
    form, however, parses and evaluates both the `println` forms it is passed as a
    string, and prints both the values `1` and `2`.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`read-string` 形式跳过了它传递的字符串中的第二个 `println` 形式，因此只打印了值 `1`。然而，`load-string`
    形式会解析并评估它作为字符串传递的 `println` 形式，并打印出值 `1` 和 `2`。
- en: The `load-reader` function is analogous to the `read` function, in the sense
    that it accepts a `java.io.PushbackReader` instance, from which it has to read
    and evaluate forms, as an argument. Another variant of `load-string` is the `load-file`
    function, to which we can pass the path of a file that contains source code. The
    `load-file` function will parse the file in the path that it is passed and evaluate
    all forms present in it.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`load-reader` 函数类似于 `read` 函数，因为它接受一个 `java.io.PushbackReader` 实例作为参数，必须从这个实例中读取和评估形式。`load-string`
    的另一个变体是 `load-file` 函数，我们可以传递包含源代码的文件路径给它。`load-file` 函数将解析它传递的路径中的文件，并评估其中所有形式。'
- en: Note
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `*file*` var can be used to obtain the path of the current file
    being executed.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以使用 `*file*` 变量来获取正在执行文件的路径。
- en: So far, we have seen how code can be parsed and evaluated by the Clojure reader.
    There are several constructs that can be used to perform these tasks. However,
    evaluating arbitrary strings is not really a good idea, as the code being evaluated
    is insecure and may be malicious. In practice, we should always set the `*read-eval*`
    variable to `false` in order to prevent the evaluation of arbitrary code by functions
    such as `read` and `read-string`. Next, we will explore how *quoting* and *unquoting*
    can be used to transform expressions.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Clojure读取器如何解析和评估代码。有几个结构可以用来执行这些任务。然而，评估任意字符串并不是一个好主意，因为被评估的代码是不安全的，可能是恶意的。在实践中，我们应该始终将`*read-eval*`变量设置为`false`，以防止`read`和`read-string`等函数评估任意代码。接下来，我们将探讨如何使用*引用*和*取消引用*来转换表达式。
- en: Quoting and unquoting code
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和取消引用代码
- en: We will now explore *quoting* and *unquoting*, which are techniques used to
    generate expressions based on a predefined template for an expression. These techniques
    are foundational in creating macros, and they help structure the code of a macro
    to look more like its macroexpanded form.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨*引用*和*取消引用*，这些是用于根据表达式的预定义模板生成表达式的技术。这些技术在创建宏时是基础性的，并且有助于使宏的代码看起来更像其宏展开形式。
- en: Note
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c4/` `quoting.clj` of the
    book's source code.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书的源代码的`src/m_clj/c4/`目录下的`quoting.clj`文件中找到。
- en: 'The `quote` form simply returns an expression without evaluating it. This may
    seem trivial, but preventing the evaluation of an expression is actually something
    that is not possible in all programming languages. The `quote` form is abbreviated
    using the apostrophe character (`''`). If we *quote* an expression, it is returned
    in verbatim, as shown here:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote`形式简单地返回一个表达式而不对其进行评估。这看起来可能微不足道，但防止表达式评估实际上并不是所有编程语言都可能做到的。`quote`形式使用撇号字符（`''`）缩写。如果我们*引用*一个表达式，它将按原样返回，如下所示：'
- en: '[PRE198]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The `quote` form is quite historic in Lisp. It is one of the seven primitive
    operators in the original Lisp language, as described in John McCarthy's paper.
    Incidentally, `quote` is one among the rare special forms that are implemented
    in Java and not in Clojure itself. The `quote` form is used to handle variable
    names, or *symbols*, as values. In a nutshell, using the `quote` form, we can
    treat a given expression as a list of symbols and values. After all, *Code is
    Data*.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote`形式在Lisp中相当历史悠久。它是原始Lisp语言中的七个原始运算符之一，如约翰·麦卡锡的论文中所述。顺便提一下，`quote`是少数在Java中实现而在Clojure自身中未实现的特殊形式之一。`quote`形式用于处理变量名，或*符号*，作为值。简而言之，使用`quote`形式，我们可以将给定的表达式视为符号和值的列表。毕竟，*代码即数据*。'
- en: Note
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An apostrophe (`'`) represents a quoted expression only when it appears as the
    first character in the expression. For example, `x'` is just a variable name.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 撇号（`'`）仅当它作为表达式的第一个字符出现时才表示一个引用表达式。例如，`x'`只是一个变量名。
- en: 'A syntax quote, written as a backtick character (`` ` ``), will quote an expression
    and allows *unquoting* to be performed within it. This construct allows us to
    create expressions just like quoting, but also has the added benefit of letting
    us interpolate values and execute arbitrary code in a quoted form. This has the
    effect of treating a predefined expression as a template with some parts left
    blank to be filled in later. An expression within a syntax quoted form can be
    unquoted using the tidal character (`~`). Unquoting an expression will evaluate
    it and insert the result into the surrounding syntax quoted form. A *splicing
    unquote*, written as `~@`, can be used to evaluate an expression that returns
    a list and use the returned list of values as arguments for a form. This is something
    like what the `apply` form does, except that it''s within the context of a syntax
    quote. We must note that both of these unquoting operations (`~` and `~@`) can
    only be used within a syntax quoted form. We can try out these operations in the
    REPL, as shown here:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 语法引号，写作反引号字符（`` ` ``），将引用一个表达式并允许在内部执行取消引用。这个构造允许我们创建与引用类似的表达式，同时还有额外的优势，即允许我们在引用形式中插入值和执行任意代码。这相当于将预定义的表达式视为模板，其中一些部分留空以供以后填充。在语法引用形式中的表达式可以使用潮汐字符
    (`~`) 进行取消引用。取消引用表达式将评估它并将结果插入到周围的语法引用形式中。切片取消引用，写作 `~@`，可以用来评估返回列表的表达式，并使用返回的值列表作为形式的参数。这类似于
    `apply` 形式的功能，但它是语法引号上下文中的。我们必须注意，这两种取消引用操作（`~` 和 `~@`）只能在语法引号形式中使用。我们可以在 REPL
    中尝试这些操作，如下所示：
- en: '[PRE199]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'As shown here, unquoting the variable `a` in the preceding syntax quoted `list`
    form returns the expression `(list 1 2 3)`. Similarly, using a splicing unquote
    with the vector `[1 2 3]` returns the same list. On the other hand, unquoting
    a variable in a quoted form will expand the unquote reader macro (`~`) to a `clojure.core/unquote`
    form, as shown here:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，在先前的语法引用 `list` 形式中取消引用变量 `a` 返回表达式 `(list 1 2 3)`。同样，使用切片取消引用向量 `[1 2
    3]` 也返回相同的列表。另一方面，在引用形式中取消引用变量将展开取消引用读取宏 (`~`) 为 `clojure.core/unquote` 形式，如下所示：
- en: '[PRE200]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'A more interesting difference between using a quote and a syntax quote is that
    the latter will resolve all variable names to namespace-qualified names. This
    applies to function names as well. For example, let''s look at the following expressions:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引号和语法引号之间更有趣的区别是，后者将解析所有变量名到具有命名空间限定名的名称。这也适用于函数名。例如，让我们看看以下表达式：
- en: '[PRE201]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: As shown in the preceding output, the variables `x`, `y`, and `z` are resolved
    to `user/x`, `user/y`, and `user/z` respectively by the syntax quoted form, since
    `user` is the current namespace. Also, the `vector` function is translated to
    its namespace-qualified name, shown as `clojure.core/vector`. The unquote and
    quote operations in succession, shown as `~'`, can be used to bypass the resolution
    of a symbol to a namespace-qualified name.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示输出，变量 `x`、`y` 和 `z` 通过引用语法被解析为 `user/x`、`user/y` 和 `user/z`，因为 `user` 是当前命名空间。此外，`vector`
    函数被转换为具有命名空间限定名的名称，显示为 `clojure.core/vector`。连续使用 `~'` 操作可以用来绕过将符号解析为具有命名空间限定名的名称。
- en: 'Quoting is supported on data structures other than lists, such as vectors,
    sets, and maps, as well. The effect of a syntax quote is the same on all of the
    data structures; it allows expressions to be unquoted within it, thus transforming
    the quoted form. Also, quoted forms can be nested, as in a quoted forms can contain
    other quoted forms. In such a case, the deepest quoted form is processed first.
    Consider the following quoted vectors:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 引用不仅支持列表，还支持其他数据结构，如向量、集合和映射。语法引号对所有数据结构的效果相同；它允许在内部取消引用表达式，从而转换引用形式。此外，引用形式可以嵌套，例如，一个引用形式可以包含其他引用形式。在这种情况下，最深的引用形式首先被处理。考虑以下引用向量：
- en: '[PRE202]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'There are a lot of interesting aspects that can be inferred from the preceding
    output. Firstly, keywords are apparently not interned to namespace-qualified names
    such as symbols. In fact, this behavior is exhibited by any value that evaluates
    to itself, such as keywords, `nil`, `true`, and `false`, when used in a syntax
    quoted form. Other than that, unquoting followed by quoting an expression in a
    syntax quote, shown as `''~(+ 1 2)`, will evaluate the expression and wrap it
    in a quote. Conversely, unquoting a quoted symbol, shown as `~''b`, will prevent
    it from being resolved to a namespace-qualified name as we mentioned earlier.
    Let''s take a look at another example that uses nested quoting, as shown here:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以推断出很多有趣的地方。首先，关键字显然没有被内部化到命名空间限定名称，如符号。实际上，任何评估为自身的值，如关键字、`nil`、`true`和`false`，在语法引号形式中使用时都会表现出这种行为。除此之外，在语法引号中先unquote然后quote一个表达式，如`'~(+
    1 2)`，将评估该表达式并将其用quote包裹。相反，unquote一个quote过的符号，如`~'b`，将防止它像我们之前提到的那样解析为命名空间限定名称。让我们看看另一个使用嵌套quote的例子，如下所示：
- en: '[PRE203]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: In the preceding output, the variables `first`, `second`, and `xs` are prevented
    from being interned to a namespace-qualified names using the quote (`'`) and unquote
    (`~`) operations in tandem. Anyone who's used older Lisps is probably cringing
    at this point. In practice, usage of the `~'` operation should actually be avoided.
    This is because preventing the resolution of a variable to a namespace-qualified
    name isn't really a good idea. In fact, unlike Clojure, some Lisps completely
    disallow it. It causes a peculiar problem called *symbol capture*, which we will
    see ahead while we explore macros.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，变量`first`、`second`和`xs`通过结合使用quote（`'`）和unquote（`~`）操作来防止被内部化到命名空间中。任何使用过较老Lisp的人可能在这个时候都会感到不舒服。实际上，应该避免使用`~'`操作。这是因为防止变量解析为命名空间限定名称并不是一个好主意。实际上，与Clojure不同，一些Lisp完全不允许这样做。这会导致一个称为*符号捕获*的特殊问题，我们将在探索宏的时候看到。
- en: Transforming code
  id: totrans-824
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码转换
- en: As previously described in this chapter, it's trivial to read and evaluate code
    in Clojure using the `read` and `eval` functions and their variants. Instead of
    evaluating code right after it is parsed, we can use macros to first transform
    code programmatically using quoting and unquoting, and then evaluate it. Thus,
    macros help us define our own constructs that rewrite and transform expressions
    passed to them. In this section, we will explore the basics of creating and using
    macros.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章之前所述，使用`read`和`eval`函数及其变体在Clojure中读取和评估代码是微不足道的。我们可以在解析代码后立即评估它，而不是使用宏首先通过quote和unquote程序性地转换代码，然后再评估它。因此，宏帮助我们定义自己的结构，这些结构可以重写和转换传递给它们的表达式。在本节中，我们将探讨创建和使用宏的基本知识。
- en: Expanding macros
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开宏
- en: Macros need to be *expanded* when they are called. All Clojure code is read,
    macroexpanded, and evaluated by the reader as we described earlier. Let's now
    take a look at how macroexpansion is performed. As you may have guessed already,
    this is done using plain Clojure functions.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在调用时需要被**展开**。所有Clojure代码都是按照我们之前描述的方式，由读取器读取、宏展开和评估的。现在让我们看看宏展开是如何进行的。正如你可能已经猜到的，这是通过普通的Clojure函数来完成的。
- en: 'Interestingly, the reader of the Clojure runtime also uses these functions
    to process a program''s source code. As an example, we will examine how the `->`
    threading macro is macroexpanded. The `->` macro can be used as shown here:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Clojure运行时的读取器也使用这些函数来处理程序的源代码。作为一个例子，我们将检查`->`连接宏是如何宏展开的。`->`宏可以像下面这样使用：
- en: '[PRE204]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Note
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples can be found in `src/m_clj/c4/macroexpand.clj` of the book's
    source code.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子可以在书籍源代码的`src/m_clj/c4/macroexpand.clj`中找到。
- en: 'All of the three expressions using the `->` macro in the preceding output will
    be evaluated to the value `1`. This is due to the fact that they are all macroexpanded
    to produce the same final expression. How can we claim that? Well, we can prove
    it using the `macroexpand-1`, `macroexpand`, and `clojure.walk/macroexpand-all`
    functions. The `macroexpand` function returns the complete macroexpansion of a
    form, as shown here:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中使用`->`宏的所有三个表达式都将被评估为值`1`。这是因为它们都被宏展开为相同的最终表达式。我们如何证明这一点呢？嗯，我们可以使用`macroexpand-1`、`macroexpand`和`clojure.walk/macroexpand-all`函数来证明。`macroexpand`函数返回一个形式的完整宏展开，如下所示：
- en: '[PRE205]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The expression using the `->` threading macro is thus transformed to the expression
    `(inc (first [0 1 2]))`, which evaluates to the value `1`. In this way, the `macroexpand`
    function allows us to inspect the macroexpanded form of an expression.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `->` 连接宏的表达式因此被转换为 `(inc (first [0 1 2]))` 表达式，该表达式计算出的值为 `1`。这样，`macroexpand`
    函数允许我们检查表达式的宏展开形式。
- en: 'The `macroexpand-1` function returns the first expansion of a macro. In fact,
    the `macroexpand` function simply applies the `macroexpand-1` function repeatedly
    until no more macroexpansion can be performed. We can inspect how the expression
    `(-> [0 1 2] (-> first inc))` is macroexpanded using these functions:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`macroexpand-1` 函数返回宏的第一个展开。实际上，`macroexpand` 函数只是重复应用 `macroexpand-1` 函数，直到无法再进行宏展开。我们可以使用这些函数检查
    `(-> [0 1 2] (-> first inc))` 表达式的宏展开过程：'
- en: '[PRE206]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The `macroexpand` function has a small limitation. It only repeatedly macroexpands
    an expression until the first form in the expression is a macro. Hence, the `macroexpand`
    function will not completely macroexpand the expression `(-> (-> [0 1 2] first)
    inc)`, as shown here:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '`macroexpand` 函数有一个小的限制。它只重复宏展开一个表达式，直到表达式的第一个形式是宏。因此，`macroexpand` 函数不会完全宏展开
    `(-> (-> [0 1 2] first) inc)` 表达式，如下所示：'
- en: '[PRE207]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'As shown in the preceding example, the `macroexpand` function will return the
    same macroexpansion as `macroexpand-1`. This is because the second call to the
    `->` macro is not the first form in the result of the first macroexpansion for
    the previous expression. In such cases, we can use the `macroexpand-all` function
    from the `clojure.walk` namespace to macroexpand a given expression regardless
    of the positions of macro calls in it, as shown here:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`macroexpand` 函数将返回与 `macroexpand-1` 相同的宏展开结果。这是因为对 `->` 宏的第二次调用不是前一个表达式的第一次宏展开结果中的第一个形式。在这种情况下，我们可以使用
    `clojure.walk` 命名空间中的 `macroexpand-all` 函数来宏展开给定表达式，无论宏调用在其中的位置如何，如下所示：
- en: '[PRE208]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Thus, all three expressions using the `->` macro as examples are macroexpanded
    to the same expression `(inc (first [0 1 2]))`, which is evaluated to the value
    `1`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `->` 宏作为示例的所有三个表达式都被宏展开为相同的表达式 `(inc (first [0 1 2]))`，该表达式计算出的值为 `1`。
- en: Note
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `macroexpand-1`, `macroexpand`, and `clojure.walk/macroexpand-all` functions
    will have no effect on an expression that does not contain any macros.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`macroexpand-1`、`macroexpand` 和 `clojure.walk/macroexpand-all` 函数对不包含任何宏的表达式没有任何影响。'
- en: The `macroexpand-1` and `macroexpand` functions are indispensable tools for
    debugging user-defined macros. Additionally, the `clojure.walk/macroexpand-all`
    function can be used in situations where the `macroexpand` function does not completely
    macroexpand a given expression. The Clojure reader also uses these functions for
    macroexpanding a program's source code.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '`macroexpand-1` 和 `macroexpand` 函数是调试用户定义宏的不可或缺的工具。此外，`clojure.walk/macroexpand-all`
    函数可以在 `macroexpand` 函数无法完全宏展开给定表达式的情况下使用。Clojure 读取器也使用这些函数来宏展开程序的源代码。'
- en: Creating macros
  id: totrans-845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建宏
- en: Macros are defined using the `defmacro` form. A macro name, a vector of arguments
    for the macro, an optional doc-string, and the body of the macro have to be passed
    to this form. We can also specify multiple arities for a macro. Its similarity
    to the `defn` form is quite obvious. Unlike a `defn` form, however, a macro defined
    using the `defmacro` form will not evaluate the arguments passed to it. In other
    words, the arguments passed to a macro are implicitly quoted. For example, we
    can create a couple of macros to rewrite an s-expression in infix and postfix
    notation, as shown in *Example 4.1*.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是通过 `defmacro` 形式定义的。宏名、宏的参数向量、可选的文档字符串和宏的主体必须传递给此形式。我们还可以指定宏的多个可变性。它与 `defn`
    形式的相似性非常明显。然而，与 `defn` 形式不同的是，使用 `defmacro` 形式定义的宏不会评估传递给它的参数。换句话说，传递给宏的参数是隐式引用的。例如，我们可以创建几个宏来重写中缀和后缀表示法中的
    s 表达式，如 *示例 4.1* 所示。
- en: '[PRE209]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '*Example 4.1: Macros to transform a prefix expression*'
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.1：将前缀表达式转换的宏*'
- en: Note
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples can be found in `src/m_clj/c4/defmacro.clj` of the book's source
    code.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在书籍源代码的 `src/m_clj/c4/defmacro.clj` 中找到。
- en: 'Each of the macros in *Example 4.1* describes an elegant way to rewrite an
    expression `expr` by treating it as a generic sequence. The function being called
    in the expression `expr` is extracted using the `first` form, and its arguments
    are obtained using the `rest` form. To convert the expression to its infix form,
    we use the `interpose` function. Similarly, the `postfix` form of the expression
    `expr` is generated using the `concat` form. We can use the `macroexpand` function
    to inspect the expression generated by the `to-infix` and `to-postfix` macros,
    as shown here:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例4.1*中的每个宏都描述了一种优雅的重写表达式`expr`的方法，将其视为一个通用序列。在表达式`expr`中调用的函数使用`first`形式提取，其参数使用`rest`形式获得。要将表达式转换为其中缀形式，我们使用`interpose`函数。同样，表达式`expr`的后缀形式使用`concat`形式生成。我们可以使用`macroexpand`函数来检查`to-infix`和`to-postfix`宏生成的表达式，如下所示：'
- en: '[PRE210]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Note
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The expression `x + y` is said to be written in an *infix* notation. The *prefix*
    notation of this expression is `+ x y`, and its *postfix* notation is `x y +`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`x + y`被称为是使用*中缀*表示法书写的。这个表达式的*前缀*表示法是`+ x y`，而其*后缀*表示法是`x y +`。
- en: In this way, by transforming expressions we can effectively modify the language.
    It's that simple! The basis of the `to-infix` and `to-postfix` macros in *Example
    4.1* are that we can treat the terms of an expression as a sequence of elements
    and manipulate them by using sequence functions such as `interpose` and `concat`.
    Of course, the preceding example was simple enough such that we could avoid the
    use of quoting altogether. The `defmacro` form can also be used in combination
    with quoting to easily rewrite more complex expressions. The same rule can be
    applied to *any* form of Clojure code.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转换表达式，我们可以有效地修改语言。就这么简单！*示例4.1*中`to-infix`和`to-postfix`宏的基础是，我们可以将表达式的项视为一个元素序列，并使用诸如`interpose`和`concat`之类的序列函数来操作它们。当然，前面的例子足够简单，以至于我们可以完全避免使用引号。`defmacro`形式也可以与引号结合使用，以便轻松重写更复杂的表达式。同样的规则可以应用于Clojure代码的任何形式。
- en: 'Interestingly, macros are internally represented as functions, and this can
    be verified by dereferencing the fully qualified name of a macro and using the
    `fn?` function, as shown here:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，宏在内部表示为函数，这可以通过取消引用宏的完全限定名称并使用`fn?`函数来验证，如下所示：
- en: '[PRE211]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Note
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'At the time of writing this book, ClojureScript only supports macros written
    in Clojure. Macros have to be referenced using the `:require-macros` keyword in
    a ClojureScript namespace declaration, as shown here:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的时候，ClojureScript只支持用Clojure编写的宏。宏必须使用`:require-macros`关键字在ClojureScript命名空间声明中引用，如下所示：
- en: '[PRE212]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'The `symbol` and `gensym` functions can be used to create temporary variables
    for use within the body of a macro. The `symbol` function returns a symbol from
    a name and an optional namespace, as shown here:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol`和`gensym`函数可以用来在宏体内部创建临时变量。`symbol`函数从一个名称和一个可选的命名空间返回一个符号，如下所示：'
- en: '[PRE213]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Note
  id: totrans-863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can check whether a value is a symbol using the `symbol?` predicate.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`symbol?`谓词来检查一个值是否是符号。
- en: 'The `gensym` function can be used to create a unique symbol name. We can specify
    a prefix to be used for the returned symbol name to the `gensym` function. The
    prefix is defaulted to a capital `G` character followed by two underscores (`G__`).
    The `gensym` function can also be used to create a new unique keyword. We can
    try out the `gensym` function in the REPL, as shown here:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '`gensym` 函数可以用来创建一个唯一的符号名称。我们可以指定一个前缀，用于`gensym`函数返回的符号名称。默认的前缀是一个大写字母`G`后跟两个下划线（`G__`）。`gensym`函数还可以用来创建一个新的唯一关键字。我们可以在REPL中尝试`gensym`函数，如下所示：'
- en: '[PRE214]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'As shown here, the `gensym` function creates a new symbol every time it is
    called. In a syntax quoted form, we can use an automatic symbol name created from
    a prefixed name and the `gensym` function by using the hash character (`#`), shown
    as follows:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，每次调用`gensym`函数时，它都会创建一个新的符号。在语法引号形式中，我们可以使用由前缀名称和`gensym`函数创建的自动符号名称，如下所示：
- en: '[PRE215]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Note
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `let` form is, in fact, a macro defined using the `let*` special form.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`形式实际上是一个使用`let*`特殊形式定义的宏。'
- en: As shown in the preceding expression, all occurrences of the *auto-gensym* variable
    `x#` in the syntax quoted form are replaced with an automatically generated symbol
    name. We should note that only symbols, and not strings or keywords, can be used
    as a prefix for an auto-gensym symbol.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的表达式所示，语法引号形式中所有出现的 *自动生成符号* 变量 `x#` 都被替换为自动生成的符号名称。我们应该注意，只有符号，而不是字符串或关键字，可以用作自动生成符号的前缀。
- en: 'By generating unique symbols in this way, we can create *hygenic macros*, which
    avoid the possibility of *symbol capture* or *variable capture*, which is an interesting
    problem that arises with the use of dynamically scoped variables and macros. To
    illustrate this problem, consider the macros defined in *Example 4.2*:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式生成唯一的符号，我们可以创建 *卫生宏*，这些宏避免了 *符号捕获* 或 *变量捕获* 的可能性，这是一个在使用动态作用域变量和宏时出现的有趣问题。为了说明这个问题，考虑
    *示例 4.2* 中定义的宏：
- en: '[PRE216]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '*Example 4.2: Macros to depict symbol capture*'
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.2：表示符号捕获的宏*'
- en: 'The macros in *Example 4.2* create a new list using a `list` form and the value
    `x`. Of course, we wouldn''t really need to use a macro here, but it is only done
    for the sake of demonstrating symbol capture. The `to-list-with-capture` macro
    *captures* the variable `x` from the surrounding scope by the use of the `~''`
    operation. If we use a `let` form to bind the variable name `x` with a value,
    we will get different results on calling the `to-list` and `to-list-with-capture`
    macros, as shown here:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4.2* 中的宏使用 `list` 形式和值 `x` 创建一个新的列表。当然，我们在这里实际上并不需要使用宏，但这样做只是为了演示符号捕获。`to-list-with-capture`
    宏通过使用 `~''` 操作从周围作用域 *捕获* 变量 `x`。如果我们使用 `let` 形式将变量名 `x` 绑定到一个值，那么在调用 `to-list`
    和 `to-list-with-capture` 宏时将得到不同的结果，如下所示：'
- en: '[PRE217]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The `to-list-with-capture` function seems to dynamically obtain the value of
    `x` from the surrounding scope, and not from the parameter passed to it. As you
    may have guessed, this can lead to a number of subtle and bizarre bugs. In Clojure,
    the solution to this problem is simple; a syntax quoted form will resolve all
    free symbols to namespace-qualified names. This can be verified by macroexpanding
    the expression that uses the `to-list` function in the preceding example.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '`to-list-with-capture` 函数似乎会从周围的作用域动态获取 `x` 的值，而不是从传递给它的参数中获取。正如你可能猜到的，这可能会导致许多微妙且奇怪的错误。在
    Clojure 中，这个问题的解决方案很简单；一个语法引号形式会将所有自由符号解析为命名空间限定名称。这可以通过宏展开前一个示例中使用 `to-list`
    函数的表达式来验证。'
- en: 'Let''s say we would like to use a temporary variable using a `let` form with
    a macro that performs the same task as the `to-list` macro from *Example 4.2*.
    This may seem rather unnecessary, but it is only being done to demonstrate how
    symbols are resolved by a syntax quote. Such a macro can be implemented as shown
    in *Example 4.3*:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用一个宏来执行与 *示例 4.2* 中的 `to-list` 宏相同任务的 `let` 形式来使用一个临时变量。这看起来可能相当没有必要，但这样做只是为了演示语法引号如何解析符号。这样的宏可以像
    *示例 4.3* 中所示那样实现：
- en: '[PRE218]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Calling the `to-list-with-error` macro will result in an error due to the use
    of the free symbol `y`, as shown here:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `to-list-with-error` 宏会导致错误，因为使用了自由符号 `y`，如下所示：
- en: '[PRE219]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This error can be quite annoying, as we simply intended to use a temporary
    variable in the body of the `to-list-with-error` macro. This error occurred because
    it is not clear where the variable `y` is resolved from. To get around this error,
    we can declare the variable `y` as an auto-gensym variable, as shown in *Example
    4.4*:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误可能相当令人烦恼，因为我们只是想在 `to-list-with-error` 宏的主体中使用一个临时变量。这个错误发生是因为不清楚变量 `y`
    是从哪里解析出来的。为了绕过这个错误，我们可以将变量 `y` 声明为自动生成符号变量，如 *示例 4.4* 中所示：
- en: '[PRE220]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '*Example 4.4: A macro that uses a let form and an auto-gensym variable*'
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.4：使用 let 形式和自动生成符号变量的宏*'
- en: 'The `to-list-with-gensym` macro works as expected without any error, as shown
    here:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`to-list-with-gensym` 宏按预期工作，没有任何错误，如下所示：'
- en: '[PRE221]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: We can also inspect the expression generated by the `to-list-with-gensym` macro
    using the `macroexpand` and `macroexpand-1` forms, and the reader is encouraged
    to try this in the REPL.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `macroexpand` 和 `macroexpand-1` 形式来检查 `to-list-with-gensym` 宏生成的表达式，鼓励读者在
    REPL 中尝试这样做。
- en: To summarize, macros defined using the `defmacro` form can be used to rewrite
    and transform code. Syntax quote and auto-gensym variables can be used to write
    hygenic macros that avoid certain problems that can arise due the use of dynamic
    scope.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 `defmacro` 形式定义的宏可以用来重写和转换代码。语法引号和自动生成符号变量可以用来编写卫生宏，从而避免由于动态作用域的使用而可能出现的某些问题。
- en: Note
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Syntax quote can actually be implemented as a user defined macro. Libraries
    such as `syntax-quote` ([https://github.com/hiredman/syntax-quote](https://github.com/hiredman/syntax-quote))
    and `backtick` ([https://github.com/brandonbloom/backtick](https://github.com/brandonbloom/backtick))
    demonstrate how syntax quote can be implemented through macros.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 语法引用实际上可以作为一个用户定义的宏来实现。例如，`syntax-quote` ([https://github.com/hiredman/syntax-quote](https://github.com/hiredman/syntax-quote))
    和 `backtick` ([https://github.com/brandonbloom/backtick](https://github.com/brandonbloom/backtick))
    库展示了语法引用是如何通过宏来实现的。
- en: Encapsulating patterns in macros
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在宏中封装模式
- en: In Clojure, macros can be used to rewrite expressions in terms of functions
    and special forms. However, in languages such as Java and C#, there is a lot of
    additional syntax added to the language for handling special forms. For example,
    consider the `if` construct in these languages, which is used to check whether
    an expression is true or not. This construct does have some special syntax. If
    a recurring pattern of usage of the `if` construct is found in a program written
    in these languages, there is no obvious way to automate this pattern. Languages
    such as Java and C# have the concept of *design patterns* that encapsulate these
    sort of patterns. But without the ability to rewrite expressions, encapsulating
    patterns in these languages can get a bit incomplete and cumbersome. The more
    special forms and syntax we add to a language, the harder it gets to programmatically
    generate code for the language. On the other hand, macros in Clojure and other
    Lisps can easily rewrite expressions to automate recurring patterns in code. Also,
    there is more-or-less no special syntax for code in Lisps, as code and data are
    one and the same. In a way, macros in Lispy languages allow us to concisely encapsulate
    design patterns by extending the language with our own hand-made constructs.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，可以使用宏来用函数和特殊形式重写表达式。然而，在Java和C#等语言中，为了处理特殊形式，语言中添加了大量的额外语法。例如，考虑这些语言中的`if`构造，它用于检查表达式是否为真。这个构造确实有一些特殊的语法。如果在用这些语言编写的程序中发现了`if`构造的重复使用模式，就没有明显的方法来自动化这个模式。Java和C#等语言有*设计模式*的概念，可以封装这类模式。但是，如果没有重写表达式的功能，在这些语言中封装模式可能会变得有些不完整和繁琐。我们向语言中添加的特别形式和语法越多，程序化生成代码就越困难。另一方面，Clojure和其他Lisp中的宏可以轻松地重写表达式，以自动化代码中的重复模式。此外，在Lisp中，代码和数据是一致的，因此几乎没有代码的特殊语法。从某种意义上说，Lispy语言中的宏通过扩展语言以我们自己的手工构造来允许我们简洁地封装设计模式。
- en: Let's explore a few examples that demonstrate how macros can be used to encapsulate
    patterns. The `->` and `->>` threading macros in Clojure are used to compose several
    functions together by passing in an initial value. In other words, the initial
    value is *threaded* through the various forms that are passed as arguments to
    the `->` and `->>` macros. These macros are defined in the `clojure.core` namespace
    as part of the Clojure language, as shown in *Example 4.5*.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些示例，以展示宏如何被用来封装模式。Clojure中的`->`和`->>`线程宏通过传递一个初始值来组合几个函数。换句话说，初始值是通过`->`和`->>`宏的参数传递的各种形式进行*线程化*的。这些宏作为Clojure语言的一部分定义在`clojure.core`命名空间中，如*示例4.5*所示。
- en: Note
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c4/threading.clj` of the book's
    source code.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c4/threading.clj`中找到。
- en: '[PRE222]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '*Example 4.5: The -> and ->> threading macros*'
  id: totrans-897
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例4.5：->和->>线程宏*'
- en: 'The `->` and `->>` macros in *Example 4.5* use a `loop` form to recursively
    thread a value `x` through the expressions represented by `forms`. The first symbol
    in a form, that is the function being called, is determined using the `first`
    function. The arguments to be passed in this function, other than `x`, are extracted
    using the `next` function. If a form is just a function name without any additional
    arguments, we create a new form using the expression `(list form x)`. The `with-meta`
    form is used to preserve any metadata specified with `form`. The `->` macro passes
    `x` as the first argument, whereas `->>` passes `x` as the last argument. This
    is done in a recursive manner for all the forms passed to these macros. Interestingly,
    syntax quoted forms are used sparingly by both of the `->` and `->>` macros. We
    can actually refactor out some parts of these macros into functions. This adds
    a slight advantage as functions can be tested quite easily compared to macros.
    The `->` and `->>` threading macros can be refactored as shown in *Example 4.6*
    and *Example 4.7*:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4.5* 中的 `->` 和 `->>` 宏使用 `loop` 形式递归地将值 `x` 线程通过由 `forms` 表示的表达式。一个形式中的第一个符号，即被调用的函数，是通过使用
    `first` 函数确定的。除了 `x` 之外，要传递给此函数的参数是通过 `next` 函数提取的。如果一个形式只是一个不带任何额外参数的函数名，我们则使用表达式
    `(list form x)` 创建一个新的形式。`with-meta` 形式用于保留使用 `form` 指定的任何元数据。`->` 宏将 `x` 作为第一个参数传递，而
    `->>` 宏将 `x` 作为最后一个参数传递。这是以递归方式对所有传递给这些宏的形式进行的。有趣的是，`->` 和 `->>` 宏都很少使用语法引用形式。我们实际上可以将这些宏的一些部分重构为函数。这带来了一点点优势，因为与宏相比，函数可以很容易地进行测试。`->`
    和 `->>` 线程宏可以重构如 *示例 4.6* 和 *示例 4.7* 所示：'
- en: '[PRE223]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '*Example 4.6: Refactoring the -> and ->> threading macros*'
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.6: 重构 -> 和 ->> 线程宏*'
- en: 'The `thread-form` function in *Example 4.6* positions the value `x` in the
    expression form using the `conj` function. The premise here is that the `conj`
    function will add an element in the head of a list and at the end or tail of a
    vector. The `first?` argument is used to indicate whether the value `x` has to
    be passed as the first argument to `form`. The `threading` function simply applies
    the `thread-form` function to all the expressions passed to it, represented by
    `forms`. The macros `->` and `->>` can now be implemented using the `threading`
    function as shown in *Example 4.7*:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4.6* 中的 `thread-form` 函数使用 `conj` 函数在表达式形式中定位值 `x`。这里的假设是 `conj` 函数将在列表的头部添加一个元素，或在向量的末尾或尾部添加一个元素。`first?`
    参数用于指示值 `x` 是否需要作为 `form` 的第一个参数传递。`threading` 函数简单地将 `thread-form` 函数应用于它接收到的所有表达式，即
    `forms`。现在可以使用 `threading` 函数实现 `->` 和 `->>` 宏，如 *示例 4.7* 所示：'
- en: '[PRE224]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '*Example 4.7: Refactoring the -> and ->> threading macros (continued)*'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.7: 重构 -> 和 ->> 线程宏（续）*'
- en: The threading macros defined in *Example 4.7* work just as well as the ones
    in *Example 4.5*, and we can verify this in the REPL. This is left as an exercise
    for the reader.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 4.7* 中定义的线程宏与 *示例 4.5* 中的宏效果一样好，我们可以在 REPL 中验证这一点。这被留作读者的练习。
- en: A common pattern of usage of the `let` form is to repeatedly rebind a variable
    to new values by passing it through several functions. This kind of pattern can
    be encapsulated using the `as->` threading macro, which is defined as shown in
    *Example 4.8*.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 表达式的常见用法是通过将变量传递给多个函数来反复重新绑定其值。这种模式可以使用 `as->` 线程宏进行封装，该宏的定义如 *示例 4.8*
    所示。'
- en: '[PRE225]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '*Example 4.8: Refactoring the -> and ->> threading macros*'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 4.8: 重构 -> 和 ->> 线程宏*'
- en: 'Let''s skip past explaining the details of the `as->` macro through words and
    simply describe the code it generates using the `macroexpand` function, as shown
    here:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过用文字解释 `as->` 宏的细节，而直接使用 `macroexpand` 函数描述它生成的代码，如下所示：
- en: '[PRE226]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The `as->` macro binds its first argument to a symbol represented by its second
    argument and generates a `let*` form as a result. This allows us to define expressions
    that have to be threaded over in terms of an explicit symbol. One might even say
    it's a more flexible way to perform the threading of a value through several expressions,
    as compared to using the `->` and `->>` macros.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '`as->` 宏将其第一个参数绑定到由其第二个参数表示的符号，并生成一个 `let*` 形式作为结果。这允许我们以显式符号的形式定义必须在线程中传递的表达式。甚至可以说，与使用
    `->` 和 `->>` 宏相比，这是一种更灵活的方式来执行通过多个表达式传递值的线程操作。'
- en: Note
  id: totrans-911
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `as->` form has been introduced in Clojure 1.5 along with several other
    threading macros.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '`as->` 形式是在 Clojure 1.5 中引入的，与其他几个线程宏一起。'
- en: Thus, macros are great tools in automating or encapsulating patterns in code.
    Several commonly used forms in the Clojure language are actually defined as macros,
    and we can just as easily define our own macros.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，宏是自动化或封装代码中模式的强大工具。Clojure语言中一些常用的形式实际上被定义为宏，我们也可以轻松地定义自己的宏。
- en: Using reader conditionals
  id: totrans-914
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用读取条件
- en: It is often necessary to interoperate with native objects in Clojure and its
    dialects such as ClojureScript. We can define platform-specific code using *reader
    conditionals*. Let's now briefly take a look at how we can use reader conditionals.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure及其方言（如ClojureScript）中，经常需要与原生对象进行交互。我们可以使用*读取条件*来定义特定平台的代码。现在让我们简要地看看我们如何使用读取条件。
- en: Note
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reader conditionals have been introduced in Clojure 1.7\. Prior to version 1.7,
    platform-specific Clojure/ClojureScript code had to be managed using the `cljx`
    library ([https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)).
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 读取条件在Clojure 1.7版本中被引入。在版本1.7之前，特定平台的Clojure/ClojureScript代码必须使用`cljx`库（[https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)）来管理。
- en: The *reader conditional form*, written as `#?( ... )`, allows us to define platform-specific
    code using the `:cljs`, `:clj`, `:clr`, and `:default` keywords. The *reader conditional
    splicing form*, written as `#?@( ... )`, has semantics similar to a reader conditional
    form. It can be used to splice a list of platform-specific values or expressions
    into a form. Both these conditional forms are processed when code is read, instead
    of when it is macroexpanded.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '*读取条件形式*，写作`#?( ... )`，允许我们使用`:cljs`、`:clj`、`:clr`和`:default`关键字来定义特定平台的代码。*读取条件拼接形式*，写作`#?@(
    ... )`，具有与读取条件形式类似的语义。它可以用来将特定平台的值或表达式列表拼接到一个形式中。这两个条件形式在读取代码时被处理，而不是在宏展开时。'
- en: 'Since Clojure 1.7, the `read-string` function has a second arity in which we
    can specify a map as an argument. This map can have two keys, `:read-cond` and
    `:features`. When a string containing a conditional form is passed to the `read-string`
    function, platform-specific code can be generated by specifying the platform as
    a set of keywords, represented by `:cljs`, `:clj`, or `:clr`, with the `:features`
    key in the map of options. In this case, the keyword `:allow` must be specified
    for the key `:read-cond` in the map passed to the `read-string` function, or else
    an exception will be thrown. We can try out the reader conditional form with the
    `read-string` function in the REPL as shown here:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 自Clojure 1.7以来，`read-string`函数有一个第二个参数，我们可以指定一个映射作为参数。这个映射可以有两个键，`:read-cond`和`:features`。当包含条件形式的字符串传递给`read-string`函数时，可以通过在映射的`:features`键中指定平台作为一组关键字（由`:cljs`、`:clj`或`:clr`表示）来生成特定平台的代码。在这种情况下，必须指定关键字`:allow`作为传递给`read-string`函数的映射中`:read_cond`键的值，否则将抛出异常。我们可以在REPL中使用`read-string`函数尝试读取条件形式，如下所示：
- en: '[PRE227]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Note
  id: totrans-921
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples can be found in `src/m_clj/c4/reader_conditionals.cljc` of the
    book's source code.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在书籍源代码的`src/m_clj/c4/reader_conditionals.cljc`中找到。
- en: 'Similarly, we can read a conditional splicing form into an expression with
    the `read-string` function as shown here:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`read-string`函数将条件拼接形式读取到一个表达式中，如下所示：
- en: '[PRE228]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We can also prevent the transformation of conditional forms by specifying the
    `:preserve` keyword with the `:read-cond` key in the optional map passed to the
    `read-string` function, as shown here:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在传递给`read-string`函数的可选映射中指定`:preserve`关键字和`:read-cond`键来防止条件形式的转换，如下所示：
- en: '[PRE229]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'However, wrapping conditional forms in a string is not really something we
    should be doing in practice. Generally, we should write all platform-specific
    code as reader conditional forms in source files with the `.cljc` extension. Once
    the top-level forms defined in the `.cljc` file are processed by the Clojure reader,
    we can use them just like any other reader forms. For example, consider the macro
    written using a reader conditional form in *Example 4.9*:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际操作中，将条件形式包裹在字符串中并不是我们应该做的事情。通常，我们应该将所有特定平台的代码作为读取条件形式写入具有`.cljc`扩展名的源文件中。一旦`.cljc`文件中定义的顶层形式被Clojure读取器处理，我们就可以像使用任何其他读取形式一样使用它们。例如，考虑在*示例4.9*中使用读取条件形式编写的宏：
- en: '[PRE230]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '*Example 4.9: A macro using a reader conditional*'
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例4.9：使用读取条件的宏*'
- en: 'The `get-milliseconds-since-epoch` macro in *Example 4.9* calls the `.getTime`
    method on a new `java.util.Date` instance when called from the Clojure code. Also,
    this macro calls the `.getTime` method on a new JavaScript `Date` object when
    used in ClojureScript code. We can macroexpand a call to the `get-milliseconds-since-epoch`
    macro from the Clojure REPL to generate JVM-specific code, as shown here:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例4.9*中，`get-milliseconds-since-epoch`宏在从Clojure代码调用时，会在新的`java.util.Date`实例上调用`.getTime`方法。此外，当在ClojureScript代码中使用时，此宏也会在新的JavaScript`Date`对象上调用`.getTime`方法。我们可以从Clojure
    REPL中宏展开对`get-milliseconds-since-epoch`宏的调用，以生成特定于JVM的代码，如下所示：
- en: '[PRE231]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Thus, reader conditionals help in encapsulating platform-specific code to be
    used in code that is agnostic of the underlying platform.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，读取条件有助于封装特定于平台的代码，以便在不受底层平台影响的代码中使用。
- en: Avoiding macros
  id: totrans-933
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用宏
- en: 'Macros are an extremely flexible way of defining our own constructs in Clojure.
    However, careless use of macros in a program can become complicated and lead to
    a number of strange bugs that are hidden from plain sight. As described in the
    book, *Programming Clojure* by *Stuart Halloway* and *Aaron Bedra*, the usage
    of macros in Clojure has two thumb rules:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是定义Clojure中我们自己的结构的一种极其灵活的方式。然而，在程序中不小心使用宏可能会变得复杂，并导致许多隐藏在视线之外的奇怪错误。正如*Stuart
    Halloway*和*Aaron Bedra*在《Programming Clojure》一书中所描述的，Clojure中宏的使用有两个经验法则：
- en: '**Don''t write macros**: Anytime we try to use a macro, we must think twice
    whether we could perform the same task using a function.'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要编写宏**：每次我们尝试使用宏时，我们必须三思是否可以使用函数来完成相同的任务。'
- en: '**Write macros if it''s the only way to encapsulate a pattern**: A macro must
    be used only if it is easier or more convenient than calling a function.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果它是封装模式的唯一方法，则编写宏**：只有当宏比调用函数更容易或更方便时，才应使用宏。'
- en: 'What''s the problem with macros? Well, macros complicate a program''s code
    in several ways:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的问题是什么？嗯，宏以几种方式使程序的代码变得复杂：
- en: Macros cannot be composed like functions as they are not really values. It's
    not possible to pass a macro as an argument to the `map` or `apply` forms, for
    example.
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏不能像函数那样组合，因为它们实际上不是值。例如，不可能将宏作为参数传递给`map`或`apply`形式。
- en: Macros cannot be tested as easily as functions. Though it can be done programmatically,
    the only way to test macros is by using macroexpansion functions and quoting.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏不像函数那样容易测试。虽然可以通过编程方式完成，但测试宏的唯一方法是通过使用宏展开函数和引用。
- en: In some cases, code that calls a macro may have been written as a macro itself,
    thus adding more complexity to our code.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，调用宏的代码可能本身就是作为宏编写的，从而增加了我们代码的复杂性。
- en: Hidden bugs caused by problems such as symbol capture make macros a little tricky.
    Debugging macros isn't really easy either, especially in a large codebase.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由符号捕获等问题引起的隐藏错误使宏变得有些棘手。在大型代码库中调试宏也不是很容易。
- en: For these reasons, macros have to be used carefully and responsibly. In fact,
    if we can solve a problem using macros as well functions, we should always prefer
    the solution that uses functions. If the use of a macro is indeed required, we
    should always strive to refactor out as much code as possible from a macro into
    a function.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，宏必须谨慎和负责任地使用。实际上，如果我们可以使用宏和函数解决同一个问题，我们应该始终优先选择使用函数的解决方案。如果确实需要使用宏，我们应该始终努力将尽可能多的代码从宏中重构到函数中。
- en: That aside, macros make programming a lot of fun as they allow us to define
    our own constructs. They allow a degree of freedom and liberty that is not really
    possible in other languages. You may hear a lot of seasoned Clojure programmers
    tell you that macros are evil and you should never use them, but don't let that
    stop you from exploring what is possible with macros. Once you encounter and tackle
    some of the problems that arise with the use of macros, you will have enough experience
    to be able to decide when macros can be used appropriately.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，宏使编程变得很有趣，因为它们允许我们定义自己的结构。它们提供了一种在其他语言中实际上不可能的自由和灵活性。你可能经常听到经验丰富的Clojure程序员告诉你宏是邪恶的，你不应该使用它们，但不要让这一点阻止你探索宏所能实现的可能性。一旦你遇到并解决了使用宏时出现的一些问题，你将拥有足够的经验来判断何时适当地使用宏。
- en: Summary
  id: totrans-944
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have explored how metaprogramming is possible with Clojure in this chapter.
    We discussed how code is read, macroexpanded, and evaluated, as well as the various
    primitive constructs that implement these operations. Macros can be used to encapsulate
    patterns in code, as we demonstrated in the various examples in this chapter.
    Toward the end of the chapter, we also talked about reader conditionals and pointed
    out the various complications that arise with the use of macros.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中探讨了如何在Clojure中使用元编程。我们讨论了代码是如何被读取、宏展开和评估的，以及实现这些操作的各个原始构造。宏可以用来封装代码中的模式，正如我们在本章的各个示例中所展示的那样。在章节的结尾，我们还讨论了读取条件，并指出了使用宏时出现的各种复杂情况。
- en: In the following chapter, we will explore how transducers can be used to process
    any data regardless of the source of the data.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用转换器处理任何数据，无论数据源是什么。
- en: Chapter 5. Composing Transducers
  id: totrans-947
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。组合转换器
- en: Let's get back to our journey of performing computations over data in Clojure.
    We've already discussed how *reducers* can be used to process collections in [Chapter
    3](ch18.html "Chapter 3. Parallelization Using Reducers"), *Parallelization Using
    Reducers*. Transducers are, in fact, a generalization of reducers that are independent
    of the source of data. Also, reducers are more about parallelization, while transducers
    are more focused on generalizing data transformations without restricting us to
    any particular source of data. Transducers capture the essence of the standard
    functions that operate on sequences, such as `map` and `filter`, for several sources
    of data. They allow us to define and compose transformations of data regardless
    of how the data is supplied to us.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到在Clojure中执行数据计算之旅。我们已经在[第3章](ch18.html "第3章。使用归约器进行并行化")中讨论了如何使用**归约器**来处理集合，即*并行化使用归约器*。实际上，转换器是归约器的一种推广，它独立于数据源。此外，归约器更多地关于并行化，而转换器则更专注于泛化数据转换，而不限制我们使用任何特定的数据源。转换器捕捉了在序列上操作的标准函数（如`map`和`filter`）的本质，适用于多个数据源。它们允许我们定义和组合数据转换，而不管数据是如何提供给我们的。
- en: Incidentally, in the context of physics, a transducer is a device that converts
    a signal from one form of energy into another form. In a way, Clojure transducers
    can be thought of as ways to capture the *energy* in functions, such as `map`
    and `filter`, and convert between different sources of data. These sources include
    collections, streams, and asynchronous channels. Transducers can also be extended
    to other sources of data. In this chapter, we will focus on how transducers can
    be used for sequences and collections, and will reserve discussing transducers
    with asynchronous channels until we talk about the `core.async` library in [Chapter
    8](ch23.html "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous
    Tasks*. Later in this chapter, we will study how transducers are implemented in
    Clojure.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在物理学的背景下，转换器是一种将一种形式的能量转换为另一种形式的设备。从某种意义上说，Clojure转换器可以被看作是捕获函数中的*能量*（如`map`和`filter`），并在不同数据源之间进行转换的方法。这些数据源包括集合、流和异步通道。转换器也可以扩展到其他数据源。在本章中，我们将重点关注如何使用转换器处理序列和集合，并将讨论与异步通道相关的转换器留到我们讨论[第8章](ch23.html
    "第8章。利用异步任务")的`core.async`库时再进行。稍后在本章中，我们将研究转换器在Clojure中的实现方式。
- en: Understanding transducers
  id: totrans-950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解转换器
- en: Transducers are essentially a stack of transformations that can be composed
    and applied to *any* representation of data. They allow us to define transformations
    that are agnostic of implementation-specific details about the source of the supplied
    data. Transducers also have a significant performance benefit. This is attributed
    to the avoidance of unnecessary memory allocations for arbitrary containers, such
    as sequences or other collections, to store intermediate results between transformations.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '转换器本质上是一系列可以组合并应用于*任何*数据表示的转换。它们允许我们定义与数据源实现特定细节无关的转换。转换器还有显著的性能优势。这归因于避免了在转换之间存储中间结果时对任意容器（如序列或其他集合）进行不必要的内存分配。 '
- en: Note
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Transducers have been introduced in Clojure 1.7.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器是在Clojure 1.7中引入的。
- en: Transformations can be composed without the use of transducers as well. This
    can be done using the `comp` and `partial` forms. We can pass any number of transformations
    to the `comp` function, and the transformation returned by the `comp` function
    will be a composition of the supplied transformations in the right-to-left order.
    In Clojure, a transformation is conventionally denoted as `xf` or `xform`.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不使用transducer的情况下组合转换。这可以通过使用`comp`和`partial`形式来完成。我们可以将任意数量的转换传递给`comp`函数，`comp`函数返回的转换将是按照从右到左的顺序提供的转换的组合。在Clojure中，转换传统上表示为`xf`或`xform`。
- en: Note
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c5/transduce.clj` of the book's
    source code.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c5/transduce.clj`中找到。
- en: 'For example, the expression `(comp f g)` will return a function that applies
    the function `g` to its input and then applies the function `f` to the result.
    The `partial` function will bind a function to any number of arguments and return
    a new function. The `comp` function can be used with a `partial` form to compose
    the `map` and `filter` functions, as shown here:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(comp f g)`将返回一个函数，该函数首先将函数`g`应用于其输入，然后将函数`f`应用于结果。`partial`函数可以将函数绑定到任意数量的参数并返回一个新的函数。`comp`函数可以与`partial`形式一起使用来组合`map`和`filter`函数，如下所示：
- en: '[PRE232]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'In the preceding output, the `partial` function is used to bind the `inc` and
    `even?` functions to the `map` and `filter` functions respectively. The functions
    returned by both the `partial` forms shown above will expect a collection to be
    passed to them. Thus, they represent transformations that can be applied to a
    given collection. These two transformations are then composed with the `comp`
    function to create a new function `xf-using-partial`. This function is then applied
    to a vector of numbers to return a sequence of even numbers. There are a few issues
    with this code:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`partial`函数被用来将`inc`和`even?`函数分别绑定到`map`和`filter`函数上。上面显示的两种`partial`形式返回的函数都将期望传递给它们的集合。因此，它们代表了可以应用于给定集合的转换。这两个转换随后与`comp`函数组合，创建一个新的函数`xf-using-partial`。然后，这个函数被应用于一个数字向量，以返回一个偶数序列。这段代码存在一些问题：
- en: The filtering of even numbers using the `even?` function is performed after
    applying the `inc` function. This proves that the transformations passed to the
    `comp` function are applied in the right-to-left order, which is the reverse of
    the order in which they are specified. This can be a little inconvenient at times.
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`even?`函数过滤偶数是在应用`inc`函数之后进行的。这证明了传递给`comp`函数的转换是按照从右到左的顺序应用的，这与它们指定的顺序相反。有时这可能会有些不方便。
- en: The value returned by the `xf-using-partial` function is a list and not a vector.
    This is because the `map` and `filter` function both return lazy sequences, which
    are ultimately converted into lists. Thus, the use of the `vec` function has no
    effect on the type of collection returned by the `xf-using-partial` function.
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xf-using-partial`函数返回的值是一个列表而不是向量。这是因为`map`和`filter`函数都返回惰性序列，最终会被转换成列表。因此，使用`vec`函数对`xf-using-partial`函数返回的集合类型没有影响。'
- en: Also, the transformation `(partial map inc)` applied by the `xf-using-partial`
    function will create a new sequence. This resulting sequence is then passed to
    the transformation `(partial filter even?)`. The intermediate use of a sequence
    is both unnecessary and wasteful in terms of memory if we have several transformations
    that must be composed.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`xf-using-partial`函数应用的转换`(partial map inc)`将创建一个新的序列。这个生成的序列随后被传递给转换`(partial
    filter even?)`。如果我们有多个必须组合的转换，那么在内存方面，中间使用序列既不必要也是浪费的。
- en: This brings us to transducers, which address the preceding problems related
    to composing transformations using the `comp` and `partial` forms. In the formal
    sense, a transducer is a function that modifies a *step function*. This step function
    is analogous to a reducing function in the context of reducers. A step function
    combines an input value with the accumulated result of a given computation. A
    transducer accepts a step function as an argument and produces a modified version
    of it. In fact, the `xf` and `xform` notations are also used to represent a transducer;
    because a transducer is also a transformation, it transforms a step function.
    While it may be hard to illustrate without any code, this modification of a step
    function performed by a transducer actually depicts how some input data is consumed
    by a given computation to produce a result. Several transducers can also be composed
    together. In this way, transducers can be thought of as a unified model to process
    data.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了转换器，它解决了使用 `comp` 和 `partial` 形式组合转换所涉及的前述问题。在正式意义上，转换器是一个修改 *步骤函数* 的函数。这个步骤函数在
    reducer 的上下文中类似于一个归约函数。步骤函数将输入值与给定计算的累积结果相结合。转换器接受一个步骤函数作为参数，并产生其修改后的版本。实际上，`xf`
    和 `xform` 语法也用来表示转换器；因为转换器也是一种转换，它转换步骤函数。虽然没有代码可能难以说明，但转换器执行的步骤函数的这种修改实际上描绘了某些输入数据是如何被给定计算消耗以产生结果的。几个转换器也可以组合在一起。这样，转换器可以被视为处理数据的一个统一模型。
- en: 'Several of the standard Clojure functions return a transducer when they are
    called with a single argument. These functions either:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准的 Clojure 函数在用单个参数调用时返回转换器。这些函数要么：
- en: Accept a function along with a collection as arguments. Examples of such functions
    are `map`, `filter`, `mapcat`, and `partition-by`.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个函数以及一个集合作为参数。此类函数的例子有 `map`、`filter`、`mapcat` 和 `partition-by`。
- en: Accept a value indicating the number of elements, usually specified as `n`,
    along with a collection. This category includes functions such as `take`, `drop`,
    and `partition-all`.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个表示元素数量的值，通常指定为 `n`，以及一个集合。这个类别包括 `take`、`drop` 和 `partition-all` 等函数。
- en: Note
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [http://clojure.org/transducers](http://clojure.org/transducers) for the
    complete list of standard functions that implement transducers.
  id: totrans-968
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问 [http://clojure.org/transducers](http://clojure.org/transducers) 获取实现转换器的完整标准函数列表。
- en: The use of transducers can be aptly depicted by Rich Hickey's baggage loading
    example. Suppose we intend to load several bags into an airplane. The bags will
    be supplied in pallets, which can be thought of as collections of bags. There
    are several steps that have to be performed to load the bags into the airplane.
    Firstly, the bags must be unbundled from the supplied pallets. Next, we must check
    whether a bag contains any food, and not process it any further if it does. Finally,
    all the bags must be weighed and labeled in case they are heavy. Note that these
    steps needed to load the bags into the airplane do not specify how the pallets
    are supplied to us, or how the labeled bags from the final step are transported
    to the plane.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: Rich Hickey 的行李装载示例很好地描述了转换器的使用。假设我们打算将几个行李装入飞机。这些行李将以托盘的形式提供，可以将其视为行李的集合。要将行李装入飞机，必须执行几个步骤。首先，必须将行李从提供的托盘上解开。接下来，我们必须检查一个行李是否包含任何食物，如果不包含，则不再进一步处理。最后，所有行李都必须称重并贴上标签，以防它们很重。请注意，这些将行李装入飞机的步骤并没有指定托盘是如何提供给我们，或者标签过的行李是如何从最后一步运输到飞机上的。
- en: 'We can model the process of loading the bags into the plane as shown in the
    `process-bags` function in *Example 5.1*, as follows:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将将行李装入飞机的过程建模为 *示例 5.1* 中的 `process-bags` 函数所示，如下所示：
- en: '[PRE233]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '*Example 5.1: Loading bags into an airplane*'
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.1：将行李装入飞机*'
- en: 'The functions `unbundle-pallet`, `non-food?`, and `label-heavy` in *Example
    5.1* represent the three steps of loading bags into an airplane. These functions
    are applied to a collection of bags using the `map`, `filter`, and `mapcat` functions.
    Also, they can be composed using the `comp` and `partial` functions in a right-to-left
    order. As we described earlier, the `map`, `filter`, and `mapcat` functions will
    all produce sequences on being called, hence creating intermediate collections
    of bags between the three transformations. This intermediate use of sequences
    is analogous to putting all the bags on trollies after the step is performed.
    The supplied input and the final result would both be a bag of trollies. The use
    of trollies not only incurs additional work between the steps of our process,
    but the steps are now convoluted with the use of trollies. Thus, we would have
    to redefine these steps if we had to use, say, conveyer belts instead of trollies
    to transport the baggage. This means that the `map`, `filter`, and `mapcat` functions
    would have to be implemented again if we intend to produce a different type of
    collection as a final result. Alternatively, we can use transducers to implement
    the `process-bags` function without specifying the type of collection of either
    the input or the result, as shown in *Example 5.2*:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 5.1* 中的 `unbundle-pallet`、`non-food?` 和 `label-heavy` 函数代表了将包裹装入飞机的三个步骤。这些函数使用
    `map`、`filter` 和 `mapcat` 函数应用于包裹集合。此外，它们还可以使用 `comp` 和 `partial` 函数以从右到左的顺序进行组合。正如我们之前所描述的，`map`、`filter`
    和 `mapcat` 函数在被调用时都会生成序列，因此在三个转换之间创建了包裹的中间集合。这种中间使用序列的方式类似于在步骤执行后将所有包裹放在手推车上。提供的输入和最终结果都会是一个手推车包裹。使用手推车不仅会在我们过程的步骤之间增加额外的工作，而且步骤现在与手推车的使用变得复杂。因此，如果我们必须使用，比如说，传送带而不是手推车来运输行李，我们就必须重新定义这些步骤。这意味着如果我们要生成不同类型的最终结果集合，我们就必须重新实现
    `map`、`filter` 和 `mapcat` 函数。或者，我们可以使用转换器来实现 `process-bags` 函数，而不指定输入或结果的集合类型，如
    *示例 5.2* 所示：
- en: '[PRE234]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '*Example 5.2: Loading bags into an airplane using transducers*'
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.2：使用转换器将包裹装入飞机*'
- en: The `process-bags` function in *Example 5.2* shows how transducers can be used
    to compose the `unbundle-pallet`, `non-food?`, and `label-heavy` functions in
    a left-to-right order. Each of the expressions passed to the `comp` function in
    *Example 5.2* return a transducer. This implementation of the `process-bags` function
    does not create any intermediary collections when it is executed.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 5.2* 中的 `process-bags` 函数展示了如何以从左到右的顺序使用转换器来组合 `unbundle-pallet`、`non-food?`
    和 `label-heavy` 函数。在 *示例 5.2* 中传递给 `comp` 函数的每个表达式都返回一个转换器。这个 `process-bags` 函数的实现执行时不会创建任何中间集合。
- en: Producing results from transducers
  id: totrans-977
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从转换器生成结果
- en: Transducers are only recipes for computations, and are not capable of performing
    any actual work on their own. A transducer can produce results when coupled with
    a source of data. There's also another vital piece of the puzzle, that is, the
    step function. To combine a transducer, a step function, and a source of data,
    we must use the `tranduce` function.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器只是计算过程的配方，本身不能执行任何实际工作。当与数据源结合时，转换器可以生成结果。还有一个至关重要的组成部分，那就是步进函数。为了组合转换器、步进函数和数据源，我们必须使用
    `tranduce` 函数。
- en: 'The step function passed to `transduce` is also used to create the initial
    value of the result to be produced. This initial value of the result can also
    be specified as an argument to the `transduce` function. For example, the `transduce`
    function can be used with the `conj` form is shown as follows:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `transduce` 的步进函数也用于生成要生成的结果的初始值。这个结果的初始值也可以作为 `transduce` 函数的参数指定。例如，`transduce`
    函数可以与以下所示的 `conj` 形式一起使用：
- en: '[PRE235]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The `inc` function is coupled with the `map` function to create a transducer
    `xf`, as shown previously. The `transduce` function can be used to produce either
    a list or a vector from the transducer `xf` using the `conj` function. The order
    of elements in the results of both the `transduce` forms shown previously is different
    due to the fact that the `conj` function will add an element to the head of a
    list, as opposed to adding it at the end of a vector.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc` 函数与 `map` 函数结合，创建了一个转换器 `xf`，如前所述。可以使用 `conj` 函数从转换器 `xf` 中生成列表或向量。之前展示的
    `transduce` 函数两种形式的元素顺序不同，这是因为 `conj` 函数会将元素添加到列表的头部，而不是向向量的末尾添加。'
- en: 'We can also compose several transducers together using the `comp` function,
    as shown here:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`comp`函数将几个转换器组合在一起，如下所示：
- en: '[PRE236]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The transducer `xf` in the preceding output encapsulates the application of
    the `inc` and `even?` functions using the `map` and `filter` forms respectively.
    This transducer will produce a vector of even numbers when used with the `transduce`
    and `conj` forms. Note that the `inc` function is indeed applied to the supplied
    collection `(range 10)`, or else the value `10` would not show up in the final
    result. This computation using the transducer `xf` can be illustrated as follows:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中的转换器`xf`封装了使用`map`和`filter`形式分别应用`inc`和`even?`函数。当与`transduce`和`conj`形式一起使用时，此转换器将生成一个偶数向量。请注意，`inc`函数确实应用于提供的集合`(range
    10)`，否则`10`的值不会出现在最终结果中。使用转换器`xf`进行的这种计算可以表示如下：
- en: '![Producing results from transducers](img/B05024_5_01.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![从转换器生成结果](img/B05024_5_01.jpg)'
- en: The preceding diagram depicts how the transformations `(map inc)`, `(filter
    even?)`, and `conj` are composed in the transformation `xf`. The `map` form is
    applied first, followed by the `filter` form, and finally the `conj` form. In
    this manner, transducers can be used to compose a series of transformations for
    any source of data.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示说明了转换`(map inc)`、`(filter even?)`和`conj`如何在`xf`转换中组合。`map`形式首先应用，然后是`filter`形式，最后是`conj`形式。这样，转换器可以用于对任何数据源进行一系列转换。
- en: 'Another way to produce a collection from a transducer is by using the `into`
    function. The result of this function depends on the initial collection supplied
    to it as the first argument, as shown here:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 从转换器生成集合的另一种方法是使用`into`函数。此函数的结果取决于它作为第一个参数提供的初始集合，如下所示：
- en: '[PRE237]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'The standard `sequence` function can also be used to produce a lazy sequence
    from a transducer. Of course, the returned lazy sequence will be converted to
    a list in the REPL, as shown here:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`sequence`函数也可以从转换器生成惰性序列。当然，在REPL中返回的惰性序列将被转换为列表，如下所示：
- en: '[PRE238]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: So far, we've composed transducers to produce collections with a finite number
    of elements. An infinite series of values could also be produced by a transducer
    when used with the `sequence` function. The `eduction` function can be used to
    represent this sort of computation. This function will transform a collection,
    specified as its last argument, to any number of transformations passed to it
    in right-to-left order. An `eduction` form may also require a fewer number of
    allocations compared to using a sequence.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经组合了转换器来生成有限数量的元素集合。当与`sequence`函数一起使用时，转换器也可以生成无限值的序列。`eduction`函数可以用来表示这种计算。此函数将转换其最后一个参数指定的集合，并将其转换为任何以从右到左的顺序传递给它的转换。与使用序列相比，`eduction`形式可能需要更少的分配。
- en: 'For example, if we were to retrieve the 100th element in a sequence using the
    `nth` function, the first 99 elements would have to be realized and also discarded
    later as they are not needed. On the other hand, an `eduction` form can avoid
    this overhead. Consider the declaration of `simple-eduction` in *Example 5.3*:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用`nth`函数检索序列中的第100个元素，前99个元素就必须实现，并在之后被丢弃，因为它们不再需要。另一方面，`eduction`形式可以避免这种开销。考虑*示例
    5.3*中`simple-eduction`的声明：
- en: '[PRE239]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '*Example 5.3: Using the eduction function*'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.3：使用`eduction`函数*'
- en: 'The collection `simple-eduction` shown in *Example 5.3* will first filter out
    even values using the `even?` predicate from the infinite range `(range)` and
    then increment the resulting values using the `inc` function. We can retrieve
    elements from the collection `simple-eduction` using the `nth` function. The same
    computation can also be modeled using lazy sequences, but transducers perform
    much better, as shown here:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5.3*中显示的集合`simple-eduction`将首先使用`even?`谓词从无限范围`(range)`中过滤出偶数值，然后使用`inc`函数增加这些值。我们可以使用`nth`函数从`simple-eduction`集合中检索元素。相同的计算也可以使用惰性序列来建模，但转换器表现得更好，如下所示：'
- en: '[PRE240]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The `eduction` form using a transducer performs twice as fast compared to a
    sequence! From the output shown previously, it is quite clear that transducers
    perform significantly better than lazy sequences for composing a number of transformations.
    In summary, transducers created using functions such as `map` and `filter` can
    be easily composed to produce collections using functions such as `transduce`,
    `into`, and `eduction`. We can also use transducers with other sources of data
    such as streams, asynchronous channels, and observables.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换器的`eduction`形式比序列快两倍！从前面的输出中可以看出，转换器在组合多个转换方面比惰性序列表现显著更好。总之，使用如`map`和`filter`之类的函数创建的转换器可以很容易地组合起来，使用如`transduce`、`into`和`eduction`之类的函数生成集合。我们还可以使用转换器与其他数据源，如流、异步通道和可观察对象。
- en: Comparing transducers and reducers
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较转换器和归约器
- en: 'Both transducers and reducers, which were discussed in [Chapter 3](ch18.html
    "Chapter 3. Parallelization Using Reducers"), *Parallelization Using Reducers,*
    are ways to improve the performance of computations performed over collections.
    While transducers are a generalization of data processing for multiple data sources,
    there are a few other subtle differences between transducers and reducers, which
    are described as follows:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch18.html "第3章。使用归约器进行并行化")“使用归约器进行并行化”中讨论的转换器和归约器，都是提高集合上计算性能的方法。虽然转换器是针对多个数据源的数据处理的泛化，但转换器和归约器之间还有一些细微的区别，如下所述：
- en: Transducers are implemented as part of the Clojure language in the `clojure.core`
    namespace. However, reducers must be explicitly included in a program, as they
    are implemented in the `clojure.core.reducers` namespace.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换器作为Clojure语言的一部分在`clojure.core`命名空间中实现。然而，归约器必须显式包含在程序中，因为它们在`clojure.core.reducers`命名空间中实现。
- en: Transducers only create a collection when producing the final result of a series
    of transformations. There are no intermediary collections required to store the
    results of a transformation that constitutes a transducer. On the other hand,
    reducers produce intermediate collections to store results, and only avoid the
    creation of unnecessary empty collections.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换器仅在生成一系列转换的最终结果时创建集合。不需要中间集合来存储构成转换器的转换结果。另一方面，归约器生成中间集合来存储结果，并且仅避免创建不必要的空集合。
- en: Transducers deal with efficient composition of a series of transformations.
    This is quite orthogonal to how reducers squeeze out performance from a computation
    performed over a collection through the use of parallelization. Transducers perform
    significantly better than both the `reduce` functions from the `clojure.core`
    and `clojure.core.reducers` namespaces. Of course, using the `clojure.core.reducers/fold`
    function is still a good way to implement a computation that can be parallelized.
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换器处理一系列转换的高效组合。这与归约器通过并行化使用集合上的计算来挤压性能的方式是正交的。转换器的性能显著优于`clojure.core`和`clojure.core.reducers`命名空间中的`reduce`函数。当然，使用`clojure.core.reducers/fold`函数仍然是实现可并行化计算的好方法。
- en: These contrasts between transducers and reducers describe how these two methodologies
    of processing data are different. In practice, the performance of these techniques
    depends on the actual computation being implemented. Generally, if we intend to
    implement an algorithm to process data in a performant way, we should use transducers.
    On the other hand, if we are dealing with a lot of data in the memory with no
    need for I/O and laziness, we should use reducers. The reader is encouraged to
    compare the performance of the `transduce` function with that of the `reduce`
    and `fold` functions of the `clojure.core.reducers` library for different computations
    and data sources.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换器和归约器之间的对比描述了这两种数据处理方法的不同之处。在实践中，这些技术的性能取决于实际实现的计算。一般来说，如果我们打算以高效的方式实现数据处理算法，我们应该使用转换器。另一方面，如果我们处理的是内存中的大量数据，且不需要I/O和惰性，我们应该使用归约器。鼓励读者比较`transduce`函数与`clojure.core.reducers`库中的`reduce`和`fold`函数在不同计算和数据源上的性能。
- en: Transducers in action
  id: totrans-1004
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动中的转换器
- en: In this section, we will examine how transducers are implemented. We will also
    get a basic idea of how our own *transducible* source of data can be implemented.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨转换器的实现方式。我们还将了解如何实现我们自己的*可转换*数据源的基本概念。
- en: Managing volatile references
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理易变引用
- en: Some transducers can internally use state. It turns out that the existing reference
    types, such as atoms and refs, aren't fast enough for the implementation of transducers.
    To circumvent this problem, transducers also introduce a new *volatile* reference
    type. A volatile reference represents a mutable variable that will not be copied
    into the thread-local cache. Also, volatile references are not atomic. They are
    implemented in Java using the `volatile` keyword with a `java.lang.Object` type.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 一些转换器可以在内部使用状态。结果证明，现有的引用类型，如原子和refs，对于转换器的实现来说不够快。为了解决这个问题，转换器还引入了一种新的*易失性*引用类型。易失性引用表示一个可变的变量，它不会被复制到线程局部缓存中。此外，易失性引用不是原子的。在Java中，它们使用`volatile`关键字与`java.lang.Object`类型实现。
- en: Note
  id: totrans-1008
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c5/volatile.clj` of the book's
    source code.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c5/volatile.clj`中找到。
- en: 'We can create a new volatile reference using the `volatile!` function. The
    value contained in the volatile state can then be retrieved using the `@` reader
    macro or a `deref` form. The `vreset!` function can be used to set the state of
    a volatile reference, as shown here:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`volatile!`函数创建一个新的易失性引用。然后可以使用`@`读取宏或`deref`形式检索易失性状态中包含的值。`vreset!`函数可以用来设置易失性引用的状态，如下所示：
- en: '[PRE241]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'In the preceding output, we encapsulate the value `0` in a volatile state,
    and then set its state to `1` using the `vreset!` function. We can also mutate
    the state contained in a volatile reference using the `vswap!` function. We will
    have to pass a volatile reference and a function to be applied to the value contained
    in the reference to this function. We can also specify any other arguments for
    the supplied function as additional arguments to the `vswap!` function. The `vswap!`
    function can be used to change the state of the volatile reference `v` that we
    previously defined, as shown here:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们将值`0`封装在一个易失性状态中，然后使用`vreset!`函数将其状态设置为`1`。我们还可以使用`vswap!`函数来突变易失性引用中包含的状态。我们必须将易失性引用和要应用于引用中值的函数传递给此函数。我们还可以将提供的函数的任何其他参数作为`vswap!`函数的附加参数指定。`vswap!`函数可以用来改变我们之前定义的易失性引用`v`的状态，如下所示：
- en: '[PRE242]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The first call to the `vswap!` function in the preceding output uses the `inc`
    function to increment the value stored in the reference `v`. Similarly, the subsequent
    call to the `vswap!` function adds the value `3` to the new value in the volatile
    reference `v`, thus producing the final value `5`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`vswap!`函数的第一个调用使用`inc`函数增加存储在引用`v`中的值。同样，随后的`vswap!`函数调用将值`3`添加到易失性引用`v`中的新值，从而产生最终的值`5`。
- en: Note
  id: totrans-1015
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can check whether a value is a volatile using the `volatile?` predicate.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`volatile?`谓词来检查一个值是否是易失性的。
- en: One may argue that the volatile reference type has the same semantics as that
    of an atom. The `vreset!` and `vswap!` functions have the exact same shape as
    the `reset!` and `swap!` functions that are used with atoms. However, there is
    an important difference between a volatile reference and an atom. Unlike an atom,
    a volatile reference does not guarantee atomicity of operations performed on it.
    Hence, it's recommended to use volatile references in a single thread.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，易失性引用类型与原子的语义相同。`vreset!`和`vswap!`函数与用于原子的`reset!`和`swap!`函数具有完全相同的形状。然而，易失性引用与原子的一个重要区别在于，与原子不同，易失性引用不保证对其执行的操作的原子性。因此，建议在单个线程中使用易失性引用。
- en: Creating transducers
  id: totrans-1018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换器
- en: 'As a transducer modifies a supplied step function, let''s first define what
    a step function actually does. The following aspects need to be considered:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 由于转换器会修改提供的步骤函数，让我们首先定义一下步骤函数实际上做什么。以下方面需要考虑：
- en: The step function must be able to provide an initial value to the transformation
    it models. In other words, the step function must have an *identity* form that
    takes no arguments.
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤函数必须能够为其所建模的转换提供初始值。换句话说，步骤函数必须有一个*恒等*形式，它不接受任何参数。
- en: Inputs must be combined with the result accumulated so far by the computation.
    This is analogous to how a reducing function combines an input value with an accumulated
    result to produce a new result. The arity of this form is also the same as that
    of a reducing function; it requires two arguments to represent the current input
    and the accumulated result.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入必须与计算到目前为止累积的结果相结合。这与减少函数将输入值与累积结果结合以产生新结果的方式类似。这种形式的arity与减少函数的arity相同；它需要两个参数来表示当前输入和累积结果。
- en: The step function must also be able to complete the computation of the modeled
    process to return something. This can be implemented as a function that accepts
    a single argument that represents the accumulated result.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步函数还必须能够完成建模过程的计算，以返回某些内容。这可以通过一个接受单个参数的函数来实现，该参数表示累积的结果。
- en: Thus, a step function is represented as a function with three arities, as described
    previously. *Early termination* may also be needed by some transducers to abruptly
    stop a computational process based on certain conditions.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，步函数被表示为一个具有三个arity的函数，就像之前描述的那样。某些转换器可能还需要 *早期终止*，以便根据某些条件突然停止计算过程。
- en: Now, let's look at how some of the standard functions in the `clojure.core`
    namespace are implemented with transducers. The `map` function returns a transducer
    when called with a single argument.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `clojure.core` 命名空间中的一些标准函数是如何使用转换器实现的。当使用单个参数调用时，`map` 函数返回一个转换器。
- en: Note
  id: totrans-1025
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c5/` `implementing_transducers.clj`
    of the book's source code.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书的源代码 `src/m_clj/c5/implementing_transducers.clj` 中找到。
- en: 'The following *Example 5.4* describes how the `map` function is implemented:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 *示例 5.4* 描述了 `map` 函数是如何实现的：
- en: '[PRE243]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '*Example 5.4: The map function*'
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.4：map 函数*'
- en: The 1-arity form of the `map` function returns a function that accepts a step
    function, represented by `step`, and returns another step function. The returned
    step function has three different arities, just like we described earlier in this
    section. The essence of the `map` function is described by the expression `(step
    result (f input))`, which translates to "apply the function `f` on the current
    input `input` and combine it with the accumulated result `result` using the function
    `step`". The returned step function also has two other arities—one that takes
    no arguments and another that takes one argument. These arities correspond to
    the other two cases of a step function that we described earlier.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数的 1-arity 形式返回一个接受步函数的函数，步函数由 `step` 表示，并返回另一个步函数。返回的步函数有三个不同的arity，就像我们在本节前面描述的那样。`map`
    函数的精髓可以用表达式 `(step result (f input))` 来描述，这可以翻译为“将函数 `f` 应用于当前输入 `input`，并使用函数
    `step` 将其与累积结果 `result` 结合”。返回的步函数还有另外两个arity——一个不接受任何参数，另一个接受一个参数。这些arity对应于我们之前描述的步函数的另外两种情况。'
- en: The second arity of the `map` function, which returns a collection and not a
    transducer, is merely a composition of the `sequence` function and the transducer
    returned by the expression `(map f)`. The actual creation of a collection is done
    by the `sequence` function. The 1-arity form of the `map` function only describes
    how the function `f` is applied over a transducible context such as a collection.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数的第二个arity，它返回一个集合而不是转换器，仅仅是 `sequence` 函数和由表达式 `(map f)` 返回的转换器的组合。集合的实际创建是由
    `sequence` 函数完成的。`map` 函数的 1-arity 形式只描述了函数 `f` 如何在可转换的上下文（如集合）上应用。'
- en: 'Similarly, the `filter` function can be implemented using a transducer, as
    shown in *Example 5.5*, as follows:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`filter` 函数可以使用转换器来实现，如 *示例 5.5* 所示，如下所示：
- en: '[PRE244]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '*Example 5.5: The filter function*'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.5：filter 函数*'
- en: The premise in the implementation of the `filter` function is that a predicate
    `p?` is used to conditionally combine the accumulated result and the current input,
    which are represented by `result` and `input` respectively. If the expression
    `(p? input)` does not return a truthy value, the accumulated result is returned
    without any modification. Similar to the map function in *Example 5.4*, the 2-arity
    form of the filter function is implemented using a `sequence` form and a transducer.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数的实现前提是使用谓词 `p?` 来有条件地将累积结果和当前输入（分别表示为 `result` 和 `input`）结合起来。如果表达式
    `(p? input)` 不返回一个真值，则累积结果将返回而不做任何修改。与 *示例 5.4* 中的 map 函数类似，filter 函数的 2-arity
    形式使用 `sequence` 形式和转换器来实现。'
- en: 'To handle early termination in transducers, we must use the `reduced` and `reduced?`
    functions. Calling reduce or a step function on a value that has been wrapped
    in a `reduced` form will simply return the contained value. The `reduced?` function
    checks whether a value is already *reduced*, that is, wrapped in a `reduced` form.
    The `reduced` and `reduced?` forms both accept a single argument, as shown here:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理转换器中的早期终止，我们必须使用`reduced`和`reduced?`函数。对已包裹在`reduced`形式的值调用reduce或步进函数将简单地返回包含的值。`reduced?`函数检查一个值是否已经被*reduced*，即包裹在`reduced`形式中。`reduced`和`reduced?`形式都接受一个参数，如下所示：
- en: '[PRE245]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Consider the following function `rf` in *Example 5.6* that uses a `reduced`
    form to ensure that the accumulated result is never more than 100 elements:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在*示例 5.6*中使用的函数`rf`，它使用`reduced`形式确保累积结果永远不会超过100个元素：
- en: '[PRE246]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '*Example 5.6: Using the reduced function*'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.6：使用 reduced 函数*'
- en: 'The function `rf` merely sums up all inputs to produce a result. If the `rf`
    function is passed to the `reduce` function along with a sufficiently large collection,
    the `:too-big` value is returned as the final result, as shown here:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`rf`只是将所有输入相加以产生一个结果。如果将`rf`函数与一个足够大的集合一起传递给`reduce`函数，那么将返回`:too-big`值作为最终结果，如下所示：
- en: '[PRE247]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: A value wrapped in a `reduced` form can be extracted using the `unreduced` function
    or the `@` reader macro. Also, the `ensure-reduced` function can be used instead
    of `reduced` to avoid re-applying a `reduced` form to a value that has already
    been reduced.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`unreduced`函数或`@`读取宏从`reduced`形式中提取值。此外，可以使用`ensure-reduced`函数代替`reduced`，以避免将`reduced`形式重新应用于已经reduced的值。
- en: 'The standard `take-while` function can be implemented using a `reduced` form
    and a transducer, as shown in the following *Example 5.7*:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`take-while`函数可以使用`reduced`形式和转换器来实现，如下面的*示例 5.7*所示：
- en: '[PRE248]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '*Example 5.7: The take-while function*'
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.7：take-while 函数*'
- en: Note that only the 1-arity form of the `take-while` function is described in
    *Example 5.7*. The step function returned by the `take-while` function uses the
    expression `(p? input)` to check if the accumulated result has to be combined
    with the current input. If the `p?` predicate does not return a truthy value,
    the accumulated result is returned by wrapping it in a `reduced` form. This prevents
    any other transformations, which may be composed with the transformation returned
    by the `take-while` function, from modifying the accumulated result any further.
    In this way, the `reduced` form can be used to wrap the result of a transducer
    and perform early termination based on some conditional logic.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅在*示例 5.7*中描述了`take-while`函数的1-arity形式。`take-while`函数返回的步进函数使用表达式`(p? input)`来检查累积的结果是否需要与当前输入结合。如果`p?`谓词不返回一个真值，则通过将其包裹在`reduced`形式中来返回累积的结果。这防止了任何其他可能与`take-while`函数返回的转换组合的转换修改累积结果。这样，`reduced`形式可以用来包裹转换的结果，并根据某些条件逻辑执行早期终止。
- en: 'Let''s look at how a stateful transducer is implemented. The `take` function
    returns a transducer that maintains an internal state. This state is used to keep
    a track of the number of items that have been processed so far, since the `take`
    function must only return a certain number of items from a collection or any other
    transducible context by definition. *Example 5.8* describes how the `take` function
    is implemented using a volatile reference to maintain state:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看状态化转换器的实现方式。`take`函数返回一个维护内部状态的转换器。这个状态用于跟踪到目前为止已处理的项目数量，因为根据定义，`take`函数必须只从集合或其他可转换上下文中返回一定数量的项目。*示例
    5.8*描述了如何使用一个易失性引用来维护状态实现`take`函数：
- en: '[PRE249]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '*Example 5.8: The take function*'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 5.8：take 函数*'
- en: The transducer returned by the `take` function will first create a volatile
    reference `nv` from the supplied value `n` to track the number of items to be
    processed. The returned step function then decrements the volatile reference `nv`
    and combines the result with the input using the `step` function. This is done
    repeatedly until the value contained in the reference `nv` is positive. Once all
    `n` items have been processed, the result is wrapped in an `ensure-reduced` form
    to signal early termination. Here, the `ensure-reduced` function is used to prevent
    wrapping the value `result` in another `reduced` form, since the expression `(step
    result input)` could return a value that is already reduced.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 由`take`函数返回的转换器首先从提供的值`n`创建一个易失性引用`nv`来跟踪要处理的项目数量。然后返回的步骤函数会递减易失性引用`nv`，并使用`step`函数将结果与输入结合。这会一直重复，直到引用`nv`中包含的值是正数。一旦处理完所有`n`个项目，结果会被包裹在`ensure-reduced`形式中，以表示提前终止。在这里，`ensure-reduced`函数被用来防止将值`result`包裹在另一个`reduced`形式中，因为`(step
    result input)`可能返回一个已经减少的值。
- en: 'Finally, let''s take a quick look at how the `transduce` function is implemented,
    as shown in *Example 5.9*:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速看一下`transduce`函数的实现方式，如*示例5.9*所示：
- en: '[PRE250]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '*Example 5.9: The transduce function*'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例5.9：transduce函数*'
- en: The `transduce` function has two arities. The 4-arity form of the `transduce`
    function calls the `.reduce` method of the transducible context `coll` if it is
    an instance of the `clojure.lang.IReduceInit` interface. This interface defines
    a single method `reduce` that represents how a data source is reduced using a
    given function and an initial value. If the variable `coll` does not implement
    this interface, the `transduce` function will fall back on the `coll-reduce` function
    to process the data source represented by `coll`. In a nutshell, the `transduce`
    function will try to process a transducible context in the fastest possible way.
    The `clojure.lang.IReduceInit` interface must be implemented by all data sources
    that must support the use of `transduce`.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '`transduce`函数有两种形式。`transduce`函数的4参数形式如果`coll`是`clojure.lang.IReduceInit`接口的实例，则会调用其`.reduce`方法。此接口定义了一个名为`reduce`的单个方法，它表示如何使用给定的函数和初始值来减少数据源。如果变量`coll`没有实现此接口，`transduce`函数将回退到`coll-reduce`函数来处理由`coll`表示的数据源。简而言之，`transduce`函数将尝试以最快的方式处理可转换上下文。所有必须支持`transduce`使用的数据源都必须实现`clojure.lang.IReduceInit`接口。'
- en: The 3-arity form of the `transduce` function produces the initial value for
    the transduction by invoking the supplied function `f` without any arguments.
    Thus, this arity of the `transduce` function can only be used with functions that
    provide an identity value.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '`transduce`函数的3参数形式通过调用不带任何参数的提供的函数`f`来生成转换的初始值。因此，这个`transduce`函数的参数形式只能与提供恒等值的函数一起使用。'
- en: Note
  id: totrans-1057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The definitions of the `map`, `filter`, `take`, and `take-while` functions,
    as shown in this section, are simplified versions of their actual definitions.
    However, the `transduce` function is shown exactly as it is implemented in the
    `clojure.core` namespace.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中所示`map`、`filter`、`take`和`take-while`函数的定义是它们实际定义的简化版本。然而，`transduce`函数在`clojure.core`命名空间中的实现方式是准确的。
- en: This depicts how transducers and the `transduce` function are implemented. If
    we need to implement our own transducible source of data, the implementations
    described in this section can be used as a guideline.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 这描绘了转换器和`transduce`函数的实现方式。如果我们需要实现自己的可转换数据源，本节中描述的实现可以作为指南。
- en: Summary
  id: totrans-1060
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have seen how we can process data using sequences, reducers, and
    transducers. In this chapter, we described how transducers can be used for performant
    computations. We also briefly studied how transducers are implemented in the Clojure
    language.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用序列、归约器和转换器来处理数据。在本章中，我们描述了如何使用转换器进行高效的计算。我们还简要研究了转换器在Clojure语言中的实现方式。
- en: In the following chapter, we will explore algebraic data structures, such as
    functors, applicatives, and monads, in Clojure. These concepts will deepen our
    understanding of functional composition, which is the keystone of functional programming.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Clojure中的代数数据结构，如函子、应用和单子，这些概念将加深我们对函数组合的理解，这是函数式编程的基石。
- en: Chapter 6. Exploring Category Theory
  id: totrans-1063
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 探索范畴论
- en: 'On a journey into functional programming, a programmer will eventually stumble
    upon *category theory*. First off, let''s just say that the study of category
    theory is not really needed to write better code. It''s more prevalent in the
    internals of pure functional programming languages, such as Haskell and Idris,
    in which functions are *pure* and more like mathematical functions that do not
    have implicit side effects such as I/O and mutation. However, category theory
    helps us reason about a very fundamental and practical aspect of computation:
    *composition*. Functions in Clojure, unlike in pure functional programming languages,
    are quite different from mathematical functions as they can perform I/O and other
    side effects. Of course, they can be pure under certain circumstances, and thus
    concepts from category theory are still useful in Clojure for writing reusable
    and composable code based on pure functions.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索函数式编程的旅途中，程序员最终会遇到 *范畴论*。首先，我们可以这样说，研究范畴论并不是编写更好代码的必要条件。它在纯函数式编程语言的内部更为普遍，如
    Haskell 和 Idris，在这些语言中，函数是 *纯* 的，更类似于没有隐式副作用（如 I/O 和修改）的数学函数。然而，范畴论帮助我们推理计算的非常基础和实用的一个方面：*组合*。与纯函数式编程语言中的函数不同，Clojure
    中的函数可以执行 I/O 和其他副作用。当然，在特定情况下，它们可以是纯的，因此范畴论的概念对于 Clojure 来说仍然很有用，可以帮助我们基于纯函数编写可重用和可组合的代码。
- en: Category theory can be thought of as a mathematical framework for modeling composition.
    In this chapter, we will discuss a few concepts from category theory using Clojure.
    We will also study a few algebraic types, such as functors, monoids, and monads.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论可以被视为一个用于建模组合的数学框架。在本章中，我们将使用 Clojure 讨论范畴论的一些概念。我们还将研究一些代数类型，如函子、幺半群和单子。
- en: Demystifying category theory
  id: totrans-1066
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭开范畴论的面纱
- en: Category theory has its own share of quirky notations and conventions. Let's
    start off by exploring some of the terminology used in category theory, in a language
    understandable by us mortal programmers.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论有其独特的符号和约定。让我们从探索范畴论中使用的术语开始，用我们这些凡人程序员能理解的语言。
- en: 'A *category* is formally defined as a collection of **objects** and **morphisms**.
    In simple terms, objects represent abstract types, and morphisms represent functions
    that convert between these types. A category is thus analogous to a programming
    language that has a few types and functions, and has two basic properties:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *范畴* 正式定义为对象和 **态射** 的集合。简单来说，对象代表抽象类型，态射代表在这些类型之间进行转换的函数。因此，范畴类似于一种编程语言，它只有几种类型和函数，并且有两个基本属性：
- en: There exists an *identity morphism* for each object in the category. In practice,
    a single identity function can be used to represent the identity morphism for
    all given objects, but this is not mandatory.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于范畴中的每个对象，都存在一个 *恒等态射*。在实践中，可以使用单个恒等函数来表示所有给定对象的恒等态射，但这不是强制性的。
- en: Morphisms in a category can be composed together into a new morphism. In fact,
    a composition of two or more morphisms is an optimization of applying the individual
    morphisms one at a time. In this way, the composition of several morphisms is
    said to *commute* with applying the constituting morphisms.
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴中的态射可以组合成一个新的态射。实际上，两个或更多态射的组合是逐个应用单个态射的优化。这样，几个态射的组合被认为是与构成态射的应用 *交换* 的。
- en: 'Morphisms in a category can be composed as illustrated by the following diagram:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴中的态射可以按照以下图示进行组合：
- en: '![Demystifying category theory](img/B05024_06_01.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![揭开范畴论的面纱](img/B05024_06_01.jpg)'
- en: In the preceding diagram, the vertices *A*, *B*, and *C* are the objects and
    the arrows are morphisms between these objects. The morphisms *I[A]*, *I[B]*,
    and *I[C]* are identity morphisms that map the objects *A*, *B*, and *C* to themselves.
    The morphism *f* maps *A* to *B*, and similarly the morphism *g* maps *B* to *C*.
    These two morphisms can be composed together, as represented by the morphism ![Demystifying
    category theory](img/4900_06_07.jpg) that maps *A* directly to *C*, and hence
    the morphism ![Demystifying category theory](img/4900_06_07.jpg) *commutes* with
    the morphisms *f* and *g*. For this reason, the preceding diagram is termed as
    a *commutative diagram*. Note that identity morphisms in a commutative diagram
    are generally not shown, unlike in the preceding diagram.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，顶点*A*、*B*和*C*是对象，箭头是这些对象之间的形态。形态*I[A]*、*I[B]*和*I[C]*是恒等形态，将对象*A*、*B*和*C*映射到自身。形态*f*将*A*映射到*B*，同样地，形态*g*将*B*映射到*C*。这两个形态可以组合在一起，如形态![范畴论揭秘](img/4900_06_07.jpg)所示，该形态将*A*直接映射到*C*，因此形态![范畴论揭秘](img/4900_06_07.jpg)与形态*f*和*g***交换**。因此，前面的图被称为**交换图**。请注意，与前面的图不同，交换图中的恒等形态通常不会显示。
- en: Note
  id: totrans-1074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c6/` `demystifying_cat_theory.clj`
    of the book's source code.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c6/` `demystifying_cat_theory.clj`中找到。
- en: 'Now, let''s translate the previous diagram to Clojure. We shall use the built-in
    string, symbol and keyword types to depict how morphisms, or rather functions,
    between these types can be composed together using the `comp` function:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将之前的图转换为Clojure代码。我们将使用内置的字符串、符号和关键字类型来展示如何使用`comp`函数将这些类型之间的形态（或函数）组合在一起：
- en: '![Demystifying category theory](img/B05024_06_02.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![范畴论揭秘](img/B05024_06_02.jpg)'
- en: As shown in the preceding diagram, the `name` function converts a keyword to
    a string, and the `symbol` function converts a string to a symbol. These two functions
    can be composed into a function that converts a keyword directly to a symbol,
    represented by the `(comp symbol name)` function. Also, the identity morphisms
    for each category translate to the `identity` function.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`name`函数将关键字转换为字符串，而`symbol`函数将字符串转换为符号。这两个函数可以组合成一个函数，该函数将关键字直接转换为符号，由`(comp
    symbol name)`函数表示。此外，每个范畴的恒等形态对应于`identity`函数。
- en: Note
  id: totrans-1079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, the string, symbol, and keyword types are represented by the `java.lang.String`,
    `clojure.lang.Symbol` and `clojure.lang.Keyword` classes respectively.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，字符串、符号和关键字类型分别由`java.lang.String`、`clojure.lang.Symbol`和`clojure.lang.Keyword`类表示。
- en: 'We can verify that the `name` and `symbol` functions can be composed together
    using the `comp` form, as shown in the following REPL output:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证`name`和`symbol`函数可以使用`comp`形式组合在一起，如下面的REPL输出所示：
- en: '[PRE251]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This establishes the fact that concepts from category theory have equivalent
    representations in Clojure, and other programming languages as well. Although
    it is perfectly valid to think about objects in a category as concrete types like
    we just described, *algebraic structures* are a more practical substitute for
    objects. Algebraic structures describe abstract properties of types, rather than
    what data is contained in a type or how data is structured by a type, and are
    more like abstract types. Thus, category theory is all about composing functions
    that operate on abstract types with certain properties.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 这确立了这样一个事实：范畴论中的概念在Clojure以及其他编程语言中都有等价的表达形式。虽然将范畴中的对象视为我们刚刚描述的具体类型是完全可以接受的，但**代数结构**是对象的一个更实用的替代品。代数结构描述了类型的抽象属性，而不是类型中包含的数据或类型如何组织数据，它们更像是抽象类型。因此，范畴论就是关于组合具有特定属性的抽象类型上操作的函数。
- en: In Clojure, algebraic structures can be thought of as protocols. Concrete types
    can implement protocols, and hence a type can represent more than one algebraic
    structure. The `cats` library ([https://github.com/funcool/cats](https://github.com/funcool/cats))
    takes this approach and provides protocol-based definitions of a few interesting
    algebraic structures. The `cats` library also provides types that implement these
    protocols. Additionally, this library extends some of the built-in types through
    these protocols allowing us to treat them as algebraic structures. Although there
    are several alternatives, `cats` is the only library compatible with ClojureScript.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，代数结构可以被视为协议。具体类型可以实现协议，因此一个类型可以代表多个代数结构。`cats`库([https://github.com/funcool/cats](https://github.com/funcool/cats))采用这种方法，并提供了一些有趣的代数结构的基于协议的定义。`cats`库还提供了实现这些协议的类型。此外，这个库通过这些协议扩展了一些内置类型，使我们能够将它们视为代数结构。尽管有几种替代方案，但`cats`是唯一兼容ClojureScript的库。
- en: Note
  id: totrans-1085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖项对于即将到来的示例是必需的：
- en: '[PRE252]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须包含在您的命名空间声明中：
- en: '[PRE253]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Now, let's study some of the algebraic structures from the `cats` library.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究`cats`库中的一些代数结构。
- en: Using monoids
  id: totrans-1091
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用幺半群
- en: Let's start by exploring **monoids**. In order to define a monoid, we must first
    understand what a semigroup is.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索**幺半群**开始。为了定义一个幺半群，我们首先必须理解什么是半群。
- en: Note
  id: totrans-1093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c6/` `monoids.clj` of the
    book's source code.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c6/` `monoids.clj`中找到。
- en: A *semigroup* is an algebraic structure that supports an associative binary
    operation. A binary operation, say ![Using monoids](img/4900_06_08.jpg), is termed
    *associative* if the operation ![Using monoids](img/4900_06_09.jpg) produces the
    same result as the operation ![Using monoids](img/4900_06_10.jpg). A monoid is
    in fact a semigroup with an additional property, as we will see ahead.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '**半群**是一种支持结合二元运算的代数结构。如果一个二元运算，比如![使用幺半群](img/4900_06_08.jpg)，运算![使用幺半群](img/4900_06_09.jpg)产生与运算![使用幺半群](img/4900_06_10.jpg)相同的结果，那么这个二元运算被称为**结合**。实际上，幺半群是一个具有额外属性的半群，我们将在下面看到这一点。'
- en: 'The `mappend` function from the `cats.core` namespace will associatively combine
    a number of instances of the same type and return a new instance of the given
    type. If we are dealing with strings or vectors, the `mappend` operation is implemented
    by the standard `concat` function. Thus, strings and vectors can be combined using
    the `mappend` function, as shown here:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`cats.core`命名空间的`mappend`函数可以结合相同类型的一组实例，并返回给定类型的新实例。如果我们处理的是字符串或向量，`mappend`操作由标准的`concat`函数实现。因此，字符串和向量可以使用`mappend`函数进行组合，如下所示：
- en: '[PRE254]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: As strings and vectors support the associative `mappend` operation, they are
    semigroups. They are also *monoids*, which are simply semigroups that have an
    *identity element*. It's fairly obvious that the identity element for strings
    is an empty string, and for vectors it's an empty vector.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串和向量支持结合的`mappend`操作，它们是半群。它们也是**幺半群**，它们只是具有**单位元素**的半群。很明显，字符串的单位元素是一个空字符串，而向量的单位元素是一个空向量。
- en: This is a good time to introduce a versatile concrete type from the world of
    functional programming—the `Maybe` type. The `Maybe` type represents an optional
    value, and can either be empty or contain a value. It can be thought of as a value
    in a context or a container. The `just` and `nothing` functions from the `cats.monads.maybe`
    namespace can be used to construct an instance of the `Maybe` type. The `just`
    function constructs an instance with a contained value, and the `nothing` function
    creates an empty `Maybe` value. The value contained in a `Maybe` instance can
    be obtained by either passing it to the `cats.monads.maybe/from-maybe` function,
    or dereferencing it (using the `deref` form or the `@` reader macro).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个介绍功能编程世界中一个多才多艺的具体类型的好时机——`Maybe`类型。`Maybe`类型表示一个可选值，可以是空的或包含一个值。它可以被视为一个值在上下文或容器中。`cats.monads.maybe`命名空间中的`just`和`nothing`函数可以用来构建`Maybe`类型的一个实例。`just`函数构建一个包含值的实例，而`nothing`函数创建一个空的`Maybe`值。可以通过将其传递给`cats.monads.maybe/from-maybe`函数或使用`deref`形式或`@`读取宏来解引用`Maybe`实例中的值。
- en: 'Incidentally, the `Maybe` type is also a monoid, since an empty `Maybe` value,
    created using the `nothing` function, is analogous to an identity element. We
    can use the `mappend` function to combine values of the `Maybe` type, just like
    any other monoid, as shown here:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`Maybe` 类型也是一个幺半群，因为使用 `nothing` 函数创建的空 `Maybe` 值类似于一个单位元素。我们可以使用 `mappend`
    函数来组合 `Maybe` 类型的值，就像任何其他幺半群一样，如下所示：
- en: '[PRE255]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The `mappend` function can thus be used to associatively combine any values
    that are monoids.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`mappend` 函数可以用来关联组合任何是幺半群的值。
- en: Using functors
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函子
- en: Next, let's take a look at **functors**. A functor is essentially a value in
    a container or a computational context. The `fmap` function must be implemented
    by a functor. This function applies a supplied function to the value contained
    in a functor. In object-oriented terminology, a functor can be thought of as a
    generic type with a single abstract method `fmap`. In a way, reference types,
    such as refs and atoms, can be thought of as functors that save results, as a
    reference type applies a function to its contained value in order to obtain the
    new value that should be stored in it.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 **函子**。函子本质上是一个容器或计算上下文中的值。函子必须实现 `fmap` 函数。这个函数将提供的函数应用到函子包含的值上。在面向对象术语中，函子可以被视为一个具有单个抽象方法
    `fmap` 的通用类型。从某种意义上说，引用类型，如 refs 和 atoms，可以被视为保存结果的函子，因为引用类型将其包含的值应用于函数以获得应存储在其内的新值。
- en: Note
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c6/` `functors.clj` of the
    book's source code.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c6/` `functors.clj` 中找到。
- en: 'The `fmap` function from the `cats.core` namespace takes two arguments: a function
    and a functor. A functor itself defines what happens when an instance of the functor
    is passed to the `fmap` function. The `cats` library extends vectors as functors.
    When a vector is passed to the `fmap` function along with a function, the supplied
    function is applied to all elements in the vector. Wait a minute! Isn''t that
    what the `map` function does? Well, yes, but the `map` function always returns
    a lazy sequence. On the other hand, the `fmap` function will return a value with
    the same concrete type as the functor that is passed. The behavior of the `map`
    and `fmap` functions can be compared as follows:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `cats.core` 命名空间的 `fmap` 函数接受两个参数：一个函数和一个函子。函子本身定义了当函子的一个实例传递给 `fmap` 函数时会发生什么。`cats`
    库将向量扩展为函子。当一个向量与一个函数一起传递给 `fmap` 函数时，提供的函数会被应用到向量中的所有元素上。等等！这不是 `map` 函数所做的吗？嗯，是的，但
    `map` 函数总是返回一个惰性序列。另一方面，`fmap` 函数将返回一个与传递的函子具有相同具体类型的值。`map` 和 `fmap` 函数的行为可以比较如下：
- en: '[PRE256]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'As shown above, the `map` function produces a lazy sequence, which gets realized
    into a list in the REPL, when it is passed a vector along with the `inc` function.
    The `fmap` function, however, produces a vector when passed the same arguments.
    We should note that the `fmap` function is also aliased as `<$>`. Lazy sequences
    and sets can also be treated as functors, as shown here:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`map` 函数生成一个惰性序列，当它传递一个向量以及 `inc` 函数到 REPL 时，这个惰性序列会被实现为一个列表。然而，`fmap`
    函数在传递相同的参数时会产生一个向量。我们应该注意，`fmap` 函数也被称为 `<$>`。惰性序列和集合也可以被视为函子，如下所示：
- en: '[PRE257]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The `Maybe` type is also a functor. The `fmap` function returns a *maybe* when
    it is passed a *maybe*, as shown here:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 类型也是一个函子。当 `fmap` 函数传递一个 `Maybe` 时，它返回一个 *maybe*，如下所示：'
- en: '[PRE258]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The `fmap` function applies the function `inc` to a `Maybe` value only when
    it contains a value. This behavior of the `fmap` function can be illustrated by
    the following diagram:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fmap` 函数对一个包含值的 `Maybe` 值应用时，它只对 `inc` 函数应用。这种 `fmap` 函数的行为可以通过以下图表来展示：
- en: '![Using functors](img/B05024_06_03.jpg)'
  id: totrans-1114
  prefs: []
  type: TYPE_IMG
  zh: '![使用函子](img/B05024_06_03.jpg)'
- en: 'The preceding diagram depicts how the `fmap` function is passed the `inc` function
    and the expression `(cmm/just 1)`, and returns a new functor instance. The `fmap`
    function extracts the value from this `Maybe` value, applies the `inc` function
    to the value, and creates a new `Maybe` value with the result. On the other hand,
    the `fmap` function will simply return an empty `Maybe` instance, created using
    the `nothing` function, without touching it, as shown in the following diagram:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了 `fmap` 函数如何传递 `inc` 函数和表达式 `(cmm/just 1)`，并返回一个新的函子实例。`fmap` 函数从这个 `Maybe`
    值中提取值，将 `inc` 函数应用到该值上，并创建一个新的包含结果的 `Maybe` 值。另一方面，`fmap` 函数将简单地返回一个使用 `nothing`
    函数创建的空 `Maybe` 实例，而不对其进行任何操作，如下面的图表所示：
- en: '![Using functors](img/B05024_06_04.jpg)'
  id: totrans-1116
  prefs: []
  type: TYPE_IMG
  zh: '![使用函子](img/B05024_06_04.jpg)'
- en: 'This behavior of the `fmap` function is defined by the implementation of the
    `Maybe` type. This is because a functor itself gets to define how the `fmap` function
    behaves with it. Of course, implementing the `fmap` function is not enough to
    qualify a type as a functor. There are also functor laws that have to be satisfied
    by any plausible implementation of a functor. The functor laws can be described
    as follows:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmap`函数的这种行为由`Maybe`类型的实现定义。这是因为函子本身可以定义`fmap`函数如何与之交互。当然，实现`fmap`函数并不足以使类型成为函子。还有函子定律，任何可能的函子实现都必须满足这些定律。函子定律可以描述如下：'
- en: 'Passing an identity morphism and a functor *F* to `fmap` must return the functor
    *F* without any modification. We can translate this into Clojure using the `identity`
    function, as follows:'
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将恒等函子和函子*F*传递给`fmap`必须返回未经修改的函子*F*。我们可以使用`identity`函数将其翻译成Clojure，如下所示：
- en: '[PRE259]'
  id: totrans-1119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Passing a functor *F* and a morphism *f* to `fmap`, followed by passing the
    result and another morphism *g* to `fmap`, must be equivalent to calling `fmap`
    with the functor *F* and the composition ![Using functors](img/4900_06_07.jpg).
    We can verify this using the `comp` function, as shown here:'
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函子*F*和函子同态*f*传递给`fmap`，然后传递结果和另一个函子同态*g*给`fmap`，必须与调用`fmap`时使用函子*F*和复合![使用函子](img/4900_06_07.jpg)等效。我们可以使用`comp`函数来验证这一点，如下所示：
- en: '[PRE260]'
  id: totrans-1121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: The first law describes identity morphisms, and the second law upholds the composition
    of morphisms. These laws can be thought of as optimizations that can be performed
    by the `fmap` function when used with valid functors.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一定律描述了恒等函子，第二定律保持了函子复合。这些定律可以被视为`fmap`函数在有效函子中使用时可以执行的优化。
- en: Using applicative functors
  id: totrans-1123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用函子
- en: 'Applicative functors are a subset of functors with a few additional requirements
    imposed on them, thus making them a bit more useful. Similar to functors, applicative
    functors are computational contexts that are capable of applying a function to
    the value contained in them. The only difference is that the function to be applied
    to an applicative functor must itself be wrapped in the context of an applicative
    functor. Applicative functors also have a different interface of functions associated
    with them. An applicative functor, in `cats`, is manipulated using two functions:
    `fapply` and `pure`.'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子是具有一些额外要求的函子子集，因此它们更有用。与应用函子类似，应用函子是能够将函数应用于其中包含的值的计算上下文。唯一的区别是，应用于应用函子的函数本身必须被包裹在应用函子的上下文中。应用函子还有与之关联的不同函数接口。在`cats`中，应用函子使用两个函数`fapply`和`pure`进行操作。
- en: Note
  id: totrans-1125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c6/` `applicatives.clj` of
    the book's source code.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c6/` `applicatives.clj`中找到。
- en: 'The `fapply` function from the `cats.core` namespace can be called with an
    applicative functor, as follows:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`cats.core`命名空间的`fapply`函数可以用应用函子调用，如下所示：
- en: '[PRE261]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Here, we again use the `Maybe` type, this time as an applicative functor. The
    `fapply` function unwraps the `inc` function and the value `1` from the `Maybe`
    values, combines them and returns the result `2` in a new `Maybe` instance. This
    can be illustrated with the following diagram:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`Maybe`类型，这次作为应用函子。`fapply`函数将`inc`函数和值`1`从`Maybe`值中解包，将它们组合并返回一个新的`Maybe`实例中的结果`2`。这可以用以下图表来说明：
- en: '![Using applicative functors](img/B05024_06_05.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![使用应用函子](img/B05024_06_05.jpg)'
- en: 'The `cats.core/pure` function is used to create a new instance of an applicative
    functor. We must pass an implementation-specific context, such as `cats.monads.maybe/context`,
    and a value to the `pure` function, as follows:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '`cats.core/pure`函数用于创建应用函子的新实例。我们必须将实现特定的上下文，例如`cats.monads.maybe/context`，和一个值传递给`pure`函数，如下所示：'
- en: '[PRE262]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'The `cats` library provides an `alet` form to easily compose applicative functors.
    Its syntax is similar to that of the `let` form, as follows:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '`cats`库提供了一个`alet`形式来轻松组合应用函子。其语法类似于`let`形式，如下所示：'
- en: '[PRE263]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The value returned by the body of the `alet` form, shown previously, is wrapped
    in a new applicative functor instance and returned. The surrounding `alet` form
    is dereferenced, and thus the entire expression returns a vector.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的`alet`形式的主体返回的值被包裹在一个新的应用函子实例中并返回。周围的`alet`形式被取消引用，因此整个表达式返回一个向量。
- en: 'The `<*>` function from the `cats.core` namespace is a variadic form of the
    `fapply` function. It accepts a value representing an applicative functor followed
    by any number of functions that produce applicative functors. The `cats` library
    also provides the `Validation` applicative functor type for validating properties
    of a given object. This type can be constructed using the `ok` and `fail` forms
    in the `cats.applicative.validation` namespace. Let''s say we want to validate
    a map representing a page with some textual content. A page must have a page number
    and an author. This validation can be implemented as shown in *Example 6.1*:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`cats.core`命名空间的`<*>`函数是`fapply`函数的变长形式。它接受一个表示应用函子的值，后跟任意数量的产生应用函子的函数。`cats`库还提供了用于验证给定对象属性的`Validation`应用函子类型。此类型可以使用`cats.applicative.validation`命名空间中的`ok`和`fail`形式来构造。假设我们想要验证一个表示带有一些文本内容的页面的映射。页面必须有一个页码和一个作者。这种验证可以像*示例6.1*中所示那样实现：
- en: '[PRE264]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '*Example 6.1: The cats.applicative.validation type*'
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例6.1: cats.applicative.validation类型*'
- en: 'The `validate-page-author` and `validate-page-number` functions in *Example
    6.1* check whether a map contains the `:author` and `:number` keys respectively.
    These functions create an instance of the `Validation` type using the `ok` function,
    and similarly use the `fail` function to create a `Validation` instance that represents
    a validation failure. Both the `validate-page-author` and `validate-page-number`
    functions are composed together using the `<*>` function. The first argument passed
    to `<*>` will have to be an instance of the `Validation` type created using the
    `pure` function. The `validate-page` function can thus validate maps representing
    pages, as shown here:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例6.1*中的`validate-page-author`和`validate-page-number`函数检查映射是否包含`:author`和`:number`键。这些函数使用`ok`函数创建`Validation`类型的实例，并类似地使用`fail`函数创建表示验证失败的`Validation`实例。`validate-page-author`和`validate-page-number`函数都通过`<*>`函数组合在一起。传递给`<*>`的第一个参数必须是使用`pure`函数创建的`Validation`类型的实例。因此，`validate-page`函数可以验证表示页面的映射，如下所示：'
- en: '[PRE265]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: A successful validation will return a `Validation` instance containing the page
    object, and an unsuccessful one will return an instance of the `Validation` type
    with the appropriate validation messages as a map. The concrete types for these
    two cases are `Ok` and `Fail`, as shown in the preceding output.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的验证将返回包含页面对象的`Validation`实例，而不成功的验证将返回包含适当的验证消息映射的`Validation`类型实例。这两种情况的具体类型是`Ok`和`Fail`，如前面的输出所示。
- en: Applicative functors must themselves define the behavior of the `fapply` and
    `pure` functions with them. Of course, there are laws that applicative functors
    must obey too. In addition to the identity and composition laws of functors, applicative
    functors also conform to the *homomorphism* and *interchange* laws. The reader
    is encouraged to find out more about these laws before implementing their own
    applicative functors.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子必须自己定义与`fapply`和`pure`函数一起的行为。当然，应用函子也必须遵守一些法则。除了函子的恒等性和组合性法则外，应用函子还必须遵守*同态*和*交换*法则。鼓励读者在实现自己的应用函子之前了解更多关于这些法则的信息。
- en: Using monads
  id: totrans-1143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子
- en: 'Finally, let''s take a look at an algebraic structure that helps us build and
    compose a sequence of computations: a **monad**. There are countless tutorials
    and articles on the web that explain monads and how they can be used. In this
    section, we will look at monads in our own unique and Clojure-y way.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一种代数结构，它帮助我们构建和组合一系列计算：**单子**。网上有无数教程和文章解释单子以及它们如何被使用。在本节中，我们将以我们独特且Clojure风格的方式来探讨单子。
- en: In category theory, a monad is a morphism between functors. This means that
    a monad transforms the context of a contained value into another context. In pure
    functional programming languages, monads are data structures used to represent
    computations that are defined in steps. Each step is represented by an operation
    on a monad, and several of these steps can be chained together. Essentially, a
    monad is a composable abstraction of a step of any computation. A distinct feature
    of monads is that they allow us to model impure side effects, which may be performed
    in the various steps of a given computation, using pure functions.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论中，单子是函子之间的一个形态。这意味着单子将包含值的上下文转换为另一个上下文。在纯函数式编程语言中，单子是用于表示按步骤定义的计算的数据结构。每个步骤由单子上的一个操作表示，并且可以链式连接多个这些步骤。本质上，单子是任何计算步骤的可组合抽象。单子的一个独特特征是它们允许我们使用纯函数来模拟在给定计算的各种步骤中可能执行的纯副作用。
- en: 'Monads abstract the way a function binds values to arguments and returns a
    value. Formally, a monad is an algebraic structure that implements two functions:
    `bind` and `return`. The `bind` function is used to apply a function to the value
    contained in a monad, and the `return` function can be thought of as a construct
    for wrapping values in a new monad instance. The type signatures of the `bind`
    and `return` functions can be described by the following pseudo code:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 单子抽象了函数将值绑定到参数并返回值的方式。形式上，单子是一个实现两个函数的代数结构：`bind`和`return`。`bind`函数用于将函数应用于单子中包含的值，而`return`函数可以被视为将值包裹在新的单子实例中的构造。`bind`和`return`函数的类型签名可以用以下伪代码描述：
- en: '[PRE266]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: The type signature of the `bind` function states that it accepts a value of
    type `Monad` `A` and a function that converts a value of type `A` to another value
    of type `Monad B`, which is simply a monad containing a value of type `B`. Also,
    the `bind` function returns a type `Monad B`. The `return` function's type signature
    shows that it takes a value of type `A` and returns a type `Monad A`. Implementing
    these two functions allows a monad to execute any code, defined in its `bind`
    implementation, before the supplied function `f` is applied to the value contained
    in the monad. A monad can also define code to be executed when the supplied function
    `f` returns a value, as defined by the monad's implementation of the `return`
    function.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数的类型签名表明它接受一个类型为`Monad A`的值和一个将类型`A`的值转换为另一个类型`Monad B`的函数，这只是一个包含类型`B`的值的单子。此外，`bind`函数返回类型`Monad
    B`。`return`函数的类型签名显示它接受一个类型为`A`的值并返回类型`Monad A`。实现这两个函数允许单子在其`bind`实现中定义的任何代码在将提供的函数`f`应用于单子中包含的值之前执行。单子还可以定义当提供的函数`f`返回值时执行的代码，这是由单子的`return`函数实现定义的。'
- en: Due to the fact that a monad can do more than just call a function over its
    contained value when passed to the `bind` function, a monad is used to indicate
    side effects in pure functional programming languages. Let's say, we have a function
    that maps type `A` to `B`. A function that maps type `A` to `Monad B` can be used
    to model the side effects that can occur when a value of type `A` is converted
    to another value of type `B`. In this way, monads can be used to represent side
    effects, such as IO, change of state, exceptions, and transactions.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在传递给`bind`函数时，单子不仅可以对其包含的值调用函数，还可以做更多的事情，因此在纯函数式编程语言中，单子被用来表示副作用。比如说，我们有一个将类型`A`映射到`B`的函数。一个将类型`A`映射到`Monad
    B`的函数可以用来模拟当类型`A`的值转换为另一个类型`B`的值时可能发生的副作用。这样，单子可以用来表示副作用，如IO、状态改变、异常和事务。
- en: Some programmers may even argue that monads are unnecessary in a language with
    macros. This is true in some sense, because macros can encapsulate side effects
    in them. However, monads help us to be explicit about any side-effects, which
    is quite useful. In fact, monads are the only way to model side effects in pure
    functional programming languages. Because monads can represent side effects, they
    allow us to write imperative-style code, which is all about mutation of state,
    in a pure functional programming language.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员甚至可能会争论，在具有宏的语言中，单子是不必要的。在某种程度上这是正确的，因为宏可以封装它们中的副作用。然而，单子帮助我们明确任何副作用，这非常有用。实际上，在纯函数式编程语言中，单子是唯一可以用来模拟副作用的方法。因为单子可以表示副作用，它们允许我们在纯函数式编程语言中编写命令式风格的代码，这完全是关于状态的修改。
- en: Note
  id: totrans-1151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c6/` `monads.clj` of the book's
    source code.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c6/` `monads.clj` 中找到。
- en: 'Let''s now look at how the `Maybe` type from the `cats` library can take the
    form of a monad. We can pass a `Maybe` value along with a function to the `cats.core/bind`
    function to call the supplied function with the contained value in the monad.
    This function is aliased as `>>=`. The behavior of the `bind` function with a
    `Maybe` type is shown here:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `cats` 库中的 `Maybe` 类型如何以单子的形式出现。我们可以将 `Maybe` 值和函数传递给 `cats.core/bind`
    函数，以在单子中包含的值上调用提供的函数。此函数别名为 `>>=`。`bind` 函数与 `Maybe` 类型的行为如下所示：
- en: '[PRE267]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'In this way, we can *bind* the `inc` function to a `Maybe` monad. The expression
    shown in the preceding output can be depicted by the following diagram:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以将 `inc` 函数绑定到 `Maybe` 单子上。前述输出中的表达式可以用以下图表示：
- en: '![Using monads](img/B05024_06_06.jpg)'
  id: totrans-1156
  prefs: []
  type: TYPE_IMG
  zh: '![使用单子](img/B05024_06_06.jpg)'
- en: 'The `inc` function is applied to a `Maybe` monad only if it contains a value.
    When a `Maybe` monad does contain a value, applying the `inc` function to it using
    the `bind` function will simply return `2`, and not a monad containing `2`. This
    is because the standard `inc` function does not return a monad. On the other hand,
    an empty `Maybe` value is returned untouched. To return a monad in both the preceding
    cases, we can use the `return` function from the `cats.core` namespace, as shown
    here:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc` 函数仅在 `Maybe` 单子包含值时应用。当一个 `Maybe` 单子确实包含值时，使用 `bind` 函数将其应用于 `inc` 函数将简单地返回
    `2`，而不是包含 `2` 的单子。这是因为标准的 `inc` 函数不返回单子。另一方面，一个空的 `Maybe` 值将保持不变。为了在这两种情况下都返回单子，我们可以使用
    `cats.core` 命名空间中的 `return` 函数，如下所示：'
- en: '[PRE268]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The `lift-m` form can be used to *lift* a function that returns a type `A`
    to return a monad containing a type `A`. The concrete type of the return value
    of a lifted function depends on the monad context passed to it. If we pass a `Maybe`
    monad to a lifted version of `inc`, it will return a new instance of the `Maybe`
    monad, as shown here:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '`lift-m` 形式可以用来将返回类型 `A` 的函数提升为返回包含类型 `A` 的单子。提升函数的返回值的具体类型取决于传递给它的单子上下文。如果我们将
    `Maybe` 单子传递给 `inc` 的提升版本，它将返回一个新的 `Maybe` 单子实例，如下所示：'
- en: '[PRE269]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'We can also compose several calls to the `bind` function, as long as the function
    passed to the `bind` function produces a monad, as shown here:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合多个对 `bind` 函数的调用，只要传递给 `bind` 函数的函数产生单子，如下所示：
- en: '[PRE270]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Of course, we can also compose calls to the `bind` function to change the type
    of monad. For example, we can map a `Maybe` monad to an `Identity` monad, which
    is constructed using the `cats.monads.identity/identity` function. We can modify
    the preceding expression to return an `Identity` monad as shown here:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以组合对 `bind` 函数的调用以更改单子的类型。例如，我们可以将 `Maybe` 单子映射到 `Identity` 单子，该单子使用
    `cats.monads.identity/identity` 函数构建。我们可以修改前面的表达式以返回一个 `Identity` 单子，如下所示：
- en: '[PRE271]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'As shown in the preceding output, calling the `bind` function multiple times
    can get a bit cumbersome. The `mlet` form lets us compose expressions that return
    monads, as shown in *Example 6.2*:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，多次调用 `bind` 函数可能会有些繁琐。`mlet` 形式允许我们组合返回单子的表达式，如 *示例 6.2* 所示：
- en: '[PRE272]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '*Example 6.2\. The mlet form*'
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 6.2\. mlet 形式*'
- en: 'In short, the `process-with-maybe` function defined in *Example 6.2* checks
    whether a number is even, then prints a line and increments the number. As we
    use the `Maybe` type, the last two steps of printing a line and incrementing a
    value are performed only if the input `x` is even. In this way, an empty `Maybe`
    monad, created using the `nothing` function, can be used to short-circuit a composition
    of monads. We can verify this behavior of the `process-with-maybe` function in
    the REPL, as shown here:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*示例 6.2* 中定义的 `process-with-maybe` 函数检查一个数字是否为偶数，然后打印一行并增加该数字。由于我们使用了 `Maybe`
    类型，打印一行和增加值的最后两个步骤仅在输入 `x` 为偶数时执行。这样，使用 `nothing` 函数创建的空 `Maybe` 单子可以用来短路单子的组合。我们可以在
    REPL 中验证 `process-with-maybe` 函数的此行为，如下所示：
- en: '[PRE273]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: As shown here, the `process-with-maybe` function prints a line only when the
    supplied value `x` is an even number. If not, an empty `Maybe` monad instance
    is returned.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，`process-with-maybe` 函数仅在提供的值 `x` 是偶数时打印一行。如果不是，则返回一个空的 `Maybe` 单子实例。
- en: The previous examples describe how we can use the `Maybe` monad. The `cats`
    library also provides implementations of the `Either` and `Exception` monads,
    in the `cats.monads.either` and `cats.monads.exception` namespaces respectively.
    Let's explore a few constructs from the `cats.monads.exception` namespace.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子描述了我们可以如何使用 `Maybe` 单子。`cats` 库还提供了 `Either` 和 `Exception` 单子的实现，分别在 `cats.monads.either`
    和 `cats.monads.exception` 命名空间中。让我们探索 `cats.monads.exception` 命名空间中的几个构造。
- en: 'We can create a new `Exception` monad instance using the `success` and `failure`
    functions. The `success` form can be passed any value, and it returns a monad
    that represents a successful step in a computation. On the other hand, the `failure`
    function must be passed a map containing an `:error` key that points to an exception,
    and returns a monad that represents a failure in a computation. The value or exception
    contained in an `Exception` monad can be obtained by dereferencing it (using the
    `deref` form or the `@` reader macro). Another way to create an `Exception` monad
    instance is by using the `try-on` macro. The following output describes how these
    constructs can be used to create an instance of the `Exception` monad:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `success` 和 `failure` 函数创建一个新的 `Exception` 单子实例。`success` 形式可以传入任何值，并返回表示计算中成功步骤的单子。另一方面，`failure`
    函数必须传入一个包含指向异常的 `:error` 键的映射，并返回表示计算中失败的单子。可以通过解引用（使用 `deref` 形式或 `@` 读取宏）来获取
    `Exception` 单子中包含的值或异常。另一种创建 `Exception` 单子实例的方法是使用 `try-on` 宏。以下输出描述了如何使用这些构造来创建
    `Exception` 单子的实例：
- en: '[PRE274]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'The `try-on` macro will return a failure instance of the `Exception` monad
    if the expression passed to it throws an error, as shown here:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-on` 宏会在传入的表达式抛出错误时返回一个 `Exception` 单子失败实例，如下所示：'
- en: '[PRE275]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'A failure instance of an `Exception` monad can be used to short-circuit a composition
    of monads. This means that binding an `Exception` monad to a function will not
    call the supplied function if the monad contains an error. This is similar to
    how exceptions are used to halt computations. We can verify this using the `bind`
    function, as shown here:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Exception` 单子的失败实例可以用来短路单子的组合。这意味着如果单子包含错误，将 `Exception` 单子绑定到函数将不会调用提供的函数。这与异常用于停止计算的方式类似。我们可以使用
    `bind` 函数来验证这一点，如下所示：
- en: '[PRE276]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Instances of the `Exception` monad can also be created using the `try-or-else`
    and `try-or-recover` macros from the `cats.monads.exception` namespace. The `try-or-else`
    form must be passed an expression and a default value. If the expression passed
    to this form throws an exception, the default value is wrapped in an `Exception`
    monad instance and returned. The `try-or-recover` form must be passed a 1-arity
    function in place of the default value. In case an error is encountered, the `try-or-recover`
    macro will invoke the supplied function and relay the value returned by it. The
    `try-or-else` and `try-or-recover` f3orms are demonstrated as follows:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `cats.monads.exception` 命名空间中的 `try-or-else` 和 `try-or-recover` 宏来创建 `Exception`
    单子的实例。`try-or-else` 形式必须传入一个表达式和一个默认值。如果传入此形式的表达式抛出异常，则默认值会被包裹在一个 `Exception`
    单子实例中并返回。`try-or-recover` 形式必须传入一个代替默认值的 1-arity 函数。在遇到错误的情况下，`try-or-recover`
    宏将调用提供的函数并转达其返回的值。以下是如何演示 `try-or-else` 和 `try-or-recover` 形式的：
- en: '[PRE277]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: In this way, monads can be used to model side effects using pure functions.
    We've demonstrated how we can use the `Maybe` and `Exception` monad types. The
    `cats` library also implements other interesting monad types. There are monad
    laws as well, and any monad that we implement must conform to these laws. You
    are encouraged to learn more about the monad laws on your own.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，单子可以用纯函数来模拟副作用。我们已经展示了如何使用 `Maybe` 和 `Exception` 单子类型。`cats` 库还实现了其他有趣的单子类型。还有单子定律，我们实现的任何单子都必须遵守这些定律。我们鼓励你自己学习更多关于单子定律的知识。
- en: Summary
  id: totrans-1181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about the notations and terminology used in category
    theory. We also discussed several algebraic types from category theory. Each of
    these abstractions have laws that must be satisfied by their implementations,
    and these laws can be thought of as optimizations for computations that use these
    algebraic types.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了范畴论中使用的符号和术语。我们还讨论了几种来自范畴论代数类型。这些抽象都有必须由其实现满足的定律，这些定律可以被视为使用这些代数类型的计算优化。
- en: In the next chapter, we will look at a different paradigm of programming altogether—logic
    programming.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种完全不同的编程范式——逻辑编程。
- en: Chapter 7. Programming with Logic
  id: totrans-1184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用逻辑编程
- en: We will now take a step back from the realm of functional programming and explore
    a completely different paradigm—**logic programming**. Logic programming has its
    own unique way of solving computational problems. Of course, logic programming
    isn't the only way to solve a problem, but it's interesting to see what kind of
    problems can be easily solved with it.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从函数式编程的领域退一步，探索一个完全不同的范式——**逻辑编程**。逻辑编程有其独特的解决计算问题的方法。当然，逻辑编程不是解决问题的唯一方法，但看到哪些问题可以轻松地用逻辑编程解决是很有趣的。
- en: Although logic programming and functional programming are two completely different
    paradigms, they do have a few commonalities. Firstly, both of these paradigms
    are forms of *declarative programming*. Studies and papers have also shown that
    it is possible to implement the semantics of logic programming within a functional
    programming language. Hence, logic programming operates at a much higher degree
    of abstraction than functional programming. Logic programming is more suited for
    problems in which we have a set of rules, and we intend to find all the possible
    values that conform to these rules.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然逻辑编程和函数式编程是两种完全不同的范式，但它们确实有一些共同点。首先，这两种范式都是声明式编程的形式。研究和论文也表明，在函数式编程语言中可以实现逻辑编程的语义。因此，逻辑编程在抽象程度上比函数式编程要高得多。逻辑编程更适合于那些我们有规则集的问题，并且我们希望找到所有符合这些规则的可能值。
- en: In this chapter, we look at logic programming in Clojure through the `core.logic`
    library. We will also study a few computational problems and how we can solve
    them in a concise and elegant manner using logic programming.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过`core.logic`库来探讨Clojure中的逻辑编程。我们还将研究一些计算问题，以及如何使用逻辑编程以简洁优雅的方式解决这些问题。
- en: Diving into logic programming
  id: totrans-1188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入逻辑编程
- en: In Clojure, logic programming can be done using the `core.logic` library ([https://github.com/clojure/core.logic/](https://github.com/clojure/core.logic/)).
    This library is a port of **miniKanren**, which is a domain-specific language
    for logic programming. miniKanren defines a set of simple constructs for creating
    logical relations and generating results from them.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，可以使用`core.logic`库进行逻辑编程([https://github.com/clojure/core.logic/](https://github.com/clojure/core.logic/))。这个库是**miniKanren**的移植，它是一种用于逻辑编程的领域特定语言。miniKanren定义了一套简单的构造，用于创建逻辑关系并从中生成结果。
- en: Note
  id: totrans-1190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: miniKanren was originally implemented in the Scheme programming language. You
    can find out more about miniKanren at [http://minikanren.org/](http://minikanren.org/).
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: miniKanren最初是在Scheme编程语言中实现的。您可以在[http://minikanren.org/](http://minikanren.org/)了解更多关于miniKanren的信息。
- en: A program written using logic programming can be thought of as a set of logical
    relations. **Logical relations** are the elementary building blocks of logic programming,
    just as functions are for functional programming. The terms *relation* and *constraint*
    are used interchangeably to refer to a logical relation. The `core.logic` library
    is in fact an implementation of constraint-based logic programming.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑编程编写的程序可以被视为一组逻辑关系。**逻辑关系**是逻辑编程的基本构建块，就像函数是函数式编程的基本构建块一样。术语*关系*和*约束*可以互换用来指代逻辑关系。《core.logic》库实际上是基于约束的逻辑编程的实现。
- en: A relation can be thought of as a function that returns a goal, and a goal can
    either be a success or a failure. In the `core.logic` library, a goal is represented
    by the `succeed` and `fail` constants. Another interesting aspect of relations
    is that they can return multiple results, or even no results. This is analogous
    to a function that produces a sequence of values, which could be empty, as a result.
    Functions such as `keep` and `filter` fit this description perfectly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关系可以被认为是一个返回目标的函数，而一个目标可以是成功或失败。在`core.logic`库中，目标由`succeed`和`fail`常量表示。关系的另一个有趣方面是它们可以返回多个结果，甚至没有结果。这类似于产生一系列值的函数，其结果可以是空的。例如`keep`和`filter`这样的函数完美地符合这一描述。
- en: Note
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖项对于即将到来的示例是必需的：
- en: '[PRE278]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE279]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: The following examples can be found in `src/m_clj/c7/diving_into_logic.clj`
    of the book's source code.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在本书源代码的`src/m_clj/c7/diving_into_logic.clj`中找到。
- en: Solving logical relations
  id: totrans-1200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决逻辑关系
- en: As a convention, relations have their name suffixed with an "o". For example,
    the `conso` construct from the `clojure.core.logic` namespace is a relation that
    represents the behavior of the `cons` function. Logical programming constructs
    that use multiple logical relations, such as `conde` and `matche`, end with an
    "e". We will explore these constructs later on in this chapter. Let's now focus
    on how we can solve problems with logical relations.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，关系名称后缀为“o”。例如，来自`clojure.core.logic`命名空间中的`conso`构造是一个表示`cons`函数行为的关系。使用多个逻辑关系（如`conde`和`matche`）的逻辑编程构造以“e”结尾。我们将在本章后面探讨这些构造。现在让我们专注于如何使用逻辑关系解决问题。
- en: The `run*` macro, from the `clojure.core.logic` namespace, processes a number
    of goals to generate all possible results. The semantics of the `run*` form allow
    us to declare a number of logical variables that can be used in relations to return
    goals. The `run*` form returns a list of possible values for the logical variables
    it defines. An expression using the `run*` form and a set of relations is essentially
    a way of asking the question "What must the universe look like for these relations
    to be true?" to a computer and asking it to find the answer.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`clojure.core.logic`命名空间的`run*`宏处理多个目标以生成所有可能的结果。`run*`形式的语义允许我们在关系中声明多个逻辑变量，这些变量可以用来返回目标。`run*`形式返回它定义的逻辑变量的可能值列表。使用`run*`形式和一组关系表达式本质上是一种向计算机提问“为了使这些关系成立，宇宙必须是什么样子？”并要求它找到答案的方式。
- en: 'An equality test can be performed using the `run*` macro in combination with
    the `clojure.core.logic/==` form, as shown here:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`run*`宏与`clojure.core.logic/==`形式结合来执行等式测试，如下所示：
- en: '[PRE280]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Both the statements using the `run*` form in the preceding output find all possible
    values of the logical variable `x`. The relation `(l/== x 1)` returns a goal that
    succeeds when the value of `x` is equal to `1`. Obviously, the only value that
    `x` can have for this relation to succeed is `1`. The `run*` form evaluates this
    relation to return `1` in a list. On the other hand, the relation `(l/== 1 0)`
    is logically false, and thus produces no results when passed to the `run*` form.
    This means that there are no values of `x` for which `1` is equal to `0`.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中使用`run*`形式的语句都找到了逻辑变量`x`的所有可能值。关系`(l/== x 1)`在`x`的值为`1`时返回一个成功的目标。显然，对于这个关系成立，`x`只能有`1`这一个值。`run*`形式评估这个关系，以返回列表中的`1`。另一方面，关系`(l/==
    1 0)`在逻辑上是假的，因此当传递给`run*`形式时不会产生任何结果。这意味着没有`x`的值使得`1`等于`0`。
- en: 'A relation built using the `==` form from the `clojure.core.logic` namespace
    is called *unification*. Unification is often used in logic programming like variable
    assignment from other paradigms, as it''s used to assign values to variables.
    Conversely, a *disequality* represents a relation in which a logical variable
    cannot be equal to a given value. The `clojure.core.logic/!=` form is used to
    construct a disequality relation, as shown here:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`clojure.core.logic`命名空间中的`==`形式构建的关系称为*统一*。统一在逻辑编程中经常被用作从其他范式中的变量赋值，因为它用于给变量赋值。相反，*不等式*表示一个逻辑变量不能等于给定的值。`clojure.core.logic/!=`形式用于构建不等式关系，如下所示：
- en: '[PRE281]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The first statement in the preceding output produces no results since the relation
    `(l/!= 1 1)` is logically false. An interesting quirk is that the second statement,
    which has a goal that always succeeds produces a single result `_0`, which represents
    an *unbound* logical variable. As we don't assign a value to `x` through unification,
    its value is said to be unbound. The symbols `_0`, `_1`, `_2`, and so on (also
    written as `_.0`, `_.1`, `_.2`, and so on) represent unbound logical variables
    in the context of a `run*` form.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中的第一个语句没有产生结果，因为关系`(l/!= 1 1)`在逻辑上是假的。一个有趣的特点是，第二个语句有一个总是成功的目标，它产生单个结果`_0`，这代表一个*未绑定*的逻辑变量。由于我们没有通过统一为`x`分配值，因此它的值被认为是未绑定的。符号`_0`、`_1`、`_2`等（也写作`_.0`、`_.1`、`_.2`等）在`run*`形式的上下文中代表未绑定的逻辑变量。
- en: The `clojure.core.logic/conso` form is useful in modeling the behavior of the
    standard `cons` function as a relation. It takes three arguments, of which two
    are the same as the `cons` function. The first two arguments passed to a `conso`
    form represent the head and tail of a sequence.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.logic/conso`形式在模拟标准`cons`函数作为关系的行为时很有用。它接受三个参数，其中两个与`cons`函数相同。传递给`conso`形式的第一个两个参数代表序列的头部和尾部。'
- en: 'The third argument is a sequence that is expected to be returned on applying
    the `cons` function on the first two arguments. The `conso` relation can be demonstrated
    as follows:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个在应用`cons`函数到前两个参数时预期返回的序列。`conso`关系可以如下演示：
- en: '[PRE282]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The expression using a `conso` relation, in the preceding output, will solve
    for values of `x` that produce the value `[1 2 3]` when a `cons` form is applied
    to the values `1` and `[2 x]`. Obviously, `x` must be `3` for this relation to
    be true, and hence the result `3` is produced.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中使用`conso`关系表达式，将解决`x`的值，当对`1`和`[2 x]`应用`cons`形式时，将产生值`[1 2 3]`。显然，`x`必须是`3`，这样这个关系才成立，因此产生了结果`3`。
- en: 'Logical variables can be created without the use of a `run*` form using the
    `lvar` function from the `clojure.core.logic` namespace. Within a `run*` form,
    we can create local logical variables using the `clojure.core.logic/fresh` macro.
    Variables declared using a `fresh` form will not be part of the final result produced
    by the surrounding `run*` form. For example, consider the expressions using the
    `run*` forms in the following output:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用来自`clojure.core.logic`命名空间的`lvar`函数在不使用`run*`形式的情况下创建逻辑变量。在`run*`形式中，我们可以使用`clojure.core.logic/fresh`宏创建局部逻辑变量。使用`fresh`形式声明的变量将不会是周围`run*`形式产生的最终结果的一部分。例如，考虑以下输出中使用`run*`形式的表达式：
- en: '[PRE283]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The first expression shown previously produces the vector `[1 1]` as a result,
    whereas the second expression produces `1` as the result. This is because we specify
    a single logical variable `x` and use a `fresh` form to internally declare the
    logical variable `y` in the second expression.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的第一个表达式产生了结果向量`[1 1]`，而第二个表达式产生了结果`1`。这是因为我们在第二个表达式中指定了一个单个逻辑变量`x`，并使用`fresh`形式在内部声明了逻辑变量`y`。
- en: The `run*` form searches for results exhaustively from the set of relations
    provided to it. If we intend to find a limited number of results and avoid performing
    any additional computation to find any more results, we should use the `run` macro
    from the `clojure.core.logic` namespace instead. The `run` form has the same semantics
    of a `run*` form, but additionally requires the number of desired results to be
    passed to it as the first argument.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '`run*`形式在其提供的关系的集合中全面搜索结果。如果我们打算找到有限数量的结果并避免执行任何额外的计算来找到更多结果，我们应该使用来自`clojure.core.logic`命名空间的`run`宏。`run`形式具有与`run*`形式相同的语义，但还需要将所需的结果数量作为第一个参数传递给它。'
- en: 'The `clojure.core.logic.fd` namespace provides us with several constructs to
    deal with relations that are constrained over a finite range of values. For example,
    suppose we wanted to find values within the range of `0` to `100` that are greater
    than `10`. We can easily express this relation using the `>`, `in`, and `interval`
    forms from the `clojure.core.logic.fd` namespace and extract the first five values
    from it using a `run` form, as shown here:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.logic.fd`命名空间为我们提供了几个结构来处理在有限值范围内受约束的关系。例如，假设我们想要找到在`0`到`100`范围内的值，这些值大于`10`。我们可以很容易地使用来自`clojure.core.logic.fd`命名空间的`>`,
    `in`, 和 `interval`形式来表达这个关系，并使用`run`形式从中提取前五个值，如下所示：'
- en: '[PRE284]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The preceding expression uses the `in` and `interval` forms to constrain the
    value of the variable `x`. The expression using these two forms ensures that `x`
    is within the range of `0` and `100`. Also, the `clojure.core.logic.fd/>` function
    defines a relation in which `x` must be greater than `10`. The surrounding `run`
    form simply extracts the first five possible values of `x` from the relations
    supplied to it. There are also several other arithmetic comparison operators,
    namely `<`, `<=`, and `>=`, implemented in the `clojure.core.logic.fd` namespace.
    Instead of specifying a range of values to the `in` macro, we can also enumerate
    the possible values of a variable by using the `clojure.core.logic.fd/domain`
    form.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式使用了`in`和`interval`形式来约束变量`x`的值。使用这两个形式的表达式确保`x`在`0`和`100`的范围内。此外，`clojure.core.logic.fd/>`函数定义了一个关系，其中`x`必须大于`10`。周围的`run`形式简单地从它提供的关系中提取`x`的前五个可能值。在`clojure.core.logic.fd`命名空间中还实现了几个其他的算术比较运算符，即`<`、`<=`和`>=`。我们不仅可以通过指定`in`宏的值范围，还可以通过使用`clojure.core.logic.fd/domain`形式来枚举变量的可能值。
- en: 'The `firsto` form can be used to describe a relation in which the value in
    a given variable must be the first element in a collection. We can try out both
    the `domain` and `firsto` forms in the REPL as shown here:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '`firsto`形式可以用来描述一个关系，其中给定变量的值必须是集合中的第一个元素。我们可以像下面这样在REPL中尝试`domain`和`firsto`形式：'
- en: '[PRE285]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: In the preceding expression, we solve for the first set of values of `v`, `a`,
    `b`, and `x` that satisfy the following relations. The value of `a` must be less
    than that of `b`, which is shown using the `<` form, and both `a` and `b` must
    constitute the elements of a vector `v`, which is shown using the `==` form. Also,
    `a`, `b`, and `x` must be equal to either `0`, `1`, or `2`, as described by a
    composition of the `in` and `domain` forms. Lastly, the first element of the vector
    `v` must be equal to the value `x`. These relations generate the vector `[0 1]`
    and the values `0`, `1`, and `0` for `a`, `b`, and `x` respectively. Note the
    arity of the `in` form in the previous expression that allows multiple logical
    variables to be passed to it along with a constraint.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，我们求解满足以下关系的`v`、`a`、`b`和`x`的第一组值。`a`的值必须小于`b`的值，这通过`<`形式表示，并且`a`和`b`都必须是向量`v`的元素，这通过`==`形式表示。此外，`a`、`b`和`x`必须等于`0`、`1`或`2`，这是通过`in`和`domain`形式的组合来描述的。最后，向量`v`的第一个元素必须等于值`x`。这些关系生成了向量`[0
    1]`以及`a`、`b`和`x`分别为`0`、`1`和`0`的值。注意前述表达式中`in`形式的阶数，它允许将多个逻辑变量及其约束传递给它。
- en: Combining logical relations
  id: totrans-1223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合逻辑关系
- en: 'The `clojure.core.logic/conde` form allows us to specify multiple relations,
    and is a bit similar to the standard `cond` form. For example, consider the following
    expression that uses the `conde` form:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.core.logic/conde`形式允许我们指定多个关系，并且与标准的`cond`形式有点相似。例如，考虑以下使用`conde`形式的表达式：'
- en: '[PRE286]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'The preceding expression, which uses a `conde` form, performs equality checks
    for the symbols `A`, `B`, and `C` against the logical variable `x`. Only two of
    these checks produce a goal that succeeds, which is described using the `succeed`
    and `fail` constants in the clauses of the `conde` form. This logical branching
    by the `conde` form in the preceding expression can be illustrated through the
    following diagram:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`conde`形式的上述表达式对符号`A`、`B`和`C`与逻辑变量`x`进行了等值检查。只有其中两个检查产生了成功的目标，这在使用`conde`形式子句中的`succeed`和`fail`常量进行了描述。前述表达式中的`conde`形式通过以下图表说明了这种逻辑分支：
- en: '![Combining logical relations](img/B05024_07_01.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
  zh: '![组合逻辑关系](img/B05024_07_01.jpg)'
- en: The `conde` form in our previous example creates a conditional check for three
    clauses. Out of these three clauses, only two succeed, and hence the symbols `A`
    and `B` are returned as results. We should note that the clauses defined in a
    `conde` form can take any number of relations. Also, the use of the `l/succeed`
    constant is implicit, and we only need to use the `l/fail` constant to represent
    a goal that fails.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，`conde`形式创建了一个针对三个子句的条件检查。在这三个子句中，只有两个成功，因此返回了符号`A`和`B`作为结果。我们应该注意，在`conde`形式中定义的子句可以包含任意数量的关系。此外，`l/succeed`常量的使用是隐式的，我们只需要使用`l/fail`常量来表示一个失败的目标。
- en: 'Another way to perform equality checks is by pattern matching. This can be
    done using the `clojure.core.logic/matche` form. The `matche` form is thus a more
    idiomatic way to define conditional branches involving logical variables, as shown
    here:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行相等性检查的方法是通过模式匹配。这可以通过使用`clojure.core.logic/matche`形式来完成。因此，`matche`形式是定义涉及逻辑变量的条件分支的更自然的方式，如下所示：
- en: '[PRE287]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Both of the preceding expressions produce the same result. The only difference
    between these expressions is that the first one uses a `conde` form and the second
    one performs a pattern match using a `matche` form. Also, the `l/succeed` constant
    is implicit and does not need to be specified, similar to a `conde` form. The
    `_` wildcard is also supported by the `matche` form, as shown here:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 两个先前的表达式产生相同的结果。这两个表达式之间的唯一区别是，第一个使用了一个`conde`形式，而第二个使用了一个`matche`形式来进行模式匹配。此外，`l/succeed`常量是隐式的，不需要指定，类似于`conde`形式。`_`通配符也由`matche`形式支持，如下所示：
- en: '[PRE288]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: In the preceding expression, we solve for all values of `x` that match the pattern
    `'A`. All other cases fail, which is described using the `_` wildcard and the
    `l/fail` constant. Of course, the pattern using the `_` wildcard is implicit and
    is only shown to describe how it can be used in a `matche` form.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述表达式中，我们求解了所有与模式`'A'`匹配的`x`的值。所有其他情况都失败，这使用`_`通配符和`l/fail`常量来描述。当然，使用`_`通配符的模式是隐式的，这里只是为了说明如何在`matche`形式中使用它。
- en: 'The `matche` construct also supports destructuring of sequences. A sequence
    can be destructured by a `matche` form using a dot (`.`) to delimit the head and
    tail of the sequence, as shown here:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '`matche`构造也支持序列的解构。一个序列可以通过`matche`形式使用点（`.`）来界定序列的头部和尾部进行解构，如下所示：'
- en: '[PRE289]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'In the preceding expression, the logical variable `x` must be `(2 3)` for the
    relation defined using the `matche` form to succeed. We can define relations using
    a syntax similar to the `defn` form using the `defne` macro from the `clojure.core.logic`
    namespace. The `defne` form allows us to define relations in pattern matching
    style. Incidentally, a lot of constructs in the `core.logic` library are defined
    using the `defne` form. For example, consider the definition of the `membero`
    relation in *Example 7.1*:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述表达式中，逻辑变量`x`必须为`(2 3)`，才能使使用`matche`形式定义的关系成功。我们可以使用与`defn`形式类似的语法，通过`clojure.core.logic`命名空间中的`defne`宏来定义关系。`defne`形式允许我们以模式匹配风格定义关系。顺便提一下，`core.logic`库中的许多结构都是使用`defne`形式定义的。例如，考虑*示例7.1*中`membero`关系的定义：
- en: '[PRE290]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '*Example 7.1: Defining the membero relation using the defne macro*'
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例7.1：使用defne宏定义membero关系*'
- en: 'The `membero` relation is used to ensure that a value `x` is a member of the
    collections `xs`. The implementation of this relation destructures the collection
    `xs` into its head and tail parts. If the value `x` is the head of the collection
    `xs`, the relation succeeds, otherwise the relation is called recursively with
    the value `x` and the tail of the destructured list `ys`. We can try out this
    relation with the `run*` form in the REPL, as shown here:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '`membero`关系用于确保值`x`是集合`xs`的成员。此关系的实现将集合`xs`解构为其头部和尾部部分。如果值`x`是集合`xs`的头部，则关系成功，否则关系将以值`x`和解构列表的尾部`ys`递归调用。我们可以在REPL中使用`run*`形式尝试此关系，如下所示：'
- en: '[PRE291]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: The preceding expression solves for values of `x` that are contained in the
    range `0` to `5` as well as in the range `3` to `10`. The results `3` and `4`
    are produced from these two relations that use the `membero` form.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式求解了包含在范围`0`到`5`以及范围`3`到`10`内的`x`的值。结果`3`和`4`是由使用`membero`形式的这两个关系产生的。
- en: 'While dealing with logical variables, it''s important to note that we cannot
    use standard functions to perform any computation with them. In order to extract
    values from a bunch of logical variables, we have to use the `clojure.core.logic/project`
    form. For example, consider the following statement:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理逻辑变量时，需要注意的是，我们不能使用标准函数对它们进行任何计算。为了从一组逻辑变量中提取值，我们必须使用`clojure.core.logic/project`形式。例如，考虑以下语句：
- en: '[PRE292]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The preceding statement solves for two values of `x` and `y` such that they
    are both in the range `1` to `10` and their sum is equal to `5`. The values `[1
    4]` and `[2 3]` are returned as results. The `project` form is used to extract
    the values of `x` and `y`, or else the `+` function would throw an exception.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的陈述求解了两个 `x` 和 `y` 的值，它们都在 `1` 到 `10` 的范围内，并且它们的和等于 `5`。返回的结果是 `[1 4]` 和 `[2
    3]`。使用 `project` 形式来提取 `x` 和 `y` 的值，否则 `+` 函数会抛出异常。
- en: Thus, the `core.logic` library provides us with a handful of constructs that
    can be used to define logical relations, combine them, and generate results from
    them.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`core.logic` 库为我们提供了一系列构造，可以用来定义逻辑关系、组合它们并从中生成结果。
- en: Thinking in logical relations
  id: totrans-1246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以逻辑关系思考
- en: Now that we are well versed with the various constructs from the `core.logic`
    library, let's look at some real world problems that can be solved through logic
    programming.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 `core.logic` 库中的各种构造，让我们看看一些可以通过逻辑编程解决的问题。
- en: Solving the n-queens problem
  id: totrans-1248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决 n-皇后问题
- en: The **n-queens problem** is an interesting problem that can be implemented using
    logical relations. The objective of the n-queens problem is to place *n* queens
    on an *n* *x* *n* sized chessboard such that no two queens are a threat to each
    other. This problem is a generalization of the *eight queens problem* published
    by Max Bezzel in 1848, which involves eight queens. In fact, we can actually solve
    the n-queens problem for any number of queens, as long as we are dealing with
    four or more queens. Traditionally, this problem can be solved using an algorithmic
    technique called *backtracking*, which is essentially an exhaustive search for
    all possible solutions to a given problem. However, in this section, we will solve
    it using logical relations.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '**n-皇后问题**是一个有趣的问题，可以使用逻辑关系来实现。n-皇后问题的目标是放置 *n* 个女王在一个 *n* *x* *n* 大小的棋盘上，使得没有两个女王会相互构成威胁。这个问题是
    1848 年由 Max Bezzel 发布的 *八皇后问题* 的一般化，涉及八个皇后。实际上，我们可以解决任何数量的 n-皇后问题，只要我们处理的是四个或更多的皇后。传统上，这个问题可以使用一种称为
    *回溯算法* 的算法技术来解决，它本质上是对给定问题所有可能解决方案的穷举搜索。然而，在本节中，我们将使用逻辑关系来解决它。'
- en: 'Let''s first define how a queen can be used. As we all know, a queen can move
    as she wishes! A queen can move horizontally, vertically, or diagonally on a chessboard.
    If any other chess piece is on the same path on which a queen can be moved, then
    the queen is a threat to it. The position of a chess piece on the chessboard can
    be specified using a pair of integers, just like how Cartesian coordinates can
    be used to represent the position of a point on a plane. Suppose the pairs (*x[1],
    y[1]) and (x[2], y[2]*) represent the positions of two queens on the chessboard.
    As they can threaten each other horizontally, vertically, or diagonally, there
    are three distinct cases we must avoid:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一下如何使用女王。众所周知，女王可以随心所欲地移动！女王可以在棋盘上水平、垂直或对角线移动。如果任何其他棋子在女王可以移动的同一路径上，那么女王就会对其构成威胁。棋子在棋盘上的位置可以使用一对整数来指定，就像如何使用笛卡尔坐标来表示平面上点的位置一样。假设
    (*x[1], y[1]) 和 (x[2], y[2]*) 代表棋盘上两个女王的坐标。由于它们可以在水平、垂直或对角线上相互威胁，我们必须避免以下三种不同的情况：
- en: The queens cannot be on the same vertical path, that is, *x[1]* equal to *x[2]*.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 女王不能位于相同的垂直路径上，也就是说，*x[1]* 等于 *x[2]*。
- en: Similarly, the queens cannot be on the same horizontal path, that is, *y[1]*
    equal to *y[2].*
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，女王不能位于相同的水平路径上，也就是说，*y[1]* 等于 *y[2]*。
- en: The queens cannot be on the same diagonal path, in which case the ratio vertical
    and horizontal distance between them is either `1` or `-1`. This is actually a
    trick from coordinate geometry, and its proof is way out of the scope of our discussion.
    This case can be concisely represented by the following equations:![Solving the
    n-queens problem](img/B05024_07_03.jpg)
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 女王不能位于相同的对角路径上，在这种情况下，它们之间的垂直和水平距离的比率要么是 `1`，要么是 `-1`。这实际上是坐标几何中的一个技巧，其证明超出了我们讨论的范围。这种情况可以用以下方程简洁地表示：![解决
    n-皇后问题](img/B05024_07_03.jpg)
- en: 'These are the only rules that determine whether two queens threaten each other.
    Yet if you think about them from a procedural or object-oriented perspective,
    implementing them could require a good amount of code. On the contrary, if we
    think in terms of relations, we can implement these three rules fairly easily
    using the `core.logic` library, as shown in the following *Example 7.2*:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是确定两个皇后是否相互威胁的唯一规则。然而，如果你从程序或面向对象的视角来思考，实现它们可能需要大量的代码。相反，如果我们从关系的角度思考，我们可以使用
    `core.logic` 库相对容易地实现这三个规则，如以下 *示例 7.2* 所示：
- en: Note
  id: totrans-1255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c7/nqueens.clj` of the book's
    source code. This example is based on code from *n-queens with core.logic* by
    Martin Trojer([http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html)).
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c7/nqueens.clj` 中找到。此示例基于 Martin Trojer 的代码 *使用 core.logic
    的 n-皇后问题*([http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html))。
- en: '[PRE293]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '*Example 7.2: The n-queens problem*'
  id: totrans-1258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.2：n-皇后问题*'
- en: In *Example 7.2*, we define two relations, namely `safeo` and `nqueenso`, to
    describe the n-queens problem. Both of these relations must be passed a list `qs`
    as an argument, where `qs` contains coordinate pairs that represent the positions
    of queens placed on the chessboard. They are interestingly recursive relations,
    and the termination is specified by the case in which `qs` is empty.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 7.2* 中，我们定义了两个关系，即 `safeo` 和 `nqueenso`，来描述 n-皇后问题。这两个关系都必须传递一个列表 `qs`
    作为参数，其中 `qs` 包含坐标对，代表放置在棋盘上的皇后位置。它们是递归关系，终止条件是 `qs` 为空。
- en: The `safeo` relation is an implementation of the three rules that determine
    whether two queens threaten each other. Note the way this relation uses a `project`
    form to extract the values `x1`, `y1`, `x2`, and `y2` to handle the case in which
    two queens are on the same diagonal path. The `nqueenso` relation processes all
    positions of queens from the list `qs` and ensures that each queen is safe. The
    `solve-queens` function initializes `n` logical variables using the `clojure.core.logic/lvar`
    form.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '`safeo` 关系是实现确定两个皇后是否相互威胁的三个规则的实现。注意这个关系如何使用 `project` 形式提取 `x1`、`y1`、`x2`
    和 `y2` 的值来处理两个皇后位于同一对角线路径上的情况。`nqueenso` 关系处理 `qs` 列表中的所有皇后位置，并确保每个皇后都是安全的。`solve-queens`
    函数使用 `clojure.core.logic/lvar` 形式初始化 `n` 个逻辑变量。'
- en: The value `qs` is initialized a list of vector pairs that each contain a logical
    variable and a number within the range of *0* to *n*. In effect, we initialize
    the *y* coordinates of all pairs, and solve for the *x* coordinates. The reasoning
    behind this is that as we are solving for *n* queens on a board with *n* columns
    and *n* rows, and each row will have a queen placed on it.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '`qs` 的值被初始化为一个向量对列表，每个向量对包含一个逻辑变量和范围在 *0* 到 *n* 之间的一个数字。实际上，我们初始化所有向量对的 *y*
    坐标，并求解 *x* 坐标。这样做的原因是，当我们在一个有 *n* 列和 *n* 行的棋盘上求解 *n* 后问题时，每一行都会放置一个皇后。'
- en: 'The `solve-nqueens` function returns a list of solutions that each contain
    a list of coordinate pairs. We can print this data in a more intuitive representation
    by using the `partition` and `clojure.pprint/pprint` functions, as shown in *Example
    7.3*:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve-nqueens` 函数返回一个包含坐标对列表的解决方案列表。我们可以通过使用 `partition` 和 `clojure.pprint/pprint`
    函数以更直观的方式打印这些数据，如 *示例 7.3* 所示：'
- en: '[PRE294]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '*Example 7.3: The n-queens problem (continued)*'
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.3：n-皇后问题（继续）*'
- en: 'Now, we just need to call the `solve-and-print-nqueens` function by passing
    it the number of queens. Let''s try to use this function to solve the n-queens
    problem for four queens, as shown here:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要通过传递皇后数量来调用 `solve-and-print-nqueens` 函数。让我们尝试使用此函数来解决四个皇后的 n-皇后问题，如下所示：
- en: '[PRE295]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: The `solve-and-print-nqueens` function prints two solutions for four queens.
    Each solution is printed as a bunch of nested lists, in which each inner list
    represents a row on the chessboard. The value `1` indicates that a queen is placed
    on that position on the chessboard. As you can see, none of the four queens threaten
    each other in either of the two solutions.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve-and-print-nqueens` 函数打印了四个皇后的两个解决方案。每个解决方案都打印为一组嵌套列表，其中每个内部列表代表棋盘上的一行。值
    `1` 表示在该位置上放置了一个皇后。正如你所见，在这两个解决方案中，四个皇后都没有相互威胁。'
- en: In this way, the `solve-nqueens` function uses relations to solve the n-queens
    problem. We mentioned earlier that the n-queens problem originally involved eight
    queens. There are totally 92 distinct solutions for eight queens, and the `solve-nqueens`
    function can find every single one of them. You are encouraged to try this out
    by passing the value `8` to the `solve-and-print-nqueens` function and verifying
    the solutions it prints.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，`solve-nqueens` 函数使用关系来解决八皇后问题。我们之前提到，八皇后问题最初涉及八个皇后。总共有 92 个不同的八皇后解决方案，`solve-nqueens`
    函数可以找到每一个。我们鼓励你通过将值 `8` 传递给 `solve-and-print-nqueens` 函数并验证它打印的解决方案来尝试这一点。
- en: Solving a Sudoku puzzle
  id: totrans-1269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决数独谜题
- en: Some of us may already be in love with the intuitive and mesmerizing Sudoku
    puzzles that we find in newspapers and magazines. This is another problem that
    involves logical rules. A Sudoku board is a *9* *x* *9* grid on which we can place
    digits. The grid is divided into nine smaller grids, each of which is further
    divided into *3* *x* *3* grids that contain digits. These smaller grids are also
    called *squares* or *boxes*. Some of the squares will be filled with boxes. The
    goal is to place digits on all positions on the grid such that each row, each
    column, and each of the smaller grids all contain distinct digits in the range
    1 through 9.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的一些人可能已经深深地爱上了我们在报纸和杂志上找到的直观迷人的数独谜题。这是一个涉及逻辑规则的问题。数独板是一个 *9* *x* *9* 的网格，我们可以在其上放置数字。网格被分成九个更小的网格，每个更小的网格进一步被分成包含数字的
    *3* *x* *3* 网格。这些更小的网格也被称为 *方格* 或 *盒子*。一些方格将被填充。目标是放置数字在网格的所有位置上，使得每一行、每一列以及每个更小的网格都包含
    1 到 9 范围内的不同数字。
- en: Let's implement the rules of a Sudoku puzzle in this way. We will create a logical
    variable for every possible position of a digit on a Sudoku board and solve for
    their values using the rules of the puzzle. The initial values of the digits on
    a Sudoku board can be provided as a single vector comprising of 81 numbers. In
    this implementation, we introduce a couple of new constructs that are useful in
    concisely describing the rules of a Sudoku puzzle. The `everyg` function from
    the `clojure.core.logic` namespace can be used to apply a relation over a list
    of logical variables, thus ensuring that a relation is true for all the supplied
    logical variables. We must also ensure that the logical variables in a row, column,
    and *3* *x* *3* sized grid in a Sudoku puzzle are distinct. This can done by using
    the `clojure.core.logic.fd/distinct` function. An implementation of this design
    of a Sudoku solver is shown in *Example 7.4*.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这种方式实现数独谜题的规则。我们将为数独板上每个可能的数字位置创建一个逻辑变量，并使用谜题的规则求解它们的值。数独板上数字的初始值可以作为一个包含
    81 个数字的单个向量提供。在这个实现中，我们引入了一些新的结构，这些结构在简洁地描述数独谜题的规则时非常有用。`clojure.core.logic` 命名空间中的
    `everyg` 函数可以用来在逻辑变量的列表上应用一个关系，从而确保该关系对所有提供的逻辑变量都为真。我们还必须确保数独谜题中行、列和 *3* *x* *3*
    大小的网格中的逻辑变量是不同的。这可以通过使用 `clojure.core.logic.fd/distinct` 函数来完成。这种数独求解器设计的实现示例如
    *示例 7.4* 所示。
- en: Note
  id: totrans-1272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c7/sudoku.clj` of the book's
    source code.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c7/sudoku.clj` 中找到。
- en: '[PRE296]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '*Example 7.4: A Sudoku solver*'
  id: totrans-1275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.4：数独求解器*'
- en: In *Example 7.4*, the `init-sudoku-board` relation initializes the logical variables
    `vars` from the puzzle `puzzle`, and the `solve-sudoku` function finds all possible
    solutions of the given puzzle. The `solve-sudoku` function creates the logical
    variables through a composition of the `repeatedly` and `clojure.core.logic/lvar`
    forms. These variables are then partitioned into rows, columns, and squares, represented
    by the variables `rows`, `cols`, and `squares` respectively. The `solve-sudoku`
    function then initializes the logical variables using the `init-sudoku-board`
    form, and uses a composition of the `everyg` and `distinct` forms to ensure that
    the rows, columns, and squares of a solution contain distinct values. All the
    logical variables are also bound to the range `1` through `9` using the internally
    defined `in-range` function.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 7.4* 中，`init-sudoku-board` 关系从谜题 `puzzle` 中初始化逻辑变量 `vars`，而 `solve-sudoku`
    函数找到给定谜题的所有可能解。`solve-sudoku` 函数通过 `repeatedly` 和 `clojure.core.logic/lvar` 表达式的组合创建逻辑变量。然后，这些变量被划分为行、列和方块，分别由变量
    `rows`、`cols` 和 `squares` 表示。`solve-sudoku` 函数随后使用 `init-sudoku-board` 表达式初始化逻辑变量，并使用
    `everyg` 和 `distinct` 表达式的组合来确保解的行、列和方块包含不同的值。所有逻辑变量也通过内部定义的 `in-range` 函数绑定到范围
    `1` 到 `9`。
- en: 'The `solve-sudoku` function defined in *Example 7.4* takes a vector of values
    representing the initial state of a Sudoku board as an argument and returns a
    list of solutions in which each solution is a vector. As a plain vector isn''t
    really an intuitive representation of a Sudoku board, let''s define a simple function
    to find all solutions of a given puzzle and print the solutions, as shown in *Example
    7.5*:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 7.4* 中定义的 `solve-sudoku` 函数接受一个表示数独棋盘初始状态的值向量作为参数，并返回一个列表，其中每个解都是一个向量。由于一个普通的向量并不是一个直观的数独棋盘表示，让我们定义一个简单的函数来找到给定谜题的所有解并打印出来，如
    *示例 7.5* 所示：
- en: '[PRE297]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '*Example 7.5: A Sudoku solver (continued)*'
  id: totrans-1279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.5：数独求解器（继续）*'
- en: The `solve-and-print-sudoku` function in *Example 7.5* calls the `solve-sudoku`
    function to determine all possible solutions to a given Sudoku puzzle and prints
    the results using the `partition` and `clojure.pprint/pprint` functions. Now,
    let's define a simple Sudoku puzzle to solve, as shown in *Example 7.6*.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 7.5* 中的 `solve-and-print-sudoku` 函数调用 `solve-sudoku` 函数来确定给定数独谜题的所有可能解，并使用
    `partition` 和 `clojure.pprint/pprint` 函数打印结果。现在，让我们定义一个简单的数独谜题来求解，如 *示例 7.6* 所示。
- en: '[PRE298]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '*Example 7.6: A Sudoku solver (continued)*'
  id: totrans-1282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.6：数独求解器（继续）*'
- en: 'Now, let''s pass the vector `puzzle-1` to the `solve-and-print-sudoku` function
    to print all possible solutions to it, as shown here:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将向量 `puzzle-1` 传递给 `solve-and-print-sudoku` 函数，以打印出所有可能的解，如下所示：
- en: '[PRE299]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'The `solve-sudoku` function finds a single solution to the Sudoku puzzle represented
    by the vector `puzzle-1` as shown previously. The puzzle represented by `puzzle-1`
    and its solution are shown on a Sudoku board in the following illustration:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve-sudoku` 函数找到了之前表示的由向量 `puzzle-1` 表示的数独谜题的单个解。由 `puzzle-1` 表示的谜题及其解在以下插图中的数独棋盘上显示：'
- en: '![Solving a Sudoku puzzle](img/B05024_07_02.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![求解数独谜题](img/B05024_07_02.jpg)'
- en: 'Example 7.7: A Sudoku solver (continued)'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7.7：数独求解器（继续）
- en: 'It is very likely that a Sudoku puzzle has multiple solutions. For example,
    the Sudoku puzzle represented by `puzzle-2` in *Example 7.7* has eight distinct
    solutions. You''re more than welcome to find the solutions to this puzzle using
    the `solve-and-print-sudoku` function:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能一个数独谜题有多个解。例如，*示例 7.7* 中的 `puzzle-2` 表示的数独谜题有八个不同的解。你完全可以使用 `solve-and-print-sudoku`
    函数来找到这个谜题的解：
- en: '[PRE300]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '*Example 7.7: A Sudoku solver (continued)*'
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 7.7：数独求解器（继续）*'
- en: In conclusion, we can implement the rules of a Sudoku puzzle as logical relations
    using the `core.logic` library.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以使用 `core.logic` 库将数独谜题的规则实现为逻辑关系。
- en: Summary
  id: totrans-1292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how Clojure can be used for logic programming.
    We introduced the `core.logic` library by exploring the various constructs provided
    by this library. We also studied how we can implement solutions to the n-queens
    problem and a Sudoku puzzle using the `core.logic` library.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 Clojure 进行逻辑编程。我们通过探索这个库提供的各种构造来介绍了 `core.logic` 库。我们还研究了如何使用
    `core.logic` 库实现 n-皇后问题和数独谜题的解决方案。
- en: In the following chapter, we will get back on our journey through functional
    programming and talk about handling asynchronous tasks in Clojure.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的函数式编程之旅，并讨论在Clojure中处理异步任务。
- en: Chapter 8. Leveraging Asynchronous Tasks
  id: totrans-1295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。利用异步任务
- en: The term **asynchronous programming** refers to defining tasks that are executed
    *asynchronously* on different threads of execution. While this is similar to multithreading,
    there are a few subtle differences. Firstly, a thread or a future will remain
    allocated to a single operating system thread until completion. This leads to
    the fact that is there can only be a limited number of futures that can be executed
    concurrently, depending on the number of processing cores available. On the other
    hand, asynchronous tasks are scheduled for execution on threads from a thread
    pool. This way, a program can have thousands, or even millions of asynchronous
    tasks running concurrently. An asynchronous task can be suspended at any time,
    or *parked*, and the underlying thread of execution can be reallocated to another
    task. Asynchronous programming constructs also allow the definition of an asynchronous
    task to look like a sequence of synchronous calls, but each call could potentially
    be executed asynchronously.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**异步编程**指的是定义在不同执行线程上异步执行的任务。虽然这与多线程类似，但也有一些细微的差别。首先，一个线程或一个未来将保留分配给单个操作系统线程，直到完成。这导致了一个事实，即可以同时执行的未来数量是有限的，这取决于可用的处理核心数量。另一方面，异步任务被安排在线程池的线程上执行。这样，一个程序可以有数千个，甚至数百万个异步任务同时运行。异步任务可以在任何时候暂停，或者*停放*，并且执行线程可以被重新分配给另一个任务。异步编程结构还允许定义异步任务看起来像一系列同步调用，但每个调用可能都是异步执行的。
- en: In this chapter, we will explore various libraries and constructs that can be
    used for asynchronous programming in Clojure. First off, we will take a look at
    *processes* and *channels* in the `core.async` library for asynchronous programming.
    Later, we will explore *actors* from the *Pulsar* library. Processes and channels
    are constructs similar to *go-routines* in the Go programming language. On the
    other hand, actors were first popularized in the Erlang programming language.
    All of these techniques are different ways of structuring code that executes asynchronously.
    We must understand that the theory behind these concepts isn't really novel, and
    more implementations of these theories have been springing up since the rise of
    distributed and multi-core architectures. With that in mind, let's start off on
    our journey into asynchronous programming.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在Clojure中进行异步编程时可以使用的各种库和结构。首先，我们将查看`core.async`库中的*进程*和*通道*，用于异步编程。稍后，我们将探索来自*Pulsar*库的*actor*。进程和通道是与Go编程语言中的*go-routines*类似的构造。另一方面，actor最初在Erlang编程语言中流行起来。所有这些技术都是结构异步执行代码的不同方式。我们必须理解，这些概念背后的理论并不是真正新颖的，自从分布式和多核架构兴起以来，这些理论的更多实现已经层出不穷。有了这个想法，让我们开始我们的异步编程之旅。
- en: Using channels
  id: totrans-1298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道
- en: 'The `core.async` library ([https://github.com/clojure/core.async](https://github.com/clojure/core.async))
    facilitates asynchronous programming in Clojure. Through this library, we can
    use asynchronous constructs that run on both the JVM and web browsers without
    dealing with how they are scheduled for execution on low-level threads. This library
    is an implementation of the theory in the paper **Communicating Sequential Processes**
    (**CSPs**), originally published in the late ''70s by C. A. R. Hoare. The bottom
    line of CSPs is that any system that processes some input and provides an output
    can be comprised of smaller subsystems, and each subsystem can be defined in terms
    of *processes* and *queues*. A queue simply buffers data, and a process can read
    from and write to several queues. Here, we shouldn''t confuse the term *process*
    with an operating system process. In the context of CSPs, a process is simply
    a sequence of instructions that interacts with some data stored in queues. Several
    processes may exist in a given system and queues are a means of conveying data
    between them. A process that takes data from a single queue and outputs data to
    another queue can be illustrated as follows:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`库([https://github.com/clojure/core.async](https://github.com/clojure/core.async))促进了Clojure中的异步编程。通过这个库，我们可以在JVM和网页浏览器上使用异步构造，而无需处理它们在低级线程上的执行调度。这个库是实现C.
    A. R. Hoare在70年代末发表的论文中的理论，即**通信顺序进程**（**CSP**）。CSP的基本观点是，任何处理某些输入并提供输出的系统都可以由更小的子系统组成，每个子系统都可以用**进程**和**队列**来定义。队列简单地缓冲数据，进程可以从多个队列中读取和写入。在这里，我们不应该将术语**进程**与操作系统进程混淆。在CSP的上下文中，进程只是一系列与存储在队列中的某些数据交互的指令。一个系统中可能存在多个进程，队列是它们之间传递数据的一种方式。一个从单个队列中获取数据并将数据输出到另一个队列的进程可以表示如下：'
- en: '![Using channels](img/B05024_08_01.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
  zh: '![使用通道](img/B05024_08_01.jpg)'
- en: As shown in the preceding diagram, input data goes into a queue, a process manipulates
    this data through the queue, and finally, writes the output data to another queue.
    The `core.async` library essentially provides first-class support for creating
    processes and queues. Queues are dubbed as **channels** in the `core.async` library,
    and can be created using the `chan` function. Processes can be created using `go`
    and `thread` macros. Let's dive a bit deeper into the details.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，输入数据进入队列，进程通过队列操作这些数据，最后将输出数据写入另一个队列。`core.async`库本质上提供了创建进程和队列的一等支持。在`core.async`库中，队列被称为**通道**，可以使用`chan`函数创建。进程可以使用`go`和`thread`宏创建。让我们更深入地探讨一下细节。
- en: Note
  id: totrans-1302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖对于即将到来的示例是必需的：
- en: '[PRE301]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE302]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Processes, created using the `thread` and `go` forms, are scheduled for execution
    on thread pools. In fact, we can create several thousands of these processes in
    a program as they do not require their own dedicated thread. On the other hand,
    creating a large number of threads or futures would result in the excessive jobs
    being queued for execution. This imposes a practical limit on the number of threads
    or futures we can run concurrently. Hence, the `core.async` library, and CSPs
    in general, allows us to model a system as a large number of lightweight and concurrent
    processes.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`thread`和`go`形式创建的进程将在线程池上执行。实际上，我们可以在程序中创建数千个这样的进程，因为它们不需要自己的专用线程。另一方面，创建大量线程或未来会导致过多的作业排队等待执行。这实际上限制了我们可以同时运行的线程或未来的数量。因此，`core.async`库以及一般的CSP（通信顺序进程）允许我们将系统建模为大量轻量级和并发的进程。
- en: Channels can be thought of as data structures for managing the state between
    processes. The `chan` function from the `core.async` namespace returns a channel
    that can be read from and written to by several concurrent processes. Channels
    are *unbuffered* by default, which means a write operation to a channel will not
    complete until a read operation is invoked on it concurrently and vice versa.
    We can also create a *buffered* channel by specifying a number to the `chan` function
    to indicate the buffer size. A buffered channel will allow a certain number of
    values to be written to it without blocking, and the buffered values can then
    be read. A channel can be closed using the `close!` function from the `core.async`
    namespace.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将通道视为管理进程之间状态的数据结构。`core.async`命名空间中的`chan`函数返回一个可以由多个并发进程读取和写入的通道。默认情况下，通道是无缓冲的，这意味着对通道的写入操作将不会完成，直到并发地对其调用读取操作，反之亦然。我们还可以通过指定一个数字给`chan`函数来指定缓冲区大小来创建一个缓冲通道。缓冲通道将允许写入一定数量的值而不阻塞，然后可以读取这些缓冲值。可以使用`core.async`命名空间中的`close!`函数关闭通道。
- en: We can also create a buffered channel by passing a buffer object to the `chan`
    function. A buffer object can be created using the `buffer`, `dropping-buffer`,
    or `sliding-buffer` functions, and these functions require a number, indicating
    the size of the buffer, as an argument. Either of the expressions `(a/chan (a/buffer
    n))` or `(a/chan n)` can be used to create a channel that can buffer `n` values,
    and the channel will block write operations to it once it is filled with `n` values.
    The `dropping-buffer` function creates a buffer that drops newly added values
    once it's full. Conversely, a buffer created using the `sliding-buffer` function
    will drop the oldest values added to it once it is completely filled.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将缓冲区对象传递给`chan`函数来创建一个缓冲通道。可以使用`buffer`、`dropping-buffer`或`sliding-buffer`函数来创建缓冲区对象，这些函数需要一个数字作为参数，表示缓冲区的大小。可以使用`(a/chan
    (a/buffer n))`或`(a/chan n)`中的任何一个表达式来创建一个可以缓冲`n`个值的通道，一旦通道被填充了`n`个值，它将阻止对该通道的写入操作。`dropping-buffer`函数创建的缓冲区在满载后会丢弃新添加的值。相反，使用`sliding-buffer`函数创建的缓冲区在完全填满后会丢弃最老的值。
- en: 'The `core.async` library provides a handful of constructs for reading from
    and writing to channels, and the values passed to and returned by these constructs
    conform to a few simple rules. A read operation on a channel returns a value from
    the channel, or `nil` if the channel is closed. A write operation will return
    `true` if it succeeds, or `false` if the channel is closed and the write operation
    couldn''t be completed. We can read the buffered data from a closed channel, but
    once the channel is exhausted of data, a read operation on it will return `nil`.
    The arguments to the read and write operations for channels conform to the following
    pattern:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`库提供了一些用于从通道读取和写入的构造，传递给这些构造的值遵循一些简单的规则。对通道的读取操作会从通道返回一个值，如果通道已关闭，则返回`nil`。如果写入操作成功，则返回`true`，如果通道已关闭且写入操作无法完成，则返回`false`。我们可以从已关闭的通道中读取缓冲数据，但一旦通道中的数据耗尽，对该通道的读取操作将返回`nil`。通道的读取和写入操作的参数遵循以下模式：'
- en: The first argument to any operation is a channel.
  id: totrans-1311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何操作的第一个参数都是一个通道。
- en: A write operation must be passed a value to put onto a channel in addition to
    the channel itself.
  id: totrans-1312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了通道本身外，写入操作还必须传递一个值以放入通道。
- en: At this point, we should note that in the context of channels, the terms "write"
    and "put" can be used interchangeably, and similarly, the terms "read" and "take"
    refer to the same operation. The `take!` and `put!` functions take data and put
    data onto a queue. Both these functions return immediately, and can be passed
    a callback function as an argument in addition to the usual parameters. Similarly,
    the `<!!` and `>!!` functions can be used to read from and write to a channel,
    respectively. However, the `<!!` operation can block the calling thread if there
    is no data in the supplied channel and the `>!!` operation will be blocked if
    there is no more buffer space available in a given channel. These two operations
    are meant to be used within a `thread` form. Finally, the parking read and write
    functions, namely `<!` and `>!`, can be used within a `go` form to interact with
    a channel. Both the `<!` and `>!` operations will park the state of the task and
    release the underlying thread of execution if an operation cannot be completed
    immediately.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 在通道的上下文中，我们应该注意，“写入”和“放置”这两个术语可以互换使用，同样，“读取”和“获取”这两个术语也指代相同的操作。`take!` 和 `put!`
    函数从队列中获取数据和放置数据。这两个函数都会立即返回，并且除了常规参数外，还可以传递一个回调函数作为参数。同样，`<!!` 和 `>!!` 函数可以分别用于从通道读取和写入。然而，如果提供的通道中没有数据，`<!!`
    操作会阻塞调用线程，而如果没有更多缓冲空间可用，`>!!` 操作将被阻塞。这两个操作旨在在 `thread` 形式中使用。最后，暂停读写函数，即 `<!`
    和 `>!`，可以在 `go` 形式中用于与通道交互。`<!` 和 `>!` 操作都会暂停任务状态，并在无法立即完成操作时释放底层执行线程。
- en: Let's move on to the details of creating processes using the `core.async` library.
    The `core.async/thread` macro is used to create a single-threaded process. It
    is similar to the `future` form in the sense that the body of a `thread` form
    is executed on a new thread and a call to a `thread` form returns immediately.
    A `thread` form returns a channel from which the output of its body can be read.
    This makes the `thread` form a bit more convenient than the standard `future`
    form for interacting with channels, and is thus preferred over a `future` form.
    The `<!!` and `>!!` functions can be used within a `thread` form to interact with
    a channel.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨使用 `core.async` 库创建过程的细节。`core.async/thread` 宏用于创建单线程过程。在意义上，它与 `future`
    形式相似，即 `thread` 形式的主体在新的线程上执行，并且对 `thread` 形式的调用会立即返回。`thread` 形式返回一个通道，可以从其中读取其主体的输出。这使得
    `thread` 形式在处理通道方面比标准 `future` 形式更方便，因此更受欢迎。`<!!` 和 `>!!` 函数可以在 `thread` 形式中用于与通道交互。
- en: To create an asynchronous process that can be parked and scheduled for execution,
    we must use the `go` macro from the `core.async` namespace. Similar to the `thread`
    form, it returns a channel from which the output of its body can be read. All
    channel operations within the body of the `go` form will park, rather than blocking
    the underlying thread of execution. This implies that the executing thread will
    not be blocked and can be reallocated to another asynchronous process. Thus, the
    execution of a number of `go` forms can be interleaved over a much lesser number
    of actual threads. We must ensure that no thread-specific operations, such as
    `Thread/sleep`, are made within a `go` form, as such operations affect the underlying
    thread of execution. Within a `go` form, we must always use the `<!` and `>!`
    parking forms to read from and write to a channel.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可以暂停并调度执行的非阻塞异步过程，我们必须使用 `core.async` 命名空间中的 `go` 宏。与 `thread` 形式类似，它返回一个通道，可以从其中读取其主体的输出。`go`
    形式主体内的所有通道操作都将暂停，而不是阻塞执行线程。这意味着执行线程不会被阻塞，可以被重新分配到另一个异步过程。因此，多个 `go` 形式的执行可以交织在更少的实际线程上。我们必须确保在
    `go` 形式中不执行任何特定于线程的操作，如 `Thread/sleep`，因为这些操作会影响执行线程。在 `go` 形式中，我们必须始终使用 `<!`
    和 `>!` 暂停形式来从通道读取和写入。
- en: Note
  id: totrans-1316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [https://clojure.github.io/core.async/](https://clojure.github.io/core.async/)
    for the complete documentation on all the functions and macros in the `core.async`
    library.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://clojure.github.io/core.async/](https://clojure.github.io/core.async/)
    获取关于 `core.async` 库中所有函数和宏的完整文档。
- en: The `go-loop` macro is an asynchronous version of the `loop` form, and accepts
    a vector of bindings as its first argument, followed by any number of forms that
    must be executed. The body of a `go-loop` form will be internally executed within
    a `go` form. The `go-loop` construct is often used to create asynchronous event
    loops that have their own localized state. As an example, let's consider the simple
    `wait-and-print` function that sets off a process that reads from a given channel,
    as shown in *Example 8.1*.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-loop` 宏是 `loop` 形式的异步版本，它接受一个绑定向量作为其第一个参数，后面跟着任何必须执行的形式。`go-loop` 形式的主体将在
    `go` 形式内部执行。`go-loop` 构造通常用于创建具有自己局部状态的异步事件循环。作为一个例子，让我们考虑一个简单的 `wait-and-print`
    函数，该函数启动一个从给定通道读取的过程，如 *示例 8.1* 所示。'
- en: Note
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c8/async.clj` of the book's
    source code.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c8/async.clj` 中找到。
- en: '[PRE303]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '*Example 8.1: A function that asynchronously reads from a channel*'
  id: totrans-1322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.1：一个异步从通道读取的函数*'
- en: 'The `wait-and-print` function shown previously will repeatedly read from the
    channel `c` passed to it. The `when` form is used to check if the value read from
    channel, represented by `v`, is not `nil`, since `nil` could be returned from
    the `<!` form if the channel `c` is closed. The `go-loop` form in the previous
    example also counts the number of values read from the channel using the variable
    `n`. On receiving a value from the channel, some information is printed and the
    body is looped over using a `recur` form. We can create a channel, pass it to
    the `wait-and-print` function and observe the output of sending values to the
    channel, as shown here:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的 `wait-and-print` 函数会反复从传递给它的通道 `c` 中读取。使用 `when` 形式是为了检查从通道读取的值，用 `v`
    表示，是否不是 `nil`，因为如果通道 `c` 被关闭，`<!` 形式可能会返回 `nil`。之前示例中的 `go-loop` 形式也使用变量 `n` 来计算从通道读取的值的数量。在从通道接收到值时，会打印一些信息，并使用
    `recur` 形式循环体。我们可以创建一个通道，将其传递给 `wait-and-print` 函数，并观察向通道发送值的输出，如下所示：
- en: '[PRE304]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'As shown previously, a call to the `wait-and-print` function starts an asynchronous
    event loop that reads from the channel `c`. On sending a value to the channel
    `c` using a `>!!` form, the value gets printed along with a total count of values
    sent to the channel. Also, calls to the `>!!` form return the value `true` immediately.
    Now, let''s see what happens when we close the channel `c` using the `close!`
    function, shown as follows:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，调用 `wait-and-print` 函数启动一个异步事件循环，该循环从通道 `c` 中读取。使用 `>!!` 形式向通道 `c` 发送值时，该值会与发送到通道的总值数一起打印出来。此外，`>!!`
    形式的调用会立即返回值 `true`。现在，让我们看看当我们使用 `close!` 函数关闭通道 `c` 时会发生什么，如下所示：
- en: '[PRE305]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: After closing the channel `c`, the `>!!` form returns `false` when it is applied
    to the channel, which implies that the channel `c` doesn't allow any more values
    to be put into it. Also, nothing gets printed, which means that the asynchronous
    routine that was trying to take values from the channel `c` has terminated.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭通道 `c` 后，当 `>!!` 形式应用于通道时，它返回 `false`，这意味着通道 `c` 不再允许放入任何值。而且，没有任何内容被打印出来，这意味着尝试从通道
    `c` 中获取值的异步例程已经终止。
- en: 'Another way to send values into a channel is by using the `onto-chan` function
    from the `core.async` namespace. This function must be passed a channel and a
    collection of values to put *onto* the channel, as shown here:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 向通道发送值的另一种方式是使用 `core.async` 命名空间中的 `onto-chan` 函数。这个函数必须传递一个通道和一个要放入通道的值集合，如下所示：
- en: '[PRE306]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The `onto-chan` function will close the channel it has been passed once the
    supplied collection of values is entirely put onto the channel. To avoid closing
    the channel, we can specify `false` as an additional argument to the `onto-chan`
    function.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供的值集合完全放入通道后，`onto-chan` 函数会关闭它所接收的通道。为了避免关闭通道，我们可以在 `onto-chan` 函数中指定 `false`
    作为额外的参数。
- en: The `alts!` and `alts!!` functions from the `core.async` namespace can be used
    to wait for completion of one of several channel operations. The main distinction
    between these functions is that the `alts!` function is intended for use within
    a `go` form and will park the current thread, unlike the `alts!!` function that
    blocks the current thread and must be used in a `thread` form. Both these functions
    must be passed a vector of channels and return a vector of two elements. The first
    element in the returned vector represents the value for a take operation or a
    Boolean value for a put operation, and the second one indicates the channel on
    which the operation completed. We can also specify a default value as a keyword
    argument with the key `:default` to the `alts!` and `alts!!` functions. The default
    value will be returned if none of the operations supplied to the `alts!` or `alts!!`
    forms have completed.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `core.async` 命名空间的 `alts!` 和 `alts!!` 函数可用于等待多个通道操作之一完成。这些函数之间的主要区别在于，`alts!`
    函数旨在在 `go` 形式中使用，并将暂停当前线程，而 `alts!!` 函数会阻塞当前线程，必须在 `thread` 形式中使用。这两个函数都必须传递一个通道向量，并返回一个包含两个元素的向量。返回向量中的第一个元素代表取操作的价值或放入操作的布尔值，第二个元素表示操作完成的通道。我们还可以通过将
    `:default` 作为关键字参数传递给 `alts!` 和 `alts!!` 函数来指定默认值。如果没有提供给 `alts!` 或 `alts!!` 形式的操作完成，则将返回默认值。
- en: 'The `core.async` library provides two versatile macros, namely `alt!` and `alt!!`,
    to wait for one among several channel operations to be complete. As you may have
    already guessed, an `alt!` form parks the current task, and an `alt!!` form blocks
    the current thread. Both these forms can also return a default value when used
    with the `:default` keyword argument. We can pass several clauses to the `alt!`
    and `alt!!` forms for reading from and writing to several channels. The `alt!`
    form in *Example 8.2* describes the clauses supported by the `alt!` and `alt!!`
    macros:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async` 库提供了两个多功能的宏，即 `alt!` 和 `alt!!`，用于等待多个通道操作中之一完成。正如你可能已经猜到的，`alt!`
    形式会暂停当前任务，而 `alt!!` 形式会阻塞当前线程。这两个形式在使用带有关键字参数 `:default` 时也可以返回默认值。我们可以向 `alt!`
    和 `alt!!` 形式传递多个子句，用于从多个通道读取和写入。*示例 8.2* 中的 `alt!` 形式描述了 `alt!` 和 `alt!!` 宏支持的子句：'
- en: '[PRE307]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '*Example 8.2: An asynchronous process implemented using the alt! form*'
  id: totrans-1334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.2：使用 alt! 形式实现的异步过程*'
- en: The preceding `process-channels` function takes six channels as its arguments,
    and uses an `alt!` form within a `go` form to perform asynchronous operations
    on these channels. The channels `c0`, `c1`, `c2`, and `c3` are read, and the channels
    `c4` and `c5` are written to. The `alt!` form tries to read from the channel `c0`
    and returns the keyword `:r` if the operation completes first. The channel `c1`
    is also read from, but the right hand side of its clause contains a parameterized
    expression with the argument `v`, where `v` is the value read from the channel.
    The channels `c2` and `c3` are passed as a vector in one of the clauses of the
    `alt!` form shown previously, and this clause uses a parameterized expression
    with the arguments `v` and `c`, where `c` is the channel on which the read operation
    completed first and `v` is the value read from the channel. Write operations are
    specified in an `alt!` form as a nested vector, where each inner vector contains
    a channel and a value to put onto the channel. The channels `c4` and `c5` are
    written to in the previous `alt!` form, and the value `:w` is returned if either
    of the two write operations completes. In this way, we can specify clauses to
    the `alt!` and `alt!!` forms to read to and write from several channels, and return
    a value based on which channel operation completes first.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `process-channels` 函数接受六个通道作为其参数，并在 `go` 形式中使用 `alt!` 形式对这些通道执行异步操作。通道 `c0`、`c1`、`c2`
    和 `c3` 被读取，而通道 `c4` 和 `c5` 被写入。`alt!` 形式尝试从通道 `c0` 读取，如果操作首先完成，则返回关键字 `:r`。通道
    `c1` 也被读取，但其子句的右侧包含一个带有参数 `v` 的参数化表达式，其中 `v` 是从通道读取的值。通道 `c2` 和 `c3` 作为向量传递给前面显示的
    `alt!` 形式的一个子句，该子句使用带有参数 `v` 和 `c` 的参数化表达式，其中 `c` 是首先完成读取操作的通道，而 `v` 是从通道读取的值。写入操作在
    `alt!` 形式中指定为嵌套向量，其中每个内部向量包含一个通道和一个要放入通道的值。在之前的 `alt!` 形式中写入通道 `c4` 和 `c5`，如果两个写入操作中的任何一个首先完成，则返回值
    `:w`。通过这种方式，我们可以指定给 `alt!` 和 `alt!!` 形式的子句，以读取和写入多个通道，并根据哪个通道操作首先完成返回一个值。
- en: Another facility that is often required in asynchronous programming is the ability
    to specify a *timeout* with a given operation. By the term *timeout*, we mean
    a specified amount of time after which the current operation is aborted. The `core.async`
    has an intuitive method for specifying operations with timeouts. This is done
    using the `core.async/timeout` function, which must be supplied a time interval
    in milliseconds and returns a channel that closes after the specified amount of
    time. If we intend to perform an operation with a timeout, we use one of the `alt*`
    forms with a channel returned by the `timeout` function.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程中，经常需要的一个功能是能够为给定的操作指定一个*超时*。通过术语*超时*，我们指的是在指定时间后当前操作被取消。`core.async`有一个直观的方法来指定带有超时的操作。这是通过使用`core.async/timeout`函数来完成的，它必须提供一个时间间隔（以毫秒为单位），并在指定的时间后关闭返回的通道。如果我们打算执行带有超时的操作，我们使用`alt*`形式之一，该形式使用由`timeout`函数返回的通道。
- en: 'This way, an operation with a channel returned by a `timeout` form will surely
    complete after the specified amount of time. The `timeout` form is also useful
    in parking or blocking the current thread of execution for a given amount of time.
    For example, a blocking read operation from a channel returned by a `timeout`
    form will block the current thread for the specified time interval, as shown here:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，由`timeout`形式返回的通道进行的操作将在指定的时间后肯定完成。`timeout`形式在暂停或阻塞当前执行线程一段时间也是很有用的。例如，从`timeout`形式返回的通道进行的阻塞读取操作将阻塞当前线程指定的时间间隔，如下所示：
- en: '[PRE308]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: We have now covered the basics of processes and channels in the `core.async`
    library.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了`core.async`库中进程和通道的基本知识。
- en: Customizing channels
  id: totrans-1340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义通道
- en: 'Channels can also be programmed to modify or compute values from those put
    into them. A read operation, for instance, on a channel could invoke a computation
    using the values buffered in the same channel, or even other channels. The `reduce`
    function from the `core.async` namespace can be used to compute values from channels
    and has more-or-less the same semantics as that of the standard `reduce` function.
    This variant of the `reduce` function requires a reducing operation, an initial
    value for the reduction operation and a channel to be passed to it, and it will
    return a channel from which the result can be read. Also, this function only produces
    values once the channel passed to it is closed. For example, consider the following
    code that computes a string from the values in a channel using the `core.async/reduce`
    function:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 通道也可以被编程来修改或计算放入其中的值。例如，对通道的读取操作可以调用使用同一通道中缓存的值或甚至其他通道的值的计算。`core.async`命名空间中的`reduce`函数可以用来从通道中计算值，并且与标准`reduce`函数有更多或更少的相同语义。这个`reduce`函数的变体需要一个减少操作、减少操作的初始值以及要传递给它的通道，并且它将返回一个可以从中读取结果的通道。此外，此函数仅在传递给它的通道关闭后才会产生值。例如，考虑以下使用`core.async/reduce`函数从通道中的值计算字符串的代码：
- en: '[PRE309]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: In the preceding example, the sequence generated by the expression `(range 5)`
    is put onto the channel `c` using an `onto-chan` form, and values from the channel
    are computed over using the channel-based variant of the `reduce` function. A
    single value is read from the resulting channel `rc`, thus producing a string
    containing all the values from the channel `c`. Note that the `reduce` form in
    this example produced a result without explicitly calling the `close!` function,
    as the `onto-chan` function closes the supplied channel after it completes putting
    values onto it.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由`(range 5)`表达式生成的序列被使用`onto-chan`形式放入通道`c`中，然后使用基于通道的`reduce`函数的变体计算通道中的值。从结果通道`rc`中读取单个值，从而生成包含通道`c`中所有值的字符串。请注意，在这个例子中，`reduce`形式产生了结果，而没有显式调用`close!`函数，因为`onto-chan`函数在将值放入通道后关闭了提供的通道。
- en: A more powerful and intuitive way to compute values from a channel is by using
    a transducer. We have already discussed transducers in some detail in [Chapter
    5](ch20.html "Chapter 5. Composing Transducers"), *Composing Transducers*, and
    we will now have a look at how transducers can be used with channels. Essentially,
    a channel can be associated with a transducer by specifying the transducer as
    a second argument to the `core.async/chan` function. Let's consider the simple
    transducer `xform` shown in *Example 8.3*.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 从通道计算值的一种更强大、更直观的方法是使用转换器。我们已经在 [第 5 章](ch20.html "第 5 章。组合转换器") *组合转换器* 中详细讨论了转换器，现在我们将看看如何使用通道与转换器一起使用。本质上，可以通过将转换器指定为
    `core.async/chan` 函数的第二个参数来将通道与转换器关联。让我们考虑 *示例 8.3* 中显示的简单转换器 `xform`。
- en: '[PRE310]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '*Example 8.3: A simple transducer to use with a channel*'
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.3：与通道一起使用的简单转换器*'
- en: 'The transducer `xform` shown is a trivial composition of mapping the functions
    `inc` and `#(* % 2)`. It will simply increment all values in a source of data,
    or rather a channel, and then double all of the results from the previous step.
    Let''s create a channel using this transducer and observe its behavior, as shown
    here:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的转换器 `xform` 是将函数 `inc` 和 `#(* % 2)` 映射的简单组合。它将简单地增加数据源中（或更确切地说，是一个通道）的所有值，然后加倍前一步骤的所有结果。让我们使用这个转换器创建一个通道，并观察其行为，如下所示：
- en: '[PRE311]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: The channel `xc` will apply the transducer `xform` to each value contained in
    it. The result of repeatedly taking values from the channel `xc` is thus a sequence
    of even numbers, which is produced by applying the functions `inc` and `#(* %
    2)` to each number in the range `(range 10)`. Note that the `onto-chan` form in
    the previous example does not close the channel `xc` as we pass `false` as its
    last argument.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 通道 `xc` 将将转换器 `xform` 应用到它包含的每个值。因此，从通道 `xc` 重复取值的结果是一个偶数序列，这是通过将函数 `inc` 和
    `#(* % 2)` 应用到 `(range 10)` 范围内的每个数字产生的。请注意，在前面的例子中，`onto-chan` 形式并没有关闭通道 `xc`，因为我们将其最后一个参数传递为
    `false`。
- en: A transducer associated with a channel could encounter an exception. To handle
    errors, we can pass a function as an additional argument to the `chan` form. This
    function must take exactly one argument, and will be passed any exception that
    is encountered by a transducer while transforming the values in a channel. For
    example, the expression `(a/chan 10 xform ex-handler)` creates a channel with
    a transducer `xform` and an exception handler `ex-handler`.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 与一个通道关联的转换器可能会遇到异常。为了处理错误，我们可以将一个函数作为额外的参数传递给 `chan` 形式。这个函数必须恰好接受一个参数，并将传递给转换器在转换通道中的值时遇到的任何异常。例如，表达式
    `(a/chan 10 xform ex-handler)` 创建了一个带有转换器 `xform` 和异常处理器 `ex-handler` 的通道。
- en: In this way, the `core.async/reduce` form and transducers can be used to perform
    computations on the values contained in channels.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，`core.async/reduce` 形式和转换器可以用来对通道中包含的值进行计算。
- en: Connecting channels
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接通道
- en: Now that we are familiar with the basics of channels and processes in the `core.async`
    library, let's explore the different ways in which channels can be connected together.
    Connecting two or more channels is useful for aggregating and distributing data
    among them. A connection between two or more channels is called a *joint fitting*,
    or simply a *joint*. We will use diagrams to describe some of the more complex
    joint fittings in this section. Keep in mind that the arrows in these diagrams
    indicate the direction of the flow of data in a given channel.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 `core.async` 库中通道和进程的基本知识，让我们探索通道可以连接在一起的不同方式。连接两个或更多通道对于在它们之间聚合和分配数据是有用的。两个或更多通道之间的连接称为
    *联合适配*，或简单地称为 *联合*。在本节中，我们将使用图表来描述一些更复杂的联合适配。请注意，这些图表中的箭头指示了给定通道中数据流的流向。
- en: The simplest way to connect two channels is by using a *pipe*, which is implemented
    by the `core.async/pipe` function. This function will take values from the first
    channel provided to it, and supplies these values to the second channel passed
    to it. In this way, a pipe between channels is similar to UNIX-style pipes between
    streams. For example, the expression `(a/pipe from to)` will take values from
    the channel `from` and put them onto the channel `to`. The `pipe` function also
    takes an optional third argument, which indicates whether the destination channel
    will be closed when the source channel closes, and this argument defaults to `true`.
    We can also connect two channels using a *pipeline*, using the `pipeline` function
    from the `core.async` namespace. The `pipeline` function will essentially apply
    a transducer to the values in a channel before they are put into another channel.
    The supplied transducer will also be invoked in parallel for each element in the
    supplied channel by the `pipeline` function.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 连接两个通道最简单的方式是使用一个*管道*，该管道通过`core.async/pipe`函数实现。这个函数将从它提供的第一个通道中获取值，并将这些值提供给传递给它的第二个通道。通过这种方式，通道之间的管道类似于UNIX风格的流管道。例如，表达式`(a/pipe
    from to)`将从`from`通道中获取值并将它们放入`to`通道。`pipe`函数还接受一个可选的第三个参数，该参数指示当源通道关闭时，目标通道是否会关闭，并且此参数默认为`true`。我们还可以使用`core.async`命名空间中的`pipeline`函数通过管道连接两个通道。`pipeline`函数将基本上在将值放入另一个通道之前，将这些值应用于通道中的转换器。提供的转换器也将由`pipeline`函数并行地对提供的通道中的每个元素调用。
- en: 'The `merge` function from the `core.async` namespace can be used to combine
    several channels. This function must be passed a vector of channels, and returns
    a channel from which the values from all of the supplied channels can be read.
    The returned channel is unbuffered by default, and we specify the size of the
    channel''s buffer by passing a number as an additional argument to the `merge`
    function. Also, the channel returned by a `merge` form will be closed once all
    the source channels have been closed. The operation of the `merge` function with
    two channels can be illustrated as follows:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`命名空间中的`merge`函数可以用来合并多个通道。此函数必须传递一个通道向量，并返回一个可以从所有提供的通道中读取值的通道。默认情况下，返回的通道是非缓冲的，我们可以通过将一个数字作为额外的参数传递给`merge`函数来指定通道的缓冲区大小。此外，一旦所有源通道都已关闭，由`merge`形式返回的通道将被关闭。两个通道的`merge`函数的操作可以用以下插图表示：'
- en: '![Connecting channels](img/B05024_08_02.jpg)'
  id: totrans-1356
  prefs: []
  type: TYPE_IMG
  zh: '![连接通道](img/B05024_08_02.jpg)'
- en: A channel can be split into two channels using the `core.async/split` function.
    The `split` function must be passed a predicate `p?` and a channel `c`, and returns
    a vector of two channels. The predicate `p?` is used to decide the channel on
    which a value from the channel `c` must be put. All values from the channel `c`
    that return a truthy value when passed to the predicate `p?` will be put onto
    the first channel in the vector returned by the `split` function.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`core.async/split`函数将一个通道拆分为两个通道。`split`函数必须传递一个谓词`p?`和一个通道`c`，并返回一个包含两个通道的向量。谓词`p?`用于决定将`c`通道中的值放入哪个通道。所有通过谓词`p?`返回真值的`c`通道中的值都将放入`split`函数返回的向量中的第一个通道。
- en: 'Conversely, the second channel in the returned vector will contain all values
    that return `false` or `nil` when `p?` is applied to these values. Both the channels
    returned by this function will be unbuffered by default, and the buffer size of
    both these channels can be specified as additional arguments to a `split` form.
    The `split` function can be depicted by the following illustration:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，返回向量中的第二个通道将包含所有在应用`p?`时返回`false`或`nil`的值。此函数返回的两个通道默认都是非缓冲的，并且可以通过将额外的参数传递给`split`形式来指定这两个通道的缓冲区大小。`split`函数可以用以下插图表示：
- en: '![Connecting channels](img/B05024_08_03.jpg)'
  id: totrans-1359
  prefs: []
  type: TYPE_IMG
  zh: '![连接通道](img/B05024_08_03.jpg)'
- en: 'A more dynamic way to combine several channels, compared to the `merge` function,
    is by using the `mix`, `admix`, and `unmix` functions from the `core.async` namespace.
    The `mix` function creates a *mix*, to which channels with incoming data can be
    connected to using the `admix` function. The `mix` function takes a channel as
    an argument, and the supplied channel will contain values from all the source
    channels added by the `admix` function. A source channel can be removed from a
    mixer by using the `unmix` function. The `admix` and `unmix` functions both accept
    a mix, which is returned by the `mix` function, and a source channel as arguments.
    To remove all channels from a mix, we simply pass the mix as an argument to the
    `unmix-all` function. The gist of a mix is that it allows us to dynamically add
    and remove source channels that send data to a given output channel. A mix, its
    output channel, and source channels can be illustrated as follows:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 与`merge`函数相比，更动态地组合几个通道的方法是使用`core.async`命名空间中的`mix`、`admix`和`unmix`函数。`mix`函数创建一个**混合**，可以使用`admix`函数将具有传入数据的通道连接到该混合。`mix`函数接受一个通道作为参数，提供的通道将包含由`admix`函数添加的所有源通道的值。可以使用`unmix`函数从混合器中移除源通道。`admix`和`unmix`函数都接受一个混合，这是由`mix`函数返回的，以及一个源通道作为参数。要从一个混合中移除所有通道，我们只需将混合作为参数传递给`unmix-all`函数。混合的精髓在于它允许我们动态地添加和移除向给定输出通道发送数据的源通道。混合、其输出通道和源通道可以如下所示：
- en: '![Connecting channels](img/B05024_08_04.jpg)'
  id: totrans-1361
  prefs: []
  type: TYPE_IMG
  zh: '![连接通道](img/B05024_08_04.jpg)'
- en: In the preceding illustration, the channel `c` is used as the output channel
    of the mix `m`, and the channels `c0` and `c1` are added as source channels to
    the mix `m` using the `admix` function.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示意图中，通道`c`被用作混合`m`的输出通道，通道`c0`和`c1`使用`admix`函数添加为混合`m`的源通道。
- en: 'The `core.async/mult` function creates a *multiple* of a given channel. The
    data from a multiple can be *tapped into* from another channel using the `tap`
    function. The channel supplied to the `tap` function will receive copies of all
    data sent to the source channel of a multiple. The `untap` function is used to
    disconnect a channel from a multiple, and the `untap-all` function will disconnect
    all channels from a multiple. A multiple essentially allows us to dynamically
    add and remove output channels that read values from a given source channel. The
    `mult` and `tap` functions can be described by the following diagram:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async/mult` 函数创建给定通道的**多个**副本。可以通过`tap`函数从另一个通道中**提取**多个通道的数据。提供给`tap`函数的通道将接收所有发送到多个通道源通道的数据副本。`untap`函数用于从多个通道断开一个通道，而`untap-all`函数将断开所有通道与多个通道的连接。多个通道本质上允许我们动态地添加和移除从给定源通道读取值的输出通道。`mult`和`tap`函数可以用以下图表来描述：'
- en: '![Connecting channels](img/B05024_08_05.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
  zh: '![连接通道](img/B05024_08_05.jpg)'
- en: In the preceding illustration, the channel `c` is used as the source channel
    by the multiple `m`, and the channels `c0` and `c1` are passed to the `tap` function
    so that they effectively receive copies of the data sent to the channel `c`.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示意图中，通道`c`被多个`m`用作源通道，通道`c0`和`c1`传递给`tap`函数，以便它们有效地接收发送到通道`c`的数据副本。
- en: 'The `core.async` library also supports a *publish-subscribe* model of transferring
    data. This can be done using a *publication*, which is created using the `core.async/pub`
    function. This function must be supplied a source channel and a function to decide
    the topic of a given value in the publication. Here, a topic can be any literal
    value, such as a string or a keyword, which is returned by the function supplied
    to the `pub` form. Channels can subscribe to a publication and a topic via the
    `sub` function, and a channel can unsubscribe from a publication using the `unsub`
    function. The `sub` and `unsub` functions must be passed a publication, a topic
    value and a channel. Also, the `unsub-all` function can be used to disconnect
    all channels that have subscribed to a publication. This function can optionally
    be passed a topic value, and will disconnect all channels that have subscribed
    to the given topic. A publication with two channels subscribed to it is depicted
    in following diagram:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async` 库还支持一种 *发布-订阅* 的数据传输模型。这可以通过使用 *发布* 来完成，该发布是通过 `core.async/pub`
    函数创建的。这个函数必须提供一个源通道和一个函数来决定发布中给定值的主题。在这里，主题可以是任何字面量，如字符串或关键字，该字面量由提供给 `pub` 形式的函数返回。通道可以通过
    `sub` 函数订阅一个发布和一个主题，一个通道可以使用 `unsub` 函数从发布中取消订阅。`sub` 和 `unsub` 函数必须传递一个发布、一个主题值和一个通道。此外，可以使用
    `unsub-all` 函数来断开所有已订阅发布的通道。此函数可以可选地传递一个主题值，并将断开所有已订阅给定主题的通道。以下图中展示了已订阅两个通道的发布：'
- en: '![Connecting channels](img/B05024_08_06.jpg)'
  id: totrans-1367
  prefs: []
  type: TYPE_IMG
  zh: '![连接通道](img/B05024_08_06.jpg)'
- en: In the preceding illustration, the publication `p` is created using the channel
    `c` and the function `topic-fn`. The channel `c0` subscribes to the publication
    `p` and the topic `:a`, while the channel `c1` subscribes to the same publication
    but for the topic `:b`. When a value is received on the channel `c`, it will either
    be sent to the channel `c0` if the function `topic-fn` returns `:a` for the given
    value, or to channel `c1` if the function `topic-fn` returns `:b` for the given
    value. Note that the values `:a` and `:b` in the preceding diagram are just arbitrary
    literals, and we could have used any other literal values just as easily.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用通道 `c` 和函数 `topic-fn` 创建了发布 `p`。通道 `c0` 订阅了发布 `p` 和主题 `:a`，而通道 `c1`
    订阅了相同的发布，但针对主题 `:b`。当通道 `c` 接收到一个值时，如果函数 `topic-fn` 对于该值返回 `:a`，则该值将被发送到通道 `c0`；如果函数
    `topic-fn` 对于该值返回 `:b`，则该值将被发送到通道 `c1`。请注意，前面图中的值 `:a` 和 `:b` 只是任意字面量，我们同样可以轻松地使用其他字面量。
- en: In summary, the `core.async` library provides several constructs to create joints
    between channels. These constructs help in modelling different ways in which data
    flows from any number of source channels into any number of output channels.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`core.async` 库提供了几个构造来在通道之间创建连接。这些构造有助于模拟数据从任意数量的源通道流向任意数量的输出通道的不同方式。
- en: Revisiting the dining philosophers problem
  id: totrans-1370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次探讨就餐哲学家问题
- en: Now, let's try to implement a solution to the **dining philosophers problem**
    using the `core.async` library. We have already implemented two solutions to the
    dining philosophers problem in [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), *Orchestrating Concurrency and Parallelism* of
    which one solution used refs and the other one used agents. In this section, we
    will use channels to implement a solution to the dining philosophers problem.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用 `core.async` 库来实现就餐哲学家问题的解决方案。我们已经在[第2章](ch17.html "第2章. 协调和并行处理")中实现了就餐哲学家问题的两个解决方案，其中一种解决方案使用了refs，另一种使用了agents。在本节中，我们将使用通道来实现就餐哲学家问题的解决方案。
- en: The dining philosophers problem can be concisely described as follows. Five
    philosophers are seated on a table with five forks placed between them. Each philosopher
    requires two forks to eat. The philosophers must somehow share access to the forks
    placed in between them to consume the food allocated to them, and none of the
    philosophers must starve due to being unable to acquire two forks. In this implementation,
    we will use channels to maintain the state of the forks as well as the philosophers
    on the table.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 就餐哲学家问题可以简洁地描述如下。五位哲学家坐在一张桌子旁，桌子上有五把叉子放在他们之间。每位哲学家需要两把叉子才能吃饭。哲学家们必须以某种方式共享他们之间放置的叉子的访问权限，以消费分配给他们的食物，并且没有任何哲学家因为无法获得两把叉子而饿死。在这个实现中，我们将使用通道来维护桌子上的叉子和哲学家的状态。
- en: Note
  id: totrans-1373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，必须在您的命名空间声明中包含以下命名空间：
- en: '[PRE312]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: The following examples can be found in `src/m_clj/c8/` `dining_philosophers_async.clj`
    of the book's source code. Some of these examples are based on code from *A Dining
    Philosophers solver* by Pepijn de Vos ([http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html)).
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c8/` `dining_philosophers_async.clj`中找到。其中一些示例基于Pepijn
    de Vos的*《进餐哲学家求解器》*中的代码([http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html))。
- en: 'Let''s first define a couple of functions to initialize all the philosophers
    and forks we are dealing with, as shown in *Example 8.4*:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义几个函数来初始化我们正在处理的所有哲学家和叉子，如*示例 8.4*所示：
- en: '[PRE313]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '*Example 8.4: The dining philosophers problem*'
  id: totrans-1379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.4: 进餐哲学家问题*'
- en: The `make-philosopher` function defined in *Example 8.4* creates a map representing
    the state of a philosopher. The argument `name` will be a string, the argument
    `forks` will be a vector of two fork channels, and the argument `food` will be
    a number indicating the amount of food served to a philosopher. The two forks
    represent the forks on the left- and right-hand side of a philosopher. These forks
    will be allocated and passed to the `make-philosopher` function by the `init-philosophers`
    function that we previously defined in [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), Orchestrating Concurrency and Parallelism. The
    `make-forks` function shown previously creates a specified number of channels,
    puts the value `:fork` onto each of them, and finally returns the new channels.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 8.4*中定义的`make-philosopher`函数创建了一个表示哲学家状态的映射。参数`name`将是一个字符串，参数`forks`将是一个包含两个叉子通道的向量，参数`food`将是一个表示提供给哲学家的食物数量的数字。这两个叉子代表哲学家左右两侧的叉子。这些叉子将由我们之前在[第
    2 章](ch17.html "第 2 章。编排并发和并行")中定义的`init-philosophers`函数分配并传递给`make-philosopher`函数。之前显示的`make-forks`函数创建指定数量的通道，将值`:fork`放入每个通道中，最后返回新的通道。
- en: 'Next, let''s define the routine of a philosopher as a process. A philosopher
    must try to acquire the forks on his left and right side, eat his food if he acquires
    both forks, and finally release any forks that he successfully acquired. Also,
    since the state of all the philosophers in our simulation is captured in a channel,
    we will have to take a philosopher out of a channel, perform the routine of a
    philosopher, and then put the philosopher''s state back onto the channel. This
    routine is implemented by the `philosopher-process` function in *Example 8.5*:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将哲学家的常规定义为一种进程。哲学家必须尝试获取他左右两侧的叉子，如果获取到两个叉子，就吃他的食物，最后释放他成功获取的任何叉子。由于我们模拟中所有哲学家的状态都由一个通道捕获，因此我们必须将一个哲学家从通道中取出，执行哲学家的常规，然后将哲学家的状态放回通道。这个常规由*示例
    8.5*中的`philosopher-process`函数实现：
- en: '[PRE314]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '*Example 8.5: The dining philosophers problem (continued)*'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.5: 进餐哲学家问题（续）*'
- en: 'The preceding `philosopher-process` function starts an asynchronous process
    using the `go-loop` macro. The arguments `p-chan`, `max-eat-ms`, and `max-think-ms`
    represent the channel containing the state of all philosophers, the maximum amount
    of time a philosopher can spend eating, and the maximum amount of time a philosopher
    can think, respectively. The asynchronous task started by the `philosopher-process`
    function will try to take values from the forks `fork-1` and `fork-2` of a philosopher
    with a timeout of `100` milliseconds. This is done using a combination of the
    `alt!` and `timeout` functions. If a philosopher is able to acquire two forks,
    he will eat for some time, put down or release both forks, spend some time thinking,
    and repeat the same process. If he is unable to get two forks, the philosopher
    will release any acquired forks and restart the same process. The state of the
    philosopher is always put back onto the channel `p-chan`. This asynchronous process
    is repeated until a philosopher has any remaining food. Next, let''s define a
    couple of functions to start and print the philosophers in our simulation, as
    shown in *Example 8.6*:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`philosopher-process`函数使用`go-loop`宏启动一个异步进程。参数`p-chan`、`max-eat-ms`和`max-think-ms`分别代表包含所有哲学家状态的通道、哲学家可以花费的最大吃饭时间和哲学家可以思考的最大时间。`philosopher-process`函数启动的异步任务将尝试从哲学家的`fork-1`和`fork-2`叉子中获取值，超时时间为`100`毫秒。这是通过`alt!`和`timeout`函数的组合来完成的。如果哲学家能够获取两个叉子，他将吃一段时间，放下或释放两个叉子，花一些时间思考，然后重复相同的过程。如果他无法获取两个叉子，哲学家将释放任何获取到的叉子并重新启动相同的过程。哲学家的状态始终被放回到通道`p-chan`。这个异步进程会一直重复，直到哲学家有任何剩余的食物。接下来，让我们定义一些函数来启动和打印我们模拟中的哲学家，如下所示*示例
    8.6*：
- en: '[PRE315]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '*Example 8.6: The dining philosophers problem (continued)*'
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.6：就餐哲学家问题（继续）*'
- en: The preceding `start-philosophers` function will put a sequence of philosophers,
    represented by the argument `philosophers`, onto the channel `p-chan`, and then
    call the `philosopher-process` function for each philosopher in the sequence `philosophers`.
    The `print-philosophers` function uses the blocking channel read and write functions,
    namely `<!!` and `>!!`, to read `n` philosophers from the channel `p-chan` and
    print the amount of food remaining on each philosopher's plate.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`start-philosophers`函数将哲学家序列（由参数`philosophers`表示）放入通道`p-chan`，然后对序列`philosophers`中的每个哲学家调用`philosopher-process`函数。`print-philosophers`函数使用阻塞通道读写函数，即`<!!`和`>!!`，从通道`p-chan`读取`n`个哲学家并打印每个哲学家盘子上的剩余食物量。
- en: Finally, let's create some instances of philosophers and associated forks by
    using the `make-philosopher` and `make-forks` functions. We will also use the
    `init-philosophers` function from [Chapter 2](ch17.html "Chapter 2. Orchestrating
    Concurrency and Parallelism"), Orchestrating Concurrency and Parallelism, to create
    philosopher objects, using the `make-philosopher` function, and assign two forks
    to each philosopher. These top-level definitions of the philosophers and forks
    in our simulation are shown in *Example 8.7*.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用`make-philosopher`和`make-forks`函数创建一些哲学家的实例及其相关的叉子。我们还将使用来自[第 2 章](ch17.html
    "第 2 章。编排并发与并行")的`init-philosophers`函数，编排并发与并行，使用`make-philosopher`函数创建哲学家对象，并将两个叉子分配给每个哲学家。我们模拟中哲学家和叉子的这些顶级定义在*示例
    8.7*中展示。
- en: '[PRE316]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '*Example 8.7: The dining philosophers problem (continued)*'
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.7：就餐哲学家问题（继续）*'
- en: 'As shown here, we define five forks and philosophers, and create a channel
    to represent the state of all philosophers we have created. Note that the channel
    we use for the philosophers has a buffer size of `5`. The simulation can be started
    by calling the `start-philosophers` function, and the state of the philosophers
    can be printed using the `print-philosophers` function, as shown here:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，我们定义了五个叉子和哲学家，并创建了一个通道来表示我们创建的所有哲学家的状态。请注意，我们用于哲学家的通道具有`5`的缓冲区大小。可以通过调用`start-philosophers`函数来启动模拟，并使用`print-philosophers`函数打印哲学家的状态，如下所示：
- en: '[PRE317]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: As the preceding output shows us, the five philosophers share access to the
    forks among themselves and consume their food at the same rate. All philosophers
    get a chance to eat their food, and thus no one starves. Note that the order of
    the philosophers printed by the `print-philosophers` function may differ from
    time to time, and some philosophers may also be printed twice by this function.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，五位哲学家在他们之间共享叉子，并以相同的速度消耗食物。所有哲学家都有机会吃到食物，因此没有人会饿死。请注意，`print-philosophers`函数打印的哲学家的顺序可能随时变化，某些哲学家也可能被此函数打印两次。
- en: In this way, we can solve a given problem using channels and processes from
    the `core.async` library. Also, we can create any number of such processes without
    bothering about the available number of operating system level threads.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以使用`core.async`库中的通道和进程来解决给定的问题。此外，我们可以创建任意数量的此类进程，而无需担心操作系统级别的线程数量。
- en: Using actors
  id: totrans-1395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用actor
- en: '**Actors** are another way of modeling a system as a large number of concurrently
    running processes. Each process in *the actor model* is termed as an actor, and
    this model is based on the philosophy that every piece of logic in a system can
    be represented as an actor. The theory behind actors was first published by Carl
    Hewitt in the early ''70s. Before we explore actors, we must note that the core
    Clojure language and libraries do not provide an implementation of the actor model.
    In fact, it is a widely accepted notion in the Clojure community that processes
    and channels are a much better methodology to model concurrently running processes
    compared to actors. That aside, actors can be used to provide more resilient error
    handling and recovery, and it is possible to use actors in Clojure through the
    Pulsar library ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)).'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**Actor**是另一种将系统建模为大量并发运行进程的方法。在*actor模型*中，每个进程被称为actor，此模型基于这样的哲学：系统中的每一块逻辑都可以表示为一个actor。actor背后的理论最早由Carl
    Hewitt在20世纪70年代初发表。在我们探索actor之前，我们必须注意，核心Clojure语言和库并没有提供actor模型的实现。事实上，在Clojure社区中，普遍认为进程和通道是比actor更好的并发运行进程的建模方法。除此之外，actor可以用来提供更健壮的错误处理和恢复，并且可以通过Pulsar库在Clojure中使用actor（[https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)）。'
- en: Note
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To find out more about why processes and channels are preferred over actors
    in Clojure, take a look at *Clojure core.async Channels* by Rich Hickey ([http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels)).
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于为什么在Clojure中进程和通道比actor更受欢迎的原因，请参阅Rich Hickey的《Clojure core.async Channels》(*Clojure
    core.async Channels*) ([http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels))。
- en: 'The actor model describes actors as concurrent processes that perform some
    computation on receiving messages. An actor can also send messages to other actors,
    create more actors, and change its own behavior depending on the messages it receives.
    Actors can also have their own internal state. In fact, actors were originally
    described as independent processors with their own local memory that interact
    with each other through a high-speed communication network. Every actor has its
    own *mailbox* to receive messages, and messages are the only means of conveying
    data between actors. The following diagram depicts an actor as an entity that
    receives some input as messages and performs computations to produce some output:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: Actor模型描述actor为接收消息时执行某些计算的并发进程。actor还可以向其他actor发送消息，创建更多actor，并根据接收到的消息改变自己的行为。actor也可以有自己的内部状态。实际上，actor最初被描述为具有自己的本地内存的独立处理器，它们通过高速通信网络相互交互。每个actor都有自己的*邮箱*来接收消息，而消息是actor之间传递数据的唯一手段。以下图展示了actor作为一个接收某些输入作为消息并执行计算以产生某些输出的实体：
- en: '![Using actors](img/B05024_08_07.jpg)'
  id: totrans-1400
  prefs: []
  type: TYPE_IMG
  zh: '![使用actor](img/B05024_08_07.jpg)'
- en: The Pulsar library provides a comprehensive implementation of the actor model.
    In this library, actors are scheduled to execute on **fibers**, which are similar
    to asynchronous tasks created using the `go` form from the `core.async` library.
    Fibers are scheduled to run on fork-join thread pools, unlike regular thread pools
    that are used in the `core.async` library. Due to this design, the Pulsar library
    is available only on the JVM, and not in the browser through ClojureScript.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar 库提供了演员模型的全面实现。在这个库中，演员被安排在 **fibers** 上执行，这些 fibers 与使用 `core.async`
    库的 `go` 表达式创建的异步任务类似。fibers 被安排在分叉-合并线程池上运行，这与在 `core.async` 库中使用的常规线程池不同。由于这种设计，Pulsar
    库仅在 JVM 上可用，而不是通过 ClojureScript 在浏览器中使用。
- en: Fibers communicate with each other through the Pulsar library's own implementation
    of *promises* and *channels*. Interestingly, the Pulsar library also has several
    thin wrappers around its implementation of channels, to provide an API that is
    fully compatible with that of the `core.async` library. Although we won't discuss
    fibers, promises, and channels from the Pulsar library any further in this section,
    we must understand that channels are quite relevant to actors, since an actor's
    mailbox is implemented using a channel. Now, let's explore the basics of actors
    in the Pulsar library.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: Fibers 通过 Pulsar 库自己实现的 *promises* 和 *channels* 进行通信。有趣的是，Pulsar 库在其通道实现周围还有几个薄薄的包装器，以提供一个与
    `core.async` 库完全兼容的 API。尽管我们不会在本节中进一步讨论 Pulsar 库的 fibers、promises 和 channels，但我们必须理解通道与演员非常相关，因为演员的邮箱是用通道实现的。现在，让我们探索
    Pulsar 库中演员的基本知识。
- en: Creating actors
  id: totrans-1403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建演员
- en: The `spawn` macro, from the `co.paralleluniverse.pulsar.actors` namespace, creates
    a new actor and must be passed a function that takes no arguments. We can specify
    the buffer size of an actor's mailbox using the `:mailbox-size` keyword argument
    of the `spawn` macro. There are several other interesting keyword arguments that
    can be passed to the `spawn` form, and you are encouraged to find out more about
    them on your own.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `co.paralleluniverse.pulsar.actors` 命名空间的 `spawn` 宏创建一个新的演员，并且必须传递一个不接受任何参数的函数。我们可以使用
    `spawn` 宏的 `:mailbox-size` 关键字参数来指定演员邮箱的缓冲区大小。还有其他几个有趣的关键字参数可以传递给 `spawn` 表达式，您被鼓励自行了解更多关于它们的信息。
- en: Note
  id: totrans-1405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖项对于即将到来的示例是必需的：
- en: '[PRE318]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'Your `project.clj` file must also contain the following entries:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `project.clj` 文件还必须包含以下条目：
- en: '[PRE319]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE320]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: The function supplied to the `spawn` macro must use the `receive` macro, from
    the `co.paralleluniverse.pulsar.actors` namespace, to process messages received
    by the actor. Within this supplied function, we can use the expression `@self`
    to refer to the actor executing it. The `receive` form also supports pattern matching,
    which is implemented through the `core.match` library. We can also call the `receive`
    macro with no arguments, in which case it will return a message from the actor's
    mailbox. The `receive` form will also park the fiber on which it is executed.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `spawn` 宏的函数必须使用来自 `co.paralleluniverse.pulsar.actors` 命名空间的 `receive` 宏来处理演员接收到的消息。在这个提供的函数中，我们可以使用表达式
    `@self` 来引用执行它的演员。`receive` 表达式还支持模式匹配，这是通过 `core.match` 库实现的。我们还可以不带参数调用 `receive`
    宏，在这种情况下，它将返回演员邮箱中的消息。`receive` 表达式还将暂停执行它的 fiber。
- en: To send messages to actors, we can use either the `!` or `!!` macros from the
    `co.paralleluniverse.pulsar.actors` namespace. Both these macros must be passed
    an actor and an expression that returns a value, and both of these forms return
    `nil`. The only difference between these two forms is that `!` is asynchronous,
    while `!!` is synchronous and may block the current thread of execution if the
    actor's mailbox is full. An actor may terminate on receiving a particular message,
    and we can check whether an actor is still active using the `done?` function from
    the `co.paralleluniverse.pulsar.actors` namespace. Once an actor terminates, we
    can obtain the final value returned by the actor using the `join` function from
    the `co.paralleluniverse.pulsar.core` namespace. For example, consider the actor
    created using the `spawn` and `receive` forms in *Example 8.8*.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 要向演员发送消息，我们可以使用 `co.paralleluniverse.pulsar.actors` 命名空间中的 `!` 或 `!!` 宏。这两个宏都必须传递一个演员和一个返回值的表达式，并且这两种形式都返回
    `nil`。这两种形式之间的唯一区别是 `!` 是异步的，而 `!!` 是同步的，并且如果演员的邮箱已满，它可能会阻塞当前执行的线程。演员在收到特定消息时可能会终止，我们可以使用
    `co.paralleluniverse.pulsar.actors` 命名空间中的 `done?` 函数来检查演员是否仍然活跃。一旦演员终止，我们可以使用
    `co.paralleluniverse.pulsar.core` 命名空间中的 `join` 函数来获取演员返回的最终值。例如，考虑使用 `spawn`
    和 `receive` 形式在 *示例 8.8* 中创建的演员。
- en: Note
  id: totrans-1414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c8/actors.clj` of the book's
    source code. Some of these examples are based on code from the official Pulsar
    documentation (`http://docs.paralleluniverse.co/pulsar/`).
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c8/actors.clj` 中找到。其中一些示例基于官方 Pulsar 文档中的代码（`http://docs.paralleluniverse.co/pulsar/`）。
- en: '[PRE321]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '*Example 8.8: An actor created using the spawn macro*'
  id: totrans-1417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.8：使用 spawn 宏创建的演员*'
- en: 'The actor, represented by the preceding variable `actor`, will receive a message,
    print it and loop using a `recur` form. If the message `:finish` is received,
    it will print a string and terminate. The following code demonstrates how we can
    send a message to the actor:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 由前一个变量 `actor` 表示的演员将接收一条消息，打印它并使用 `recur` 形式循环。如果收到消息 `:finish`，它将打印一个字符串并终止。以下代码演示了我们可以如何向演员发送消息：
- en: '[PRE322]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'As shown here, sending the value `:foo` to the actor returns `nil` immediately,
    and the message gets printed from another thread. As the `done?` function returns
    `false` when passed the variable `actor`, it is evident that the actor does not
    terminate on receiving the value `:foo` as a message. On the other hand, if we
    send the value `:finish` to the actor, it will terminate, as shown here:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，向演员发送值 `:foo` 会立即返回 `nil`，并且消息会从另一个线程中打印出来。由于 `done?` 函数在传递变量 `actor` 时返回
    `false`，因此很明显，演员在收到值 `:foo` 作为消息时不会终止。另一方面，如果我们向演员发送值 `:finish`，它将终止，如下所示：
- en: '[PRE323]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'After being sent the value `:finish`, the `done?` function returns `true` when
    applied to the actor, which implies that the actor has terminated. The value returned
    by an actor before termination can be obtained using the `join` function from
    the `co.paralleluniverse.pulsar.core` namespace. We must note that the `join`
    function actually returns the result of any fiber, and will block the calling
    thread of execution until the fiber completes or terminates. For example, consider
    the actor in *Example 8.9* that divides a number by another number:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送值 `:finish` 后，当将 `done?` 函数应用于演员时，它返回 `true`，这意味着演员已经终止。演员在终止前返回的值可以使用 `co.paralleluniverse.pulsar.core`
    命名空间中的 `join` 函数获取。我们必须注意，`join` 函数实际上返回任何纤维的结果，并且将阻塞调用线程的执行，直到纤维完成或终止。例如，考虑 *示例
    8.9* 中除以另一个数字的演员：
- en: '[PRE324]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '*Example 8.9: An actor that performs division of a number by another*'
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.9：执行数字除法的演员*'
- en: 'We can send messages to the actor `divide-actor` defined in *Example 8.9*,
    and obtain the final result from it using the `join` function, as shown here:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 *示例 8.9* 中定义的演员 `divide-actor` 发送消息，并使用 `join` 函数从它那里获取最终结果，如下所示：
- en: '[PRE325]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: The preceding code shows that we can send two numbers to the actor `divide-actor`,
    and send it the value `:result` to terminate it. After termination, we can obtain
    the result of the actor, that is `3`, by passing the actor to the `join` function.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示我们可以向演员 `divide-actor` 发送两个数字，并发送值 `:result` 来终止它。终止后，我们可以通过将演员传递给 `join`
    函数来获取演员的结果，即 `3`。
- en: Actors can be registered with meaningful names that can be used to locate them.
    This is done using the `register!` function from the `co.paralleluniverse.pulsar.actors`
    namespace, which must be passed an actor instance and a name to register for the
    supplied actor. We can then send messages to a registered actor by specifying
    the actor's name to either the `!` or `!!` functions. For example, suppose the
    variable `actor` represents an actor instance created using the `spawn` macro.
    After registering the actor with the name `:my-actor` by calling `(pa/register!
    actor :my-actor)`, we can send the value `:foo` to the actor by calling `(pa/!
    :my-actor :foo)`.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以用有意义的名称注册，这些名称可以用来定位它们。这是通过`co.paralleluniverse.pulsar.actors`命名空间中的`register!`函数完成的，该函数必须传递一个演员实例和一个要为该演员注册的名称。然后我们可以通过指定演员的名称到`!`或`!!`函数来向注册的演员发送消息。例如，假设变量`actor`代表使用`spawn`宏创建的演员实例。通过调用`(pa/register!
    actor :my-actor)`将演员以名称`:my-actor`注册后，我们可以通过调用`(pa/! :my-actor :foo)`将值`:foo`发送到该演员。
- en: Passing messages between actors
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递演员之间的消息
- en: 'Now, let''s build a simple simulation of a ping pong game with two actors.
    These two actors will send the messages `:ping` and `:pong` to each other for
    a specified number of times. The code for this simulation is shown in *Example
    8.10* as follows:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的由两个演员组成的乒乓游戏的模拟。这两个演员将互相发送指定次数的`:ping`和`:pong`消息。这个模拟的代码在*示例 8.10*中如下所示：
- en: '[PRE326]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '*Example 8.10: Two actors playing a game of ping-pong*'
  id: totrans-1432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.10：两个演员玩乒乓球的例子*'
- en: 'The `ping-fn` and `pong-fn` functions shown in *Example 8.10* implement the
    logic of two actors playing a game of ping pong. The `ping-fn` will essentially
    send a vector containing the keyword `:ping` and the current actor instance to
    the actor represented by the argument `pong`. This is done `n` times, and finally
    the message `:finished` is sent to the actor `pong`. The function `pong-fn` will
    receive the vector `[:ping ping]`, where `ping` will be the actor sending the
    message. An actor created with the `pong-fn` will terminate once it receives the
    message `:finished`. The `start-ping-pong` function simply creates two actors
    using the functions `ping-fn` and `pong-fn` and waits until they are both finished
    using the `join` function. We can call the `start-ping-pong` function by passing
    in the number of times each of the two actors must send messages to each other,
    as shown here:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 8.10*中展示的`ping-fn`和`pong-fn`函数实现了两个演员玩乒乓球的逻辑。`ping-fn`将基本上发送一个包含关键字`:ping`和当前演员实例的向量到由参数`pong`表示的演员。这会进行`n`次，最后将消息`:finished`发送到演员`pong`。`pong-fn`函数将接收向量`[:ping
    ping]`，其中`ping`将是发送消息的演员。使用`pong-fn`创建的演员一旦收到消息`:finished`就会终止。`start-ping-pong`函数简单地使用`ping-fn`和`pong-fn`函数创建两个演员，并使用`join`函数等待它们都完成。我们可以通过传递每个演员必须互相发送消息的次数来调用`start-ping-pong`函数，如下所示：
- en: '[PRE327]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: The two actors created by the `start-ping-pong` function pass messages between
    themselves to simulate a game of ping pong, as demonstrated by the preceding output.
    In conclusion, actors from the Pulsar library can be used to implement concurrently
    executing processes.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 由`start-ping-pong`函数创建的两个演员通过互相传递消息来模拟乒乓球游戏，如前面的输出所示。总之，Pulsar库中的演员可以用来实现并发执行的过程。
- en: Handling errors with actors
  id: totrans-1436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用演员处理错误
- en: Actors support some interesting methods for error handling. If an actor encounters
    an error while processing a received message, it will terminate. The exception
    that was raised within the fiber executing the actor will be saved and thrown
    again when we pass the actor to the `join` function. In effect, we don't need
    to handle exceptions within the function passed to the `spawn` macro, and instead
    we must catch exceptions when the `join` function is called.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 演员支持一些有趣的错误处理方法。如果一个演员在处理接收到的消息时遇到错误，它将终止。在执行演员的纤维中抛出的异常将被保存，并在我们将演员传递给`join`函数时再次抛出。实际上，我们不需要在传递给`spawn`宏的函数中处理异常，相反，我们必须在调用`join`函数时捕获异常。
- en: This brings us to an interesting consequence of actors. If an actor could encounter
    an error and fail, we can have another actor that monitors the first actor, and
    restart it in case of failure. Thus, an actor can be notified when another actor
    in the system terminates. This principle allows actors to recover from errors
    in an automated fashion. In the Pulsar library, this sort of error handling is
    done through the `watch!` and `link!` functions from the `co.paralleluniverse.pulsar.actors`
    namespace.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了演员的一个有趣后果。如果一个演员可能遇到错误并失败，我们可以有一个监视第一个演员的另一个演员，并在失败的情况下重新启动它。因此，演员可以在系统中的另一个演员终止时得到通知。这个原则允许演员以自动化的方式从错误中恢复。在
    Pulsar 库中，这种错误处理是通过 `co.paralleluniverse.pulsar.actors` 命名空间中的 `watch!` 和 `link!`
    函数来完成的。
- en: An actor can *watch* or *monitor* another actor by calling the `watch!` function
    from within its body. For example, we must call `(watch! A)` within the body of
    an actor to watch the actor `A`. If the actor being watched encounters an exception,
    the same exception will be thrown from the `receive` form of the monitoring actor.
    The monitoring actor must catch the exception, or else it will be terminated along
    with the actor from which the exception originated. Also, the monitoring actor
    could restart the terminated actor by calling the `spawn` macro. To stop watching
    an actor, we must pass the watched actor to the `unwatch!` function from within
    the body of the monitoring actor.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以通过在其体内调用 `watch!` 函数来*监视*或*监控*另一个演员。例如，我们必须在演员的体内调用 `(watch! A)` 来监视演员 `A`。如果被监视的演员遇到异常，监视演员的
    `receive` 形式将抛出相同的异常。监视演员必须捕获异常，否则它将与产生异常的演员一起终止。此外，监视演员可以通过调用 `spawn` 宏来重新启动已终止的演员。要停止监视一个演员，我们必须在监视演员的体内将监视的演员传递给
    `unwatch!` 函数。
- en: Two actors could also be *linked* by passing them to the `link!` function. If
    two actors are linked together, an exception encountered in either of the two
    actors will be caught by the other one. In this way, linking two actors is a symmetrical
    way of monitoring them for errors. The `link!` function can also be called within
    the function passed to a `spawn` form, in which case it must be passed the actor
    to be linked. To unlink two actors, we can use the `unlink!` function.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 两个演员也可以通过将它们传递给 `link!` 函数来*链接*。如果两个演员被链接在一起，那么两个演员中的任何一个遇到的异常都将被另一个捕获。通过这种方式，链接两个演员是对它们进行错误监视的对称方式。`link!`
    函数也可以在传递给 `spawn` 形式的函数中调用，在这种情况下，必须传递要链接的演员。要解除两个演员的链接，我们可以使用 `unlink!` 函数。
- en: Thus, the Pulsar library provides some interesting ways to watch and link actors
    to perform error handling and recovery.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Pulsar 库提供了一些有趣的方法来监视和链接演员以执行错误处理和恢复。
- en: Managing state with actors
  id: totrans-1442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用演员管理状态
- en: As we mentioned earlier, actors can have their own internal mutable state. Of
    course, accessing this state from other actors is not allowed, and immutable messages
    are the only way an actor can communicate with other actors. Another way that
    an actor can maintain or manage its state is by changing its behavior depending
    on the messages it receives, and this technique is called a *selective receive*.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，演员可以拥有自己的内部可变状态。当然，不允许从其他演员访问这个状态，不可变消息是演员与其他演员通信的唯一方式。演员维持或管理其状态的另一种方式是根据接收到的消息改变其行为，这种技术称为*选择性接收*。
- en: Every actor created using the `spawn` function can read its internal state using
    the expression `@state`, and can also write to this state using the `set-state!`
    function. The `set-state!` function will also return the new state of the actor,
    as returned by the expression `@state`. Note that both of these forms are implemented
    in the `co.paralleluniverse.pulsar.actors` namespace.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spawn` 函数创建的每个演员都可以使用表达式 `@state` 读取其内部状态，也可以使用 `set-state!` 函数写入此状态。`set-state!`
    函数还将返回演员的新状态，正如表达式 `@state` 返回的那样。请注意，这两个形式都是在 `co.paralleluniverse.pulsar.actors`
    命名空间中实现的。
- en: Consider the `add-using-state` function in *Example 8.11* that uses an actor
    to add two numbers. Of course, we would never really need such a function in the
    real world, and it is only demonstrated here to depict how an actor can change
    its internal state.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 *示例 8.11* 中的 `add-using-state` 函数，该函数使用演员来添加两个数字。当然，在现实世界中我们永远不会真正需要这样的函数，这里只是演示了演员如何改变其内部状态。
- en: '[PRE328]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '*Example 8.11: A function to add two numbers using an actor*'
  id: totrans-1447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.11：使用演员添加两个数字的函数*'
- en: 'The `add-using-state` function shown in *Example 8.11* creates an actor that
    sets its state to `0`, and adds the first two messages it receives to its state.
    The actor will return the latest state of the actor, as returned by the last call
    to `set-state!` in the function passed to the `spawn` macro. On calling the `add-using-state`
    function with two numbers, it produces their sum as its output, shown as follows:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8.11*中所示的`add-using-state`函数创建了一个actor，将其状态设置为`0`，并将它接收到的前两个消息添加到其状态中。actor将返回actor的最新状态，这是通过`spawn`宏传递给函数的`set-state!`的最后一次调用返回的状态。在调用带有两个数字的`add-using-state`函数时，它产生它们的和作为其输出，如下所示：'
- en: '[PRE329]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Another way in which an actor can modify its state is through a selective receive,
    in which the actor modifies its behavior on receiving a particular message. This
    is done by calling a `receive` form within the body of another `receive` form,
    as shown in *Example 8.12*:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种actor可以修改其状态的方式是通过选择性接收，在actor接收到特定消息时修改其行为。这是通过在另一个`receive`形式的体内调用`receive`形式来完成的，如*示例
    8.12*所示：
- en: '[PRE330]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '*Example 8.12: A function to add two numbers using an actor with selective
    receive*'
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 8.12：使用具有选择性接收的actor添加两个数字的函数*'
- en: 'The `add-using-selective-receive` function shown previously will set its state
    to `0`, receive the messages `m` and `n` through a selective receive, and add
    these messages. This function produces identical results as the `add-using-state`
    function from *Example 8.11*, as shown here:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的`add-using-selective-receive`函数将设置其状态为`0`，通过选择性接收接收消息`m`和`n`，并将这些消息相加。此函数产生的结果与*示例
    8.11*中的`add-using-state`函数相同，如下所示：
- en: '[PRE331]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: In this way, actors can change their internal state and behavior based on the
    messages sent to them.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，actors可以根据发送给它们的消息改变其内部状态和行为。
- en: Comparing processes and actors
  id: totrans-1456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较进程和actors
- en: 'CSPs and actors are two distinct approaches to modeling a system as a large
    number of concurrent processes that execute and interact asynchronously. The logic
    of an asynchronous task can reside within a process created using a `go` block,
    or within the function passed to the `spawn` macro that creates an actor. However,
    there are some subtle contrasts between these two approaches:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: CSPs和actors是两种将系统建模为大量并发进程的方法，这些进程异步执行和交互。异步任务逻辑可以位于使用`go`块创建的进程内，或者位于创建actor的`spawn`宏传递的函数内。然而，这两种方法之间存在一些细微的对比：
- en: Processes created using the `go` and `thread` forms encourage us to put all
    states onto channels. Actors, on the other hand, can have their own internal state,
    in addition to the state in the form of messages sent to them. Thus, actors are
    more like objects with encapsulated state, while processes are more like functions
    that operate on states stored in channels.
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go`和`thread`形式创建的进程鼓励我们将所有状态放入通道中。另一方面，actors可以有自己的内部状态，除了以发送给它们的消息形式的状态之外。因此，actors更像是具有封装状态的对象，而进程更像是操作存储在通道中的状态的函数。
- en: Tasks created using the `go` or `thread` macros have no implicit error handling,
    and we must handle exceptions using the `try` and `catch` forms in the body of
    the `go` and `thread` macros. Of course, channels do support error handlers, but
    only when combined with a transducer. Actors, however, will save any exception
    they run into until we apply the `join` function on the actor. Also, actors can
    be linked and monitored to provide a form of automated error recovery. In this
    way, actors are more focused on building fault-tolerant systems.
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go`或`thread`宏创建的任务没有隐式的错误处理，我们必须在`go`和`thread`宏的体内使用`try`和`catch`形式来处理异常。当然，通道支持错误处理，但仅当与转换器结合使用时。然而，actors会在我们对其应用`join`函数之前保存它们遇到的任何异常。此外，actors可以被链接和监控，以提供一种自动的错误恢复形式。以这种方式，actors更专注于构建容错系统。
- en: These distinguishing factors between CSPs and the actor model give us an idea
    about which approach is more suitable for implementing asynchronous tasks in a
    given problem.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: CSPs（通信顺序进程）与actor模型之间的这些区别因素，让我们对在特定问题中实现异步任务哪种方法更合适有了概念。
- en: Summary
  id: totrans-1461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how we can create concurrent and asynchronous
    tasks using the `core.async` and Pulsar libraries. The `core.async` library provides
    an implementation of CSPs, and is supported in both Clojure and ClojureScript.
    We studied the various constructs in the `core.async` library and also demonstrated
    how a solution to the dining philosophers problem can be implemented using this
    library. Later on, we explored actors through the Pulsar library.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用`core.async`和Pulsar库创建并发和异步任务。`core.async`库提供了一个CSP的实现，并在Clojure和ClojureScript中都有支持。我们研究了`core.async`库中的各种构造，并展示了如何使用这个库实现就餐哲学家问题的解决方案。后来，我们通过Pulsar库探索了actor。
- en: We will explore reactive programming in the following chapter. As we will see
    ahead, reactive programming can be thought of as an extension of asynchronous
    programming for handling data and events.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨响应式编程。正如我们之前所看到的，响应式编程可以被视为异步编程的扩展，用于处理数据和事件。
- en: Chapter 9. Reactive Programming
  id: totrans-1464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。响应式编程
- en: One of the many interesting applications of programming with asynchronous tasks
    is *reactive programming*. This methodology of programming is all about asynchronously
    reacting to changes in state. In reactive programming, code is structured in such
    a way that it *reacts* to changes. Generally, this is implemented using asynchronous
    data streams, in which data and events are propagated asynchronously through a
    program. In fact, there are quite a few interesting variants of reactive programming.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步任务进行编程的许多有趣应用之一是*响应式编程*。这种编程方法完全是关于异步响应状态的变化。在响应式编程中，代码以这样的方式组织，它可以*响应*变化。通常，这是通过异步数据流实现的，其中数据和事件在程序中异步传播。实际上，响应式编程有许多有趣的变体。
- en: Reactive programming is particularly useful in designing graphical user interfaces
    in frontend development, where changes in the internal state of an application
    must asynchronously trickle down to the user interface. A program is thus segregated
    into events and logic that is executed on those events. For programmers used to
    imperative and object-oriented programming techniques, the hardest part of reactive
    programming is thinking in reactive abstractions and letting go of old habits
    like using the mutable state. However, if you've been paying attention so far
    and have started thinking with immutability and functions, you'll find reactive
    programming quite natural. In the JavaScript world, reactive programming with
    *observables* can be thought of as a contrasting alternative to using promises
    to manage asynchronous events and actions.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程在设计和开发前端图形用户界面时特别有用，因为应用程序内部状态的变化必须异步地逐渐传递到用户界面。因此，程序被分割成事件和在这些事件上执行的逻辑。对于习惯于命令式和面向对象编程技术的程序员来说，响应式编程中最困难的部分是思考响应式抽象，并放弃使用可变状态等旧习惯。然而，如果你一直保持关注并开始用不可变性和函数进行思考，你会发现响应式编程非常自然。在JavaScript世界中，使用*观察者*进行响应式编程可以被视为使用承诺管理异步事件和动作的对比替代方案。
- en: In this chapter, we will explore a few interesting forms of reactive programming
    through Clojure and ClojureScript libraries. Later on, we will also demonstrate
    how we can build dynamic user interfaces using reactive programming.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过Clojure和ClojureScript库探索一些有趣的响应式编程形式。稍后，我们还将展示如何使用响应式编程构建动态用户界面。
- en: Reactive programming with fibers and dataflow variables
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纤维和数据流变量进行响应式编程
- en: '*Dataflow programming* is one of the simplest forms of reactive programming.
    In dataflow programming, computations are described by composing variables without
    bothering about when these variables are set to a value. Such variables are also
    called **dataflow variables**, and they will trigger computations that refer to
    them once they are set. The *Pulsar* library ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar))
    provides a few useful constructs for dataflow programming. These constructs can
    also be used with Pulsar **fibers**, which we briefly talked about in [Chapter
    8](ch23.html "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous
    Tasks*. In this section, we will explore the basics of fibers and dataflow variables
    from the Pulsar library.'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据流编程* 是反应式编程中最简单的一种形式。在数据流编程中，计算是通过组合变量来描述的，而不必关心这些变量何时被设置为某个值。这样的变量也被称为
    **数据流变量**，一旦它们被设置，就会触发引用它们的计算。*Pulsar* 库（[https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)）为数据流编程提供了一些有用的构造。这些构造也可以与
    Pulsar **纤维** 一起使用，我们曾在第 8 章 *利用异步任务* 中简要讨论过。在本节中，我们将从 Pulsar 库中探索纤维和数据流变量的基础知识。'
- en: Note
  id: totrans-1470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例所需的库依赖项：
- en: '[PRE332]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Your `project.clj` file must also contain the following entries:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `project.clj` 文件还必须包含以下条目：
- en: '[PRE333]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE334]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The elementary abstraction of an asynchronous task in the Pulsar library is
    a fiber. Fibers are scheduled for execution on fork-join based thread pools, and
    we can create a large number of fibers without bothering about the number of available
    processing cores. Fibers can be created using the `spawn-fiber` and `fiber` macros
    from the `co.paralleluniverse.pulsar.core` namespace. The `spawn-fiber` macro
    must be passed a function that takes no arguments, and the `fiber` form must be
    passed a body of expressions. The body of both these forms will be executed on
    a new fiber. The `join` function from the `co.paralleluniverse.pulsar.core` namespace
    can be used to retrieve the value returned by a fiber.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar 库中异步任务的基本抽象是纤维。纤维被安排在基于 fork-join 的线程池上执行，我们可以创建大量纤维，而无需担心可用的处理核心数量。可以使用来自
    `co.paralleluniverse.pulsar.core` 命名空间的 `spawn-fiber` 和 `fiber` 宏来创建纤维。`spawn-fiber`
    宏必须传递一个不接受任何参数的函数，而 `fiber` 形式必须传递一个表达式体。这两个形式的体将在新的纤维上执行。可以使用来自 `co.paralleluniverse.pulsar.core`
    命名空间的 `join` 函数来检索纤维返回的值。
- en: An important rule we must keep in mind while dealing with fibers is that we
    must never call methods or functions that manipulate the current thread of execution
    from within a fiber. Instead, we must use fiber-specific functions from the `co.paralleluniverse.pulsar.core`
    namespace to perform these operations. For example, calling the `java.lang.Thread/sleep`
    method in a fiber must be avoided. Instead, the `sleep` function from the `co.paralleluniverse.pulsar.core`
    namespace can be used to suspend the current fiber for a given number of milliseconds.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理纤维时，我们必须牢记的一个重要规则是，我们绝不能在纤维内部调用操作当前执行线程的方法或函数。相反，我们必须使用来自 `co.paralleluniverse.pulsar.core`
    命名空间的特殊纤维函数来执行这些操作。例如，在纤维中调用 `java.lang.Thread/sleep` 方法必须避免。相反，可以使用来自 `co.paralleluniverse.pulsar.core`
    命名空间的 `sleep` 函数来暂停当前纤维一段时间，以毫秒为单位。
- en: Note
  id: totrans-1479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c9/fibers.clj` of the book's
    source code. Some of these examples are based on code from the official Pulsar
    documentation ([http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)).
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c9/fibers.clj` 中找到。其中一些示例基于官方 Pulsar 文档中的代码（[http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)）。
- en: 'For example, we can add two numbers using a fiber as shown in *Example 9.1*.
    Of course, using a fiber for such a trivial operation has no practical use, and
    it is only shown here to demonstrate how we can create a fiber and obtain its
    return value:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用纤维来添加两个数字，如 *示例 9.1* 所示。当然，使用纤维进行这种微不足道的操作没有实际用途，这里仅展示如何创建纤维并获取其返回值：
- en: '[PRE335]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '*Example 9.1: Adding two numbers with a fiber*'
  id: totrans-1483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.1：使用纤维添加两个数字*'
- en: The preceding `add-with-fiber` function creates a fiber `f` using the `spawn-fiber`
    macro and fetches the return value of the fiber using the `join` function. The
    fiber `f` will suspend itself for `100` milliseconds using the `sleep` function
    and then return the sum of `a` and `b`.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `add-with-fiber` 函数使用 `spawn-fiber` 宏创建了一个纤维 `f`，并使用 `join` 函数获取纤维的返回值。纤维
    `f` 将使用 `sleep` 函数暂停 `100` 毫秒，然后返回 `a` 和 `b` 的和。
- en: Let's talk a bit about dataflow variables. We can create dataflow variables
    using the `df-val` and `df-var` functions from the `co.paralleluniverse.pulsar.dataflow`
    namespace. A dataflow variable created using these functions can be set by calling
    it like a function and passing it a value. Also, the value of a dataflow variable
    can be obtained by dereferencing it using the `@` operator or the `deref` form.
    A dataflow variable declared using the `df-val` function can only be set once,
    whereas one created using the `df-var` function can be set several times.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单谈谈数据流变量。我们可以使用 `co.paralleluniverse.pulsar.dataflow` 命名空间中的 `df-val` 和
    `df-var` 函数来创建数据流变量。使用这些函数创建的数据流变量可以通过像调用函数一样调用它并传递一个值来设置。此外，可以通过使用 `@` 操作符或 `deref`
    形式解引用来获取数据流变量的值。使用 `df-val` 函数声明的数据流变量只能设置一次，而使用 `df-var` 函数创建的可以设置多次。
- en: 'The `df-var` function can also be passed a function that takes no arguments
    and refers to other dataflow variables in the current scope. This way, the value
    of such a dataflow variable will be recomputed when the values of referenced variables
    are changed. For example, two numbers can be added using dataflow variables as
    shown in the `df-add` function defined in *Example 9.2*:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '`df-var` 函数也可以传递一个不带参数的函数，该函数引用当前作用域中的其他数据流变量。这样，当引用变量的值发生变化时，此类数据流变量的值将重新计算。例如，可以使用数据流变量将两个数字相加，如
    *示例 9.2* 中定义的 `df-add` 函数所示：'
- en: '[PRE336]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '*Example 9.2: Adding two numbers with dataflow variables*'
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.2：使用数据流变量添加两个数字*'
- en: 'The value of the dataflow variable `sum`, declared in the preceding `df-add`
    function, will be recalculated when the referenced dataflow variables `x` and
    `y` are set to a value. The variables `x` and `y` are set by calling them like
    functions. Similarly, we can add a number to each element in a range of numbers
    using the `df-val` and `df-var` functions as shown in the following *Example 9.3*:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `df-add` 函数中声明的数据流变量 `sum` 的值将在引用的数据流变量 `x` 和 `y` 被设置为值时重新计算。变量 `x` 和 `y`
    通过像函数一样调用它们来设置。同样，我们可以使用 `df-val` 和 `df-var` 函数，如以下 *示例 9.3* 所示，向数字范围中的每个元素添加一个数字：
- en: '[PRE337]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '*Example 9.3: Adding a number to a range of number with dataflow variables*'
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.3：使用数据流变量向数字范围添加一个数字*'
- en: 'The `df-add-to-range` function shown previously defines the dataflow variables
    `x`, `y`, and `sum`, where `sum` is dependent on `x` and `y`. The function then
    creates a fiber `f` that uses the `for` macro to return a sequence of values.
    Within the body of the `for` macro, the dataflow variable `y` is set to a value
    from the range `r`, and the value `@sum` is returned. The fiber thus returns the
    result of adding `a` to all elements in the range `r`, as shown in the following
    output:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的 `df-add-to-range` 函数定义了数据流变量 `x`、`y` 和 `sum`，其中 `sum` 依赖于 `x` 和 `y`。该函数随后创建了一个使用
    `for` 宏返回一系列值的纤维 `f`。在 `for` 宏的体内，数据流变量 `y` 被设置为范围 `r` 中的一个值，并返回 `@sum` 的值。因此，纤维返回了将
    `a` 添加到范围 `r` 中所有元素的结果，如下面的输出所示：
- en: '[PRE338]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: In conclusion, we can use the `df-val` and `df-var` functions to define dataflow
    variables, whose value can be recomputed when its referenced variables are changed.
    Effectively, changing the state of a dataflow variable may cause other dataflow
    variables to *react* to the change.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以使用 `df-val` 和 `df-var` 函数来定义数据流变量，当其引用的变量发生变化时，其值可以重新计算。实际上，更改数据流变量的状态可能会使其他数据流变量对变化做出
    *反应*。
- en: We should note that the Pulsar library also implements channels, which are analogous
    to channels from the `core.async` library. In a nutshell, channels can be used
    to exchange data with fibers. The Pulsar library also provides constructs for
    reactive programming with channels, through the `co.paralleluniverse.pulsar.rx`
    namespace. These constructs are termed as *reactive extensions*, and are very
    similar to transducers, in the sense that they perform some computation on the
    values in a channel. Reactive extensions are also implemented by the *RxClojure*
    library. We should note that one of the limitations of both the Pulsar and RxClojure
    libraries is that they are available only on the JVM, and can't be used in ClojureScript
    programs. Thus, using `core.async` channels with transducers is a more feasible
    option in ClojureScript. Nevertheless, we will briefly explore reactive extensions
    through the RxClojure library in the following section.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，Pulsar库也实现了通道，这些通道与`core.async`库中的通道类似。简而言之，通道可以用于与纤维交换数据。Pulsar库还通过`co.paralleluniverse.pulsar.rx`命名空间提供了具有通道的响应式编程结构。这些结构被称为*响应式扩展*，它们在通道中的值上执行某些计算，与转换器非常相似。响应式扩展也由*RxClojure*库实现。我们应该注意，Pulsar和RxClojure库的一个局限性是它们仅在JVM上可用，不能用于ClojureScript程序。因此，在ClojureScript中使用带有转换器的`core.async`通道是一个更可行的选项。尽管如此，我们将在下一节简要探讨通过RxClojure库的响应式扩展。
- en: Using Reactive Extensions
  id: totrans-1496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式扩展
- en: '**Reactive Extensions** (written as **Rx**) are a generalized implementation
    of reactive programming that can be used to model event and data streams. Rx can
    be thought of as an object-oriented approach to reactive programming, in the sense
    that an event stream is an object with certain methods and properties. In Rx,
    asynchronous event streams are termed as *observables*. An entity or object that
    subscribes to events from an observable is called an *observer*. Reactive extensions
    are essentially a library of functions, or methods, to manipulate observables
    and create objects that conform to the observer-observable pattern. For example,
    an observable can be transformed using the Rx variants of the `map` and `filter`
    functions, as shown in the following illustration:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式扩展**（缩写为**Rx**）是响应式编程的通用实现，可用于建模事件和数据流。在Rx中，可以将事件流视为具有某些方法和属性的对象。在Rx中，异步事件流被称为*可观察量*。订阅来自可观察量事件的实体或对象被称为*观察者*。响应式扩展本质上是一个函数库或方法库，用于操作可观察量并创建符合观察者-可观察量模式的对象。例如，可以使用Rx的`map`和`filter`函数变体来转换可观察量，如下面的插图所示：'
- en: '![Using Reactive Extensions](img/B05024_09_01.jpg)'
  id: totrans-1498
  prefs: []
  type: TYPE_IMG
  zh: '![使用响应式扩展](img/B05024_09_01.jpg)'
- en: As shown previously, an observable can be described as a collection of values
    that vary over a period of time. It's quite evident that observables can be treated
    as a sequence of values using the Rx-flavored variants of the `map` and `filter`
    functions. An observable can also be subscribed to by an observer, and the observer
    will be asynchronously invoked for any value produced by an observable.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个可观察量可以被描述为随时间变化的一系列值。很明显，可观察量可以用`map`和`filter`函数的Rx风格变体来处理，将其视为值序列。一个可观察量也可以被观察者订阅，观察者将对可观察量产生的任何值进行异步调用。
- en: We will now discuss the various constructs of the RxClojure library ([https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)).
    There are several implementations of Rx across multiple languages, such as C#,
    Java, and PHP. The Java library for reactive extensions is RxJava, and the RxClojure
    library provides Clojure bindings to RxJava. As we mentioned earlier, it's important
    to note that RxClojure can only be used on the JVM. Also, the RxClojure library
    predates the implementation of transducers in Clojure, and thus channels and transducers
    are a more portable and generic approach to reactive programming.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论RxClojure库的各种结构（[https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)）。Rx在多种语言中都有几个实现，例如C#、Java和PHP。响应式扩展的Java库是RxJava，RxClojure库为RxJava提供了Clojure绑定。如我们之前提到的，需要注意的是，RxClojure只能在JVM上使用。此外，RxClojure库在Clojure实现转换器之前就已经存在，因此通道和转换器是响应式编程的更便携和更通用的方法。
- en: Note
  id: totrans-1501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖项对于即将到来的示例是必需的：
- en: '[PRE339]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE340]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: The `rx.lang.clojure.core` namespace contains functions for creating and manipulating
    observables. Observables are internally represented as collections of values.
    To extract values from observables, we can use functions from the `rx.lang.clojure.blocking`
    namespace. However, we must note that functions from the `rx.lang.clojure.blocking`
    namespace must be avoided in a program and used only for testing purposes. The
    `rx.lang.clojure.interop` namespace contains functions for performing Java interop
    with the underlying RxJava library.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '`rx.lang.clojure.core`命名空间包含用于创建和操作可观察对象的函数。可观察对象在内部表示为值的集合。要从可观察对象中提取值，我们可以使用`rx.lang.clojure.blocking`命名空间中的函数。然而，我们必须注意，`rx.lang.clojure.blocking`命名空间中的函数应避免在程序中使用，仅用于测试目的。`rx.lang.clojure.interop`命名空间包含用于与底层RxJava库进行Java互操作的函数。'
- en: Note
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `src/m_clj/c9/rx.clj` of the book's source
    code.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`src/m_clj/c9/rx.clj`中找到。
- en: 'A value can be converted to an observable using the `return` function from
    the `rx.lang.clojure.core` namespace. An observable can be converted to a vector
    of values using the `rx.lang.clojure.blocking/into` function, and similarly, we
    can obtain the first value of an observable using the `rx.lang.clojure.blocking/first`
    function. These functions are demonstrated in the following output:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`rx.lang.clojure.core`命名空间中的`return`函数将值转换为可观察对象。可以使用`rx.lang.clojure.blocking/into`函数将可观察对象转换为值的向量，同样，我们可以使用`rx.lang.clojure.blocking/first`函数获取可观察对象的第一值。这些函数在以下输出中得到了演示：
- en: '[PRE341]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'A sequence of values can be converted to an observable using the `seq->o` function
    from the `rx.lang.clojure.core` namespace. To convert the observable back to a
    sequence, we pass it to the `o->seq` function from the `rx.lang.clojure.blocking`
    namespace. For example, we can convert the vector `[1 2 3]` to an observable and
    back to a sequence, as shown here:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`rx.lang.clojure.core`命名空间中的`seq->o`函数将值序列转换为可观察对象。要将可观察对象转换回序列，我们将它传递给`rx.lang.clojure.blocking`命名空间中的`o->seq`函数。例如，我们可以将向量`[1
    2 3]`转换为可观察对象，然后再将其转换回序列，如下所示：
- en: '[PRE342]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'Another way of creating an observable is by using the `cons` and `empty` functions
    from the `rx.lang.clojure.core` namespace. The `empty` function creates an observable
    with no values, and the `cons` function adds or combines a value and an observable
    into a new, observable, similar to the standard `cons` function. We can create
    an observable containing the value `0` using the `cons` and `empty` functions
    as follows:'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可观察对象的另一种方法是使用`rx.lang.clojure.core`命名空间中的`cons`和`empty`函数。`empty`函数创建一个没有值的可观察对象，而`cons`函数将一个值和一个可观察对象添加或组合到一个新的、可观察的对象中，类似于标准的`cons`函数。我们可以使用`cons`和`empty`函数创建包含值`0`的可观察对象，如下所示：
- en: '[PRE343]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'As we mentioned earlier, observers can subscribe to events from observables.
    Observers can be defined by implementing the `rx.lang.clojure.Observer` interface.
    This interface defines three methods, namely `onNext`, `onError`, and `onCompleted`.
    The `onNext` method is called whenever an observable produces a new value, and
    the `onCompleted` method is called when an observable is done producing values.
    The `onError` method will be called in case an exception is encountered. Interestingly,
    all of these methods will be invoked asynchronously from an observable. For example,
    we can create an observer using the `reify` form to implement the `Observer` interface
    as shown in *Example 9.4*:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，观察者可以订阅可观察对象的事件。观察者可以通过实现`rx.lang.clojure.Observer`接口来定义。该接口定义了三个方法，即`onNext`、`onError`和`onCompleted`。每当可观察对象产生新值时，都会调用`onNext`方法，而当可观察对象完成产生值时，会调用`onCompleted`方法。如果遇到异常，将调用`onError`方法。有趣的是，所有这些方法都将从可观察对象异步调用。例如，我们可以使用`reify`形式创建一个观察者来实现`Observer`接口，如*示例
    9.4*所示：
- en: '[PRE344]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '*Example 9.4: Implementing the rx.lang.clojure.Observer interface*'
  id: totrans-1517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.4：实现 rx.lang.clojure.Observer 接口*'
- en: 'An observable can call the methods of all its subscribed observers using the
    `on-next`, `on-error` and `on-completed` functions from the `rx.lang.clojure.core`
    namespace. We can also define an observable using these functions and the `observable*`
    form from the `rx.lang.clojure.core` namespace. The `observable*` form must be
    passed a function that takes a single argument, which represents an observer.
    For example, we can define a function to create an observable of two values using
    the `observable*` form as shown in *Example 9.5*:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象可以使用 `rx.lang.clojure.core` 命名空间中的 `on-next`、`on-error` 和 `on-completed`
    函数调用其所有已订阅观察者的方法。我们还可以使用这些函数和 `rx.lang.clojure.core` 命名空间中的 `observable*` 形式定义可观察对象。`observable*`
    形式必须传递一个接受单个参数的函数，该参数表示观察者。例如，我们可以使用 `observable*` 形式定义一个创建两个值可观察对象的函数，如 *示例 9.5*
    所示：
- en: '[PRE345]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '*Example 9.5: Creating an observable using the observable* form*'
  id: totrans-1520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.5：使用 observable 形式创建可观察对象*'
- en: 'The function passed to the `observable*` form, shown previously, calls the
    `on-next` and `on-completed` functions to produce an observable of two values.
    We can convert this observable into a vector using the `into` function from the
    `rx.lang.clojure.blocking` namespace, as shown here:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的 `observable*` 形式的函数调用 `on-next` 和 `on-completed` 函数以产生两个值的可观察对象。我们可以使用
    `rx.lang.clojure.blocking` 命名空间中的 `into` 函数将此可观察对象转换为向量，如下所示：
- en: '[PRE346]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'An observer can also be created using the `subscribe` function from the `rx.lang.clojure.core`
    namespace. This function must be passed a function that takes a single value,
    and an observer will be created by implementing the `onNext` method using the
    supplied function. We can also pass a second argument representing the `onError`
    method, as well as a third argument that represents the `onCompleted` method,
    to the `subscribe` function. For example, we can subscribe to an observable using
    the `subscribe` function, and apply a function to all values in the observable
    using the `rx.lang.clojure.core/map` function, as shown in *Example 9.6*:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者也可以使用 `rx.lang.clojure.core` 命名空间中的 `subscribe` 函数创建。这个函数必须传递一个接受单个值的函数，并通过实现提供的函数使用
    `onNext` 方法创建观察者。我们还可以将表示 `onError` 方法的第二个参数以及表示 `onCompleted` 方法的第三个参数传递给 `subscribe`
    函数。例如，我们可以使用 `subscribe` 函数订阅可观察对象，并使用 `rx.lang.clojure.core/map` 函数对所有可观察对象中的值应用一个函数，如
    *示例 9.6* 所示：
- en: '[PRE347]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '*Example 9.6: Subscribing to an observable using the subscribe function*'
  id: totrans-1525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.6：使用 subscribe 函数订阅可观察对象*'
- en: 'We can create an observable and pass it to the `rx-inc` function defined in
    *Example 9.6*, as shown here:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个可观察对象并将其传递给 *示例 9.6* 中定义的 `rx-inc` 函数，如下所示：
- en: '[PRE348]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'The function passed to the `subscribe` form in *Example 9.6* is executed every
    time the `inc` function is applied to a value in the observable `o`. We could
    as well define the `rx-inc` function using Java interop with RxJava, as shown
    in *Example 9.7*:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 9.6* 中传递给 `subscribe` 形式的函数会在每次将 `inc` 函数应用于可观察对象 `o` 中的值时执行。我们同样可以使用
    RxJava 和 Java 互操作定义 `rx-inc` 函数，如 *示例 9.7* 所示：
- en: '[PRE349]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '*Example 9.7: Subscribing to an observable using the Java interop*'
  id: totrans-1530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.7：使用 Java 互操作订阅可观察对象*'
- en: 'It''s quite clear that using the RxJava library through Java interop isn''t
    pretty, as we would have to wrap all the functions in the `action` and `fn` forms
    from the `rx.lang.clojure.interop` namespace. The `action` macro is used to represent
    a function that performs a side-effect, whereas the `fn` macro is used to wrap
    functions that return values. Observables can also be created using the Java interop.
    This is done using the `from` static method from the `rx.lang.clojure.core.Observable`
    class. The following output demonstrates this method as well as the `rxj-inc`
    function defined in *Example 9.7*:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，通过 Java 互操作使用 RxJava 库并不美观，因为我们不得不将 `rx.lang.clojure.interop` 命名空间中的 `action`
    和 `fn` 形式的所有函数包装起来。`action` 宏用于表示执行副作用的功能，而 `fn` 宏用于包装返回值的函数。可观察对象也可以使用 Java 互操作创建。这是通过
    `rx.lang.clojure.core.Observable` 类的 `from` 静态方法完成的。以下输出展示了此方法以及定义在 *示例 9.7* 中的
    `rxj-inc` 函数：
- en: '[PRE350]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Of course, we should prefer to use functions from the `rx.lang.clojure.core`
    namespace, and we are using Java interop here only to show that it is possible.
    Similar to the `map` function used in *Example 9.6*, there are several other functions
    in the `rx.lang.clojure.core` namespace that allow us to treat observables as
    sequences. Thus, functions such as `map`, `filter`, and `mapcat` comprise the
    interface of observables, and describe the many ways in which we can interact
    with them. For example, the following output demonstrates the Rx variants of the
    `take`, `cycle`, and `range` functions:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该优先使用来自 `rx.lang.clojure.core` 命名空间的功能，我们在这里使用 Java 互操作只是为了说明这是可能的。类似于在
    *示例 9.6* 中使用的 `map` 函数，`rx.lang.clojure.core` 命名空间中还有其他几个函数允许我们将可观察对象视为序列。因此，`map`、`filter`
    和 `mapcat` 等函数构成了可观察对象的接口，并描述了我们与之交互的多种方式。例如，以下输出演示了 `take`、`cycle` 和 `range`
    函数的 Rx 变体：
- en: '[PRE351]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'The `rx.lang.clojure.core` namespace also provides a `filter` function that
    can be used with an observable and a predicate, as shown here:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '`rx.lang.clojure.core` 命名空间还提供了一个 `filter` 函数，可以与可观察对象和谓词一起使用，如下所示：'
- en: '[PRE352]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'The `group-by` and `mapcat` functions from the `rx.lang.clojure.core` namespace
    have the same semantics as the standard versions of these functions. For example,
    let''s define a function that uses the `group-by` and `mapcat` functions, as shown
    in *Example 9.8*:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `rx.lang.clojure.core` 命名空间的 `group-by` 和 `mapcat` 函数与这些函数的标准版本具有相同的语义。例如，让我们定义一个使用
    `group-by` 和 `mapcat` 函数的函数，如 *示例 9.8* 所示：
- en: '[PRE353]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '*Example 9.8: Using the group-by and mapcat functions*'
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.8：使用 group-by 和 mapcat 函数*'
- en: 'The `group-maps` function, defined previously, will transform a number of maps
    into an observable, group the maps by their values for the key `:k`, and create
    a number of vectors using the `mapcat` and `map` functions. Of course, we wouldn''t
    really need such a function in practice, and it''s only shown here to demonstrate
    how the `group-by` and `mapcat` functions can be used. We can pass a vector of
    maps to the `group-maps` function to produce a sequence of vectors, as shown here:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `group-maps` 函数将多个映射转换为可观察对象，按键 `:k` 的值对这些映射进行分组，并使用 `mapcat` 和 `map`
    函数创建多个向量。当然，在实践中我们可能并不真的需要这样的函数，这里只展示如何使用 `group-by` 和 `mapcat` 函数。我们可以将映射的向量传递给
    `group-maps` 函数以生成一个向量的序列，如下所示：
- en: '[PRE354]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'Several observables can be combined using the `merge` function from the `rx.lang.clojure.core`
    namespace. The `merge` function can be passed any number of observables, as shown
    here:'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `rx.lang.clojure.core` 命名空间的 `merge` 函数将多个可观察对象组合起来。`merge` 函数可以传递任意数量的可观察对象，如下所示：
- en: '[PRE355]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'An observable can also be split up into two observables using the `split-with`
    function from the `rx.lang.clojure.core` namespace. This function must be passed
    an observable and a predicate function, as shown here:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象也可以使用 `rx.lang.clojure.core` 命名空间的 `split-with` 函数拆分为两个可观察对象。这个函数必须传递一个可观察对象和一个谓词函数，如下所示：
- en: '[PRE356]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: In summary, the RxClojure library provides us with several constructs for creating
    and manipulating observables. We can also easily create observers that asynchronously
    *react* to observables using the `subscribe` function from this library. Also,
    the constructs from the `rx.lang.clojure.core` namespace have semantics similar
    to that of standard functions such as `map`, `filter`, and `mapcat`. There are
    several functions in the `rx.lang.clojure.core` namespace that we haven't talked
    about in this section, and you're encouraged to explore them on your own.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，RxClojure 库为我们提供了创建和操作可观察对象的几个构造。我们还可以使用这个库中的 `subscribe` 函数轻松创建异步 *响应*
    可观察对象的观察者。此外，`rx.lang.clojure.core` 命名空间中的构造与标准函数（如 `map`、`filter` 和 `mapcat`）的语义相似。在本节中，我们还没有讨论
    `rx.lang.clojure.core` 命名空间中的几个函数，我们鼓励你自己去探索它们。
- en: Using functional reactive programming
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数式响应式编程
- en: A more functional flavor of reactive programming is **functional reactive programming**
    (abbreviated as **FRP**). FRP was first described in the late '90s by Conal Elliott,
    who was a member of the Microsoft Graphics Research Group at the time, and Paul
    Hudak, a major contributor to the Haskell programming language. FRP was originally
    described as a bunch of functions to interact with *events* and *behaviors*. Both
    events and behaviors represent values that change over time. The major difference
    between these two is that events are values that change discretely over time,
    whereas behaviors are continuously changing values. There is no mention of an
    observer-observable pattern in FRP. Also, programs in FRP are written as composable
    transformations of events and behaviors, and are also termed as **compositional
    event systems** (**CESs**).
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 更功能化的响应式编程风味是**函数式响应式编程**（简称**FRP**）。FRP首次在20世纪90年代末由Conal Elliott描述，当时他是微软图形研究小组的成员，同时也是Haskell编程语言的主要贡献者。FRP最初被描述为一系列用于与*事件*和*行为*交互的函数。事件和行为都代表随时间变化的值。这两者之间的主要区别在于，事件是随时间离散变化的值，而行为是持续变化的值。在FRP中没有提到观察者可观察的模式。此外，FRP中的程序被编写为事件和行为的可组合转换，也被称作**组合事件系统**（**CESs**）。
- en: Modern implementations of FRP provide constructs to create and transform asynchronous
    event streams. Also, any form of state change is represented as an event stream.
    In this perspective, a click of a button, a request made to a server, and mutating
    a variable, can all be treated as event streams. The *Bacon.js* library ([https://github.com/baconjs/bacon.js/](https://github.com/baconjs/bacon.js/))
    is a JavaScript implementation of FRP, and the *Yolk* library ([https://github.com/Cicayda/yolk](https://github.com/Cicayda/yolk))
    provides ClojureScript bindings to the Bacon.js library. In this section, we will
    briefly study the constructs provided by the Yolk library.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: FRP的现代实现提供了创建和转换异步事件流的构造。任何形式的状态变化都表示为事件流。从这个角度来看，按钮的点击、对服务器的请求以及变量的修改都可以被视为事件流。*Bacon.js*库（[https://github.com/baconjs/bacon.js/](https://github.com/baconjs/bacon.js/））是FRP的JavaScript实现，*Yolk*库（[https://github.com/Cicayda/yolk](https://github.com/Cicayda/yolk)）提供了对Bacon.js库的ClojureScript绑定。在本节中，我们将简要研究Yolk库提供的构造。
- en: Note
  id: totrans-1550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例需要以下库依赖：
- en: '[PRE357]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须包含在您的命名空间声明中：
- en: '[PRE358]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `set-html!` and `by-id` functions from `src/m_clj/c9/common.cljs`. These functions
    are defined as follows:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的依赖项之外，以下示例还使用了来自`src/m_clj/c9/common.cljs`的`set-html!`和`by-id`函数。这些函数定义如下：
- en: '[PRE359]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Ensure that the code in the following ClojureScript examples is compiled, using
    the following command:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下ClojureScript示例中的代码使用以下命令编译：
- en: '[PRE360]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: The `yolk.bacon` namespace provides several functions to create event streams,
    such as the `later` and `interval` functions. The `later` function creates an
    event stream that produces a single value after a given delay. The `interval`
    function can infinitely repeat a value with a given time interval. Both these
    functions must be passed a number of milliseconds as the first argument and a
    value to produce as the second argument.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '`yolk.bacon`命名空间提供了创建事件流的几个函数，例如`later`和`interval`函数。`later`函数创建一个事件流，在给定延迟后产生一个单一值。`interval`函数可以在给定的时间间隔内无限重复一个值。这两个函数都必须传递一个表示毫秒数的第一个参数和一个作为第二个参数产生的值。'
- en: Event streams in the Yolk library may produce an infinite number of values.
    We can limit the number of values produced by an event stream by using the `yolk.bacon/sliding-window`
    function, which creates an event stream that drops older values once it's full.
    This function must be passed an event stream and a number indicating the capacity
    of the event stream returned by it.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: Yolk库中的事件流可能会产生无限数量的值。我们可以通过使用`yolk.bacon/sliding-window`函数来限制事件流产生的值的数量，该函数创建一个事件流，一旦填满就会丢弃旧值。此函数必须传递一个事件流和一个表示返回的事件流容量的数字。
- en: We can also create an *event bus*, onto which we can arbitrarily push values,
    using the `bus` function from the `yolk.bacon` namespace. The `push` function
    puts a value onto an event bus, and the `plug` function connects an event bus
    to another event stream.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `yolk.bacon` 命名空间中的 `bus` 函数创建一个 *事件总线*，我们可以任意地向其推送值。`push` 函数将一个值推送到事件总线，而
    `plug` 函数将事件总线连接到另一个事件流。
- en: To listen to values produced from event streams, we can use the `on-value`,
    `on-error`, and `on-end` functions. The `on-value` and `on-error` functions will
    call a supplied 1-arity function whenever a given event stream produces a value
    or an error, respectively. The `on-end` function will call a supplied function
    that takes no arguments whenever a stream ends. This function is often used with
    the `yolk.bacon/never` function, which creates an event stream that ends immediately
    without producing a value.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听事件流产生的值，我们可以使用 `on-value`、`on-error` 和 `on-end` 函数。`on-value` 和 `on-error`
    函数将在给定的事件流产生值或错误时分别调用提供的 1-arity 函数。`on-end` 函数将在流结束时调用一个不带参数的函数。此函数通常与 `yolk.bacon/never`
    函数一起使用，该函数创建一个立即结束而不产生值的流。
- en: Event streams can also be combined in several ways. The `merge-all` function
    combines a vector of several event streams into a single one. Another function
    that can collect values from several event streams in this way is the `flat-map`
    function. Alternatively, the `combine-array` function can be used to create a
    single event stream that produces arrays of the values from the supplied streams.
    The `yolk.bacon/when` function can be used to conditionally combine several channels.
    This function must be passed a number of clauses, similar to the `cond` form.
    Each clause must have two parts—a vector of event streams and an expression that
    will be invoked when all the supplied event streams produce values.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流也可以以几种方式组合。`merge-all` 函数将多个事件流组合成一个单一的流。另一种以这种方式从多个事件流中收集值的函数是 `flat-map`
    函数。或者，可以使用 `combine-array` 函数创建一个生成从提供的流中值的数组的单一事件流。`yolk.bacon/when` 函数可以用来条件性地组合多个通道。此函数必须传递多个子句，类似于
    `cond` 形式。每个子句必须有两个部分——事件流的向量和一个表达式，当所有提供的事件流产生值时将调用该表达式。
- en: The `yolk.bacon` namespace also provides event stream based variants of the
    standard `map`, `filter`, and `take` functions. These functions take an event
    stream as the first argument, which is a little different from the semantics of
    the standard versions of these functions.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '`yolk.bacon` 命名空间还提供了基于事件流的 `map`、`filter` 和 `take` 函数的标准变体。这些函数将事件流作为第一个参数，这与这些函数标准版本的语义略有不同。'
- en: Using these functions from the Yolk library, we can implement a simplified ClojureScript
    based solution to the dining philosophers problem, which we described in the previous
    chapters. For a detailed explanation of the dining philosophers problem and its
    solution, refer to [Chapter 2](ch17.html "Chapter 2. Orchestrating Concurrency
    and Parallelism"), *Orchestrating Concurrency and Parallelism* and [Chapter 8](ch23.html
    "Chapter 8. Leveraging Asynchronous Tasks"), *Leveraging Asynchronous Tasks*.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Yolk 库中的这些函数，我们可以实现一个简化的基于 ClojureScript 的 dining philosophers 问题解决方案，我们已在之前的章节中描述过。有关
    dining philosophers 问题及其解决方案的详细解释，请参阅第 2 章 [Orchestrating Concurrency and Parallelism](ch17.html
    "第 2 章。编排并发与并行") 和第 8 章 [Leveraging Asynchronous Tasks](ch23.html "第 8 章。利用异步任务")。
- en: Note
  id: totrans-1566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following examples can be found in `src/m_clj/c9/yolk/core.cljs` of the
    book''s source code. Also, the HTML page for the following ClojureScript examples
    can be found in `resources/html/yolk.html`. The following scripts will be included
    in this page:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书的源代码的 `src/m_clj/c9/yolk/core.cljs` 中找到。此外，以下 ClojureScript 示例的 HTML
    页面可以在 `resources/html/yolk.html` 中找到。以下脚本将包含在这个页面上：
- en: '[PRE361]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'In this implementation of the dining philosophers problem, we will represent
    the state of the philosophers and the forks on the table using event buses. The
    event buses can then be combined using the `when` function from the Yolk library.
    We won''t maintain much state about the philosophers for the sake of simplicity.
    Let''s first define functions to print the philosophers and represent the routine
    of a philosopher, as shown in the following *Example 9.9*:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 dining philosophers 问题的实现中，我们将使用事件总线来表示哲学家和桌子上的叉子的状态。然后可以使用 Yolk 库中的 `when`
    函数将这些事件总线组合起来。为了简化，我们不会维护太多关于哲学家的状态。让我们首先定义打印哲学家和表示哲学家日常生活的函数，如下面的 *示例 9.9* 所示：
- en: '[PRE362]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '*Example 9.9: Solving the dining philosophers problem with event streams*'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例9.9：使用事件流解决就餐哲学家问题*'
- en: 'The preceding `render-philosophers` function will wrap each philosopher in
    a `div` tag, which will be displayed on a web page. The `philosopher-fn` function
    returns a function that represents the routine of a philosopher. The function
    returned by the `philosopher-fn` function sets off a task, using the `setTimeout`
    JavaScript function, to push values representing a particular philosopher and
    his associated forks into the event buses. This function will finally return a
    string indicating that the given philosopher was able to eat the food supplied
    to him. Using these functions, we can create a simulation of the dining philosophers
    problem in a web page, as shown in the following *Example 9.10*:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`render-philosophers`函数将每个哲学家包裹在一个`div`标签中，该标签将在网页上显示。`philosopher-fn`函数返回一个表示哲学家日常生活的函数。该函数通过使用`setTimeout`
    JavaScript函数启动一个任务，将代表特定哲学家及其相关叉子的值推送到事件总线上。这个函数最终将返回一个字符串，表明给定的哲学家能够吃到提供的食物。使用这些函数，我们可以在网页上创建就餐哲学家问题的模拟，如下面的*示例9.10*所示：
- en: '[PRE363]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '*Example 9.10: Solving the dining philosophers problem with event streams (continued)*'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例9.10：使用事件流解决就餐哲学家问题（继续）*'
- en: 'In the `let` form shown in *Example 9.10*, we created the philosophers and
    forks in our simulation using the `bus` function from the Yolk library. The values
    produced by these event buses are then combined using a `when` form. The `when`
    function in the preceding code will check for events from a philosopher and the
    forks on his left- and right-hand side. The combinations of philosophers and forks
    are, in fact, hardcoded into the clauses of the `when` form. Of course, we must
    understand that the clauses of the `when` form shown previously could have easily
    been generated using a macro. Values are then placed onto the event buses representing
    the philosophers and forks using the `push` function, to start the simulation.
    The last five philosophers who could eat are rendered in the web page, as shown
    here:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例9.10*中显示的`let`形式中，我们使用Yolk库的`bus`函数在我们的模拟中创建了哲学家和叉子。这些事件总线产生的值随后通过`when`形式进行组合。前述代码中的`when`函数将检查来自哲学家及其左右手边的叉子的事件。实际上，哲学家和叉子的组合是硬编码在`when`形式的子句中的。当然，我们必须理解，前面显示的`when`形式的子句可以很容易地通过宏生成。然后使用`push`函数将这些值放置到代表哲学家和叉子的事件总线上，以启动模拟。最后五个能够就餐的哲学家将在网页上显示，如下所示：
- en: '![Using functional reactive programming](img/B05024_09_02.jpg)'
  id: totrans-1576
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数式响应式编程](img/B05024_09_02.jpg)'
- en: In summary, the Yolk library provides several constructs to handle event streams.
    There are several functions from this library that we haven't discussed, and you
    should explore them on your own. In the following section, we will provide examples
    that demonstrate the other functions from the Yolk library.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Yolk库提供了处理事件流的几个构造。该库中还有一些我们尚未讨论的函数，您应该自己探索它们。在下一节中，我们将提供一些示例，展示Yolk库的其他函数。
- en: Note
  id: totrans-1578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the preceding examples are based on code from *Yolk examples* by Wilkes
    Joiner ([https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)).
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 一些先前的示例基于Wilkes Joiner的*Yolk示例*代码（[https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)）。
- en: Building reactive user interfaces
  id: totrans-1580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建响应式用户界面
- en: One of the primary applications of reactive programming is frontend development,
    where we must create user interface components that react asynchronously to changes
    in state. In this section, we will describe a few examples implemented using the
    `core.async` library and the Yolk library. This is meant to give you a comparison
    between channels and event streams, and also demonstrate how we can design solutions
    to problems using both these concepts. Note that only the overall design and code
    for these examples will be described, and you should be able to fill in the details
    on your own.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程的主要应用之一是前端开发，我们必须创建对状态变化异步响应的用户界面组件。在本节中，我们将描述一些使用`core.async`库和Yolk库实现的示例。这是为了向您展示通道和事件流的比较，并展示我们如何使用这两个概念设计解决方案。请注意，这里将仅描述这些示例的整体设计和代码，您应该能够自己填充细节。
- en: Note
  id: totrans-1582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例所需的库依赖项如下：
- en: '[PRE364]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE365]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `set-html!` and `by-id` functions from `src/m_clj/c9/common.cljs`. Ensure
    that the code in the following ClojureScript examples is compiled, using the following
    command:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的依赖关系外，以下示例还使用了来自 `src/m_clj/c9/common.cljs` 的 `set-html!` 和 `by-id` 函数。请确保以下
    ClojureScript 示例中的代码使用以下命令进行编译：
- en: '[PRE366]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: As a first example, let's create three asynchronous tasks that each produce
    values at different time intervals. We must fetch all the values produced by these
    tasks and render them on a web page in the same order.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个示例，让我们创建三个异步任务，每个任务在不同的时间间隔产生值。我们必须获取这些任务产生的所有值，并以相同的顺序在网页上渲染它们。
- en: Note
  id: totrans-1590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following examples can be found in `src/m_clj/c9/reactive/core.cljs` of
    the book''s source code. Also, the HTML page for the following ClojureScript examples
    can be found in `resources/html/reactive.html`. The following scripts will be
    included in this page:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c9/reactive/core.cljs` 中找到。此外，以下 ClojureScript 示例的
    HTML 页面可以在 `resources/html/reactive.html` 中找到。以下脚本将包含在此页面上：
- en: '[PRE367]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'We could implement this using processes and channels from the `core.async`
    library. In this case, channels will convey the values produced by three processes,
    and we will use a `merge` operation to combine these channels, as shown in the
    following *Example 9.11*:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `core.async` 库中的进程和通道来实现这一点。在这种情况下，通道将传递三个进程产生的值，我们将使用 `merge` 操作来组合这些通道，如下所示
    *示例 9.11*：
- en: '[PRE368]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '*Example 9.11: Three asynchronous tasks using channels*'
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.11：使用通道的三个异步任务*'
- en: 'The preceding `start-process` function will create a process that periodically
    produces values using the `go` form, and returns a channel from which the values
    can be read. The `render-div` function will generate HTML for the values produced
    by the three tasks. Only the ten most recent values will be shown. This code will
    produce the following output:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `start-process` 函数将创建一个进程，该进程会定期使用 `go` 形式产生值，并返回一个可以从中读取值的通道。`render-div`
    函数将为三个任务产生的值生成 HTML。只会显示最近的十个值。此代码将产生以下输出：
- en: '![Building reactive user interfaces](img/B05024_09_03.jpg)'
  id: totrans-1597
  prefs: []
  type: TYPE_IMG
  zh: '![构建响应式用户界面](img/B05024_09_03.jpg)'
- en: 'We could also implement the preceding example using FRP, in which values produced
    by each of the three tasks are represented as event streams. The `merge-all` function
    from the `yolk.bacon` namespace can be used to combine these event streams, and
    the `sliding-window` function can obtain the ten most recent values produced by
    the resulting stream. The `render-div` function from *Example 9.11* can be reused
    to render the values. This is implemented in *Example 9.12*, and produces the
    same output as *Example 9.11*:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 FRP（函数式响应式编程）来实现前面的示例，其中每个任务产生的值都表示为事件流。`yolk.bacon` 命名空间中的 `merge-all`
    函数可以用来组合这些事件流，而 `sliding-window` 函数可以获取结果流产生的十个最新值。*示例 9.11* 中的 `render-div` 函数可以重用来渲染值。这已在
    *示例 9.12* 中实现，并产生与 *示例 9.11* 相同的输出：
- en: '[PRE369]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '*Example 9.12: Three asynchronous tasks using FRP*'
  id: totrans-1600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.12：使用 FRP 的三个异步任务*'
- en: 'Next, let''s try to capture mouse events from a particular `div` tag, and display
    the page offset values of the locations of these events. We can do this with channels,
    but we would first need a function to convey DOM events onto a channel. We can
    implement this using the `goog.events/listen` and `cljs.core.async/put!` functions,
    as shown in *Example 9.13*:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试捕获特定 `div` 标签的鼠标事件，并显示这些事件位置的页面偏移值。我们可以使用通道来完成此操作，但首先需要一个将 DOM 事件传递到通道的函数。我们可以使用
    `goog.events/listen` 和 `cljs.core.async/put!` 函数来实现这一点，如下所示 *示例 9.13*：
- en: '[PRE370]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '*Example 9.13: A function to convey events onto a channel*'
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.13：一个将事件传递到通道的函数*'
- en: 'We can now use the `listen` function defined previously to listen to the `goog.events.EventType.MOUSEMOVE`
    event type from a particular `div` tag. The values will have to be converted to
    page offsets, and this can be done using the `getPageOffsetLeft` and `getPageOffsetTop`
    functions from the `goog.style` namespace. This implementation is described in
    *Example 9.14*:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用之前定义的 `listen` 函数来监听来自特定 `div` 标签的 `goog.events.EventType.MOUSEMOVE`
    事件类型。值必须转换为页面偏移，这可以使用 `goog.style` 命名空间中的 `getPageOffsetLeft` 和 `getPageOffsetTop`
    函数来完成。此实现已在 *示例 9.14* 中描述：
- en: '[PRE371]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '*Example 9.14: Mouse events using channels*'
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.14：使用通道的鼠标事件*'
- en: 'We can also implement a solution to this problem using the `from-event-stream`
    and `map` functions from the Yolk library. Interestingly, the events produced
    by the stream returned by the `from-event-target` function will have page offsets
    of the event stored as the `pageX` and `pageY` properties. This allows us to have
    a much simpler implementation, as shown in *Example 9.15*:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Yolk 库中的 `from-event-stream` 和 `map` 函数来实现这个问题的解决方案。有趣的是，由 `from-event-target`
    函数返回的流产生的事件将具有事件存储为 `pageX` 和 `pageY` 属性的页面偏移量。这使得我们可以实现一个更简单的实现，如 *示例 9.15* 所示：
- en: '[PRE372]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '*Example 9.15: Mouse events using FRP*'
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.15：使用 FRP 的鼠标事件*'
- en: 'Both of the implementations shown in *Example 9.14* and *Example 9.15* work
    as expected, and produce the following output:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 9.14* 和 *示例 9.15* 中展示的两个实现都按预期工作，并产生以下输出：
- en: '![Building reactive user interfaces](img/B05024_09_04.jpg)'
  id: totrans-1611
  prefs: []
  type: TYPE_IMG
  zh: '![构建响应式用户界面](img/B05024_09_04.jpg)'
- en: 'As a final example, we will simulate several search queries being performed
    and display the results from the first three queries that return results. The
    queries can be described as: two queries for web results, two queries for image
    results, and two queries for video results. We can implement these simulated queries
    as shown in *Example 9.16*:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，我们将模拟执行几个搜索查询并显示前三个返回结果的查询结果。查询可以描述为：两个针对网页结果的查询，两个针对图片结果的查询，以及两个针对视频结果的查询。我们可以将这些模拟查询实现如
    *示例 9.16* 所示：
- en: '[PRE373]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '*Example 9.16: Simulating search queries with channels*'
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.16：使用通道模拟搜索查询*'
- en: 'The `chan-search` function returns a function that uses the `cljs.core.async/timeout`
    function to simulate a search query by parking the current task for a random number
    of milliseconds. Using the `chan-search` function, we create several queries for
    the different kinds of results we are interested in. Using these functions, we
    can implement a function to perform all the queries and return the first three
    results, as shown in *Example 9.17*:'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '`chan-search` 函数返回一个函数，该函数使用 `cljs.core.async/timeout` 函数通过暂停当前任务一定数量的毫秒来模拟搜索查询。使用
    `chan-search` 函数，我们可以为不同类型的感兴趣结果创建多个查询。使用这些函数，我们可以实现一个执行所有查询并返回前三个结果的函数，如 *示例
    9.17* 所示：'
- en: '[PRE374]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '*Example 9.17: Simulating search queries with channels (continued)*'
  id: totrans-1617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.17：使用通道模拟搜索查询（继续）*'
- en: 'As shown in the preceding example, the `merge` function can be used to combine
    channels that produce the results of the search queries. Note that the queries
    to all three types of results, namely web, images, and videos, are timed out after
    `80` milliseconds. We can bind the `chan-search-fastest` function to the click
    of a mouse button using the `listen` function we defined earlier, as shown in
    *Example 9.18*:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，可以使用 `merge` 函数将产生搜索查询结果的通道合并。请注意，针对所有三种类型的结果（即网页、图片和视频）的查询在 `80` 毫秒后超时。我们可以使用之前定义的
    `listen` 函数将 `chan-search-fastest` 函数绑定到鼠标按钮的点击上，如 *示例 9.18* 所示：
- en: '[PRE375]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '*Example 9.18: Simulating search queries with channels (continued)*'
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.18：使用通道模拟搜索查询（继续）*'
- en: Clicking on the button bound to the `chan-search-fastest` function will show
    the following output. Note that the `nil` value in the following output indicates
    a timeout of all queries for a particular search result type.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 点击绑定到 `chan-search-fastest` 函数的按钮将显示以下输出。注意，以下输出中的 `nil` 值表示特定搜索结果类型的所有查询都超时了。
- en: '![Building reactive user interfaces](img/B05024_09_05.jpg)'
  id: totrans-1622
  prefs: []
  type: TYPE_IMG
  zh: '![构建响应式用户界面](img/B05024_09_05.jpg)'
- en: 'We can just as easily implement an FRP version of the simulation of search
    queries that was previously described. The queries for the various sources of
    data are defined as shown in the following *Example 9.19*:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样容易地实现之前描述的搜索查询模拟的 FRP 版本。针对各种数据源的查询定义如以下 *示例 9.19* 所示：
- en: '[PRE376]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '*Example 9.19: Simulating search queries with FRP*'
  id: totrans-1625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.19：使用 FRP 模拟搜索查询*'
- en: 'The preceding functions all return event streams for search results. The search
    results produced can be combined with timeouts using the `later`, `merge`, and
    `combine-as-array` functions from the `yolk.bacon` namespace, as shown in *Example
    9.20*:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数都返回搜索结果的事件流。产生的搜索结果可以使用 `yolk.bacon` 命名空间中的 `later`、`merge` 和 `combine-as-array`
    函数与超时结合，如 *示例 9.20* 所示：
- en: '[PRE377]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '*Example 9.20: Simulating search queries with FRP (continued)*'
  id: totrans-1628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.20：使用 FRP 模拟搜索查询（继续）*'
- en: 'The `frp-search-fastest` function can be invoked on clicking a button, as shown
    in *Example 9.21*:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在点击按钮时调用 `frp-search-fastest` 函数，如 *示例 9.21* 所示：
- en: '[PRE378]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '*Example 9.21: Simulating search queries with FRP (continued)*'
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.21：使用 FRP 模拟搜索查询（继续）*'
- en: 'The preceding example produces the following output when the search button
    is clicked:'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击搜索按钮时，前面的示例会产生以下输出：
- en: '![Building reactive user interfaces](img/B05024_09_06.jpg)'
  id: totrans-1633
  prefs: []
  type: TYPE_IMG
  zh: '![构建响应式用户界面](img/B05024_09_06.jpg)'
- en: In conclusion, we can use both channels and event streams to implement interactive
    interfaces in web pages. Although the FRP implementations of the preceding examples
    are slightly shorter, we can say that both the `core.async` and Yolk libraries
    have their own elegance.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以在网页中同时使用通道和事件流来实现交互式界面。尽管前面示例的 FRP 实现略短，但我们可以说 `core.async` 和 Yolk 库都有自己的优雅之处。
- en: Note
  id: totrans-1635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding examples are based on code from *Communicating Sequential Processes*
    by David Nolen ([http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/))
    and *CSP vs. FRP* by Draco Dormiens ([http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html)).
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例基于 David Nolen 的 *Communicating Sequential Processes* ([http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/))
    和 Draco Dormiens 的 *CSP vs. FRP* ([http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html))
    中的代码。
- en: Introducing Om
  id: totrans-1637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Om
- en: The *Om* library ([https://github.com/omcljs/om](https://github.com/omcljs/om))
    is a great tool for building dynamic user interfaces in ClojureScript. In fact,
    it's an interface to *React.js* ([http://facebook.github.io/react/](http://facebook.github.io/react/)),
    which is a JavaScript library for creating interactive user interface components.
    Om lets us define a user interface as a hierarchy of components, and each component
    reactively modifies its appearance based on changes to the component's state.
    In this way, Om components *react* to changes in their state.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: '*Om* 库 ([https://github.com/omcljs/om](https://github.com/omcljs/om)) 是在 ClojureScript
    中构建动态用户界面的优秀工具。实际上，它是对 *React.js* ([http://facebook.github.io/react/](http://facebook.github.io/react/))
    的接口，这是一个用于创建交互式用户界面组件的 JavaScript 库。Om 允许我们将用户界面定义为组件的层次结构，并且每个组件根据组件状态的变化反应性地修改其外观。通过这种方式，Om
    组件 *对状态的变化做出反应*。'
- en: Note
  id: totrans-1639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例需要以下库依赖项：
- en: '[PRE379]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须包含在你的命名空间声明中：
- en: '[PRE380]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'In addition to the preceding dependencies, the following examples also use
    the `by-id` function from `src/m_clj/c9/common.cljs`. Ensure that the code in
    the following ClojureScript examples is compiled, using the following command:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的依赖关系之外，以下示例还使用了来自 `src/m_clj/c9/common.cljs` 的 `by-id` 函数。请确保以下 ClojureScript
    示例代码已编译，使用以下命令：
- en: '[PRE381]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: The Om components are generally defined by implementing the `IRender` and `IRenderState`
    protocols from the `om.core` namespace. The `IRender` protocol declares a single
    function `render`, and similarly the `IRenderState` protocol declares the `render-state`
    function. The `render` and `render-state` functions define how a component that
    implements either of these protocols is converted to DOM, which can be rendered
    by a web browser. The implementations of these functions must return a DOM object
    constructed using functions from the `om.dom` namespace. There are also several
    other protocols in the `om.core` namespace that allow us to define a component's
    behavior. Internally, Om uses React.js to perform batched updates to the DOM for
    the sake of performance, and uses *virtual DOM* to maintain the state of the DOM
    to be rendered.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: Om 组件通常通过实现 `om.core` 命名空间中的 `IRender` 和 `IRenderState` 协议来定义。`IRender` 协议声明了一个名为
    `render` 的单个函数，同样地，`IRenderState` 协议声明了 `render-state` 函数。`render` 和 `render-state`
    函数定义了实现这些协议之一的组件如何转换为 DOM，这可以通过网络浏览器进行渲染。这些函数的实现必须返回使用 `om.dom` 命名空间中的函数构建的 DOM
    对象。`om.core` 命名空间中还有其他几个协议，允许我们定义组件的行为。内部，Om 使用 React.js 进行批处理更新 DOM 以提高性能，并使用
    *虚拟 DOM* 来维护要渲染的 DOM 的状态。
- en: Note
  id: totrans-1647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following examples can be found in `src/m_clj/c9/om/core.cljs` of the book''s
    source code. Also, the HTML page for the following ClojureScript examples can
    be found in `resources/html/om.html`. The following scripts will be included in
    this page:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c9/om/core.cljs` 中找到。此外，以下 ClojureScript 示例的 HTML 页面可以在
    `resources/html/om.html` 中找到。以下脚本将包含在这个页面中：
- en: '[PRE382]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Let''s now build a simple component using Om. Suppose we want to build a web
    application. One of the first steps in doing so is creating a login page for our
    application. As an example, let''s create a simple login form with Om. A user
    will enter their username and password in this form. The only requirement is that
    the submit button of this form must be enabled only if the user has entered a
    username and password. Let''s start off by defining some functions to create an
    input field of a form, as shown in *Example 9.22*:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 Om 构建一个简单的组件。假设我们想要构建一个网络应用程序。这样做的一个第一步是为我们的应用程序创建一个登录页面。作为一个例子，让我们使用
    Om 创建一个简单的登录表单。用户将在这个表单中输入他们的用户名和密码。唯一的要求是这个表单的提交按钮只有在用户输入了用户名和密码时才启用。让我们首先定义一些函数来创建表单的输入字段，如
    *示例 9.22* 所示：
- en: '[PRE383]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '*Example 9.22: A login form using Om*'
  id: totrans-1652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.22：使用 Om 的登录表单*'
- en: The `update-input-value-fn` function defined in *Example 9.22* accepts a component
    `owner` as an argument and returns a function that we can bind to a DOM event.
    The returned function updates the state of the component with the value of the
    `.-value` property using the `set-state!` function from the `om.core` namespace.
    The `input-field` function returns a DOM object for an input field with some associated
    properties. The `input-field` function also creates an event handler using the
    `update-input-value-fn` function and binds it to the `onChange` event of the input
    field.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 9.22* 中定义的 `update-input-value-fn` 函数接受一个组件 `owner` 作为参数，并返回一个我们可以绑定到
    DOM 事件的函数。返回的函数使用 `om.core` 命名空间中的 `set-state!` 函数更新组件的状态，该状态使用 `.-value` 属性的值。`input-field`
    函数返回一个具有一些相关属性的输入字段的 DOM 对象。`input-field` 函数还使用 `update-input-value-fn` 函数创建一个事件处理器，并将其绑定到输入字段的
    `onChange` 事件。
- en: Note
  id: totrans-1654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that a component can change its state or the global application state by
    using the `set-state!`, `update-state!`, `update!`, or `transact!` functions from
    the `om.core` namespace.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组件可以通过使用 `om.core` 命名空间中的 `set-state!`、`update-state!`、`update!` 或 `transact!`
    函数来改变其状态或全局应用程序状态。
- en: 'Next, let''s define a form as a component using the `om.core/IRenderState`
    protocol and `input-field` function, as shown in *Example 9.23*:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `om.core/IRenderState` 协议和 `input-field` 函数将表单定义为组件，如 *示例 9.23* 所示：
- en: '[PRE384]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '*Example 9.23: A login form using Om (continued)*'
  id: totrans-1658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 9.23：使用 Om 的登录表单（续）*'
- en: 'The preceding `form` function creates a component by implementing the `render-state`
    function of the `IRenderState` protocol. This component also implements the `IInitState`
    protocol to define the initial state of the component. The `form` function will
    render a login form with two input fields, for a username and password, and a
    login button. The button is enabled only when the username and password are entered.
    Also, the component is mounted onto a `div` using the `om.core/root` function.
    The following output in a web page describes the behavior of the component defined
    by the `form` function:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `form` 函数通过实现 `IRenderState` 协议的 `render-state` 函数来创建一个组件。此组件还实现了 `IInitState`
    协议以定义组件的初始状态。`form` 函数将渲染一个包含两个输入字段（用于用户名和密码）以及一个登录按钮的登录表单。按钮仅在用户名和密码输入后才会启用。此外，该组件使用
    `om.core/root` 函数挂载到一个 `div` 元素上。以下网页中的输出描述了由 `form` 函数定义的组件的行为：
- en: '![Introducing Om](img/B05024_09_07.jpg)'
  id: totrans-1660
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Om](img/B05024_09_07.jpg)'
- en: The preceding output describes two states of the login form component defined
    by the `form` function. The login button is observed to be disabled when either
    the username or password fields are empty, and is enabled only when the user enters
    values in both of these input fields. In this way, the login form *reacts* to
    changes in the state of its input fields.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出描述了由 `form` 函数定义的登录表单组件的两个状态。观察到当用户名或密码字段为空时，登录按钮处于禁用状态，并且只有在用户在这两个输入字段中输入值时才会启用。通过这种方式，登录表单
    *响应* 输入字段状态的变化。
- en: Note
  id: totrans-1662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [https://github.com/omcljs/om/wiki/Documentation](https://github.com/omcljs/om/wiki/Documentation)
    for complete documentation on all the protocols, functions, and macros in the
    Om library.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/omcljs/om/wiki/Documentation](https://github.com/omcljs/om/wiki/Documentation)
    获取 Om 库中所有协议、函数和宏的完整文档。
- en: Thus, the Om library provides us with several constructs for creating interactive
    and stateful components.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Om 库为我们提供了创建交互式和有状态组件的几个构造。
- en: Summary
  id: totrans-1665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: So far, we have discussed reactive programming through the Pulsar, RxClojure,
    and Yolk libraries. We have also described several ClojureScript examples that
    compare channels from the `core.async` library to reactive event streams from
    the Yolk library. We also demonstrated how we can leverage the Om library to build
    dynamic user interfaces.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过 Pulsar、RxClojure 和 Yolk 库讨论了响应式编程。我们还描述了几个 ClojureScript 示例，比较了 `core.async`
    库中的通道与 Yolk 库中的响应式事件流。我们还演示了如何利用 Om 库构建动态用户界面。
- en: In the following chapter, we will explore how we can test our Clojure programs.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试我们的 Clojure 程序。
- en: Chapter 10. Testing Your Code
  id: totrans-1668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：测试您的代码
- en: Testing is an integral part of developing software. Alongside implementing functionality
    in our software, it is imperative to simultaneously define tests to verify several
    aspects of it. The Clojure standard library provides several constructs to define
    tests and mock data. There are also several community libraries that allow us
    to verify different aspects of the code being tested.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个组成部分。在实现软件功能的同时，我们必须同时定义测试来验证其多个方面。Clojure 标准库提供了几个构造来定义测试和模拟数据。还有几个社区库允许我们验证正在测试的代码的不同方面。
- en: The main advantage of using tests is that they allow us to identify the overall
    impact of a particular change in a program's code. If we have tests to check the
    functionality of a program, we can refactor the program with confidence and without
    the fear of losing any functionality. If there's something that we unavoidably
    missed while refactoring a program, it will surely be brought to our attention
    when we run the program's tests. Thus, tests are indispensable tools for keeping
    code maintainable.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试的主要优势在于，它们使我们能够识别程序代码中特定更改的整体影响。如果我们有测试来检查程序的功能，我们就可以有信心地对程序进行重构，而无需担心丢失任何功能。如果在重构程序时不可避免地遗漏了某些内容，那么在运行程序测试时，这些内容肯定会引起我们的注意。因此，测试是保持代码可维护性的不可或缺的工具。
- en: In this chapter, we will study the different ways in which we can write tests
    in Clojure. We will also discuss how we can perform type checking in Clojure.
    Although we describe several libraries for writing tests in this chapter, we must
    note that there are several more available in the Clojure ecosystem. That aside,
    the libraries described in this chapter are the most mature and battle-hardened
    tools for testing our code.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究在 Clojure 中编写测试的不同方法。我们还将讨论如何在 Clojure 中执行类型检查。尽管在本章中我们描述了几个用于编写测试的库，但我们必须注意，Clojure
    生态系统中有更多可用的库。除此之外，本章中描述的库是测试我们代码最成熟和经验丰富的工具。
- en: Writing tests
  id: totrans-1672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: Being a thoughtfully designed language, Clojure has a built-in unit testing
    library, namely `clojure.test`. Apart from that, there are a couple constructs
    in the core language that are helpful with regard to testing. Of course, these
    constructs don't allow us to define and run any tests in the formal sense, and
    the constructs from the `clojure.test` namespace must be preferred for that purpose.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种精心设计的语言，Clojure 内置了单元测试库，即 `clojure.test`。除此之外，核心语言中还有一些有助于测试的构造。当然，这些构造并不能让我们在正式意义上定义和运行任何测试，对于这个目的，我们应优先使用
    `clojure.test` 命名空间中的构造。
- en: Let's start off by briefly discussing the constructs from the core language
    that can be used for unit testing. The `assert` function checks whether an expression
    evaluates to a truthy value at runtime. This function will throw an exception
    if the expression passed to it does not evaluate to a truthy value, and the message
    of this exception can be optionally specified as a second argument to the `assert`
    form. We can effectively disable all the `assert` forms in a given program by
    using the global `*assert*` compile time `var`. This variable can only be changed
    by a top-level `set!` form in a given program or namespace.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简要讨论一下核心语言中可用于单元测试的构造。`assert` 函数检查表达式在运行时是否评估为真值。如果传递给该函数的表达式没有评估为真值，则该函数将抛出异常，并且可以可选地指定异常的消息作为
    `assert` 表达式的第二个参数。我们可以通过使用全局的 `*assert*` 编译时 `var` 来有效地禁用给定程序中的所有 `assert` 表达式。这个变量只能通过给定程序或命名空间中的顶层
    `set!` 表达式来更改。
- en: Another interesting aspect of testing that is easily tackled by the core language
    is *mocking* and *stubbing*. In a nutshell, these techniques allow us to redefine
    the behavior of certain functions within the context of a test case. This is useful
    in preventing functions from performing unwanted side effects or using unavailable
    resources. In the Clojure language, this can be done using the `with-redefs` function.
    This form can be used within tests as well as plain functions, but its usage outside
    of the scope of tests is not really encouraged. Its semantics are similar to that
    of the standard `let` form, and you are encouraged to go through the Clojure docs
    for examples on the `with-redefs` form.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的另一个有趣方面，可以通过核心语言轻松解决，是*模拟*和*存根*。简而言之，这些技术允许我们在测试用例的上下文中重新定义某些函数的行为。这在防止函数执行不想要的副作用或使用不可用的资源时非常有用。在Clojure语言中，这可以使用`with-redefs`函数来完成。这个形式可以在测试以及普通函数中使用，但鼓励不要在测试范围之外使用它。它的语义与标准`let`形式相似，鼓励您查阅Clojure文档以获取`with-redefs`形式的示例。
- en: Now, let's explore how we can actually define tests using constructs from the
    `clojure.test` namespace.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用`clojure.test`命名空间中的构造来实际定义测试。
- en: Defining unit tests
  id: totrans-1677
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义单元测试
- en: Clojure has support for defining unit tests baked into it. The `clojure.test`
    namespace, which requires no additional dependencies whatsoever, provides several
    constructs for testing our code. Let's explore a few of them.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure内置了对定义单元测试的支持。`clojure.test`命名空间不需要任何额外的依赖，提供了几个用于测试我们代码的构造。让我们探索其中的一些。
- en: Note
  id: totrans-1679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following namespaces must be included in your namespace declaration for
    the upcoming examples:'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，你必须将以下命名空间包含在你的命名空间声明中：
- en: '[PRE385]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: The following examples can be found in `test/m_clj/c10/test.clj` of the book's
    source code.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`test/m_clj/c10/test.clj`中找到。
- en: 'Tests can be defined using the `deftest` macro. This form must be passed a
    symbol, indicating the name of the defined test, and any number of expressions.
    Generally, `is` and `are` forms are used within the `deftest` macro. The `is`
    form must be passed an expression, and will fail the test if the supplied expression
    does not return a truthy value. The `are` form must be passed a vector of variable
    names, a condition to test, and values for the defined variables. For example,
    the standard `*` function can be tested as shown in *Example 10.1*:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以使用`deftest`宏来定义。这个形式必须传递一个符号，表示定义的测试的名称，以及任意数量的表达式。通常，在`deftest`宏中使用`is`和`are`形式。`is`形式必须传递一个表达式，如果提供的表达式不返回一个真值，则测试将失败。`are`形式必须传递一个变量名向量、一个要测试的条件以及为定义的变量提供的值。例如，标准的`*`函数可以像*示例10.1*中所示的那样进行测试：
- en: '[PRE386]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '*Example 10.1: Defining tests using the clojure.test namespace*'
  id: totrans-1685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例10.1：使用clojure.test命名空间定义测试*'
- en: 'The preceding code defines two tests using the `is` and `are` forms. We can
    run tests using the `run-tests` and `run-all-tests` functions from the `clojure.test`
    namespace. The `run-tests` function can be passed any number of namespaces, and
    will run all the tests defined in them. Also, this form can be called without
    passing any arguments, in which case it will run all the tests in the current
    namespace. The `run-all-tests` function will run all the tests in all namespaces
    of the current project. It can optionally be passed a regular expression, and
    will only run the tests from matching namespaces if this argument is supplied.
    In fact, an IDE with integrated support for running tests will call these functions.
    For example, we can run the tests we defined in *Example 10.1* using the `run-tests`
    function shown here:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`is`和`are`形式定义了两个测试。我们可以使用`clojure.test`命名空间中的`run-tests`和`run-all-tests`函数来运行测试。`run-tests`函数可以传递任意数量的命名空间，并将运行其中定义的所有测试。此外，这个形式可以不传递任何参数来调用，在这种情况下，它将运行当前命名空间中的所有测试。`run-all-tests`函数将运行当前项目中所有命名空间中的所有测试。它可以可选地传递一个正则表达式，如果提供了这个参数，它将只运行匹配命名空间中的测试。实际上，具有集成测试运行支持的IDE会调用这些函数。例如，我们可以使用这里显示的`run-tests`函数来运行我们在*示例10.1*中定义的测试：
- en: '[PRE387]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'As shown in the preceding output, the `run-tests` function executes both the
    tests, and both of them pass. Let''s now define a test that will fail, although
    we shouldn''t really be doing this unless we have a good reason:'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，`run-tests`函数执行了这两个测试，并且它们都通过了。现在，让我们定义一个会失败的测试，尽管我们实际上不应该这样做，除非我们有充分的理由：
- en: '[PRE388]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '*Example 10.2: A test that fails*'
  id: totrans-1690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例10.2：一个失败的测试*'
- en: 'The test `test-*-fails` shown in *Example 10.2* will fail when it is run, as
    shown here:'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 10.2* 中显示的 `test-*-fails` 测试在运行时会失败，如下所示：
- en: '[PRE389]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: In fact, defining tests that fail should be considered a part and parcel of
    developing a program. To start a feature or fix a bug in a program, we must first
    define a test that validates this change (by failing!). We should then proceed
    to implement the feature or fix, such that all the newly defined tests pass. These
    two steps are then repeated, until all the requirements of our feature or fix
    are met. This is the essence of **test-driven development** (**TDD**).
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，定义失败的测试应该被视为程序开发的一个组成部分。为了启动一个功能或修复程序中的错误，我们首先必须定义一个验证此更改的测试（通过失败！）然后继续实现功能或修复，以确保所有新定义的测试都通过。这两个步骤然后重复进行，直到满足我们功能或修复的所有要求。这就是**测试驱动开发**（**TDD**）的精髓。
- en: Note
  id: totrans-1694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can also run the tests defined in a given namespace using the following
    command:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下命令来运行给定命名空间中定义的测试：
- en: '[PRE390]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: The `clojure.test` namespace must be used for testing programs written strictly
    in Clojure. For testing ClojureScript programs in the same way, we can use the
    *doo* library ([https://github.com/bensu/doo](https://github.com/bensu/doo)),
    which provides ClojureScript implementations of the `deftest`, `is`, and `are`
    constucts.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 对于严格使用 Clojure 编写的程序，必须使用 `clojure.test` 命名空间进行测试。为了以相同的方式测试 ClojureScript 程序，我们可以使用
    *doo* 库（[https://github.com/bensu/doo](https://github.com/bensu/doo)），它提供了 `deftest`、`is`
    和 `are` 构造的 ClojureScript 实现。
- en: Using top-down testing
  id: totrans-1698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自顶向下测试
- en: A more powerful way to define tests in Clojure is by using the *Midje* library
    ([https://github.com/marick/Midje](https://github.com/marick/Midje)). This library
    provides several constructs that allow us to easily define unit tests by describing
    relationships between several functions, rather than describing the implementation
    of the functions themselves. This approach is also called *top-down testing*,
    and Midje champions this kind of testing methodology. Let's dive into the details
    of the Midje library.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中定义测试的一个更强大的方法是使用 *Midje* 库（[https://github.com/marick/Midje](https://github.com/marick/Midje)）。这个库提供了几个构造，允许我们通过描述几个函数之间的关系来轻松定义单元测试，而不是描述函数的实现本身。这种方法也称为
    *自顶向下测试*，Midje 推崇这种测试方法。让我们深入了解 Midje 库的细节。
- en: Note
  id: totrans-1700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖对于即将到来的示例是必需的：
- en: '[PRE391]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'We must also include the following dependencies in the `:plugins` section of
    your `project.clj` file:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `project.clj` 文件的 `:plugins` 部分包含以下依赖项：
- en: '[PRE392]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE393]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: The following examples can be found in `test/m_clj/c10/midje.clj` of the book's
    source code.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书的源代码的 `test/m_clj/c10/midje.clj` 中找到。
- en: 'Firstly, let''s define a simple function that we intend to test, as shown in
    *Example 10.3*:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个我们打算测试的简单函数，如 *示例 10.3* 所示：
- en: '[PRE394]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '*Example 10.3: A simple function to test*'
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.3：一个简单的测试函数*'
- en: We can define tests for the `first-element` function using the `facts` and `fact`
    constructs from the `midje.sweet` namespace, as shown in *Example 10.4*.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `midje.sweet` 命名空间中的 `facts` 和 `fact` 构造来定义 `first-element` 函数的测试，如 *示例
    10.4* 所示。
- en: '[PRE395]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '*Example 10.4: Tests for the first-element function*'
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.4：第一个元素函数的测试*'
- en: As shown in the preceding code, the `fact` form describes a test, and can be
    passed any number of clauses. Each clause is comprised of an expression, a `=>`
    symbol, and the expected return value of the supplied expression. The `facts`
    form is simply used to group together several `fact` forms. It's quite apparent
    that instead of checking logical conditions, we use `fact` forms to check expressions
    and the values returned by them.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`fact` 形式描述了一个测试，可以传递任意数量的子句。每个子句由一个表达式、一个 `=>` 符号和所提供表达式的预期返回值组成。`facts`
    形式简单用于将多个 `fact` 形式组合在一起。很明显，我们不是检查逻辑条件，而是使用 `fact` 形式来检查表达式及其返回的值。
- en: 'The `provided` form can be used to mock function calls. The Midje library allows
    us to use *metaconstants* in our tests, and they are often used with the `provided`
    form. Metaconstants can be thought of as generic placeholders for values and functions.
    All metaconstants should start and end with two or more dots (`.`) or hyphens
    (`-`); hyphens are more suitable for metaconstants representing functions. For
    example, we can test the `first-element` function we defined earlier using metaconstants
    and the `provided` form as shown in *Example 10.5*:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `provided` 形式来模拟函数调用。Midje 库允许我们在测试中使用 *元常量*，它们通常与 `provided` 形式一起使用。元常量可以被视为值和函数的通用占位符。所有元常量都应该以两个或更多点（`.`）或连字符（`-`）开始和结束；连字符更适合表示函数的元常量。例如，我们可以使用元常量和
    `provided` 形式测试我们之前定义的 `first-element` 函数，如 *示例 10.5* 所示：
- en: '[PRE396]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '*Example 10.5: Using the provided form and metaconstants*'
  id: totrans-1717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.5：使用提供的形式和元常量*'
- en: In the test shown previously, the metaconstant `..seq..` is used to indicate
    the first argument passed to the `first-element` function, and the `provided`
    form mocks the call to the `empty?` function. This way, we can implement tests
    without completely implementing the functions being tested. Of course, we should
    avoid mocking or redefining standard functions in the `provided` form. For example,
    suppose we have three partially implemented functions, as shown in *Example 10.6*.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，元常量 `..seq..` 用于指示传递给 `first-element` 函数的第一个参数，而 `provided` 形式模拟了对 `empty?`
    函数的调用。这样，我们可以在不完整实现被测试函数的情况下实现测试。当然，我们应该避免在 `provided` 形式中模拟或重新定义标准函数。例如，假设我们有三个部分实现的功能，如
    *示例 10.6* 所示。
- en: '[PRE397]'
  id: totrans-1719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '*Example 10.6: Partially implemented functions to test*'
  id: totrans-1720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.6：部分实现的功能以进行测试*'
- en: Notice that only the `overall-cost-of-car` function is completely implemented
    in the preceding code. Nevertheless, we can still test the relation between these
    three functions using the Midje library, as shown in *Example 10.7*.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面代码中，只有 `overall-cost-of-car` 函数是完全实现的。尽管如此，我们仍然可以使用 Midje 库测试这三个函数之间的关系，如
    *示例 10.7* 所示。
- en: '[PRE398]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '*Example 10.7: Testing the is-diesel?, cost-of-car and overall-cost-of-car
    functions*'
  id: totrans-1723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.7：测试 is-diesel?、cost-of-car 和 overall-cost-of-car 函数*'
- en: 'In the test shown previously, the `cost-of-car` and `is-diesel?` functions
    are mocked using the `provided` form and the `..car..` metaconstant, and the value
    returned by the `overall-cost-of-car` function is checked. We can run all of the
    tests we have defined so far using the `autotest` function from the `midje.repl`
    namespace, as shown here:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，使用 `provided` 形式和 `..car..` 元常量模拟了 `cost-of-car` 和 `is-diesel?` 函数，并检查了
    `overall-cost-of-car` 函数返回的值。我们可以使用 `midje.repl` 命名空间中的 `autotest` 函数运行我们迄今为止定义的所有测试，如下所示：
- en: '[PRE399]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Note
  id: totrans-1726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can also run the tests defined in a given namespace using the following
    command. Note that the following command will watch your project for file changes,
    and will run the tests in any files once they are changed:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令运行给定命名空间中定义的测试。请注意，以下命令将监视您的项目文件更改，并在文件更改后运行任何文件的测试：
- en: '[PRE400]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: In this way, we can use the Midje library to write tests, even for functions
    that haven't been completely implemented. Midje allows us to describe tests as
    relations between functions using metaconstants. In summary, the `clojure.test`
    and Midje libraries are great tools for defining unit tests.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以使用 Midje 库来编写测试，即使是尚未完全实现的功能也可以。Midje 允许我们使用元常量来描述测试，这些测试是函数之间的关系。总之，`clojure.test`
    和 Midje 库是定义单元测试的出色工具。
- en: Testing with specs
  id: totrans-1730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 specs 进行测试
- en: We will now take a look at the Speclj, pronounced *speckle*, library ([https://github.com/slagyr/speclj](https://github.com/slagyr/speclj)),
    which is used to write *specs*. Specs are similar to unit tests, but are focused
    on the behavior of functions being tested, rather than their internal implementation.
    In fact, **behavior-driven development** (**BDD**) is centered about writing specs.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看 Speclj 库，发音为 *speckle* ([https://github.com/slagyr/speclj](https://github.com/slagyr/speclj))，它用于编写
    *specs*。Specs 与单元测试类似，但专注于被测试函数的行为，而不是其内部实现。实际上，**行为驱动开发**（**BDD**）的核心是编写 specs。
- en: The main difference between TDD and BDD is that BDD focuses on the behavior
    or specifications of functions, rather than their implementation. From this perspective,
    if we change the internal implementation of a function that has been previously
    tested, there is a smaller chance that we have to modify the tests, or rather
    specs, associated with the function. BDD can also be thought of as a refined approach
    to TDD, in which the interface and behavior of a function is more important than
    its internal implementation. Now, let's study the various constructs of the Speclj
    library.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 和 BDD 之间的主要区别在于 BDD 专注于函数的行为或规范，而不是它们的实现。从这个角度来看，如果我们更改已经测试过的函数的内部实现，我们修改与该函数关联的测试或规范的可能性较小。BDD
    也可以被视为对 TDD 的改进方法，其中函数的接口和行为比其内部实现更重要。现在，让我们研究 Speclj 库的各种构造。
- en: Note
  id: totrans-1733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples.
    We must also include the following dependencies in the `:plugins` section of your
    `project.clj` file:'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖项对于即将到来的示例是必需的。我们还必须在 `project.clj` 文件的 `:plugins` 部分包含以下依赖项：
- en: '[PRE401]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE402]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: The `describe`, `it`, and `should` forms, from the `speclj.core` namespace,
    are used to define specs for a given function. The `it` form represents a single
    specification for the function being tested, and the `describe` form is used to
    group together several specs together. Assertions within an `it` form can be expressed
    using the `should` form and its variants. For example, we can write a spec for
    the behavior of the standard `*` function, as shown in the following *Example
    10.8*.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `speclj.core` 命名空间的 `describe`、`it` 和 `should` 形式用于定义给定函数的规范。`it` 形式代表对正在测试的函数的单个规范，而
    `describe` 形式用于将多个规范组合在一起。`it` 形式内的断言可以使用 `should` 形式及其变体来表示。例如，我们可以为标准 `*` 函数的行为编写规范，如下面的
    *示例 10.8* 所示。
- en: Note
  id: totrans-1739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `spec/m_clj/c10/speclj.clj` of the book's
    source code.
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `spec/m_clj/c10/speclj.clj` 中找到。
- en: '[PRE403]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '*Example 10.8: A spec for the * function*'
  id: totrans-1742
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.8: `*` 函数的规范*'
- en: The spec shown previously checks a single condition using the `should` and `=`
    forms. There are several variants of the `should` form, such as `should=`, `should-not`,
    `should-fail`, and `should-throw`. These forms are pretty much self-explanatory,
    and you are encouraged to go through the Speclj docs for more details. We can
    describe some specs for the standard `/` function, as shown in *Example 10.9*.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的规范使用 `should` 和 `=` 形式检查单个条件。`should` 形式有几个变体，如 `should=`, `should-not`,
    `should-fail` 和 `should-throw`。这些形式基本上是自我解释的，我们鼓励您查阅 Speclj 文档以获取更多详细信息。我们可以为标准的
    `/` 函数描述一些规范，如下面的 *示例 10.9* 所示。
- en: '[PRE404]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '*Example 10.9: Specs for the / function using several it forms*'
  id: totrans-1745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.9: 使用多个 `it` 形式对 `/` 函数进行规范*'
- en: Within a `describe` form, we can use the `before` and `after` forms to execute
    arbitrary code before or after each `it` form is checked. Similarly, the `before-all`
    and `after-all` forms can specify what to execute before and after all the specs
    are checked in a `describe` form.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `describe` 形式中，我们可以使用 `before` 和 `after` 形式在检查每个 `it` 形式之前或之后执行任意代码。同样，`before-all`
    和 `after-all` 形式可以指定在 `describe` 形式中检查所有规范之前和之后要执行的操作。
- en: 'Input and output performed by a certain function can be described using specs.
    This is done using the `with-out-str` and `with-in-str` forms. The `with-out-str`
    form returns whatever data is sent to standard output by a given expression. Conversely,
    the `with-in-str` form must be passed a string and an expression, and the supplied
    string will be sent to the standard input once the supplied expression is called.
    For example, let''s say we have a simple function that reads a string and prints
    it. We can write a spec for such a function using the `with-out-str` and `with-in-str`
    forms as shown in *Example 10.10*:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 某个函数执行输入和输出可以使用规范来描述。这是通过使用 `with-out-str` 和 `with-in-str` 形式来完成的。`with-out-str`
    形式返回由给定表达式发送到标准输出的任何数据。相反，`with-in-str` 形式必须传递一个字符串和一个表达式，并且提供的字符串将在提供的表达式被调用后发送到标准输入。例如，假设我们有一个简单的读取字符串并打印它的函数。我们可以使用
    `with-out-str` 和 `with-in-str` 形式编写这样的函数的规范，如下面的 *示例 10.10* 所示：
- en: '[PRE405]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '*Example 10.10: A spec for a function that reads a string and prints it*'
  id: totrans-1749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.10: 对读取字符串并打印它的函数进行规范*'
- en: We can also mock function calls within an `it` form using the standard `with-redefs`
    macro we described earlier. For example, we can write a spec for the `echo` function
    described in *Example 10.10* by mocking the `read-line` and `println` functions
    as shown in *Example 10.11*. Obviously, it's not advisable to mock standard functions,
    and it's only done here to depict the usage of the `with-redefs` macro within
    a spec.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用前面描述的标准 `with-redefs` 宏在 `it` 表达式中模拟函数调用。例如，我们可以通过模拟 *示例 10.11* 中的 `read-line`
    和 `println` 函数来编写 *示例 10.10* 中描述的 `echo` 函数的 spec。显然，模拟标准函数是不推荐的，这里仅为了展示在 spec
    中使用 `with-redefs` 宏的用法。
- en: '[PRE406]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '*Example 10.11: Using the with-redefs macro within a spec*'
  id: totrans-1752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.11：在 spec 中使用 with-redefs 宏*'
- en: 'To run all the specs defined in a given project, we can call the `run-specs`
    macro, as shown here:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行给定项目中定义的所有 spec，我们可以调用 `run-specs` 宏，如下所示：
- en: '[PRE407]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Note
  id: totrans-1755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can also run the specs defined in a given namespace using the following
    command. Note that the following command will watch your project for file changes,
    and will run the specs in any files once they are changed:'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令运行给定命名空间中定义的 spec。请注意，以下命令将监视您的项目文件更改，并在文件更改后运行 spec：
- en: '[PRE408]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: To summarize, the Speclj library provides us with several constructs to define
    specs for BDD. Specs for a given function should be modified only when the required
    functionality or behavior of a function must be changed. With specs, there's less
    of a chance that modifying the underlying implementation of a function will require
    a change in its associated specs. Of course, the question of whether you should
    use specs or tests in your project is a subjective one. Some projects do fine
    with simple tests, and others prefer to use specs.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Speclj 库为我们提供了几个结构来定义 BDD 的 spec。对于给定函数的 spec 应该只在需要更改函数所需的功能或行为时进行修改。有了
    spec，修改函数的底层实现需要更改其相关 spec 的可能性就小得多。当然，是否应该在项目中使用 spec 或测试是一个主观问题。有些项目使用简单的测试就很好，而有些则更喜欢使用
    spec。
- en: Generative testing
  id: totrans-1759
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成测试
- en: Another form of testing is **generative testing**, in which we define properties
    of functions that must hold true for all inputs. This is quite different compared
    to enumerating the expected inputs and outputs of functions, which is essentially
    what unit tests and specs do. In Clojure, generative testing can be done using
    the `test.check` library ([https://github.com/clojure/test.check](https://github.com/clojure/test.check)).
    This library is inspired by Haskell's QuickCheck library, and provides similar
    constructs for testing properties of functions.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试形式是**生成测试**，在这种测试中，我们定义函数的属性，这些属性必须对所有输入都成立。这与列举函数的预期输入和输出有很大不同，而这正是单元测试和
    spec 所做的。在 Clojure 中，可以使用 `test.check` 库进行生成测试 ([https://github.com/clojure/test.check](https://github.com/clojure/test.check))。这个库受到了
    Haskell 的 QuickCheck 库的启发，并为测试函数的属性提供了类似的构造。
- en: Note
  id: totrans-1761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖对于即将到来的示例是必需的：
- en: '[PRE409]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE410]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: The following examples can be found in `src/m_clj/c10/check.clj` of the book's
    source code.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在本书源代码的 `src/m_clj/c10/check.clj` 中找到。
- en: 'To define a property to check, we can use the `for-all` macro from the `clojure.test.check.properties`
    namespace. This macro must be passed a vector of generator bindings, which can
    be created using constructs from the `clojure.test.check.generators` namespace,
    along with a property to verify. For example, consider the properties defined
    in *Example 10.12*:'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个要检查的属性，我们可以使用 `clojure.test.check.properties` 命名空间中的 `for-all` 宏。此宏必须传递一个生成器绑定向量，这些绑定可以使用
    `clojure.test.check.generators` 命名空间中的构造创建，并附带一个要验证的属性。例如，考虑 *示例 10.12* 中定义的属性：
- en: '[PRE411]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '*Example 10.12: Simple properties defined using the test.check library*'
  id: totrans-1769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.12：使用 test.check 库定义的简单属性*'
- en: 'In the preceding code, we have defined two properties, namely `commutative-mult-prop`
    and `first-is-min-after-sort-prop`. The `commutative-mult-prop` property asserts
    that a multiplication operation using the `*` function is commutative, and the
    `first-is-min-after-sort-prop` function checks whether the first element of a
    vector of integers sorted using the `sort` function is the smallest value in the
    vector. Note the use of the `int`, `vector` and `non-empty` functions from the
    `clojure.test.check.generators` namespace. We can verify that these properties
    are true using the `quick-check` function from the `clojure.test.check` namespace,
    as shown here:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个属性，即 `commutative-mult-prop` 和 `first-is-min-after-sort-prop`。`commutative-mult-prop`
    属性断言使用 `*` 函数的乘法操作是交换律的，而 `first-is-min-after-sort-prop` 函数检查使用 `sort` 函数排序的整数向量的第一个元素是否是向量中的最小值。注意使用了来自
    `clojure.test.check.generators` 命名空间的 `int`、`vector` 和 `non-empty` 函数。我们可以使用 `clojure.test.check`
    命名空间中的 `quick-check` 函数来验证这些属性是否成立，如下所示：
- en: '[PRE412]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'As shown previously, the `quick-check` function must be passed the number of
    checks to run and a property to verify. This function returns a map describing
    the checks performed on the supplied properties, in which the value of the `:result`
    key indicates the outcome of the test. It''s fairly evident that both of the properties
    `commutative-mult-prop` and `first-is-min-after-sort-prop` hold true for the specified
    type of inputs. Now, let''s define a property that is not true, as shown in *Example
    10.13*:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`quick-check` 函数必须传递要运行的检查次数和一个要验证的性质。此函数返回一个描述对提供的属性执行的检查的映射，其中 `:result`
    键的值表示测试的结果。很明显，对于指定的输入类型，两个属性 `commutative-mult-prop` 和 `first-is-min-after-sort-prop`
    都是成立的。现在，让我们定义一个不成立的属性，如 *示例 10.13* 所示：
- en: '[PRE413]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '*Example 10.13: A property that won''t be true defined using the test.check
    library*'
  id: totrans-1774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.13：使用 test.check 库定义的一个不会成立的属性*'
- en: 'Running the preceding check will obviously fail, as shown in the following
    output:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的检查将显然失败，如下面的输出所示：
- en: '[PRE414]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'We can also define specs based on generative testing using the `defspec` macro
    from the `clojure.test.check.clojure-test` namespace. This form must be passed
    the number of checks to perform and a property, which is analogous to the `quick-check`
    function. Specs defined using the `defspec` form will be checked by the standard
    `clojure.test` runner. For example, we can define the `commutative-mult-prop`
    property as a spec as shown in *Example 10.14*:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `clojure.test.check.clojure-test` 命名空间中的 `defspec` 宏根据生成性测试来定义规范。这个形式必须传递要执行的检查次数和一个性质，这与
    `quick-check` 函数类似。使用 `defspec` 形式定义的规范将由标准的 `clojure.test` 运行器进行检查。例如，我们可以将 `commutative-mult-prop`
    属性定义为规范，如 *示例 10.14* 所示：
- en: '[PRE415]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '*Example 10.14: A spec defined using the defspec macro*'
  id: totrans-1779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.14：使用 defspec 宏定义的规范*'
- en: The spec defined in the preceding code can be verified by calling the `run-tests`
    or `run-all-tests` functions from the `clojure.test` namespace, or by running
    the `lein test` Leiningen command. In conclusion, generative testing through the
    `test.check` library is yet another way to test our code. It focuses on specifying
    properties of functions rather than describing the expected output of functions
    for some input.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的规范可以通过从 `clojure.test` 命名空间调用 `run-tests` 或 `run-all-tests` 函数，或者通过运行
    `lein test` Leiningen 命令来验证。总之，通过 `test.check` 库进行生成性测试是我们测试代码的另一种方式。它侧重于指定函数的性质，而不是描述函数对于某些输入的预期输出。
- en: Testing with types
  id: totrans-1781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行测试
- en: '**Type checking** is something that is often taken for granted in statically
    typed languages. With type checking, type errors can be found at compile time,
    rather than during runtime. In some dynamic languages such as Clojure, type signatures
    can be declared wherever and whenever they are required, and this technique is
    termed as *optional typing*. Type checking can be done using the `core.typed`
    library ([https://github.com/clojure/core.typed](https://github.com/clojure/core.typed)).
    Using `core.typed`, the type signature of a var can be checked using *type annotations*.
    Type annotations can be declared for any var, which includes values created using
    a `def` form, a `binding` form, or any other construct that creates a var. In
    this section, we will explore the details of this library.'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型检查** 在静态类型语言中通常是理所当然的。有了类型检查，类型错误可以在编译时而不是在运行时被发现。在一些动态语言，如 Clojure 中，类型签名可以在需要时和任何地方声明，这种技术被称为
    *可选类型*。类型检查可以使用 `core.typed` 库（[https://github.com/clojure/core.typed](https://github.com/clojure/core.typed)）来完成。使用
    `core.typed`，可以使用 *类型注解* 检查变量的类型签名。可以为任何变量声明类型注解，包括使用 `def` 形式、`binding` 形式或任何其他创建变量的构造创建的值。在本节中，我们将探讨这个库的细节。'
- en: Note
  id: totrans-1783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following library dependencies are required for the upcoming examples.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库依赖对于即将到来的示例是必需的。
- en: '[PRE416]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Also, the following namespaces must be included in your namespace declaration.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须包含在你的命名空间声明中。
- en: '[PRE417]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: The following examples can be found in `src/m_clj/c10/typed.clj` of the book's
    source code.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `src/m_clj/c10/typed.clj` 中找到。
- en: Type annotations for vars are declared using the `ann` macro from the `clojure.core.typed`
    namespace. This form must be passed an expression to annotate and a vector of
    types. For example, a type annotation for a function that accepts two numbers
    as arguments and returns a number is shown in *Example 10.15*.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `clojure.core.typed` 命名空间中的 `ann` 宏声明变量的类型注解。这个形式必须传递一个要注解的表达式和一个类型向量。例如，一个接受两个数字作为参数并返回数字的函数的类型注解如
    *示例 10.15* 所示。
- en: '[PRE418]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '*Example 10.15: A type annotation for a function that accepts two numbers and
    returns a number*'
  id: totrans-1791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.15：一个接受两个数字并返回数字的函数的类型注解*'
- en: 'To check all the type annotations in the given namespace, we must call the
    `clojure.core.typed/check-ns` function by passing it the namespace to be checked,
    as shown here:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查给定命名空间中的所有类型注解，我们必须通过传递要检查的命名空间来调用 `clojure.core.typed/check-ns` 函数，如下所示：
- en: '[PRE419]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'As shown previously, the `check-ns` function prints some information about
    the namespaces being checked, and returns the keyword `:ok` if all type checks
    in the specified namespace have passed. Now, let''s change the definition of the
    `add` function we previously defined as shown in *Example 10.16*:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`check-ns` 函数会打印出正在检查的命名空间的一些信息，如果指定命名空间中的所有类型检查都通过，则返回关键字 `:ok`。现在，让我们改变之前定义的
    `add` 函数，如下所示 *示例 10.16*：
- en: '[PRE420]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '*Example 10.16: Redefining the add function*'
  id: totrans-1796
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.16：重新定义 add 函数*'
- en: 'Although the preceding definition is valid, it will not be passed by the type
    checker, as shown here:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的定义是有效的，但它不会被类型检查器通过，如下所示：
- en: '[PRE421]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'The `check-ns` function throws an error stating that a `String` type was found
    where a `Number` type was expected. In this way, the `check-ns` function can find
    type errors in functions that have been annotated with the `ann` macro. Functions
    with multiple arities can be annotated using the `IFn` construct from the `clojure.core.typed`
    namespace, as shown in *Example 10.17*:'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-ns` 函数抛出一个错误，指出在期望 `Number` 类型的地方找到了 `String` 类型。这样，`check-ns` 函数就可以在用
    `ann` 宏注解的函数中找到类型错误。可以使用 `clojure.core.typed` 命名空间中的 `IFn` 构造来注解具有多个arity的函数，如
    *示例 10.17* 所示：'
- en: '[PRE422]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '*Example 10.17: Annotating functions with multiple arities*'
  id: totrans-1801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.17：使用多个arity注解函数*'
- en: We can also annotate functions with variadic arguments using the `*` symbol
    in the vector of types passed to the `ann` macro, as shown in *Example 10.18*.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用传递给 `ann` 宏的类型向量中的 `*` 符号来注解具有可变参数的函数，如 *示例 10.18* 所示。
- en: '[PRE423]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '*Example 10.18: Annotating functions with variadic arguments*'
  id: totrans-1804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.18：使用可变参数注解函数*'
- en: 'In the REPL, we can determine the inferred type of an expression or a value
    using the `cf` macro from the `clojure.core.typed` namespace. This macro can also
    be passed the expected type as the second argument. Note that the `cf` form is
    only for experimentation and should not be used in type annotations. The `cf`
    form returns an inferred type, along with a structure called a *filter set*, which
    is represented as a map. For example, the type and filter sets of the values `nil`,
    `true`, and `false` can be inferred using the `cf` form as shown here:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，我们可以使用`clojure.core.typed`命名空间中的`cf`宏来确定表达式或值的推断类型。此宏也可以将预期类型作为第二个参数传递。请注意，`cf`形式仅用于实验，不应用于类型注解。`cf`形式返回一个推断类型，以及一个称为**过滤器集**的结构，它表示为映射。例如，可以使用`cf`形式推断`nil`、`true`和`false`值的类型，如下所示：
- en: '[PRE424]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'In the preceding output, the second value in each of the vectors returned by
    the `cf` macro represents the filter set derived from the supplied expression.
    A filter set can be described as a collection of the two filters:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，由`cf`宏返回的每个向量中的第二个值代表从提供的表达式派生的过滤器集。过滤器集可以描述为两个过滤器的集合：
- en: The `:then` filter, which is true if the expression is a truthy value
  id: totrans-1808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式是一个真值，则`:then`过滤器为真
- en: The `:else` filter, which is true if the expression is not a truthy value
  id: totrans-1809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式不是真值，则`:else`过滤器为真
- en: 'In the context of filter sets, there are two *trivial filters*, namely `tt`
    and `ff`, which can be described as follows:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器集的上下文中，存在两个**平凡过滤器**，即`tt`和`ff`，可以描述如下：
- en: '`tt`, which translates to trivially true and means the value is truthy.'
  id: totrans-1811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt`，它翻译为**显然为真**，意味着值是真值。'
- en: '`ff`, which translates to *forever false* and means the value is not truthy.
    This filter is also termed as the *impossible filter*.'
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff`，它翻译为**永远为假**，意味着值不是真值。此过滤器也称为**不可能过滤器**。'
- en: 'In this perspective, the filter set `{:then tt, :else ff}` translates into
    "the expression could be a truthy value, but it is impossible for it to be a non-truthy
    value". Thus, false values such as `nil` and `false` are never true as inferred
    by the `cf` form, which agrees with the semantics of these values in Clojure.
    Truthy values will always have `tt` as the `:then` filter, as shown in the following
    output:'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，过滤器集`{:then tt, :else ff}`翻译为“表达式可能是一个真值，但它不可能是一个非真值”。因此，`nil`和`false`等假值永远不会被`cf`形式推断为真，这与Clojure中这些值的语义一致。真值将始终有`tt`作为`:then`过滤器，如下面的输出所示：
- en: '[PRE425]'
  id: totrans-1814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'The `cf` macro can also be used to check the type signature of functions, as
    shown here:'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '`cf`宏也可以用来检查函数的类型签名，如下所示：'
- en: '[PRE426]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'A form or expression can be annotated with an expected type using the `ann-form`
    macro, as shown here:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ann-form`宏对形式或表达式进行预期类型的注解，如下所示：
- en: '[PRE427]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'Aggregate types such as lists and vectors also have types defined for them
    in the `clojure.core.typed` namespace. We can infer the types of these data structures
    using the `cf` macro, as shown here:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和向量等聚合类型在`clojure.core.typed`命名空间中也有为它们定义的类型。我们可以使用`cf`宏推断这些数据结构的类型，如下所示：
- en: '[PRE428]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'The types `PersistentList` and `HVec` in the preceding output are concrete
    types for a list and a vector respectively. We can also pass the expected type
    as an extra argument to the `cf` form as shown here:'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中的类型`PersistentList`和`HVec`分别是列表和向量的具体类型。我们还可以将预期类型作为额外的参数传递给`cf`形式，如下所示：
- en: '[PRE429]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: The `core.typed` library also supports *parameterized types*, *union types*,
    and *intersection types*. Union types are declared using the `U` construct, and
    intersection types are declared using the `I` construct. Intersection types are
    meant to be used with protocols, which implies that the intersection type `(I
    A B)` must implement both the protocols `A` and `B`. On the other hand, union
    types can be defined using concrete types. For example, the `clojure.core.typed`
    namespace defines a parameterized `Option` type, which is simply a union of `nil`
    and the parameterized type. In other words, the type `(Option x)` is defined as
    the union type `(U x nil)`. Another good example of a union type is the `AnyInteger`
    type, which represents a whole number, and is defined in the `clojure.core.typed`
    namespace as shown in *Example 10.19*.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.typed` 库也支持**参数化类型**、**联合类型**和**交集类型**。联合类型使用 `U` 构造来声明，交集类型使用 `I` 构造来声明。交集类型旨在与协议一起使用，这意味着交集类型
    `(I A B)` 必须实现协议 `A` 和 `B`。另一方面，联合类型可以使用具体类型来定义。例如，`clojure.core.typed` 命名空间定义了一个参数化的
    `Option` 类型，它只是 `nil` 和参数化类型的联合。换句话说，类型 `(Option x)` 被定义为联合类型 `(U x nil)`。另一个联合类型的良好例子是
    `AnyInteger` 类型，它表示一个整数，并在 `clojure.core.typed` 命名空间中定义，如 *示例 10.19* 所示。'
- en: '[PRE430]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '*Example 10.19: The AnyInteger union type*'
  id: totrans-1825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.19：AnyInteger 联合类型*'
- en: '*Polymorphic types* are also supported by the `core.typed` library, which allow
    us to specify generalized types. For example, the `identity` and `iterate` functions
    have polymorphic type signatures, as shown here:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.typed` 库也支持**多态类型**，这允许我们指定泛化类型。例如，`identity` 和 `iterate` 函数具有多态类型签名，如下所示：'
- en: '[PRE431]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: We can annotate functions with polymorphic type signatures using the `All` construct
    from the `clojure.core.typed` namespace, as shown in *Example 10.20*.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自 `clojure.core.typed` 命名空间的 `All` 构造来为函数添加多态类型签名，如 *示例 10.20* 所示。
- en: '[PRE432]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '*Example 10.20: Defining a polymorphic type signature*'
  id: totrans-1830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 10.20：定义多态类型签名*'
- en: In conclusion, the `core.typed` library provides several constructs to define
    and verify type signatures of vars. There are also several constructs for determining
    the type signature of a given expression. Using `core.typed`, you can find logical
    type errors in your code before it is executed at runtime. Type annotations can
    also be thought of as a form of documentation, which concisely describe the types
    of functions and vars. Thus, there are several benefits of using types through
    the `core.typed` library in Clojure.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`core.typed` 库提供了几个构造来定义和验证变量的类型签名。还有几个构造用于确定给定表达式的类型签名。使用 `core.typed`，你可以在代码在运行时执行之前找到逻辑类型错误。类型注解也可以被视为一种文档形式，它简洁地描述了函数和变量的类型。因此，通过
    `core.typed` 库在 Clojure 中使用类型有多个好处。
- en: Summary
  id: totrans-1832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have discussed several libraries that can help us test and verify
    our code. We talked about the `clojure.test` and Midje libraries for defining
    tests. We also explored how we can define specs in the spirit of BDD using the
    Speclj library. Generative testing is another approach to testing, and we demonstrated
    how it can be done using the `test.check` library. Lastly, we talked about how
    we can perform type checking in Clojure using the `core.typed` library. Hence,
    there is a wide array of options for testing our code in Clojure.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了几个可以帮助我们测试和验证代码的库。我们讨论了用于定义测试的 `clojure.test` 和 Midje 库。我们还探讨了如何使用
    Speclj 库在 BDD 精神中定义规范。生成测试是另一种测试方法，我们展示了如何使用 `test.check` 库来实现。最后，我们讨论了如何使用 `core.typed`
    库在 Clojure 中执行类型检查。因此，在 Clojure 中测试我们的代码有广泛的选项。
- en: In the next and final chapter, we will talk about how we can troubleshoot our
    code, as well as some good practices for developing applications in Clojure.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将讨论如何调试我们的代码，以及一些在 Clojure 中开发应用程序的良好实践。
- en: Chapter 11. Troubleshooting and Best Practices
  id: totrans-1835
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。故障排除和最佳实践
- en: By now, you must be aware of all the features and most of the constructs of
    the Clojure language. Before you start building your own applications and libraries
    in Clojure, we will briefly discuss a few techniques to troubleshoot your code
    and some practices that you should incorporate in your projects.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须已经了解了 Clojure 语言的所有特性和大多数构造。在你开始使用 Clojure 构建自己的应用程序和库之前，我们将简要讨论一些调试代码的技术以及你应该在你的项目中采用的一些实践。
- en: Debugging your code
  id: totrans-1837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: Along your journey of building applications and libraries in Clojure, you'll
    surely run into situations where it would be helpful to debug your code. The usual
    response to such a situation is to use an **Integrated Development Environment**
    (**IDE**) with a debugger. And while Clojure IDEs such as *CIDER* ([https://github.com/clojure-emacs/cider](https://github.com/clojure-emacs/cider))
    and *Counterclockwise* ([http://doc.ccw-ide.org](http://doc.ccw-ide.org)) do support
    debugging, there are a few simpler constructs and tools that we can use to troubleshoot
    our code. Let's have a look at a few of them.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 Clojure 构建应用程序和库的过程中，您肯定会遇到需要调试代码的情况。对此类情况的通常反应是使用带有调试器的 **集成开发环境** （**IDE**）。虽然
    Clojure IDE，如 *CIDER* ([https://github.com/clojure-emacs/cider](https://github.com/clojure-emacs/cider))
    和 *Counterclockwise* ([http://doc.ccw-ide.org](http://doc.ccw-ide.org)) 支持调试，但我们还可以使用一些更简单的构造和工具来排除代码中的故障。让我们看看其中的一些。
- en: One of the easiest ways to debug your code is by printing the value of some
    variables used within a function. We could use the standard `println` function
    for this purpose, but it doesn't always produce the most readable output for complex
    data types. As a convention, we should use the `clojure.pprint/pprint` function
    to print variables to the console. This function is the standard pretty-printer
    of the Clojure language.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 调试代码的最简单方法之一是打印函数内部使用的某些变量的值。我们可以使用标准的 `println` 函数来完成这个任务，但它并不总是为复杂的数据类型产生最可读的输出。作为一种惯例，我们应该使用
    `clojure.pprint/pprint` 函数将变量打印到控制台。这个函数是 Clojure 语言的标准化格式化打印器。
- en: Note
  id: totrans-1840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros can be quite bewildering to debug. As we mentioned in [Chapter 4](ch19.html
    "Chapter 4. Metaprogramming with Macros"), *Metaprogramming with Macros*, macros
    should be used sparingly and we can debug macros using macroexpansion constructs
    such as `macroexpand` and `macroexpand-all`.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在调试时可能会让人感到困惑。正如我们在 [第 4 章](ch19.html "第 4 章。使用宏进行元编程") 中提到的 *使用宏进行元编程*，宏应该谨慎使用，我们可以使用宏展开构造，如
    `macroexpand` 和 `macroexpand-all` 来调试宏。
- en: Apart from these built-in constructs, there are a couple of useful libraries
    that we can add to our debugging toolkit.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些内置构造之外，还有一些有用的库我们可以添加到我们的调试工具包中。
- en: Note
  id: totrans-1843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples can be found in `test/m_clj/c11/` `debugging.clj` of
    the book's source code.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的 `test/m_clj/c11/` `debugging.clj` 中找到。
- en: Using tracing
  id: totrans-1845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用追踪
- en: '*Tracing* can be used to determine when and how a form is called. The `tools.trace`
    contrib library ([https://github.com/clojure/tools.trace](https://github.com/clojure/tools.trace))
    provides some handy constructs for tracing our code.'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '*追踪* 可以用来确定何时以及如何调用一个形式。`tools.trace` 贡献库 ([https://github.com/clojure/tools.trace](https://github.com/clojure/tools.trace))
    为我们的代码追踪提供了一些实用的构造。'
- en: Note
  id: totrans-1847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖项对于即将到来的示例是必需的：
- en: '[PRE433]'
  id: totrans-1849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE434]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'The `trace` function, from the `clojure.tools.trace` namespace, is the most
    elementary way to trace an expression. It will simply print the value returned
    by the expression passed to it. The `trace` construct can also be passed a string,
    with which the trace can be tagged, as an additional argument. For example, suppose
    we have to trace the function defined in *Example 11.1*:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `clojure.tools.trace` 命名空间的 `trace` 函数是追踪表达式的最基本方法。它将简单地打印传递给它的表达式的返回值。`trace`
    构造也可以传递一个字符串，作为附加参数，以便对追踪进行标记。例如，假设我们需要追踪定义在 *示例 11.1* 中的函数：
- en: '[PRE435]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '*Example 11.1: A simple function to trace*'
  id: totrans-1854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 11.1：一个简单的追踪函数*'
- en: 'We can trace the expression `(make-vector 0)` using the `trace` function shown
    here:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这里显示的 `trace` 函数来追踪表达式 `(make-vector 0)`：
- en: '[PRE436]'
  id: totrans-1856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'We can trace all the functions defined in a namespace by passing the namespace
    to the `trace-ns` macro, which is defined in the `clojure.tools.trace` namespace.
    Similarly, specific functions or vars in a namespace can be traced using the `trace-vars`
    macro. Traces added using these forms can be removed using the `untrace-ns` and
    `untrace-vars` marcos. If we want to determine which expression among several
    ones is failing, we can pass the expressions to the `trace-forms` macro, shown
    here:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将命名空间传递给定义在 `clojure.tools.trace` 命名空间中的 `trace-ns` 宏来追踪一个命名空间中定义的所有函数。同样，可以使用
    `trace-vars` 宏来追踪命名空间中的特定函数或变量。使用这些形式添加的追踪可以通过 `untrace-ns` 和 `untrace-vars` 宏来移除。如果我们想确定几个表达式中的哪一个失败了，我们可以将表达式传递给这里显示的
    `trace-forms` 宏：
- en: '[PRE437]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'As the preceding output shows, the `trace-forms` macro will print the form
    that causes the error. A more informative way to trace a function is by replacing
    the `defn` symbol in its definition by `clojure.tools.trace/deftrace`, which simply
    defines a function whose arguments and return value will be traced. For example,
    consider the function defined in the following *Example 11.2*:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，`trace-forms` 宏将打印出导致错误的表达式。通过将定义中的 `defn` 符号替换为 `clojure.tools.trace/deftrace`，可以更详细地追踪一个函数。`deftrace`
    简单地定义了一个函数，其参数和返回值将被追踪。例如，考虑以下 *示例 11.2* 中定义的函数：
- en: '[PRE438]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '*Example 11.2: Tracing a function using the deftrace macro*'
  id: totrans-1861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 11.2：使用 deftrace 宏追踪函数*'
- en: 'On calling the `add-into-vector` function defined previously, the following
    trace will be printed:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用之前定义的 `add-into-vector` 函数时，将打印以下追踪信息：
- en: '[PRE439]'
  id: totrans-1863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: In this way, tracing can be used to find the value returned by an expression
    during the execution of a program. The tracing constructs from the `tools.trace`
    namespace allow us to determine when a function is called, as well as what its
    return value and arguments are.
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，追踪可以用来在程序执行过程中找到表达式的返回值。`tools.trace` 命名空间中的追踪结构允许我们确定函数何时被调用，以及它的返回值和参数是什么。
- en: Using Spyscope
  id: totrans-1865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spyscope
- en: As you may have already been thinking, you can easily implement your own debugging
    constructs using macros. The Spyscope library ([https://github.com/dgrnbrg/spyscope](https://github.com/dgrnbrg/spyscope))
    takes this approach and implements a few reader macros for debugging code. The
    use of reader macros for debugging is a more favorable approach for languages
    with the parentheses-flavored syntax of Lisps. This is because, in these languages,
    reader macros that print debugging information can be added more easily to an
    existing program compared to forms such as `trace` and `deftrace`. Let's explore
    the constructs of the Spyscope library to get a clearer idea of the advantage
    of debugging code with reader macros.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经想到的，您可以使用宏轻松实现自己的调试结构。Spyscope 库（[https://github.com/dgrnbrg/spyscope](https://github.com/dgrnbrg/spyscope)）采用这种方法，并实现了一些用于调试代码的读取宏。对于具有
    Lisp 风格括号语法的语言，使用读取宏进行调试是一种更受欢迎的方法。这是因为在这些语言中，与 `trace` 和 `deftrace` 这样的形式相比，可以更容易地将打印调试信息的读取宏添加到现有程序中。让我们探索
    Spyscope 库的结构，以更清楚地了解使用读取宏进行调试代码的优势。
- en: The Spyscope library provides the `#spy/p`, `#spy/d`, and `#spy/t` reader macros,
    which can all be used by writing them immediately before expressions that have
    to be debugged. It is a common practice to have these forms made available in
    the REPL using the `:injections` section of the `project.clj` file in a Leiningen
    project.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: Spyscope 库提供了 `#spy/p`、`#spy/d` 和 `#spy/t` 读取宏，这些都可以通过在需要调试的表达式之前立即写入它们来使用。在
    Leiningen 项目中，使用 `project.clj` 文件的 `:injections` 部分使这些形式可用是一种常见做法。
- en: Note
  id: totrans-1868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖关系对于即将到来的示例是必需的：
- en: '[PRE440]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'We must also include the following forms as a vector in the `:injections` section
    of your `project.clj` file:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `project.clj` 文件的 `:injections` 部分包含以下形式作为向量：
- en: '[PRE441]'
  id: totrans-1872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在您的命名空间声明中包含：
- en: '[PRE442]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'The `#spy/p` reader macro can be used to print a value that is used within
    an expression. An interesting point about this construct is that it is implemented
    using the `clojure.pprint/pprint` function. For example, we can print out the
    intermediate values produced by a `take` form shown here:'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '`#spy/p` 读取宏可以用来打印表达式内部使用的值。关于这个结构的有趣之处在于它是使用 `clojure.pprint/pprint` 函数实现的。例如，我们可以打印出这里显示的
    `take` 形式产生的中间值：'
- en: '[PRE443]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'To produce more detailed information, such as the call stack and the form that
    returns a value, we can use the `#spy/d` reader macro. For example, we can use
    this construct to produce the following information:'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成更详细的信息，例如调用堆栈和返回值的表达式，我们可以使用 `#spy/d` 读取宏。例如，我们可以使用这个结构生成以下信息：
- en: '[PRE444]'
  id: totrans-1878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'The `#spy/d` reader macro also supports several options, which can be passed
    to it as metadata. The `:fs` key of this metadata map specifies the number of
    stack frames to display. Also, the `:marker` key can be used to declare a string
    tag for a form. We can use these options to display information from the call
    stack of a form, shown here:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '`#spy/d` 读取宏还支持几个选项，可以作为元数据传递给它。这个元数据映射的 `:fs` 键指定要显示的堆栈帧数。此外，可以使用 `:marker`
    键为表达式声明一个字符串标签。我们可以使用这些选项来显示来自表达式调用堆栈的信息，如下所示：'
- en: '[PRE445]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'The preceding output shows the top three stack frames of a call to the `+`
    form. We can also filter out stack frames from the call stack information using
    the `:nses` key with a regular expression, shown here:'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了`+`表单调用的前三个堆栈帧。我们还可以使用正则表达式通过`:nses`键从调用堆栈信息中过滤出堆栈帧，如下所示：
- en: '[PRE446]'
  id: totrans-1882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: To skip printing the form being debugged, we can specify the `:form` key with
    a `false` value in the metadata map specified to the `#spy/d` reader macro, and
    this key defaults to `true`. We can also print out the time at which a form is
    called using the `:time` key. The value for this key can either be `true`, in
    which case the default time format is used, or a string such as `"hh:mm:ss"`,
    which represents the timestamp format with which the time must be displayed.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳过打印正在调试的表单，我们可以在指定的元数据映射中指定`:form`键为`false`值给`#spy/d`读取宏，并且此键默认为`true`。我们还可以使用`:time`键打印出表单被调用的时间。此键的值可以是`true`，在这种情况下，使用默认的时间格式，或者是一个如`"hh:mm:ss"`的字符串，它表示必须显示的时间戳格式。
- en: 'The `#spy/t` reader macro is used for tracing a form, and this construct supports
    the same options as the `#spy/d` reader macro. The trace is not printed immediately,
    and can be displayed using the `trace-query` function from the `spyscope.repl`
    namespace. For example, consider the function in *Example 11.3* that adds a number
    of values in a future:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '`#spy/t`读取宏用于跟踪一个表单，这个构造支持与`#spy/d`读取宏相同的选项。跟踪不会立即打印，可以使用`spyscope.repl`命名空间中的`trace-query`函数显示。例如，考虑*示例11.3*中在未来的值中添加数字的函数：'
- en: '[PRE447]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '*Example 11.3: Tracing a function that adds numbers in a future*'
  id: totrans-1886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例11.3：跟踪在未来的加法函数*'
- en: 'Once the `add-in-future` function is called, we can display a trace of the
    call using the `trace-query` function, shown here:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`add-in-future`函数，我们可以使用`trace-query`函数显示调用跟踪，如下所示：
- en: '[PRE448]'
  id: totrans-1888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: In the preceding output, the `trace-next` function is used to start a new *generation*
    of traces. Traces in the Spyscope library are grouped into generations, and a
    new generation can be started using the `spyscope.repl/trace-next` function. All
    trace information from all generations can be cleared using the `trace-clear`
    function from the `spyscope.repl` namespace. We can also pass an argument to the
    `trace-query` function to filter out results. This argument can be either a number,
    which represents the number of recent generations to show, or a regex to filter
    traces by their namespaces.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，使用`trace-next`函数启动一个新的*生成*跟踪。Spyscope库中的跟踪被分组到生成中，可以使用`spyscope.repl/trace-next`函数启动一个新的生成。可以使用`spyscope.repl`命名空间中的`trace-clear`函数清除所有生成中的跟踪信息。我们还可以向`trace-query`函数传递一个参数来过滤结果。此参数可以是表示要显示的最近生成数量的数字，或者是一个正则表达式，用于通过命名空间过滤跟踪。
- en: To summarize, there are several ways to debug your code in Clojure without the
    use of a debugger. The `tools.trace` and Spyscope libraries have several useful
    and simple constructs for debugging and tracing the execution of Clojure code.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在Clojure中，不使用调试器也可以有几种方法来调试你的代码。`tools.trace`和Spyscope库提供了几个有用的简单构造，用于调试和跟踪Clojure代码的执行。
- en: Logging errors in your application
  id: totrans-1891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的应用程序中记录错误
- en: Another way to analyze what went wrong in an application is by using logs. Logging
    can be done using the `tools.logging` contrib library. This library lets us use
    multiple logging implementations through an agnostic interface, and the implementations
    to choose from include `slf4j`, `log4j`, and `logback`. Let's quickly skim over
    how we can add logging to any Clojure program using the `tools.logging` library
    and `logback`, which is arguably the most recent and configurable implementation
    to use with this library.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 分析应用程序中发生错误的另一种方法是使用日志。可以使用`tools.logging`贡献库进行日志记录。这个库允许我们通过一个无差别的接口使用多个日志实现，可以选择的实现包括`slf4j`、`log4j`和`logback`。让我们快速浏览一下如何使用`tools.logging`库和`logback`（可以说是最最新和可配置的实现）将日志添加到任何Clojure程序中。
- en: Note
  id: totrans-1893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following library dependencies are required for the upcoming examples:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库依赖关系对于即将到来的示例是必需的：
- en: '[PRE449]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Also, the following namespaces must be included in your namespace declaration:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下命名空间必须在你的命名空间声明中包含：
- en: '[PRE450]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: The following examples can be found in `test/m_clj/c11/` `logging.clj` of the
    book's source code.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在书籍源代码的`test/m_clj/c11/` `logging.clj`中找到。
- en: All the logging macros implemented in the `clojure.tools.logging` namespace
    fall into two categories. The first category of macros require arguments like
    those which are passed to the `println` form. All of these arguments are concatenated
    and written to the log. The other category of macros must be passed a format string
    and values to interpolate into the specified format. This second category of macros
    are generally suffixed with an `f` character, such as `debugf` or `infof`. The
    logging macros in the `tools.logging` library can be passed an exception followed
    by the other usual arguments.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `clojure.tools.logging` 命名空间中实现的全部日志宏分为两类。第一类宏需要像传递给 `println` 形式的参数一样传递参数。所有这些参数都将连接并写入日志。另一类宏必须传递一个格式字符串和要插入到指定格式的值。这类宏通常以
    `f` 字符结尾，例如 `debugf` 或 `infof`。`tools.logging` 库中的日志宏可以传递一个异常，然后是其他常规参数。
- en: The macros in the `tools.logging` library write log messages at differing log
    levels. For example, the `debug` and `debugf` forms write log messages at the
    `DEBUG` level, and similarly, the `error` and `errorf` macros log at the `ERROR`
    level. In addition, the `spy` and `spyf` macros will evaluate and return the value
    of an expression, and may log the result if the current log level is equal to
    or below the log level specified to it, which defaults to `DEBUG`.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '`tools.logging` 库中的宏以不同的日志级别写入日志消息。例如，`debug` 和 `debugf` 形式在 `DEBUG` 级别写入日志消息，同样，`error`
    和 `errorf` 宏在 `ERROR` 级别进行日志记录。此外，`spy` 和 `spyf` 宏将评估并返回表达式的值，如果当前日志级别等于或低于指定的日志级别（默认为
    `DEBUG`），则可能记录结果。'
- en: 'For example, the `divide` function, shown in the following *Example 11.4*,
    logs some information, using the `info`, `spyf`, and `error` macros, while performing
    integer division:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 *示例 11.4* 中所示的 `divide` 函数，在执行整数除法的同时，使用 `info`、`spyf` 和 `error` 宏记录一些信息：
- en: '[PRE451]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '*Example 11.4: A function that logs information using the tools.logging library*'
  id: totrans-1903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 11.4：使用 tools.logging 库记录信息的函数*'
- en: 'The following log messages will be written when the `divide` function is called:'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `divide` 函数时，将写入以下日志消息：
- en: '[PRE452]'
  id: totrans-1905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: As shown previously, the `divide` function writes several log messages at different
    log levels when it is called. The logging configuration for `logback` must be
    saved in a file named `logback.xml`, which can reside in either the `src/` or
    `resources/` directories of a Leiningen project. We can specify the default log
    level and several other options for `logback` in this file.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当调用 `divide` 函数时，它会以不同的日志级别写入多个日志消息。`logback` 的日志配置必须保存在一个名为 `logback.xml`
    的文件中，该文件可以位于 Leiningen 项目的 `src/` 或 `resources/` 目录中。我们可以在该文件中指定 `logback` 的默认日志级别和其他几个选项。
- en: Note
  id: totrans-1907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in the logging configuration for the previous examples,
    take a look at the `src/logback.xml` file in the book's source code. For detailed
    configuration options, visit [http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html).
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对前例的日志配置感兴趣，请查看书中源代码的 `src/logback.xml` 文件。有关详细的配置选项，请访问 [http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html)。
- en: 'It is also handy to have a global exception handler that logs exceptions for
    all threads in a program. This can be particularly useful for checking errors
    that are encountered during the execution of `go` and `thread` macros from the
    `core.async` library. Such a global exception handler can be defined using the
    `setDefaultUncaughtExceptionHandler` method from the `java.lang.Thread` class,
    as shown in *Example 11.5*:'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个全局异常处理器，记录程序中所有线程的异常，也非常方便。这特别有助于检查在执行 `core.async` 库中的 `go` 和 `thread`
    宏时遇到的错误。可以使用 `java.lang.Thread` 类的 `setDefaultUncaughtExceptionHandler` 方法定义这样的全局异常处理器，如
    *示例 11.5* 所示：
- en: '[PRE453]'
  id: totrans-1910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '*Example 11.5: A global exception handler that logs all errors*'
  id: totrans-1911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*示例 11.5：一个全局异常处理器，记录所有错误*'
- en: Note
  id: totrans-1912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use *Timbre* ([https://github.com/ptaoussanis/timbre](https://github.com/ptaoussanis/timbre))
    for logging, which can be configured without the use of XML and is also supported
    on ClojureScript.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 *Timbre* ([https://github.com/ptaoussanis/timbre](https://github.com/ptaoussanis/timbre))
    进行日志记录，它可以在不使用 XML 的情况下进行配置，并且也支持 ClojureScript。
- en: In conclusion, there are several options for logging available to us through
    the `tools.logging` library. This library also supports several logging implementations
    that each have their own set of configuration options.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，通过 `tools.logging` 库，我们有几种日志记录选项可用。此库还支持几种日志实现，每种实现都有自己的配置选项集。
- en: Thinking in Clojure
  id: totrans-1915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Clojure中思考
- en: 'Let''s briefly discuss a handful of good practices for building real world
    applications in Clojure. Of course, these practices are only guidelines, and you
    should eventually try to establish your own set of rules and practices for writing
    code in Clojure:'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一些在Clojure中构建现实世界应用程序的良好实践。当然，这些实践只是指南，你最终应该尝试建立自己的一套规则和实践来编写Clojure代码：
- en: '**Minimize state and use pure functions**: Most applications must inevitably
    use some form of state. You must always strive to reduce the amount of state you''re
    dealing with, and implement most of the heavy lifting in pure functions. State
    can be managed using reference types, channels, or even monads in Clojure, thus
    giving us a lot of proven options. In this way, we can reduce the number of conditions
    that can cause any unexpected behavior in a program. Pure functions are also easier
    to compose and test.'
  id: totrans-1917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化状态并使用纯函数**：大多数应用程序不可避免地必须使用某种形式的状态。你必须始终努力减少你处理的状态量，并在纯函数中实现大部分繁重的工作。在Clojure中，可以使用引用类型、通道甚至单子来管理状态，这为我们提供了很多经过验证的选项。这样，我们可以减少可能导致程序中任何意外行为的条件数量。纯函数也更容易组合和测试。'
- en: '**Don''t forget about laziness**: Laziness can be used as an alternative to
    solve problems that have solutions based on recursion. Although laziness does
    tend to simplify several aspects of functional programming, it also incurs additional
    memory usage in certain situations, such as holding on to the head of a lazy sequence.
    Take a look at [http://clojure.org/reference/lazy#_don_t_hang_onto_your_head](http://clojure.org/reference/lazy#_don_t_hang_onto_your_head)
    for more information on how laziness can increase the memory usage of your program.
    Most of the standard functions in Clojure return lazy sequences as results, and
    you must always consider laziness when working with them.'
  id: totrans-1918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记懒惰**：懒惰可以用作解决基于递归的解决方案的替代方案。虽然懒惰确实倾向于简化函数式编程的几个方面，但在某些情况下，如保留懒惰序列的头部，它也会导致额外的内存使用。查看[http://clojure.org/reference/lazy#_don_t_hang_onto_your_head](http://clojure.org/reference/lazy#_don_t_hang_onto_your_head)了解更多关于懒惰如何增加程序内存使用的信息。Clojure中的大多数标准函数都返回懒惰序列作为结果，因此在使用它们时，你必须始终考虑懒惰。'
- en: '**Model your program as transformations of data**: It is unavoidable to think
    in steps as humans, and you must always try to model your code as steps of transforming
    data. Try to avoid thinking in steps that mutate state, but rather in transformations
    of data. This leads to a more composable design, which makes combining a handful
    of transformations very easy.'
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将你的程序建模为数据的转换**：作为人类，按步骤思考是不可避免的，你必须始终尝试将你的代码建模为转换数据的步骤。尽量避免按步骤思考会改变状态，而应该是在数据的转换上。这导致了一种更可组合的设计，使得组合几个转换变得非常容易。'
- en: '**Use the threading macros -> and ->> to avoid nesting expressions**: You must
    have seen quite a few examples in this book that have used these macros, and have
    probably started enjoying their presence in your own code as well. The `->` and
    `->>` macros improve readability greatly, and must be used wherever possible.
    Don''t hesitate to use these macros even if it avoids a couple of levels of nesting.
    There are several other threading macros, such as `cond->` and `as->`, that can
    often be useful.'
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用线程宏->和->>来避免嵌套表达式**：你一定在这本书中看到了很多使用这些宏的例子，可能已经开始享受它们在你自己的代码中的存在了。`->`和`->>`宏极大地提高了可读性，应该在可能的情况下使用。即使它避免了几个嵌套级别，也不要犹豫使用这些宏。还有一些其他的线程宏，如`cond->`和`as->`，通常非常有用。'
- en: '**Parallelism is at your fingertips**: There are several ways to write programs
    that benefit through the use of parallelism in Clojure. You can choose between
    futures, reducers, `core.async` processes, and several other constructs to model
    concurrent and parallel operations. Also, most of the state management constructs,
    such as atoms, agents, and channels, have been designed with concurrency in mind.
    So, don''t hesitate to use them when you''re dealing with concurrent tasks and
    state.'
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性触手可及**：在Clojure中，有几种编写能够通过并行使用受益的程序的方法。你可以选择使用futures、reducers、`core.async`进程以及几种其他结构来模拟并发和并行操作。此外，大多数状态管理结构，如atoms、agents和channels，都是考虑到并发而设计的。所以，在处理并发任务和状态时，不要犹豫使用它们。'
- en: '**Live in the REPL**: It''s an indispensable tool for experimenting with code
    and prototyping your programs. After writing a function or a macro, the first
    thing you should do is play with it in the REPL. You can use the `load-file` function
    to quickly reload changes in your source files without ever restarting the REPL.
    Keep in mind that reloading a source file with the `load-file` form will erase
    any modifications or redefinitions in the namespace of the source file that have
    been made through the REPL.'
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生活在REPL中**：这是实验代码和原型化程序不可或缺的工具。在编写函数或宏之后，你应该首先在REPL中对其进行实验。你可以使用`load-file`函数快速重新加载源文件中的更改，而无需重新启动REPL。请记住，使用`load-file`形式重新加载源文件将擦除通过REPL在源文件命名空间中通过REPL所做的任何修改或重新定义。'
- en: '**Embed a Clojure REPL in your application**: It is possible to embed the REPL
    into an application, thus allowing us to connect to it and modify its behavior
    at runtime as we desire. For more information on how to do this, take a look at
    the constructs in the `clojure.core.server.repl` namespace or the `tools.nrepl`
    library ([https://github.com/clojure/tools.nrepl](https://github.com/clojure/tools.nrepl)).
    But, this is a possible security risk, and should be used with caution.'
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在应用程序中嵌入Clojure REPL**：可以将REPL嵌入到应用程序中，这样我们就可以连接到它，并根据我们的需求在运行时修改其行为。有关如何做到这一点的更多信息，请参阅`clojure.core.server.repl`命名空间中的结构或`tools.nrepl`库（[https://github.com/clojure/tools.nrepl](https://github.com/clojure/tools.nrepl)）。但是，这可能会带来潜在的安全风险，因此应谨慎使用。'
- en: '**Use the standard coding style with consistency**: Maintaining a good coding
    style is important in any project or programming language. All of the examples
    in this book are formatted in a standard way, as defined by the Clojure style
    guide ([https://github.com/bbatsov/clojure-style-guide](https://github.com/bbatsov/clojure-style-guide)).'
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一致的标准化编码风格**：在任何项目或编程语言中，保持良好的编码风格都很重要。本书中的所有示例都按照Clojure风格指南（[https://github.com/bbatsov/clojure-style-guide](https://github.com/bbatsov/clojure-style-guide)）定义的标准方式格式化。'
- en: Summary
  id: totrans-1925
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we talked about several ways to troubleshoot our code. The `tools.trace`
    and Spyscope libraries are useful in interactive debugging, while the `tools.logging`
    library can be used to log information in running applications. We also discussed
    a handful of good practices for developing applications and libraries in Clojure.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了几种调试代码的方法。`tools.trace`和Spyscope库在交互式调试中很有用，而`tools.logging`库可以用于在运行中的应用程序中记录信息。我们还讨论了在Clojure中开发应用程序和库的一些良好实践。
- en: You must be quite anxious by now to write your own applications in Clojure.
    If you've been paying attention so far, you must have noticed that Clojure is
    indeed a simple language. Yet, through its simplicity, we are empowered to create
    elegant and scalable solutions to a lot of interesting problems. On your journey
    with Clojure ahead, always strive to make things simpler, if they aren't simple
    enough already. We'll leave you with a few thought provoking quotes as you go
    onwards to realize the possibilities of this elegant, powerful, and simple programming
    language.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经迫不及待地想要用Clojure编写自己的应用程序了。如果你一直很关注，你一定已经注意到Clojure确实是一种简单的语言。然而，正是通过其简单性，我们能够创造出优雅且可扩展的解决方案来解决许多有趣的问题。在你继续使用Clojure的旅程中，始终努力使事物变得更简单，如果它们还不够简单的话。我们将给你留下一些引人深思的名言，以便你继续探索这个优雅、强大且简单的编程语言的无限可能。
- en: '|   | *"Composing simple components is the way we write robust software."*
    |   |'
  id: totrans-1928
  prefs: []
  type: TYPE_TB
  zh: '|   | *"通过组合简单的组件，我们编写出健壮的软件。" |   |'
- en: '|   | --*Rich Hickey* |'
  id: totrans-1929
  prefs: []
  type: TYPE_TB
  zh: '|   | --*理查德·赫基* |'
- en: '|   | *"Simplicity is prerequisite for reliability."* |   |'
  id: totrans-1930
  prefs: []
  type: TYPE_TB
  zh: '|   | *"简洁是可靠性的前提。" |   |'
- en: '|   | --*Edsger W. Dijkstra* |'
  id: totrans-1931
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃德加·W·迪杰斯特拉* |'
- en: '|   | *"Simplicity is the ultimate sophistication."* |   |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
  zh: '|   | *"简洁是最高级的复杂。" |   |'
- en: '|   | --*Leonardo da Vinci* |'
  id: totrans-1933
  prefs: []
  type: TYPE_TB
  zh: '|   | --*列奥纳多·达·芬奇* |'
- en: Appendix A. References
  id: totrans-1934
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 参考文献
- en: '*Anatomy of a Reducer*, Rich Hickey (2012): [http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html](http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html)'
  id: totrans-1935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Reducer的解剖学》，理查德·赫基（2012）*：[http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html](http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html)'
- en: '*Transducers are Coming*, Rich Hickey (2014): [http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming)'
  id: totrans-1936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《即将到来的Transducers》，理查德·赫基（2014）*：[http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming)'
- en: '*Introduction to Logic Programming with Clojure*, Ambrose Bonnaire-Sergeant
    (2011): [http://github.com/frenchy64/Logic-Starter/wiki](http://github.com/frenchy64/Logic-Starter/wiki)'
  id: totrans-1937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Clojure 进行逻辑编程入门*, Ambrose Bonnaire-Sergeant (2011): [http://github.com/frenchy64/Logic-Starter/wiki](http://github.com/frenchy64/Logic-Starter/wiki)'
- en: '*N-Queens with core.logic*, Martin Trojer (2012): [http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html)'
  id: totrans-1938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 core.logic 解决 N 皇后问题*, Martin Trojer (2012): [http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html](http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html)'
- en: '*Clojure core.async Channels*, Rich Hickey (2013): [http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels)'
  id: totrans-1939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clojure core.async 通道*, Rich Hickey (2013): [http://clojure.com/blog/2013/06/28/clojure-core-async-channels](http://clojure.com/blog/2013/06/28/clojure-core-async-channels)'
- en: '*Communicating Sequential Processes*, C. A. R. Hoare (1978): [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)'
  id: totrans-1940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信顺序过程*, C. A. R. Hoare (1978): [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)'
- en: '*Communicating Sequential Processes*, David Nolen (2013): [http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/)'
  id: totrans-1941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信顺序过程*, David Nolen (2013): [http://swannodette.github.io/2013/07/12/communicating-sequential-processes/](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/)'
- en: '*A Dining Philosophers solver*, Pepijn de Vos (2013): [http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html)'
  id: totrans-1942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哲学家就餐问题求解器*，Pepijn de Vos (2013): [http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html](http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html)'
- en: '*CSP vs. FRP*, Draco Dormiens (2014): [http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html)'
  id: totrans-1943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CSP 与 FRP 对比*, Draco Dormiens (2014): [http://potetm.github.io/2014/01/07/frp.html](http://potetm.github.io/2014/01/07/frp.html)'
- en: '*Functional Reactive Animation*, Conal Elliott and Paul Hudak (1997): [http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
  id: totrans-1944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能性反应式动画*, Conal Elliott 和 Paul Hudak (1997): [http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
- en: '*Yolk* *examples*, Wilkes Joiner (2013): [https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)'
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Yolk 示例*, Wilkes Joiner (2013): [https://github.com/Cicayda/yolk-examples](https://github.com/Cicayda/yolk-examples)'
- en: '*The* *Clojure docs*: [http://clojure.org/](http://clojure.org/)'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clojure 文档*: [http://clojure.org/](http://clojure.org/)'
- en: '*Cats* *Documentation*: [http://funcool.github.io/cats/latest](http://funcool.github.io/cats/latest)'
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cats 文档*: [http://funcool.github.io/cats/latest](http://funcool.github.io/cats/latest)'
- en: '*The* *core.logic wiki*: [http://github.com/clojure/core.logic/wiki](http://github.com/clojure/core.logic/wiki)'
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*core.logic 的 wiki*: [http://github.com/clojure/core.logic/wiki](http://github.com/clojure/core.logic/wiki)'
- en: '*The* *Pulsar docs*: [http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)'
  id: totrans-1949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pulsar 文档*: [http://docs.paralleluniverse.co/pulsar/](http://docs.paralleluniverse.co/pulsar/)'
- en: '*The* *Midje wiki*: [http://github.com/marick/Midje/wiki](http://github.com/marick/Midje/wiki)'
  id: totrans-1950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Midje 的 wiki*: [http://github.com/marick/Midje/wiki](http://github.com/marick/Midje/wiki)'
- en: '*Getting* *Started with Speclj*: [http://speclj.com/tutorial](http://speclj.com/tutorial)'
  id: totrans-1951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Speclj 入门*: [http://speclj.com/tutorial](http://speclj.com/tutorial)'
- en: '*The* *core.typed* *wiki*: [http://github.com/clojure/core.typed/wiki](http://github.com/clojure/core.typed/wiki)'
  id: totrans-1952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*core.typed 的 wiki*: [http://github.com/clojure/core.typed/wiki](http://github.com/clojure/core.typed/wiki)'
