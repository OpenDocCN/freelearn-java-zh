- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Securing Access to APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 API 访问
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn how
    to use HTTPS to protect against eavesdropping on external access to our APIs,
    and how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will use HTTP Basic authentication
    to secure access to the discovery server, Netflix Eureka.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何保护上一章中介绍的边缘服务器暴露的 API 和网页的访问。我们将学习如何使用 HTTPS 保护对外部访问我们 API 的监听，以及如何使用
    OAuth 2.0 和 OpenID Connect 认证和授权用户和客户端应用程序访问我们的 API。最后，我们将使用 HTTP Basic 认证来保护对发现服务器
    Netflix Eureka 的访问。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0 和 OpenID Connect 标准简介
- en: A general discussion on how to secure the system landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何保护系统架构的一般讨论
- en: Protecting external communication with HTTPS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTPS 保护外部通信
- en: Securing access to the discovery server, Netflix Eureka
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护对发现服务器，Netflix Eureka 的访问
- en: Adding a local authorization server to our system landscape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地授权服务器添加到我们的系统架构中
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth 2.0 和 OpenID Connect 认证和授权 API 访问
- en: Testing with the local authorization server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: Testing with an external OpenID Connect provider, Auth0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部 OpenID Connect 提供商 Auth0 进行测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 21 章*，*macOS 安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 22 章*，*使用 WSL 2 和 Ubuntu 的 Microsoft Windows 安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter11`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例全部来自 `$BOOK_HOME/Chapter11` 中的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to secure access to the APIs in the microservice landscape,
    you can compare it with the source code for *Chapter 10*, *Using Spring Cloud
    Gateway to Hide Microservices behind an Edge Server*. You can use your favorite
    `diff` tool and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看对本章源代码所做的更改，即查看在微服务领域中保护 API 访问所需要的内容，你可以将其与 *第 10 章*，*使用 Spring Cloud
    Gateway 在边缘服务器后面隐藏微服务* 的源代码进行比较。你可以使用你喜欢的 `diff` 工具比较两个文件夹，`$BOOK_HOME/Chapter10`
    和 `$BOOK_HOME/Chapter11`。
- en: Introduction to OAuth 2.0 and OpenID Connect
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0 和 OpenID Connect 简介
- en: Before introducing OAuth 2.0 and OpenID Connect, let’s clarify what we mean
    by authentication and authorization. **Authentication** means identifying a user
    by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 OAuth 2.0 和 OpenID Connect 之前，让我们先明确一下我们所说的认证和授权的含义。**认证**意味着通过验证用户提供的凭据（如用户名和密码）来识别用户。**授权**是指允许经过认证的用户访问各种部分，在我们的例子中，是访问
    API。
- en: '**OAuth 2.0** is an open standard for **authorization delegation**, and **OpenID
    Connect** is an add-on to OAuth 2.0 that enables client applications to verify
    the identity of users based on the authentication performed by the authorization
    server. Let’s look briefly at OAuth 2.0 and OpenID Connect separately to get an
    initial understanding of their purposes!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2.0** 是一个用于**授权委托**的开放标准，**OpenID Connect** 是 OAuth 2.0 的附加组件，它允许客户端应用程序根据授权服务器执行的认证来验证用户的身份。让我们简要地看看
    OAuth 2.0 和 OpenID Connect，以获得它们目的的初步了解！'
- en: Introducing OAuth 2.0
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 OAuth 2.0
- en: OAuth 2.0 is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user. Giving a third-party client application the
    right to act in the name of a user, for example, calling an API, is known as **authorization
    delegation**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 是一个广泛接受的开放标准，用于授权，它允许用户同意第三方客户端应用程序以用户的名义访问受保护资源。将代表用户执行操作的权利（例如，调用
    API）授予第三方客户端应用程序，称为**授权委托**。
- en: So, what does this mean?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这又意味着什么呢？
- en: 'Let’s start by sorting out the concepts used:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先理清所使用的概念：
- en: '**Resource owner**: The end user.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：最终用户。'
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：第三方客户端应用程序，例如，一个网络应用程序或原生移动应用程序，它希望代表最终用户调用受保护的 API。'
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：暴露我们想要保护的 API 的服务器。'
- en: '**Authorization server**: The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：在资源所有者，即最终用户经过身份验证后，授权服务器向客户端发放令牌。用户信息和用户身份验证的管理通常在幕后委托给一个**身份提供者**（**IdP**）。'
- en: A client is registered in the authorization server and is given a **client ID**
    and a **client secret**. The client secret must be protected by the client, like
    a password. A client also gets registered with a set of allowed **redirect URIs**
    that the authorization server will use after a user has been authenticated to
    send **authorization codes** and **tokens** that have been issued back to the
    client application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在授权服务器中注册，并分配一个**客户端 ID**和一个**客户端密钥**。客户端密钥必须由客户端保护，就像密码一样。客户端还注册了一组允许的**重定向
    URI**，授权服务器在用户经过身份验证后使用这些 URI 发送**授权码**和**令牌**，并将它们发送回客户端应用程序。
- en: The following is an example by way of illustration. Let’s say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，以供说明。假设用户访问第三方客户端应用程序，并且客户端应用程序希望调用受保护的 API 来服务用户。为了允许访问这些 API，客户端应用程序需要一种方法来告诉
    API 它是在代表用户行事。为了避免用户必须与客户端应用程序共享其凭据以进行身份验证的解决方案，授权服务器会发放一个**访问令牌**，该令牌允许客户端应用程序代表用户有限地访问一组选定的
    API。
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as **scopes** in OAuth 2.0 terms. A **refresh
    token** can also be issued to a client application by the authorization server.
    A refresh token can be used by the client application to obtain new access tokens
    without having to involve the user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户永远不需要向客户端应用程序透露其凭据。用户还可以同意客户端应用程序代表用户访问特定的 API。访问令牌代表一组时间限制的访问权限，在 OAuth
    2.0 术语中表达为**作用域**。授权服务器还可以向客户端应用程序发放一个**刷新令牌**。刷新令牌可以被客户端应用程序用来获取新的访问令牌，而无需涉及用户。
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 规范定义了四种用于发放访问令牌的授权流程，如下所述：
- en: '**Authorization code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interacts with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权码授权流程**：这是最安全的，但也是最复杂的授权流程。此授权流程要求用户通过网页浏览器与授权服务器进行交互以进行身份验证并同意客户端应用程序，如下面的图示所示：'
- en: '![Diagram  Description automatically generated](img/B19825_11_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图示描述自动生成](img/B19825_11_01.png)'
- en: 'Figure 11.1: OAuth 2.0 – authorization code grant flow'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：OAuth 2.0 – 授权码授权流程
- en: 'Here’s what’s going on in this diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个图示中发生的事情：
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序通过将用户发送到授权服务器（在网页浏览器中）来启动授权流程。
- en: The authorization server will authenticate the user and ask for the user’s consent.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将验证用户并请求用户的同意。
- en: The authorization server will redirect the user back to the client application
    with an authorization code. The authorization server will use a **redirect URI**
    specified by the client in *step 1* to know where to send the authorization code.
    Since the authorization code is passed back to the client application using the
    web browser, that is, to an unsecure environment where malicious JavaScript code
    can potentially pick up the authorization code, it is only allowed to be used
    once and only during a short time period.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将用户重定向回客户端应用程序，并附带一个授权代码。授权服务器将使用客户端在 *步骤 1* 中指定的**重定向 URI**来确定发送授权代码的位置。由于授权代码是通过网页浏览器返回给客户端应用程序的，即在一个可能存在恶意
    JavaScript 代码潜在获取授权代码的不安全环境中，因此它只能使用一次，并且只能在短时间内使用。
- en: To exchange the authorization code for an access token, the client application
    is expected to call the authorization server again. The client application must
    present its client ID and client secret together with the authorization code for
    the authorization server. Since the client secret is sensitive and must be protected,
    this call must be executed from server-side code.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将授权代码交换为访问令牌，客户端应用程序需要再次调用授权服务器。客户端应用程序必须向授权服务器出示其客户端 ID、客户端密钥以及授权代码。由于客户端密钥是敏感信息且必须受到保护，此调用必须从服务器端代码执行。
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器发放访问令牌并将其发送回客户端应用程序。授权服务器还可以选择性地发放并返回一个刷新令牌。
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌，客户端可以向资源服务器公开的保护 API 发送请求。
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. *Steps 6* and *7* can be repeated as long as
    the access token is valid. When the lifetime of the access token has expired,
    the client can use their refresh token to acquire a new access token.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器验证访问令牌，在验证成功的情况下提供服务。*步骤 6* 和 *步骤 7* 可以在访问令牌有效的情况下重复进行。当访问令牌的生命周期已过期时，客户端可以使用其刷新令牌来获取一个新的访问令牌。
- en: '**Implicit grant flow**: This flow is also web browser-based but intended for
    client applications that are not able to keep a client secret protected, for example,
    a single-page web application. The web browser gets an access token back from
    the authorization server instead of an authorization code. Since the implicit
    grant flow is less secure than the authorization code grant flow, the client can’t
    request a refresh token.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式授权流程**：这个流程也是基于网页浏览器的，但旨在用于无法保护客户端密钥的客户端应用程序，例如单页网页应用程序。网页浏览器从授权服务器获取访问令牌，而不是授权代码。由于隐式授权流程比授权代码授权流程安全性较低，客户端无法请求刷新令牌。'
- en: '**Resource owner password credentials grant flow**: If a client application
    can’t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者密码凭证授权流程**：如果客户端应用程序无法与网页浏览器交互，它可以回退到这个授权流程。在这个授权流程中，用户必须与客户端应用程序共享其凭证，客户端应用程序将使用这些凭证来获取访问令牌。'
- en: '**Client credentials grant flow**: In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端凭证授权流程**：在客户端应用程序需要调用与特定用户无关的 API 的情况下，它可以使用此授权流程，通过其自己的客户端 ID 和客户端密钥来获取访问令牌。'
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).
    One additional specification that is worth some extra attention is *RFC 7636 –
    Proof Key for Code Exchange by OAuth Public Clients* (or **PKCE** for short),
    [https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完整规范可在此处找到：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)。还有许多其他规范详细说明了OAuth
    2.0的各个方面；欲了解概述，请参阅[https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)。一个值得额外关注的规定是*RFC
    7636 – OAuth公共客户端的代码交换证明密钥*（简称**PKCE**），[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636)。
- en: This specification describes how an otherwise unsecure public client, such as
    a mobile native app or desktop application, can utilize the authorization code
    grant flow in a secure way by adding an extra layer of security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范描述了如何通过添加额外的安全层，以安全的方式利用授权代码授权流程，使原本不安全的公共客户端，如移动原生应用或桌面应用程序，能够安全地使用该授权流程。
- en: 'The OAuth 2.0 specification was published in 2012, and over the years, a lot
    of lessons have been learned about what works and what does not. In 2019, work
    began to establish OAuth 2.1, consolidating all the best practices and experiences
    from using OAuth 2.0\. A draft version can be found here: [https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范于2012年发布，多年来，人们从OAuth 2.0的使用中吸取了许多经验教训。2019年，开始建立OAuth 2.1，整合了OAuth
    2.0使用中的所有最佳实践和经验。草稿版本可在此处找到：[https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08)。
- en: 'In my opinion, the most important improvements in OAuth 2.1 are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，OAuth 2.1最重要的改进是：
- en: PKCE is integrated into the authorization code grant flow. The use of PKCE will
    be required by public clients to improve their security, as described above. For
    confidential clients, where the authorization server can verify their credentials,
    the use of PKCE is not required, only recommended.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PKCE已集成到授权代码授权流程中。如上所述，公共客户端将需要使用PKCE来提高其安全性。对于授权服务器可以验证其凭证的机密客户端，PKCE的使用不是必需的，但建议使用。
- en: The implicit grant flow is deprecated and omitted from the specification, due
    to its less secure nature.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其安全性较低，隐式授权流程已被弃用，并从规范中省略。
- en: The resource owner password credentials grant flow is also deprecated and omitted
    from the specification, for the same reasons.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证授权流程也被弃用，并从规范中省略，原因相同。
- en: Given the direction in the upcoming OAuth 2.1 specification, we will only use
    the authorization code grant flow and the client credentials grant flow in this
    book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于即将发布的OAuth 2.1规范的方向，我们将在本书中仅使用授权代码授权流程和客户端凭证授权流程。
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the client credentials grant flow is very handy since it doesn’t require manual
    interaction using a web browser. We will use this grant flow later on in this
    chapter with our test script; see the *Changes in the test script* section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到对由OAuth 2.0保护的API进行自动化测试时，客户端凭证授权流程非常方便，因为它不需要使用网络浏览器进行手动交互。我们将在本章后面的测试脚本中使用此授权流程；请参阅*测试脚本中的更改*部分。
- en: Introducing OpenID Connect
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍OpenID Connect
- en: OpenID Connect (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect（缩写为**OIDC**），正如之前提到的，是OAuth 2.0的一个附加组件，它使客户端应用程序能够验证用户的身份。OIDC增加了一个额外的令牌，即ID令牌，客户端应用程序在完成授权流程后从授权服务器获取该令牌。
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating its digital signature using
    public keys from the authorization server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ID令牌被编码为**JSON Web Token**（**JWT**），并包含多个声明，例如用户的ID和电子邮件地址。ID令牌使用JSON Web签名进行数字签名。这使得客户端应用程序可以通过使用授权服务器的公钥验证其数字签名来信任ID令牌中的信息。
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory, according to the specification. Also important,
    OIDC defines a **discovery endpoint**, which is a standardized way to establish
    URLs to important endpoints, such as requesting authorization codes and tokens
    or getting the public keys to verify a digitally signed JWT. Finally, it also
    defines a **user-info endpoint**, which can be used to get extra information about
    an authenticated user given an access token for that user.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，访问令牌也可以像ID令牌一样进行编码和签名，但根据规范，这不是强制的。同样重要的是，OIDC定义了一个**发现端点**，这是一种标准化的方式来建立到重要端点的URL，例如请求授权代码和令牌或获取公钥以验证数字签名的JWT。最后，它还定义了一个**用户信息端点**，可以使用该端点获取有关给定用户的访问令牌的额外信息。
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用规范的概述，请参阅[https://openid.net/developers/specs/](https://openid.net/developers/specs/)。
- en: In this book, we will only use authorization servers that comply with the OpenID
    Connect specification. This will simplify the configuration of resource servers
    by the use of their discovery endpoints. We will also use the optional support
    for digitally signed JWT access tokens to simplify how resource servers can verify
    the authenticity of the access tokens. See the *Changes in both the edge server
    and the product-composite service* section below.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只使用符合OpenID Connect规范的授权服务器。这将通过使用它们的发现端点简化资源服务器的配置。我们还将使用对数字签名JWT访问令牌的可选支持来简化资源服务器验证访问令牌真实性的方式。请参阅下文中的*边缘服务器和产品组合服务的变化*部分。
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    Later on in this chapter, we will learn more about how to use these standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对OAuth 2.0和OpenID Connect标准的介绍。在本章的稍后部分，我们将了解如何使用这些标准。在下一节中，我们将从高层次了解系统景观将如何得到保护。
- en: Securing the system landscape
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护系统景观
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保本章引言中描述的系统景观安全，我们将执行以下步骤：
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HTTPS加密对我们外部API的外部请求和响应，以防止窃听。
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对访问我们的API的用户和客户端应用程序进行身份验证和授权。
- en: Secure access to the discovery server, Netflix Eureka, using HTTP basic authentication.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HTTP基本身份验证保护对发现服务器Netflix Eureka的访问。
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只为与边缘服务器的外部通信应用HTTPS，而在系统景观内部通信时使用纯HTTP。
- en: In the chapter on service meshes (*Chapter 18*, *Using a Service Mesh to Improve
    Observability and Management*) that will appear later in this book, we will see
    how we can get help from a service mesh product to automatically provision HTTPS
    to secure communication inside a system landscape.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书稍后出现的关于服务网格的章节（第18章，*使用服务网格提高可观察性和管理*）中，我们将看到如何从服务网格产品中获得帮助，以自动配置HTTPS来保护系统景观内的通信。
- en: For test purposes, we will add a local OAuth 2.0 authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the `product-composite`
    service will act as OAuth 2.0 resource servers; that is, they will require a valid
    OAuth 2.0 access token to allow access.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将在系统景观中添加一个本地的OAuth 2.0授权服务器。所有与授权服务器的外部通信将通过边缘服务器路由。边缘服务器和`product-composite`服务将作为OAuth
    2.0资源服务器；也就是说，它们将需要有效的OAuth 2.0访问令牌才能允许访问。
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWTs and that the authorization server exposes an endpoint
    that the resource servers can use to access the public keys, also known as a **JSON
    Web Key Set**, or **jwk-set** for short, required to validate the signing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化验证访问令牌的开销，我们假设它们被编码为签名JWT，并且授权服务器公开了一个端点，资源服务器可以使用该端点来访问公钥，也称为**JSON Web
    Key Set**，或简称**jwk-set**，这是验证签名所必需的。
- en: 'The system landscape will look like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 系统景观将如下所示：
- en: '![Diagram  Description automatically generated](img/B19825_11_02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_11_02.png)'
- en: 'Figure 11.2: Adding an authorization server to the system landscape'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：将授权服务器添加到系统景观
- en: 'From the preceding diagram, we can note that:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以注意到：
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS用于外部通信，而纯文本HTTP用于系统景观内部。
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地OAuth 2.0授权服务器将通过边缘服务器从外部访问。
- en: Both the edge server and the `product-composite` microservice will validate
    access tokens as signed JWTs.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器和`product-composite`微服务都将验证访问令牌作为已签名的JWT。
- en: The edge server and the `product-composite` microservice will get the authorization
    server’s public keys from its `jwk-set` endpoint and use them to validate the
    signature of the JWT-based access tokens.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器和`product-composite`微服务将从其`jwk-set`端点获取授权服务器的公钥，并使用它们来验证基于JWT的访问令牌的签名。
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the **OWASP Top Ten Project**. Refer
    to [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    for more information.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将专注于通过HTTP保护对API的访问，而不是涵盖一般性的最佳实践，例如，管理由**OWASP Top Ten项目**指出的Web应用程序安全风险。有关更多信息，请参阅[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)。
- en: With this overview of how the system landscape will be secured, let’s start
    to see how we can protect external communication from eavesdropping using HTTPS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了系统景观如何被保护之后，让我们看看我们如何可以使用HTTPS保护外部通信免受窃听。
- en: Protecting external communication with HTTPS
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example, from the internet, via the public APIs exposed by the edge server.
    We will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何防止外部通信（例如，从互联网，通过边缘服务器公开的公共API）被窃听。我们将使用HTTPS来加密通信。要使用HTTPS，我们需要执行以下操作：
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建证书**：我们将创建自己的自签名证书，这对于开发目的来说是足够的。'
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置边缘服务器**：它必须配置为仅接受使用证书的基于HTTPS的外部流量。'
- en: 'The self-signed certificate is created with the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建自签名证书：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code comes with a sample certificate file, so you don’t need to run
    this command to run the following examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码附带一个示例证书文件，因此您不需要运行此命令来运行以下示例。
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath at runtime at `keystore/edge.p12`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求输入多个参数。当要求输入密码时，我输入了`password`。对于其余的参数，我简单地输入了一个空值以接受默认值。创建的证书文件`edge.p12`被放置在`gateway`项目的`src/main/resources/keystore`文件夹中。这意味着证书文件将在构建时放置在`.jar`文件中，并在运行时在`keystore/edge.p12`的类路径上可用。
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    See the *Replacing a self-signed certificate at runtime* section below for how
    we can replace this certificate with an external certificate at runtime!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间，使用类路径提供证书是足够的，但不适用于其他环境，例如，生产环境。下面将说明如何在运行时使用外部证书替换此证书！
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置边缘服务器使用证书和HTTPS，以下内容被添加到`gateway`项目的`application.yml`中：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some notes from the preceding source code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的源代码中的一些注意事项：
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to `classpath:keystore/edge.p12`. This means that the certificate will
    be picked up on the classpath from the location `keystore/edge.p12`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的路径由`server.ssl.key-store`参数指定，并设置为`classpath:keystore/edge.p12`。这意味着证书将从`keystore/edge.p12`的位置在类路径中检索。
- en: The password for the certificate is specified in the `server.ssl.key-store-password`
    parameter.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的密码指定在`server.ssl.key-store-password`参数中。
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了表明边缘服务器使用HTTPS而不是HTTP，我们还将在`server.port`参数中将端口从`8080`更改为`8443`。
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol, replacing
    `HTTP` with `HTTPS` and `8080` with `8443`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在边缘服务器中的这些更改外，还需要在以下文件中进行更改，以反映端口和HTTP协议的更改，将`HTTP`替换为`HTTPS`，将`8080`替换为`8443`：
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件，`docker-compose*.yml`
- en: The test script, `test-em-all.bash`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本，`test-em-all.bash`
- en: Providing certificates using the classpath is, as mentioned previously, only
    sufficient during development. Let’s see how we can replace this certificate with
    an external certificate at runtime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用类路径提供证书仅适用于开发阶段。让我们看看我们如何在运行时用外部证书替换此证书。
- en: Replacing a self-signed certificate at runtime
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时替换自签名证书
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.jar`文件中放置自签名证书仅对开发有用。对于运行时环境中的工作解决方案，例如测试或生产，必须能够使用由授权**CA**（简称**证书颁发机构**）签名的证书。
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the external certificate in the Docker volume.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 必须也能够在运行时指定要使用的证书，而无需重新构建`.jar`文件，当使用Docker时，包含`.jar`文件的Docker镜像。当使用Docker Compose管理Docker容器时，我们可以将Docker容器中的卷映射到Docker主机上的证书。我们还可以为Docker容器设置环境变量，指向Docker卷中的外部证书。
- en: In *Chapter 15*, *Introduction to Kubernetes*, we will learn about Kubernetes,
    where we will see more powerful solutions for how to handle secrets, such as certificates,
    that are suitable for running Docker containers in a cluster; that is, where containers
    are scheduled on a group of Docker hosts and not on a single Docker host.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第15章*，*Kubernetes简介*中，我们将学习Kubernetes，我们将看到如何处理秘密，如证书，这些秘密适合在集群中运行Docker容器；也就是说，容器是在一组Docker主机上而不是在单个Docker主机上调度。
- en: The changes described in this topic have **not** been applied to the source
    code in the book’s GitHub repository; you need to make them yourself to see them
    in action!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改尚未应用于书中GitHub仓库的源代码；您需要自行进行更改才能看到其效果！
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换打包在`.jar`文件中的证书，请执行以下步骤：
- en: 'Create a second certificate and set the password to `testtest` when asked for
    it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个证书，并在被要求时将其密码设置为`testtest`：
- en: '[PRE2]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location, the password for the new certificate, and a volume that maps
    to the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Docker Compose文件，`docker-compose.yml`，包含位置环境变量、新证书的密码以及映射到放置新证书的文件夹的卷。更改后边缘服务器的配置如下：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边缘服务器正在运行，则需要使用以下命令重新启动：
- en: '[PRE4]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the gateway service, but it actually does not take changes in `docker-compose.yml`
    into consideration. Hence, it is not a useful command in this case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose restart gateway`命令可能看起来是重启网关服务的良好候选，但实际上它没有考虑`docker-compose.yml`中的更改。因此，在这种情况下，它不是一个有用的命令。'
- en: The new certificate is now in use!
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的证书现在正在使用中！
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section, we will learn how to secure access to the discovery server,
    Netflix Eureka, using HTTP Basic authentication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于如何使用HTTPS保护外部通信的内容到此结束。在下一部分，我们将学习如何使用HTTP基本认证来保护发现服务器，Netflix Eureka的访问。
- en: Securing access to the discovery server
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护发现服务器访问
- en: Previously, we learned how to protect external communication with HTTPS. Now
    we will use HTTP Basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka. This means that we will require a user
    to supply a username and password to get access. Changes are required both on
    the Eureka server and in the Eureka clients, described as follows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何使用HTTPS保护外部通信。现在我们将使用HTTP基本认证来限制对发现服务器Netflix Eureka上的API和网页的访问。这意味着我们需要用户提供一个用户名和密码来获取访问权限。需要在Eureka服务器和Eureka客户端上进行更改，具体如下。
- en: Changes in the Eureka server
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eureka服务器的更改
- en: 'To protect the Eureka server, the following changes have been applied to the
    source code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护Eureka服务器，以下更改已应用于源代码：
- en: 'In `build.gradle`, a dependency has been added for Spring Security:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.gradle`中添加了对Spring Security的依赖项：
- en: '[PRE5]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Security configuration has been added to the `SecurityConfig` class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已将安全配置添加到`SecurityConfig`类中：
- en: 'The user is defined as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户定义如下：
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`username`和`password`从配置文件注入到构造函数中：'
- en: '[PRE7]'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All APIs and web pages are protected using HTTP Basic authentication by means
    of the following definition:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有API和网页都通过以下定义使用HTTP基本认证进行保护：
- en: '[PRE8]'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户凭证在配置文件`application.yml`中设置：
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the test class, `EurekaServerApplicationTests`, uses the credentials
    from the configuration file when testing the APIs of the Eureka server:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试类`EurekaServerApplicationTests`在测试Eureka服务器的API时使用配置文件中的凭证：
- en: '[PRE10]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The above are the steps required for restricting access to the APIs and web
    pages of the discovery server, Netflix Eureka. It will now use HTTP Basic authentication
    and require a user to supply a username and password to get access. The last step
    is to configure Netflix Eureka clients so that they pass credentials when accessing
    the Netflix Eureka server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是限制对发现服务器Netflix Eureka的API和网页访问所需的步骤。现在它将使用HTTP基本认证，并要求用户提供用户名和密码来获取访问权限。最后一步是配置Netflix
    Eureka客户端，以便在访问Netflix Eureka服务器时传递凭证。
- en: Changes in Eureka clients
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eureka客户端的更改
- en: 'For Eureka clients, the credentials can be specified in the connection URL
    for the Eureka server. This is specified in each client’s configuration file,
    `application.yml`, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eureka客户端，凭证可以指定在Eureka服务器的连接URL中。这在每个客户端的配置文件`application.yml`中指定，如下所示：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the *Testing the protected discovery server* section, we will run tests to
    verify that the access is protected. In the next section, we will learn how to
    add a local authorization server to the system landscape.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于如何限制对Netflix Eureka服务器访问的内容到此结束。在*测试受保护的发现服务器*部分，我们将运行测试以验证访问是否受到保护。在下一部分，我们将学习如何将本地授权服务器添加到系统架构中。
- en: Adding a local authorization server
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加本地授权服务器
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an authorization server that is
    compliant with these specifications to our system landscape. Historically, Spring
    Security has not provided an authorization server out of the box. But in April
    2020, a community-driven project, **Spring Authorization Server**, led by the
    Spring Security team, was announced with the goal of delivering an authorization
    server. In August 2021, the Spring Authorization Server project was moved out
    of experimental status and became a member of the Spring project’s portfolio.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用OAuth 2.0和OpenID Connect安全使用的API在本地和完全自动化地运行测试，我们将添加一个符合这些规范的授权服务器到我们的系统景观中。历史上，Spring
    Security没有提供开箱即用的授权服务器。但在2020年4月，由Spring Security团队领导的一个社区驱动项目，**Spring Authorization
    Server**，宣布旨在提供授权服务器。到2021年8月，Spring Authorization Server项目从实验状态移出，成为Spring项目组合的一部分。
- en: For more information, see [https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server](https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server)
    and [https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects](https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server](https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server)和[https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects](https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects)。
- en: The Spring Authorization Server supports both the use of the OpenID Connect
    discovery endpoint and the digital signing of access tokens. It also provides
    an endpoint that can be accessed using the discovery information to get keys for
    verifying the digital signature of a token. With support for these features, it
    can be used as the authorization server in local and automated tests that verify
    that the system landscape works as expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Authorization Server支持使用OpenID Connect发现端点和访问令牌的数字签名。它还提供了一个端点，可以使用发现信息访问以获取验证令牌数字签名的密钥。有了这些功能的支持，它可以作为本地和自动测试中的授权服务器使用，以验证系统景观按预期工作。
- en: The authorization server in this book is based on the sample authorization server
    provided by the Spring Authorization Server project; see [https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver](https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的授权服务器基于Spring Authorization Server项目提供的示例授权服务器；请参阅[https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver](https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver)。
- en: 'The following changes have been applied to the sample project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对示例项目已应用以下更改：
- en: The build file has been updated to follow the structure of the other projects’
    build files in this book.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建文件已更新，以遵循本书中其他项目的构建文件结构。
- en: The port is set to `9999`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口已设置为`9999`。
- en: A Dockerfile has been added with the same structure as for the other projects
    in this book.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加与本书中其他项目相同的结构的Dockerfile。
- en: The authorization server has been integrated with Eureka for service discovery
    in the same way as the other projects in this book.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器已与Eureka集成，以实现与本书中其他项目相同的服务发现方式。
- en: Public access has been added to the actuator’s endpoints.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加对actuator端点的公共访问。
- en: '**WARNING**: As already warned about in *Chapter 7*, *Developing Reactive Microservices*,
    allowing public access to the actuator’s endpoints is very helpful during development,
    but it can be a security issue to reveal too much information in actuator endpoints
    in production systems. Therefore, plan for minimizing the information exposed
    by the actuator endpoints in production!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：正如在*第7章*，*开发响应式微服务*中已警告的那样，允许公共访问actuator的端点在开发期间非常有帮助，但在生产系统中透露过多信息可能会成为安全问题。因此，计划最小化生产中actuator端点暴露的信息！'
- en: Unit tests have been added that verify access to the most critical endpoints
    according to the OpenID Connect specification.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加单元测试，以验证根据OpenID Connect规范对最关键端点的访问。
- en: The username and password for the single registered user are set to `u` and
    `p`, respectively.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个注册用户的用户名和密码分别设置为`u`和`p`。
- en: Two OAuth clients are registered, `reader` and `writer`. The `reader` client
    is granted a `product:read` scope, and the `writer` client is granted both a `product:read`
    and `product:write` scope. The clients are configured to have their client secret
    set to `secret-reader` and `secret-writer`, respectively.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册两个 OAuth 客户端，`reader` 和 `writer`。`reader` 客户端被授予 `product:read` 范围，而 `writer`
    客户端被授予 `product:read` 和 `product:write` 范围。客户端被配置为将它们的客户端密钥设置为 `secret-reader`
    和 `secret-writer`。
- en: Allowed redirect URIs for the clients are set to `https://my.redirect.uri` and
    `https://localhost:8443/webjars/swagger-ui/oauth2-redirect.html`. The first URI
    will be used in the tests described below, and the second URI will be used by
    the Swagger UI component.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的允许重定向 URI 设置为 `https://my.redirect.uri` 和 `https://localhost:8443/webjars/swagger-ui/oauth2-redirect.html`。下面的测试中将使用第一个
    URI，Swagger UI 组件将使用第二个 URI。
- en: By default, for security reasons, the authorization server does not allow redirect
    URIs that start with `https://localhost`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，出于安全原因，授权服务器不允许以 `https://localhost` 开头的重定向 URI。
- en: 'The authorization server has been customized to accept `https://localhost`
    for development and testing purposes. The applied customization is described here:
    [https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation](https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器已被定制以接受 `https://localhost` 用于开发和测试目的。所应用的定制在此处描述：[https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation](https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation)。
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器的源代码可在 `$BOOK_HOME/Chapter11/spring-cloud/authorization-server` 中找到。
- en: 'To incorporate the authorization server in the system landscape, changes to
    the following files have been applied:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要将授权服务器纳入系统架构，以下文件已应用了更改：
- en: The server has been added to the common build file, `settings.gradle`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器已被添加到通用构建文件中，`settings.gradle`。
- en: The server has been added to the three Docker Compose files, `docker-compose*.yml`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器已被添加到三个 Docker Compose 文件中，`docker-compose*.yml`。
- en: The edge server, `spring-cloud/gateway`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器，`spring-cloud/gateway`。
- en: A health check has been added for the authorization server in `HealthCheckConfiguration`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `HealthCheckConfiguration` 中为授权服务器添加了健康检查。
- en: Routes to the authorization server for the URIs starting with `/oauth`, `/login`,
    and `/error` have been added in the configuration file, `application.yml`. These
    URIs are used to issue tokens for clients, authenticate users, and show error
    messages.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置文件 `application.yml` 中已添加指向以 `/oauth`、`/login` 和 `/error` 开头的 URI 的授权服务器路由。这些
    URI 用于向客户端颁发令牌、验证用户和显示错误消息。
- en: Since these three URIs need to be unprotected by the edge server, they are configured
    in the new class `SecurityConfig` to permit all requests.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这三个 URI 需要由边缘服务器进行保护，因此它们被配置在新类 `SecurityConfig` 中以允许所有请求。
- en: With an understanding of how a local authorization server is added to the system
    landscape, let’s move on and see how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何将本地授权服务器添加到系统架构之后，让我们继续看看如何使用 OAuth 2.0 和 OpenID Connect 来验证和授权对 API 的访问。
- en: Protecting APIs using OAuth 2.0 and OpenID Connect
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth 2.0 和 OpenID Connect 保护 API
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service to become OAuth 2.0 resource servers, so that
    they will require a valid access token to allow access. The edge server will be
    configured to accept any access token it can validate using the digital signature
    provided by the authorization server. The `product-composite` service will also
    require the access token to contain valid OAuth 2.0 scopes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好授权服务器之后，我们可以增强边缘服务器和 `product-composite` 服务以成为 OAuth 2.0 资源服务器，这样它们将需要有效的访问令牌才能允许访问。边缘服务器将被配置为接受授权服务器提供的数字签名验证的任何访问令牌。`product-composite`
    服务也将需要访问令牌包含有效的 OAuth 2.0 范围：
- en: The `product:read` scope will be required for accessing the read-only APIs.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product:read` 范围将用于访问只读 API。'
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product:write` 范围将用于访问创建和删除 API。'
- en: The `product-composite` service will also be enhanced with a configuration that
    allows its Swagger UI component to interact with the authorization server to issue
    an access token. This will allow users of the Swagger UI web page to test the
    protected API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite` 服务也将通过一个配置进行增强，允许其 Swagger UI 组件与授权服务器交互以颁发访问令牌。这将允许 Swagger
    UI 网页的用户测试受保护的 API。'
- en: We also need to enhance the test script, `test-em-all.bash`, so that it acquires
    access tokens and uses them when it performs the tests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要增强测试脚本 `test-em-all.bash`，以便在执行测试时获取访问令牌并使用它们。
- en: Changes in both the edge server and the product-composite service
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘服务器和产品组合服务的更改
- en: 'The following changes have been applied in the source code for both the edge
    server and the `product-composite` service:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，对边缘服务器和 `product-composite` 服务都应用了以下更改：
- en: 'Spring Security dependencies have been added to `build.gradle` to support OAuth
    2.0 resource servers:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 依赖项已添加到 `build.gradle` 文件中，以支持 OAuth 2.0 资源服务器：
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Security configurations have been added to new `SecurityConfig` classes in
    both projects:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个项目中都添加了新的 `SecurityConfig` 类的安全配置：
- en: '[PRE13]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Explanations for the preceding source code are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面源代码的解释：
- en: The `@EnableWebFluxSecurity` annotation enables Spring Security support for
    APIs based on Spring WebFlux.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableWebFluxSecurity` 注解启用了基于 Spring WebFlux 的 API 的 Spring Security 支持。'
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow unrestricted access
    to URLs that should be unprotected, for example, the `actuator` endpoints, in
    this case. Refer to the source code for URLs that are treated as unprotected.
    Be careful about which URLs are exposed unprotected. For example, the `actuator`
    endpoints should be protected before going to production.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pathMatchers("/actuator/**").permitAll()` 用于允许对应该不受保护的 URL 的无限制访问，例如，在本例中的
    `actuator` 端点。请参阅源代码以了解被视为不受保护的 URL。小心选择哪些 URL 不受保护。例如，在投入生产之前，应保护 `actuator`
    端点。'
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.anyExchange().authenticated()` 确保用户在允许访问所有其他 URL 之前已进行身份验证。'
- en: '`.oauth2ResourceServer().jwt()` specifies that authorization will be based
    on OAuth 2.0 access tokens encoded as JWTs.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.oauth2ResourceServer().jwt()` 指定授权将基于编码为 JWT 的 OAuth 2.0 访问令牌。'
- en: 'The authorization server’s OIDC discovery endpoint has been registered in the
    configuration file, `application.yml`:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器的 OIDC 发现端点已在配置文件 `application.yml` 中注册：
- en: '[PRE14]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: L
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: L
- en: 'Later on in this chapter, when the system landscape is started up, you can
    test the discovery endpoint. You can, for example, find the endpoint that returns
    the keys required for verifying the digital signature of a token using this command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，当系统景观启动时，您可以测试发现端点。例如，您可以使用以下命令找到返回用于验证令牌数字签名的密钥的端点：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to make some changes that only apply to the `product-composite`
    service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对仅适用于 `product-composite` 服务的某些更改。
- en: Changes in the product-composite service only
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅在产品组合服务中进行的更改
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中应用的常见更改外，以下更改也已应用于 `product-composite` 服务：
- en: 'The security configuration in the `SecurityConfig` class has been refined by
    requiring OAuth 2.0 scopes in the access token in order to allow access:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityConfig` 类中的安全配置已通过要求访问令牌中的 OAuth 2.0 范围来细化，以便允许访问：'
- en: '[PRE16]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By convention, OAuth 2.0 scopes need to be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，当使用 Spring Security 检查权限时，OAuth 2.0 范围需要以 `SCOPE_` 前缀开头。
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `ProductCompositeServiceImpl` class for details.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了一个方法 `logAuthorizationInfo()`，用于在每次调用 API 时记录 JWT 编码的访问令牌的相关部分。可以使用标准的 Spring
    Security `SecurityContext` 获取访问令牌，在反应式环境中，可以使用静态辅助方法 `ReactiveSecurityContextHolder.getContext()`
    获取。有关详细信息，请参阅 `ProductCompositeServiceImpl` 类。
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行基于Spring的集成测试时，已禁用OAuth的使用。为了防止在运行集成测试时OAuth机制启动，我们按以下方式禁用它：
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests. It permits access to all resources:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个安全配置`TestSecurityConfig`，用于测试期间使用。它允许访问所有资源：
- en: '[PRE17]'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Spring集成测试类中，我们配置`TestSecurityConfig`以覆盖现有的安全配置，如下所示：
- en: '[PRE18]'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Changes to allow Swagger UI to acquire access tokens
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许Swagger UI获取访问令牌的更改
- en: 'To allow access to the protected APIs from the Swagger UI component, the following
    changes have been applied in the `product-composite` service:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许从Swagger UI组件访问受保护的API，已在`product-composite`服务中应用以下更改：
- en: 'The web pages exposed by the Swagger UI component have been configured to be
    publicly available. The following line has been added to the `SecurityConfig`
    class:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Swagger UI组件暴露的网页已被配置为公开可用。以下行已添加到`SecurityConfig`类中：
- en: '[PRE19]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The OpenAPI Specification of the API has been enhanced to require that the security
    schema `security_auth` is applied.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的OpenAPI规范已被增强，要求应用安全模式`security_auth`。
- en: 'The following line has been added to the definition of the interface `ProductCompositeService`
    in the `API` project:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行已添加到`API`项目中接口`ProductCompositeService`的定义中：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To define the semantics of the security schema `security_auth`, the class `OpenApiConfig`
    has been added to the `product-composite` project. It looks like this:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了定义安全模式`security_auth`的语义，已在`product-composite`项目中添加了`OpenApiConfig`类。它看起来像这样：
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From the preceding class definition, we can see:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的类定义中，我们可以看到：
- en: The security schema will be based on OAuth 2.0.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全模式将基于OAuth 2.0。
- en: The authorization code grant flow will be used.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用授权代码授予流程。
- en: The required URLs for acquiring an authorization code and access tokens will
    be supplied by the configuration using the parameters `springdoc.oAuthFlow.authorizationUrl`
    and `springdoc.oAuthFlow.tokenUrl`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权代码和访问令牌所需的URL将由配置通过参数`springdoc.oAuthFlow.authorizationUrl`和`springdoc.oAuthFlow.tokenUrl`提供。
- en: A list of scopes (`product:read` and `product:write`) that Swagger UI will require
    to be able to call the APIs.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger UI将需要的一组作用域（`product:read`和`product:write`），以便能够调用API。
- en: 'Finally, some configuration is added to `application.yml`:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一些配置被添加到`application.yml`中：
- en: '[PRE22]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the preceding configuration, we can see:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，我们可以看到：
- en: The redirect URL that Swagger UI will use to acquire the authorization code.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger UI将使用该URL来获取授权代码的重定向URL。
- en: Its client ID and client secret.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其客户端ID和客户端密钥。
- en: It will use HTTP Basic authentication when identifying itself for the authorization
    server.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将使用HTTP基本认证来识别授权服务器。
- en: The values of the `authorizationUrl` and `tokenUrl` parameters, used by the
    `OpenApiConfig` class described above. Note that these URLs are used by the web
    browser and not by the `product-composite` service itself. So they must be resolvable
    from the web browser.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上文所述的`OpenApiConfig`类使用的`authorizationUrl`和`tokenUrl`参数的值。请注意，这些URL是由网络浏览器使用的，而不是由`product-composite`服务本身使用的。因此，它们必须可以从网络浏览器解析。
- en: 'To allow unprotected access to the Swagger UI web pages, the edge server has
    also been configured to allow unrestricted access to URLs that are routed to the
    Swagger UI component. The following is added to the edge server’s `SecurityConfig`
    class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许对Swagger UI网页的无保护访问，边缘服务器也已配置为允许对路由到Swagger UI组件的URL进行无限制访问。以下行被添加到边缘服务器的`SecurityConfig`类中：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers, and the Swagger UI component can
    act as an OAuth client. The last step we need to take to introduce the usage of
    OAuth 2.0 and OpenID Connect is to update the test script so it acquires access
    tokens and uses them when running the tests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，边缘服务器和`product-composite`服务都可以作为OAuth 2.0资源服务器，Swagger UI组件可以作为OAuth客户端。引入OAuth
    2.0和OpenID Connect使用的最后一步是更新测试脚本，以便在运行测试时获取访问令牌并使用它们。
- en: Changes in the test script
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试脚本的更改
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done, as already mentioned above, using
    the OAuth 2.0 client credentials flow. To be able to call the create and delete
    APIs, we acquire an access token as the `writer` client, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在调用任何API（除了健康API）之前获取一个访问令牌。这就像之前提到的那样，使用OAuth 2.0客户端凭据流来完成。为了能够调用创建和删除API，我们以`writer`客户端的身份获取一个访问令牌，如下所示：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the preceding command, we can see that it uses HTTP Basic authentication,
    passing its client ID and client secret as `writer:secret-writer@` before the
    hostname.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到它使用了HTTP基本认证，在主机名之前传递其客户端ID和客户端密钥作为`writer:secret-writer@`。
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证基于范围的授权是否工作，测试脚本中增加了两个测试：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The test script uses the reader client’s credentials to acquire an access token:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本使用读取器客户端的凭据来获取访问令牌：
- en: The first test calls an API without supplying an access token. The API is expected
    to return the `401 Unauthorized` HTTP status.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试在未提供访问令牌的情况下调用API。API预期将返回`401 Unauthorized` HTTP状态。
- en: The second test verifies that the reader client can call a read-only API.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试验证读取器客户端可以调用只读API。
- en: The last test calls an updating API using the `reader` client, which is only
    granted a `read` scope. A request sent to the delete API is expected to return
    the `403 Forbidden` HTTP status.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个测试调用了一个使用`reader`客户端的更新API，该客户端仅被授予`read`权限。向删除API发送的请求预期将返回`403 Forbidden`
    HTTP状态。
- en: For the full source code, see `test-em-all.bash`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请参阅`test-em-all.bash`。
- en: With the test script updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try it out in the next section!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本更新为获取和使用OAuth 2.0访问令牌后，我们就可以在下一节尝试它了！
- en: Testing with the local authorization server
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: 'In this section, we will try out the secured system landscape; that is, we
    will test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试测试受保护的系统环境；也就是说，我们将一起测试所有安全组件。我们将使用本地授权服务器来颁发访问令牌。以下将执行以下测试：
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从源代码构建并运行测试脚本，以确保一切都能正常工作。
- en: Next, we will test the protected discovery server’s API and web page.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试受保护的发现服务器的API和网页。
- en: After that, we will learn how to acquire access tokens using OAuth 2.0 client
    credentials and authorization code grant flows.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将学习如何使用OAuth 2.0客户端凭据流和授权码授权流获取访问令牌。
- en: With the issued access tokens, we will test the protected APIs. We will also
    verify that an access token issued for a reader client can’t be used to call an
    updating API.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用颁发的访问令牌，我们将测试受保护的API。我们还将验证为读取器客户端颁发的访问令牌不能用于调用更新API。
- en: Finally, we will also verify that Swagger UI can issue access tokens and call
    the APIs.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还将验证Swagger UI是否可以颁发访问令牌并调用API。
- en: Building and running the automated tests
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行自动化测试
- en: 'To build and run automated tests, we perform the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行自动化测试，我们执行以下步骤：
- en: 'Build the Docker images from source with the following commands:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从源代码构建Docker镜像：
- en: '[PRE26]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the system landscape in Docker and run the usual tests with the following
    command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在Docker中启动系统环境并运行常规测试：
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the new negative tests at the end that verify that we get a `401 Unauthorized`
    code back when not authenticated, and `403 Forbidden` when not authorized.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的新的负面测试，验证在未认证时返回`401 Unauthorized`代码，在未授权时返回`403 Forbidden`。
- en: Testing the protected discovery server
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试受保护的发现服务器
- en: With the protected discovery server, Eureka, up and running, we have to supply
    valid credentials to be able to access its APIs and web pages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在受保护的发现服务器Eureka启动并运行后，我们必须提供有效的凭据才能访问其API和网页。
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command, where we supply the username and password
    directly in the URL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过以下`curl`命令请求Eureka服务器注册的实例，其中我们直接在URL中提供用户名和密码：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A sample response is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例响应如下：
- en: '![Text  Description automatically generated](img/B19825_11_03.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_11_03.png)'
- en: 'Figure 11.3: Services registered in Eureka using an API call'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：使用API调用在Eureka中注册的服务
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an unsecure connection, since our certificate is self-signed, and
    next, we have to supply valid credentials, as specified in the configuration file
    (`u` as username and `p` as password):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`https://localhost:8443/eureka/web`上的网页时，我们首先必须接受一个不安全的连接，因为我们的证书是自签名的，然后我们必须提供有效的凭据，如配置文件中指定的（`u`作为用户名，`p`作为密码）：
- en: '![Graphical user interface  Description automatically generated](img/B19825_11_04.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B19825_11_04.png)'
- en: 'Figure 11.4: Eureka requires authentication'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：Eureka需要身份验证
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，我们将看到来自Eureka服务器的熟悉网页：
- en: '![Table  Description automatically generated with medium confidence](img/B19825_11_05.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![表格  自动生成的中等置信度描述](img/B19825_11_05.png)'
- en: 'Figure 11.5: Services registered in Eureka using the web page'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：使用网页注册到Eureka的服务
- en: After ensuring that access to the Eureka server is protected, we will learn
    how to issue OAuth access tokens.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保对Eureka服务器的访问受保护后，我们将学习如何颁发OAuth访问令牌。
- en: Acquiring access tokens
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: Now we are ready to acquire access tokens using grant flows defined by OAuth
    2.0\. We will first try out the client credentials grant flow, followed by the
    authorization code grant flow.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用OAuth 2.0定义的授权流程获取访问令牌。我们首先将尝试客户端凭证授权流程，然后是授权码授权流程。
- en: Acquiring access tokens using the client credentials grant flow
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用客户端凭证授权流程获取访问令牌
- en: 'To get an access token for the `writer` client, that is, with both the `product:read`
    and `product:write` scopes, issue the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`writer`客户端获取访问令牌，即具有`product:read`和`product:write`作用域，执行以下命令：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The client identifies itself using HTTP Basic authentication, passing its client
    ID, `writer`, and its client secret, `secret`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用HTTP基本身份验证来识别自己，传递其客户端ID，`writer`，以及其客户端密钥，`secret`。
- en: 'A sample response is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![Text  Description automatically generated](img/B19825_11_06.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_11_06.png)'
- en: 'Figure 11.6: Sample token response'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：示例令牌响应
- en: 'From the screenshot, we can see that we got the following information in the
    response:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从截图我们可以看到，在响应中我们得到了以下信息：
- en: The access token itself.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌本身。
- en: The scopes granted to the token. The `writer` client is granted both the `product:write`
    and `product:read` scope. It is also granted the `openid` scope, allowing access
    to information regarding the user’s ID, such as an email address.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予令牌的作用域。`writer`客户端被授予`product:write`和`product:read`作用域。它还被授予`openid`作用域，允许访问有关用户ID的信息，例如电子邮件地址。
- en: The type of token we got; `Bearer` means that the bearer of this token should
    be given access according to the scopes granted to the token.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获得的令牌类型；`Bearer`表示持有此令牌的人应根据授予令牌的作用域获得访问权限。
- en: The number of seconds that the access token is valid, `3599` seconds in this
    case.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌的有效秒数，在本例中为`3599`秒。
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command, resulting
    in:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`reader`客户端获取访问令牌，即只有`product:read`作用域，只需在先前的命令中将`writer`替换为`reader`，结果如下：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Acquiring access tokens using the authorization code grant flow
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用授权码授权流程获取访问令牌
- en: To acquire an access token using the authorization code grant flow, we need
    to involve a web browser. This grant flow is a bit more complicated in order to
    make it secure in an environment that is partly unsecure (the web browser).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用授权码授权流程获取访问令牌，我们需要涉及一个网络浏览器。这个授权流程在部分不安全的环境（网络浏览器）中要复杂一些，以便使其更安全。
- en: In the first unsecure step, we will use the web browser to acquire an authorization
    code that can be used only once, to be exchanged for an access token. The authorization
    code will be passed from the web browser to a secure layer, for example, server-side
    code, which can make a new request to the authorization server to exchange the
    authorization code for an access token. In this secure exchange, the server has
    to supply a client secret to verify its identity.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个不安全的步骤中，我们将使用网络浏览器获取一个只能使用一次的授权码，以交换访问令牌。授权码将从网络浏览器传递到一个安全层，例如服务器端代码，它可以向授权服务器发出新的请求以交换授权码为访问令牌。在这个安全交换中，服务器必须提供一个客户端密钥来验证其身份。
- en: 'Perform the following steps to execute the authorization code grant flow:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以执行授权码授权流程：
- en: 'To get an authorization code for the `reader` client, use the following URL
    in a web browser that accepts the use of self-signed certificates, for example,
    Chrome: `https://localhost:8443/oauth2/authorize?response_type=code&client_id=reader&redirect_uri=https://my.redirect.uri&scope=product:read&state=35725`.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为 `reader` 客户端获取授权码，请在接受自签名证书使用的网页浏览器中输入以下 URL，例如 Chrome：`https://localhost:8443/oauth2/authorize?response_type=code&client_id=reader&redirect_uri=https://my.redirect.uri&scope=product:read&state=35725`。
- en: 'When asked to log in by the web browser, use the credentials specified in the
    configuration of the authorization server, `u` and `p`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当网页浏览器要求登录时，使用授权服务器配置中指定的凭据，即 `u` 和 `p`：
- en: '![Graphical user interface  Description automatically generated](img/B19825_11_07.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B19825_11_07.png)'
- en: 'Figure 11.7: Trying out the authorization code grant flow'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：尝试授权码授权流程
- en: 'We will be asked to give the `reader` client consent to call the APIs in our
    name:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将被要求为 `reader` 客户端同意以我们的名义调用 API：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_08.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B19825_11_08.png)'
- en: 'Figure 11.8: Authorization code grant flow consent page'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：授权码授权流程同意页面
- en: 'After clicking on the **Submit Consent** button, we will get the following
    response:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **提交同意** 按钮后，我们将得到以下响应：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_11_09.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_11_09.png)'
- en: 'Figure 11.9: Authorization code grant flow redirect page'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：授权码授权流程重定向页面
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初看可能有点失望。授权服务器发送回网页浏览器的 URL 是基于客户端在初始请求中指定的重定向 URI。将 URL 复制到文本编辑器中，你会找到类似以下的内容：
- en: '`https://my.redirect.uri/?code=7XBs...0mmyk&state=35725`'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`https://my.redirect.uri/?code=7XBs...0mmyk&state=35725`'
- en: 'Great! We can find the authorization code in the redirect URL in the `code`
    request parameter. Extract the authorization code from the `code` parameter and
    define an environment variable, `CODE`, with its value:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！我们可以在重定向 URL 的 `code` 请求参数中找到授权码。从 `code` 参数中提取授权码，并定义一个环境变量 `CODE`，其值为：
- en: '[PRE31]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Pretend you are the backend server that exchanges the authorization code with
    an access token using the following `curl` command:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你是后端服务器，使用以下 `curl` 命令交换授权码和访问令牌：
- en: '[PRE32]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A sample response is as follows:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![Text  Description automatically generated](img/B19825_11_10.png)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_11_10.png)'
- en: 'Figure 11.10: Authorization code grant flow access token'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.10：授权码授权流程访问令牌
- en: 'From the screenshot, we can see that we got similar information in the response
    as we got from the client credentials flow, with the following exceptions:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从截图可以看出，我们得到的响应信息与客户端凭据流程中得到的类似，但有以下例外：
- en: Since we used a more secure grant flow, we also got a `refresh token` issued
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用了更安全的授权流程，我们还获得了一个 `刷新令牌`
- en: Since we asked for an access token for the `reader` client, we only got a `product:read`
    scope, no `product:write` scope
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们请求了 `reader` 客户端的访问令牌，所以我们只得到了 `product:read` 范围，没有 `product:write` 范围
- en: 'To get an authorization code for the `writer` client, use the following URL:
    `https://localhost:8443/oauth2/authorize?response_type=code&client_id=writer&redirect_uri=https://my.redirect.uri&scope=product:read+product:write&state=72489`.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为 `writer` 客户端获取授权码，请使用以下 URL：`https://localhost:8443/oauth2/authorize?response_type=code&client_id=writer&redirect_uri=https://my.redirect.uri&scope=product:read+product:write&state=72489`。
- en: 'To exchange the code for an access token for the `writer` client, run the following
    command:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为 `writer` 客户端交换代码以获取访问令牌，请运行以下命令：
- en: '[PRE33]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Verify that the response now also contains the `product:write` scope!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 验证响应现在也包含 `product:write` 范围！
- en: Calling protected APIs using access tokens
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问令牌调用受保护 API
- en: Now, let’s use the access tokens we have acquired to call the protected APIs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们获得的访问令牌来调用受保护的 API。
- en: An OAuth 2.0 access token is expected to be sent as a standard HTTP `authorization`
    header, where the access token is prefixed with `Bearer`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 预期 OAuth 2.0 访问令牌将以标准 HTTP `authorization` 标头发送，其中访问令牌以 `Bearer` 为前缀。
- en: 'Run the following commands to call the protected APIs:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以调用受保护的 API：
- en: 'Call an API to retrieve a composite product without a valid access token:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有有效访问令牌的情况下调用 API 以检索复合产品：
- en: '[PRE34]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It should return the following response:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该返回以下响应：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_11_11.png)'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_11_11.png)'
- en: 'Figure 11.11: Invalid token results in a 401 Unauthorized response'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.11：无效令牌导致 401 未授权响应
- en: The error message clearly states that the access token is invalid!
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误信息清楚地表明访问令牌无效！
- en: 'Try using the API to retrieve a composite product using one of the access tokens
    acquired for the `reader` client from the previous section:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用之前章节中为 `reader` 客户端获取的其中一个访问令牌来检索复合产品：
- en: '[PRE35]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们将获得 `200 OK` 状态码，预期的响应体将被返回：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_11_12.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B19825_11_12.png)'
- en: 'Figure 11.12: Valid access token results in a 200 OK response'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：有效的访问令牌导致 200 OK 响应
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用为 `reader` 客户端获取的访问令牌访问一个正在更新的 API，例如删除 API，调用将失败：
- en: '[PRE36]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will fail with a response similar to the following:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将以类似以下响应失败：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_11_13.png)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B19825_11_13.png)'
- en: 'Figure 11.13: Insufficient scope results in a 403 Forbidden result'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.13：权限不足导致 403 禁止结果
- en: From the error response, it is clear that we are forbidden to call the API since
    the request requires higher privileges than what our access token is granted.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从错误响应中可以看出，我们被禁止调用 API，因为请求需要比我们的访问令牌所授予的更高权限。
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with `202 Accepted` in the response.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们重复调用删除 API，但使用为 `writer` 客户端获取的访问令牌，调用将成功，响应为 `202 已接受`。
- en: The `delete` operation should return `202` even if the product with the specified
    product ID does not exist in the underlying database, since the `delete` operation
    is idempotent, as described in *Chapter 6*, *Adding Persistence*. Refer to the
    *Adding new APIs* section.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在底层数据库中不存在指定产品 ID 的产品，`delete` 操作也应返回 `202`，因为 `delete` 操作是幂等的，如第 6 章 *添加持久性*
    中所述。请参阅 *添加新 API* 部分。
- en: 'If you look into the log output using the `docker-compose logs -f product-composite`
    command, you should be able to find authorization information such as the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `docker-compose logs -f product-composite` 命令查看日志输出，应该能够找到如下授权信息：
- en: '![Text  Description automatically generated](img/B19825_11_14.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_11_14.png)'
- en: 'Figure 11.14: Authorization info in the log output'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：日志输出中的授权信息
- en: This information was extracted in the `product-composite` service from the JWT-encoded
    access token; the `product-composite` service did not need to communicate with
    the authorization server to get this information!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息是从 JWT 编码的访问令牌中提取的 `product-composite` 服务；`product-composite` 服务无需与授权服务器通信即可获取此信息！
- en: With these tests, we have seen how to acquire an access token with the client
    credentials and authorization code grant flows. We have also seen how scopes can
    be used to limit what a client can do with a specific access token, for example,
    only use it for reading operations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们已经看到了如何使用客户端凭据和授权代码授权流程获取访问令牌。我们还看到了如何使用作用域来限制客户端可以使用特定访问令牌执行的操作，例如，仅用于读取操作。
- en: Testing Swagger UI with OAuth 2.0
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OAuth 2.0 测试 Swagger UI
- en: In this section, we will learn how to use the Swagger UI component to access
    the protected API. The configuration described in the *Changes in the product-composite
    service only* section above allows us to issue an access token for Swagger UI
    and use it when calling the APIs from Swagger UI.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Swagger UI 组件访问受保护的 API。上面 *仅针对 product-composite 服务中的更改* 部分中描述的配置允许我们为
    Swagger UI 发出访问令牌，并在从 Swagger UI 调用 API 时使用它。
- en: 'To try it out, perform the following steps:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试它，请执行以下步骤：
- en: 'Open the Swagger UI start page by going to the following URL in a web browser:
    `https://localhost:8443/openapi/swagger-ui.html`.'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在网页浏览器中访问以下URL来打开Swagger UI起始页面：`https://localhost:8443/openapi/swagger-ui.html`。
- en: On the start page, we can now see a new button, next to the **Servers** drop-down
    list, with the text **Authorize**.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在起始页面上，我们现在可以看到一个新按钮，位于**服务器**下拉列表旁边，按钮上显示文本**授权**。
- en: Click on the **Authorize** button to initiate an authorization code grant flow.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**授权**按钮以启动授权码授予流程。
- en: Swagger UI will present a list of scopes that it will ask the authorization
    server to get access to. Select all scopes by clicking on the link with the text
    **select all** and then clicking on the **Authorize** button:![Graphical user
    interface, application  Description automatically generated](img/B19825_11_15.png)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger UI将显示一个作用域列表，它将请求授权服务器获取访问权限。通过点击带有文本**全选**的链接并然后点击**授权**按钮来选择所有作用域：![图形用户界面，应用程序描述自动生成](img/B19825_11_15.png)
- en: 'Figure 11.15: Swagger UI asking for OAuth scopes'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.15：Swagger UI请求OAuth作用域
- en: You will then be redirected to the authorization server. If you are not already
    logged in from the web browser used, the authorization server will ask for your
    credentials as in the *Acquiring access tokens using the authorization code grant
    flow* section.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将被重定向到授权服务器。如果您还没有从所使用的网页浏览器登录，授权服务器将要求您提供凭证，就像在*使用授权码授予流程获取访问令牌*部分中描述的那样。
- en: Log in with username `u` and password `p`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名`u`和密码`p`登录。
- en: The authorization server will ask for your consent. Select both scopes and click
    on the **Submit Consent** button.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将要求您的同意。选择两个作用域并点击**提交同意**按钮。
- en: 'Swagger UI will complete the authorization process by showing information about
    the completed grant flow. Click on the **Close** button to get back to the start
    page:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger UI将通过显示完成的授权流程信息来完成授权过程。点击**关闭**按钮返回起始页面：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_16.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_11_16.png)'
- en: 'Figure 11.16: Swagger UI summarizing the OAuth grant flow'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：Swagger UI总结OAuth授权流程
- en: Now you can try out the APIs in the same way as described in *Chapter 5*, *Adding
    an API Description Using OpenAPI*. Swagger UI will add the access token to the
    requests. If you look closely at the `curl` command reported below the **Responses**
    header, you can find the access token.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以像在*第5章*，*使用OpenAPI添加API描述*中描述的那样尝试API。Swagger UI将把访问令牌添加到请求中。如果您仔细查看**响应**标题下报告的`curl`命令，您可以找到访问令牌。
- en: This completes the tests we will perform with the local authorization server.
    In the next section, we will replace it with an external OpenID Connect-compliant
    provider.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们将使用本地授权服务器进行的测试。在下一节中，我们将用外部OpenID Connect兼容提供者替换它。
- en: Testing with an external OpenID Connect provider
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部OpenID Connect提供者进行测试
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let’s find out, shall we?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，OAuth舞蹈与我们所控制的授权服务器配合得很好。但如果我们用认证的OpenID Connect提供者替换它，会发生什么？从理论上讲，它应该能够直接工作。让我们来看看，好吗？
- en: For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取OpenID Connect的认证实现列表，请参阅[https://openid.net/developers/certified/](https://openid.net/developers/certified/).
- en: 'We will use Auth0, `https://auth0.com/`, for our tests with an external OpenID
    provider. To be able to use Auth0 instead of our own authorization server, we
    will go through the following topics:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Auth0，`https://auth0.com/`，作为我们的外部OpenID提供者测试。为了能够使用Auth0而不是我们自己的授权服务器，我们将讨论以下主题：
- en: Setting up an account with a `reader` and `writer` client and a user in Auth0
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Auth0中设置一个具有`reader`和`writer`客户端和用户的账户
- en: Applying the changes required to use Auth0 as an OpenID provider
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用使用Auth0作为OpenID提供者所需的更改
- en: Running the test script to verify that it is working
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试脚本以验证其是否正常工作
- en: 'Acquiring access tokens using the following grant flows:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下授权流程获取访问令牌：
- en: Client credentials grant flow
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭证授予流程
- en: Authorization code grant flow
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码授予流程
- en: Calling protected APIs using the access tokens acquired from the grant flows
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从授权流程中获得的访问令牌调用受保护的API
- en: Using the user info endpoint to get more information about a user
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户信息端点获取有关用户的更多信息
- en: Let us go through each of them in the following sections.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中逐一介绍它们。
- en: Setting up and configuring an account in Auth0
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和配置Auth0账户
- en: Most of the configuration required in Auth0 will be taken care of by a script
    that uses Auth0’s management API. But we must perform a few manual steps up to
    the point where Auth0 has created a client ID and client secret we can use to
    access the management API. Auth0’s service is multi-tenant, allowing us to create
    our own domain of OAuth objects in terms of clients, resource owners, and resource
    servers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在Auth0中所需的大部分配置将由使用Auth0管理API的脚本处理。但我们必须执行一些手动步骤，直到Auth0创建了一个我们可以用来访问管理API的客户端ID和客户端密钥。Auth0的服务是多租户的，允许我们创建自己的OAuth对象域，包括客户端、资源所有者和资源服务器。
- en: 'Perform the following manual steps to sign up for a free account in Auth0 and
    create a client that we can use to access the management API:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下手动步骤，在Auth0注册免费账户并创建一个我们可以用来访问管理API的客户端：
- en: Open the URL [https://auth0.com](https://auth0.com) in your browser.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开URL [https://auth0.com](https://auth0.com)。
- en: Click on the **hamburger menu** (☰) in the top-right corner.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的**汉堡菜单**（☰）。
- en: 'Click on the **Sign up** button:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**注册**按钮：
- en: Sign up with an email of your choice.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的电子邮件地址进行注册。
- en: 'After a successful sign-up, you will be asked to create a tenant domain. Enter
    the name of the tenant of your choice, in my case: `dev-ml-3rd.eu.auth0.com`.'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功注册后，您将被要求创建一个租户域名。输入您选择的租户名称，以我的情况为例：`dev-ml-3rd.eu.auth0.com`。
- en: Fill in the information about your account as requested.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照要求填写您的账户信息。
- en: Also, look in your mailbox for an email with the subject **Please Verify Your
    Auth0 Account** and use the instructions in the email to verify your account.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，查看您的邮箱，寻找主题为**请验证您的Auth0账户**的电子邮件，并使用电子邮件中的说明来验证您的账户。
- en: Following sign-up, you will be directed to an **onboarding** page.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，您将被引导到一个**入门**页面。
- en: In the menu to the left, click on **Applications** to get it expanded, then
    click on **APIs** to find the management API, **Auth0 Management API**. This API
    was created for you during the creation of your tenant. We will use this API to
    create the required definitions in the tenant.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，点击**应用程序**以展开它，然后点击**APIs**以找到管理API，**Auth0管理API**。此API是在创建租户时为您创建的。我们将使用此API在租户中创建所需的定义。
- en: Click on **Auth0 Management API** and select the **Test** tab.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Auth0管理API**并选择**测试**标签。
- en: A big button with the text **Create & Authorize Test**will appear. Click on
    it to get a client created that can be used to access the management API.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个带有文本**创建并授权测试**的大按钮。点击它以创建一个可以用来访问管理API的客户端。
- en: Once created, a page is displayed with the header **Asking Auth0 for tokens
    from my application**. As a final step, we need to give the created client permission
    to use the management APIs.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，将显示一个带有标题**从我的应用程序请求Auth0令牌**的页面。作为最后一步，我们需要授予创建的客户端使用管理API的权限。
- en: Click on the tab **Machine to Machine Applications**, next to the **Test** tab.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**标签旁边的**机器到机器应用程序**标签。
- en: Here we will find the test client, **Auth0 Management API (Test Application)**,
    and we can see that it is authorized to use the management API. If we click on
    the down arrow next to the **Authorized** toggle button, a large number of available
    privileges are revealed.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们可以找到测试客户端，**Auth0管理API（测试应用程序**），我们可以看到它被授权使用管理API。如果我们点击**授权**切换按钮旁边的向下箭头，将揭示大量可用的权限。
- en: 'Click on the **All** choice and then on the **Update** button. The screen should
    look similar to the following screenshot:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全部**选项，然后点击**更新**按钮。屏幕应类似于以下截图：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_17.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_11_17.png)'
- en: 'Figure 11.17: Auth0 management API client permissions'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：Auth0管理API客户端权限
- en: Click on the **Continue** button after understanding that you now have a very
    powerful client with access to all management APIs within your tenant.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在理解您现在拥有一个可以访问您租户内所有管理API的非常强大的客户端后，点击**继续**按钮。
- en: Now, we just need to collect the client ID and client secret of the created
    client. The easiest way to do that is to select **Applications** in the menu to
    the left (under the main menu choice **Applications**) and then select the application
    named **Auth0 Management API (Test Application)**.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要收集创建的客户端的客户端ID和客户端密钥。最简单的方法是在左侧菜单中选择**应用程序**（在主菜单选择**应用程序**下）然后选择名为**Auth0管理API（测试应用程序**）的应用程序。
- en: 'A screen similar to the following should be displayed:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该显示一个类似于以下屏幕的屏幕：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19825_11_18.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队  自动生成的描述](img/B19825_11_18.png)'
- en: 'Figure 11.18: Auth0 Management API client application information'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：Auth0管理API客户端应用程序信息
- en: 'Open the file `$BOOK_HOME/Chapter11/auth0/env.bash` and copy the following
    values from the screen above:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`$BOOK_HOME/Chapter11/auth0/env.bash`并从上面的屏幕复制以下值：
- en: '**Domain** into the value of the variable `TENANT`'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**域名**放入变量`TENANT`的值中'
- en: '**Client ID** into the value of the variable `MGM_CLIENT_ID`'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端ID**放入变量`MGM_CLIENT_ID`的值中'
- en: '**Client Secret** into the value of the variable `MGM_CLIENT_SECRET`'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端密钥**放入变量`MGM_CLIENT_SECRET`的值中'
- en: Complete the values required in the `env.bash` file by specifying an email address
    and password, in the variables `USER_EMAIL` and `USER_PASSWORD`, of a test user
    that the script will create for us.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定电子邮件地址和密码，在变量`USER_EMAIL`和`USER_PASSWORD`中完成`env.bash`文件中所需值的设置，该脚本将为我们创建一个测试用户。
- en: Specifying a password for a user like this is not considered best practice from
    a security perspective. Auth0 supports enrolling users who will be able to set
    the password themselves, but it is more involved to set up. For more information,
    see [https://auth0.com/docs/connections/database/password-change](https://auth0.com/docs/connections/database/password-change).
    Since this is only used for test purposes, specifying a password like this is
    OK.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度考虑，为像这样的用户指定密码不被认为是最佳实践。Auth0支持注册用户，他们可以自己设置密码，但这需要更复杂的设置。有关更多信息，请参阅[https://auth0.com/docs/connections/database/password-change](https://auth0.com/docs/connections/database/password-change)。由于这仅用于测试目的，指定这样的密码是可以的。
- en: 'We can now run the script that will create the following definitions for us:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行脚本，该脚本将为我们创建以下定义：
- en: Two applications, `reader` and `writer`, or clients in OAuth terminology
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个应用程序，`reader`和`writer`，或者OAuth术语中的客户端
- en: The `product-composite` API, a resource server in OAuth terminology, with the
    OAuth scopes `product:read` and `product:write`
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite` API，OAuth术语中的资源服务器，具有OAuth作用域`product:read`和`product:write`'
- en: A user, a resource owner in OAuth terminology, that we will use to test the
    authorization code grant flow
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户，OAuth术语中的资源所有者，我们将使用它来测试授权代码流
- en: Finally, we will grant the `reader` application the scope `product:read`, and
    the `writer` application the scopes `product:read` and `product:write`
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将授予`reader`应用程序`product:read`作用域，并将`writer`应用程序的作用域设置为`product:read`和`product:write`
- en: 'Run the following commands:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE37]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Expect the following output (details removed from the output below):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '预期以下输出（以下输出中已删除详细信息）:'
- en: '![Text  Description automatically generated](img/B19825_11_19.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_11_19.png)'
- en: 'Figure 11.19: Output from setup-tenant.bash the first time it is executed'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：第一次执行`setup-tenant.bash`时的输出
- en: Save a copy of the `export` commands printed at the end of the output; we will
    use them multiple times later on in this chapter.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存输出末尾打印的`export`命令的副本；我们将在本章的后面多次使用它们。
- en: Look in your mailbox for the email specified for the test user. You will receive
    a mail with the subject **Verify your email***.* Use the instructions in the email
    to verify the test user’s email address.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的邮箱中查找为测试用户指定的测试邮件。您将收到一封主题为**验证您的电子邮件**的邮件。*使用邮件中的说明来验证测试用户的电子邮件地址。
- en: 'Note that the script is idempotent, meaning it can be run multiple times without
    corrupting the configuration. If running the script again, it should respond with:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该脚本是无状态的，这意味着它可以多次运行而不会破坏配置。如果再次运行脚本，它应该响应：
- en: '![](img/B19825_11_20.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19825_11_20.png)'
- en: 'Figure 11.20: Output from setup-tenant.bash the next time it is executed'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：第二次执行`setup-tenant.bash`时的输出
- en: It can be very handy to be able to run the script again, for example, to get
    access to the client ID and client secret of the `reader` and `writer`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 能够再次运行脚本非常有用，例如，以获取对`reader`和`writer`的客户端ID和客户端密钥的访问。
- en: If you need to remove the objects created by `setup-tenant.bash`, you can run
    the script `reset-tenant.bash`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要删除由 `setup-tenant.bash` 创建的对象，您可以运行脚本 `reset-tenant.bash`。
- en: With an Auth0 account created and configured, we can move on and apply the necessary
    configuration changes in the system landscape.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建并配置了 Auth0 账户后，我们可以继续前进并应用系统景观中必要的配置更改。
- en: Applying the required changes to use Auth0 as an OpenID provider
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用必要的更改以使用 Auth0 作为 OpenID 提供者
- en: In this section, we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite` and `gateway` services. We also need to change our test script
    a bit, so that it acquires the access tokens from Auth0 instead of acquiring them
    from our local authorization server. Let’s start with the OAuth resource servers,
    the `product-composite` and `gateway` services.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习需要哪些配置更改才能用 Auth0 替换本地授权服务器。我们只需更改充当 OAuth 资源服务器的两个服务的配置，即 `product-composite`
    和 `gateway` 服务。我们还需要稍微修改我们的测试脚本，以便从 Auth0 而不是从本地授权服务器获取访问令牌。让我们从 OAuth 资源服务器，即
    `product-composite` 和 `gateway` 服务开始。
- en: The changes described in this topic have **not** been applied to the source
    code in the book’s Git repository; you need to make them yourself to see them
    in action!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改尚未应用于书中 Git 仓库中的源代码；您需要自己进行这些更改才能看到它们的效果！
- en: Changing the configuration in the OAuth resource servers
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OAuth 资源服务器中更改配置
- en: As already described, when using an OpenID Connect provider, we only have to
    configure the base URI to the standardized discovery endpoint in the OAuth resource
    servers.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用 OpenID Connect 提供者时，我们只需配置 OAuth 资源服务器中标准发现端点的基 URI。
- en: 'In the `product-composite` and `gateway` projects, update the OIDC discovery
    endpoint to point to Auth0 instead of to our local authorization server. Make
    the following change to the `application.yml` file in both projects:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `product-composite` 和 `gateway` 项目中，更新 OIDC 发现端点以指向 Auth0 而不是指向我们的本地授权服务器。在两个项目的
    `application.yml` 文件中做出以下更改：
- en: Locate the property `spring.security.oauth2.resourceserver.jwt.issuer-uri`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位属性 `spring.security.oauth2.resourceserver.jwt.issuer-uri`。
- en: Replace its value with `https://${TENANT}/`, where `${TENANT}` should be replaced
    with your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`. Do *not*
    forget the trailing `/!`
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其值替换为 `https://${TENANT}/`，其中 `${TENANT}` 应替换为您的租户域名；在我的情况下，它是 `dev-ml.eu.auth0.com`。**不要**忘记尾随的
    `/!`
- en: 'In my case, the configuration of the OIDC discovery endpoint will look like
    this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，OIDC 发现端点的配置将如下所示：
- en: '[PRE38]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you are curious, you can see what’s in the discovery document by running
    the following command:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，可以通过运行以下命令查看发现文档的内容：
- en: '[PRE39]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式重新构建 `product-composite` 和 `gateway` 服务：
- en: '[PRE40]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With the `product-composite` and `gateway` services updated, we can move on
    and also update the test script.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `product-composite` 和 `gateway` 服务的更新，我们可以继续前进并更新测试脚本。
- en: Changing the test script so it acquires access tokens from Auth0
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改测试脚本以从 Auth0 获取访问令牌
- en: 'We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新测试脚本，以便从 Auth0 OIDC 提供者获取访问令牌。这通过在 `test-em-all.bash` 中执行以下更改来完成：
- en: 'Find the following command:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下命令：
- en: '[PRE41]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace it with these commands:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下命令替换：
- en: '[PRE42]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note from the preceding command that Auth0 requires us to specify the intended
    **audience** of the requested access token, as an extra layer of security. The
    audience is the API we plan to call using the access token. Given that an API
    implementation verifies the `audience` field, this would prevent the situation
    where someone tries to use an access token issued for another purpose to get access
    to an API.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前一个命令，Auth0 要求我们指定请求访问令牌的预期**受众**，作为额外的安全层。受众是我们计划使用访问令牌调用的 API。鉴于 API 实现验证
    `audience` 字段，这将防止有人试图使用为其他目的签发的访问令牌来访问 API。
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands with the values returned by the
    `setup-tenant.bash` script.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的命令中设置环境变量 `TENANT`、`WRITER_CLIENT_ID` 和 `WRITER_CLIENT_SECRET` 的值，这些值由 `setup-tenant.bash`
    脚本返回。
- en: As mentioned above, you can run the script again to acquire these values without
    risking any negative side effects!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，您可以再次运行脚本以获取这些值，而不会产生任何负面影响！
- en: 'Find the following command:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下命令：
- en: '[PRE43]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace it with this command:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下命令替换：
- en: '[PRE44]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we only request the `product:read` scope and not the `product:write`
    scope here.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里只请求 `product:read` 范围，而不是 `product:write` 范围。
- en: Set the values for the environment variables `READER_CLIENT_ID` and `READER_CLIENT_SECRET`
    in the preceding commands with the values returned by the `setup-tenant.bash`
    script.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的命令中，将环境变量 `READER_CLIENT_ID` 和 `READER_CLIENT_SECRET` 的值设置为 `setup-tenant.bash`
    脚本返回的值。
- en: Now the access tokens are issued by Auth0 instead of our local authorization
    server, and our API implementations can verify the access tokens using information
    from Auth0’s discovery service configured in the `application.yml` files. The
    API implementations can, as before, use the scopes in the access tokens to authorize
    the client to perform the call to the API, or not.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问令牌由 Auth0 而不是我们的本地授权服务器颁发，我们的 API 实现可以使用在 `application.yml` 文件中配置的 Auth0
    的发现服务的信息来验证访问令牌。API 实现可以像以前一样，使用访问令牌中的范围来授权客户端执行对 API 的调用，或者不授权。
- en: With this, we have all the required changes in place. Let’s run some tests to
    verify that we can acquire access tokens from Auth0.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了所有必要的更改。让我们运行一些测试来验证我们是否可以从 Auth0 获取访问令牌。
- en: Running the test script with Auth0 as the OpenID Connect provider
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Auth0 作为 OpenID Connect 提供者运行测试脚本
- en: Now, we are ready to give Auth0 a try!
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好尝试使用 Auth0 了！
- en: 'Run the usual tests, but this time, using Auth0 as the OpenID Connect provider,
    with the following command:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 运行常规测试，但这次使用 Auth0 作为 OpenID Connect 提供者，以下命令：
- en: '[PRE45]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the logs, you will be able to find authorization information from the access
    tokens issued by Auth0\. Run the command:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，您将能够找到来自 Auth0 颁发的访问令牌的授权信息。运行以下命令：
- en: '[PRE46]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Expect the following outputs from the command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 预期以下命令的输出：
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see both scopes listed as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从使用具有 `product:read` 和 `product:write` 范围的访问令牌的调用中，我们将看到以下范围列出：
- en: '![Text  Description automatically generated](img/B19825_11_21.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_11_21.png)'
- en: 'Figure 11.21: Authorization information for the writer client from Auth0 in
    the log output'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21：日志输出中来自 Auth0 的写客户端的授权信息
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仅使用 `product:read` 范围的访问令牌的调用中，我们将看到只列出以下范围：
- en: '![Text  Description automatically generated](img/B19825_11_22.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_11_22.png)'
- en: 'Figure 11.22: Authorization information for the reader client from Auth0 in
    the log output'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22：日志输出中来自 Auth0 的读客户端的授权信息
- en: As we can see from the log output, we now also get information regarding the
    **intended audience** for this access token. To strengthen security, we could
    add a test to our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would, as mentioned earlier,
    prevent the situation where someone tries to use an access token issued for another
    purpose than to get access to our API.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从日志输出中看到的那样，我们现在还获得了有关此访问令牌的**预期受众**的信息。为了加强安全性，我们可以在我们的服务中添加一个测试来验证其 URL（在这种情况下为
    `https://localhost:8443/product-composite`）是否是受众列表的一部分。正如之前提到的，这将防止有人试图使用为获取对我们的
    API 访问权限以外的目的而颁发的访问令牌。
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let’s start
    with the client credentials grant flow.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Auth0 的自动化测试一起工作时，我们可以继续学习如何使用不同类型的授权流程获取访问令牌。让我们从客户端凭证授权流程开始。
- en: Acquiring access tokens using the client credentials grant flow
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端凭证授权流程获取访问令牌
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command, using the client credentials grant flow:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己从 Auth0 获取访问令牌，可以通过运行以下命令，使用客户端凭证授权流程来实现：
- en: '[PRE47]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands with the values returned by the
    `setup-tenant.bash` script.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，将环境变量 `TENANT`、`WRITER_CLIENT_ID` 和 `WRITER_CLIENT_SECRET` 的值设置为 `setup-tenant.bash`
    脚本返回的值。
- en: Following the instructions in the *Calling protected APIs using access tokens*
    section, you should be able to call the APIs using the acquired access token.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第*使用访问令牌调用受保护的API*部分的说明，你应该能够使用获取的访问令牌调用API。
- en: Acquiring access tokens using the authorization code grant flow
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用授权码授权流程获取访问令牌
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the authorization code grant flow. As already described above, we first need to
    acquire an authorization code using a web browser. Next, we can use server-side
    code to exchange the authorization code for an access token.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用授权码授权流程从Auth0获取访问令牌。如上所述，我们首先需要使用网络浏览器获取授权码。接下来，我们可以使用服务器端代码将授权码交换为访问令牌。
- en: 'Perform the following steps to execute the authorization code grant flow with
    Auth0:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以执行使用Auth0的授权码授权流程：
- en: 'To get an authorization code for the default app client, use the following
    URL in the web browser:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为默认应用程序客户端获取授权码，请在网络浏览器中使用以下URL：
- en: '`https://${TENANT}/authorize?audience=https://localhost:8443/product-composite&scope=openid
    email product:read product:write&response_type=code&client_id=${WRITER_CLIENT_ID}&redirect_uri=https://my.redirect.uri&state=845361`.'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`https://${TENANT}/authorize?audience=https://localhost:8443/product-composite&scope=openid
    email product:read product:write&response_type=code&client_id=${WRITER_CLIENT_ID}&redirect_uri=https://my.redirect.uri&state=845361`。'
- en: Replace `${TENANT}` and `${WRITER_CLIENT_ID}` in the preceding URL with the
    tenant domain name and writer client ID returned by the `setup-tenant.bash` script.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的URL中的`${TENANT}`和`${WRITER_CLIENT_ID}`替换为`setup-tenant.bash`脚本返回的租户域名和writer客户端ID。
- en: 'Auth0 should present the following login screen:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Auth0应显示以下登录屏幕：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_23.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_11_23.png)'
- en: 'Figure 11.23: Authorization code grant flow with Auth0, the login screen'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：使用Auth0的授权码授权流程，登录屏幕
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录成功后，Auth0会要求你同意客户端应用程序：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_24.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_11_24.png)'
- en: 'Figure 11.24: Authorization code grant flow with Auth0, the consent screen'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：使用Auth0的授权码授权流程，同意屏幕
- en: 'The authorization code is now in the URL in the browser, just like when we
    tried out the authorization code grant flow with our local authorization server:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权码现在位于浏览器中的URL中，就像我们尝试使用本地授权服务器进行授权码授权流程时一样：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_25.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_11_25.png)'
- en: 'Figure 11.25: Authorization code grant flow with Auth0, access token'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：使用Auth0的授权码授权流程，访问令牌
- en: 'Extract the code and run the following command to get the access token:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取代码并运行以下命令以获取访问令牌：
- en: '[PRE48]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands to the values returned by the
    `setup-tenant.bash` script.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中设置环境变量`TENANT`、`WRITER_CLIENT_ID`和`WRITER_CLIENT_SECRET`的值为`setup-tenant.bash`脚本返回的值。
- en: Now that we have learned how to acquire access tokens using both grant flows,
    we are ready to try calling the external API using an access token acquired from
    Auth0 in the next section.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用两种授权流程获取访问令牌，我们准备在下一节尝试使用从Auth0获取的访问令牌调用外部API。
- en: Calling protected APIs using the Auth0 access tokens
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Auth0访问令牌调用受保护的API
- en: We can use access tokens issued by Auth0 to call our APIs, just like when we
    used access tokens issued by our local authorization server.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Auth0签发的访问令牌来调用我们的API，就像我们使用本地授权服务器签发的访问令牌一样。
- en: 'For a read-only API, execute the following command:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读API，执行以下命令：
- en: '[PRE49]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For an updating API, execute the following command:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新中的API，执行以下命令：
- en: '[PRE50]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return `200 OK`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们请求了两个作用域，`product:read`和`product:write`，因此预期的前一个API调用都将返回`200 OK`。
- en: Getting extra information about the user
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取有关用户的额外信息
- en: 'From the log output in *Figures 11.21* and *11.22* in the *Running the test
    script with Auth0 as the OpenID Connect provider section*, we could not see any
    information about the user that initiated the API request. If you want your API
    implementation to know a bit more about the user, it can call Auth0’s `userinfo_endpoint`.
    The URL of the `userinfo` endpoint can be found in the response of a request to
    the OIDC discovery endpoint, as described in the *Changing the configuration in
    the OAuth resource servers* section. To get user info related to an access token,
    make the following request:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 从“使用Auth0作为OpenID Connect提供者的运行测试脚本”部分中的*图11.21*和*图11.22*的日志输出中，我们看不到任何关于发起API请求的用户的信息。如果您希望您的API实现能够了解更多关于用户的信息，它可以调用Auth0的`userinfo_endpoint`。`userinfo`端点的URL可以在对OIDC发现端点的请求的响应中找到，如*在OAuth资源服务器中的配置更改*部分所述。要获取与访问令牌相关的用户信息，请执行以下请求：
- en: '[PRE51]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Set the values for the `TENANT` environment variable in the preceding commands
    to the values returned by the `setup-tenant.bash` script.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中设置`TENANT`环境变量的值，使其等于`setup-tenant.bash`脚本返回的值。
- en: Note that this command only applies to access tokens issued using the authorization
    code grant flow. Access tokens issued using the client credentials grant flow
    don’t contain any user information and will result in an error response if tried.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此命令仅适用于使用授权码授权流程颁发的访问令牌。使用客户端凭据授权流程颁发的访问令牌不包含任何用户信息，如果尝试使用，将导致错误响应。
- en: 'A sample response is as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例响应如下：
- en: '![Text  Description automatically generated](img/B19825_11_26.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_11_26.png)'
- en: 'Figure 11.26: Requesting extra user information from Auth0'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：从Auth0请求额外的用户信息
- en: This endpoint can also be used to verify that the user hasn’t revoked the access
    token in Auth0.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点也可以用来验证用户是否没有在Auth0中撤销访问令牌。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统景观以结束测试：
- en: '[PRE52]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This concludes the section, where we have learned how to replace the local OAuth
    2.0 authorization server with an external alternative. We have also seen how to
    reconfigure the microservice landscape to validate access tokens using an external
    OIDC provider.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束，我们学习了如何用外部替代方案替换本地OAuth 2.0授权服务器。我们还看到了如何重新配置微服务景观，以使用外部OIDC提供者验证访问令牌。
- en: Summary
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring Security来保护我们的API。
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access to the discovery server, Netflix Eureka,
    using HTTP Basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client applications. We have learned both
    how to set up a local OAuth 2.0 authorization server based on Spring Security
    and also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，使用Spring Security启用HTTPS以防止第三方窃听是多么容易。使用Spring Security，我们还了解到，使用HTTP基本身份验证限制对发现服务器Netflix
    Eureka的访问是直接了当的。最后，我们看到了如何使用Spring Security简化OAuth 2.0和OpenID Connect的使用，允许第三方客户端应用程序以用户的名义访问我们的API，但不需要用户与客户端应用程序共享凭据。我们学习了如何设置基于Spring
    Security的本地OAuth 2.0授权服务器，以及如何更改配置，以便可以使用外部OpenID Connect提供者Auth0。
- en: One concern, however, is how to manage the configuration required. Each microservice
    instance must be provided with its own configuration, making it hard to get a
    good overview of the current configuration. Updating configuration that concerns
    multiple microservices will also be challenging. Added to the scattered configuration
    is the fact that some of the configurations we have seen so far contain sensitive
    information, such as credentials or certificates. It seems like we need a better
    way to handle the configuration for a number of cooperating microservices and
    also a solution for how to handle sensitive parts of the configuration.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个担忧是，如何管理所需的配置。每个微服务实例都必须提供其自己的配置，这使得很难获得当前配置的良好概览。更新涉及多个微服务的配置也将具有挑战性。加之分散的配置，我们之前看到的一些配置包含敏感信息，如凭证或证书。这似乎需要一种更好的方式来处理多个协作微服务的配置，以及如何处理配置敏感部分的方法。
- en: In the next chapter, we will explore the Spring Cloud Config Server and see
    how it can be used to handle these types of problems.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Spring Cloud Config Server，并看看它是如何被用来处理这些类型的问题的。
- en: Questions
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits and shortcomings of using self-signed certificates?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自签名证书的好处和缺点是什么？
- en: What is the purpose of OAuth 2.0 authorization codes?
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0 授权码的目的是什么？
- en: What is the purpose of OAuth 2.0 scopes?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0 范围的目的是什么？
- en: What does it mean when a token is a JWT?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个令牌是 JWT 时，这意味着什么？
- en: How can we trust the information that is stored in a JWT?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何信任存储在 JWT 中的信息？
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OAuth 2.0 授权码授权流程与原生移动应用是否合适？
- en: What does OpenID Connect add to OAuth 2.0?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenID Connect 为 OAuth 2.0 增加了什么？
