- en: Spring Aspect Oriented Programming with Proxy and Decorator pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring面向切面编程（AOP）与代理和装饰者模式
- en: Before you start reading this chapter, I want to share something with you; as
    I was writing this chapter, my wife Anamika, was taking a selfie and uploading
    it to several social media sites such as Facebook and WhatsApp. She keeps a track
    of the *likes*, However, uploading more photos uses more mobile data, and mobile
    data costs money. I rarely use social media as I prefer to avoid paying more to
    the internet company. Every month, the internet company knows how much to bill
    us. Now consider what would happen if the internet usage, total call duration
    and bill calculation was meticulously planned and managed by us? It's possible
    that some obsessive internet users would manage it and I'm really clueless as
    to how.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始阅读本章之前，我想与你分享一些事情；当我撰写本章时，我的妻子Anamika正在拍自拍并上传到几个社交媒体网站，如Facebook和WhatsApp。她跟踪着*点赞*的数量，然而上传更多的照片会消耗更多的移动数据，而移动数据是需要付费的。我很少使用社交媒体，因为我更喜欢避免向互联网公司支付更多费用。每个月，互联网公司都知道他们应该向我们收取多少费用。现在考虑一下，如果互联网使用、总通话时长和账单计算都由我们精心计划和管理的会怎样？可能一些沉迷于互联网的用户会管理它，而我对此真的毫无头绪。
- en: Calculating billing for internet usage and calls is an important function, but
    it is still not predominant for most internet users. For those like my wife, taking
    selfies, uploading photos to social media, and watching videos on YouTube are
    the kinds of things that most internet users are actively involved in. Managing
    and calculating their internet bill is a passive action for internet users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算互联网使用和通话的账单是一个重要的功能，但对于大多数互联网用户来说，它仍然不是主要的。对于像我妻子这样的人，拍自拍、上传照片到社交媒体、在YouTube上观看视频，这些都是大多数互联网用户积极参与的事情。管理和计算他们的互联网账单对互联网用户来说是一种被动行为。
- en: Similarly some modules of the enterprise applications are like the internet
    billing calculator for our internet usage. There are some modules in the application
    that have important functionalities that need to be placed at multiple points
    in the application. But it is unexpected to explicitly call these functionalities
    at every points. Functionalities such as logging, security, and transaction management
    are important for your application but your business objects are not actively
    participating in it because your business objects need to focus on the business
    domain problems they're designed for, and leave certain aspects to be handled
    by someone else.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一些企业应用模块就像我们互联网使用的互联网账单计算器。在应用中，有一些模块具有重要的功能，需要在应用的多个位置放置。但是，在每一个点显式调用这些功能是不太可能的。例如，日志记录、安全和事务管理对于你的应用来说很重要，但你的业务对象并没有积极参与其中，因为你的业务对象需要专注于它们被设计用于解决的业务领域问题，并将某些方面留给其他人处理。
- en: In software development, there are specific tasks to be performed at certain
    points in an application. These tasks or functions are known as **cross-cutting
    concerns**. In an application, all cross-cutting concerns are separate from the
    business logic of this application. Spring provides a module **Aspect-Oriented
    Programming** (**AOP**) to separate these cross-cutting concerns from the business
    logic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，在应用中的特定点需要执行特定的任务。这些任务或函数被称为**跨切面关注点**。在一个应用中，所有的跨切面关注点都与该应用的业务逻辑分离。Spring提供了一个模块**面向切面编程**（**AOP**）来将这些跨切面关注点从业务逻辑中分离出来。
- en: As in [Chapter 4](fb30c4f8-9c4c-4705-b508-3782801e2a81.xhtml), *Wiring Beans
    using Dependency Injection Pattern*, you learned about the dependency injection
    to configure and resolve dependencies of collaborating objects in the application.
    Whereas DI promotes programming to interface and decoupling application objects
    from each other, Spring AOP promotes decoupling between the application's business
    logic and the cross-cutting concerns in the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[第4章](fb30c4f8-9c4c-4705-b508-3782801e2a81.xhtml)中所述的*使用依赖注入模式连接豆芽*，你学习了如何使用依赖注入来配置和解决应用中协作对象之间的依赖关系。而依赖注入（DI）推崇面向接口编程和将应用对象解耦，Spring
    AOP则推崇将应用的业务逻辑与跨切面关注点解耦。
- en: In our bankapp example, transferring money from one account to another account
    is a business logic but logging this activity and securing the transaction are
    cross-cutting concerns in our bankapp application. That means logging, security,
    and transaction are common examples of the application of aspects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的bankapp示例中，从一个账户向另一个账户转账是业务逻辑，但在我们的bankapp应用程序中记录此活动和确保交易安全是横切关注点。这意味着记录、安全和事务是方面应用的常见示例。
- en: 'In this chapter, you will explore Spring''s support for aspects. It will cover
    the following points:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探索Spring对方面的支持。它将涵盖以下要点：
- en: Proxy pattern in Spring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring中的代理模式
- en: Adapter design pattern to handle load time weaving
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器设计模式用于处理运行时编织
- en: Decorator design pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: Aspect-oriented programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向切面编程
- en: Problems resolved by AOP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP解决的问题
- en: Core AOP concepts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心AOP概念
- en: Defining point cuts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义切入点
- en: Implementing Advices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现建议
- en: Creating aspects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建方面
- en: Understanding AOP proxies
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解AOP代理
- en: Before we go further into our Spring AOP discussion, let's first understand
    the implemented patterns under the Spring AOP Framework, and see how these patterns
    are applied.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步讨论Spring AOP之前，让我们首先了解Spring AOP框架下实现的模式，并看看这些模式是如何应用的。
- en: Proxy pattern in Spring
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的代理模式
- en: Proxy design pattern provides an object of class that has the functionality
    of another class. This pattern comes under the structural design pattern of GOF
    design patterns. According to GOF pattern, *Provide a surrogate or placeholder
    for another object to control access to it*. The intent of this design pattern
    is to provide a different class for another class with its functionality to the
    outer world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式提供了一个具有另一个类功能的对象。此模式属于GOF设计模式的结构设计模式。根据GOF模式，*为另一个对象提供一个代理或占位符以控制对其的访问*。此设计模式的目的是为外部世界提供一个具有其功能的不同类。
- en: Proxying classes using Decorator pattern in Spring
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring中使用装饰器模式代理类
- en: As you have seen in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*, according to GOF book,
    *Attach additional responsibilities to an object dynamically. Decorators provide
    a flexible alternative to subclassing for extending functionality.* This pattern
    allows you to add and remove behaviors to an individual object at the runtime
    dynamically or statically without changing the existing behavior of other associated
    objects from the same class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[第3章](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml)中看到的，“考虑结构和行为模式”，根据GOF书籍，*动态地为对象附加额外责任。装饰器为扩展功能提供了一种灵活的替代子类化的方法。*
    此模式允许您在运行时或静态地动态地向单个对象添加和删除行为，而不会改变同一类中其他相关对象的现有行为。
- en: In Spring AOP, CGLIB is used to create the proxy in the application. CGLIB proxying
    works by generating a subclass of the target class at runtime. Spring configures
    this generated subclass to delegate method calls to the original target--the subclass
    is used to implement the Decorator pattern, weaving in the advice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring AOP中，CGLIB用于在应用程序中创建代理。CGLIB代理通过在运行时生成目标类的子类来工作。Spring配置此生成的子类将方法调用委托给原始目标--子类用于实现装饰器模式，编织建议。
- en: Spring provides two ways to create the proxy in the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了两种在应用程序中创建代理的方法。
- en: CGLIB proxy
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CGLIB代理
- en: JDK proxy or dynamic proxy
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK代理或动态代理
- en: 'Let''s see the following table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下表格：
- en: '| **JDK proxy** | **CGLIB proxy** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **JDK代理** | **CGLIB代理** |'
- en: '| Also called **dynamic proxies** | NOT built into JDK |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 也称为**动态代理** | NOT built into JDK |'
- en: '| API is built into the JDK | Included in Spring JARs |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| API内置在JDK中 | 包含在Spring JARs中 |'
- en: '| Requirements: Java interface(s) | Used when interface not available |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 要求：Java接口（s） | 当接口不可用时使用 |'
- en: '| All interfaces proxied | Cannot be applied to final classes or methods |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 所有的代理接口 | 不能应用于final类或方法 |'
- en: 'Let''s see the following figure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图：
- en: '![](img/9b911954-7460-422b-be91-2ca3bb52de3e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b911954-7460-422b-be91-2ca3bb52de3e.png)'
- en: Note--CGLIB proxying has one issue to be considered, that is, final methods
    can't be advised, as they can't be overridden.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意--CGLIB代理有一个需要考虑的问题，那就是final方法不能被建议，因为它们不能被重写。
- en: In the following section let's learn more about the cross-cutting concerns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于横切关注点的内容。
- en: What are cross-cutting concerns?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是横切关注点？
- en: In any application, there is some generic functionality that is needed in many
    places. But this functionality is not related to the application's business logic.
    Suppose you perform a role-based security check before every business method in
    your application. Here security is a cross-cutting concern. It is required for
    any application but it is not necessary from the business point of view, it is
    a simple generic functionality we have to implement in many places in the application.
    The following are examples of the cross-cutting concerns for the enterprise application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，都存在一些在许多地方都需要使用的通用功能。但这个功能与应用程序的业务逻辑无关。假设你在应用程序的每个业务方法之前执行基于角色的安全检查。这里的安全性是一个横切关注点。它对于任何应用程序都是必需的，但从业务角度来看，它是一个简单的通用功能，我们必须在应用程序的许多地方实现。以下是企业应用程序的横切关注点的例子。
- en: Logging and tracing
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和跟踪
- en: Transaction management
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理
- en: Security
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Caching
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Error handling
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Performance monitoring
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能监控
- en: Custom business rules
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制业务规则
- en: Let's see how we will implement these cross-cutting concerns in our application
    by using aspects of Spring AOP.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何通过使用Spring AOP的方面来实现这些横切关注点。
- en: What is Aspect-Oriented Programming?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是面向切面编程？
- en: 'As mentioned earlier, **Aspect-Oriented Programming** (**AOP**) enables modularization
    of cross-cutting concerns. It complements **Object-oriented programming** (**OOP**)
    which is another programing paradigm. OOP has class and object as key elements
    but AOP has aspect as key element. Aspects allow you to modularize some functionality
    across the application at multiple points. This type of functionality is known
    as **cross-cutting concerns**. For example, security is one of the cross-cutting
    concerns in the application, because we have to apply it at multiple methods where
    we want security. Similarly, transaction and logging are also cross-cutting concerns
    for the application and many more. Let''s see in the following figure how these
    concerns are applied to the business modules:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**面向切面编程**（**AOP**）使得横切关注点的模块化成为可能。它补充了**面向对象编程**（**OOP**），这是另一种编程范式。OOP以类和对象作为关键元素，而AOP以方面作为关键元素。方面允许你在应用程序的多个位置对某些功能进行模块化。这种类型的功能被称为**横切关注点**。例如，安全性是应用程序中的一个横切关注点，因为我们必须在多个方法中应用它以实现安全性。同样，事务和日志记录也是应用程序的横切关注点，还有更多。让我们在下面的图中看看这些关注点是如何应用到业务模块中的：
- en: '![](img/adfca5cd-3471-4fc6-9b82-e378370fb23a.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/adfca5cd-3471-4fc6-9b82-e378370fb23a.png)'
- en: As you can see in the preceding figure, there are three main business modules
    as **TransferService**, **AccountService**, and **BankService**. All business
    modules require some common functionality such as **Security**, **Transaction**
    management and **Logging**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有三个主要业务模块，分别是**TransferService**、**AccountService**和**BankService**。所有业务模块都需要一些共同的功能，例如**安全性**、**事务**管理和**日志**。
- en: Let's check out what problems we have to face in the application if we do not
    use the Spring AOP.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们不使用Spring AOP，在应用程序中我们会面临哪些问题。
- en: Problems resolved by AOP
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP解决的问题
- en: 'As stated earlier, aspects enable modularization of cross-cutting concerns.
    So if you are not using aspects, then modularization of some cross-cutting functionality
    is not possible. It tends to mix the cross-cutting functionality with the business
    modules. If you use a common object-oriented principle to reuse the common functionalities
    such as security, logging and transaction management, *you need to use* inheritance
    or composition. But here using inheritance can violate the single responsibility
    of SOLID principles and also increase object hierarchy. Also, the composition
    can be complicated to handle across the application. That means, failing to modularize
    cross-cutting concerns leads to two main problems as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，方面使得横切关注点的模块化成为可能。所以如果你没有使用方面，那么某些横切功能的模块化是不可能的。这往往会导致横切功能与业务模块混合。如果你使用面向对象的一个共同原则来重用共同的功能，如安全性、日志和事务管理，*你需要使用*继承或组合。但是在这里使用继承可能会违反SOLID原则中的单一职责原则，并增加对象层次。此外，组合在应用程序中可能难以处理。这意味着，未能模块化横切关注点会导致以下两个主要问题：
- en: Code tangling
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码纠缠
- en: Code scattering
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码分散
- en: Code tangling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码纠缠
- en: 'It is a coupling of concerns in the application. Code tangling occurs when
    there is a mixing of cross-cutting concerns with the application''s business logic.
    It promotes tight coupling between the cross-cutting and business modules. Let''s
    see the following code to understand more about code tangling:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它是在应用中关注点的耦合。当横切关注点与应用的业务逻辑混合时，就会发生代码纠缠。它促进了横切模块和业务模块之间的紧密耦合。让我们看看以下代码，以了解代码纠缠的更多内容：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in the preceding code, security concern code (highlighted) is
    mixing with application''s business logic code. This situation is an example of
    code tangling. Here we have only included security concern, but in the enterprise
    application you have to implement multiple cross-cutting concerns such as logging,
    transaction management and so on. In such cases, it will be even more complicated
    to manage the code and make any change to the code, which may cause critical bugs
    in the code as follows in the figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，安全关注点代码（高亮显示）与应用的业务逻辑代码混合。这种情况是代码纠缠的一个例子。在这里，我们只包括了安全关注点，但在企业应用中，你必须实现多个横切关注点，如日志记录、事务管理等。在这种情况下，管理代码和修改代码将变得更加复杂，如图中所示可能会引起代码中的关键错误：
- en: '![](img/5e372d1d-cc14-4430-94d1-8926573c605a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e372d1d-cc14-4430-94d1-8926573c605a.png)'
- en: In the preceding figure, you can see there are three cross-cutting concerns
    which are distributed across the `TransferService` business class and cross-cutting
    concerns logic mixing with `AccountService`'s business logic. This coupling between
    the concerns and application's logic is called **code tangling**. Let's see another
    main problem if we are using aspects for cross-cutting concern.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，你可以看到有三个横切关注点分布在`TransferService`业务类和与`AccountService`业务逻辑混合的横切关注点逻辑中。这种关注点与应用逻辑之间的耦合称为**代码纠缠**。让我们看看如果我们使用方面处理横切关注点时，另一个主要问题是什么。
- en: Code scattering
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分散
- en: 'This means that the same concern is spread across modules in the application.
    Code scattering promotes the duplicity of the concern''s code across the application
    modules. Let''s see the following code to understand more about code scattering:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着相同的关注点分散在应用的不同模块中。代码分散促进了关注点代码在应用模块中的重复。让我们看看以下代码，以了解代码分散的更多内容：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the preceding code, there are two modules for the application,
    `TransferService` and `AccountService`. Both modules have the same cross-cutting
    concern code for the security. The bold highlighted code in both business modules
    are the same, it means there is code duplication here. The following figure illustrates
    code scattering:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，应用有两个模块，`TransferService`和`AccountService`。这两个模块都有相同的横切关注点代码用于安全。在两个业务模块中加粗高亮的代码是相同的，这意味着这里存在代码重复。以下图示说明了代码分散：
- en: '![](img/c8012756-1076-44af-b483-493e64d5e477.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8012756-1076-44af-b483-493e64d5e477.png)'
- en: In the preceding figure, there are three business modules **TransferService**,
    **AccountService**, and **BankService**. Each business module contains cross-cutting
    concerns such as **Security**, **Logging** and **Transaction** management. All
    modules have the same code of concerns in the application. It is actually duplication
    of concerns code across the application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，有三个业务模块**TransferService**、**AccountService**和**BankService**。每个业务模块都包含横切关注点，如**安全**、**日志**和**事务**管理。所有模块在应用中都有相同的关注点代码。实际上，这是在应用中关注点代码的重复。
- en: Spring AOP provides solution for these two problems that is, code tangling and
    code scattering in the Spring application. Aspects enable modularization of cross-cutting
    concerns to avoid tangling and to eliminate scattering. Let's see in further section
    how AOP solves these problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP为Spring应用中的这两个问题提供了解决方案，即代码纠缠和代码分散。方面（Aspects）允许将横切关注点模块化，以避免纠缠并消除分散。让我们在下一节中看看AOP是如何解决这些问题的。
- en: How AOP Works to solve problems
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP如何解决问题
- en: 'Spring AOP allows you to keep cross-cutting concern logic separate from the
    mainline application logic. That means, you can implement your mainline application
    logic and only focus on the core problem of the application. And you can write
    aspects to implement your cross-cutting concerns. Spring provides many aspects
    out-of-the-box. After creating the aspects, you can add these aspects that is,
    cross-cutting behaviors to the right places into your application. Let''s see
    the following figure that illustrates the functionality of AOP:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP允许您将横切关注点逻辑与主线应用逻辑分开。这意味着，您可以实现主线应用逻辑，并且只关注应用的核心问题。您还可以编写方面来实现您的横切关注点。Spring提供了许多开箱即用的方面。在创建方面之后，您可以将这些方面（即横切行为）添加到应用程序的正确位置。让我们看看以下图示，它说明了AOP的功能：
- en: '![](img/ef9a3a53-6425-4198-9c33-db865e4c4942.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef9a3a53-6425-4198-9c33-db865e4c4942.png)'
- en: As you can see in the preceding figure, all aspects such as Security, Logging,
    and Transaction aspect are implemented separately in the application. We have
    added these aspects at the right places in the applications. Now our application
    logic is separate from the concerns. Let's see the following section defining
    the core AOP concepts and use AOP's terminology in your application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，所有方面如安全、日志和事务方面都在应用程序中单独实现。我们已经将这些方面添加到应用程序的正确位置。现在，我们的应用逻辑与关注点分离了。让我们看看以下部分，它定义了核心AOP概念，并在您的应用程序中使用AOP的术语。
- en: Core AOP terminology and concepts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心AOP术语和概念
- en: 'As with other technologies, AOP has its own vocabularies. Let''s start to learn
    some core AOP concepts and terminology. Spring used the AOP paradigm for the Spring
    AOP module. But unfortunately, terms used in the Spring AOP Framework are Spring-specific.
    These terms are used to describe AOP modules and features, but these aren''t intuitive.
    In spite of this, these terms are used in order to understand AOP. Without an
    understanding of the AOP idiom you will not be able to understand AOP functionality.
    Basically, AOP is defined in terms of advice, pointcuts, and join points. Let''s
    see the following figure that illustrates about the core AOP concepts and how
    they are tied together in the framework:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他技术一样，AOP有其自己的词汇。让我们开始学习一些核心AOP概念和术语。Spring在Spring AOP模块中使用了AOP范式。但不幸的是，Spring
    AOP框架中使用的术语是Spring特定的。这些术语用于描述AOP模块和功能，但它们并不直观。尽管如此，这些术语被用来理解AOP。如果没有理解AOP习语，您将无法理解AOP功能。基本上，AOP是用通知、切入点（pointcut）和连接点（join
    point）来定义的。让我们看看以下图示，它说明了核心AOP概念以及它们如何在框架中相互关联：
- en: '![](img/f45ada93-dcf9-4f09-86db-f36b666fc9e6.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f45ada93-dcf9-4f09-86db-f36b666fc9e6.png)'
- en: In the preceding figure, you can see an AOP functionality, it is known as **Advices**
    and it is implemented into multiple points. These points are known as **Joint
    Points**, these are defined by using an expression. These expression are known
    as **pointcuts**. Let's understand these terms in detail using an example (remember
    my wife's internet bill story?).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，您可以看到一个AOP功能，它被称为**通知**，并且它在多个点实现。这些点被称为**连接点**，它们是通过表达式定义的。这些表达式被称为**切入点**。让我们通过一个例子详细理解这些术语（还记得我妻子的互联网账单故事吗？）。
- en: Advice
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知（Advice）
- en: An internet plan is used for calculating the bill according to data usage in
    MB or GB by the internet company. The internet company has a list of customers,
    also and they also company calculates the internet bill for them. So calculating
    bills and sending it to the customers is a core job for the internet company but
    not for customers. Likewise, each aspect has its own main job and also has a purpose
    for doing this job. The job of an aspect is known as advice in the AOP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网公司根据互联网公司使用的数据使用量（以MB或GB为单位）来计算账单。互联网公司有一份客户名单，并且他们还为公司计算互联网账单。因此，计算账单并发送给客户是互联网公司的核心工作，而不是客户的工作。同样，每个方面都有自己的主要工作和完成这项工作的目的。在AOP中，方面的这项工作被称为通知。
- en: 'As you know now, advice is a job, aspect will perform this job, so there are
    some questions that come to in mind, when to perform this job and what will be
    in this job. Will this job be performed before a business method is invoked? Or
    will it be performed after the business method is invoked? Or will it be performed
    both before and after method invocation? Or it will be performed when business
    method throws an exception. Sometime this business method is also called the **advised
    method**. Let''s see the following five kinds of advises used by Spring aspects:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，建议是一项工作，方面将执行这项工作，因此当思考何时执行这项工作以及这项工作将包含什么内容时，会涌现一些问题。这项工作是在调用业务方法之前执行吗？或者是在调用业务方法之后执行？或者是在方法调用前后都执行？或者是在业务方法抛出异常时执行。有时，这个业务方法也被称为**建议方法**。让我们看看Spring方面使用的以下五种建议类型：
- en: '**Before:** Advice''s job executes before the `advised` method is invoked.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之前：** 建议的工作在调用建议方法之前执行。'
- en: If the advice throws an exception, target will not be called - this is a valid
    use of a Before Advice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果建议抛出异常，目标将不会被调用——这是有效使用之前建议的情况。
- en: '**After:** Advice''s job executes after the advised method completes regardless
    of whether an exception has been thrown by the target or not.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之后：** 建议的工作在建议方法完成之后执行，无论目标是否抛出异常。'
- en: '**After-returning:** Advice''s job executes after the advised method successfully
    completes. For example, if a business method returns without throwing an exception.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回后：** 建议的工作在建议方法成功完成后执行。例如，如果业务方法返回而没有抛出异常。'
- en: '**After-throwing:** Advice''s job executes if the advised method exits by throwing
    an exception.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出后：** 如果建议方法通过抛出异常退出，建议的工作将执行。'
- en: '**Around:** This is one of the most powerful advice of Spring AOP, this advice
    surrounds the advised method, providing some advice''s job before and after the
    advised method is invoked.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环绕：** 这是Spring AOP中最强大的建议之一，这个建议围绕建议方法，在建议方法被调用之前和之后提供一些建议的工作。'
- en: In short, advice's job code to be executed at each selected point that is, Join
    Point, let's look into another term of AOP.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，建议的工作代码将在每个选定的点上执行，即连接点，让我们来看看AOP的另一个术语。
- en: Join Point
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接点
- en: The internet company provides internet to many customers. Each customer has
    an internet plan and that plan needs to be used for their bill calculation. With
    the help of each internet plan, the company could potentially calculates the internet
    bill for all customers. Similarly, your application may have multiple number of
    places to apply advice. These places in the application are called **join points**.
    A join point is a point in the execution of a program such as a method call or
    exception thrown. In these points, Spring aspect inserts concern functionality
    in your application. Let's see how AOP knows about the join points and discuss
    another term of AOP concepts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网公司为许多客户提供互联网服务。每个客户都有一个互联网套餐，这个套餐需要用于他们的账单计算。借助每个互联网套餐，公司可以潜在地为所有客户计算互联网账单。同样，你的应用程序可能有多个地方可以应用建议。这些应用程序中的地方被称为**连接点**。连接点是在程序执行中的一个点，例如方法调用或异常抛出。在这些点上，Spring方面会在你的应用程序中插入关注的功能。让我们看看AOP如何知道连接点，并讨论AOP概念的另一个术语。
- en: Pointcut
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切入点
- en: Internet company makes a number of internet plans according to usage of internet
    data (customers like my wife need more data) because it is not possible for any
    internet company to provide same plan for all customers or a unique plan for each
    customer. Instead, each plan is assigned to the subset of the customers. In the
    same way, an advice is not necessary to apply to all join points in an application.
    You can define an expression that selects one or more Join Points in the application.
    This expression is known as **pointcut**. It helps to narrow down the join points
    advised by an aspect. Let's see another term of AOP that is Aspect.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网公司根据互联网数据的使用情况（例如，我妻子需要更多的数据）制定了许多互联网套餐，因为任何互联网公司都无法为所有客户提供相同的套餐或为每个客户提供一个独特的套餐。相反，每个套餐都分配给客户的一个子集。同样，建议也不必应用到应用程序中的所有连接点上。你可以定义一个表达式来选择应用程序中的一个或多个连接点。这个表达式被称为**切入点**。它有助于缩小方面建议的连接点。让我们看看AOP的另一个术语，即方面。
- en: Aspect
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方面
- en: An internet company knows which customer has what internet plan. On the basis
    of this information the internet company calculates an internet bill and sends
    it to the customer. In this example internet company is an aspect, internet plans
    are pointcuts and customers are join points, and calculating internet bills by
    the company is an advice. Likewise, in your application, an aspect is a module
    that encapsulates pointcuts and advice. Aspects know what it does; where and when
    it does it in the application. Let's see how AOP applies the aspect to the business
    methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一家互联网公司知道哪个客户有什么互联网套餐。基于这些信息，互联网公司计算互联网账单并发送给客户。在这个例子中，互联网公司是一个方面，互联网套餐是切入点，客户是连接点，公司计算互联网账单是一个通知。同样，在你的应用中，方面是一个封装了切入点和通知的模块。方面知道它做什么；在哪里以及何时在应用中执行。让我们看看AOP是如何将方面应用于业务方法的。
- en: Weaving
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程编织
- en: '**Weaving** is a technique by which aspects are combined with the business
    code. This is a process of applying aspects to a target object by creating a new
    proxy object. Weaving can be done at the compile time or at class load time, or
    at runtime. Spring AOP uses the runtime weaving by using proxy pattern.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**编织**是一种将方面与业务代码结合的技术。这是一个通过创建新的代理对象将方面应用于目标对象的过程。编织可以在编译时、类加载时或在运行时进行。Spring
    AOP通过使用代理模式使用运行时编织。'
- en: You have seen lot of terms used in the AOP. You must know about this terminology
    whenever your learn about any AOP Framework either AspectJ or Spring AOP. Spring
    has used AspectJ Framework to implement Spring AOP Framework. Spring AOP supports
    limited features of AspectJ. Spring AOP provides proxy-based AOP solution. Spring
    only supports the method joint points. Now you have some basic idea about Spring
    AOP and how it works, let's move on the next topics how to define pointcuts in
    the Spring's declarative AOP model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你在AOP中看到了很多术语。无论你学习任何AOP框架，无论是AspectJ还是Spring AOP，你都必须了解这些术语。Spring使用了AspectJ框架来实现Spring
    AOP框架。Spring AOP支持AspectJ的有限功能。Spring AOP提供基于代理的AOP解决方案。Spring只支持方法连接点。现在你对Spring
    AOP及其工作原理有了基本了解，让我们继续探讨如何在Spring的声明式AOP模型中定义切入点。
- en: Defining pointcuts
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义切入点
- en: As mentioned before, pointcuts are used to define a point where advice would
    be applied. So pointcut is one of the most important elements of an aspect in
    the application. Let's understand how to define pointcuts. In Spring AOP, we can
    use expression language to define the pointcuts. Spring AOP uses AspectJ's pointcut
    expression language for selecting where to apply advice. Spring AOP supports a
    subset of the pointcut designators available in AspectJ because as you know, Spring
    AOP is proxy-based and some designators do not support proxy-based AOP. Let's
    see following table has Spring AOP supported designators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，切入点用于定义应用通知的点。因此，切入点是应用中方面最重要的元素之一。让我们了解如何定义切入点。在Spring AOP中，我们可以使用表达式语言来定义切入点。Spring
    AOP使用AspectJ的点切表达式语言来选择应用通知的位置。Spring AOP支持AspectJ中可用的切入点设计器的一个子集，因为正如你所知，Spring
    AOP是基于代理的，某些设计器不支持基于代理的AOP。让我们看看以下表格中Spring AOP支持的设计器。
- en: '| **Spring supported AspectJ designators** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **Spring支持的AspectJ设计器** | **描述** |'
- en: '| execution | It matches the join points by method executions, it is primary
    pointcut designator supported by Spring AOP. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| execution | 它通过方法执行匹配连接点，是Spring AOP支持的初级切入点设计器。|'
- en: '| within | It matches the join points by limit within certain types. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| within | 它通过限制在特定类型内匹配连接点。|'
- en: '| this | It limits matching to join points where the bean reference is an instance
    of the given type. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| this | 它限制匹配到bean引用是给定类型实例的连接点。|'
- en: '| target | It limits matching to join points where the target object is of
    a given type. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| target | 它限制匹配到目标对象是给定类型的连接点。|'
- en: '| args | It limits matching to join points where the arguments are instances
    of the given types. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| args | 它限制匹配到参数是给定类型实例的连接点。|'
- en: '| `@target` | It limits matching to join points where the target object has
    an annotation of the given type. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `@target` | 它限制匹配到目标对象具有给定类型注解的连接点。|'
- en: '| `@args` | It limits matching to join points where the runtime, type of the
    actual arguments passed have annotations of the given type. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `@args` | 它限制匹配到运行时实际参数的类型具有给定类型注解的连接点。|'
- en: '| `@within` | It limits matching to join points where the declared type of
    the target object has the given type annotation. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `@within` | 它限制匹配到目标对象声明的类型具有给定类型注解的连接点。|'
- en: '| `@annotation` | It limits matching to join points where the subject of the
    join point has the given annotation. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `@annotation` | 它将匹配限制在具有给定注解的连接点的主语上。|'
- en: As listed earlier, Spring supported pointcut designators, execution is primary
    pointcut designator. So here I will only show you how to define pointcuts using
    execution designators. Let's see how to write the pointcut expression in the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring 支持切入点设计器，其中 `execution` 是主要切入点设计器。因此，在这里我将向您展示如何使用 `execution` 设计器定义切入点。让我们看看如何在应用程序中编写切入点表达式。
- en: Writing pointcuts
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写切入点
- en: 'We can write pointcuts by using execution designator as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `execution` 设计器编写切入点如下：
- en: '**execution(<method pattern>)**: The method must match the pattern as defined
    follows'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**execution(<方法模式>)**: 该方法必须匹配以下定义的模式'
- en: '**Can chain together to create composite pointcuts by using following operators**:
    `&& (and)`, `|| (or)`, `! (not)`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以使用以下运算符连接起来创建组合切入点**: `&& (与)`, `|| (或)`, `! (非)`'
- en: '**Method pattern**: Following is method pattern:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法模式**：以下为方法模式：'
- en: '`[Modifiers] ReturnType [ClassType]`'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Modifiers] ReturnType [ClassType]`'
- en: '`MethodName ([Arguments]) [throws ExceptionType]`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodName ([Arguments]) [throws ExceptionType]`'
- en: In the preceding method pattern, values within bracket `[ ]` that is, modifiers,
    `ClassType`, arguments and exceptions are all optional values. There is no need
    to define it for every pointcut using execution designator. Value without brackets
    such as `ReturnType`, and `MethodName` are mandatory to define.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法模式中，方括号 `[ ]` 内的值，即修饰符、`ClassType`、参数和异常都是可选值。在使用 `execution` 设计器定义每个切入点时，没有必要定义它。没有方括号的值，如
    `ReturnType` 和 `MethodName` 是必须定义的。
- en: 'Let''s define a `TransferService` interface:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 `TransferService` 接口：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`TransferService` is a service for transferring amounts from one to another
    account. Let''s say that you want to write a logging aspect that triggers off
    `TransferService`''s `transfer()` method. The following figure illustrates a pointcut
    expression that can be used to apply advice whenever the `transfer()` method is
    executed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferService` 是用于从一个账户转移到另一个账户的金额的服务。假设您想编写一个触发 `TransferService` 的 `transfer()`
    方法的日志方面。以下图示了一个可以用于在 `transfer()` 方法执行时应用建议的切入点表达式：'
- en: '![](img/fd74bf26-fc3c-4b3a-a33e-28e15f5de131.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd74bf26-fc3c-4b3a-a33e-28e15f5de131.png)'
- en: As in the preceding figure, you can see, I used the `execution()` designator
    to select join point `TransferService`'s `transfer()` method. In preceding expression
    in figure, I have used an asterisk at the beginning of the expression. This means
    that method can return any type. And after asterisk, I have specified a fully
    qualified class name and name of method as `transfer()`. As method arguments,
    I have used double dot (..), it means that the pointcut can select a method whose
    name is `transfer()` with no parameter or any number of parameters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，您可以看到，我使用了 `execution()` 设计器来选择 `TransferService` 的 `transfer()` 方法。在前图的先前表达式中，我在表达式的开头使用了星号。这意味着该方法可以返回任何类型。在星号之后，我指定了完全限定的类名和
    `transfer()` 方法名。作为方法参数，我使用了双点 (..)，这意味着切入点可以选择名为 `transfer()` 的方法，没有参数或任何数量的参数。
- en: 'Let''s see following some more pointcut expressions to select join points:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下一些更多的切入点表达式来选择连接点：
- en: 'Any class or package:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类或包：
- en: '**execution(void transfer*(String))**: Any method starting with transfer that
    takes a single String parameter and has a void return type'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**execution(void transfer*(String))**: 任何以 `transfer` 开头，接受单个 `String` 参数且返回类型为
    `void` 的方法'
- en: '**execution(* transfer(*))**: Any method named `transfer()` that takes a single
    parameter'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**execution(* transfer(*))**: 任何名为 `transfer()` 的方法，接受单个参数'
- en: '**execution(* transfer(int, ..))**: Any method named transfer whose first parameter
    is an int (the `".."` signifies zero or more parameters may follow)'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**execution(* transfer(int, ..))**: 任何名为 `transfer` 的方法，其第一个参数为整数（`".."` 表示可能跟有零个或多个参数）'
- en: 'Restrict by class:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制为类：
- en: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferServiceImpl.*(..))`:
    Any void method in the `TransferServiceImpl` class, it is including any sub-class,
    but will be ignored if a different implementation is used.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferServiceImpl.*(..))`:
    `TransferServiceImpl` 类中的任何无返回值的方法，包括任何子类，但如果使用了不同的实现，则会被忽略。'
- en: 'Restrict by interface:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制为接口：
- en: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferService.transfer(*))`:
    Any void `transfer()` method taking one argument, in any object implementing `TransferService`,
    it is more flexible choice--works if implementation changes.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferService.transfer(*))`:
    任何接受一个参数的 void `transfer()` 方法，在实现 `TransferService` 的任何对象中，这是一个更灵活的选择——如果实现发生变化，它仍然可以工作。'
- en: Using Annotations
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解
- en: '`execution(@javax.annotation.security.RolesAllowed void transfer*(..))`: Any
    void method whose name starts with `transfer` that is annotated with the `@RolesAllowed`
    annotation.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(@javax.annotation.security.RolesAllowed void transfer*(..))`: 任何以
    `transfer` 开头并带有 `@RolesAllowed` 注解的 void 方法。'
- en: Working with packages
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与包一起工作
- en: '`execution(* com..bankapp.*.*(..))`: There is one directory between `com` and
    `bankapp`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(* com..bankapp.*.*(..))`: `com` 和 `bankapp` 之间有一个目录'
- en: '`execution(* com.*.bankapp.*.*(..))`: There may be several directories between
    `bankapp` and `com`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(* com.*.bankapp.*.*(..))`: `bankapp` 和 `com` 之间可能有多个目录'
- en: '`execution(* *..bankapp.*.*(..))`: Any sub-package called `bankapp`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution(* *..bankapp.*.*(..))`: 任何名为 `bankapp` 的子包'
- en: Now that you have seen that the basics of writing pointcuts, let's see how to
    write the advice and declare the aspects that use those pointcuts
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了编写切入点的基础，让我们看看如何编写通知并声明使用这些切入点的方面
- en: Creating aspects
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方面
- en: As I said earlier, *aspects* is one of the most important terms in the AOP.
    Aspect merges the pointcuts and advices in the application. Let's see how to define
    aspect in the application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，*方面* 是 AOP 中最重要的术语之一。方面将应用中的切入点和建议合并。让我们看看如何在应用中定义方面。
- en: You've already defined the `TransferService` interface as the subject of your
    aspect's pointcuts. Now let's use AspectJ annotations to create an aspect.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将 `TransferService` 接口定义为你的方面切入点的主题。现在让我们使用 AspectJ 注解来创建一个方面。
- en: Define aspects using Annotation
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解定义方面
- en: 'Suppose in your bank application, you want to generate log for a money transfer
    service for auditing and tracking to understand customers'' behaviors. A business
    never succeeds without understanding its customers. Whenever you will think about
    it from the perspective of a business, an auditing is required but isn''t central
    to the function of the business itself; it''s a separate concern. Therefore, it
    makes sense to define the auditing as an aspect that''s applied to a transfer
    service. Let''s see the following code which shows the `Auditing` class that defines
    the aspects for this concern:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的银行应用中，你想要为审计和跟踪生成一个资金转账服务的日志，以了解客户的行为。一个业务如果不了解其客户就不会成功。无论你从商业的角度考虑什么，审计都是必要的，但它并不是业务本身的中心功能；它是一个单独的关注点。因此，将审计定义为应用于转账服务的方面是有意义的。让我们看看以下代码，它展示了定义这个关注点的
    `Auditing` 类：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see how the `Auditing` class is annotated with `@Aspect` annotation.
    It means this class is not just Spring bean, it is an aspect of the application.
    And `Auditing` class has some methods, these are advices and define some logic
    within these methods. As we know that before beginning to transfer amount from
    an account to another, bank will validate (`validate ()`) the use credentials
    and after that instantiate (`transferInstantiate()`) this service. After successful
    validation (`success ()`) amount is transferred and the bank audits it. But if
    the amount transferring fails in any case, then the bank should roll back (`rollback
    ()`) that amount.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Auditing` 类被 `@Aspect` 注解所标注。这意味着这个类不仅仅是一个 Spring Bean，它还是应用的一个方面。`Auditing`
    类有一些方法，这些方法就是通知，并在这些方法中定义了一些逻辑。正如我们所知，在开始从一个账户向另一个账户转账之前，银行会验证（`validate()`）使用凭证，然后实例化（`transferInstantiate()`）这个服务。验证成功（`success()`）后，金额被转账，银行会审计它。但如果金额转账在任何情况下失败，那么银行应该回滚（`rollback()`）这笔金额。
- en: 'As you can see, all methods of `Auditing` aspects are annotated with advice
    annotations to indicate when those methods should be called. Spring AOP provides
    five type advice annotations for defining advice. Let''s see in the following
    table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Auditing` 方面的所有方法都被注解了通知注解，以指示这些方法应该在何时被调用。Spring AOP 提供了五种类型的通知注解来定义通知。让我们在以下表中查看：
- en: '| **Annotation** | **Advice** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **注解** | **通知** |'
- en: '| `@Before` | It is used for before advice, `advice`''s method executes before
    the advised method is invoked. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `@Before` | 它用于前置通知，`advice` 的方法在建议方法被调用之前执行。|'
- en: '| `@After` | It is used for after advice, advice''s method execute after the
    advised method executes normally or abnormally doesn''t matter. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `@After` | 它用于后建议，建议的方法在受建议方法正常或异常执行后执行。|'
- en: '| `@AfterReturning` | It used for after returning advice, advice''s method
    execute after the advised method complete successfully. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterReturning` | 它用于返回后建议，建议的方法在受建议方法成功完成后执行。|'
- en: '| `@AfterThrowing` | It used for after throwing advice, advice''s method execute
    after the method terminate abnormally by throwing an exception. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterThrowing` | 它用于抛出后建议，建议的方法在方法通过抛出异常异常终止后执行。|'
- en: '| `@Around` | It is used for around advice, advice''s method executes before
    and after the advised method invoked. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `@Around` | 它用于环绕建议，建议的方法在调用受建议方法之前和之后执行。|'
- en: Let's see the implementation of advices and how these work in the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看建议的实现以及它们如何在应用程序中工作。
- en: Implementing Advice
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议实现
- en: As you know that, Spring provides five types of advices, let's see work flow
    of one by one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，Spring提供了五种类型的建议，让我们逐一看看它们的工作流程。
- en: Advice type - Before
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议类型 - 在前
- en: 'Let''s see the following figure for before advice. This advice executes the
    before the target method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于前建议的图示。此建议在目标方法之前执行：
- en: '![](img/2326ca56-3752-4323-8173-14d3d5077e09.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2326ca56-3752-4323-8173-14d3d5077e09.png)'
- en: As you can see in figure, before advice is executed first and then it calls
    the **Target** method. As we know that Spring AOP is proxy-based. So a **Proxy**
    object is created of target class. It is based on Proxy design pattern and Decorator
    Design Pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中看到的，前建议首先执行，然后调用**目标**方法。正如我们所知，Spring AOP是基于代理的。因此，创建了一个目标类的**代理**对象。它是基于代理设计模式和装饰器设计模式。
- en: Before Advice example
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前建议示例
- en: 'Let''s see the use of `@Before` annotation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`@Before`注解的使用：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note--if the advice throws an exception, target will not be called--this is
    a valid use of a Before Advice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 - 如果建议抛出异常，则目标方法不会被调用 - 这是有效使用前建议的情况。
- en: Now you have seen the before advice, let's have a look into another type advice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了前建议，让我们看看另一种类型的建议。
- en: 'Advice Types: After Returning'
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议类型：返回后
- en: 'Let''s see the following figure for after returning advice. This advice executes
    the after the **Target** method executed successfully:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于返回后建议的图示。此建议在**目标**方法成功执行后执行：
- en: '![](img/83caf5aa-cf58-49e4-a856-16798371089a.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83caf5aa-cf58-49e4-a856-16798371089a.png)'
- en: As you can see in figure, the after returning advice is executed after the target
    returns successfully. This advice will never execute if target throws any exception
    in the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中看到的，返回后建议在目标成功返回后执行。如果目标在应用程序中抛出任何异常，则此建议将不会执行。
- en: After Returning Advice example
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回后建议示例
- en: 'Let''s see the use of the `@AfterReturning` annotation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`@AfterReturning`注解的使用：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you have seen the after returning advice, let's move to another type advice
    in the Spring AOP.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了返回后建议，让我们转向Spring AOP中的另一种类型建议。
- en: 'Advice Types: After Throwing'
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议类型：抛出后
- en: 'Let''s see the following figure for after throwing advice. This advice executes
    the after the target method terminated abnormally. It mean the `target` method
    throws any exception, then this advice will be executed. Please refer to the following
    diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于抛出后建议的图示。此建议在目标方法异常终止后执行。这意味着`target`方法抛出任何异常，然后此建议将被执行。请参考以下图表：
- en: '![](img/aa71dc23-ee24-4fe2-9ff6-46379859a877.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa71dc23-ee24-4fe2-9ff6-46379859a877.png)'
- en: As you can see in figure, the after throwing advice is executed after the target
    throws an exception. This advice will never execute if the target doesn't throw
    any exception in the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中看到的，抛出后建议在目标抛出异常后执行。如果目标在应用程序中没有抛出任何异常，则此建议将不会执行。
- en: After Throwing Advice example
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出后建议示例
- en: 'Let''s see the use of the `@AfterThrowing` annotation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`@AfterThrowing`注解的使用：
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the `@AfterThrowing` annotation with the throwing attribute,
    it only invokes advice if the right exception type is thrown:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用带有抛出属性的`@AfterThrowing`注解，它仅在抛出正确的异常类型时调用建议：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Execute every time a `TransferService` class throws an exception of type `DataAccessException`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`TransferService`类抛出`DataAccessException`类型的异常时，都会执行。
- en: The `@AfterThrowing` advice will not stop the exception from propagating. However,
    it can throw a different type of exception.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AfterThrowing` 建议不会阻止异常的传播。然而，它可以抛出不同类型的异常。'
- en: 'Advice Types: After'
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议类型：在后
- en: 'Let''s see the following figure for **AfterAdvice**. This advice executes after
    the **Target** method is terminated normally or abnormally. It doesn''t matter
    that **Target** method throws any exception or executes without any exception:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图来了解 **AfterAdvice**。这个建议在 **Target** 方法正常或异常终止后执行。无论 **Target** 方法是否抛出异常或无异常执行，都没有关系：
- en: '![](img/1b0871fc-98a6-47c9-93c3-cc2f3b299093.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b0871fc-98a6-47c9-93c3-cc2f3b299093.png)'
- en: As you can see in figure, the after advice is executed after the `target` method
    terminates by throwing any exception or normally.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，在 `target` 方法通过抛出任何异常或正常终止后，将执行后建议。
- en: After Advice example
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: After 建议 示例
- en: 'Let''s see the use of `@After` annotation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `@After` 注解的使用：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use `@After` annotation called regardless of whether an exception has been thrown
    by the target or not.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@After` 注解，无论目标是否抛出异常，都会被调用。
- en: Advice Types - Around
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议类型 - Around
- en: 'Let''s see the following figure for **AroundAdvice**. This advice executes
    both times before and after the **Target** method is invoked. This advice is very
    powerful advice of Spring AOP. Many features of the Spring Framework are implemented
    by using this advice. This is the only advice in Spring which has capability to
    stop or proceed the target method execution. Please refer to the following diagram:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图来了解 **AroundAdvice**。这个建议在调用 **Target** 方法之前和之后都执行。这是 Spring AOP 中非常强大的建议。Spring
    框架的许多功能都是通过使用这个建议实现的。这是 Spring 中唯一一个具有停止或继续目标方法执行能力的建议。请参考以下图表：
- en: '![](img/f85e8209-cdcc-4a3f-8bfa-9b7d79f40e51.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f85e8209-cdcc-4a3f-8bfa-9b7d79f40e51.png)'
- en: 'As you can see in the preceding figure, **AroundAdvice** executed two times,
    first time it is executed before the advised method and second time it is executed
    after advised method is invoked. And also this advice calls the `proceed()` method
    to execute the advised method in the application. Let''s see the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**AroundAdvice** 执行了两次，第一次是在被建议的方法执行之前，第二次是在被建议的方法被调用之后。此外，这个建议还调用了 `proceed()`
    方法来在应用程序中执行被建议的方法。让我们看看下面的例子：
- en: Around Advice example
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Around 建议示例
- en: 'Let''s see the use of the `@Around` annotation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `@Around` 注解的使用：
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here I used `@Around` annotation and a `ProceedingJoinPoint`, it inherits from
    Join Point and adds the `proceed()` method. As you can see in this example, this
    advice proceeds to target only if value is not already in the cache.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了 `@Around` 注解和一个 `ProceedingJoinPoint`，它继承自 Join Point 并添加了 `proceed()`
    方法。正如您在这个例子中所看到的，这个建议只有在值尚未在缓存中时才会继续执行目标。
- en: You have seen how to implement the advice in the application using annotations
    and how to create aspect and how to define pointcuts by annotations. In this example,
    we are using Auditing as an aspect class and it is annotated with `@Aspect` annotation,
    but this annotation will not work if you don't enable AOP proxy behavior of the
    Spring.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何在应用程序中使用注解实现建议，如何创建方面以及如何通过注解定义切入点。在这个例子中，我们使用 Auditing 作为方面类，并且它被 `@Aspect`
    注解所标记，但如果您没有启用 Spring 的 AOP 代理行为，这个注解将不起作用。
- en: 'Let''s see the following Java configuration file, `AppConfig.java`, you can
    turn on auto-proxying by applying the `@EnableAspectJAutoProxy` annotation at
    the class level:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 Java 配置文件，`AppConfig.java`，您可以通过在类级别应用 `@EnableAspectJAutoProxy` 注解来开启自动代理：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you''re using XML configuration, let''s see how to wire your beans in Spring
    and how to enable Spring AOP feature by using the `<aop:aspectj-autoproxy>` element
    from Spring''s AOP namespace:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 XML 配置，让我们看看如何在 Spring 中连接您的豆子以及如何通过使用 Spring AOP 命名空间中的 `<aop:aspectj-autoproxy>`
    元素来启用 Spring AOP 功能：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's see how you can declare aspects in a Spring XML configuration file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Spring XML 配置文件中声明方面。
- en: Define aspects using XML configuration
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 配置定义方面
- en: 'As we know that, we can configure beans in the XML based configuration, similarly
    you can declare aspects in the XML configuration. Spring provides another AOP
    namespace and it offers many elements that are used to declare aspects in XML,
    let''s see in the following tables:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们可以在基于 XML 的配置中配置豆子，同样您也可以在 XML 配置中声明方面。Spring 提供了另一个 AOP 命名空间，它提供了许多用于在
    XML 中声明方面的元素，让我们在以下表中看看：
- en: '| **Annotation** | **Parallel XML element** | **Purpose of XML element** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **注解** | **并行 XML 元素** | **XML 元素的目的** |'
- en: '| `@Before` | `<aop:before>` | It defines before advice. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `@Before` | `<aop:before>` | 它定义了前建议。 |'
- en: '| `@After` | `<aop:after>` | It defines after advice. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `@After` | `<aop:after>` | 它定义了后建议。 |'
- en: '| `@AfterReturning` | `<aop:after-returning>` | It defines after returning
    advice. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterReturning` | `<aop:after-returning>` | 它定义了返回后通知。|'
- en: '| `@AfterThrowing` | `<aop:after-throwing>` | It defines after throwing advice.
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterThrowing` | `<aop:after-throwing>` | 它定义了抛出后通知。|'
- en: '| `@Around` | `<aop:around>` | It defines around advice. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `@Around` | `<aop:around>` | 它定义了环绕通知。|'
- en: '| `@Aspect` | `<aop:aspect>` | It defines an aspect. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `@Aspect` | `<aop:aspect>` | 它定义了一个方面。|'
- en: '| `@EnableAspectJAutoProxy` | `<aop:aspectj-autoproxy>` | It enables annotation-driven
    aspects using `@AspectJ`. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `@EnableAspectJAutoProxy` | `<aop:aspectj-autoproxy>` | 它通过 `@AspectJ` 启用注解驱动的方面。|'
- en: '| `@Pointcut` | `<aop:pointcut>` | It defines a pointcut. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `@Pointcut` | `<aop:pointcut>` | 它定义了一个切入点。|'
- en: '| -- | `<aop:advisor>` | It define AOP adviser |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| -- | `<aop:advisor>` | 它定义了 AOP 顾问|'
- en: '| -- | `<aop:config>` | It is top level AOP element |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| -- | `<aop:config>` | 它是顶级 AOP 元素|'
- en: 'As you can see in the preceding table, a number of AOP namespace elements are
    parallel to the corresponding annotation available in the Java based configuration.
    Let''s see the following same example in the XML based configuration, first have
    a look into the aspect class `Auditing`. Let''s remove all of those AspectJ annotations
    as shown in following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的表中所见，许多 AOP 命名空间元素与基于 Java 的配置中可用的相应注解并行。让我们看看以下基于 XML 的配置中的相同示例，首先看看方面类
    `Auditing`。让我们移除以下代码中显示的所有 AspectJ 注解：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see the preceding code, now our aspect class doesn''t indicate that
    it is an aspect class. It is a basic Java POJO class with some methods. Let''s
    see in next section how to declare advices in XML configuration:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中所见，现在我们的方面类没有表明它是一个方面类。它是一个基本的 Java POJO 类，包含一些方法。让我们在下一节中看看如何在 XML
    配置中声明通知：
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `<aop-config>` is using a top level element. In `<aop:config>`,
    you declare other elements like `<aop:aspect>`, this element has `ref` attribute
    and it references to the POJO bean Auditing. It indicates that `Auditing` is an
    aspect class in the application. Now `<aop-aspect>` element has advices and pointcuts
    elements. All logics are same as we have defined in Java configuration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`<aop-config>` 使用了一个顶级元素。在 `<aop:config>` 中，你声明其他元素，如 `<aop:aspect>`，这个元素有
    `ref` 属性，它引用了 POJO 实例 Auditing。这表明 `Auditing` 是应用程序中的一个方面类。现在 `<aop-aspect>` 元素有通知和切入点元素。所有逻辑都与我们在
    Java 配置中定义的相同。
- en: Let's see in the next section how spring create AOP proxy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看 Spring 如何创建 AOP 代理。
- en: Understanding AOP proxies
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 AOP 代理
- en: 'As you know that, Spring AOP is proxy-based. It mean Spring creates the proxy
    to weave the aspect between the business logic that is, in `target` object. It
    is based on the Proxy and Decorator design pattern. Let''s see `TransferServiceImpl`
    class as an implementation of `TransferService` interface:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Spring AOP 是基于代理的。这意味着 Spring 创建代理来在业务逻辑（即 `target` 对象）之间编织方面。它是基于代理和装饰器设计模式的。让我们看看
    `TransferServiceImpl` 类作为 `TransferService` 接口的一个实现：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Caller invokes this service (`transfer()` method) directly by the object reference,
    let''s see the following figure to illustrate more:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者通过对象引用直接调用此服务（`transfer()` 方法），让我们看看以下图解以了解更多：
- en: '![](img/32f326cc-3a54-42ad-8912-5e0b5346bb20.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32f326cc-3a54-42ad-8912-5e0b5346bb20.png)'
- en: As you can see that caller could directly call the service and do the task assigned
    to it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，调用者可以直接调用服务并执行分配给它的任务。
- en: But you declare this `TransferService` as a target for the aspect. Since this
    is done, things change slightly. Now this class wrapped by proxy and client code
    actually doesn't call this service directly, it calls routed by this proxy. Let's
    see the following diagram.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但你将这个 `TransferService` 声明为方面的目标。由于这样做，事情略有变化。现在这个由代理包装的类，客户端代码实际上并不直接调用这个服务，而是通过这个代理进行路由。让我们看看下面的图解。
- en: '![](img/0488bcb2-9014-4db0-b912-7f2e31556772.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0488bcb2-9014-4db0-b912-7f2e31556772.png)'
- en: 'As you can see in the preceding diagram, Spring apply the AOP-proxy to the
    object in the following sequence:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图解中所见，Spring 按以下顺序将 AOP 代理应用于对象：
- en: Spring creates a proxy weaving aspect and target.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 创建了一个编织方面和目标的代理。
- en: Proxy also implements target interface, that is, `TransferServive` interface.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理也实现了目标接口，即 `TransferServive` 接口。
- en: All calls for transfer service method `transfer()` routed through proxy interceptor.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有对传输服务方法 `transfer()` 的调用都通过代理拦截器路由。
- en: Matching advice is executed.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配的通知被执行。
- en: Then `target` method is executed.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 `target` 方法被执行。
- en: As preceding list, is the flow when you call the method that has the proxy created
    by Spring.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述列表，这是当你调用由 Spring 创建的代理的方法时的流程。
- en: You have seen in this chapter the Spring AOP Framework, it has actually implemented
    some part of the AspectJ Framework using proxy-based aspect weaving. I think,
    this gave good knowledge about Spring AOP.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中已经看到了 Spring AOP 框架，它实际上使用基于代理的方面织入实现了 AspectJ 框架的一部分。我认为，这为 Spring AOP
    提供了很好的知识。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen the Spring AOP Framework and used design patterns
    behind this module. AOP is a very powerful paradigm and it complements the Object
    oriented programming. **Aspect-Oriented Programming** (**AOP**) modularizes cross-cutting
    concerns such as Logging, Security and Transaction. An aspect is a Java class
    annotated with `@Aspect` annotation. It defines a module containing the crosscutting
    behavior. This module separates from the application's business logic. We can
    reuse it in our application with other business modules without making any changes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 Spring AOP 框架并使用了该模块背后的设计模式。AOP 是一个非常强大的范式，它补充了面向对象编程。**面向切面编程**（**AOP**）模块化了跨切面关注点，如日志记录、安全和事务。方面是一个带有
    `@Aspect` 注解的 Java 类。它定义了一个包含跨切面行为的模块。此模块与应用程序的业务逻辑分离。我们可以在应用程序中与其他业务模块一起重用它，而无需进行任何更改。
- en: In Spring AOP, behavior is implemented as an advice method. You have learned
    in Spring, there are five types as Before, AfterThrowing, AfterReturning, After
    and Around. Around advice is a very powerful advice, there are interesting features
    implemented by using Around advice. You've learned how to weave these advices
    using load time weaving.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring AOP 中，行为被实现为一个建议方法。您在 Spring 中已经学到，有五种类型，分别是 Before、AfterThrowing、AfterReturning、After
    和 Around。Around 建议是一个非常强大的建议，通过使用 Around 建议实现了有趣的功能。您已经学到了如何使用加载时织入来织入这些建议。
- en: You have seen how to declare Pointcuts in the Spring application and pointcuts
    select joinpoints where advice applies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何在 Spring 应用程序中声明切入点，切入点选择建议应用的位置。
- en: Now we'll move to the essential part and look at how spring works in the backend
    to connect with database and read data for the application. Starting in the next
    chapter, you'll see how to build applications using JDBC template in Spring.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向关键部分，看看 Spring 如何在后台工作以连接数据库并读取应用程序的数据。从下一章开始，您将看到如何使用 Spring 中的 JDBC
    模板构建应用程序。
