- en: Model-View-Controller Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器架构
- en: In this chapter, we will dive into one of the most common architectural patterns
    used by frameworks today.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究当今框架中使用的最常见的架构模式之一。
- en: The **Model-View-Controller** (**MVC**) architectural pattern was formulated
    in 1979 by Trygve Reenskaug. This was one of the first attempts to create an organized
    method for working on graphical user interfaces. Although many years have passed
    since then, this pattern continues to be quite popular even in the most modern
    UI frameworks. This is because it is designed to build almost any type of application,
    including the most common types of applications, such as mobile, desktop, and
    web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）架构模式是由Trygve Reenskaug于1979年制定的。这是对图形用户界面进行组织化工作的最早尝试之一。尽管从那时起已经过去了许多年，但这种模式在最现代的UI框架中仍然非常受欢迎。这是因为它旨在构建几乎任何类型的应用程序，包括最常见的应用程序类型，如移动应用程序、桌面应用程序和Web应用程序。'
- en: The popularity of this pattern mostly comes down to the ease of understanding
    it. MVC provides an excellent way to separate applications into three different
    components, which we will review in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的流行主要归结于易于理解。MVC提供了一种将应用程序分成三个不同组件的绝佳方法，我们将在本章中进行审查。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'The elements of MVC:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC的元素：
- en: Model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: View
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看
- en: Controller
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: The benefits of using MVC architectures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVC架构的好处
- en: Common pitfalls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: 'Implementing applications using MVC:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVC实现应用程序：
- en: Spring MVC
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC
- en: Testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: 'UI frameworks: Thymeleaf'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI框架：Thymeleaf
- en: 'Securing an MVC application:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护MVC应用程序：
- en: Basic authentication
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: HTTP and HTTPS
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP和HTTPS
- en: MVC
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC
- en: 'The idea of supporting the MVC pattern was developed as a part of Trygve Reenskaug''s
    research in which he concluded the following key idea:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 支持MVC模式的想法是作为Trygve Reenskaug研究的一部分而发展的，他得出了以下关键思想：
- en: '"MVC was conceived as a general solution to the problem of users controlling
    a large and complex data set. The hardest part was to hit upon good names for
    the different architectural components. Model-View-editor was the first set. "'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “MVC被构想为解决用户控制大型和复杂数据集的问题的一般解决方案。最困难的部分是找到不同架构组件的良好名称。模型-视图-编辑器是第一套。”
- en: – [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '- [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html)'
- en: 'One of the biggest problems in computer science is related to naming things,
    which is why the original name was Model-View-Editor. It later evolved into MVC,
    as mentioned in the preceding link:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中最大的问题之一与命名有关，这就是为什么最初的名称是模型-视图-编辑器。后来演变成了MVC，如前面的链接中所述：
- en: '"After long discussions, particularly with Adele Goldberg, we ended with the
    terms Model-View-Controller."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “经过长时间的讨论，特别是与Adele Goldberg的讨论，我们最终确定了模型-视图-控制器这些术语。”
- en: MVC is a software architectural pattern that makes it possible to establish
    a clear separation between the domain objects of an application (where the business
    logic resides) and the elements that are used to build the UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种软件架构模式，可以在应用程序的领域对象（业务逻辑所在的地方）和用于构建UI的元素之间建立明确的分离。
- en: With this concept in mind, the isolation and separation of concerns between
    these parts are quite important. They also constitute the underlying principles
    to build applications using this pattern. In following sections, let's review
    how the business logic and presentation layer of an application fits within the
    MVC pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这个概念，这些部分之间的隔离和关注点的分离非常重要。它们也构成了使用这种模式构建应用程序的基本原则。在接下来的章节中，让我们来看看应用程序的业务逻辑和表示层如何适应MVC模式。
- en: The Model (M)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型（M）
- en: Within this context, the **Model** represents the domain objects needed to express
    the business logic supporting the requirements inherent to the application. It's
    here that all of the use cases are represented as real-world abstractions and
    a well-defined API is made available to be consumed by any kind of delivery mechanism,
    such as the web.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**模型**代表了表达支持应用程序固有要求的业务逻辑所需的领域对象。在这里，所有用例都被表示为现实世界的抽象，并且一个明确定义的API可供任何一种交付机制（如Web）使用。
- en: Regarding traditional applications, all of the logic to interact with a database
    or middleware is implemented in the Model. However, the Model (the M in MVC) should
    expose functionalities (in terms of the business) that are easy to understand.
    We should also avoid building anemic models that only allow for interacting with
    the database and are difficult to understand for the rest of the team working
    on the project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于传统应用程序，与数据库或中间件交互的所有逻辑都是在模型中实现的。然而，模型（MVC中的M）应该暴露易于理解的功能（从业务角度）。我们还应该避免构建贫血模型，这些模型只允许与数据库交互，并且对于项目其他成员来说很难理解。
- en: Once this part of the application has been coded, we should ideally be able
    to create any UI that allows the users to interact with the Model. Furthermore, since
    UIs can defer from each other (mobile, web, and desktop apps), the Model should
    be agnostic to all of them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序的这一部分被编码，我们应该能够创建任何允许用户与模型交互的UI。此外，由于UI可能彼此不同（移动应用程序、Web和桌面应用程序），模型应该对所有这些都是不可知的。
- en: In a perfect world, an isolated team would be able to build this part of the
    application, but in real life, this assumption is entirely wrong. Interaction
    with the team in charge of building the GUI is required, in order to create an
    effective Model that is able to address all of the business requirements and expose
    a comprehensive API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，一个独立的团队将能够构建应用程序的这一部分，但在现实生活中，这种假设完全是错误的。需要与负责构建GUI的团队进行交互，以创建一个能够满足所有业务需求并公开全面API的有效模型。
- en: The View (V)
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图（V）
- en: The **View** is a visual representation of the Model (M in MVC) but with some
    subtle differences. As a part of these differences, the View tends to remove,
    add, and/or transform specific Model attributes, with the aim of making the Model
    understandable for the users interacting with the View.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是模型（MVC中的M）的视觉表示，但有一些细微的差异。作为这些差异的一部分，视图倾向于删除、添加和/或转换特定的模型属性，目的是使模型对与视图交互的用户可理解。'
- en: Since the Model is sometimes complex, many views can be used to represent one
    part of it, and, conversely, many parts of the Model can be included as only one
    part of the View.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型有时很复杂，可以使用多个视图来表示其一部分，反之亦然，模型的许多部分可以作为视图的一部分。
- en: The Controller (C)
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器（C）
- en: A **Controller** is a link between the end user of an application and the business
    logic implemented by the Model. Controllers are objects in charge of taking user
    input and figuring out what part of the Model should be invoked to achieve defined
    business goals. As a result of this interaction, the Model is often changed, and
    these changes should be propagated to the views using Controllers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是应用程序的最终用户和模型实现的业务逻辑之间的链接。控制器是负责接受用户输入并确定应调用模型的哪个部分以实现定义的业务目标的对象。作为这种交互的结果，模型经常会发生变化，并且应该使用控制器将这些变化传播到视图中。'
- en: Direct communication between the View and the Model must never happen since
    it constitutes a violation of how this pattern works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和模型之间绝对不能直接通信，因为这构成了对这种模式工作方式的违反。
- en: 'Keeping the preceding tip in mind, all communication should be done in a specific
    order from each part of the MVC pattern, passing the information from the View
    to the Controller and from the Controller to the Model, and never directly from
    the Model to the View, as illustrated in the following interaction diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记前面的提示，所有通信应按照MVC模式的特定顺序进行，从视图传递信息到控制器，从控制器传递信息到模型，而不是直接从模型到视图，如下面的交互图所示：
- en: '![](img/0396a5e1-c22c-4a1b-8c43-23e0f91f3043.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0396a5e1-c22c-4a1b-8c43-23e0f91f3043.png)'
- en: MVC interaction diagram
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: MVC交互图
- en: In order to propagate these changes, the View elements are bound to representations
    in the Controllers, which makes it possible to manipulate them as required. The
    process of updating a View occurs when the Model is updated, and it often involves
    reloading data or hiding/showing certain elements in the View.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传播这些变化，视图元素与控制器中的表示绑定在一起，这样就可以根据需要对其进行操作。当模型更新时，更新视图的过程会发生，并且通常涉及重新加载数据或在视图中隐藏/显示某些元素。
- en: When a change should be propagated to more than one element in the View, various
    Controllers can work together collaboratively to achieve the goal. In these cases,
    a simple implementation of the observer design pattern can often be useful for
    avoiding entangled code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将更改传播到视图中的多个元素时，各种控制器可以协同工作以实现目标。在这些情况下，观察者设计模式的简单实现通常可以有助于避免纠缠的代码。
- en: 'The following diagram is a graphical representation of how the pieces in this
    pattern are arranged, in either the presentation or business logic layer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是这种模式中的部分如何排列的图形表示，无论是在演示层还是业务逻辑层：
- en: '![](img/b43675b9-a457-4b7c-a7ea-498fd0ead679.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b43675b9-a457-4b7c-a7ea-498fd0ead679.png)'
- en: MVC graphical representation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MVC图形表示
- en: Benefits of using MVC
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVC的好处
- en: MVC provides many benefits for applications that are implemented using it; the
    main benefit is the clear separation of concerns, with a single responsibility
    for each part of the application, thereby avoiding messing up the code and making
    the code easy to understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MVC为使用它实现的应用程序提供了许多好处；主要好处是关注点的清晰分离，每个应用程序部分都有单一的责任，从而避免混乱的代码并使代码易于理解。
- en: 'While Controllers and views are tied together to build the visual representation
    of the application using MVC, the Model is absolutely isolated. This makes it
    possible to reuse the same Model to create a different kind of application, including,
    but not limited to, the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制器和视图在使用MVC构建应用程序的可视表示时是相互关联的，但模型是绝对隔离的。这使得可以重用相同的模型来创建不同类型的应用程序，包括但不限于以下内容：
- en: Mobile
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Web
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Desktop
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面
- en: You might be tempted to conclude that a project developed using this Model can
    count on teams working in parallel, but separately, during the development phase,
    which is true in some cases, but not a rule in general. As mentioned previously,
    effective communication across teams is still necessary for building the application
    as a whole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为使用这种模型开发的项目可以依靠在开发阶段同时但分别工作的团队，这在某些情况下是正确的，但并不是普遍规则。如前所述，跨团队的有效沟通仍然对整体构建应用程序是必要的。
- en: Common pitfalls
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: 'When we work on applications using MVC, it''s common to find projects structured
    following the MVC acronym, as the following diagram illustrates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用MVC开发应用程序时，通常会发现项目按照MVC首字母缩写结构化，如下图所示：
- en: '![](img/dad7ede6-b98c-4094-b684-939f57a30d17.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dad7ede6-b98c-4094-b684-939f57a30d17.png)'
- en: MVC project structure
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MVC项目结构
- en: 'This directory structure indicates the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录结构表示以下内容：
- en: The project name is **abc-web**
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称是**abc-web**
- en: This is a web application
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个Web应用程序
- en: The application uses the MVC architecture (structure)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序使用MVC架构（结构）
- en: Unfortunately, none of these points provide meaningful information for the team
    in charge of creating or maintaining an application. That is because a team working
    on a project is not interested in the file organization. Instead, it's much more
    useful to organize your code according to business rules, use cases, or other
    factors related to the business itself, rather than the technical aspects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些观点都没有为负责创建或维护应用程序的团队提供有意义的信息。这是因为一个项目的团队并不关心文件组织。相反，根据业务规则、用例或与业务本身相关的其他因素来组织代码要更有用得多，而不是技术方面。
- en: 'With this idea in mind, we will suggest that a much more useful directory structure
    is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个想法，我们建议一个更有用的目录结构如下：
- en: '![](img/98cc2f43-58d8-4774-ba84-3624b3095bf4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98cc2f43-58d8-4774-ba84-3624b3095bf4.png)'
- en: Understandable project structure
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可理解的项目结构
- en: 'From this diagram, we can infer the following points:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中，我们可以推断出以下几点：
- en: This is an **accounting** system.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个**会计**系统。
- en: 'The main features of the project are related to the following, and more:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的主要特点与以下内容相关：
- en: Income
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Income
- en: Expenses
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expenses
- en: Reporting
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告
- en: Using the project layout shown in the preceding diagram, if we are tasked with
    fixing a report that is no longer working, we can think about reviewing the reporting
    folder. This approach is helpful for reducing the amount of time and effort required
    to accomplish project tasks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面图表中显示的项目布局，如果我们被要求修复一个不再工作的报告，我们可以考虑审查报告文件夹。这种方法有助于减少完成项目任务所需的时间和精力。
- en: We can conclude that the information provided by the second project structure
    is much more useful and practical, in comparison to the first one, since the first
    one does not provide information regarding the business at all.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，第二个项目结构提供的信息比第一个更有用和实用，因为第一个根本没有提供有关业务的信息。
- en: Every single part of the project should communicate information regarding the
    business, rather than concerning the delivery mechanism or pattern used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的每个部分都应该传达有关业务的信息，而不是关于使用的交付机制或模式。
- en: 'These details are small, but they are essential. At the beginning of this book,
    we mentioned that a good architecture is built around business requirements, and
    any goal that an architecture pursues should be understood by the whole team.
    We should approach every single detail with an aim to achieve this goal. Remember:
    details matter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节很小，但很重要。在本书的开头，我们提到一个良好的架构是围绕业务需求构建的，架构追求的任何目标都应该被整个团队理解。我们应该以实现这个目标为目标来处理每一个细节。记住：细节很重要。
- en: Implementing applications using MVC
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVC实现应用程序
- en: Now that you understand the theory behind MVC architectures, it is time to put
    the concepts that you have learned into practice and to see how the Spring Framework
    implements them. We are going to start by reviewing Spring MVC, which is the project
    that allows us to achieve this architectural style.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了MVC架构背后的理论，是时候将你学到的概念付诸实践，看看Spring框架如何实现它们。我们将从回顾Spring MVC开始，这是一个允许我们实现这种架构风格的项目。
- en: Spring MVC
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC
- en: Spring provides support for the MVC architectural pattern through Spring MVC.
    This Spring project allows for incorporating a vast set of UI frameworks, in order
    to build forms and related components that will enable users to interact with
    the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过Spring MVC提供对MVC架构模式的支持。这个Spring项目允许整合大量的UI框架，以构建表单和相关组件，使用户能够与应用程序进行交互。
- en: Spring MVC is built on top of the servlet API, which is designed to create web
    applications. There is no way to create a desktop, or any other kind of application,
    using this. Even though the MVC architectural pattern can be applied to all of
    them, Spring MVC is only focused on the web.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是建立在servlet API之上的，它旨在创建Web应用程序。没有办法使用它来创建桌面或任何其他类型的应用程序。尽管MVC架构模式可以应用于所有这些应用程序，但Spring
    MVC只专注于Web。
- en: Spring MVC is formally known as Spring Web MVC.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC正式称为Spring Web MVC。
- en: 'Despite the large number of View technologies supported by Spring MVC, the
    one most commonly used tends to be Thymeleaf, because of its smooth integration.
    However, you can also use another framework, such as the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring MVC支持大量的视图技术，但最常用的技术往往是Thymeleaf，因为它的集成非常顺畅。但是，你也可以使用其他框架，比如以下的：
- en: JSF
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF
- en: FreeMarker
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeMarker
- en: Struts
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Struts
- en: GWT
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GWT
- en: Spring MVC is designed around the front-Controller pattern, which relies on
    a single object to handle all of the incoming requests and provide the respective
    responses. In the case of Spring MVC, this object is represented by a `Servlet`
    implemented by the `org.springframework.web.servlet.DispatcherServlet` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是围绕前端控制器模式设计的，它依赖于一个对象来处理所有传入的请求并提供相应的响应。在Spring MVC的情况下，这个对象由`Servlet`实现，由`org.springframework.web.servlet.DispatcherServlet`类表示。
- en: 'This `Servlet` is in charge of delegating the requests to the Controllers and
    rendering the corresponding page on the screen, with the desired data. The following
    diagram shows how `DispatcherServlet` processes the requests:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Servlet`负责将请求委托给控制器，并在屏幕上呈现相应的页面，带有所需的数据。以下图表显示了`DispatcherServlet`如何处理请求：
- en: '![](img/b206a811-4848-457e-9e13-199f9655a0ec.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b206a811-4848-457e-9e13-199f9655a0ec.png)'
- en: DispatcherServlet request processing
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: DispatcherServlet请求处理
- en: In the preceding diagram, we can see that Controller is a Java class and **View**
    is an HTML file. In the latter case, we can also use any `tag-library/template-engine` tag
    that will later be compiled as HTML code that is rendered in a web browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到`Controller`是一个Java类，`View`是一个HTML文件。在后一种情况下，我们还可以使用任何`tag-library/template-engine`标签，它将被编译为在Web浏览器中呈现的HTML代码。
- en: 'A Controller in Spring is created using the `@Controller` annotation over the
    class name, as shown in the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，使用`@Controller`注解在类名上创建一个控制器，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that the class is marked as a Controller, we need to indicate what request
    mapping will be handled, and what actions need to be executed as a part of the
    request processing. In order to support this functionality, we need to write a
    simple method using the `@RequestMapping` annotation, as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类被标记为一个控制器，我们需要指示将处理什么请求映射，并作为请求处理的一部分需要执行什么操作。为了支持这个功能，我们需要使用`@RequestMapping`注解编写一个简单的方法，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the preceding method handles the incoming request from the `/ABC` path**,**
    and, once the processing is done, a `ui-template`is provided, to be rendered on
    the browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的方法处理来自`/ABC`路径的传入请求，一旦处理完成，将提供一个`ui-template`，以在浏览器上呈现。
- en: This operation is done by Spring MVC using View resolvers, which will look to
    render a file with the name `ui-template.html`. You can also write custom resolvers
    to add suffixes or prefixes to your views, if required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作是由Spring MVC使用视图解析器完成的，它将查找渲染名为`ui-template.html`的文件。如果需要，您还可以编写自定义解析器来为视图添加后缀或前缀。
- en: When we need to pass data from the Controller to the View, we can use the `Model`
    object, enabled by Spring View resolvers. This object can be populated with any
    data that you want to use in your views. In the same way, when the user submits
    data from the views, this object is populated with the entered information, which
    the Controllers can use to perform any desired logic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从控制器传递数据到视图时，我们可以使用`Model`对象，由Spring视图解析器启用。这个对象可以填充任何您想在视图中使用的数据。同样，当用户从视图提交数据时，这个对象将填充输入的信息，控制器可以使用它来执行任何所需的逻辑。
- en: 'In order to send data from the Controller to the View, we need to include the
    `Model` object as an argument in the method that handles the request, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从控制器发送数据到视图，我们需要在处理请求的方法中将`Model`对象作为参数包含，如下所示：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All templates have the ability to read the attributes passed from the Controller
    using the `${...}` syntax, known as expression language:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板都可以使用`${...}`语法（称为表达式语言）读取从控制器传递的属性：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, if you want to pass data from View components to the Controller,
    you have to populate an object in the View (using a form, for example), as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想要将数据从视图组件传递到控制器，您必须在视图中填充一个对象（例如使用表单），如下所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the object fields are populated and the submit button is pressed, the
    request will be sent, so that we can declare a method to handle the request:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象字段被填充并且提交按钮被按下，请求将被发送，以便我们可以声明一个方法来处理请求：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, you may have noticed that we are using `@ModelAttribute` to capture
    the data that was sent in the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能已经注意到我们使用`@ModelAttribute`来捕获请求中发送的数据。
- en: Testing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is crucial to our applications. When we use Spring MVC, we can count
    on the `spring-test` module to add support for unit and integration tests that
    are context-aware, which means that we can rely on annotations to wire dependencies.
    We can also use the `@Autowired` annotation to test a specific component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对我们的应用程序至关重要。当我们使用Spring MVC时，我们可以依赖`spring-test`模块来添加对上下文感知的单元测试和集成测试的支持，这意味着我们可以依赖注解来连接依赖项。我们还可以使用`@Autowired`注解来测试特定组件。
- en: 'The following is an example of how simple it is to write a test that is context-aware:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，演示了编写一个上下文感知的测试有多简单：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s review the code in bold, in order to understand how it works:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下粗体字的代码，以了解它是如何工作的：
- en: The first two annotations do all of the work for us; they will allow running
    our tests inside of a servlet container, and the Spring Boot annotations used
    for testing will wire all of the classes in the same way as the code running in
    production.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个注解为我们完成了所有的工作；它们将允许我们在Servlet容器内运行我们的测试，并且用于测试的Spring Boot注解将以与在生产中运行的代码相同的方式连接所有类。
- en: Since we added the previously mentioned annotations, we can now wire the components
    that we want to test using the `@Autowired` annotation.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们添加了前面提到的注解，现在我们可以使用`@Autowired`注解来连接我们想要测试的组件。
- en: The code validates that the class being tested has been successfully instantiated,
    and is ready to be used. This also means that all of the dependencies in the class
    have been successfully wired.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码验证了被测试的类已成功实例化，并且准备好被使用。这也意味着类中的所有依赖项都已成功连接。
- en: This is an easy way to test code that has to interact with databases, message
    broker servers, or any other middleware. The approach used to validate interactions
    with a database server uses an in-memory database, such as H2, for traditional
    SQL databases such as PostgreSQL or MySQL; there are also options for NoSQL databases,
    such as an embedded Cassandra or Mongo.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个测试代码的简单方法，该代码必须与数据库、消息代理服务器或任何其他中间件进行交互。用于验证与数据库服务器交互的方法使用内存数据库，例如H2，用于传统SQL数据库（如PostgreSQL或MySQL）；还有用于NoSQL数据库的选项，例如嵌入式Cassandra或Mongo。
- en: On the other hand, when you need to test integrations with other third-party
    software, an excellent approach to keep in mind is the use of sandboxes. A sandbox
    is an environment that is similar to the production environment, provided to software
    vendors for testing purposes. These sandboxes are often deployed in production,
    but they also have some restrictions. For example, operations related to payments
    are not processed in the last stage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当您需要测试与其他第三方软件的集成时，一个很好的方法是使用沙盒。沙盒是一个类似于生产环境的环境，供软件供应商用于测试目的。这些沙盒通常部署在生产环境中，但它们也有一些限制。例如，与支付相关的操作不会在最后阶段处理。
- en: This testing approach is useful when you don't have any way to deploy applications
    in your own environments, but of course, you will need to test whether the integrations
    are working with your applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您没有任何方法在自己的环境中部署应用程序时，这种测试方法是有用的，但当然，您需要测试集成是否与您的应用程序正常工作。
- en: Let's suppose that you are building an application that has integration with
    Facebook. In this case, it's evident that no change is required in order to deploy
    a Facebook instance in your own staging area for testing purposes. This is a perfect
    example of when a sandbox environment is appropriate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建一个与Facebook集成的应用程序。在这种情况下，显然不需要进行任何更改，以便在自己的测试环境中部署Facebook实例。这是沙盒环境适用的完美例子。
- en: Bear in mind that sandboxes test integrations using third-party software. If
    you're a software vendor, you need to consider providing sandboxes that allow
    your customers to try your products in a testing mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，沙盒测试集成使用第三方软件。如果您是软件供应商，您需要考虑提供允许客户以测试模式尝试您的产品的沙盒。
- en: 'Spring MVC Test also has a fluent API that makes it possible to write highly
    expressive tests. This framework provides a `MockMvc` object that can be used
    to simulate end-user requests and then validate the provided responses. Common
    use cases include the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC测试还具有流畅API，可以编写高度表达性的测试。该框架提供了一个`MockMvc`对象，可用于模拟最终用户请求，然后验证提供的响应。常见用例包括以下内容：
- en: Validating HTTP code statuses
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证HTTP代码状态
- en: Verifying expected content in the responses
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证响应中的预期内容
- en: URL redirection
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL重定向
- en: 'The following code snippet uses the `MockMvc` object to test the previously
    described examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用`MockMvc`对象来测试先前描述的示例：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s quickly review the code in bold, in order to understand how it works:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速审查粗体字中的代码，以了解其工作原理：
- en: The `AutoConfigureMockMvc` annotation generates all of the required plumbing
    code to use the `MockMvc` object in the tests.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoConfigureMockMvc`注解生成了在测试中使用`MockMvc`对象所需的所有基础代码。'
- en: The `MockMvc` object is autowired and ready to use.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvc`对象已自动装配并准备就绪。'
- en: The fluent API provided by `MockMvc` is used to validate the expected status
    code from the response. We are also testing a simple redirection, as well as the
    content expected on the page once the redirection is done.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvc`提供的流畅API用于验证响应的预期状态代码。我们还在测试简单的重定向，以及重定向完成后页面上预期的内容。'
- en: Test coverage
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: When we discuss tests, it's quite common to hear the term **test coverage.**
    This is a measure used to check how much code is being executed by the suite tests,
    and it's helpful for determining what alternative paths of code are not tested
    and are hence prone to bugs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论测试时，经常会听到术语**测试覆盖率**。这是一个用于检查测试套件执行了多少代码的度量标准，有助于确定未经测试的代码的替代路径，并因此容易出现错误。
- en: Let's suppose that you are writing a method that has an `if` statement. In that
    case, your code has two alternative paths to follow; so, if you want to achieve
    100% coverage, you will need to write tests to validate all of the alternative
    routes that your code can follow.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个具有`if`语句的方法。在这种情况下，您的代码有两条可选路径要遵循；因此，如果您想实现100%的覆盖率，您需要编写测试来验证代码可以遵循的所有可选路径。
- en: There are many useful libraries available for measuring the coverage that code
    has. In this chapter, we are going to introduce one of the most popular libraries
    in the Java world; the library is called JaCoCo ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有用的库可用于测量代码的覆盖率。在本章中，我们将介绍Java世界中最流行的库之一；该库称为JaCoCo（[http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)）。
- en: In order to make JaCoCo a part of our application, we need to include it as
    a plugin, using our preferred build tool.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使JaCoCo成为我们应用程序的一部分，我们需要将其作为插件包含在内，使用我们首选的构建工具。
- en: 'The following is the required configuration to include JaCoCo using Gradle:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Gradle包含JaCoCo所需的配置：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the required configuration to include JaCoCo using Maven:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Maven包含JaCoCo所需的配置：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once JaCoCo has been included as a part of the project, we will have new tasks
    that can be used to measure the coverage of our code. Let''s generate a coverage
    report by executing the following Gradle task:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JaCoCo作为项目的一部分被包含进来，我们将有新的任务可用于测量我们的代码覆盖率。通过执行以下Gradle任务来生成覆盖率报告：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The coverage report that is generated will be available in HTML format, as
    shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的覆盖率报告将以HTML格式提供，如下截图所示：
- en: '![](img/f775fbe3-e0a6-4894-82eb-af5a787e702f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f775fbe3-e0a6-4894-82eb-af5a787e702f.png)'
- en: JaCoCo report
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo报告
- en: Although it is true that we want to achieve high coverage for our code, we need
    to be careful with what kinds of tests we are writing because, with this approach
    in mind, we may be tempted to write useless tests, just to achieve 100% coverage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确实希望为我们的代码实现高覆盖率，但我们需要小心编写什么类型的测试，因为考虑到这种方法，我们可能会被诱使编写无用的测试，只是为了实现100%的覆盖率。
- en: 'To fully understand what I''m talking about here, let''s review the report
    generated by JaCoCo for one of the classes in the domain package:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解我在这里谈论的内容，让我们审查JaCoCo为域包中的一个类生成的报告：
- en: '![](img/9caf22ac-ecd6-4807-84a1-0bf87ae0062d.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9caf22ac-ecd6-4807-84a1-0bf87ae0062d.png)'
- en: Test coverage report for a domain class
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 域类的测试覆盖率报告
- en: The report shows that there are no tests at all for some methods. Some of these
    methods are standard for any Java object, and the others are only getters and
    setters (accessors), which do not need to be tested. Writing getters and setters
    often leads to building anemic domain models, and, most of the time, this is only
    used to make the code compatible with frameworks relying on the Java Beans convention.
    For this reason, there is no need to write tests to cover getters and setters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 报告显示，某些方法根本没有测试。其中一些方法对于任何Java对象都是标准的，其他方法只是getter和setter（访问器），不需要进行测试。编写getter和setter通常会导致构建贫血的领域模型，并且大多数情况下，这仅用于使代码与依赖于Java
    Beans约定的框架兼容。因此，没有必要编写测试来覆盖getter和setter。
- en: I have seen people writing tests for these methods only to achieve 100% coverage,
    but that is a useless and impractical procedure that should be avoided, as it
    doesn't add any value to the quality of the code or the written tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到有人仅为这些方法编写测试，以实现100%的覆盖率，但这是一个无用且不切实际的过程，应该避免，因为它对代码或编写的测试质量没有任何价值。
- en: 'Now, let''s review the report for one of the classes that has some logic worth
    testing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来审查一下具有一些值得测试逻辑的类的报告：
- en: '![](img/beb5e7a9-44a0-4193-90c2-eb28d15de1ba.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beb5e7a9-44a0-4193-90c2-eb28d15de1ba.png)'
- en: JaCoCo coverage report for a service class
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类的JaCoCo覆盖率报告
- en: 'Surprisingly, this class has 100% coverage. Let''s review the associated tests
    for this class, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这个类有100%的覆盖率。让我们回顾一下这个类的相关测试，如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We cannot always achieve 100% coverage, as we did in this example. However,
    a good measure tends to be 80%. You must think of the previously mentioned percentage
    not as a rule, but a recommendation; if you verify that your tests are exercising
    all of the logic needed, sometimes a value less than 80% will be fine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是能够达到100%的覆盖率，就像在这个例子中一样。然而，一个很好的度量标准往往是80%。您必须将之前提到的百分比视为建议，而不是规则；如果您验证您的测试是否涵盖了所有需要的逻辑，有时低于80%的值也是可以接受的。
- en: You need to be smart, using the generated report to figure out what logic needs
    to be tested and then work on it, rather than feel frustrated by the results.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要聪明地使用生成的报告来弄清楚需要测试的逻辑，然后着手解决，而不是为结果感到沮丧。
- en: One of the good things about using this kind of tool is that you can integrate
    it as part of your continuous integration server, to generate reports that are
    visible all of the time. In this way, the reports can be used to continually check whether
    the coverage is growing or going down and take action. We will discuss this topic
    in more detail in [Chapter 11](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml), *DevOps
    and Release Management*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种工具的好处之一是，您可以将其集成为持续集成服务器的一部分，以生成始终可见的报告。通过这种方式，报告可以用于不断检查覆盖率是增加还是下降，并采取行动。我们将在[第11章](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml)
    *DevOps和发布管理*中更详细地讨论这个话题。
- en: UI frameworks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI框架
- en: When you are working with Spring MVC, you have the option to choose from a huge
    set of technologies to build your web pages. Depending on what framework you have
    chosen, you will need to add the corresponding configuration, in order to let
    Spring know about your choice.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Spring MVC时，您可以选择从大量的技术中构建您的网页。根据您选择的框架，您需要添加相应的配置，以便让Spring知道您的选择。
- en: 'As we know, Spring supports configuration by code, so you will need to add
    a few annotations and/or configuration classes to make your frameworks work. If
    you want to avoid these steps, you can use Thymeleaf; this framework can be easily
    integrated as part of an existing Spring application including the Thymeleaf starter
    dependency. There are different lines of codes to be used depending upon the tools
    being used which are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Spring支持代码配置，因此您需要添加一些注解和/或配置类来使您的框架工作。如果您想避免这些步骤，您可以使用Thymeleaf；这个框架可以很容易地集成到现有的Spring应用程序中，包括Thymeleaf
    starter依赖项。根据所使用的工具，需要使用不同的代码行，如下所示：
- en: 'The dependency when Gradle is used is as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Gradle时，依赖项如下：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The dependency when Maven is used is as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Maven时，依赖项如下：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the application starts, Spring Boot will do all of the boring stuff for
    you, preparing your application for using Thymeleaf.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，Spring Boot将为您完成所有无聊的工作，为您的应用程序准备使用Thymeleaf。
- en: Thymeleaf
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thymeleaf
- en: Thymeleaf is a relatively new template engine; the first version was released
    in 2011\. Thymeleaf is pretty similar to HTML, which doesn't require any servlet
    containers to preview content in a browser. This is exploited in order to allow
    designers to work on the look and feel of the application, without deploying it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf是一个相对较新的模板引擎；第一个版本于2011年发布。Thymeleaf与HTML非常相似，不需要任何servlet容器即可在浏览器中预览内容。这被利用来允许设计人员在不部署应用程序的情况下工作应用程序的外观和感觉。
- en: 'Let''s review how to convert a web template build, using HTML and Bootstrap,
    into a Thymeleaf template, in order to see that this template engine is not intrusive.
    The following code represents a very basic HTML template:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何将使用HTML和Bootstrap构建的Web模板转换为Thymeleaf模板，以便看到这个模板引擎并不具有侵入性。以下代码代表一个非常基本的HTML模板：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since this is a regular HTML file, you can open it in a browser to see how
    it looks:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个常规的HTML文件，您可以在浏览器中打开它，看看它的样子：
- en: '![](img/bf74150a-6dcd-4e30-bddf-d45e3775f9d4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf74150a-6dcd-4e30-bddf-d45e3775f9d4.png)'
- en: HTML and Bootstrap template
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTML和Bootstrap模板
- en: 'Now, let''s implement a few requirements, to make our template work in a more
    realistic way:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一些要求，使我们的模板以更现实的方式工作：
- en: The Logout option should be present only when the user is logged in
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当用户登录时，注销选项才应出现
- en: The My notification channels optionshould not be present if the user is not
    logged in
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户未登录，则不应出现“我的通知渠道”选项
- en: The Login option should not be present once the user is logged in
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户登录，登录选项就不应该出现
- en: Once the user is logged in, the Home option should show a welcome message using
    their username
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户登录，主页选项应该显示一个欢迎消息，使用他们的用户名
- en: These requirements are trivial when we are creating web applications, and fortunately,
    they are also easy to implement using Thymeleaf.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web应用程序时，这些要求是微不足道的，幸运的是，它们也很容易使用Thymeleaf实现。
- en: In order to show/hide certain elements in a web page once the user is logged
    in, we need to include an additional library to deal with this stuff.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户登录后显示/隐藏网页中的某些元素，我们需要包含一个额外的库来处理这些内容。
- en: 'To include the library with Gradle, use the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gradle包含库，请使用以下命令：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To include the library with Maven, use the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Maven包含库，请使用以下命令：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we need to add a tag declaration in the HTML file, in order to use Thymeleaf
    and the new extension that was added:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在HTML文件中添加一个标签声明，以便使用Thymeleaf和新增加的新扩展：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we have included these tags, we will have the ability to use the provided
    built-in functionality. When you need to hide/show a certain element, depending
    on whether or not the user is logged in, you can use the `isAuthenticated()` condition,
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们包含了这些标签，我们将能够使用提供的内置功能。当您需要根据用户是否已登录来隐藏/显示某个元素时，您可以使用`isAuthenticated()`条件，如下所示：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s also quite common to restrict access, depending on the user roles assigned.
    These checks are also easy to implement using the added extension, as shown in
    the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分配的用户角色限制访问也是相当常见的。使用添加的扩展来实现这些检查也很容易，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To finish, if you need to show the username on a web page, you can use the
    following tag inside of your HTML file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您需要在Web页面上显示用户名，您可以在HTML文件中使用以下标签：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, once the template has been created by our designers or frontend
    experts, we will want to use it across the whole application, to keep a consistent
    look and feel. In order to achieve this goal, we need to define which part of
    the page will be replaced by specific content in the template, using the `layout`
    tags:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一旦模板由我们的设计师或前端专家创建完成，我们将希望在整个应用程序中使用它，以保持一致的外观和感觉。为了实现这个目标，我们需要定义模板中哪些部分将使用`layout`标签来替换特定内容：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The pages will then need to define the template name and the content that should
    be shown in the defined fragments, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后页面将需要定义模板名称和应该显示在定义片段中的内容，如下所示：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We mentioned earlier that Thymeleaf is not intrusive at all, and we are going
    to show you why. Once all of the desired logic has been implemented using the
    Thymeleaf tags, you can open the template again using a regular browser, without
    deploying the application in a servlet container. You will get the following result:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到Thymeleaf根本不具有侵入性，我们将向您展示为什么。一旦使用Thymeleaf标签实现了所有期望的逻辑，您可以再次使用常规浏览器打开模板，而无需将应用程序部署在Servlet容器中。您将得到以下结果：
- en: '![](img/4575d939-9029-4f25-8eba-bfcbbe75a622.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4575d939-9029-4f25-8eba-bfcbbe75a622.png)'
- en: Thymeleaf and Bootstrap template
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf和Bootstrap模板
- en: We have duplicate menu options, and we can still see the login and logout options,
    because the browser is not able to interpret the Thymeleaf tags. However, the
    good news is that the introduced code is not harming the template at all. This
    is exactly why your web designers can keep working and still have a preview in
    the browser. No matter how many Thymeleaf tags you have introduced in the template,
    these tags are not intrusive to the existing HTML code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有重复的菜单选项，我们仍然可以看到登录和注销选项，因为浏览器无法解释Thymeleaf标签。然而，好消息是，引入的代码并没有对模板造成任何伤害。这正是为什么您的Web设计师可以继续工作并在浏览器中预览的原因。无论您在模板中引入了多少Thymeleaf标签，这些标签对现有的HTML代码都不具有侵入性。
- en: Securing an MVC application
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护MVC应用程序
- en: Security is a key aspect in software development, and we need to take it seriously
    if we want to avoid exposing our applications to common attacks. Also, we may
    want to restrict access to non-authorized people. We will review some techniques
    to keep our software safe in [Chapter 13](645d19fb-b708-4610-a98e-cb484bd48bb3.xhtml),
    *Security*. In the meantime, you will learn how to secure an MVC application using
    Spring Security.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是软件开发中的关键方面，如果我们想要避免将我们的应用程序暴露给常见的攻击，我们需要认真对待它。此外，我们可能希望限制非授权人员的访问。我们将在[第13章](645d19fb-b708-4610-a98e-cb484bd48bb3.xhtml)
    *安全*中审查一些保持软件安全的技术。与此同时，您将学习如何使用Spring Security保护MVC应用程序。
- en: Up to this point, we have reviewed how to build a web application using Thymeleaf
    and Spring MVC. When working with web applications, one of the most common authentication
    mechanisms is basic authentication. Let's discuss this in more detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了如何使用Thymeleaf和Spring MVC构建Web应用程序。在处理Web应用程序时，最常见的身份验证机制之一是基本身份验证。让我们更详细地讨论一下这个问题。
- en: Basic authentication
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: Basic authentication, or basic access authentication, is a mechanism used to
    restrict or provide access to specific resources in the server. In a web application,
    the resources are often web pages, but this mechanism can be used to secure RESTful
    web services, as well. However, this approach is not common; a different mechanism,
    based on tokens, is preferred.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证，或基本访问验证，是用于限制或提供对服务器中特定资源的访问的机制。在Web应用程序中，这些资源通常是网页，但这种机制也可以用于保护RESTful
    Web服务。然而，这种方法并不常见；基于令牌的不同机制更受青睐。
- en: When a website is secured using basic authentication, the users need to provide
    their credentials before requesting the website's pages. The user credentials
    are merely a simple combination of a username and password that is encoded using
    a Base64 algorithm, to calculate the value that should be in the **Authentication**
    header. This will be used by the server later, to validate whether the user is
    authenticated and authorized to access the requested resource. If the user is
    authenticated, this means that the provided username and password combination
    is valid; being authorized means that the authenticated user has permission to
    execute specific actions or View individual pages.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站使用基本身份验证进行保护时，用户需要在请求网站页面之前提供他们的凭据。用户凭据仅仅是用户名和密码的简单组合，使用Base64算法进行编码，计算出应该在**身份验证**标头中的值。服务器稍后将使用这个值来验证用户是否经过身份验证并获得访问所请求资源的授权。如果用户经过身份验证，这意味着提供的用户名和密码组合是有效的；被授权意味着经过身份验证的用户有权限执行特定操作或查看单个页面。
- en: 'One problem with using this authentication mechanism is that when the user
    sends the credentials to the server during the authentication process, the credentials
    are sent in plain text. If the request is then intercepted, the credentials are
    exposed. The following screenshot makes this problem evident; in this case, the
    request was intercepted using a tool called Wireshark ([https://www.wireshark.org](https://www.wireshark.org)):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种身份验证机制的一个问题是，当用户在身份验证过程中将凭据发送到服务器时，凭据是以明文形式发送的。如果请求被拦截，凭据就会暴露出来。以下截图清楚地显示了这个问题；在这种情况下，使用了一个名为Wireshark的工具来拦截请求（[https://www.wireshark.org](https://www.wireshark.org)）：
- en: '![](img/36c8691f-7520-44ff-926d-543720bf1767.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36c8691f-7520-44ff-926d-543720bf1767.png)'
- en: Intercepted HTTP request
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截的HTTP请求
- en: 'This issue can be solved easily using a secure version of HTTP, in which a
    certificate is necessary for encrypting the data that is exchanged between the
    server and the browser. The certificate should be issued by a trusted **Certificate
    Authority** (**CA**) and should be located in the server. Browsers have a list
    of trusted CA root certificates that are validated when a secured connection is
    established. Once the certificate is validated, the address bar shows a padlock,
    as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用安全版本的HTTP来轻松解决此问题，其中需要证书来加密服务器和浏览器之间交换的数据。证书应由受信任的**证书颁发机构**（**CA**）颁发，并应位于服务器上。浏览器有一个受信任的CA根证书列表，在建立安全连接时进行验证。一旦证书验证通过，地址栏将显示一个挂锁，如下图所示：
- en: '![](img/cff6d101-4299-4113-980a-1bdf54daa13d.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cff6d101-4299-4113-980a-1bdf54daa13d.png)'
- en: Padlock shown in the address bar
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 地址栏中显示的挂锁
- en: 'As you can see in the following screenshot, the HTTPS protocol uses the `8443`
    port instead of the standard `80`, which is intended for HTTP:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，HTTPS协议使用`8443`端口，而不是标准的`80`端口，后者用于HTTP：
- en: '![](img/da4775b6-747a-4489-86b8-7c06a2f29c7e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da4775b6-747a-4489-86b8-7c06a2f29c7e.png)'
- en: Address bar using HTTPS
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 地址栏使用HTTPS
- en: For development purposes, you can generate your own certificates, but the browser
    will show you a warning indicating that the certificate could not be validated;
    you can add an exception to open the requested pages using HTTPS.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 出于开发目的，您可以生成自己的证书，但浏览器会显示警告，指示无法验证证书；您可以添加异常以使用HTTPS打开请求的页面。
- en: 'The following diagram shows how a connection is established using the HTTPS
    protocol:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用HTTPS协议建立连接的过程：
- en: '![](img/a15cc8b0-106c-4136-abee-4ac95febbe38.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a15cc8b0-106c-4136-abee-4ac95febbe38.png)'
- en: HTTPS connection
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS连接
- en: 'The padlock located in the middle represents the encrypted data when it is
    going through the computer network, which makes it impossible to read. The following
    screenshot shows how the data looks when it is intercepted using Wireshark:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的挂锁代表了数据在计算机网络中传输时的加密，使其无法阅读。以下截图显示了使用Wireshark拦截数据的样子：
- en: '![](img/19bc0593-e13d-4981-85da-13041ff93ff1.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19bc0593-e13d-4981-85da-13041ff93ff1.png)'
- en: Intercepted HTTPS request
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截的HTTPS请求
- en: As you can see, this intercepted data is hard to understand. In this way, all
    of the information sent is protected, and, even if it is captured in transit,
    it can't be easily read. This attack is known as a man-in-the-middle attack, which
    is one of the most common types of attack.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些拦截的数据很难理解。通过这种方式，发送的所有信息都受到保护，即使在传输过程中被捕获，也不能轻易阅读。这种攻击被称为中间人攻击，是最常见的攻击类型之一。
- en: Implementing basic authentication
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施基本身份验证
- en: Now that you know the basics related to Basic authentication and how it works,
    let's review how to implement it in a Spring MVC application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与基本身份验证相关的基础知识以及其工作原理，让我们来看看如何在Spring MVC应用程序中实现它。
- en: To begin, we need to include the starter dependency for Spring Security.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含Spring Security的起始依赖项。
- en: 'It can be included in Gradle as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Gradle中包含如下：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It can be included in Maven as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Maven中包含如下：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After adding this dependency, Spring Boot will do all of the boring stuff for
    us, and we won't have to do anything to secure the application. If we don't add
    any additional configurations, Spring will generate a user for testing, and the
    password will be printed in the console. This scenario is perfect when we are
    only in the early stages of development.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个依赖项后，Spring Boot将为我们完成所有繁琐的工作，我们不需要做任何事情来保护应用程序。如果我们不添加任何额外的配置，Spring将为测试生成一个用户，并且密码将打印在控制台上。这种情况在开发的早期阶段非常完美。
- en: On the other hand, if we require a customized way to allow or restrict access
    to users, all that we need to do is implement the `loadUserByUsername` method, which
    is a part of the `UserDetailsService` interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要自定义的方式来允许或限制用户访问，我们只需要实现`loadUserByUsername`方法，该方法是`UserDetailsService`接口的一部分。
- en: The implementation is fairly simple; the method retrieves the `username` provided,
    and, using that username, you will need to return a `UserDetails` object with
    the user information.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单；该方法检索提供的`username`，并且使用该用户名，您需要返回一个带有用户信息的`UserDetails`对象。
- en: 'Let''s review an example, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，如下所示：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `findByUsername` method is responsible for finding the users that you need
    in a database or in any other storage. Once you have customized where your users
    are, you have to work on the authorization for the web pages. This can be done
    by implementing the `WebSecurityConfigurerAdapter` interface, as shown in the
    following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`findByUsername`方法负责在数据库或其他存储中查找您需要的用户。一旦您定制了用户的位置，您就必须处理网页的授权。这可以通过实现`WebSecurityConfigurerAdapter`接口来完成，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s review the code that has been highlighted in bold:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审查加粗显示的代码：
- en: We are configuring a path to grant access to any user, whether or not the request
    is authenticated
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在配置一个路径来授予任何用户访问权限，无论请求是否经过身份验证
- en: A configuration for restricting access to only users with the `CUSTOMER` role
    is added for all of the pages under the `customers` path
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`CUSTOMER`角色的用户限制访问的配置已添加到`customers`路径下的所有页面
- en: A login page is configured, as well as the pages to forward successful and failed
    authentication attempts to
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了登录页面，以及成功和失败的认证尝试的页面转发
- en: The URL `/logout` is provided, to redirect the user once the logout process
    has occurred
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了`/logout` URL，用于在注销过程发生后重定向用户
- en: As you can see, once you have implemented the preceding configuration class,
    you will have all that you need to secure the web pages in your application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦实现了前面的配置类，您将拥有所有必要的内容来保护应用程序中的网页。
- en: 'We mentioned earlier that a good approach to follow is to use HTTPS to encrypt
    the data that is sent between the browser and the server. To achieve this goal,
    Spring Boot offers the ability to add the following configuration properties to
    the `application.properties` file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，一个好的方法是使用HTTPS来加密在浏览器和服务器之间发送的数据。为了实现这个目标，Spring Boot提供了将以下配置属性添加到`application.properties`文件中的能力：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s review the configurations in this file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个文件中的配置：
- en: As mentioned earlier, HTTPS uses the `8443` port.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，HTTPS使用`8443`端口。
- en: The next parameter allows for specifying the digital certificate name.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个参数允许指定数字证书名称。
- en: The keystore password should also be provided. Note that this value can be provided
    when executing the application as a parameter. An even better method is to get
    these values from a configuration server, instead of having them hardcoded in
    the `application.properties` file.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥库密码也应提供。请注意，当执行应用程序时，可以将此值作为参数提供。更好的方法是从配置服务器获取这些值，而不是将它们硬编码在`application.properties`文件中。
- en: This parameter is used to specify the store type used when the certificate was
    generated.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此参数用于指定生成证书时使用的存储类型。
- en: The last parameter corresponds to the alias for the digital certificate.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数对应于数字证书的别名。
- en: Note that the code should not be modified to enable HTTPS in the application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码不应该被修改以在应用程序中启用HTTPS。
- en: 'For the sake of testing, a self-signed certificate can be created by using
    a key tool, which is part of a standard Java installation, as shown in the following
    screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试的目的，可以使用标准Java安装的一部分的密钥工具来创建自签名证书，如下面的屏幕截图所示：
- en: '![](img/6c5311c1-ec7b-4fee-bf15-ef64ef56e6a0.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c5311c1-ec7b-4fee-bf15-ef64ef56e6a0.png)'
- en: Self-signed certificate creation
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书创建
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concepts related to MVC architecture and how
    they work. We also discussed the errors that people tend to make when building
    applications using this architectural style.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与MVC架构及其工作相关的概念。我们还讨论了人们在使用这种架构风格构建应用程序时容易犯的错误。
- en: Then we reviewed how to create an application using Spring MVC, looking at different
    tests and how to implement them using features provided by Spring. We also reviewed
    how to use Thymeleaf with Spring MVC in order to build the UI for a web application.
    To finish this chapter, we discussed some security concepts, including how to
    apply them in a Spring MVC application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了如何使用Spring MVC创建应用程序，查看了不同的测试以及如何使用Spring提供的功能来实现它们。我们还回顾了如何在Spring
    MVC中使用Thymeleaf来构建Web应用程序的用户界面。为了完成本章，我们讨论了一些安全概念，包括如何在Spring MVC应用程序中应用它们。
- en: In the next chapter, you will learn about event-driven architectures, which
    are becoming quite popular.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解事件驱动架构，这种架构变得非常流行。
