- en: '*Chapter 8*: Deploying Microservices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：部署微服务'
- en: 'The literal meaning of *deployment* is to bring resources into effective action.
    Therefore, in the microservices context, it means to bring microservices into
    effective action. Any service deployment is a multi-step process and often involves
    building the artifacts and then pushing the artifacts to a runtime environment.
    In the microservices world, an effective strategy for microservices deployment
    is crucial. Essentially, we need to watch out for the following when planning
    a deployment process:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*的直译意思是将资源投入有效行动。因此，在微服务环境中，这意味着将微服务投入有效行动。任何服务部署都是一个多步骤的过程，通常涉及构建工件然后将工件推送到运行环境。在微服务世界中，一个有效的微服务部署策略至关重要。本质上，在规划部署过程时，我们需要注意以下几点：'
- en: Continue with the pattern of *separation of concern* and self-isolate the artifact-building
    process for each microservice.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续采用*关注点分离*的模式，并为每个微服务的工件构建过程进行自我隔离。
- en: Decouple any connection requirements within microservices and let the service
    discovery or an implementation close to service discovery handle the microservice
    bindings.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦微服务内部的任何连接需求，并让服务发现或接近服务发现的实现来处理微服务绑定。
- en: Implement a seamless deployment process that can handle instantiating all of
    the microservice application components in a unified and automated way.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施一个无缝的部署过程，能够以统一和自动化的方式实例化所有微服务应用程序组件。
- en: 'In this chapter, we will dive into these aforementioned concerns while covering
    the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨上述关注点，同时涵盖以下主题：
- en: Building the container artifacts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器工件
- en: Deploying the container artifacts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署容器工件
- en: By the end of this chapter, you will be well versed in these aspects of microservices
    deployment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对微服务部署的这些方面有深入的了解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the commands and technical instructions in this chapter run on Windows
    10 and macOS. The code examples covered in this chapter are available in the book''s
    GitHub repo here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在Windows 10和macOS上运行。本章涵盖的代码示例可在本书的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08
    )'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08)'
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具需要在开发环境中安装和设置：
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**：版本13或以上（我们使用了Java 14）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：这是可选的，仅在你希望使用Maven作为构建系统时需要。然而，我们建议在任何开发机器上设置Maven。下载和安装Maven的说明可以在[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)找到。'
- en: '**A development IDE**: Based on your preference, any Java-based IDE can be
    used, but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发IDE**：根据你的偏好，可以使用任何基于Java的IDE，但为了编写本章，使用了IntelliJ。'
- en: '**Git**: Instructions to download and install this can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：下载和安装的说明可以在[https://git-scm.com/downloads](https://git-scm.com/downloads)找到。'
- en: '**PostgreSQL**: Instructions to download and install this can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：下载和安装的说明可以在[https://www.postgresql.org/download/](https://www.postgresql.org/download/)找到。'
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred then instructions
    to download and install it can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：MongoDB Atlas提供了一个免费在线数据库即服务，存储空间高达512 MB。然而，如果你更喜欢本地数据库，下载和安装的说明可以在[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)找到。我们为本章的编写使用了本地安装。'
- en: '**A REST client**: Any HTTP REST client can be used. We used the **Advanced
    REST Client** Chrome plugin.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST 客户端**：任何 HTTP REST 客户端都可以使用。我们使用了 **Advanced REST Client** Chrome 插件。'
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：有关下载和安装 Docker 的说明，请参阅[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。'
- en: Building the container artifacts
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器工件
- en: To deploy any application, the first step is to build all the required artifacts.
    And building an artifact typically involves checking out the source code and compiling
    and creating a deployable artifact. In regard to microservices, often, this deployable
    form is a Docker container image. Docker images have elegantly decoupled the runtime
    topology requirements. A Docker image is platform agnostic and can be deployed
    to any host machine that runs Docker. In the next section, we will dive into how
    to build Docker images for the microservices in our pet-clinic application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 部署任何应用程序的第一步是构建所有必需的工件。构建一个工件通常涉及检出源代码、编译并创建可部署的工件。在微服务方面，通常，这种可部署的形式是一个 Docker
    容器镜像。Docker 镜像优雅地解耦了运行时拓扑需求。Docker 镜像是平台无关的，可以部署到任何运行 Docker 的主机机器。在下一节中，我们将深入了解如何在我们的
    pet-clinic 应用程序中为微服务构建 Docker 镜像。
- en: Containerizing the Micronaut microservices using Jib
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jib 容器化 Micronaut 微服务
- en: 'Jib is a containerizing framework from Google that can seamlessly tie with
    Java build frameworks such as Maven or Gradle to build container images. Jib has
    hugely simplified the process to create container (Docker) images. Let''s quickly
    see the workflow without Jib to create a Docker image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Jib 是来自 Google 的一个容器化框架，它可以无缝地与 Java 构建框架（如 Maven 或 Gradle）结合使用来构建容器镜像。Jib 极大地简化了创建容器（Docker）镜像的过程。让我们快速看看没有
    Jib 创建 Docker 镜像的工作流程：
- en: '![Figure 8.1 – Docker containerization workflow without Jib'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 无 Jib 的 Docker 容器化工作流程'
- en: '](img/Figure_8.1_B16585_Fixed.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 无 Jib 的 Docker 容器化工作流程'
- en: Figure 8.1 – Docker containerization workflow without Jib
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 无 Jib 的 Docker 容器化工作流程
- en: As you can see in the preceding diagram, to build a Docker image without Jib
    we need to build the **Source code** and create a **Docker file**. The **Docker
    daemon** then uses the build context to create a **Container image** and push
    it to the repository/registry.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，要构建没有 Jib 的 Docker 镜像，我们需要构建 **源代码** 并创建一个 **Docker 文件**。然后，**Docker 守护进程**使用构建上下文创建一个
    **容器镜像** 并将其推送到仓库/注册表。
- en: 'In contrast to the preceding workflow, Jib simplifies the whole process as
    shown in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的工作流程相比，Jib 如下图中所示简化了整个过程：
- en: '![Figure 8.2 – Docker containerization with Jib'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 使用 Jib 的 Docker 容器化'
- en: '](img/Figure_8.2_B16585_Fixed.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 使用 Jib 的 Docker 容器化'
- en: Figure 8.2 – Docker containerization with Jib
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 使用 Jib 的 Docker 容器化
- en: Jib takes the configuration from the build file such as project's `pom` file
    or a Gradle file to build the container image and uploads it to the configured
    repository/registry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Jib 从构建文件（如项目的 `pom` 文件或 Gradle 文件）中获取配置来构建容器镜像并将其上传到配置的仓库/注册表。
- en: We will use Jib for containerizing our microservices in the following sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将使用 Jib 容器化我们的微服务。
- en: Containerizing the pet-owner microservice
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化宠物主人微服务
- en: 'In the pet-owner microservice, we will simplify configuration management to
    use local `application.properties`. We can still use `consul` for configuration
    management, but to focus on the containerization aspect, we opt to use a local
    `application.properties` file. Delete or back up the `bootstrap.yml` file and
    make the following changes to the `application.properties` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在宠物主人微服务中，我们将简化配置管理以使用本地的 `application.properties`。我们仍然可以使用 `consul` 进行配置管理，但为了专注于容器化方面，我们选择使用本地的
    `application.properties` 文件。删除或备份 `bootstrap.yml` 文件，并对 `application.properties`
    文件进行以下更改：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A few things to ponder in these application properties changes are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些应用程序属性更改中需要思考的一些事情如下：
- en: '`host.docker.internal` instead of localhost to point to the Postgres instance
    installed on the host operating system (outside Docker).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `host.docker.internal` 而不是 localhost 来指向安装在主机操作系统（Docker 外部）上的 Postgres 实例。
- en: '`consul` service. To use Dockerized `consul` from a pet-owner Docker container,
    we will need to specify the service name instead of localhost.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul` 服务。要从宠物主人 Docker 容器中使用 Docker 化的 `consul`，我们需要指定服务名称而不是 localhost。'
- en: '**Port**: We are specifying a fixed port to run the pet-owner microservice
    as this will expose this port later in the deployment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 我们指定了一个固定的端口来运行宠物主人微服务，因为这个端口将在部署过程中被暴露。'
- en: Essentially, to use anything from the host machine we should use `host.docker.internal`,
    and to use any Docker service container we must specify the Docker service name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，要使用主机机器上的任何内容，我们应该使用`host.docker.internal`，而要使用任何Docker服务容器，我们必须指定Docker服务名称。
- en: 'After making the previous application configuration changes, we can proceed
    to containerization. To containerize the pet-owner microservice we will use Jib.
    Make the following changes in the project''s `pom` file build settings:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行前面的应用程序配置更改后，我们可以继续容器化。为了容器化宠物主人微服务，我们将使用Jib。在项目的`pom`文件构建设置中进行以下更改：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding `pom` changes, we are using `jib-maven-plugin` to build the
    container image. The `<configuration>` section specifies the Docker configurations
    such as the `<from>` image (which is pointing to use JDK 13). To name the created
    image, we use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`pom`更改中，我们使用`jib-maven-plugin`来构建容器镜像。`<configuration>`部分指定了Docker配置，例如`<from>`镜像（指向使用JDK
    13）。为了给创建的镜像命名，我们使用`<to>`结合`<creationTime>`来正确地在镜像上标记时间坐标。
- en: 'To build the image, perform the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像的步骤如下：
- en: Open the terminal and change directory to the `pet-owner` root directory.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到`pet-owner`根目录。
- en: Type and run the `mvn compile jib:dockerBuild` command in the terminal.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入并运行`mvn compile jib:dockerBuild`命令。
- en: Wait for the command to finish.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待命令完成。
- en: 'These instructions will create a local Docker image that can be verified using
    the `docker images | grep pet-owner` command in the terminal:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明将创建一个本地Docker镜像，可以使用终端中的`docker images | grep pet-owner`命令进行验证：
- en: '![Figure 8.3 – Verifying the pet-owner image in the local Docker registry'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 验证本地Docker注册表中的宠物主人镜像'
- en: '](img/Figure_8.3_B16585_Fixed.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16585_Fixed.jpg)'
- en: Figure 8.3 – Verifying the pet-owner image in the local Docker registry
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 验证本地Docker注册表中的宠物主人镜像
- en: In the preceding screenshot, we can see the output of `docker images`. A `pet-owner-0.1-image`
    image is stored in the local Docker registry.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到`docker images`的输出。一个名为`pet-owner-0.1-image`的镜像存储在本地Docker注册表中。
- en: Containerizing the pet-clinic microservice
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化宠物诊所微服务
- en: 'To make the pet-clinic microservice container ready, make the following changes
    to the `application.properties` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使宠物诊所微服务容器就绪，对`application.properties`文件进行以下更改：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are a few things to ponder in application properties changes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序属性更改中需要思考的以下几点：
- en: '`host.docker.internal` instead of localhost to point to Postgres installed
    in the host operating system (outside Docker).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`host.docker.internal`而不是localhost来指向主机操作系统（Docker外部）中安装的Postgres。
- en: '`consul` service. To use Dockerized `consul` from the pet-clinic Docker container,
    we will need to specify the service name instead of localhost.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul`服务。要使用来自宠物诊所Docker容器的Docker化`consul`，我们需要指定服务名称而不是localhost。'
- en: '**Kafka server**: In our Docker services, we will configure a **Kafka** service.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kafka服务器**: 在我们的Docker服务中，我们将配置一个**Kafka**服务。'
- en: '**Port**: We are specifying a fixed port to run the pet-clinic microservice
    as we will expose this port later in the deployment.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 我们指定了一个固定的端口来运行宠物诊所微服务，因为我们将在部署过程中暴露这个端口。'
- en: 'After making the preceding application configuration changes, we can proceed
    to containerization. To containerize the pet-clinic microservice we will use Jib.
    Make the following changes in the project''s `pom` file build settings:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行前面的应用程序配置更改后，我们可以继续容器化。为了容器化宠物诊所微服务，我们将使用Jib。在项目的`pom`文件构建设置中进行以下更改：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding `pom` changes, we use `jib-maven-plugin` to build the container
    image. The `<configuration>` section specifies Docker configurations such as the
    `<from>` image (which is pointing to use JDK 13). To name the created image we
    use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`pom`更改中，我们使用`jib-maven-plugin`来构建容器镜像。`<configuration>`部分指定了Docker配置，例如`<from>`镜像（指向使用JDK
    13）。为了给创建的镜像命名，我们使用`<to>`结合`<creationTime>`来正确地在镜像上标记时间坐标。
- en: 'To build the image, we perform the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像的步骤如下：
- en: Open the terminal and change directory to the `pet-clinic` root directory.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到`pet-clinic`根目录。
- en: Type and run the `mvn compile jib:dockerBuild` command in the terminal.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入并运行 `mvn compile jib:dockerBuild` 命令。
- en: Wait for the command to finish.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待命令完成。
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic` command in the terminal.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将在终端中创建一个本地 Docker 镜像，可以使用 `docker images | grep pet-clinic` 命令进行验证。
- en: Containerizing the pet-clinic-reviews microservice
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化 pet-clinic-reviews 微服务
- en: 'To make the pet-clinic-reviews microservice container ready, make the following
    changes to the `application.properties` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 pet-clinic-reviews 微服务容器准备就绪，请在 `application.properties` 文件中进行以下更改：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following are a few things to ponder in application properties changes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用属性更改中，以下是一些需要思考的事项：
- en: '`host.docker.internal` instead of localhost to point to the Mongo DB instance
    installed on the host operating system (outside Docker).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `host.docker.internal` 而不是 localhost 来指向安装在宿主操作系统（Docker外部）上的 MongoDB 实例。
- en: '`consul` service. To use Dockerized `consul` from the `pet-clinic-reviews`
    Docker container, we will need to specify the service name instead of localhost.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul` 服务。要从 pet-clinic-concierge Docker 容器中使用 Docker 化的 `consul`，我们需要指定服务名称而不是
    localhost。'
- en: '`kafka` service. To use Dockerized `consul` from the `pet-clinic-reviews` Docker
    container, we will need to specify the service name instead of localhost.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kafka` 服务。要从 `pet-clinic-reviews` Docker 容器中使用 Docker 化的 `consul`，我们需要指定服务名称而不是
    localhost。'
- en: '**Port**: We are specifying a fixed port to run the pet-clinic-reviews microservice
    as we will expose this port later in the deployment.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：我们指定了一个固定端口来运行 pet-clinic-reviews 微服务，因为我们将在部署中稍后公开此端口。'
- en: 'After making the preceding application configuration changes, we can proceed
    to containerization. To containerize the `pet-clinic-reviews` microservice we
    will use Jib. Make the following changes in the project''s `pom` fie build settings:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行上述应用程序配置更改后，我们可以继续容器化。要容器化 `pet-clinic-reviews` 微服务，我们将使用 Jib。在项目的 `pom`
    文件构建设置中进行以下更改：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding `pom` changes, we are using `jib-maven-plugin` to build the
    container image. The `<configuration>` section specifies Docker configurations
    such as the `<from>` image (which is pointing to use JDK 13). To name the created
    image, we use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `pom` 更改中，我们使用 `jib-maven-plugin` 来构建容器镜像。`<configuration>` 部分指定了 Docker
    配置，如 `<from>` 镜像（指向使用 JDK 13）。为了给创建的镜像命名，我们使用 `<to>` 结合 `<creationTime>` 来正确地在镜像上标记时间坐标。
- en: 'To build the image, perform the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，请执行以下步骤：
- en: Open the terminal and change directory to the `pet-clinic-reviews` root directory.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到 `pet-clinic-reviews` 根目录。
- en: Type and run the `mvn compile jib:dockerBuild` command in terminal.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入并运行 `mvn compile jib:dockerBuild` 命令。
- en: Wait for the command to finish.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待命令完成。
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic-reviews` command in the terminal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将在终端中创建一个本地 Docker 镜像，可以使用 `docker images | grep pet-clinic-reviews` 命令进行验证。
- en: Containerizing the pet-clinic-concierge microservice
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化 pet-clinic-concierge 微服务
- en: 'To make the pet-clinic-concierge microservice container ready, make the following
    changes to the `application.properties` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 pet-clinic-concierge 微服务容器准备就绪，请在 `application.properties` 文件中进行以下更改：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following are a few things to ponder in application properties changes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用属性更改中，以下是一些需要思考的事项：
- en: '`consul` service. To use Dockerized `consul` from the pet-clinic-concierge
    Docker container we will need to specify the service name instead of localhost.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul` 服务。要从 pet-clinic-concierge Docker 容器中使用 Docker 化的 `consul`，我们需要指定服务名称而不是
    localhost。'
- en: '`pet-clinic-concierge` microservice as we will expose this port later in the
    deployment.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-clinic-concierge` 微服务，因为我们将在部署中稍后公开此端口。'
- en: 'After making the preceding application configuration changes we can proceed
    to containerization. To containerize the `pet-clinic-concierge` microservice (the
    API gateway) we will use `jib`. Make the following changes in the project''s `pom`
    file build settings:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行上述应用程序配置更改后，我们可以继续容器化。要容器化 `pet-clinic-concierge` 微服务（API 网关），我们将使用 `jib`。在项目的
    `pom` 文件构建设置中进行以下更改：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding `pom` changes, we use `jib-maven-plugin` to build the container
    image. The `<configuration>` section specifies Docker configurations such as the
    `<from>` image (which is pointing to use JDK 13). To name the created image we
    use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`pom`更改中，我们使用`jib-maven-plugin`来构建容器镜像。`<configuration>`部分指定了Docker配置，如`<from>`镜像（指向使用JDK
    13）。为了正确标记镜像上的时间坐标，我们使用`<to>`结合`<creationTime>`来命名创建的镜像。
- en: 'To build the image, perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，请执行以下步骤：
- en: Open the terminal and change directory to the `pet-clinic-concierge` root directory.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到`pet-clinic-concierge`根目录。
- en: Type and run the `mvn compile jib:dockerBuild` command in terminal.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入并运行`mvn compile jib:dockerBuild`命令。
- en: Wait for the command to finish.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待命令完成。
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic-concierge` command in the terminal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明将创建一个本地Docker镜像，您可以在终端中使用`docker images | grep pet-clinic-concierge`命令进行验证。
- en: 'Now, we have containerized all the microservices. We can verify these images
    in the Docker Dashboard as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经容器化了所有微服务。我们也可以在Docker仪表板中验证这些镜像：
- en: '![Figure 8.4 – Verifying the Docker images in the Docker UI'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4 – 在Docker UI中验证Docker镜像'
- en: '](img/Figure_8.4_B16585_Fixed.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.4_B16585_Fixed.jpg](img/Figure_8.4_B16585_Fixed.jpg)'
- en: Figure 8.4 – Verifying the Docker images in the Docker UI
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 在Docker UI中验证Docker镜像
- en: In the Docker UI, we can simply go to **Images** and under the **LOCAL** tab,
    we can filter all the pet-clinic application images. In the next section, we will
    use these Docker images in our pet-clinic application deployment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker UI中，我们可以简单地转到**Images**，然后在**LOCAL**选项卡下，我们可以过滤所有pet-clinic应用程序的镜像。在下一节中，我们将在pet-clinic应用程序的部署中使用这些Docker镜像。
- en: Deploying the container artifacts
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器工件
- en: In the previous section, we explored how we can use `Jib` to simplify microservice
    containerization. In this section, we will dive into how we can make the end-to-end
    deployment seamless and unified using Docker orchestration with `docker-compose`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了如何使用`Jib`简化微服务容器化。在本节中，我们将深入了解如何使用`docker-compose`与Docker编排相结合，使端到端部署无缝且统一。
- en: Using docker-compose to deploy the pet-clinic services
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用docker-compose部署pet-clinic服务
- en: '`docker-compose` is a tool available under the Docker ecosystem and is very
    intuitive in defining and deploying a multi-container application. With a simple
    YAML-flavored syntax, we can set up all the services and their dependencies and
    use a single command to deploy the whole application. We will create a `docker-compose`
    file for the pet-clinic application covering all the necessary services/components,
    including microservices, service discovery, and the Apache Kafka ecosystem.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`是Docker生态系统中的一个工具，它在定义和部署多容器应用程序时非常直观。使用简单的YAML风格语法，我们可以设置所有服务及其依赖关系，并使用单个命令部署整个应用程序。我们将为pet-clinic应用程序创建一个`docker-compose`文件，涵盖所有必要的服务/组件，包括微服务、服务发现和Apache
    Kafka生态系统。'
- en: 'Firstly, let''s define the ancillary services in `docker-compose` as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`docker-compose`中定义以下辅助服务：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the previous code, we see the `docker-compose` file. We begin by defining
    a service for the `consul` service discovery. We will expose `consul` on port
    `8500`. Furthermore, we will define services for the Apache Kafka ecosystem; that
    is, Zookeeper, Kafka, and the Kafdrop UI. Once these services are defined in the
    `docker-compose` file, we can proceed to the pet-clinic microservices. Refer to
    the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们看到`docker-compose`文件。我们首先定义一个用于`consul`服务发现的`consul`服务。我们将`consul`暴露在端口`8500`上。此外，我们将定义Apache
    Kafka生态系统的服务；即Zookeeper、Kafka和Kafdrop UI。一旦这些服务在`docker-compose`文件中定义，我们就可以继续处理`pet-clinic`微服务。请参考以下代码：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While defining the configurations for the `pet-clinic` microservices, we can
    specify the dependencies using `depends_on`. This will ensure that Docker instantiates
    the services as per the dependency order. Also, for deploying each service, we
    will be using the `pet-clinic` microservices Docker images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`pet-clinic`微服务的配置时，我们可以使用`depends_on`来指定依赖关系。这将确保Docker按照依赖顺序实例化服务。此外，对于部署每个服务，我们将使用`pet-clinic`微服务的Docker镜像。
- en: 'Once the `docker-compose` file is defined for the `pet-clinic` application,
    refer to the following instructions to deploy the pet-clinic application:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为`pet-clinic`应用程序定义了`docker-compose`文件，请参考以下说明来部署`pet-clinic`应用程序：
- en: Open the `bash` terminal.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bash`终端。
- en: Change the directory to the location where the `docker-compose` file is stored.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为存储`docker-compose`文件的位置。
- en: Type and run the `docker compose up` command.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入并运行`docker compose up`命令。
- en: Wait for Docker to instantiate the containers as specified in the `docker-compose`
    file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Docker根据`docker-compose`文件指定的容器实例化。
- en: 'After the successful run of the `docker-compose` command, we can verify the
    `pet-clinic` application in the Docker Dashboard, shown as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行`docker-compose`命令后，我们可以在Docker仪表板上验证`pet-clinic`应用程序，如下所示：
- en: '![Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 在Docker仪表板上验证宠物诊所的部署'
- en: '](img/Figure_8.5_B16585_Fixed.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16585_Fixed.jpg)'
- en: Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 在Docker仪表板上验证宠物诊所的部署
- en: 'In the preceding screenshot, you can see the status of all the services in
    the pet-clinic application. You can click on a service and monitor the logs and
    access the web interface (if any). Furthermore, we can check the `consul` service
    discovery for the health of the pet-clinic microservices. Refer to the following
    screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到宠物诊所应用程序中所有服务的状态。你可以点击一个服务来监控日志和访问Web界面（如果有）。此外，我们可以检查`consul`服务发现以了解宠物诊所微服务的健康状况。参看以下截图：
- en: '![Figure 8.6 – Verifying the microservices health in service discovery'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 在服务发现中验证微服务健康'
- en: '](img/Figure_8.6_B16585.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B16585.jpg)'
- en: Figure 8.6 – Verifying the microservices health in service discovery
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 在服务发现中验证微服务健康
- en: In the `consul` service discovery, we can observe the health of each instance
    of a microservice. In the preceding screenshot, we can see all the `pet-clinic`
    microservices are running normally.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`consul`服务发现中，我们可以观察到每个微服务实例的健康状况。在前面的截图上，我们可以看到所有`pet-clinic`微服务都在正常运行。
- en: Microservice container orchestration is the bedrock of any deployment strategy.
    For the scope of this chapter, we covered the local Docker deployment of the pet-clinic
    application, but the container images built can be deployed anywhere, be it locally
    or in a cloud environment, using a container orchestration tool such as `docker-compose`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务容器编排是任何部署策略的基础。在本章的范围内，我们涵盖了宠物诊所应用程序的本地Docker部署，但构建的容器镜像可以在任何地方部署，无论是本地还是云环境，使用容器编排工具如`docker-compose`。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we jumpstarted our understanding with a discussion about making
    Micronaut microservices container ready. Later, we dived into using Jib for creating
    the container images for each microservice. We saw how to define all the service
    container configurations using `docker-compose` and seamlessly deploy all the
    required service components using a single command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过讨论使Micronaut微服务容器就绪来启动我们的理解。随后，我们深入探讨了使用Jib为每个微服务创建容器镜像。我们看到了如何使用`docker-compose`定义所有服务容器配置，并使用单个命令无缝部署所有必需的服务组件。
- en: This chapter enhances the deployment aspects of your Micronaut microservices
    journey by equipping you with first-hand knowledge on containerization and automated
    deployment. This skill set is much sought after in microservices application development
    and maintenance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过为您提供容器化和自动化部署的第一手知识，增强了您的Micronaut微服务之旅的部署方面。这一技能集在微服务应用程序的开发和维护中非常受欢迎。
- en: In the next chapter, we will explore various ways to monitor different aspects
    of the pet-clinic application in Micronaut.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在Micronaut中监控宠物诊所应用程序不同方面的各种方法。
- en: Questions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Jib?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Jib？
- en: How can we use Jib to create a Docker container in Micronaut?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Jib在Micronaut中创建Docker容器？
- en: How can we connect to localhost from a Docker container in Micronaut?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从Micronaut的Docker容器连接到localhost？
- en: How can we deploy a multi-service application using `docker-compose` in Micronaut?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`docker-compose`在Micronaut中部署多服务应用程序？
- en: How can we perform Docker containerization of a Micronaut microservices application?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何执行Micronaut微服务应用程序的Docker容器化？
