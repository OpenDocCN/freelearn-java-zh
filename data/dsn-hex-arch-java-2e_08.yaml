- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building the Framework Hexagon
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建框架六边形
- en: When building a hexagonal application, the last step consists of exposing the
    application features by connecting input adapters to input ports. Also, if there
    is any need to get data from, or persist it inside, external systems, then we
    need to connect output adapters to output ports. The Framework hexagon is the
    place where we assemble all the adapters required to make the hexagonal system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建六边形应用时，最后一步是通过将输入适配器连接到输入端口来公开应用功能。此外，如果需要从外部系统获取数据或将其持久化，则需要将输出适配器连接到输出端口。框架六边形是我们组装所有适配器以使六边形系统工作的地方。
- en: 'We first created the domain model using things including entities, value objects,
    and specifications in the Domain hexagon. Then, in the Application hexagon, we
    expressed the user’s intent using use cases and ports. Now, in the Framework hexagon,
    we have to employ adapters to expose system features and define which technologies
    will be used to enable such features. After assembling the Domain, Application,
    and Framework hexagons, we will have an architecture resembling the following
    figure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在领域六边形中创建了领域模型，包括实体、值对象和规范。然后，在应用六边形中，我们使用用例和端口表达用户的意图。现在，在框架六边形中，我们必须使用适配器来公开系统功能并定义将用于启用这些功能的技术。在组装了领域、应用和框架六边形之后，我们将拥有一个类似于以下图示的架构：
- en: '![Figure 8.1 – Domain, Application, and Frameworks hexagons assembled](img/B19777_08_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 领域、应用和框架六边形组合](img/B19777_08_01.jpg)'
- en: Figure 8.1 – Domain, Application, and Frameworks hexagons assembled
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 领域、应用和框架六边形组合
- en: What is so compelling about the hexagonal architecture is that we can add and
    remove adapters without worrying about changing the core system logic wrapped
    in the Domain hexagon. Of course, there is a price to be paid in the form of data
    translation between domain entities and external entities. However, in exchange,
    we gain a more decoupled system with clear boundaries between its realms of responsibilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构之所以引人入胜，在于我们可以在不担心改变领域六边形包裹的核心系统逻辑的情况下添加和删除适配器。当然，这需要付出数据在领域实体和外部实体之间转换的代价。然而，作为交换，我们获得了一个更加解耦的系统，其责任领域之间有清晰的边界。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Bootstrapping the Framework hexagon
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入框架六边形
- en: Implementing output adapters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现输出适配器
- en: Implementing input adapters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现输入适配器
- en: Testing the Framework hexagon
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架六边形
- en: By the end of this chapter, you’ll have learned to create input adapters to
    make the hexagonal application features accessible to other users and systems.
    Also, you’ll learn how to implement output adapters to enable the hexagonal system
    to communicate with external data sources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会创建输入适配器，使六边形应用功能可供其他用户和系统使用。您还将学习如何实现输出适配器，以使六边形系统能够与外部数据源通信。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you’ll need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for the Linux, Mac, and Windows operating systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，您需要在计算机上安装最新的**Java SE 开发工具包**和**Maven 3.8**。它们都适用于 Linux、Mac
    和 Windows 操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08)。
- en: Bootstrapping the Framework hexagon
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入框架六边形
- en: When building a system using hexagonal architecture, you don’t need to decide
    upfront whether the system API will be exposed using REST or gRPC, nor whether
    the system’s primary data source will be a MySQL database or MongoDB. Instead,
    what you need to do is start modeling your problem domain in the Domain hexagon,
    then designing and implementing use cases in the Application hexagon. Then, only
    after creating the previous two hexagons do you need to start thinking about which
    technologies will enable the hexagonal system’s functionalities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用六边形架构构建系统时，你不需要一开始就决定系统API将使用REST还是gRPC，也不需要决定系统的主要数据源将是MySQL数据库还是MongoDB。相反，你需要做的是从领域六边形开始建模你的问题域，然后在应用六边形中设计和实现用例。然后，只有在创建了前两个六边形之后，你才需要开始考虑哪些技术将使六边形系统的功能得以实现。
- en: A hexagonal approach centered around **Domain-Driven Design** allows us to postpone
    the decisions regarding the underlying technologies internal or external to the
    hexagonal system. Another prerogative of the hexagonal approach is the pluggable
    nature of the adapters. If you want to expose a certain system feature to be accessible
    via REST, you create and plug a REST input adapter into an input port. Later on,
    if you want to expose that same feature to clients using gRPC, you can create
    and plug a gRPC input adapter into the same input port.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以**领域驱动设计**为中心的六边形方法使我们能够推迟关于六边形系统内部或外部底层技术的决策。六边形方法的另一个优点是适配器的可插拔性。如果你想通过REST公开某个系统功能，你可以在输入端口创建并插入一个REST输入适配器。稍后，如果你想通过gRPC向客户端公开相同的功能，你可以在同一个输入端口创建并插入一个gRPC输入适配器。
- en: When dealing with external data sources, we have the same pluggable prerogatives
    using output adapters. You can plug different output adapters into the same output
    port, changing the underlying data source technology without having to majorly
    refactor the whole hexagonal system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理外部数据源时，我们使用输出适配器具有相同的可插拔优势。你可以将不同的输出适配器插入到同一个输出端口，无需对整个六边形系统进行大规模重构即可更改底层数据源技术。
- en: To further explore input adapters, we’ll have a more in-depth discussion in
    [*Chapter 12*](B19777_12.xhtml#_idTextAnchor244), *Using RESTEasy Reactive to
    Implement Input Adapters*. We’ll also investigate more possibilities for output
    adapters in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data
    with Output Adapters and* *Hibernate Reactive*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索输入适配器，我们将在[*第12章*](B19777_12.xhtml#_idTextAnchor244)，*使用RESTEasy Reactive实现输入适配器*中进行更深入的讨论。我们还将调查在[*第13章*](B19777_13.xhtml#_idTextAnchor263)，*使用输出适配器和Hibernate
    Reactive持久化数据*中输出适配器的更多可能性。
- en: Let’s stick to the basics and create a solid structure for input and output
    adapters. On top of this structure, later on, we’ll be able to add the exciting
    features provided by the Quarkus framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坚持基础，为输入和输出适配器创建一个坚实的基础结构。在这个结构之上，稍后我们将能够添加Quarkus框架提供的令人兴奋的功能。
- en: Continuing the development of the topology and inventory system, we need to
    bootstrap the Framework hexagon as a Maven and Java module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开发拓扑和库存系统，我们需要将框架六边形作为Maven和Java模块启动。
- en: 'Inside the topology and inventory Maven root project, we have to run the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在拓扑和库存Maven根项目中，我们必须运行以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We recommend running the preceding command directly on CMD instead of PowerShell
    if you are using Windows. If you need to use PowerShell, you’ll need to wrap each
    part of the command in double quotes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，我们建议直接在CMD中运行前面的命令，而不是PowerShell。如果你需要使用PowerShell，你需要将命令的每一部分用双引号括起来。
- en: The `mvn` `archetype:generate` goal creates a Maven module called `framework`
    inside `topology-inventory`. This module comes with a skeleton directory structure
    based on the `groupId` and `artificatId` we passed into the `mvn` command. Also,
    it includes a child `pom.xml` file inside the `framework` directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn` `archetype:generate`目标在`topology-inventory`内部创建一个名为`framework`的Maven模块。此模块包含基于我们传递给`mvn`命令的`groupId`和`artificatId`的骨架目录结构。此外，它还包括`framework`目录内的子`pom.xml`文件。'
- en: 'After executing the `mvn` command to create the `framework` module, the root
    project’s `pom.xml` file will be updated to contain the new module:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`mvn`命令创建`framework`模块后，根项目的`pom.xml`文件将更新以包含新的模块：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `framework` module is inserted at the end as the latest module we have just
    added.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`framework`模块作为最新添加的模块被插入到末尾。'
- en: 'Because the `framework` module depends on both the `domain` and `application`
    modules, we need to add them as dependencies to the `framework` module’s `pom.xml`
    file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `framework` 模块依赖于 `domain` 和 `application` 模块，我们需要将它们添加为依赖项到 `framework`
    模块的 `pom.xml` 文件中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After running the Maven command to create the `framework` module, you should
    see a directory tree similar to the one shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Maven 命令创建 `framework` 模块后，你应该看到一个类似于下面所示的目录树：
- en: '![Figure 8.2 – The directory structure of the Framework hexagon](img/B19777_08_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 框架六边形的目录结构](img/B19777_08_02.jpg)'
- en: Figure 8.2 – The directory structure of the Framework hexagon
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 框架六边形的目录结构
- en: There should be a child `pom.xml` file in the `framework` directory and a parent
    `pom.xml` file in the `topology-inventory` directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `framework` 目录中应该有一个子 `pom.xml` 文件，在 `topology-inventory` 目录中应该有一个父 `pom.xml`
    文件。
- en: 'Once we have completed the Maven configuration, we can create the descriptor
    file that turns the `framework` Maven module into a Java module. We do that by
    creating the following file, `topology-inventory/framework/src/java/module-info.java`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了 Maven 配置，我们就可以创建将 `framework` Maven 模块转换为 Java 模块的描述符文件。我们通过创建以下文件来完成此操作，`topology-inventory/framework/src/java/module-info.java`：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have added `domain` and `application` as Maven dependencies to the
    framework’s `pom.xml` file, we can also add them as Java module dependencies to
    the `module-info.java` descriptor file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 `domain` 和 `application` 作为 Maven 依赖项添加到框架的 `pom.xml` 文件中，我们也可以将它们作为
    Java 模块依赖项添加到 `module-info.java` 描述符文件中。
- en: With both the Maven and Java modules properly configured for the Framework hexagon,
    we can move on to creating the output adapters for the topology and inventory
    system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在为框架六边形正确配置了 Maven 和 Java 模块之后，我们可以继续创建拓扑和库存系统的输出适配器。
- en: Implementing output adapters
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现输出适配器
- en: We will start by implementing the output adapters to set up the integration
    between our topology and inventory system and the underlying data source technology,
    which is an `H2` in-memory database. It’s also important to implement output adapters
    first because we refer to them when implementing the input adapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现输出适配器，以设置我们的拓扑和库存系统与底层数据源技术（一个 `H2` 内存数据库）之间的集成。首先实现输出适配器也很重要，因为我们实现输入适配器时会引用它们。
- en: The topology and inventory system allows external data retrieval for routers’
    and switches’ entities. So, in this section, we will review the output port interfaces
    that get external data related to these entities. We’ll also provide an output
    adapter implementation for each output port interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑和库存系统允许外部检索路由器和交换机实体的数据。因此，在本节中，我们将回顾获取与这些实体相关的外部数据的输出端口接口。我们还将为每个输出端口接口提供输出适配器实现。
- en: The router management output adapter
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由管理输出适配器
- en: 'The router management output adapter we need to create should implement this
    `RouterManagementOutputPort` interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的路由管理输出适配器应该实现这个 `RouterManagementOutputPort` 接口：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both the `retrieveRouter` and `removeRouter` methods’ signatures have `Id` as
    a parameter. We use `Id` to identify the router in the underlying data source.
    Then, we have the `persistRouter` method signature receiving a `Router` parameter,
    which can represent both core and edge routers. We use that `Router` parameter
    to persist the data in the data source.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieveRouter` 和 `removeRouter` 方法的签名都包含 `Id` 参数。我们使用 `Id` 来识别底层数据源中的路由器。然后，我们有
    `persistRouter` 方法的签名接收一个 `Router` 参数，它可以代表核心路由器和边缘路由器。我们使用该 `Router` 参数在数据源中持久化数据。'
- en: For the topology and inventory system, for now, we have to implement only one
    output adapter to allow the system to use an `H2` in-memory database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拓扑和库存系统，目前我们只需要实现一个输出适配器，以便系统可以使用 `H2` 内存数据库。
- en: 'We start the implementation with the `RouterManagementH2Adapter` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `RouterManagementH2Adapter` 类开始实现：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `H2` database connection is controlled by `EntityManager`. This connection
    is configured by the `setUpH2Database` method, which we execute when we call the
    class’s empty constructor. We use the variable called `instance` to provide a
    singleton so other objects can trigger database operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`H2` 数据库连接由 `EntityManager` 控制。此连接由 `setUpH2Database` 方法配置，我们在调用类的空构造函数时执行此方法。我们使用名为
    `instance` 的变量来提供单例，以便其他对象可以触发数据库操作。'
- en: 'Let’s implement each method declared on the output port interface:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现输出端口接口上声明的每个方法：
- en: 'We start with the `retrieveRouter` method, which receives `Id` as a parameter:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`retrieveRouter`方法开始，它接收`Id`作为参数：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `getReference` method from `EntityManager` is called with `RouterData.class`
    and the UUID value is extracted from the `Id` object. `RouterData` is a database
    entity class that we use to map data coming from the database into the `Router`
    domain entity class. This mapping is accomplished by the `routerDataToDomain`
    method from the `RouterH2Mapper` class.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`EntityManager`的`getReference`方法调用，并使用`RouterData.class`作为参数，UUID值从`Id`对象中提取。`RouterData`是我们用来将来自数据库的数据映射到`Router`域实体类的数据库实体类。这种映射是通过`RouterH2Mapper`类的`routerDataToDomain`方法完成的。
- en: 'Then, we implement the `removeRouter` method, which removes a router from the
    database:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现`removeRouter`方法，它从数据库中删除路由器：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To remove a router, we first have to retrieve it by calling the `getReference`
    method. Once we have a `RouterData` object representing the database entity, we
    can call the `remove` method from `EntityManager`, which can delete the router
    from the database.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要删除一个路由器，我们首先需要通过调用`getReference`方法来检索它。一旦我们有了表示数据库实体的`RouterData`对象，我们就可以从`EntityManager`调用`remove`方法，从而从数据库中删除路由器。
- en: 'Finally, we implement the `persistRouter` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现`persistRouter`方法：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It receives a `Router` domain entity object that needs to be converted into
    a `RouterData` database entity object that can be persisted with the `persist`
    method from `EntityManager`.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它接收一个需要转换为`RouterData`数据库实体对象以便使用`EntityManager`的`persist`方法持久化的`Router`域实体对象。
- en: By implementing the `retrieveRouter`, `removeRouter`, and `persistRouter` methods,
    we provide the basic database operations required by the topology and inventory
    system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`retrieveRouter`、`removeRouter`和`persistRouter`方法，我们提供了拓扑和库存系统所需的基本数据库操作。
- en: Let’s move on to see the switch output adapters’ implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看交换机输出适配器的实现。
- en: The switch management output adapter
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换机管理输出适配器
- en: The output adapter we implement for the switch is simpler because we don’t need
    to persist switches directly or remove them. The sole purpose of the switch’s
    output adapter is to enable the retrieval of switches from the database. We allow
    persistence only through the router output adapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为交换机实现的输出适配器更简单，因为我们不需要直接持久化交换机或删除它们。交换机输出适配器的唯一目的是从数据库中检索交换机。我们只允许通过路由器输出适配器进行持久化。
- en: 'To get started, let’s define the `SwitchManagementOutputPort` interface:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们定义`SwitchManagementOutputPort`接口：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have just one method called `retrieveSwitch`, which receives `Id` and returns
    `Switch`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个名为`retrieveSwitch`的方法，它接收`Id`并返回`Switch`。
- en: 'The `SwitchManagementH2Adapter` output adapter implementation is very straightforward
    and similar to its router counterpart. So, we’ll just assess the implementation
    of the `retrieveSwitch` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwitchManagementH2Adapter`输出适配器的实现非常简单，与其路由器对应部分类似。所以，我们只需评估`retrieveSwitch`方法的实现：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We call the `getReference` method from `EntityManager` with `SwitchData.class`
    and a UUID value as parameters in order to retrieve a `SwitchData` database entity
    object. Then, this object is converted into a `Switch` domain entity when we call
    the `switchDataToDomain` method from the `RouterH2Mapper` class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EntityManager`的`getReference`方法，并使用`SwitchData.class`和从`Id`对象中提取的UUID值作为参数来检索一个`SwitchData`数据库实体对象。然后，当我们从`RouterH2Mapper`类调用`switchDataToDomain`方法时，该对象被转换为`Switch`域实体。
- en: Now that we have both `RouterManagementH2Adapter` and `SwitchManagementH2Adapter`
    properly implemented, we can proceed to implement the input adapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确实现了`RouterManagementH2Adapter`和`SwitchManagementH2Adapter`，我们可以继续实现输入适配器。
- en: Implementing the input adapters
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现输入适配器
- en: When building the Application hexagon, we need to create use cases and input
    ports to express system capabilities. To make these capabilities available to
    users and other systems, we need to build input adapters and connect them to input
    ports.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建应用程序六边形时，我们需要创建用例和输入端口来表示系统能力。为了使这些能力对用户和其他系统可用，我们需要构建输入适配器并将它们连接到输入端口。
- en: For the topology and inventory system, we will implement a set of generic input
    adapters as Java POJOs. These generic input adapters are the basis for the technologically
    specific implementation that takes place in [*Chapter 12*](B19777_12.xhtml#_idTextAnchor244),
    *Using RESTEasy Reactive to Implement Input Adapters*. In that chapter, we will
    reimplement the generic input adapters as RESTEasy-based input adapters using
    the Quarkus framework.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拓扑和库存系统，我们将实现一组通用输入适配器作为 Java POJO。这些通用输入适配器是技术特定实现的基础，该实现发生在 [*第12章*](B19777_12.xhtml#_idTextAnchor244)，*使用
    RESTEasy Reactive 实现输入适配器*。在该章中，我们将重新实现通用输入适配器，作为基于 RESTEasy 的输入适配器，使用 Quarkus
    框架。
- en: The input adapter’s central role is to receive requests from outside the hexagonal
    system and fulfill these requests using an input port.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入适配器的核心作用是从六边形系统外部接收请求，并使用输入端口来满足这些请求。
- en: Continuing to develop the topology and inventory system, let’s implement the
    input adapters that receive requests related to router management.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开发拓扑和库存系统，让我们实现接收与路由器管理相关的请求的输入适配器。
- en: The router management input adapter
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器管理输入适配器
- en: 'We start by creating the `RouterManagementGenericAdapter` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建 `RouterManagementGenericAdapter` 类：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start the `RouterManagementGenericAdapter` implementation by declaring a
    class attribute for `RouterManagementUseCase`. Instead of using an input port
    class reference, we utilize the use case interface reference, `RouterManagementUseCase`,
    to connect to the input port.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过声明一个 `RouterManagementUseCase` 类属性来开始 `RouterManagementGenericAdapter` 的实现。我们不是使用输入端口类引用，而是利用用例接口引用
    `RouterManagementUseCase` 来连接到输入端口。
- en: On the constructor of `RouterManagementGenericAdapter`, we call the `setPorts`
    method, which instantiates `RouterManagementInputPort` with a `RouterManagementH2Adapter`
    parameter as an output port to connect to the H2 in-memory database that the input
    port uses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RouterManagementGenericAdapter` 构造函数中，我们调用 `setPorts` 方法，该方法使用 `RouterManagementH2Adapter`
    参数作为输出端口来连接到输入端口使用的 H2 内存数据库。
- en: 'The following is how we should implement the `setPorts` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们应该如何实现 `setPorts` 方法：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `setPorts` method stores a `RouterManagementInputPort` object in the `RouterManagementUseCase`
    attribute we defined earlier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPorts` 方法将一个 `RouterManagementInputPort` 对象存储在我们之前定义的 `RouterManagementUseCase`
    属性中。'
- en: 'After class initialization, we need to create the methods that expose the operations
    supported by the hexagonal system. The intent here is to receive the request in
    the input adapter and forward it to an input port by using its use case interface
    reference:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在类初始化之后，我们需要创建暴露六边形系统支持的操作的方法。这里的意图是在输入适配器中接收请求，并通过使用其用例接口引用将其转发到输入端口：
- en: 'Here are the operations for retrieving and removing routers from the system:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是检索和从系统中删除路由器的操作：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The comments are to remind us that these operations will be transformed into
    REST endpoints when integrating Quarkus into the hexagonal system. Both `retrieveRouter`
    and `removeRouter` receive `Id` as a parameter. Then, the request is forwarded
    to an input port using a use case reference.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注释是为了提醒我们，这些操作在将 Quarkus 集成到六边形系统时将被转换为 REST 端点。`retrieveRouter` 和 `removeRouter`
    都接收 `Id` 作为参数。然后，使用用例引用将请求转发到输入端口。
- en: 'Then, we have the operation to create a new router:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有创建新路由器的操作：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the `RouterManagementUseCase` reference, we first call the `createRouter`
    method to create a new router, then we persist it using the `persistRouter` method.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `RouterManagementUseCase` 引用中，我们首先调用 `createRouter` 方法创建一个新的路由器，然后使用 `persistRouter`
    方法将其持久化。
- en: 'Remember that in the topology and inventory system, only core routers can receive
    connections from both core and edge routers. To allow the addition and removal
    of routers to or from a core router, we first define the following operation to
    add routers:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，在拓扑和库存系统中，只有核心路由器可以接收来自核心路由器和边缘路由器的连接。为了允许将路由器添加到或从核心路由器中移除，我们首先定义以下操作来添加路由器：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the `addRouterToCoreRouter` method, we pass the routers’ `Id` instances
    as parameters we intend to add along with the target core router’s `Id`. With
    these IDs, we call the `retrieveRouter` method to get the router objects from
    our data source. Once we have the `Router` and `CoreRouter` objects, we handle
    the request to the input port using a use case reference, by calling `addRouterToCoreRouter`
    to add one router to the other.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`addRouterToCoreRouter`方法，我们传递路由器的`Id`实例作为参数，我们打算添加的目标核心路由器的`Id`。有了这些ID，我们调用`retrieveRouter`方法从我们的数据源获取路由器对象。一旦我们有了`Router`和`CoreRouter`对象，我们通过使用情况引用来处理对输入端口的请求，通过调用`addRouterToCoreRouter`将一个路由器添加到另一个路由器。
- en: 'After that, we define the operation to remove routers from a core router:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义从核心路由器中移除路由器的操作：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the `removeRouterFromCoreRouter` method, we follow the same steps as those
    for the `addRouterToCoreRouter` method. The only difference, though, is that at
    the end, we call `removeRouterFromCoreRouter` from the use case in order to remove
    one router from the other.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`removeRouterFromCoreRouter`方法，我们遵循与`addRouterToCoreRouter`方法相同的步骤。然而，唯一的区别是，在最后，我们从使用情况中调用`removeRouterFromCoreRouter`以从另一个路由器中移除一个路由器。
- en: Let’s now create the adapter that handles switch-related operations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建处理交换机相关操作的适配器。
- en: The switch management input adapter
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换机管理输入适配器
- en: 'Before we define the methods that expose the switch-related operations, we
    need to configure the proper initialization of the `SwitchManagementGenericAdapter`
    class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义暴露交换机相关操作的函数之前，我们需要配置`SwitchManagementGenericAdapter`类的适当初始化：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`SwitchManagementGenericAdapter` is connected to two input ports – the first
    input port is `SwitchManagementInputPort` from `SwitchManagementUseCase`, and
    the second input port is `RouterManagementInputPort` from `RouterManagementUseCase`.
    That’s why we start the class implementation by declaring the attributes for `SwitchManagementUseCase`
    and `RouterManagementUseCase`. We are connecting the switch adapter to the router
    input port because we want to enforce any persistence activity to happen only
    through a router. The `Router` entity, as an aggregate, controls the life cycles
    of the objects that are related to it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwitchManagementGenericAdapter`连接到两个输入端口——第一个输入端口是来自`SwitchManagementUseCase`的`SwitchManagementInputPort`，第二个输入端口是来自`RouterManagementUseCase`的`RouterManagementInputPort`。这就是为什么我们开始类实现时声明了`SwitchManagementUseCase`和`RouterManagementUseCase`的属性。我们将交换机适配器连接到路由器输入端口，因为我们想强制任何持久化活动只通过路由器发生。`Router`实体作为一个聚合，控制与其相关的对象的生命周期。'
- en: 'Next, we implement the `setPorts` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`setPorts`方法：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the `setPorts` method, we initialize both input ports with the `SwitchManagementH2Adapter`
    and `RouterManagementH2Adapter` adapters to allow access to the H2 in-memory database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`setPorts`方法，我们使用`SwitchManagementH2Adapter`和`RouterManagementH2Adapter`适配器初始化两个输入端口，以允许访问H2内存数据库。
- en: 'Let’s see how to implement the methods that expose the switch-related operations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现暴露交换机相关操作的函数：
- en: 'We start with a simple operation that just retrieves a switch:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个简单的操作开始，这个操作只是检索一个交换机：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `retrieveSwitch` method receives `Id` as a parameter. Then, it utilizes
    a use case reference to forward the request to the input port.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`retrieveSwitch`方法接收`Id`作为参数。然后，它利用使用情况引用将请求转发到输入端口。'
- en: 'Next, we have a method that lets us create and add a switch to an edge router:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个方法，允许我们创建并添加一个交换机到边缘路由器：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We call the switch input port method, `createSwitch`, by passing the parameters
    received by the `createAndAddSwitchToEdgeRouter` method to create a switch. With
    `routerId`, we retrieve the edge router by calling the `retrieveRouter` method
    from the `router` input port. Once we have the `Switch` and `EdgeRouter` objects,
    we can call the `addSwitchToEdgeRouter` method to add the switch to the edge router.
    As the last step, we call the `persistRouter` method to persist the operation
    in the data source.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过传递`createAndAddSwitchToEdgeRouter`方法接收到的参数调用交换机输入端口的`createSwitch`方法来创建一个交换机。通过`routerId`，我们通过调用`router`输入端口的`retrieveRouter`方法检索边缘路由器。一旦我们有了`Switch`和`EdgeRouter`对象，我们可以调用`addSwitchToEdgeRouter`方法将交换机添加到边缘路由器。作为最后一步，我们调用`persistRouter`方法在数据源中持久化操作。
- en: 'Finally, we have the `removeSwitchFromEdgeRouter` method, which allows us to
    remove a switch from an edge router:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`removeSwitchFromEdgeRouter`方法，它允许我们从边缘路由器中移除一个交换机：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`removeSwitchFromEdgeRouter` receives `Id` as a parameter for the switch and
    another `Id` for the edge router. Then, it retrieves the router by calling the
    `retrieveRouter` method. With the switch ID, it retrieves the `switch` object
    from the edge router object. Once it gets the `Switch` and `EdgeRouter` objects,
    it calls the `removeSwitchFromEdgeRouter` method to remove the switch from the
    edge router.'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`removeSwitchFromEdgeRouter`接收交换机的`Id`参数以及边缘路由器的另一个`Id`。然后，它通过调用`retrieveRouter`方法检索路由器。使用交换机ID，它从边缘路由器对象中检索`switch`对象。一旦获取到`Switch`和`EdgeRouter`对象，它就调用`removeSwitchFromEdgeRouter`方法从边缘路由器中移除交换机。'
- en: What’s left now is to implement the adapter that deals with the topology and
    inventory networks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的是实现处理拓扑和库存网络的适配器。
- en: The network management input adapter
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络管理输入适配器
- en: 'As we did with the router and switch adapters, let’s implement the `NetworkManagementGenericAdapter`
    class by first defining the ports it needs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在路由器和交换机适配器中所做的那样，让我们首先定义它需要的端口来实现`NetworkManagementGenericAdapter`类：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Besides `NetworkManagementUseCase`, we also use `SwitchManagementUseCase`.
    We need to call the `setPorts` method from the constructor of `NetworkManagementGenericAdapter`
    to properly initialize the input port objects and assign them to their respective
    use case references. The following is how we implement the `setPorts` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`NetworkManagementUseCase`，我们还使用`SwitchManagementUseCase`。我们需要从`NetworkManagementGenericAdapter`的构造函数中调用`setPorts`方法，以正确初始化输入端口对象并将它们分配给相应的用例引用。以下是如何实现`setPorts`方法的示例：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we did in previous input adapter implementations, we configure the `setPorts`
    method to initialize the input port objects and assign them to the use case references.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的输入适配器实现中所做的那样，我们配置`setPorts`方法以初始化输入端口对象并将它们分配给用例引用。
- en: 'Let’s implement the network-related methods:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现与网络相关的函数：
- en: 'First, we implement the `addNetworkToSwitch` method to add a network to a switch:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实现`addNetworkToSwitch`方法以将网络添加到交换机：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `addNetworkToSwitch` method receives the `Network` and `Id` objects as parameters.
    To proceed, we need to retrieve the `Switch` object by calling the `retrieveSwitch`
    method. Then, we can call the `addNetworkToSwitch` method to add the network to
    the switch.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addNetworkToSwitch`方法接收`Network`和`Id`对象作为参数。为了继续操作，我们需要通过调用`retrieveSwitch`方法来检索`Switch`对象。然后，我们可以调用`addNetworkToSwitch`方法将网络添加到交换机。'
- en: 'Then, we implement the method to remove a network from a switch:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现从交换机中移除网络的方法：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we get a `Switch` object by calling the `retrieveSwitch` method with
    the `Id` parameter. To remove a network from a switch, we use the network name
    to find it from a list of networks attached to the switch. We do that by calling
    the `removeNetworkFromSwitch` method.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们通过使用`Id`参数调用`retrieveSwitch`方法来获取`Switch`对象。要从交换机中移除网络，我们使用网络名称从交换机附加的网络列表中找到它。我们通过调用`removeNetworkFromSwitch`方法来完成这个操作。
- en: The adapter for managing networks is the last input adapter we have to implement.
    With these three adapters, we can now manage routers, switches, and networks from
    the Framework hexagon. To make sure these adapters are working well, let’s create
    some tests for them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 管理网络的适配器是我们必须实现的最后一个输入适配器。有了这三个适配器，我们现在可以从框架六边形管理路由器、交换机和网络。为了确保这些适配器工作良好，让我们为它们创建一些测试。
- en: Testing the Framework hexagon
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试框架六边形
- en: By testing the Framework hexagon, we not only have the opportunity to check
    whether the input and output adapters are working well but we can also test whether
    the other hexagons, Domain and Application, are doing their part in response to
    the requests coming from the Framework hexagon.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试框架六边形，我们不仅有机会检查输入和输出适配器是否工作良好，还可以测试其他六边形（域和应用）是否在响应来自框架六边形的请求时履行其职责。
- en: To test it, we call the input adapters to trigger the execution of everything
    necessary in the downstream hexagons to fulfill the request. We start by implementing
    tests for the router management adapters. The tests for switches and networks
    follow the same pattern and are available in the GitHub repository for this book.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们调用输入适配器以触发下游六边形中所有必要操作的执行，以满足请求。我们首先实现路由器管理适配器的测试。交换机和网络的测试遵循相同的模式，并在本书的GitHub仓库中可用。
- en: 'For the routers, we will put our tests into the `RouterTest` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路由器，我们将把我们的测试放入`RouterTest`类中：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `RouterTest` constructor, we instantiate the `RouterManagementGenericAdapter`
    input adapter class that we use to perform the tests. The `loadData` method loads
    some test data from the `FrameworkTestData` parent class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RouterTest`构造函数中，我们实例化了用于执行测试的`RouterManagementGenericAdapter`输入适配器类。`loadData`方法从`FrameworkTestData`父类加载一些测试数据。
- en: 'Once we have correctly configured the requirements of the tests, we can proceed
    with the testing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们正确配置了测试的要求，我们就可以继续进行测试：
- en: 'First, we test router retrieval:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们测试路由器检索：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We call the input adapter, informing it of the router `id` we want to retrieve.
    With `assertEquals`, we compare the expected ID with the actual ID to see whether
    they match.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用输入适配器，通知它我们想要检索的路由器`id`。使用`assertEquals`，我们比较预期的ID与实际ID，以查看它们是否匹配。
- en: 'To test router creation, we have to implement the `createRouter` test method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试路由器创建，我们必须实现`createRouter`测试方法：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the router input adapter, we call the `createRouter` method to create and
    persist a new router. Then, we call the `retrieveRouter` method with the ID previously
    generated by the router we have just created. Finally, we run `assertEquals` to
    confirm whether the router retrieved from the data source is indeed the router
    we created.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从路由器输入适配器中，我们调用`createRouter`方法来创建和持久化一个新的路由器。然后，我们使用刚刚创建的路由器之前生成的ID调用`retrieveRouter`方法。最后，我们运行`assertEquals`以确认从数据源检索的路由器确实是我们创建的路由器。
- en: 'To test the addition of a router to a core router, we have the `addRouterToCoreRouter`
    test method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试将路由器添加到核心路由器，我们实现了`addRouterToCoreRouter`测试方法：
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We pass the variables, `routerId` and `coreRouterId`, as parameters to the input
    adapter’s `addRouterToCoreRouter` method, which returns a core router. `assertEquals`
    checks whether the core router has the router we added.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将变量`routerId`和`coreRouterId`作为参数传递给输入适配器的`addRouterToCoreRouter`方法，该方法返回一个核心路由器。`assertEquals`检查核心路由器是否包含我们添加的路由器。
- en: 'To test the removal of a router from a core router, we’ll use this code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试从核心路由器中移除路由器，我们将使用以下代码：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This test is very similar to the previous one. We again use the `routerId` and
    `coreRouterId` variables, but now we also use the `removeRouterFromCoreRouter`
    method, which returns the removed router. `assertEquals` checks whether the removed
    router’s ID matches the ID from the `routerId` variable.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此测试与上一个测试非常相似。我们再次使用`routerId`和`coreRouterId`变量，但现在我们还使用了`removeRouterFromCoreRouter`方法，该方法返回被移除的路由器。`assertEquals`检查移除的路由器的ID是否与`routerId`变量的ID匹配。
- en: 'To run these tests, execute the following command in the Maven project root
    directory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，请在Maven项目根目录中执行以下命令：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should be similar to the one here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Along with `RouterTest`, we also have tests from `SwitchTest` and `NetworkTest`,
    which you can find in the book’s GitHub repository, as mentioned before.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`RouterTest`之外，我们还有来自`SwitchTest`和`NetworkTest`的测试，这些测试可以在之前提到的书的GitHub仓库中找到。
- en: By implementing the Framework hexagon tests, we conclude the development of
    the Framework hexagon and the whole topology and inventory system’s backend. Taking
    what we’ve learned from this chapter and the previous chapters, we can apply all
    the techniques covered to create a system following the hexagonal architecture
    principles.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现框架六边形测试，我们完成了框架六边形的开发以及整个拓扑和库存系统后端。结合本章和前几章所学，我们可以将涵盖的所有技术应用于创建遵循六边形架构原则的系统。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the Framework hexagon construction by first implementing the output
    adapters to enable the topology and inventory system to use an H2 in-memory database
    as its primary data source.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先实现输出适配器来启动框架六边形构建，以使拓扑和库存系统可以使用H2内存数据库作为其主要数据源。
- en: 'Then, we created three input adapters: one for router operations, another one
    for switch operations, and the last one for network-related operations. To conclude,
    we implemented tests to ensure that the adapters and the whole hexagonal system
    worked as expected. By completing the development of the Framework hexagon, we
    have finished the development of our overall hexagonal system.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了三个输入适配器：一个用于路由器操作，另一个用于交换操作，最后一个用于与网络相关的操作。最后，我们实现了测试以确保适配器和整个六边形系统按预期工作。通过完成框架六边形的开发，我们已经完成了我们整体六边形系统的开发。
- en: We can improve the hexagonal system we have created by exploring the possibilities
    offered by the **Java Module Platform System** (**JPMS**). For example, we can
    leverage the hexagonal modular structure to apply the **Dependency Inversion**
    **Principle** (**DIP**). By doing so, we can make the hexagonal system more loosely
    coupled. We shall examine the DIP and other exciting features in the next chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过探索**Java模块平台系统**（**JPMS**）提供的可能性来改进我们创建的六边形系统。例如，我们可以利用六边形模块结构来应用**依赖倒置原则**（**DIP**）。通过这样做，我们可以使六边形系统更加松散耦合。我们将在下一章中探讨DIP和其他令人兴奋的功能。
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Which other Java modules does the `Framework hexagon` Java module depend on?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Framework hexagon` Java模块依赖于哪些其他Java模块？'
- en: Why do we need to create the output adapters?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要创建输出适配器？
- en: In order to communicate with the input ports, the input adapters instantiate
    input port objects and assign them to an interface reference. What’s that interface?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与输入端口通信，输入适配器实例化输入端口对象并将它们分配给一个接口引用。那么这个接口是什么？
- en: When we test a Framework hexagon’s input adapter, we are also testing other
    hexagons. Why does that happen?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们测试`Framework hexagon`的输入适配器时，我们也在测试其他六边形。为什么会发生这种情况？
- en: Answers
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `Framework hexagon` module depends on the Domain and Application hexagons’
    Java modules.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Framework hexagon`模块依赖于领域和应用程序六边形的Java模块。'
- en: We create output adapters to enable the hexagonal system to connect to external
    data sources.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建输出适配器以使六边形系统能够连接到外部数据源。
- en: It’s the use case interface.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那是使用案例接口。
- en: Because the input adapters depend on the components provided by the Domain and
    Application hexagons.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为输入适配器依赖于领域和应用程序六边形提供的组件。
