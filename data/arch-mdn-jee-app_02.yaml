- en: Designing and Structuring Java Enterprise Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和构建Java企业应用程序
- en: Every piece of software is designed in a certain way. The design includes the
    architecture of the system, structure of the projects, and structure and quality
    of the code. It can either communicate the intentions well or obfuscate them.
    Engineers need to design an enterprise application or system, before it is implemented.
    In order to do that, the purpose and motivations of the software need to be clear.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件都是以某种方式设计的。设计包括系统的架构、项目的结构以及代码的结构和质量。它可以很好地传达意图，也可以使意图变得模糊。工程师在实现之前需要设计企业应用程序或系统。为了做到这一点，软件的目的和动机需要明确。
- en: 'This chapter will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖：
- en: What aspects to focus on when developing software
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发软件时应关注哪些方面
- en: Project build structures and Java EE build systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目构建结构和Java EE构建系统
- en: How to structure enterprise projects modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建企业项目模块
- en: How to realize module package structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现模块包结构
- en: The purpose of enterprise applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业应用程序的目的
- en: Behind every action, be it in daily life, big organizations, or software projects,
    there should be a reason. We humans need reasons why we are doing things. In enterprise
    software development, there is no difference.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个行动背后，无论是日常生活、大型组织还是软件项目，都应该有一个原因。我们人类需要知道我们为什么做事情。在企业软件开发中，这一点并无不同。
- en: When we build software applications, the first question asked should be *why?*.
    Why is this piece of software needed? Why is it reasonable or required to spend
    time and effort to develop a solution? And why should the company care about developing
    that solution itself?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建软件应用程序时，首先应该问的问题是 *为什么？* 为什么需要这个软件？为什么有必要花费时间和精力去开发解决方案？以及为什么公司应该关心自己开发这个解决方案？
- en: In other words, what is the application's purpose? What problem is this piece
    of software trying to solve? Do we want the application to implement an important
    business process? Will it generate revenue? Is it going to gather revenue directly,
    for example by selling products, or indirectly by marketing, supporting customers,
    or business processes? Are there other possibilities to support customers, employees,
    or business processes?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，应用程序的目的是什么？这个软件试图解决什么问题？我们希望应用程序实现重要的业务流程吗？它会产生收入吗？它将通过销售产品、通过营销、支持客户或业务流程直接产生收入，还是通过其他方式支持客户、员工或业务流程？
- en: These and other questions target the application's business goals. Generally
    speaking, every piece of software needs a justification in the overall picture
    before we invest time and effort into it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他问题针对应用程序的业务目标。一般来说，在投入时间和精力之前，每件软件都需要在整体图中找到其合理性。
- en: The most obvious legitimization is to implement necessary business use cases.
    These use cases bring certain value for the overall business and will sooner or
    later realize features and generate revenue. At the end of the day, the software
    should achieve the goal of implementing the business use cases as best as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的合法化是实施必要的业务用例。这些用例为整体业务带来一定的价值，并将迟早实现功能并产生收入。最终，软件应该尽可能好地实现业务用例的目标。
- en: What developers should focus on
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者应该关注什么
- en: Therefore, software developers as well as project managers should first focus
    on meeting the business concerns and implementing the use cases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，软件开发人员和项目经理首先应该关注满足业务需求和实现用例。
- en: This clearly sounds obvious, but too often the focus of enterprise projects
    starts drifting away into other concerns. Developer effort is spent on implementation
    details or features that have little benefit for solving the actual problem. How
    many logging implementations, home-grown enterprise frameworks, or over-engineered
    levels of abstractions have we seen in the past?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来显然，但企业项目的焦点往往过于偏离到其他关注点。开发者将精力投入到实现细节或对解决实际问题帮助甚微的功能上。我们过去见过多少日志实现、自制的企业框架或过度设计的抽象级别？
- en: Non-functional requirements, quality of software, and so-called cross-cutting
    concerns are in fact an important aspect of software development. But the first
    and main focus of all engineering effort should be directed to meeting the business
    requirements and developing software that actually has a purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求、软件质量以及所谓的横切关注点实际上是软件开发的重要方面。但所有工程努力的首要和主要焦点应该是满足商业需求并开发具有实际目的的软件。
- en: Meeting customer's demands
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满足客户需求
- en: 'We have the following questions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下问题：
- en: What is the application's business purpose?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的商业目的是什么？
- en: What are the most important features that users care about?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户最关心的最重要的功能是什么？
- en: Which aspects will generate revenue?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些方面会产生收入？
- en: The answers to these questions should be known to the stakeholders. If not,
    then the correct way would be to take a step back, look at the overall picture
    of the software landscape, and reconsider the software's right to exist. Not in
    all cases the motivation will be purely business-driven. There are, in fact, a
    lot of cases where we will implement solutions that do not directly generate revenue
    but do so indirectly, by supporting others. These cases are certainly necessary
    and we will cover them and the general topic of how to construct reasonable system
    landscapes in Chapter 8, *Microservices and System Architecture*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案应该为利益相关者所知晓。如果不是这样，那么正确的做法是退一步，审视整个软件领域的全景，并重新考虑软件存在的合理性。并非所有情况下的动机都是纯粹的商业驱动。实际上，有很多情况下我们会实施那些不直接产生收入但间接支持他人的解决方案。这些情况无疑是必要的，我们将在第8章“微服务与系统架构”中涵盖这些情况以及如何构建合理的系统景观的一般主题。
- en: Besides these supporting software systems, we focus on business aspects. Having
    this main goal in mind, the first thing to address is how to model the business
    use cases and transform them into software. Only after that, the use cases are
    implemented using certain technologies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些支持性软件系统之外，我们关注商业方面。牢记这个主要目标，首先要解决的问题是如何对商业用例进行建模并将它们转化为软件。只有在之后，才会使用某些技术来实现这些用例。
- en: These priorities will also reflect the customer demands. The application's stakeholders
    care about software that fulfills its purpose.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优先级也将反映客户需求。应用程序的利益相关者关心的是能够实现其目的的软件。
- en: Software engineers tend to see this differently. They care about implementation
    details and the elegance of solutions. Engineers are often passionate about certain
    technologies and spend much time and effort choosing the right solutions as well
    as implementing them well. This includes a lot of technical cross-cutting concerns,
    such as logging, and so-called over-engineering, which is not mandatory for the
    business domain. Embracing software craftsmanship certainly has its importance
    and is essential for writing better software, but many times it is orthogonal
    to the client's motivations. Before spending time and effort with implementation
    details, engineers should be aware of the client's demands first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师往往有不同的看法。他们关心实现细节和解决方案的优雅性。工程师们通常对某些技术充满热情，花费大量时间和精力选择正确的解决方案以及有效地实施它们。这包括许多技术横切关注点，如日志记录，以及所谓的过度设计，这在商业领域并非强制性的。拥抱软件工艺当然有其重要性，并且对于编写更好的软件是必不可少的，但很多时候它与客户的动机是正交的。在花费时间和精力处理实现细节之前，工程师们首先应该了解客户的需求。
- en: Project timeline requirements are another aspect to consider. Software teams
    weigh business use cases against the quality of technical solutions. They tend
    to postpone required software tests or quality measures in order to meet deadlines.
    The technology used to implement the business application should support effective
    and pragmatic development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目时间表要求是另一个需要考虑的方面。软件团队会权衡商业用例与技术解决方案的质量。他们倾向于推迟必要的软件测试或质量措施以满足截止日期。用于实现商业应用的技术应该支持有效和务实的发展。
- en: When seeing the enterprise world through the eyes of a paying customer or a
    manager with limited time and budget, software engineers will likely understand
    their priorities. Caring about revenue-generating use cases first is mandatory.
    Technical necessities beyond these are seen by customers and managers as a *necessary
    evil*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当从付费客户或时间有限且预算有限的经理的角度看待企业世界时，软件工程师可能会理解他们的优先级。首先关注收入生成用例是强制性的。客户和经理将这些技术必要性视为一种*必要的恶*。
- en: The rest of this book will show you how to meet and balance these two motivations
    with Java EE.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分将向您展示如何使用Java EE满足并平衡这两个动机。
- en: Outer enterprise project structure
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部企业项目结构
- en: Having the goal of business use cases in mind, let's move our focus a bit more
    down to earth to real-world enterprise projects. In later chapters, we will see
    what methods are there to help us reflecting the business domains in the architecture
    in a suitable way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记商业用例的目标，让我们将焦点稍微更多地转向现实世界的企业项目。在后面的章节中，我们将看到有哪些方法可以帮助我们在架构中以适当的方式反映业务领域。
- en: Business and team structures
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业和团队结构
- en: Software projects are usually developed by a team of engineers, software developers,
    or architects. For simplicity, we will call them developers. Software developers,
    architects, testers, and all kind of engineers should arguably program from time
    to time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目通常由工程师团队、软件开发人员或架构师开发。为了简单起见，我们将它们称为开发者。软件开发人员、架构师、测试人员以及所有类型的工程师应该时不时地编写代码。
- en: However, in most situations we have several people working simultaneously on
    a software project. This already requires us to take a few things into account,
    mainly communication and organizational overhead. When we look at the structure
    within organizations with several teams working on multiple projects, or temporarily
    even the same project, we deal with even more challenges.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，我们有多个人同时在一个软件项目上工作。这已经要求我们考虑一些事情，主要是沟通和组织开销。当我们观察由多个团队在多个项目（甚至暂时是同一项目）上工作的组织结构时，我们会面临更多的挑战。
- en: 'The Conway''s law claims that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律声称：
- en: Organizations which design systems [...] are constrained to produce designs
    which are copies of the communication structures of these organizations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设计系统的组织 [...] 受限于产生与这些组织的沟通结构相复制的设计。
- en: '- Melvin Conway'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '- 梅尔文·康威'
- en: That being said, the way in which the teams are organized and communicate with
    each other will inevitably leak into software design. The organization chart of
    developers and their effective communication structures has to be considered when
    constructing software projects. We will have a detailed look into how to construct
    several distributed systems and more specific microservices in Chapter 8, *Microservices
    and System Architecture*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，团队的组织方式和相互沟通的方式不可避免地会渗透到软件设计中。在构建软件项目时，必须考虑开发者的组织结构及其有效的沟通结构。在第8章*微服务和系统架构*中，我们将详细探讨如何构建多个分布式系统以及更具体的微服务。
- en: Even in a single project owned by a team of few developers, there will likely
    be multiple features and bug fixes being developed simultaneously. This fact impacts
    how we plan the iterations, organize, and integrate source code, and build and
    deploy runnable software. In particular [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml),
    *Application Development Workflows* and Chapter 7, *Testing* will cover this topic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在一个由少数开发者组成的团队拥有的单一项目中，也可能会同时开发多个特性和错误修复。这一事实影响了我们规划迭代、组织、整合源代码以及构建和部署可运行软件的方式。特别是[第6章](599c6821-8971-4489-931c-9e11b5e23afd.xhtml)，*应用开发工作流程*和第7章，*测试*将涵盖这一主题。
- en: Software projects contents
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件项目内容
- en: Enterprise software projects include several artifacts necessary to build and
    ship applications. Let's have a closer look at them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件项目包括构建和交付应用程序所需的几个工件。让我们更仔细地看看它们。
- en: Application source code
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用源代码
- en: First of all, all enterprise applications, like probably any application, are
    written in source code. The source code is arguably the most important part of
    our software project. It represents the application and all its functionality
    at its core and can be seen as the single source of truth of software behavior.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有企业应用程序，可能像任何应用程序一样，都是用源代码编写的。源代码可以说是我们软件项目最重要的部分。它代表了应用程序及其核心功能，可以看作是软件行为的单一真相来源。
- en: The project's sources are separated into code that runs on production and test
    code to verify the application's behavior. The technologies as well as the quality
    demands will vary for test and production code. In Chapter 7, *Testing*, we will
    deeply cover the technologies and structures of software tests. Apart from that
    chapter, the focus of this book lies on production code, which is shipped and
    which handles the business logic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的源代码被分为运行在生产环境中的代码和用于验证应用程序行为的测试代码。测试代码和生产代码的技术以及质量要求可能会有所不同。在第7章“测试”中，我们将深入探讨软件测试的技术和结构。除了那一章之外，本书的重点在于生产代码，即已发布并处理业务逻辑的代码。
- en: Software structures
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件结构
- en: 'The software project organizes the source code in certain structures. In Java
    projects, we have the possibility to cluster components and responsibilities into
    Java packages and project modules, respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目以特定的结构组织源代码。在Java项目中，我们可以将组件和职责分别聚类到Java包和项目模块中：
- en: '![](img/a3993e8c-d3db-4403-a5ca-129fcb4b833a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3993e8c-d3db-4403-a5ca-129fcb4b833a.png)'
- en: Structuring these components is obviously less a technical rather than an architectural
    necessity. Code that is packaged arbitrarily would technically run equally well.
    However, this structure helps engineers understanding the software and its responsibilities.
    By clustering software components that fulfill coherent features, we increase
    cohesion and achieve a better organization of the source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化这些组件显然更多的是一种架构必要性而非技术必要性。任意打包的代码在技术上也能同样良好运行。然而，这种结构有助于工程师理解软件及其职责。通过聚类实现连贯特性的软件组件，我们增加了内聚性，并实现了源代码的更好组织。
- en: This and the next chapter will discuss the benefits of *Domain-Driven Design*,
    described in the book by Eric Evans, and the why and how to organize code in business-driven
    packages. For now, let's record that we group coherent components that form logical
    features into logical packages or project modules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节和下一章将讨论由埃里克·埃文斯所著书籍中描述的**领域驱动设计**（Domain-Driven Design）的好处，以及如何在业务驱动包中组织代码的原因和方法。目前，我们先记录下来，我们将形成逻辑特性的连贯组件分组到逻辑包或项目模块中。
- en: Java SE 9 comes with the possibility of shipping modules as Java 9 modules.
    These modules are, in essence, similar to the JAR files with the ability to declare
    dependencies and usages restrictions of other modules. Since this book is targeted
    for Java EE 8 and since the fact that the usage of Java 9 modules hasn't spread
    yet in real-world projects, we will cover only Java packages and project modules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 9提供了将模块作为Java 9模块发布的能力。这些模块本质上类似于具有声明其他模块依赖和用法限制能力的JAR文件。由于本书针对的是Java
    EE 8，并且Java 9模块在实际项目中的应用尚未广泛推广，我们将仅涵盖Java包和项目模块。
- en: Breaking the structure of software projects further down, the next smaller unit
    of software components is a Java class. Classes and the responsibilities thereof
    encapsulate single functionalities in the domain. They are ideally loosely coupled
    and show a high cohesion.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分解软件项目的结构，软件组件的下一个更小的单元是Java类。类及其职责封装了领域中的单一功能。它们理想上是松散耦合的，并显示出高度的内聚性。
- en: A lot has been written about clean code practices and representing functionality
    in source code. The book *Clean Code* by Robert C. Martin, for example, explains
    methods such as proper naming or refactoring, that help achieve well-crafted source
    code in packages, classes and methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于清洁代码实践和如何在源代码中表示功能已经有很多论述。例如，罗伯特·C·马丁所著的《Clean Code》一书，解释了诸如适当命名或重构等方法，这些方法有助于在包、类和方法中实现精心制作的源代码。
- en: Version control systems
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: The source code is kept under version control, since most software projects
    require coordination of simultaneous code changes, made by multiple developers.
    **Version control systems** (**VCS**) have established themselves as mandatory
    to reliably coordinate, track, and comprehend changes in software systems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数软件项目需要协调多个开发者同时进行的代码更改，源代码需要置于版本控制之下。**版本控制系统**（**VCS**）已经确立为可靠协调、跟踪和了解软件系统变更的必要手段。
- en: There are a lot of choices of version control systems, such as Git, Subversion,
    Mercurial or CVS. In the last years, **distributed revision control** systems,
    particularly **Git**, have been widely accepted as the state-of-the-art tools.
    They use a so-called *hash tree*, or *Merkle tree* to store and resolve individual
    commits, which enables efficient *diffs* and *merges*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统的选择有很多，例如Git、Subversion、Mercurial或CVS。在过去的几年里，**分布式修订控制系统**，尤其是**Git**，已被广泛接受为最先进的工具。它们使用所谓的*哈希树*或*默克尔树*来存储和解决单个提交，这使得高效的*差异*和*合并*成为可能。
- en: Distributed VCS enables developers to work with project repositories in distributed
    ways, without constantly requiring a network connection. Every workstation has
    its own repository, which includes the full history and is eventually synchronized
    with the central project repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式VCS使开发人员能够以分布式的方式与项目仓库一起工作，而无需始终需要网络连接。每个工作站都有自己的仓库，它包含完整的历史记录，并最终与中央项目仓库同步。
- en: As of writing this book, the vast majority of software projects use Git as version
    control system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书撰写时的情况来看，绝大多数软件项目使用Git作为版本控制系统。
- en: Binaries
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制
- en: The VCS project repository should only contain the sources that are produced
    and maintained by developers. Certainly, enterprise applications will have to
    be deployed as some kind of binary artifacts. Only these shippable binaries can
    be executed as runnable software. The binaries are ultimately the outcome of the
    development and build process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统（VCS）的项目仓库应仅包含由开发人员产生和维护的源代码。当然，企业应用程序必须以某种二进制工件的形式部署。只有这些可运输的二进制文件才能作为可执行软件运行。二进制文件是开发和构建过程的最终成果。
- en: In the Java world this means that the Java source code is compiled to portable
    bytecode and is usually packaged as **Web Application Archive** (**WAR**) or **Java
    Archive** (**JAR**), respectively. WAR or JAR files comprise all classes and files
    required to ship an application, framework dependency, or library. The **Java
    Virtual Machine** (**JVM**) finally executes the bytecode and together with that,
    our business functionality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，这意味着Java源代码被编译成可移植的字节码，通常分别打包为**Web应用程序存档**（**WAR**）或**Java存档**（**JAR**）。WAR或JAR文件包含了发送应用程序、框架依赖项或库所需的所有类和文件。**Java虚拟机**（**JVM**）最终执行字节码，以及与之相关的我们的业务功能。
- en: In enterprise projects the deployment artifacts, the WAR or JAR files, are either
    deployed to an application container or already ship the container themselves.
    The application container is needed, since beside their distilled business logic,
    enterprise applications will have to integrate additional concerns, such as application
    life cycle or communication in various forms. For example, a web application that
    implements certain logic but is not addressable over HTTP communication has little
    value. In Java Enterprise, the application container is responsible for providing
    this integration. The packaged application contains the distilled business logic
    and is deployed to a server, which takes care of the rest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业项目中，部署工件，即WAR或JAR文件，要么部署到应用程序容器中，要么自身携带容器。需要应用程序容器，因为除了它们提炼的业务逻辑外，企业应用程序还必须集成其他关注点，例如应用程序生命周期或各种形式的通信。例如，一个实现了某些逻辑但无法通过HTTP通信访问的Web应用程序几乎没有价值。在Java企业版中，应用程序容器负责提供这种集成。打包的应用程序包含提炼的业务逻辑，并部署到服务器上，服务器负责处理其余部分。
- en: In recent years, more Linux container technologies such as Docker have emerged.
    This carries the ideas of shippable binaries even further. The *binary* then not
    only contains the packaged Java application, but all components required to run
    the application. This, for examples, includes an application server, the Java
    Virtual Machine, and required operating system binaries. We will discuss the topic
    of shipping and deploying enterprise applications, especially regarding container
    technology, in [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml), *Lightweight
    Java EE*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，出现了更多像Docker这样的Linux容器技术。这进一步推动了可运输二进制的思想。然后，*二进制*不仅包含打包的Java应用程序，还包含运行应用程序所需的所有组件。例如，这包括应用程序服务器、Java虚拟机和所需的操作系统二进制文件。我们将在[第4章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，“轻量级Java
    EE”中讨论发送和部署企业应用程序的主题，特别是关于容器技术。
- en: The binaries are produced as part of the software build process. It enables
    to reliably recreate all binaries from the repository's sources. Therefore, the
    binaries should not be kept under version control. The same is true for generated
    source code. In the past, for example, JAX-WS classes which are required for SOAP
    communication were usually generated from descriptor files. Generated source code
    is created during the build process and should also not be kept under version
    control. The idea is to keep only the distilled source code in the repository
    and no artifacts that can be derived from it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件作为软件构建过程的一部分生成。它使得从存储库的源代码中可靠地重新创建所有二进制文件成为可能。因此，二进制文件不应被纳入版本控制之下。对于生成的源代码也是如此。例如，在以前，用于SOAP通信所需的JAX-WS类通常是从描述符文件生成的。生成的源代码在构建过程中创建，也不应被纳入版本控制之下。其理念是仅在存储库中保留提炼后的源代码，而不保留可以从中派生的任何工件。
- en: Build systems
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统
- en: The build process is first of all responsible for compiling the sources of a
    Java software project into bytecode. This happens every time changes have been
    made to the project. All modern build systems ship with useful conventions to
    minimize the required configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程首先负责将Java软件项目的源代码编译成字节码。每次对项目进行更改时都会发生这种情况。所有现代构建系统都提供了有用的约定，以最小化所需的配置。
- en: In the enterprise world, with all its different frameworks and libraries, an
    important step is to organize and define all dependencies on APIs and implementations.
    Build tools such as **Apache Maven** or **Gradle** support developers by including
    powerful dependency resolution mechanisms. The build tool adds all the dependencies
    with the corresponding versions required to compile or run the application, respectively.
    This simplyfies to setup the project among multiple developers. It also enables
    repeatable builds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业领域，拥有所有不同的框架和库，组织并定义所有对API和实现的依赖关系是一个重要的步骤。如**Apache Maven**或**Gradle**之类的构建工具通过包括强大的依赖关系解析机制来支持开发者。构建工具添加了编译或运行应用程序所需的相应版本的依赖项。这简化了在多个开发者之间设置项目的过程。它还使得构建可重复。
- en: Packaging the compiled classes and their dependencies into deployment artifacts
    is also part of the build process. Depending on the used technology the artifacts
    are packaged as WAR or JAR files. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will discuss the different ways of packaging Java enterprise
    applications together with their pros and cons.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将编译后的类及其依赖项打包成部署工件也是构建过程的一部分。根据所使用的技术，工件被打包为WAR或JAR文件。[第4章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，*轻量级Java
    EE* 将讨论打包Java企业应用的不同方式及其优缺点。
- en: The topics, *Gradle* and *Apache Maven*, will discuss the implementation and
    differences of the two main build systems in more depth.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主题，*Gradle* 和 *Apache Maven*，将更深入地讨论这两个主要构建系统的实现和差异。
- en: Single versus multi-module projects
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单模块与多模块项目
- en: As said before, we can organize the application's source code in Java packages
    and project modules, respectively. Project modules group related functionality
    together into separately buildable sub-projects. They are usually specified by
    the build systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以分别组织应用程序的源代码为Java包和项目模块。项目模块将相关功能组合成可单独构建的子项目。它们通常由构建系统指定。
- en: At first, the motivations behind splitting up project modules are quite understandable.
    Grouping Java code and packages into related modules creates a clearer view for
    the developers, enables a better structure, and increases cohesion.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，将项目模块拆分背后的动机是相当可以理解的。将Java代码和包分组到相关模块中，为开发者提供了一个更清晰的视图，使得结构更佳，并增加了凝聚力。
- en: Another reason for multi-modules is build time performance. The more complex
    our software project becomes the longer it will take to compile and package it
    into artifacts. Developers mostly touch few locations in the projects at a time.
    Therefore, the idea is to not always rebuild the whole project, but only the modules
    necessary in order to apply the desired changes. This is an advertised advantage
    of the Gradle build system, to save time by rebuilding only what has changed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多模块的另一个原因是构建时间性能。我们的软件项目越复杂，编译和打包成工件所需的时间就越长。开发者通常一次只接触项目中的少数几个位置。因此，理念是不总是重新构建整个项目，而只重新构建应用所需更改的必要模块。这是Gradle构建系统的一个宣传优势，通过只重新构建已更改的部分来节省时间。
- en: Another argument for this practice is the possibility of reusing certain sub-modules
    in several projects. By building sub-projects into self-sufficient artifacts we
    could possibly take and include a sub-artifact in another software project. For
    example, a common practice is to design a *model* module that contains the entities
    of the business domain, usually as standalone **plain old Java objects** (**POJOs**).
    This model would be packaged to a JAR file and reused as a dependency in other
    enterprise projects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的另一个论点是可以在多个项目中重用某些子模块。通过将子项目构建成自给自足的工件，我们可能可以将子工件包含到另一个软件项目中。例如，一种常见的做法是设计一个*模型*模块，它包含业务域的实体，通常作为独立的**普通Java对象**（**POJOs**）。这个模型会被打包成JAR文件，并在其他企业项目中作为依赖项重用。
- en: There are, however, some drawbacks, or rather, illusions to this practice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有一些缺点，或者更确切地说，是错觉。
- en: Illusion of reusability
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用的错觉
- en: We have to remind ourselves that software projects are built by teams of developers
    and the project structure will therefore adhere to their communication structures.
    Reusing certain modules within several projects requires quite a bit of coordination.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提醒自己，软件项目是由开发团队构建的，因此项目结构将因此遵循他们的沟通结构。在多个项目中重用某些模块需要相当多的协调。
- en: Technical dependencies
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术依赖
- en: A project's module that is subject to be reused has to meet specific criteria.
    First of all the technology of the shared modules has to match the target project.
    This sounds obvious, but has quite some implications on the implementation details.
    Especially used libraries and frameworks will inevitably cause the involved modules
    to be coupled and dependent on the specific technology. For example, model classes
    in Java EE typically contain annotations from APIs such as JPA that need to be
    available in all dependent modules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何要重用的项目模块都必须满足特定标准。首先，共享模块的技术必须与目标项目相匹配。这听起来很显然，但在实现细节上有很多影响。特别是使用的库和框架不可避免地会导致涉及的模块耦合并依赖于特定的技术。例如，Java
    EE中的模型类通常包含来自JPA等API的注解，这些注解需要在所有依赖模块中可用。
- en: Third-party dependencies with specific versions that are required for a shared
    module to function correctly have even more technical impact. These dependencies
    then have to be available at runtime and must not collide with other dependencies
    or versions thereof. This can cause a lot of headache with colliding dependencies
    that are already available on the server. The same holds true for implementation
    details that contain implicit dependencies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享模块正确运行所必需的特定版本的第三方依赖项甚至具有更多技术影响。这些依赖项必须在运行时可用，并且不能与其他依赖项或其版本冲突。这可能导致服务器上已经存在的冲突依赖项带来很多麻烦。同样，包含隐式依赖的实现细节也是如此。
- en: A typical example of this is JSON mapping libraries such as Jackson or Gson.
    A lot of third-party dependencies use these libraries in specific versions that
    might collide with other dependencies or versions at runtime. Another example
    is logging implementations such as **Logback** or **Log4j**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这的典型例子是像Jackson或Gson这样的JSON映射库。许多第三方依赖项使用这些库的特定版本，这些版本可能与运行时其他依赖项或版本冲突。另一个例子是日志实现，如**Logback**或**Log4j**。
- en: In general, shared models should be as self-sufficient as possible or at least
    contain only stable dependencies that won't likely drift into these issues. A
    good example for a very stable dependency is the Java EE API. Because of the backwards-compatible
    nature of the Enterprise Edition, usage of the API and resulting functionality
    won't break if a newer version is introduced.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，共享模型应尽可能自给自足，或者至少只包含不会轻易出现这些问题的稳定依赖项。一个非常好的稳定依赖项例子是Java EE API。由于企业版的向后兼容性，API的使用和由此产生的功能在引入新版本时不会中断。
- en: But even if the Java EE API is the only dependency of shared modules, it will
    bind the model to a specific version and reduce the freedom to change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Java EE API是共享模块的唯一依赖项，它也会将模型绑定到特定版本，并减少改变的自由度。
- en: Organizational challenges
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织挑战
- en: Shared technology and dependencies come with organizational challenges. The
    greater the number of developers and teams, respectively, the bigger the impact
    of used technology and dependencies. Teams have to agree upon certain technology,
    used frameworks and libraries and versions thereof.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 共享技术和依赖项伴随着组织挑战。开发者和团队的数量越多，所使用的技术和依赖项的影响就越大。团队必须就某些技术、使用的框架和库及其版本达成一致。
- en: If a single teams want to change something in this graph of dependencies or
    some of the used technologies, this change requires a lot of coordination and
    overhead. Chapter 8, *Microservices and System Architecture*, covers this topic
    of sharing code and artifacts within several systems and whether this is advisable
    or not.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个团队想要更改这个依赖图或某些使用的技术中的某些内容，这种更改需要大量的协调和开销。第8章“微服务和系统架构”涵盖了在多个系统中共享代码和工件的问题，以及这是否是可取的。
- en: Reusability considerations
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性考虑
- en: The trade-off is always reusability and having to deal with these issues versus
    simplicity and potential duplication. Depending on the level of self-sufficiency,
    the choice will be made toward one or the other. Generally speaking, the cost
    of coordinating dependencies, versions, and technology, outweighs the benefits
    of avoiding redundancy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的总是可重用性和处理这些问题与简单性和潜在重复之间的权衡。根据自给自足的程度，选择将倾向于一个或另一个。一般来说，协调依赖项、版本和技术成本超过了避免冗余的好处。
- en: An important question to be asked, however, is how the projects modules are
    layered either vertically or horizontally. An example for horizontal layering
    is the typical three-tier architecture of clustering into a *presentation*, *business*
    and *data layer*. Vertical layering means to group functionality based on their
    business domain. Examples would be modules for accounts, orders or articles, including
    all technical requirements such as HTTP endpoints or database access. Both types
    of modules can potentially be reused.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个重要的问题是要问项目模块是垂直还是横向分层。横向分层的例子是典型的三层架构，将集群分为*表示层*、*业务层*和*数据层*。垂直分层意味着根据业务领域分组功能。例如，包括所有技术要求（如HTTP端点或数据库访问）在内的账户、订单或文章模块。这两种类型的模块都有可能被重用。
- en: In reality horizontal layered modules like models are more likely subject to
    be shared among other projects. These types of modules naturally have a smaller
    variety of dependencies, ideally zero. On the contrary, vertical layered modules
    will contain implementation details and expect certain circumstances, for example,
    how the container is configured. And again, it depends a lot on the technology
    being used within the modules that are subject to share.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，像模型这样的横向分层模块更有可能被其他项目共享。这类模块自然具有更小的依赖性种类，理想情况下为零。相反，垂直分层模块将包含实现细节并期望某些情况，例如容器的配置方式。同样，这很大程度上取决于要共享的模块中使用的科技。
- en: Project artifacts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目工件
- en: Let's take a step back and look at the deployment artifacts of our enterprise
    application. Typically, an application results in a single artifact that will
    run our software. Even with several multi-modules being used at the end of the
    day, these will boil down to a single or few artifacts. So, in most of the cases
    all of this structure is flattened again into single JAR or WAR files. Looking
    at the reusability of modules, which is not necessarily being given, this raises
    the question of whether we need several modules per project at all. At the end
    of the day, introducing and managing sub-projects, vertical or horizontal, will
    require certain developer effort.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看我们企业应用的部署工件。通常，一个应用程序会产生一个单一的工件，用于运行我们的软件。即使最终使用了多个多模块，这些模块最终也会归结为一个或少数几个工件。因此，在大多数情况下，所有这些结构都会再次简化为单个JAR或WAR文件。考虑到模块的可重用性，这并不一定是既定的，这引发了是否每个项目都需要多个模块的问题。最终，引入和管理子项目，无论是垂直的还是水平的，都需要一定的开发者努力。
- en: It is true that splitting up the code base can improve build performance if
    only sub-projects that have been changed are rebuilt. However, in the sub-chapters
    *Apache Maven* and *Gradle* and [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* we will see that building a single reasonably designed project
    into a single artifact is sufficiently fast and that there are usually other aspects
    responsible for making builds slow.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，如果只重建已更改的子项目，那么拆分代码库可以提高构建性能。然而，在*Apache Maven*和*Gradle*以及第 4 章*轻量级 Java
    EE*中，我们将看到将单个合理设计的项目构建成一个单一工件是足够快的，而且通常还有其他方面负责使构建变慢。
- en: One project per artifact
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个工件一个项目
- en: It is advisable to package the enterprise project into a single deployment artifact
    that emerges from a single project module. The number and structure of deployment
    artifacts then maps the structure of the software projects. If other artifacts
    emerge from the project, they are organized in separate project modules as well.
    This enables an understandable and lightweight project structure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将企业项目打包成一个单一的部署工件，该工件源自单个项目模块。部署工件的数量和结构映射了软件项目的结构。如果项目产生了其他工件，它们也将被组织在单独的项目模块中。这使项目结构易于理解和轻量。
- en: Usually, an enterprise project will result in a shippable JAR or WAR file, originating
    from a single project module. Yet sometimes, we do have good reasons to create
    modules that are shared among projects. These are then sensibly crafted as own
    project modules that build own artifacts, for example JAR files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，企业项目将产生一个可发布的 JAR 或 WAR 文件，源自单个项目模块。然而，有时我们确实有很好的理由创建在项目之间共享的模块。这些模块随后被合理地构建为自己的项目模块，构建自己的工件，例如
    JAR 文件。
- en: There are still other motivations for multi-module projects. System tests that
    verify a deployed enterprise application from the *outside* don't necessarily
    have dependencies on the production code. It makes sense, in some situations,
    to organize these tests in separate project modules that are part of a multi-module
    project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多模块项目，还有其他动机。验证已部署的企业应用程序的系统测试可能不依赖于生产代码，从*外部*进行。在某些情况下，将这些测试组织为多模块项目的一部分，作为单独的项目模块是有意义的。
- en: Another example is frontend technologies that are just loosely coupled to the
    backend application. With modern client-centric JavaScript frameworks being used
    more and more, the coupling to the backend also decreases. The workflow and life
    cycle of developing frontends can vary from the backend application. Therefore,
    it can make sense to split the technology into several sub-projects or even several
    software projects. The topic, *Structuring for modern frontend technologies*,
    covers how to tackle these situations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是前端技术，这些技术与后端应用程序只是松散耦合。随着现代以客户端为中心的 JavaScript 框架越来越被使用，与后端的耦合也降低了。前端开发和的生命周期可能不同于后端应用程序。因此，将技术拆分为几个子项目，甚至几个软件项目是有意义的。*为现代前端技术结构化*这一主题涵盖了如何应对这些情况。
- en: These situations, however, also fit the concept of mapping *artifacts* in the
    broader sense to project modules. A system test project is used and executed separately
    from the production code. Developing and building the frontend project could equally
    be differ from the backend part. There may be some other situations where it is
    advisable as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些情况也符合将更广泛意义上的*工件*映射到项目模块的概念。系统测试项目是独立于生产代码使用和执行的。开发和构建前端项目也可能与后端部分不同。可能还有其他情况，在这种情况下也是建议的。
- en: Build systems for Java EE
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 的构建系统
- en: The project modules are specified as modules of the build system. Whether we
    can follow the straightforward way of having a single project or multiple projects;
    for example, motivated by system tests, we will build and execute them as part
    of the build process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 项目模块被指定为构建系统的模块。我们是否可以遵循简单的方式有一个单一的项目或多个项目；例如，受系统测试的驱动，我们将它们作为构建过程的一部分进行构建和执行。
- en: A good build system needs to ship certain features. The main task of it is to
    compile the sources and package the binaries as artifacts. Required dependencies
    are also resolved and used for compilation or packaged, respectively. There are
    several scopes where dependencies are required, such as during compilation, testing,
    or runtime. Different scope definition specify whether dependencies are shipped
    with the artifact.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的构建系统需要提供某些功能。它的主要任务是编译源代码并将二进制文件打包成工件。所需的依赖项也会被解决并用于编译或打包。依赖项在几个范围内是必需的，例如在编译、测试或运行时。不同的范围定义指定了依赖项是否与工件一起打包。
- en: The project should be built in a reliable, reproducible way. Several builds
    with identical project contents and build configuration must produce the same
    results. This is important for implementing **Continuous Delivery** (**CD**) pipelines,
    which enable reproducible builds. That said the build system must be able to run
    on a **Continuous Integration** (**CI**) server, such as **Jenkins** or **TeamCity**.
    This requires the software to ship a command-line interface, especially for Unix-based
    systems. [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml), *Application
    Development Workflows*, will show the motivations behind Continuous Delivery.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 项目应该以可靠、可重复的方式构建。具有相同项目内容和构建配置的多个构建必须产生相同的结果。这对于实施**持续交付**（**CD**）管道非常重要，这些管道可以实现可重复构建。也就是说，构建系统必须能够在**持续集成**（**CI**）服务器上运行，例如**Jenkins**或**TeamCity**。这要求软件提供命令行界面，特别是对于基于Unix的系统。[第6章](599c6821-8971-4489-931c-9e11b5e23afd.xhtml)，*应用程序开发工作流程*，将展示持续交付背后的动机。
- en: The build system will be used by software engineers working on various environments
    and operating systems, which should be supported as well. For JVM-based build
    systems this portability is usually given. It may be the case that projects have
    specific requirements such as native code that needs to be built on specific environments.
    For Java enterprise applications, however, this is usually not the case.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统将由在各种环境和操作系统上工作的软件工程师使用，这也应该得到支持。对于基于JVM的构建系统，这种可移植性通常是默认的。可能存在项目有特定要求的情况，例如需要在特定环境中构建的本机代码。然而，对于Java企业应用来说，这种情况通常并不存在。
- en: In general the build process should run as fast as possible. Booting up and
    configuring the build system should not require much time. The longer the build
    takes the higher the turnaround times and the slower the feedback engineers get
    from the build pipeline. In [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE,* we will cover more of this topic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，构建过程应该尽可能快地运行。启动和配置构建系统不应花费太多时间。构建时间越长，周转时间越高，工程师从构建管道中获得的反馈就越慢。在[第4章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，*轻量级Java
    EE*，我们将更详细地介绍这个主题。
- en: At the time of writing, Apache Maven is the most used build system well known
    to the majority of Java developers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Apache Maven是最受大多数Java开发者熟悉的、最常用的构建系统。
- en: Maven is a Java-based build system configured by XML. It's projects are defined
    by a so-called **project object model** (**POM**). Maven makes use of a **convention
    over configuration** approach that minimizes the required configuration. The default
    configuration is well suited for Java applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是一个基于Java的构建系统，通过XML进行配置。它的项目由所谓的**项目对象模型**（**POM**）定义。Maven利用**约定优于配置**的方法，最大限度地减少了所需的配置。默认配置非常适合Java应用程序。
- en: Another build tool with high usage is Gradle. Gradle is a build tool that offers
    a Groovy-based **Domain-Specific Language** (**DSL**) to configure fully extensible
    and scriptable project builds. Since Groovy is a full programming language Gradle
    build scripts are naturally powerful and flexible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用率很高的构建工具是Gradle。Gradle是一个提供基于Groovy的**领域特定语言**（**DSL**）的构建工具，可以配置完全可扩展和可脚本化的项目构建。由于Groovy是一种完整的编程语言，Gradle构建脚本自然强大且灵活。
- en: Both Gradle and Maven include a sophisticated dependency management and are
    well suited to build Java-based projects. There are certainly still other build
    systems, such as SBT, however, Gradle and Maven are, by far, the most-used ones
    and will be covered in the following section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle和Maven都包括复杂的依赖管理，非常适合构建基于Java的项目。当然，还有其他构建系统，例如SBT，但是Gradle和Maven无疑是使用最广泛的，将在下一节中介绍。
- en: Apache Maven
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Maven
- en: Apache Maven is widely used in Java-based projects and known to the vast majority
    of enterprise developers. The wide-spread usage and the familiarity of this tool
    is certainly a benefit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Maven在基于Java的项目中广泛使用，并且为大多数企业开发者所熟知。这种广泛的使用和工具的熟悉性当然是一个优势。
- en: Maven is based on a **convention over configuration** approach which simplifies
    straightforward use cases. Maven's configuration, however, does not always provide
    flexibility. In fact, this inflexibility is sometimes a feature. Since it's cumbersome
    to change the default Maven project structure and build process, most of the Java
    enterprise projects come in a very similar and familiar way. New developers easily
    find their way through the project's build configuration.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Maven基于**约定优于配置**的方法，这简化了直接使用场景。然而，Maven的配置并不总是提供灵活性。实际上，这种不灵活性有时是一个特性。由于更改默认Maven项目结构和构建过程很麻烦，大多数Java企业项目都以非常相似和熟悉的方式出现。新开发者可以轻松地找到项目构建配置的路径。
- en: 'The following snippet shows a typical example of a Maven project structure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了Maven项目结构的典型示例：
- en: '![](img/d1e10bd8-29c3-43a9-93eb-4151e67d690e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1e10bd8-29c3-43a9-93eb-4151e67d690e.png)'
- en: This will seem familiar to the majority of enterprise Java developers. This
    example web application is packaged as a WAR file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于大多数企业Java开发者来说都很熟悉。这个示例Web应用程序被打包成一个WAR文件。
- en: One of the shortcomings of Apache Maven is its somewhat nontransparent way of
    defining used build plugins and dependencies thereof. Using the default build
    convention without explicitly specifying versions for plugins such as the **Maven
    Compiler Plugin** can result in unwanted changes of used versions. This violates
    the principle of repeatable builds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Maven的一个缺点是其定义使用的构建插件和依赖关系的方式相对不透明。在不明确指定插件版本（如**Maven编译插件**）的情况下使用默认构建约定可能会导致不希望的变化。这违反了可重复构建的原则。
- en: Because of this, projects that require reproducibility often explicitly specify
    and override the plugin dependency versions in the POMs. By doing so, projects
    will be built using the same versions all the time, even if the default plugin
    versions change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要可重复性的项目通常会在POM中显式指定并覆盖插件依赖关系版本。这样做，项目将始终使用相同的版本进行构建，即使默认插件版本发生变化。
- en: Super POM definitions are another common solution to specify exact plugin versions.
    Project POMs can inherit from parent projects and reduce boilerplate plugin definitions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 超级POM定义是指定确切插件版本的另一种常见解决方案。项目POM可以从父项目中继承并减少样板插件定义。
- en: Developers can use the *effective POM* view that shows the resulting POM, after
    applying the default configuration and potential inheritance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用显示应用默认配置和潜在继承后结果的*有效POM*视图。
- en: 'A typical issue with Maven POMs is that enterprise projects very often overuse
    the XML definitions. They prematurely introduce plugins or configuration that
    already would be covered by the build conventions. The following snippet shows
    the minimum POM requirements for a Java EE 8 project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Maven POM的一个典型问题是企业项目非常经常过度使用XML定义。它们过早地引入了本应由构建约定覆盖的插件或配置。以下代码片段显示了Java EE
    8项目的最小POM要求：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *car manufacture* application is built into a WAR artifact. The `finalName`
    overrides the implied name of the WAR file, here resulting in `car-manufacture.war`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*汽车制造*应用程序构建在一个WAR工件中。`finalName`覆盖了WAR文件的隐含名称，这里结果为`car-manufacture.war`。'
- en: The specified Java EE 8 API is the only production dependency that a straightforward
    enterprise solution requires. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will deeply cover the topic of project dependencies and
    their impact.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的Java EE 8 API是直接企业解决方案所需的生产依赖的唯一依赖。[第4章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，*轻量级Java
    EE*将深入探讨项目依赖及其影响。
- en: The provided `properties` tag removes the need to explicitly configure the build
    plugins. Maven plugins per convention uses properties for configuration. Specifying
    these will reconfigure the used plugin without needing to explicitly declare the
    full definitions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`properties`标签消除了显式配置构建插件的需求。按照约定，Maven插件使用属性进行配置。指定这些属性将重新配置使用的插件，而无需显式声明完整定义。
- en: The properties cause the project to be built using Java SE 8, with all source
    files considered to be encoded as UTF-8\. The WAR file doesn't need to ship a
    `web.xml` deployment descriptor; this is why we instruct Maven not to fail the
    build on a missing descriptor. In the past, the Servlet API required deployment
    descriptors in order to configure and map the application's Servlets. Since the
    advent of Servlet API version 3, `web.xml` descriptors are not necessarily required
    anymore; Servlets are configurable using annotations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 属性使得项目使用Java SE 8进行构建，所有源文件都被视为UTF-8编码。WAR文件不需要包含`web.xml`部署描述符；这就是为什么我们指示Maven在缺少描述符时不要使构建失败。在过去，Servlet
    API需要部署描述符来配置和映射应用程序的Servlet。然而，自从Servlet API版本3推出以来，`web.xml`描述符不再是必需的；Servlet可以通过注解进行配置。
- en: Maven defines its build process in several phases, such as *compile*, *test*,
    or *package*. Depending on the chosen phase, multiple steps will be executed.
    For example, triggering the *package* phase will compile the `main` as well as
    `test` sources, run the test cases, and package all classes and resources into
    the artifact.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Maven在其构建过程中定义了几个阶段，例如*编译*、*测试*或*打包*。根据所选阶段，将执行多个步骤。例如，触发*打包*阶段将编译`main`以及`test`源代码，运行测试用例，并将所有类和资源打包到工件中。
- en: The Maven build commands are triggered in the IDE or the `mvn` command line,
    for example, as `mvn package`. This command triggers the *package* phase, resulting
    in a packaged artifact. More details on phases and functionality of Apache Maven
    can be found under its official documentation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Maven构建命令在IDE或`mvn`命令行中触发，例如，作为`mvn package`。此命令触发*打包*阶段，从而生成打包的工件。有关Apache
    Maven的阶段和功能更详细的信息，可以在其官方文档中找到。
- en: Gradle
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle
- en: At the time of writing, Gradle is less commonly used in Java enterprise projects
    than Apache Maven. This may be due to enterprise developers often being unfamiliar
    with dynamic JVM languages such as Groovy, which Gradle uses as its build script
    language. However, writing Gradle build files doesn't require deep knowledge of
    Groovy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Gradle在Java企业项目中的使用不如Apache Maven普遍。这可能是因为企业开发者通常不熟悉Gradle使用的Groovy等动态JVM语言。然而，编写Gradle构建文件并不需要深入了解Groovy。
- en: Gradle comes with quite a few benefits, most importantly its flexibility. Developers
    can leverage the full power of a programming language in order to define and potentially
    customize the project build.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle带来了许多好处，最重要的是其灵活性。开发者可以利用编程语言的全部功能来定义和可能自定义项目构建。
- en: Gradle will keep a daemon running in the background, that is being reused after
    the first build, to speed up subsequent build executions. It also keeps track
    of build inputs and outputs, whether changes have been made since the last build
    execution. This enables the system to cache steps and decrease the development
    build time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle将在后台保持一个守护进程的运行，该守护进程在第一次构建后将被重用，以加快后续构建执行的效率。它还会跟踪构建输入和输出，以及自上次构建执行以来是否进行了更改。这使得系统可以缓存步骤并减少开发构建时间。
- en: However, depending on the complexity of the project and its used dependencies
    this optimization might not even be required. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will cover the impact of project dependencies and zero-dependency
    applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据项目的复杂性和使用的依赖项，这种优化可能甚至不是必需的。[第4章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，*轻量级Java
    EE*将涵盖项目依赖项和零依赖应用程序的影响。
- en: 'The following snippet shows the build structure of a Gradle project:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了Gradle项目的构建结构：
- en: '![](img/46247618-3f58-4403-b4fc-0da571e05ade.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46247618-3f58-4403-b4fc-0da571e05ade.png)'
- en: As you can see, the structure is quite similar to Maven projects, with the difference
    being that built binaries are per default placed into the `build` directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结构相当类似于Maven项目，区别在于默认情况下构建的二进制文件放置在`build`目录中。
- en: It's common for Gradle projects to include a wrapper script for environments
    that have no Gradle installations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有Gradle安装的环境，Gradle项目通常包含一个包装脚本。
- en: 'The following code demonstrates an example of a `build.script` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一个`build.script`文件的示例：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Gradle build tasks are triggered via the command line, using `gradle` or the
    provided wrapper scripts. Executing `gradle build`, for example, is the analog
    of `mvn package`, compiling the sources, executing tests and building the artifact.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建任务通过命令行触发，使用`gradle`或提供的包装脚本。例如，执行`gradle build`是`mvn package`的类似物，编译源代码，执行测试并构建工件。
- en: There are certain benefits of having a fully-fledged programming language defining
    the build files. With the build scripts being treated as code, developers are
    encouraged to apply clean code principles for definitions that become too complex.
    Sophisticated build steps can, for example, be refactored into several, readable
    methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个完整的编程语言定义构建文件有其一定的优势。随着构建脚本被视为代码，开发者被鼓励为变得过于复杂的定义应用清洁代码原则。例如，复杂的构建步骤可以被重构为几个可读的方法。
- en: However, this power also brings the danger of over-engineering the build. As
    said, the inflexibility of Apache Maven can be considered a feature; the possibility
    of easily customizing build scripts eventually leads to build definitions that
    are very specific to the project. Compared to Maven, overly-customized builds
    can be an obstacle for developers who are unfamiliar with the project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种力量也带来了过度工程化构建的危险。正如所说，Apache Maven的不可灵活性可以被认为是一种特性；轻松定制构建脚本的可行性最终导致构建定义非常具体于项目。与Maven相比，过度定制的构建可能成为不熟悉项目的开发者的障碍。
- en: Experience shows that the vast majority of enterprise project builds are quite
    similar. This raises the question of whether the flexibility Gradle provides is
    required. Projects that don't have any special requirements, unlike for example
    product development, are sufficiently covered using Maven as build system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，绝大多数企业级项目构建相当相似。这引发了这样一个问题：Gradle提供的灵活性是否是必需的。与产品开发不同，没有特殊要求的项目，使用Maven作为构建系统已经足够。
- en: The rest of this book will thus use Maven when a build system is required as
    an example. All code examples, however, are equally well suited to use Gradle.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本书的其余部分将在需要构建系统时使用Maven作为示例。然而，所有代码示例同样适用于使用Gradle。
- en: Structuring for modern frontend technologies
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为现代前端技术进行结构化
- en: After shedding light on modern build systems for enterprise systems, let's have
    a look at how to integrate frontend technologies into the backend.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了企业级系统的现代构建系统之后，让我们看看如何将前端技术集成到后端。
- en: Traditionally, this was pretty straightforward. The frontend of web applications
    were, in most of the cases, server-side rendered HTML pages, powered by JSP or
    JSF. The HTML was crafted on the server on demand, that is, on request, and returned
    to the client. In order to realize that, the JSP or JSF pages, respectively, have
    to reside on the backend. Therefore, the whole enterprise application would be
    shipped and deployed as single artifact.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这相当直接。在大多数情况下，Web应用程序的前端是服务器端渲染的HTML页面，由JSP或JSF驱动。HTML是在服务器上按需制作的，即按请求制作，然后返回给客户端。为了实现这一点，JSP或JSF页面必须位于后端。因此，整个企业应用程序将作为一个单一工件进行打包和部署。
- en: Enter JavaScript frameworks
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入JavaScript框架
- en: With new frontend technologies, basically sophisticated JavaScript frameworks,
    and especially single page applications, this premise has changed quite a bit.
    The web frontend frameworks became more and more client-centric and included much
    more business logic than in the past. On the server side this meant that the interaction
    between backend and frontend moved from fine grained methods to more coarse grained,
    business use case methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的前端技术，基本上是复杂的JavaScript框架，尤其是单页应用程序的出现，这个前提已经发生了很大的变化。Web前端框架变得更加以客户端为中心，并且比过去包含了更多的业务逻辑。在服务器端，这意味着后端和前端之间的交互从细粒度方法转变为更粗粒度、业务用例方法。
- en: So, the more client-centric and powerful the JavaScript frameworks became, the
    more the communication between frontend and backend went from tightly coupled
    requests and responses to a more *API-like* usage, typically JSON via HTTP. This
    also meant that the server-side became more client-agnostic. For example, communicating
    solely via *RESTful-like*, JSON-format APIs enables native or mobile clients such
    as smartphones to use the same API like the frontend does.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着JavaScript框架越来越以客户端为中心和强大，前端和后端之间的通信从紧密耦合的请求和响应转变为更*API-like*的使用，通常是JSON通过HTTP。这也意味着服务器端变得更加客户端无关。例如，仅通过*RESTful-like*、JSON格式的API进行通信，使得原生或移动客户端，如智能手机，可以使用与前端相同的API。
- en: We have seen this movement in a lot of enterprise projects. However, one could
    argue about the relevance of putting more and more logic into the client side
    or whether a hybrid solution of having some parts rendered on the server-side
    and some on the client-side is more appropriate. Without going too much into this
    topic, let us look at a few key points.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多企业项目中看到了这种趋势。然而，有人可能会争论将更多逻辑放入客户端的相关性，或者是否在服务器端和客户端之间有一个混合解决方案，即部分在服务器端渲染，部分在客户端渲染，更为合适。不深入探讨这个话题，让我们看看几个关键点。
- en: Preparation of data or content will be performed faster on the server-side.
    There are more capabilities and resources available than on the client. The server
    can also utilize features such as caching and use the advantage of *seeing* the
    whole picture.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据或内容的准备将在服务器端进行得更快。服务器端有更多的能力和资源可用。服务器还可以利用诸如缓存等功能，并利用*看到*整个图景的优势。
- en: Sophisticated frontend technologies often include a navigation logic that makes
    use of so-called *hashbang* pages. An example of a hashbang page URL is `/car-manufacture/#!/cars/1234`.
    These pages, for example, *car 1234*, do not reside on the server, but are only
    rendered on the client-side. The URL of that sub-page is determined after the
    hash-sign, which is not taken into account while requesting resources over HTTP.
    That means that the client requests a generic *entry page* that then does the
    whole navigation logic including rendering sub-pages. This clearly reduces the
    number of requests, but has the drawback that the server cannot support preparing
    or pre-rendering content; everything happens on the client-side. There have been
    big companies such as Twitter that originally pursued this approach but went away
    from it again, due to this reason. In particular, viewing these pages on mobile
    devices comes with certain challenges. With potential slow mobile connections
    and less computing power, rendering and executing sophisticated client-logic on
    these devices do take longer than displaying pre-rendered HTML.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 高级前端技术通常包括一种利用所谓的*hashbang*页面的导航逻辑。一个hashbang页面的URL示例是`/car-manufacture/#!/cars/1234`。例如，这些页面，比如*car
    1234*，并不位于服务器上，而是在客户端渲染。该子页面的URL是在hash符号之后确定的，这在通过HTTP请求资源时不会被考虑。这意味着客户端请求一个通用的*入口页面*，然后执行整个导航逻辑，包括渲染子页面。这显然减少了请求数量，但缺点是服务器无法支持准备或预渲染内容；所有事情都在客户端发生。一些大公司，如Twitter，最初追求这种方法，但后来又放弃了，原因就在于此。特别是，在移动设备上查看这些页面会带来一定的挑战。由于潜在的缓慢移动连接和较少的计算能力，在这些设备上渲染和执行复杂客户端逻辑确实比显示预渲染的HTML要花费更长的时间。
- en: Compared to statically typed, high-level languages such as Java, JavaScript
    frontends do have the issue that dynamically typed languages introduce more potential
    errors while programming that would have been prevented by a compiler. Because
    of this reason, we have seen more sophisticated frontend technologies such as
    TypeScript emerging, which introduced static types and higher language features
    that are processed into JavaScript again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态类型的高级语言如Java相比，JavaScript前端确实存在动态类型语言在编程过程中引入更多潜在错误的问题，这些问题本可以通过编译器来避免。正因为如此，我们看到了像TypeScript这样的更高级的前端技术出现，它引入了静态类型和更高级的语言特性，这些特性最终被转换成JavaScript。
- en: Organizing modern frontends
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织现代前端
- en: However, no matter which specific frontend technology is chosen, enterprise
    projects do have more sophisticated frontends than in the past. This comes with
    new challenges of how to organize the daily development work. Typically the work
    cycles of the frontend and the backend will vary slightly. Some developers will
    typically see themselves more on the backend and others more on the frontend side.
    Even if the team solely consists of *full-stack* developers, some de-facto roles
    are likely to emerge over time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论选择哪种具体的前端技术，企业项目都比过去具有更复杂的前端。这带来了如何组织日常开发工作的新挑战。通常，前端和后端的工作周期会有所不同。一些开发者典型地会将自己视为更偏向后端，而其他人则更偏向前端。即使团队仅由*全栈*开发者组成，随着时间的推移，一些事实上的角色很可能会出现。
- en: Depending on the used technology it therefore makes sense to separate the frontend
    into a single project. As said before, as soon as some part of the software is
    shipped individually or has different life cycles than the rest, it makes sense
    to create a dedicated project module.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据所使用的技术的不同，将前端分离成一个单独的项目是有意义的。正如之前所说，一旦软件的某个部分是单独发货或具有与其余部分不同的生命周期，创建一个专门的项目模块就很有意义。
- en: If the frontend technology can be deployed without any backend dependencies
    other than the HTTP usage, organizing the project is pretty straightforward. The
    project can be built and deployed on a web server individually and will use one
    or several backends from the client side. This project then only consists of static
    resources, such as HTML, JavaScript, or CSS files, which are transferred to the
    client and executed there. There will be no tight technical dependencies to the
    used backends, besides the HTTP API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前端技术可以在不依赖任何后端依赖（除了HTTP使用）的情况下部署，组织项目就相当直接。该项目可以单独构建和部署在Web服务器上，并将使用来自客户端的一个或多个后端。这个项目只包含静态资源，如HTML、JavaScript或CSS文件，这些文件被传输到客户端并在那里执行。除了HTTP
    API之外，将没有对使用的后端有紧密的技术依赖。
- en: This aspect clearly has to be communicated well upfront during development,
    as well as documented on the backend side. Typically, the backend defines HTTP
    resources that serve required content in JSON format, which can optionally be
    filtered by query parameters if necessary. The reason behind the JSON format being
    popular is that JavaScript client code can use the response directly as JavaScript
    objects without any other transformation required.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方面显然需要在开发初期就很好地沟通，并在后端侧进行文档记录。通常，后端定义HTTP资源，以JSON格式提供所需的内容，如果需要，可以由查询参数进行过滤。JSON格式之所以受欢迎，是因为JavaScript客户端代码可以直接将响应作为JavaScript对象使用，而无需进行任何其他转换。
- en: If the frontend will be deployed together with the backend as a single artifact
    the project structure requires more coordination. The artifact contains both layers
    of technology and compiles and packages both at build time. During development
    this combination isn't necessarily helpful if the cycles of developing the frontend
    vary from the backend side. A programmer currently focusing on the frontend side
    probably doesn't want to build the backend part each and every time. The same
    is true with the backend technology waiting for potentially slow JavaScript compilation
    and packaging.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前端将与后端一起作为单个工件部署，则项目结构需要更多的协调。该工件包含技术层的两个层面，并在构建时编译和打包。在开发过程中，如果前端开发的周期与后端侧不同，这种组合可能并不一定有帮助。目前专注于前端开发的程序员可能不想每次都构建后端部分。同样，后端技术等待可能缓慢的JavaScript编译和打包也是如此。
- en: In these cases, it makes sense to split the project into several modules that
    can be built individually. What has proven itself well is to package the frontend
    module as an individual module and to introduce it as a dependency of the backend
    module, which then will package it altogether. By doing this, the frontend module
    clearly can be built individually, whereas a backend developer can rebuild the
    backend part as well by using their latest version of the frontend. Therefore,
    build times are reduced on both sides.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将项目拆分成几个可以单独构建的模块是有意义的。已经证明有效的方法是将前端模块打包成一个单独的模块，并将其作为后端模块的依赖项引入，然后后端模块将一起打包它。通过这样做，前端模块可以清楚地单独构建，而后端开发者也可以通过使用他们最新的前端版本来重新构建后端部分。因此，两边的构建时间都减少了。
- en: To realize this feature, the Servlet API can deliver static resources that are
    packed not only in the archive, but also in contained JAR files. Resources that
    reside under `META-INF/resources` of a JAR file that is contained in the WAR file,
    are delivered by the Servlet container, as well. The frontend project contains
    all its required frontend technology, framework and tools, and builds a separate
    JAR file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能，Servlet API可以提供静态资源，这些资源不仅打包在存档中，还打包在包含的JAR文件中。位于WAR文件中包含的JAR文件的`META-INF/resources`下的资源，也由Servlet容器提供。前端项目包含所有必需的前端技术、框架和工具，并构建一个单独的JAR文件。
- en: This enables developers to separate the frontend from the backend project to
    adapt to different life cycles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得开发者能够将前端项目与后端项目分开，以适应不同的生命周期。
- en: The rest of this book will focus on the backend technology and business use
    cases that are accessible via machine to machine communication such as web services.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本书余下的部分将专注于通过机器到机器通信（如Web服务）可访问的后端技术和业务用例。
- en: Enterprise project code structure
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业项目代码结构
- en: After seeing how we can organize our enterprise project structure, let's have
    a closer look at the detailed structure within a project. Assuming we have modeled
    an enterprise system that is reasonable in size and responsibility, we now map
    the concerns of the project into code structures.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到我们如何组织企业项目结构之后，让我们更仔细地看看项目内部的结构。假设我们已经建模了一个在规模和责任上合理的企业系统，我们现在将项目的关注点映射到代码结构中。
- en: Previously, we have discussed vertical versus horizontal module layers. This
    is precisely one of the aspects we need to look into when structuring the project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了垂直与水平模块层。这正是我们在结构化项目时需要考虑的方面之一。
- en: Situation in enterprise projects
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业项目中的情况
- en: The structure of typical enterprise projects has traditionally been a three-tier
    architecture. Three-tiers means three technically motivated layers, namely the
    *presentation*, *business*, and *data layer*. That being said, the project is
    organized horizontally, with three sub-modules, or packages, respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，典型企业项目的结构是一个三层架构。三层意味着三个技术驱动的层，即*表示层*、*业务层*和*数据层*。换句话说，项目是水平组织的，有三个子模块或包。
- en: The idea is to separate concerns from the data layer, from the business layer,
    and both of them from the presentation layers, as well. Functionality on a *lower*
    layer can therefore not have any dependencies on a *higher* layer, only the other
    way around. The business layer cannot use functionality of the presentation layer,
    only vice versa. The same is true for the data layer not depending on the business
    layer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将关注点从数据层、业务层以及它们与表示层分离。因此，低层上的功能不能有任何对高层功能的依赖，只有相反。业务层不能使用表示层的功能，只有相反。对于数据层不依赖于业务层也是如此。
- en: Each technically motivated layer or module has its own internal dependencies,
    that cannot be used from the outside as well. For example, only the *data layer*
    would be able to use the database, no direct invocations from the *business* layer
    would be possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个技术驱动的层或模块都有其自身的内部依赖关系，这些依赖关系不能从外部使用。例如，只有*数据层*能够使用数据库，从*业务层*的直接调用是不可能的。
- en: Another motivation is to be able to swap implementation details without impacting
    other layers. If the database technology would be changed in favor of another,
    that would in theory not affect the other two layers, since the data layer encapsulates
    these details. The same is true if the presentation technology changes. In fact,
    even several *presentation* layers can be developed with all of them using the
    same *business* layer components, at least if the layers are organized as separate
    modules.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个动机是能够在不影响其他层的情况下交换实现细节。如果数据库技术被改为另一种技术，从理论上讲，这不会影响其他两层，因为数据层封装了这些细节。如果表示技术发生变化，情况也是如此。实际上，甚至可以开发几个*表示层*，所有这些层都使用相同的*业务层*组件，至少如果这些层被组织为独立的模块的话。
- en: We have seen heated discussions, mostly from high-level architects, about the
    necessity of organizing and separating responsibilities by technical concerns.
    However, there are some drawbacks from this approach.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了关于通过技术关注点组织和分离责任必要性的激烈讨论，这些讨论大多来自高级架构师。然而，这种方法有一些缺点。
- en: Horizontal versus vertical layering
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平与垂直分层
- en: Clean code is all about code that aims to be understood by humans not machines.
    The same holds true for designing domains and organizing responsibilities. We
    want to find structures that easily tell the engineers what the project is all
    about.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码全部关于旨在被人类而非机器理解的代码。设计领域和组织职责也是如此。我们希望找到易于让工程师了解项目内容的结构。
- en: The challenge with structuring by technical concerns at already high layers
    of abstractions is that the purpose and domain of the software gets obfuscated
    and hidden in lower layers of abstraction. When someone unfamiliar with the project
    looks at the code structure the first thing that they see are the three technical
    layers, although names and numbers might differ in some cases. This will at least
    look familiar to them, but it tells nothing about the actual domain.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经高度抽象的技术关注点上进行结构化时，挑战在于软件的目的和领域被模糊和隐藏在抽象的较低层。当不熟悉项目的人查看代码结构时，他们首先看到的是三个技术层，尽管在某些情况下名称和数字可能有所不同。这至少看起来熟悉，但它并没有告诉他们实际的领域。
- en: Software engineers seek to understand domain modules, not necessarily technical
    layers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师寻求理解领域模块，而不一定是技术层。
- en: For example, when touching the *accounts* functionality, developers regard everything
    related to the accounts domain, not all the database access classes at once. Other
    than that, developers hardly search for *all database access classes*, but for
    that single class which handles that logic of their current domain.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当触及*账户*功能时，开发者会考虑与账户领域相关的所有内容，而不是一次性查看所有数据库访问类。除此之外，开发者很少搜索*所有数据库访问类*，而是寻找处理当前领域逻辑的那个单一类。
- en: The same is true when changes have to be made to the system. Changes in functionality
    are more likely to affect all technical layers of a single or a few business domains,
    but hardly all classes of a single technical layer at once. For example, changing
    a field to the user account likely affects the user model, database accesses,
    business use cases, and even the presentation logic, but not necessarily all the
    other model classes as well.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对系统进行更改时，也是如此。功能上的更改更有可能影响单个或少数业务领域的所有技术层，但几乎不会一次性影响单个技术层中的所有类。例如，将字段更改为用户账户可能会影响用户模型、数据库访问、业务用例，甚至展示逻辑，但不一定影响其他所有模型类。
- en: To make the idea what aspects developers are interested in more clearer, let
    me give another example. Imagine a family organized their clothes in a single
    big wardrobe. They could cluster all pants from all family members in a single
    drawer, as well as separate drawers for all socks and all shirts, respectively.
    But the family members won't likely search for all pants at once when they try
    to dress. Rather than this, they're just interested in their individual clothes,
    be it pants, shirts, socks, or something else. Therefore, it would make sense
    for them to organize by several areas of the wardrobe first, one per family member
    and then structuring by *technical clothes* aspects second, ideally following
    a similar structure. The same can be seen for software responsibilities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地表达开发者感兴趣的部分，让我再举一个例子。想象一个家庭将衣物整理在一个大衣柜里。他们可以将所有家庭成员的裤子集中在一个抽屉里，同时为所有袜子、所有衬衫分别设置单独的抽屉。但当家庭成员尝试穿衣时，他们不太可能一次性寻找所有裤子。相反，他们只对个人的衣物感兴趣，无论是裤子、衬衫、袜子还是其他东西。因此，他们首先按几个衣柜区域组织衣物是有意义的，每个家庭成员一个，然后按*技术衣物*方面进行结构化，理想情况下遵循类似的架构。同样的情况也适用于软件职责。
- en: Business-driven structure
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以业务驱动结构
- en: 'Uncle Bob once wrote about *Screaming Architectures* that should aim to at
    first tell the engineer what the whole enterprise project is about. The idea was
    that when looking at blueprints of buildings and seeing the structure and the
    detailed interior you immediately can tell: *this is a house*, *this is a library*,
    *this is a train station*. The same should hold true for software systems. You
    should be able to look at the project structure and be able to say: *this is an
    accounting system*, *this is a book store inventory system*, *this is an order
    management system*. Is this the case for the most projects we have? Or, does looking
    at the highest level of modules and packages rather tell us: *this is a Spring
    application*, *this system has a presentation, business and data layer*, *this
    system uses a Hazelcast cache*?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Uncle Bob 曾经写过关于*尖叫架构*的文章，这种架构应该首先向工程师说明整个企业项目的目的。这个想法是，当查看建筑蓝图和看到结构和详细的内部布局时，你立刻就能知道：*这是一座房子*，*这是一座图书馆*，*这是一座火车站*。软件系统也应该如此。你应该能够查看项目结构，并能够说：*这是一个会计系统*，*这是一个书店库存系统*，*这是一个订单管理系统*。这是否是我们大多数项目的实际情况？或者，查看最高层级的模块和包是否更多地告诉我们：*这是一个Spring应用程序*，*这个系统有一个表示层、业务层和数据层*，*这个系统使用Hazelcast缓存*？
- en: The technical implementations are certainly important to us developers. But
    again, the first thing that we focus on is business concerns. Following this approach,
    these aspects should be reflected in the project and module structure as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 技术实现对我们开发者来说当然很重要。但再次强调，我们首先关注的是业务问题。遵循这种方法，这些方面也应该反映在项目和模块结构中。
- en: Most importantly, this means our domain should be reflected in the application
    structure. Just by looking at the highest hierarchy of package names should give
    a good idea of what the software is trying to do. We therefore layer after business
    concerns first, implementation details second.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，这意味着我们的领域应该反映在应用程序结构中。仅仅通过查看最高层级的包名，就应该能很好地了解软件试图做什么。因此，我们首先关注业务问题，其次是实现细节。
- en: Blueprint plans for buildings will also first build up a picture what the building
    is about, how the rooms are separated, and where doors and windows are located.
    Then, as a secondary priority they may specify used materials, bricks, and types
    of concrete being used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑的蓝图计划首先会构建一个关于建筑的概念，如何分隔房间，以及门和窗户的位置。然后，作为次要优先级，它们可能会指定使用的材料、砖块和混凝土的类型。
- en: 'As an outlook for microservices consider the following: designing vertical
    modules enables the team to split up the application into a system of several
    applications much more easily. Looking at the module dependencies, for example
    through static code analysis, provides a picture of where the integration points
    between the systems would be. These integration points would emerge in some form
    of communication between the applications. In theory, we can then take that single
    module, plus minimal *plumbing*, and package it as a separate, self-sufficient
    application.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对微服务的一个展望，考虑以下内容：设计垂直模块使得团队能够更轻松地将应用程序拆分为多个应用程序的系统。通过查看模块依赖关系，例如通过静态代码分析，可以描绘出系统之间集成点的位置。这些集成点将以某种形式的应用程序间通信出现。从理论上讲，我们然后可以取那个单独的模块，加上最少的*管道*，将其打包为一个独立的、自给自足的应用程序。
- en: 'A point on names: by using the term *modules* we, by now, focus on business
    driven modules that are realized in Java packages and sub-packages, not build
    project modules. The term *modules* then serves more as a concept, less as a strict
    technical realization.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名的一个观点：通过使用术语*模块*，我们现在关注的是以Java包和子包实现的业务驱动模块，而不是构建项目模块。术语*模块*更多地作为一个概念，而不是严格的技术实现。
- en: Designing reasonable modules
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计合理的模块
- en: More down to earth, how do we find reasonably sized and structured modules?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际一些，我们如何找到合理大小和结构的模块？
- en: Putting business concerns first, a good start is to draw overviews of all the
    responsibilities and use cases of the application. This may be part of a brainstorming
    session, ideally together with business domain experts if that step hasn't been
    done before. What are the application's responsibilities? What business motivated
    use cases do we have? Which coherent functionality can be seen? The answers to
    these questions already give a good idea which modules are likely to be represented,
    without focusing on external systems, implementation details, or framework choices.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务关注点放在首位，一个好的开始是绘制应用程序所有责任和使用情况的概述。这可能是一部分头脑风暴会议的一部分，理想情况下是与业务领域专家一起进行，如果这一步之前还没有完成。应用程序有哪些责任？我们有哪些由业务驱动的使用案例？哪些连贯的功能可以观察到？对这些问题的回答已经给出了一个很好的想法，即哪些模块可能被表示，而不必关注外部系统、实现细节或框架选择。
- en: In this step we also already consider dependencies between these business concerns.
    Dependencies are helpful indicators of whether modules should be split up or,
    especially when circular dependencies are found, should be merged together. Constructing
    these overview diagrams, starting from a higher level and working the way down
    in several iterations will give a clearer image of what the business contents
    of the application are. Generally speaking, the identified modules should match
    well with the business aspects identified by the domain experts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们已经开始考虑这些业务关注点之间的依赖关系。依赖关系是判断模块是否应该拆分或，特别是在发现循环依赖时，应该合并在一起的有用指标。从更高层次开始构建这些概述图，并在几次迭代中逐步向下工作，将给出更清晰的图像，了解应用程序的业务内容。一般来说，确定的模块应该与领域专家识别的业务方面很好地匹配。
- en: 'To give an example, an online shopping application could identify modules for
    *users*, *recommendation*, *articles*, *payment*, and *shipping*. These would
    be reflected as the base domain modules:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个在线购物应用程序为例，它可以识别用于*用户*、*推荐*、*文章*、*支付*和*运输*的模块。这些将反映为基础领域模块：
- en: '![](img/86827232-c66e-4b88-b9c4-7fa61411aa97.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86827232-c66e-4b88-b9c4-7fa61411aa97.png)'
- en: The identified modules represent the base Java packages in our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确定的模块代表了我们应用程序中的基础Java包。
- en: It makes sense to put some effort into these considerations. However, as always,
    any *definitive* structure or implementation, no matter whether on code or module
    level, should be able to be changed later on. New requirements might emerge or
    there might be a better understanding later on, once the developers start to deep
    dive into the domain. Iterative refactoring, no matter on which level, will improve
    the quality of the system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些考虑因素上投入一些努力是有意义的。然而，一如既往，任何*确定性的*结构或实现，无论是在代码层面还是模块层面，都应该能够在以后进行更改。新的需求可能会出现，或者一旦开发者开始深入研究领域，可能会有更好的理解。无论在哪个层面，迭代重构都将提高系统的质量。
- en: Chapter 8, *Microservices and System Architecture*, will show similar motivations
    and methodologies when designing systems that comprise distributed applications.
    Particularly, the Domain-Driven Design approaches of bounded contexts and context
    maps will be discussed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章，*微服务和系统架构*，将展示在设计包含分布式应用的系统时的类似动机和方法。特别是，将讨论领域驱动设计的边界上下文和上下文映射方法。
- en: Realizing package structures
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现包结构
- en: Assuming we found appropriate base Java packages to start with. Now, how do
    you realize the inner package structure, that is, which sub-packages to use?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经找到了合适的Java基础包作为起点。现在，如何实现内部包结构，即使用哪些子包？
- en: Package contents
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包内容
- en: At first let's have a look at the contents of a vertically sliced module. Since
    it is modeled after business concerns, the module will include everything necessary
    to fulfill certain functionality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看垂直切片模块的内容。由于它是根据业务关注点建模的，因此该模块将包括实现某些功能所需的一切。
- en: First of all, the module includes technical entry points for use cases such
    as HTTP endpoints, presentation framework controllers, or JMS endpoints. These
    classes and methods usually make use of Java EE principles, such as inversion
    of control, to be called from the container as soon as some communication hits
    the application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该模块包括用于用例的技术入口点，例如HTTP端点、表示框架控制器或JMS端点。这些类和方法通常使用Java EE原则，如控制反转，以便在容器中调用，一旦某些通信触达应用程序。
- en: The functionalities that initiate the actual use cases are the next and equally
    important concern. They usually differ from the technical endpoints such that
    they don't contain any communication logic. The business use case boundaries are
    the entry point of our domain logic. They are implemented as managed beans, usually
    Stateless Sessions Beans, EJBs in other words, or CDI managed beans.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 启动实际用例的功能是下一个同样重要的关注点。它们通常与技术端点不同，因为它们不包含任何通信逻辑。业务用例边界是我们领域逻辑的入口点。它们作为托管豆实现，通常是无状态的会话豆，换句话说，是无状态的
    EJB 或 CDI 管理豆。
- en: The boundaries initiate and implement the business logic. In cases where the
    logic of a use case consists of just a few steps the boundary can sufficiently
    contain the whole logic in the business method or private methods in the class
    definition. Then no other delegate is required. For the vast majority of use cases
    the boundary would delegate logic to corresponding services. These delegates have
    finer-grained responsibilities. Depending on the domain this includes implementing
    detailed business logic or accessing external systems such as databases. Following
    Domain-Driven Design language, these classes include services, transaction scripts,
    factories, and repositories.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 边界负责启动和实现业务逻辑。在用例逻辑仅包含几个步骤的情况下，边界可以足够地包含整个逻辑在业务方法或类定义中的私有方法中。然后不需要其他代理。对于绝大多数用例，边界会将逻辑委派给相应的服务。这些代理具有更细粒度的责任。根据领域，这包括实现详细业务逻辑或访问外部系统，如数据库。遵循领域驱动设计语言，这些类包括服务、事务脚本、工厂和存储库。
- en: The next type of objects are all classes that typically would be considered
    as *model* content, such as entities, value objects, and transfer objects. These
    classes represent the entities in the domain, but also can, and should, implement
    business logic. Examples are entity beans that are managed in the database, other
    POJOs, and enumerations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种类型的对象都是通常被认为是 *model* 内容的类，例如实体、值对象和传输对象。这些类代表领域中的实体，但也可以，并且应该实现业务逻辑。例如，在数据库中管理的实体豆、其他
    POJO 和枚举。
- en: In some cases the package might also contain cross-cutting concerns such as
    interceptors with business or technical responsibilities. All these types of components
    now have to be organized within a module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，包可能还包含具有业务或技术责任的拦截器等横切关注点。现在所有这些类型的组件都必须在模块内组织。
- en: Horizontal package layering
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平包分层
- en: If we were to organize the module contents, our first attempt probably would
    be to design the inner package structure by technical layering. Slicing up by
    business concerns first and technical ones second at least sounds reasonable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要组织模块内容，我们的第一次尝试可能就是通过技术分层来设计内部包结构。首先按业务关注点切片，然后是技术关注点，至少听起来是合理的。
- en: In the *users* package this would mean to have sub-packages such as *controller*,
    *business* or *core*, *model*, *data* and *client*, respectively. By following
    this approach, we split up responsibilities inside the *users* package by their
    technical categories. In order to be consistent, all the other modules and packages
    in the project would have similar packages, depending on their contents. The idea
    is similar to a three-tier architecture, but inside of the domain modules.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *users* 包中，这意味着拥有如 *controller*、*business* 或 *core*、*model*、*data* 和 *client*
    等子包。通过遵循这种方法，我们根据技术类别将 *users* 包内的责任分割开来。为了保持一致性，项目中所有其他模块和包都会根据其内容拥有类似的包。这种想法类似于三层架构，但位于领域模块内部。
- en: 'One of the sub-packages would be considered to be the technical entry point,
    for instance *controller*. This package would contain the communication endpoints
    initiating the use case logic and serve as entry point outside of the application.
    The following shows the structure of a horizontally organized `users` package:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个子包将被视为技术入口点，例如 *controller*。这个包将包含启动用例逻辑的通信端点，并作为应用程序外的入口点。以下显示了水平组织化的 `users`
    包的结构：
- en: '![](img/3db0ac0a-adde-467a-94e3-8066492acbb9.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3db0ac0a-adde-467a-94e3-8066492acbb9.png)'
- en: 'This structure is realized in Java packages as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构如下所示在 Java 包中实现：
- en: '![](img/846313ce-1cb0-4168-93e8-c676b0677d3f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/846313ce-1cb0-4168-93e8-c676b0677d3f.png)'
- en: Flat module package
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平坦模块包
- en: An even simpler and more straightforward approach to organize module contents
    is to directly put all related classes into this module package in a flat hierarchy.
    For the `users` package this means to place all classes, including user related
    use case entry points, user database access code, potential external system functionality,
    and the user entity classes themselves, directly into this package.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 组织模块内容的一个更简单、更直接的方法是将所有相关类直接放入此模块包中的扁平层次结构中。对于`users`包来说，这意味着将所有类，包括用户相关的用例入口点、用户数据库访问代码、潜在的外部系统功能，以及用户实体类本身，直接放入此包中。
- en: Depending on the complexity of the modules this can be a clean and straightforward
    approach or it can become too unorganized over time. Especially entities, value
    objects, and transfer objects can reach a number of classes that, if put into
    a single package, drastically reduce clarity and overview. However, it makes a
    lot of sense to start with this approach and refactor later.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模块的复杂性，这可以是一个干净、直接的方法，或者随着时间的推移变得过于无序。特别是实体、值对象和传输对象可以达到一定数量的类，如果放入一个单独的包中，将极大地降低清晰度和概览性。然而，从这种方法开始并稍后重构是非常有意义的。
- en: 'The following shows the package structure of an example `users` package:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了示例`users`包的包结构：
- en: '![](img/89782f98-faa5-42ea-84a7-b43607cbe0b4.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89782f98-faa5-42ea-84a7-b43607cbe0b4.png)'
- en: A benefit of this approach is that it's well supported by the Java language.
    By default Java classes and methods come with package-private visibility. This
    fact together with organizing all classes in one place leverages encapsulations
    and visibility practices. Components, that are desired to be accessible from outside
    of the package, get public visibility; all classes and methods that are only accessed
    from within this package define package-private visibility. The package can therefore
    encapsulate all internal concerns.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是它得到了Java语言的良好支持。默认情况下，Java类和方法具有包私有可见性。这一事实与将所有类组织在一个地方相结合，利用了封装和可见性实践。希望从包外部访问的组件具有公共可见性；所有仅在此包内部访问的类和方法定义了包私有可见性。因此，包可以封装所有内部关注点。
- en: Entity Control Boundary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体控制边界
- en: Coping with the number of classes in the module package, there is another approach
    similar to technical layering, but with fewer and clearer defined packages. The
    idea is to structure due to what is a use case boundary of the module, which are
    subsequent business logic components, and which are entity classes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 应对模块包中的类数量，存在另一种类似技术分层的方法，但包定义更少且更清晰。想法是根据模块的使用案例边界来结构化，即后续的业务逻辑组件，以及哪些是实体类。
- en: This focuses on organizing module packages by their responsibilities, but with
    fewer technical details at the top package layer, compared to horizontal layering.
    The **boundary** package contains the use cases initiators, the boundaries, which
    are accessed from the outside of the system. These classes typically represent
    HTTP endpoints, message driven beans, frontend related controllers, or simply
    Enterprise Java Beans. They will implement the business driven use cases and optionally
    delegate to subsequent classes residing in the optional **control** package. The
    **entity** package contains all the *nouns* in the module, domain entities or
    transfer objects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这侧重于根据模块包的责任来组织模块包，但与水平分层相比，在顶层包层中包含的技术细节较少。**边界**包包含用例启动器、边界，这些边界可以从系统外部访问。这些类通常代表HTTP端点、消息驱动的豆类、前端相关的控制器，或者简单地是企业Java
    Bean。它们将实现业务驱动的用例，并可选择委托给位于可选**控制**包中的后续类。**实体**包包含模块中的所有**名词**，即领域实体或传输对象。
- en: 'Ivar Jacobson has formed the term **Entity Control Boundary** for following
    way of organizing modules:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ivar Jacobson为以下组织模块的方式提出了术语**实体控制边界**：
- en: '![](img/3879e8f1-419e-4893-95c8-1ac90cbda261.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3879e8f1-419e-4893-95c8-1ac90cbda261.png)'
- en: Packages
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: Let's have a closer look at the boundary package. The idea was that all business
    use cases called from the frontend or outside of the system are initiated here.
    Invocations for creation, update, or deletion of users, first land in classes
    residing in this package. Depending on the complexity of the use cases, the boundary
    either completely handles the logic itself or delegates into the control before
    becoming too complex.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下边界包。其理念是所有从前端或系统外部发起的业务用例都从这里启动。创建、更新或删除用户的调用首先到达这个包中的类。根据用例的复杂程度，边界要么完全处理逻辑，要么在变得过于复杂之前委托给控制层。
- en: For a Java enterprise application, classes in the boundary package are implemented
    as managed beans. As mentioned before, typically EJBs are used here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java企业应用，边界包中的类实现为托管Bean。如前所述，通常在这里使用EJB。
- en: If the logic in the boundary becomes too complex and not manageable within a
    single class anymore, we refactor the logic into delegates that are used in the
    boundary. These delegates or *controls* are placed in the control package. They
    typically fulfill more detailed business logic or handle database or external
    system access by acting within the technical transaction that was initiated in
    the boundary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果边界中的逻辑变得过于复杂，无法在一个类中管理，我们将逻辑重构为在边界中使用的委托。这些委托或*控制*被放置在控制包中。它们通常执行更详细的企业逻辑或通过在边界中启动的技术事务处理数据库或外部系统访问。
- en: This structure increases cohesion and reusability and honors the single responsibility
    principle. The structure of the business use case becomes more readable, once
    we introduce these abstraction layers. You can start by looking at the boundary
    as the entry point of the use case, and retrace every delegated step one after
    another.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构增加了内聚性和可复用性，并遵循单一职责原则。一旦我们引入这些抽象层，业务用例的结构就变得更加易于阅读。你可以从将边界视为用例的入口点开始，依次回溯每个委托步骤。
- en: In Domain-Driven Design language, the contents of the control package includes
    services, transaction scripts, factories and repositories. However, the existence
    of a control package for business use cases is optional.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计语言中，控制包的内容包括服务、事务脚本、工厂和存储库。然而，对于业务用例而言，存在控制包是可选的。
- en: At the heart of our domain we have all entities and value objects. These, together
    with transfer objects, build up the model of our domain module, the objects that
    a use case typically deals with. They are organized within the entity package,
    the last one of the Entity Control Boundary pattern.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的领域核心，我们有所有实体和价值对象。这些，连同传输对象，构成了我们的领域模块模型，即用例通常处理的那些对象。它们组织在实体包中，这是实体控制边界模式的最后一个包。
- en: Now, what about presentation-related components and cross-cutting concerns such
    as Interceptors or framework *plumbing* logic? Fortunately, in a modern Java EE
    project required framework plumbing is kept within limits as we will see in [Chapter
    3](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml), *Implementing Modern Java Enterprise
    Applications*. The few things that are required, for example bootstrapping JAX-RS
    with the application activator class, are placed in the root package of our project
    or in a specific `platform` package. The same is true for cross-cutting concerns
    such as technically motivated interceptors that are not bound to a specific module,
    but the application as a whole. The number of these classes is typically not too
    high; if so, then a dedicated package makes sense. The danger of having such a
    platform package is that it naturally tempts developers to put other components
    in there as well. This place is just meant for the few platform specific classes;
    everything else should reside in its own business motivated module package.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于与表示相关的组件和横切关注点，如拦截器或框架*管道*逻辑呢？幸运的是，在现代Java EE项目中，所需的框架管道逻辑被限制在一定的范围内，正如我们将在[第3章](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml)，“实现现代Java企业应用”中看到的。所需的东西很少，例如使用应用程序激活器类启动JAX-RS，这些都被放置在我们的项目根包或特定的`platform`包中。对于横切关注点也是如此，例如那些不绑定到特定模块，而是整个应用程序的由技术动机驱动的拦截器。这些类的数量通常不多；如果是这样，那么一个专门的包是有意义的。拥有这样一个平台包的危险在于，它自然会诱使开发者将其他组件也放入其中。这个地方只是用来放置少数平台特定类；其他所有东西都应该位于其自己的业务动机模块包中。
- en: 'The following is an example of the `users` module, using the Entity Control
    Boundary pattern:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用实体控制边界模式的`users`模块的示例：
- en: '![](img/2edc5642-6f75-4394-ad53-c8f4cc4362bb.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2edc5642-6f75-4394-ad53-c8f4cc4362bb.png)'
- en: Package access
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包访问
- en: Not all accesses from every package of the Entity Control Boundary pattern are
    allowed or make sense, respectively. In general, the logic flow starts at the
    boundary, going down to the control and entity package. The boundary package therefore,
    has dependencies to both the control, if existent, and the entity package. Using
    boundaries of other modules are not allowed and won't make sense, since the boundary
    represents a business use case. Accessing another boundary would mean to invoke
    something that should be a separate, standalone use case. Therefore boundaries
    can only go *down* the hierarchy to controls.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 并非从实体控制边界模式的每个包的所有访问都是允许的或是有意义的。一般来说，逻辑流程从边界开始，向下到控制包和实体包。因此，边界包因此对控制（如果存在）和实体包都有依赖。不允许使用其他模块的边界，因为这不会有意义，因为边界代表一个业务用例。访问另一个边界意味着调用应该是独立、独立用例的东西。因此，边界只能向*下*的层次结构到控制。
- en: However, dependencies and invocations from boundaries to controls of other modules
    are allowed and do make sense in some cases. Developers have to pay attention
    that the transaction scopes are still chosen correctly when accessing components
    from other modules. When accessing controls of other modules, it will also happen
    that they work with or return entities of that foreign module. This happens for
    more than trivial use cases and won't be an issue, as long as care is taken where
    the responsibilities are placed, and that the controls and entities are being
    used correctly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从边界到其他模块控制的依赖和调用是被允许的，在某些情况下也是有意义的。开发者必须注意，在从其他模块访问组件时，事务作用域仍然被正确选择。当访问其他模块的控制时，它们也会与该外国模块的实体一起工作或返回这些实体。这种情况发生在非平凡用例中，只要注意责任分配得当，并且控制和使用实体正确，就不会成为问题。
- en: Controls may access controls of other modules and their own and foreign entities.
    For the same reason as with boundaries, it makes no sense that a control invokes
    functionality of any boundary. This would be equivalent to starting new top-level
    business use cases within a running use case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 控制可以访问其他模块的控制、自己的以及外国实体。与边界相同的原因，控制调用任何边界的功能是没有意义的。这相当于在运行中的用例内启动新的顶级业务用例。
- en: Entities are only allowed to depend on other entities. In some cases it will
    be necessary to have imports on controls, for example, if JPA entity listeners
    or JSON-B type converters exist that can implement sophisticated logic. These
    technically motivated cases are the exception where it should be allowed for simplicity
    to import these classes. Ideally, these entity *supporting* components, such as
    entity listeners or converters should reside directly in the entity package. Due
    to other dependencies and usage of delegates this premise cannot always be fulfilled,
    which should not lead to overly complex technical workarounds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实体只能依赖于其他实体。在某些情况下，可能需要在控制上设置导入，例如，如果存在可以实施复杂逻辑的JPA实体监听器或JSON-B类型转换器。这些由技术驱动的案例是例外，在这种情况下，为了简单起见，允许导入这些类。理想情况下，这些实体*支持*组件，如实体监听器或转换器，应直接位于实体包中。由于其他依赖和代理的使用，这个前提并不总是能够得到满足，这不应该导致过于复杂的技术解决方案。
- en: This also brings us to another more general topic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这也引出了另一个更普遍的话题。
- en: Don't over-enforce architecture
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度强制架构
- en: Whichever architectural pattern you choose, the main priority of the application
    should be the business domain. This is true for both finding reasonable, domain-motivated
    modules, but also how to structure the packages within a module, so that developers
    can work with it with least effort.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种架构模式，应用程序的主要优先级应该是业务领域。这既适用于寻找合理的、由领域驱动的模块，也适用于如何在模块内结构化包，以便开发者可以以最少的努力与之合作。
- en: 'This is one important thing to note: developers should be able to work on the
    project without too complex or overly enforced structures and architectures. We
    have seen too many examples in the past that deliberately used technically driven
    layers or overly strict patterns, just to *match the book* and fulfill certain
    constraints. But these constraints are often self-motivated and don''t fulfill
    any higher purpose. We should sensibly reconsider what is required and what just
    bloats the development processes. Search for the term *cargo cult programming*
    when you have the time, and you will find an interesting real-world story of following
    rules and rituals without questioning their purpose.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一点需要注意的重要事项：开发者应该能够在不过于复杂或过度强制的结构和架构下工作。我们过去已经看到了太多例子，故意使用技术驱动的层或过于严格的模式，只是为了*符合书本*和满足某些约束。但这些约束通常是自发的，并不能满足任何更高的目的。我们应该理智地重新考虑需要什么，什么只是让开发过程膨胀。当你有时间的时候，搜索一下*载货文化编程*这个术语，你会找到一个有趣的现实世界故事，讲述的是在不质疑其目的的情况下遵循规则和仪式。
- en: Therefore, don't over-complicate or over-enforce architecture. If there is a
    simple and straightforward way that fulfills what currently is required, just
    go for it. This is not only true for premature refactoring, but also for architectural
    design. If putting a few classes in a single, well-named package serves the purpose
    and clearly documents the reasoning, why not? If a business use case boundary
    class can already fulfill the whole, simple logic, why introduce empty delegates?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要过度复杂化或过度强化架构。如果有一种简单直接的方法可以满足当前的需求，那就去做吧。这不仅适用于过早的重构，也适用于架构设计。如果将几个类放入一个命名良好的包中可以达到目的，并且清楚地说明了理由，为什么不呢？如果一个业务用例边界类已经能够满足整个简单逻辑，为什么还要引入空委托？
- en: The trade-off of following an architectural pattern, even if not required in
    all places, is consistency versus simplicity. Having all packages, modules, and
    projects showing the same patterns and structure shows a picture familiar to developers.
    However, in Chapter 8, *Microservices and System Architecture* we will see that
    in greater detail, ultimately, consistency is a goal that isn't likely to be achieved
    within the whole organization, or even single projects. The benefits of crafting
    something simpler and eventually more flexible outweighs uniformity in many cases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随架构模式所付出的代价，即使不是在所有地方都需要，是统一性与简单性之间的权衡。让所有包、模块和项目都展示相同的模式和结构，对开发者来说是一个熟悉的画面。然而，在第8章*微服务与系统架构*中，我们将更详细地看到，最终，统一性是一个不太可能在整个组织或单个项目中实现的目标。制作更简单且最终更灵活的东西的好处，在很多情况下超过了统一性。
- en: The same is true for overly trying to encapsulate the implementation using technical
    layers. It is definitely the case that modules as well as classes should encapsulate
    implementation details and provide clean and clear interfaces. However, these
    responsibilities can and should be contained in single, ideally self-sufficient
    packages or classes. Packaging the module's concerns by technical terms ultimately
    exposes the details to the rest of the module, for example, that a database or
    a client to an external system is being used. Organizing by domain motivation
    first, enables us to encapsulate functionality into single points of responsibility,
    transparent to the rest of the modules or application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，过度尝试使用技术层封装实现也是一样。确实，模块以及类应该封装实现细节并提供干净、清晰的接口。然而，这些责任可以并且应该包含在单个、理想上自给自足的包或类中。通过技术术语打包模块的关注点最终会将细节暴露给模块的其余部分，例如，使用数据库或连接到外部系统的客户端。首先按领域动机组织，使我们能够将功能封装到单个责任点中，对模块或应用的其余部分来说是透明的。
- en: In order to prevent accidental misuse of a way of packaging, the easiest and
    most transparent way is to introduce static code analysis. Package imports in
    classes and whole packages can be scanned and analyzed to detect and prevent unwanted
    dependencies. This represents a security measurement, similar to test cases, to
    avoid careless mistakes. Static code analyses will typically run as an extended
    part of the build process on the Continuous Integration server, as they may take
    some time to build. In [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml),
    *Application Development Workflows* we will cover this topic in more depth.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止意外滥用打包方式，最简单、最透明的方法是引入静态代码分析。类和整个包中的包导入可以被扫描和分析，以检测和防止不希望的依赖。这代表了一种安全措施，类似于测试用例，以避免粗心大意的错误。静态代码分析通常作为构建过程的一部分在持续集成服务器上运行，因为它们可能需要一些时间来构建。在[第6章](599c6821-8971-4489-931c-9e11b5e23afd.xhtml)“应用程序开发工作流程”中，我们将更深入地探讨这个话题。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Enterprise software should be built with the main priority to solve business
    problems, leading to business-driven applications and technology rather than to
    technology-driven solutions. The business use cases are what ultimately will generate
    revenue for the company.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件应该以解决业务问题为主要优先级来构建，导致以业务驱动应用和技术，而不是以技术驱动解决方案。业务用例最终将为公司创造收入。
- en: If possible, enterprise applications should be developed in one build project
    per artifact, kept under version control. Splitting up a project into several,
    independent build modules that are in the end boiled down to a single artifact,
    doesn't add much value. For the coarse project structure it's advisable to structure
    the software modules vertically, not horizontally. This means to structure by
    business rather than technical concerns. Looking at the project structure should
    immediately tell developers what the project's domain and responsibilities are
    about.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，企业应用应该在一个构建项目中开发每个工件，并保持在版本控制之下。将项目拆分成几个独立的构建模块，最终归结为一个单一工件，并不会增加太多价值。对于粗略的项目结构，建议垂直而不是水平地组织软件模块。这意味着按照业务而不是技术问题来组织。查看项目结构应该立即让开发者了解项目的领域和责任。
- en: An individual application module can, in the simplest way, be designed as a
    single, flat Java package. This is advisable if the number of classes per module
    is small. For more complex modules it makes sense to add another hierarchical
    layer using patterns such as Entity Control Boundary.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 单个应用程序模块可以以最简单的方式设计为一个单一的、平面的Java包。如果每个模块的类数量较少，这是推荐的。对于更复杂的模块，使用如实体控制边界等模式添加另一个分层层是有意义的。
- en: Software engineers should be reminded not to over-enforce software architecture.
    Well-thought-out design and bureaucratic organization certainly support developers
    a lot in crafting high quality software. Still, there is always a happy medium
    between reasonable design and over-engineering.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提醒软件工程师不要过度强调软件架构。经过深思熟虑的设计和官僚组织当然在很大程度上支持开发者构建高质量的软件。然而，合理设计和过度工程之间总是有一个快乐的平衡点。
- en: After seeing the course structure of enterprise projects and how to design modules,
    let's dive down one level to how to realize project modules. The following chapter
    will show you what it takes to implement enterprise applications with Java EE.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到企业项目的课程结构和如何设计模块之后，让我们深入一层，看看如何实现项目模块。下一章将向您展示使用Java EE实现企业应用需要哪些步骤。
