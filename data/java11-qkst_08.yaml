- en: Enhanced Enums in Project Amber
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Amber 中的增强枚举
- en: In Java 5, enums introduced a powerful way to define finite and predefined set
    of constants, with type safety. Enums enabled you to define a new type (like classes
    or interfaces) with state and behavior. **Project Amber** is enhancing enums,
    taking it to the next level; by adding type variables (generics) and allowing
    sharper type checking for enums. These two features will enable an enum to have
    constant specific type information and constant specific state and behavior. These
    enhancements will reduce the need of refactoring enums to classes, to use generics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 5 中，枚举引入了一种强大的方式来定义有限和预定义的常量集，具有类型安全。枚举使您能够定义一个新的类型（如类或接口），具有状态和行为。**Project
    Amber** 正在增强枚举，将其提升到下一个层次；通过添加类型变量（泛型）并允许对枚举进行更严格的类型检查。这两个特性将使枚举具有常量特定的类型信息和常量特定的状态和行为。这些增强将减少将枚举重构为类以使用泛型的需求。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is the reason for enhancing enums?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强枚举的原因是什么？
- en: Adding state and behavior to enum constants
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为枚举常量添加状态和行为
- en: How to create generic enums?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建泛型枚举？
- en: Accessing constant specific state and behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问特定常量的状态和行为
- en: Perform sharper type checking for enum constants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对枚举常量执行更严格的类型检查
- en: Challenges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战
- en: Introduction to enums in Java 5
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 5 中枚举的介绍
- en: '**Enums** introduced type safety to the use of constants, which were earlier
    defined using static final variables of type, say, `int`, or others. Imagine limiting
    the sizes of a shirt to some predefined sizes, say, `Small`, `Medium`, or `Large`.
    Here''s how you can do that with an enum, say, `Size`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**为常量的使用引入了类型安全，这些常量之前是用静态最终变量定义的，例如 `int` 类型或其他类型。想象一下将衬衫的尺寸限制为一些预定义的尺寸，比如
    `Small`、`Medium` 或 `Large`。以下是使用枚举（例如 `Size`）来实现这一点的示例：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java's coding conventions recommend use of uppercase to define enum constants
    (like `SMALL`).  Multiple words in a constant can be separated using an underscore.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的编码规范建议使用大写字母来定义枚举常量（如 `SMALL`）。枚举常量中的多个单词可以使用下划线分隔。
- en: 'Here''s how you can use enum `Size` in a class, say, `Shirt`, to restrict its
    sizes to constants defined in enum `Size`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在类（例如 `Shirt`）中使用枚举 `Size` 来限制其尺寸为枚举 `Size` 中定义的常量：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The instance variable of type `Size` in `Shirt` class limits the values that
    are assigned to it to `Size.SMALL`, `Size.MEDIUM` and `Size.LARGE`. Here''s an
    example of how another class, say, `GarmentFactory` class uses enum constants
    to create instances of class `Shirt`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shirt` 类中类型为 `Size` 的实例变量限制了分配给它的值只能是 `Size.SMALL`、`Size.MEDIUM` 和 `Size.LARGE`。以下是如何使用枚举常量创建
    `Shirt` 类实例的另一个类（例如 `GarmentFactory` 类）的示例：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Enums define a new type with a predefined set of constant values. Enums add
    type safety to the constant values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举定义了一个具有预定义常量值的新类型。枚举为常量值添加了类型安全。
- en: Decompiled enum – behind the scenes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反编译枚举 – 背后的事情
- en: 'Every user defined `enum` implicitly extends `java.lang.Enum` class. Behind
    the scenes, the one liner enum `Size` (defined in the preceding section) is compiled
    into something similar like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户定义的 `enum` 都隐式地扩展了 `java.lang.Enum` 类。在幕后，前面章节中定义的一行枚举 `Size`（`Size`）被编译成类似以下的内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Enums are syntactic sugar. The compiler takes your enum construct and extends
    `java.lang.Enum` to create a class. It adds the variables, initializers and methods
    to get the required behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是语法糖。编译器将你的枚举结构扩展为 `java.lang.Enum` 以创建一个类。它添加了变量、初始化器和方法以获得所需的行为。
- en: Adding state and behavior to enum constants
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为枚举常量添加状态和行为
- en: The enum constants can have their own state and behavior. One of the ways to
    do so is to define instance variables and methods in an enum. All of these are
    accessible to the enum constants. Let's modify the enum `Size` defined in the
    previous section, adding state and behavior to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举常量可以有自己的状态和行为。实现这一点的其中一种方法是在枚举中定义实例变量和方法。所有这些都可以被枚举常量访问。让我们修改上一节中定义的枚举 `Size`，给它添加状态和行为。
- en: 'Each enum constant can define a constant specific class body - defining new
    state and behaviour or override the default behaviour of enum methods in which
    it is defined. Here''s an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举常量都可以定义一个常量特定的类体 - 定义新的状态和行为或覆盖它所定义的枚举方法的默认行为。以下是一个示例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, enum Size defines three enum constants - `SMALL`,
    `MEDIUM` and `LARGE`. It also defines instance variables (`length` and `breadth`),
    a constructor and methods `getLength()`, `getWidth` and `toText()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，枚举 `Size` 定义了三个枚举常量 - `SMALL`、`MEDIUM` 和 `LARGE`。它还定义了实例变量（`length`
    和 `breadth`）、构造函数和 `getLength()`、`getWidth` 和 `toText()` 方法。
- en: Accessing state and behaviour of enum constants
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问枚举常量的状态和行为
- en: 'At present, an enum constant can access:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，枚举常量可以访问：
- en: State and behavior common to all enum constants
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有枚举常量共有的状态和行为
- en: Methods overridden by an enum constant
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由枚举常量重写的方法
- en: 'For the `Size` enum (defined in the preceding section), you can access the
    state and behavior common to all enum constants, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在前面部分定义的 `Size` 枚举，你可以按照以下方式访问所有枚举常量共有的状态和行为：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code outputs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also access the behavior, which a specific enum constant overrides:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以访问特定枚举常量重写的行为：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code outputs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But, you can''t access the state or behavior that is specific to an enum constant:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能访问特定于枚举常量的状态或行为：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `getSize()` method or the `number` variable can''t be accessed using the
    `MEDIUM` constant. This is because, `MEDIUM` creates an anonymous class and overrides
    the methods of the `Size` enum. It can''t access constant specific state or behavior
    because it''s still referenced by a variable of the `Size` type; which doesn''t
    define them. Here''s an image to help you remember this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MEDIUM` 常量无法访问 `getSize()` 方法或 `number` 变量。这是因为，`MEDIUM` 创建了一个匿名类并覆盖了 `Size`
    枚举的方法。由于它仍然通过一个 `Size` 类型的变量引用，无法访问特定于常量的状态或行为，而这个变量没有定义它们。以下是一张图片来帮助你记住这一点：
- en: '![](img/76889c86-0dcf-4762-a00e-53e8d8025604.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76889c86-0dcf-4762-a00e-53e8d8025604.png)'
- en: Existing enums don't allow access to state or behavior that is specific to an
    enum constant because it create an anonymous class to do so.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的枚举不允许访问特定于枚举常量的状态或行为，因为这会创建一个匿名类来执行此操作。
- en: Workaround to access state and behaviour of enum specific constants
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问枚举特定常量状态和行为的解决方案
- en: 'One the ways to get around it and access enum constant specific members is
    to define them for all members, but allow the usage only for specific members
    (I know, this is a dumb way). I''ve removed code not relevant to show how this
    works, on purpose:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题并访问枚举常量特定成员的一种方法是为所有成员定义它们，但只允许使用特定成员（我知道，这是一个愚蠢的方法）。我有意移除了与展示如何实现此功能无关的代码：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s try to access method `getSize()` using enum constants:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用枚举常量访问方法 `getSize()`：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exception in thread—`java.lang.UnsupportedOperationException`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 线程异常 - `java.lang.UnsupportedOperationException`。
- en: First and foremost, adding code (method `getSize()`) which is not applicable
    to all enum constants breaks encapsulation. In the preceding example, I defined
    `getSize()` in the main body, whereas only enum constant `MEDIUM` required the
    method `getSize()`. This is neither desirable, nor recommended.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加不适用于所有枚举常量的代码（方法 `getSize()`）会破坏封装。在前面的例子中，我在主体中定义了 `getSize()`，而只有枚举常量
    `MEDIUM` 需要这个方法。这既不理想，也不推荐。
- en: Compare it with an arrangement of a base class and its derived classes, and
    adding all behavior, specific to different derived classes in your base class.
    This sure sounds insane to me. Please don't try it at your work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将它与一个基类及其派生类的排列进行比较，并在基类中添加所有特定于不同派生类的行为。这对我来说听起来很疯狂。请不要在工作时尝试这样做。
- en: Don't attempt this workaround at work; it doesn't define encapsulated code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在工作时尝试这个解决方案；它没有定义封装的代码。
- en: Another example – using inheritance with enum constants
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个例子 - 使用枚举常量进行继承
- en: 'Here''s another example of an enum, which works with a set of subclasses by
    passing instances of subclasses to enum constructor. To get the point across,
    I''ve modified the `Size` enum, with which we have been working since the beginning
    of this chapter. Here''s the modified code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个枚举的例子，它通过将子类的实例传递给枚举构造函数与一组子类一起工作。为了说明这一点，我已经修改了 `Size` 枚举，我们从本章开始就一直使用它。以下是修改后的代码：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, you can''t access the state and behavior of enum constant specific code.
    Here''s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你不能访问特定于枚举常量的代码的状态和行为。以下是一个例子：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here comes enhanced enums to the rescue. JEP 301 introduces enhanced enums by
    adding type variables or generic to it. Let's see how it works in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 增强枚举正是为了解决这个问题而出现的。JEP 301 通过添加类型变量或泛型来引入增强枚举。让我们在下一节中看看它是如何工作的。
- en: Adding generics to Enums
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向枚举添加泛型
- en: 'Let''s rewrite the enum code in the preceding example (listing 8.x), adding
    type variables to the enum `Size.` Here''s the modified code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写前面示例（列表 8.x）中的枚举代码，向枚举 `Size` 添加类型变量。以下是修改后的代码：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code can be used to access constant specific behavior, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来访问特定常量的行为，如下所示：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the enhanced enums (generics added), you will be able to access an enum
    constant specific state or behavior.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在增强枚举（添加了泛型）的情况下，你将能够访问枚举常量的特定状态或行为。
- en: Let's work with another example of a generic enum, which can be used to restrict
    the user data to certain types.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个通用枚举的例子，它可以用来限制用户数据到某些类型。
- en: 'The following example creates a generic enum Data, which can be passed a type
    parameter, `T`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个泛型枚举 `Data`，它可以传递一个类型参数 `T`：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The class `FormData` defines a generic method, which can accept constant of
    enum `Data` and a value of the same type that is used for the enum constant:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormData` 类定义了一个泛型方法，它可以接受枚举 `Data` 的常量以及用于枚举常量的相同类型的值：'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s how you can use the constants of enum `Data` to restrict the combination
    of type of values you pass to method `add`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用枚举 `Data` 的常量来限制传递给 `add` 方法的值类型的组合的方法：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the mismatched data, the code fails at compilation, making it easier for
    the developer to correct her assumptions or program flow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据不匹配的情况下，代码将在编译时失败，这使得开发者更容易纠正她的假设或程序流程。
- en: Compilation failures are always better than runtime exceptions. Usage of generic
    enum `Data` will make the code fail at compile time, for mismatched combination
    of values passed to `add()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误总是比运行时异常要好。使用泛型枚举 `Data` 将使代码在编译时失败，对于传递给 `add()` 的值组合不匹配。
- en: Sharper typing of enum constants
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举常量的更精确类型化
- en: 'One of the two major goals of enhanced enums is to perform sharper type checking
    for enums. At present, the type of all enum constants is the enum in which they
    are defined. Referring to our example on enum, `Size`, this essentially means
    that the type of all the enum constants, that is, `SMALL`, `MEDIUM` and `LARGE`,
    is `Size`, which is incorrect (as depicted in the following image):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 增强枚举的两个主要目标之一是执行枚举的更精确类型检查。目前，所有枚举常量的类型是它们定义的枚举。参考我们的枚举示例 `Size`，这本质上意味着所有枚举常量的类型，即
    `SMALL`、`MEDIUM` 和 `LARGE`，是 `Size`，这是不正确的（如下面的图像所示）：
- en: '![](img/6dda7fab-7afa-47d5-b909-8299e36dfb9b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6dda7fab-7afa-47d5-b909-8299e36dfb9b.png)'
- en: Though enum constants are allowed to define constant specific class body, which
    includes variables and methods, the constant type is not sharp enough to allow
    access to enum constant-specific values. Even in the case of generic enums, the
    static type of an enum constant is not sharp enough to capture the full type information
    of individual constants.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管枚举常量可以定义特定于常量的类体，包括变量和方法，但常量类型不够精确，无法访问特定于枚举常量的值。即使在泛型枚举的情况下，枚举常量的静态类型也不够精确，无法捕获个别常量的完整类型信息。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you started with how the enums in Java 5 introduced type safety
    to constants. You covered how enums can have state and behavior, not just the
    one that applies to all constants in an enum; but also specific to the constants.
    However, its not feasible to access the state and behavior that is specific to
    an enum constant, with the existing enums.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你从 Java 5 中枚举如何引入类型安全到常量开始。你了解了枚举可以拥有状态和行为，不仅仅是适用于枚举中所有常量的行为；还可以是特定于常量的。然而，使用现有的枚举无法访问特定于枚举常量的状态和行为。
- en: You covered how the enhanced enums can use generics and enable access to constant
    specific state and behaviour. With examples, you also covered how type parameters
    when added to enums facilitate sharper typing of enum constants.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了增强枚举如何使用泛型并允许访问特定于常量的状态和行为。通过示例，你也了解了当类型参数添加到枚举中时，如何促进枚举常量的更精确类型化。
