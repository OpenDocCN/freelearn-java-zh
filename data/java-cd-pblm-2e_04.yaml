- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Records and Record Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和记录模式
- en: This chapter includes 19 problems that cover, in detail, the Java records introduced
    in JDK 16 (JEP 395), and record patterns introduced as a preview feature in JDK
    19 (JEP 405), as a second preview feature in JDK 20 (JEP 432), and as a final
    feature in JDK 21 (JEP 440).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括19个问题，详细介绍了JDK 16（JEP 395）中引入的Java记录，以及作为JDK 19（JEP 405）的预览特性、作为JDK 20（JEP
    432）的第二预览特性、作为JDK 21（JEP 440）的最终特性引入的记录模式。
- en: We start by defining a simple Java record. We continue by analyzing a record’s
    internals, what it can and cannot contain, how to use records in streams, how
    they improve serialization, and so on. We are also interested in how we can use
    records in Spring Boot applications, including JPA and jOOQ technologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个简单的Java记录。然后，我们分析记录的内部结构，它可以包含和不能包含的内容，如何在流中使用记录，它们如何改进序列化等。我们还对如何在Spring
    Boot应用程序中使用记录感兴趣，包括JPA和jOOQ技术。
- en: Next, we focus on record patterns for `instanceof` and `switch`. We will talk
    about nested record patterns, guarded record patterns, handling `null` values
    in record patterns, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注`instanceof`和`switch`的记录模式。我们将讨论嵌套记录模式、受保护记录模式、在记录模式中处理`null`值等。
- en: At the end of this chapter, you’ll have mastered Java records. This is great
    because records are a must-have for any Java developer who wants to adopt the
    coolest Java features.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将掌握Java记录。这很好，因为对于任何想要采用最酷Java特性的Java开发者来说，记录是必不可少的。
- en: Problems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess on Java records.
    I strongly encourage you to give each problem a try before you turn to the solutions
    and download the example programs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java记录上的编程能力。我强烈建议你在查看解决方案并下载示例程序之前，尝试解决每个问题：
- en: '**Declaring a Java record**: Write an application that exemplifies the creation
    of a Java record. Moreover, provide a short description of the artifacts generated
    by the compiler for a record behind the scenes.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**声明Java记录**：编写一个示例应用程序，展示Java记录的创建。此外，提供编译器在幕后为记录生成的工件简短描述。'
- en: '**Introducing the canonical and compact constructors for records**: Explain
    the role of the built-in record’s canonical and compact constructors. Provide
    examples of when it makes sense to provide such explicit constructors.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍记录的规范和紧凑构造函数**：解释内置记录的规范和紧凑构造函数的作用。提供一些示例，说明何时提供这样的显式构造函数是有意义的。'
- en: '**Adding more artifacts in a record**: Provide a meaningful list of examples
    about adding explicit artifacts in Java records (for instance, adding instance
    methods, static artifacts, and so on).'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在记录中添加更多工件**：提供一个有意义的示例列表，说明如何在Java记录中添加显式的工件（例如，添加实例方法、静态工件等）。'
- en: '**Iterating what we cannot have in a record**: Exemplify what we cannot have
    in a record (for instance, we cannot have explicit `private` fields) and explain
    why.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在记录中迭代我们无法拥有的内容**：举例说明我们无法在记录中拥有的内容（例如，我们无法有显式的`private`字段），并解释原因。'
- en: '**Defining multiple constructors in a record**: Exemplify several approaches
    for declaring multiple constructors in a record.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在记录中定义多个构造函数**：举例说明在记录中声明多个构造函数的几种方法。'
- en: '**Implementing interfaces in records**: Write a program that shows how to implement
    interfaces in records.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在记录中实现接口**：编写一个程序，展示如何在记录中实现接口。'
- en: '**Understanding record serialization**: Explain in detail and exemplify how
    record serialization works behind the scenes.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解记录序列化**：详细解释并举例说明记录序列化在幕后是如何工作的。'
- en: '**Invoking the canonical constructor via reflection**: Write a program that
    exemplifies how to invoke, via reflection, the canonical constructor of a record.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过反射调用规范构造函数**：编写一个程序，展示如何通过反射调用记录的规范构造函数。'
- en: '**Using records in streams**: Write several examples to highlight the usage
    of records for simplifying functional expressions relying on the Stream API.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在流中使用记录**：编写几个示例，突出记录在简化依赖于Stream API的功能表达式方面的用法。'
- en: '**Introducing record patterns for instanceof**: Write a bunch of examples that
    introduce *record patterns* for `instanceof`, including *nested record patterns*.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为instanceof引入记录模式**：编写一些示例，介绍`instanceof`的*记录模式*，包括*嵌套记录模式*。'
- en: '**Introducing record patterns for switch**: Write a bunch of examples that
    introduce *record patterns* for `switch`.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为switch引入记录模式**：编写一些示例，介绍`switch`的*记录模式*。'
- en: '**Tackling guarded record patterns**: Write several snippets of code to exemplify
    *guarded record patterns* (guarded conditions based on the binding variables).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理受保护的记录模式**：编写几个代码片段来举例说明*受保护的记录模式*（基于绑定变量的受保护条件）。'
- en: '**Using generic records in record patterns**: Write an application that highlights
    the declaration and usage of generic records.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在记录模式中使用泛型记录**：编写一个应用程序来突出泛型记录的声明和使用。'
- en: '**Handling nulls in nested record patterns**: Explain and exemplify how to
    deal with `null` values in record patterns (explain the edge case of `null` values
    in nested record patterns as well).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理嵌套记录模式中的 null 值**：解释并举例说明如何在记录模式中处理 `null` 值（解释嵌套记录模式中 `null` 值的边缘情况）。'
- en: '**Simplifying expressions via record patterns**: Imagine that you have an expression
    (arithmetic, string-based, Abstract Syntax Tree (AST), and so on). Write a program
    that uses record patterns to simplify the code for evaluating/transforming this
    expression.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过记录模式简化表达式**：想象一下，你有一个表达式（算术、基于字符串的、抽象语法树（AST）等）。编写一个使用记录模式简化评估/转换此表达式代码的程序。'
- en: '**Hooking unnamed patterns and variables:** Explain and exemplify the JDK 21
    preview feature covering unnamed patterns and variables.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**钩子未命名的模式和变量**：解释并举例说明 JDK 21 预览功能，该功能涵盖未命名的模式和变量。'
- en: '**Tackling records in Spring Boot**: Write several applications for exemplifying
    different use cases of records in Spring Boot (for instance, using records in
    templates, using records for configurations, and so on).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 Spring Boot 中的记录**：编写几个应用程序来举例说明 Spring Boot 中记录的不同用例（例如，在模板中使用记录，使用记录进行配置等）。'
- en: '**Tackling records in JPA**: Write several applications for exemplifying different
    use cases of records in JPA (for instance, using records and constructor expressions,
    using records and result transformers, and so on).'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 JPA 中的记录**：编写几个应用程序来举例说明 JPA 中记录的不同用例（例如，使用记录和构造表达式，使用记录和结果转换器等）。'
- en: '**Tacking records in jOOQ**: Write several applications for exemplifying different
    use cases of records in jOOQ (for instance, using records and the `MULTISET` operator).'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 jOOQ 中处理记录**：编写几个应用程序来举例说明 jOOQ 中记录的不同用例（例如，使用记录和 `MULTISET` 操作符）。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了前面问题的解决方案。请记住，通常没有一种正确的方式来解决特定的问题。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04)。
- en: 88\. Declaring a Java record
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 88. 声明 Java 记录
- en: 'Before diving into Java records, let’s think a little bit about how we commonly
    hold data within a Java application. You’re right … we define simple classes containing
    the needed instance fields populated with our data via the constructors of these
    classes. We also expose some specific getters, and the popular `equals()`, `hashCode()`,
    and `toString()` methods. Further, we create instances of these classes that wrap
    our precious data and we pass them around to solve our tasks all over our application.
    For instance, the following class carries data about melons like the melon types
    and their weights:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 Java 记录之前，让我们稍微思考一下在 Java 应用程序中我们通常如何持有数据。你说得对……我们定义包含所需实例字段的简单类，并通过这些类的构造函数用我们的数据填充它们。我们还公开了一些特定的获取器，以及流行的
    `equals()`、`hashCode()` 和 `toString()` 方法。此外，我们创建这些类的实例来封装我们宝贵的数据，并在整个应用程序中传递它们以解决我们的任务。例如，以下类携带有关西瓜的数据，如西瓜类型和它们的重量：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should be pretty familiar with this kind of traditional Java class and
    this tedious ceremony, so there is no need to go over this code in detail. Now,
    let’s see how we can accomplish the exact same thing but using Java record syntactical
    sugar that drastically reduces the previous ceremony:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该非常熟悉这种传统的 Java 类和这种繁琐的仪式，因此没有必要详细查看此代码。现在，让我们看看我们如何使用 Java 记录的语法糖来完成完全相同的事情，但大大减少了之前的仪式：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Java records were delivered as a feature preview starting with JDK 14, and
    it was released and closed in JDK 16 as JEP 395\. This single line of code gives
    us the same behavior as the previous one, the `Melon` class. Behind the scenes,
    the compiler provides all the artifacts, including two `private` `final` fields
    (`type` and `weight`), a constructor, two accessor methods having the same names
    as the fields (`type()` and `weight()`), and the trilogy containing `hashCode()`,
    `equals()`, and `toString()`. We can easily see the code generated by the compiler
    by calling the `javap` tool on the `MelonRecord` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java 记录作为功能预览从 JDK 14 开始提供，并在 JDK 16 中作为 JEP 395 发布和关闭。这一行代码为我们提供了与之前相同的行为，即
    `Melon` 类。在幕后，编译器提供了所有工件，包括两个 `private` `final` 字段（`type` 和 `weight`）、一个构造函数、两个与字段同名的方法（`type()`
    和 `weight()`），以及包含 `hashCode()`、`equals()` 和 `toString()` 的三部曲。我们可以通过在 `MelonRecord`
    类上调用 `javap` 工具来轻松地看到编译器生成的代码：
- en: '![Figure 4.1.png](img/B19665_04_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1.png](img/B19665_04_01.png)'
- en: 'Figure 4.1: The code of a Java record'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：Java 记录的代码
- en: Pay attention that these accessor’s names don’t follow the Java Bean convention,
    so there is no `getType()` or `getWeight()`. There is `type()` and `weight()`.
    However, you can explicitly write these accessors or explicitly add the `getType()`/`getWeight()`
    getters – for instance, for exposing defensive copies of fields.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些访问器的名称不遵循 Java Bean 规范，因此没有 `getType()` 或 `getWeight()`。有 `type()` 和 `weight()`。然而，你可以明确地编写这些访问器或明确添加
    `getType()`/`getWeight()` 获取器 - 例如，为了公开字段的防御性副本。
- en: All these things are built based on the parameters given when we declare a record
    (`type` and `weight`). These parameters are also known as the components of the
    record and we say that a record is built on the given components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在声明记录时给出的参数（`type` 和 `weight`）的基础上构建的。这些参数也被称为记录的组成部分，我们说记录是基于给定的组成部分构建的。
- en: The compiler recognizes a Java record via the `record` keyword. This is a special
    type of class (exactly like `enum` is a special type of Java class) declared as
    `final` and automatically extending `java.lang.Record`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过 `record` 关键字识别 Java 记录。这是一种特殊的类类型（就像 `enum` 是特殊的 Java 类类型一样），声明为 `final`
    并自动扩展 `java.lang.Record`。
- en: 'Instantiating `MelonRecord` is the same as instantiating the `Melon` class.
    The following code creates a `Melon` instance and a `MelonRecord` instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 `MelonRecord` 与实例化 `Melon` 类相同。以下代码创建了一个 `Melon` 实例和一个 `MelonRecord` 实例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Java records are not an alternative to mutable Java Bean classes. Moreover,
    you may think that a Java record is just a plain transparent approach for carrying
    immutable data or an immutable state (we say “transparent” because it fully exposes
    its state, and we say “immutable” because the class is `final`, it has only `private`
    `final` fields, and no setters). In this context, we may think that Java records
    are not quite useful because they just overlap the functionality that we can obtain
    via Lombok or Kotlin. But as you’ll see in this chapter, a Java record is more
    than that, and it provides several features that are not available in Lombok or
    Kotlin. Moreover, if you benchmark, you’ll notice that using records has significant
    advantages in the performance context.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Java 记录不是可变 Java Bean 类的替代品。此外，你可能认为 Java 记录只是携带不可变数据或不可变状态的简单透明方法（我们说“透明”，因为它完全暴露了其状态；我们说“不可变”，因为该类是
    `final` 的，它只有 `private` `final` 字段，没有设置器）。在这种情况下，我们可能会认为 Java 记录并不十分有用，因为它们只是重叠了我们通过
    Lombok 或 Kotlin 可以获得的功能。但是，正如你将在本章中看到的那样，Java 记录不仅仅是这样，它还提供了 Lombok 或 Kotlin 中不可用的几个功能。此外，如果你进行基准测试，你将注意到使用记录在性能方面具有显著优势。
- en: 89\. Introducing the canonical and compact constructors for records
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 89. 介绍记录的规范和紧凑构造函数
- en: 'In the previous problem, we created the `MelonRecord` Java record and we instantiated
    it via the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，我们创建了 `MelonRecord` Java 记录，并通过以下代码实例化了它：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How is this possible (since we didn’t write any parameterized constructor in
    `MelonRecord`)? The compiler just followed its internal protocol for Java records
    and created a default constructor based on the components that we provided in
    the record declaration (in this case, there are two components, `type` and `weight`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能（因为我们没有在 `MelonRecord` 中编写任何参数化构造函数）？编译器只是遵循其内部协议为 Java 记录创建了一个默认构造函数，基于我们在记录声明中提供的组件（在这种情况下，有两个组件，`type`
    和 `weight`）。
- en: This constructor is known as the *canonical constructor* and it is always aligned
    with the given components. Every record has a canonical constructor that represents
    the only way to create instances of that record.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数被称为 *规范构造函数*，它始终与给定的组件保持一致。每个记录都有一个规范构造函数，它代表了创建该记录实例的唯一方式。
- en: 'But, we can redefine the canonical constructor. Here is an explicit canonical
    constructor similar to the default one – as you can see, the canonical constructor
    simply takes all the given components and sets the corresponding instance fields
    (also generated by the compiler as `private` `final` fields):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以重新定义规范构造函数。以下是一个类似于默认的显式规范构造函数——如您所见，规范构造函数只是简单地接受所有给定的组件，并将相应的实例字段（也由编译器生成作为
    `private` `final` 字段）设置：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the instance is created, it cannot be changed (it is immutable). It will
    only serve the purpose of carrying this data around your program. This explicit
    canonical constructor has a shortcut known as the *compact constructor* – this
    is specific to Java records. Since the compiler knows the list of given components,
    it can accomplish its job from this compact constructor, which is equivalent to
    the previous one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例被创建，它就不能被更改（它是不可变的）。它将只用于在程序中携带这些数据。这个显式规范构造函数有一个称为 *紧凑构造函数* 的快捷方式——这是 Java
    记录特有的。由于编译器知道给定的组件列表，它可以从这个紧凑构造函数中完成其工作，这与前面的一个等价：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Pay attention to not confuse this compact constructor with the one without
    arguments. The following snippets are not equivalent:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要混淆这个紧凑构造函数与无参数的那个。以下片段并不等价：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, it doesn’t make sense to write an explicit canonical constructor
    just to mimic what the default one does. So, let’s examine several scenarios when
    redefining the canonical constructor makes sense.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅为了模仿默认构造函数的功能而编写显式规范构造函数是没有意义的。因此，让我们检查在重新定义规范构造函数时具有意义的几个场景。
- en: Handling validation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理验证
- en: 'At this moment, when we create a `MelonRecord`, we can pass the type as `null`,
    or the melon’s weight as a negative number. This leads to corrupted records containing
    non-valid data. Validating the record components can be handled in an explicit
    canonical constructor as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，当我们创建一个 `MelonRecord` 时，我们可以将类型传递为 `null`，或者将西瓜的重量作为一个负数。这会导致包含非有效数据的损坏记录。可以通过以下显式规范构造函数来处理记录组件的验证：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, via the compact constructor as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过以下紧凑构造函数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Validation handling is the most common use case for explicit canonical/compact
    constructors. Next, let’s see two more lesser-known use cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 验证处理是显式规范/紧凑构造函数最常见的使用场景。接下来，让我们看看两个更少为人知的用例。
- en: Reassigning components
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新分配组件
- en: 'Via an explicit canonical/compact constructor, we can reassign components.
    For instance, when we create a `MelonRecord`, we provide its type (for instance,
    Cantaloupe) and its weight in grams (for instance, 2600 grams). But, if we want
    to use weight in kilograms (2600 g = 2.6 kg), then we can provide this conversion
    in an explicit canonical constructor as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式规范/紧凑构造函数，我们可以重新分配组件。例如，当我们创建一个 `MelonRecord` 时，我们提供其类型（例如，哈密瓜）和其重量（以克为单位，例如，2600
    克）。但是，如果我们想使用千克（2600 g = 2.6 kg）作为重量，那么我们可以在显式规范构造函数中提供这种转换，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the `weight` component is available and reassigned before the
    `weight` field is initialized with the new reassigned value. In the end, the `weight`
    component and the `weight` field have the same value (2.6 kg). How about this
    snippet of code?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`weight` 组件在 `weight` 字段使用新的重新分配值初始化之前是可用的，并被重新分配。最终，`weight` 组件和 `weight`
    字段具有相同的值（2.6 kg）。那么这段代码片段呢？
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Well, in this case, in the end, the `weight` field and the `weight` component
    will have different values. The `weight` field is 2.6 kg, while the `weight` component
    is 2600 g. Pay attention that most probably this is not what you want. Let’s check
    another snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这种情况下，最终，`weight` 字段和 `weight` 组件将具有不同的值。`weight` 字段是 2.6 kg，而 `weight` 组件是
    2600 g。请注意，这很可能不是你想要的。让我们检查另一个片段：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, in the end, the `weight` field and the `weight` component will have different
    values. The `weight` field is 2600 g, while the `weight` component is 2.6 kg.
    And again, pay attention—most probably this is not what you want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，最终，`weight` 字段和 `weight` 组件将具有不同的值。`weight` 字段是 2600 g，而 `weight` 组件是 2.6
    kg。再次注意——这很可能不是你想要的。
- en: 'Of course, the cleanest and most simple approach relies on the compact constructor.
    This time, we cannot sneak in any accidental reassignments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最干净、最简单的方法依赖于紧凑构造函数。这次，我们无法偷偷进行任何意外的重新分配：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, let’s tackle the third scenario.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们解决第三个场景。
- en: Defensive copies of the given components
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给定组件的防御性副本
- en: We know that a Java record is immutable. But this doesn’t mean that its components
    are immutable as well. Think of components such as arrays, lists, maps, dates,
    and so on. All these components are mutable. In order to restore total immutability,
    you’ll prefer to work on copies of these components rather than modify the given
    components. And, as you may have already intuited, this can be done via the explicit
    canonical constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Java记录是不可变的。但这并不意味着其组件也是不可变的。想想数组、列表、映射、日期等组件。所有这些组件都是可变的。为了恢复完全不可变性，你将更愿意在这些组件的副本上工作而不是修改给定的组件。而且，正如你可能已经直觉到的，这可以通过显式的规范构造函数来完成。
- en: 'For instance, let’s consider the following record that gets a single component
    representing the retail prices for a set of items as a `Map`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下记录，它获取一个表示一组项目零售价格的单一组件作为`Map`：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This record shouldn’t modify this `Map`, so it relies on an explicit canonical
    constructor for creating a defensive copy that will be used in subsequent tasks
    without any risks of modification (`Map.copyOf()` returns an unmodifiable copy
    of the given `Map`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录不应该修改这个`Map`，因此它依赖于一个显式的规范构造函数来创建一个用于后续任务而没有任何修改风险的防御性副本（`Map.copyOf()`返回给定`Map`的不可修改副本）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Basically, this is just a flavor of component reassignment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这仅仅是一种组件重新分配的变体。
- en: 'Moreover, we can return defensive copies via the accessor methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过访问器方法返回防御性副本：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can practice all these examples in the bundled code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习所有这些示例。
- en: 90\. Adding more artifacts in a record
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 90. 在记录中添加更多工件
- en: 'So far, we know how to add an explicit canonical/compact constructor into a
    Java record. What else can we add? Well, for example, we can add instance methods
    as in any typical class. In the following code, we add an instance method that
    returns the `weight` converted from grams to kilograms:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何将显式的规范/紧凑构造函数添加到Java记录中。我们还能添加什么？例如，我们可以添加实例方法，就像在典型类中一样。在以下代码中，我们添加了一个返回从克转换为千克的`weight`的实例方法：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can call `weightToKg()` exactly as you call any other instance method of
    your classes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像调用你类中的任何其他实例方法一样调用`weightToKg()`：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Besides instance methods, we can add `static` fields and methods as well. Check
    out this code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法之外，我们还可以添加`static`字段和方法。查看以下代码：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Calling `getDefaultMelon()` is done as usual via class name:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类名调用`getDefaultMelon()`就像往常一样：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Adding nested classes is also possible. For example, here we add a `static`
    nested class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 添加嵌套类也是可能的。例如，这里我们添加一个`static`嵌套类：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And, calling `Slicer` can be done as usual:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，调用`Slicer`可以像往常一样进行：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But, even if it is allowed to add all these artifacts in a Java record, I strongly
    suggest you think twice before doing this. The main reason is that Java records
    should be about data and only data, so it is kind of weird to pollute a record
    with artifacts that involve additional behavior. If you hit such a scenario, then
    you probably need a Java class, not a Java record.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使允许在Java记录中添加所有这些工件，我强烈建议你在这样做之前三思。主要原因在于Java记录应该是关于数据，而且仅仅是数据，因此用涉及额外行为的工件污染记录有点奇怪。如果你遇到这样的场景，那么你可能需要一个Java类，而不是Java记录。
- en: In the next problem, we will see what we cannot add to a Java record.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将看到我们无法添加到Java记录中的内容。
- en: 91\. Iterating what we cannot have in a record
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 91. 在记录中迭代我们无法拥有的内容
- en: There are several artifacts that we cannot have in a Java record. Let’s tackle
    the top 5 one by one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java记录中，有一些我们不能拥有的工件。让我们逐一解决前5个。
- en: A record cannot extend another class
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录不能扩展另一个类
- en: 'Since a record already extends `java.lang.Record` and Java doesn’t support
    multiple inheritances, we cannot write a record that extends another class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录已经扩展了`java.lang.Record`，而Java不支持多重继承，因此我们不能编写扩展另一个类的记录：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This snippet doesn’t compile.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段无法编译。
- en: A record cannot be extended
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录不能被扩展
- en: 'Java records are `final` classes, so they cannot be extended:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录是`final`类，因此不能被扩展：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This snippet doesn’t compile.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段无法编译。
- en: A record cannot be enriched with instance fields
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录不能通过实例字段进行扩展
- en: 'When we declare a record, we also provide the components that become the instance
    fields of the record. Later, we cannot add more instance fields as we could in
    a typical class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个记录时，我们也提供了将成为记录实例字段的组件。之后，我们不能再像典型类那样添加更多实例字段：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding `color` as a `final` or non-`final` separate field doesn’t compile.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将`color`作为`final`或非`final`的独立字段添加是不编译的。
- en: A record cannot have private canonical constructors
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录不能有私有规范构造函数
- en: 'Sometimes we create classes with `private` constructors that expose `static`
    factories for creating instances. Basically, we call the constructor indirectly
    via a `static` factory method. This practice is not available in a Java record
    because `private` canonical/compact constructors are not allowed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们创建具有`private`构造函数的类，该构造函数公开`static`工厂以创建实例。基本上，我们通过`static`工厂方法间接调用构造函数。这种做法在Java记录中不可用，因为不允许`private`规范/紧凑构造函数：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A record cannot have setters
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录不能有setter
- en: 'As you saw, a Java record exposes a getter (accessor method) for each of its
    components. These getters have the same names as components (for `type` we have
    `type()`, not `getType()`). On the other hand, we cannot have setters since the
    fields corresponding to the given components are `final`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Java记录为每个组件提供了一个getter（访问器方法）。这些getter的名称与组件相同（对于`type`我们有`type()`，而不是`getType()`）。另一方面，我们不能有setter，因为对应给定组件的字段是`final`：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 92\. Defining multiple constructors in a record
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 92. 在记录中定义多个构造函数
- en: As you know, when we declare a Java record, the compiler uses the given components
    to create a default constructor known as the canonical constructor. We can also
    provide an explicit canonical/compact constructor, as you saw in *Problem 89*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当我们声明Java记录时，编译器使用给定的组件创建一个默认构造函数，称为规范构造函数。我们还可以提供显式的规范/紧凑构造函数，如你在*问题89*中看到的。
- en: 'But, we can go even further and declare more constructors with a different
    list of arguments. For example, we can have a constructor with no arguments for
    returning a default instance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以更进一步，并声明具有不同参数列表的更多构造函数。例如，我们可以有一个不带参数的构造函数来返回默认实例：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, we can write a constructor that gets only the melon’s type or the melon’s
    weight as an argument:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以编写一个只接受瓜的类型或重量作为参数的构造函数：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Moreover, we can add arguments that don’t fit any component (here, `country`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以添加不适合任何组件的参数（这里，`country`）：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What do all these constructors have in common? They all call the canonical constructor
    via the `this` keyword. Remember that the only way to instantiate a Java record
    is via its canonical constructor, which can be called directly or, as you saw
    in the previous examples, indirectly. So, keep in mind that all explicit constructors
    that you add to a Java record must first call the canonical constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些构造函数有什么共同点？它们都通过`this`关键字调用规范构造函数。记住，实例化Java记录的唯一方法是通过其规范构造函数，可以直接调用，或者，如你之前所见的，间接调用。所以，请记住，你添加到Java记录的所有显式构造函数都必须首先调用规范构造函数。
- en: 93\. Implementing interfaces in records
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 93. 在记录中实现接口
- en: 'Java records cannot extend another class but they can implement any interface
    exactly like a typical class. Let’s consider the following interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录不能扩展另一个类，但它们可以像典型类一样实现任何接口。让我们考虑以下接口：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following snippet of code is a straightforward usage of this interface:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是此接口的直接使用：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the code overrides the `abstract` method `exterminatePest()` and
    calls the `default` method `detectPest()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码覆盖了`abstract`方法`exterminatePest()`并调用了`default`方法`detectPest()`。
- en: 94\. Understanding record serialization
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 94. 理解记录序列化
- en: In order to understand how Java records are serialized/deserialized, let’s have
    a parallel between classical code based on plain Java classes and the same code
    but expressed via the Java record’s syntactical sugar.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Java记录的序列化/反序列化，让我们将基于普通Java类的经典代码与通过Java记录的语法糖表达的相同代码进行比较。
- en: 'So, let’s consider the following two plain Java classes (we have to explicitly
    implement the `Serializable` interface because, in the second part of this problem,
    we want to serialize/deserialize these classes):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑以下两个普通的Java类（我们必须显式实现`Serializable`接口，因为在问题的第二部分，我们想要序列化/反序列化这些类）：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, the `MelonContainer` class that uses the previous `Melon` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用之前`Melon`类的`MelonContainer`类：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we express this code via Java records, then we have the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过Java记录表达此代码，那么我们就有以下代码：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we have explicitly implemented the `Serializable` interface since,
    by default, Java records are not serializable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们明确实现了 `Serializable` 接口，因为默认情况下，Java 记录不可序列化。
- en: 'Next, let’s create a `MelonContainer` instance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个 `MelonContainer` 实例：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And, a `MelonContainerRecord` instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个 `MelonContainerRecord` 实例：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To serialize these objects (`gacContainer` and `gacContainerR`), we can use
    the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化这些对象（`gacContainer` 和 `gacContainerR`），我们可以使用以下代码：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And, the deserialization can be accomplished via the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，反序列化可以通过以下代码完成：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before exploiting these snippets of code for a practical examination of serialization/deserialization,
    let’s try a theoretical approach meant to provide some hints for these operations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际检查序列化/反序列化之前，让我们尝试一种理论方法，旨在为这些操作提供一些提示。
- en: How serialization/deserialization works
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化/反序列化是如何工作的
- en: 'The serialization/deserialization operations are represented in the following
    diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化/反序列化操作在以下图中表示：
- en: '![Figure 4.2.png](img/B19665_04_02.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2.png](img/B19665_04_02.png)'
- en: 'Figure 4.2: Java serialization/deserialization operations'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Java 序列化/反序列化操作
- en: In a nutshell, *serialization* (or serializing an object) is the operation of
    extracting the state of an object as a byte stream and representing it as a persistent
    format (a file, a database, in memory, over the network, and so on). The reverse
    operation is called *deserialization* (or deserializing an object) and represents
    the steps of reconstructing the object state from the persistent format.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*序列化*（或序列化一个对象）是将对象的状态提取为字节流，并以持久格式（文件、数据库、内存、网络等）表示的操作。相反的操作称为 *反序列化*（或反序列化一个对象），它表示从持久格式中重建对象状态的过程。
- en: In Java, an object is serializable if it implements the `Serializable` interface.
    This is an empty interface with no state or behavior that acts as a marker for
    the compiler. In the absence of this interface, the compiler assumes that the
    object is not serializable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，如果一个对象实现了 `Serializable` 接口，则该对象是可序列化的。这是一个没有状态或行为的空接口，它作为编译器的标记。如果没有这个接口，编译器会假设该对象不可序列化。
- en: 'The compiler uses its internal algorithm for the serialization of objects.
    This algorithm relies on every trick in the book, like special privileges (ignoring
    accessibility rules) to access objects, malicious reflection, constructors bypassing,
    and so on. It is beyond our purpose to bring light to this dark magic, so as a
    developer, it is enough to know that:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用其内部算法来序列化对象。这个算法依赖于书中所有的技巧，比如特殊的权限（忽略可访问性规则）来访问对象，恶意反射，构造函数绕过等等。揭示这种黑暗魔法的细节超出了我们的目的，因此作为一个开发者，知道以下内容就足够了：
- en: If a part of an object is not serializable then you’ll get a runtime error
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象的一部分不可序列化，那么你将得到一个运行时错误
- en: You can alter the serialization/ deserialization operations via the `writeObject()`/`readObject()`
    API
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过 `writeObject()`/`readObject()` API 来修改序列化/反序列化操作
- en: Ok, now let’s see what’s going on when an object is serialized.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们看看当一个对象被序列化时发生了什么。
- en: Serializing/deserializing gacContainer (a typical Java class)
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化/反序列化 gacContainer（一个典型的 Java 类）
- en: 'The `gacContainer` object is an instance of `MelonContainer`, which is a plain
    Java class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`gacContainer` 对象是 `MelonContainer` 的一个实例，它是一个普通的 Java 类：'
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After serializing it in a file called *object.data*, we obtain the byte stream
    representing the `gacContainer` state. While you can inspect this file in the
    bundled code (use a hex editor such as [https://hexed.it/](https://hexed.it/)),
    here is a human-readable interpretation of its content:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 *object.data* 的文件中序列化后，我们得到了表示 `gacContainer` 状态的字节流。虽然你可以在捆绑的代码中检查此文件（使用十六进制编辑器，如
    [https://hexed.it/](https://hexed.it/)），但以下是其内容的可读性解释：
- en: '![Figure 4.3.png](img/B19665_04_03.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3.png](img/B19665_04_03.png)'
- en: 'Figure 4.3: Human-readable interpretation of gacContainer serialization'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：gacContainer 序列化的可读性解释
- en: The deserialization operation takes place by building the object graph from
    the top down. When the class name is known, the compiler creates an object by
    calling the non-arguments constructor of the first superclass of `MelonContainer`
    that is non-serializable. In this case, that is the non-argument constructor of
    `java.lang.Object`. So, the compiler is not calling the constructor of `MelonContainer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化操作是通过从上到下构建对象图来进行的。当类名已知时，编译器通过调用 `MelonContainer` 的第一个非序列化超类的无参构造函数来创建一个对象。在这种情况下，这是
    `java.lang.Object` 的无参构造函数。因此，编译器并没有调用 `MelonContainer` 的构造函数。
- en: 'Next, the fields are created and set to the default values, so the created
    object has `expiration`, `batch`, and `melon` as `null`. Of course, this is not
    the correct state of our object, so we continue processing the serialization stream
    to extract and populate the fields with the correct values. This can be seen in
    the following diagram (on the left side, the created object has default values;
    on the right side, the fields have been populated with the correct state):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，字段被创建并设置为默认值，因此创建的对象的 `expiration`、`batch` 和 `melon` 都是 `null`。当然，这不是我们对象的正确状态，所以我们继续处理序列化流以提取和填充字段为正确的值。这可以在以下图中看到（左侧，创建的对象具有默认值；右侧，字段已填充为正确的状态）：
- en: '![Figure 4.4.png](img/B19665_04_04.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4.png](img/B19665_04_04.png)'
- en: 'Figure 4.4: Populating the created object with the correct state'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：用正确状态填充创建的对象
- en: When the compiler hits the `melon` field, it must perform the same steps to
    obtain the `Melon` instance. It sets the fields (`type` and `weight` to `null`,
    respectively, `0.0f`). Further, it reads the real values from the stream and sets
    the correct state for the `melon` object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到 `melon` 字段时，它必须执行相同的步骤以获取 `Melon` 实例。它设置字段（`type` 和 `weight` 分别设置为 `null`，`0.0f`）。进一步地，它从流中读取真实值并设置
    `melon` 对象的正确状态。
- en: 'Finally, after the entire stream is read, the compiler will link the objects
    accordingly. This is shown in the following figure (1, 2, and 3 represent the
    steps of the deserialization operation):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在读取整个流之后，编译器将相应地链接对象。这如图所示（1、2 和 3 代表反序列化操作的步骤）：
- en: '![Figure 4.5.png](img/B19665_04_05.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5.png](img/B19665_04_05.png)'
- en: 'Figure 4.5: Linking the objects to obtain the final state'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：将对象链接以获得最终状态
- en: At this point, the deserialization operation has been done and we can use the
    resulting object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，反序列化操作已经完成，我们可以使用生成的对象。
- en: Deserializing a malicious stream
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反序列化恶意流
- en: 'Providing a malicious stream means altering the object state before deserialization.
    This can be done in many ways. For instance, we can manually modify the *object.data*
    instance in an editor (this is like an untrusted source) as in the following figure
    where we replaced the valid batch `ML9000SQA0` with the invalid batch `0000000000`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个恶意流意味着在反序列化之前改变对象状态。这可以通过许多方式完成。例如，我们可以在编辑器中手动修改 *object.data* 实例（这就像一个不受信任的来源），如下图中我们将有效的批次
    `ML9000SQA0` 替换为无效的批次 `0000000000`：
- en: '![Figure 4.6.png](img/B19665_04_06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6.png](img/B19665_04_06.png)'
- en: 'Figure 4.6: Modify the original stream to obtain a malicious stream'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：修改原始流以获得恶意流
- en: 'If we deserialize the malicious stream (in the bundle code, you can find it
    as the `object_malicious.data` file) then you can see that the corrupted data
    has “successfully” landed in our object (a simple call of `toString()` reveals
    that batch is `0000000000`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反序列化恶意流（在捆绑代码中，你可以找到它作为 `object_malicious.data` 文件），那么你可以看到损坏的数据“成功”地进入了我们的对象（简单的
    `toString()` 调用揭示了批次是 `0000000000`）：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The guarding conditions from `Melon`/`MelonContainer` constructors are useless
    since the deserialization doesn’t call these constructors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `Melon`/`MelonContainer` 构造函数的防护条件是无用的，因为反序列化没有调用这些构造函数。
- en: So, if we summarize the shortcomings of serializing/deserializing a Java class,
    we must highlight the presence of the window of time that occurs when the objects
    are in an improper state (waiting for the compiler to populate fields with the
    correct data and to link them in the final graph) and the risk of dealing with
    malicious states. Now, let’s pass a Java record through this process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们总结序列化/反序列化 Java 类的缺点，我们必须强调在对象处于不正确状态（等待编译器用正确数据填充字段并将它们链接到最终图中）时出现的时间窗口，以及处理恶意状态的风险。现在，让我们将一个
    Java 记录通过这个过程。
- en: Serializing/deserializing gacContainerR (a Java record)
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化/反序列化 gacContainerR（一个 Java 记录）
- en: In a nutshell, the minimalist design of declaring Java records and their semantic
    constraints allows the serialization/deserialization operations to act differently
    from a typical Java class. And when I say “differently,” I should actually say
    much better and more robust. How so? Well, the serialization of a Java record
    is based only on its component’s state, while deserialization relies on the single
    point of entry for a Java record, its canonical constructor. Remember that the
    only way to create a Java record is to directly/indirectly call its canonical
    constructor? This applies to deserialization as well, so this operation can no
    longer bypass the canonical constructor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，声明Java记录及其语义约束的最简设计使得序列化/反序列化操作与典型的Java类有所不同。当我说是“不同”的时候，我实际上应该说它更好、更健壮。为什么会这样呢？好吧，Java记录的序列化仅基于其组件的状态，而反序列化则依赖于Java记录的单一点——它的规范构造函数。记住，创建Java记录的唯一方法就是直接/间接调用其规范构造函数？这同样适用于反序列化，因此这个操作不能再绕过规范构造函数。
- en: 'That being said, the `gacContainerR` object is a `MelonContainerRecord` instance:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`gacContainerR`对象是一个`MelonContainerRecord`实例：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After serializing it in a file called `object_record.data`, we obtain the byte
    stream representing the `gacContainerR` state. While you can inspect this file
    in the bundled code (use a hex editor such as [https://hexed.it/](https://hexed.it/)),
    here is a human-readable interpretation of its content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`object_record.data`的文件中序列化后，我们获得了表示`gacContainerR`状态的字节流。虽然您可以在捆绑的代码中检查此文件（使用十六进制编辑器，如[https://hexed.it/](https://hexed.it/)），但以下是其内容的可读解释：
- en: '![Figure 4.7.png](img/B19665_04_07.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.7.png](img/B19665_04_07.png)'
- en: 'Figure 4.7: Human-readable interpretation of MelonContainerRecord serialization'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：MelonContainerRecord序列化的人读解释
- en: Yes, you’re right—with the exception of the class name (`MelonContainerRecord`),
    the rest is the same as in *Figure 4.3*. This sustains the migration from ordinary/regular
    Java classes to Java records. This time, the compiler can use the accessors exposed
    by the record, so no dark magic is needed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您说得对——除了类名（`MelonContainerRecord`）之外，其余的与*图4.3*中的相同。这保持了从普通/常规Java类到Java记录的迁移。这次，编译器可以使用记录公开的访问器，因此不需要使用任何暗黑魔法。
- en: Ok, so nothing got our attention here, so let’s examine the deserialization
    operation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里没有什么引起我们的注意，那么让我们来检查反序列化操作。
- en: Remember that for regular Java classes, the deserialization builds the object
    graph from the top down. In the case of Java records, this operation takes place
    from the bottom up, so in reverse order. In other words, this time, the compiler
    reads first the fields (primitives and reconstructed objects) from the stream
    and stores them in memory. Next, having all the fields in its hands, the compiler
    tries to match these fields (their names and values) against the components of
    the record. Any field from the stream that doesn’t match a component (name and
    value) is dropped from the deserialization operation. Finally, after the match
    is successfully performed, the compiler calls the canonical constructor to reconstruct
    the record object state.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于常规Java类，反序列化是从上到下构建对象图。在Java记录的情况下，这个操作是从下到上进行的，所以是反向的。换句话说，这次，编译器首先从流中读取字段（原始类型和重建的对象），并将它们存储在内存中。接下来，拥有所有字段后，编译器尝试将这些字段（它们的名称和值）与记录的组件进行匹配。任何与组件（名称和值）不匹配的字段都会从反序列化操作中丢弃。最后，匹配成功后，编译器调用规范构造函数来重建记录对象的状态。
- en: Deserializing a malicious stream
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反序列化恶意流
- en: 'In the bundled code, you can find a file named `object_record_malicious.data`
    where we replaced the valid batch `ML9000SQA0` with the invalid batch `0000000000`.
    This time, deserializing this malicious stream will result in the exception from
    the following figure:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您可以找到一个名为`object_record_malicious.data`的文件，我们在其中将有效的批次`ML9000SQA0`替换为无效的批次`0000000000`。这次，反序列化这个恶意流将导致以下图中的异常：
- en: '![Figure 4.9.png](img/B19665_04_08.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.9.png](img/B19665_04_08.png)'
- en: 'Figure 4.8: Deserializing a malicious stream causing an exception'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：反序列化恶意流导致异常
- en: As you already know, this exception originates in our guarding condition added
    in the explicit canonical constructor of our Java record.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，这个异常起源于我们添加到Java记录显式规范构造函数中的保护条件。
- en: It is obvious that Java records significantly improve serialization/deserialization
    operations. This time, there is no moment when the reconstructed objects are in
    a corrupted state, and the malicious streams can be intercepted by guarding conditions
    placed in the canonical/compact constructor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Java 记录显著提高了序列化和反序列化操作。这次，重建的对象不再处于损坏状态，恶意流可以被放置在规范/紧凑构造函数中的保护条件拦截。
- en: In other words, the record’s semantic constraints, their minimalist design,
    the state accessible only via the accessor methods, and the object creation only
    via the canonical constructors sustain the serialization/deserialization as a
    trusted process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，记录的语义约束、它们的简约设计、只能通过访问器方法访问的状态，以及只能通过规范构造函数创建的对象，都使得序列化和反序列化成为一个可信的过程。
- en: Refactoring legacy serialization
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构遗留序列化
- en: Serialization/deserialization via Java records is awesome, but what can we do
    in the case of legacy code, such as `MelonContainer`? We cannot take all our legacy
    classes that act as carriers of data and rewrite them as Java records. It will
    consume a lot of work and time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Java 记录进行序列化和反序列化非常棒，但在遗留代码的情况下，例如 `MelonContainer`，我们能做什么呢？我们不能将所有作为数据载体的遗留类重写为
    Java 记录，这将消耗大量的工作和时间。
- en: Actually, there is a solution backed in the serialization mechanism that requires
    us to add two methods named `writeReplace()` and `readResolve()`. By following
    this reasonable refactoring step, we can serialize legacy code as records and
    deserialize it back into legacy code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一个基于序列化机制的解决方案，它要求我们添加两个名为 `writeReplace()` 和 `readResolve()` 的方法。通过遵循这个合理的重构步骤，我们可以将遗留代码序列化为记录，并将其反序列化回遗留代码。
- en: 'If we apply this refactoring step to `MelonContainer`, then we start by adding
    the `writeReplace()` method in this class as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个重构步骤应用到 `MelonContainer` 上，那么我们首先在这个类中添加 `writeReplace()` 方法，如下所示：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `writeReplace()` method must throw an `ObjectStreamException` and return
    an instance of `MelonContainerRecord`. The compiler will use this method for serializing
    `MelonContainer` instances as long as we mark it with the `@Serial` annotation.
    Now, the serialization of a `MelonContainer` instance will produce the *object.data*
    file containing the byte stream corresponding to a `MelonContainerRecord` instance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeReplace()` 方法必须抛出 `ObjectStreamException` 并返回一个 `MelonContainerRecord`
    实例。只要我们用 `@Serial` 注解标记它，编译器就会使用这个方法来序列化 `MelonContainer` 实例。现在，`MelonContainer`
    实例的序列化将生成包含对应于 `MelonContainerRecord` 实例的字节流的 *object.data* 文件。'
- en: 'Next, the `readResolve()` method must be added to the `MelonContainerRecord`
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须将 `readResolve()` 方法添加到 `MelonContainerRecord` 中，如下所示：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `readResolve()` method must throw an `ObjectStreamException` and return
    an instance of `MelonContainer`. Again, the compiler will use this method for
    deserializing `MelonContainerRecord` instances as long as we mark it with the
    `@Serial` annotation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`readResolve()` 方法必须抛出 `ObjectStreamException` 并返回一个 `MelonContainer` 实例。同样，只要我们用
    `@Serial` 注解标记它，编译器就会使用这个方法来反序列化 `MelonContainerRecord` 实例。'
- en: When the compiler deserializes an instance of `MelonContainerRecord`, it will
    call the canonical constructor of this record, so it will pass through our guarding
    conditions. This means that a malicious stream will not pass the guarding conditions,
    so we avoid creating corrupted objects. If the stream contains valid values, then
    the `readResolve()` method will use them to reconstruct the legacy `MelonContainer`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器反序列化 `MelonContainerRecord` 的一个实例时，它将调用这个记录的规范构造函数，因此它将通过我们的保护条件。这意味着恶意流将不会通过保护条件，因此我们避免了创建损坏的对象。如果流包含有效值，那么
    `readResolve()` 方法将使用它们来重建遗留的 `MelonContainer`。
- en: Hey, Kotlin/Lombok, can you do this? No, you can’t!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，Kotlin/Lombok，你能做到这一点吗？不，你不能！
- en: In the bundled code, you can find a file named `object_malicious.data` that
    you can use to practice the previous statement.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到一个名为 `object_malicious.data` 的文件，你可以用它来练习前面的说法。
- en: 95\. Invoking the canonical constructor via reflection
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 95. 通过反射调用规范构造函数
- en: It is not a daily task to invoke the canonical constructor of a Java record
    via reflection. However, this can be accomplished quite easily starting with JDK
    16, which provides in `java.lang.Class` the `RecordComponent[] getRecordComponents()`
    method. As its name and signature suggest, this method returns an array of `java.lang.reflect.RecordComponent`
    representing the components of the current Java record.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射调用 Java 记录的规范构造器并不是一项日常任务。然而，从 JDK 16 开始，这可以相当容易地完成，因为 `java.lang.Class`
    提供了 `RecordComponent[] getRecordComponents()` 方法。正如其名称和签名所暗示的，此方法返回一个 `java.lang.reflect.RecordComponent`
    数组，代表当前 Java 记录的组件。
- en: Having this array of components, we can call the well-known `getDeclaredConstructor()`
    method to identify the constructor that gets as arguments exactly this array of
    components. And that is the canonical constructor.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个组件数组后，我们可以调用众所周知的 `getDeclaredConstructor()` 方法来识别接受这个组件数组作为参数的构造器。这就是规范构造器。
- en: 'The code that puts these statements into practice is provided by the Java documentation
    itself, so there is no need to reinvent it. Here it is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些语句付诸实践的代码由 Java 文档本身提供，因此没有必要重新发明它。下面是它：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Consider the following records:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下记录：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finding and calling the canonical constructors for these records via the previous
    solution can be done as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前一种解决方案找到并调用这些记录的规范构造器可以这样做：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you need deep coverage of Java reflection principles, then consider *Java
    Coding Problems*, *First Edition*, *Chapter 7*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要深入了解 Java 反射原理，那么请考虑 *Java 编程问题*，*第一版*，*第七章*。
- en: 96\. Using records in streams
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 96. 在流中使用记录
- en: 'Consider the `MelonRecord` that we have used before:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前使用过的 `MelonRecord`：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And a list of melons as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个西瓜列表：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our goal is to iterate this list of melons and extract the total weight and
    the list of weights. This data can be carried by a regular Java class or by another
    record as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是迭代这个西瓜列表，并提取总重量和重量列表。这些数据可以由一个常规的 Java 类或另一个记录携带，如下所示：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Populating this record with data can be done in several ways, but if we prefer
    the Stream API then most probably we will go for the `Collectors.teeing()` collector.
    We won’t go into too much detail here, but we’ll quickly show that it is useful
    for merging the results of two downstream collectors. (If you’re interested, you
    can find more details about this particular collector in *Java Coding Problems,
    First Edition, Chapter 9, Problem 192*.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下几种方式之一填充此记录的数据，但如果我们更喜欢 Stream API，那么我们很可能会选择 `Collectors.teeing()` 收集器。这里我们不会过多地深入细节，但我们会快速展示它对于合并两个下游收集器的结果是有用的。（如果您感兴趣，可以在
    *Java 编程问题，第一版，第九章，问题 192* 中找到更多关于这个特定收集器的详细信息。）
- en: 'Let’s see the code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have the `summingDouble()` collector, which computes the total weight,
    and the `mapping()` collector, which maps the weights in a list. The results of
    these two downstream collectors are merged in `WeightsAndTotalRecord`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有 `summingDouble()` 收集器，它计算总重量，以及 `mapping()` 收集器，它将列表中的重量进行映射。这两个下游收集器的结果合并到
    `WeightsAndTotalRecord` 中。
- en: 'As you can see, the Stream API and records represent a very nice combo. Let’s
    have another example starting from this functional code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Stream API 和记录代表了一个非常好的组合。让我们从以下功能代码开始另一个例子：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code starts from a list of elevations given in centimeters (based on sea
    level being 0). First, we want to keep only the positive elevations (so, we apply
    `filter()`). Next, these will be converted to inches (via `map()`) and counted
    (via the `groupingBy()` and `counting()` collectors).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从以厘米（以海平面为 0）给出的海拔列表开始。首先，我们只想保留正海拔（因此，我们应用 `filter()`）。接下来，这些将转换为英寸（通过
    `map()`），并通过 `groupingBy()` 和 `counting()` 收集器进行计数。
- en: The resulting data is carried by `Map<Double, Long>`, which is not very expressive.
    If we pull this map out of the context (for instance, we pass it as an argument
    into a method), it is hard to say what `Double` and `Long` represent. It would
    be more expressive to have something such as `Map<Elevation, ElevationCount>`,
    which clearly describes its content.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据由 `Map<Double, Long>` 携带，这并不是非常具有表达性。如果我们把这个映射从上下文中提取出来（例如，将其作为参数传递给一个方法），就很难说
    `Double` 和 `Long` 代表什么。有一个像 `Map<Elevation, ElevationCount>` 这样的东西会更有表达性，它清楚地描述了其内容。
- en: 'So, `Elevation` and `ElevationCount` can be two records as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Elevation` 和 `ElevationCount` 可以是以下两个记录：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To simplify the functional code a little bit, we also moved to convert from
    centimeters to inches in the `Elevation` record, inside its explicit canonical
    constructor. This time, the functional code can be rewritten as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微简化功能代码，我们还将在`Elevation`记录的显式规范构造函数中将厘米转换为英寸。这次，功能代码可以重写如下：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, passing `Map<Elevation, ElevationCount>` to a method dispels any doubt
    about its content. Any team member can inspect these records in the blink of an
    eye without losing time reading our functional implementation in order to deduce
    what `Double` and `Long` represent. We can be even more expressive and rename
    the `Elevation` record as `PositiveElevation`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`Map<Elevation, ElevationCount>`传递给一个方法消除了对其内容的任何疑问。任何团队成员都可以在眨眼间检查这些记录，而无需浪费时间阅读我们的功能实现来推断`Double`和`Long`代表什么。我们可以更加明确地将`Elevation`记录重命名为`PositiveElevation`。
- en: 97\. Introducing record patterns for instanceof
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 97. 引入记录模式用于 instanceof
- en: 'In order to introduce *record patterns*, we need a more complex record than
    the one we’ve used so far, so here’s one:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入*记录模式*，我们需要一个比迄今为止使用的更复杂的记录，所以这里有一个例子：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This record implements the `Staff` interface as any other employee of our hospital.
    Now, we can identify a certain doctor in the old-fashioned style via `instanceof`
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录实现了`Staff`接口，就像我们医院的其他任何员工一样。现在，我们可以通过`instanceof`以传统方式识别某个医生，如下所示：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But, as we know from *Chapter* 2, *Problems* *58-67*, JDK has introduced *type
    patterns* that can be used for `instanceof` and `switch`. So, in this particular
    case, we can rewrite the previous code via type patterns as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们从*第2章*，*问题* *58-67* 中所知，JDK 引入了可用于`instanceof`和`switch`的*类型模式*。因此，在这种情况下，我们可以通过类型模式重写之前的代码，如下所示：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Nothing is new so far! The binding variable `dr` can be used to call the record
    accessor’s `specialty()` and `name()`, to add checks, computations, and so on.
    But, the compiler knows very well that the `Doctor` record was built based on
    two components (`name` and `specialty`) so the compiler should be able to deconstruct
    this object and give us these components directly as binding variables instead
    of accessing them via `dr`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新东西！绑定变量`dr`可以用来调用记录访问器的`specialty()`和`name()`，添加检查、计算等等。但是，编译器非常清楚`Doctor`记录是基于两个组件（`name`和`specialty`）构建的，因此编译器应该能够解构此对象，并直接将这些组件作为绑定变量提供给我们，而不是通过`dr`来访问它们。
- en: This is exactly what *record pattern matching* is all about. Record pattern
    matching appeared as a preview feature in JDK 19 (JEP 405), as a second preview
    feature in JDK 20 (JEP 432), and as a final release in JDK 21 (JEP 440).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是*记录模式匹配*的全部内容。记录模式匹配作为预览功能首次出现在 JDK 19（JEP 405）中，作为第二个预览功能出现在 JDK 20（JEP
    432）中，并在 JDK 21（JEP 440）中作为最终版本发布。
- en: 'Record pattern matching is exactly the syntax of declaring `name` and `specialty`
    as binding variables by following the same declaration syntax as in the record
    itself (or like in the canonical constructor). Here is the previous code written
    via record patterns:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 记录模式匹配正是通过遵循记录本身的相同声明语法（或类似于规范构造函数）来声明`name`和`specialty`作为绑定变量的语法。以下是使用记录模式编写的先前代码：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Very simple, isn’t it?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，不是吗？
- en: Now, `name` and `specialty` are the binding variables that can be used directly.
    We simply put this syntax in place of the type pattern. In other words, we replaced
    the type pattern with a record pattern.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`name`和`specialty`是可以直接使用的绑定变量。我们只需将此语法放在类型模式的位置。换句话说，我们用记录模式替换了类型模式。
- en: '**Important note**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The compiler exposes the record’s components via the corresponding binding variables.
    This is accomplished by deconstructing records in pattern matching, which is referred
    to as *record patterns*. In other words, the deconstruction patterns allow us
    to access the components of an object in a very handy, intuitive, and readable
    way.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过相应的绑定变量公开记录的组件。这是通过模式匹配中的记录解构来实现的，这被称为*记录模式*。换句话说，解构模式允许我们以非常方便、直观和可读的方式访问对象的组件。
- en: In record patterns, it is the compiler’s responsibility to initialize binding
    variables such as `name` and `specialty`. In order to accomplish this, the compiler
    calls the accessors of the corresponding components. This means that if you have
    some extra code in these accessors (for example, return defensive copies, perform
    validations or apply constraints, and so on), then this code is properly executed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录模式中，初始化绑定变量（如`name`和`specialty`）是编译器的责任。为了完成这个任务，编译器会调用相应组件的访问器。这意味着，如果您在这些访问器中有额外的代码（例如，返回防御性副本，执行验证或应用约束等），那么这些代码将被正确执行。
- en: Let’s go further and work with some nested records.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，处理一些嵌套记录。
- en: Nested records and record patterns
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套记录和记录模式
- en: 'Let’s assume that besides the `Doctor` record, we also have the following record:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设除了`Doctor`记录之外，我们还有以下记录：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Each resident has a coordinator, which is a doctor, so a `Resident` nests a
    `Doctor`. This time, we have to nest the record patterns accordingly as in the
    following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个居民都有一个协调员，即医生，所以`Resident`嵌套了`Doctor`。这次，我们必须相应地嵌套记录模式，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Both the resident and the doctor, have a `name` component. But we cannot use
    the binding variable `name` twice in this context since it will cause a conflict.
    This is why we have `rsname` and `drname`. Notice that the names of the binding
    variables don’t have to mirror the names of the components. This is possible because
    the compiler identifies components by position not by their names. But, of course,
    when it is possible, mirroring the name reduces the confusion and keeps the readability
    of the code high.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 居住者和医生都有一个`name`组件。但由于在这个上下文中不能重复使用绑定变量`name`，因为这会导致冲突，所以我们有`rsname`和`drname`。请注意，绑定变量的名称不必与组件的名称相匹配。这是因为编译器通过位置而不是名称来识别组件。但是，当然，当可能的时候，与名称相匹配可以减少混淆并保持代码的可读性高。
- en: 'If there is no need to deconstruct the `Doctor` record, then we can write it
    like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要解构`Doctor`记录，那么我们可以这样写：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Adding more nested records follows the same principle. For instance, let’s
    add the `Patient` and `Appointment` records as well:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多嵌套记录遵循相同的原理。例如，让我们添加`Patient`和`Appointment`记录：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we can write the following beauty:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以写出以下美妙的代码：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Or, if we don’t want to deconstruct `Appointment` and use `var`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们不想解构`Appointment`并使用`var`：
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that, this time, we have used `var` instead of explicit types. Feel free
    to do the same since `var` fits very well in this case. If you are not familiar
    with type inference, then consider *Java Coding Problems*, *First Edition*, *Chapter
    4*, which contains detailed explanations and best practices. More details about
    argument type inference in record patterns are available later in this chapter
    in *Problem 100*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们使用了`var`而不是显式类型。由于`var`在这个情况下非常适合，所以您可以自由地这样做。如果您不熟悉类型推断，那么可以考虑阅读*《Java
    编程问题》*，*第一版*，*第四章*，其中包含详细的解释和最佳实践。关于记录模式中参数类型推断的更多细节将在本章后面的*问题 100*中提供。
- en: I think you got the idea!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了这个想法！
- en: 98\. Introducing record patterns for switch
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 98. 为`switch`引入记录模式
- en: 'You already know that type patterns can be used for `instanceof` and `switch`
    expressions. This statement is true for record patterns as well. For instance,
    let’s reiterate the `Doctor` and `Resident` records:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道类型模式可以用于`instanceof`和`switch`表达式。这个说法对记录模式同样适用。例如，让我们再次回顾`Doctor`和`Resident`记录：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can easily use these two records via record patterns in a `switch` expression
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过记录模式在`switch`表达式中轻松使用这两个记录，如下所示：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Adding more nested records follows the same principle. For instance, let’s
    add the `Patient` and `Appointment` records as well:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多嵌套记录遵循相同的原理。例如，让我们添加`Patient`和`Appointment`记录：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can write the following beauty:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以写出以下美妙的代码：
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Or, without deconstructing `Appointment` and using `var`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，不解构`Appointment`并使用`var`：
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that the topics covered in *Chapter 2*, such as dominance, completeness,
    and unconditional patterns, remain valid for record patterns with `switch` as
    well. Actually, there are some important things to highlight about unconditional
    patterns, but that is covered later, in *Problem 101*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*第二章*中涵盖的主题，如支配性、完整性和无条件模式，对于具有`switch`的记录模式同样有效。实际上，还有一些关于无条件模式的重要事项需要强调，但那将在*问题
    101*中介绍。
- en: 99\. Tackling guarded record patterns
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 99. 解决受保护记录模式
- en: 'Exactly as in the case of type patterns, we can add guarding conditions based
    on the binding variables. For instance, the following code uses guarding conditions
    with `instanceof` for determining if the Allergy cabinet is open or closed (you
    should be familiar with the `Doctor` record from the previous two problems):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如类型模式的情况一样，我们可以根据绑定变量添加保护条件。例如，以下代码使用`instanceof`和保护条件来确定过敏柜是打开还是关闭（你应该熟悉前两个问题中的`Doctor`记录）：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we add into the equation the `Resident` record as well, then we can write
    this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Resident`记录也加入等式中，那么我们可以写成这样：
- en: '[PRE70]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And, if we add the `Patient` and `Appointment` records as well, then we can
    check if a certain patient has an appointment as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还将`Patient`和`Appointment`记录添加进去，那么我们可以按照以下方式检查某个患者是否有预约：
- en: '[PRE71]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we are using record patterns with guarded conditions in `switch` expressions,
    things are straightforward. The mention consists of using the `when` keyword (not
    the `&&` operator) as in the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`switch`表达式中使用带有保护条件的记录模式时，事情变得简单明了。提及的部分包括使用`when`关键字（而不是`&&`运算符），如下面的代码所示：
- en: '[PRE72]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And, if we add the `Patient` and `Appointment` records as well, then we can
    check if a certain patient has an appointment as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还将`Patient`和`Appointment`记录添加进去，那么我们可以按照以下方式检查某个患者是否有预约：
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The JDK 19+ context-specific keyword `when` is added between the pattern label
    and the checks (the boolean expressions representing the guarding conditions)
    this avoids the confusion of using the `&&` operator.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 19+的上下文特定关键字`when`被添加到模式标签和检查（代表保护条件的布尔表达式）之间，这避免了使用`&&`运算符的混淆。
- en: 100\. Using generic records in record patterns
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 100. 在记录模式中使用泛型记录
- en: 'Declaring a generic record for mapping fruit data can be done as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 声明用于映射水果数据的泛型记录可以按照以下方式完成：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let’s assume a `MelonRecord`, which is a fruit (actually, there is some
    controversy over whether a melon is a fruit or a vegetable, but let’s say that
    it is a fruit):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设一个`MelonRecord`，它是一种水果（实际上，关于西瓜是水果还是蔬菜有一些争议，但让我们假设它是水果）：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can declare a `FruitRecord<MelonRecord>` as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式声明一个`FruitRecord<MelonRecord>`：
- en: '[PRE76]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This `FruitRecord<MelonRecord>` can be used in record patterns with `instanceof`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FruitRecord<MelonRecord>`可以在带有`instanceof`的记录模式中使用：
- en: '[PRE77]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Or, in `switch` statements/expressions:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`switch`语句/表达式中：
- en: '[PRE78]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Next, let’s see how we can use type argument inference.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用类型参数推断。
- en: Type argument inference
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型参数推断
- en: 'Java supports inference of type arguments for record patterns, so we can re-write
    the previous examples as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持对记录模式进行类型参数推断，因此我们可以将之前的示例重写如下：
- en: '[PRE79]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Or, if we want more concise code, then we can drop the type arguments as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想要更简洁的代码，那么我们可以省略类型参数如下所示：
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The same works for `switch`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`switch`也是同样的道理：
- en: '[PRE81]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or, more concise:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简洁一些：
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, the type for `melon` is inferred as `MelonRecord`, and the type for `country`
    as `String`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`melon`的类型被推断为`MelonRecord`，`country`的类型为`String`。
- en: 'Now, let’s assume the following generic record:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设以下泛型记录：
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The generics `X`, `Y`, and `Z` can be anything. For instance, we can define
    an engine by its type, horsepower, and cooling system as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型`X`、`Y`和`Z`可以是任何东西。例如，我们可以通过类型、马力以及冷却系统来定义一个引擎如下所示：
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, we can use the `engine` variable and `instanceof` as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`engine`变量和`instanceof`如下所示：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And, with `switch` as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用`switch`如下所示：
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In both examples, we rely on inferred types for arguments. The type inferred
    for the `type` argument is `String`, for `power` is `Integer`, and for `cooling`
    is `String`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们依赖于推断的类型作为参数。对于`type`参数推断的类型是`String`，对于`power`是`Integer`，对于`cooling`是`String`。
- en: Type argument inference and nested records
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型参数推断和嵌套记录
- en: 'Let’s assume the following record:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设以下记录：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And the following nested `container`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下嵌套的`container`：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we can use `container` as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以按照以下方式使用`container`：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here, the `type` argument for the nested pattern `ContainerRecord(var c)` is
    inferred to be `String`, so the pattern itself is inferred to be `ContainerRecord<String>(var
    c)`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，嵌套模式`ContainerRecord(var c)`的类型参数被推断为`String`，因此模式本身被推断为`ContainerRecord<String>(var
    c)`。
- en: 'More concise code can be obtained if we drop the type arguments in the outer
    record pattern as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在外部记录模式中省略类型参数，我们可以得到更简洁的代码如下所示：
- en: '[PRE90]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, the compiler will infer that the entire `instanceof` pattern is `ContainerRecord<ContainerRecord<String>>(ContainerRecord<String>(var
    c))`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器会推断整个 `instanceof` 模式是 `ContainerRecord<ContainerRecord<String>>(ContainerRecord<String>(var
    c))`。
- en: 'Or, if we want the outer container, then we write the following record pattern:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想得到外部容器，那么我们编写以下记录模式：
- en: '[PRE91]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the bundled code, you can find these examples for `switch` as well.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你还可以找到这些 `switch` 的例子。
- en: '**Important note**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Pay attention that type patterns don’t support the implicit inference of type
    arguments (for instance, the type pattern `List list` is always treated as a raw
    type pattern).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型模式不支持类型参数的隐式推断（例如，类型模式 `List list` 总是作为原始类型模式处理）。
- en: So, Java Generics can be used in records exactly as in regular Java classes.
    Moreover, we can use them in conjunction with record patterns and `instanceof`/`switch`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java 泛型可以在记录中像在常规 Java 类中一样使用。此外，我们可以将它们与记录模式和 `instanceof`/`switch` 结合使用。
- en: 101\. Handling nulls in nested record patterns
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 101. 处理嵌套记录模式中的 null
- en: 'From *Chapter 2*, *Problem 54*, *Tackling the case null clause in switch,*
    we know that starting with JDK 17 (JEP 406), we can treat a `null` case in `switch`
    as any other common case:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *第二章*，*问题 54*，*处理 switch 中的 null 情况*，我们知道从 JDK 17（JEP 406）开始，我们可以将 `switch`
    中的 `null` 情况视为任何其他常见情况：
- en: '[PRE92]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This statement partially works for record patterns as well. For instance, let’s
    consider the following records:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句对记录模式也部分有效。例如，让我们考虑以下记录：
- en: '[PRE93]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And, let’s consider the following `switch`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们考虑以下 `switch`：
- en: '[PRE94]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If we call `buyFruit(null)`, then we will get the message *Ops!*. The compiler
    is aware that the selector expression is `null` and that there is a `case null`,
    therefore it will execute that branch. If we remove that `case null`, then we
    immediately get a `NullPointerException`. The compiler will not evaluate the record
    patterns; it will simply throw a `NullPointerException`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `buyFruit(null)`，那么我们会得到消息 *Ops!*。编译器知道选择表达式是 `null`，并且有一个 `case null`，因此它会执行那个分支。如果我们删除那个
    `case null`，那么我们立即得到一个 `NullPointerException`。编译器不会评估记录模式；它将简单地抛出一个 `NullPointerException`。
- en: 'Next, let’s create an eggplant:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个茄子：
- en: '[PRE95]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This time, if we call `buyFruit(seed)`, we get the message *This is a seed of
    Fairytale from India.* The call matches the `case SeedRecord(String type, String
    country)` branch. And, if we call `buyFruit(eggplant)`, then we get the message
    *This is a Fairytale eggplant*. The call matches the `case EggplantRecord(SeedRecord
    seed, float weight)` branch. There are no surprises so far!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如果我们调用 `buyFruit(seed)`，我们会得到消息 *这是来自印度的童话种子.* 调用与 `case SeedRecord(String
    type, String country)` 分支匹配。如果我们调用 `buyFruit(eggplant)`，那么我们会得到消息 *这是一颗童话茄子.*
    调用与 `case EggplantRecord(SeedRecord seed, float weight)` 分支匹配。到目前为止，没有惊喜！
- en: 'Now, let’s have an edge case. We assume that `SeedRecord` is `null` and we
    create the following “bad” eggplant:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个边缘情况。我们假设 `SeedRecord` 是 `null`，并创建以下“坏”茄子：
- en: '[PRE96]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `buyFruit(badEggplant)` call will return a `NullPointerException` containing
    the following crystal clear message: *java.lang.NullPointerException: Cannot invoke
    “modern.challenge.SeedRecord.type()” because “seed” is null*. As you can see,
    in the case of nested `null`, the compiler cannot prevent the execution of the
    corresponding branch. The nested `null` doesn’t short-circuit the code and hits
    the code of our branch (`case EggplantRecord(SeedRecord seed, float weight)`)
    where we call `seed.type()`. Since `seed` is `null`, we get a `NullPointerException`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '调用 `buyFruit(badEggplant)` 将返回一个包含以下清晰信息的 `NullPointerException`：*java.lang.NullPointerException:
    无法调用“modern.challenge.SeedRecord.type()”因为“seed”是 null*。正如你所见，在嵌套 `null` 的情况下，编译器无法阻止执行相应的分支。嵌套的
    `null` 不会短路代码，而是触发了我们的分支（`case EggplantRecord(SeedRecord seed, float weight)`）中的代码，我们在那里调用
    `seed.type()`。由于 `seed` 是 `null`，我们得到一个 `NullPointerException`。'
- en: 'We cannot cover this edge case via a case such as `case EggplantRecord(null,
    float weight)`. This will not compile. Obviously, a deeper or wider nesting will
    complicate these edge cases even more. However, we can add a guard to prevent
    the issue and cover this case as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法通过例如 `case EggplantRecord(null, float weight)` 这样的情况来覆盖这个边缘情况。这将无法编译。显然，更深或更广的嵌套将使这些边缘情况更加复杂。然而，我们可以添加一个守卫来防止问题，并按以下方式覆盖这个情况：
- en: '[PRE97]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let’s see what happens in the case of using `instanceof` instead of `switch`.
    So, the code becomes:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `instanceof` 而不是 `switch` 时会发生什么。因此，代码变为：
- en: '[PRE98]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the case of `instanceof`, there is no need to add explicit `null` checks.
    A call such as `buyFruit(null)` will return the message *This is an unknown fruit*.
    This happens since no `if` statement will match the given `null`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `instanceof` 的情况下，没有必要添加显式的 `null` 检查。例如，`buyFruit(null)` 的调用将返回消息 *This is
    an unknown fruit*。这是由于没有 `if` 语句与给定的 `null` 匹配。
- en: Next, if we call `buyFruit(seed)`, we get the message *This is a seed of Fairytale
    from India*. The call matches the `if (fruit instanceof SeedRecord(String type,
    String country))` branch. And, if we call `buyFruit(eggplant)`, then we get the
    message *This is a Fairytale eggplant*. The call matches the case `if (fruit instanceof
    EggplantRecord(SeedRecord seed, float weight))` branch. Again, there are no surprises
    so far!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们调用 `buyFruit(seed)`，我们会得到消息 *This is a seed of Fairytale from India*。这个调用与
    `if (fruit instanceof SeedRecord(String type, String country))` 分支匹配。如果我们调用 `buyFruit(eggplant)`，那么我们会得到消息
    *This is a Fairytale eggplant*。这个调用与 `case if (fruit instanceof EggplantRecord(SeedRecord
    seed, float weight))` 分支匹配。到目前为止，还没有惊喜！
- en: 'Finally, let’s bring in front the `badEggplant` via the `buyFruit(badEggplant)`
    call. Exactly as in the case of the `switch` example, the result will consist
    of an NPE: *Cannot invoke “modern.challenge.SeedRecord.type()” because “seed”
    is null*. Again, the nested `null` cannot be intercepted by the compiler and the
    `if (fruit instanceof EggplantRecord(SeedRecord seed, float weight))` branch is
    executed leading to a `NullPointerException` because we call `seed.type()` while
    `seed` is `null`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过 `buyFruit(badEggplant)` 调用将 `badEggplant` 带到前面。正如在 `switch` 示例中的情况一样，结果将包含一个
    NPE：*Cannot invoke “modern.challenge.SeedRecord.type()” because “seed” is null*。再次，嵌套的
    `null` 不能被编译器拦截，并且 `if (fruit instanceof EggplantRecord(SeedRecord seed, float
    weight))` 分支被执行，导致 `NullPointerException`，因为我们调用 `seed.type()` 时 `seed` 是 `null`。
- en: 'Trying to cover this edge case via the following snippet of code will not compile:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过以下代码片段覆盖这个边缘情况将无法编译：
- en: '[PRE99]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'However, we can add a guard to cover this case as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以添加一个守卫来覆盖这个情况，如下所示：
- en: '[PRE100]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: So, pay attention that nested patterns don’t take advantage of `case null` or
    of the JDK 19+ behavior that throws an NPE without even inspecting the patterns.
    This means that `null` values can pass through a `case` (or `instanceof` check)
    and execute that branch leading to NPEs. So, avoiding `null` values or adding
    extra checks (guards) as much as possible should be the way to a smooth road ahead.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请注意嵌套模式没有利用 `case null` 或 JDK 19+ 的行为，即在没有检查模式的情况下抛出 NPE。这意味着 `null` 值可以穿过一个
    `case`（或 `instanceof` 检查）并执行导致 NPE 的分支。所以，尽可能避免 `null` 值或添加额外的检查（守卫）应该是通往顺利道路的方式。
- en: 102\. Simplifying expressions via record patterns
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 102. 通过记录模式简化表达式
- en: Java records can help us to simplify snippets of code meant to handle/evaluate
    different expressions (mathematical, statistical, string-based, **Abstract Syntax
    Tree** (**AST**), and so on) a lot. Typically, evaluating such expressions implies
    a lot of conditions and checks that can be implemented via `if` and/or `switch`
    statements.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Java 记录可以帮助我们大大简化处理/评估不同表达式（数学、统计、基于字符串的、**抽象语法树**（**AST**）等）的代码片段。通常，评估此类表达式意味着有很多条件检查可以通过
    `if` 和/或 `switch` 语句实现。
- en: 'For example, let’s consider the following records meant to shape string-based
    expressions that can be concatenated:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下旨在形成可以连接的基于字符串的表达式的记录：
- en: '[PRE101]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Some parts of the string expression are literals (`Literal`) while others are
    provided as variables (`Variable`). For brevity, we can evaluate these expressions
    only via the concatenation operation (`Concat`), but feel free to add more operations.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串表达式的某些部分是字面量（`Literal`），而其他部分作为变量（`Variable`）提供。为了简洁起见，我们可以通过连接操作（`Concat`）来评估这些表达式，但请随意添加更多操作。
- en: During the evaluation, we have an intermediary step for simplifying the expression
    by removing/replacing irrelevant parts. For example, we can consider that the
    terms of the expression that are empty strings can be safely removed from the
    concatenation process. In other words, a string expression such as `t + " "` can
    be simplified as `t`, since the second term of our expression is a blank string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估过程中，我们有一个中间步骤，通过删除/替换不相关的部分来简化表达式。例如，我们可以考虑表达式中的空字符串项可以安全地从连接过程中删除。换句话说，一个字符串表达式如
    `t + " "` 可以简化为 `t`，因为我们的表达式的第二个项是一个空字符串。
- en: 'The code meant to perform this kind of simplification can rely on type patterns
    and `instanceof` as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行此类简化的代码可以依赖于类型模式和 `instanceof`，如下所示：
- en: '[PRE102]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This code will become quite verbose if we continue to add more rules for simplifying
    the given `str`. Fortunately, we can increase the readability of this code by
    using record patterns and `switch`. This way, the code becomes more compact and
    expressive. Check this out:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续为简化给定的`str`添加更多规则，这段代码将变得相当冗长。幸运的是，我们可以通过使用记录模式和`switch`来提高代码的可读性。这样，代码变得更加紧凑和易于表达。看看这个：
- en: '[PRE103]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How cool is this?
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？
- en: 103\. Hooking unnamed patterns and variables
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 103. 将未命名的模式和变量挂钩
- en: One of the most remarkable preview features of JDK 21 is JEP 443 or *unnamed
    patterns and variables*. In other words, via unnamed patterns and variables, JDK
    21 provides support for representing record components and local variables that
    we are not using in our code (we don’t care about them) as an underscore character
    (_).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 21最引人注目的预览特性之一是JEP 443或*未命名的模式和变量*。换句话说，通过未命名的模式和变量，JDK 21为我们提供了表示代码中未使用（我们不关心）的记录组件和局部变量的支持，即下划线字符（_）。
- en: Unnamed patterns
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未命名的模式
- en: 'Deconstructing a record allows us to express record patterns, but we do not
    always use all the resulting components. Unnamed patterns are useful for indicating
    the record components that we don’t use but we have to declare for the sake of
    syntax. For instance, let’s have the following example (the `Doctor`, `Resident`,
    `Patient`, and `Appointment` records were introduced earlier, in *Problem 97*
    and *98*, so, for brevity, I’ll skip their declarations here):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 解构记录使我们能够表达记录模式，但我们并不总是使用所有生成的组件。未命名的模式对于指示我们不使用但为了语法必须声明的记录组件非常有用。例如，让我们看以下示例（`Doctor`、`Resident`、`Patient`和`Appointment`记录在*问题97*和*98*中已介绍，为了简洁，我将在此省略它们的声明）：
- en: '[PRE104]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In this example, the `Doctor` record was deconstructed as `Doctor(String name,
    String specialty)` but we are using only the `specialty` component while we don’t
    need the `name` component. However, we cannot write `Doctor(String specialty)`
    since this doesn’t respect the `Doctor` record signature. Alternatively, we can
    simply replace the `String name` with an underscore as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Doctor`记录被解构为`Doctor(String name, String specialty)`，但我们只使用了`specialty`组件，而无需`name`组件。然而，我们不能写`Doctor(String
    specialty)`，因为这不符合`Doctor`记录的签名。作为替代，我们可以简单地用下划线替换`String name`如下：
- en: '[PRE105]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The unnamed pattern is shorthand for the type pattern `var _`, so we can write
    `if (staff instanceof Doctor(var _, String specialty))` as well.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名的模式是类型模式`var _`的简写，因此我们可以这样写`if (staff instanceof Doctor(var _, String specialty))`。
- en: 'Let’s consider another use case:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个用例：
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In this case, we use the `name` of the `Resident` but we don’t care about the
    `Doctor`, so we can simply use an underscore as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`Resident`的`name`，但我们不关心`Doctor`，因此我们可以简单地使用下划线如下：
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here is another example that ignores the specialty of the doctor:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个忽略医生专业性的示例：
- en: '[PRE108]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Next, let’s add the `Patient` and `Appointment` records as well:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们也添加`Patient`和`Appointment`记录：
- en: '[PRE109]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In this example, we don’t need the `npi` component and the `Doctor` component
    so we can replace them with an underscore:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要`npi`组件和`Doctor`组件，因此我们可以用下划线替换它们：
- en: '[PRE110]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And, here is a case that needs only the patient’s name:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是一个只需要患者姓名的情况：
- en: '[PRE111]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Of course, in such cases, you may prefer to rely on type pattern matching and
    express the code as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，你可能更喜欢依赖类型模式匹配，并按以下方式表达代码：
- en: '[PRE112]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: I think you got the idea! When you don’t need a record component and you want
    to clearly communicate this aspect while typing your code faster, just replace
    that component with an underscore (_).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你已经明白了这个想法！当你不需要记录组件，并且想要在快速编写代码时清楚地传达这一方面，只需将那个组件替换为下划线（_）即可。
- en: 'Unnamed patterns can be used with `switch` as well. Here is an example:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名的模式也可以与`switch`一起使用。以下是一个示例：
- en: '[PRE113]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Nested records and unnamed patterns can significantly reduce the code length.
    Here is an example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套记录和未命名的模式可以显著缩短代码长度。以下是一个示例：
- en: '[PRE114]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, let’s focus on another use case of unnamed variables, and let’s assume
    the following starting point:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于未命名的变量的另一个用例，并假设以下起点：
- en: '[PRE115]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'So, we have a sealed class (`EngineType`) extended by three final classes (`ESSEngine`,
    `DSLEngine`, and `LPGEngine`), and a record (`Car`). Next, we want to write the
    following `switch`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个密封类（`EngineType`），它由三个最终类（`ESSEngine`、`DSLEngine`和`LPGEngine`）扩展，还有一个记录（`Car`）。接下来，我们想要编写以下`switch`：
- en: '[PRE116]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Check out the first `case` label. We have grouped the first two patterns in
    one `case` label since the DSL and ESS cars can have the same type of carburetor.
    However, this will not compile and will result in an error: *illegal fall-through
    from a pattern*. Since both patterns can match is erroneous to name the components.
    In such cases, we can elide the components via unnamed variables as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第一个 `case` 标签。我们之所以将前两个模式组合在一个 `case` 标签中，是因为 DSL 和 ESS 汽车可以具有相同类型的化油器。然而，这将无法编译，并导致错误：*从模式非法跳过*。由于两个模式都可以匹配，给组件命名是错误的。在这种情况下，我们可以通过未命名的变量省略组件，如下所示：
- en: '[PRE117]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This compiles and works fine. Moreover, the second `case` label can be written
    as `case` `Car(LPGEngine _)` as well since we don’t use the `lpg` name on the
    right-hand side.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这会编译并正常工作。此外，第二个 `case` 标签也可以写成 `case` `Car(LPGEngine _)`，因为我们没有在右侧使用 `lpg`
    名称。
- en: 'If you need to add a *guard* to a case label with multiple patterns, then keep
    in mind that the guard applies to the multiple patterns as a whole not to each
    individual pattern. For instance, the following code is correct:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向具有多个模式的 case 标签添加 *守卫*，那么请记住，守卫适用于多个模式作为一个整体，而不是每个单独的模式。例如，以下代码是正确的：
- en: '[PRE118]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Next, let’s tackle unnamed variables.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理未命名变量。
- en: Unnamed variables
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未命名变量
- en: Along with **unnamed patterns** (specific to the deconstruction of record components),
    JDK 21 introduces *unnamed variables*. An unnamed variable is also represented
    by an underscore (_) and is useful to highlight which variables we don’t need/use.
    Such variables can occur in one of the following contexts.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **未命名的模式**（特定于记录组件的解构）之外，JDK 21 还引入了 *未命名的变量*。未命名的变量也由下划线 (_) 表示，并且有助于突出显示我们不需要/使用的变量。这些变量可以出现在以下任一上下文中。
- en: In a catch block
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 catch 块中
- en: '[PRE119]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The same technique can be applied to multi-catch cases.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以应用于多捕获情况。
- en: In a for loop
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一个 for 循环中
- en: '[PRE121]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'So, here, we don’t care about the cards’ values, so instead of writing `for
    (String card : cards) {…}`, we simply write `for (String _ : cards) {…}`.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，在这里，我们不在乎卡片的值，所以我们不是写 `for (String card : cards) {…}`，而是简单地写 `for (String
    _ : cards) {…}`。'
- en: In an assignment that ignores the result
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在忽略结果的赋值中
- en: 'Let’s consider the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码：
- en: '[PRE124]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `deleteIfExists()` method returns a boolean result indicating if the given
    file was successfully deleted or not. But, in this code, we didn’t capture that
    result, so it is not clear if we want to ignore the result or if we just forgot
    about it. If we assume that we forgot about it, then most probably we wanted to
    write this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteIfExists()` 方法返回一个布尔结果，表示给定的文件是否被成功删除。但是，在这个代码中，我们没有捕获那个结果，所以不清楚我们是想忽略结果还是只是忘记它。如果我们假设我们忘记了它，那么我们很可能会想写这样：'
- en: '[PRE125]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'But, if we just wanted to ignore it, then we can clearly communicate it via
    an unnamed variable (this signals that we are aware of the result but we don’t
    want to take further actions based on its value):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们只是想忽略它，那么我们可以通过未命名的变量清楚地传达这一点（这表明我们意识到了结果，但我们不想根据其值采取进一步行动）：
- en: '[PRE126]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The same technique applies every time you want to ignore the result of the expression
    on the right-hand side.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想忽略右侧表达式的结果时，都可以使用相同的技巧。
- en: In try-with-resources
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 try-with-resources 中
- en: 'Sometimes, we don’t use the resource opened in a *try-with-resources* block.
    We just need the context of this resource and we want to benefit from the fact
    that it is `AutoCloseable`. For instance, when we call `Arena.ofConfined()`, we
    may need the `Arena` context without explicitly using it. In such cases, unnamed
    variables can help us as in the following example:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不会使用在 *try-with-resources* 块中打开的资源。我们只需要这个资源的上下文，并且我们想从它是 `AutoCloseable`
    的这一事实中受益。例如，当我们调用 `Arena.ofConfined()` 时，我们可能需要 `Arena` 上下文，而无需明确使用它。在这种情况下，未命名的变量可以帮助我们，如下例所示：
- en: '[PRE127]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Or, using `var`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 `var`：
- en: '[PRE128]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `Arena` API is part of the Foreign (Function) Memory API introduced in *Chapter
    7*.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arena` API 是在 *第7章* 中引入的外部（函数）内存 API 的一部分。'
- en: In lambda expressions
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 lambda 表达式中
- en: 'When a lambda parameter is not relevant for our lambda expression, we can simply
    replace it with an underscore. Here is an example:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 参数对我们 lambda 表达式不相关时，我们可以简单地将其替换为下划线。以下是一个例子：
- en: '[PRE129]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Done! Don’t forget that this is a preview feature in JDK 21, so use `--enable-preview`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！别忘了，这是 JDK 21 中的一个预览功能，所以请使用 `--enable-preview`。
- en: 104\. Tackling records in Spring Boot
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 104. 解决 Spring Boot 中的记录问题
- en: Java records fit perfectly in Spring Boot applications. Let’s have several scenarios
    where Java records can help us increase readability and expressiveness by squeezing
    the homologous code.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录非常适合Spring Boot应用程序。让我们看看几个Java记录可以帮助我们通过压缩同源代码来提高可读性和表达性的场景。
- en: Using records in controllers
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中使用记录
- en: 'Typically, a Spring Boot controller operates with simple POJO classes that
    carry our data back over the wire to the client. For instance, check out this
    simple controller endpoint returning a list of authors, including their books:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Spring Boot控制器使用简单的POJO类操作，这些类携带我们的数据通过线传输到客户端。例如，检查这个简单的控制器端点，它返回一个包含作者及其书籍的作者列表：
- en: '[PRE130]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, the `Author` (and `Book`) can be simple carriers of data written as POJOs.
    But, they can be replaced by records as well. Here it is:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Author`（和`Book`）可以作为简单的数据载体，以POJO的形式编写。但它们也可以被记录所替代。如下所示：
- en: '[PRE131]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: That’s all! The Jackson library (which is the default JSON library in Spring
    Boot) will automatically marshal instances of type `Author`/`Book` into JSON.
    In the bundled code, you can practice the complete example via the `localhost:8080/authors`
    endpoint address.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！Jackson库（它是Spring Boot中的默认JSON库）将自动将`Author`/`Book`类型的实例序列化为JSON。在捆绑的代码中，您可以通过`localhost:8080/authors`端点地址练习完整的示例。
- en: Using records with templates
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用记录与模板
- en: Thymeleaf ([https://www.thymeleaf.org/](https://www.thymeleaf.org/)) is probably
    the most used templating engine in Spring Boot applications. Thymeleaf pages (HTML
    pages) are typically populated with data carried by POJO classes, which means
    that Java records should work as well.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf ([https://www.thymeleaf.org/](https://www.thymeleaf.org/))可能是Spring
    Boot应用程序中最常用的模板引擎。Thymeleaf页面（HTML页面）通常用POJO类携带的数据填充，这意味着Java记录也应该可以工作。
- en: 'Let’s consider the previous `Author` and `Book` records, and the following
    controller endpoint:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的`Author`和`Book`记录，以及以下控制器端点：
- en: '[PRE132]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `List<Author>` returned via `fetchAuthors()` is stored in the model under
    a variable named `authors`. This variable is used to populate `bookstore.html`
    as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`fetchAuthors()`返回的`List<Author>`存储在模型中，变量名为`authors`。这个变量用于以下方式填充`bookstore.html`：
- en: '[PRE133]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Done!
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: Using records for configuration
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用记录进行配置
- en: 'Let’s assume that in `application.properties` we have the following two properties
    (they could be expressed in YAML as well):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`application.properties`中拥有以下两个属性（它们也可以用YAML表示）：
- en: '[PRE134]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Spring Boot maps such properties to POJO via `@ConfigurationProperties`. But,
    a record can be used as well. For instance, these properties can be mapped to
    the `BestSellerConfig` record as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过`@ConfigurationProperties`将这些属性映射到POJO。但是，记录也可以使用。例如，这些属性可以按如下方式映射到`BestSellerConfig`记录：
- en: '[PRE135]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Next, in `BookstoreService` (a typical Spring Boot service), we can inject
    `BestSellerConfig` and call its accessors:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`BookstoreService`（一个典型的Spring Boot服务）中，我们可以注入`BestSellerConfig`并调用其访问器：
- en: '[PRE136]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In the bundled code, we have added a controller that uses this service as well.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，我们添加了一个使用此服务的控制器。
- en: Record and dependency injection
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和依赖注入
- en: 'In the previous examples, we have injected the `BookstoreService` service into
    `BookstoreController` using the typical mechanism provided by SpringBoot – dependency
    injection via constructor (it can be done via `@Autowired` as well):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经使用SpringBoot提供的典型机制将`BookstoreService`服务注入到`BookstoreController`中，即通过构造函数进行依赖注入（也可以通过`@Autowired`完成）：
- en: '[PRE137]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'But, we can compact this class by re-writing it as a record as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以通过将其重写为记录来压缩这个类，如下所示：
- en: '[PRE138]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The canonical constructor of this record will be the same as our explicit constructor.
    Feel free to challenge yourself to find more use cases of Java records in Spring
    Boot applications.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录的规范构造函数将与我们的显式构造函数相同。请随意挑战自己，在Spring Boot应用程序中找到更多Java记录的使用案例。
- en: 105\. Tackling records in JPA
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 105. 解决JPA中的记录问题
- en: If you are a fan of JPA (I cannot see why, but who am I to judge), then you’ll
    be more than happy to find out that Java records can be helpful in JPA. Typically,
    Java records can be used as DTOs. Next, let’s see several scenarios when records
    and JPA make a delightful combo.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个JPA的粉丝（我不明白为什么，但我是谁来判断呢），那么你一定会很高兴地发现Java记录在JPA中很有帮助。通常，Java记录可以用作DTO。接下来，让我们看看记录和JPA如何成为令人愉悦的组合的几个场景。
- en: DTO via record constructor
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过记录构造函数创建DTO
- en: Let’s assume that we have a JPA typical `Author` entity that maps author data
    such as `id`, `name`, `age`, and `genre`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个典型的JPA `Author`实体，它映射作者数据，如`id`、`name`、`age`和`genre`。
- en: 'Next, we want to write a query that fetches the authors of a certain `genre`.
    But, we don’t need to fetch authors as entities because we don’t plan to modify
    this data. This is a read-only query returning only the `name` and `age` of each
    author of the given `genre`. So, we need a DTO that can be expressed via records
    as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要编写一个查询，以获取某个 `genre` 的作者。但是，我们不需要以实体形式获取作者，因为我们不打算修改这些数据。这是一个只读查询，只返回给定
    `genre` 的每个作者的 `name` 和 `age`。因此，我们需要一个可以通过记录如下表达的 DTO：
- en: '[PRE139]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, a typical Spring Data JPA, `AuthorRepository` powered by the Spring Data
    Query Builder mechanism, can take advantage of this record as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个典型的 Spring Data JPA，由 Spring Data Query Builder 机制驱动的 `AuthorRepository`
    可以利用这个记录如下：
- en: '[PRE140]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Now, the generated query fetches the data and Spring Boot will map it accordingly
    to be carried around by the `AuthorDto`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成的查询获取数据，Spring Boot 将相应地将其映射为 `AuthorDto` 来携带。
- en: DTO via record and JPA constructor expression
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过记录和 JPA 构造器表达式生成 DTO
- en: 'Another flavor of the previous scenario can rely on a JPA query that uses a
    constructor expression as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个场景的另一种风味可以依赖于如下使用的构造器表达式的 JPA 查询：
- en: '[PRE141]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The `AuthorDto` is the same record listed in the previous example.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorDto` 与前一个示例中列出的相同记录。'
- en: DTO via record and result transformer
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过记录和结果转换器生成 DTO
- en: If working with Hibernate 6.0+ result transformers is not on your “to-do” list,
    then you can simply jump to the next topic.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在“待办事项”列表中添加使用 Hibernate 6.0+ 结果转换器，那么你可以直接跳到下一个主题。
- en: 'Let’s consider the following two records:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下两个记录：
- en: '[PRE142]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This time, we have to fetch a hierarchical DTO represented by `AuthorDto` and
    `BookDto`. Since an author can have several books written, we have to provide,
    in `AuthorDto`, a component of the type `List<BookDto>` and a helper method for
    collecting the books of the current author.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们必须获取由 `AuthorDto` 和 `BookDto` 表示的层次化 DTO。由于一个作者可以写多本书，我们必须在 `AuthorDto`
    中提供一个 `List<BookDto>` 类型的组件和一个用于收集当前作者书籍的辅助方法。
- en: 'In order to populate this hierarchical DTO, we can rely on an implementation
    of `TupleTransformer`, `ResultListTransformer` as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这个层次化的 DTO，我们可以依赖于 `TupleTransformer`、`ResultListTransformer` 的如下实现：
- en: '[PRE143]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You can find the complete application in the bundled code.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到完整的应用程序。
- en: DTO via record and JdbcTemplate
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过记录和 JdbcTemplate 生成 DTO
- en: If working with SpringBoot `JdbcTemplate` is not on your “to-do” list, then
    you can simply jump to the next topic.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在“待办事项”列表中添加使用 SpringBoot `JdbcTemplate`，那么你可以直接跳到下一个主题。
- en: The `JdbcTemplate` API has been a huge success among those who love to work
    with JDBC. So, if you are familiar with this API, then you’ll be very happy to
    find out that it can be combined with Java records quite nicely.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` API 在喜欢使用 JDBC 的人群中取得了巨大的成功。所以，如果你熟悉这个 API，那么你一定会很高兴地发现它可以与
    Java 记录很好地结合。'
- en: 'For instance, having the same `AuthorDto` and `BookDto` as in the previous
    scenario, we can rely on `JdbcTemplate` to populate this hierarchical DTO as follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与上一个场景中相同的 `AuthorDto` 和 `BookDto`，我们可以依赖于 `JdbcTemplate` 来填充这个层次化 DTO 如下：
- en: '[PRE144]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You can find the complete application in the bundled code.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到完整的应用程序。
- en: Team up Java records and @Embeddable
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Java 记录和 @Embeddable 结合起来
- en: 'Hibernate 6.2+ allows us to define Java records as embeddable. Practically,
    we start with an embeddable class defined as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 6.2+ 允许我们定义可嵌入的 Java 记录。实际上，我们从一个如下定义的可嵌入类开始：
- en: '[PRE145]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Next, we use this embeddable in our `Author` entity as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `Author` 实体中使用这个可嵌入部分如下：
- en: '[PRE146]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'And, in our `AuthorDto` DTO as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，在我们的 `AuthorDto` DTO 中如下：
- en: '[PRE147]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Next, a classical Spring Data JPA `AuthorRepository` powered by the Spring
    Data Query Builder mechanism can take advantage of this record as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个经典的 Spring Data JPA `AuthorRepository`，由 Spring Data Query Builder 机制驱动，可以如下利用这个记录：
- en: '[PRE148]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now, the generated query fetches the data and Spring Boot will map it accordingly
    to be carried around by the `AuthorDto`. If we print one of the fetched authors
    to the console, we will see something like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成的查询获取数据，Spring Boot 将相应地将其映射为 `AuthorDto` 来携带。如果我们打印一个获取的作者到控制台，我们会看到如下内容：
- en: '[PRE149]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The highlighted part represents our embeddable.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分代表我们的可嵌入部分。
- en: 106\. Tackling records in jOOQ
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 106. 处理 jOOQ 中的记录
- en: The more you learn about JPA, the more you’ll love jOOQ. Why? Because jOOQ represents
    the best way to write SQL in Java. Flexibility, versatility, dialect agnostic,
    rock-solid SQL support, a small learning curve, and high performance are just
    a few of the attributes that make jOOQ the most appealing persistence technology
    for modern applications.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你对JPA了解得越多，你就越会喜欢jOOQ。为什么？因为jOOQ代表了在Java中编写SQL的最佳方式。灵活性、多功能性、方言无关、坚如磐石的SQL支持、学习曲线小、高性能只是使jOOQ成为现代应用程序最具吸引力的持久化技术的一些属性。
- en: Being part of the modern technology stack, jOOQ is the new persistence trend
    that respects all standards of a mature, robust, and well-documented technology.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 作为现代技术栈的一部分，jOOQ是尊重成熟、健壮和良好文档化的技术所有标准的新的持久化趋势。
- en: If you are not familiar with jOOQ, then please consider my book *jOOQ Masterclass*.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉jOOQ，那么请考虑我的书 *jOOQ大师班*。
- en: 'That being said, let’s assume that we have a database schema consisting of
    two tables, `Productline` and `Product`. A product line contains multiple products,
    so we can shape this one-to-many relationship via two records as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们假设我们有一个由两个表组成的数据库模式，分别是`Productline`和`Product`。一个产品线包含多个产品，因此我们可以通过以下两个记录来塑造这种一对一的关系：
- en: '[PRE150]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'In jOOQ, we can populate this model via a simple query based on the `MULTISET`
    operator:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，我们可以通过基于`MULTISET`运算符的简单查询来填充此模型：
- en: '[PRE151]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: How cool is this? jOOQ can produce any nested collection value of jOOQ Records
    or DTOs (POJO/Java records) in a fully type-safe manner, with zero reflections,
    no N+1 risks, no de-duplications, and no accidental Cartesian products. This allows
    the database to perform nesting and optimize the query execution plan.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？jOOQ可以以完全类型安全的方式生成jOOQ Records或DTOs（POJO/Java记录）的任何嵌套集合值，无需反射，无N+1风险，无去重，无意外的笛卡尔积。这允许数据库执行嵌套并优化查询执行计划。
- en: In the bundled code, you can see another example that fetches a many-to-many
    relationship in a record model. Moreover, in the bundled code, you can find an
    example that relies on the jOOQ `MULTISET_AGG()` function. This is a synthetic
    aggregate function that can be used as an alternative to `MULTISET`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到另一个示例，它在一个记录模型中检索多对多关系。此外，在捆绑的代码中，你可以找到一个依赖于jOOQ `MULTISET_AGG()`函数的示例。这是一个合成聚合函数，可以用作`MULTISET`的替代品。
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was to deeply cover Java records and record patterns.
    We have assigned the same importance to both the theoretical and the practical
    parts so that, in the end, there are no secrets regarding the use of these two
    topics. And, just in case you wonder why we didn’t cover the topic regarding record
    patterns appearing in the header of an enhanced `for` statement, then please notice
    that this was added as a preview in JDK 20 but it was removed in JDK 21\. This
    feature may be re-proposed in a future JEP.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是深入探讨Java记录和记录模式。我们对理论和实践部分都赋予了同等的重要性，以便最终这两个主题没有秘密。而且，如果你想知道为什么我们没有涵盖出现在增强型`for`语句标题中的记录模式主题，那么请注意，这被添加为JDK
    20的一个预览功能，但在JDK 21中被删除。这个功能可能会在未来的JEP中重新提出。
- en: Leave a review!
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码以获取20%的折扣码。
- en: '![](img/Leave_Reivew_QR.png)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![留评二维码](img/Leave_Reivew_QR.png)'
- en: '**Limited Offer*'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
