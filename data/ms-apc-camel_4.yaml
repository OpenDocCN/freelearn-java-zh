- en: Chapter 4. Beans
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。豆子
- en: In the previous chapter, we saw one of the key, and very helpful, Camel components—the
    processor. However, a processor is tied to Camel as it extends the `org.apache.camel.Processor`
    interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 Camel 的一个关键且非常有用的组件——处理器。然而，处理器与 Camel 相关联，因为它扩展了 `org.apache.camel.Processor`
    接口。
- en: This means that in order to reuse some existing beans in your application, you
    have to wrap it in a processor, meaning additional code to be maintained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了在应用程序中重用一些现有的豆子，你必须将其包装在处理器中，这意味着需要维护额外的代码。
- en: Fortunately, Camel has extensive support for POJO and beans, and bean model
    frameworks such as Spring or Blueprint.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Camel 对 POJO 和豆子以及 Spring 或 Blueprint 等豆模型框架提供了广泛的支持。
- en: 'In this chapter, we will see:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到：
- en: How Camel looks for beans in different registries and the different registry
    implementations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel 在不同注册表中查找豆子以及不同的注册表实现
- en: How Camel acts as a service activator to load the beans and bind the parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel 如何作为服务激活器来加载豆子并绑定参数
- en: The Camel annotations that enables *advanced* binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许进行 *高级* 绑定的 Camel 注解
- en: The Camel language annotations that allow the usage of code in parameter binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在参数绑定中使用代码的 Camel 语言注解
- en: Registry
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Registry
- en: It's possible to use a bean exactly as a processor, meaning, directly inline
    in a route. This allows us to use a lightweight, simple programming model, reusing
    existing components in Camel routes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将豆子直接用作处理器，这意味着直接内联在路由中。这允许我们使用轻量级、简单的编程模型，在 Camel 路由中重用现有组件。
- en: When a bean is used in a Camel route, the bean must be registered in a registry.
    Depending on which environment is running, Camel bootstraps different registries.
    When Camel works with beans, it looks them up in the registry to locate them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个豆子在 Camel 路由中使用时，这个豆必须在注册表中注册。根据运行的环境不同，Camel 会启动不同的注册表。当 Camel 与豆子一起工作时，它会查找注册表以定位它们。
- en: The registry is defined at the `CamelContext` level. A registry is automatically
    created for you by Camel with the `CamelContext`. If you create the `CamelContext`
    manually, you can instantiate a registry and put this registry in the `CamelContext`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表在 `CamelContext` 级别定义。Camel 会自动为你创建一个与 `CamelContext` 相关的注册表。如果你手动创建 `CamelContext`，你可以实例化一个注册表并将其放入
    `CamelContext`。
- en: 'The following registry implementations are shipped with Camel:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与 Camel 一起提供的注册表实现：
- en: '`SimpleRegistry`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleRegistry`'
- en: '`JndiRegistry`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JndiRegistry`'
- en: '`ApplicationContextRegistry`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationContextRegistry`'
- en: '`OsgiServiceRegistry`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OsgiServiceRegistry`'
- en: Let's have a look at each one of these in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细看看这些内容。
- en: SimpleRegistry
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SimpleRegistry
- en: '`SimpleRegistry` is a simple implementation, mostly used for testing where
    only a limited number of JDK classes are available. It''s basically a simple `Map`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleRegistry` 是一个简单的实现，主要用于测试，在测试环境中只有有限数量的 JDK 类可用。它基本上是一个简单的 `Map`。'
- en: You have to create an instance of `SimpleRegistry` by hand before using it.
    Camel doesn't load any `SimpleRegistry` by default.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，你必须手动创建 `SimpleRegistry` 的一个实例。Camel 默认不会加载任何 `SimpleRegistry`。
- en: The following example in (`chapter4a` folder) shows how to create a `SimpleRegistry`,
    register a bean, and use it in a Camel route.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例（在 `chapter4a` 文件夹中）展示了如何创建一个 `SimpleRegistry`，注册一个豆子，并在 Camel 路由中使用它。
- en: In this example, we instantiate a `SimpleRegistry` that we put in a `CamelContext`
    that we create as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实例化了一个 `SimpleRegistry`，并将其放入我们创建的 `CamelContext` 中。
- en: We populate the `SimpleRegistry` with a `SimpleBean`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `SimpleBean` 来填充 `SimpleRegistry`
- en: In the `CamelContext`, we add a route that calls the `SimpleBean`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CamelContext` 中，我们添加了一个调用 `SimpleBean` 的路由。
- en: To simplify the execution, we embed this code in a main method that we execute
    via a Maven plugin.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化执行，我们将此代码嵌入到一个主方法中，并通过 Maven 插件执行。
- en: 'The Maven `pom.xml` is the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 的 `pom.xml` 如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `src/main/java` folder of the project, we create the `com.packt.camel.chapter4a`
    package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的 `src/main/java` 文件夹中，我们创建 `com.packt.camel.chapter4a` 包。
- en: 'In this package, we have:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个包中，我们包含了：
- en: A `SimpleBean` class
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `SimpleBean` 类
- en: A `Main` class
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Main` 类
- en: 'The `SimpleBean` class is pretty simple; it just says hello:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleBean` 类相当简单；它只是说“你好”：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Main` class contains only the main method. It''s in this method that:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 类只包含主方法。正是在这个方法中：'
- en: We create a `SimpleRegistry`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个 `SimpleRegistry`
- en: We populate the registry with an instance of the `SimpleBean`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `SimpleBean` 的一个实例来填充注册表
- en: We create a `CamelContext`, which uses our `SimpleRegistry`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个 `CamelContext`，它使用我们的 `SimpleRegistry`
- en: We create and add a route in the `CamelContext`. This route uses the `SimpleBean`
    from the registry
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `CamelContext` 中创建并添加了一个路由。这个路由使用注册表中的 `SimpleBean`。
- en: 'Here''s the code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run the project, use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，请使用以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the execution:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到执行结果：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This proves that the `SimpleRegistry` has been used by our `CamelContext`. Camel
    succeeded in looking for the bean in the registry and using it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们的 `CamelContext` 使用了 `SimpleRegistry`。Camel 成功在注册表中查找并使用了该豆。
- en: JndiRegistry
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JndiRegistry
- en: '`JndiRegistry` is an implementation that uses an existing **Java Naming and
    Directory** (**JNDI**) registry to look up beans. It''s the default registry used
    by Camel when using the Camel Java DSL.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`JndiRegistry` 是一个使用现有 **Java 命名和目录服务**（**JNDI**）注册表来查找豆的实现。它是 Camel 在使用 Camel
    Java DSL 时使用的默认注册表。'
- en: A `JndiRegistry` can be constructed using a JNDI InitialContext. It gives the
    flexibility to use existing JNDI InitialContext. Camel itself provides a simple
    `JndiContext` that you can use with the `JndiRegistry`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 JNDI InitialContext 构建一个 `JndiRegistry`。它提供了使用现有 JNDI InitialContext 的灵活性。Camel
    本身提供了一个简单的 `JndiContext`，您可以使用它与 `JndiRegistry` 一起使用。
- en: We can illustrate the usage of a `JndiRegistry` by implementing an example very
    similar to the previous one (using a `SimpleRegistry`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现一个与前一个示例非常相似的示例（使用 `SimpleRegistry`）来说明 `JndiRegistry` 的用法。
- en: 'The Maven `pom.xml` is basically the same as in the previous example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 的 `pom.xml` 基本上与上一个示例相同：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `src/main/java` directory of the project, we create the `com.packt.camel.chapter4b`
    package.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的 `src/main/java` 目录中，我们创建了 `com.packt.camel.chapter4b` 包。
- en: 'This package contains a `SimpleBean` class similar to the one in the previous
    example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包包含一个 `SimpleBean` 类，类似于前一个示例中的类：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the main difference is in the `Main` class; we just replace the `SimpleRegistry`
    with a `JndiRegistry`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主要区别在于 `Main` 类；我们只是将 `SimpleRegistry` 替换为 `JndiRegistry`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To run the project, use the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，请使用以下命令：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The execution gives basically the same result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果基本上相同：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We switched to another registry implementation without any impact on the execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们切换到另一个注册表实现，对执行没有影响。
- en: As a reminder, the `JndiRegistry` is implicitly created by Camel when you use
    the Java DSL for your route.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，当您使用 Java DSL 为您的路由时，`JndiRegistry` 会隐式地由 Camel 创建。
- en: ApplicationContextRegistry
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ApplicationContextRegistry
- en: '`ApplicationContextRegistry` is a Spring-based implementation to look up beans
    from the Spring `ApplicationContext`. This implementation is automatically used
    when you are using Camel in a Spring environment.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationContextRegistry` 是一个基于 Spring 的实现，用于从 Spring `ApplicationContext`
    中查找豆。当您在 Spring 环境中使用 Camel 时，此实现会自动使用。'
- en: OsgiServiceRegistry
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OsgiServiceRegistry
- en: '`OsgiServiceRegistry` is a hook to the OSGi Service Registry. It''s used by
    Camel when running in OSGi environment.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`OsgiServiceRegistry` 是连接到 OSGi 服务注册表的钩子。当在 OSGi 环境中运行时，Camel 会使用它。'
- en: Creating CompositeRegistry
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CompositeRegistry
- en: These registries can be composed to create a multilayer registry using a `CompositeRegistry`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注册表可以通过 `CompositeRegistry` 组合起来创建一个多层注册表。
- en: You can create a `CompositeRegistry` by adding other registries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加其他注册表来创建一个 `CompositeRegistry`。
- en: To illustrate the usage of a `CompositeRegistry`, we create a new example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `CompositeRegistry` 的用法，我们创建了一个新的示例。
- en: 'Again, the Maven `pom.xml` is basically the same:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Maven 的 `pom.xml` 基本上相同：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `src/main/java` directory of the project, we have a `com.packt.camel.chapter4c`
    package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的 `src/main/java` 目录中，我们有一个 `com.packt.camel.chapter4c` 包。
- en: 'We again have the sample `SimpleBean` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有示例 `SimpleBean` 类：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But this time, in the `Main` class, we create two registries that we gather
    in a composite registry.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次，在 `Main` 类中，我们创建了两个注册表，我们将它们收集到一个复合注册表中。
- en: To illustrate the usage, we create two instances of the `SimpleBean` in each
    registry part of the composite, each instance having a different name in the registries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明用法，我们在复合注册表的每个注册表部分创建了两个 `SimpleBean` 实例，每个实例在注册表中具有不同的名称。
- en: 'We now create two routes in the `CamelContext`; one route uses the `SimpleBean`
    instance, and the other uses the `otherBean` instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `CamelContext` 中创建了两个路由；一个路由使用 `SimpleBean` 实例，另一个使用 `otherBean` 实例：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run the project, use the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，请使用以下命令：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, at execution time, we can see that the two routes have been executed,
    each route using the `bean` instance in the registry. But actually, each instance
    is in a different registry:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在执行时间，我们可以看到两个路由已经执行，每个路由都使用注册表中的`bean`实例。但实际上，每个实例都在不同的注册表中：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Service activator
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务激活器
- en: Camel acts as a service activator, using `BeanProcessor`, which sits between
    the caller and the actual bean.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Camel充当服务激活器，使用`BeanProcessor`，它位于调用者和实际bean之间。
- en: The `BeanProcessor` is a special processor that converts the inbound exchange
    to a method invocation on a bean (POJO).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanProcessor`是一个特殊的处理器，它将传入的交换转换为对bean（POJO）的方法调用。'
- en: 'The `BeanProcessor` performs the following steps when called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，`BeanProcessor`执行以下步骤：
- en: It looks up the bean in the registry.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在注册表中查找bean。
- en: It selects the method to invoke the bean.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它选择要调用的bean的方法。
- en: It binds to the parameters of the selected method.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它绑定到所选方法的参数。
- en: It actually invokes the method.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它实际上调用了该方法。
- en: It possibly handles any invocation errors that occurred.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能处理发生的任何调用错误。
- en: It sets the method's reply as the body of the output message.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将方法的响应设置为输出消息的主体。
- en: Bean and method bindings
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean和方法绑定
- en: 'During step 2, when the `BeanProcessor` selects the method to invoke, the message/method
    bindings can occur in different ways. Camel tries the following steps to resolve
    the bean method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，当`BeanProcessor`选择要调用的方法时，消息/方法绑定可以以不同的方式发生。Camel尝试以下步骤来解决bean方法：
- en: If the incoming message (`in` message) contains the `CamelBeanMethodName` header,
    then this method is invoked, converting the `in` message body to the type of the
    method's argument.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传入的消息（`in`消息）包含`CamelBeanMethodName`头，则调用此方法，将`in`消息主体转换为方法参数的类型。
- en: You can specify the method name directly in the route definition (on the bean
    endpoint).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以直接在路由定义中（在bean端点）指定方法名称。
- en: If the bean contains a method annotated with `@Handler`, then this method is
    invoked.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果bean包含带有`@Handler`注解的方法，则调用此方法。
- en: If the bean can be converted to a processor (containing the `process()` method),
    we fall back to the regular processor usage as seen in the previous chapter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果bean可以转换为处理器（包含`process()`方法），我们将回退到上一章中看到的常规处理器使用方式。
- en: If the body of the in message can be converted to a `org.apache.camel.component.bean.BeanInvocation`
    component, then it's the result of the `getMethod()` method, which is used as
    the method name.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传入消息的主体可以转换为`org.apache.camel.component.bean.BeanInvocation`组件，则它是`getMethod()`方法的结果，用作方法名称。
- en: Otherwise, the body type of the in message is used to find a matching method.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，使用传入消息的主体类型来查找匹配的方法。
- en: 'Several exceptions can occur during the method lookup. They are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法查找过程中可能会发生几个异常。它们如下：
- en: If Camel cannot find the method, it throws a `MethodNotFoundException` exception
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Camel找不到方法，它会抛出`MethodNotFoundException`异常
- en: If Camel cannot uniquely resolve a method (for instance, depending on the method
    argument), it throws an `AmbigiousMethodCallException` exception.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Camel无法唯一解析一个方法（例如，根据方法参数），它会抛出`AmbigiousMethodCallException`异常。
- en: Before Camel invokes the selected method, it must convert the in message body
    to the parameter type required by the method. If this fails, a `NoTypeConversionAvailableException`
    exception is thrown.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Camel调用所选方法之前，它必须将传入消息的主体转换为方法所需的参数类型。如果失败，则抛出`NoTypeConversionAvailableException`异常。
- en: Once the method name has been identified, Camel populates the method parameters;
    it's what we name method parameters binding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了方法名称，Camel就会填充方法参数；这就是我们所说的方法参数绑定。
- en: 'Some Camel types are automatically bound, such as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Camel类型会自动绑定，例如：
- en: '`org.apache.camel.Exchange`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.camel.Exchange`'
- en: '`org.apache.camel.Message`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.camel.Message`'
- en: '`org.apache.camel.CamelContext`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.camel.CamelContext`'
- en: '`org.apache.camel.TypeConverter`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.camel.TypeConverter`'
- en: '`org.apache.camel.spi.Registry`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.camel.spi.Registry`'
- en: '`java.lang.Exception`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Exception`'
- en: It means that you can directly use any of these types in the method parameters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以直接在方法参数中使用这些类型中的任何一种。
- en: 'For instance, your bean may contain a single method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的bean可能只包含一个方法：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Camel will provide the current exchange to your method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Camel将提供当前交换给您的函数。
- en: By default, Camel will try to convert the `in` message body as the first parameter
    of the method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Camel会尝试将`in`消息主体转换为方法的第一个参数。
- en: The return statement of the `bean` method is used to populate the body of the
    `in` message (in case the bean is used via the Camel bean component) or a header
    value (in case the bean is used via the `setHeader` Camel statement).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`bean` 方法的返回语句用于填充 `in` 消息的正文（如果 bean 通过 Camel bean 组件使用）或头部值（如果 bean 通过 `setHeader`
    Camel 语句使用）。'
- en: However, depending on your bean, you might have some ambiguity. Camel gives
    you fine-grained control of the method parameters by providing a set of annotations,
    which we will cover in the following section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据你的 bean，你可能会有一些歧义。Camel 通过提供一系列注解，让你可以精细控制方法参数，这些注解将在下一节中介绍。
- en: Annotations
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Depending on your bean, you might have some ambiguity. Camel gives you fine-grained
    control of the method parameters by providing a set of annotations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 bean，你可能会有一些歧义。Camel 通过提供一系列注解，让你可以精细控制方法参数。
- en: Thanks to the annotations, you can describe the expected binding for both method
    binding and parameter binding.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了注解，你可以描述方法绑定和参数绑定预期的绑定。
- en: For method binding, Camel provides the `@Handler` annotation. This annotation
    allows you to specify the method that Camel will use during execution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法绑定，Camel 提供了 `@Handler` 注解。这个注解允许你指定 Camel 在执行期间将使用的方法。
- en: 'For instance, you may have the following bean:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个以下 bean：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In that case, Camel (without specifying the method to use in the route definition)
    will fail to find the method to call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Camel（在路由定义中没有指定要使用的方法）将无法找到要调用的方法。
- en: 'The `@Handler` annotation removes the ambiguity:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Handler` 注解消除了歧义：'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Camel also provides annotations for the method parameters binding. The `@Body`
    binds the parameter to the `in` message body. It allows to bind type like directly
    a POJO:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 还为方法参数提供了注解。`@Body` 将参数绑定到 `in` 消息体。它允许直接绑定类型，就像直接绑定一个 POJO：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Camel will use a converter to transform the actual in message body to the expected
    type of the method parameter. The `@ExchangeException` binds the parameter to
    the `Exchange` exception. This annotation allows you to directly inject the `Exchange`
    exception in your method. For instance, you can test if the exception is not null
    and react accordingly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 将使用转换器将实际消息体中的内容转换为方法参数期望的类型。`@ExchangeException` 将参数绑定到 `Exchange` 异常。这个注解允许你直接在你的方法中注入
    `Exchange` 异常。例如，你可以测试异常是否不为空，并相应地做出反应。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `@Header` binds the parameter to a header of the in message. You can specify
    the header name on the annotation as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Header` 将参数绑定到 `in` 消息的头部。你可以在注解中指定头部名称，如下所示：'
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@Headers` binds the parameter to the `Map` containing all headers of the
    `in` message. It's especially interesting when you have to manipulate multiple
    headers in your method. Using this annotation, the parameter has to be of the
    `Map` type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Headers` 将参数绑定到包含 `in` 消息所有头部的 `Map`。当你需要在方法中操作多个头部时，这特别有趣。使用这个注解，参数必须是 `Map`
    类型。'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, like `@Headers` for the in message, the `@OutHeaders` annotation
    binds the parameter to the `Map` containing all headers of the `out` message.
    It''s especially interesting when you have to populate some headers (using the
    `put()` method on the Map):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类似于 `@Headers` 对于 `in` 消息，`@OutHeaders` 注解将参数绑定到包含 `out` 消息所有头部的 `Map`。当你需要使用
    `put()` 方法在 Map 中填充一些头部时，这特别有趣：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `@Property` binds a property of the `Exchange`. As a reminder, the lifetime
    of a property is the `Exchange`, whereas a header is related to a message. The
    name of the property is directly provided on the annotation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Property` 将 `Exchange` 的一个属性绑定。提醒一下，属性的生存期是 `Exchange`，而头部与消息相关。属性名称直接在注解中提供。'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As for the headers, `@Properties` binds a property to the `Map` containing
    all the properties of the `Exchange`. Again, it''s interesting to add new properties
    to the method (using the `put()` method of the `Map`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于头部，`@Properties` 将属性绑定到包含 `Exchange` 所有属性的 `Map`。同样，向方法添加新属性（使用 Map 的 `put()`
    方法）很有趣：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Annotations for expression languages
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语言注解
- en: It's also possible to directly leverage the languages supported by Camel to
    populate the method parameters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接利用 Camel 支持的语言来填充方法参数。
- en: 'The following annotations are provided:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提供以下注解：
- en: '`@Bean` binds another bean to the parameter. It allows you to inject a bean
    into a bean. Camel will look for the bean with the ID provided in the annotation:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Bean` 将另一个bean绑定到参数。它允许你将bean注入到bean中。Camel将寻找注解中提供的ID对应的bean：'
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`@BeanShell` binds the result of a bean method call to the parameter. BeanShell
    is a convenient language allowing you to explicitly call a bean method. The bean
    scripting is defined directly on the annotation:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeanShell` 将bean方法调用的结果绑定到参数。BeanShell是一种方便的语言，允许你显式调用bean方法。bean脚本直接在注解上定义：'
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`@Constant` binds a static String to the parameter:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Constant` 将静态String绑定到参数：'
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`@EL` binds the result of an expression language (JUEL) to the parameter. The
    expression is defined in the annotation:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EL` 将表达式语言（JUEL）的结果绑定到参数。表达式在注解中定义：'
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`@Groovy` binds the result of a Groovy expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Groovy` 将Groovy表达式的结果绑定到参数。表达式在注解中定义。请求关键字对应于`in`消息：'
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`@JavaScript` binds the result of a JavaScript expression to the parameter.
    The expression is defined in the annotation:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JavaScript` 将JavaScript表达式的结果绑定到参数。表达式在注解中定义：'
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`@MVEL` binds the result of a MVEL expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MVEL` 将MVEL表达式的结果绑定到参数。表达式在注解中定义。请求关键字对应于`in`消息：'
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`@OGNL` binds the result of a OGNL expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OGNL` 将OGNL表达式的结果绑定到参数。表达式在注解中定义。请求关键字对应于`in`消息：'
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`@PHP` binds the result of a PHP expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PHP` 将PHP表达式的结果绑定到参数。表达式在注解中定义。请求关键字对应于`in`消息：'
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`@Python` binds the result of a Python expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Python` 将Python表达式的结果绑定到参数。表达式在注解中定义。请求关键字对应于`in`消息：'
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`@Ruby` binds the result of a Ruby expression to the parameter. The expression
    is defined in the annotation. The request Ruby variable corresponds to the `in`
    message:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Ruby` 将Ruby表达式的结果绑定到参数。表达式在注解中定义。请求的Ruby变量对应于`in`消息：'
- en: '[PRE35]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`@Simple` binds the result of a simple expression to the parameter. The expression
    is defined in the annotation. Simple is a Camel language allowing you to define
    simple expressions directly using the Camel objects:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Simple` 将简单表达式的结果绑定到参数。表达式在注解中定义。Simple是Camel语言，允许你直接使用Camel对象定义简单表达式：'
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`@XPath` binds the result of a XPath expression to the parameter. The expression
    is defined in the annotation. It''s very convenient to extract part of an XML
    `in` message:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XPath` 将XPath表达式的结果绑定到参数。表达式在注解中定义。它非常方便从XML `in`消息中提取部分内容：'
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`@XQuery` binds the result of a XQuery expression to the parameter. The expression
    is defined in the annotation. Like XPath, it''s very convenient to extract part
    of a XML `in` message:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XQuery` 将XQuery表达式的结果绑定到参数。表达式在注解中定义。像XPath一样，它非常方便从XML `in`消息中提取部分内容：'
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, it's possible to combine the different annotations with multiple
    parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以将不同的注解与多个参数组合使用。
- en: Camel gives you great flexibility, irrespective of the language that you already
    know, you can use it in the expressions and predicates definition.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Camel提供了极大的灵活性，无论你已知的语言是什么，你都可以在表达式和谓词定义中使用它。
- en: Example – creating an OSGi bundle with a bean
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 创建包含bean的OSGi包
- en: We illustrate the use of beans in a simple example. This example will create
    an OSGi bundle containing a bean called by a Camel route.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个简单的示例来说明bean的使用。此示例将创建一个包含由Camel路由调用的bean的OSGi包。
- en: 'We will create a bean used in two parts of a route:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个在路由的两个部分中使用的bean：
- en: One that directly uses the Camel bean component to change the body of the in
    message
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种直接使用Camel bean组件来更改入站消息的正文
- en: Another to define a header in the route
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种在路由中定义一个报头
- en: 'First, we create the Maven project `pom.xml` for our bundle:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的bundle创建Maven项目`pom.xml`：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This `pom.xml` is pretty simple:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pom.xml`文件相当简单：
- en: It defines the Camel core dependency in order to get the bean annotations
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了Camel核心依赖项，以便获取bean注解
- en: It uses the Maven bundle plugin to package the bean and the route as an OSGi
    bundle
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Maven bundle插件将bean和路由打包为OSGi bundle
- en: Creating the MyBean class
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建MyBean类
- en: 'We create the `MyBean` class containing two methods:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建包含两个方法的`MyBean`类：
- en: The `doMyLogic()` method is annotated as `@Handler` as described previously.
    It's the one that will be used by the Camel Bean component. This method has a
    unique parameter `body` of the `String` type. Thanks to the `@Body` annotation,
    this parameter will be populated by Camel with the body of the in message.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doMyLogic()`方法如前所述被注解为`@Handler`。这是Camel Bean组件将使用的方法。此方法有一个唯一的`body`参数，类型为`String`。多亏了`@Body`注解，此参数将由Camel用入消息的正文填充。'
- en: The `setMyHeader()` method just returns `String`. This method will be used by
    Camel to populate a header of the in message.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMyHeader()`方法仅返回`String`。此方法将由Camel用于填充入消息的头。'
- en: 'The code of `MyBean` class is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyBean`类的代码如下：'
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can note that the doMyLogic() method defines the bean as a message translator:
    it transforms the body of the in message in another message body. It looks like
    the `PrefixerProcessor` used in the previous chapter.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到`doMyLogic()`方法将bean定义为消息转换器：它将入消息的正文转换为另一个消息正文。它看起来像前一章中使用的`PrefixerProcessor`。
- en: Writing a route definition using the Camel Blueprint DSL
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Camel Blueprint DSL编写路由定义
- en: We are going to use Blueprint DSL to write the definition of the route. Thanks
    to this, we don't have to provide all the plumbing code to create the `CamelContext`
    and reference it as an OSGi service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Blueprint DSL来编写路由的定义。多亏了这一点，我们不需要提供所有管道代码来创建`CamelContext`并将其作为OSGi服务引用。
- en: The `CamelContext` is implicitly created by Camel, and we describe the route
    directly using XML.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`CamelContext`由Camel隐式创建，我们直接使用XML描述路由。'
- en: 'In the `OSGI-INF/blueprint` folder of our bundle, we create the following `route.xml`
    definition:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的bundle的`OSGI-INF/blueprint`文件夹中，我们创建以下`route.xml`定义：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we declare our bean in the Blueprint container. It means that the Blueprint
    container will use our class to create an instance of this bean and give it an
    ID.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在Blueprint容器中声明我们的bean。这意味着Blueprint容器将使用我们的类来创建此bean的实例并为其分配一个ID。
- en: When using the Blueprint DSL, Camel uses a Blueprint container registry; this
    means that Camel will lookup the beans using the ID in the Blueprint container.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Blueprint DSL时，Camel使用Blueprint容器注册表；这意味着Camel将使用Blueprint容器中的ID查找bean。
- en: Using Camel, DSL would use exactly the same behavior.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Camel，DSL将使用完全相同的行为。
- en: 'The `<route/>` element defines the following route:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`<route/>`元素定义了以下路由：'
- en: The route starts with a timer that creates an empty exchange every 5 seconds.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由从计时器开始，每5秒创建一个空交换。
- en: We define a static content Hello Chapter4 for the body of the `in` message using
    `<setBody/>`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`<setBody/>`定义静态内容Hello Chapter4作为`in`消息的正文。
- en: The exchange is sent to our bean. We use the Camel Bean component to directly
    call `myBean`. Camel will look for a bean named myBean in the Blueprint container.
    Once found, it will use the `doMyLogic()` method as it's the one with the `@Handler`
    annotation. Camel will bind the body of the in message with the `doMyLogic()`
    body parameter.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换被发送到我们的bean。我们使用Camel Bean组件直接调用`myBean`。Camel将在Blueprint容器中寻找名为myBean的bean。一旦找到，它将使用带有`@Handler`注解的`doMyLogic()`方法。Camel将绑定入消息的正文与`doMyLogic()`的正文参数。
- en: After the bean processor, we can see another use of the bean. This time, we
    use the bean (the same instance) to define the `myHeaderSetByTheBean` header of
    the in message. Here we use the `<method/>` syntax providing the `myBean` bean
    ID and the `setMyHeader()` method. Camel will look for the bean with the `myBean`
    ID in the Blueprint container, and it will call the `setMyHeader()` method. The
    return value of this method will be used to populate the `myHeaderSetByTheBean`
    header.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean处理器之后，我们可以看到bean的另一种使用。这次，我们使用bean（相同的实例）来定义入消息的`myHeaderSetByTheBean`头。在这里，我们使用`<method/>`语法提供`myBean`bean
    ID和`setMyHeader()`方法。Camel将在Blueprint容器中查找具有`myBean` ID的bean，并将调用`setMyHeader()`方法。此方法的返回值将用于填充`myHeaderSetByTheBean`头。
- en: Finally, we send the exchange to a log endpoint.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将交换发送到日志端点。
- en: Building and deploying
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署
- en: We are now ready to build our bundle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好构建我们的bundle。
- en: 'Using Maven, we run the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven，我们运行以下命令：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our bundle is now available in our local Maven repository (by default in the
    `.m2/repository` folder of the home directory).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的本地 Maven 仓库中找到我们的包（默认情况下位于主目录的 `.m2/repository` 文件夹中）。
- en: We can deploy this bundle in a Karaf OSGi container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个包部署到 Karaf OSGi 容器中。
- en: 'After having started Karaf (with `bin/karaf` script for instance), we add the
    Camel features using the `feature:repo-add` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Karaf（例如使用 `bin/karaf` 脚本）之后，我们使用 `feature:repo-add` 命令添加 Camel 功能：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We install the camel-blueprint feature:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装 camel-blueprint 功能：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now install our bundle and start it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安装我们的包并启动它：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can see that our routes are running, since we can see the log messages (using
    the `log:display` command):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的路由正在运行，因为我们可以看到日志消息（使用 `log:display` 命令）：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can see our route using the `camel:route-list` command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `camel:route-list` 命令查看我们的路由：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `camel:route-info` command gives details about our route, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`camel:route-info` 命令提供了关于我们路由的详细信息，如下所示：'
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Thanks to the bean support, it's possible to easily use an existing code in
    Camel routes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了豆子支持，我们可以在 Camel 路由中轻松使用现有代码。
- en: Moreover, with the wide range of annotations and the supported languages, you
    have complete control over the usage of your beans.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，凭借广泛的注释和所支持的语言，你可以完全控制你的豆子的使用。
- en: Using the DSL used to write the route definition, Camel knows on which system
    it's running, and so, it loads different bean registry implementations, making
    it possible to define the bean in a standard way.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编写路由定义所用的 DSL，Camel 知道它在哪个系统上运行，因此，它加载不同的豆子注册实现，使得以标准方式定义豆子成为可能。
- en: The Camel bean support is a great complement to the Camel processors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 豆子支持是 Camel 处理器的绝佳补充。
- en: If most of the EIPs that we will see in the next chapter are implemented using
    Camel processors, some EIPs can be implemented using a bean (such as MessageTranslator
    EIP).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将在下一章中看到的 EIP 的大部分都是使用 Camel 处理器实现的，那么一些 EIP 可以使用豆子实现（例如 MessageTranslator
    EIP）。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use beans in Camel routes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在 Camel 路由中使用豆子。
- en: First, we saw the different registries supported, where Camel looks for beans.
    Specifically, we saw the mapping between the Camel DSL used and the default registry
    loaded. We saw examples of different registries in action, including the composite
    registry. For this lookup, Camel acts as a service activator. The example showed
    how to leverage the Spring or Blueprint service registry.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到了 Camel 支持的不同注册表，Camel 在这些注册表中寻找豆子。具体来说，我们看到了 Camel DSL 与默认注册表加载之间的映射。我们看到了不同注册表在实际操作中的示例，包括组合注册表。对于这个查找，Camel
    充当服务激活器。示例展示了如何利用 Spring 或 Blueprint 服务注册表。
- en: We also saw the usage of the annotations to qualify the method and arguments
    binding. Those annotations can be combined with language annotations, allowing
    a very powerful way to populate method arguments.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了使用注解来限定方法和参数绑定的情况。这些注解可以与语言注解结合使用，允许以非常强大的方式填充方法参数。
- en: In the next chapter, we will see one of the Camel key features—routing and Enterprise
    Integration Patterns support. We will see ready-to-use processors and DSL implementing
    different EIPs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到 Camel 的一个关键特性——路由和企业集成模式支持。我们将看到可用于实现不同 EIP 的现成处理器和 DSL。
