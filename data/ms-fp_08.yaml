- en: Basic Type Classes and Their Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型类及其用法
- en: In the previous chapter, we discussed the idea of the type class and how type
    classes are a methodology for decoupling data from behavior. We have also seen
    how type classes can be treated as toolboxes that abstract away certain behavior.
    In essence, to a functional programmer, they are what a workshop is to a carpenter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了类型类的概念以及类型类是如何作为解耦数据与行为的方法论的。我们还看到了类型类如何被当作工具箱来抽象某些行为。本质上，对于一个函数式程序员来说，它们就像是木匠的工作室。
- en: In the previous chapters, we also saw how type classes are motivated based on
    the practical needs that arise during functional programming. In this chapter,
    we will see how an entire library of classes for functional programming arise
    from practical needs. We'll take a look at one such library, and we will see how
    typical libraries are structured and how they can be used in practice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们也看到了类型类是如何基于函数式编程中出现的实际需求来激发的。在这一章中，我们将看到整个函数式编程类库是如何从实际需求中产生的。我们将查看这样一个库，并了解典型库的结构以及它们在实际中的应用。
- en: 'The following are the topics that we will be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A motivation for organizing type classes into systems and libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型类组织成系统和库的动机
- en: The `Cats` library for purely functional programming and its structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数式编程的`Cats`库及其结构
- en: Type classes `Cats` defines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cats`类型类定义'
- en: A motivation for organizing type classes into systems and libraries
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型类组织成系统和库的动机
- en: The basic principle of engineering is abstracting away what repeats. In the
    previous chapters, we saw how functional programming deals with effect types extensively
    and encapsulates side effects into them. This is because working with them directly
    can be tedious. It is pretty hard to analyze these data structures in an ad hoc
    using only the services provided to you by your programming language of choice.
    Hence, patterns of working with effect types get abstracted away into type classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 工程学的基本原则是抽象掉重复的部分。在之前的章节中，我们看到了函数式编程如何广泛地处理效果类型并将副作用封装到它们中。这是因为直接处理它们可能会很繁琐。仅使用你选择的编程语言提供的服务来分析这些数据结构是非常困难的。因此，处理效果类型的模式被抽象到类型类中。
- en: So far, we have only seen a small amount of type classes. However, the most
    important thing to realize is the principle behind their creation, that is, realizing
    how the type classes get created and what the motivation is for their existence.
    The motivation for creating new type classes is precisely dealing with the complexity
    that side effects impose on the programmer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了一小部分类型类。然而，最重要的是要认识到它们背后的原则，即认识到类型类是如何被创建的以及它们存在的动机。创建新类型类的动机正是处理副作用给程序员带来的复杂性。
- en: We have also learned that the type class pattern consists of at least two parts.
    The first part is a declaration of the methods that are supported by the type
    class, and the second part is the implementation of the type class for the effect
    types you are going to work with. Certain effect types are embedded into the language's
    core. For example, in Scala, types such as `Future`, `Option`, and `Either` are
    present in the language core library by default. This means that you are going
    to be dealing with them frequently, and this, in turn, means that you will need
    the implementation of the type classes whenever you deal with these effect types.
    Basically, this means that you are going to redefine our implantation of type
    classes for these types every time you need them in different projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，类型类模式至少由两部分组成。第一部分是声明类型类支持的方法，第二部分是为你将要工作的效果类型实现类型类。某些效果类型被嵌入到语言的核心中。例如，在Scala中，`Future`、`Option`和`Either`等类型默认存在于语言核心库中。这意味着你将频繁地处理它们，这也意味着每次你处理这些效果类型时，都需要类型类的实现。基本上，这意味着每次你在不同的项目中需要这些类型时，你都将重新定义我们对这些类型的类型类实现。
- en: Whenever some functionality repeats from project to project, it makes sense
    to encapsulate it into a separate library. So, the preceding discussion shows
    that here, we have the situation where you have functionality that repeats from
    project to project. The first one is the type classes themselves that we use in
    multiple projects. For example, Monad deals with sequential composition, and sequential
    composition is frequent in both the functional and non-functional worlds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些功能从项目到项目重复出现时，将其封装到独立的库中是有意义的。因此，前面的讨论表明，这里我们遇到了从项目到项目重复出现功能的情况。第一个是我们在多个项目中使用的类型类本身。例如，Monad处理顺序组合，而顺序组合在函数式和非函数式世界中都很常见。
- en: Another item that repeats from project to project is the implementation of the
    type classes for frequently repeating effect types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在项目间重复的项目是频繁重复的效果类型的类型类实现。
- en: The preceding argument can be extended a little bit to the effect types themselves.
    Previously, we mentioned that the core libraries of functional languages usually
    include support for frequently encountered effect types. However, it is possible
    to imagine a situation where you're going to want to define the effect types yourself.
    For example, you may be dealing with some new effects that you want to encapsulate,
    or maybe you are going to define something that is specific to your own use case,
    and your own project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的论点可以稍微扩展到效果类型本身。之前我们提到，函数式语言的核心库通常包括对经常遇到的效果类型的支持。然而，可以想象一种情况，您可能需要自己定义效果类型。例如，您可能正在处理一些想要封装的新效果，或者您可能正在定义一些针对您自己的用例和项目的特定内容。
- en: With that, you'll notice that certain side effects that are not members of the
    core library start repeating from project to project. In this case, it would be
    wise to encapsulate them into a separate library, too. Of course, if you are frequently
    dealing with the same effect types that are not present in the language core,
    it is also a good idea to define the type class implementations for them in the
    library as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您会注意到某些不是核心库成员的副作用从项目到项目开始重复出现。在这种情况下，将它们封装到独立的库中是明智的。当然，如果您经常处理不在语言核心中的相同效果类型，那么在库中定义它们的类型类实现也是一个好主意。
- en: This is because whenever you need these effect types, you will also need the
    type classes to work with them. So, if you are going to encapsulate the effect
    types into a separate library, you will also need to encapsulate the type class
    implementations in that library as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为每当您需要这些效果类型时，您也将需要相应的类型类来与之配合。因此，如果您打算将这些效果类型封装到一个独立的库中，您也需要在该库中封装类型类的实现。 '
- en: 'To summarize the preceding argument, we need to encapsulate three things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的论点，我们需要封装三件事：
- en: The type class definitions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类定义
- en: The type class implementations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类实现
- en: The frequently encountered effect types that are not present in the language
    core and the type class implementations for them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些不在语言核心中且为它们提供类型类实现经常遇到的效果类型
- en: Such libraries for purely functional programming have been implemented for various
    programming languages. Now, let's take a look at what such a library may look
    like and how you can use it in practice. We will use a library called `Cats`,
    which comes from Scala.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些纯函数式编程的库已经为各种编程语言实现了。现在，让我们看看这样一个库可能的样子以及您如何在实践中使用它。我们将使用一个名为`Cats`的库，它来自Scala。
- en: The Cats library for purely functional programming
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于纯函数式编程的Cats库
- en: In this section, we will introduce the library that we will be using for purely
    functional programming in Scala. It encapsulates frequently encountered type classes,
    implementations of them for frequently encountered effect types, and some effect
    types as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们将用于Scala纯函数式编程的库。它封装了经常遇到类型类、它们为经常遇到的效果类型提供的实现，以及一些效果类型本身。
- en: In this section, we will dive deeper into the structure of the library, and
    we will see how you can use it in practice. We will be following an example of
    a `Monad` type class that we discussed in the previous chapters. We will see how
    this type class is defined in this library and how it is implemented for its data
    types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨库的结构，并展示您如何在实践中使用它。我们将以之前章节中讨论过的`Monad`类型类为例。我们将看到这个类型类在这个库中的定义以及它是如何为其数据类型实现的。
- en: The structure of the library
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的结构
- en: 'The library consists of the top-level package and its subpackages. The top-level
    package is called `cats` and is a location where basic type classes are defined:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 库由顶级包及其子包组成。顶级包被称为`cats`，是定义基本类型类的地方：
- en: '![](img/57e96392-216e-4c9e-8d27-bde045a1f7c9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57e96392-216e-4c9e-8d27-bde045a1f7c9.png)'
- en: Apart from that, there are several subpackages present in the top-level package.
    The most important ones are `instances`, `data`, and `syntax`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，顶级包中还有几个子包。其中最重要的是`instances`、`data`和`syntax`。
- en: The `instances` package contains the implementations of the type classes for
    basic data types that are present in the language core and the ones defined by
    the `Cats` library. Finally, data types that are frequently encountered and absent
    from the language core are defined under the `data` package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`instances`包包含了语言核心和`Cats`库定义的基本数据类型的类型类实现。最后，在`data`包下定义了经常遇到但不在语言核心中的数据类型。'
- en: We will now take a look at each of these structural pieces in detail. We will
    start from the top level package, that is, `cats`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细查看这些结构元素中的每一个。我们将从顶级包开始，即`cats`。
- en: Core
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心部分
- en: 'The core package, `cats`, of the library exposes the following API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 库的核心包`cats`公开了以下API：
- en: '![](img/89caab0d-1699-4481-89fd-58c3aa51e29a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89caab0d-1699-4481-89fd-58c3aa51e29a.png)'
- en: The core package contains a list of all the type classes that are defined by
    the library. The type classes pattern in the `Cats` implementation usually consists
    of a trait and its companion object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 核心包包含由库定义的所有类型类的列表。在`Cats`实现中，类型类模式通常由一个特质及其伴随对象组成。
- en: 'Let''s use an example of `Monad` to take a look at what a typical type class
    looks like in the context of the library:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个`Monad`的例子来看看在库的上下文中一个典型的类型类是什么样的：
- en: '![](img/3c0d41ca-1195-4e93-9f52-67a917eca5ca.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c0d41ca-1195-4e93-9f52-67a917eca5ca.png)'
- en: Let us now take a closer look at how the type classes in the type class hierarchy
    of `Cats` are structured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来更详细地看看`Cats`类型类层次结构中的类型类是如何构建的。
- en: Type class hierarchy
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类层次结构
- en: The first thing to notice here is that the type classes are defined in the format
    that we saw in the previous chapter. Another thing to notice is the hierarchy
    of type classes in the `Cats` library. So, for example, the `Monad` class extends
    the `FlatMap` and `Applicative` type classes, and if you take a look at the linear
    super types of the type class, you will see that the ancestors are far more numerous.
    Also, if you have a look at the subclasses, you will notice that a number of type
    classes also extend the `Monad` type class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的是，类型类是以我们在上一章中看到的形式定义的。另一个要注意的是`Cats`库中类型类的层次结构。例如，`Monad`类扩展了`FlatMap`和`Applicative`类型类，如果你查看类型类的线性超类型，你会看到祖先类非常多。此外，如果你查看子类，你会注意到许多类型类也扩展了`Monad`类型类。
- en: The reason for this hierarchy is that the `Cats` library is quite fine-grained.
    We previously discussed that type classes can be treated as containers for methods
    that you're going to use. Type classes such as `Monad` may define several methods
    at once. Therefore, it may be reasonable to have a separate type class for each
    of the method. Let us now discuss the abstract methods that `Monad` defines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层次结构的原因是`Cats`库非常细粒度。我们之前讨论过，类型类可以被看作是用于方法的容器。例如，`Monad`类型类可以一次性定义多个方法。因此，为每个方法定义一个单独的类型类似乎是合理的。现在让我们讨论`Monad`定义的抽象方法。
- en: Abstract methods
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象方法
- en: Let's take a look at the *value member* section of the Scaladoc documentation
    of the `Monad` implementation by `Cats`. The abstract members section is the most
    important section of any type cause definition. A type class is a declaration
    of certain tools, and its concrete instances must support these tools. They are
    declared, but not implemented in the type class trait. So, the abstract methods
    defined by a type class constitute a definition of this type class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Cats`实现的`Monad`的Scaladoc文档的`value member`部分。抽象成员部分是任何类型定义最重要的部分。类型类是一系列工具的声明，其具体实例必须支持这些工具。它们在类型类特质中声明，但没有实现。因此，类型类定义的抽象方法构成了这个类型类的定义。
- en: 'Concretely, in the case of Monad, we have three abstract methods, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在`Monad`的情况下，我们有三个抽象方法，如下所示：
- en: There is a `flatMap` method, which we are already familiar with.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`flatMap`方法，我们已经很熟悉了。
- en: The pure method is able to lift any value into an effect type of `F`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯方法能够将任何值提升到 `F` 的效果类型。
- en: There is a `tailRecM` and type class. It is a tail recursive Monadic loop. The
    intuition for this method is as follows. Monad's `flatMap` defines a sequential
    composition of effectful computations. Where there is a sequence, a loop may also
    be desirable. A loop is a sequence of instructions that repeat over and over.
    Therefore, a loop is built on top of the sequential composition. If you define
    the sequential composition, you can use it to also define the loop. The role of
    `tailRecM` is to provide such a loop for the functional programming under effect
    types. You can think of it as a `while` loop of pure functional programming. We
    will discuss this method in more detail later on in the chapter.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个 `tailRecM` 和类型类。它是一个尾递归的 Monadic 循环。这个方法的直觉如下。Monad 的 `flatMap` 定义了效果计算的可序列组合。在有序列的情况下，也可能需要循环。循环是一系列重复执行的指令。因此，循环建立在序列组合之上。如果你定义了序列组合，你可以用它来定义循环。`tailRecM`
    的作用是为效果类型下的函数式编程提供一个这样的循环。你可以把它看作是纯函数式编程的 `while` 循环。我们将在本章后面更详细地讨论这个方法。
- en: Concrete methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体方法
- en: Besides abstract methods, the `Monad` type class provides a bunch of predefined
    concrete value members. These are implemented by default in the type class, so
    when you define the type class instance, you do not need to provide the implementation
    of these value members. Their definitions are based on the abstract value members
    that we saw previously. This means that every method that you encounter under
    concrete value members can be defined in terms of the abstract value members we
    saw previously.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抽象方法之外，`Monad` 类型类提供了一组预定义的具体值成员。这些成员默认在类型类中实现，因此当你定义类型类实例时，不需要提供这些值成员的实现。它们的定义基于我们之前看到的抽象值成员。这意味着你可以用之前看到的抽象值成员来定义在具体值成员下遇到的每个方法。
- en: 'It is very common for concrete value members to contain methods that are abstract
    value members in a superclass of the type class in question. Take, for example,
    the `map` method, which we are already familiar with. Technically, it comes as
    an abstract member of the `Functor` type class. However, it is possible to define
    a type class in terms of only `flatMap` and pure functions. These two functions
    are abstract members of the `Monad` class, and hence we can override the inherited
    `map` function with a concrete implementation of it, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 具体值成员通常包含在类型类的超类中的抽象值成员的方法是很常见的。以我们已熟悉的 `map` 方法为例。技术上，它作为 `Functor` 类型类的抽象成员。然而，可以仅用
    `flatMap` 和纯函数来定义类型类。这两个函数是 `Monad` 类的抽象成员，因此我们可以用具体的实现来覆盖继承的 `map` 函数，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, you can see how exactly that function can be
    implemented when you have `flatMap` and `pure` functions. A word of caution, that
    this kind of implementation based on the `flatMap` and `pure` functions is not
    always desirable. There are situations where you will want to have a custom implementation
    of the functions that can be implemented in terms of the abstract methods. In
    some scenarios, reusing the functionality that you already have is not always
    the best solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到当你有 `flatMap` 和 `pure` 函数时，这个函数是如何实现的。提醒一下，基于 `flatMap` 和 `pure`
    函数的这种实现并不总是可取的。有些情况下，你可能希望有一个自定义的函数实现，这些函数可以用抽象方法来实现。在某些场景中，重用你已有的功能并不总是最佳解决方案。
- en: The intuition for this logic is as follows. We have already discussed that sequential
    composition in pure functional programming is facilitated by Monad. Later in this
    chapter, we will see a type class that has been designed for parallel composition.
    The operator to compose two computationals in parallel can be implemented in two
    ways. One way is what you would expect from real parallelism. It performs computations
    independently. For example, if one computation fails, the other computation will
    still continue and will still produce a value. However, it is possible to implement
    the parallel composition operator with the help of sequential composition. You
    may have an implementation of such a composition that just composes two computations
    sequentially, although you will have it named as a parallel composition operator.
    So, if you have a sequential composition operator such as `flatMap`, a naive parallel
    composition operator will be defined as a sequential composition of the computations
    using this sequential composition operator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种逻辑的直觉如下。我们已经讨论过，在纯函数式编程中，序列组合是由 Monad 促成的。在本章的后面，我们将看到一个为并行组合设计的类型类。并行组合两个计算的操作符可以有两种实现方式。一种方式是你从真正的并行性中期望的方式。它独立执行计算。例如，如果一个计算失败，另一个计算仍然会继续，并且仍然会产生一个值。然而，可以使用序列组合来帮助实现并行组合操作符。你可能有一个这样的组合实现，它只是顺序地组合两个计算，尽管你可能会将其命名为并行组合操作符。所以，如果你有一个如`flatMap`这样的序列组合操作符，一个简单的并行组合操作符将被定义为使用这个序列组合操作符对计算进行序列组合。
- en: The reason we are having this discussion is that Monad inherits from the Applicative
    type class. The Applicative type class was designed for parallel computation.
    It contains a method called `ap` that is designed to compose computations in parallel.
    However, when we discussed the `Monad` type class in the past, we did not see
    this method among the abstract members. This is because it is a concrete member
    of the `Monad` type class, which means that it was implemented using the methods
    defined by Monad—the `flatMap` and the `pure` functions. In practice, it means
    that if you want to perform a parallel composition, you may be able to, depending
    on either the Monad or Applicative type class. However, if you depend on Monad,
    you may not get true parallelism, since its parallelism operator may be implemented
    in terms of sequential composition. So, it is very important to understand the
    mechanics of type classes and not to treat them as something magical because you
    might be in for an unexpected error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这次讨论的原因是，Monoid 继承自 Applicative 类型类。Applicative 类型类是为并行计算设计的。它包含一个名为`ap`的方法，该方法旨在并行组合计算。然而，当我们过去讨论`Monad`类型类时，我们没有看到这个方法在抽象成员中。这是因为它是`Monad`类型类的具体成员，这意味着它是使用由
    Monad 定义的`flatMap`和`pure`函数实现的。在实践中，这意味着如果你想要执行并行组合，你可能能够做到，这取决于 Monad 或 Applicative
    类型类。然而，如果你依赖于 Monad，你可能不会得到真正的并行性，因为它的并行操作符可能是以序列组合的形式实现的。因此，理解类型类的机制非常重要，不要将它们视为某种神奇的东西，因为你可能会遇到意外的错误。
- en: Type classes have a solid mathematical foundation in the form of Category Theory.
    We will not be discussing the theory in this pragmatic guide to functional programming.
    However, in the next section, we will touch upon the mathematical nature of type
    classes and discuss which mathematical laws they must obey.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类在形式上有一个坚实的数学基础，即范畴论。我们不会在这个关于函数式编程的实用指南中讨论这个理论。然而，在下一节中，我们将触及类型类的数学性质，并讨论它们必须遵守的数学定律。
- en: Laws
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法则
- en: Type classes are defined in terms of the methods they support. When defining
    a type class, you do not have an idea of how exactly the methods will be implemented
    for every given data type. However, you do have a rough idea of what these methods
    will do. For example, we have a rough idea that `flatMap` is responsible for sequential
    composition, and pure corresponds to lifting a value into an effect type without
    doing anything else.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是通过它们支持的方法来定义的。在定义一个类型类时，你并没有一个确切的想法知道对于每一个给定的数据类型，这些方法将如何具体实现。然而，你确实有一个大致的概念，了解这些方法将做什么。例如，我们有一个大致的概念，认为`flatMap`负责序列组合，而纯函数对应于将一个值提升到效果类型而不做其他任何事情。
- en: This kind of information regarding how the methods should behave can be encapsulated
    in terms of the mathematical laws that the type class must obey. In fact, the
    majority of type classes can be viewed from a mathematical perspective, and so
    there are certain laws that they must obey.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关于方法应该如何表现的信息可以通过类型类必须遵守的数学定律来封装。实际上，大多数类型类都可以从数学的角度来观察，因此它们必须遵守某些定律。
- en: 'Let''s take a look at the laws that Monads must obey. There are three of them,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Monads必须遵守的定律。共有三个，如下所示：
- en: '**Left identity**: `pure(a).flatMap(f) == f(a)`. This means that if you have
    a raw value, `a`, and a function, `f`, which takes that value as an input and
    computes an effect type out of it, the effect of applying this function directly
    on `a` should be the same as if you first used the `pure` function on `a` and
    flatMapped the result with `f`.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**左单位定律**：`pure(a).flatMap(f) == f(a)`。这意味着如果你有一个原始值`a`和一个函数`f`，该函数接受这个值作为输入并从中计算出一个效果类型，那么直接在`a`上应用这个函数的效果应该与首先在`a`上使用`pure`函数然后与`f`扁平映射的结果相同。'
- en: '**Right identity**: `m.flatMap(pure) == m`. This means that a pure function
    must lift a value into the effect type without performing any other action. The
    effect of this function is nil. This also means that if you are using the `flatMap`
    function on pure, pure must behave as an identity, meaning the effect type you
    flatMapped will be equal to the result of flatMapping.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**右单位定律**：`m.flatMap(pure) == m`。这意味着一个纯函数必须将一个值提升到效果类型中，而不执行任何其他操作。这个函数的效果是空的。这也意味着如果你在纯函数上使用`flatMap`函数，纯函数必须表现得像一个恒等函数，这意味着你扁平映射的效果类型将等于扁平映射的结果。'
- en: '**Associativity**: `m.flatMap(f).flatMap(g) == m.flatMap(a => f(a).flatMap(g))`.
    Basically, this law states that the precedence of the `flatMap` application do
    not matter. Think of the associativity in the context of the `+` operator—`(a
    + b) + c == a + (b + c)`.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合律**：`m.flatMap(f).flatMap(g) == m.flatMap(a => f(a).flatMap(g))`。基本上，这个定律表明`flatMap`应用的优先级并不重要。将结合律与`+`操作符的上下文联系起来思考——`(a
    + b) + c == a + (b + c)`。'
- en: For the majority of type classes out there, you should expect some mathematical
    laws to be defined. The meaning of them is that they provide certain guarantees
    that you can rely on when programming your software. For every concrete implementation
    of the `Monad` type class, the preceding mathematical laws must hold true. For
    any other type class, all of its implementations must obey its own laws.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数类型类，你应该期待定义一些数学定律。它们的含义是，它们为你提供了在编写软件时可以依赖的某些保证。对于`Monad`类型类的每个具体实现，前面的数学定律必须成立。对于任何其他类型类，所有其实现都必须遵守其自己的定律。
- en: Since there is a requirement for every type class implementation to obey certain
    laws, it is reasonable to expect that all of your implementations must be tested
    with respect to these laws. Since the laws are not dependent on a particular implementation
    of a type class and should hold true for every implementation of the type class,
    it is also reasonable to have the tests defined in the same library that defines
    the type classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个类型类实现都必须遵守某些定律，因此合理地预期所有实现都必须根据这些定律进行测试。由于定律不依赖于类型类的特定实现，并且应该对类型类的每个实现都成立，因此将这些测试定义在定义类型类的同一库中也是合理的。
- en: We do this so that we do not need to redefine these tests every time. Indeed,
    these tests are defined in a separate module of the `Cats` library—`cats-laws`.
    The module defines the laws for every cats type class and provides an integration
    with the majority of popular test frameworks so that once you define your own
    implementation of a type class, you do not need to define the tests to check this
    implementation against the mathematical laws.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了我们不必每次都重新定义这些测试。实际上，这些测试是在`Cats`库的单独模块`cats-laws`中定义的。该模块为每个`cats`类型类定义了定律，并提供与大多数流行测试框架的集成，这样一旦你定义了自己的类型类实现，你就不需要定义测试来检查这个实现是否与数学定律相符。
- en: 'For example, this is how tests for Monad are defined:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是定义`Monad`测试的方式：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let us discuss how to use methods defined by `Monad` conveniently from
    the Scala code with `Cats`. Let us have a look at what infrastructure `Cats` provides
    to expose methods on effect types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何使用`Cats`库方便地从Scala代码中调用由`Monad`定义的方法。让我们看看`Cats`提供了哪些基础设施来暴露效果类型上的方法。
- en: Syntax
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: We should mention here that the requirement to use the implicit mechanism with
    a *Rich Wrapper* pattern is a requirement that's specific to Scala. Scala is a
    language that mixes object-oriented and purely functional styles. This is why
    certain functional programming features such as type classes are not a part of
    the language and are implemented in a more generic way instead. This means that
    in Scala, method injection and the type class pattern are not first-class citizens.
    They are not defined at the language level. Instead, they leverage a more general
    mechanism that is defined on the class level—the implicit mechanism. Hence, in
    order to seamlessly use type classes in a Scala project, you need to use this
    mechanism so that they take effect manually.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里应该提到，使用具有 *Rich Wrapper* 模式的隐式机制的要求是Scala特有的。Scala是一种混合面向对象和纯函数式风格的编程语言。这就是为什么某些函数式编程特性，如类型类，不是语言的一部分，而是以更通用的方式实现的。这意味着在Scala中，方法注入和类型类模式不是一等公民。它们不是在语言级别定义的。相反，它们利用在类级别定义的更通用机制——隐式机制。因此，为了在Scala项目中无缝使用类型类，你需要使用这种机制，以便它们能够手动生效。
- en: A note should be taken that this may not be true for other functional languages.
    For example, Haskell has language-level support for the type class style of programming.
    This is why you don't need to bother with method injection. This is because the
    language itself does all of the necessary work for you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这可能不适用于其他函数式语言。例如，Haskell对类型类编程风格有语言级别的支持。这就是为什么你不需要担心方法注入。这是因为语言本身为你做了所有必要的工作。
- en: However, languages such as Scala that do not have first-class citizen support
    for style may require you to use such a mechanism. The exact approaches to type
    class programming may vary from language to language. In this section, we will
    take a look at how this works for Scala.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像Scala这样的语言，它们可能没有对风格的一等公民支持，可能需要你使用这样的机制。类型类编程的确切方法可能因语言而异。在本节中，我们将探讨这对于Scala是如何工作的。
- en: 'We previously discussed that method injection in Scala happens with the help
    of the implicit mechanism and the *Rich Wrapper* pattern. Since this kind of mechanism
    to inject methods is defined for every type class, it makes sense to define the
    required Rich Wrappers in the `Cats` library together with all of the type classes.
    This is indeed done in the `Cats` library, in the `syntax` package, like following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，Scala中的方法注入是通过隐式机制和 *Rich Wrapper* 模式实现的。由于这种注入方法的机制是为每个类型类定义的，因此将所需的Rich
    Wrappers与所有类型类一起定义在 `Cats` 库中是有意义的。这确实在 `Cats` 库中实现了，在 `syntax` 包中，如下所示：
- en: '![](img/4a746d62-f06f-4c52-90e1-b2f9fd93c7fb.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a746d62-f06f-4c52-90e1-b2f9fd93c7fb.png)'
- en: The package contains a set of classes and traits. What you need to notice are
    the naming conventions they follow. You will see that lots of the traits and classes
    end in `Ops` and `Syntax`, for example, `MonadOps` or `MonadSyntax`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含一系列类和特质。你需要注意它们遵循的命名约定。你会看到许多特性和类以 `Ops` 和 `Syntax` 结尾，例如，`MonadOps` 或 `MonadSyntax`。
- en: Besides classes and traits, you will also notice a set of singleton objects
    are present in this package. The names of these objects mimic the names of the
    type classes they are defined for.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类和特质之外，你还会注意到这个包中存在一组单例对象。这些对象的名称模仿了它们定义的类型类的名称。
- en: 'Let''s take a look at how this mechanism works for the `Monad` type class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种机制是如何在 `Monad` 类型类中工作的：
- en: '![](img/73859f8e-f26d-4159-a9de-a7e3e4a1a574.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73859f8e-f26d-4159-a9de-a7e3e4a1a574.png)'
- en: First, let's take a look at the `MonadOps` class. This is a Rich Wrapper that
    is supposed to be used for `Monad` method injection. It injects the methods provided
    by the `Monad` type class into an effect type, `f`. One thing to notice about
    the methods it injects is that all of them have an implicit `Monad` argument.
    They delegate their implementation to this type class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `MonadOps` 类。这是一个Rich Wrapper，用于 `Monad` 方法注入。它将 `Monad` 类型类提供的方法注入到效果类型
    `f` 中。关于它注入的方法，有一点需要注意，那就是所有这些方法都有一个隐式的 `Monad` 参数。它们将其实施委托给这个类型类。
- en: 'However, the `MonadOps` class is not an implicit class—it is an ordinary class.
    We learned previously that for the *Rich Wrapper* pattern, we need an implicit
    conversion from an effect type to the Rich Wrapper. So, where is this conversion
    defined, and how is it brought into scope? To find out, let''s take a look at
    the `MonadSyntax` trait:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`MonadOps` 类不是一个隐式类——它是一个普通类。我们之前了解到，对于 *Rich Wrapper* 模式，我们需要从效果类型到 Rich
    Wrapper 的隐式转换。那么，这个转换在哪里定义的，又是如何引入作用域的？为了找出答案，让我们看一下 `MonadSyntax` 特质：
- en: '![](img/074e0741-687d-457e-a8e2-14cc3aefbf88.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/074e0741-687d-457e-a8e2-14cc3aefbf88.png)'
- en: As you can see, the `MonadSyntax` contains implicit methods. These are supposed
    to convert any object, `F[A]`, into `MonadOps[F[A]]`. However, how do you bring
    the methods into scope?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`MonadSyntax` 包含隐式方法。这些方法本应将任何对象 `F[A]` 转换为 `MonadOps[F[A]]`。然而，你如何将这些方法引入作用域？
- en: 'For this, let''s take a look at the Monad singleton:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，让我们看一下 Monad 单例：
- en: '![](img/1332acf1-bb04-4a99-b52a-3a0bcec796c2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1332acf1-bb04-4a99-b52a-3a0bcec796c2.png)'
- en: As you can see in the preceding screenshot, the singleton extends the `MonadSyntax`
    trait. So basically, this is a concrete implementation of the `MonadSyntax` trait.
    You can import all of the contents of this object, and you will have the Rich
    Wrapper for `MonadOps`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，单例扩展了 `MonadSyntax` 特质。所以这基本上是 `MonadSyntax` 特质的具体实现。你可以导入这个对象的所有内容，并将
    `MonadOps` 的 Rich Wrapper 包含在内。
- en: Why is it implemented as a combination of a singleton and a trait? Would it
    not be more convenient to implement the Rich Wrapper as one singleton object that
    contains all of the required methods?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它被实现为单例和特质的组合？将 Rich Wrapper 实现为一个包含所有必需方法的单例对象不是更方便吗？
- en: This can be understood if you take a look at the sheer amount of singleton objects
    present in the `syntax` package. If you are using a lot of type classes in a single
    Scala file, all of the imports for each type class can be tedious to write and
    track. Hence, you might want to just bring in scope the syntax for all available
    type classes at once, even though you will never use the majority of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `syntax` 包中存在的单例对象的数量，这可以理解。如果你在一个 Scala 文件中使用很多类型类，每个类型类的所有导入都可能很繁琐，难以编写和跟踪。因此，你可能希望一次性引入所有可用类型类的语法，即使你永远不会使用其中大部分。
- en: 'Precisely for this reason, there is an `all` singleton object, as shown in
    the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，存在一个 `all` 单例对象，如下截图所示：
- en: '![](img/51ef1905-4d96-45f3-a975-db8a94c2971a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51ef1905-4d96-45f3-a975-db8a94c2971a.png)'
- en: If you take a look at this object and its supertypes, you'll see that its ancestors
    constitute a massive list. They include all of the syntax traits defined in the
    package. This means that this singleton object contains all of the implicit conversion
    from effect types to Rich Wrappers that inject methods defined in the type classes
    into the effect types in question. You can import all of the contents of this
    object into your project and have all of these implicit conversions in scope.
    This is exactly why we define implicit conversions inside the trait and not inside
    singleton objects. If you define these implicit conversions as part of singleton
    objects, you will not be able to combine these singleton objects into one object,
    because you cannot inherit from a singleton object. However, you can inherit from
    multiple traits in Scala. Therefore, the reason for having traits is modularity
    and composability.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个对象及其超类型，你会发现其祖先构成一个庞大的列表。它们包括在包中定义的所有语法特性。这意味着这个单例对象包含了从效果类型到 Rich Wrappers
    的所有隐式转换，这些 Rich Wrappers 将类型类中定义的方法注入到相关效果类型中。你可以将这个对象的所有内容导入到你的项目中，并使所有这些隐式转换在作用域内。这正是我们在特质内部而不是在单例对象内部定义隐式转换的原因。如果你将这些隐式转换定义为单例对象的一部分，你将无法将这些单例对象组合成一个对象，因为你不能从单例对象继承。然而，在
    Scala 中你可以从多个特质继承。因此，特质存在的原因是模块化和可组合性。
- en: 'To summarize, the `Cats` library contains two major components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Cats` 库包含两个主要组件：
- en: It contains the Rich Wrapper classes that wrap effect types and inject methods
    defined by the type classes into these effect types
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含包装效果类型并注入类型类定义的方法的 Rich Wrapper 类
- en: It contains implicit conversions from these effect types to the Rich Wrapper
    classes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含从这些效果类型到 Rich Wrapper 类的隐式转换
- en: Later in this chapter, we will see examples of how to use these capabilities
    in practice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何在实际中利用这些功能。
- en: Next, let's take a look at the structure and the purpose of the `instances`
    package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`instances`包的结构和目的。
- en: Instances
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例
- en: 'The `instances` package exposes the following API:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`instances`包公开了以下API：'
- en: '![](img/af1ffeec-e2b4-40b3-91b0-7abca12e0880.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af1ffeec-e2b4-40b3-91b0-7abca12e0880.png)'
- en: As you can see from the preceding screenshot, the `instances` package contains
    quite a lot of entities. As in the case of the `syntax` package, the main thing
    to notice here is the naming convention of these entities. First, we have a set
    of traits and classes. They are named as follows—the first part of the name is
    the name of the type for which the instances are defined, and then there's the
    `Instances` suffix.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`instances`包包含相当多的实体。与`syntax`包的情况一样，这里要注意的主要是这些实体的命名约定。首先，我们有一组特性和类。它们的命名如下——名称的第一部分是定义实例的类型名称，然后是`Instances`后缀。
- en: There are also singleton objects, which are named after the types for which
    the instances are defined.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也存在一些单例对象，它们的名称与定义实例的类型相对应。
- en: 'Let''s take a look at what one of the instances traits looks like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实例特质的一个样子：
- en: '![](img/8398a71f-5910-43e2-9d41-37fd43946f58.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8398a71f-5910-43e2-9d41-37fd43946f58.png)'
- en: In the preceding screenshot, you can see the structure of the `FutureInstances`
    trait. All of the methods are defined as `implicit` methods, which means they
    will be brought into the implicit scope whenever the members of this trait are
    imported. Another important thing to notice is the result types of the methods.
    These result types are all some kind of type class. It is the meaning of these
    methods to provide the implicit implementations of various type classes for a
    given effect type. Also notice that the trait contains a lot of methods for various
    type classes, but all of them are parametrized by the `Future` type. All of the
    type classes are implemented for this effect type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图中，你可以看到`FutureInstances`特质的结构。所有的方法都被定义为`implicit`方法，这意味着每当导入这个特质的成员时，它们都会被带入隐式作用域。另一个需要注意的重要事情是方法的返回类型。这些返回类型都是某种类型类。这些方法的含义是为给定效果类型提供各种类型类的隐式实现。还要注意，特质包含了许多针对各种类型类的方法，但它们都是通过`Future`类型参数化的。所有类型类都为此效果类型实现了。
- en: 'Similarly to the case of the `syntax` package, the traits are then used to
    create singleton objects. For example, let''s take a look at the `future` singleton:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与`syntax`包的情况类似，特质随后被用来创建单例对象。例如，让我们看看`future`单例：
- en: '![](img/4bb931b8-754c-4440-a36a-c97d9c48bf18.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bb931b8-754c-4440-a36a-c97d9c48bf18.png)'
- en: 'The `future` singleton object extends the `FutureInstances` trait, and the
    same pattern repeats for all of the other singleton objects present in the `instances`
    package. The reason for having the singletons extending the traits is similar
    to the situation with the `syntax` package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`future`单例对象扩展了`FutureInstances`特质，同样的模式也适用于`instances`包中存在的所有其他单例对象。单例扩展特质的理由与`syntax`包的情况类似：'
- en: '![](img/bc1a769f-6656-47ae-a76d-d46b9d0b40ee.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc1a769f-6656-47ae-a76d-d46b9d0b40ee.png)'
- en: The package also defines an `all` singleton object, which extends all of the
    other traits present in the package. The value of this strategy is that in order
    to bring the standard implementations of type classes in scope, all you need to
    do is import the contents of the `all` object. You do not need to import the implementation
    separately for every type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还定义了一个`all`单例对象，它扩展了包中存在的所有其他特质。这个策略的价值在于，为了将标准类型类的实现纳入作用域，你只需要导入`all`对象的内容即可。你不需要为每个类型单独导入实现。
- en: Finally, let's take a look at the last essential part of the `Cats` library,
    that is, the `data` package.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`Cats`库的最后一部分，也就是`data`包。
- en: Data
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: 'Let us now discuss the `data` package, which is another package you will use
    a lot in daily functional programming with `Cats`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下`data`包，这是你在使用`Cats`进行日常函数式编程时经常会用到的另一个包：
- en: '![](img/6ba84616-5235-4e68-87b5-0701bae792c6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ba84616-5235-4e68-87b5-0701bae792c6.png)'
- en: Previously, we discussed that the main utility of having a library such as `cat`
    is to abstract away the common type classes for functional programming. We have
    also seen that not only do the type classes get abstracted, but also all of the
    various kinds of supporting stuff to use them in practice efficiently. This supporting
    stuff includes the mechanism for syntax injection and the default implementations
    for commonly encountered effect types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了拥有像`cat`这样的库的主要效用是抽象出函数式编程的常见类型类。我们还看到，不仅类型类被抽象化，而且还有各种支持性内容，以便在实践中使用它们时效率更高。这些支持性内容包括语法注入机制和常见效果类型的默认实现。
- en: A final piece of the supporting infrastructure that cats provides is a set of
    common effect types. These are encapsulated under the `data` package. Under this
    package, you will encounter various data types that you can use to express your
    side effects in a purely functional way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 猫提供的支持性基础设施的最后一部分是一组常见的效果类型。这些类型封装在`data`包下。在这个包下，你会遇到各种数据类型，你可以用它们以纯函数式的方式表达你的副作用。
- en: For example, there are data types such as `Reader`, `Writer`, and others. The
    effect types are often not related one to another, and you can really use each
    of them independently.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有如`Reader`、`Writer`等其他数据类型。效果类型通常彼此不相关，你可以真正独立地使用每一个。
- en: Infrastructure synergy
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施协同
- en: In this section, we have seen how cats defines its type classes and how it can
    be used in functional programming. The main points to understand about the `Cats`
    library are regarding the supporting infrastructure that it provides to you as
    a functional programmer, and how exactly to use it in practice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了猫是如何定义其类型类以及如何在函数式编程中使用它们。关于`Cats`库需要理解的主要点是其为你这个函数式程序员提供的支持性基础设施，以及如何在实践中具体使用它。
- en: The supporting infrastructure in questions provides a set of the type classes,
    their implementations for the commonly encountered data types, and a mechanism
    to inject their methods into your effect types. Also, cats provides a set of commonly
    encountered effect types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关的支持性基础设施提供了一组类型类，它们对常见数据类型的实现，以及将它们的方法注入你的效果类型中的机制。此外，cats还提供了一组常见的效果类型。
- en: The library is very modular, and you can use various parts of it independently
    from the rest of the library. So, it is a good strategy for beginner programmers
    so that they can simply start with one or two basic type classes and use the library
    to bring them in scope. As you gradually progress as a functional programmer,
    you will start to pick up and familiarize yourself with more and more type classes
    and chunks of this library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该库非常模块化，你可以独立于库的其他部分使用它的各个部分。因此，对于初学者程序员来说，这是一个很好的策略，他们可以简单地从一两个基本类型类开始，并使用库将它们纳入范围。随着你作为函数式程序员逐渐进步，你将开始挑选并熟悉越来越多的类型类和库的各个部分。
- en: In this section, we have familiarized ourselves with the general structure of
    the `Cats` library. In the rest of this chapter, we will familiarize ourselves
    with certain commonly encountered type classes. We will see how to use them in
    practice. We will also have a look at some of the mechanics for how the type classes
    are implemented.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们熟悉了`Cats`库的一般结构。在本章的其余部分，我们将熟悉某些常见类型类。我们将了解如何在实践中使用它们。我们还将查看类型类是如何实现的某些机制。
- en: Type classes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: So far, we have performed a bird's-eye overview of the `Cats` library and its
    structure. In this section, we'll have a look at some individual type classes
    from the `Cats` library that are frequently used in real-world projects. For every
    such type class, will take a look at the motivation as to why it exists. We will
    discuss their methods and behavior in detail. We will also take a look at examples
    of the usage of the type class. Finally, we will take a look at the implementation
    of the type class for various effect types, and take a look at how the class is
    implemented for popular types so that you have an idea of what an implementation
    of the type class might look like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对`Cats`库及其结构进行了鸟瞰。在本节中，我们将查看`Cats`库中一些在现实项目中经常使用的单个类型类。对于每一个这样的类型类，我们将探讨其存在的动机。我们将详细讨论它们的方法和行为。我们还将查看类型类的使用示例。最后，我们将查看为各种效果类型实现类型类的方法，并查看该类是如何为流行类型实现的，以便你有一个关于类型类实现可能外观的印象。
- en: Monad
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态
- en: Let us have a look at how you can use type classes from the `Cats` library on
    an example of `Monad`, the type class we are already familiar with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 `Monad` 类型类的一个例子中使用来自 `Cats` 库的类型类，我们已经熟悉这个类型类。
- en: In the previous sections, in order to use a `Monad` type class, we defined it
    as ad hoc. However, the `Cats` library provides all of the abstractions we need
    so that we don't need to define this type class and its syntax ourselves.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，为了使用 `Monad` 类型类，我们将其定义为临时性的。然而，`Cats` 库提供了我们需要的所有抽象，这样我们就不需要自己定义这个类型类及其语法。
- en: 'So, how do you use the `Monad` type class in the context of the logging example
    from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea of the
    Type Classes*? As you may recall, in that chapter, we took a look at an example
    of logging capabilities and discussed that it is a good example of the sequential
    composition that can be handled by Monad. So, let''s take a look at how this can
    be done with `cats`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在 [第7章](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml)，“类型类概念”的日志记录示例中使用 `Monad`
    类型类呢？如你所回忆，在那个章节中，我们查看了一个日志能力的例子，并讨论了它是 Monad 可以处理的顺序组合的一个好例子。所以，让我们看看如何使用 `cats`
    来实现这一点：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First of all, we no longer need to define the trait of Monad ourselves as well
    as its companion object where we normally defined the syntax for it. All we need
    to do is perform some imports from cats. In the preceding code, you can see that
    first of all we perform an import of the `Monad` type from the `cats` package,
    and then we import the syntax for the Monad. We have already discussed how this
    mechanism works in the previous section of this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不再需要自己定义 Monad 特质以及我们通常为其定义语法的伴随对象。我们只需要从 `cats` 中执行一些导入。在前面的代码中，你可以看到首先我们导入了
    `cats` 包中的 `Monad` 类型，然后我们导入了 Monad 的语法。我们已经在本章的前一节讨论了这一机制的工作原理。
- en: 'After that, we can define the method  from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The
    Idea of the Type Classes*, for adding two integers and writing to the login process,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以定义来自 [第7章](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml)，“类型类概念”的方法，用于添加两个整数并将它们写入登录过程，如下所示：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the definition looks exactly the same as the one from [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml),
    *The Idea of the Type Classes*. However, the semantics is a bit different. The
    Monad type comes from the `cats` package and is not defined as ad hoc.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，定义看起来与 [第7章](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml)，“类型类概念”中的定义完全相同。然而，语义上略有不同。Monad
    类型来自 `cats` 包，并不是临时定义的。
- en: 'Also, in order to use the type class with the `SimpleWriter` effect type that
    we defined in [Chapter 7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea
    of the Type Classes*, we still need to add an implementation of the Monad for
    this data type. We can do so as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使用我们在 [第7章](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml)，“类型类概念”中定义的 `SimpleWriter`
    效果类型，我们仍然需要为这个数据类型添加一个 Monad 的实现。我们可以这样做：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Actually, `cats` already provides a type similar to our `SimpleWriter` effect
    type that is intended precisely for logging. Let us now discuss how to get rid
    of `SimpleWriter` in favor of the capabilities `cats` provides.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`cats` 已经提供了一个类似于我们 `SimpleWriter` 效果类型的类型，这个类型正是为了日志记录而设计的。现在让我们讨论一下如何用
    `cats` 提供的功能来替代 `SimpleWriter`。
- en: Writer effect type
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Writer 效果类型
- en: The Writer effect type provides us with a bit more of a generic type class than
    the `SimpleWriter` implementation. However, if we use it, we do not need to define
    the `SimplerWriter` type, as well as an implementation of the type classes for
    it. Since cats provides the implementation of its type classes for its data types,
    we don't need to worry about doing this ourselves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer` 效果类型比 `SimpleWriter` 实现提供了更多的通用类型类。然而，如果我们使用它，我们就不需要定义 `SimplerWriter`
    类型，以及为其定义类型类的实现。由于 `cats` 为其数据类型提供了类型类的实现，我们不需要担心自己来做这件事。'
- en: As you may recall, our `SimpleWriter` object is essentially a pair. The first
    element of the pair is a list of strings which represents all of the logging messages
    that were logged by a computation. The other object of a pair is a value that
    was computed by the computation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，我们的 `SimpleWriter` 对象本质上是一个对。对的第一元素是一个字符串列表，它代表了计算过程中记录的所有日志消息。对的另一个元素是计算过程中计算出的值。
- en: The cats implementation of the `Writer` object is essentially very similar to
    our simpler Writer implementation, except the first element of a pair is not a
    list of strings but an arbitrary type. This has a certain utility, because now
    you have the ability to use it for logging data structures other than lists of
    strings.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`cats`对`Writer`对象的实现基本上与我们更简单的Writer实现非常相似，除了对的数据对中的第一个元素不是一个字符串列表，而是一个任意类型。这有一定的实用性，因为现在你可以用它来记录除了字符串列表之外的数据结构。'
- en: 'The `SimpleWriter` that we are using can be expressed in terms of the cats
    Writer if we explicitly specify the type in which the log messages are stored:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所使用的`SimpleWriter`可以通过显式指定存储日志消息的类型，用`cats Writer`来表示：
- en: '![](img/556bd98d-0ac0-445e-b5ec-8628c4b34067.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/556bd98d-0ac0-445e-b5ec-8628c4b34067.png)'
- en: In the preceding screenshot, you can see the documentation of the Writer singleton
    object from the `data` package. This object can be used to write log messages
    into a Writer effect type. The two most important methods over here are `tell`
    and `value`. The `tell` method writes a message into the log and the `value` method
    lifts an arbitrary value into the Writer data structure with an empty log message.
    The Writer data type has a `Monad` instance that defines how to sequentially compose
    two Writers. During the sequential composition, the logs of two effect types are
    combined into one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到`data`包中Writer单例对象的文档。这个对象可以用来将日志消息写入Writer效果类型。这里最重要的两个方法是`tell`和`value`。`tell`方法将消息写入日志，而`value`方法将任意值提升到Writer数据结构中，并带有空日志消息。Writer数据类型有一个`Monad`实例，它定义了如何顺序组合两个Writer。在顺序组合过程中，两个效果类型的日志被合并成一个。
- en: Also, if you look through the `data` package of `cats`, you will discover that
    there is no trait or class called Writer. The real name of the Writer data type
    is `WriterT`. One thing to remember about `cats` is that it aims to provide highly
    generic and abstract tools that can be used in a wide range of different scenarios.
    So, in this particular situation, the technique of Monad Transformers is used,
    hence why is has the strange name of `WriterT`. For the time being, you don't
    need to worry about the Monad Transformers, and you can use the Writer type, which
    is defined in `cats` in terms of `WriterT`. The Writer singleton provides a convenient
    set of methods to deal with it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你查看`cats`的`data`包，你会发现没有名为Writer的特质或类。Writer数据类型的真实名称是`WriterT`。关于`cats`有一件事需要记住，那就是它旨在提供高度通用和抽象的工具，这些工具可以在各种不同的场景中使用。因此，在这种情况下，使用了Monad
    Transformers技术，这就是为什么它有`WriterT`这个奇怪名称的原因。目前，你不需要担心Monad Transformers，你可以使用在`cats`中定义的Writer类型，它是基于`WriterT`的。Writer单例提供了一套方便的方法来处理它。
- en: Since the Writer data type is a standard data type of `cats`, we can replace
    our custom `SimpleWriter` with the Writer that comes from `cats`, and we can also
    remove the Logging type class from our application altogether. The reason we do
    this is to standardize on the `Cats` library. This standardization makes the code
    more compact, eliminates redundancy, and increases reliability. We do this because
    we are using standard tools instead of reinventing them ad hoc.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Writer数据类型是`cats`的标准数据类型，我们可以用来自`cats`的Writer替换我们的自定义`SimpleWriter`，并且我们还可以从我们的应用程序中完全删除Logging类型类。我们这样做的原因是标准化`Cats`库。这种标准化使代码更加紧凑，消除了冗余，并提高了可靠性。我们这样做是因为我们使用的是标准工具，而不是临时重新发明它们。
- en: In the code snippet, you can see an implementation of an addition method from [Chapter
    7](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml), *The Idea of the Type Classes,* using
    the capabilities from `cats` that we discussed previously.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，你可以看到一个来自[第7章](a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml)，“类型类概念”的加法方法的实现，使用了我们之前讨论的`cats`的能力。
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The tailRecM method
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`tailRecM`方法'
- en: 'Previously in this section, we touched on the `tailRecM` method briefly. It
    is pretty useful in certain situations, because it allows you to define loops
    in the context of an effect type. In this subsection, let''s take a more detailed
    look at its signature and at how this method works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之前，我们简要提到了`tailRecM`方法。它在某些情况下非常有用，因为它允许你在效果类型的上下文中定义循环。在本小节中，让我们更详细地看看它的签名以及这个方法是如何工作的：
- en: '![](img/77354c52-e187-496e-944b-788b880e01d4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77354c52-e187-496e-944b-788b880e01d4.png)'
- en: Let's take a look at the arguments of this method. First of all, let's take
    a look at the second argument of this method, the `f` function. The function takes
    a raw value of type `A`, and the result of this function is an effect type, which
    is `F[Either[A, B]]`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法的参数。首先，让我们看看这个方法的第二个参数，即`f`函数。该函数接受类型`A`的原始值，该函数的结果是一个效果类型，即`F[Either[A,
    B]]`。
- en: Let's think about what we can do with this computation to make a loop out of
    it. Suppose that we start from some value, `A`. Suppose that we run the computation
    `f` on this value. Then, our result is of the type `F[Either[A, B]]`. There are
    two possibilities of what exactly this type will be—either `F[Left[A]]` or `F[Right[B]]`.
    If it is `F[Left[A]]`, then we are able to use `flatMap` on `F[Left[A]]`; after
    that, we can extract `A` from `Left`, and then we can run the computation `f`
    again on that `A`. If it is the `F[Right[B]]`, there is nothing left to do but
    return the result of the computation, that is, `F[B]`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们可以如何使用这个计算来使其成为一个循环。假设我们从某个值`A`开始。假设我们在该值上运行计算`f`。那么，我们的结果是类型`F[Either[A,
    B]]`。这个类型的确切可能性有两种——要么是`F[Left[A]]`，要么是`F[Right[B]]`。如果是`F[Left[A]]`，那么我们可以在`F[Left[A]]`上使用`flatMap`；之后，我们可以从`Left`中提取`A`，然后我们可以在那个`A`上再次运行计算`f`。如果是`F[Right[B]]`，就没有其他事情可做，只能返回计算的结果，即`F[B]`。
- en: So, the function passed to `tailRecM` will run on argument `A` while it produces
    the results of type `F[Left[A]]`. Once it produces `F[Right[B]]`, this result
    is counted as the final result and is returned from the loop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，传递给`tailRecM`的函数将在参数`A`上运行，同时产生类型为`F[Left[A]]`的结果。一旦它产生`F[Right[B]]`，这个结果就被视为最终结果，并从循环中返回。
- en: Basically, if we have the ability to perform a `flatMap` on the effect type
    `F`, we are also able to define a loop based on `flatMap`. However, why is it
    an abstract method? If all it takes to make a loop is the ability to perform `flatMap`,
    then why can we not define it as a concrete method implemented in terms of `flatMap`?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果我们有能力在效果类型`F`上执行`flatMap`，那么我们也能基于`flatMap`定义一个循环。然而，为什么它是一个抽象方法？如果创建循环只需要执行`flatMap`的能力，那么为什么我们不能将其定义为基于`flatMap`的具体方法？
- en: 'Well, we might want to try and do that. Consider the implementation of the
    Monad for our `SimpleWriter` example, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可能想要尝试这样做。考虑我们的`SimpleWriter`示例的Monad实现，如下所示：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we have a `tailRecM` in terms of `flatMap`. What happens
    if we try an infinite loop?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个基于`flatMap`的`tailRecM`。如果我们尝试一个无限循环会发生什么？
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code results in a `StackOverflowError`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会导致`StackOverflowError`：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This error occurs most frequently in the scenario of a recursive call where
    we run out of stack frames of memory that are allocated for us by the JVM.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误最频繁地发生在递归调用的情况下，我们耗尽了由JVM为我们分配的内存栈帧。
- en: Every time you perform a method call, a specific memory fragment is allocated
    by the JVM for all of the variables and parameters of that method call. This memory
    fragment is called a stack frame. So, if you are calling a method recursively,
    you will have the number of stack frames growing proportionally to the depths
    of your recursion. The memory you can use for the stack frames is set on the JVM
    level and is usually up to 1 MB, and it is fairly easy to run into its limit with
    a deep enough recursion.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你执行一个方法调用时，JVM都会为该调用分配一个特定的内存片段，用于所有变量和参数。这个内存片段被称为栈帧。因此，如果你递归地调用一个方法，你的栈帧数量将与递归的深度成比例增长。可用于栈帧的内存是在JVM级别设置的，通常高达1
    MB，并且如果递归足够深，很容易达到其限制。
- en: However, there are situations when you do not need to create additional stack
    frames in cases of recursion. Here, we are talking about tail recursion. Basically,
    you are able to drop the previous stack frame of recursion if it is no longer
    needed. This situation arises if there is nothing else to do in the method owning
    the stack frame, and the result of this method is fully dependent on the result
    of the subsequent calls of the recursion.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你不需要在递归的情况下创建额外的栈帧。这里，我们谈论的是尾递归。基本上，如果你不再需要递归的先前栈帧，你可以将其丢弃。这种情况发生在方法拥有栈帧且没有其他事情可做时，并且该方法的输出完全依赖于递归后续调用的结果。
- en: 'Consider, for example, the following example of a factorial computation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下阶乘计算的示例：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the `factorial` function is defined recursively. So,
    in order to compute a factorial of a number `n`, you first need to compute a factorial
    of `n-1`, and then multiply it by `n`. When we call the factorial method recursively,
    we can ask a question as to whether we need to do anything else in this method
    after the recursive call is done, or if its results are dependent only on the
    method that we are calling recursively. More precisely, we are talking about whether
    we need to do anything else after the factorial call inside the `factorial` function.
    The answer is that we need to perform one more step to complete the computation.
    This step is the multiplication of the result of the factorial call by the number
    `n`. So, until this step is completed, we are not able to drop the frame of the
    current call. However, consider the `factorial` method, which is defined as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`factorial` 函数是递归定义的。因此，为了计算一个数字 `n` 的阶乘，你首先需要计算 `n-1` 的阶乘，然后将它乘以 `n`。当我们递归地调用
    `factorial` 方法时，我们可以问一个问题：在递归调用完成后，在这个方法中我们是否还需要做其他事情，或者它的结果是否只依赖于我们递归调用的方法。更确切地说，我们是在讨论在
    `factorial` 函数内部对阶乘调用之后是否还需要做其他事情。答案是，我们需要执行一个额外的步骤来完成计算。这个步骤是将阶乘调用的结果乘以数字 `n`。所以，直到这个步骤完成，我们才不能丢弃当前调用的栈帧。然而，考虑以下定义的
    `factorial` 方法：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, when we are calling the `factorial` method, we can
    ask ourselves the following question—do we have anything else to do in the method
    in order to complete its computation after the call to the `factorial` method?
    Or is the result of this method fully dependent on the result of the `factorial`
    method we are calling in this place? The answer is that we do not need to do anything
    else here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们调用 `factorial` 方法时，我们可以问自己以下问题——在调用 `factorial` 方法之后，我们是否还需要在方法中做其他事情来完成它的计算？或者这个方法的结果是否完全依赖于我们在这里调用的
    `factorial` 方法的结果？答案是，我们在这里不需要做其他任何事情。
- en: The Scala compiler can recognize such situations and perform optimization in
    places where recursion can reuse the stack frames of the previous reclusive calls.
    This situation is called **tail recursion.** In general, such calls are much more
    efficient than ordinary recursion because you cannot get a Stack Overflow with
    them, and in general their speed is comparable to the speed of an ordinary `while`
    loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 编译器可以识别这种情况，并在可以重用先前递归调用栈帧的地方进行优化。这种情况被称为**尾递归**。一般来说，这样的调用比普通递归更高效，因为你不能因为它们而得到栈溢出，而且一般来说它们的速度与普通
    `while` 循环的速度相当。
- en: 'In fact, you can explicitly make a requirement on a method so that it''s tail
    recursive in Scala, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以在 Scala 中明确地对一个方法提出要求，使其成为尾递归，如下所示：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the first method will not compile because it is not
    tail recursive while annotated with `@tailrec`. The Scala compiler will perform
    a check for all the methods annotated with `@tailrec` so see whether they're tail
    recursive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个方法将无法编译，因为它虽然被标注了 `@tailrec`，但不是尾递归。Scala 编译器将对所有标注了 `@tailrec` 的方法进行检查，以确定它们是否是尾递归。
- en: Let's revisit our case of `tailRecM`. From the name, you can now guess that
    this method is supposed to be tail recursive. Now, let's recall our naive implementation
    of this method for `SimpleWriter`. Its execution resulted in a stack overflow
    exception. This is because, here, the recursion is split into several methods.
    So if you take a look at the stack trace output, you can see that the output is
    periodic. There are two methods repeating in this output—`flatMap` and `tailRecM`.
    The Scala compiler is not able to prove that the method is tail recursive in such
    a periodic recursion situation. In principle, you can think of a way to optimize
    recursion even in this, but Scala compiler cannot do that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `tailRecM` 的例子。从名字上，你现在可以猜到这个方法应该是尾递归的。现在，让我们回忆一下 `SimpleWriter` 的这个方法的原始实现。它的执行导致了栈溢出异常。这是因为在这里，递归被分割成几个方法。所以如果你查看堆栈跟踪输出，你可以看到输出是周期性的。在这个输出中有两个方法在重复——`flatMap`
    和 `tailRecM`。Scala 编译器无法证明在这种情况下该方法是否是尾递归。原则上，你可以想出一个方法来优化递归，即使在这种情况下，但 Scala
    编译器无法做到这一点。
- en: 'Also, let''s see what happens if you try to declare the `tailRecM` method with
    the `@tailrec` annotation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们看看如果你尝试使用 `@tailrec` 注解声明 `tailRecM` 方法会发生什么：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see that the code stops compiling because the method is not recognized
    as tail recursive:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现代码无法编译，因为该方法没有被识别为尾递归：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The point of having this method as an abstract method is precisely because
    you must implement it, not in terms of `flatMap` (which would inevitably lead
    to periodic recursion), but in terms of a single tail recursive method. For example,
    in the context of `SimpleWriter`, we can come up with such an implementation such
    as the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法作为抽象方法的目的正是您必须实现它，而不是使用 `flatMap`（这不可避免地会导致周期性递归），而是使用一个单一尾递归方法。例如，在 `SimpleWriter`
    的上下文中，我们可以提出如下这样的实现：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, as you can see, we have an implementation of
    `tailRecM` in a tail recursive manner. Notice that we are still using techniques
    similar to the ones that we are using in the `flatMap` function. However, these
    techniques are wrapped in a single method which is tail recursive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，如您所见，我们以尾递归的方式实现了 `tailRecM`。请注意，我们仍在使用与 `flatMap` 函数中使用的类似的技术。然而，这些技术被封装在一个单一的方法中，该方法是以尾递归的方式实现的。
- en: 'One remark should be made, and that is that not every Monad implementation
    has an implementation of `tailRecM`. Frequently, you will find scenarios where
    `tailRecM` just throws a `NotImplementedError`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的一点是，并非每个 Monad 实现都有 `tailRecM` 的实现。您经常会遇到 `tailRecM` 只会抛出 `NotImplementedError`
    的场景：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `???` syntax is used in Scala to conveniently throw such an error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中使用 `???` 语法方便地抛出这样的错误。
- en: So far, we have discussed a `flatMap` in the context of composition of side
    effecting computations. Now, let's take a look at an example of the composition
    of a side effecting computation with a non-side effecting computation. Let's take
    a look at Functor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在副作用计算组合的上下文中 `flatMap`。现在，让我们看看一个副作用计算与非副作用计算组合的例子。让我们看看 Functor。
- en: Functor
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Functor
- en: Another frequently encountered type class in functional programming is Functor.
    Functor is all about the map function in its essence. As you may recall from the
    previous chapters, the `map` function is very similar to `flatMap` function; however,
    it takes a non-side effecting computation as its argument. It is used to transform
    a value within the context of a effect type when this transformation is not side
    effecting itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中经常遇到的其他类型类是 Functor。Functor 的本质是关于 map 函数。如您从前面的章节中回忆起来，`map` 函数与 `flatMap`
    函数非常相似；然而，它接受一个非副作用计算作为其参数。它用于在转换本身不是副作用的情况下，在效果类型的上下文中转换一个值。
- en: You might want to use a Functor if you want to do something with the result
    of a side effecting computation without extracting it from its effect type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在不需要从其效果类型中提取结果的情况下对副作用计算的结果进行操作，您可能会想使用 Functor。
- en: As you may recall, we used an intuition of sequential composition in the case
    of the `flatMap` of a Monad. This intuition may not be the best one for Functor.
    In the case of `map`, we can use another intuition of function, changing a value
    under the effect type. The operation that is abstracted away in this case is one
    of extracting the value from an effect type. The `map` method asks you only about
    what you want to do with the result of a side-effecting computation, without demanding
    from you and information about how exactly to extract this result from the effect
    type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，在处理 Monad 的 `flatMap` 的情况下，我们使用了序列组合的直觉。这种直觉对于 Functor 可能并不是最好的。在 `map`
    的情况下，我们可以使用另一种关于函数的直觉，即在效果类型下改变一个值。在这种情况下抽象的操作是从效果类型中提取值。`map` 方法只询问您想要如何处理副作用计算的结果，而不要求您提供有关如何从效果类型中提取此结果的确切信息。
- en: As in the case of the `Monad` type class, we have already discussed the `map`
    method in detail in the previous sections, so we will not be stopping on this
    type class for long. All we will do is take a look at how you might want to use
    it with the `Cats` library.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几节中详细讨论了 `Monad` 类型类的情况一样，我们已经在之前详细讨论了 `map` 方法，因此我们不会在这个类型类上停留太久。我们只是想看看您如何可能想要使用
    `Cats` 库来使用它。
- en: 'Let''s take a look at the classes defined by the `Cats` library for Functor:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Cats` 库为 Functor 定义的类：
- en: '![](img/def275eb-529e-48ac-a367-c3b7ad143bc1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/def275eb-529e-48ac-a367-c3b7ad143bc1.png)'
- en: 'In the preceding screenshot, you can see the documentation and the definition
    of the Functor type class. Now, let''s take a look at what its implementation
    may look like for our `SimpleWriter` type. First of all, let''s recall the definition
    of the `SimpleWriter` data type:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以查看 Functor 类型类的文档和定义。现在，让我们看看 `SimpleWriter` 类型可能的实现。首先，让我们回顾一下
    `SimpleWriter` 数据类型的定义：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to provide an implementation of the Functor type class from the
    `Cats` library. We will do some imports from the `Cats` library:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要提供`Cats`库中Functor类型类的实现。我们将从`Cats`库中做一些导入：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are performing an import of the Functor type from
    the `cats` package (by importing `cats._`). After that, we must import the syntax
    for this type class (by importing `cats.implicits._` imports all the syntax and
    instances for all the type classes). So, whenever we have an implementation of
    the type class in scope, we will also have the syntax for it injected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在导入`cats`包中的Functor类型（通过导入`cats._`）。之后，我们必须导入这个类型类的语法（通过导入`cats.implicits._`导入所有类型类的语法和实例）。所以，每当类型类的实现处于作用域内时，我们也将有它的语法注入。
- en: 'So, let''s provide the implementation of the Functor type class for `SimpleWriter`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为`SimpleWriter`类型类提供实现：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, you can see a simple implementation of the Functor type
    class for `SimpleWriter`. As you can see, all we need to do is implement the `map`
    method of this type class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到一个简单的`SimpleWriter`类型类的Functor实现。正如你所见，我们只需要实现这个类型类的`map`方法。
- en: 'After that, once we have created some very simple instances of the effect type,
    we are able to call the `map` method on it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一旦我们创建了一些非常简单的效果类型实例，我们就能调用它的`map`方法：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, the `map` method gets injected into our effect type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`map`方法被注入到我们的效果类型中。
- en: One question you might be asking is, what is the point is this? If Functor and
    Monad both define the `map` method, why have Functor at all? Why not have the
    Monad implementation for every type class where we need the `map` method and not
    bother with the Functor class at all? The answer is that not every effect type
    has the `flatMap` method implementation for it. So, an effect type might have
    an implementation of `map`, but it may be impossible to define a `flatMap` on
    it. Hence, the `Cats` library provides a fine-grained structure of its type class
    hierarchy so that you can use it according to your own needs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有一个疑问，这个做法的意义是什么？如果Functor和Monad都定义了`map`方法，为什么还要有Functor呢？为什么不在需要`map`方法的每个类型类中都有Monad实现，而不去关心Functor类呢？答案是，并不是每个效果类型都有`flatMap`方法的实现。所以，一个效果类型可能有一个`map`的实现，但可能无法定义其上的`flatMap`。因此，`Cats`库提供了一个精细的类型类层次结构，这样你可以根据自己的需求来使用它。
- en: So far, we have discussed type classes for sequential composition. Now, let's
    take a look at the case of parallel composition and how the Applicative type class
    handles it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了用于顺序组合的类型类。现在，让我们看看并行组合的情况以及Applicative类型类是如何处理它的。
- en: Applicative
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applicative
- en: Knowing how to compose computations in sequence is a basic skill that enables
    procedural programming to take place. This is something that we rely upon by default
    when we use imperative programming languages. When we write two statements in
    sequence, we implicitly mean that these two statements are supposed to be executed
    one after another.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何按顺序组合计算是一种基本技能，它使得过程式编程得以实现。这是我们默认依赖的东西，当我们使用命令式编程语言时。当我们按顺序写两个语句时，我们隐含地意味着这两个语句应该一个接一个地执行。
- en: However, sequential programming is not capable of describing all the programming
    situations, especially if you're working in the context of an application that
    is supposed to run in parallel. There may be lots of situations where you may
    want computations composed in parallel. This is exactly where the Applicative
    type class comes into play.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，顺序编程无法描述所有编程情况，特别是如果你在一个应该并行运行的应用程序上下文中工作。可能会有很多你想要并行组合计算的情况。这正是Applicative类型类发挥作用的地方。
- en: Motivation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: 'Consider that we have two independent computations. Suppose we have two computations
    that evaluate mathematical expressions, and then we need to combine their results.
    Also, suppose that their computation is performed under the `Either` effect type.
    So, the main idea is that either of the two computations can fail, and if one
    of them fails, it is the result of interpretation being left with an error, and
    if it succeeds, the result is  `Right` of some result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个独立的计算。假设我们有两个计算数学表达式，然后我们需要组合它们的结果。也假设它们的计算是在`Either`效果类型下进行的。所以，主要思想是这两个计算中的任何一个都可能失败，如果其中一个失败了，解释的结果将留下一个错误，如果成功了，结果是某个结果的`Right`：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, you can see how you can combine two such computations
    sequentially using the `Monad` type class. Here, we are using for comprehensions
    to compute the result of the first computation, and then the second computation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到如何使用`Monad`类型类按顺序组合两个这样的计算。在这里，我们使用列表推导式来计算第一个计算的结果，然后是第二个计算。
- en: 'Let''s take a look at a scenario where one of these computations goes wrong:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个这些计算出错的情况：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see two situations and two outputs. The first one is where the first
    computation goes wrong and the second one is where the second computation goes
    from. So basically, the result of the combined computation will be `Left` if either
    both of the two computations fail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到两种情况和两种输出。第一种是第一个计算出错的情况，第二种是第二个计算出错的情况。所以，基本上，合并计算的结果将是`Left`，如果两个计算中的任何一个都失败了。
- en: What happens if both of these computations fail?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个计算都失败了会怎样？
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see an output of the situation where both of these computations fail.
    An error the first computation only gets an output. This is because they are composed
    sequentially, and the sequence is terminated on the first error. The behavior
    of the Monad for `Either` is to terminate sequential composition if `Left` is
    encountered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这两种计算都失败的情况的输出。第一个计算只得到一个错误输出。这是因为它们是按顺序组合的，序列在第一个错误时终止。对于`Either`的`Monad`行为是在遇到`Left`时终止顺序组合。
- en: This kind of scenario may not always be desirable, especially in large applications
    that consist of a large amount of various modules that can fail. In such an application,
    for debugging purposes, you would like to collect as much information about the
    errors that have occurred as possible. If you're only collecting one error at
    a time, and you have dozens of independent computations that fail, you will have
    to debug them one at a time because you will not have access to the entire set
    of errors that have occurred. This is because only the first error encountered
    will be reported, even though the computations are independent on one another.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能并不总是期望的，特别是在由大量可能失败的各个模块组成的大型应用程序中。在这种情况下，出于调试目的，你希望尽可能多地收集已发生的错误信息。如果你一次只收集一个错误，并且你有数十个独立的计算失败，你必须逐个调试它们，因为你将无法访问已发生的整个错误集。这是因为只有遇到的第一个错误将被报告，尽管这些计算是相互独立的。
- en: The reason why this scenarios happens is because of the very nature of the way
    we have composed our computations. They are composed sequentially. The nature
    of sequential composition is to run computations one after another, even if they
    are not dependent on one another's results. Since these computations run one after
    another, it is only natural to interrupt an entire sequence if an error has occurred
    in one of the links of the chain.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况发生的原因是因为我们组合计算的方式的本质。它们是按顺序组合的。顺序组合的本质是按顺序运行计算，即使它们不依赖于彼此的结果。由于这些计算是按顺序运行的，如果在链中的某个链接发生错误，中断整个序列是自然而然的。
- en: This solution to the preceding scenario would be to compose independent computations
    in parallel instead of in sequence. So, they should all be run independently one
    from another, and their results should be combined in some manner after they finish.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 解决前一个场景的方法是将独立的计算并行执行而不是按顺序执行。因此，它们都应该独立于彼此运行，并在完成后以某种方式合并它们的结果。
- en: Applicative type class
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applicative类型类
- en: 'We would like to define a new primitive for the preceding scenario. We can
    call this method `zip`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为前一个场景定义一个新的原始方法。我们可以称这个方法为`zip`：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method will take two computations as its arguments, and it will output a
    combined result of two of its supplied inputs as a tuple under their common effect
    type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将接受两个计算作为其参数，并将输出两个提供的输入的合并结果，作为一个元组，其类型是它们共同的效果类型。
- en: Also notice that we are dealing with specific cases of `Left` being a list of
    strings. This is to combine multiple error strings for multiple failed computations
    into one error report.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们正在处理`Left`是一个字符串列表的特定情况。这是为了将多个失败的计算的多个错误字符串合并成一个错误报告。
- en: The way it works is that if both compilations are successful, their results
    are combined into a pair. Otherwise, if either of these computations fails, their
    errors are collected in a combined list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是，如果两个编译都成功，它们的组合结果将是一个对。否则，如果这些计算中的任何一个失败，它们的错误将收集在一个组合列表中。
- en: 'Given the new method, `zip`, we can express the preceding example as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 给定新的方法`zip`，我们可以将前面的例子表达如下：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that here we're making the use of `zip` to create combined versions of
    two independent computations, and addressing the fact that we are using the `map`
    method to do something with the result of this computation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们使用`zip`来创建两个独立计算的组合版本，并处理我们使用`map`方法对这个计算结果进行操作的事实。
- en: 'Actually, we can express the `zip` function in terms of a more generic `ap`
    (short for `apply`) function. It is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以用更通用的`ap`（即`apply`）函数来表达`zip`函数。具体如下：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is how we can express the `zip` function in terms of the `ap` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样表达`zip`函数，即通过`ap`函数：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The actual meaning of the `ap` function is a more generic way to express the
    combination of two independent computations running together. The trick is that
    the first computation results in some function, `F[A => B]`, and the second computation
    is raw computation, `F[A]`. The point about this function and why it is different
    from the `zip` function in a qualitative way is as follows. Intervention is composition
    plus execution. It composes some value lifted into effect type `F`, together with
    a computation, `A => B`, that works on this value, which is also lifted into the
    context `F`. Since at composition time we already deal with effect types, we already
    have the independent computations finished. Compare that to the case of `flatMap`,
    where one of the arguments is a function, `A => F[B]`, that outputs an effect
    type. So, in the case of `flatMap`, one of the competitions is a function that
    is going to be executed. It is the responsibility of `flatMap` to execute it and
    obtain the result `F[B]`. This cannot be said about `ap`, which already has access
    to the results that the effect types computed—`F[A => B]` and `F[A]`. Hence, there
    is independence of computations. Since one of the values of the computed effect
    types is a function, `A => B`, it is not only a composition in terms of zipping
    into a pair, but also an execution that's similar to mapping.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`ap`函数的实际意义是表达两个独立计算同时运行的一种更通用的方式。技巧在于第一个计算结果是一个函数`F[A => B]`，第二个计算是一个原始计算`F[A]`。关于这个函数以及为什么它在本质上与`zip`函数不同，以下是一些说明。干预是组合加执行。它组合了一些提升到效果类型`F`的值，以及一个在值上工作的计算`A
    => B`，这个计算也被提升到`F`的上下文中。由于在组合时我们已处理效果类型，因此我们已经完成了独立计算。与`flatMap`的情况相比，其中一个参数是一个函数`A
    => F[B]`，它输出一个效果类型。所以，在`flatMap`的情况下，其中一个参数是一个将要被执行的函数。这是`flatMap`的责任，它将执行它并获得结果`F[B]`。这不能应用于`ap`，因为`ap`已经可以访问效果类型计算的结果——`F[A
    => B]`和`F[A]`。因此，存在计算的独立性。由于计算的效果类型中的一个值是一个函数`A => B`，它不仅是在组合中通过`zip`成对，而且也是一个类似于映射的执行。'
- en: 'Actually, the `ap` function comes from the `Apply` type class, which is an
    ancestor of Applicative:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`ap`函数来自`Apply`类型类，它是`Applicative`的祖先：
- en: '![](img/f5db63dd-576a-4fe0-b27c-adac657fbae9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5db63dd-576a-4fe0-b27c-adac657fbae9.png)'
- en: However, you will encounter Applicative versions of the type class that extend
    the `Apply` type class more frequently. The only difference between these type
    classes is that Applicative also has the `pure` function, which is used to lift
    a raw value, `a`, into the same effect type, `F`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将更频繁地遇到扩展`Apply`类型类的`Applicative`版本。这些类型类之间的唯一区别是`Applicative`还有一个`pure`函数，该函数用于将原始值`a`提升到相同的效果类型`F`。
- en: 'Applicative also has a bunch of useful concrete methods defined in terms of
    `ap`. There is also some nice syntactic sugar support that `cats` provides for
    you so that you can use Applicative in your projects in an intuitive way. For
    example, you can perform a `map` on two values at once, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative`还有许多以`ap`为依据的有用具体方法。`cats`还为你提供了一些语法糖支持，以便你可以以直观的方式在你的项目中使用`Applicative`。例如，你可以同时对两个值执行`map`操作，如下所示：'
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can use the syntactic sugar that `cats` injects in tuples in order to easily
    work with such kind of cases of parallel computation. So, you can just unite two
    effect types under a tuple and map them with the Applicative type class in scope.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cats`在元组中注入的语法糖，以便轻松处理这种并行计算的情况。因此，你只需将两个效果类型组合成一个元组，并在作用域中使用`Applicative`类型类来映射它们。
- en: Implementation of the type class
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类的实现
- en: 'Let''s take a look at how the type class can be implemented for a data type.
    For example, let''s look at `Either`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型类如何为数据类型实现。例如，让我们看看`Either`：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see how the type class can be implemented for `Either` with `Left` being
    `List[String]`. So, as you can see, if two computations are successful, that is,
    they are `Right`, we simply combine them. However, if at least one of them is
    `Left`, we combine the `Left` side of both computations into a single `Left[List[String]]`.
    This is done specifically in mind for the cases where several independent computations
    may produce errors that you might want to combine under a single data structure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如何为`Either`实现类型类，其中`Left`是`List[String]`。所以，正如你所看到的，如果两个计算都成功了，即它们是`Right`，我们简单地将它们合并。然而，如果至少有一个是`Left`，我们将两个计算的`Left`部分合并成一个`Left[List[String]]`。这是专门针对可能产生错误并且你希望在一个单一的数据结构下合并的几个独立计算的情况。
- en: You have probably noticed that we are using a pretty specific case of `Either`—the
    one where `Left` is always a `List[String]`. We have done this because we need
    a way to combine the `Left` sides of two computations into one, and we are not
    able to combine generic types. The preceding example can be generalized further
    to the arbitrary version of the type of `Left`, `Either[L, A]`. This can be done
    with the help of the `Monoid` type class, which we will learn about next. So,
    let's take a look at this type class and see where it can be useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们正在使用`Either`的一个非常具体的案例——即`Left`总是`List[String]`的情况。我们之所以这样做，是因为我们需要一种方法将两个计算中的`Left`部分合并成一个，而我们无法合并泛型类型。前一个例子可以进一步推广到`Left`类型的任意版本，即`Either[L,
    A]`。这可以通过`Monoid`类型类来实现，我们将在下一节中学习它。所以，让我们来看看这个类型类，看看它在哪里可以派上用场。
- en: Monoid
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monoid
- en: Monoid is another popular type class that you will frequently encounter in practice.
    Basically, it defines how to combine two data types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monoid`是你在实践中经常遇到的一个流行的类型类。基本上，它定义了如何组合两种数据类型。'
- en: As an example of Monoid, let's take a look at the implementation of an Applicative
    type class for the `Either` data type. In the previous section, we were forced
    to use a specific version of `Either`, the one with `Left` set to a list of strings.
    This was done precisely because we know how to combine two lists of strings, but
    we do not know how to combine any two generic types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Monoid的一个例子，让我们看看为`Either`数据类型实现Applicative类型类的实现。在前一节中，我们被迫使用一个特定的`Either`版本，即`Left`被设置为字符串列表的那个版本。这正是因为我们知道如何合并两个字符串列表，但我们不知道如何合并任何两种泛型类型。
- en: 'If we define the signature of this preceding Applicative as follows, then we
    will not be able to provide a decent implementation of this function because we
    will not be able to combine two generic types:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义前面提到的Applicative的签名如下，那么我们将无法提供一个合理的函数实现，因为我们无法合并两个泛型类型：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you tried to write an implementation of this function, it would look something
    like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编写这个函数的实现，它可能看起来像以下这样：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using a special operator, `|+|`, in order to describe the operation of
    combining two data types we know nothing about. However, since we know nothing
    about the data types we are trying to combine, the code will not compile. We cannot
    simply combine two arbitrary data types because the compiler does not know how
    to do that.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个特殊的操作符`|+|`来描述我们一无所知的两种数据类型的组合操作。然而，由于我们对我们要组合的数据类型一无所知，代码将无法编译。我们不能简单地组合任意两种数据类型，因为编译器不知道如何做到这一点。
- en: 'This situation can be changed if we make the Applicative type class implicitly
    depend on another type class that does know how to implicitly combine these two
    data types. Meet Monoid:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让Applicative类型类隐式地依赖于另一个知道如何隐式合并这两种数据类型的类型类，这种状况就可以改变。那就是Monoid：
- en: '![](img/0b8f98c4-c89d-4aa5-a17b-682bf0a1179b.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b8f98c4-c89d-4aa5-a17b-682bf0a1179b.png)'
- en: 'The Monoid type class extends `Semigroup`. `Semigroup` is a mathematical structure
    of from. It is a type class that is defined as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monoid`类型类扩展了`Semigroup`。`Semigroup`是一种数学结构。它是一个定义为以下类型的类型类：'
- en: '![](img/7a1fd818-e5ee-4247-8abd-0f0260f0c9ff.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a1fd818-e5ee-4247-8abd-0f0260f0c9ff.png)'
- en: Basically, `Semigroup` is defined in the context of abstract algebra and Set
    Theory. Given a set, a `Semigroup` is a structure on this set that defines an
    operator that can combine two arbitrary elements of a set to produce another element
    of the same set. So, for any two elements of a set, you are able to combine them
    using this operator to produce another element that also belongs to this set.
    In the language of programming, `Semigroup` is a type class that can be defined,
    as shown in the preceding screenshot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，**半群**是在抽象代数和集合论中定义的。给定一个集合，一个**半群**是这个集合上的一个结构，它定义了一个运算符，可以将集合中的任意两个元素组合起来产生集合中的另一个元素。因此，对于集合中的任意两个元素，你可以使用这个运算符将它们组合起来，产生另一个属于这个集合的元素。在编程语言中，`Semigroup`是一个可以定义的类型类，如前一个屏幕截图所示。
- en: In the preceding screenshot, you can see that `Semigroup` defines a single method
    called `combined`. It takes two arguments of type `A` and returns another value
    of type `A`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，你可以看到`Semigroup`定义了一个名为`combined`的单个方法。它接受两个类型为`A`的参数，并返回另一个类型为`A`的值。
- en: 'An intuitive way to understand `Semigroup` is to have a look at the addition
    operation on integers:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Semigroup`的一个直观方法是看看整数上的加法运算：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In addition operation on integers, `+` is an operator that can be used to combine
    any two arbitrary integers to obtain another integer. Hence, the operation of
    addition forms a `Semigroup` on the set of all possible integers. The `Semigroup`
    type class in `cats` generalizes this idea to any arbitrary type, `A`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数加法运算中，`+`是一个运算符，可以用来将任意两个整数组合起来得到另一个整数。因此，加法运算在所有可能的整数集合上形成一个`Semigroup`。`cats`中的`Semigroup`类型类将这个想法推广到任何任意类型`A`。
- en: 'Looking back at our Monoid example, we can see that it extends a `Semigroup`
    and adds another method to it, which is called `empty`. Monoid must obey certain
    laws. One of these laws is that the `empty` element must be an identity with respect
    to the `combined` operation. This means that the following equalities must hold
    true:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的Monoid示例，我们可以看到它扩展了`Semigroup`并为其添加了另一个名为`empty`的方法。Monoid必须遵守某些定律。其中一条定律是`empty`元素必须是`combined`运算的单位元。这意味着以下等式必须成立：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So basically, if you try to combine an empty identity element with any other
    element of set `A`, you will get that same element as a result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，如果你尝试将空单位元与集合`A`中的任何其他元素组合，你将得到相同的元素作为结果。
- en: 'An intuitive way to understand this point is to have a look at the operation
    of the addition of integers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个点的直观方法是看看整数加法运算：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see an implementation of the Monoid for integers. If we take the operation
    to be an addition, then `0` is an empty element. Indeed, if you add `0` to any
    other integer, you will get this integer as a result. `0` is an identity element
    with respect to the addition operation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到整数Monoid的实现。如果我们把运算定义为加法，那么`0`是一个空元素。确实，如果你将`0`加到任何其他整数上，你将得到这个整数作为结果。`0`是加法运算的单位元。
- en: 'This remark, *with respect to the addition operation*, is really important
    to notice. For example, `0` is not an identity element with respect to multiplication.
    In fact, if you multiply `0` by any other element, you will get `0` and not that
    other element. Speaking of multiplication, we can define a Monoid for integers
    with the operation of multiplication and the identity element being one, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这条关于**加法运算**的评论确实非常重要，需要注意。例如，`0`不是乘法运算的单位元。实际上，如果你将`0`与任何其他元素相乘，你将得到`0`而不是那个其他元素。说到乘法，我们可以定义一个整数乘法运算和单位元为`1`的Monoid，如下所示：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Actually, `cats` defines some nice syntactic sugar for Monoids. Given the preceding
    definition of that Monoid for integers for the multiplication operation, we can
    use it as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`cats`为Monoid定义了一些很好的语法糖。给定前面定义的整数乘法运算的Monoid，我们可以如下使用它：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can see how you can use an infix operator, `|+|`, in Scala to combine two
    elements. The preceding code is equivalent to the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如何在Scala中使用中缀运算符`|+|`来组合两个元素。前面的代码等同于以下代码：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a common practice in `cats` in order to define such kinds of symbolic
    operators for frequently encountered operators. Let us have a look at how `Applicative`
    can be implemented for `Either` with `Monoid` as its dependency.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`cats`中定义这类符号运算符的常见做法，以定义经常遇到的运算符。让我们看看如何使用`Monoid`作为依赖项实现`Either`的`Applicative`。
- en: Another library for functional programming, ScalaZ, is more aggressive than
    `cats` with respect to operator usage, and hence it can be more difficult to understand
    for a beginner. `cats` is more friendly in this respect. The reason symbolic operators
    are less friendly is because their meaning is not immediately obvious from the
    name. For example, the preceding operator, `|+|`, can be pretty ambiguous for
    somebody who is looking at it for the first time. However, the `combine` method
    gives you a very solid idea of what it does.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于函数式编程的库ScalaZ在运算符使用上比`cats`更为激进，因此对于初学者来说可能更难理解。在这一点上`cats`更为友好。符号运算符之所以不那么友好，是因为它们的含义从名称上并不立即明显。例如，前面的运算符`|+|`对于第一次看到它的人来说可能相当模糊。然而，`combine`方法给你一个非常清晰的概念，了解它是做什么的。
- en: Implementation for Either
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either的实现
- en: Now that we have familiarized ourselves with Monoid and had a look at how it
    is used in the context of simple types such as integer, let's take a look at our
    previous example, the example of `Either` with a generic type of `Left`—`Either[L,
    A]`. How can we define the Applicative instance for a generic `Left` type? Previously,
    we saw that the body of the `ap` function for a generic `Left` type is not very
    different from the body of this function for the list. The only problem was that
    we didn't know how to combine two arbitrary types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Monoid，并查看它在简单类型（如整数）的上下文中的应用，让我们看看之前的例子，即具有泛型类型`Left`的`Either`例子——`Either[L,
    A]`。我们如何为泛型`Left`类型定义Applicative实例？之前我们看到，泛型`Left`类型的`ap`函数的主体与列表的该函数的主体并没有太大区别。唯一的问题是，我们不知道如何组合两种任意类型。
- en: 'This combination sounds like exactly the task for Monoid. So, if we bring the
    implicit dependency on Monoid into scope, we can define the `ap` and Applicative
    type class for the `Either` type as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合听起来正是Monoid的任务。因此，如果我们将Monoid的隐式依赖引入作用域，我们可以为`Either`类型定义`ap`和Applicative类型类如下：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see an implicit implementation of the Applicative type class that is
    also dependent on an implicit implementation of the `Monoid` type class for the
    `Left` type of `Either`. So, what happens is that the Applicative type class will
    be implicitly resolved, but only if it's possible to implicitly resolve the Monoid
    for the `Left` type's value. If there is no implicit implementation of Monoid
    for `Left` in scope, we will not be able to generate Applicative. This makes sense,
    because the body of Applicative depends on the functionality provided by Monoid
    in order to define its own functionality.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个隐式实现的Applicative类型类，它还依赖于`Either`类型的`Left`类型的隐式`Monoid`类型类的实现。所以，发生的情况是Applicative类型类将被隐式解析，但仅当可以隐式解析`Left`类型值的Monoid时。如果没有在作用域内为`Left`提供Monoid的隐式实现，我们就无法生成Applicative。这很有道理，因为Applicative的主体依赖于Monoid提供的功能来定义其自身的功能。
- en: The only thing to notice about the body of the `ap` function is that it now
    uses the `|+|` operator in order to combine the left elements if both computations
    result in an error.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ap`函数的主体中需要注意的唯一一点是，它现在使用`|+|`运算符来组合两个计算结果都为错误的情况下的左侧元素。
- en: One peculiarity to notice about Monoid is that it is said it is defined not
    for an effective, but for an ordinary type. So, if you look at the signature of
    Monoid again, it is of the kind `Monoid[A]`, not the kind of `Monoid[F[A]]`. So
    far, we have only encountered the type classes that work on effect types, that
    is, the types of the kind `F[A]`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单例（Monoid）的一个需要注意的奇特之处是，它被定义为适用于普通类型，而不是有效类型。因此，如果你再次查看单例的签名，它属于`Monoid[A]`类型，而不是`Monoid[F[A]]`类型。到目前为止，我们只遇到了作用于效果类型的类型类，即`F[A]`类型的类型。
- en: What is the reason for the existence of type classes that work on raw types
    and not effect types? To answer this question, let's remember what the motivation
    for the existence of ordinary type classes that we are familiar with so far was.
    The main motivation for their existence was that certain operations with effect
    types were not convenient to accomplish. We had the need to abstract certain operations
    with effect types. We needed an abstraction to define tools that work on the effect
    types.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么存在作用于原始类型而不是效果类型的类型类呢？为了回答这个问题，让我们回顾一下我们熟悉的普通类型类存在的动机。它们存在的主要动机是某些效果类型的操作不方便完成。我们需要抽象某些效果类型的操作。我们需要一个抽象来定义作用于效果类型的工具。
- en: Effect types are usually data structures, and it is pretty hard to work with
    them ad hoc. You are not usually able to work with them using the capabilities
    built into your language conveniently. Hence, we encountered difficulties working
    with these data types on every corner if we did not have a toolset defined for
    them. Hence, the need for type classes manifests itself mostly for effect types.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 效果类型通常是数据结构，并且很难临时处理它们。您通常无法方便地使用您语言内置的能力来处理它们。因此，如果我们没有为这些数据类型定义工具集，我们在处理这些数据类型时就会遇到困难。因此，类型类的需求主要表现在效果类型上。
- en: Ordinary types like `A` are usually not as hard to work with as data structures.
    Hence, the need for tools and for abstractions over these data types is less obvious
    than for the effect types. However, as we saw previously, there are situations
    where type classes can be useful for raw types as well. The reason we had to define
    a separate type class Monoid for a raw type is in the fact that we needed to generalize
    the feature that the type must be composable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 普通类型如 `A` 通常不像数据结构那样难以处理。因此，对于这些数据类型的工具和抽象的需求不如效果类型明显。然而，正如我们之前所看到的，在某些情况下，类型类对于原始类型也是有用的。我们需要为原始类型定义一个单独的类型类
    Monoid 的原因在于，我们需要泛化类型必须是可组合的这一特性。
- en: Also notice that we can hardly do that using any other technique than type classes.
    An ordinary approach of object-oriented programming to the problem of making sure
    a datatype exposes certain functionality is interfaces. Interfaces must be declared
    at definition time of the class implementing them. So, for example, there is no
    single interface to specify that lists, integers, and strings are composable with
    another with the same method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们几乎只能使用类型类以外的任何技术来做这件事。面向对象编程的普通方法来确保数据类型暴露了某种功能是接口。接口必须在实现它们的类的定义时间声明。因此，例如，没有单一的接口可以指定列表、整数和字符串可以使用相同的方法与其他类型组合。
- en: The only way to specify such an exposure of certain functionality is to define
    an interface as ad hoc. But ordinary object-oriented programming does not provide
    you with the capability to inject interfaces into already implemented classes.
    This cannot be said about type classes. With type classes, whenever you want to
    capture that a type exposes a certain functionality, you can define a type class
    as ad hoc. You can also define in which way exactly a class exhibits this functionality
    by defining and implementing this type class for this particular class. Notice
    exactly when it is done. This operation can be done in any part of the program.
    So, whenever you need to make it explicit that a type exhibits certain functionality
    and has this functionality in common with other types, you are able to do so by
    defining a type class that captures this functionality.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 指定此类特定功能暴露的唯一方法是将接口定义为临时的。但是，普通的面向对象编程并不提供将接口注入已实现类的能力。这一点并不适用于类型类。使用类型类，每当您想要捕捉一个类型暴露了某种功能时，您都可以定义一个临时的类型类。您还可以通过为这个特定类定义和实现这个类型类来精确地定义一个类如何展示这种功能。请注意具体操作的时间点。这种操作可以在程序的任何部分进行。因此，每当您需要明确指出一个类型展示了某种功能并且与其他类型具有这种共同功能时，您都可以通过定义一个捕获这种功能的类型类来实现这一点。
- en: This kind of extensibility provides you with a greater level of flexibility
    that is hard to achieve with ordinary object-oriented programming techniques such
    as, for example, those in Java. In fact, it can be argued that it is sufficient
    for the programmer to drop the object-oriented style of interfaces altogether
    and resort to only using the type classes. In the style of programming Haskell
    is based on, there is a strict separation of data and behavior.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的可扩展性为您提供了普通面向对象编程技术（例如 Java 中的技术）难以达到的更高灵活性。事实上，可以争论说，程序员完全可以放弃接口的面向对象风格，而只使用类型类。在
    Haskell 所基于的编程风格中，数据和行为的分离是严格的。
- en: MonoidK
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MonoidK
- en: 'Previously, we saw the version of Monoid that works on all types. A version
    of Monoid also exists that operates on effect types, that is, on the types of
    the kind of `F[A]`. This type class is called `MonoidK`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了适用于所有类型的 Monoid 版本。也存在一种 Monoid 版本，它操作于效果类型，即 `F[A]` 类型的类型。这个类型类被称为
    `MonoidK`：
- en: '![](img/9518c592-e97f-40ca-89fe-c850a3020a58.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9518c592-e97f-40ca-89fe-c850a3020a58.png)'
- en: So, as you can see, the method is defined for an effect type, and instead of
    the `combined` method that works on two types, `A`, `MonoidK` defines a method
    called `combineK`, which works on values of type `F[A]`. Also notice that this
    method is parametrized by the type `A` on the method level and not on the level
    of the type class itself, which means that you can have the single type class
    defined for some effect type, `F[_]`, and you can use it for arbitrary `A` in
    the context of `F[A]`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，这个方法是为效果类型定义的，并且不是在类型类的层面上，而是在方法层面上参数化类型 `A`。这意味着你可以为某些效果类型 `F[_]`
    定义单个类型类，并且你可以用它来处理 `F[A]` 上下文中的任意 `A`。
- en: 'This example can be useful when combining lists. While it is not really an
    effect type, because a `List` is a data structure that does not encapsulate any
    side effects, it is still a type of the form `F[A]`. We can imagine an implementation
    of `combinedK` for it as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在组合列表时可能很有用。虽然它实际上不是一个效果类型，因为 `List` 是一个不封装任何副作用的数据结构，但它仍然是形式为 `F[A]` 的类型。我们可以想象如下实现
    `combinedK`：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, in the preceding code, we are able to implement the method in a manner that
    is independent of type `A` because the behavior of the combination of two lists
    is independent of the type of the elements that are contained in them. This combination
    is just a concatenation of the elements of one list with the elements of another
    list to form one combined list.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的代码中，我们能够以独立于类型 `A` 的方式实现这个方法，因为两个列表组合的行为与包含在其中的元素类型无关。这种组合只是将一个列表的元素与另一个列表的元素连接起来，形成一个组合列表。
- en: Also notice the `algebra` method here. This method can be used to obtain a `Monoid`
    instance from the `MonoidK` instance. This can be useful in cases where you need
    a `Monoid` instance, but you only have `MonoidK`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意这里的 `algebra` 方法。这个方法可以用来从 `MonoidK` 实例获得 `Monoid` 实例。这在需要 `Monoid` 实例但只有
    `MonoidK` 的情况下可能很有用。
- en: Traverse
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Traverse
- en: Previously, we learned about the Applicative type class. We argued that the
    main utility of the Applicative type class is that it allows us to combine two
    independent computations in parallel. No longer are we bound by the `flatMap`
    function that performs sequential composition, so that if one computation fails
    then no other computation is ever performed. In the Applicative scenario, all
    of the computations are performed, despite the fact that some of them can fail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了 Applicative 类型类。我们争论说，Applicative 类型类的主要效用是它允许我们并行组合两个独立的计算。我们不再受执行顺序组合的
    `flatMap` 函数的约束，因此如果一个计算失败，则不会执行其他任何计算。在 Applicative 情景中，尽管一些计算可能会失败，但所有计算都会被执行。
- en: However, Applicative is only able to combine two independent computations. There
    are also methods to combine up to 22 computations into tuples. However, what if
    we need to combine an arbitrary amount of computations? The usual generalization
    for multiplicity is collections. Tuples are just special cases of collections.
    So, if there is a type class for combining independent computations into tuples,
    there must be a type class for combining independent computations into collections.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Applicative 只能组合两个独立的计算。也有方法将多达 22 个计算组合成元组。但是，如果我们需要组合任意数量的计算呢？对于多重性的通常推广是集合。元组只是集合的特殊情况。所以，如果有一个类型类可以将独立的计算组合成元组，那么也必须有一个类型类可以将独立的计算组合成集合。
- en: To illustrate this scenario, consider our example we we're working with in Applicative
    case. What if we have an arbitrary list of mathematical expressions computed under
    the parallel operator, and we have a function that is supposed to combine them
    by summing them up? What might such a function look like?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种情况，考虑我们在 Applicative 情况下正在处理的一个例子。如果我们有一个在并行运算符下计算出的任意数学表达式列表，并且有一个函数应该通过求和来组合它们，这样的函数可能是什么样子？
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, the preceding function takes a list of the results of the computations,
    and its job is to produce a combined result of all of the computations. This result
    will be of the type `Either[List[String], List[Double]]` type, which means that
    we also need to aggregate all of the errors that happened in all of the computationals
    we are trying to combine. How would we go about it in the case of Applicative?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的函数接受一个计算结果的列表，其任务是产生所有计算的组合结果。这个结果将是`Either[List[String], List[Double]]`类型，这意味着我们还需要聚合所有我们在尝试组合的计算中发生的所有错误。在Applicative的情况下，我们该如何处理呢？
- en: What we need to do is take the first element of the list, combine it with the
    second element of the list using the `ap` function, add the results together to
    obtain an `Either` as a result, and combine this result with the third element,
    and so on.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是取列表的第一个元素，使用`ap`函数将其与列表的第二个元素结合，将结果相加以获得一个`Either`类型的结果，然后将这个结果与第三个元素结合，依此类推。
- en: 'In fact, there is a type class to perform just that. Meet the `Traverse` type
    class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一个类型类可以执行这个操作。认识一下`Traverse`类型类：
- en: '![](img/ca9ec1bf-e863-4365-a00a-36b5c5eb9a10.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca9ec1bf-e863-4365-a00a-36b5c5eb9a10.png)'
- en: 'The main point of interest of the `Traverse` type class is the `traverse` method.
    Let''s take a look at its signature:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traverse`类型类的关注点主要是`traverse`方法。让我们看看它的签名：'
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The signature of this method is very abstract. So, let's give all the types
    involved a little bit more context. In the preceding signature, consider that
    type `F` is a collection type. Consider that type `G` is an effect type.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的签名非常抽象。所以，让我们给所有涉及的类型提供更多一些的上下文。在上面的签名中，考虑类型`F`是一个集合类型。考虑类型`G`是一个效果类型。
- en: This means that traverse takes a collection as its first argument—a collection
    of some arbitrary raw elements, `A`. The second argument is similar to what we
    saw in `flatMap`. It is a side effecting computation that works on the elements
    of the collection we saw as the first argument. So, the idea is that you have
    a collection of some elements, `A`, and a computation that you can run on these
    elements, `A`. However, this computation is side effecting. The side effects from
    this computation are wrapped into the effect type `G`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`traverse`函数接受一个集合作为其第一个参数——一个包含一些任意原始元素的集合`A`。第二个参数类似于我们在`flatMap`中看到的内容。它是一个对第一个参数中集合的元素进行操作的副作用计算。所以，想法是，你有一个包含一些元素的集合`A`，你可以对这些元素运行一个计算`A`。然而，这个计算是具有副作用的。这个计算的副作用被封装到效果类型`G`中。
- en: What would happen if you ran such a computation on every element of the collection?
    What would happen if you map collection `F` with the help of this operation?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个集合的每个元素上运行这样的计算会发生什么？如果你使用这个操作映射集合`F`会发生什么？
- en: The result type that you would expect to get is this: `F[G[B]]`. So, you will
    get a collection of effect types that are the results of the computation that
    you've run on every element of the original collection.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望得到的结果类型是：`F[G[B]]`。所以，你将得到一个包含效果类型的集合，这些类型是你对原始集合的每个元素运行计算的结果。
- en: 'Returning to our example of `Either` that we need to combine together, we would
    get the following result:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们需要组合的`Either`示例。我们会得到以下结果：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we are not looking for this. We are looking to obtain a list of all
    the results of our computation under the effect type `Either`. In the case of
    Applicative, the `ap` method was taking the results of side effecting computations
    and combining them under their common effect type. So, in the case of `ap` and
    `zip` based on it, we had the following results:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不是在寻找这个。我们想要获得一个在效果类型`Either`下的所有计算结果的列表。在Applicative的情况下，`ap`方法接受副作用计算的结果，并将它们组合在它们共同的效果类型下。所以，在`ap`和基于它的`zip`的情况下，我们有以下结果：
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, in our generalized case, the role of tuple is replaced by `List`. Therefore,
    we are aiming for the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的泛化情况下，元组的作用被`List`所取代。因此，我们的目标是以下内容：
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's return to our `traverse` function. Let's take a look at its result
    type. The result of this function is `G[F[B]]`. `G` is an effect type. `F` is
    a collection type. So, all of the results of the computations are combined into
    a single collection under an effect type, `G`. This is precisely what we were
    aiming at in the case of `Either`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`traverse`函数。让我们看看它的结果类型。这个函数的结果是`G[F[B]]`。`G`是一个效果类型。`F`是一个集合类型。所以，所有计算的结果都组合成一个单一的集合，在效果类型`G`下。这正是我们在`Either`的情况下所追求的。
- en: So, this makes `Traverse` a more generic case of Applicative that can be used
    for situations where you do not know how many computations you are going to combine
    ahead of time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这使得`Traverse`成为了一个更通用的Applicative情况，可以用于你事先不知道将要组合多少计算的情况。
- en: A word of caution here. We have also discussed that the type `F` is a collection
    type and that the type `G` is an effect type. You should remember that this constraint
    is not encoded into a type class itself. We have imposed this constraint in order
    to be able to develop an intuition for the type class. So, potentially, you might
    come up with some more advanced uses of the `Traverse` type class that go beyond
    this collection. However, in your projects, you will be using it in the context
    of collections the most frequently.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提醒大家注意。我们之前也讨论过，类型`F`是一个集合类型，而类型`G`是一个效果类型。你应该记住，这个约束并没有编码到类型类本身中。我们施加这个约束是为了能够对类型类有一个直观的理解。因此，你可能会有一些更高级的`Traverse`类型类的使用方法，这些方法超出了这个集合的范围。然而，在你的项目中，你将最频繁地在集合的上下文中使用它。
- en: 'Let''s take a look at what our example might look like with the help of `Traverse`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助`Traverse`来看看我们的示例可能是什么样子：
- en: '[PRE44]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can further enhance this example if we use the `combineAll` method from
    the `Traverse` type class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Traverse`类型类的`combineAll`方法，我们可以进一步增强这个示例：
- en: '[PRE45]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The examples are introduced in the context of the following type classes that
    are defined:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在定义的以下类型类上下文中引入的示例：
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`combinedAll` works on some collection, `F[A]`, and produces the result `A`
    out of this collection, given `Monoid[A]` in scope. The Monoid defines how to
    combine two elements, `A`, into one element, `A`. `F[A]` is a collection of elements, `A`.
    So, given a collection of elements, `A`, `combineAll` is capable of combining
    all of the elements and computing a single result, `A`, with the help of the Monoid
    in scope that defines a binary composition operation.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinedAll`在某个集合`F[A]`上工作，并在作用域内有`Monoid[A]`的情况下，从这个集合中产生结果`A`。Monoid定义了如何将两个元素`A`组合成一个元素`A`。`F[A]`是元素`A`的集合。所以，给定一个元素集合`A`，`combineAll`能够结合所有元素，并借助作用域内定义的二进制组合操作的Monoid来计算一个单一的结果`A`。'
- en: One thing to notice here is that the type classes of `cats` form an ecosystem
    and frequently depend one on another. In order to obtain an instance of a certain
    type class for a certain type, you might discover that it is implicitly dependent
    on an instance of another type class. For other type classes, you can discover
    that some of its methods are dependent on some other type class implicitly, just
    like in the case of `combineAll` depending on Monoid.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`cats`的类型类形成了一个生态系统，并且经常相互依赖。为了获得某个类型的某个类型类的实例，你可能会发现它隐式地依赖于另一个类型类的实例。对于其他类型类，你可能会发现它的一些方法隐式地依赖于其他类型类，就像`combineAll`依赖于Monoid的情况一样。
- en: This connection can be used to the advantage of a learner of purely functional
    programming. This kind of ecosystem means that you can start very small. You can
    start by using one or two type classes that you understand. Since the `Cats` library
    forms an ecosystem of dependent type classes, you will encounter situations where
    your familiar type classes will depend on type classes that you still do not know.
    Therefore, you will need to learn about the other type classes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种联系可以用来帮助纯函数编程的学习者。这种类型的生态系统意味着你可以从非常小的地方开始。你可以从使用你理解的一个或两个类型类开始。由于`Cats`库形成了一个依赖类型类的生态系统，你可能会遇到你的熟悉类型类依赖于你还不了解的类型类的情况。因此，你需要了解其他类型类。
- en: Other things that we need to notice about the type classes that we have learned
    about so far is that they are pretty generic and language independent. What it
    encodes is the relationships and the transformations between types. This can be
    encoded in any language of your choosing. For example, in Haskell, the language
    is built around the idea of type classes. So, if you look at Haskell, you will
    find that it also contain the type classes that we have covered in this chapter.
    As a matter of fact, there is an entire mathematical theory that deals with these
    concepts and defines the type classes that we have covered, called the **category
    theory**. That means that we could have discussed type classes from a mathematical
    perspective without touching programming at all. Therefore, the concepts of the
    type classes are language independent and have a solid mathematical foundation.
    We have extensively covered a library that is specific to Scala, but the concepts
    that we have covered are language independent. In one form or another, they are
    implemented in all of the languages that support purely functional styles.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的关于我们迄今为止所学的类型类的一些其他事情是，它们相当通用且与语言无关。它们编码的是类型之间的关系和转换。这可以用你选择的任何语言来编码。例如，在
    Haskell 中，语言是围绕类型类的概念构建的。因此，如果你查看 Haskell，你会发现它也包含了我们在本章中涵盖的类型类。实际上，有一个完整的数学理论处理这些概念，并定义了我们涵盖的类型类，称为**范畴论**。这意味着我们可以从数学的角度讨论类型类，而不涉及任何编程。因此，类型类的概念是语言无关的，并且有一个坚实的数学基础。我们已经广泛地覆盖了一个特定于
    Scala 的库，但我们涵盖的概念是语言无关的。以某种形式或另一种形式，它们在所有支持纯函数式风格的编程语言中都有实现。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we had an in-depth look at the system of type classes used
    in purely functional programming. We take a look at the library, that is, a standard
    library for purely functional programming. We had our first look at the structure
    of the library and we found out that it is composed of separate models for the
    type classes, the syntax, and the effect types.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在纯函数式编程中使用的类型类系统。我们审视了库，即纯函数式编程的标准库。我们首次了解了库的结构，并发现它由类型类、语法和效果类型的独立模型组成。
- en: Then, we had an in-depth look at some type classes that are defined by the library.
    We saw the motivation for their existence, as well as their implementation and
    usage details. One thing to remember about all of the type classes is that they
    are not Scala specific. In fact, there is an entire mathematical theory that deals
    with them in a manner that is independent from any programming language at all.
    This is called category theory. So, if you know the concepts from one programming
    language, we are able to use them in any programming language that supports the
    functional style.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入研究了由库定义的一些类型类。我们看到了它们存在的动机，以及它们的实现和使用细节。关于所有类型类要记住的一件事是，它们不是 Scala 特有的。实际上，有一个完整的数学理论以与任何编程语言无关的方式处理它们。这被称为范畴论。所以，如果你了解一种编程语言的概念，我们就能在支持函数式风格的任何编程语言中使用它们。
- en: Cats provides us with effective functional programming tools. However, we need
    higher-level libraries to write industrial-grade software such as web application
    backends. In the next chapter, we will see more advanced functional libraries
    that build on the basic ones.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 为我们提供了有效的函数式编程工具。然而，我们需要更高级的库来编写工业级软件，例如网络应用的后端。在下一章中，我们将看到更多基于基本库的高级函数式库。
- en: Questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the motivation to organize type classes into libraries?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型类组织到库中的动机是什么？
- en: What methods does Traverse define?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Traverse 定义了哪些方法？
- en: Which real-world scenario would we use Traverse in?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会在哪种现实场景中使用 Traverse？
- en: What methods does Monad define?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Monad 定义了哪些方法？
- en: Which real-world scenario would we use Monad in?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会在哪种现实场景中使用 Monad？
- en: What is the structure of the Cats library?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cats 库的结构是怎样的？
