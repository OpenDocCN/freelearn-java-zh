- en: Chapter 5. Digital Signatures and Encryption of Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：数字签名和消息加密
- en: Since many systems interact with each other to achieve their business goals,
    we often feel the obligation to interact with services exposed by others. Also,
    when security needs play an important role, we must verify that the information
    we receive has been sent from whom we expected, and it has come without being
    altered. It is here where digital signatures will play an important role and help
    us meet this need.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多系统相互作用以实现其业务目标，我们常常感到有必要与别人公开的服务进行交互。此外，当安全需求扮演重要角色时，我们必须验证我们接收到的信息是否来自我们期望的人，并且它没有在传输过程中被修改。正是在这里，数字签名将发挥重要作用，帮助我们满足这一需求。
- en: Also, we may sometimes need to encrypt the message body to prevent it from being
    read if intercepted by unwanted persons. It is here where we can make use of Secure/Multipurpose
    Internet Mail Extensions, or the S/MIME standard, which is commonly used in the
    world of e-mail for public keys ([http://en.wikipedia.org/wiki/Public_key](http://en.wikipedia.org/wiki/Public_key)),
    encryption ([http://en.wikipedia.org/wiki/Encryption](http://en.wikipedia.org/wiki/Encryption)),
    and signing ([http://en.wikipedia.org/wiki/Digital_signature](http://en.wikipedia.org/wiki/Digital_signature))
    of MIME data ([http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME)),
    and which also offers the ability to adapt the HTTP protocol and allows us to
    use it on RESTful web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有时可能需要加密消息体，以防止它被不受欢迎的人拦截后阅读。正是在这里，我们可以利用安全/多用途互联网邮件扩展（Secure/Multipurpose
    Internet Mail Extensions），或称S/MIME标准，这在电子邮件领域被广泛用于公钥（[http://en.wikipedia.org/wiki/Public_key](http://en.wikipedia.org/wiki/Public_key)）、加密（[http://en.wikipedia.org/wiki/Encryption](http://en.wikipedia.org/wiki/Encryption)）和签名（[http://en.wikipedia.org/wiki/Digital_signature](http://en.wikipedia.org/wiki/Digital_signature)）MIME数据（[http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME)），并且它还提供了适应HTTP协议的能力，使我们能够在RESTful
    Web服务中使用它。
- en: 'In this chapter, we are going to learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Signing messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名消息
- en: Verifying signatures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证签名
- en: Encrypting message bodies with S/MIME
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用S/MIME加密消息体
- en: Digital signatures
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名
- en: Digital signatures, nowadays, are a widely used mechanism. They are mainly used
    to sign digital documents and issue electronic invoices, among other things.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数字签名是一种广泛使用的机制。它们主要用于签署数字文档和发行电子发票等。
- en: 'Among the benefits of using them are the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的优点包括以下内容：
- en: They allow the receiver to obtain the identity of whoever has made the signature.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许接收者获得签名者的身份。
- en: They provide the ability to verify that the information sent has not been altered
    since it has been signed by the issuer.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一种能力，可以验证发送的信息自签发以来未被修改。
- en: In order to electronically sign the information that we will exchange through
    RESTful web services, we will use the authentication mechanism known as **DomainKeys
    Identified Mail** (**DKIM**), which allows us to decorate messages with headers
    using the rules dictated by the DOSETA specification. This authentication mechanism
    is mainly used for e-mail identity verification; however, it also works over other
    protocols such as HTTP, and it is because of this fact we can integrate it with
    RESTful web services. Thus, we will inject metadata into our messages with the
    purpose of signing, and these signatures can be verified by those who wish to
    consume.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过RESTful Web服务电子签名我们将交换的信息，我们将使用名为**域密钥识别邮件**（DomainKeys Identified Mail，**DKIM**）的认证机制，它允许我们使用DOSETA规范规定的规则装饰消息的头部。这种认证机制主要用于电子邮件身份验证；然而，它也可以在其他协议如HTTP上工作，正因为如此，我们可以将其集成到RESTful
    Web服务中。因此，我们将注入用于签名的元数据到我们的消息中，这些签名可以被希望消费它们的人验证。
- en: At this time, we will build an example that shows how to sign a message, and
    then dissect each part of it to understand its operation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们将构建一个示例，展示如何签名一条消息，然后剖析它的每个部分来理解其操作。
- en: 'If you want, you can download the source code using the following link on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以使用以下GitHub链接下载源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures)'
- en: 'Otherwise, we will explain it in the following pages. Let''s start by creating
    a new project. Open the terminal and type the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将在以下页面中解释它。让我们先创建一个新的项目。打开终端并输入以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When it asks you for the version, change the default value `1.0-SNAPSHOT` to
    `1.0`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当它要求你输入版本时，将默认值 `1.0-SNAPSHOT` 更改为 `1.0`
- en: Now, we will generate the keys that allow us to encrypt messages and place them
    in the classpath of our application. For this, we will first import the project
    into Eclipse IDE and then create a folder within the project in which we place
    the keys that we want to generate. In Eclipse, right-click on the new project
    named `signatures` and select the option **New** | **Source folder**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将生成允许我们加密消息的密钥，并将它们放置在我们的应用程序的类路径中。为此，我们首先将项目导入到 Eclipse IDE 中，然后在项目中创建一个文件夹，我们将要生成的密钥放置在这个文件夹中。在
    Eclipse 中，右键单击名为 `signatures` 的新项目，并选择 **新建** | **源文件夹**。
- en: In the field **Folder name**, we will enter `src/main/resources`, and then we
    press the **Finish** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **文件夹名称** 字段中，我们将输入 `src/main/resources`，然后点击 **完成** 按钮。
- en: 'Now, let''s go to this directory from the command line and execute the following
    instruction:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从命令行进入这个目录并执行以下指令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we should enter a password for both the KeyStore and the keys with which
    we will sign the message. When it asks you for a password, type `changeit`, which
    is the same password we have been using so far in our examples in this book. Then,
    we enter the requested information as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该为 KeyStore 和我们将用于签名消息的密钥输入一个密码。当它要求你输入密码时，输入 `changeit`，这是我们在这本书的示例中一直使用的相同密码。然后，我们输入如下截图所示的信息：
- en: '![Digital signatures](img/0109OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![数字签名](img/0109OS_05_01.jpg)'
- en: Now, we will implement some source code to sign a message. We first need to
    add the required dependencies to the `pom.xml` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一些源代码来签名一个消息。我们首先需要将所需的依赖项添加到 `pom.xml` 文件中。
- en: 'First, add the JBoss repository from which we get the artifacts, as shown in
    the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加从其中获取工件的自定义 JBoss 存储库，如下代码所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s add all the dependencies we need to sign our message, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加所有我们需要签名消息的依赖项，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the purpose of avoiding duplicated classes in the classpath, we should
    delete the following dependency:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免类路径中重复的类，我们应该删除以下依赖项：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating RESTEasy JAR files
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 RESTEasy JAR 文件
- en: As we are using the 3.0.6.Final Version to compile the project, it is necessary
    to update the existing versions in JBoss. So, we will go to the URL [http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/](http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/)
    and download the version we just described.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 3.0.6.Final 版本来编译项目，因此有必要更新 JBoss 中的现有版本。因此，我们将前往 URL [http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/](http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/)
    并下载我们刚刚描述的版本。
- en: 'When we unzip the `.zip` file, we will find a file named `resteasy-jboss-modules-3.0.6.Final.zip`.
    Let''s unzip this file too, and then paste all its content in our directory `JBOSS_HOME/modules`.
    Given RESTEasy modules have dependencies, we have to update them too. So, after
    we update the RESTEasy modules, we should update the module `org.apache.httpcomponents`.
    Let''s go to the directory `JBOSS_HOME/modules/org/apache/httpcomponents` and
    update the following artifacts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解压 `.zip` 文件时，我们会找到一个名为 `resteasy-jboss-modules-3.0.6.Final.zip` 的文件。让我们也解压这个文件，然后将所有内容粘贴到我们的目录
    `JBOSS_HOME/modules` 中。由于 RESTEasy 模块有依赖项，我们还需要更新它们。因此，在更新 RESTEasy 模块后，我们应该更新模块
    `org.apache.httpcomponents`。让我们前往目录 `JBOSS_HOME/modules/org/apache/httpcomponents`
    并更新以下工件：
- en: '`httpclient-4.1.2.jar` to `httpclient-4.2.1.jar`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `httpclient-4.1.2.jar` 更新为 `httpclient-4.2.1.jar`
- en: '`httpcore-4.1.4.jar` to `httpcore-4.2.1.jar`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `httpcore-4.1.4.jar` 更新为 `httpcore-4.2.1.jar`
- en: 'Also, we modify the `module.xml` file because the names of the JAR files are
    different, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们修改 `module.xml` 文件，因为 JAR 文件的名字不同，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Applying digital signatures
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数字签名
- en: 'Now that we have everything we need to compile our project, we will create
    a very simple operation and apply a signature. In order to achieve this, let''s
    create a class called `SignedService` in the source code package called `com.packtpub.resteasy.services`,
    as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了编译我们项目所需的一切，我们将创建一个非常简单的操作并应用签名。为了实现这一点，让我们在源代码包 `com.packtpub.resteasy.services`
    中创建一个名为 `SignedService` 的类，如下截图所示：
- en: '![Applying digital signatures](img/0109OS_05_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![应用数字签名](img/0109OS_05_02.jpg)'
- en: To sign a message, we take a key from the KeyStore and use it. We can identify
    the keys in a unique way through their alias and the domain they belong to. For
    example, for the key `demo._domainKey.packtpub.com`, the alias is `demo` and the
    domain it belongs to is the key `packtpub.com`. Given that we can find several
    keys in a KeyStore, RESTEasy offers the capability to select the one we want by
    using the annotation `@Signed`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要签名消息，我们从KeyStore中取一个密钥并使用它。我们可以通过它们的别名和它们所属的域以独特的方式识别密钥。例如，对于密钥`demo._domainKey.packtpub.com`，别名是`demo`，它所属的域是密钥`packtpub.com`。鉴于我们可以在KeyStore中找到多个密钥，RESTEasy提供了使用注解`@Signed`选择我们想要的密钥的能力。
- en: 'Let''s add the method highlighted in the following code to the class and watch
    how the annotation works:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码中突出显示的方法添加到类中，并观察注解是如何工作的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following figure shows us in a better way how the key is selected to sign
    the message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以更好的方式展示了如何选择密钥来签名消息：
- en: '![Applying digital signatures](img/0109OS_05_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![应用数字签名](img/0109OS_05_03.jpg)'
- en: 'Now, we will define the path under our signed resources will be available,
    so let''s annotate the class as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义在签名资源下的路径将可用，因此让我们按照以下方式注释类：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to make the application work properly, we will give it information
    so that it can apply the appropriate signatures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序正常工作，我们将提供信息，以便它可以应用适当的签名。
- en: First, in the folder `src/main/webapp`, we will create the `WEB-INF` folder
    with an empty `web.xml` file inside.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`src/main/webapp`文件夹中，我们将创建一个包含空`web.xml`文件的`WEB-INF`文件夹。
- en: 'Let''s start with the `web.xml` file, which should look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`web.xml`文件开始，它应该看起来如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the first thing we will do is tell our application what resource we want
    to sign, which is the class that contains the method that we are signing. For
    this, let''s configure the parameter `resteasy.resources` with the corresponding
    full class name, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们首先要做的是告诉我们的应用程序我们想要签名的资源是什么，即包含我们正在签名的方法的类。为此，让我们使用相应的完整类名配置参数`resteasy.resources`，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will inform our application of the location of the key with which
    we apply the signature (the `.jks` file we created earlier). For this, we have
    two context parameters available, `resteasy.doseta.keystore.classpath` and `resteasy.keystore.filename`.
    Let''s use the first parameter so that our file looks like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通知我们的应用程序应用签名的密钥的位置（我们之前创建的`.jks`文件）。为此，我们有两个上下文参数可用，`resteasy.doseta.keystore.classpath`和`resteasy.keystore.filename`。让我们使用第一个参数，以便我们的文件看起来如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you remember, we were asked for a password for the KeyStore when creating
    the key. We will tell our application what this is using the parameter `resteasy.doseta.keystore.password`.
    Let''s add the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，在创建密钥时，我们被要求为KeyStore提供密码。我们将使用参数`resteasy.doseta.keystore.password`告诉我们的应用程序这是什么。让我们添加以下内容：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create the KeyStore from which we will extract the key that will allow us
    to sign the message, we must add the following parameter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建KeyStore，从中我们将提取允许我们签名消息的密钥，我们必须添加以下参数：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we should add the RESTEasy servlet, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该添加RESTEasy servlet，如下所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we show how the `web.xml` file should look once you have finished adding
    all the required information:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了在添加所有必需信息后`web.xml`文件应该如何看起来：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s generate the WAR file by executing the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行以下命令生成WAR文件：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this, we will copy the generated artifact in to the JBoss deploy directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将生成的工件复制到JBoss部署目录。
- en: Testing the functionality
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试功能
- en: 'Now, open SoapUI and test whether the web service is running as expected, as
    shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开SoapUI，测试是否如以下截图所示，web服务按预期运行：
- en: '![Testing the functionality](img/0109OS_05_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_04.jpg)'
- en: 'As you can see in the response, we obtain the `DKIM-Signature` header used
    to sign the message. The full content of this header is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在响应中看到的，我们获得了用于签名消息的`DKIM-Signature`头。此头的完整内容如下：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From this whole string, what is important for us are the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个字符串中，对我们来说重要的是以下内容：
- en: '`d=`: This is the domain, the value which is indicated at the time we implement
    the method.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d=`: 这是域，在实现方法时指示的值。'
- en: '`a=`: This is the algorithm used by RESTEasy to sign the message. In this case,
    we use RSA because it is the only algorithm that is supported to date by the framework.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a=`：这是RESTEasy用来签名消息的算法。在这种情况下，我们使用RSA，因为它是目前框架唯一支持的算法。'
- en: The other parameters are not very important, and they are only necessary for
    a signed message.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数并不重要，它们只是为了一个签名的消息。
- en: Now, in order to validate the authenticity of the signature, we will create
    a class from which we will make the verification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证签名的真实性，我们将创建一个类，我们将从这个类中进行验证。
- en: 'We will use JUnit; so, first add the corresponding dependency in the `pom.xml`
    file, as shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JUnit；因此，首先在 `pom.xml` 文件中添加相应的依赖项，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s create a new source folder named `scr/test/java` and a package
    named `com.packtpub.resteasy.services.test` inside it. Inside the package, let''s
    create the class `SignedServiceTest` using the following content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的源文件夹名为 `scr/test/java`，并在其中创建一个名为 `com.packtpub.resteasy.services.test`
    的包。在包内部，让我们使用以下内容创建一个名为 `SignedServiceTest` 的类：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If everything goes well, we will see a green bar as a result of our test, as
    shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到测试结果是一个绿色的条形，如下面的截图所示：
- en: '![Testing the functionality](img/0109OS_05_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_05.jpg)'
- en: Validating signatures with annotations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注解验证签名
- en: A simpler way to validate whether a resource is signed is to use annotations.
    This solution can be used mainly when you have a flow of signatures that must
    be met.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 验证资源是否签名的更简单方法是使用注解。这种解决方案主要适用于你必须满足的签名流。
- en: 'For example, imagine that employees of the company Packt Publishing have a
    system through which they can apply to increase the RAM of their computers. To
    treat such requests as valid, they must be signed by the person making the request.
    We mean that we only need that the request be signed to be considered valid, as
    shown in the following figure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，Packt Publishing 公司的员工可以通过一个系统申请增加他们的电脑的RAM。为了将这些请求视为有效，它们必须由提出请求的人签名。我们的意思是，我们只需要请求被签名，才能被认为是有效的，如下面的图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用注解验证签名](img/0109OS_05_06.jpg)'
- en: 'For this example, we will add two methods to our `SignedService` class; the
    first method will allow us to send the requests, as shown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将向我们的 `SignedService` 类添加两种方法；第一个方法将允许我们发送请求，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To meet the business requirements, we will use the `@Verify` annotation in which
    we can add restrictions on signatures. For now, we only need to verify that the
    request is signed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足业务需求，我们将使用 `@Verify` 注解，在其中我们可以对签名添加限制。目前，我们只需要验证请求是否已签名。
- en: 'The following is the method that shows all the complicated logic used by the
    boss to approve or deny memory increases to employee PCs:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个方法，展示了老板用来批准或拒绝为员工PC增加内存的复杂逻辑：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s deploy the application on JBoss and test it with SoapUI. As we
    have mentioned, the requests must be signed in order to be processed. So, first
    make a request to the method `processRequestRam` without a signature, as shown
    in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 JBoss 上部署应用程序，并使用 SoapUI 进行测试。正如我们提到的，为了处理请求，请求必须经过签名。因此，首先对 `processRequestRam`
    方法发送一个不带签名的请求，如下面的截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用注解验证签名](img/0109OS_05_07.jpg)'
- en: What is essential for the application to be processed is that it comes from
    the company domain, in this case, `packtpub.com`. Later, the boss conducts a rigorous
    analysis of the application and issues a judgment to determine whether the application
    is approved or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序能够被处理来说，最重要的是它来自公司域，在这种情况下，是 `packtpub.com`。之后，老板对申请进行严格的分析，并做出判断，以确定申请是否被批准或拒绝。
- en: 'For this example, we will remove the method that we created earlier and add
    two methods to our `SignedService` class; the first method will allow us to send
    the requests, as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将删除我们之前创建的方法，并向我们的 `SignedService` 类添加两种方法；第一个方法将允许我们发送请求，如下所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output shows us the error very clearly. The request couldn't be processed
    because there is no `DKIM-Signature` header that contains the information to verify
    the signature. This means that the headers aren't there because they weren't signed
    earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了错误。请求无法处理，因为没有包含验证签名的信息的 `DKIM-Signature` 标头。这意味着这些头信息不存在，因为它们之前没有被签名。
- en: In order to get the request successfully processed, we will call a web service
    that signs the request. We will add the headers with the signature information
    and call the `processRequestRam` method again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理请求，我们将调用一个签名的Web服务。我们将添加带有签名信息的头，并再次调用`processRequestRam`方法。
- en: 'Let'' start by calling the `requestRam` operation, as shown in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先调用`requestRam`操作，如下截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_08.jpg)'
- en: 'As a result of this callback, we will obtain the following values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个回调，我们将获得以下值：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s keep moving! Now, we will use these values to make a request. From SoapUI,
    let''s invoke the `processRequestRam` operation and focus on the bottom-left area
    of our request editor; there is an option that says **Header**. Let''s select
    this option and click on the **+** symbol. Now, we have to enter the `DKIM-Signature`
    header and place the corresponding value. Also, don''t forget to send the request
    parameter `8-GB` that was the response of the invocation of the `requestRam` operation,
    as highlighted in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进！现在，我们将使用这些值发出请求。从SoapUI中，让我们调用`processRequestRam`操作，并关注请求编辑器的左下角；那里有一个名为**Header**的选项。让我们选择这个选项，并点击**+**符号。现在，我们必须输入`DKIM-Signature`头，并放置相应的值。同时，别忘了发送请求参数`8-GB`，这是`requestRam`操作的响应，如以下截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_09.jpg)'
- en: 'As we can see, the request was successfully processed, but the boss denied
    the increase of memory. Now, we indicate that digital signatures allow us to validate
    that the information is not altered once it has been signed. Suppose malicious
    software intercepted the response, and instead of `8-GB`, it delivered the value
    `12-GB`. Let''s make this request in SoapUI following the theory of digital signatures.
    This request should not be valid; however, we must check:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，请求已成功处理，但老板拒绝了内存增加的请求。现在，我们指出数字签名允许我们验证信息在签名后未被篡改。假设恶意软件拦截了响应，并且不是`8-GB`，而是提供了`12-GB`的值。让我们根据数字签名的理论在SoapUI中发出这个请求。这个请求应该是不合法的；然而，我们必须检查：
- en: '![Validating signatures with annotations](img/0109OS_05_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_10.jpg)'
- en: The error message clearly indicates that the message body was altered, so the
    request is not processed and we get the `HTTP 401 Unauthorized` message. This
    corroborates the statement made before regarding the integrity of the signed messages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息清楚地表明消息体已被篡改，因此请求未处理，我们收到`HTTP 401 Unauthorized`消息。这证实了之前关于已签名消息完整性的陈述。
- en: 'RESTEasy allows us, however, to do more than just validate that a message has
    been signed. We can verify that the signer belongs to a specific domain. In our
    example, a firm would be considered valid only when it comes under the `packtpub.com`
    domain. To perform this type of control, we will make the following change:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RESTEasy不仅允许我们验证消息已被签名，我们还可以验证签名人是否属于特定域名。在我们的例子中，只有当公司属于`packtpub.com`域名时，才会被认为是有效的。为了执行此类控制，我们将进行以下更改：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s deploy the application in JBoss and execute the request again from SoapUI:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在JBoss中部署应用程序，并再次从SoapUI中执行请求：
- en: '![Validating signatures with annotations](img/0109OS_05_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_11.jpg)'
- en: 'Now, let''s force a fault. We will assume that valid messages are only those
    that are signed from the domain `itpacktpub.com`. So, let''s apply the following
    change:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们强制一个故障。我们将假设只有从`itpacktpub.com`域名签名的有效消息。因此，让我们应用以下更改：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s deploy the application in JBoss again, and execute the request from
    SoapUI:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在JBoss中再次部署应用程序，并从SoapUI中执行请求：
- en: '![Validating signatures with annotations](img/0109OS_05_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_12.jpg)'
- en: As we expected, the request failed this time. Obviously, this happened because
    the signatures could not be verified as the message was signed with the `packtpub.com`
    domain and not with the `itpacktpub.com` domain as we set in the operation `processRequestRam`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，这次请求失败了。显然，这是因为签名无法验证，因为消息是用`packtpub.com`域名签名的，而不是我们在`processRequestRam`操作中设置的`itpacktpub.com`域名。
- en: 'Suddenly, you wonder why the value of the identified name is `d`. As we mentioned
    before, the letter `d` represents the domain. The RESTEasy documentation explains
    a little more about each of the parameters in the header. Here, we show you an
    example from the documentation about JBoss related to this topic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，你可能会想知道为什么识别出的名称的值是`d`。正如我们之前提到的，字母`d`代表域。RESTEasy文档对每个参数的说明稍微详细一些。在这里，我们向您展示文档中关于JBoss相关主题的一个示例：
- en: '*Here''s what an example DKIM-Signature header might look like:*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里是一个DKIM-Signature头部示例的外观：*'
- en: '*DKIM-Signature: v=1;*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*DKIM-Signature: v=1;*'
- en: '*a=rsa-sha256;*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*a=rsa-sha256;*'
- en: '*d=example.com;*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*d=example.com;*'
- en: '*s=burke;*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*s=burke;*'
- en: '*c=simple/simple;*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*c=simple/simple;*'
- en: '*h=Content-Type;*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*h=Content-Type;*'
- en: '*x=0023423111111;*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*x=0023423111111;*'
- en: '*bh=2342322111;*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*bh=2342322111;*'
- en: '*b=M232234=*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*b=M232234=*'
- en: '*As you can see, it is a set of name value pairs delimited by a '';''. While
    it''s not THAT important to know the structure of the header, here''s an explanation
    of each parameter:*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*如你所见，它是一组以分号分隔的名称值对。虽然了解头部的结构并不那么重要，但以下是每个参数的解释：*'
- en: '*v: Protocol version. Always 1.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*v: 协议版本。始终为1。*'
- en: '*a: Algorithm used to hash and sign the message. RSA signing and SHA256 hashing
    is the only supported algorithm at the moment by RESTEasy.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*a: 用于哈希和签名的算法。目前RESTEasy只支持RSA签名和SHA256哈希算法。*'
- en: '*d: Domain of the signer. This is used to identify the signer as well as discover
    the public key to use to verify the signature.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*d: 签名者的域。这用于识别签名者以及发现用于验证签名的公钥。*'
- en: '*s: Selector of the domain. Also used to identify the signer and discover the
    public key.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*s: 域选择器。也用于识别签名者和发现公钥。*'
- en: '*c: Canonical algorithm. Only simple/simple is supported at the moment. Basically,
    this allows you to transform the message body before calculating the hash.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*c: 规范化算法。目前只支持simple/simple。基本上，这允许你在计算哈希之前转换消息体。*'
- en: '*h: Semi-colon delimited list of headers that are included in the signature
    calculation.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*h: 签名计算中包含的头部列表，以分号分隔。*'
- en: '*x: When the signature expires. This is a numeric long value of the time in
    seconds since epoch. Allows signer to control when a signed message''s signature
    expires.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*x: 签名何时过期。这是一个自纪元以来的时间秒的数值长值。允许签名者控制已签名消息的签名何时过期。*'
- en: '*t: Timestamp of signature. Numeric long value of the time in seconds since
    epoch. Allows the verifier to control when a signature expires.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*t: 签名的时间戳。自纪元以来的时间秒的数值长值。允许验证者控制签名何时过期。*'
- en: '*bh: Base 64 encoded hash of the message body.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*bh: 消息体的Base 64编码哈希值。*'
- en: '*b: Base 64 encoded signature.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*b: Base 64编码的签名。*'
- en: 'Now that we have this information, it is clear to assume that if you want to
    check the signer, instead of using the letter `d`, we must use the letter `s`,
    and instead of `packtpub.com`, we will use `demo`. Once you apply these changes,
    our code should look like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些信息，很明显，如果你想检查签名者，而不是使用字母`d`，我们必须使用字母`s`，而不是`packtpub.com`，我们将使用`demo`。一旦应用这些更改，我们的代码应该看起来像以下这样：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition, if you want to verify the signer''s name and domain, you must
    apply a slight change. This time, we will use the `@Verifications` annotation;
    this annotation receives an array of `@Verify` annotations as a parameter, which
    allows us to perform what we described earlier. In this case, we should add two
    controls using the `@Verify` annotation, and our code should look like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想验证签名者的名称和域，你必须进行一些小的更改。这次，我们将使用`@Verifications`注解；这个注解接收一个`@Verify`注解数组作为参数，这允许我们执行我们之前描述的操作。在这种情况下，我们应该使用`@Verify`注解添加两个控制，我们的代码应该看起来像以下这样：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have applied the changes, we can perform a request using SoapUI. We
    should get a successful execution as the result, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了这些更改，我们就可以使用SoapUI进行请求。我们应该得到一个成功的执行结果，如下面的截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_13.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_13.jpg)'
- en: Message body encryption
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息体加密
- en: In the previous chapter, we saw how to encrypt a complete HTTP message using
    HTTPS. Now, we will explain how we can encrypt just the message body and the differences
    between each process. We start by constructing a simple example, and then, as
    we perform the respective tests of our implementation, we'll understand how it
    works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用HTTPS加密完整的HTTP消息。现在，我们将解释如何仅加密消息体以及每个过程的区别。我们首先构建一个简单的示例，然后，随着我们对实现进行相应的测试，我们将了解它是如何工作的。
- en: 'In order not to spoil our previous project, we will build a new one. For this,
    we will execute the following commands in the terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不破坏我们之前的工程，我们将构建一个新的。为此，我们将在终端中执行以下命令：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As seen earlier in this chapter, when you get asked for a version, change the
    default value of `1.0-SNAPSHOT` to `1.0`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所见，当你被要求输入版本号时，将 `1.0-SNAPSHOT` 的默认值更改为 `1.0`。
- en: 'Of course, if you want, you can download all the source code from GitHub from
    the following URL:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想的话，你可以从以下 URL 下载所有源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption)'
- en: Now, let's import the project into Eclipse, delete the existing default dependence
    in the `pom.xml` file, and add dependencies on the artifacts `resteasy-jaxrs`
    and `resteasy-crypto`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将项目导入到 Eclipse 中，删除 `pom.xml` 文件中的现有默认依赖项，并添加对 `resteasy-jaxrs` 和 `resteasy-crypto`
    艺术品的依赖。
- en: 'The `dependencies` section should look like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies` 部分应该看起来像以下这样：'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s create the class `EncryptedService` inside the package `com.packtpub`.
    In this class, we will create a very simple operation, as shown:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在包 `com.packtpub` 内创建一个名为 `EncryptedService` 的类。在这个类中，我们将创建一个非常简单的操作，如下所示：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To register the services of our application, let''s create the class `EncryptedApplication`,
    as shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册我们应用程序的服务，让我们创建一个名为 `EncryptedApplication` 的类，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing the functionality
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试功能
- en: 'After this, our application should be ready. So, let''s execute a test from
    SoapUI to watch the traffic using Wireshark, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们的应用程序应该就绪了。所以，让我们从 SoapUI 执行一个测试，使用 Wireshark 观察流量，如下面的截图所示：
- en: '![Testing the functionality](img/0109OS_05_14.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_14.jpg)'
- en: 'Wireshark shows us the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 显示以下内容：
- en: '![Testing the functionality](img/0109OS_05_15.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_15.jpg)'
- en: As we can see, the traffic analyzer shows how all the information is traveling
    straight and how easily it is interpreted. Now, let's enable HTTPS on JBoss to
    show how the whole message is encrypted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，流量分析器显示了所有信息是如何直接传输的，以及它被解释得有多容易。现在，让我们在 JBoss 上启用 HTTPS 来展示整个消息是如何加密的。
- en: Enabling the server with HTTPS
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 HTTPS 服务器
- en: 'So, first we have to create a certificate KeyStore. We can achieve this by
    executing the following command on the terminal:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先我们必须创建一个证书 KeyStore。我们可以通过在终端上执行以下命令来实现这一点：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When it asks you for a password, you should use `changeit` as we have already
    used it in this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当它要求你输入密码时，你应该使用 `changeit`，因为我们已经在本书中使用过它。
- en: 'Now, we look at the `JBOSS_HOME/standalone/configuration/standalone.xml` file,
    at the line containing `<connector name="http"`, and add the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们查看 `JBOSS_HOME/standalone/configuration/standalone.xml` 文件，在包含 `<connector
    name="http"` 的行中，并添加以下内容：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you''ve made this change, we will restart the application server, deploy
    the application, and edit the request. This time, we''ll use port 8443 and the
    HTTPS protocol. So, the URL should look like the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个更改，我们将重新启动应用程序服务器，部署应用程序，并编辑请求。这次，我们将使用端口 8443 和 HTTPS 协议。因此，URL 应该看起来像以下这样：
- en: '`https://localhost:8443/encryption-1.0/services/encrypted`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:8443/encryption-1.0/services/encrypted`'
- en: 'Let''s execute the request using SoapUI; our traffic analyzer will now show
    us the following result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 SoapUI 执行请求；现在，我们的流量分析器将显示以下结果：
- en: '![Enabling the server with HTTPS](img/0109OS_05_16.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![启用 HTTPS 服务器](img/0109OS_05_16.jpg)'
- en: As we expected, this time, the analyzer shows us very clearly that all the information
    has been encrypted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，这次，分析器清楚地显示所有信息都已加密。
- en: Moving forward with our example, we will now disable HTTPS in JBoss. For this,
    we have to remove the connector we added before. Now, we will use S/MIME in order
    to encrypt only the message body of the response. First, let's check some concepts
    that will help us understand how it works.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中继续前进，我们现在将在 JBoss 中禁用 HTTPS。为此，我们必须删除之前添加的连接器。现在，我们将使用 S/MIME 来仅加密响应的消息体。首先，让我们检查一些将帮助我们理解其工作原理的概念。
- en: 'S/MIME comes from Secure MIME. MIME stands for Multipurpose Internet Mail Extension,
    which helps us to not only send messages such as "Hello world", but also to send
    more interesting content such as videos, audio, and so on. MIME works with e-mail
    protocols such as SMTP and HTTP. This helps us to work with RESTful S/MIME web
    services. On the other hand, MIME offers us the following features:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: S/MIME来自Secure MIME。MIME代表多用途互联网邮件扩展，它不仅帮助我们发送“Hello world”之类的消息，还可以发送视频、音频等更有趣的内容。MIME与SMTP和HTTP等电子邮件协议一起工作。这有助于我们处理RESTful
    S/MIME Web服务。另一方面，MIME为我们提供了以下功能：
- en: Message encryption
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息加密
- en: Validating the identity of the user who sends the message
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证发送消息的用户身份
- en: The capability to verify the information integrity of the message
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消息信息完整性的能力
- en: Given that S/MIME works with certifications, this is where the information of
    the message sender is saved. When the receiver gets the message, they observe
    all the public part of the message. The message can then be deciphered using a
    key. Also, the receiver can access its content. If you want to proceed further
    with S/MIME, we recommend you visit the link [http://datatracker.ietf.org/wg/smime/charter/](http://datatracker.ietf.org/wg/smime/charter/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于S/MIME与证书一起工作，这是消息发送者信息保存的地方。当接收者收到消息时，他们会观察到消息的所有公开部分。然后，可以使用密钥解密消息。此外，接收者可以访问其内容。如果您想进一步了解S/MIME，我们建议您访问链接[http://datatracker.ietf.org/wg/smime/charter/](http://datatracker.ietf.org/wg/smime/charter/)。
- en: Let's start by making some changes. First, we will create the source folder
    `src/main/resources` in the application; in this directory, we will place the
    resources necessary to encrypt the message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做一些修改。首先，我们在应用中创建源文件夹`src/main/resources`；在这个目录中，我们将放置加密消息所需的资源。
- en: 'Then, we generate a certificate using `openssl`, go to the directory we just
    created from the console, and run the following at the command line on a terminal:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`openssl`生成证书，从控制台进入我们刚刚创建的目录，并在终端上运行以下命令：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we have to enter the requested information as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须输入如下截图所示的信息：
- en: '![Enabling the server with HTTPS](img/0109OS_05_17.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![启用服务器的HTTPS](img/0109OS_05_17.jpg)'
- en: 'This will generate two files: `demokey.pem`, which is a private key, and `democert.pem`,
    which is a certificate we will use to encrypt the message body. To represent a
    signed response, RESTEasy uses the `EnvelopedOutput` object. In the following
    figure, we show you how RESTEasy encrypts messages:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件：`demokey.pem`，这是一个私钥，以及`democert.pem`，这是我们用来加密消息体的证书。为了表示已签名的响应，RESTEasy使用`EnvelopedOutput`对象。在以下图中，我们向您展示了RESTEasy如何加密消息：
- en: '![Enabling the server with HTTPS](img/0109OS_05_18.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![启用服务器的HTTPS](img/0109OS_05_18.jpg)'
- en: 'Therefore, we must replace the return type of the method `gretting()` in the
    `EncryptedService` class. Let''s change the string to `EnvelopedOutput` and encrypt
    the message body using the certificate we generated before. Applying these changes,
    our method should look like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须替换`EncryptedService`类中`gretting()`方法的返回类型。让我们将字符串更改为`EnvelopedOutput`，并使用我们之前生成的证书加密消息体。应用这些更改后，我们的方法应如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s make a change in the `pom.xml` file. We will modify the `dependencies`
    section in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`pom.xml`文件中进行一些修改。我们将按照以下方式修改`dependencies`部分：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice how we changed the scope of the `resteasy-jaxrs` and `resteasy-jaxb-provider`
    artifacts; this is necessary to avoid duplicate classes when we encrypt the message.
    Since these artifacts are modules within the application server, you need to indicate
    that we want to load them. For this, we will modify the `pom.xml` file in the
    plugin section of `maven-war-plugin`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何更改了`resteasy-jaxrs`和`resteasy-jaxb-provider`组件的作用域；这是在加密消息时避免重复类所必需的。由于这些组件是应用服务器内的模块，您需要指明我们想要加载它们。为此，我们将修改`pom.xml`文件中的`maven-war-plugin`插件部分，如下所示：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since JBoss Version 7 is a module-based application server, by default, only
    a few modules are activated when it starts. If you want to access other modules,
    it is necessary to indicate these dependencies explicitly. This can be done through
    the `MANIFEST.MF` file or by creating a file called `jboss-deployment-structure.xml`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JBoss版本7是一个基于模块的应用服务器，默认情况下，启动时只激活了少数几个模块。如果您想访问其他模块，则需要明确指出这些依赖项。这可以通过`MANIFEST.MF`文件或创建一个名为`jboss-deployment-structure.xml`的文件来完成。
- en: In this case, we will choose the first file by using `maven-war-`plugin to indicate
    the required dependencies.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用 `maven-war-` 插件选择第一个文件，以指示所需的依赖项。
- en: Testing the functionality
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试功能
- en: Now, let's make the request again from SoapUI to the URL `http://localhost:8080/encryption-1.0/services/encrypted`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次从 SoapUI 向 URL `http://localhost:8080/encryption-1.0/services/encrypted`
    发送请求。
- en: 'This time, the response we will get is shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将得到的响应如下截图所示：
- en: '![Testing the functionality](img/0109OS_05_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_19.jpg)'
- en: 'The following is what we will see from the traffic analyzer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从流量分析器中可以看到的内容：
- en: '![Testing the functionality](img/0109OS_05_20.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_20.jpg)'
- en: 'As we can see, it shows us something very similar to the response from SoapUI.
    To decrypt the content, it is necessary that we have the private key and certificate.
    Through these two resources, we can obtain the object `EnvelopedInput` and get
    the message from it, as shown in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它显示的内容与 SoapUI 的响应非常相似。为了解密内容，我们必须拥有私钥和证书。通过这两个资源，我们可以获取对象 `EnvelopedInput`
    并从中获取消息，如图所示：
- en: '![Testing the functionality](img/0109OS_05_21.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_21.jpg)'
- en: This will be demonstrated in the following code through a unit test. However,
    before going forward, we want to show that when encrypting messages with S/MIME,
    headers remain readable but the message body is fully encrypted. So, if we do
    not have the resources, the information is outdated and cannot be interpreted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过以下代码中的单元测试进行演示。然而，在继续之前，我们想展示当使用 S/MIME 加密消息时，标题仍然是可读的，但消息体是完全加密的。因此，如果我们没有这些资源，信息就是过时的，无法解释。
- en: Now, we will write a class that allows us to read the message body. For this,
    we will create a new source folder called `src/main/test`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个类，使我们能够读取消息体。为此，我们将创建一个新的源文件夹，名为 `src/main/test`。
- en: 'Within this folder, let''s create the class `com.packtpub.EncryptedServiceTest`
    with the following content:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，让我们创建一个名为 `com.packtpub.EncryptedServiceTest` 的类，其内容如下：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we need both the private key and the certificate to decrypt the message
    to obtain the entity formed from a string containing the message `Hello world`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要私钥和证书来解密消息，以获取由包含消息 `Hello world` 的字符串形成的实体。
- en: When we run this unit test, we should get a green bar if all goes well. This
    indicates that to decrypt the message, using the previous resources (private key
    and certificate) has obtained the expected message.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个单元测试时，如果一切顺利，我们应该得到一个绿色的条形。这表明，为了解密消息，使用之前的资源（私钥和证书）已经获得了预期的消息。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked with digital signatures and learned how to use them
    in RESTful web services. These days, digital signatures are often used because
    they guarantee message integrity, and information cannot be compromised while
    it is traveling from the sender to the receptor. We already know that information
    can be modified in transit, but when you're verifying the signed information,
    the receiver can notice it and take the actions that he/she believes are appropriate.
    For example, they can send another request to avoid working with corrupt information.
    At the end of this chapter, we worked with message body encryption, and we saw
    the difference between using these encryptions and HTTPS. Finally, we saw how
    the receiver, using the key, figured out the message body to make use of the information
    according to their needs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了数字签名，并学习了如何在 RESTful 网络服务中使用它们。这些天，数字签名经常被使用，因为它们保证了消息的完整性，信息在从发送者传输到接收者的过程中不会被破坏。我们已经知道信息在传输过程中可能会被修改，但在验证签名信息时，接收者可以注意到这一点，并采取他们认为适当的行动。例如，他们可以发送另一个请求以避免处理损坏的信息。在本章的结尾，我们处理了消息体加密，并看到了使用这些加密与
    HTTPS 之间的区别。最后，我们看到了接收者如何使用密钥来解析消息体，并根据他们的需求使用信息。
