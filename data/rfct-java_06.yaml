- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Metaprogramming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: In a book about refactoring, it may seem a bit strange to talk about metaprogramming.
    More than refactoring per se, in our opinion, talking about metaprogramming and
    tools that use it can be useful concerning clean code, and writing clean code
    means “preventing” the refactoring, which is indeed still relevant to our goal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本关于重构的书中，讨论元编程可能显得有些奇怪。在我们看来，与其说是重构本身，不如说讨论元编程及其工具对于编写清洁代码是有益的，而编写清洁代码意味着“预防”重构，这确实与我们的目标仍然相关。
- en: 'As we will see shortly, metaprogramming involves writing programs that work
    on programs. In our context, we will endorse the usage of frameworks written by
    others (the first virtue of a good software engineer: laziness) that help us write
    less code (told you!).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快将看到的，元编程涉及编写在程序上工作的程序。在我们的上下文中，我们将支持使用他人编写的框架（优秀软件工程师的第一个美德：懒惰），这些框架可以帮助我们编写更少的代码（我告诉过你！）。
- en: 'Writing less code (or rather, having it written by tools) is a good thing:
    it means less code to maintain, trivially, and it means that those portions of
    code are in charge of dedicated tools that will then write that code in the best
    possible way.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更少的代码（或者说，让工具来编写）是件好事：这意味着维护的代码更少，而且那些代码部分由专门的工具负责，这些工具将以最佳方式编写代码。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is metaprogramming?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是元编程？
- en: Exploring compile-time and runtime metaprogramming tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索编译时和运行时元编程工具
- en: Lombok and MapStruct
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lombok 和 MapStruct
- en: Weighing the pros and cons of metaprogramming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估元编程的利弊
- en: What is metaprogramming?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是元编程？
- en: When we encounter software designed to create, manipulate, or interact with
    other software in various ways, we are engaging in **metaprogramming**. This technique
    allows computer programs to treat other programs as their data. In my opinion,
    it represents a very powerful instrument in the hands of wise people; as with
    everything in life, it also has some drawbacks that we’ll analyze later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到旨在以各种方式创建、操作或与其他软件交互的软件时，我们正在进行**元编程**。这项技术允许计算机程序将其他程序视为其数据。在我看来，它代表了智者手中的非常强大的工具；就像生活中的每一件事一样，它也有一些缺点，我们稍后会分析。
- en: Metaprogramming means writing software (or, as we’ll see in a moment, using
    software) that can be set up to do things such as read, create, analyze, or change
    other programs. It can even tweak its own code while it’s running. This cool trick
    allows developers to write solutions with less code, saving time. Plus, it makes
    programs more flexible so that they can handle new situations without needing
    a full rewrite.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程意味着编写（或者，如我们稍后将看到的，使用）软件，该软件可以设置成执行诸如读取、创建、分析或更改其他程序等操作。它甚至可以在运行时调整自己的代码。这个酷炫的技巧允许开发者用更少的代码编写解决方案，节省时间。此外，它使程序更加灵活，以便它们可以处理新的情况而无需进行全面的重写。
- en: Just as with any programming language, grasping the fundamentals of metaprogramming
    and adopting sound software development practices is crucial for enhancing the
    overall quality of applications, including those that incorporate metaprogramming
    techniques.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何编程语言一样，掌握元编程的基础知识并采用合理的软件开发实践对于提高应用程序的整体质量至关重要，包括那些采用元编程技术的应用程序。
- en: First and foremost, metaprogramming promotes **code reusability**. It accomplishes
    this by allowing developers to create code generators and templates that eliminate
    redundancy in their code bases. This not only reduces the likelihood of errors
    but also streamlines maintenance efforts. When code is generated automatically,
    developers can make changes in one place, and those changes will propagate throughout
    the code base. This results in more maintainable, cleaner, and less error-prone
    code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，元编程促进了**代码的可重用性**。它通过允许开发者创建代码生成器和模板来实现这一点，这些模板可以消除代码库中的冗余。这不仅减少了错误的可能性，还简化了维护工作。当代码自动生成时，开发者可以在一个地方进行更改，这些更改将传播到整个代码库。这导致代码更易于维护、更清洁且错误更少。
- en: One of the most compelling aspects of metaprogramming is its capacity to enable
    dynamic behavior in programs. This dynamic behavior empowers software systems
    to adapt to changing conditions at runtime. In practical terms, this means that
    the behavior of a program can be adjusted or configured without the need for extensive
    code modifications and recompilation. As a result, metaprogramming is particularly
    valuable in scenarios where a program’s behavior must be flexible, configurable,
    or subject to frequent changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程最吸引人的方面之一是它能够使程序具有动态行为。这种动态行为使软件系统能够在运行时适应不断变化的情况。从实际的角度来看，这意味着程序的行为可以在不进行大量代码修改和重新编译的情况下进行调整或配置。因此，元编程在程序的行为必须灵活、可配置或频繁变化的情况下特别有价值。
- en: Furthermore, metaprogramming has a direct impact on developer productivity.
    By automating repetitive coding tasks, it allows developers to focus on higher-level
    design and problem-solving. This, in turn, leads to faster development cycles
    and more efficient code bases. The time and effort saved through metaprogramming
    can be channeled into improving the overall quality of the software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，元编程对开发者生产力有直接影响。通过自动化重复的编码任务，它允许开发者专注于更高层次的设计和问题解决。这反过来又导致更快的开发周期和更高效的代码库。通过元编程节省的时间和精力可以用于提高软件的整体质量。
- en: 'Metaprogramming is not limited to making code more efficient; it also promotes
    the creation of **domain-specific languages** (**DSLs**). These DSLs are tailored
    to specific problem domains, enabling developers to express complex ideas more
    naturally and concisely. DSLs abstract away the intricacies of general-purpose
    programming languages and allow developers to communicate directly with the domain’s
    concepts, significantly improving communication between technical and non-technical
    stakeholders. To illustrate this concept, imagine you are working on a financial
    application, and you need to calculate the interest on a loan. In Java, using
    a general-purpose language, it might look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程不仅限于使代码更高效；它还促进了**领域特定语言**（**DSLs**）的创建。这些 DSLs 被定制为特定的问题域，使得开发者能够更自然、更简洁地表达复杂思想。DSLs
    抽象掉了通用编程语言的复杂性，并允许开发者直接与领域的概念进行沟通，显著提高了技术和非技术利益相关者之间的沟通。为了说明这个概念，想象你正在开发一个金融应用程序，你需要计算一笔贷款的利息。在
    Java 中，使用通用语言，它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this Java code, you are dealing with low-level details such as variable types,
    operators, and calculations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段 Java 代码中，你正在处理诸如变量类型、运算符和计算等低级细节。
- en: 'Now, let’s see how a DSL could make this more domain-specific:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 DSL 如何使这更加领域特定：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `LoanDSL` is a DSL that’s designed to work with financial calculations.
    It abstracts away the low-level details and provides a higher-level interface
    that directly communicates with the financial domain’s concepts, making it easier
    to understand and work with. This can greatly improve communication between developers
    and domain experts in finance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`LoanDSL` 是一个专为与金融计算一起工作而设计的领域特定语言（DSL）。它抽象掉了低级细节，提供了一个高级接口，该接口直接与金融领域的概念进行通信，这使得理解和操作更加容易。这可以大大提高开发者和金融领域专家之间的沟通。
- en: 'Lastly, metaprogramming helps in building efficient abstractions. These abstractions
    hide the underlying implementation details, making the code more understandable
    and maintainable. By encapsulating complexity and exposing only essential information,
    metaprogramming enhances the code base’s overall clarity and comprehensibility.
    Metaprogramming can be split into two main categories: compile-time and runtime.
    Let’s taste a bit of each of them.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，元编程有助于构建高效的抽象。这些抽象隐藏了底层实现细节，使得代码更易于理解和维护。通过封装复杂性和仅暴露必要信息，元编程增强了代码库的整体清晰度和可理解性。元编程可以分为两大类：编译时和运行时。让我们尝一尝这两者的滋味。
- en: Exploring compile-time metaprogramming tools
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索编译时元编程工具
- en: 'Compile-time metaprogramming involves code transformations and generation that
    occur during the compilation phase. In other words, operations, transformations,
    or code generation are performed on a program during the compilation process –
    that is, before the program is executed. Macros, code generators, and annotation
    processors are common tools for compile-time metaprogramming in Java. Given the
    subject of this book, compile-time metaprogramming will be our main focus since
    we think that the instruments and frameworks that fall under this definition are
    the best ways to keep your code clean. In particular, we’ll focus on code generator
    tools: programming languages and tools that provide facilities for generating
    code based on certain specifications or models (in the following section, we will
    focus specifically on Lombok and MapStruct). The code generated by these tools
    can be customized according to the specific requirements of the program.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时元编程涉及在编译阶段发生的代码转换和生成。换句话说，操作、转换或代码生成是在程序执行之前（即在程序执行之前）对程序进行的。宏、代码生成器和注解处理器是
    Java 中编译时元编程的常见工具。鉴于本书的主题，编译时元编程将是我们的主要关注点，因为我们认为符合此定义的工具和框架是保持代码清洁的最佳方式。特别是，我们将重点关注代码生成工具：提供基于某些特定规范或模型生成代码的设施（在下一节中，我们将具体关注
    Lombok 和 MapStruct）。这些工具生成的代码可以根据程序的具体要求进行定制。
- en: Lombok
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lombok
- en: '**Project Lombok** (born in 2009) is a popular Java library that simplifies
    Java development by reducing boilerplate code and making the code cleaner and
    more concise.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Project Lombok**（诞生于 2009 年）是一个流行的 Java 库，通过减少样板代码并使代码更简洁来简化 Java 开发。'
- en: In Java (at least until version 14 with the introduction of the `record` keyword),
    there is often a significant amount of boilerplate code that needs to be written
    for basic tasks such as defining getter and setter methods, constructors, and
    the `toString()`, `equals()`, and `hashCode()` methods. This boilerplate code
    can be time-consuming to write and maintain, making the code base longer and harder
    to read.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中（至少直到 14 版本引入 `record` 关键字为止），通常需要编写大量的样板代码来完成基本任务，例如定义 getter 和 setter
    方法、构造函数以及 `toString()`、`equals()` 和 `hashCode()` 方法。这些样板代码的编写和维护可能很耗时，使得代码库更长且更难阅读。
- en: '**Lombok** addresses this issue by providing annotations that automatically
    generate this boilerplate code during compilation. This means developers don’t
    have to write these repetitive code elements themselves, reducing the likelihood
    of errors and making the code base more concise.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lombok** 通过在编译期间自动生成这些样板代码来解决此问题。这意味着开发者不必自己编写这些重复的代码元素，从而降低了出错的可能性，并使代码库更加简洁。'
- en: Lombok functions as an annotation processor that enhances your classes by introducing
    additional code during the compilation phase. Annotation processing was introduced
    to the Java compiler in version 5\. The concept involves users placing annotation
    processors, whether self-authored or obtained from third-party dependencies such
    as Lombok, in the build classpath. During the compilation process, as the compiler
    encounters an annotation, it effectively inquires, “Is anyone in the classpath
    concerned with this `@Annotation`?” For those processors answering yes, the compiler
    delegates control to them, along with the compilation context, allowing them to
    perform their respective tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Lombok 作为一种注解处理器，在编译阶段引入额外的代码来增强你的类。注解处理是在 Java 编译器 5.0 版本中引入的。该概念涉及用户将注解处理器（无论是自行编写的还是从第三方依赖项，如
    Lombok 获得的）放置在构建类路径中。在编译过程中，当编译器遇到注解时，它实际上会询问：“类路径中是否有人关心这个 `@Annotation`？”对于回答是的处理器，编译器将控制权委托给他们，以及编译上下文，允许他们执行各自的任务。
- en: Lombok’s annotation processing involves making adjustments to the compiler’s
    data structures that represent the code, specifically the **abstract syntax tree**
    (**AST**). Think of the AST as a roadmap for the computer program. It shows all
    the necessary steps that must be taken to create the final program. In Java, it
    is created before the actual program code (**bytecode**) is made. The cool thing
    is that you can change and work with this AST in Java. Through these modifications
    to the compiler’s AST, Lombok indirectly influences the generation of the final
    bytecode. To achieve this functionality, Lombok is required to intercept and manage
    calls that are made to the Java compiler for handling the generation of intermediate
    code. This interception process is facilitated using plugins, which can be configured
    within your **integrated development environment** (**IDE**), such as IntelliJ,
    VS Code, or Eclipse, or integrated into your build automation tools, such as Maven,
    Gradle, or Make. It’s important to note that if your IDE or build management system
    lacks compatibility with Lombok, it may result in compilation issues for your
    code; anyway, that simply will not happen with modern versions of the most used
    IDEs (they support Lombok out of the box).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lombok 的注解处理涉及对表示代码的编译器数据结构进行调整，特别是 **抽象语法树**（**AST**）。将 AST 视为计算机程序的路线图。它显示了创建最终程序必须采取的所有必要步骤。在
    Java 中，它是在实际程序代码（**字节码**）生成之前创建的。酷的地方在于你可以在 Java 中更改并处理这个 AST。通过这些对编译器 AST 的修改，Lombok
    间接影响了最终字节码的生成。为了实现这一功能，Lombok 需要拦截并管理对 Java 编译器的调用，以处理中间代码的生成。这个过程是通过插件来简化的，这些插件可以在你的
    **集成开发环境**（**IDE**）中配置，例如 IntelliJ、VS Code 或 Eclipse，或者集成到你的构建自动化工具中，例如 Maven、Gradle
    或 Make。重要的是要注意，如果你的 IDE 或构建管理系统与 Lombok 不兼容，可能会导致你的代码在编译时出现问题；无论如何，在大多数最常用的 IDE
    的现代版本中，这种情况是不会发生的（它们默认支持 Lombok）。 '
- en: As we already said, Lombok works with a bunch of very simple annotations. Let’s
    see some examples of its magic. We’ll provide you with the basics. However, there’s
    much more to discover in the Lombok official documentation, which you can find
    in the *Further* *reading* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Lombok 与一系列非常简单的注解一起工作。让我们看看它的魔法示例。我们将提供基础知识。然而，在 Lombok 官方文档中还有更多内容可以探索，你可以在
    *进一步* *阅读* 部分找到它。
- en: Getting started with Lombok with an example
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例开始使用 Lombok
- en: 'Let’s start with the most basic form of a Java class: a `toString()` method,
    an often `equals()` and `hashcode()` to complete the picture. It’s faster to write
    one than to describe it (the following code is intentionally long):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基础的 Java 类形式开始：一个 `toString()` 方法，以及经常需要的 `equals()` 和 `hashcode()` 方法来完善整个结构。写这个方法比描述它要快（以下代码故意写得比较长）：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It should be simple to understand what this class does: nothing! It has three
    fields, all of which are `private`, three constructors (the default one with no
    argument and one with all the fields – one that takes another instance of the
    same object), one getter and one setter for each of the fields, `equals` and `hashcode`
    methods that involve all of the fields, and finally a `toString` method. All of
    this code has been generated from my IDE; this class just represents a piece of
    information. It is what is called a **data class** in other languages. And just
    for this, we have more than 70 lines of code! Let’s see how Lombok can rescue
    us.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很容易理解这个类的作用：什么也不做！它有三个字段，都是 `private` 的，三个构造函数（一个不带参数的默认构造函数和一个包含所有字段的构造函数——一个接受相同对象实例的构造函数），每个字段一个
    getter 和 setter，`equals` 和 `hashcode` 方法涉及所有字段，最后是一个 `toString` 方法。所有这些代码都是从我的
    IDE 生成的；这个类仅仅代表一条信息。在其他语言中，这被称为 **数据类**。仅此而已，我们就有了超过 70 行的代码！让我们看看 Lombok 如何帮助我们。
- en: 'First things first, add Project Lombok to your classpath. If you are using
    Maven, you just have to add the dependency to your `pom.xml` file (we’re going
    to use the latest version at the time of writing):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 Project Lombok 添加到你的类路径中。如果你使用 Maven，你只需将依赖项添加到你的 `pom.xml` 文件中（我们将在写作时使用最新版本）：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One funny thing is that if you just start typing Lombok’s annotations into your
    code, some IDEs, such as IntelliJ IDEA, will suggest that you include Lombok in
    your classpath. It is that smooth.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你只是开始在代码中输入 Lombok 的注解，一些 IDE，如 IntelliJ IDEA，会建议你将 Lombok 添加到你的类路径中。这真是太顺畅了。
- en: 'As we said, Lombok works by adding annotations to the source code, which implement
    some behaviors considered *boilerplate*. For example, in the *copy constructor*
    of the object, we can see an `if` statement that checks for the possible nullity
    of the parameter that’s passed in as input:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，Lombok通过在源代码中添加注解来实现，这些注解实现了被认为是一些*样板代码*的行为。例如，在对象的*复制构造函数*中，我们可以看到一个检查传入参数可能为null的`if`语句：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `if` statement can be replaced with the `@NonNull` annotation next to
    the parameter in the constructor: the null check takes the form of an `if` statement,
    `if (param == null) throw new NullPointerException("param is marked non-null but
    is null")`, and will be placed at the beginning of your method. In the case of
    constructors, the null check will be inserted right after any explicit `this()`
    or `super()` calls:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句可以用在构造函数参数旁边的`@NonNull`注解来替换：null检查的形式是一个`if`语句，`if (param == null)
    throw new NullPointerException("param is marked non-null but is null")`，并将放置在你的方法的开头。在构造函数的情况下，null检查将直接插入到任何显式的`this()`或`super()`调用之后：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s look at the default constructor:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看默认构造函数：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `@NoArgsConstructor` annotation, we can get rid of the default constructor.
    A constructor with no parameters will be automatically generated. However, if
    this isn’t feasible due to the presence of final fields, a compiler error will
    occur. This will happen unless you explicitly annotate with `@NoArgsConstructor(force
    = true)`, in which case all final fields will be initialized with default values
    (`0` for numeric types, `false` for Boolean, and `null` for reference types).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@NoArgsConstructor`注解，我们可以消除默认构造函数。一个没有参数的构造函数将被自动生成。然而，如果由于存在final字段而无法实现这一点，编译器将出现错误。除非你显式地使用`@NoArgsConstructor(force
    = true)`进行注解，否则所有final字段都将使用默认值初始化（数值类型为`0`，布尔类型为`false`，引用类型为`null`）。
- en: 'The second constructor we can get rid of is the **all-arguments** constructor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以消除的第二个构造函数是**所有参数**的构造函数：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can replace these lines of code with the `@AllArgsConstructor` annotation,
    which produces a constructor that accepts one parameter for each field within
    your class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`@AllArgsConstructor`注解来替换这些代码行，该注解生成一个接受你类中每个字段的一个参数的构造函数。
- en: 'Should any of the arguments be `final`, this means that only some of the fields
    are required:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何参数是`final`的，这意味着只有一些字段是必需的：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we can use `@RequiredArgsConstructor`, which generates a constructor
    with one parameter for each field that necessitates specific treatment. This includes
    all non-initialized final fields, as well as any fields annotated with `@NonNull`
    that haven’t been initialized where they are declared. For the fields marked with
    `@NonNull`, an explicit null check is also created. If any of the parameters intended
    for `@NonNull` fields contain null, the constructor will throw a `NullPointerException`
    error. The parameter order corresponds to the order in which the fields are defined
    in your class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用`@RequiredArgsConstructor`，它为每个需要特定处理的字段生成一个参数的构造函数。这包括所有未初始化的final字段，以及任何在声明处未初始化且带有`@NonNull`注解的字段。对于标记为`@NonNull`的字段，还会创建显式的null检查。如果任何旨在用于`@NonNull`字段的参数包含null，构造函数将抛出`NullPointerException`错误。参数的顺序对应于你在类中定义字段的顺序。
- en: 'The next features of Lombok are the `@Getter` and/or `@Setter` annotations
    to any field, allowing Lombok to automatically generate default getter and setter
    methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Lombok的下一个特性是对任何字段使用`@Getter`和/或`@Setter`注解，允许Lombok自动生成默认的getter和setter方法：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A default getter method essentially retrieves the field’s value and follows
    the `getName` naming convention if the field is named `name` (or `isName` if the
    field is of the Boolean type). Meanwhile, a default setter method named `setName`
    is used if the field is named `name`, returns `void`, and accepts a single parameter
    of the same type as the field. This setter method simply assigns the field the
    provided value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认getter方法基本上是检索字段的值，如果字段名为`name`（或字段为布尔类型时为`isName`），则遵循`getName`命名约定。同时，如果字段名为`name`，则使用名为`setName`的默认setter方法，返回`void`，并接受与字段相同类型的单个参数。这个setter方法只是将字段赋值为提供的值。
- en: 'It’s also possible to apply the `@Getter` and/or `@Setter` annotation to a
    class itself. In such cases, it’s as though you’ve annotated all non-static fields
    within that class with the same annotation. So, the previous code snippet can
    be also written in the following manner:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以将`@Getter`和/或`@Setter`注解应用于类本身。在这种情况下，就好像你已将相同的注解应用于该类中所有非静态字段。因此，之前的代码片段也可以用以下方式编写：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, the generated getter and setter methods are public, unless you
    explicitly specify `AccessLevel`. The access levels that you can use are `PUBLIC`,
    `PROTECTED`, `PACKAGE`, and `PRIVATE`. For example, you could write the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的getter和setter方法都是公开的，除非你明确指定`AccessLevel`。你可以使用的访问级别有`PUBLIC`、`PROTECTED`、`PACKAGE`和`PRIVATE`。例如，你可以编写以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `equals` and `hashcode` methods can be generated by adding the `@EqualsAndHashCode`
    annotation: this allows Lombok to automatically generate implementations for the
    `equals(Object other)` and `hashCode()` methods. By default, it includes all non-static,
    non-transient fields. However, you have the flexibility to customize which fields
    are included (and even specify that the results of certain methods should be considered)
    by annotating type members with `@EqualsAndHashCode.Include` or `@EqualsAndHashCode.Exclude`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加`@EqualsAndHashCode`注解来生成`equals`和`hashCode`方法：这允许Lombok自动生成`equals(Object
    other)`和`hashCode()`方法的实现。默认情况下，它包括所有非静态、非瞬态字段。然而，你可以通过注解类型成员使用`@EqualsAndHashCode.Include`或`@EqualsAndHashCode.Exclude`来自定义包含哪些字段（甚至可以指定某些方法的返回结果应被视为）。
- en: Alternatively, you can precisely specify the fields or methods you want to include
    by annotating them with `@EqualsAndHashCode.Include` and using `@EqualsAndHashCode``(onlyExplicitlyIncluded
    =` `true)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过使用`@EqualsAndHashCode.Include`注解并使用`@EqualsAndHashCode(onlyExplicitlyIncluded
    = true)`来精确指定你想要包含的字段或方法。
- en: Last but not least, you have the chance to make Lombok generate a `toString`
    method simply by adding the `@ToString` annotation. Configuration options are
    used to determine whether field names should be included. Otherwise, the format
    follows a fixed structure, which is the class name followed by parentheses containing
    fields separated by commas – as an example, it appears as `Person(name=charlie,
    surname=brown)`. To enhance the clarity (although it may increase the length)
    of the `toString()` method’s output, you can set the `includeFieldNames` parameter
    to `true`. By default, all non-static fields are printed. If you wish to exclude
    certain fields, you can annotate them with `@ToString.Exclude`. Alternatively,
    you can precisely specify which fields to include by using `@ToString(onlyExplicitlyIncluded
    = true)` and then marking each field you want to include with `@ToString.Include`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你有机会通过添加`@ToString`注解来让Lombok生成一个`toString`方法。配置选项用于确定是否应包含字段名称。否则，格式遵循一个固定的结构，即类名后跟括号，括号内包含用逗号分隔的字段
    - 例如，它看起来像`Person(name=charlie, surname=brown)`。为了提高`toString()`方法输出的清晰度（尽管可能会增加长度），你可以将`includeFieldNames`参数设置为`true`。默认情况下，所有非静态字段都会被打印。如果你希望排除某些字段，你可以用`@ToString.Exclude`注解它们。或者，你可以通过使用`@EqualsAndHashCode.Include`注解并标记每个你想要包含的字段来精确指定要包含的字段或方法，然后使用`@EqualsAndHashCode(onlyExplicitlyIncluded
    = true)`。
- en: 'In the end, our 70-lines-long code is reduced to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的70行代码简化为以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Still not satisfied? You can use `@Data`, a convenient shortcut annotation
    that bundles the features of `@ToString`, `@EqualsAndHashCode`, `@Getter` / `@Setter`,
    and `@``RequiredArgsConstructor` together:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还不够满意？你可以使用`@Data`，这是一个方便的快捷注解，它将`@ToString`、`@EqualsAndHashCode`、`@Getter`
    / `@Setter`和`@RequiredArgsConstructor`的功能捆绑在一起：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you want to preserve immutability (and you definitively should!), you can
    use the `@Value` annotation, which is the immutable variant of `@Data`. In this
    case, all fields are automatically set as `private` and `final` by default, and
    no setters are generated. Additionally, the class itself is made `final` by default
    because enforcing immutability on a subclass is not feasible. Similar to the `@Data`
    annotation, it includes helpful `toString()`, `equals()`, and `hashCode()` methods
    generation. Each field is equipped with a getter method, and a constructor is
    generated to encompass all arguments (excluding `final` fields, which are initialized
    in the field declaration).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要保留不可变性（而且你绝对应该这样做！），你可以使用`@Value`注解，它是`@Data`的不可变版本。在这种情况下，所有字段默认设置为`private`和`final`，并且不会生成任何setter。此外，类本身默认设置为`final`，因为强制子类不可变是不可行的。类似于`@Data`注解，它包括有用的`toString()`、`equals()`和`hashCode()`方法生成。每个字段都配备了一个getter方法，并且生成一个构造函数来包含所有参数（排除`final`字段，这些字段在字段声明中初始化）。
- en: This is just a general overview of Lombok’s annotations. Using their properties
    (and also some other configurations that can be added to the project through a
    file called `lombok.config` (the link for the official documentation can be found
    in the *Further reading* section)), it is possible to make the behavior of Lombok
    much more granular, acting at the level of a single field, a single method, or
    customizing the implementation generated by this powerful library. This was just
    the proverbial tip of the iceberg.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对Lombok注解的一般概述。使用它们的属性（以及也可以通过一个名为`lombok.config`的文件添加到项目中的其他一些配置），可以使Lombok的行为更加细致，在单个字段、单个方法或自定义由这个强大的库生成的实现级别上操作。这仅仅是冰山一角。
- en: Lombok’s builder
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lombok的构建器
- en: 'In [*Chapter 5*](B20912_05.xhtml#_idTextAnchor117), we saw what the builder
    pattern is: a design pattern that helps construct complex objects by separating
    their construction from their representation, making it easier to create objects
    with various configurations.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B20912_05.xhtml#_idTextAnchor117)中，我们了解了构建器模式：一种设计模式，通过将对象的构建与其表示分离来帮助构建复杂对象，这使得创建具有各种配置的对象变得更容易。
- en: 'The `@Builder` annotation lets you create a *builder* class for your type with
    basically no effort. If we take the `Person` class we wrote at the end of the
    previous section and add the `@Builder` annotation on top of it, Lombok will generate
    some code that we can use to instantiate a `Person` instance in the following
    manner:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Builder`注解让你几乎不费吹灰之力就为你的类型创建一个*构建器*类。如果我们取上一节末尾编写的`Person`类，并在其上方添加`@Builder`注解，Lombok将生成一些代码，我们可以用它以以下方式实例化一个`Person`实例：'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, you’re creating an instance of `Person` using a fluent and
    readable builder pattern. You set the values of the fields using the generated
    builder’s methods and then call `.build()` to create the final instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你正在使用流畅且易于阅读的构建器模式创建`Person`的一个实例。你使用生成的构建器的方法设置字段的值，然后调用`.build()`来创建最终的实例。
- en: The `@Builder` annotation can also handle optional fields and default values,
    making it a convenient way to create objects with a variable number of properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Builder`注解还可以处理可选字段和默认值，这使得以可变数量的属性创建对象变得方便。'
- en: Lombok’s `@Builder` annotation is especially useful in scenarios where you need
    to construct complex objects with many optional parameters or when you want to
    create immutable objects. It eliminates the need to write repetitive, verbose,
    and error-prone boilerplate code for building objects, making your code more concise
    and maintainable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lombok的`@Builder`注解在需要使用许多可选参数构建复杂对象或想要创建不可变对象的情况下特别有用。它消除了编写重复、冗长且易出错的样板代码来构建对象的需求，使代码更加简洁和易于维护。
- en: 'The `@Builder` annotation can generate “singular” methods for collection parameters/fields,
    which accept a single element rather than an entire list, and add that element
    to the collection. Let’s look at the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Builder`注解可以为集合参数/字段生成“单一”方法，这些方法接受单个元素而不是整个列表，并将该元素添加到集合中。让我们看看以下示例：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `@Singular` annotation that was put on a collection field. When you
    annotate a parameter in a method or constructor with the `@Singular` annotation
    or a field in a class with the `@Singular` annotation, Lombok treats that builder
    node as a collection. As a result, Lombok generates two **adder** methods instead
    of a **setter** method. The first adder method allows you to add a single element
    to the collection, while the second adder method allows you to add all elements
    from another collection to the existing collection. Lombok does not generate a
    setter method that replaces the entire collection. Additionally, Lombok generates
    a **clear** method for the collection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意被放置在集合字段上的 `@Singular` 注解。当你在一个方法或构造函数的参数上使用 `@Singular` 注解，或者在类的字段上使用 `@Singular`
    注解时，Lombok 将该构建节点视为一个集合。因此，Lombok 生成两个 **adder** 方法而不是一个 **setter** 方法。第一个 adder
    方法允许你向集合添加单个元素，而第二个 adder 方法允许你将另一个集合的所有元素添加到现有集合中。Lombok 不会生成替换整个集合的 setter 方法。此外，Lombok
    还为集合生成一个 **clear** 方法。
- en: 'For example, you could write the following code for the previously shown `Team`
    class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以为之前显示的 `Team` 类编写以下代码：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you could also write the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以编写以下内容：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will get the same result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到相同的结果。
- en: 'If a particular field or parameter is not explicitly set during the object
    construction process, it will default to values such as `0`, `null`, or `false`,
    depending on its type. When you use the `@Builder` annotation in a class (rather
    than a method or constructor), you can define a default value directly on the
    field and annotate it with `@Builder.Default`. Look at the following code as an
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象构造过程中没有明确设置特定字段或参数，它将默认为其类型的值，例如 `0`、`null` 或 `false`。当你在一个类中使用 `@Builder`
    注解（而不是方法或构造函数）时，你可以在字段上直接定义默认值，并用 `@Builder.Default` 注解它。以下代码是一个示例：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, if the created field is not set during object construction,
    it will default to the result of `System.currentTimeMillis()`, ensuring that it
    always has a valid timestamp value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果创建的字段在对象构造期间未设置，它将默认为 `System.currentTimeMillis()` 的结果，确保它始终有一个有效的时间戳值。
- en: When used in a sentence, Lombok’s builder feature is particularly useful because
    it simplifies the creation of complex objects with a fluent and concise syntax,
    reducing the need for manual builder pattern implementation in Java. However,
    there are also some drawbacks to using this library, which we will investigate
    in the following section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当在句子中使用时，Lombok 的构建功能特别有用，因为它通过流畅和简洁的语法简化了复杂对象的创建，减少了在 Java 中手动实现构建模式的必要性。然而，使用这个库也有一些缺点，我们将在下一节中探讨。
- en: Some final considerations about Lombok’s pros and cons
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 Lombok 的优缺点的一些最终考虑
- en: By reducing the boilerplate code, Lombok helps improve code cleanliness and
    readability. Developers can focus on writing the essential business logic of their
    classes, making the code base more understandable and maintainable. It also reduces
    the chances of introducing bugs in the manually written boilerplate code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少样板代码，Lombok 有助于提高代码的整洁性和可读性。开发者可以专注于编写他们类的基本业务逻辑，从而使代码库更易于理解和维护。它还减少了在手动编写的样板代码中引入错误的机会。
- en: With Lombok, maintaining the code becomes more straightforward. When you need
    to add or remove fields from a class, you don’t have to update all the related
    methods manually. Lombok’s annotations take care of these changes automatically
    during compilation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lombok，维护代码变得更加简单。当你需要向类中添加或删除字段时，你不必手动更新所有相关方法。Lombok 的注解会在编译期间自动处理这些更改。
- en: Most modern IDEs support Lombok out of the box. They can recognize Lombok annotations
    and provide code completion, navigation, and refactoring assistance as if the
    code were written manually. This ensures a seamless development experience for
    developers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代 IDE 默认支持 Lombok。它们可以识别 Lombok 注解，并提供代码补全、导航和重构辅助，就像代码是手动编写的一样。这确保了开发者有一个无缝的开发体验。
- en: In our humble opinion, Project Lombok is a valuable tool in the Java ecosystem
    that simplifies code development by automating the generation of common code elements,
    reducing boilerplate, and improving code readability. It allows developers to
    focus on the core functionality of their classes and reduces the chances of introducing
    errors in repetitive code. This makes Java code cleaner, more concise, and easier
    to maintain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谦逊的观点中，Project Lombok是Java生态系统中的一个宝贵工具，通过自动化生成常见的代码元素、减少样板代码和提高代码可读性来简化代码开发。它允许开发者专注于其类的核心功能，并减少在重复代码中引入错误的机会。这使得Java代码更干净、更简洁，更容易维护。
- en: 'However, to give a complete and honest overview, we have to highlight some
    common criticisms about Lombok. Let’s start with the most subjective (almost a
    “gut feeling” some people have) criticism: Lombok’s unique and sometimes forceful
    way of doing things (in particular, modifying the bytecode) has often made people
    see it as a bit of a workaround. We see it as a clever, technically sound, and
    innovative solution rather than a negative hack. However, some developers still
    see it as a workaround and avoid using Lombok for that reason. That’s a valid
    perspective, but in our experience, Lombok’s advantages in terms of productivity
    are more significant than any worries about its approach. We’ve been using it
    happily in real-life projects for many years.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了给出一个全面和诚实的概述，我们必须强调一些关于Lombok的常见批评。让我们从最主观的（几乎是某些人的“直觉”）批评开始：Lombok独特且有时强制性的做事方式（特别是修改字节码）常常让人觉得它是一种权宜之计。我们将其视为一种聪明、技术合理且创新的解决方案，而不是一种负面的黑客行为。然而，一些开发者仍然将其视为权宜之计，并因此避免使用Lombok。这是一个合理的观点，但根据我们的经验，Lombok在生产力方面的优势比对其方法的任何担忧都要重要。我们已经愉快地在现实生活中的项目中使用了多年。
- en: It is useless to deny that, since Lombok intervenes as a sort of “extra step”
    at the time of compilation, the time to carry out this practice increases. As
    the code base increases, of course, the times increase proportionally. As high
    as the efficiency is and the Lombok team actively working on further improvements,
    it is undeniable that projects compile faster without Lombok.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 否认这一点是没有用的，因为Lombok在编译时作为“额外步骤”介入，这增加了执行此实践的时间。随着代码库的增加，当然，时间也会成比例增加。尽管效率很高，Lombok团队也在积极进行进一步的改进，但不可否认的是，没有Lombok的项目编译速度更快。
- en: There could also be problems related to compatibility between different versions
    of Java. With each version change, Java could change the way your AST is generated
    and/or interpreted. Consequently, it is not certain that Lombok can generate the
    code correctly or that it succeeds at all. The code may stop compiling. Unfortunately,
    we would only notice this after upgrading Java, but it is also true that new versions
    of the library are released before the final versions of Java. However, there
    is still one possibility to be considered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在与不同版本的Java兼容性的问题。随着每个版本的更新，Java可能会改变生成和/或解释AST的方式。因此，不能确定Lombok能否正确生成代码，或者它是否能够成功。代码可能会停止编译。不幸的是，我们可能只有在升级Java之后才会注意到这一点，但事实也是，在Java最终版本发布之前，库的新版本就已经发布了。然而，仍然有一个可能性需要考虑。
- en: This eventuality leads us to another problematic aspect, namely the fact that
    Lombok makes the code we write non-standard; since we need the Lombok plugin to
    compile, it is undeniable that the code we are writing, in a sense, is not valid.
    We will always depend on tools that are “external” to Java.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可能性让我们想到了另一个问题，即Lombok使得我们编写的代码变得非标准；由于我们需要Lombok插件来编译，从某种意义上说，我们正在编写的代码是不合法的。我们总是依赖于Java“外部”的工具。
- en: The last possible flaw that comes to mind is not a defect in my opinion, but
    something I have often heard. It’s true that Lombok greatly reduces the number
    of lines of code, eliminating the so-called boilerplate, but it is also true that
    all IDEs can generate that boilerplate in a couple of clicks. This is a pseudo-criticism
    of Lombok. While it is certainly true that getters, setters, equals, builders,
    and more are generated in a moment by any IDE worthy of the name, it is also true
    that all of this code must then be maintained. How many times have we added a
    field to a class and forgotten to update the `equals` method? How many times have
    we had to change the getters and setters of a field because we changed its name
    or type? With Lombok, the chances of all these errors occurring simply do not
    exist.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我脑海中最后想到的可能缺陷，在我看来并不是缺陷，而是一些我经常听到的事情。确实，Lombok大大减少了代码行数，消除了所谓的样板代码，但同样真实的是，所有IDE都可以通过几点击就能生成这些样板代码。这是对Lombok的一种伪批评。虽然确实，任何值得称道的IDE都可以瞬间生成getter、setter、equals、builders等，但同样真实的是，所有这些代码都必须维护。我们有多少次在类中添加字段时忘记更新`equals`方法？我们有多少次因为更改了字段的名字或类型而不得不更改getter和setter？使用Lombok，所有这些错误发生的可能性几乎不存在。
- en: I hope I’ve given you some interesting ideas to think about so far. Unfortunately,
    I don’t have a one-size-fits-all solution for all these considerations. As always,
    we recommend evaluating each situation individually and trying to reach a team
    agreement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望到目前为止我已经给你提供了一些有趣的想法。不幸的是，我没有一个适用于所有这些考虑的万能解决方案。像往常一样，我们建议逐个评估每种情况，并尝试达成团队共识。
- en: In the next section, we will tell you about another library that can save you
    from a lot of manual work, especially when it comes to converting one type into
    another, which is something that unfortunately needs to be done in practically
    every project. MapStruct will free you from this burden or at least make it easier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍另一个可以让你从大量手动工作中解脱出来的库，尤其是在将一种类型转换为另一种类型时，这在几乎所有项目中都是不幸必须做的。MapStruct将让你摆脱这种负担，或者至少让它更容易。
- en: MapStruct
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapStruct
- en: While it’s not great to say, part of our job as software engineers is shipping
    information from one place to another. Sometimes, this shipping becomes a mere
    translation of a model into another model. Sad, but true.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样说并不太好，但作为软件工程师，我们的一部分工作就是将信息从一个地方传输到另一个地方。有时，这种传输仅仅是将一个模型翻译成另一个模型。悲哀但却是事实。
- en: 'Object mapping (sometimes referred to as **object adapting**) refers to the
    process of transforming data between different data models, such as from objects
    in an object-oriented programming language to database tables and vice versa.
    This process also includes objects belonging to different subdomains or even different
    layers of the application. Another notable example of mapping that is done frequently
    is when you have to call an external service (for example, via an HTTP/REST call)
    and you have to map the response you get from that service into your objects or
    your model. This situation is represented in the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象映射（有时被称为**对象适配**）是指在不同数据模型之间转换数据的过程，例如从面向对象编程语言中的对象到数据库表，反之亦然。这个过程还包括属于不同子域或甚至应用不同层的对象。另一个经常进行的映射示例是在你必须调用外部服务（例如，通过HTTP/REST调用）并将从该服务获得的响应映射到你的对象或模型时。这种情况在以下图中表示：
- en: '![Figure 6.1 – Mapping between client and service request models and back to
    the client model](img/B20912_06_1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 客户端和服务请求模型之间的映射以及返回客户端模型](img/B20912_06_1.jpg)'
- en: Figure 6.1 – Mapping between client and service request models and back to the
    client model
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 客户端和服务请求模型之间的映射以及返回客户端模型
- en: Writing mapping code can be very boring, and it’s prone to mistakes. But what
    if there was a tool that could do all this grunt work with minimal effort? Luckily
    for us, there are quite a few such tools out there, and our top pick is MapStruct.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编写映射代码可能非常无聊，而且容易出错。但如果有这样一个工具，可以以最小的努力完成所有这些繁琐的工作呢？幸运的是，我们确实有相当多的这样的工具，我们首选的是MapStruct。
- en: '**MapStruct** is an open source Java-based code generation library that simplifies
    the process of mapping between Java beans (POJOs). It is specifically designed
    for generating mapping codes between objects, eliminating the need to write this
    code manually, which can be time-consuming and error-prone. MapStruct’s primary
    purpose is to provide a straightforward and efficient way to convert data between
    different Java bean classes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapStruct** 是一个开源的基于 Java 的代码生成库，它简化了 Java bean（POJO）之间的映射过程。它专门设计用于生成对象之间的映射代码，消除了手动编写此代码的需要，这既耗时又容易出错。MapStruct
    的主要目的是提供一个简单高效的方法，在不同的 Java bean 类之间转换数据。'
- en: MapStruct serves as an annotation processor that’s seamlessly integrated into
    the Java compiler, making it compatible with command-line build tools such as
    Maven and Gradle, and equally suitable for use within your favorite IDE. While
    MapStruct provides sensible defaults for mapping, it also allows you to configure
    and implement specific behaviors when needed, giving you flexibility without imposing
    rigid constraints.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: MapStruct 作为一种注解处理器，无缝集成到 Java 编译器中，使其与 Maven 和 Gradle 等命令行构建工具兼容，同样适用于您喜欢的
    IDE。虽然 MapStruct 为映射提供了合理的默认值，但它也允许您在需要时配置和实现特定的行为，给您提供灵活性，而不强加严格的约束。
- en: 'Let’s see how MapStruct works. Suppose you have the following two classes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 MapStruct 是如何工作的。假设您有以下两个类：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to transfer the data from an instance of `PersonDTO` to an instance
    of `Person`. To do it in plain Java, we would need to write the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `PersonDTO` 实例的数据传输到 `Person` 实例。在纯 Java 中完成此操作，我们需要编写以下代码：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That is quite a lot of code for only three fields; it’s boring, time-consuming,
    and error-prone.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是三个字段就需要很多代码；这很无聊，耗时，且容易出错。
- en: 'Using MapStruct, we could just write an interface and let it do the magic:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MapStruct，我们只需编写一个接口，然后让它施展魔法：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The presence of the `@Mapper` annotation designates the interface as a mapping
    interface and triggers the MapStruct processor to engage during the compilation
    process. In the mapping method itself, you can freely select its name, and it
    should accept the `source` object as a parameter while returning the `target`
    object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存在 `@Mapper` 注解表明该接口是一个映射接口，并在编译过程中触发 MapStruct 处理器的运行。在映射方法本身中，您可以自由选择其名称，并且它应该接受
    `source` 对象作为参数，同时返回 `target` 对象。
- en: To handle attributes with distinct names in the `source` and `target` objects,
    you can employ the `@Mapping` annotation to specify the desired configuration.
    When necessary and feasible, type conversions will be carried out for attributes
    with differing types in the `source` and `target` objects. For instance, an enumeration
    type may be transformed into a string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 `source` 和 `target` 对象中具有不同名称的属性，您可以使用 `@Mapping` 注解来指定所需的配置。当必要时且可行时，将对
    `source` 和 `target` 对象中具有不同类型的属性执行类型转换。例如，枚举类型可能被转换为字符串。
- en: It’s worth noting that a single interface can host multiple mapping methods,
    each of which will have an implementation auto-generated by MapStruct. You can
    obtain an instance of the interface’s implementation through the `Mappers` class.
    As a convention, the interface typically includes a member called `INSTANCE`,
    offering clients a means to access the mapper implementation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，单个接口可以托管多种映射方法，每种方法都将由 MapStruct 自动生成实现。您可以通过 `Mappers` 类获取接口实现的实例。按照惯例，该接口通常包含一个名为
    `INSTANCE` 的成员，为客户端提供访问映射实现的方式。
- en: MapStruct will generate all the needed code for you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MapStruct 将为您生成所有需要的代码。
- en: 'You might have noticed that we’re missing the mapping from `birthdate` to `age`;
    this cannot be done automatically by MapStruct since a little bit of logic is
    involved (to calculate the current age from the birth date). In this case – and
    in any case, we should need it – we can implement specific mappings; also, in
    this case, the method names are not important since MapStruct will choose the
    right one based on the parameter and return types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们缺少从 `birthdate` 到 `age` 的映射；由于涉及一点逻辑（从出生日期计算当前年龄），MapStruct 无法自动完成此操作。在这种情况下——以及在任何情况下，我们可能需要它——我们可以实现特定的映射；此外，在这种情况下，方法名称并不重要，因为
    MapStruct 将根据参数和返回类型选择正确的方法：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the auto-generated implementation of the method, MapStruct will choose the
    `calculateCurrentAge` method just because it takes a `LocalDate` parameter and
    returns an `Integer` value. It is also possible to specify Java expressions and
    other stuff in the `@Mapping` annotation, but I recommend reading the documentation
    to dig a little bit deeper.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法自动生成的实现中，MapStruct将选择`calculateCurrentAge`方法，因为它接受一个`LocalDate`参数并返回一个`Integer`值。您也可以在`@Mapping`注解中指定Java表达式和其他内容，但我建议阅读文档以深入了解。
- en: With that, we’ve seen how MapStruct works and how it can make our lives easier
    by handling time-consuming tasks. As I mentioned, these were static metaprogramming
    tools – they work directly on the code. Now, let’s look at runtime metaprogramming
    tools, which work on the running program instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经看到了MapStruct是如何工作的，以及它是如何通过处理耗时任务来使我们的生活变得更轻松的。正如我提到的，这些是静态元编程工具——它们直接在代码上工作。现在，让我们看看运行时元编程工具，它们在运行的程序上工作。
- en: Exploring runtime metaprogramming tools
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索运行时元编程工具
- en: '**Runtime metaprogramming** operates while the program is being executed. It
    enables the program to inspect and modify its own code and data structures during
    runtime, often using techniques such as reflection, dynamic code generation, and
    dynamic proxy. Learning about runtime metaprogramming tools can empower you to
    manipulate and adapt the behavior of a running program dynamically, enhancing
    flexibility and customization within your software.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时元编程**在程序执行时进行操作。它使程序能够在运行时检查和修改自己的代码和数据结构，通常使用反射、动态代码生成和动态代理等技术。了解运行时元编程工具可以帮助您动态地操作和调整正在运行的程序的行为，从而增强软件中的灵活性和定制性。'
- en: Now, let’s talk about reflection since it is the most used feature in runtime
    metaprogramming.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈反射，因为它是运行时元编程中最常用的功能。
- en: Reflection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射
- en: '**Reflection** is a feature in programming languages such as Java that allows
    a program to examine or *reflect* upon its structure, data, and behavior during
    runtime. In Java, reflection is primarily used to inspect and manipulate classes,
    objects, methods, fields, and other elements of the program at runtime.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**是Java等编程语言中的一项功能，允许程序在运行时检查或*反映*其结构、数据和行为。在Java中，反射主要用于在运行时检查和操作类、对象、方法、字段和程序的其他元素。'
- en: 'Reflection allows you to perform the following tasks in Java:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许您在Java中执行以下任务：
- en: '**Inspect classes**: You can obtain information about classes, including their
    name, superclass, implemented interfaces, constructors, methods, and fields'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查类**：您可以获取有关类的信息，包括它们的名称、超类、实现的接口、构造函数、方法和字段。'
- en: '**Inspect objects**: You can examine the properties and fields of objects,
    even if their types are not known at compile time'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查对象**：即使它们的类型在编译时未知，您也可以检查对象的属性和字段。'
- en: '**Invoke methods**: You can invoke methods on objects, even if you don’t know
    the method’s name until runtime'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用方法**：即使不知道方法名称，您也可以在对象上调用方法。'
- en: '**Access fields**: You can read or modify the values of fields within an object,
    even if you don’t know the field’s name until runtime'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**访问字段**：即使不知道字段的名称，您也可以在运行时读取或修改对象内字段的值。'
- en: 'For example, let’s add the following method to the `Person` class (see the
    *MapStruct* section):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向`Person`类添加以下方法（参见*MapStruct*部分）：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s create another class that operates on it using reflection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个使用反射操作它的类：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we do the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行以下操作：
- en: We obtain the `Class` object representing the `Person` class using `Class.forName("
    com.example.demo3.mapstruct.Person")`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Class.forName("com.example.demo3.mapstruct.Person")`获取表示`Person`类的`Class`对象。
- en: We create an instance of the `Person` class dynamically using its constructor
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用构造函数动态创建`Person`类的实例。
- en: We access the private name field, bypassing the access modifier and modifying
    its value
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们访问私有名称字段，绕过访问修饰符并修改其值。
- en: We invoke the `greet` method of the `Person` instance using reflection
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用反射调用`Person`实例的`greet`方法。
- en: We verify that the name field has been modified successfully
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们验证名称字段已被成功修改。
- en: Please note that while this example demonstrates the use of reflection, it is
    essential to exercise caution when using reflection in practice. Reflection should
    be used judiciously, and you should be aware of the potential risks and performance
    implications associated with it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然这个示例演示了反射的使用，但在实际使用反射时必须谨慎。反射应谨慎使用，并且你应该意识到与之相关的潜在风险和性能影响。
- en: For example, there could be security risks because reflection can bypass Java’s
    access controls, allowing you to access and modify private members of classes.
    While this flexibility can be beneficial, it can also introduce security vulnerabilities
    if it’s not used with due care. Unauthorized access to sensitive data or the manipulation
    of internal program states can occur, which is why it’s crucial to employ security
    measures to prevent abuse.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能存在安全风险，因为反射可以绕过Java的访问控制，允许你访问和修改类的私有成员。虽然这种灵活性可能是有益的，但如果使用不当，也可能引入安全漏洞。未经授权访问敏感数据或操纵程序内部状态可能会发生，这就是为什么采取安全措施防止滥用至关重要的原因。
- en: 'Another very common problem is type safety: reflection operates at a low level
    and doesn’t provide the same level of type safety as traditional Java code. This
    can lead to unexpected type errors at runtime. For instance, you might call a
    method with the wrong parameters, and the error won’t be discovered until your
    code is running. This lack of compile-time checks can result in hard-to-debug
    runtime exceptions. It is also true that most of the modern IDEs warn the developer
    about this risk at the moment of writing code.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的问题是类型安全：反射在低级别操作，并且不提供与传统Java代码相同的类型安全级别。这可能导致运行时出现意外的类型错误。例如，你可能会用错误的参数调用方法，错误直到代码运行时才会被发现。这种缺乏编译时检查可能导致难以调试的运行时异常。同时，大多数现代IDE在编写代码时会提醒开发者这种风险。
- en: There are also some other challenges, concerning reflection in association with
    the clean code, that we will expand on in the following section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们还将扩展与干净的代码相关的其他一些挑战，涉及反射。
- en: Reflection and clean code
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射与干净的代码
- en: In a chapter about metaprogramming, we felt we had the duty to tell you something
    about runtime metaprogramming and its most (in)famous declination, which is reflection.
    But let’s think a bit about what reflection involves in terms of keeping your
    code base clean.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于元编程的章节中，我们觉得有责任告诉你关于运行时元编程及其最（不）著名的表现形式——反射的一些内容。但让我们先思考一下，从保持代码库清洁的角度来看，反射涉及哪些方面。
- en: 'Reflection and **clean code** can sometimes be at odds with each other as reflection
    introduces complexities and potential code readability issues. However, when used
    carefully and thoughtfully, reflection can be employed in a clean and maintainable
    way. Let’s explore how reflection can impact clean code principles and how to
    strike a balance between them:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 反射与**干净的代码**有时可能存在冲突，因为反射引入了复杂性和潜在的代码可读性问题。然而，当谨慎且深思熟虑地使用时，反射可以以干净和可维护的方式使用。让我们探讨反射如何影响干净的代码原则，以及如何在它们之间取得平衡：
- en: '**Readability**: Clean code promotes readability. Reflection can make code
    less readable as it often involves working with class names and method names as
    strings, which are error-prone and can lead to code that is challenging to understand.
    To mitigate this, document your use of reflection thoroughly and provide clear
    comments explaining your intentions.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：干净的代码促进可读性。反射可能会使代码的可读性降低，因为它通常涉及以字符串形式处理类名和方法名，这容易出错，可能导致难以理解的代码。为了减轻这种情况，应彻底记录反射的使用，并提供清晰的注释来解释你的意图。'
- en: '**Maintainability**: Reflection can make code harder to maintain because it
    bypasses some of the compile-time checks that the Java compiler provides. If you’re
    using reflection to access private members or perform operations that wouldn’t
    be allowed through normal means, it can lead to unexpected behavior or maintenance
    challenges. You should consider alternatives, such as making the necessary changes
    to the code structure, whenever possible.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：反射可以使代码更难维护，因为它绕过了Java编译器提供的某些编译时检查。如果你使用反射来访问私有成员或执行通过常规方式不允许的操作，可能会导致意外的行为或维护挑战。在可能的情况下，你应该考虑替代方案，例如对代码结构进行必要的修改。'
- en: '**Simplicity**: Clean code encourages simplicity. Reflection, being a complex
    feature, can introduce unnecessary complexity. It’s essential to ensure that your
    use of reflection is justified and that you are not introducing complexity where
    it’s not needed.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：清洁代码鼓励简洁性。作为一个复杂的特性，反射可能会引入不必要的复杂性。确保你的反射使用是合理的，并且没有在不必要的地方引入复杂性是至关重要的。'
- en: '**Consistency**: Clean code aims for consistency and a uniform style. Reflection
    can lead to inconsistent code because different parts of your program might access
    and manipulate elements in a variety of ways. To maintain consistency, consider
    establishing conventions and patterns for your use of reflection.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：清洁代码追求一致性和统一风格。反射可能导致代码不一致，因为程序的不同部分可能以各种方式访问和操作元素。为了保持一致性，考虑为你的反射使用建立约定和模式。'
- en: '**Testing**: Clean code emphasizes testability. Reflection can make it challenging
    to write unit tests since it allows you to bypass encapsulation. You might need
    to rely on integration tests or mock objects, which can be less ideal for isolated
    unit testing. Whenever possible, prefer to design your code for easy unit testing
    without relying heavily on reflection.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：清洁代码强调可测试性。反射可能会使编写单元测试变得具有挑战性，因为它允许你绕过封装。你可能需要依赖集成测试或模拟对象，这对于隔离单元测试来说可能不是最佳选择。在可能的情况下，优先设计易于单元测试的代码，而不依赖于过度的反射。'
- en: '**Performance**: Clean code should be efficient. Reflection can introduce performance
    overhead due to its dynamic nature. Before using reflection, profile your code
    and ensure that the performance impact is acceptable. In performance-critical
    applications, you might need to explore alternative approaches.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：清洁代码应该是高效的。由于反射的动态特性，它可能会引入性能开销。在使用反射之前，分析你的代码并确保性能影响是可以接受的。在性能关键的应用中，你可能需要探索替代方法。'
- en: '**Documentation**: Clean code aims to have no technical documentation at all
    since the code is so clear that it explains itself. However, since reflection
    decreases readability (we just said that a few words ago), the need for clear
    documentation or comments becomes essential. When using reflection, think about
    providing comprehensive documentation explaining the purpose, expected behavior,
    and potential risks associated with your reflective code.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：清洁代码的目标是完全不需要技术文档，因为代码本身如此清晰，可以自我解释。然而，由于反射降低了可读性（我们刚才说过），清晰文档或注释的需求变得至关重要。在使用反射时，考虑提供全面的文档，解释反射代码的目的、预期行为和潜在风险。'
- en: So, reflection is a powerful but potentially dangerous feature in Java, and
    it should be used sparingly and with caution. It’s essential to weigh the benefits
    of using reflection against the added complexity and potential drawbacks it introduces
    to your code base. If you decide to use reflection, do so thoughtfully and document
    your code thoroughly to maintain clarity and transparency. Clean code principles
    should remain a top priority, even when you’re using reflection, to ensure your
    code base remains maintainable, readable, and efficient (nevertheless, it is worth
    noticing that reflection is often used “under the hood” in many metaprogramming
    frameworks).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，反射是Java中一种强大但潜在危险的特性，应该谨慎且少量使用。在决定使用反射时，必须权衡其带来的好处与对代码库增加的复杂性和潜在缺点。如果决定使用反射，应深思熟虑并详尽地记录代码，以保持清晰和透明度。即使在使用反射时，清洁代码的原则也应始终是首要任务，以确保代码库保持可维护性、可读性和效率（尽管如此，值得注意的是，反射通常在许多元编程框架的“幕后”使用）。
- en: Now that we’ve learned what metaprogramming is, both in its static and runtime
    flavor, let’s add some considerations about the pros and cons of these very powerful
    tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是元编程，包括其静态和运行时风味，让我们来考虑一下这些非常强大的工具的优缺点。
- en: Weighing the pros and cons of metaprogramming
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑元编程的利弊
- en: Metaprogramming and clean code are two essential concepts in software development,
    and while they can sometimes appear to be at odds, they can also work in harmony
    when used effectively.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程和清洁代码是软件开发中的两个基本概念，虽然它们有时似乎相互矛盾，但使用得当的话，它们也可以和谐共存。
- en: Metaprogramming, in essence, involves dynamically manipulating or generating
    code during compilation or runtime. It offers the ability to automate repetitive
    tasks, create abstractions, and introduce flexibility into software development.
    Clean code, on the other hand, is a coding philosophy that emphasizes writing
    code that is easily readable, understandable, and maintainable. It promotes principles
    such as meaningful naming, eliminating redundancy, small and focused functions,
    and adhering to established coding conventions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程本质上涉及在编译或运行时动态操作或生成代码。它提供了自动化重复任务、创建抽象和将灵活性引入软件开发的能力。另一方面，干净的代码是一种编码哲学，强调编写易于阅读、理解和维护的代码。它推崇诸如有意义的命名、消除冗余、小型和专注的函数以及遵守既定的编码规范等原则。
- en: Metaprogramming can aid in generating clean code by automating the creation
    of repetitive code structures and reducing clutter in source code files (for example,
    eliminating some boilerplate code, as we saw in the case of Lombok).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程可以通过自动化创建重复的代码结构并减少源代码文件中的杂乱（例如，像我们在Lombok的案例中看到的那样消除一些样板代码）来帮助生成干净的代码。
- en: Moreover, it can facilitate the development of abstractions that hide implementation
    details, leading to cleaner and more maintainable code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还可以促进开发隐藏实现细节的抽象，从而产生更干净、更易于维护的代码。
- en: However, not all that glitters is gold; you must ensure that the generated code
    is clean and adheres to clean code principles. Automation should not result in
    messy or cryptic code. In this sense, using well-known and well-tested frameworks
    with a solid community and a lot of documentation is probably the way to go. We
    don’t endorse reinventing the wheel, never; it’s very unlikely that you will find
    yourself in a situation where metaprogramming from scratch is what you need unless
    it’s for very small and limited use cases.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有闪亮的东西都是金子；你必须确保生成的代码是干净的，并遵循干净代码的原则。自动化不应导致杂乱或难以理解的代码。从这个意义上说，使用知名、经过良好测试的框架，拥有坚实的社区和大量文档，可能是正确的做法。我们从不支持重造轮子，永远不；除非是非常小和有限的用例，否则你不太可能发现自己需要从头开始进行元编程。
- en: You also have to balance the advantages of automation with code readability
    and understandability since metaprogramming can introduce complexity. I once found
    myself in front of a Java method that returned a string containing an HTML web
    page! Without getting to sadness peaks like that, be sure that your teammates
    (and don’t forget your future self) can expand or modify your software with only
    a reasonable amount of headaches. We invite you to discuss every metaprogramming
    choice with the team. Avoid excessive “magic” in your code as it can obscure the
    understanding of the underlying processes. This obscurity may result in the emergence
    of bugs or unpredictable performance issues.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须平衡自动化的优势与代码的可读性和可理解性，因为元编程可能会引入复杂性。我曾经面对一个返回包含HTML网页字符串的Java方法！不要陷入那样的悲伤顶峰，确保你的队友（还有不要忘记你未来的自己）只需合理的头痛就能扩展或修改你的软件。我们邀请你与团队讨论每一个元编程选择。避免在代码中过度使用“魔法”，因为这可能会掩盖底层过程的了解。这种不明朗可能会导致错误或不可预测的性能问题。
- en: If you just have to go for metaprogramming, document complex metaprogramming
    solutions thoroughly, providing clear explanations to assist future developers.
    Provide examples and write comments; in a single word, be merciful.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须采用元编程，请彻底记录复杂的元编程解决方案，提供清晰的解释以帮助未来的开发者。提供示例并编写注释；用一个词来说，就是仁慈。
- en: Having said that, we think that clean code’s advantages in terms of testing
    and debugging are notable, especially when dealing with compile-time metaprogramming
    tools such as Lombok and MapStruct. The essence of that advantage is that not
    only do you have cleaner code (because, for instance, the usage of Lombok facilitates
    object immutability) but you have less code. Having as little code as possible
    should be one of your top priorities.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们认为在测试和调试方面，干净代码的优势是显著的，尤其是在处理像Lombok和MapStruct这样的编译时元编程工具时。这种优势的本质在于，你不仅拥有更干净的代码（例如，Lombok的使用促进了对象的不可变性），而且代码量更少。尽可能少地编写代码应该是你的首要任务之一。
- en: Metaprogramming and clean code can coexist harmoniously. Combining the advantages
    of automation and flexibility with a commitment to writing clean and maintainable
    code ensures that software projects remain both efficient and sustainable in the
    long run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程和清洁代码可以和谐共存。将自动化的优势与灵活性与编写清洁且可维护的代码的承诺相结合，确保软件项目在长期内既高效又可持续。
- en: While talking about metaprogramming’s pros and cons, it is worth mentioning
    the so-called **Not-Invented-Here** (**NIH**) syndrome. NIH syndrome refers to
    the tendency of some development teams or individuals to prefer creating their
    own solutions or tools rather than adopting existing, external solutions. This
    can happen even when existing solutions are well-established, proven, and readily
    available.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论元编程的优缺点时，值得提及所谓的**“非原创”**（**NIH**）综合症。NIH综合症指的是一些开发团队或个人倾向于创建自己的解决方案或工具，而不是采用现有的外部解决方案。即使现有解决方案已经确立、经过验证且易于获取，这种情况也可能发生。
- en: NIH syndrome can lead to several issues, including increased development time,
    reinvention of the wheel, and missed opportunities to leverage the expertise and
    contributions of the broader development community. It’s often considered a counterproductive
    behavior, and many software development communities encourage a more open-minded
    approach to adopting existing solutions when appropriate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: NIH综合症可能导致几个问题，包括增加的开发时间、重复造轮子，以及错失利用更广泛开发社区的专业知识和贡献的机会。这通常被认为是一种反生产力的行为，许多软件开发社区鼓励在适当的时候采取更开放的心态来采用现有解决方案。
- en: Teams and developers are encouraged to weigh the pros and cons of building something
    in-house versus using external libraries or frameworks while considering factors
    such as time, expertise, maintenance, and the availability of well-established
    solutions in the open source community.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑时间、专业知识、维护以及开源社区中已确立解决方案的可用性等因素时，鼓励团队和开发者权衡在内部构建与使用外部库或框架之间的利弊。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we talked about metaprogramming: what it is, how it works,
    and how it can or cannot be useful concerning clean code and refactoring. In particular,
    we looked at two very popular libraries that involve metaprogramming, especially
    code auto-generation: Lombok and MapStruct.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了元编程：它是什么，它是如何工作的，以及它对清洁代码和重构有何帮助或无帮助。特别是，我们研究了两个涉及元编程的非常流行的库，特别是代码自动生成：Lombok和MapStruct。
- en: We also warned you about the potential risks of using reflection and, in general,
    spoke about the pros and cons of using metaprogramming tools.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提醒了您使用反射可能存在的潜在风险，并且一般性地讨论了使用元编程工具的优缺点。
- en: In the next chapter, we will dive into static analysis, a method of code inspection
    that checks for issues without executing the code, and dynamic analysis, which
    involves evaluating code during its execution to identify problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨静态分析，这是一种不执行代码就检查问题的代码检查方法，以及动态分析，它涉及在代码执行期间评估代码以识别问题。
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Lombok’s official documentation: [https://projectlombok.org/features/](https://projectlombok.org/features/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lombok的官方文档：[https://projectlombok.org/features/](https://projectlombok.org/features/)
- en: '*Lombok: The Good, The Bad, and The Controversial*, by Felix Coutinho [https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/](https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Lombok：优点、缺点和争议》*，作者 Felix Coutinho [https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/](https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/)'
- en: 'MapStruct’s official website: [https://mapstruct.org/](https://mapstruct.org/)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MapStruct的官方网站：[https://mapstruct.org/](https://mapstruct.org/)
