- en: Application Performance Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能优化
- en: In the previous chapter, we focused on how to profile an application to figure
    out the performance issue of an application. We also covered logging, which is
    a useful tool in identifying issues in the application. It was an essential part
    and will be part of our daily routine when we work on Spring applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们重点介绍了如何对应用程序进行分析以找出应用程序的性能问题。我们还涵盖了日志记录，这是识别应用程序问题的有用工具。这是一个重要的部分，并且在我们处理Spring应用程序时将成为我们日常工作的一部分。
- en: Now let's look at what we've got in this chapter. This is a crucial chapter
    in this book; it provides you with ways to improve application performance. In this
    chapter, we will discuss the fundamental approach for application performance
    optimization, which is key for any application, including Spring-based applications.
    We'll discuss Spring's support for **Java Management Extension** (**JMX**), improvements
    in database interactions, and the performance tuning of Spring applications. By
    the end of this chapter, you will be able to identify performance bottlenecks
    in a Spring-based application and resolve them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看本章内容。这是本书中的一个关键章节；它为您提供了改善应用性能的方法。在本章中，我们将讨论应用性能优化的基本方法，这对于任何应用程序都是关键的，包括基于Spring的应用程序。我们将讨论Spring对Java管理扩展（JMX）的支持，数据库交互的改进以及Spring应用程序的性能调优。通过本章结束时，您将能够识别Spring应用程序中的性能瓶颈并解决它们。
- en: 'Let''s look at important aspects of application performance optimization with
    a structured approach. We''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以结构化的方式来看应用性能优化的重要方面。我们将涵盖以下主题：
- en: Performance issue symptoms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能问题症状
- en: Performance tuning life cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能调优生命周期
- en: Performance tuning patterns and anti-patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能调优模式和反模式
- en: The iterative performance-tuning process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代性能调优过程
- en: Spring support of JMX
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring对JMX的支持
- en: Performance issue symptoms
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题症状
- en: Let's start with performance issue symptoms. This is an obvious place to start,
    as it's like consulting a doctor where symptoms are discussed and then a diagnosis
    is made. Application performance is the behavior experienced by the end users
    in terms of speed, accuracy in delivering the content, and average response times
    under the highest load. The load is referred to by the number of transactions
    processed by the application per unit time. The response times are the times required
    for an application to respond to a user's actions at such a load.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从性能问题症状开始。这是一个明显的起点，就像咨询医生一样，首先讨论症状，然后做出诊断。应用性能是用户在速度、交付内容的准确性和最高负载下的平均响应时间方面所经历的行为。负载是指应用程序每单位时间处理的交易数量。响应时间是应用程序在这样的负载下响应用户操作所需的时间。
- en: Whenever performance needs an improvement, the first thing that comes to mind
    is the problems that are affecting the performance of our application. To find
    the issues with performance, we need to look for certain symptoms that can lead
    us to the issue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当性能需要改进时，首先想到的是影响我们应用程序性能的问题。要找出性能问题，我们需要寻找一些症状，这些症状可以引导我们找到问题。
- en: 'Some common symptoms that can be observed in a Spring application are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用中可能观察到的一些常见症状如下：
- en: Timeouts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时
- en: Running out of worker threads
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程不足
- en: Threads waiting on class loaders
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程等待类加载器
- en: A major amount of time spent on loading classes even under normal load
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在正常负载下，加载类所花费的大量时间
- en: Class loader attempts to load non-existing classes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器尝试加载不存在的类
- en: In the following sections, we will understand these symptoms with an example
    context. The details will help us identify the symptom when it occurs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过一个示例情境来理解这些症状。这些细节将帮助我们在发生时识别症状。
- en: Timeouts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: Timeouts occur in two different ways. One is the request timeout, which is represented
    by `HTTP response status code 408`. Another flavor of timeout is the gateway timeout,
    which is represented by `HTTP response status code 504`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 超时以两种不同的方式发生。一种是请求超时，由HTTP响应状态码408表示。另一种超时是网关超时，由HTTP响应状态码504表示。
- en: The request timeout indicates that the server did not receive the complete request
    from the client within the specified time. In such a case, the server chose to
    close the connection with the client. The request timeout is an error message
    directly from the server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请求超时表示服务器未能在指定时间内从客户端接收完整的请求。在这种情况下，服务器选择与客户端关闭连接。请求超时是服务器直接的错误消息。
- en: The gateway timeout indicates that the gateway or the proxy server timed out
    while processing the request. In most cases, this is because the proxy or gateway
    do not receive a timely response from the actual server in the upstream.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 网关超时表示网关或代理服务器在处理请求时超时。在大多数情况下，这是因为代理或网关未能及时从上游的实际服务器接收到响应。
- en: Running out of worker threads
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作线程不足
- en: 'Consider the example of a bank; the bank has a web application with a monitoring
    system on top of it. The monitoring system keeps an eye on the strength of the
    JVMs. The parameters for measurement are memory, CPU, I/O, heap memory, and various
    other attributes. The monitoring system provides distinctive dashboards that show
    and highlight the measurements for the aforementioned attributes. There exists
    an accompanying dashboard that demonstrates the group of activities performed
    in the banking application. This dashboard also identifies the group of activities
    on which the JVM starts running low while accessing specialized application resources,
    such as threads. The application is running in multiple JVM environments. The
    following is a screenshot of a sample dashboard for reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以银行为例；银行拥有一个带有监控系统的Web应用程序。监控系统关注JVM的强度。测量参数包括内存、CPU、I/O、堆内存和其他各种属性。监控系统提供了独特的仪表板，显示并突出显示了上述属性的测量结果。还有一个附带的仪表板，显示了银行应用程序中执行的活动组。该仪表板还确定了JVM在访问专门的应用程序资源（如线程）时开始运行低的活动组。该应用程序在多个JVM环境中运行。以下是一个示例仪表板的屏幕截图，仅供参考：
- en: '![](img/c373a988-ca43-4519-83e1-858dba4aa7e3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c373a988-ca43-4519-83e1-858dba4aa7e3.png)'
- en: The monitoring system is configured with threshold values. For example, the
    maximum threads utilized by a JVM at a time should be no more than 250\. When
    the JVM is utilizing less than 150 threads at a time, the corresponding JVM indicator
    in the dashboard is green. At the time when the JVM starts utilizing more than
    150 threads, the monitoring system indicates that JVM in red. It is a symptom
    indicating that a failure might occur or that performance is impacted beyond normal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 监控系统配置了阈值。例如，JVM一次使用的最大线程数不应超过250个。当JVM一次使用的线程少于150个时，仪表板中相应的JVM指示灯为绿色。当JVM开始使用超过150个线程时，监控系统会将该JVM指示为红色。这是一个症状，表明可能会发生故障或性能受到异常影响。
- en: 'The following is a timeline-based screenshot showing JVMs maxed out of worker
    threads:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基于时间线的屏幕截图，显示了JVM的工作线程达到最大值：
- en: '![](img/bb3eb73b-7e96-45ee-944a-f4820cc2478a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb3eb73b-7e96-45ee-944a-f4820cc2478a.png)'
- en: Threads waiting on class loaders
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程在类加载器上等待
- en: Continuing with the same example as described in the previous section, the first
    question that arises is, what is wrong with these threads? Taking a deeper look
    into the threads and breaking down the state, it was discerned that these threads
    (approximately 242 out of 250) were looking out for the server's `CompoundClassLoader`.
    These threads were stacking extra objects and that's what they were looking out
    for the class loader. Because of the high number of threads endeavoring to get
    to that common asset—the class loader—most threads got stuck in pause.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用前一节中描述的相同示例，首先出现的问题是，这些线程有什么问题？深入研究线程并分解状态后发现，这些线程（大约250个中的242个）正在寻找服务器的`CompoundClassLoader`。这些线程正在堆叠额外的对象，这就是它们正在寻找类加载器的原因。由于大量线程试图访问这个共享资源——类加载器，大多数线程都陷入了暂停状态。
- en: 'The following screenshot from the monitoring shows the number of threads waiting
    for `CompoundClassLoader`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 监控显示了等待`CompoundClassLoader`的线程数量：
- en: '![](img/deab9529-89de-4cb5-acf7-2a91ed0379f6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deab9529-89de-4cb5-acf7-2a91ed0379f6.png)'
- en: Time spent on class-loading activities
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类加载活动上花费的时间
- en: 'Another thing that came out of the analysis in the monitoring system is that
    threads spend most of their time on class-loading activities. The following is
    the monitoring system screenshot highlighting this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控系统中进行的分析还表明，线程大部分时间都花在类加载活动上。以下是突出显示这一点的监控系统截图：
- en: '![](img/fc724071-fc1d-43cc-8a32-b241274c1ab0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc724071-fc1d-43cc-8a32-b241274c1ab0.png)'
- en: Looking at the previous screenshot of the monitoring system, it is clear that
    regardless of the current load, the class-loading activities take considerable
    time compared to other activities in a request-processing life cycle. This is
    an indication or symptom of a performance problem as it increases the overall
    response time. In the case of a bank, it could be confirmed by evaluating average
    response times.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从监控系统的先前屏幕截图来看，很明显，无论当前负载如何，与请求处理生命周期中的其他活动相比，类加载活动都需要相当长的时间。这是性能问题的指标或症状，因为它会增加整体响应时间。在银行的情况下，可以通过评估平均响应时间来确认。
- en: Class loader trying to load non-existent classes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载器尝试加载不存在的类
- en: 'One question arises: Is the class stacking extremely important? Digging deeper
    and looking at the requests processed, it demonstrated that each request tried
    to stack a class that did not exist. The application server was prompting a huge
    amount of the `ClassNotFoundException` class. The main driver of the issue is
    that the class could never be effectively stacked, but the application server
    continued attempting to stack it for each request. This should not be a problem
    for quick and moderate requests and features. This level of detail for each incoming
    request or feature may clutch the rare asset—the class loader—and, accordingly,
    affect the response time for requests.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题出现了：类堆叠是否非常重要？深入挖掘并查看处理的请求，表明每个请求都试图堆叠一个不存在的类。应用服务器正在提示大量的`ClassNotFoundException`类。问题的主要驱动因素是该类无法被有效地堆叠，但应用服务器继续尝试为每个请求堆叠它。这对于快速和中等请求和功能来说不应该是一个问题。对于每个传入请求或功能的这种细节水平可能会占用稀缺资源——类加载器，并因此影响请求的响应时间。
- en: 'The ability, adaptability, and capacity of the monitoring system is to catch
    each and every request and response with the data on stacking classes to help
    recognize the symptoms. The following screenshot displays one such scenario in
    the application framework:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 监控系统的能力、适应性和容量是捕捉每个请求和响应以及有关堆叠类数据的关键。以下屏幕截图显示了应用框架中的一个这样的场景：
- en: '![](img/9881ec25-1c27-499d-bd7a-158e8cf8ba1d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9881ec25-1c27-499d-bd7a-158e8cf8ba1d.png)'
- en: 'The symptoms of a potential performance issue must be clear by now. It is specifically
    applicable to any JVM-based web application, not only a Spring-based web application.
    The following screenshot shows us the pointers that would basically help us identify
    the impact of performance issues:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了潜在性能问题的症状。这特别适用于任何基于JVM的Web应用程序，而不仅仅是基于Spring的Web应用程序。以下截图显示了基本上可以帮助我们识别性能问题影响的指针。
- en: '![](img/2c99527f-9e1b-4148-9ea7-f400f5f6c078.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c99527f-9e1b-4148-9ea7-f400f5f6c078.png)'
- en: Poorly performing applications matter a lot to businesses, as they have seen
    dips in sales because of application performance. An application can also notice
    productivity or business loss because of performance issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不佳的应用对企业非常重要，因为它们因应用性能而导致销售额下降。应用也可能因性能问题而导致生产率或业务损失。
- en: 'Let''s understand the business impact of performance issues with a basic illustration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基本示例来了解性能问题对业务的影响：
- en: '![](img/9425db8d-afef-400b-8c3a-f2d273f73661.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9425db8d-afef-400b-8c3a-f2d273f73661.jpg)'
- en: As we can understand from the previous diagram, bad application behavior can
    impact business, which can be described in either high project costs, a decrease
    in conversion ratios, fewer repeat visits and poor customer retention, a decline
    in sales, a decline in productivity, losing customers, increases in project cost,
    and delays or declines in profit and returns on investments. Performance matters
    a lot to businesses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以理解，糟糕的应用行为会影响业务，可能导致项目成本高、转化率下降、重复访问减少、客户保留率低、销售额下降、生产率下降、客户流失、项目成本增加，以及利润和投资回报的延迟或下降。性能对企业非常重要。
- en: What do we need to do to avoid or address performance issues? Don't wait for
    performance issues to occur. Get architecture, design, and code reviewed, and
    plan out for load testing, tuning, and benchmarking in advance. Today, in the
    world of competitive marketing, an organization's key point is to have their system
    up and running with the best performance. Any failure or downtime directly impacts
    the business and revenue; performance of an application is a factor that cannot
    be overlooked. Day by day, the mountain of data is growing because of the extensive
    use of technology in numerous ways. Due to this, the load average is going through
    the roof. For some cases, it cannot be assured that data will not exceed the limit
    or the number of users will not go out of bounds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做什么来避免或解决性能问题？不要等待性能问题发生。提前进行架构、设计和代码审查，并计划进行负载测试、调优和基准测试。如今，在竞争激烈的市场中，组织的关键是确保其系统以最佳性能运行。任何故障或停机都直接影响业务和收入；应用程序的性能是一个不容忽视的因素。由于技术的广泛应用，数据量日益增长。因此，负载平均值正在飙升。在某些情况下，无法保证数据不会超出限制或用户数量不会超出范围。
- en: At any point, we can meet unexpected demands to scale. For any organization,
    it is very important for its application to provide scalability, performance,
    availability, and security. Application scalability in terms of scaling horizontally
    and vertically by spreading database to cater to different application queries
    across multiple servers, is quite feasible. It is easy to add horsepower to the
    cluster to handle the load. Cluster servers instantly handle failures and manage
    the failover part to keep your system available almost all the time. If one server
    goes down, it will redirect the user's request to another node and perform the
    requested operation. Today, in the world of competitive marketing, an organization's
    key point is to have their system up and running. Any failure or downtime directly
    impacts business and revenue; high availability is a factor that cannot be overlooked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，我们都可能遇到意想不到的扩展需求。对于任何组织来说，其应用程序提供可伸缩性、性能、可用性和安全性非常重要。在多个服务器上分布数据库以满足不同应用程序查询的应用程序可伸缩性，无论是水平扩展还是垂直扩展，都是相当可行的。向集群添加计算能力以处理负载非常容易。集群服务器可以立即处理故障并管理故障转移部分，以保持系统几乎一直可用。如果一个服务器宕机，它将重定向用户的请求到另一个节点并执行所请求的操作。如今，在竞争激烈的市场中，组织的关键是确保其系统正常运行。任何故障或停机都直接影响业务和收入；高可用性是一个不容忽视的因素。
- en: 'The following diagram shows us some of the common performance issues that we
    might come across:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们可能遇到的一些常见性能问题：
- en: '![](img/f5deff9a-aecd-42c7-85d3-b708660ee1b5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5deff9a-aecd-42c7-85d3-b708660ee1b5.png)'
- en: Now, let's move towards the phases of the performance tuning life cycle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看性能调优生命周期的各个阶段。
- en: Performance tuning life cycle
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能调优生命周期
- en: Speed is at the heart of every business. In this hyper-connected modern world,
    the thing that fascinates the majority of people is speed; be it the fastest car,
    fastest computer processor, or even the fastest website. Website performance has
    become the highest priority of each and every business. User's expectations are
    higher than ever. If your website doesn't respond instantly, there are high chances
    that your users will switch to your competitors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是每个企业的核心。在这个超连接的现代世界中，大多数人着迷的是速度；无论是最快的汽车、最快的计算机处理器，甚至是最快的网站。网站性能已经成为每个企业的最高优先级。用户的期望比以往任何时候都更高。如果您的网站不能立即响应，很有可能用户会转向竞争对手。
- en: A study by Walmart ([https://www.slideshare.net/devonauerswald/walmart-pagespeedslide](https://www.slideshare.net/devonauerswald/walmart-pagespeedslide))
    found that for every 1 second of page performance improvement, there's a 2% increase
    in conversions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 沃尔玛的一项研究发现，每提高1秒的页面性能，转化率就会增加2%。
- en: 'A study by Akamai ([https://www.akamai.com/us/en/about/news/](https://www.akamai.com/us/en/about/news/))
    found that:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Akamai的一项研究发现：
- en: 47% of people expect a web page to load in two seconds or fewer
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 47%的人期望网页在两秒内加载完成
- en: 40% will abandon a web page if it takes more than three seconds to load
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个网页加载时间超过三秒，40%的人会放弃访问
- en: 52% of online shoppers say quick page loads are important for their loyalty
    to a site
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 52%的在线购物者表示快速页面加载对他们对网站的忠诚度很重要
- en: In 2007, Amazon reported that for every 100-millisecond increase in the load
    time of Amazon ([https://www.amazon.com/](https://www.amazon.com/)), their sales
    decreased by 1%.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年，亚马逊报告称，亚马逊（[https://www.amazon.com/](https://www.amazon.com/)）的加载时间每增加100毫秒，销售额就会减少1%。
- en: 'With help of the following figure, we can easily understand the different phases
    of the life cycle of performance tuning:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 借助以下图，我们可以轻松理解性能调优生命周期的不同阶段：
- en: '![](img/0d791f68-7d97-47f3-a077-4fc430654185.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d791f68-7d97-47f3-a077-4fc430654185.jpg)'
- en: 'In most of these cases, performance issues can be avoided by reviewing the
    following artifacts at the right time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，通过在适当的时候审查以下工件，可以避免性能问题：
- en: Architecture
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: Design
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计
- en: Code
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: Engage expert consultants to perform application reviews at the right time
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聘请专家顾问在适当的时候进行应用程序审查
- en: Engage any time before the development phase is completed
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发阶段完成之前的任何时间进行审查
- en: It is strongly recommended to identify performance optimization issues beforehand,
    which can start before the completion of the architecture phase
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈建议提前识别性能优化问题，这可以在架构阶段完成之前开始
- en: It's always better to prevent performance issues before making applications
    available to users
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向用户提供应用程序之前，最好预防性能问题
- en: Conduct various reviews and tests to avoid performance issues in production
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行各种审查和测试，以避免生产中的性能问题
- en: The performance tuning life cycle can also be done after going to production
    or when facing performance issues in the production environment
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能调优生命周期也可以在投入生产后或在生产环境中面临性能问题时进行
- en: In order to tune the performance of a Spring application, the strategies described
    in the following sections can be pretty handy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整Spring应用程序的性能，以下部分描述的策略可能非常有用。
- en: Connection pooling
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接池
- en: '**Connection pooling** is a strategy to help an application''s execution where
    *N* connections with the database are opened and overseen in a pool. The application
    just requests a connection, utilizes it, and afterward drops it back to the pool.
    At the point when the application requests a connection, the prepared connections
    are kept accessible to be utilized as part of the pool. The pool deals with the
    connection life cycle to such an extent that the developer really doesn''t have
    to sit tight for the connection and shift through the stale ones.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接池**是一种帮助应用程序执行的策略，其中打开和管理数据库的*N*个连接在池中。应用程序只需请求连接，使用它，然后将其放回池中。当应用程序请求连接时，准备好的连接保持可用以供池中使用。池管理连接的生命周期，以至于开发人员实际上不必等待连接并筛选过时的连接。'
- en: Hibernate uses its magic to identify which connection pool provider to use—based
    on the properties you configure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate利用其魔力来识别要使用的连接池提供程序 - 基于您配置的属性。
- en: 'The following is the properties configuration for the c3p0 connection pooling:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是c3p0连接池的属性配置：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the example connection pooling properties configuration for
    the Apache Commons DBCP:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Apache Commons DBCP的连接池属性配置示例：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When using either of the connection pooling mechanisms, we have to place the
    JAR dependencies in the server classpath manually or by using a dependency management
    tool such as Maven.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何连接池机制时，我们必须手动将JAR依赖项放置在服务器类路径中，或者使用Maven等依赖管理工具。
- en: It is also possible to specify the connection provider explicitly with the `hibernate.connection.provider_class` property,
    though it is not mandatory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`hibernate.connection.provider_class`属性明确指定连接提供程序，尽管这不是强制性的。
- en: 'If we do not configure a connection pool with Hibernate, the default is used. It
    is visible in the log or console output when we start the application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用Hibernate配置连接池，默认会使用。当启动应用程序时，可以在日志或控制台输出中看到：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default connection pool of Hibernate is a good option for the development
    environment, but when it comes to production, it is recommended to configure the
    pool based on the requirements and the use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate的默认连接池对于开发环境是一个不错的选择，但是在生产环境中，建议根据要求和用例配置连接池。
- en: If you are using an application server, you may wish to use the built-in pool
    (typically, a connection is obtained using the **Java Naming and Directory Interface**
    (**JNDI**)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用应用程序服务器，可能希望使用内置池（通常使用**Java命名和目录接口**（**JNDI**）获取连接）。
- en: 'To use the server''s built-in pool with Hibernate session using JNDI configuration,
    we need to set the following property in the Hibernate configuration file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用服务器的内置池与使用JNDI配置的Hibernate会话，我们需要在Hibernate配置文件中设置以下属性：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is assumed that `AB_DB` is the JNDI name of the Tomcat JDBC Connection Pool
    `DataSource`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`AB_DB`是Tomcat JDBC连接池`DataSource`的JNDI名称。
- en: 'If you cannot or do not wish to use your application server''s built-in connection
    pool, Hibernate supports several other connection pools, such as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不能或不希望使用应用程序服务器内置的连接池，Hibernate支持其他几种连接池，例如：
- en: c3p0
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c3p0
- en: Proxool
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Proxool
- en: After Apache DBCP, the second most preferred connection pool implementation
    is c3p0, which easily integrates with Hibernate, and is said to deliver good performance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache DBCP之后，第二受欢迎的连接池实现是c3p0，它可以轻松集成Hibernate，并且据说性能良好。
- en: Hibernate
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate
- en: The connection pooling mechanism ensures that the application does not run out
    of database connections when it needs one badly. Hibernate is one of the finest
    ORM frameworks for Java-based applications. When used, it must be tuned for performance
    optimization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池机制确保应用程序在需要时不会耗尽数据库连接。Hibernate是Java应用程序的最佳ORM框架之一。在使用时，必须进行性能优化。
- en: Transaction
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: Hibernate does the grimy checking just when it needs to, to keep in mind the
    execution cost. The cost increments when a specific substance has a relating table
    with an expansive number of segments. To try and limit the filthy checking cost,
    it's better we help Spring by determining an exchange to be perused, which enhances
    the execution stunningly better, wiping out the requirement for any grimy checks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate只在需要时进行脏检查，以考虑执行成本。当特定实体具有与大量列对应的表时，成本会增加。为了尽量减少脏检查成本，最好我们通过指定一个交易来帮助Spring进行读取，这将进一步提高执行效率，消除了任何脏检查的需求。
- en: 'The following is an example use of the `@Transactional` annotation, which indicates
    that the method runs within the Hibernate transaction:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`@Transactional`注解的一个示例用法，该注解表示该方法在Hibernate事务中运行：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Periodical clearing of Hibernate sessions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定期清除Hibernate会话
- en: While including/adjusting information in the database, Hibernate maintains sessions.
    In the session, it stores a form of the instances which are to be held on. If
    these instances or records are altered or modified before the session is closed,
    it is known as **filthy checking. ** Nonetheless, we can keep Hibernate from holding
    the elements in its session longer than really required. So once the requirements
    are done, we will not have to keep the instances in the session any longer. For
    this situation, we can securely flush and clear the `EntityManager` to adjust
    the condition of elements in the database and expel the instances from the session.
    This will keep the application far from memory requirements and beyond any doubt
    to affect the execution on a higher side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中包含/调整信息时，Hibernate会维护会话。在会话中，它存储了将要保存的实例的形式。如果在会话关闭之前修改了这些实例或记录，这就被称为**脏检查**。然而，我们可以让Hibernate不要在其会话中保存元素的时间比实际需要的时间长。因此，一旦需求完成，我们就不必再在会话中保存实例。在这种情况下，我们可以安全地刷新和清除`EntityManager`，以调整数据库中元素的状态并将实例从会话中移除。这将使应用程序远离内存需求，并且肯定会对执行产生积极影响。
- en: 'The following is a piece of code that can be used to `flush()` and `clear()` the
    Hibernate session:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段代码，可以用来`flush()`和`clear()` Hibernate会话：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lazy initialization
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: In case you are using Hibernate, you should take care that the `IN` statements
    are used adequately. It lazily loads the records only when it's required. When
    such custom records are loaded into memory inefficiently, every record will be
    stacked independently with separate utilization. Consequently, if there are excessively
    numerous instances loaded in memory, the same number of queries will execute consecutively,
    which may result into a major execution hit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Hibernate，您应该注意适当使用`IN`语句。它只在需要时才懒惰加载记录。当这些自定义记录被不高效地加载到内存中时，每个记录将被单独加载并单独使用。因此，如果内存中加载了太多实例，那么将依次执行许多查询，这可能导致严重的执行问题。
- en: Constructor-based HQLs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于构造函数的HQLs
- en: In typical situations, when an application is utilizing Hibernate, we don't
    try to recover the entire substance with every one of its properties despite the
    fact that we need not bother with every one of them for a specific use case. A
    solitary substance may have 30 properties, while we may only need a couple to
    be set in our feature or shown to the client. In such a case, a huge number of
    records are retrieved with the query to the database. It adds up to a significant
    load considering the unused fields sticking with the application, which will eventually
    be a gigantic execution or performance hit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，当应用程序使用Hibernate时，我们不会尝试检索整个内容及其所有属性，尽管我们不需要它们用于特定用例。一个实体可能有30个属性，而我们可能只需要其中几个在我们的功能中设置或显示给用户。在这种情况下，将使用查询从数据库中检索大量记录。考虑到未使用的字段与应用程序粘合在一起，这将最终导致巨大的执行或性能问题。
- en: To manage this, HQL/JPA gives us a select new constructor call, which is frequently
    utilized for detailing inquiries, which also enables the designer to choose collected
    esteems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，HQL/JPA为我们提供了一个select new构造函数调用，通常用于制定查询，这也使开发人员能够选择聚合值。
- en: Entity and query caching
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和查询缓存
- en: In the event that a similar inquiry is conjured each time for a specific element
    and the table information isn't subject to change for a specific availability,
    we can store the question and the elements with Hibernate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次为特定实体调用相同的查询，并且表数据对于特定可用性不会发生变化，我们可以使用Hibernate存储查询和实体。
- en: In the event that an inquiry store is connected, at that point, no resulting
    SQL articulation is sent to the database for execution. If the inquiry store or
    first-level cache cannot find the elements based on the identifier, the stored
    element identifiers are utilized to get to Hibernate's second-level store where
    comparing real elements are reserved. This highly affects the reaction time. When
    we do this, we are likewise worried about when the reserve invigorates itself.
    We can do that effortlessly with some basic setups.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用了查询缓存，那么对于执行，后续的SQL语句将不会发送到数据库。如果查询缓存或一级缓存找不到基于标识符的元素，那么将使用存储的元素标识符来访问Hibernate的二级缓存，其中存储了相应的实际元素。这对响应时间有很大影响。当我们这样做时，我们也关心缓存何时刷新自身。我们可以通过一些简单的设置轻松实现这一点。
- en: Native queries
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地查询
- en: In spite of the fact that the local inquiries have a mishap, they are the fastest
    where execution is concerned. At the point when HQL changes don't resist enhancing
    the execution of your application, local questions can essentially enhance the
    execution by around 40%.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本地查询有缺点，但在执行方面它们是最快的。当HQL更改无法改善应用程序的执行时，本地查询可以显著提高执行效率，大约提高40%。
- en: Primary key generation
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主键生成
- en: While indicating Hibernate comments into substance classes or composing `.hbm`
    documents, we should abstain from utilizing the auto key age methodology, which
    prompts a gigantic measure of succession calls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Hibernate注释指示到实体类或编写`.hbm`文件时，我们应该避免使用自动键生成方法，这会导致大量的序列调用。
- en: 'The following is an example code for defining the key generation strategy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义密钥生成策略的示例代码：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this simple change, an improvement in the range of 10-20% can be noticed in
    insert-intensive applications, with basically no code changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的改变，在插入密集型应用程序中可以注意到10-20%的改进，基本上不需要代码更改。
- en: Database
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: Once the Hibernate performance optimization life cycle is performed, the next
    step would be to perform an optimization life cycle at a database level. The following
    sections define performance improvement techniques for database components.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了Hibernate性能优化生命周期，下一步将是在数据库级别执行优化生命周期。以下部分定义了数据库组件的性能改进技术。
- en: Indexing
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: Lists become an imperative factor if the tables included in the query have a
    large number of columns. Also, it impacts when complex database queries get terminated
    by the application. The most ideal approach to get recommendations on required
    indexes is to check the query execution plan. While analyzing the SQL queries
    for indexing, we must anticipate every one of the genuine queries separately.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询涉及的表具有大量列，则列表成为一个重要因素。此外，当复杂的数据库查询被应用程序终止时，它也会产生影响。获取所需索引建议的最佳方法是检查查询执行计划。在分析用于索引的SQL查询时，我们必须分别预期每一个真实的查询。
- en: 'While working with indexes, it must be noted that:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用索引时，必须注意以下几点：
- en: Indexes might slow down inserts and updates, so apply them carefully on columns
    that are frequently updated
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引可能会减慢插入和更新，因此在经常更新的列上谨慎应用它们
- en: Indexes are meant to speed up search operations that use `WHERE` and `ORDER
    BY` clauses in the query
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引旨在加速使用查询中的`WHERE`和`ORDER BY`子句的搜索操作
- en: Views
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Database views are another procedure that we explore or think of when we are
    highly encompassed with longer execution time issues. Until SQL Server 2000, views
    were implied only for accommodation, and not speed. Later forms of SQL server
    included an uncommon component called recorded views that is said to monstrously
    expand the execution, however, ordered views must be made utilizing an arrangement
    of rules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库视图是我们在高度围绕较长的执行时间问题时探索或考虑的另一种过程。直到SQL Server 2000，视图仅用于便利，而不是速度。SQL Server的后续版本包括一个称为索引视图的特殊功能，据说可以大大提高性能，但必须使用一套规则创建索引视图。
- en: Spring Security
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security is one of the most important aspects for any application, especially
    those running over the internet. While Spring Security provides an application
    with a secure facade and prevents the application from unwanted access, it adds
    up to a lot of overhead if not managed properly. We will focus on Spring Security
    best practices in the sections to follow.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security对于任何应用程序都是最重要的方面之一，特别是那些在互联网上运行的应用程序。虽然Spring Security为应用程序提供了安全外观并防止应用程序被非法访问，但如果管理不当，它会增加很多额外负担。我们将在接下来的部分重点介绍Spring
    Security的最佳实践。
- en: Authentication cache
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证缓存
- en: Spring Security execution is one of the worries that occasionally comes into
    the picture, when the demand-handling time is seen to be on the high, and therefore
    inadmissible, side. There may be circumstances where you see that the real demand
    handling takes around 120 milliseconds, while Spring Security validation/verification
    includes another 500-600 milliseconds.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security执行是偶尔出现的担忧之一，当需求处理时间被认为过高，因此不可接受。有时你会发现真正的需求处理大约需要120毫秒，而Spring
    Security验证/验证又需要另外500-600毫秒。
- en: LDAP custom authorities
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP自定义权限
- en: This won't be the approach that you would need to consider, yet it does provide
    you with another option to enhance the execution of your Spring Security implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你需要考虑的方法，但它确实为你提供了另一种增强Spring Security实现执行的选择。
- en: In this approach, we set the user authorities with our own custom usage, as
    opposed to confirming it from LDAP. There are a few good reasons to do this, and
    the application's execution is one of them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用自己的自定义方式设置用户权限，而不是从LDAP进行确认。这样做有几个很好的理由，应用程序的执行是其中之一。
- en: Native LDAP
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地LDAP
- en: Spring Security provides us with the most standard and solid usage to LDAP verification.
    With Center Spring LDAP, the approach turns somewhat terrible, yet shows signs
    of streamlined improvements. The last approach (with Center Spring LDAP) has been
    seen to radically enhance the execution of your application when contrasted with
    that of Spring Security. This is not a preferred approach, still we can consider
    it to be one of the options for development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为我们提供了最标准和可靠的LDAP验证实现。通过中心Spring LDAP，方法变得有点糟糕，但显示出了优化改进的迹象。最后一种方法（使用中心Spring
    LDAP）被看到与Spring Security相比，极大地提高了应用程序的执行。这不是首选的方法，但我们可以考虑它作为发展的选择之一。
- en: Multithreading
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Every application nowadays is multithreaded, meaning it is capable of performing
    multiple operations at the same time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个应用程序都是多线程的，这意味着它能够同时执行多个操作。
- en: With every conceivable streamline, the single hits to your application may look
    fulfilling. Be that as it may, the heap tests with a few simultaneous hits to
    your application begin to obstruct your application's execution. In such highly
    simultaneous situations, you may need to tune up the thread defaults on the Tomcat
    server. On the off-chance that there is high simultaneousness, the HTTP asks to
    put it on hold until the point that a thread winds up to process it. In more outrageous
    cases, the hold-up lines hoist and the solicitations time out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个可能的优化，对应用程序的单次点击可能看起来令人满意。然而，在应用程序遭受多个同时点击的负载测试时，应用程序的执行开始受到阻碍。在这种高度并发的情况下，您可能需要调整Tomcat服务器上的线程默认设置。如果存在高度并发性，HTTP请求将被挂起，直到线程处理它。在更极端的情况下，等待队列会升高，请求会超时。
- en: The default server thread usage can be additionally supplemented with the use
    of agent structure inside your business rationale, to additionally make simultaneous
    non-concurrent calls from inside a strategy in a solitary string execution stream.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认服务器线程使用可以通过在业务逻辑内部使用代理结构来进一步补充，以便在单个线程执行流中进一步进行并发非同步调用。
- en: Performance tuning patterns and anti-patterns
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能调优模式和反模式
- en: Performance tuning is the change of the framework execution. Regularly in PC
    frameworks, the inspiration for such an action is known as a performance issue,
    which can be either genuine or assumed. Most frameworks will react to expanded
    load with some level of diminishing execution. A framework's capacity to acknowledge
    a higher load is called versatility, and altering a framework to deal with a higher
    load is synonymous with execution tuning.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优是改变系统执行情况。通常在计算机系统中，这样做的动机被称为性能问题，可以是真实的或假设的。大多数系统会对增加的负载做出一定程度的执行降低。系统接受更高负载的能力称为可扩展性，调整系统以处理更高负载等同于性能调优。
- en: 'The performance tuning involves the following mentioned steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优包括以下步骤：
- en: The issue should be surveyed and checked against expected numeric counts for
    satisfaction.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题应该根据预期的数字计数进行评估和检查以满足要求。
- en: Measure the execution of the framework before alteration.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前测量系统的执行情况。
- en: Distinguish the piece of the framework that is basic for enhancing the execution.
    This is known as the **bottleneck**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别系统中关键的部分以改善执行情况。这被称为**瓶颈**。
- en: Alter that piece of the framework to evacuate the bottleneck.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改系统的部分以消除瓶颈。
- en: Measure the execution of the framework after alteration.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后测量框架的执行情况。
- en: In the event that the adjustment improves the execution, receive it. In the
    event that the change aggravates the execution, set it back the way it was.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调整改善了执行情况，请接受它。如果改变恶化了执行情况，请将其恢复到原样。
- en: Anti-patterns
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: As there are patterns, there are also anti-patterns in software development.
    Patterns help to ensure the betterment of the application in terms of performance,
    scalability, and optimized processing. On the other hand, the existence of anti-patterns
    in the code indicates that challenges exist in application execution. Anti-patterns
    impact the application with a similar degree to patterns but in a negative way.
    Performance anti-patterns mostly degrade the application's performance. We are
    discussing anti-patterns because, along with following patterns and best practices,
    we have to ensure that we do not follow or use anti-patterns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与模式一样，软件开发中也存在反模式。模式有助于确保应用程序在性能、可扩展性和优化处理方面的改进。另一方面，代码中存在反模式表明应用程序执行存在挑战。反模式以与模式类似的程度影响应用程序，但是以负面方式。性能反模式大多会降低应用程序的性能。我们讨论反模式，是因为除了遵循模式和最佳实践外，我们还必须确保不遵循或使用反模式。
- en: Architectural anti-patterns
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构反模式
- en: There are many types of performance anti-patterns in architecture. The multi-layering
    anti-pattern describes an architecture that attempts to achieve high abstraction
    through as many independent, logical application layers as possible. As a developer,
    such an architecture quickly becomes recognizable by the fact that much of the
    time spent mapping and converting data is lost, and that a simple pass from the
    interface to the database is complex.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 架构中存在许多类型的性能反模式。多层反模式描述了一种试图通过尽可能多的独立的逻辑应用层来实现高抽象的架构。作为开发人员，这样的架构很快就会因为大部分时间花在映射和转换数据上而变得可识别，并且从界面到数据库的简单传递变得复杂。
- en: Such architectures usually arise because the application should be kept as flexible
    as possible so that, for example, GUIs can be exchanged easily and quickly, and
    the dependencies on other systems and components can be kept low. The decoupling
    of the layers leads to performance losses during the mapping and exchange of the
    data— especially if the layers are also physically separated and the data exchange
    takes place via remoting technologies, such as **Simple Object Access Protocol**
    (**SOAP**) or **Remote Method Invocation** (**RMI**), **Internet Inter-ORB Protocol**
    (**IIOP**).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构通常出现是因为应用程序应该尽可能灵活，以便可以轻松快速地交换GUI，并且对其他系统和组件的依赖性可以保持较低。层的解耦导致在映射和数据交换过程中出现性能损失，特别是如果层也是物理上分离的，并且数据交换通过远程技术进行，例如**简单对象访问协议**（**SOAP**）或**远程方法调用**（**RMI**），**Internet对象请求代理协议**（**IIOP**）。
- en: The many mapping and conversion operations can also result in higher garbage
    collection activity, known as the cycling object problem. As a solution to this
    anti-pattern, the architecture drivers should be scrutinized to clarify what flexibility
    and decoupling is needed. New framework approaches, such as JBoss Seam, have addressed
    the problem and try to avoid mapping data as much as possible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多映射和转换操作也可能导致更高的垃圾收集活动，这被称为循环对象问题。作为解决这种反模式的方法，应该仔细审查架构驱动程序，澄清需要什么灵活性和解耦。新的框架方法，如JBoss
    Seam，已经解决了这个问题，并尽量避免映射数据。
- en: Another architectural anti-pattern is the so-called **session cache**. In doing
    so, the web session of an application is misused as a large data cache, which
    severely limits the scalability of the application. Session sizes have often been
    measured to be well larger than 1 MB in tuning jobs—in most cases, no team member
    knows the exact content of the session. Large sessions cause the Java heap to
    be very busy and only a small number of parallel users are possible. Especially
    when clustering applications with session replication, depending on the technology
    used, the performance loss due to serialization and data transfer is very high.
    Some projects help to acquire new hardware and more memory, but in the long run,
    this is a very expensive and risky solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个架构反模式是所谓的**会话缓存**。这样做，应用程序的Web会话被误用为大型数据缓存，严重限制了应用程序的可扩展性。调整工作中经常测量到会话大小远远大于1MB，在大多数情况下，没有团队成员知道会话的确切内容。大型会话会导致Java堆非常繁忙，只能容纳少量并行用户。特别是在使用会话复制进行集群应用时，根据所使用的技术，由于序列化和数据传输而导致的性能损失非常严重。一些项目帮助获取新的硬件和更多内存，但从长远来看，这是一个非常昂贵和风险的解决方案。
- en: Session caches arise because the architecture of the application has not clearly
    defined which data is session-dependent and which is persistent, that is, recoverable
    at any time. During development, all data is quickly stored in the session, because
    this is a very convenient solution—often this data is no longer removed from the
    session. To solve this problem, you should first memory-analyze the session using
    a production heap dump and clean up the session for data that is not session-dependent.
    Caching can positively impact performance if the process of getting data is performance
    critical, for example, with database accesses. Optimally, the caching is then
    transparent to the developer within the framework. For example, Hibernate provides
    a first and second-level cache to optimize access to data, but be careful; the
    configuration and tuning of such frameworks should be done by experts, otherwise,
    you'll quickly get a new performance anti-pattern.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 会话缓存的产生是因为应用程序的架构没有清楚地定义哪些数据是会话相关的，哪些是持久的，即随时可恢复的。在开发过程中，所有数据都很快地存储在会话中，因为这是一个非常方便的解决方案——通常这些数据不再从会话中删除。要解决这个问题，首先应该使用生产堆转储对会话进行内存分析，并清理不是会话相关的数据。如果获取数据的过程对性能至关重要，例如数据库访问，缓存可以对性能产生积极影响。在最佳情况下，缓存对开发人员来说应该是透明的，嵌入在框架中。例如，Hibernate提供了一级和二级缓存来优化对数据的访问，但要小心；这些框架的配置和调优应该由专家来完成，否则你很快就会遇到新的性能反模式。
- en: Implementing anti-patterns
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施反模式
- en: There are many Java performance anti-patterns and tuning tips available, but
    the problem with these technological anti-patterns is that they are heavily dependent
    on the Java version and manufacturer, and especially on the use case. A very common
    anti-pattern is the underrated frontend. For web applications, the frontend is
    often the performance Achilles heel. HTML and JavaScript development are often
    a nuisance to real application developers and are therefore often under-optimized
    for performance. Even with the increasing use of DSL, the connection is often
    still a bottleneck, especially if it is a mobile connection via **Universal Mobile
    Telecommunications System** (**UMTS**) or **General Packet Radio Service** (**GPRS**).
    Web applications are becoming increasingly complex, driven by the Web 2.0 hype,
    and are increasingly approaching desktop applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Java性能反模式和调优技巧可用，但这些技术反模式的问题在于它们严重依赖于Java版本和制造商，特别是用例。一个非常常见的反模式是被低估的前端。对于Web应用程序，前端通常是性能的软肋。HTML和JavaScript开发经常让真正的应用程序开发人员感到困扰，因此通常对性能进行了低优化。即使在越来越多地使用DSL的情况下，连接通常仍然是一个瓶颈，特别是如果是通过**通用移动通信系统**（**UMTS**）或**通用分组无线业务**（**GPRS**）的移动连接。Web应用程序变得越来越复杂，受到Web
    2.0炒作的推动，并且越来越接近桌面应用程序。
- en: This comfort leads to extended waiting times and higher server and network load
    through many server round trips and large pages. There is a whole range of solutions
    to optimize web-based interfaces. Compressing HTML pages with GZip significantly
    reduces the amount of data transferred and has been supported by all browsers
    since HTTP 1.1\. Web servers, such as Apache, have modules (`mod_ gzip`) to perform
    the compression without changing the application. However, page sizes can also
    be reduced quickly in HTML by consistently using CSS and swapping CSS and JavaScript
    sources into your own files so that they can be better cached by the browser.
    Also, AJAX can, when correctly used, improve the performance significantly, because
    the complete reloading of web pages can be saved; for example, only the contents
    of lists are retransmitted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种便利导致了延长的等待时间和通过许多服务器往返和大页面增加了更高的服务器和网络负载。有一整套解决方案来优化基于Web的界面。使用GZip压缩HTML页面可以显著减少传输的数据量，并且自HTTP
    1.1以来所有浏览器都支持。例如，Apache等Web服务器有模块（`mod_gzip`）可以在不改变应用程序的情况下执行压缩。然而，通过一致使用CSS并将CSS和JavaScript源代码交换到自己的文件中，可以快速减小HTML页面的大小，以便浏览器更好地缓存。此外，如果正确使用，AJAX可以显著提高性能，因为可以节省完全重新加载网页的过程；例如，只重新传输列表的内容。
- en: 'But even in the analysis, the performance of the surfaces can be significantly
    improved by adapting the contents of the pages to the requirements of the user.
    For example, if only those fields that are needed 80% of the time appear on a
    page, the average transfer rate can be significantly reduced; the dropped fields
    are offloaded to separate pages. As an example, in many web applications, there
    are forms with more than 30 input fields. In 90% of the instances when users fill
    in those forms, they fill in values for only two fields but we display all these
    30 fields in the listing pages or reports, including all lists for the selection
    boxes. Another common anti-pattern is **phantom logging**, which can be found
    in almost all projects. Phantom logging generates log messages that do not actually
    have to be created in the active log level. The following code is an example of
    the problem:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使在分析中，通过将页面内容调整到用户的要求，页面的性能也可以得到显着改善。例如，如果页面上只显示80% 的时间需要的字段，平均传输速率可以显著降低；被删除的字段被卸载到单独的页面上。例如，在许多
    Web 应用程序中，有超过30个输入字段的表单。在用户填写这些表单的90% 的情况下，他们只为两个字段填写值，但我们在列表页面或报告中显示了所有这些30个字段，包括选择框的所有列表。另一个常见的反模式是**幻影日志**，几乎所有项目中都可以找到。幻影日志生成实际上不必在活动日志级别中创建的日志消息。以下代码是问题的一个例子：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although the message would not be logged in the `INFO` level, the string is
    assembled. Depending on the number and complexity of the debug and trace messages,
    this can lead to enormous performance losses, especially if objects have an over-written
    and costly `toString()` method. The solution is simple:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管消息不会在`INFO`级别中记录，但字符串被组装。根据调试和跟踪消息的数量和复杂性，这可能导致巨大的性能损失，特别是如果对象具有重写和昂贵的`toString()`方法。解决方案很简单：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the log level is first queried and the log message is only generated
    if the `DEBUG` log level is active. In order to avoid performance bottlenecks
    during development,  the used frameworks in particular should be understood correctly.
    Most commercial and open source solutions have sufficient performance documentation,
    and experts should be consulted at regular intervals to implement the solution.
    Even if profiling finds the bottleneck within a framework, it does not mean that
    the problem lies within the framework. In most cases, the problem is misuse or
    configuration.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先查询日志级别，只有在`DEBUG`日志级别处于活动状态时才生成日志消息。为了避免在开发过程中出现性能瓶颈，特别应正确理解所使用的框架。大多数商业和开源解决方案都有足够的性能文档，并且应定期咨询专家以实施解决方案。即使在分析中发现了框架中的瓶颈，也并不意味着问题出现在框架内。在大多数情况下，问题是误用或配置。
- en: The iterative performance-tuning process
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代性能调优过程
- en: The iterative performance-tuning process is a set of guidelines that will help
    improve application performance drastically. These guidelines can be applied in
    iterations until the desired output is achieved. These guidelines can also be
    applied to a variety of web applications, regardless of the technology used to
    build the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代性能调优过程是一组指南，将帮助大幅提高应用程序的性能。这些指南可以在迭代中应用，直到达到期望的输出。这些指南也可以应用于各种 Web 应用程序，无论使用何种技术构建应用程序。
- en: The first and most important part of any application is the rendering of static
    content. The delivery of static content is one of the most common performance
    bottlenecks. The static content includes images, logos, browser executable scripts,
    cascaded style sheets, and themes. As this content remains the same all the time,
    it is unnecessary to serve this content dynamically. Instead, the web server,
    such as Apache, should be configured to have a long browser cache time while serving
    static resources to the response. This improvement in static content delivery
    can significantly improve the application's overall performance. The web server
    must also be configured to compress static resources. Web accelerators can be
    used for caching a web resource. For content-driven public portals, it is highly
    recommended to cache whole pages through the web accelerator. Varnish is an open
    source web accelerator tool.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的第一个和最重要的部分是静态内容的渲染。静态内容的传递是最常见的性能瓶颈之一。静态内容包括图像、标志、浏览器可执行脚本、级联样式表和主题。由于这些内容始终保持不变，因此无需动态提供这些内容。相反，应该配置
    Web 服务器（如 Apache）在向响应提供静态资源时具有长时间的浏览器缓存时间。静态内容传递的改进可以显著提高应用程序的整体性能。Web 服务器还必须配置为压缩静态资源。可以使用
    Web 加速器来缓存 Web 资源。对于内容驱动的公共门户，强烈建议通过 Web 加速器缓存整个页面。Varnish 是一种开源的 Web 加速器工具。
- en: 'Server resource monitoring must be included as part of iterative performance
    analysis. The reason is that as the application grows, it starts occupying more
    resources at a particular instance in time. The higher demand for server resources,
    such as CPU, memory, and disk I/O, can cause it to exceed the operating system
    limits and become prone to failure. The monitoring systems must be set up in order
    to observe resource utilization. Resource monitoring usually includes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器资源监控必须作为迭代性能分析的一部分。原因是随着应用程序的增长，它开始在特定时间占用更多资源。对服务器资源的更高需求，如 CPU、内存和磁盘 I/O，可能导致超出操作系统限制并容易发生故障。监控系统必须设置以观察资源利用情况。资源监控通常包括：
- en: Web servers
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器
- en: Application servers
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器
- en: Processes—Maximum versus actual
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程-最大与实际
- en: Threads—Maximum versus actual
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程-最大与实际
- en: Memory usage
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: CPU utilization
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 利用率
- en: Heap memory as a separate measurement
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存作为单独的测量
- en: Disk I/O operations
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘 I/O 操作
- en: Database connections—Maximum versus busy
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接-最大与繁忙
- en: JVM garbage collection
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 垃圾回收
- en: Database slow queries
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库慢查询
- en: Cache
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Cache hits—Number of times the result is found from the cache
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存命中-从缓存中找到结果的次数
- en: Cache misses—Number of times the result is not found from the cache
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存未命中-未从缓存中找到结果的次数
- en: 'In order to monitor the resources, the following tools can be used:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监视资源，可以使用以下工具：
- en: '`jconsole` and `jvisualvm` come bundled with the standard **Java Development
    Kit** (**JDK**). Using these tools, we can monitor JVM, garbage collection execution,
    cache statistics, threads, CPU usage, memory usage, and database-connection pooling
    statistics.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jconsole`和`jvisualvm`与标准的**Java开发工具包**（**JDK**）捆绑在一起。使用这些工具，我们可以监视JVM、垃圾收集执行、缓存统计、线程、CPU使用率、内存使用率和数据库连接池统计。'
- en: '`mpstat` and `vmstat` are available on Linux-based operating systems. Both
    of these are command-line tools and are used for collecting and reporting processor-related
    statistics.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mpstat`和`vmstat`在基于Linux的操作系统上可用。这两者都是命令行工具，用于收集和报告与处理器相关的统计信息。'
- en: '`ifstat` and `iostat` are useful for monitoring system input/output operations.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifstat`和`iostat`对于监视系统的输入/输出操作很有用。'
- en: 'There might be a question on why we should do this iterative performance tuning
    process while we follow best practices. The goals of the iterative performance
    tuning process are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一个问题，为什么我们要在遵循最佳实践的同时进行这个迭代的性能调优过程。迭代性能调优过程的目标如下：
- en: Identify bottlenecks in the system's performance at various levels
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各个级别识别系统性能瓶颈
- en: Improve the performance of the portal as per the expectations
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据期望改善门户的性能
- en: Find the solution and approach
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到解决方案和方法
- en: Put the solution workflow in place
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将解决方案工作流程放在适当的位置
- en: Understand the performance pain areas of the system
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解系统性能的痛点
- en: Define the performance strategy for the application
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序定义性能策略
- en: Identify the performance measurement tool based on the technologies
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据技术选择性能测量工具
- en: Understand application key user scenarios
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用程序的关键用户场景
- en: Document key scenarios
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录关键场景
- en: Prepare sufficient data to generate considerable distributed load on all flavors
    in a single execution
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备足够的数据，在单次执行中对所有风味产生可观的分布式负载
- en: Customize and combine load testing scripts to prepare a performance test suite
    that can be used for execution on any single flavor or on all flavors at a time
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制和组合负载测试脚本，以准备可用于任何单个风味或同时用于所有风味的性能测试套件
- en: Execute performance scripts with different scenarios and load combinations to
    identify bottlenecks using response times
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同场景和负载组合执行性能脚本，以识别响应时间的瓶颈
- en: 'The iterative performance tuning process is followed at all stages of the application
    development life cycle. The following table demonstrates the items being reviewed
    with input and output expectations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代性能调优过程在应用程序开发生命周期的所有阶段都得到遵循。以下表格演示了正在审查的项目以及输入和输出期望：
- en: '| **Review item** | **Input** | **Output** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **审查项目** | **输入** | **输出** |'
- en: '| Architecture'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '| 架构'
- en: High availability
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: Scalability
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Caching
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Integration
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成
- en: Network
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Search Engine
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎
- en: Database
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: '| System architecture diagram | Recommendations on best practices |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 系统架构图 | 最佳实践建议 |'
- en: '| User interface |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 用户界面 |'
- en: Frontend code
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端代码
- en: Existing technology selection criteria
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有技术选择标准
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Review of the code
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Recommendations for the change
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改建议
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Hardware configuration |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 硬件配置 |'
- en: Web server details
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器细节
- en: App server details
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器细节
- en: Database details
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库细节
- en: Server type (Virtual or Physical)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器类型（虚拟或物理）
- en: Number of CPU
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU数量
- en: Hard disk space
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘空间
- en: Memory configuration
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存配置
- en: '| Changes recommended in hardware configuration |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 建议在硬件配置中进行的更改 |'
- en: '| Software configuration |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 软件配置 |'
- en: Framework configuration
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架配置
- en: Dependent modules/integrations configuration, if any
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖模块/集成配置，如果有的话
- en: '| Recommendations on configuration change |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 配置更改建议 |'
- en: '| Application server configuration |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 应用服务器配置 |'
- en: App server configuration files
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器配置文件
- en: '| Recommendations on configuration change |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 配置更改建议 |'
- en: '| Web server configuration |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| Web服务器配置 |'
- en: Web server configuration files
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器配置文件
- en: Cache control settings
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存控制设置
- en: Static resource-handling settings
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态资源处理设置
- en: '| Recommendations on configuration change |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 配置更改建议 |'
- en: '| Deployment architecture |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 部署架构 |'
- en: Deployment diagram
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署图
- en: Software installation details
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件安装细节
- en: Configuration details
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置细节
- en: '| Recommendation on deployment architecture changes |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 部署架构更改建议 |'
- en: '| Code and database |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 代码和数据库 |'
- en: Code review
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: DB design review
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计审查
- en: Code duplication
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重复
- en: Modularization of code
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码模块化
- en: Any third-party libraries/APIs
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何第三方库/ API
- en: Coding standard implemented
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施的编码标准
- en: Loops and conditions
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环和条件
- en: Data normalization
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据规范化
- en: Indexing
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Long-running queries
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的查询
- en: Relations between tables
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表之间的关系
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Code review results
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查结果
- en: Recommendations for improvement
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进建议
- en: '|'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Spring support of JMX
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring对JMX的支持
- en: JMX is the standard component in the Java platform. It was first released in
    J2SE 5.0\. Basically, JMX is a set of specifications defined for application and
    network management. It empowers developers to assign management attributes to
    the Java objects used in the applications. By assigning management attributes,
    it makes the Java objects capable of working with network management software
    in use. It provides a standard way for developers to manage applications, devices,
    and services.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: JMX是Java平台中的标准组件。它首次发布于J2SE 5.0。基本上，JMX是为应用程序和网络管理定义的一组规范。它使开发人员能够为应用程序中使用的Java对象分配管理属性。通过分配管理属性，它使Java对象能够与正在使用的网络管理软件一起工作。它为开发人员提供了一种标准的方式来管理应用程序、设备和服务。
- en: 'JMX has a three-layer architecture. The three layers are defined here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: JMX具有三层架构。这三层在这里定义：
- en: '**The probe or instrumentation layer**: This layer contains managed beans.
    The application resources to be managed are enabled for JMX.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探针或仪表层**：此层包含托管的bean。要管理的应用程序资源已启用JMX。'
- en: '**The agent or MBeanServer layer**: This layer forms the core of the JMX. It
    works as an intermediary between managed beans and the application.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理或MBeanServer层**：这一层构成了JMX的核心。它作为托管bean和应用程序之间的中介。'
- en: '**The remote management layer**: This layer enables the remote applications
    to connect to and access `MBeanServer` using connectors or adapters. The connector
    provides full access to `mBeanServer` whereas an adapter adapts the API.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程管理层**：此层使远程应用程序能够使用连接器或适配器连接到和访问`MBeanServer`。连接器提供对`mBeanServer`的完全访问权限，而适配器则适应API。'
- en: 'The following diagram shows the architecture of JMX:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了JMX的架构：
- en: '![](img/f6d6ebb6-fe47-46b9-b712-2de301215c30.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6d6ebb6-fe47-46b9-b712-2de301215c30.png)'
- en: Source: https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.5.5/com.ibm.websphere.nd.multiplatform.doc/ae/cxml_javamanagementx.html
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.5.5/com.ibm.websphere.nd.multiplatform.doc/ae/cxml_javamanagementx.html
- en: Managed beans
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管bean
- en: The managed bean is a type of Java bean. It is used specifically in JMX technology
    and it is created using the **dependency injection** (**DI**) technique. In JMX,
    a resource is represented as a **managed bean** (**MBean**). These managed beans
    are registered with a core managed beans server. So, a managed bean can be visualized
    as a wrapper around Java services, components, or devices. As all the managed
    components are registered with the MBeans server, it is used for managing all
    of the managed beans. The managed beans server allows server components to wire
    in and find managed beans. A typical JMX agent consists of a managed beans server
    and services required to interact with managed beans.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 托管bean是一种Java bean。它专门用于JMX技术，并且是使用**依赖注入**（**DI**）技术创建的。在JMX中，资源被表示为**托管bean**（**MBean**）。这些托管bean被注册到核心托管bean服务器中。因此，托管bean可以被视为Java服务、组件或设备的包装器。由于所有托管组件都注册到MBeans服务器，因此它用于管理所有托管bean。托管bean服务器允许服务器组件连接并找到托管bean。典型的JMX代理由托管bean服务器和与托管bean交互所需的服务组成。
- en: The JMX specification describes standard connectors. These connectors are also
    known as **JMX connectors**. JMX connectors allow us to access JMX agents from
    remote management applications. The connectors can use different protocols to
    work with the same management interface.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: JMX规范描述了标准连接器。这些连接器也被称为**JMX连接器**。JMX连接器允许我们从远程管理应用程序访问JMX代理。连接器可以使用不同的协议与相同的管理接口一起工作。
- en: 'The following are the reasons why JMX should be used:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为什么应该使用JMX的原因：
- en: It provides a way to manage applications on different devices
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种在不同设备上管理应用程序的方法
- en: It provides a standard way to manage Java applications and networks
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种标准的管理Java应用程序和网络的方法
- en: It can be used to manage JVM
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用来管理JVM
- en: It provides a scalable and dynamic management interface
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个可扩展和动态的管理接口
- en: With the basic understanding of JMX, let's move on to check how it is supported
    in Spring. The JMX support for Spring enables us to transform the spring application
    into JMX architecture quite easily.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对JMX的基本理解，让我们继续检查它在Spring中的支持。Spring对JMX的支持使我们能够很容易地将Spring应用程序转换为JMX架构。
- en: 'The following are the features provided by Spring''s JMX support:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的JMX支持提供的功能如下：
- en: Automatic registration of a Spring bean as a managed bean
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动将Spring bean注册为托管bean
- en: A flexible structure for controlling the management interface for Spring beans
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于控制Spring beans的管理接口的灵活结构
- en: A declarative approach for managed beans over remote connectors
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程连接器上托管bean的声明性方法
- en: Proxying of local and remote managed bean resources
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地和远程托管bean资源的代理
- en: These features work without coupling with either of Spring or JMX's classes
    or interfaces. Spring JMX support has a class called `MBeanExporter`. This class
    is responsible for collecting Spring beans and registering them with the managed
    beans server.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能可以在不与Spring或JMX的类或接口耦合的情况下工作。Spring JMX支持有一个名为`MBeanExporter`的类。这个类负责收集Spring
    beans并将它们注册到托管的beans服务器中。
- en: 'The following is an example of a Spring bean:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring bean的示例：
- en: '[PRE9]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to expose this bean and its properties as managed attributes and operations,
    the following configurations should be done in the configuration file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此bean及其属性公开为托管属性和操作，应在配置文件中进行以下配置：
- en: '[PRE10]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An important bean definition, from the preceding configuration, to look for
    is the exporter bean. The beans map property of the exporter bean indicates the
    Spring beans to be exposed as JMX beans to the JMX-managed beans server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，要查找的一个重要的bean定义是导出器bean。导出器bean的beans map属性指示要将哪些Spring beans暴露为JMX
    beans到JMX托管的beans服务器。
- en: With the preceding configuration, it is assumed that the managed beans server
    must be running in the environment accessible to the Spring application. If the
    managed beans server or `MBeanServer` is running, Spring will attempt to find
    it and register all the beans. This default behavior is useful when the application
    is running inside Tomcat or IBM WebSphere that has a bundled `MBeanServer`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述配置，假设托管bean服务器必须在Spring应用程序可访问的环境中运行。如果托管bean服务器或`MBeanServer`正在运行，Spring将尝试找到它并注册所有bean。当应用程序在Tomcat或IBM
    WebSphere中运行时，这种默认行为是有用的，因为它有捆绑的`MBeanServer`。
- en: 'In other cases, we have to create an `MBeanServer` instance, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们必须创建一个`MBeanServer`实例，如下所示：
- en: '[PRE11]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have to specify the server property on the `MBeanExporter` bean to associate
    it with the `MBeanServer` that has been created.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`MBeanExporter` bean上指定server属性，以将其与已创建的`MBeanServer`关联起来。
- en: With the inception of annotations in JDK 5.0, Spring enabled the provision for
    setting annotations to register Spring beans as JMX beans.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JDK 5.0中注解的引入，Spring使得可以使用注解将Spring beans注册为JMX beans。
- en: 'The following is an example `Calculator` bean defined using the `@ManagedResource`
    annotation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`@ManagedResource`注解定义的`Calculator` bean的示例：
- en: '[PRE12]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@ManagedAttribute` and `@ManagedOperation` annotations are used to expose
    the bean properties and methods to manage the beans server.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ManagedAttribute`和`@ManagedOperation`注解用于将bean的属性和方法暴露给管理bean服务器。'
- en: 'The following is the client code that instantiates the managed beans, which
    can be monitored by tools such as JConsole or VisualVM:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实例化受管bean的客户端代码，可以通过诸如JConsole或VisualVM之类的工具进行监视：
- en: '[PRE13]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once exposed as managed beans, these resources can be monitored for various
    parameters, such as the number of objects, memory occupied by the objects, and
    heap memory space occupied by the objects, using tools such as JConsole or VisualVM.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦暴露为受管bean，这些资源可以通过诸如JConsole或VisualVM之类的工具监视各种参数，例如对象数量、对象占用的内存以及对象占用的堆内存空间。
- en: 'The following is a screenshot from Java VisualVM highlighting the exposure
    of the `Calculator` as a managed bean:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java VisualVM的屏幕截图，突出显示了`Calculator`作为受管bean的暴露：
- en: '![](img/ba6700e0-0402-417d-a4ae-1bdb5413c631.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba6700e0-0402-417d-a4ae-1bdb5413c631.jpg)'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This is one of the most important chapters in this book. It solely focuses on
    performance measurement and enhancement strategies. This chapter resembles a real-life
    health checkup scenario. If a person is unwell, the first step is to identify
    the symptoms in order to identify and cure the disease. Similarly, this chapter
    started by identifying the symptoms of performance degradation, moving on to the
    performance tuning life cycle. Performance tuning patterns and anti-patterns were
    described, which resemble the best practices to be followed. This was followed
    by the iterative performance tuning process and JMX support in the Spring framework.
    We saw an example of Spring beans turned into JMX-managed beans.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中最重要的章节之一。它专注于性能测量和增强策略。本章类似于现实生活中的健康检查场景。如果一个人不舒服，第一步是识别症状以便诊断和治疗疾病。同样，本章从识别性能下降的症状开始，然后进入性能调优生命周期。描述了性能调优模式和反模式，类似于应遵循的最佳实践。接着是迭代性能调优过程和Spring框架中的JMX支持。我们看到了Spring
    bean被转换为JMX受管bean的示例。
- en: The next chapter focuses on fine-tuning the JVM. This will not be tuning that
    is specific to a Spring application, but is applicable to any application running
    on JVM. This chapter will do a deep dive into the inside details of JVM, which
    are not very well-known to developers. Let's get ready to dive into JVM.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章重点介绍JVM的微调。这不是针对Spring应用程序特定的调整，而是适用于在JVM上运行的任何应用程序。本章将深入探讨JVM的内部细节，这些细节对开发人员来说并不是很熟悉。让我们准备好深入JVM。
