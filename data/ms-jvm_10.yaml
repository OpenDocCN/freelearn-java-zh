- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: GraalVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraalVM
- en: In the ever-evolving landscape of JVMs, GraalVM stands out as a revolutionary
    and versatile alternative. This chapter delves into the intricacies of GraalVM,
    unraveling its unique features and shedding light on its role as a game-changer
    in the realm of JVM internals. GraalVM, developed by Oracle Labs, transcends the
    traditional boundaries of a conventional JVM by providing a polyglot runtime that
    supports multiple languages, including Java, JavaScript, Python, Ruby, and more.
    This flexibility opens up new avenues for developers, allowing them to integrate
    different languages within a single application seamlessly. As we navigate the
    pages of this chapter, you’ll gain a comprehensive understanding of GraalVM’s
    architecture, its distinctive components, and its pivotal role in reshaping the
    landscape of Java development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 的不断演变中，GraalVM 作为一种革命性和多功能的替代品脱颖而出。本章深入探讨了 GraalVM 的复杂性，揭示了其独特的特性，并阐明了其在
    JVM 内部世界中的颠覆性角色。由 Oracle Labs 开发的 GraalVM 超越了传统 JVM 的传统边界，提供了一种多语言运行时，支持包括 Java、JavaScript、Python、Ruby
    等多种语言。这种灵活性为开发者开辟了新的途径，使他们能够在一个应用程序中无缝集成不同的语言。随着我们翻阅本章的页面，你将全面了解 GraalVM 的架构、其独特的组件以及它在重塑
    Java 开发格局中的关键作用。
- en: GraalVM’s architecture is a testament not only to its engineering prowess but
    also to its commitment to performance and efficiency. The chapter not only explores
    the underlying architecture and components of GraalVM but also highlights its
    innovative JIT compiler, which is at the heart of its efficiency. Understanding
    the nuts and bolts of GraalVM’s architecture is essential for developers looking
    to harness its power to optimize and enhance the performance of their applications.
    Additionally, we’ll delve into real-world use cases, showcasing scenarios where
    GraalVM excels and the unique problems it addresses. Whether you’re aiming to
    boost the execution speed of your Java applications or seeking a seamless integration
    of multiple languages, GraalVM emerges as a compelling solution, and this chapter
    will guide you through its capabilities and potential applications. Get ready
    to explore the cutting-edge features of GraalVM and unlock a new dimension of
    possibilities in the ever-evolving landscape of JVM internals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 的架构不仅是对其工程实力的证明，也是其对性能和效率承诺的体现。本章不仅探讨了 GraalVM 的底层架构和组件，还突出了其创新的即时编译器（JIT
    compiler），这是其效率的核心。理解 GraalVM 架构的细节对于希望利用其力量优化和提升应用程序性能的开发者至关重要。此外，我们还将深入研究实际应用案例，展示
    GraalVM 在哪些场景中表现出色以及它解决的独特问题。无论你是希望提高 Java 应用程序的执行速度，还是寻求多语言的无缝集成，GraalVM 都是一个引人注目的解决方案，本章将引导你了解其功能和潜在应用。准备好探索
    GraalVM 的前沿特性，并在不断发展的 JVM 内部世界中发现新的可能性维度。
- en: 'In this chapter, we’ll explore the topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: GraalVM overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 概述
- en: Native Image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生镜像（Native Image）
- en: Creating a Native Image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原生镜像
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下要求：
- en: GraalVM 21
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 21
- en: Git
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的集成开发环境（IDE）
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07)
- en: GraalVM overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraalVM 概述
- en: In this enlightening section, we’ll embark on a journey through the groundbreaking
    landscape of GraalVM, an innovation that has redefined the expectations of a JVM.
    GraalVM’s rise to prominence can be attributed to its sensational features, with
    a special emphasis on its high-performance compiler, **ahead-of-time** (**AOT**)
    compilation, and prowess in managing diverse language runtimes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启发性的部分，我们将踏上探索 GraalVM 创新领域的开创性旅程，这一创新重新定义了 JVM 的期望。GraalVM 的崛起归功于其令人惊叹的特性，特别强调其高性能编译器、**即时编译**（AOT）和在不同语言运行时管理方面的能力。
- en: At the heart of GraalVM’s exceptional performance lies its state-of-the-art
    JIT compiler. This compiler is meticulously engineered to optimize the execution
    of Java applications, pushing the boundaries of speed and efficiency. Unlike traditional
    JVMs, GraalVM’s JIT compiler boasts advanced techniques and optimizations, resulting
    in faster startup times and reduced memory footprint. Therefore, developers experience
    a significant boost in the overall performance of their applications, making GraalVM
    an invaluable tool for those striving for excellence in execution speed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM卓越性能的核心是其最先进的JIT编译器。这个编译器经过精心设计，以优化Java应用程序的执行，推动速度和效率的极限。与传统JVM不同，GraalVM的JIT编译器拥有先进的技巧和优化，从而实现了更快的启动时间和更小的内存占用。因此，开发者可以体验到应用程序整体性能的显著提升，使GraalVM成为追求执行速度卓越的宝贵工具。
- en: GraalVM introduces a paradigm shift with its AOT compilation, enabling developers
    to pre-compile their programs into native machine code. This approach eliminates
    the need for JIT compilation during runtime, resulting in faster startup times
    and lower memory consumption. AOT compilation opens up new horizons for GraalVM,
    making it an ideal choice for scenarios where rapid startup and reduced latency
    are critical. This section will explore the intricacies of AOT compilation and
    guide you on harnessing its power to optimize your applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM通过其AOT编译引入了一种范式转变，使开发者能够将他们的程序预编译成原生机器代码。这种方法消除了运行时JIT编译的需求，从而实现了更快的启动时间和更低的内存消耗。AOT编译为GraalVM开辟了新的天地，使其成为快速启动和降低延迟至关重要的场景的理想选择。本节将探讨AOT编译的复杂性，并指导您如何利用其力量来优化您的应用程序。
- en: GraalVM transcends the confines of a traditional JVM by offering a multilingual
    runtime environment. This means developers can seamlessly integrate and execute
    programs written in multiple languages within the same application. From Java
    and JavaScript to Python, Ruby, and more, GraalVM supports various languages,
    fostering a polyglot ecosystem. This section will delve into the implications
    of polyglot capabilities, demonstrating how developers can leverage this feature
    to build versatile and efficient applications that transcend language barriers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM通过提供多语言运行环境超越了传统JVM的局限。这意味着开发者可以在同一应用程序中无缝集成和执行用多种语言编写的程序。从Java和JavaScript到Python、Ruby等，GraalVM支持各种语言，培育了一个多语言生态系统。本节将深入探讨多语言能力的含义，展示开发者如何利用这一特性构建超越语言障碍的灵活和高效的应用程序。
- en: While GraalVM brings many innovative features, like any technology, it comes
    with trade-offs. This section aims to shed light on these considerations, helping
    developers make informed decisions on when and where to harness the power of GraalVM.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GraalVM 带来了许多创新特性，但任何技术都有其权衡之处。本节旨在阐明这些考虑因素，帮助开发者做出明智的决定，了解何时何地利用 GraalVM
    的力量。
- en: 'While balancing benefits such as enhanced runtime and polyglot capabilities,
    developers must also consider factors like increased memory usage, longer compilation
    times, and compatibility nuances. Exploring these trade-offs will empower developers
    to make informed decisions tailored to their project requirements. Understanding
    these intricacies enables a strategic application of GraalVM’s strengths while
    mitigating potential challenges in specific use cases:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在平衡增强的运行时和多语言能力等好处的同时，开发者还必须考虑增加的内存使用量、更长的编译时间和兼容性细节等因素。探讨这些权衡将使开发者能够根据项目需求做出明智的决定。了解这些复杂性能够战略性地应用
    GraalVM 的优势，同时减轻特定用例中可能遇到的潜在挑战。
- en: '**Memory overhead**: A slight increase in memory usage often accompanies GraalVM’s
    impressive performance gains. The advanced optimizations and versatile language
    support contribute to a more substantial memory footprint than some traditional
    JVMs. Developers must weigh the performance benefits against the potential impact
    on memory resources, particularly in environments with stringent memory constraints.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：随着GraalVM令人印象深刻的性能提升，内存使用量略有增加。高级优化和灵活的语言支持导致内存占用比一些传统JVM更大。开发者必须权衡性能优势与对内存资源的潜在影响，特别是在内存约束严格的环境中。'
- en: '**Compilation time**: While GraalVM’s JIT compiler is a powerhouse for runtime
    performance, it’s worth noting that the initial compilation time may be longer
    compared to other JVMs. Developers working on short-lived applications or scenarios
    where quick startup is critical should carefully assess whether the benefits of
    runtime performance outweigh the longer compilation times during application initialization.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时间**：虽然GraalVM的JIT编译器在运行时性能方面是一大优势，但值得注意的是，与其它JVM相比，初始编译时间可能会更长。对于开发短期应用或在快速启动至关重要的场景中工作的开发者，应仔细评估运行时性能的好处是否超过了在应用程序初始化期间较长的编译时间。'
- en: '**Compatibility**: While GraalVM supports a wide array of languages, certain
    language features or libraries might not be fully compatible. Developers need
    to consider their projects’ specific language requirements and ensure that GraalVM
    provides adequate support. Compatibility issues may require additional effort
    in adapting or optimizing code to work seamlessly with GraalVM.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：虽然GraalVM支持多种语言，但某些语言特性或库可能不完全兼容。开发者需要考虑他们项目的具体语言需求，并确保GraalVM提供足够的支持。兼容性问题可能需要额外的努力来调整或优化代码，以便与GraalVM无缝工作。'
- en: 'Identifying the optimal scenarios for leveraging GraalVM’s strengths requires
    a targeted assessment of best use cases. In microservices and serverless architectures,
    GraalVM’s superior performance and reduced memory footprint align seamlessly with
    the agility demands of these environments. Its polyglot capabilities make it ideal
    for projects involving multiple languages, fostering a cohesive runtime environment.
    High-performance computing applications benefit from GraalVM’s advanced JIT compilation,
    accelerating computation-intensive tasks. Additionally, resource-intensive applications
    in cloud environments can capitalize on GraalVM’s efficiency in resource utilization
    without compromising performance. Developers can strategically employ GraalVM
    to maximize its advantages in diverse application scenarios by pinpointing these
    use cases:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确定利用GraalVM优势的最佳场景需要对最佳用例进行有针对性的评估。在微服务和无服务器架构中，GraalVM卓越的性能和减少的内存占用与这些环境的敏捷性需求无缝对接。其多语言能力使其成为涉及多种语言的项目的理想选择，促进了一个统一的运行时环境。高性能计算应用得益于GraalVM的高级JIT编译，加速了计算密集型任务。此外，云环境中的资源密集型应用可以利用GraalVM在资源利用效率上的优势，而不会影响性能。开发者可以通过确定这些用例，有策略地利用GraalVM在多样化的应用场景中的优势，以最大化其优势：
- en: '**Microservices and serverless architectures**: GraalVM’s impressive performance
    gains and reduced memory footprint make it well-suited for microservices and serverless
    architectures. The faster startup times and efficient resource utilization align
    with the demands of these environments where agility and responsiveness are paramount.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务和无服务器架构**：GraalVM令人印象深刻的性能提升和减少的内存占用使其非常适合微服务和无服务器架构。更快的启动时间和高效的资源利用与这些环境中敏捷性和响应性的需求相吻合。'
- en: '**Polyglot applications**: The polyglot capabilities of GraalVM shine in scenarios
    where applications are built using multiple programming languages. If your project
    involves components written in Java, JavaScript, Python, Ruby, and more, GraalVM’s
    ability to seamlessly integrate these languages within a single runtime environment
    becomes a decisive advantage.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言应用**：GraalVM的多语言能力在应用使用多种编程语言构建的场景中尤为突出。如果你的项目涉及用Java、JavaScript、Python、Ruby等多种语言编写的组件，GraalVM在单个运行时环境中无缝集成这些语言的能力成为决定性的优势。'
- en: '**High-performance computing**: Applications with a focus on high-performance
    computing, such as scientific simulations or data processing, can benefit from
    GraalVM’s advanced JIT compilation. The enhanced runtime performance can significantly
    accelerate computation-intensive tasks.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能计算**：专注于高性能计算的应用，如科学模拟或数据处理，可以从GraalVM的高级即时编译（JIT）中受益。增强的运行时性能可以显著加速计算密集型任务。'
- en: '**Resource-intensive applications**: GraalVM’s efficiency in resource utilization
    makes it an excellent choice for resource-intensive applications, particularly
    in cloud-based environments. Developers can leverage GraalVM to optimize resource
    consumption without compromising on performance.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源密集型应用**：GraalVM在资源利用效率上的优势使其成为资源密集型应用的绝佳选择，尤其是在基于云的环境下。开发者可以利用GraalVM优化资源消耗，同时不牺牲性能。'
- en: In conclusion, GraalVM presents a compelling option for various scenarios, especially
    where the trade-offs align with the project’s priorities and constraints. By carefully
    evaluating the application’s specific needs, developers can harness the full potential
    of GraalVM in scenarios where its strengths shine the brightest.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，GraalVM在各种场景下提供了一个有吸引力的选择，尤其是在权衡与项目的优先级和限制相一致的情况下。通过仔细评估应用程序的具体需求，开发者可以在其优势最耀眼的情况下充分利用GraalVM的潜力。
- en: As we conclude our exploration of GraalVM and its nuanced considerations, it
    becomes evident that this innovative JVM alternative is a force to be reckoned
    with in the ever-evolving landscape of Java development. From its high-performance
    JIT compiler to polyglot language runtimes, GraalVM offers a compelling set of
    features that can elevate application development to new heights. While we’ve
    discussed the trade-offs involved, it’s crucial to recognize that these considerations
    are integral to making informed decisions in line with specific project requirements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对GraalVM及其细微考量的探索时，一个明显的结论是，这个创新的JVM替代品在Java开发的不断演变格局中是一个不容忽视的力量。从其高性能JIT编译器到多语言语言运行时，GraalVM提供了一套引人入胜的功能，可以将应用程序开发提升到新的高度。虽然我们已经讨论了涉及的权衡，但认识到这些考虑是符合特定项目要求做出明智决策的必要组成部分。
- en: Moreover, our journey through GraalVM’s best use cases has unveiled scenarios
    where its strengths shine brightest, from microservices architectures to resource-intensive
    cloud applications. However, the story doesn’t end here. GraalVM’s Native Image
    functionality takes the narrative further by allowing developers to compile applications
    ahead of time into standalone executables, completely sidestepping the need for
    a JVM during deployment. It sets the stage for a deeper dive into Native Image,
    where GraalVM’s capabilities are extended to provide an even more streamlined,
    efficient, and resource-friendly approach to application deployment. As we unravel
    the possibilities unlocked by GraalVM’s Native Image, reshaping the landscape
    of Java development with unparalleled efficiency and innovation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过GraalVM的最佳用例之旅，揭示了其优势最耀眼的应用场景，从微服务架构到资源密集型云应用。然而，故事还没有结束。通过允许开发者提前将应用程序编译成独立的可执行文件，完全绕过部署时对JVM的需求，GraalVM的本地图像功能将叙事进一步推进。它为深入探讨本地图像奠定了基础，其中GraalVM的能力得到扩展，提供了一种更加流畅、高效和资源友好的应用程序部署方法。随着我们揭开GraalVM本地图像释放的可能性，我们正在用无与伦比的效率和创新能力重塑Java开发格局。
- en: Native Image
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地图像
- en: Welcome to an illuminating session dedicated to GraalVM, a game-changing technology
    that transcends the conventional boundaries of JVMs. Developed by Oracle Labs,
    GraalVM emerges as a multifaceted solution, introducing revolutionary features
    that redefine the application development landscape. This section serves as your
    gateway to understanding the key facets of GraalVM, from its high-performance
    JIT compiler to its polyglot language runtimes and innovative AOT compilation.
    As we delve into GraalVM’s architecture and capabilities, you’ll gain insights
    into how it addresses the evolving needs of modern applications. Join us on this
    exploration of GraalVM, where innovation meets versatility, and discover how it
    empowers developers to create efficient, polyglot applications that push the boundaries
    of what’s possible in the Java ecosystem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎参加一个专注于GraalVM的启发式研讨会，这是一项颠覆传统JVM边界的变革性技术。由Oracle Labs开发，GraalVM作为一个多面手解决方案出现，引入了重新定义应用程序开发格局的革命性功能。本节是您了解GraalVM关键方面的入门，从其高性能JIT编译器到多语言语言运行时和创新的AOT编译。随着我们深入探讨GraalVM的架构和能力，您将了解它是如何满足现代应用程序不断变化的需求的。加入我们的GraalVM探索之旅，在这里创新与多功能性相遇，发现它是如何赋予开发者创建高效、多语言应用程序的能力，这些应用程序将Java生态系统的可能性推向了新的高度。
- en: One of the most distinctive features of GraalVM is its Native Image functionality,
    a transformative capability that propels application deployment into a new era.
    Unlike traditional Java applications running on a JVM, GraalVM’s Native Image
    empowers developers to compile their applications ahead of time into standalone
    executables. Instead of relying on a JVM during deployment, the application is
    packaged as a self-contained binary directly interacting with the operating system,
    bypassing the need for an intermediary virtual machine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM最显著的特点之一是其原生图像功能，这是一种变革性的能力，将应用程序部署推进到一个新时代。与在JVM上运行的常规Java应用程序不同，GraalVM的原生图像功能使开发者能够在部署前将应用程序编译成独立的可执行文件。在部署期间，应用程序被打包成一个自包含的二进制文件，直接与操作系统交互，绕过了需要中间虚拟机的需求。
- en: The key advantage of the Native Image approach lies in its efficiency gains
    during both startup time and runtime performance. By eliminating the need for
    a JVM to interpret and execute the code, Native Image significantly reduces the
    application’s startup time, making it ideal for scenarios where rapid responsiveness
    is crucial. Moreover, the absence of a JVM reduces the application’s memory footprint,
    enhancing resource utilization and making it more suitable for resource-constrained
    environments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原生图像方法的关键优势在于其在启动时间和运行时性能方面的效率提升。通过消除JVM解释和执行代码的需求，原生图像显著减少了应用程序的启动时间，使其在快速响应至关重要的场景中变得理想。此外，没有JVM的存在减少了应用程序的内存占用，提高了资源利用率，使其更适合资源受限的环境。
- en: 'However, it should also be highlighted that AOT compilation removes the exact
    benefits of JIT compilation as the bytecode is no longer available at runtime
    to optimize the code concerning changing code behavior. In many cases where applications
    run for a longer time, the gain of a quick startup, while notable, may be partially
    offset because the overall performance is lower due to the absence of dynamic
    runtime optimizations. For a detailed exploration of this trade-off between AOT
    and JIT, you can refer to this insightful presentation: [https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/](https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也应强调，AOT编译消除了JIT编译的精确好处，因为字节码在运行时不再可用，无法根据代码行为的变化来优化代码。在许多应用程序运行时间较长的案例中，快速启动的收益虽然显著，但可能部分被抵消，因为整体性能由于缺乏动态运行时优化而降低。关于AOT和JIT之间这种权衡的详细探讨，您可以参考这篇有洞察力的演示：[https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/](https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/)。
- en: 'While GraalVM’s Native Image feature brings notable advantages in terms of
    startup time, memory efficiency, and resource utilization, it also comes with
    trade-offs that developers should carefully consider:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GraalVM 的原生图像功能在启动时间、内存效率和资源利用率方面带来了显著的优势，但它也带来了开发者应仔细考虑的权衡：
- en: '**Build time and complexity**: Creating a Native Image involves AOT compilation,
    which occurs during the build phase. This compilation process is more time-consuming
    compared to traditional JIT compilation used in JVM-based applications. Additionally,
    configuring the Native Image build can be more intricate, requiring developers
    to manage native libraries, reflective access, and other considerations to achieve
    optimal results.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时间和复杂性**：创建原生图像涉及AOT编译，这发生在构建阶段。与在基于JVM的应用程序中使用的传统JIT编译相比，这个过程更加耗时。此外，配置原生图像构建可能更加复杂，需要开发者管理本地库、反射访问和其他考虑因素，以实现最佳结果。'
- en: '**Dynamic class loading and reflection**: Native Image requires a static analysis
    of the application’s code during compilation, which can pose challenges for applications
    that heavily rely on dynamic class loading or reflection. Since the Native Image
    compiler needs to know the complete set of classes and methods at build time,
    dynamically loaded or generated code may need special handling, potentially requiring
    adjustments to the application code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态类加载和反射**：原生图像在编译期间需要对应用程序的代码进行静态分析，这可能给那些高度依赖动态类加载或反射的应用程序带来挑战。由于原生图像编译器需要在构建时知道完整的类和方法集，因此动态加载或生成的代码可能需要特殊处理，可能需要调整应用程序代码。'
- en: '**Limited runtime profile**: AOT compilation necessitates a comprehensive understanding
    of the application’s behavior during the build phase. It can be challenging for
    applications with complex runtime behaviors or those dynamically adapting to various
    scenarios. In such cases, the Native Image may not capture the complete runtime
    profile, leading to potential performance trade-offs.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的运行时配置文件**：AOT编译需要全面了解应用程序在构建阶段的行为。对于具有复杂运行时行为或动态适应各种场景的应用程序来说，这可能具有挑战性。在这种情况下，原生图像可能无法捕获完整的运行时配置文件，从而导致潜在的性能权衡。'
- en: '**Platform dependencies**: Native Image produces platform-specific binaries,
    potentially introducing challenges for cross-platform compatibility. While GraalVM
    provides some level of cross-compilation support, developers must be mindful of
    potential platform dependencies and thoroughly test their applications on target
    platforms.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台依赖性**：原生图像生成特定平台的二进制文件，可能引入跨平台兼容性的挑战。虽然GraalVM提供了一定程度的交叉编译支持，但开发者必须注意潜在的平台依赖性，并在目标平台上彻底测试他们的应用程序。'
- en: '**The footprint of included libraries**: Including certain libraries in a Native
    Image can increase size, potentially offsetting some of the gains in memory efficiency.
    Developers must carefully choose and optimize the dependencies included in the
    native image to strike the right balance between footprint and functionality.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含库的占用**：在原生图像中包含某些库可能会增加大小，可能抵消一些内存效率的收益。开发者必须仔细选择和优化包含在原生图像中的依赖项，以在占用和功能之间取得正确的平衡。'
- en: 'Navigating the landscape of application deployment, it becomes essential to
    comprehend the fundamental distinctions between Native Image applications and
    those running on a JVM. The divergence lies in their approach to execution and
    resource utilization. Native Image applications, crafted through GraalVM’s innovative
    AOT compilation, stand out for their streamlined startup times and reduced memory
    footprints. They eschew the need for a JVM during deployment, directly interacting
    with the operating system as standalone executables. In contrast, JVM-based applications
    boast portability across platforms and can run on any environment equipped with
    a compatible JVM. Next, we’ll delve into the nuances of these differences, shedding
    light on considerations such as startup time, memory efficiency, and the impact
    on application portability. By unraveling these distinctions, developers can make
    informed choices tailored to the specific demands of their projects, unlocking
    the optimal balance between performance, portability, and resource utilization:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航应用程序部署的领域中，理解原生图像应用程序和运行在JVM上的应用程序之间的基本区别变得至关重要。这种差异在于它们执行和资源利用的方法。通过GraalVM的创新AOT编译技术制作的原生图像应用程序，以其简化的启动时间和较小的内存占用而突出。它们在部署期间无需JVM，作为独立的可执行文件直接与操作系统交互。相比之下，基于JVM的应用程序具有跨平台的可移植性，可以在任何配备兼容JVM的环境上运行。接下来，我们将深入探讨这些差异的细微之处，阐明启动时间、内存效率和应用可移植性等方面的影响。通过揭示这些区别，开发者可以根据项目特定的需求做出明智的选择，实现性能、可移植性和资源利用之间的最佳平衡：
- en: '**Startup time**: Native Image applications excel in terms of startup time
    as they eliminate the overhead associated with initializing a JVM. This is particularly
    advantageous for short-lived applications or microservices where rapid responsiveness
    is paramount. In contrast, JVM-based applications typically have a longer startup
    time as the JVM needs to interpret and compile the code at runtime.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时间**：原生图像应用程序在启动时间方面表现出色，因为它们消除了与初始化JVM相关的开销。这对于生命周期短的应用程序或微服务来说尤其有利，因为这些场景下快速响应至关重要。相比之下，基于JVM的应用程序通常具有较长的启动时间，因为JVM需要在运行时解释和编译代码。'
- en: '**Memory footprint**: Native Image applications generally have a smaller memory
    footprint compared to their JVM counterparts. Without the need for a JVM, the
    overhead associated with running the virtual machine is eliminated, resulting
    in more efficient resource utilization. This makes Native Image applications well-suited
    for environments with stringent memory constraints.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存占用**：与JVM对应的原生图像应用程序通常具有更小的内存占用。由于无需JVM，运行虚拟机的开销被消除，从而实现了更有效的资源利用。这使得原生图像应用程序非常适合对内存约束严格的
    环境。'
- en: '**Portability**: JVM applications are known for their portability – the ability
    to run on any platform with a compatible JVM. On the other hand, Native Image
    applications, being compiled to platform-specific binaries, may have platform
    dependencies. While GraalVM provides some level of cross-compilation support,
    it’s essential to consider platform-specific implications when using Native Image.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：JVM应用程序以其可移植性而闻名——能够在任何具有兼容JVM的平台上运行。另一方面，Native Image应用程序，由于编译成特定平台的二进制文件，可能存在平台依赖性。虽然GraalVM提供了一定程度的交叉编译支持，但在使用Native
    Image时，考虑平台特定的影响是至关重要的。'
- en: 'Diving into the intricate decision-making process of application deployment,
    the following comparison table illuminates the distinctive characteristics between
    Native Image applications and those operating on a JVM. Each column encapsulates
    crucial aspects that influence performance, resource utilization, and adaptability.
    Native Image applications, sculpted through GraalVM’s innovative AOT compilation,
    boast expedited startup times and diminished memory footprints, making them particularly
    adept for scenarios prioritizing efficiency. In contrast, JVM-based applications
    offer the advantage of cross-platform compatibility and dynamic adaptability,
    leveraging JIT compilation. This table serves as a compass for developers, providing
    a concise yet comprehensive guide to navigate the trade-offs and make informed
    decisions based on the specific needs of their projects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨应用程序部署的复杂决策过程，以下比较表揭示了Native Image应用程序与在JVM上运行的应用程序之间的独特特征。每一列都封装了影响性能、资源利用率和适应性的关键方面。通过GraalVM的创新AOT编译，Native
    Image应用程序具有加速的启动时间和较小的内存占用，特别适合优先考虑效率的场景。相比之下，基于JVM的应用程序具有跨平台兼容性和动态适应性的优势，利用JIT编译。此表为开发者提供指南，提供简洁而全面的指南，以导航权衡并基于项目的具体需求做出明智的决定：
- en: '| **Feature** | **Native** **Image Applications** | **JVM-Based Applications**
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **Native Image应用程序** | **基于JVM的应用程序** |'
- en: '| **Startup Time** | Generally faster | May be slower, depending on the JIT
    compilation |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **启动时间** | 通常更快 | 可能较慢，取决于JIT编译 |'
- en: '| **Memory Footprint** | Smaller | Larger |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **内存占用** | 较小 | 较大 |'
- en: '| **Build Time** | Longer due to AOT compilation | Shorter due to the JIT compilation
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **构建时间** | 由于AOT编译而较长 | 由于JIT编译而较短 |'
- en: '| **Dynamic** **Class Loading** | Limited; requires careful handling | More
    flexible |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **动态** **类加载** | 受限；需要谨慎处理 | 更灵活 |'
- en: '| **Reflection** | Limited; requires careful handling | More flexible |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **反射** | 受限；需要谨慎处理 | 更灵活 |'
- en: '| **Platform Portability** | Platform-specific binaries | Cross-platform with
    a compatible JVM |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **平台可移植性** | 特定平台的二进制文件 | 兼容JVM的跨平台 |'
- en: '| **Resource Utilization** | Efficient; lower overheads | May have higher overheads
    depending on the JVM |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **资源利用** | 效率较高；开销较低 | 可能具有更高的开销，取决于JVM |'
- en: '| **Dependency Inclusion** | Need to optimize to manage size | Easier management
    with dependency managers |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **依赖包含** | 需要优化以管理大小 | 使用依赖管理器更容易管理 |'
- en: '| **Adaptability to** **Runtime Changes** | Less dynamic; needs careful handling
    | More adaptive with JIT compilation |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **对** **运行时变化的适应性** | 动态性较低；需要谨慎处理 | 更适应，利用JIT编译 |'
- en: '| **Build Complexity** | Higher; requires configuration | Lower; generally
    handled by the JVM |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **构建复杂性** | 较高；需要配置 | 较低；通常由JVM处理 |'
- en: 'Table 7.1: Native Image versus JVM'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：Native Image与JVM对比
- en: This table provides a high-level overview of the key differences between Native
    Image and JVM-based applications. It’s important to note that the choice between
    the two depends on specific project requirements, considering factors such as
    startup time, memory efficiency, platform portability, and flexibility needed
    in dynamic features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此表提供了Native Image与基于JVM应用程序之间关键差异的高级概述。需要注意的是，选择两者之间的差异取决于具体的项目需求，考虑因素包括启动时间、内存效率、平台可移植性和在动态功能中所需的灵活性。
- en: On exploring the differences between Native Image applications and their counterparts,
    it becomes clear that the path to optimal application deployment is nuanced and
    multifaceted. This comparative journey has uncovered both approaches’ unique strengths
    and considerations, guiding developers toward informed decisions that align with
    project priorities. Now, with a richer understanding of the trade-offs and benefits,
    we stand at the threshold of hands-on mastery.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索原生图像应用程序及其对应程序之间的差异时，我们可以清楚地看到，实现最佳应用程序部署的道路是复杂且多层次的。这次比较之旅揭示了两种方法独特的优势和考虑因素，引导开发者做出与项目优先级相一致的有信息量的决策。现在，随着我们对权衡和益处的理解更加丰富，我们站在了实际掌握的门槛上。
- en: In the upcoming session, we’ll delve into the practical realm of creating a
    Native Image using GraalVM. We’ll unravel the intricacies of the AOT compilation
    process, demystifying the steps to transform a Java application into a standalone
    executable. From optimizing dependencies to navigating platform specific considerations,
    this hands-on exploration will empower you to harness the efficiency gains of
    Native Image deployment. Join us in the next section as we embark on a practical
    journey toward unlocking the potential of Native Image, reshaping the landscape
    of application deployment with GraalVM’s groundbreaking capabilities.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的会话中，我们将深入探讨使用 GraalVM 创建原生图像的实际领域。我们将揭示 AOT 编译过程的复杂性，揭开将 Java 应用程序转换为独立可执行文件的步骤。从优化依赖项到处理特定平台的考虑因素，这次动手探索将赋予你利用原生图像部署效率提升的能力。请加入我们，在下一节中，我们将踏上解锁原生图像潜力、利用
    GraalVM 的开创性能力重塑应用程序部署格局的实际旅程。
- en: Creating a Native Image
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建原生图像
- en: In this immersive and hands-on section, we delve into mastering the creation
    of Native Images using GraalVM. Building upon the insights gained in our comparative
    exploration of Native Image applications and JVM counterparts, this section is
    your gateway to the practical realm of application deployment efficiency. As we
    shift from theory to practice, our focus now centers on empowering you to wield
    the transformative capabilities of Native Image compilation. Prepare to embark
    on a journey where we demystify the AOT compilation process, offering step-by-step
    guidance on transforming a Java application into a standalone executable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个沉浸式和动手操作的章节中，我们将深入掌握使用 GraalVM 创建原生图像。在比较探索原生图像应用程序和 JVM 对应程序所获得的见解的基础上，这一章节是你通往应用程序部署效率实际领域的门户。随着我们从理论转向实践，我们的重点现在集中在赋予你运用原生图像编译的变革性能力。准备开始一段旅程，我们将揭开
    AOT 编译过程的神秘面纱，提供将 Java 应用程序转换为独立可执行文件的逐步指导。
- en: Throughout this section, we will delve into the intricacies of optimizing dependencies,
    navigating platform-specific considerations, and unleashing the full potential
    of Native Image deployment. Whether you’re a seasoned developer seeking to enhance
    application performance or an enthusiast eager to explore the cutting-edge of
    GraalVM technology, this hands-on experience will equip you with the practical
    skills to integrate Native Image compilation seamlessly into your development
    toolkit. Let’s dive in and turn theory into practice as we navigate the creation
    of Native Images, reshaping the landscape of application deployment with GraalVM’s
    revolutionary capabilities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨优化依赖项、处理特定平台的考虑因素以及释放原生图像部署的完整潜力。无论你是寻求提升应用程序性能的资深开发者，还是渴望探索 GraalVM
    技术前沿的热心爱好者，这次动手实践将为你提供将原生图像编译无缝集成到你的开发工具包中的实用技能。让我们深入其中，将理论转化为实践，在导航创建原生图像的过程中，利用
    GraalVM 的革命性能力重塑应用程序部署的格局。
- en: In this hands-on practice section, we’ll dive into the exciting world of Native
    Image compilation by working on a whimsically simple yet illustrative Java application.
    The `App` class is designed to print a greeting to the world and, in a super silly
    twist, reverse a given string. As we explore the code, you’ll notice it’s not
    your typical “Hello, World!” example. Instead, it introduces a method called `reverseString`
    that recursively reverses a given string. The application starts by printing a
    greeting and then reverses the string “Native Image is awesome” using the `reverseString`
    method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动手实践部分，我们将通过一个既简单又富有说明性的Java应用程序，深入探索原生图像编译的激动人心世界。`App`类被设计用来向世界打印问候语，并在一个超级愚蠢的转折中，反转一个给定的字符串。当我们探索代码时，你会注意到它并不是典型的“Hello,
    World!”示例。相反，它引入了一个名为`reverseString`的方法，该方法递归地反转一个给定的字符串。应用程序首先打印一个问候语，然后使用`reverseString`方法反转字符串“Native
    Image is awesome”。
- en: 'This playful sample serves as the canvas for our Native Image experiment. Through
    this exercise, we’ll not only witness the creation of a Native Image but also
    gain insights into the optimization process and the resulting efficiency gains.
    So, buckle up as we traverse the creation of a Native Image for this super silly
    yet instructive Java application. Let’s make the whimsical tangible and explore
    the magic of Native Image with GraalVM:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的示例是我们原生图像实验的画布。通过这个练习，我们不仅将见证原生图像的创建，还将深入了解优化过程以及带来的效率提升。所以，系好安全带，随着我们穿越创建原生图像的这个既愚蠢又富有教育意义的Java应用程序，让我们将这种奇妙变为现实，并探索与GraalVM一起使用原生图像的魔力：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting up GraalVM is a crucial step in our journey toward mastering Native
    Image compilation. To streamline this process and manage different Java versions
    effortlessly, we’ll leverage the SDKMan project. SDKMan simplifies the installation
    and switching between different Java versions, providing a seamless experience
    for developers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设置GraalVM是我们掌握原生图像编译旅程中的关键步骤。为了简化这个过程并轻松管理不同的Java版本，我们将利用SDKMan项目。SDKMan简化了不同Java版本的安装和切换，为开发者提供无缝的体验。
- en: 'For manual installation, you can refer to the official GraalVM documentation.
    However, to make our lives easier, let’s use SDKMan to install GraalVM. At the
    time of writing, we’re opting for version 21.0.1 with GraalVM support. Execute
    the following command in your terminal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于手动安装，你可以参考官方的GraalVM文档。然而，为了使我们的生活更简单，让我们使用SDKMan来安装GraalVM。在撰写本文时，我们选择的是带有GraalVM支持的21.0.1版本。在你的终端中执行以下命令：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command fetches and installs GraalVM version 21.0.1 through SDKMan. Once
    established, you can either set it as the default Java version for your system
    or use it selectively in the current terminal session. If you wish to set it as
    the default, employ the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过SDKMan获取并安装GraalVM版本21.0.1。一旦安装完成，你可以将其设置为系统默认的Java版本，或者在选择当前终端会话中使用它。如果你希望将其设置为默认版本，请使用以下命令：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, with GraalVM seamlessly integrated into your development environment, we’re
    well-prepared to explore Native Image creation. Let’s embark on the next steps
    of this hands-on journey, where we’ll combine the power of GraalVM with the simplicity
    of SDKMan.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着GraalVM无缝集成到你的开发环境中，我们已经做好了探索原生图像创建的准备。让我们开始这个动手旅程的下一步，我们将结合GraalVM的力量与SDKMan的简单性。
- en: 'Creating a Native Image is the pivotal next step in our exploration, and the
    process involves a series of commands to compile, package, and, finally, generate
    the native image. Let’s break it down:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原生图像是我们探索的关键下一步，这个过程涉及一系列用于编译、打包，最后生成原生图像的命令。让我们将其分解：
- en: '**Compile the** **App class**:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译App类**：'
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command compiles the `App` class and stores the compiled files in the `build`
    directory.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令编译`App`类，并将编译后的文件存储在`build`目录中。
- en: '**Create a** **JAR file**:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个** **JAR文件**：'
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we package the compiled files into a JAR file named `App.jar` and specify
    the main class as `expert.os.App`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将编译后的文件打包成一个名为`App.jar`的JAR文件，并指定主类为`expert.os.App`。
- en: '**Create the** **Native Image**:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个** **原生图像**：'
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Utilizing GraalVM’s `native-image` tool, we generate the native image from the
    JAR file. This step involves AOD compilation, resulting in a standalone executable.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 利用GraalVM的`native-image`工具，我们从JAR文件生成原生图像。这一步涉及AOT编译，生成一个独立的可执行文件。
- en: '**Execute the** **Native Image**:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行原生图像**：'
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the native image created, we can run the executable. Upon execution, the
    console will display the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了原生图像后，我们可以运行可执行文件。在执行时，控制台将显示以下输出：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations! You’ve successfully navigated the process of creating a Native
    Image using GraalVM, turning our whimsically simple Java application into a streamlined,
    standalone executable. This hands-on experience sets the stage for further exploration
    of the efficiency gains and optimization possibilities offered by Native Image
    compilation. Let’s revel in the results and continue our journey into the dynamic
    realm of GraalVM.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功完成使用 GraalVM 创建原生图像的过程，将我们那看似简单的 Java 应用程序转换成了一个精简的、独立的可执行文件。这次动手实践为探索原生图像编译提供的效率提升和优化可能性奠定了基础。让我们享受这些成果，并继续我们的
    GraalVM 动态领域的探索之旅。
- en: As we conclude this section on Native Image creation with GraalVM, it’s evident
    that we’ve embarked on a transformative journey in application deployment. By
    seamlessly integrating the power of GraalVM, we’ve transformed a playful Java
    application into a standalone executable, unlocking efficiency gains in startup
    time and resource utilization.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 GraalVM 创建原生图像的这一节结束时，很明显，我们已经踏上了一段变革性的应用程序部署之旅。通过无缝集成 GraalVM 的力量，我们将一个有趣味的
    Java 应用程序转换成了一个独立的可执行文件，解锁了启动时间和资源利用率的效率提升。
- en: Through meticulous compilation steps and the magic of AOT processing, we’ve
    witnessed the birth of a native image. The output of our executable not only echoes
    the familiar “Hello, World!” greeting but also showcases the whimsical reversal
    of a string – a testament to the versatility of GraalVM.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过细致的编译步骤和 AOT 处理的魔力，我们见证了原生图像的诞生。我们的可执行文件的输出不仅回响了熟悉的“Hello, World！”问候，还展示了字符串的奇妙反转——这是
    GraalVM 多功能性的证明。
- en: This hands-on experience lays a solid foundation for further exploration. Armed
    with a Native Image, developers can delve into real-world applications, optimizing
    performance and navigating the intricacies of efficient resource utilization.
    The journey doesn’t end here, though; it extends into the dynamic landscapes of
    GraalVM’s capabilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次动手实践为进一步的探索奠定了坚实的基础。有了原生图像，开发者可以深入研究现实世界应用程序，优化性能并导航高效资源利用的复杂性。然而，旅程并未结束；它延伸到了
    GraalVM 能力的动态领域。
- en: As we celebrate the successful execution of our native image, let this be a
    catalyst for your continued exploration into the possibilities and efficiencies
    unlocked by GraalVM. The adventure continues, and the next chapters await, promising
    deeper insights and mastery in the fascinating world of Java application development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在庆祝我们成功执行原生图像的同时，让这成为您继续探索 GraalVM 解锁的可能性和效率的催化剂。冒险仍在继续，下一章等待着，承诺带来对 Java 应用程序开发迷人世界的更深入见解和掌握。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the transformative capabilities of GraalVM,
    from its high-performance compiler to the creation of a Native Image. Witnessing
    the efficiency gains achievable through AOT compilation marked a significant milestone,
    showcasing GraalVM’s versatility in reshaping the Java development landscape.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 GraalVM 的变革能力，从其高性能编译器到原生图像的创建。通过 AOT 编译实现的效率提升标志着重要的里程碑，展示了 GraalVM
    在重塑 Java 开发格局方面的多功能性。
- en: As we conclude, this chapter served as a stepping stone to the broader exploration
    of the JVM ecosystem and alternative JVMs in the next chapter. The diverse options
    beyond conventional JVMs, such as OpenJ9 and Azul Zing, will be unraveled, providing
    insights into their unique features and contributions to the ever-evolving Java
    ecosystem. Join us in the next chapter as we navigate the diverse paths within
    the JVM landscape, informed by the knowledge we’ve gained from our exploration
    of GraalVM.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，它成为下一章更广泛探索 JVM 生态系统和替代 JVM 的垫脚石。我们将揭示超越传统 JVM 的多样化选项，如 OpenJ9 和 Azul
    Zing，提供对这些独特功能和它们对不断发展的 Java 生态系统的贡献的见解。请加入我们，在下一章中，我们将根据我们从 GraalVM 探索中获得的知识，在
    JVM 领域的多样化路径中导航。
- en: Questions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试您对本章的知识：
- en: What is the primary benefit of GraalVM’s Native Image compilation?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 的原生图像编译的主要好处是什么？
- en: Increased memory footprint
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加的内存占用
- en: Slower startup time
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较慢的启动时间
- en: Platform portability
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台可移植性
- en: Limited language support
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言支持有限
- en: Which command is used to compile the **App** class in the GraalVM Native Image
    creation process?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GraalVM 本地图像创建过程中，用于编译 **App** 类的命令是什么？
- en: '**compile -****class App**'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**compile -****class App**'
- en: '**javac -d** **build src/main/java/expert/os/App.java**'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**javac -d** **build src/main/java/expert/os/App.java**'
- en: '**native-image --****compile App**'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**native-image --****compile App**'
- en: '**graalvm-compile App.java**'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**graalvm-compile App.java**'
- en: What is the purpose of the **reverseString** method in the provided Java application?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的 Java 应用程序中 **reverseString** 方法的目的是什么？
- en: Concatenates strings
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接字符串
- en: Reverses a given string
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转一个给定的字符串
- en: Checks for a palindrome
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查回文
- en: Removes whitespace from a string
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串中删除空白字符
- en: How does GraalVM’s Native Image differ from JVM-based applications in terms
    of startup time?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 的本地图像在启动时间方面与基于 JVM 的应用程序有何不同？
- en: Native Image has a slower startup time
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地图像具有较慢的启动时间
- en: Both have similar startup times
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们都有相似的启动时间
- en: Native Image has a faster startup time
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地图像具有更快的启动时间
- en: JVM-based applications have a faster startup time
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 JVM 的应用程序具有更快的启动时间
- en: What is SDKMan used for in the context of GraalVM installation?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GraalVM 安装的情况下，SDKMan 的用途是什么？
- en: Managing Java versions and installations
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理Java版本和安装
- en: Creating native images
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地图像
- en: Debugging Java applications
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试Java应用程序
- en: Managing Docker images
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理Docker镜像
- en: What does the **native-image** command do in the GraalVM Native Image creation
    process?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GraalVM 本地图像创建过程中，**native-image** 命令做什么？
- en: Compiles Java source code
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译Java源代码
- en: Generates a standalone executable
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个独立的可执行文件
- en: Downloads Java dependencies
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Java依赖项
- en: Executes the Java application
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行Java应用程序
- en: Answers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: C. Platform portability
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 平台可移植性
- en: B. **javac -d** **build src/main/java/expert/os/App.java**
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. **javac -d** **build src/main/java/expert/os/App.java**
- en: B. Reverses a given string
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 反转一个给定的字符串
- en: C. Native Image has a faster startup time
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 本地图像具有更快的启动时间
- en: A. Managing Java versions and installations
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 管理Java版本和安装
- en: B. Generates a standalone executable
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 生成一个独立的可执行文件
