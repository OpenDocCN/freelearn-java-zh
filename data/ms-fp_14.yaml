- en: Introduction to Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 简介
- en: This book uses Scala extensively as its primary example language. In this chapter,
    we will briefly overview the language basics. First, we will start from the motivation
    for using it as an example language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书广泛使用 Scala 作为其主要示例语言。在本章中，我们将简要概述语言基础。首先，我们将从将其作为示例语言的动机开始。
- en: 'Following are the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Motivation for using Scala
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scala 的动机
- en: Variables and functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和函数
- en: Control structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Inheritance model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承模型
- en: This chapter is supposed to be a quick introduction for the rest of the book,
    and should not be regarded as a full-size tutorial on Scala.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为本书的其余部分提供一个快速介绍，不应被视为 Scala 的完整教程。
- en: Motivation for using Scala
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scala 的动机
- en: The primary motivation for using Scala for examples in this book is as follows. First
    of all, Scala is a functional language. This means that it has support for almost
    all of the functional programming styles that have been developed so far. Another
    reason for choosing Scala is that it is designed explicitly with object-oriented
    programmers in mind. Scala positions itself as a mix between object-oriented and
    functional languages. This means that new programmers that come from the object-oriented
    world can use Scala as an object-oriented language. This facilitates the transition
    from the object-oriented style. In fact, Scala is often used as Java without semicolons,
    meaning that you can program your Scala programs similarly to how you used to
    program your Java programs. The preceding reasons facilitate transition for new
    programmers greatly. Also, Scala features a very powerful mechanics for functional
    programming. So, you can write functional programs just the way you would do in
    Haskell.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用 Scala 作为示例语言的主要动机如下。首先，Scala 是一种函数式语言。这意味着它支持迄今为止开发的所有函数式编程风格。选择 Scala
    的另一个原因是它是专门为面向对象程序员设计的。Scala 将自己定位在面向对象和函数式语言之间。这意味着来自面向对象世界的程序员可以使用 Scala 作为面向对象语言。这有助于从面向对象风格的过渡。实际上，Scala
    经常被用作没有分号的 Java，这意味着你可以用与以前编写 Java 程序相同的方式编写 Scala 程序。上述原因极大地促进了新程序员的过渡。此外，Scala
    还具有非常强大的函数式编程机制。因此，你可以像在 Haskell 中一样编写函数式程序。
- en: We can even say that Scala is more potent than Haskell because, in some circumstances,
    the object-oriented approach is absolutely necessary. You can access the entire
    JVM infrastructure, meaning that you can use any Java library from Scala easily.
    The infrastructure is very mature and industry-oriented. Unfortunately, you cannot
    say the same thing about Haskell, which is less production-ready than JVM languages.
    Purely functional languages such as Haskell are used in production. However, they
    do not possess as mature infrastructure, say, for dependency management or compile
    tools as does Scala. Even though you can use all of the object-oriented libraries
    from Java in Scala, there is an entire host of native libraries for Scala, which
    are also production-ready and can facilitate a purely functional programming style.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以说 Scala 比 Haskell 更强大，因为在某些情况下，面向对象的方法是绝对必要的。你可以访问整个 JVM 基础设施，这意味着你可以轻松地从
    Scala 使用任何 Java 库。该基础设施非常成熟且面向行业。不幸的是，你不能对 Haskell 说同样的话，因为 Haskell 比JVM 语言更不适用于生产环境。像
    Haskell 这样的纯函数式语言在生产环境中使用。然而，它们在依赖管理或编译工具等基础设施方面不如 Scala 成熟。尽管你可以在 Scala 中使用所有来自
    Java 的面向对象库，但 Scala 还有一系列本机库，这些库也是生产就绪的，可以促进纯函数式编程风格。
- en: A final thing about Scala worth mentioning is that it is an experimental language.
    This means it is often used as a playground to test new features and research
    in computer science. This means that leading-edge research is available to you
    as a Scala programmer. Combine that with accessibility to JVM, and you get an
    ideal tool to advance your knowledge in computer science while developing real-world
    software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Scala 是一种实验性语言。这意味着它经常被用作测试计算机科学新功能和研究的游乐场。这意味着作为 Scala 程序员，你可以获得前沿的研究成果。结合对
    JVM 的访问，你将获得一个理想工具，在开发实际软件的同时，提升你在计算机科学领域的知识。
- en: In short, all of this means that while using Scala, you can use a wide spectrum
    of styles, from a conventional object-oriented approach all the way to leading
    edge functional programming research. This makes it a great language for examples
    in this books.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，所有这些都意味着在使用 Scala 时，你可以使用广泛风格的组合，从传统的面向对象方法到前沿的函数式编程研究。这使得它成为这本书示例的绝佳语言。
- en: Scala infrastructure
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 架构
- en: First, let's have a look at the infrastructure developed for Scala. Let's have
    a look at the Scala interpreter first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看为 Scala 开发的架构。首先让我们看看 Scala 解释器。
- en: Scala interpreter
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 解释器
- en: Although Scala is a compiled language, it has its own interpreter. It comes
    as part of the standard language distribution, and if you install Scala, you will
    have access to it. Please consult [https://www.scala-lang.org/](https://www.scala-lang.org/)
    on the instructions to install Scala.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Scala 是一种编译型语言，但它有自己的解释器。它是标准语言分发的组成部分，如果你安装了 Scala，你将能够访问它。请参阅 [https://www.scala-lang.org/](https://www.scala-lang.org/)
    了解安装 Scala 的说明。
- en: You can access the interpreter from the command line by simply typing `scala`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地输入 `scala` 命令从命令行访问解释器。
- en: 'In this interpreter, you can run Scala expressions and get evaluations of them
    in real time. Besides ordinary expressions, you can run interpreter-specific expressions
    to tune it up. This kind of expression usually starts with a colon followed by
    a keyword. To access the list of all the relevant Scala interpreter expressions,
    type the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解释器中，你可以运行 Scala 表达式，并实时获取它们的评估结果。除了普通表达式外，你还可以运行解释器特定的表达式来调整它。这类表达式通常以冒号后跟关键字开始。要访问所有相关
    Scala 解释器表达式的列表，请输入以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/58c25f72-880b-48f2-b4ce-54637cb2e50e.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58c25f72-880b-48f2-b4ce-54637cb2e50e.png)'
- en: SBT build tool
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT 构建工具
- en: SBT is a build tool for Scala. It is a dedicated build tool developed specifically
    for Scala. It is possible to integrate Scala with Gradle or Maven, and in fact,
    this is an option that many teams prefer to do. SBT is supposed to be simple,
    but in fact, it is the precise opposite of simple. If you decide to use SBT as
    your Scala build tool, be advised that it possesses a complex infrastructure and
    is not well documented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SBT 是 Scala 的构建工具。它是一个专门为 Scala 开发的专用构建工具。可以将 Scala 与 Gradle 或 Maven 集成，实际上，这是许多团队更愿意选择的做法。SBT
    应该是简单的，但实际上，它恰恰相反。如果你决定使用 SBT 作为你的 Scala 构建工具，请注意它拥有复杂的架构，并且文档并不完善。
- en: However, it is rather powerful. It allows you to write build descriptions in
    a subset of the Scala language. This means that your build scripts are Scala programs
    in themselves. This is not something you get with build tools, such as Gradle
    or Maven.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它相当强大。它允许你使用 Scala 语言的一个子集编写构建描述。这意味着你的构建脚本本身就是 Scala 程序。这不是 Gradle 或 Maven
    等构建工具所提供的东西。
- en: For this book, we do not need to be familiar with SBT. The GitHub repository
    with the examples for this books uses SBT, so you will need some basic familiarity
    with this software to run the examples. However, in this book, we do not feature
    SBT in parts that are crucial to functional programming. If you want to become
    more familiar with this tool, please see the official documentation of SBT.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们不需要熟悉 SBT。这本书的示例 GitHub 仓库使用 SBT，因此你需要对这款软件有一些基本的了解才能运行示例。然而，在这本书中，我们没有在功能编程至关重要的部分介绍
    SBT。如果你想更熟悉这个工具，请参阅 SBT 的官方文档。
- en: Variables and functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和函数
- en: The backbone of the Scala language is variables and functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 语言的骨架是变量和函数。
- en: 'The variables are defined as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的定义如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Variables are defined using the `var` keyword followed by the name of the variable,
    followed by the value you would like to assign to the variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量使用 `var` 关键字定义，后跟变量名，然后是你要分配给变量的值。
- en: 'Variables defined in the preceding manner are mutable. This means that once
    they are assigned, you can modify them:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方式定义的变量是可变的。这意味着一旦它们被赋值，你就可以修改它们：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, purely functional programming advocates against this style. Since
    Scala positions itself as a mixture of purely functional and object-oriented styles,
    it offers a way to define an immutable variable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，纯函数式编程倡导者反对这种风格。由于 Scala 将自己定位为纯函数式和面向对象风格的混合体，它提供了一种定义不可变变量的方法：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if you try to modify is this variable, you will get a compile-time error:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试修改这个变量，你将得到一个编译时错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides all of these, Scala has a similar syntax for functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些之外，Scala 还具有类似函数的语法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, a function is just like a value. However, it can be parameterized by arguments,
    and it will evaluate every time you call it. A normal value is evaluated only
    once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个函数就像一个值。然而，它可以由参数化，并且每次调用时都会评估。一个普通值只评估一次。
- en: 'Value can be modified with a `lazy` attribute to make it lazily evaluated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以通过 `lazy` 属性来修改，使其进行惰性评估：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you do find this way, it is not evaluated right away but at the time when
    it is called for the first time. In a sense, it is similar to a function in this
    manner, because it is not evaluated right away. However, a function is evaluated
    every time we call it, and this can be not said of a value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式找到时，它不会立即评估，而是在第一次调用时评估。从某种意义上说，它类似于函数，因为它不会立即评估。然而，函数每次调用时都会被评估，而值则不同。
- en: In the preceding code, all of their definitions are specified without the types
    they return. However, Scala is a strongly typed language. The compiler knows the
    types of all its variables. The compiler of Scala is powerful, and it can infer
    the types of its values and variables in a wide range of circumstances so that
    you do not need to provide them explicitly. So, in the preceding code, the compiler
    infers the types of the values, variables, and functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，它们的定义都没有指定返回类型。然而，Scala 是一种强类型语言。编译器知道所有变量的类型。Scala 的编译器功能强大，它可以在广泛的情况下推断值和变量的类型，因此你不需要显式提供它们。所以，在前面的代码中，编译器推断出值、变量和函数的类型。
- en: 'You can explicitly specify the type you would like a variable to have as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式指定你希望变量拥有的类型如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Also, notice that when you run the code without an explicit type specification
    through a Scala interpreter, the result will be aware of the type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当你通过 Scala 解释器运行没有显式类型指定的代码时，结果将知道其类型。
- en: Control structures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Similarly to the majority of modern programming languages, the Scala language
    has a bunch of control structures; for example, for branching and looping. The
    control structures in question are `if`, `while`, `for`, and pattern matching.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于大多数现代编程语言，Scala 语言有一系列控制结构；例如，用于分支和循环。这些控制结构包括 `if`、`while`、`for` 和模式匹配。
- en: If and While
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果和 While
- en: '`if` and `while` are implemented the same way as they are in any other programming
    language:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 和 `while` 的实现方式与其他任何编程语言相同：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that in such constructs, you can optionally omit the curly braces if
    the body of the construct is a single expression:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些结构中，如果结构体是一个单独的表达式，你可以选择性地省略花括号：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is something you can do in many places in Scala. Wherever you have a body
    that consists of a single expression, you can omit the curly braces around this
    expression. There are certain exceptions to this rule, however.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Scala 的许多地方都可以做到的事情。无论你在哪里有一个由单个表达式组成的主体，你都可以省略围绕这个表达式的花括号。然而，这个规则有一些例外。
- en: For
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: For
- en: 'The `for` statement is a little bit more unconventional. In fact, the `for`
    statement is syntactic sugar for an application of the `foreach`, `map`, and `flatMap`
    methods. For example, take a look at the following expression:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句稍微有些不寻常。实际上，`for` 语句是 `foreach`、`map` 和 `flatMap` 方法应用的一种语法糖。例如，看看以下表达式：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding `for` expression expands to the following method applications:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `for` 表达式展开为以下方法应用：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, basically, if a type defines the methods specified in the preceding code,
    you can write the application in terms of the `for` construct. For example, if
    you take an `Option` type that defines `map`, `flatMap`, and `foreach`, you can
    write a program as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，如果一个类型定义了前面代码中指定的方法，你可以用 `for` 结构来编写应用程序。例如，如果你使用一个定义了 `map`、`flatMap`
    和 `foreach` 的 `Option` 类型，你可以编写如下程序：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `for` construct is not called a loop in Scala, but a Monadic flow. This
    is due to the special meaning of the `map` and `flatMap` functions in functional
    programming.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，`for` 结构不被称为循环，而是一种 Monadic 流。这是由于函数式编程中 `map` 和 `flatMap` 函数的特殊意义。
- en: Pattern matching
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'Special constructs in Scala are partial functions and pattern matching. For
    example, you can write expressions as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的特殊结构包括部分函数和模式匹配。例如，你可以按照以下方式编写表达式：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'More complex pattern matching is also possible. For example, given a list,
    we can match on its head and tail, or its head and its second argument and its
    tail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的模式匹配也是可能的。例如，给定一个列表，我们可以匹配其头部和尾部，或者其头部和第二个参数及其尾部：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In fact, we can perform pattern matching on virtually anything with the help
    of so-called extractors. For example, it is possible to match on a custom data
    type as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用所谓的提取器在几乎任何东西上执行模式匹配。例如，可以匹配自定义数据类型，如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The semantics of pattern matching is that on runtime, the environment will call
    the `unapply` function on the data type in question, and see whether this function
    returns some result or whether it is a `None`. If some result is returned in an
    option, the result is used to populate the variables in the pattern matching clause.
    Otherwise, the pattern is considered not matched.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的语义是，在运行时，环境将对相关数据类型调用`unapply`函数，并查看该函数是否返回某些结果或是否为`None`。如果在选项中返回了某些结果，则该结果用于填充模式匹配子句中的变量。否则，该模式被认为没有匹配。
- en: Partial functions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: 'The preceding pattern matching statements are very close to the notion of partial
    functions in Scala. The same way pattern matching statements have a certain domain
    of cases that they can handle and throw an exception in all other cases, partial
    functions are defined on a part of their input domain. For example, the preceding
    `match` statement can be converted into a partial function, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模式匹配语句与Scala中部分函数的概念非常接近。与模式匹配语句有它们可以处理的特定案例域并抛出异常处理所有其他情况一样，部分函数是在它们输入域的一部分上定义的。例如，前面的`match`语句可以转换为部分函数，如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inheritance model
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承模型
- en: Scala features a lot of object-oriented functionality. This means it supports
    inheritance concepts that are core to the object-oriented programming. Moreover,
    since Scala compiles to the Java Virtual Machine, it is essential that it supports
    the same model as Java for Java interoperability reasons.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Scala具有许多面向对象的功能。这意味着它支持面向对象编程的核心继承概念。此外，由于Scala编译到Java虚拟机，为了Java互操作性，它必须支持与Java相同的模型。
- en: Classes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'Classes in Scala have similar semantics to their Java counterparts. They are
    defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的类与它们的Java对应物具有类似的语义。它们如下定义：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, it is possible to define so-called case classes in Scala. These classes
    are used to represent product types, that is, several types bound together in
    one datatype. For example, you can define a case class for the `User` domain object
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以在Scala中定义所谓的案例类。这些类用于表示产品类型，即在一个数据类型中将多个类型绑定在一起。例如，可以定义一个用于`User`域对象的案例类，如下所示：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As follows from their name, case classes are primarily used for pattern matching.
    When you are defining a case class, the compiler automatically generates extractors
    for this class, so that it can be used in pattern matching, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，情况类主要用于模式匹配。当你定义一个情况类时，编译器会自动为该类生成提取器，以便可以在模式匹配中使用，如下所示：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, the compiler generates convenient `toString`, `equals`, and `hashCode`
    methods for case classes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编译器为情况类生成方便的`toString`、`equals`和`hashCode`方法：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Case classes are especially useful when modeling your domain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 情况类在建模领域时特别有用。
- en: Traits
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质
- en: 'The concept of an object-oriented interface is encapsulated in a trait in Scala.
    Similarly to an interface, a trait can have abstract members. However, unlike
    Java interfaces, traits may also have concrete members. These are injected into
    the implementing classes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中面向对象接口的概念封装在一个特质中。与接口类似，特质可以有抽象成员。然而，与Java接口不同，特质也可以有具体成员。这些成员将被注入到实现类中：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like in Java, Scala classes can implement more than one trait. However,
    since traits in Scala can have concrete members, a new inheritance model that
    allows for that is required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Java中一样，Scala类可以实现多个特质。然而，由于Scala中的特质可以有具体成员，因此需要一个允许这种情况的新继承模型。
- en: 'In Scala, a so-called linearization model is implemented. This means that whenever
    a class is inherited from multiple traits, they are organized into a clear sequence,
    which determines the priority of inheritance. For example, consider the following
    inheritance case:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，实现了一个所谓的线性化模型。这意味着每当一个类从多个特质继承时，它们将被组织成一个清晰的序列，这决定了继承的优先级。例如，考虑以下继承情况：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the `Bar` trait will get a priority over the `Foo` trait. This
    allows you to inherit from multiple traits and be aware of the precise sequence
    in which they will be applied.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Bar`特质将优先于`Foo`特质。这允许您从多个特质中继承，并了解它们将被应用的精确顺序。
- en: Singleton objects
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例对象
- en: 'In Scala, it is impossible to make a class have static members. However, the
    concept of a static member is present in Java. Since Scala compiles to JVM, it
    needs a way to model this concept from Java. In Scala, a concept of a singleton
    object is used to model static members:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，无法使一个类具有静态成员。然而，静态成员的概念存在于Java中。由于Scala编译到JVM，它需要一种方式来模拟这个概念。在Scala中，使用单例对象的概念来模拟静态成员：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we can call the members of the singleton object without
    instantiating it or doing anything else with it, directly by its name. This is
    because it is a standalone fully fledged object that is constructed by our `object`
    statement. It exists in a single instance for the entire JVM.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以直接通过其名称调用单例对象的成员，而无需实例化它或对其进行其他操作。这是因为它是一个由我们的`object`语句构建的独立完整对象。它在整个JVM中只有一个实例存在。
- en: The concept of a singleton object can be leveraged to model static members from
    Java. In Scala, there is a concept of a so-called companion object of a trait
    or a class. For any trait or class, if you define an object with the same name
    as the entity in question, it is considered a companion object to it. All of the
    static members of this class are defined as members of this singleton object.
    This allows you a clear separation between object and types. No longer can you
    call a member of a class without instantiating it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 单例对象的概念可以用来模拟Java中的静态成员。在Scala中，有一个所谓的特质的伴生对象或类的概念。对于任何特质或类，如果您定义了一个与问题实体同名的对象，它就被认为是它的伴生对象。这个类的所有静态成员都被定义为这个单例对象的成员。这允许您在对象和类型之间进行清晰的分离。您不再能够在不实例化它的情况下调用类的成员。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a brief overview of the Scala programming language,
    in which the examples in this book are implemented. First of all, we have motivated
    the usage of Scala as an example language by the fact that it supports a wide
    range of programming styles.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对Scala编程语言进行了简要概述，本书中的示例都是用Scala实现的。首先，我们通过Scala支持广泛的编程风格这一事实来激发使用Scala作为示例语言。
- en: Next, we had a look at what makes Scala different from other languages. Please
    keep in mind that this section is meant as a brief overview of the language, and
    you should use more comprehensive tutorials if you are interested in finding out
    more about Scala.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看了一下Scala与其他语言的不同之处。请记住，本节旨在对语言进行简要概述，如果您想了解更多关于Scala的信息，请使用更全面的教程。
