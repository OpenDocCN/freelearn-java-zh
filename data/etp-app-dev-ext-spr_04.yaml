- en: Chapter 4. Data Access Made Easy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 数据访问变得简单
- en: '**The Data Access Object** (**DAO**) design pattern is a simple and elegant
    way of abstracting database persistence from application business logic. This
    design ensures a clear separation of the two core parts of any enterprise application:
    the data access layer and the service (or business logic) layer. The DAO pattern
    is a well-understood Java EE programming structure, initially brought to prominence
    by Sun Microsystems in its Java EE Design Blueprints that has since been adopted
    by other programming environments such as the .NET framework.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问对象（DAO）设计模式是一种简单而优雅的方式，将数据库持久性与应用程序业务逻辑抽象出来。这种设计确保了企业应用程序的两个核心部分的清晰分离：数据访问层和服务（或业务逻辑）层。DAO模式是一种广为人知的Java
    EE编程结构，最初由Sun Microsystems在其Java EE设计蓝图中引起关注，后来被其他编程环境如.NET框架所采用。
- en: 'The following image illustrates where the DAO layer sits in the overall application
    structure:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片说明了DAO层在整个应用程序结构中的位置：
- en: '![Data Access Made Easy](img/5457_04_05.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![数据访问变得简单](img/5457_04_05.jpg)'
- en: Changing an implementation in the DAO layer should not affect the service layer
    in any way. This is achieved by defining DAO interfaces to encapsulate the persistence
    operations that the service layer can access. The DAO implementation itself is
    hidden to the service layer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在DAO层更改实现不应以任何方式影响服务层。这是通过定义DAO接口来实现的，以封装服务层可以访问的持久性操作。DAO实现本身对服务层是隐藏的。
- en: Defining the DAO interfaces
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义DAO接口
- en: An interface in the Java programming language defines a set of method signatures
    and constant declarations. Interfaces expose behaviors (or *what* can be done)
    and define a contract that implementing classes promise to provide (*how* it is
    done). Our DAO layer will contain one interface and one implementing class per
    domain object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言中的接口定义了一组方法签名和常量声明。接口公开行为（或*可以做什么）并定义了实现类承诺提供的合同（*如何做）。我们的DAO层将包含每个域对象一个接口和一个实现类。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of interfaces is an often misunderstood pattern in enterprise programming.
    The argument goes along the line, "Why add another set of Java objects to your
    codebase when they are not required". Interfaces do add to the number of lines
    of code that you write, but their beauty will be appreciated as soon as you are
    asked to refactor an aging project that was written with interfaces from the start.
    I have migrated an SQL-based persistence layer to a JPA persistence layer. The
    new DAO implementation replaced the old without any significant change in the
    service layer, thanks to the use of interfaces. Development was done in parallel
    to supporting the existing (old) implementation until we were ready to swap in
    the new implementation. This was a relatively painless process that would not
    have been as easily achieved without the use of interfaces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的使用在企业编程中经常被误解。有人认为，“为什么在代码库中添加另一组Java对象，当它们并不是必需的时候”。接口确实增加了你编写的代码行数，但它们的美妙之处将在你被要求重构一个使用接口编写的老项目时得到赞赏。我曾将基于SQL的持久性层迁移到JPA持久性层。新的DAO实现替换了旧的实现，而服务层几乎没有发生任何重大变化，这要归功于接口的使用。开发是并行进行的，同时支持现有（旧的）实现，直到我们准备好切换到新的实现。这是一个相对轻松的过程，如果没有接口的使用，就不会那么容易实现。
- en: Let's start with the company interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从公司接口开始。
- en: Adding the CompanyDao interface
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CompanyDao接口
- en: Navigate to **File** | **New File** from the menu and select **Java Interface**
    as shown in the following screenshot:![Adding the CompanyDao interface](img/5457_04_01.jpg)
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中导航到“文件”|“新建文件”，并选择“Java接口”，如下截图所示：![添加CompanyDao接口](img/5457_04_01.jpg)
- en: Click on the **Next** button and fill in the details as shown in the following
    screenshot:![Adding the CompanyDao interface](img/5457_04_02.jpg)
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮，并按照以下截图中显示的方式填写详细信息：![添加CompanyDao接口](img/5457_04_02.jpg)
- en: The name of the interface is `CompanyDao`. We could have named this interface
    using the uppercase acronym `CompanyDAO`. In keeping with the newer Java EE naming
    styles, we have decided to use the camel case form of the acronym. Recent examples
    of this style include the `Html`*, `Json`*, and `Xml`* classes and interfaces,
    an example of which is `javax.json.JsonObject`. We also believe that this form
    is easier to read. However, this does not prohibit you from using the uppercase
    acronym; there are many of these examples in Java EE as well (`EJB`*, `JAXB`*,
    and `JMS`* interfaces and classes to name a few). Whatever you choose, be consistent.
    Do not mix forms and create `CompanyDAO` and `ProjectDao` interfaces!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的名称是`CompanyDao`。我们本可以使用大写首字母缩写`CompanyDAO`来命名此接口。为了符合较新的Java EE命名风格，我们决定使用驼峰式缩写形式。最近的例子包括`Html`*、`Json`*和`Xml`*类和接口，例如`javax.json.JsonObject`。我们也相信这种形式更容易阅读。但是，这并不妨碍您使用大写首字母缩写；在Java
    EE中也有许多这样的例子（`EJB`*、`JAXB`*和`JMS`*接口和类等）。无论您选择哪种形式，都要保持一致。不要混合形式，创建`CompanyDAO`和`ProjectDao`接口！
- en: Note that the package `com.gieman.tttracker.dao` does not exist yet and will
    be created for you. Click on **Finish** to create your first interface, after
    which NetBeans will open the file in the editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包`com.gieman.tttracker.dao`目前还不存在，将由系统为您创建。点击“完成”以创建您的第一个接口，之后NetBeans将在编辑器中打开该文件。
- en: '![Adding the CompanyDao interface](img/5457_04_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![添加CompanyDao接口](img/5457_04_03.jpg)'
- en: 'The Company interface will define the persistence methods that we will use
    in our application. The core methods must include the ability to perform each
    CRUD operation in addition to any other operations appropriate to our business
    needs. We will add the following methods to this interface:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 公司接口将定义我们在应用程序中将使用的持久性方法。核心方法必须包括执行每个CRUD操作的能力，以及适合我们业务需求的任何其他操作。我们将在此接口中添加以下方法：
- en: '`persist`: This method inserts a new company record'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persist`：此方法插入新的公司记录'
- en: '`merge`: This method updates an existing company record'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`：此方法更新现有的公司记录'
- en: '`remove`: This method deletes a company record'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：这个方法删除公司记录'
- en: '`find`: This method selects a company record using a primary key'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`：这个方法使用主键选择公司记录'
- en: '`findAll`: This method returns all the company records'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAll`：这个方法返回所有公司记录'
- en: 'Note that the JPA terminologies `persist`, `merge`, `remove`, and `find` are
    equivalent to the SQL operations `insert`, `update`, `delete`, and `select`. Add
    the methods to `CompanyDao` as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JPA术语`persist`、`merge`、`remove`和`find`等同于SQL操作`insert`、`update`、`delete`和`select`。按照以下代码将这些方法添加到`CompanyDao`中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have defined a contract that the implementing class must promise to deliver.
    We will now add the `ProjectDao` interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了实现类必须承诺提供的契约。现在我们将添加`ProjectDao`接口。
- en: Adding the ProjectDao interface
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ProjectDao接口
- en: 'The `ProjectDao` interface will define a similar set of methods to the `CompanyDao`
    interface:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectDao`接口将定义一组类似于`CompanyDao`接口的方法：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will note that all method signatures in the `ProjectDao` interface are
    identical to the `CompanyDao` interface. The only difference is in class types
    where `Company` is replaced by `project`. The same situation will occur in all
    the other interfaces that we are going to add (`TaskDao`, `UserDao`, and `TaskLogDao`).
    Each of the interfaces will require a definition for the `find` method that will
    look like the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`ProjectDao`接口中的所有方法签名与`CompanyDao`接口中的完全相同。唯一的区别在于类类型，其中`Company`被`project`替换。在我们将要添加的所有其他接口（`TaskDao`、`UserDao`和`TaskLogDao`）中，情况也是如此。每个接口都需要一个`find`方法的定义，看起来像下面的代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the only functional difference in each of these methods is the
    returned type. The same can be said for the `persist`, `merge`, and `remove` methods.
    This situation lends itself perfectly to the use of Java generics.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个方法的唯一功能区别是返回类型。对于`persist`、`merge`和`remove`方法也是如此。这种情况非常适合使用Java泛型。
- en: Defining a generic DAO interface
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个通用的DAO接口
- en: This interface will be extended by each of our DAO interfaces. The `GenericDao`
    interface uses generics to define each method in a way that can be used by each
    descendent interface. These methods will then be available free of cost to the
    extending interfaces. Rather than defining a `find(Integer id)` method in each
    of the `CompanyDao`, `ProjectDao`, `TaskDao`, `UserDao`, and `TaskLogDao` interfaces,
    the `GenericDao` interface defines the generic method that is then available for
    all descendants.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口将被我们的每个DAO接口扩展。`GenericDao`接口使用泛型来定义每个方法，以便可以被每个后代接口使用。然后这些方法将免费提供给扩展接口。与在`CompanyDao`、`ProjectDao`、`TaskDao`、`UserDao`和`TaskLogDao`接口中定义`find(Integer
    id)`方法不同，`GenericDao`接口定义了通用方法，然后这些方法对所有后代接口都可用。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a powerful technique for enterprise application programming and should
    always be considered when designing or architecting an application framework.
    A well-structured design using Java generics will simplify change requests and
    maintenance for many years to come.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的企业应用程序编程技术，应该在设计或构建应用程序框架时始终考虑。使用Java泛型的良好结构设计将简化多年来的变更请求和维护。
- en: 'The generic interface definition looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通用接口定义如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now refactor the `CompanyDao` interface as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按照以下方式重构`CompanyDao`接口：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the way in which we have extended the `GenericDao` interface using the
    `<Company, Integer>` types. The type parameters `<T, ID>` in the `GenericDao`
    interface become placeholders for the types specified in the `CompanyDao` definition.
    A `T` or `ID` that is found in the `GenericDao` interface will be replaced with
    `Company` and `Integer` in the `CompanyDao` interface. This automatically adds
    the `find`, `persist`, `merge`, and `remove` methods to `CompanyDao`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`<Company, Integer>`类型扩展了`GenericDao`接口。`GenericDao`接口中的类型参数`<T, ID>`成为了`CompanyDao`定义中指定的类型的占位符。在`CompanyDao`接口中，`GenericDao`接口中找到的`T`或`ID`将被替换为`Company`和`Integer`。这会自动将`find`、`persist`、`merge`和`remove`方法添加到`CompanyDao`中。
- en: Generics allow the compiler to check type correctness at compile-time. This
    improves code robustness. A good explanation of Java generics can be found at
    [http://docs.oracle.com/javase/tutorial/extra/generics/index.html](http://docs.oracle.com/javase/tutorial/extra/generics/index.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许编译器在编译时检查类型正确性。这提高了代码的健壮性。关于Java泛型的良好解释可以在[http://docs.oracle.com/javase/tutorial/extra/generics/index.html](http://docs.oracle.com/javase/tutorial/extra/generics/index.html)找到。
- en: 'In a similar way, we can now refactor the `ProjectDao` interface:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们现在可以重构`ProjectDao`接口：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's continue with the missing interfaces in the same manner.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以相同的方式继续添加缺失的接口。
- en: The TaskDao interface
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskDao接口
- en: 'Apart from the common generic methods, we will once again need a `findAll`
    method. This interface looks like the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用的泛型方法，我们还需要一个`findAll`方法。这个接口看起来像下面的代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The UserDao interface
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserDao接口
- en: 'We will need a list of all the users in the system as well as a few finder
    methods to identify a user by different parameters. These methods will be required
    when we develop our frontend user interfaces and service layer functionality.
    The `UserDao` interface looks like the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要系统中所有用户的列表，以及一些查找方法来根据不同的参数识别用户。当我们开发前端用户界面和服务层功能时，将需要这些方法。`UserDao`接口看起来像下面的代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the `UserDao` interface extends `GenericDao` with a `String` ID type.
    This is because the `User` domain entity has a `String` primary key type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`UserDao`接口使用`String` ID类型扩展了`GenericDao`。这是因为`User`领域实体具有`String`主键类型。
- en: The TaskLogDao interface
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskLogDao接口
- en: The `TaskLogDao` interface will also need a few additional methods to be defined
    in order to allow different views into the task log data. These methods will once
    again be required when we develop our frontend user interfaces and service layer
    functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskLogDao`接口还需要定义一些额外的方法，以便允许对任务日志数据进行不同的查看。当我们开发前端用户界面和服务层功能时，这些方法将再次被需要。'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that our finder methods for the `TaskLogDao` interface have descriptive
    names that identify the purpose of the method. Each finder method will be used
    to retrieve a subset of task log entries that are appropriate for the business
    needs of the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为`TaskLogDao`接口的查找方法命名具有描述性的名称，以标识方法的目的。每个查找方法将用于检索适合应用程序业务需求的任务日志条目的子集。
- en: This covers all the required interfaces for our application. It is now time
    to define the implementations for each of our interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们应用程序所需的所有接口。现在是时候为我们的每个接口定义实现了。
- en: Defining the generic DAO implementation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义通用的DAO实现
- en: 'We will once again use Java generics to define a common ancestor class that
    will be extended by each of our implementation classes (`CompanyDaoImpl`, `ProjectDaoImpl`,
    `TaskDaoImpl`, `TaskLogDaoImpl`, and `UserDaoImpl`). The `GenericDaoImpl` and
    all other implementing classes will be added to the same `com.gieman.tttracker.dao`
    package as our DAO interfaces. Key lines of code in `GenericDaoImpl` are highlighted
    and will be explained in the following sections:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Java泛型来定义一个通用的祖先类，该类将由我们的每个实现类（`CompanyDaoImpl`、`ProjectDaoImpl`、`TaskDaoImpl`、`TaskLogDaoImpl`和`UserDaoImpl`）扩展。`GenericDaoImpl`和所有其他实现类将被添加到与我们的DAO接口相同的`com.gieman.tttracker.dao`包中。`GenericDaoImpl`中的关键代码行已经突出显示，并将在接下来的章节中进行解释：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a lot of new concepts in this class! Let's tackle them one at a time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中有很多新概念！让我们一次解决一个。
- en: The Simple Logging Facade for Java
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java的简单日志门面
- en: The Simple Logging Facade for Java or SLF4J is a simple abstraction for key
    logging frameworks including `java.util.logging`, `log4j` and `logback`. SLF4J
    allows the end user to plug in the desired logging framework at deployment time
    by simply including the appropriate implementation library. More information about
    SLF4J can be found at [http://slf4j.org/manual.html](http://slf4j.org/manual.html).
    Logging not only allows developers to debug code, but it can also provide a permanent
    record of actions and application state within your application. Examples of application
    state could be current memory usage, the number of authorized users currently
    logged on, or the number of pending messages awaiting processing. Log files are
    usually the first place to look at when analyzing production bugs, and they are
    an important component of any enterprise application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java的简单日志门面或SLF4J是对关键日志框架（包括`java.util.logging`、`log4j`和`logback`）的简单抽象。SLF4J允许最终用户在部署时通过简单地包含适当的实现库来插入所需的日志记录框架。有关SLF4J的更多信息可以在[http://slf4j.org/manual.html](http://slf4j.org/manual.html)找到。日志记录不仅允许开发人员调试代码，还可以提供应用程序内部操作和状态的永久记录。应用程序状态的示例可能是当前内存使用情况、当前已经登录的授权用户数量或等待处理的挂起消息数量。在分析生产错误时，日志文件通常是首要查看的地方，它们是任何企业应用程序的重要组成部分。
- en: Although the default Java logging is adequate for simple uses, it would not
    be appropriate for more sophisticated applications. The `log4J` framework ([http://logging.apache.org/log4j/1.2](http://logging.apache.org/log4j/1.2))
    and the `logback` framework ([http://logback.qos.ch](http://logback.qos.ch)) are
    examples of highly configurable logging frameworks. The `logback` framework is
    usually considered the successor of `log4j` as it offers some key advantages over
    `log4j` including better performance, less memory consumption, and automatic reloading
    of configuration files. We will use `logback` in our application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认的Java日志记录对于简单的用途已经足够，但对于更复杂的应用程序来说就不合适了。`log4J`框架（[http://logging.apache.org/log4j/1.2](http://logging.apache.org/log4j/1.2)）和`logback`框架（[http://logback.qos.ch](http://logback.qos.ch)）是高度可配置的日志记录框架的例子。`logback`框架通常被认为是`log4j`的继任者，因为它在性能、内存消耗和配置文件的自动重新加载等方面都比`log4j`具有一些关键优势。我们将在我们的应用程序中使用`logback`。
- en: 'The required SLF4J and `logback` libraries will be added to the application
    by adding the following dependency to `pom.xml`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下依赖项添加到`pom.xml`中，所需的SLF4J和`logback`库将被添加到应用程序中：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will also need to add the additional `logback.version` property to `pom.xml`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将额外的`logback.version`属性添加到`pom.xml`中：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now perform a **Clean and Build Project** to download the `logback-classic`,
    `logback-core`, and `slf4j-api` JAR files. This will then enable us to add the
    imports defined in `GenericDaoImpl` as well as the logger definition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以执行**清理和构建项目**以下载`logback-classic`、`logback-core`和`slf4j-api` JAR文件。这将使我们能够添加`GenericDaoImpl`中定义的导入以及日志记录器定义：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All descendent classes will now be able to use the logger (it is declared as
    `protected`) but will not be able to change it (it is declared as `final`). We
    will start using the logger in [Chapter 5](ch05.html "Chapter 5. Testing the DAO
    Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and JUnit*,
    where we will examine the `logback.xml` configuration file in detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后代类现在都可以使用日志记录器（它被声明为`protected`），但不能更改它（它被声明为`final`）。我们将在[第5章](ch05.html
    "第5章。使用Spring和JUnit测试DAO层")中开始使用日志记录器，*使用Spring和JUnit测试DAO层*，在那里我们将详细检查`logback.xml`配置文件。
- en: The@PersistenceContext(unitName = "tttPU") line
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@PersistenceContext(unitName = "tttPU")行'
- en: This one line annotating the `EntityManager` interface method is all that's
    required for Spring Framework to plug in or inject the `EclipseLink` implementation
    during runtime. The `EntityManager` interface defines methods for interacting
    with the persistence context such as `persist`, `merge`, `remove`, and `find`.
    A full listing of the `EntityManager` interface methods can be found at [http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html](http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行注释`EntityManager`接口方法是Spring框架在运行时插入或注入`EclipseLink`实现所需的全部。`EntityManager`接口定义了与持久化上下文交互的方法，如`persist`、`merge`、`remove`和`find`。`EntityManager`接口方法的完整列表可以在[http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html](http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html)找到。
- en: Our persistence context is defined in `persistence.xml` in which we have named
    it as `tttPU`. This is what binds `EntityManager` in `GenericDaoImpl` to the persistence
    context through the `@PersistenceContext` annotation `unitName` property. A persistence
    context is a set of entity instances (in our application, these are the `Company`,
    `Project`, `Task`, `User`, and `TaskLog` objects) in which, for any persistent
    entity, there is a unique entity instance. Within the persistence context, the
    entity instances and their lifecycle is managed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的持久化上下文在`persistence.xml`中定义，我们将其命名为`tttPU`。这是将`GenericDaoImpl`中的`EntityManager`与持久化上下文绑定的方式，通过`@PersistenceContext`注解的`unitName`属性。持久化上下文是一组实体实例（在我们的应用程序中，这些是`Company`、`Project`、`Task`、`User`和`TaskLog`对象），对于任何持久实体，都有一个唯一的实体实例。在持久化上下文中，实体实例及其生命周期是受管理的。
- en: The `EntityManager` API is used to create and remove persistent entity instances,
    to find entities by their primary key, and to query over entities. In our `GenericDaoImpl`
    class, the `EntityManager` instance `em` is used to perform the generic CRUD operations.
    Each descendent class will hence have access to these methods as well as the `em`
    instance itself (it is declared as protected).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager` API用于创建和删除持久化实体实例，按主键查找实体，以及对实体进行查询。在我们的`GenericDaoImpl`类中，`EntityManager`实例`em`用于执行通用的CRUD操作。因此，每个子类都将可以访问这些方法以及`em`实例本身（它被声明为protected）。'
- en: The @Transactional annotation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`@Transactional`注解'
- en: The `@Transactional` annotation is the cornerstone of Spring's declarative transaction
    management. It allows you to specify transactional behavior at an individual method
    level and is very simple to use. This option has the least impact on application
    code, and it does not require any complex configuration. In fact, it is completely
    non-invasive as there is no Java coding required for commits and rollbacks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`注解是Spring声明式事务管理的基石。它允许您在单个方法级别指定事务行为，并且非常简单易用。这个选项对应用程序代码的影响最小，不需要任何复杂的配置。事实上，它完全是非侵入性的，因为不需要Java编码来进行提交和回滚。'
- en: 'Spring recommends that you only annotate classes (and methods of classes) with
    the `@Transactional` annotation as opposed to annotating interfaces (a full explanation
    can be found at [http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html](http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html)).
    For this reason, we will annotate all appropriate methods in the generic and implementing
    classes with one of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring建议只对类（和类的方法）使用`@Transactional`注解，而不是对接口进行注解（完整的解释可以在[http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html](http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html)找到）。因此，我们将对通用和实现类中的所有适当方法使用以下之一的注解：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `@Transactional` annotation is metadata that specifies that a method must
    have transactional semantics. For example, we could define metadata that defines
    starting a brand new read-only transaction when this method is invoked, suspending
    any existing transaction. The default `@Transactional` settings are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`注解是指定方法必须具有事务语义的元数据。例如，我们可以定义元数据，定义在调用此方法时启动全新的只读事务，挂起任何现有事务。默认的`@Transactional`设置如下：'
- en: '`propagation` setting is `Propagation.REQUIRED`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `propagation`设置为`Propagation.REQUIRED`'
- en: '`readOnly` is false'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `readOnly`为false'
- en: It is a good practice to define all properties including default settings, as
    we have done previously. Let's examine these properties in detail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义所有属性，包括默认设置，是一个好习惯，就像我们之前做的那样。让我们详细地检查这些属性。
- en: The Propagation.REQUIRED property
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Propagation.REQUIRED属性
- en: It is the default value for transactions that do not specify a `propagation`
    setting. This property supports a current transaction if one exists or creates
    a new one if none exists. This ensures that the `Propagation.REQUIRED` annotated
    method will always have a valid transaction available and should be used whenever
    the data is modified in the persistence storage. This property is usually combined
    with `readOnly=false`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '- 默认值为不指定`propagation`设置的事务。如果存在当前事务，则支持此属性，如果不存在事务，则创建一个新的事务。这确保了`Propagation.REQUIRED`注解的方法始终有一个有效的事务可用，并且应该在持久化存储中修改数据时使用。这个属性通常与`readOnly=false`结合使用。'
- en: The Propagation.SUPPORTS property
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '- Propagation.SUPPORTS属性'
- en: This property supports a current transaction if one exists or executes non-transactionally
    if none exists. The `Propagation.SUPPORTS` property should be used if the annotated
    method does not modify the data (will not execute an `insert`, `update`, or `delete`
    statement against the database). This property is usually combined with `readOnly=true`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在当前事务，则支持此属性，如果不存在事务，则以非事务方式执行。如果注解的方法不修改数据（不会对数据库执行insert、update或delete语句），则应该使用`Propagation.SUPPORTS`属性。这个属性通常与`readOnly=true`结合使用。
- en: The readOnly property
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: readOnly属性
- en: This just serves as a hint for the actual transaction subsystem to allow optimization
    of executed statements if possible. It may be possible that the transaction manager
    may not be able to interpret this property. For self-documenting code, however,
    it is a good practice to include this property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个提示，用于实际事务子系统，以便在可能的情况下优化执行的语句。可能事务管理器无法解释此属性。然而，对于自我记录的代码来说，包含此属性是一个很好的做法。
- en: Other transaction properties
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他事务属性
- en: Spring allows us to fine-tune transactional properties with additional options
    that are beyond the scope of this book. Browse the link that was mentioned earlier
    to find out more about how transactions can be managed in more complex scenarios
    including multiple transactional resources.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring允许我们使用额外的选项来微调事务属性，这超出了本书的范围。浏览之前提到的链接，了解更多关于如何在更复杂的情况下管理事务的信息，包括多个事务资源。
- en: Defining the DAO implementations
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义DAO实现
- en: The following DAO implementations will inherit the core CRUD operations from
    `GenericDaoImpl` and add their own class-specific methods as defined in the implemented
    interface. Each method will use the `@Transactional` annotation to define the
    appropriate transactional behavior.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下DAO实现将从`GenericDaoImpl`继承核心CRUD操作，并根据实现的接口添加自己的特定于类的方法。每个方法将使用`@Transactional`注解来定义适当的事务行为。
- en: The CompanyDaoImpl class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CompanyDaoImpl`类'
- en: 'The full listing for our `CompanyDaoImpl` class is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CompanyDaoImpl`类的完整列表如下：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first thing to notice is the `@Repository("companyDao")` annotation. This
    annotation is used by Spring to automatically detect and process DAO objects when
    the application is loaded. The Spring API defines this annotation as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是`@Repository("companyDao")`注解。这个注解被Spring用来在应用程序加载时自动检测和处理DAO对象。Spring
    API将这个注解定义如下：
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It indicates that an annotated class is a `Repository`, originally defined by
    Domain-Driven Design (Evans, 2003) as a mechanism for encapsulating storage, retrieval,
    and search behavior that emulate a collection of objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示一个带注解的类是一个`Repository`，最初由领域驱动设计（Evans, 2003）定义为一种模拟对象集合的存储、检索和搜索行为的机制。
- en: The purpose of the annotation is to allow Spring to auto detect implementing
    classes through the `classpath` scanning and to process this class for data access
    exception translation (used by Spring to abstract database exception messages
    from the underlying implementation). The Spring application will then hold a reference
    to the implementing class under the key `companyDao`. It is considered as the
    best practice to match the key value with the name of the implemented interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注解的目的是允许Spring通过`classpath`扫描自动检测实现类，并处理该类以进行数据访问异常转换（Spring用于将数据库异常消息从底层实现中抽象出来）。Spring应用程序将持有实现类的引用，键为`companyDao`。最佳实践是将键值与实现的接口名称匹配。
- en: 'The `CompanyDaoImpl` class also introduces the use of the JPA named queries
    that were defined during the reverse engineering process in the previous chapter.
    The method call `em.createNamedQuery("Company.findAll")` creates the named query
    defined by the unique identifier `"Company.findAll"` in the persistence engine.
    This named query was defined in the `Company` class. Calling `getResultList()`
    executes the query against the database, returning a `java.util.List` of Company
    objects. Let''s now review the named query definition in the `Company` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyDaoImpl`类还引入了在上一章的反向工程过程中定义的JPA命名查询的使用。方法调用`em.createNamedQuery("Company.findAll")`创建了持久化引擎中由唯一标识符`"Company.findAll"`定义的命名查询。这个命名查询是在`Company`类中定义的。调用`getResultList()`执行了针对数据库的查询，返回了一个`java.util.List`的Company对象。现在让我们来审查一下`Company`类中的命名查询定义：'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will make a minor change to this named query to arrange the results by `companyName`
    in ascending order. This will require the addition of an `ORDER BY` clause in
    the query statement. The final named queries definition in the `Company` class
    will now look like the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个命名查询进行微小的更改，以按照`companyName`的升序排列结果。这将需要在查询语句中添加`ORDER BY`子句。`Company`类中的最终命名查询定义现在看起来像以下代码：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ProjectDaoImpl class
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ProjectDaoImpl`类'
- en: 'This implementation is defined as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现被定义为：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once again, we will add the `ORDER BY` clause to the `Project.findAll` named
    query in the Project class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在`Project`类的`Project.findAll`命名查询中添加`ORDER BY`子句：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The TaskDaoImpl class
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TaskDaoImpl`类'
- en: 'This class is defined as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被定义为：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again, we will add the `ORDER BY` clause to the `Task.findAll` named query
    in the Task class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在`Task`类的`Task.findAll`命名查询中添加`ORDER BY`子句：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The UserDaoImpl class
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UserDaoImpl`类'
- en: 'This `UserDaoImpl` class will require an additional named query in the `User`
    domain class to test a user''s logon credentials (username/password combination).
    The `UserDaoImpl` class definition follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`UserDaoImpl`类将需要在`User`领域类中添加一个额外的命名查询，以测试用户的登录凭据（用户名/密码组合）。`UserDaoImpl`类的定义如下：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The missing named query is `User.findByUsernamePassword` that is used to verify
    a user with the given username and password. The query definition must be added
    to the `User` class as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的命名查询是`User.findByUsernamePassword`，用于验证具有给定用户名和密码的用户。查询定义必须添加到`User`类中，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this definition allows a user to be matched by either the username
    or e-mail field. As is the common practice in web applications, a user may log
    on with either their unique logon name (username) or their e-mail address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个定义允许用户通过用户名或电子邮件字段进行匹配。正如在Web应用程序中的常见做法一样，用户可以使用他们的唯一登录名（用户名）或他们的电子邮件地址进行登录。
- en: 'The `findByEmail`, `findByUsername`, and `findByUsernamePassword` methods can
    only ever return `null` (no match found) or a single result as there cannot be
    more than one record in the database with these unique fields. Instead of using
    the `getResultList()` method to retrieve a `List` of results and testing for a
    list size of one, we could have used the code that is similar to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`findByEmail`、`findByUsername`和`findByUsernamePassword`方法只能返回`null`（未找到匹配）或单个结果，因为数据库中这些唯一字段不可能有多条记录。我们可以使用类似以下的代码来代替使用`getResultList()`方法来检索结果列表并测试列表大小是否为一：'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `getSingleResult()` method returns exactly one result or throws an exception
    if a single result could not be found. You will also notice the need to cast the
    returned result to the required `User` type. The calling method would also need
    to catch any exceptions that would be thrown from the `getSingleResult()` method
    unless the sample code given previously is changed to catch the exception.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSingleResult()`方法返回确切的一个结果，如果找不到单个结果，则会抛出异常。您还会注意到需要将返回的结果转换为所需的`User`类型。调用方法还需要捕获从`getSingleResult()`方法抛出的任何异常，除非之前给出的示例代码更改为捕获异常。'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We believe that the code in our `UserDaoImpl` interface is cleaner than the
    previous example that uses the `try`/`catch` function to wrap the `getSingleResult()`
    method. In both cases, however, the method returns `null` if the record cannot
    be found.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信我们的`UserDaoImpl`接口中的代码比使用`try`/`catch`函数包装`getSingleResult()`方法的先前示例更清晰。然而，在两种情况下，如果找不到记录，该方法都会返回`null`。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exceptions should be used judiciously in enterprise programming and only for
    truly exceptional circumstances. Throwing exceptions should be avoided unless
    the exception indicates a situation that the calling code cannot recover from.
    It is far cleaner to return `null` (or perhaps true/false in appropriate scenarios)
    to indicate that a situation is not as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业编程中应谨慎使用异常，只能在真正的异常情况下使用。除非异常表示调用代码无法恢复的情况，否则应避免抛出异常。如果情况不如预期，返回`null`（或者在适当的情况下返回true/false）会更清晰。
- en: We do not consider being unable to find a record by ID, or by e-mail or by e-mail
    address as an exceptional circumstance; it is possible that a different user has
    deleted the record, or there is simply no record with the e-mail specified. Returning
    `null` clearly identifies that the record was not found without the need to throw
    an exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不认为无法按ID或电子邮件或电子邮件地址找到记录是一个异常情况；可能是不同的用户已删除了记录，或者根本没有使用指定电子邮件的记录。返回`null`清楚地表明未找到记录，而无需抛出异常。
- en: 'Regardless of whether you throw exceptions to indicate a record that cannot
    be found or use `null` as is our preference, your API should be documented to
    indicate the behavior. The `UserDaoImpl.findByUsernamePassword` method could,
    for example, be documented as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是抛出异常来指示找不到记录，还是使用`null`作为我们的首选，您的API都应该记录下行为。例如，`UserDaoImpl.findByUsernamePassword`方法可以记录如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Users of your API will then understand the expected behavior and code their
    interactions accordingly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API的用户将了解预期的行为并相应地编写其交互。
- en: The TaskLogDaoImpl class
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TaskLogDaoImpl`类'
- en: 'The final DAO class in our application follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的最终DAO类如下：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, we will refactor the `TaskLog` named queries as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将重构`TaskLog`命名查询如下：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have removed several queries that will not be required and added three new
    ones as shown. The `TaskLog.findByUser` query will be used to list task logs assigned
    to a user for the given date range. Note the use of the `BETWEEN` key word to
    specify the date range. Also note the use of the `TemporalType.DATE` when setting
    the parameter in the `TaskLogDaoImpl.findByUser` method. This will ensure a strict
    date comparison, ignoring any time component, if present, in the arguments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已删除几个不需要的查询，并添加了三个新的查询，如所示。`TaskLog.findByUser`查询将用于列出分配给用户的任务日志的给定日期范围。请注意在`TaskLogDaoImpl.findByUser`方法中设置参数时，使用`TemporalType.DATE`来确保严格的日期比较，忽略任何时间组件（如果存在）。
- en: The `TaskLog.findTaskLogCountByTask` and `TaskLog.findTaskLogCountByUser` named
    queries will be used in our service layer to test if deletions are permitted.
    We will implement checks to ensure that a user or a task may not be deleted if
    valid task logs are assigned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskLog.findTaskLogCountByTask`和`TaskLog.findTaskLogCountByUser`命名查询将在我们的服务层中用于测试是否允许删除。我们将实施检查以确保如果分配了有效的任务日志，则用户或任务可能不会被删除。'
- en: A better domain layer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的领域层
- en: 'Let''s now revisit the domain layer created in [Chapter 3](ch03.html "Chapter 3. Reverse
    Engineering the Domain Layer with JPA"), *Reverse Engineering the Domain Layer
    with JPA*. Defining an ancestor class for all entities in this layer is not only
    the best practice but will also make our domain layer far easier to enhance in
    the future. Our ancestor class is defined as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在重新审视在[第3章](ch03.html "第3章。使用JPA逆向工程领域层")中创建的领域层，*使用JPA逆向工程领域层*。为这一层中的所有实体定义一个祖先类不仅是最佳实践，而且还将使我们的领域层在未来更容易增强。我们的祖先类定义如下：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although this class has an empty implementation, we will add functionality in
    subsequent chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个类有一个空的实现，但我们将在随后的章节中添加功能。
- en: 'We will also define an appropriate interface that has one generic method to
    return the ID of the entity:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个适当的接口，该接口具有一个通用方法来返回实体的ID：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our domain layer can now extend our base `AbstractEntity` class and implement
    the `EntityItem` interface. The changes required to our `Company` class follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域层现在可以扩展我们的基本`AbstractEntity`类并实现`EntityItem`接口。对我们的`Company`类所需的更改如下：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In a similar way, we can change the remaining domain classes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以更改剩余的领域类：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now be well prepared for future changes in the domain layer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为领域层中的未来变更做好充分准备。
- en: Exercise – a simple change request
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-一个简单的变更请求
- en: 'This simple exercise will again demonstrate the power of generics. Each record
    inserted into the database should now be logged at using `logger.info()` with
    the message:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的练习将再次展示泛型的强大。现在，插入到数据库中的每条记录都应该使用`logger.info()`记录日志，消息为：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In addition, records that are deleted should be logged using `logger.warn()`
    with the message:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，删除的记录应该使用`logger.warn()`记录日志，消息为：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In both cases, the `?` token should be replaced with the ID of the entity being
    inserted or deleted while the `className` token should be replaced with the class
    name of the entity being inserted or deleted. This is a trivial change when using
    generics, as the code can be added to the `persist` and `remove` methods of the
    `GenericDaoImpl` class. Without the use of generics, each of the `CompanyDaoImpl`,
    `ProjectDaoImpl`, `TaskDaoImpl`, `UserDaoImpl`, and `TaskLogDaoImpl` classes would
    need to have this change made. When you consider that enterprise applications
    may have 20, 30, 40, or more tables represented in the DAO layer, such a trivial
    change may not be so trivial without the use of generics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`?`标记应该被插入或删除的实体的ID替换，而`className`标记应该被插入或删除的实体的类名替换。使用泛型时，这是一个微不足道的改变，因为这段代码可以添加到`GenericDaoImpl`类的`persist`和`remove`方法中。如果不使用泛型，每个`CompanyDaoImpl`、`ProjectDaoImpl`、`TaskDaoImpl`、`UserDaoImpl`和`TaskLogDaoImpl`类都需要进行这个改变。考虑到企业应用程序可能在DAO层中表示20、30、40个或更多的表，这样一个微不足道的改变在没有使用泛型的情况下可能并不那么微不足道。
- en: Your task is to implement the change request as outlined previously. Note that
    this exercise will introduce you to the `instanceof` operator.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是按照之前概述的实现更改请求。请注意，这个练习将向您介绍`instanceof`运算符。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has introduced the Data Access Object design pattern and defined
    a set of interfaces that will be used in our 3T application. The DAO design pattern
    clearly separates the persistence layer operations from the business logic of
    the application. As will be introduced in the next chapter, this clear separation
    ensures that the data access layer is easy to test and maintain.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数据访问对象设计模式，并定义了一组接口，这些接口将在我们的3T应用程序中使用。DAO设计模式清楚地将持久层操作与应用程序的业务逻辑分离开来。正如将在下一章中介绍的那样，这种清晰的分离确保了数据访问层易于测试和维护。
- en: We have also introduced Java Generics as a technique to simplify application
    design by moving common functionality to an ancestor. The `GenericDao` interface
    and the `GenericDaoImpl` class define and implement methods that will be available
    free of cost to the extending components. Our implementations also introduced
    SLF4J, transactional semantics, and working with JPA named queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Java泛型作为一种简化应用程序设计的技术，通过将通用功能移动到祖先。`GenericDao`接口和`GenericDaoImpl`类定义并实现了将免费提供给扩展组件的方法。我们的实现还介绍了SLF4J、事务语义和使用JPA命名查询。
- en: Our journey will now continue with [Chapter 5](ch05.html "Chapter 5. Testing
    the DAO Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and
    JUnit*, where we will configure a testing environment and develop test cases for
    several of our DAO implementations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程现在将继续进行，[第5章](ch05.html "第5章。使用Spring和JUnit测试DAO层")，*使用Spring和JUnit测试DAO层*，在那里我们将配置一个测试环境，并为我们的DAO实现开发测试用例。
