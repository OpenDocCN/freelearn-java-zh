- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Generating Code with OpenAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenAPI生成代码
- en: In this chapter, we will start the development of a completely new API called
    Order Management that will interact with the Product API developed in [*Chapter
    2*](B21843_02.xhtml#_idTextAnchor050) and evolved in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始开发一个全新的API，称为订单管理，该API将与在[*第2章*](B21843_02.xhtml#_idTextAnchor050)中开发的Product
    API以及在第[*第3章*](B21843_03.xhtml#_idTextAnchor076)中演化的API进行交互。
- en: In the previous chapter, the Product API was developed following the *code-first*
    approach, wherein the API was implemented before the documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，产品API是按照*代码优先*的方法开发的，即在文档之前实现API。
- en: In this chapter, we will adopt a *specification-first* approach, also known
    as API-first, wherein we will have the specification of the whole API done first,
    and then have the API implemented.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采用*规范优先*的方法，也称为API-first，即首先完成整个API的规范，然后实现API。
- en: Firstly, we will build the OpenAPI specification for the Order Management API,
    declaring the paths, methods, and request and response schemas (some of them using
    polymorphism) for it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为订单管理API构建OpenAPI规范，声明其路径、方法和请求及响应模式（其中一些使用多态）。
- en: Then, we will use OpenAPI tools to generate Java code stubs from the API specification.
    This generated code speeds up the implementation process, reduces manual maintenance
    of boilerplate code, and, most importantly, makes it easier to maintain consistency
    between the API specification and the service implementation for future changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用OpenAPI工具从API规范生成Java代码存根。此生成的代码加快了实现过程，减少了样板代码的手动维护，最重要的是，使得在API规范和服务实现之间保持一致性更容易，以便于未来的更改。
- en: Next, we will go through the package structure of the service and the code implementation
    bullet points for the build of this API, delivering it in a ready-to-work state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍服务的包结构和API构建的代码实现要点，将其交付为可工作的状态。
- en: Finally, we will look into establishing communication between the Order Management
    and Product APIs to validate the products that will be registered in the orders
    created in this service, by calling an external API and responding accordingly
    to the received condition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨在订单管理和产品API之间建立通信，通过调用外部API并根据接收到的条件相应地做出响应，以验证在此服务中创建的订单中将要注册的产品。
- en: By the end of this chapter, you will have built all the knowledge you need to
    get started with the design, development, and integration of specification-first
    APIs to greatly empower you and speed up your design and development phases in
    an unbelievable manner.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将构建出开始设计、开发和集成规范优先API所需的所有知识，这将极大地增强您的实力，并以令人难以置信的方式加快您的设计和开发阶段。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Specification of the Order Management API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理API规范
- en: Generating code from the specification
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从规范生成代码
- en: Package structure of the Order Management API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理API的包结构
- en: Implementing the Order Management API controller
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现订单管理API控制器
- en: Communicating with the Product API
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与产品API通信
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will implement an example Order Management API. To be able
    to follow along and use the code examples as they are printed in the book, you
    should have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个示例订单管理API。为了能够跟随本书中的代码示例进行操作，您应该具备以下条件：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Java语言和平台有中级知识
- en: At least a basic knowledge of Spring Boot or a similar framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要了解Spring Boot或类似框架的基本知识
- en: Java 21 and Maven 3.9.0 installed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Java 21和Maven 3.9.0
- en: In this chapter, we are going to apply API-first REST principles to create our
    API; you can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用API-first REST原则来创建我们的API；您可以在GitHub上找到本章的代码，网址为[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)。
- en: Specifying the Order Management API
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范订单管理API
- en: In this section, you will develop the specification of the operations and data
    structures of the Order Management API. The Order Management API, as part of the
    project we are building over the course of this book, will handle the orders of
    products managed by the Product API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开发订单管理API的操作和数据结构的规范。订单管理API作为我们在本书中构建的项目的一部分，将处理由产品API管理的产品的订单。
- en: As explained in the previous chapter, *specification-first* means an abstract
    API specification is created before the actual implementation of the API. Instead
    of starting with executable code in a programming language, you begin by defining
    the structure, behavior, and functionality of the API. That is why this is also
    known as API-first development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，*规范优先*意味着在API的实际实现之前创建一个抽象的API规范。您不是从编程语言中的可执行代码开始，而是首先定义API的结构、行为和功能。这就是为什么这也被称为API优先开发。
- en: In [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015) , we visited many key principles
    that should be considered when designing RESTful APIs. Let us look at how to apply
    those principles with the API-first approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B21843_01.xhtml#_idTextAnchor015)中，我们探讨了在设计RESTful API时应考虑的许多关键原则。让我们看看如何使用API优先的方法应用这些原则。
- en: Implementing HTTP principles in API-first development
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在API优先开发中实施HTTP原则
- en: 'When adopting an API-first approach, it is crucial to think in HTTP terms right
    from the design phase. Let us look at some of the principles:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用API优先的方法时，从设计阶段开始就考虑HTTP术语至关重要。让我们看看一些原则：
- en: '**Define API contracts first** : Use tools such as OpenAPI/Swagger to define
    your API structure, including endpoints, request/response formats, and data models.
    This contract serves as a blueprint for developers and helps ensure consistency
    and clarity. We are going to build an API contract with an OpenAPI specification
    file for the Order Management API in the next section.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首先定义API合约**：使用OpenAPI/Swagger等工具定义您的API结构，包括端点、请求/响应格式和数据模型。此合约作为开发者的蓝图，有助于确保一致性和清晰性。在下一节中，我们将使用OpenAPI规范文件为订单管理API构建API合约。'
- en: '**Consistent use of HTTP methods and status codes** : Follow conventions for
    HTTP methods and status codes, as seen in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    . For example, use `GET` for retrieving resources, `POST` for creating, `PUT`
    for updating, and `DELETE` for removing resources. Use appropriate status codes
    to communicate the result of the request. These should also be described in the
    specification file.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致使用HTTP方法和状态码**：遵循如[*第2章*](B21843_02.xhtml#_idTextAnchor050)中看到的HTTP方法和状态码的约定。例如，使用`GET`检索资源，`POST`创建，`PUT`更新，`DELETE`删除资源。使用适当的状态码来传达请求的结果。这些也应在规范文件中描述。'
- en: '**Emphasize resource modeling** : Focus on accurately modeling your domain
    as resources. This involves identifying key entities and their relationships,
    identifying them by URLs that can be accessed using HTTP methods. For example,
    in our Order Management API, resources are `Customers` , `Products` , and `Orders`
    .'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强调资源建模**：关注准确地将您的领域建模为资源。这包括识别关键实体及其关系，通过可以使用HTTP方法访问的URL来识别它们。例如，在我们的订单管理API中，资源是`Customers`、`Products`和`Orders`。'
- en: '**Plan for versioning** : Implement versioning strategies to handle API evolution.
    This can be done through URL path versioning (e.g., `/v2/books` ) and standard
    or custom request headers. Versioning supports backward compatibility and smooth
    transitions as the API grows and changes. This will be defined in the Common API
    metadata of our specification file.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划版本控制**：实施版本控制策略以处理API的演变。这可以通过URL路径版本控制（例如，`/v2/books`）和标准或自定义请求头来完成。版本控制支持向后兼容性和随着API的增长和变化而平稳过渡。这将在我们的规范文件的通用API元数据中定义。'
- en: '**Consider security** : Define authentication and authorization mechanisms,
    such as OAuth, API keys, or JSON Web Tokens (JWTs), to secure your API. We will
    briefly look at how to add a security scheme to our specification, and you will
    learn how to implement it in depth in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176)
    .'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑安全性**：定义认证和授权机制，例如OAuth、API密钥或JSON Web Tokens (JWTs)，以保护您的API。我们将简要介绍如何将安全方案添加到我们的规范中，您将学习如何在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中深入实现它。'
- en: Now that we have a clearer picture of the principles we aim to achieve with
    this definition, let us start writing into the specification itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对通过此定义要实现的原则有了更清晰的了解，让我们开始编写规范本身。
- en: Designing the OpenAPI specification
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 OpenAPI 规范
- en: 'We will write the Order Management API specification using the YAML syntax.
    You can use any editor of your personal preference to follow along: you can use
    the online Swagger Editor available at [https://editor.swagger.io/](https://editor.swagger.io/)
    , or if you work using IDEs such as JetBrains IntelliJ or Microsoft VS Code, you
    can use plugins to get a similar experience to the Swagger website and validate
    your specification while writing it inside your IDE.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 YAML 语法编写订单管理 API 规范。您可以使用您个人偏好的任何编辑器来跟随：您可以使用在线 Swagger 编辑器 [https://editor.swagger.io/](https://editor.swagger.io/)，或者如果您使用
    JetBrains IntelliJ 或 Microsoft VS Code 等 IDE 工作，您可以使用插件来获得类似 Swagger 网站的经验，并在
    IDE 内部编写规范时验证您的规范。
- en: The full specification that we will create is available on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的完整规范可在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)。
- en: Let us begin the specification file by defining the API’s common metadata.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义 API 的公共元数据开始编写规范文件。
- en: Common API metadata
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共 API 元数据
- en: 'We will start by defining the top-level context of the specification with the
    metadata about the API, defining the title, the description, and the version of
    the API. Also, here we describe the servers where the application will be running.
    In our case, since we want to run it locally, we will use `localhost` for testing
    purposes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 API 的元数据定义规范的最高层上下文，包括 API 的标题、描述和版本。此外，我们在这里描述应用程序将运行的服务器。在我们的案例中，因为我们想本地运行它，所以我们将使用
    `localhost` 进行测试目的：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Order Management API paths
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单管理 API 路径
- en: 'This API will have three paths:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 将有三个路径：
- en: '`/orders` with the `POST` and `GET` methods for creating and retrieving orders,
    respectively'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders` 使用 `POST` 和 `GET` 方法分别用于创建和检索订单'
- en: '`/orders/{orderId}` with the `GET` , `PUT` , and `DELETE` methods for accessing,
    editing, and removing specific orders, respectively'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{orderId}` 使用 `GET`、`PUT` 和 `DELETE` 方法分别用于访问、编辑和删除特定订单'
- en: '`/orders/{orderId}/status` with the `PATCH` method to change the status of
    an existing order'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{orderId}/status` 使用 `PATCH` 方法来更改现有订单的状态'
- en: Methods for the /orders path
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`/orders` 路径的方法'
- en: 'Let us start by defining the `POST` method with its request and response. Remember,
    the `$ref` notation is used to refer to the schema definitions in a separate section
    of the specification document. This allows the schemas to be reused, and the `paths`
    section to be shorter and more readable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 `POST` 方法及其请求和响应。记住，`$ref` 符号用于引用规范文档中单独部分的规范定义。这允许规范可重用，并且使 `paths`
    部分更短、更易读：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this `POST` definition, we are defining that when the controller receives
    a `POST` request with the `/orders` path, the request should contain a body as
    specified in the `OrderRequestBody` schema definition. If everything goes well,
    the API will respond with the `201 Created` HTTP status code, with the body defined
    in the `OrderResponse` schema. If the request body does not match `OrderRequestBody`
    , the API will respond with a `400 Bad Request` HTTP response code. We are going
    to define the request and response bodies later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `POST` 定义中，我们定义了当控制器接收到带有 `/orders` 路径的 `POST` 请求时，请求应包含 `OrderRequestBody`
    规范定义中的主体。如果一切顺利，API 将以 `201 Created` HTTP 状态码响应，主体由 `OrderResponse` 规范定义。如果请求主体不匹配
    `OrderRequestBody`，API 将以 `400 Bad Request` HTTP 响应代码响应。我们将在本章后面定义请求和响应主体。
- en: Also, to help the OpenAPI generator name the classes that will be generated
    from our specification, we are specifying a tag in each method operation. In this
    case, the tag will be named `OrderManagement` . If we omit the tag, the generated
    class will be named `DefaultApi` . We will cover this in detail in the *Generating
    code from the specification* section when we have configured the generator and
    start generating code from the specification.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了帮助 OpenAPI 生成器命名从我们的规范中生成的类，我们在每个方法操作中指定了一个标签。在这种情况下，标签将被命名为 `OrderManagement`。如果我们省略标签，生成的类将被命名为
    `DefaultApi`。我们将在配置生成器并开始从规范生成代码的 *从规范生成代码* 部分详细说明这一点。
- en: 'Next, we will define the `GET` method for the `/orders` path endpoint:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `/orders` 路径端点定义 `GET` 方法：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a `GET` method and, when called, it returns the list of orders, if any,
    with HTTP status `200` , and with an array of objects of type `OrderResponse`
    that contains all the orders in the system. If there are none, the returned list
    will be empty still with HTTP status `200` , meaning that the request was successfully
    completed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `GET` 方法，当调用时，它返回订单列表（如果有），HTTP 状态为 `200`，以及一个包含系统中所有订单的对象数组 `OrderResponse`。如果没有订单，返回的列表仍然为空，HTTP
    状态为 `200`，这意味着请求已成功完成。
- en: We will also specify an endpoint to retrieve a single order from the system
    in the next path.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个路径中指定一个端点来检索系统中的单个订单。
- en: Methods for the /orders/{orderId} path
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /orders/{orderId} 路径的方法
- en: 'Now, we are going to define another path to access specific orders, and we
    will define a `GET` , a `PUT` , and a `DELETE` method for this path, starting
    with the `GET` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义另一个路径来访问特定的订单，并且我们将为这个路径定义一个 `GET`、一个 `PUT` 和一个 `DELETE` 方法，从 `GET`
    方法开始：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `GET` method, we are defining a path to retrieve data from a single
    order. Here, we are receiving a single parameter in the path, to be able to get
    the data from a specific order, defined as the `/orders/{orderId}` path, containing
    the order ID in the `{orderId}` placeholder. We also need to have the parameter
    defined in `parameters` , under the `in: path` flag. This is where we specify
    that `orderId` is a parameter to be received.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `GET` 方法中，我们正在定义一个路径来从单个订单中检索数据。在这里，我们正在路径中接收一个参数，以便能够从特定的订单中获取数据，该订单定义为
    `/orders/{orderId}` 路径，包含在 `{orderId}` 占位符中的订单ID。我们还需要在 `parameters` 下定义该参数，在
    `in: path` 标志下。这就是我们指定 `orderId` 是要接收的参数的地方。'
- en: In a successful case, an `OrderResponse` object will be returned containing
    the order itself with a `200 OK` HTTP status response. A `404 Not Found` HTTP
    status will be returned if there is no order with the given ID.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，将返回一个包含订单本身的 `OrderResponse` 对象，HTTP 响应状态为 `200 OK`。如果没有给定ID的订单，将返回
    `404 Not Found` HTTP 状态。
- en: 'Now, let us have a look at the `PUT` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `PUT` 方法：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar to the `GET` method, with the `PUT` method, we are defining an operation
    to update a single order. Please note that we are demonstrating an approach different
    from that adopted when building the Product API, where we used the `PUT` method
    for creating entities. In the Order Management API, we use a separate `POST` method
    (without an ID in the request) for creating orders.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `GET` 方法类似，使用 `PUT` 方法，我们正在定义一个更新单个订单的操作。请注意，我们在这里展示的方法与构建 Product API 时采用的方法不同，在那里我们使用了
    `PUT` 方法来创建实体。在订单管理 API 中，我们使用一个单独的 `POST` 方法（请求中不带ID）来创建订单。
- en: '`PUT` is an idempotent method, meaning it can be called multiple times (with
    the same order ID) without affecting the result. On the other hand, `POST` is
    not idempotent, so every time you call it, it creates a new order in our service.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 是一个幂等方法，这意味着它可以多次调用（使用相同的订单ID）而不会影响结果。另一方面，`POST` 不是幂等的，所以每次调用它都会在我们的服务中创建一个新的订单。'
- en: For the `PUT` method, we receive the order ID in the path, defined in the `/orders/{orderId}`
    path, receiving the order ID through the `orderId` parameter defined in the list
    of parameters and `OrderRequestBody` , the same way as seen in the `POST` method,
    containing all the details of the order to be updated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `PUT` 方法，我们在 `/orders/{orderId}` 路径中接收订单ID，通过在参数列表中定义的 `orderId` 参数和 `OrderRequestBody`
    接收订单ID，这与在 `POST` 方法中看到的方式相同，包含要更新的订单的所有详细信息。
- en: In case of success, it will return a `200 OK` HTTP status code and `OrderResponse`
    containing the details of the persisted order. If the order is not found, `404
    Not Found` will be returned. In case of a wrong format in the request, `400 Bad
    Request` will be returned.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作成功，它将返回一个 `200 OK` HTTP 状态码和包含持久化订单详细信息的 `OrderResponse`。如果找不到订单，将返回 `404
    Not Found`。如果请求格式错误，将返回 `400 Bad Request`。
- en: 'Finally, let us see the `DELETE` method to cancel a specific order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看用于取消特定订单的 `DELETE` 方法：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this method, we are required to pass a parameter named `orderId` , which
    is the ID of the order to be cancelled, the same way we did with the `GET` and
    `PUT` methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们需要传递一个名为 `orderId` 的参数，它是要取消的订单的ID，这与我们在 `GET` 和 `PUT` 方法中所做的方式相同。
- en: In case of success, a response HTTP status code of `204 No Content` will be
    returned to the caller because there is no response body. `404 Not Found` will
    be returned if there is no order with the specified ID.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作成功，将向调用者返回一个 `204 No Content` HTTP 状态码，因为没有响应体。如果没有指定ID的订单，将返回 `404 Not
    Found`。
- en: Method for the /orders/{orderId}/status
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /orders/{orderId}/status 的方法
- en: 'Finally, let us have a look at the last defined endpoint path to change the
    status of the orders, with the `PATCH` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看最后一个定义的端点路径，使用 `PATCH` 方法来更改订单的状态：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The goal of this endpoint is to update the status of an order. In a real-world
    production environment, the status of an order depends on external circumstances
    defined by other services in business logic, for example, the payment approval
    validated by a payment provider, availability of the items in a warehouse, or
    even fraud detection; it’s important to have a way to change the status of the
    orders with external calls, and this endpoint is specifically to accomplish this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点的目标是更新订单的状态。在现实世界的生产环境中，订单的状态取决于由其他服务在业务逻辑中定义的外部情况，例如，由支付提供商验证的支付批准、仓库中物品的可用性，甚至欺诈检测；有一个方法来通过外部调用更改订单的状态是很重要的，而这个端点正是为了完成这个任务。
- en: Note that the body of this request is being defined by reference, using `$ref`
    , to the `OrderStatus` schema that will be defined in the next section. This exemplifies
    the reusability of the specification-first design, where you define a reusable
    schema that can be referenced across multiple path definitions, parameters, and
    endpoints in the OpenAPI schema definition file, eliminating the need to repeat
    any definitions. The next section covers this topic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此请求的正文是通过引用来定义的，使用 `$ref` 指向下一节将要定义的 `OrderStatus` 架构。这展示了规范优先设计的可重用性，其中你定义一个可重用的架构，可以在
    OpenAPI 架构定义文件中的多个路径定义、参数和端点中引用，从而消除重复定义的需要。下一节将涵盖这个主题。
- en: Now, we are going to define the schemas used as a body for the requests and
    responses and as params in the operations we have just finished defining.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义用于请求和响应正文以及作为我们刚刚定义的操作参数的架构。
- en: Defining the API schemas
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 API 架构
- en: Now that we have finished defining the paths that identify the resources of
    our API, we are going to define the schemas that we use in the operations defined
    in the previous section. The schemas describe the structure of the request and
    response bodies for those operations and can also be used as parameters in the
    operations as seen before.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了定义识别我们 API 资源路径的路径，我们将定义我们在上一节中定义的操作中使用的架构。这些架构描述了这些操作的请求和响应正文的结构，也可以像之前看到的那样用作操作的参数。
- en: '![Figure 4.1: Entity-Relationship diagram from the defined API schema](img/B21843_04_1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：从定义的 API 架构生成的实体-关系图](img/B21843_04_1.png)'
- en: 'Figure 4.1: Entity-Relationship diagram from the defined API schema'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：从定义的 API 架构生成的实体-关系图
- en: In the preceding diagram, you can see the relationship between the entities
    that will be created later by extending from the schema definitions we are about
    to write and generate – that is why they differ in the name definition. This way,
    you can have the whole entity structure defined from the OpenAPI schema, reinforcing
    the API-first principle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到将要由我们即将编写的架构定义扩展而创建的实体之间的关系。这就是为什么它们在名称定义上有所不同。这样，你可以从 OpenAPI 架构中定义整个实体结构，从而加强
    API 优先原则。
- en: Schema definitions are located under the `components` section of the OpenAPI
    specification.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 架构定义位于 OpenAPI 规范的 `components` 部分下。
- en: 'OpenAPI schemas use a language that supports defining complex structures of
    JSON data and the relationships between the structures. The schemas are entries
    inside the `schemas` section, with the first ones being `Product` and `Customer`
    :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 架构使用一种支持定义 JSON 数据的复杂结构和结构之间关系的语言。架构位于 `schemas` 部分的条目中，首先是 `Product`
    和 `Customer`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Product` is the simplest schema in our specification. It just defines that
    its type is a JSON object with two properties: `productSKU` of type `string` ,
    which will be the ID for our products, and `quantity` of type `integer` , which
    will represent the availability of this product.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 是我们规范中最简单的架构。它仅仅定义了其类型是一个具有两个属性的 JSON 对象：`productSKU` 类型为 `string`，它将成为我们产品的
    ID，以及 `quantity` 类型为 `integer`，它将表示该产品的可用性。'
- en: 'Moving to the `Customer` schema, it is an object containing four properties:
    `customerType` , `streetAddress` , `city` , and `postalCode` . All the properties
    are of type `string` . But here, we also start to introduce the concept of inheritance
    and polymorphism.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `Customer` 架构，它是一个包含四个属性的对象：`customerType`、`streetAddress`、`city` 和 `postalCode`。所有属性都是
    `string` 类型。但在这里，我们也开始引入继承和多态性的概念。
- en: The `Customer` schema will serve as a parent (base) schema, which will be extended
    by two other schemas— `PersonCustomer` and `CompanyCustomer` —that we will introduce
    later. This setup demonstrates inheritance, with one parent and two child schemas,
    and polymorphism, allowing `Customer` to represent either `PersonCustomer` or
    a `CompanyCustomer` .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 架构将作为一个父（基础）架构，它将由另外两个架构扩展——`PersonCustomer` 和 `CompanyCustomer`——这两个架构我们将在后面介绍。这种设置展示了继承，有一个父架构和两个子架构，以及多态性，允许
    `Customer` 代表 `PersonCustomer` 或 `CompanyCustomer`。'
- en: This is where the `discriminator` property comes into play. The `discriminator`
    property is used by the JSON parser to indicate which of the child schemas it
    is inheriting from when it tries to deserialize the JSON data into the generated
    object while loading from JSON and converting it into an object in runtime. In
    our case, the discriminator will be the `customerType` property. This property
    will define whether `Customer` will be of type `PersonCustomer` or type `CompanyCustomer`
    .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，`discriminator` 属性开始发挥作用。当 JSON 解析器尝试在从 JSON 加载并转换为运行时对象的过程中反序列化 JSON
    数据时，`discriminator` 属性被用来指示它正在从哪个子架构继承。在我们的例子中，判别器将是 `customerType` 属性。这个属性将定义
    `Customer` 是 `PersonCustomer` 类型还是 `CompanyCustomer` 类型。
- en: This property is used when you place an order, as part of the `POST` request
    body that we previously defined. With the discriminator, a single endpoint can
    accept two different bodies, one with `Customer` of type `PersonCustomer` for
    individual customers, and another one with `Customer` of type `CompanyCustomer`
    for companies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你下订单时，这个属性会被使用，作为之前定义的 `POST` 请求体的一部分。有了判别器，单个端点可以接受两个不同的体，一个包含 `Customer`
    类型为 `PersonCustomer` 的个人客户，另一个包含 `Customer` 类型为 `CompanyCustomer` 的公司。
- en: 'Now, let us define the child schemas, `PersonCustomer` and `CompanyCustomer`
    , and relate them to the parent `Customer` schema:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义子架构 `PersonCustomer` 和 `CompanyCustomer`，并将它们与父 `Customer` 架构相关联：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both schema definitions look similar; both of them use the `allOf` keyword that
    refers to the `Customer` schema. It defines that the child schema should contain
    (inherit) all the properties of the `Customer` schema.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个架构定义看起来很相似；它们都使用了 `allOf` 关键字，该关键字引用 `Customer` 架构。它定义子架构应该包含（继承）`Customer`
    架构的所有属性。
- en: Since we have implemented hierarchy in our specification, let us briefly look
    at how to create new orders in this structure, using the `OrderRequestBody` that
    will be used for `POST` and `PUT` methods to create and update resources in the
    application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在规范中实现了层次结构，让我们简要地看看如何使用 `OrderRequestBody` 创建新订单，该 `OrderRequestBody` 将用于
    `POST` 和 `PUT` 方法来创建和更新应用程序中的资源。
- en: '![Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI](img/B21843_04_2.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – OpenAPI Swagger UI 中的 OrderRequestBody 架构](img/B21843_04_2.png)'
- en: Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – OpenAPI Swagger UI 中的 OrderRequestBody 架构
- en: 'The `POST` method expects `OrderRequestBody` in the body of the request. Since
    we have used `discriminator` in the definition, here we will need to select one
    of the bodies in the request, as specified by `oneOf->` in the preceding figure:
    `PersonCustomer` , `CompanyCustomer` , or `Customer` . The value for the `customerType`
    field needs to be one of `person` , `company` , or `customer` to match one of
    the bodies defined. The usage of `Customer` alone is discouraged since it does
    not benefit from the hierarchy and the polymorphism, but it is important to know
    that you can use it alone too without the extra fields from `PersonCustomer` or
    `CompanyCustomer` if needed.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法期望在请求体中包含 `OrderRequestBody`。由于我们在定义中使用了 `discriminator`，因此在这里我们需要在请求中选择一个体，如前图中的
    `oneOf->` 所指定：`PersonCustomer`、`CompanyCustomer` 或 `Customer`。`customerType` 字段的值需要是
    `person`、`company` 或 `customer` 中的一个，以匹配定义的体之一。单独使用 `Customer` 不被鼓励，因为它没有从层次结构和多态性中受益，但重要的是要知道，如果需要，你也可以单独使用它，而不需要
    `PersonCustomer` 或 `CompanyCustomer` 的额外字段。'
- en: Then, you can add the corresponding fields of each of these, so if it is a company,
    you will have fields such as `vatId` and `companyName` in your request body, and
    if it is a person, you will have fields such as `firstName` and `lastName` in
    your request. The fields mentioned in the `Customer` specification are common
    to both types of customers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以添加这些每个对应的字段，所以如果是一个公司，你将在请求体中拥有`vatId`和`companyName`等字段，如果是个人，你将在请求中拥有`firstName`和`lastName`等字段。在`Customer`规范中提到的字段对两种客户类型都是通用的。
- en: 'To finish the schema section of our API specification, we will define the request
    and response bodies used by the Order Management API:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们API规范中的模式部分，我们将定义由订单管理API使用的请求和响应体：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `OrderRequestBody` object definition, there are two properties – one
    that is of the `Customer` type defined above, using `$ref` to refer to its definition,
    and the `products` property, which is a JSON array that will represent a list
    of `Product` JSON objects within `OrderRequestBody` .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OrderRequestBody`对象定义中，有两个属性——一个是上面定义的`Customer`类型，使用`$ref`来引用其定义，以及`products`属性，它是一个JSON数组，将在`OrderRequestBody`中表示一个`Product`
    JSON对象的列表。
- en: 'In the response schema definition, `OrderResponse` contains an array of `Product`
    JSON objects, containing every product for a particular order, the `customer`
    property that references the `Customer` schema and returns the customer data for
    this order, the `orderCreatedDate` and `orderUpdatedDate` properties with the
    date and time of the order creation and update if any, and the `status` property
    that references the `OrderStatus` defined, which references the `Status` `enum`
    , containing all the possible statuses for an order: `Pending` , `Approved` ,
    or `Cancelled` . Since we can reuse these definitions anywhere around the specification,
    the `OrderStatus` schema is also referenced in the order change status endpoint
    as the request body definition for allowed values in the request.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应模式定义中，`OrderResponse`包含一个`Product` JSON对象的数组，包含特定订单的每个产品，`customer`属性引用`Customer`模式并返回此订单的客户数据，`orderCreatedDate`和`orderUpdatedDate`属性包含订单创建和更新的日期和时间（如果有），以及`status`属性，它引用定义的`OrderStatus`，该`OrderStatus`引用`Status`
    `enum`，包含订单的所有可能状态：`Pending`、`Approved`或`Cancelled`。由于我们可以在规范中的任何地方重用这些定义，因此`OrderStatus`模式也在订单状态更改端点作为请求体定义中引用，以允许请求中的值。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Sharing schemas across APIs
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在API之间共享模式
- en: With Java and other programming languages, we are used to defining reusable
    libraries to avoid repeating the same code in multiple projects. OpenAPI specifications
    can also refer to external files, so it is possible to share common parts among
    multiple APIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java和其他编程语言，我们习惯于定义可重用的库以避免在多个项目中重复相同的代码。OpenAPI规范也可以引用外部文件，因此可以在多个API之间共享公共部分。
- en: However, you should be aware that this approach creates coupling among the APIs.
    In case the common part changes, it can lead to unexpected inconsistencies. So,
    it is advisable to try to keep the individual API specifications self-contained.
    If you want to reuse schemas, you should ensure that they are very stable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该意识到这种方法会在API之间创建耦合。如果公共部分发生变化，可能会导致意外的不一致。因此，建议尽量保持单个API规范的自包含。如果你想要重用模式，你应该确保它们非常稳定。
- en: One such example could be the structure used for reporting errors. But in our
    example APIs, we use the `ProblemDetail` schema based on the RFC 7807 internet
    standard. This way, we avoid maintaining the shared schema.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的一个例子可能是用于报告错误的结构。但在我们的示例API中，我们使用基于RFC 7807互联网标准的`ProblemDetail`模式。这样，我们避免了维护共享模式。
- en: Defining security schemes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义安全方案
- en: 'Besides schemas, the components section of the OpenAPI specification can be
    used to specify security-related requirements for our API. Here, we will specify
    the authentication mechanism to use: OpenID Connect with JWT. You will learn more
    about security in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模式之外，OpenAPI规范的组件部分也可以用来指定我们API的安全相关要求。在这里，我们将指定要使用的身份验证机制：OpenID Connect配合JWT。你将在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中了解更多关于安全的信息。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `securitySchemes` defines a security scheme named `JWTAuth` and applies
    it globally to all operations in the API. Here is a breakdown of its components
    and their implications:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`securitySchemes`定义了一个名为`JWTAuth`的安全方案，并将其全局应用于API中的所有操作。以下是其组件及其影响的分析：'
- en: '`JWTAuth` : This is the identifier for the security scheme'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JWTAuth`：这是安全方案的标识符。'
- en: '`type: http` : This specifies that the security scheme is HTTP-based'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: http`：这指定了安全方案是基于HTTP的。'
- en: '`scheme: bearer` : This indicates that the scheme uses bearer tokens'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheme: bearer`：这表示该方案使用携带令牌。'
- en: '`bearerFormat: JWT` : This specifies that the bearer tokens are in JWT format'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bearerFormat: JWT`：这指定了携带令牌的格式为JWT。'
- en: 'With all that defined, we can move away from the `components` keyword and get
    to know our last keyword in this definition, the `security` keyword:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些之后，我们可以从`components`关键字移开，了解这个定义中的最后一个关键字，即`security`关键字：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This security definition is at the root level, and it indicates that there are
    no specific scopes or permissions required within the JWT for accessing the API.
    So, a valid JWT must be provided in the Authorization header for all API calls,
    but the token itself does n ot need to specify any particular scopes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安全定义处于根级别，它表明在JWT中访问API不需要特定的作用域或权限。因此，所有API调用都必须在授权头中提供有效的JWT，但令牌本身不需要指定任何特定的作用域。
- en: If you prefer not to use JWTs for authentication, you can consider using session
    state IDs as an alternative. They were widely used before the advent of JWTs,
    which replaced session state IDs for many reasons.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用JWT进行认证，可以考虑使用会话状态ID作为替代方案。在JWT出现之前，它们被广泛使用，并且由于许多原因，JWT取代了会话状态ID。
- en: 'Before looking at how to use session state IDs, let us see the key reasons
    that JWTs became the preferred authentication method for microservices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看如何使用会话状态ID之前，让我们看看JWT成为微服务首选认证方法的关键原因：
- en: '**Statelessness** : JWTs are stateless, meaning they do not require the server
    to maintain session state. This is beneficial for microservices, which are designed
    to be stateless and scalable.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：JWT是无状态的，这意味着它们不需要服务器维护会话状态。这对微服务有益，因为微服务被设计成无状态和可扩展的。'
- en: '**Scalability** : Since JWTs are self-contained and do not require server-side
    storage, they are more scalable in distributed systems compared to session state
    IDs, which require centralized session storage.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：由于JWT是自包含的，并且不需要服务器端存储，与需要集中式会话存储的会话状态ID相比，它们在分布式系统中具有更高的可扩展性。'
- en: '**Decentralized authentication** : JWTs can be verified by any service that
    has a public key, allowing for decentralized authentication across multiple microservices
    without the need for a central session store.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化认证**：JWT可以被任何拥有公钥的服务验证，允许在多个微服务之间进行去中心化认证，而无需中央会话存储。'
- en: '**Interoperability** : JWTs are a standard (RFC 7519) and are widely supported
    across different platforms and languages, making them suitable for heterogeneous
    microservice environments.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：JWT是一个标准（RFC 7519），并且在不同的平台和语言中得到广泛支持，这使得它们适合异构微服务环境。'
- en: '**Security** : JWTs can be signed and optionally encrypted, providing integrity
    and confidentiality. They can also include claims that provide additional context
    about the user or the session.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：JWT可以进行签名和可选加密，提供完整性和机密性。它们还可以包含提供有关用户或会话的额外上下文的声明。'
- en: But for specific circumstances, which could be dealing with legacy services
    and integrations with already existing services that make use of session state
    IDs, this approach may be necessary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但在特定情况下，例如处理遗留服务和与已使用会话状态ID的现有服务的集成时，这种方法可能是必要的。
- en: Session state IDs involve maintaining a session on the server side, where each
    session is identified by a unique session ID. This session ID is stored on the
    client side, typically in a cookie, and sent with each request to the server.
    The server then validates the session ID and retrieves the associated session
    data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态ID涉及在服务器端维护会话，其中每个会话由一个唯一的会话ID标识。这个会话ID存储在客户端，通常在cookie中，并随每个请求发送到服务器。然后服务器验证会话ID并检索相关的会话数据。
- en: Some of the advantages of session state IDs are that the server has full control
    over the session, including the ability to invalidate sessions at any time and
    there is no need to handle token expiration and renewal as with JWT.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态ID的一些优点是服务器对会话拥有完全控制权，包括在任何时候使会话失效的能力，并且与JWT相比，无需处理令牌过期和续订。
- en: On the other hand, it requires maintaining session state on the server, which
    can be challenging in a distributed environment, and, unlike JWT, which is stateless,
    session state IDs require the server to maintain state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它需要在服务器上维护会话状态，这在分布式环境中可能具有挑战性，并且与无状态的 JWT 不同，会话状态 ID 需要服务器维护状态。
- en: 'Here is an example of how you can define session state IDs in your OpenAPI
    schema:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明您如何在 OpenAPI 架构中定义会话状态 ID：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `SessionIDAuth` security scheme specifies that the session
    ID will be sent in a cookie named `SESSIONID` . The server will then validate
    this session ID to authenticate the user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`SessionIDAuth` 安全方案指定会话 ID 将以名为 `SESSIONID` 的 cookie 发送。然后服务器将验证此会话 ID
    以验证用户身份。
- en: We will not be covering session state IDs in our services since they break the
    stateless goal of a RESTful microservice and having JWTs with all the advantages
    explained above, but it is good to know how you can use them with the specification-first
    approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务中，我们不会涵盖会话状态 ID，因为它们破坏了无状态目标 RESTful 微服务，并且有了上面解释的所有 JWT 优点，但了解如何使用它们以规范优先的方法是很好的。
- en: Also, as mentioned before, we will go into the security subject in more depth
    in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如前所述，我们将更深入地探讨第 [*7章*](B21843_07.xhtml#_idTextAnchor176) 的安全主题。
- en: With that, we have our specification completed. You can save your file with
    a name that represents your API, ending with the `.yml` extension (short for YAML).
    In our example, the file will be named `Order_Management_API.yml` .
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了规范。您可以将文件保存为表示您的 API 的名称，并以 `.yml` 扩展名结尾（YAML 的简称）。在我们的示例中，文件将命名为 `Order_Management_API.yml`。
- en: As mentioned earlier, you can see the complete file in the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以在 GitHub 仓库中查看完整文件，网址为 [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)。
- en: Next, we are going to generate code from this specification, using `openapi-generator-maven-plugin`
    . Let us find out how.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `openapi-generator-maven-plugin` 从此规范生成代码。让我们看看如何操作。
- en: Generating code from the specification
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从规范生成代码
- en: In order to generate code from a specification, the application needs to be
    prepared for it. In this section, you will configure a plugin and generate code
    from what we have specified in the specification file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从规范生成代码，应用程序需要为此做好准备。在本节中，您将配置一个插件，并从我们在规范文件中指定的内容生成代码。
- en: The following XML fragment configures `openapi-generator-maven-plugin` for our
    Maven project, specifically designed to generate Spring-based Java code from the
    OpenAPI specification defined in the previous section. This plugin facilitates
    the automatic creation of API endpoints, models, and configuration classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 XML 片段配置了 `openapi-generator-maven-plugin`，这是为我们的 Maven 项目设计的，专门用于从上一节中定义的
    OpenAPI 规范生成基于 Spring 的 Java 代码。此插件简化了 API 端点、模型和配置类的自动创建。
- en: 'We are going to configure the plugin in the `pom.xml` file inside our project.
    You can refer to the GitHub repository to see the full file, but here we will
    focus on the specific changes to accomplish our goals. Let us look at this configuration
    now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目中的 `pom.xml` 文件中配置插件。您可以参考 GitHub 仓库以查看完整文件，但在这里我们将关注实现我们目标的具体更改。现在让我们看看这个配置：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a breakdown of its key components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是其关键组件的分解：
- en: '**Plugin identification** : `groupId` and `artifactId` identify the plugin
    within the Maven ecosystem:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件识别**：`groupId` 和 `artifactId` 在 Maven 生态系统中标识插件：'
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Plugin version** : Specifies the version of the plugin to use, ensuring compatibility
    and access to specific features available in this version:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件版本**：指定要使用的插件版本，确保兼容性并访问此版本中可用的特定功能：'
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Execution configuration** : The `executions` block defines when and how the
    plugin should run. The goal named `generate` triggers the code generation process:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行配置**：`executions` 块定义了插件何时以及如何运行。名为 `generate` 的目标触发代码生成过程：'
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Specification input** : The `inputSpec` configuration points to the OpenAPI
    specification file. This path is relative to the project’s base directory, indicating
    where the plugin should look for the API definition elaborated in the previous
    section:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范输入** : `inputSpec` 配置指向 OpenAPI 规范文件。此路径相对于项目的基本目录，表示插件应在何处查找上一节中详细说明的
    API 定义：'
- en: '[PRE17]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Generator configuration** : The `generatorName` specifies that the generated
    code should be tailored for Spring, influencing the structure and annotations
    used in the output:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器配置** : `generatorName` 指定生成的代码应针对 Spring 进行定制，这会影响输出中使用的结构和注解：'
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Package names** : The `apiPackage` and `modelPackage` configurations define
    the Java package names for generated API interfaces (API operations) and model
    classes (data structures), respectively. This helps in organizing the generated
    code within the project structure. Also, having a suffix added by `modelNameSuffix`
    helps to have the DTOs generated with this suffix in the name:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包名** : `apiPackage` 和 `modelPackage` 配置分别定义了生成的 API 接口（API 操作）和模型类（数据结构）的
    Java 包名。这有助于在项目结构中组织生成的代码。此外，通过 `modelNameSuffix` 添加的后缀有助于生成具有此后缀名称的 DTO：'
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Additional options** : The `configOptions` section provides further customization
    of the generated code. Let us briefly describe each of the options we are using
    here and their functionality:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加选项** : `configOptions` 部分提供了对生成的代码的进一步自定义。让我们简要描述我们在这里使用的每个选项及其功能：'
- en: '`documentationProvider` : This specifies the documentation provider to use.
    In this case, `springdoc` is used to generate API documentation.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`documentationProvider` : 这指定了要使用的文档提供程序。在这种情况下，使用 `springdoc` 生成 API 文档。'
- en: '`interfaceOnly` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interfaceOnly` : 当设置为 `true` 时，仅生成 API 的接口，而不生成任何实现。'
- en: '`oas3` : This indicates that the OpenAPI 3.0 specification is being used.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oas3` : 这表示正在使用 OpenAPI 3.0 规范。'
- en: '`openApiNullable` : When set to `false` , the generator will not use the `@Nullable`
    annotation for optional fields.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openApiNullable` : 当设置为 `false` 时，生成器将不会为可选字段使用 `@Nullable` 注解。'
- en: '`serializableModel` : When set to `true` , the generated models will implement
    the `Serializable` interface.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serializableModel` : 当设置为 `true` 时，生成的模型将实现 `Serializable` 接口。'
- en: '`useBeanValidation` : When set to `true` , the generated models will include
    annotations for bean validation (e.g., `@NotNull` , `@Size` ).'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useBeanValidation` : 当设置为 `true` 时，生成的模型将包括用于 bean 验证的注解（例如，`@NotNull`，`@Size`）。'
- en: '`useSpringBoot3` : When set to `true` , the generator will produce code compatible
    with Spring Boot 3.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useSpringBoot3` : 当设置为 `true` 时，生成器将生成与 Spring Boot 3 兼容的代码。'
- en: '`useTags` : When set to `true` , the generator will use tags defined in the
    OpenAPI specification to group API operations.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTags` : 当设置为 `true` 时，生成器将使用 OpenAPI 规范中定义的标签来分组 API 操作。'
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With that, we have covered every aspect of the configuration of the plugin in
    our `pom.xml` file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经覆盖了 `pom.xml` 文件中插件配置的各个方面。
- en: 'Next, let us execute the build and have the implementation generated:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们执行构建并生成实现：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If your build was successful, you will note that you have the DTOs and an interface
    generated in your target folder.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的构建成功，你会注意到在你的目标文件夹中生成了 DTO 和接口。
- en: '![Figure 4.3 – Implementation generated in the target folder](img/B21843_04_3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 在目标文件夹中生成的实现](img/B21843_04_3.png)'
- en: Figure 4.3 – Implementation generated in the target folder
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 在目标文件夹中生成的实现
- en: 'If you use IntelliJ IDEA, switch to the **Packages** view, so you can see the
    generated sources along with the structure of the project and work seamlessly
    with the generated sources and your own implementation, as seen in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 IntelliJ IDEA，切换到 **包** 视图，这样你就可以看到生成的源代码以及项目的结构，并与生成的源代码和你的实现无缝工作，如下面的截图所示：
- en: '![Figure 4.4 – Implementation generated along with the project structure](img/B21843_04_4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 与项目结构一起生成的实现](img/B21843_04_4.png)'
- en: Figure 4.4 – Implementation generated along with the project structure
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 与项目结构一起生成的实现
- en: By generating the code in the `target` folder, we clearly separate it from the
    manually written code in the `src` folder. The generated code should not be stored
    in a version control system (Git or another) to avoid inconsistencies with the
    source specification it should be generated from. Instead, fresh code is generated
    during every Maven build.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`target`文件夹中生成代码，我们清楚地将其与`src`文件夹中手动编写的代码分开。生成的代码不应存储在版本控制系统（Git或其他）中，以避免与应从中生成的源规范不一致。相反，每次Maven构建都会生成新的代码。
- en: 'Let us see the results in the generated `PersonCustomerDto` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的`PersonCustomerDto`类中的结果：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we can see that for every field that was specified in the specification
    schema, a Java class field was generated accordingly, including the relationships
    with other schemas, such as the inheritance from the `Customer` schema, proving
    that we can also model object-oriented programming concepts using the API-first
    approach if we define the relationships in the specification file properly. The
    other classes look similar, each one generated according to its own schema definition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，对于规范模式中指定的每个字段，都生成了一个相应的Java类字段，包括与其他模式的关系，例如从`Customer`模式继承，这证明了如果我们正确地在规范文件中定义关系，我们也可以使用API-first方法来建模面向对象编程概念。其他类看起来很相似，每个类都是根据其自己的模式定义生成的。
- en: 'Before moving on to the implementation of the operations listed in the API
    specification, let us see what our API paths and methods were translated to. For
    example, let us see the `DELETE` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实现API规范中列出的操作之前，让我们看看我们的API路径和方法是如何被转换的。例如，让我们看看`DELETE`方法：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that the generated default implementation code does nothing;
    it only returns a response entity with the status `NOT_IMPLEMENTED` . If we tried
    to invoke the API with this default code, the client would see a `501 Not Implemented`
    HTTP status.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到生成的默认实现代码没有任何作用；它只返回一个状态为`NOT_IMPLEMENTED`的响应实体。如果我们尝试使用这个默认代码调用API，客户端会看到一个`501
    Not Implemented`的HTTP状态。
- en: The default implementation is expected to be overridden by the actual implementation.
    The path, its parameters, and responses are already defined and documented. The
    API documentation of the running API application is accessible using the Swagger
    UI interface or by downloading the OpenAPI JSON definition through the auto-generated
    `/v3/api-docs` path, like with the code-first API we developed in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现预期将被实际实现所覆盖。路径、其参数和响应已经定义和文档化。运行中的API应用程序的API文档可以通过Swagger UI界面访问，或者通过自动生成的`/v3/api-docs`路径下载OpenAPI
    JSON定义，就像我们在[*第2章*](B21843_02.xhtml#_idTextAnchor050)中开发的先定义API一样。
- en: Just keep in mind that you will need to add the `springdoc-openapi-starter-webmvc-ui`
    dependency into your `pom.xml` file to be able to use the Swagger UI graphical
    interface. Please refer to the GitHub repository of *Chapter 4* to get the full
    list of dependencies needed to run the project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要将`springdoc-openapi-starter-webmvc-ui`依赖项添加到您的`pom.xml`文件中，以便能够使用Swagger
    UI图形界面。请参考[*第4章*](B21843_04.xhtml#_idTextAnchor050)的GitHub仓库以获取运行项目所需的完整依赖项列表。
- en: This is what makes the specification-first approach handy, since after the design
    is defined, developers can focus on the implementation while consumers can start
    the integration with the system even before the actual development is finished.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么先定义规范的方法很方便，因为一旦设计被定义，开发者就可以专注于实现，而消费者甚至可以在实际开发完成之前就开始与系统进行集成。
- en: Now that our specification is generated, let us have an overview of the package
    structure of this service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了规范，让我们概述一下这个服务的包结构。
- en: Package structure of the Order Management API
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单管理API的包结构
- en: 'Let us have a look at what our package structure looks like for the Order Management
    API:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看订单管理API的包结构是什么样的：
- en: '![Figure 4.5 – Package structure of implemented Order Management API](img/B21843_04_5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 实现的订单管理API的包结构](img/B21843_04_5.png)'
- en: Figure 4.5 – Package structure of implemented Order Management API
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 实现的订单管理API的包结构
- en: 'Here, we can see that the Order Management API follows the same architectural
    approach as described in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) , following
    the principles of clean architecture. Let us look at the contained packages:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到订单管理API遵循与[*第2章*](B21843_02.xhtml#_idTextAnchor050)中描述的相同架构方法，遵循清洁架构的原则。让我们看看包含的包：
- en: '`adapter` : This package contains the four following packages:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adapter` : 这个包包含以下四个子包：'
- en: '`exception` : This contains all class exceptions and exception handlers'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception` : 这包含所有类异常和异常处理器。'
- en: '`inbound.rest` : This is responsible for handling all the inputs, transformations,
    and generated data from the specification'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inbound.rest` : 这负责处理所有输入、转换和由规范生成的数据。'
- en: '`mapper` : This contains all the mapper transformations between objects, such
    as `toOrderRequest` from `OrderRequestBodyDto` , and the custom-defined mappers.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper` : 这包含所有对象之间的映射转换，例如从 `OrderRequestBodyDto` 到 `toOrderRequest` 的转换，以及自定义定义的映射器。'
- en: '`outbound` : This package contains all elements that interact with external
    services, such as databases and other services. In this service, we will have
    two subpackages within it:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outbound` : 这个包包含所有与外部服务交互的元素，如数据库和其他服务。在这个服务中，我们将有两个子包：'
- en: '`outbound.database` : This contains all the elements that will interact with
    the database itself, the implementation of use cases that contain operations such
    as `createOrder` and `updateOrderStatus` , and the repositories also go here.
    It contains an internal package within it.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outbound.database` : 这包含所有将与数据库本身交互的元素，包含如 `createOrder` 和 `updateOrderStatus`
    等操作的用例实现，以及仓库也在这里。它包含一个内部的包。'
- en: '`outbound.database.entity` : This contains all the defined entities for the
    service that declares the tables and interacts with the database.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outbound.database.entity` : 这包含服务中声明的表和与数据库交互的所有定义的实体。'
- en: '`outbound.rest` : This package contains all the elements required to interact
    with external services through REST calls. In this service, we have the elements
    required to interact with the Product API, created in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outbound.rest` : 这个包包含所有通过REST调用与外部服务交互所需的元素。在这个服务中，我们有与在 [*第2章*](B21843_02.xhtml#_idTextAnchor050)
    中创建的产品API交互所需的元素。'
- en: '`domain` : This package contains the POJOs that define the base structure for
    each domain contained by this service. Its structure will be inherited mostly
    by the entities, but they are not the entities themselves (those are defined in
    the `adapter.outbound.database.entity` package), so it contains POJOs from the
    `Order` , `Customer` (also `PersonCustomer` and `CompanyCustomer` ), and `Product`
    definitions, along with the `StatusEnum` definitions as well.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain` : 这个包包含定义每个由该服务包含的域的基础结构的POJOs。其结构将主要继承自实体，但它们本身不是实体（那些在 `adapter.outbound.database.entity`
    包中定义），因此它包含来自 `Order`、`Customer`（也包括 `PersonCustomer` 和 `CompanyCustomer`）以及 `Product`
    定义，以及 `StatusEnum` 定义。'
- en: '`usecase` : This contains the interface definitions for the use cases, containing
    the actions that will be implemented. In this service, we have two use cases:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usecase` : 这包含用例的接口定义，包含将要实现的动作。在这个服务中，我们有两个用例：'
- en: '`OrdersCommandUseCase` : This contains the definitions of actions like `createOrder`
    and `updateOrder` that are implemented by the class `OrdersCommandUseCaseImpl`
    in the `adapter.outbound.database`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrdersCommandUseCase` : 这包含如 `createOrder` 和 `updateOrder` 等动作的定义，这些动作由 `adapter.outbound.database`
    中的 `OrdersCommandUseCaseImpl` 类实现。'
- en: '`OrdersQueryUseCase` : This contains the definition of the actions that happen
    with the database through queries and is implemented by `OrdersQueryUseCaseImpl`
    in the `adapter.inbound.rest` package.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrdersQueryUseCase` : 这包含通过查询与数据库发生的动作的定义，并由 `adapter.inbound.rest` 包中的 `OrdersQueryUseCaseImpl`
    实现。'
- en: Now that we are aware of the package structure of the service, let us jump into
    the implementation of the controller itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了服务的包结构，让我们跳入控制器的实现本身。
- en: Implementing the Order Management API controller
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现订单管理API控制器
- en: The Order Management API will follow the same architecture and package structure
    used in the Product API, so the controllers will be created within the `adapter.inbound.rest`
    package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理API将遵循与产品API相同的架构和包结构，因此控制器将在 `adapter.inbound.rest` 包内创建。
- en: 'The first step is to create the `OrderManagementApiController` class, implementing
    the methods of the `OrderManagementApi` interface. Here is a sample of the code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建 `OrderManagementApiController` 类，实现 `OrderManagementApi` 接口的方法。以下是代码的示例：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, there is no concrete implementation yet, but we are
    defining the methods that were specified previously in our specification file
    and generated in the `OrderManagementApi` interface. If we keep the `super` calls
    (invoking the default implementation of the parent interface), the server returns
    a `501 Not Implemented` HTTP status code to the caller. It can be useful when
    you want to deploy your application partially to let the users know that this
    feature is not yet available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，还没有具体的实现，但我们正在定义在规范文件中指定并在`OrderManagementApi`接口中生成的先前方法。如果我们保留`super`调用（调用父接口的默认实现），服务器将返回`501
    Not Implemented` HTTP状态码给调用者。当您想部分部署应用程序并让用户知道此功能尚不可用时，这可能很有用。
- en: All the definitions in the OpenAPI specification file serve as documentation
    for the API. If you paste the specification into the online [editor.swagger.io](https://www.editor.swagger.io)
    tool or run the application and open the Swagger UI with your browser at the URL
    [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)
    , you will be able to see every operation and schema defined until now. This documentation
    represents the API contract, describing all the available resources, methods available
    to interact with them, and what data the API is expected to receive and return.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范文件中的所有定义都作为API的文档。如果您将规范粘贴到在线[editor.swagger.io](https://www.editor.swagger.io)工具中，或者运行应用程序并使用浏览器在URL[http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)打开Swagger
    UI，您将能够看到迄今为止定义的每个操作和模式。这份文档代表了API合约，描述了所有可用的资源、与它们交互的方法，以及API预期接收和返回的数据。
- en: '![Figure 4.6 – Swagger UI from the Order Management API specification](img/B21843_04_6.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 来自订单管理API规范的Swagger UI](img/B21843_04_6.png)'
- en: Figure 4.6 – Swagger UI from the Order Management API specification
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 来自订单管理API规范的Swagger UI
- en: This is the first step toward a concrete implementation of the operations defined
    in our API specification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现我们API规范中定义的操作的第一步。
- en: For the sake of brevity, we are not going to look at every step of the implementation
    process here, since the goal of this chapter is to show you how to have the code
    generated from the specification, as we saw in the previous sections. Feel free
    to refer to the source code in the GitHub repository for *Chapter 4* to have a
    deeper understanding of the implementation details, since this goes much deeper
    than what we are going to describe in this section alone.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们在这里不会查看实现过程的每一步，因为本章的目标是向您展示如何从规范中生成代码，正如我们在前面的章节中看到的那样。您可以自由地参考GitHub仓库中*第4章*的源代码，以深入了解实现细节，因为这将比本节中将要描述的深入得多。
- en: 'This is what the controller looks like after being implemented:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现后的控制器看起来像什么：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Looking at the implementation of the controller, we can notice some similar
    patterns as were implemented in the Product API, especially the usage of use cases
    and mappers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看控制器的实现，我们可以注意到一些与在产品API中实现的模式相似，特别是使用用例和映射器的使用。
- en: But unlike the Product API, here we override the generated code of the `OpenManagementAPI`
    interface where all the paths and operations are defined. Unlike the code-first
    approach, the documentation that has been already defined previously in the OpenAPI
    specification does not need to be repeated manually here, since it is contained
    within the generated `OpenManagementAPI` . This is the power of a specification-first
    (API-first) implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但与产品API不同，在这里我们覆盖了`OpenManagementAPI`接口的生成代码，其中定义了所有路径和操作。与代码优先的方法不同，之前在OpenAPI规范中已经定义的文档在这里不需要手动重复，因为它包含在生成的`OpenManagementAPI`中。这就是规范优先（API优先）实现的力量。
- en: 'In this controller, we are injecting three main interfaces that are used for
    the processing of all the business logic, persistence, and data layer transformation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们注入了三个主要接口，用于处理所有业务逻辑、持久性和数据层转换：
- en: '`OrdersCommandUseCase`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrdersCommandUseCase`'
- en: '`OrdersQueryUseCase`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrdersQueryUseCase`'
- en: '`OrderMapper`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderMapper`'
- en: Let us first focus on the use case implementations of this service, which are
    `OrdersCommandUseCase` and `OrdersQueryUseCase` , and their purpose within the
    Order Management API, starting with `OrdersCommandUseCaseImpl` .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注这个服务的用例实现，即`OrdersCommandUseCase`和`OrdersQueryUseCase`，以及它们在订单管理API中的作用，从`OrdersCommandUseCaseImpl`开始。
- en: Implementing OrdersCommandUseCase
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现OrdersCommandUseCase
- en: 'Let us start by implementing `OrdersCommandUseCase` with the `OrdersCommandUseCaseImpl`
    class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`OrdersCommandUseCaseImpl`类实现`OrdersCommandUseCase`开始：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As described earlier in the package structure, the `OrdersCommandUseCaseImpl`
    class contains the business logic of the service itself, the actions, and interactions
    with other components such as the repository and mapper, and even other services
    such as the Product API, as we will see in detail in the *Communicating with the
    Product API* section. That is why this class is annotated with the `@Service`
    annotation from Spring, indicating that it is a `Service` stereotype of Bean.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在包结构中，`OrdersCommandUseCaseImpl`类包含了服务本身的业务逻辑、操作以及与其他组件（如仓库和映射器）以及其他服务（如产品API）的交互，正如我们将在*与产品API通信*部分详细看到的那样。这就是为什么这个类被Spring的`@Service`注解标注，表示它是一个Bean的`Service`类型。
- en: Implementing OrdersQueryUseCase
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现OrdersQueryUseCase
- en: 'Moving to the implementation of `OrdersQueryUseCase` , we will have `OrdersQueryUseCaseImpl`
    :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`OrdersQueryUseCase`的实现，我们将有`OrdersQueryUseCaseImpl`：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `OrdersQueryUseCaseImpl` , we have a much smaller implementation, since here
    the focus is the interaction with the database. Any custom queries or requests
    that you would have just go into this class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OrdersQueryUseCaseImpl`中，我们的实现要小得多，因为这里的重点是与数据库的交互。任何你可能会有的自定义查询或请求都直接进入这个类。
- en: Configuring OrderMapper with MapStruct
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MapStruct配置OrderMapper
- en: And finally, there’s the `OrderMapper` interface. Unlike the use case classes,
    we do not implement any class here; instead, we define an interface with the mappings
    we want to have in our project. Since this project uses MapStruct for object mapping,
    we define the mapping within this interface and any custom mappings separately.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有`OrderMapper`接口。与用例类不同，我们在这里没有实现任何类；相反，我们定义了一个接口，其中包含了我们想在项目中拥有的映射。由于本项目使用MapStruct进行对象映射，我们在该接口内定义映射，并将任何自定义映射单独定义。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: '**MapStruct**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapStruct**'
- en: MapStruct is a code generator that simplifies the process of mapping between
    Java bean types by relying on a convention-over-configuration strategy. That is
    why we are defining this interface; it contains the configuration that MapStruct
    needs to generate the mapping code. Also, we are going to define a custom mapping
    for the cases when the basic generated mapping code is not enough.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MapStruct是一个代码生成器，通过依赖约定优于配置的策略简化了Java bean类型之间的映射过程。这就是我们定义这个接口的原因；它包含了MapStruct生成映射代码所需的配置。此外，我们还将为基本生成的映射代码不足以应对的情况定义一个自定义映射。
- en: 'Let us start with the interface definition:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从接口定义开始：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is what the `OrderMapper` interface looks like. We are defining the mapping
    operations that we want MapStruct to perform, such as the `toOrderRequest` operation,
    which is a mapping from an `OrderRequestBodyDto` object to an `OrderRequest` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`OrderMapper`接口的样子。我们正在定义MapStruct要执行映射操作，例如`toOrderRequest`操作，这是一个从`OrderRequestBodyDto`对象到`OrderRequest`对象的映射。
- en: Simple mapping with `Mapstruct` is straightforward, but when things get complicated,
    there is a need to introduce a custom mapping implementation for it. This is where
    the `CustomerCustomMapper` class gets into our mapping definition.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Mapstruct`进行简单映射很简单，但当事情变得复杂时，就需要引入一个自定义映射实现。这就是`CustomerCustomMapper`类进入我们的映射定义的地方。
- en: To have a custom mapping used with MapStruct, you need to create a custom mapping
    class and tell the interface to use it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MapStruct的定制映射，你需要创建一个自定义映射类，并告诉接口使用它。
- en: Here, we are adding the `CustomerCustomMapper` class in the `uses` property
    within the `@Mapper` annotation at the class level. This way, MapStruct knows
    that there is a custom implementation mapper that it needs to refer to.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在类级别的`@Mapper`注解的`uses`属性中添加了`CustomerCustomMapper`类。这样，MapStruct就知道有一个自定义实现映射器需要引用。
- en: This approach allows for partial or complete object mapping, depending on your
    requirements. In this case, we will perform partial mapping by using parts of
    the generated mapping from MapStruct and applying custom mapping to handle a specific
    complex object that the simple mapping cannot handle correctly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许根据你的需求进行部分或完整的对象映射。在这种情况下，我们将通过使用MapStruct生成的映射的部分来执行部分映射，并应用自定义映射来处理简单映射无法正确处理的特定复杂对象。
- en: For every mapping operation, such as `toOrder` , `toOrderRequest` , and `toOrderResponse`
    , if you have a custom mapping that changes the default mapping behavior from
    MapStruct, you need to specify it with the `@Mapping` annotation at the method
    level to tell MapStruct that you have a custom mapping.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个映射操作，例如`toOrder`、`toOrderRequest`和`toOrderResponse`，如果您有一个自定义映射，它改变了MapStruct的默认映射行为，您需要在该方法级别使用`@Mapping`注解来告诉MapStruct您有一个自定义映射。
- en: In our custom mapping example, both `target` and `source` properties specify
    that the `customer` property within the received parameter ( `orderRequestBody`
    in the `toOrderRequest` method and `order` in the `toOrderResponse` method) is
    going to be mapped in a custom way that needs to refer to the custom mapper implementation
    that is implemented by the `CustomerCustomMapper` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义映射示例中，`target`和`source`属性都指定了接收参数（`toOrderRequest`方法中的`orderRequestBody`和`toOrderResponse`方法中的`order`）中的`customer`属性将以自定义方式映射，需要引用由`CustomerCustomMapper`类实现的自定义映射器实现。
- en: Finally, the `qualifiedByName` property tells MapStruct which method to refer
    to for the mapping into the custom mapper, being identified by the `@Named` annotation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`qualifiedByName`属性告诉MapStruct要引用哪个方法进行映射到自定义映射器，该映射器由`@Named`注解标识。
- en: Due to the complexity and polymorphism introduced to have distinct types of
    customers with inheritance, this custom map was needed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引入了复杂性和多态性，以区分具有继承的不同类型的客户，因此需要这个自定义映射。
- en: 'So, let us look at this custom mapping specification:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这个自定义映射规范：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since this is a MapStruct component, it is annotated `@Component` so it can
    be created as a Bean in the Spring context and made available to be detected by
    the mapping generator during the build process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个MapStruct组件，它被注解为`@Component`，因此它可以作为一个Bean在Spring上下文中创建，并在构建过程中被映射生成器检测到。
- en: But the key aspect of it is the `@Named` method-level annotation, as mentioned
    earlier. It specifies the unique qualifier mentioned in the `qualifiedByName`
    MapStruct interface we just saw. The `customer` object is the only object being
    custom-mapped in the `CustomerCustomMapper` implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但其关键方面是前面提到的`@Named`方法级注解。它指定了我们在`qualifiedByName` MapStruct接口中提到的唯一限定符。`customer`对象是`CustomerCustomMapper`实现中唯一被自定义映射的对象。
- en: 'With that, when you generate your project using MapStruct, it will generate
    the mappings as specified in the `OrderMapper` interface, but it will call this
    custom-mapping implementation, as we can see in the generated code snippet in
    the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MapStruct生成项目时，它将生成`OrderMapper`接口中指定的映射，但它将调用这个自定义映射实现，正如我们可以在以下屏幕截图中的生成代码片段中看到：
- en: '![Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping](img/B21843_04_7.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 生成映射到OrderRequest调用客户自定义映射](img/B21843_04_7.png)'
- en: Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 生成映射到OrderRequest调用客户自定义映射
- en: You can find the generated code from the preceding screenshot in the `OrderMapperImpl`
    generated class after building your project under the `target` folder, within
    the `classes` folder, in the `mapper` package, where the `OrderMapper` interface
    and the `CustomerCustomMapper` class are also defined. But if you are using the
    **Packages** view in IntelliJ, the generated classes will be shown to you automatically
    in the `mapper` package with your own implemented classes, as seen before in this
    chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在构建项目后，在`target`文件夹中的`classes`文件夹内的`mapper`包中找到前一个屏幕截图中的生成代码，其中`OrderMapper`接口和`CustomerCustomMapper`类也被定义。但如果您在IntelliJ中使用**包**视图，生成的类将自动显示在`mapper`包中，与您之前在本章中看到的自己的实现类一起。
- en: Now, let us look at how the Order Management API can communicate with the Product
    API to validate the products in the received orders.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看订单管理API如何与产品API通信以验证接收到的订单中的产品。
- en: Communicating with the Product API
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用产品API进行通信
- en: To validate whether the products of an order exist, the Order Management API
    validates the inserted product SKUs against the Product API through an API call
    either when a new order is created or when an order update contains an insertion
    of a new product into the order.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证订单中的产品是否存在，订单管理API通过API调用验证插入的产品SKU与产品API，无论是在创建新订单时还是在订单更新包含将新产品插入订单时。
- en: In real-world production applications, the Product API may need to validate
    whether there are enough products available in stock to be added to the order
    and respond properly if there are not. For our purposes of demonstrating how to
    create APIs, we will show how to validate whether the products of an order exist
    within Product API service data and retrieve their prices to be added to our order.
    If a product is not found, the Order Management API will return a proper message
    with a `404 Not Found` HTTP status code and the error message `Product not found`
    , explaining that the order cannot be placed because that product does not exist
    and needs to be created in the Product API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的生产应用中，Product API 可能需要验证库存中是否有足够的产品可以添加到订单中，并在没有足够产品时正确响应。为了展示如何创建 API
    的目的，我们将展示如何验证订单中的产品是否存在于 Product API 服务数据中，并检索它们的定价以添加到我们的订单中。如果找不到产品，订单管理 API
    将返回一个带有`404 Not Found` HTTP 状态码和错误消息`Product not found`的正确消息，解释说由于该产品不存在，无法下订单，需要在
    Product API 中创建它。
- en: To make this call, we will generate the client from the Product API specification.
    Since this chapter is about generating code, why not generate the client to retrieve
    the data from the Product API itself?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个调用，我们将从 Product API 规范生成客户端。由于本章是关于生成代码的，为什么不生成从 Product API 本身检索数据的客户端呢？
- en: You saw in the previous section, in the `OrdersCommandUseCaseImpl` implementation,
    the `updateProductPrice` method. This private method makes use of `productsQueryUseCase.getProductById`
    to retrieve the data of the product with the generated client and calculate the
    total value of the order based on the products it contains.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前面的部分中看到了，在`OrdersCommandUseCaseImpl`实现中，`updateProductPrice`方法。这个私有方法使用`productsQueryUseCase.getProductById`通过生成的客户端检索产品的数据，并根据它包含的产品计算订单的总价值。
- en: To have this client generated, we will need to update our generator plugin,
    adding the Product API specification to it, and generating a new build.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成这个客户端，我们需要更新我们的生成器插件，向其中添加 Product API 规范，并生成一个新的构建。
- en: 'Let us start with updating the OpenAPI generator plugin. We will be adding
    a second execution to it, below the first execution created at the beginning of
    this chapter. This is what it looks like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新 OpenAPI 生成器插件开始。我们将在本章开头创建的第一个执行下面添加第二个执行。它看起来是这样的：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The configuration here is similar to what we did in the first generator using
    the Order Management API specification, in the *Generating code from the specification*
    section, but now we will point to the Product API specification instead. There
    are only a few differences that we will detail now and, as we did for the first
    generator, let us go through each of the items to have them detailed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配置与我们在使用订单管理 API 规范的第一个生成器中做的类似，在*从规范生成代码*部分，但现在我们将指向 Product API 规范。现在我们将详细说明只有几个差异，就像我们对第一个生成器所做的那样，让我们逐一查看每个项目：
- en: '`<execution>` : This defines a specific execution of the plugin. Each execution
    can have its own configuration and goals. Here, we are adding a new one.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<execution>`：这定义了插件的特定执行。每个执行都可以有自己的配置和目标。在这里，我们添加了一个新的。'
- en: '`<id>` : This is a unique identifier for this execution. In this case, it is
    `generate-client` . In the previous execution, we used `generate-server` as the
    ID.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<id>`：这是这个执行的唯一标识符。在这种情况下，它是`generate-client`。在前一个执行中，我们使用`generate-server`作为
    ID。'
- en: '`<goals>` : This specifies the goals to be executed. Here, the goal is `generate`
    , which triggers the code generation process.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<goals>`：这指定了要执行的目标。在这里，目标是`generate`，它触发了代码生成过程。'
- en: '`<configuration>` : This contains the configuration options for this execution.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<configuration>`：这包含了这个执行的配置选项。'
- en: '`<inputSpec>` : This specifies the path to the OpenAPI specification file.
    Here, it is `${project.basedir}/src/main/resources/Product_API.json` , which is
    where the Product API specification is contained within this service. The specification
    is in the JSON format that we could download using the Product API Swagger UI.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<inputSpec>`：这指定了 OpenAPI 规范文件的路径。在这里，它是`${project.basedir}/src/main/resources/Product_API.json`，这是
    Product API 规范包含在这个服务中的位置。规范是 JSON 格式，我们可以使用 Product API Swagger UI 下载。'
- en: '`<generatorName>` : This defines the generator to use. In this case, it is
    `java` , indicating that Java client code will be generated.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<generatorName>`：这定义了要使用的生成器。在这种情况下，它是`java`，表示将生成 Java 客户端代码。'
- en: '`<library>` : This specifies the library to use for the generated code. Here,
    it is `restclient` , which generates a REST client.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<library>` : 这指定了用于生成代码的库。在这里，它是 `restclient` ，它生成一个 REST 客户端。'
- en: '`<apiPackage>` : This defines the package for the generated API classes. Here,
    it is `com.packt.ordermanagementapi.adapter.outbound.rest` .'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<apiPackage>` : 这定义了生成 API 类的包。在这里，它是 `com.packt.ordermanagementapi.adapter.outbound.rest`
    。'
- en: '`<modelPackage>` : This defines the package for the generated model classes.
    Here, it is `com.packt.ordermanagementapi.adapter.outbound.rest.dto` .'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<modelPackage>` : 这定义了生成模型类的包。在这里，它是 `com.packt.ordermanagementapi.adapter.outbound.rest.dto`
    。'
- en: '`<modelNameSuffix>` : This adds a suffix to the names of the generated model
    classes. Here, it is `Dto` .'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<modelNameSuffix>` : 这将为生成的模型类名称添加后缀。在这里，它是 `Dto` 。'
- en: '`<generateApiTests>` : When set to `false` , API test classes will not be generated.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<generateApiTests>` : 当设置为 `false` 时，不会生成 API 测试类。'
- en: '`<generateModelTests>` : When set to `false` , model test classes will not
    be generated.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<generateModelTests>` : 当设置为 `false` 时，不会生成模型测试类。'
- en: '`<configOptions>` : This contains additional configuration options for the
    generator.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<configOptions>` : 这包含生成器的附加配置选项。'
- en: '`<interfaceOnly>` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<interfaceOnly>` : 当设置为 `true` 时，将仅生成 API 的接口，而不生成任何实现。'
- en: '`<useJakartaEe>` : When set to `true` , the generated code will use Jakarta
    EE instead of Java EE.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<useJakartaEe>` : 当设置为 `true` 时，生成的代码将使用 Jakarta EE 而不是 Java EE。'
- en: '`<openApiNullable>` : When set to `false` , the generator will not use the
    `@Nullable` annotation for optional fields.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<openApiNullable>` : 当设置为 `false` 时，生成器将不会为可选字段使用 `@Nullable` 注解。'
- en: 'Having our plugin configured and pointing to the Product API specification,
    we can proceed to generate a new build that will generate the REST client from
    the specification, along with the DTOs needed for it. Again, we will run the Maven
    command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在将插件配置好并指向产品 API 规范后，我们可以继续生成一个新的构建，该构建将从规范生成 REST 客户端，以及所需的 DTO。同样，我们将运行 Maven
    命令：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After a successful build, this will generate the DTOs and the API classes into
    the specified packages that were configured in the plugin, as you can see in the
    following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建成功后，这将在插件中配置的指定包中生成 DTO 和 API 类，如下面的截图所示：
- en: '![Figure 4.8 – Generated Product API client and DTO classes](img/B21843_04_8.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 生成的产品 API 客户端和 DTO 类](img/B21843_04_8.png)'
- en: Figure 4.8 – Generated Product API client and DTO classes
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 生成的产品 API 客户端和 DTO 类
- en: This approach is extremely powerful since we already have the specification
    of the service that our API is going to consume. This can save hours of development
    time just by having the code and the client generated quickly for you.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常强大，因为我们已经有了我们 API 将要消费的服务的规范。这可以通过快速为你生成代码和客户端来节省数小时的开发时间。
- en: You could think of an alternative solution where the client code would be generated
    as a module by the service providing the (Product) API and a client interested
    in consuming the API would just use the code as a library in the form of a JAR
    file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象一个替代方案，其中客户端代码将由提供（产品）API 的服务生成作为一个模块，而感兴趣的客户端只需将代码作为 JAR 文件形式的库来使用。
- en: This may look like making the life of the consumer implementers even easier,
    but it has serious drawbacks. It would force the consumer to be compatible with
    the library (and a particular version of it) used inside the JAR file. It would
    not support non-Java consumers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来让消费者的生活变得更简单，但它有严重的缺点。它将迫使消费者与 JAR 文件内使用的库（及其特定版本）兼容。它不支持非 Java 消费者。
- en: One of the advantages of microservices architecture is the loose coupling between
    the services. Depending on JAR files to consume APIs of different microservices
    creates unwanted coupling and defeats the purpose of making the application distributed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个优点是服务之间的松散耦合。依赖于 JAR 文件来消费不同微服务的 API 会导致不希望的耦合，并违背了使应用程序分布化的目的。
- en: 'If you noticed when we looked at the `OrdersCommandUseCaseImpl` class in the
    previous section, there was a private method that uses this generated Product
    API client called `updateProductPrice` . Let us look at how it works and how to
    make the best use of it inside the Order Management API:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了我们在上一节查看 `OrdersCommandUseCaseImpl` 类时，有一个使用此生成的产品 API 客户端的私有方法，名为 `updateProductPrice`。让我们看看它是如何工作的，以及如何在订单管理
    API 中充分利用它：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `productsQueryUseCase` is injected into `OrdersCommandUseCaseImpl` , where
    all related calls to the external Product API are handled. Within the `updateProductPrice`
    method, the `getProductById` method from `ProductsQueryUseCase` is called for
    each product in the order request, passing the unique product identifier (product
    SKU) to retrieve the product details.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`productsQueryUseCase` 被注入到 `OrdersCommandUseCaseImpl` 中，处理所有对外部产品 API 的相关调用。在
    `updateProductPrice` 方法中，对订单请求中的每个产品，都会调用 `ProductsQueryUseCase` 中的 `getProductById`
    方法，传递唯一的商品标识符（产品 SKU）以检索产品详情。
- en: Our goal is to validate whether these products exist in the Product API and
    get their value to be added to the total of the order.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是验证这些产品是否存在于产品 API 中，并获取它们的值以添加到订单总额中。
- en: If the product is found, it will be returned and attributed to the `ProductDetails`
    variable named `catalogueProduct` , and the price of the individual product will
    be set in the products list.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到产品，它将被返回并分配给名为 `catalogueProduct` 的 `ProductDetails` 变量，并且单个产品的价格将被设置在产品列表中。
- en: If any of the products in the order are not found in the Products API, `404
    Not Found` will be returned from this external API call and will be caught by
    the `GlobalExceptionHandler` of the application, interrupting the order creation.
    This is the expected behavior since we do not want to allow any order to be created
    with a product that does not exist.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单中的任何产品在产品 API 中找不到，则此外部 API 调用将返回 `404 Not Found`，并被应用程序的 `GlobalExceptionHandler`
    捕获，中断订单创建。这是预期的行为，因为我们不希望允许创建任何不存在产品的订单。
- en: If you are curious about the code generated by the plugin and how the REST client
    was built, we encourage you to generate your own code to see it in action following
    these steps. You can also always refer to the chapter code in the official repository
    of this book at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对插件生成的代码以及如何构建 REST 客户端感兴趣，我们鼓励你按照这些步骤生成自己的代码以查看其实际效果。你也可以始终参考本书官方仓库中的章节代码，网址为
    [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the main differences between specification-first,
    (API-first), and code-first development. We developed an OpenAPI specification
    from scratch in detail, going through each part of its structure, creating paths
    and methods with parameters, defining schemas for generating the DTOs to use in
    the requests, responses, and as parameters, and defining a security scheme.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了规范优先（API-first）、代码优先开发之间的主要区别。我们从头开始详细开发了一个 OpenAPI 规范，逐部分介绍了其结构，创建了带有参数的路径和方法，定义了用于请求、响应和作为参数的
    DTO 生成模式，并定义了一个安全方案。
- en: Then we configured the Order Management API service with the OpenAPI code generator
    plugin for Maven and looked at each necessary parameter to have the code generated
    properly as expected and ran a successful build using the OpenAPI plugin.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 Maven 的 OpenAPI 代码生成器插件配置了订单管理 API 服务，并查看每个必要的参数以确保代码按预期正确生成，并使用 OpenAPI
    插件成功构建。
- en: After that, we started to look at the generated code, where it is located, and
    how to see it along with your own code implementation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始查看生成的代码，它的位置以及如何与自己的代码实现一起查看。
- en: We went through an overview of the architectural package structure for the project
    and the objective of each package in the structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了项目的架构包结构以及结构中每个包的目标。
- en: Next, we implemented our controller, using the generated interface from the
    specification, initially by overriding the methods and then by creating a real
    working implementation with all the features expected for this service, with a
    deep dive into the code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们实现了我们的控制器，使用规范生成的接口，最初是通过覆盖方法，然后通过创建一个具有所有预期功能的实际工作实现，深入代码。
- en: Finally, we learned how to expand our code generator by adding a new execution
    into the OpenAPI plugin and generated a REST client to call the Product API.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何通过向 OpenAPI 插件添加新的执行来扩展我们的代码生成器，并生成了一个用于调用产品 API 的 REST 客户端。
- en: We used the generated Product API client to call and validate the products in
    the creation or update flow of an order, checking whether it exists in the Product
    API and computing the total of the order. If any product is not found, it just
    aborts the creation or update of the order.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了生成的产品API客户端来调用和验证订单创建或更新流程中的产品，检查它是否存在于产品API中，并计算订单总额。如果任何产品未找到，它将直接终止订单的创建或更新。
- en: In the next chapter, you will get to know more about some advanced API concepts
    – how to handle timeouts, retries, and more – that could be used in a scenario
    where the Product API is unavailable at a certain request of the Order Management
    API, and how to handle it properly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到一些高级API概念——如何处理超时、重试等，这些概念可以在产品API在订单管理API的某个请求不可用时使用，以及如何正确处理这种情况。
