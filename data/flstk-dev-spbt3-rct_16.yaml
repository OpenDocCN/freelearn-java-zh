- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Adding CRUD Functionalities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 CRUD 功能
- en: This chapter describes how we can implement **Create**, **Read**, **Update**,
    and **Delete** (**CRUD**) functionalities in our frontend. We are going to use
    the components that we learned about in *Chapter 11*, *Useful Third-Party Components
    for React*. We will fetch data from our backend and present the data in a table.
    Then, we will implement the delete, edit, and create functionalities. In the final
    part of this chapter, we will add features so that we can export our data to a
    CSV file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何在我们的前端中实现 **创建**、**读取**、**更新** 和 **删除**（**CRUD**）功能。我们将使用我们在 *第 11 章*，*React
    的有用第三方组件* 中学习到的组件。我们将从后端获取数据并在表格中展示数据。然后，我们将实现删除、编辑和创建功能。在本章的最后部分，我们将添加功能，以便我们可以将数据导出为
    CSV 文件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the list page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建列表页面
- en: Adding the delete functionality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加删除功能
- en: Adding the add functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加添加功能
- en: Adding the edit functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加编辑功能
- en: Exporting the data to CSV
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据导出为 CSV
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot `cardatabase` application that we created in *Chapter 12*, *Setting
    Up the Frontend for Our Spring Boot RESTful Web Service*, (the unsecured backend)
    is required, as is the React app that we created in the same chapter, `carfront`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第 12 章*，*为我们的 Spring Boot RESTful Web 服务设置前端* 中创建的 Spring Boot `cardatabase`
    应用程序（未加密的后端）以及同一章中创建的 React 应用程序 `carfront` 都是必需的。
- en: 'The following GitHub link will also be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要以下 GitHub 链接：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13)。
- en: Creating the list page
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表页面
- en: 'In this first section, we will create the list page to show cars with paging,
    filtering, and sorting features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将创建一个列表页面来显示带有分页、过滤和排序功能的汽车：
- en: 'Run your unsecured Spring Boot backend. The cars can be fetched by sending
    the `GET` request to the `http://localhost:8080/api/cars` URL, as shown in *Chapter
    4*, *Creating a RESTful Web Service with Spring Boot*. Now, let’s inspect the
    JSON data from the response. The array of cars can be found in the `_embedded.cars`
    node of the JSON response data:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的未加密的 Spring Boot 后端。可以通过向 `http://localhost:8080/api/cars` URL 发送 `GET`
    请求来获取汽车，如 *第 4 章*，*使用 Spring Boot 创建 RESTful Web 服务* 中所示。现在，让我们检查响应中的 JSON 数据。汽车数组可以在
    JSON 响应数据的 `_embedded.cars` 节点中找到：
- en: '![](img/B19818_13_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_01.png)'
- en: 'Figure 13.1: Fetching cars'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：获取汽车
- en: Open the `carfront` React app with Visual Studio Code (the React app we created
    in the previous chapter).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 打开 `carfront` React 应用程序（我们在上一章中创建的 React 应用程序）。
- en: We are using React Query for networking, so we have to initialize the query
    provider first.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用 React Query 进行网络操作，因此我们首先需要初始化查询提供者。
- en: You learned the basics of React Query in *Chapter 10*, *Consuming the REST API
    with React*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 *第 10 章*，*使用 React 消费 REST API* 中学习了 React Query 的基础知识。
- en: 'The `QueryClientProvider` component is used to connect and provide `QueryClient`
    to your application. Open your `App.tsx` file and add the highlighted imports
    and components to your `App` component:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QueryClientProvider` 组件来连接并提供 `QueryClient` 给你的应用程序。打开你的 `App.tsx` 文件，并将高亮的导入和组件添加到
    `App` 组件中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s fetch some cars.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些汽车。
- en: Fetching data from the backend
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从后端获取数据
- en: 'Once we know how to fetch cars from the backend, we will be ready to implement
    the list page to show the cars. The following steps describe this in practice:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何从后端获取汽车，我们就可以准备实现列表页面来显示汽车。以下步骤描述了实际操作：
- en: 'When your app has multiple components, it is recommended that you create a
    folder for them. Create a new folder called `components` in the `src` folder.
    With Visual Studio Code, you can create a folder by right-clicking the folder
    in the sidebar file explorer and selecting **New Folder...** from the menu:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的应用程序有多个组件时，建议为它们创建一个文件夹。在 `src` 文件夹中创建一个名为 `components` 的新文件夹。使用 Visual Studio
    Code，你可以通过在侧边栏文件资源管理器中右键单击文件夹并从菜单中选择 **New Folder...** 来创建文件夹：
- en: '![](img/B19818_13_02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_02.png)'
- en: 'Figure 13.2: New folder'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：新文件夹
- en: 'Create a new file called `Carlist.tsx` in the `components` folder. Your project
    structure should look like the following:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中创建一个名为`Carlist.tsx`的新文件。你的项目结构应该如下所示：
- en: '![](img/B19818_13_03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_03.png)'
- en: 'Figure 13.3: Project structure'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：项目结构
- en: 'Open the `Carlist.tsx` file in the editor view and write the base code of the
    component, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器视图中打开`Carlist.tsx`文件，并编写组件的基本代码，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, when we are using TypeScript, we have to define the type for our car data.
    Let’s create a new file where we define our types. Create a file called `types.ts`
    in the `src` folder of your project. From the response, you can see that the car
    object looks like the following, and it contains all the car properties and also
    links:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们使用TypeScript时，我们必须为我们的汽车数据定义类型。让我们创建一个新文件，在那里定义我们的类型。在你的项目`src`文件夹中创建一个名为`types.ts`的文件。从响应中，你可以看到汽车对象看起来如下，它包含所有汽车属性，还包括链接：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create the following `CarResponse` type in the `types.ts` file and export it
    so that we can use it in files where it is needed:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`types.ts`文件中创建以下`CarResponse`类型，并导出它，以便我们可以在需要它的文件中使用：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will create a function that fetches cars from our backend by sending
    a `GET` request to the `http://localhost:8080/api/cars` endpoint. The function
    returns a **promise** that contains an array of `CarResponse` objects that we
    defined in our `types.ts` file. We can use the `Promise<Type>` generic, where
    `Type` indicates the resolved value type of the promise. Open the `Carlist.tsx`
    file and add the following imports and function:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数，通过向我们的后端发送一个`GET`请求到`http://localhost:8080/api/cars`端点来获取汽车。该函数返回一个包含我们定义在`types.ts`文件中的`CarResponse`对象数组的**promise**。我们可以使用`Promise<Type>`泛型，其中`Type`表示promise解析的值类型。打开`Carlist.tsx`文件，并添加以下导入和函数：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will use the `useQuery` hook to fetch cars:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`useQuery`钩子来获取汽车：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `useQuery` hook uses TypeScript generics because it doesn’t fetch data
    and doesn’t know the type of your data. However, React Query can infer the type
    of the data, so we don’t have to do it manually here using generics. If you explicitly
    set generics, the code looks like this:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useQuery`钩子使用TypeScript泛型，因为它不获取数据，也不知道你的数据类型。然而，React Query可以推断数据类型，因此我们在这里不需要手动使用泛型。如果你显式设置泛型，代码看起来像这样：'
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will use **conditional rendering** to check if the fetch is successful and
    if there are any errors. If `isSuccess` is `false`, it means the data fetching
    is still in progress and, in this case, a loading message is returned. We also
    check if `error` is `true`, which indicates there’s an error, and an error message
    is returned. When data is available, we use the `map` function to transform car
    objects into table rows in the `return` statement and add the `table` element:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用**条件渲染**来检查获取操作是否成功以及是否存在任何错误。如果`isSuccess`为`false`，则表示数据获取仍在进行中，在这种情况下，会返回一个加载信息。我们还会检查`error`是否为`true`，这表示存在错误，并返回一个错误信息。当数据可用时，我们使用`map`函数将汽车对象转换成`return`语句中的表格行，并添加`table`元素：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we have to import and render the `Carlist` component in our `App.tsx`
    file. In the `App.tsx` file, add the `import` statement, and then render the `Carlist`
    component inside the `QueryClientProvider` component, as highlighted. `QueryClientProvider`
    is a component that provides the React Query context to your components, and it
    should wrap the components where you are making REST API requests from:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在`App.tsx`文件中导入并渲染`Carlist`组件。在`App.tsx`文件中，添加`import`语句，然后渲染`Carlist`组件在`QueryClientProvider`组件内部，如高亮所示。`QueryClientProvider`是一个提供React
    Query上下文到你的组件的组件，它应该包裹你进行REST API请求的组件：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you start the React app using the `npm run dev` command, you should
    see the following list page. Note that your backend should also be running:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用`npm run dev`命令启动React应用，你应该看到以下列表页面。请注意，你的后端也应该正在运行：
- en: '![](img/B19818_13_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_04.png)'
- en: 'Figure 13.4: Car frontend'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：汽车前端
- en: Using environment variables
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Let’s do some code refactoring before we move on. The server URL can be repeated
    multiple times in the source code when we create more CRUD functionalities, and
    it will change when the backend is deployed to a server other than the local host;
    therefore, it is better to define it as an **environment variable**. Then, when
    the URL value changes, we only have to modify it in one place.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们做一些代码重构。当我们在源代码中创建更多的 CRUD 功能时，服务器 URL 可以重复多次，并且当后端部署到非本地主机的服务器时，它将发生变化；因此，最好将其定义为
    **环境变量**。然后，当 URL 值更改时，我们只需在一个地方修改它。
- en: 'When using Vite, environment variable names should start with the text `VITE_`.
    Only variables prefixed with `VITE_` are exposed to your source code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Vite 时，环境变量名称应该以文本 `VITE_` 开头。只有以 `VITE_` 为前缀的变量才会暴露给您的源代码：
- en: 'Create a new `.env` file in the root folder of our app. Open the file in the
    editor and add the following line to the file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们应用程序的根文件夹中创建一个新的 `.env` 文件。在编辑器中打开文件，并添加以下行到文件中：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also separate all API call functions into their own module. Create
    a new folder named `api` in the `src` folder of your project. Create a new file
    called `carapi.ts` in the `api` folder, and now your project structure should
    look like the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将所有 API 调用函数分离到它们自己的模块中。在您的项目 `src` 文件夹中创建一个名为 `api` 的新文件夹。在 `api` 文件夹中创建一个名为
    `carapi.ts` 的新文件，现在您的项目结构应该如下所示：
- en: '![](img/B19818_13_05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_05.png)'
- en: 'Figure 13.5: Project structure'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：项目结构
- en: 'Copy the `getCars` function from the `Carlist.tsx` file to the `carapi.ts`
    file. Add `export` at the beginning of the function so that we can use it in other
    components. In Vite, the environment variables are exposed to your app source
    code via `import.meta.env` as strings. Then, we can import the server URL environment
    variable to our `getCars` function and use it there. We also need to import `axios`
    and the `CarResponse` type into the `carapi.ts` file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `getCars` 函数从 `Carlist.tsx` 文件复制到 `carapi.ts` 文件中。在函数开头添加 `export`，以便我们可以在其他组件中使用它。在
    Vite 中，环境变量通过 `import.meta.env` 作为字符串暴露给您的应用程序源代码。然后，我们可以将服务器 URL 环境变量导入到 `getCars`
    函数中并在那里使用它。我们还需要将 `axios` 和 `CarResponse` 类型导入到 `carapi.ts` 文件中：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can remove the `getCars` function and unused `axios` import from the
    `Carlist.tsx` file and import it from the `carapi.ts` file. The source code should
    appear as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `Carlist.tsx` 文件中移除 `getCars` 函数和未使用的 `axios` 导入，并从 `carapi.ts` 文件中导入它。源代码应如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After these refactoring steps, you should see the car list page like previously.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些重构步骤之后，您应该看到与之前相同的汽车列表页面。
- en: Adding paging, filtering, and sorting
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加分页、过滤和排序
- en: 'We have already used the `ag-grid` component to implement a data grid in *Chapter
    11*, *Useful Third-Party Components for React*, and it could be used here as well.
    Instead, we will use the new MUI `DataGrid` component to get paging, filtering,
    and sorting features out of the box:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *第 11 章* 中使用了 `ag-grid` 组件来实现数据网格，*React 的有用第三方组件*，它也可以在这里使用。相反，我们将使用新的
    MUI `DataGrid` 组件来获得开箱即用的分页、过滤和排序功能：
- en: Stop the development server by pressing *Ctrl* + *C* in the terminal.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中按 *Ctrl* + *C* 停止开发服务器。
- en: 'We will install the MUI data grid community version. The following is the installation
    command at the time of writing, but you should check the latest installation command
    and usage from the MUI documentation:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将安装 MUI 数据网格社区版。以下是在撰写本文时的安装命令，但您应该从 MUI 文档中检查最新的安装命令和用法：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After installation, restart the app.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，重新启动应用程序。
- en: 'Import the `DataGrid` component into your `Carlist.tsx` file. We will also
    import `GridColDef`, which is a type for the column definitions in the MUI data
    grid:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DataGrid` 组件导入到您的 `Carlist.tsx` 文件中。我们还将导入 `GridColDef`，它是 MUI 数据网格中列定义的类型：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The grid columns are defined in the `columns` variable, which has the type
    `GridColDef[]`. The column `field` property defines where data in the columns
    is coming from; we are using our car object properties. The `headerName` prop
    can be used to set the title of the columns. We will also set the width of the
    columns. Add the following column definition code inside the `Carlist` component:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格列定义在 `columns` 变量中，该变量具有 `GridColDef[]` 类型。列的 `field` 属性定义了列中的数据来源；我们使用我们的汽车对象属性。`headerName`
    属性可以用来设置列的标题。我们还将设置列的宽度。在 `Carlist` 组件内部添加以下列定义代码：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, remove the `table` and all its child elements from the component’s `return`
    statement and add the `DataGrid` component. Also remove the unused `CarResponse`
    import that we used in the `map` function. The data source of the data grid is
    the `data`, which contains fetched cars and is defined using the `rows` prop.
    The `DataGrid` component requires all rows to have a unique ID property that is
    defined using the `getRowId` prop. We can use the `link` field of the car object
    because that contains the unique car ID (`_links.self.href`). Refer to the source
    code of the following `return` statement:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从组件的`return`语句中移除`table`及其所有子元素，并添加`DataGrid`组件。同时移除在`map`函数中使用的未使用的`CarResponse`导入。数据网格的数据源是`data`，它包含获取的汽车，并使用`rows`属性定义。`DataGrid`组件要求所有行都具有一个唯一的ID属性，该属性使用`getRowId`属性定义。我们可以使用汽车对象的`link`字段，因为它包含唯一的汽车ID（`_links.self.href`）。请参考以下`return`语句的源代码：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the MUI `DataGrid` component, we implemented all the necessary features
    for our table with only a small amount of coding. Now, the list page looks like
    the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MUI `DataGrid`组件，我们仅通过少量编码就实现了我们表格的所有必要功能。现在，列表页面看起来如下所示：
- en: '![](img/B19818_13_06.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/B19818_13_06.png)'
- en: 'Figure 13.6: Car frontend'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：汽车前端
- en: 'Data grid columns can be filtered using the column menu and clicking the **Filter**
    menu item. You can also set the visibility of the columns from the column menu:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据网格列可以通过列菜单和点击**筛选**菜单项进行筛选。您还可以从列菜单设置列的可见性：
- en: '![](img/B19818_13_07.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/B19818_13_07.png)'
- en: 'Figure 13.7: Column menu'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：列菜单
- en: Next, we will implement the delete functionality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现删除功能。
- en: Adding the delete functionality
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加删除功能
- en: 'Items can be deleted from the database by sending the `DELETE` method request
    to the `http://localhost:8080/api/cars/{carId}` endpoint. If we look at the JSON
    response data, we can see that each car contains a link to itself, which can be
    accessed from the `_links.self.href` node, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向`http://localhost:8080/api/cars/{carId}`端点发送`DELETE`方法请求从数据库中删除项目。如果我们查看JSON响应数据，我们可以看到每辆车都包含一个指向自身的链接，该链接可以从`_links.self.href`节点访问，如下面的截图所示：
- en: '![](img/B19818_13_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/B19818_13_08.jpg)'
- en: 'Figure 13.8: Car link'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：汽车链接
- en: We already used the `link` field in the previous section to set a unique ID
    for every row in the grid. That row ID can be used in deletion, as we will see
    later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中使用了`link`字段来为网格中的每一行设置一个唯一的ID。该行ID可以在删除时使用，正如我们稍后将要看到的。
- en: 'The following steps demonstrate how to implement the delete functionality:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何实现删除功能：
- en: First, we will create a button for each row in the MUI `DataGrid`. When we need
    more complex cell content, we can use the `renderCell` column property to define
    how a cell’s contents are rendered.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在MUI `DataGrid`的每一行创建一个按钮。当我们需要更复杂的单元格内容时，我们可以使用`renderCell`列属性来定义单元格内容如何渲染。
- en: 'Let’s add a new column to the table using `renderCell` to render the `button`
    element. The `params` argument that is passed to the function is a row object
    that contains all values from a row. The type of `params` is `GridCellParams`,
    which is provided by MUI. In our case, it contains a link to a car in each row,
    and that is needed in the deletion. The link is in the row’s `_links.self.href`
    property, and we will pass this value to a `delete` function. Let’s first show
    an alert with the ID when a button is pressed to test that the button is working
    properly. Refer to the following source code:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用`renderCell`来向表中添加一个新列，以渲染`button`元素。传递给函数的`params`参数是一个包含一行所有值的行对象。`params`的类型是`GridCellParams`，由MUI提供。在我们的情况下，它包含每行中的一个指向汽车的链接，这在删除时是必需的。链接位于行的`_links.self.href`属性中，我们将传递此值到`delete`函数。让我们首先在按钮被按下时显示一个带有ID的警告框来测试按钮是否正常工作。请参考以下源代码：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We don’t want to enable sorting and filtering for the `button` column, so the
    `filterable` and `sortable` props are set to `false`. We also disable the column
    menu in this column by setting the `disableColumnMenu` prop to `true`. The button
    invokes the `onDelClick` function when pressed and passes a link (`row.id`) to
    the function as an argument, and the link value is shown in an alert.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不想为`按钮`列启用排序和筛选功能，因此将`filterable`和`sortable`属性设置为`false`。我们还将此列的列菜单禁用，通过将`disableColumnMenu`属性设置为`true`。按钮在被按下时会调用`onDelClick`函数，并将一个链接（`row.id`）作为参数传递给该函数，链接值将在一个警告框中显示。
- en: 'Now, you should see a **delete** button in each row. If you press any of the
    buttons, you can see an alert that shows the link for the car. To delete a car,
    we should send a `DELETE` request to its link:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该在每个行中看到一个 **删除** 按钮。如果你按下任何一个按钮，你可以看到一个显示汽车链接的警告。要删除汽车，我们应该向其链接发送一个 `DELETE`
    请求：
- en: '![](img/B19818_13_09.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_09.png)'
- en: 'Figure 13.9: Delete button'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：删除按钮
- en: 'Next, we will implement the `deleteCar` function, which sends the `DELETE`
    request to a car link using the Axios `delete` method. A `DELETE` request to the
    backend returns a deleted car object. We will implement the `deleteCar` function
    in the `carapi.ts` file and export it. Open the `carapi.ts` file and add the following
    function there:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `deleteCar` 函数，该函数使用 Axios 的 `delete` 方法向汽车链接发送 `DELETE` 请求。向后端发送
    `DELETE` 请求会返回一个已删除的汽车对象。我们将在 `carapi.ts` 文件中实现 `deleteCar` 函数并将其导出。打开 `carapi.ts`
    文件并添加以下函数：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We use the React Query `useMutation` hook to handle deletion. We saw an example
    in *Chapter 10*. First, we have to add the `useMutation` import to the `Carlist.tsx`
    file. We will also import the `deleteCar` function from the `carapi.ts` file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 React Query 的 `useMutation` 钩子来处理删除。我们在 *第 10 章* 中看到了一个例子。首先，我们必须将 `useMutation`
    导入到 `Carlist.tsx` 文件中。我们还将从 `carapi.ts` 文件中导入 `deleteCar` 函数：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `useMutation` hook, which calls our `deleteCar` function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `useMutation` 钩子，它调用我们的 `deleteCar` 函数：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, call `mutate` in our delete button and pass the car link as an argument:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的删除按钮中调用 `mutate` 并将汽车链接作为参数传递：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, if you start the app and press the **delete** button, the car is deleted
    from the database, but it still exists in the frontend. You can manually refresh
    the browser, after which the car disappears from the table.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你启动应用程序并按下 **删除** 按钮，汽车将从数据库中删除，但在前端它仍然存在。你可以手动刷新浏览器，之后汽车将从表中消失。
- en: 'We can also refresh the frontend automatically when a car is deleted. In React
    Query, the fetched data is saved to a cache that the query client handles. The
    `QueryClient` has a **query invalidation** feature that we can use to fetch data
    again. First, we have to import and call the `useQueryClient` hook function, which
    returns the current query client:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在删除汽车时自动刷新前端。在 React Query 中，获取的数据被保存到一个由查询客户端处理的缓存中。`QueryClient` 有一个
    **查询失效** 功能，我们可以使用它来重新获取数据。首先，我们必须导入并调用 `useQueryClient` 钩子函数，它返回当前的查询客户端：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `queryClient` has an `invalidateQueries` method that we can call to re-fetch
    our data after successful deletion. You can pass the key of the query that you
    want to re-fetch. Our query key for fetching cars is `cars`, which we defined
    in our `useQuery` hook:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryClient` 有一个 `invalidateQueries` 方法，我们可以在成功删除后调用它来重新获取我们的数据。你可以传递你想要重新获取的查询的键。我们获取汽车的查询键是
    `cars`，我们在 `useQuery` 钩子中定义了它：'
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, every time a car is deleted, all the cars are fetched again. The car disappears
    from the list when the **Delete** button is pressed. After a deletion, you can
    restart the backend to re-populate the database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次删除汽车时，都会重新获取所有汽车。当按下 **删除** 按钮时，汽车从列表中消失。删除后，你可以重新启动后端以重新填充数据库。
- en: 'You can also see that when you click any row in the grid, the row is selected.
    You can disable that by setting the `disableRowSelectionOnClick` prop in the grid
    to `true`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，当你点击网格中的任何一行时，该行会被选中。你可以通过将网格的 `disableRowSelectionOnClick` 属性设置为 `true`
    来禁用此功能：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Displaying a toast message
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示通知消息
- en: 'It would be nice to show the user some feedback in the case of a successful
    deletion, or if there are any errors. Let’s implement a **toast message** to show
    the status of the deletion. For this, we are going to use the MUI `Snackbar` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除成功或出现任何错误，向用户显示一些反馈会很好。让我们实现一个 **通知消息** 来显示删除的状态。为此，我们将使用 MUI 的 `Snackbar`
    组件：
- en: 'First, we have to import the `Snackbar` component by adding the following `import`
    statement to our `Carlist.tsx` file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过将以下 `import` 语句添加到我们的 `Carlist.tsx` 文件中来导入 `Snackbar` 组件：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Snackbar` component’s `open` prop value is a boolean, and if it is `true`,
    the component is shown; otherwise, it is hidden. Let’s import the `useState` hook
    and define a state called `open` to handle the visibility of our `Snackbar` component.
    The initial value is `false` because the message is shown only after the deletion:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Snackbar` 组件的 `open` 属性值是一个布尔值，如果它是 `true`，则组件显示；否则，它隐藏。让我们导入 `useState` 钩子并定义一个名为
    `open` 的状态来处理我们的 `Snackbar` 组件的可见性。初始值是 `false`，因为消息只有在删除后才会显示：'
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we add the `Snackbar` component in the `return` statement after the MUI
    `DataGrid` component. The `autoHideDuration` prop defines the time in milliseconds
    after which the `onClose` function is called automatically and the message disappears.
    The `message` prop defines the message to display. We also have to wrap the `DataGrid`
    and `Snackbar` components inside the fragment (`<></>`):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 MUI `DataGrid` 组件之后的 `return` 语句中添加 `Snackbar` 组件。`autoHideDuration`
    属性定义了在自动调用 `onClose` 函数并消失消息之前的时间（以毫秒为单位）。`message` 属性定义了要显示的消息。我们还需要将 `DataGrid`
    和 `Snackbar` 组件包裹在片段 (`<></>`) 中：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we set the `open` state to `true` after the successful deletion in
    our `useMutation` hook:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `useMutation` 钩子中成功删除后，我们将 `open` 状态设置为 `true`：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you will see the toast message when the car is deleted, as shown in the
    following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当车辆被删除时，您将看到以下截图所示的托盘消息：
- en: '![](img/B19818_13_10.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_10.png)'
- en: 'Figure 13.10: Toast message'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：托盘消息
- en: Adding a confirmation dialog window
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加确认对话框窗口
- en: 'To avoid accidental deletion of a car, it would be useful to have a confirmation
    dialog after the **Delete** button has been pressed. We will implement this using
    the `window` object’s `confirm` method. It opens a dialog with an optional message
    and returns `true` if you press the **OK** button. Add `confirm` to the delete
    button’s `onClick` event handler:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外删除车辆，在按下 **删除** 按钮后有一个确认对话框将很有用。我们将使用 `window` 对象的 `confirm` 方法来实现这一点。它打开一个带有可选消息的对话框，如果您按下
    **确定** 按钮，则返回 `true`。将 `confirm` 添加到删除按钮的 `onClick` 事件处理器：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the confirmation message, we have used ES6 string interpolation to display
    the car’s brand and model. (Note! Remember to use backticks.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认消息中，我们使用了 ES6 字符串插值来显示车辆的品牌和型号。（注意！记得使用反引号。）
- en: 'If you press the **Delete** button now, the confirmation dialog will open and
    the car will only be deleted if you press the **OK** button:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在按下 **删除** 按钮，将打开确认对话框，并且只有当您按下 **确定** 按钮时，车辆才会被删除：
- en: '![](img/B19818_13_11.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_11.png)'
- en: 'Figure 13.11: Confirmation dialog'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：确认对话框
- en: Next, we will begin the implementation of the functionality to add a new car.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始实现添加新车的功能。
- en: Adding the add functionality
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加添加功能
- en: The next step is to add an add functionality to the frontend. We will implement
    this using the MUI modal dialog.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为前端添加添加功能。我们将使用 MUI 模态对话框来实现这一点。
- en: We went through the MUI modal form in *Chapter 11*, *Useful Third-Party Components
    for React*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第11章* 中介绍了 MUI 模态表单，*React 的有用第三方组件*。
- en: We will add the **New Car** button to the user interface, which opens the modal
    form when it is pressed. The modal form contains all the fields that are required
    to add a new car, as well as the buttons for saving and canceling.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在用户界面中添加一个 **新车辆** 按钮，当按下时将打开模态表单。模态表单包含添加新车辆所需的所有字段，以及保存和取消的按钮。
- en: 'The following steps show you how to create the add functionality using the
    modal dialog component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用模态对话框组件创建添加功能：
- en: 'Create a new file called `AddCar.tsx` in the `components` folder and write
    some functional component base code to the file, as shown here. Add the imports
    for the MUI `Dialog` component:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中创建一个名为 `AddCar.tsx` 的新文件，并将一些功能组件基础代码写入文件，如下所示。添加 MUI `Dialog`
    组件的导入：
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have already defined the type for our `Car` response data (a car object
    with links). Let’s also create a type for the car object that doesn’t contain
    links, because the user doesn’t enter links in the form. We need this for the
    state where we will save a new car. Add the following `Car` type to your `types.ts`
    file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的 `Car` 响应数据类型（一个包含链接的车辆对象）。让我们也创建一个不包含链接的车辆对象类型，因为用户不会在表单中输入链接。我们需要这个状态来保存新车辆。将以下
    `Car` 类型添加到您的 `types.ts` 文件中：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare a state of type `Car` that contains all car fields using the `useState`
    hook. For the dialog, we also need a boolean state to define the visibility of
    the dialog form:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `useState` 钩子声明一个包含所有车辆字段的 `Car` 类型状态。对于对话框，我们还需要一个布尔状态来定义对话框表单的可见性：
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we add two functions to close and open the dialog form. The `handleClose`
    and `handleOpen` functions set the value of the `open` state, which affects the
    visibility of the modal form:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加两个函数来关闭和打开对话框表单。`handleClose` 和 `handleOpen` 函数设置 `open` 状态的值，这会影响模态表单的可见性：
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the `Dialog` component inside the `AddCar` component’s `return` statement.
    The form contains the MUI `Dialog` component with buttons and the input fields
    that are required to collect the car data. The button that opens the modal window,
    which will be shown on the car list page, must be outside of the `Dialog` component.
    All input fields should have a `name` attribute with a value that is the same
    as the name of the state the value will be saved to. Input fields also have the
    `onChange` prop, which saves the value to the `car` state by invoking the `handleChange`
    function. The `handleChange` function dynamically updates the `car` state by creating
    a new object with the existing state properties and updating a property based
    on the input element’s name and the new value entered by the user:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AddCar`组件的`return`语句中添加`Dialog`组件。表单包含带有按钮和收集汽车数据的输入字段的MUI `Dialog`组件。打开模态窗口的按钮必须位于`Dialog`组件之外。所有输入字段都应该有一个`name`属性，其值与将要保存到状态中的名称相同。输入字段还具有`onChange`属性，通过调用`handleChange`函数将值保存到`car`状态。`handleChange`函数通过创建一个新的对象并基于输入元素的名称和用户输入的新值更新属性来动态更新`car`状态：
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the `addCar` function in the `carapi.ts` file, which will send the
    `POST` request to the backend `api/cars` endpoint. We are using the Axios `post`
    method to send `POST` requests. The request will include the new car object inside
    the body and the `''Content-Type'':''application/json''` header. We also need
    to import the `Car` type because we are passing a new car object as an argument
    to the function:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`carapi.ts`文件中实现`addCar`函数，该函数将向后端`api/cars`端点发送`POST`请求。我们使用Axios的`post`方法发送`POST`请求。请求将包括在主体内的新汽车对象和`'Content-Type':'application/json'`头。我们还需要导入`Car`类型，因为我们正在将新汽车对象作为参数传递给函数：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we use the React Query `useMutation` hook, like we did in the delete
    functionality. We also invalidate the cars query after the car has been added
    successfully. The `addCar` function that we use in the `useMutation` hook is imported
    from the `carapi.ts` file. Add the following imports and the `useMutation` hook
    to your `AddCar.tsx` file. We also need to get the query client from the context
    using the `useQueryClient` hook. Remember that context is used to provide access
    to the query client to components deep in the component tree:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用与删除功能中相同的React Query `useMutation`钩子。在汽车添加成功后，我们也使汽车查询失效。我们在`useMutation`钩子中使用的`addCar`函数是从`carapi.ts`文件中导入的。将以下导入和`useMutation`钩子添加到你的`AddCar.tsx`文件中。我们还需要使用`useQueryClient`钩子从上下文中获取查询客户端。请记住，上下文用于将查询客户端提供给组件树中深层的组件：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Import the `AddCar` component into the `Carlist.tsx` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AddCar`组件导入到`Carlist.tsx`文件中：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `AddCar` component to the `Carlist.tsx` file’s `return` statement.
    You also have to import the `AddCar` component. Now, the `return` statement of
    the `Carlist.tsx` file should appear as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AddCar`组件添加到`Carlist.tsx`文件的`return`语句中。你还需要导入`AddCar`组件。现在，`Carlist.tsx`文件的`return`语句应该如下所示：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you start the car shop app, it should now look like the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你启动了汽车商店应用，它现在应该看起来像以下这样：
- en: '![](img/B19818_13_12.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_12.png)'
- en: 'Figure 13.12: Car Shop'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：汽车商店
- en: If you press the **New Car** button, it should open the modal form.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下**新汽车**按钮，它应该打开模态表单。
- en: 'To save a new car, create a function called `handleSave` in the `AddCar.tsx`
    file. The `handleSave` function calls `mutate`. Then, we set the `car` state back
    to its initial state, and the modal form is closed:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存新汽车，在`AddCar.tsx`文件中创建一个名为`handleSave`的函数。`handleSave`函数调用`mutate`。然后，我们将`car`状态重置为其初始状态，并关闭模态表单：
- en: '[PRE38]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we have to change the `AddCar` component’s `onClick` save button to
    call the `handleSave` function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须将`AddCar`组件的`onClick`保存按钮更改为调用`handleSave`函数：
- en: '[PRE39]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, you can open the modal form by pressing the **New Car** button. You will
    see that there is placeholder text in each field when it is empty. You can fill
    out the form with data and press the **Save** button. At this point, the form
    doesn’t have a nice appearance, but we are going to style it in the next chapter:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过按下**新汽车**按钮打开模态表单。你会看到当字段为空时，每个字段中都有占位符文本。你可以用数据填写表单并按下**保存**按钮。此时，表单的外观并不美观，但我们将在下一章中对其进行样式化：
- en: '![](img/B19818_13_13.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_13.png)'
- en: 'Figure 13.13: Add new car'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：添加新汽车
- en: 'After saving, the list page is refreshed, and the new car can be seen in the
    list:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存后，列表页面会刷新，新汽车可以在列表中看到：
- en: '![](img/B19818_13_14.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_14.png)'
- en: 'Figure 13.14: Car Shop'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：汽车商店
- en: 'Now, we can do some code refactoring. When we start to implement the edit functionality,
    we will actually need the same fields in the **Edit** form as in the **New Car**
    form. Let’s create a new component that renders the text fields in our **New Car**
    form. The idea is that we are splitting the text fields into their own component,
    which can then be used in both the **New Car** and **Edit** forms. Create a new
    file called `CarDialogContent.tsx` in the `components` folder. We have to pass
    the `car` object and the `handleChange` function to the component using `props`.
    To do that, we create a new type called `DialogFormProps`. We can define this
    type in the same file because we don’t need it in any other file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以进行一些代码重构。当我们开始实现编辑功能时，我们实际上需要在**编辑**表单中与**新汽车**表单中相同的字段。让我们创建一个新的组件来渲染我们的**新汽车**表单中的文本字段。想法是将文本字段拆分到它们自己的组件中，然后可以在**新汽车**和**编辑**表单中使用这个组件。在`components`文件夹中创建一个新的文件名为`CarDialogContent.tsx`。我们必须使用`props`将`car`对象和`handleChange`函数传递给组件。为此，我们创建了一个新的类型`DialogFormProps`。我们可以在同一文件中定义这个类型，因为我们不需要在任何其他文件中使用它：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we can move our `DialogContent` component from the `AddCar` component
    to the `CarDialogContent` component. Your code should look like the following:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将`DialogContent`组件从`AddCar`组件移动到`CarDialogContent`组件。您的代码应该如下所示：
- en: '[PRE41]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can import the `CarDialogContent` to the `AddCar` component and render
    it inside the `Dialog` component. Pass the `car` state and the `handleChange`
    function to the component using props. Also, remove the unused MUI `DialogContent`
    import from the `AddCar` component:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将`CarDialogContent`导入到`AddCar`组件中，并在`Dialog`组件内部渲染它。使用属性将`car`状态和`handleChange`函数传递给组件。同时，从`AddCar`组件中删除未使用的MUI
    `DialogContent`导入：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to add a new car, and it should work like it did before the refactoring.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加一辆新车，它应该像重构之前一样工作。
- en: Next, we will begin to implement the edit functionality.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始实现编辑功能。
- en: Adding the edit functionality
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加编辑功能
- en: 'We will implement the edit functionality by adding the **Edit** button to each
    table row. When the row **Edit** button is pressed, it opens a modal form where
    the user can edit the existing car and save their changes. The idea is that we
    pass car data from the grid row to the edit form, and the form fields are populated
    when the form is opened:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在每个表格行中添加**编辑**按钮来实现编辑功能。当按下行中的**编辑**按钮时，它将打开一个模态表单，用户可以在其中编辑现有的汽车并保存他们的更改。想法是将网格行中的汽车数据传递到编辑表单中，当表单打开时，表单字段将被填充：
- en: 'First, create a file called `EditCar.tsx` in the `components` folder. We have
    to define a `FormProps` type for our props, and this can be defined inside our
    component because we don’t need this type anywhere else. The type of data that
    will be passed to the `EditCar` component is the `CarResponse` type. We will also
    create a state for car data like we did in the add functionality section. The
    code for the `EditCar.tsx` file looks like the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`components`文件夹中创建一个名为`EditCar.tsx`的文件。我们必须为我们的属性定义一个`FormProps`类型，并且这个类型可以在我们的组件内部定义，因为我们不需要这个类型在其他任何地方。传递给`EditCar`组件的数据类型是`CarResponse`类型。我们还将创建一个用于汽车数据的`state`，就像我们在添加功能部分所做的那样。`EditCar.tsx`文件的代码如下：
- en: '[PRE43]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will create a dialog that will be opened when the **Edit** button is pressed.
    We need the `open` state to define if the dialog is visible or hidden. Add the
    functions that open and close the `Dialog` component and save updates:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个当按下**编辑**按钮时将打开的对话框。我们需要`open`状态来定义对话框是可见的还是隐藏的。添加打开和关闭`Dialog`组件并保存更新的函数：
- en: '[PRE44]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we will import the `CarDialogContent` component and render it inside
    the `Dialog` component. We also need to add the `handleChange` function, which
    saves edited values to the `car` state. We pass in the `car` state and the `handleChange`
    function using the props, as we did earlier with the add functionality:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导入`CarDialogContent`组件并在`Dialog`组件内部渲染它。我们还需要添加`handleChange`函数，该函数将保存编辑的值到`car`状态。我们使用属性传递`car`状态和`handleChange`函数，就像我们之前在添加功能中做的那样：
- en: '[PRE45]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we will set the values of the `car` state using the props in the `handleClickOpen`
    function:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`handleClickOpen`函数中的属性设置`car`状态值：
- en: '[PRE46]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our form will be populated with the values from the car object that is passed
    to the component in props.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式将使用传递给组件的属性中的汽车对象的值进行填充。
- en: 'In this step, we will add the edit functionality to our data grid in the `Carlist`
    component. Open the `Carlist.tsx` file and import the `EditCar` component. Create
    a new column that renders the `EditCar` component using the `renderCell` column
    property, as we did in the delete functionality section. We pass the row object
    to the `EditCar` component, and that object contains the car object:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将向`Carlist`组件中的数据网格添加编辑功能。打开`Carlist.tsx`文件并导入`EditCar`组件。创建一个新列，使用`renderCell`列属性渲染`EditCar`组件，就像我们在删除功能部分所做的那样。我们将行对象传递给`EditCar`组件，该对象包含汽车对象：
- en: '[PRE47]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, you should see the **Edit** button in each table row in your car list.
    When you press the **Edit** button, it should open the car form and populate fields
    using the car from the row where you pressed the button:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该在汽车列表的每一行中看到**编辑**按钮。当您按下**编辑**按钮时，它应该打开汽车表单并使用您按下的按钮所在的行的汽车填充字段：
- en: '![](img/B19818_13_15.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_15.png)'
- en: 'Figure 13.15: Edit button'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：编辑按钮
- en: Next, we have to implement the update request that sends an updated car to the
    backend. To update the car data, we have to send a `PUT` request to the `http://localhost:8080/api/cars/[carid]`
    URL. The link will be the same as it is for the delete functionality. The request
    contains the updated car object inside the body, and the `'Content-Type':'application/json'`
    header that we also set for the add functionality. For the update functionality,
    we need a new type. In React Query, the mutation function can only take one parameter,
    but in our case, we have to send the car object (`Car` type) and its link.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须实现发送更新汽车到后端的更新请求。为了更新汽车数据，我们必须向`http://localhost:8080/api/cars/[carid]`
    URL发送一个`PUT`请求。链接将与删除功能中的链接相同。请求包含在主体中的更新汽车对象，以及我们为添加功能设置的`'Content-Type':'application/json'`头。对于更新功能，我们需要一个新的类型。在React
    Query中，突变函数只能接受一个参数，但在我们的情况下，我们必须发送汽车对象（`Car`类型）及其链接。
- en: 'We can solve that by passing an object that contains both values. Open the
    `types.ts` file and create the following type, called `CarEntry`:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过传递一个包含两个值的对象来解决。打开`types.ts`文件并创建以下类型，称为`CarEntry`：
- en: '[PRE48]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, open the `carapi.ts` file, create the following function, and export
    it. The function gets the `CarEntry` type object as an argument and it has `car`
    and `url` properties, where we get the values that are needed in the request:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`carapi.ts`文件，创建以下函数并导出它。该函数接受`CarEntry`类型的对象作为参数，并具有`car`和`url`属性，其中我们获取请求中需要的值：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we import the `updateCar` function into the `EditCar` component and use
    the `useMutation` hook to send a request. We invalidate the cars query to re-fetch
    the list after a successful edit; therefore, we also have to get the query client:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`updateCar`函数导入到`EditCar`组件中，并使用`useMutation`钩子发送请求。在编辑成功后，我们使汽车查询失效以重新获取列表；因此，我们还需要获取查询客户端：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we call `mutate` in the `handleSave` function. As was already mentioned,
    `mutate` only accepts one parameter, and we have to pass the car object and URL;
    therefore, we create an object that contains both values and pass that one. We
    also need to import the `CarEntry` type:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`handleSave`函数中调用`mutate`。如前所述，`mutate`只接受一个参数，我们必须传递汽车对象和URL；因此，我们创建一个包含这两个值的对象，并将其传递。我们还需要导入`CarEntry`类型：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, if you press the **Edit** button in the table, it opens the modal form
    and displays the car from that row. The updated values are saved to the database
    when you press the **Save** button:![](img/B19818_13_16.png)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您在表中按下**编辑**按钮，它将打开模态表单并显示该行的汽车。当您按下**保存**按钮时，更新的值将保存到数据库中：![图片](img/B19818_13_16.png)
- en: 'Figure 13.16: Edit car'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.16：编辑汽车
- en: Similarly, if you press the **New Car** button, it will open an empty form and
    save the new car to the database when the form is filled and the **Save** button
    is pressed. We used one component to handle both use cases by using the component
    props.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，如果您按下**新建汽车**按钮，它将打开一个空表单，并在表单填写并按下**保存**按钮时将新汽车保存到数据库中。我们通过使用组件属性，使用一个组件来处理这两个用例。
- en: 'You can also see what happens in the backend when you edit a car. If you look
    at the Eclipse console after a successful edit, you can see that there is an `update`
    SQL statement that updates the database:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以看到在编辑汽车时后端发生的情况。如果您在成功编辑后查看Eclipse控制台，您可以看到有一个`update` SQL语句更新数据库：
- en: '![](img/B19818_13_17.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_13_17.png)'
- en: 'Figure 13.17: Update car statement'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17：更新汽车语句
- en: Now, we have implemented all the CRUD functionalities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经实现了所有CRUD功能。
- en: Exporting the data to CSV
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据导出到 CSV
- en: 'One feature that we will also implement is a **comma-separated values** (**CSV**)
    export of the data. We don’t need any extra libraries for the export because the
    MUI data grid provides this feature. We will activate the data grid toolbar, which
    contains a lot of nice features:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个功能，即数据的 **逗号分隔值**（**CSV**）导出。我们不需要任何额外的库来进行导出，因为 MUI 数据网格提供了这个功能。我们将激活数据网格工具栏，它包含许多有用的功能：
- en: 'Add the following import to the `Carlist.tsx` file. The `GridToolbar` component
    is a toolbar for the MUI data grid that contains nice functionalities, such as
    export:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入添加到 `Carlist.tsx` 文件中。`GridToolbar` 组件是 MUI 数据网格的工具栏，它包含许多有用的功能，如导出：
- en: '[PRE52]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need to enable our toolbar, which contains the **Export** button and other
    buttons. To enable the toolbar in the MUI data grid, you have to use the `slots`
    prop and set the value to `toolbar: GridToolbar`. The `slots` prop can be used
    to override the data grid’s internal components:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们需要启用我们的工具栏，其中包含 **导出** 按钮和其他按钮。要在 MUI 数据网格中启用工具栏，你必须使用 `slots` 属性并将值设置为 `toolbar:
    GridToolbar`。`slots` 属性可以用来覆盖数据网格的内部组件：'
- en: '[PRE53]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, you will see the **EXPORT** button in the grid. If you press the button
    and select **Download as CSV**, the grid data is exported to a CSV file. You can
    **Print** your grid using the **EXPORT** button, and you will get a printer-friendly
    version of your page (you can also hide and filter columns and set row density
    using the toolbar):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将在网格中看到 **导出** 按钮。如果你按下按钮并选择 **下载为 CSV**，网格数据将被导出到 CSV 文件。你可以使用 **导出** 按钮打印你的网格，你将获得一个打印友好的页面版本（你也可以使用工具栏隐藏和过滤列，并设置行密度）：
- en: '![](img/B19818_13_18.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_13_18.png)'
- en: 'Figure 13.18: Export CSV'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18：导出 CSV
- en: 'You can change the page title and icon by editing the `index.html` page, as
    shown in the following code. The icon can be found in your project’s `public`
    folder, and you can use your own icon instead of Vite’s default one:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过编辑 `index.html` 页面来更改页面标题和图标，如下面的代码所示。图标可以在你的项目的 `public` 文件夹中找到，你可以使用自己的图标而不是
    Vite 的默认图标：
- en: '[PRE54]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, all the functionalities have been implemented. In *Chapter 14*, *Styling
    the Frontend with React MUI*, we will focus on styling the frontend.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有功能都已实现。在 *第 14 章*，*使用 React MUI 美化前端* 中，我们将专注于美化前端。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented all the functionalities for our app. We started
    with fetching the cars from the backend and showing these in the MUI `DataGrid`,
    which provides paging, sorting, and filtering features. Then, we implemented the
    delete functionality and used the `SnackBar` component to give feedback to the
    user.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了我们应用的所有功能。我们从从后端获取汽车并在 MUI `DataGrid` 中显示它们开始，MUI `DataGrid` 提供了分页、排序和过滤功能。然后，我们实现了删除功能并使用
    `SnackBar` 组件向用户反馈。
- en: The add and edit functionalities were implemented using the MUI modal `dialog`
    component. Finally, we implemented the ability to export data to a CSV file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MUI 模态 `dialog` 组件实现了添加和编辑功能。最后，我们实现了将数据导出到 CSV 文件的能力。
- en: In the next chapter, we are going to style the rest of our frontend using the
    React Material UI component library.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 React Material UI 组件库来美化我们的前端。
- en: Questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you fetch and present data using the REST API with React?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 和 REST API 获取并展示数据？
- en: How do you delete data using the REST API with React?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 和 REST API 删除数据？
- en: How do you show toast messages with React and MUI?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 和 MUI 显示 toast 消息？
- en: How do you add data using the REST API with React?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 和 REST API 添加数据？
- en: How do you update data using the REST API with React?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 和 REST API 更新数据？
- en: How do you export data to a CSV file with React?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 React 将数据导出到 CSV 文件？
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are other good resources available for learning about React and React
    Query. For example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习 React 和 React Query，还有其他很好的资源。例如：
- en: '*Practical React Query – TkDoDo’s blog*, by Dominik Dorfmeister ([https://tkdodo.eu/blog/practical-react-query](https://tkdodo.eu/blog/practical-react-query))'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用 React 查询 – TkDoDo 的博客*，由 Dominik Dorfmeister 提供 ([https://tkdodo.eu/blog/practical-react-query](https://tkdodo.eu/blog/practical-react-query))'
- en: '*Material Design Blog*, by Google ([https://material.io/blog/](https://material.io/blog/))'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Material Design Blog*，由 Google 提供 ([https://material.io/blog/](https://material.io/blog/))'
- en: Learn more on Discord
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10796108009382640.png)'
