- en: 'Chapter 14: Monitoring and Tracing Techniques'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章：监控和追踪技术
- en: There is a risk, as developers and architects, of overlooking what happens to
    our applications and services after production release. We may be tempted to think
    that it's just a problem for sysadmins and whoever oversees service operations.
    As is easy to understand, this is the wrong point of view.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员和架构师，存在忽视我们应用程序和服务在生产发布后发生情况的风险。我们可能会倾向于认为这只是系统管理员和负责服务运营的人的问题。正如容易理解的那样，这种观点是错误的。
- en: Understanding how our application behaves in production gives us a lot of insight
    into what is and is not working—from both a code and an architecture perspective.
    As we learned in the previous chapter, maintenance of our application is crucial
    for the success of each software project, and looking closely at how the application
    is going in production is the perfect way to understand whether there is something
    that can be improved.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的应用程序在生产中的行为，可以让我们从代码和架构的角度深入了解什么有效，什么无效。正如我们在上一章中学习的，我们应用程序的维护对于每个软件项目的成功至关重要，仔细观察应用程序在生产中的表现是了解是否可以改进的最佳方式。
- en: Moreover, in modern DevOps teams, as we learned in [*Chapter 5*](B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109),
    *Exploring the Most Common Development Models*, the separation of concerns must
    be overcome, and the development and architectural teams are responsible for operating
    services as well. In this chapter, we will have an overview of the common topics
    regarding the visibility of what happens to our application during production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在现代DevOps团队中，正如我们在[*第5章*](B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109)中学习的，“探索最常见的发展模型”，必须克服关注点的分离，开发和架构团队也负责运营服务。在本章中，我们将概述有关我们应用程序在生产过程中发生情况的可视性的常见主题。
- en: 'We will look at the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Log management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志管理
- en: Collecting application metrics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集应用程序指标
- en: Defining application health checks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序健康检查
- en: Application Performance Management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序性能管理
- en: Service monitoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务监控
- en: The idea is not only to have an overview of these topics and what they are useful
    for, but also to understand the impact that a correct design and implementation
    may have on these topics. With that said, let's start discussing log management.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目的不是仅仅概述这些主题及其用途，还要了解正确设计和实现对这些主题可能产生的影响。话虽如此，让我们开始讨论日志管理。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the source code used in this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter14).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章使用的源代码：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter14)。
- en: Log management
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志管理
- en: '**Log management** has been taken for granted so far in the book. Let''s just
    take a quick glance over some basic concepts related to producing logs in our
    Java applications.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中一直认为**日志管理**是理所当然的。让我们快速浏览一些与我们Java应用程序中生成日志相关的基本概念。
- en: Logging in Java has had a troubled history. At the very beginning, no standard
    was provided as part of the Java platform. When a standard (such as **Java Util
    Logging** (**JUL**)) was added to the platform (in release **1.4**), other alternative
    frameworks were available, such as **Apache Commons Logging** and **Log4j**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的日志记录有着复杂的历史。一开始，Java平台没有提供任何标准。当（例如**Java Util Logging**（**JUL**））作为标准添加到平台（在**1.4**版本中）时，其他替代框架也变得可用，例如**Apache
    Commons Logging**和**Log4j**。
- en: At the time of writing, Log4j has been deprecated and replaced by **Log4j2**
    and **logback**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Log4j已被弃用，并由**Log4j2**和**logback**取代。
- en: Even though the JUL standard has been a part of the platform for many years
    now, the usage of alternative frameworks such as logback and Log4j2 is still very
    widespread, due to their features and performance. Regardless of which implementation
    we choose, there are some common concepts to consider.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JUL标准已经作为平台的一部分存在多年，但由于其功能和性能，替代框架如logback和Log4j2的使用仍然非常普遍。无论我们选择哪种实现，都有一些共同的概念需要考虑。
- en: Common concepts in logging frameworks
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志框架中的常见概念
- en: 'As described previously, no matter what kind of preferred log implementation
    is used in your projects, there are two main concepts that are common to every
    one of them:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，无论在项目中使用哪种首选的日志实现，都存在两个主要概念，这些概念适用于所有这些实现：
- en: '`INFO` level is commonly present, and defines the *average* level of verbosity,
    reporting log entries that record basic information useful to understand what''s
    going on, but that can be discarded if you want to reduce the amount of logging
    or if you are familiar and confident enough with your app''s behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO` 级别通常存在，并定义了 *平均* 的冗余程度，报告记录基本信息的日志条目，这些信息有助于理解正在发生的事情，但如果您想减少日志量或对应用程序的行为足够熟悉和自信，则可以丢弃这些日志条目。'
- en: Above the `INFO` level, there are `WARNING` and other similar levels (such as
    `ERROR` and `FATAL`) that are used for reporting unusual or incorrect behavior.
    For this reason, these levels are almost always kept active. Finally, below `INFO`
    there are other levels, such as `DEBUG` and `TRACE`, which are used for getting
    details on what is happening in our application and are usually reported only
    for a limited amount of time. They are also used to gather data on whether there
    is something wrong in our application that needs troubleshooting, as well as collect
    data in non-production environments for development purposes. These levels of
    logging are discouraged in production as they will produce a lot of entries and
    may impact performance, which leads to our next point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`INFO`级别之上，有`WARNING`和其他类似级别（如`ERROR`和`FATAL`），用于报告异常或不正确的行为。因此，这些级别几乎总是保持激活状态。最后，在`INFO`级别之下，还有其他级别，如`DEBUG`和`TRACE`，用于获取有关应用程序中发生的事情的详细信息，并且通常仅在有限的时间内报告。它们还用于收集有关应用程序中是否存在需要调试的问题的数据，以及在非生产环境中收集用于开发目的的数据。在生产环境中不建议使用这些日志级别，因为它们会产生大量条目并可能影响性能，这引出了我们下一个要点。
- en: '`CONSOLE` and `FILE` are two common ones used to report log entries in the
    console or in a file. Other alternatives may include appenders to a database and
    to other external systems (such as logging to a socket).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSOLE`和`FILE`是两种常用的用于在控制台或文件中报告日志条目的方法。其他替代方案可能包括将appenders添加到数据库和其他外部系统（例如通过套接字进行日志记录）。'
- en: As described in the previous point, appenders may impact the overall performance.
    Writing to a file may be slower than writing to the console. For this reason,
    appenders often offer asynchronous alternatives that buffer the log entries in
    memory before writing them to the target system. However, this of course increases
    the risk of losing data should our application crash before the entries are forwarded
    to the relevant system (such as the file or the database).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一点所述，appenders可能会影响整体性能。将数据写入文件可能比写入控制台慢。因此，appenders通常提供异步替代方案，在将日志条目写入目标系统之前，先将它们缓冲在内存中。然而，当然，如果在条目转发到相关系统（如文件或数据库）之前应用程序崩溃，这会增加数据丢失的风险。
- en: 'These are some very basic concepts of logging in Java (similar concepts can
    be found in other languages). But there are also some recommendations about logging
    that I can provide, from personal experience:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Java中日志的一些非常基本的概念（在其他语言中也可以找到类似的概念）。但也有一些关于日志的建议，我可以根据个人经验提供：
- en: It's a good practice to avoid string concatenation (such as `"My log is " +
    variable + " ! "`). Other than being ugly, it can have a performance impact since
    string concatenation operations happen even if the log is not used (because it's
    related to a disabled level). Most logging frameworks offer alternatives based
    on placeholders (such as `"My log is {} !", variable`). Most recent Java versions
    automatically mitigate string concatenation by replacing it at compilation time
    with more efficient alternatives (such as `StringBuilder`), but it's still a good
    idea to avoid it.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免字符串连接（例如 `"My log is " + variable + " ! "`）是一种良好的做法。除了外观不美观外，它还可能影响性能，因为即使日志未使用（因为它与禁用级别相关），字符串连接操作也会发生。大多数日志框架提供基于占位符的替代方案（例如
    `"My log is {} !", variable`）。大多数最新的Java版本通过在编译时将其替换为更有效的替代方案（例如`StringBuilder`）来自动减轻字符串连接的影响，但仍然建议避免它。
- en: Consider differentiating log destinations by content type. You may want to have
    different appenders (almost every framework allows it) to log different information.
    So, business information (related to how our application is performing from a
    business perspective) such as user information or the products used can go to
    a specific database table (and maybe then can be aggregated and reported), while
    logs containing technical information (useful for troubleshooting or checking
    the application's health) may go in a file to be easily accessed by SysOps.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑通过内容类型区分日志目的地。你可能希望有不同类型的appender（几乎每个框架都允许这样做）来记录不同的信息。因此，与业务性能相关的业务信息（如用户信息或使用的商品）可以记录在特定的数据库表中（并且可能随后可以汇总和报告），而包含技术信息的日志（对故障排除或检查应用程序的健康状况很有用）可能可以存放在文件中，以便系统操作员容易访问。
- en: 'This can also be done by log severity by sending the `INFO` level on a certain
    appender, and other levels on other appenders. This may also allow for different
    *quality of service* for logs: you could log business information that is logged
    on an asynchronous appender (because you may lose some data in the event of an
    application issue—this is not a problem), while technical logs should go on synchronous
    appenders (because you cannot afford to lose anything if you intend to understand
    the issues behind a misbehaving application).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过日志严重性来实现，通过在某个appender上发送`INFO`级别，在其他appender上发送其他级别。这也许还能为日志提供不同的*服务质量*：你可以将业务信息记录在异步appender上（因为如果应用程序出现问题时可能会丢失一些数据——这不是问题），而技术日志则应该记录在同步appender上（因为如果你打算理解一个表现不佳的应用程序背后的问题，你不能承受任何损失）。
- en: '**Log rotation** is an essential concept, but it''s still sometimes forgotten,
    especially in older applications. Log rotation can be implemented using the logging
    framework itself or by external scripts and utilities. It''s basically related
    to file appenders, and defines the way logs are archived by renaming them, moving
    them, and optionally compressing them. A log rotation policy allows the current
    logs to be small enough (for easy reading and searching) and makes it easier to
    find information from previous dates and save space on disk. This will help SysOps,
    who sometimes have to deal with misconfigured applications that fill the disk
    because of a misconfigured log rotation policy. Hopefully, this should be less
    common nowadays.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志轮转**是一个基本概念，但有时仍然会被遗忘，尤其是在较老的应用程序中。日志轮转可以通过日志框架本身或通过外部脚本和工具来实现。它基本上与文件appender相关，定义了通过重命名、移动和可选地压缩日志来归档日志的方式。日志轮转策略允许当前日志足够小（便于阅读和搜索），并使得从以前的日期查找信息更容易，同时还能在磁盘上节省空间。这将有助于系统操作员，他们有时必须处理由于日志轮转策略配置不当而填满磁盘的错误配置的应用程序。希望现在这种情况会少一些。'
- en: Every message should provide meaningful information. As trivial as it may sound,
    it's very easy to write just basic things in logs, assuming that whoever reads
    the log will have enough context. *I highly recommend not doing this!* Log messages
    could be read by people not knowing much about the application (such as first-line
    support staff) in emergency situations (such as production troubleshooting). When
    in doubt, be as clear as possible. This doesn't necessarily mean being verbose,
    but make sure to provide a decent amount of content.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条消息都应该提供有意义的信息。尽管这听起来可能很 trivial，但很容易在日志中只记录基本的事情，假设阅读日志的人会有足够的上下文。*我强烈建议不要这样做!*
    日志消息可能由对应用程序不太了解的人（如一线支持人员）在紧急情况下（如生产故障排除）阅读。当有疑问时，尽可能清楚。这并不一定意味着要冗长，但请确保提供足够的内容。
- en: Logging levels should be defined in a standard way. Especially in big projects
    composed of many microservices or applications, it should be well documented what
    is supposed to be logged as INFO, what should be higher, and what should be lower.
    In this way, logging levels can be set in a uniform way, expecting the same kind
    of information across all modules.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应以标准方式定义日志级别。特别是在由许多微服务或应用程序组成的大项目中，应该详细记录应该记录为INFO的内容，应该更高或更低的内容。这样，日志级别可以统一设置，期望在整个模块中提供相同类型的信息。
- en: The same is true for log format. Almost every logging library supports defining
    a pattern, which means setting which information (apart from the log message itself)
    should be written, including date, time, the log level, and more. It's better
    if this kind of format is uniform across all the components to be easy to read
    and parse using tools (such as the very basic `grep` utility). Also, I strongly
    suggest configuring the logging library to provide information about the class
    that is generating the log. It's usually a bit expensive from a computational
    perspective (often negligible) but is worth it for sure.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于日志格式来说，也是如此。几乎每个日志库都支持定义一个模式，这意味着可以设置哪些信息（除了日志消息本身）应该被写入，包括日期、时间、日志级别等等。如果这种格式在所有组件中都是统一的，那么使用工具（如非常基础的`grep`实用程序）进行阅读和解析会更容易。此外，我强烈建议配置日志库以提供生成日志的类的信息。从计算角度来看，这通常有点昂贵（通常可以忽略不计），但绝对值得。
- en: You should have a discussion with security and legal advisors as soon as possible
    (if present) about what can, must, and should not be present in logs. This varies
    from application to application, but there may be information (such as personal
    information or credit card data) that is prohibited from being present in logs
    (or needs to be anonymized), and other information that is required to be present
    by law (such as audit information). You need to know about this and implement
    the requirements accordingly.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该尽快（如果有的话）与安全和法律顾问讨论日志中可以、必须和不应包含的内容。这因应用程序而异，但可能有信息（如个人信息或信用卡数据）被禁止出现在日志中（或需要匿名化），以及法律要求必须出现的信息（如审计信息）。你需要了解这一点并相应地实施要求。
- en: As a follow-up from the previous point, most applications have legal (or other
    kinds of) requirements for log storage and archiving. You may need to store logs
    for many years, sometimes in an immutable way. Hence, log rotation and specialized
    hardware and software may be needed.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从前面的观点继续，大多数应用程序对日志存储和归档都有法律（或其他类型）的要求。你可能需要存储日志多年，有时以不可变的方式。因此，可能需要日志轮转和专门的硬件和软件。
- en: As a final consideration about logging, we cannot avoid having a chat about
    log aggregation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志的最后一个考虑因素，我们无法避免讨论日志聚合。
- en: Log aggregation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志聚合
- en: 'In [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing
    Cloud-Native Architectures*, when discussing **Twelve-Factor Applications**, we
    saw how logs can be seen as an event stream and must be handled by a supporting
    platform, capable of capturing the event stream, storing it, and making it usable
    and searchable across different applications. We even mentioned **Fluentd** as
    a commonly used solution for this. This is exactly what log aggregation is about.
    A typical log aggregation architecture features the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，“设计云原生架构”中，当讨论**十二要素应用**时，我们看到了日志如何被视为事件流，并且必须由一个支持平台来处理，该平台能够捕获事件流、存储它，并使不同应用程序可使用和可搜索。我们甚至提到了**Fluentd**作为常用的解决方案。这正是日志聚合的内容。典型的日志聚合架构具有以下特点：
- en: An agent for collecting logs from the console (or a file) in the form of event
    streams. Fluentd is a common choice (even though it has some known limitations
    in terms of performance and logs that can potentially be lost in corner cases).
    **Filebeat** and **collectd** are some alternatives to this.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于从控制台（或文件）以事件流形式收集日志的代理。Fluentd是一个常见的选择（尽管它在性能和日志方面有一些已知的限制，在边缘情况下可能会丢失日志）。**Filebeat**和**collectd**是这种选择的替代品。
- en: Persistence for log entries. **Elasticsearch** is practically the standard in
    this area, providing storing, indexing, and searching capabilities.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志条目的持久性。**Elasticsearch** 在这个领域实际上是标准，提供存储、索引和搜索功能。
- en: 'A frontend for navigating and monitoring log entries. Software commonly used
    for this goal are **Kibana** and **Grafana**. Here is a screenshot of the Kibana
    UI:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于导航和监控日志条目的前端。用于此目的的常用软件是**Kibana**和**Grafana**。以下是Kibana UI的截图：
- en: '![Figure 14.1 – Kibana UI home'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 – Kibana UI首页'
- en: '](img/Figure_14.1_B16354_new.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B16354_new.jpg)'
- en: Figure 14.1 – Kibana UI home
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – Kibana UI首页
- en: Log aggregation should be considered a must in cloud-native architecture, because
    having a heavily distributed application based on microservices will mean having
    a lot of systems to monitor and troubleshoot in the event of issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生架构中，应将日志聚合视为必须考虑的事项，因为基于微服务的重度分布式应用程序将意味着在出现问题时需要监控和调试许多系统。
- en: With a log aggregation strategy, you will have a centralized way to access logs,
    hence everything will become a bit easier.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志聚合策略，您将有一个集中化的方式来访问日志，因此一切都会变得容易一些。
- en: In this section, we had a quick overview of logging in Java, and then we highlighted
    the characteristics and the advantages of log aggregation. In the next section,
    we are going to have a look at another key topic about monitoring, which is metrics
    collection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要概述了 Java 中的日志记录，然后强调了日志聚合的特点和优势。在下一节中，我们将探讨监控的另一个关键主题，即度量收集。
- en: Collecting application metrics
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集应用程序度量
- en: '**Metrics** are a way to instrument your source code to provide real-time insights
    into what''s happening. Metrics are also known as **telemetry**. Instead of logs,
    which represent information pushed into a file, a console, or another appender,
    metrics are values exposed by the application and are supposed to be pulled by
    whoever is interested in them.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**度量**是您对源代码进行工具化的方式，以提供对正在发生的事情的实时洞察。度量也被称为**遥测**。与代表推送到文件、控制台或其他附件器的信息的日志不同，度量是由应用程序暴露的值，并应由对其感兴趣的人拉取。'
- en: Moreover, while a log contains what's happening in our application, collected
    in a sequential way, metrics expose a snapshot of how the application was behaving
    in that instant, summarized into some well-known values (such as the number of
    threads, the memory allocated, and so on). It's also possible to define some custom
    metrics, which can be useful to define figures that are specific to our particular
    use case (such as the number of payments, transactions, and so on).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然日志包含我们的应用程序中发生的事情，以顺序方式收集，但度量暴露了应用程序在那个时刻的行为快照，总结为一些已知值（如线程数、分配的内存等）。也可以定义一些自定义度量，这些度量可以用来定义特定于我们特定用例的数字（如支付次数、交易次数等）。
- en: There are many widespread frameworks useful for exposing metrics in Java. `Micrometer`
    is an open source façade implementation, while other commercial solutions exist,
    such as **New Relic** and **Datadog**. However, I think that one of the most interesting
    efforts in this area is one part of the MicroProfile standard. We looked at MicroProfile
    in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164), *Exploring Middleware
    and Frameworks*, when discussing Quarkus as an implementation of it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多广泛使用的框架可用于在 Java 中暴露度量。`Micrometer` 是一个开源的界面实现，而其他商业解决方案也存在，例如 **New Relic**
    和 **Datadog**。然而，我认为在这个领域最有趣的努力之一是 MicroProfile 标准的一部分。我们在 [*第 7 章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)
    中探讨了 MicroProfile，*探索中间件和框架*，当时讨论了 Quarkus 作为其实现之一。
- en: 'I think that a quick example (MicroProfile compliant) will be useful here to
    better explain what metrics look like. Let''s see a simple hello world REST API:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一个快速示例（MicroProfile 兼容）将有助于更好地解释度量看起来是什么样子。让我们看看一个简单的 hello world REST API：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the `hello` method is annotated with two metric-related annotations
    (`Counted` and `Timed`), which declare the kind of metrics we want to collect.
    The annotations also provide some documentation (the `name` and `description`
    of the metric). Now, if we query the application via REST, we can see all the
    metrics values exposed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`hello` 方法被两个与度量相关的注解（`Counted` 和 `Timed`）标注，这些注解声明了我们想要收集的度量类型。这些注解还提供了一些文档（度量的
    `name` 和 `description`）。现在，如果我们通过 REST 查询应用程序，我们可以看到所有暴露的度量值：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A number of other metrics (such as minimum, maximum, and average) are omitted
    in the preceding output and calculated automatically by the framework.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中省略了许多其他度量（如最小值、最大值和平均值），这些度量由框架自动计算。
- en: These kinds of metrics are exposed under the `/metrics/application` endpoint
    (`/q/metrics/application`, in the case of the Quarkus framework).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的度量在 `/metrics/application` 端点下暴露（在 Quarkus 框架的情况下为 `/q/metrics/application`）。
- en: 'The MicroProfile specification also defines the `/metrics/vendor` (vendor-specific),
    `/metrics/base` (a meaningful predefined subset), and `/metrics` (all the metrics
    available) endpoints. In these endpoints, you may find a lot of useful insights
    into the application, such as virtual machine stats and similar things. This is
    a small subset of what can be retrieved from such endpoints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 规范还定义了 `/metrics/vendor`（供应商特定的）、`/metrics/base`（一个有意义的预定义子集）和
    `/metrics`（所有可用的度量）端点。在这些端点中，您可能会发现许多关于应用程序的有用见解，例如虚拟机统计信息等。这是可以从这些端点检索到的小部分内容：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The metrics exposed in this way can then be collected by external systems, which
    can store them and provide alerts in the event of something going wrong. A widely
    used framework to do so is **Prometheus**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式暴露的指标可以被外部系统收集，这些系统可以存储它们，并在出现问题时提供警报。用于此目的的一个广泛使用的框架是**Prometheus**。
- en: Being a part of the **Cloud-Native Computing Foundation** (**CNCF**) effort,
    Prometheus is able to collect the metrics from various systems (including OpenMetrics-compliant
    endpoints, similar to the ones exposed by the example we saw previously), store
    them in a so-called **Time Series Database** (**TSDB**) (which is basically a
    database optimized for storing events on a temporal scale), and provide capabilities
    for querying the metrics and providing alerts. It also offers a built-in graphical
    interface and integration with Grafana.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为**云原生计算基金会**（**CNCF**）努力的一部分，Prometheus能够从各种系统（包括与我们之前看到的示例类似的开源度量标准合规端点）收集指标，将它们存储在所谓的**时间序列数据库**（**TSDB**）中（这基本上是一个针对存储时间尺度上的事件进行优化的数据库），并提供查询指标和提供警报的功能。它还提供内置的图形界面和与Grafana的集成。
- en: But metrics are just one of the aspects of application monitoring. Another similar
    and important one is health checks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但指标只是应用程序监控的一个方面。另一个类似且重要的方面是健康检查。
- en: Defining application health checks
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序健康检查
- en: '**Health checks** are a kind of special case for metrics collection. Instead
    of exposing figures useful for evaluating the trends of application performance,
    health checks provide simple *on/off* information about the application being
    healthy or not.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**健康检查**是指标收集的一种特殊情况。而不是暴露用于评估应用程序性能趋势的数字，健康检查提供了关于应用程序是否健康的简单**开/关**信息。'
- en: Such information is particularly useful in cloud and PaaS environments (such
    as Kubernetes) because it can allow self-healing (such as a restart) in the event
    of an application not working.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息在云和PaaS环境（如Kubernetes）中特别有用，因为它可以在应用程序无法工作时允许自我修复（如重启）。
- en: 'OpenMetrics currently defines three kinds of health checks: **live**, **ready**,
    and **started**. These checks come from concepts in the Kubernetes world:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMetrics目前定义了三种健康检查：**live**、**ready**和**started**。这些检查来自Kubernetes世界中的概念：
- en: By using a live (health) check, Kubernetes knows whether an application is up
    and running, and restarts it if it's not healthy.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用实时（健康）检查，Kubernetes知道应用程序是否正在运行，如果不健康，则会重启它。
- en: By using a readiness check, Kubernetes will be aware of whether the application
    is ready to take requests and will forward connections to it.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用就绪检查，Kubernetes将了解应用程序是否准备好接收请求，并将连接转发给它。
- en: Startup checks identify the successful completion of the startup phase.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动检查识别启动阶段的成功完成。
- en: Note that **ready** and **started** are very similar but **started** has to
    do with the first startup of the application (which may be slow), while **ready**
    may involve a temporary inability to process requests (as an example, a traffic
    spike or other temporary slowdowns).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**ready**和**started**非常相似，但**started**与应用程序的首次启动有关（可能很慢），而**ready**可能涉及暂时无法处理请求（例如，流量激增或其他暂时性减速）。
- en: Quarkus provides such checks with the `smallrye-health` extension. The probes
    are exposed, by default, at the `/q/health/live`, `/q/health/ready`, and `/q/health/started`
    endpoints and the results are formatted as JSON.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus通过`smallrye-health`扩展提供此类检查。默认情况下，探测器在`/q/health/live`、`/q/health/ready`和`/q/health/started`端点暴露，结果格式化为JSON。
- en: 'In order to implement the checks, Quarkus provides an infrastructure based
    on annotations. This is how a basic `Liveness` probe is implemented:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现检查，Quarkus提供了一个基于注解的基础设施。这就是一个基本的`Liveness`探测器是如何实现的：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the preceding method is annotated with `@Liveness` and returns
    a message using the `up` method of the `HealthCheckResponse` object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的方法使用`@Liveness`进行了注解，并使用`HealthCheckResponse`对象的`up`方法返回一条消息。
- en: 'Similarly, a `Readiness` check will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一个`Readiness`检查将如下所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Also, in this case, the preceding method is annotated (in this case, with `@Readiness`)
    and returns a message using the `up` method of the `HealthCheckResponse` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，前面的方法也进行了注解（在这种情况下，使用`@Readiness`）并使用`HealthCheckResponse`对象的`up`方法返回一条消息。
- en: 'Finally, a `Startup` check will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个`Startup`检查将如下所示：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For startup checks, the preceding method is annotated (with `@Startup`) and
    returns a message using the `up` method of the `HealthCheckResponse` object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于启动检查，前面的方法被注解（使用`@Startup`），并使用`HealthCheckResponse`对象的`up`方法返回一个消息。
- en: As you can see, the API is pretty simple. The objects providing the functionalities
    are singletons by default. Of course, in a real-world application, you may want
    to do some complex checks such as testing the database connection or something
    similar.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，API非常简单。提供功能的对象默认是单例。当然，在现实世界的应用中，你可能想要做一些复杂的检查，比如测试数据库连接或类似的事情。
- en: You can of course return a negative response (such as with the `down()` method)
    if you detect any failure. Other useful features include the chaining of multiple
    checks (where the cumulative answer is `up`, only if every check is up) and the
    ability to include some metadata in the response.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以返回一个负响应（例如使用`down()`方法）如果你检测到任何故障。其他有用的功能包括多个检查的链式调用（其中累积答案是`up`，只有当每个检查都是`up`时）以及能够在响应中包含一些元数据的能力。
- en: Implementing OpenTracing
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现OpenTracing
- en: Tracing is a crucial monitoring technique when you have a long chain of calls
    (for example, a microservice calling other microservices, and so on), as you compose
    your answer by calling a huge number of internal or external services.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一系列长的调用链（例如，一个微服务调用其他微服务，等等）时，跟踪是一种至关重要的监控技术，因为你通过调用大量的内部或外部服务来构建你的答案。
- en: 'Indeed, it''s a very common use case in microservices applications: you have
    a call coming into your application (such as from a REST web service or an operation
    on a web user interface, which in turn translates into one or more REST calls).
    This kind of call will then be served by a number of different microservices,
    ultimately being assembled into a unique answer.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这在微服务应用中是一个非常常见的用例：一个调用进入你的应用（例如，来自REST Web服务或Web用户界面的操作，这反过来又转化为一个或多个REST调用）。这种调用将由多个不同的微服务来处理，最终组装成一个独特的答案。
- en: The issue with this is that you may end up losing trace of whatever happened.
    It becomes very hard to correlate the incoming call with every specific sub-call.
    And that may be a big problem, in terms of troubleshooting issues and even simply
    understanding what's happening.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于你可能会失去对所发生事件的追踪。将来电与每个特定的子调用相关联变得非常困难。这可能会成为一个大问题，无论是在故障排除问题中，还是在简单地理解正在发生的事情时。
- en: Tracing allows a way to identify the path made by each request by propagating
    an identifier code used in each subsystem, hence helping to document and reconstruct
    the tree of calls used to implement our use case, both for troubleshooting and
    for other purposes, such as audit logging.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪允许通过在每个子系统中使用的一个标识码来传播，从而识别每个请求的路径，这有助于记录和重建实现我们用例所使用的调用树，无论是用于故障排除还是其他目的，如审计日志。
- en: '`smallrye-opentracing`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`smallrye-opentracing`。'
- en: An interesting feature is that OpenTracing also supports computing the time
    spent on each sub-call.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的功能是，OpenTracing还支持计算每个子调用的耗时。
- en: Let's see a very simple example to understand how tracing works in Quarkus.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的例子，以了解在Quarkus中跟踪是如何工作的。
- en: 'We will start with a simple REST resource, as we have seen many other times
    in this book:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的REST资源开始，就像我们在本书中多次看到的那样：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, it's a simple REST method listening on the `/trace` endpoint.
    It uses a service (`NameGuessService`) that has been injected.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个简单的REST方法，监听`/trace`端点。它使用一个已经被注入的服务（`NameGuessService`）。
- en: 'It''s worth noticing that there is no specific code related to tracing: indeed,
    tracing in REST endpoints is basically automatically provided by the framework.
    It''s enough to have the `smallrye-opentracing` extension in the project itself.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，没有与跟踪相关的特定代码：实际上，在REST端点上的跟踪基本上是由框架自动提供的。只要在项目中包含`smallrye-opentracing`扩展就足够了。
- en: 'Now, let''s have a look at the `NameGuessService` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`NameGuessService`类：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, there is nothing special here: there''s just a simple mocked
    service returning a string, which is chosen randomly. The only notable thing is
    that the method is annotated with `@Traced`, because the framework needs to know
    explicitly whether the method must be traced.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有什么特别的地方：只有一个简单的模拟服务返回一个字符串，这个字符串是随机选择的。唯一值得注意的是，该方法被注解为`@Traced`，因为框架需要明确知道该方法是否必须被跟踪。
- en: '*Where do we go from here?* The most common and useful way to use tracing is
    with a Jaeger server. Jaeger basically exposes some services that collect and
    graphically display what''s happening in our application. The basic concept is
    a **span**, which is an end-to-end method call. In our case, one **span** is made
    out of our REST call, and another one is the sub-call in our injected service.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们从哪里开始？* 使用跟踪最常见且实用的方式是与Jaeger服务器一起使用。Jaeger基本上暴露了一些服务，这些服务收集并图形化显示我们的应用程序中发生的事情。基本概念是**跨度**，它是一个端到端的方法调用。在我们的例子中，一个**跨度**由我们的REST调用组成，另一个是由我们注入的服务中的子调用。'
- en: A quick way to test our service locally is to use a ready-made Jaeger server
    containerized.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地快速测试我们的服务的一种方法是使用现成的Jaeger服务器容器化。
- en: 'On a laptop with a container engine (such as Docker) installed, it''s enough
    to run the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了容器引擎（如Docker）的笔记本电脑上，只需运行以下命令即可：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will run a `jaegertracing` *all-in-one* image, specifying the ports used.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行一个`jaegertracing`的*一体化*镜像，指定使用的端口。
- en: 'We can then run our application, hooking it into a Jaeger server:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行我们的应用程序，将其连接到Jaeger服务器：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These parameters are provided as command-line arguments but could also be provided
    as part of the properties file. In this case, we are specifying how this service
    is called and which kind of sampling should be done (it's okay to use the default
    parameters for the purposes of this test).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数作为命令行参数提供，但也可以作为属性文件的一部分提供。在这种情况下，我们指定了如何调用此服务以及应该进行哪种类型的采样（对于本次测试，可以使用默认参数）。
- en: 'Now, we can invoke our REST service a couple of times at `http://127.0.0.1:8080/trace`,
    just to generate some traffic to display. If we then navigate to the Jaeger UI,
    available by default at `http://localhost:16686/`, we will see something similar
    (click on the **Find Traces** button and select the **test-opentracing** service,
    if necessary):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`http://127.0.0.1:8080/trace`上调用我们的REST服务几次，只是为了生成一些要显示的流量。如果我们然后导航到Jaeger
    UI，默认情况下在`http://localhost:16686/`，我们将看到类似的内容（如果需要，请点击**查找跟踪**按钮并选择**test-opentracing**服务）：
- en: '![Figure 14.2 – Jaeger UI home'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 – Jaeger UI首页'
- en: '](img/Figure_14.2_B16354_new.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.2_B16354_new.jpg)'
- en: Figure 14.2 – Jaeger UI home
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – Jaeger UI首页
- en: As you can see, each of the calls made to our service is displayed with the
    overall time to respond (a couple of milliseconds, in our example).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对我们的服务发出的每个调用都会显示总的响应时间（在我们的例子中是几毫秒）。
- en: 'If we click on one of those calls, we can see the two spans:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击其中一个调用，我们可以看到两个跨度：
- en: '![Figure 14.3 – Jaeger UI spans'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 – Jaeger UI跨度'
- en: '](img/Figure_14.3_B16354_new.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B16354_new.jpg)'
- en: Figure 14.3 – Jaeger UI spans
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – Jaeger UI跨度
- en: As you can see, the main span concerns the REST call with a smaller span on
    the sub-call of the injected service. It's easy to imagine how useful it is to
    have this kind of information on an application running in production.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要跨度涉及REST调用，而子调用注入的服务有一个较小的跨度。很容易想象在运行中的应用程序上拥有此类信息是多么有用。
- en: As you can see, in this example, we have just one microservice with two methods.
    However, the same concept can be easily extended to more than one microservice
    talking to each other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个例子中，我们只有一个微服务，有两个方法。然而，这个概念可以很容易地扩展到多个相互通信的微服务。
- en: Tracing and metrics are part of a bigger concept called **Application Performance
    Management** (**APM**).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪和指标是更大概念的一部分，称为**应用性能管理**（**APM**）。
- en: Application Performance Management
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能管理
- en: APM is a broad and very important aspect of running an application in production.
    It involves a lot of different technologies, and sometimes it has some unknowns
    around log aggregation, metrics collection, and overall monitoring, among other
    things.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: APM是运行生产中应用程序的一个广泛且非常重要的方面。它涉及许多不同的技术，有时在日志聚合、指标收集和整体监控等方面存在一些未知因素。
- en: Each vendor or stack of monitoring technologies has slightly different comprehensions
    of what APM is about, and somewhat different implementations of it as a result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个供应商或监控技术堆栈对APM（应用性能管理）的理解略有不同，因此其实现也有所不同。
- en: 'I think that it''s good to start from the goal: the goal of APM is to have
    insights into how a set of applications is performing, and what impact the underlying
    parameters (such as memory usage, database metrics, and more) have on the end
    user experience (such as user interface responsiveness, response times, and so
    on).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为从目标开始是好的：APM的目标是深入了解一组应用程序的性能，以及底层参数（如内存使用、数据库指标等）对最终用户体验（如用户界面响应性、响应时间等）的影响。
- en: It is easy to understand that to implement such a useful (and broad) goal, you
    may need to stack a number of different tools and frameworks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解，为了实现这样一个有用（且广泛）的目标，你可能需要堆叠多个不同的工具和框架。
- en: 'We have seen some of this in the previous section: you may want to have information
    coming from logs (to understand what the application is doing), together with
    metrics (to understand the resource consumption and collect other KPIs such as
    the number of calls), with health checks (to have a quick view over which service
    is up), and with tracing (to understand how each specific call is performed, including
    all the sub-calls).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到了一些这样的内容：你可能希望从日志中获取信息（以了解应用程序正在做什么），以及与指标（以了解资源消耗并收集其他KPI，如调用次数）一起，进行健康检查（以快速查看哪些服务正在运行），以及进行跟踪（以了解每个特定调用是如何执行的，包括所有子调用）。
- en: And there are a number of other tools that you can use. As an example, JVM provides
    some useful parameters (we saw some when discussing metrics) such as memory and
    CPU consumption.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他工具你可以使用。例如，JVM提供了一些有用的参数（我们在讨论指标时看到了一些），如内存和CPU消耗。
- en: Last but not least, for code that is not natively instrumented (such as legacy
    code that is not providing metrics using frameworks similar to the one seen previously),
    it is possible to collect some metrics using some more invasive approaches, such
    as Java agents, which are low-level configurations that act on the JVM to understand
    how and when each method of our code is called.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，对于不是原生可插装的代码（例如之前提到的类似框架未提供指标的遗留代码），可以通过一些更侵入性的方法收集一些指标，例如Java代理，这些是低级配置，在JVM上操作以了解我们的代码中的每个方法是如何以及何时被调用的。
- en: With that said, you can imagine how hard it can be to provide a unified, easy-to-read,
    overall vision of what's happening with our application. You will need to install
    and maintain a lot of different tools and glue them together in order to display
    meaningful and uniform information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可以想象提供关于我们应用程序的整体、易于阅读的视图是多么困难。你需要安装和维护许多不同的工具，并将它们粘合在一起，以便显示有意义的统一信息。
- en: For this reason, aside from open source standards and tools, commercial solutions
    have emerged (such as **Dynatrace**, **Datadog**, and **Splunk**), which allow
    us to use ready-made stacks to provide such information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了开源标准和工具之外，还出现了商业解决方案（如**Dynatrace**、**Datadog**和**Splunk**），这些解决方案允许我们使用现成的堆栈来提供此类信息。
- en: 'But now that it is clear how important and useful it is to have this kind of
    information, let''s look at some topics to be aware of when talking about APM:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们已经清楚拥有这类信息的重要性和实用性，让我们来看看在讨论APM时需要注意的一些话题：
- en: '**It may impact performance**: Many of the approaches seen so far have been
    designed to have as little impact as possible by using asynchronous and non-blocking
    techniques. However, especially if we use older approaches such as Java agents,
    the impact can be significant. And if you think that an APM system might be useful
    when your application is slow, it''s easy to understand that APM must be as lightweight
    as possible, to avoid putting any further pressure on systems that are already
    requested.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能会影响性能**：迄今为止看到的大多数方法都是通过使用异步和非阻塞技术来尽量减少影响而设计的。然而，特别是如果我们使用像Java代理这样的旧方法，影响可能会很大。如果你认为当应用程序运行缓慢时APM系统可能很有用，那么很容易理解APM必须尽可能轻量级，以避免对已经请求的系统造成更多压力。'
- en: '**It requires nontrivial maintenance**: The data collected can simply be huge
    in quantity. Think about every transaction generating a bunch of metrics (timing,
    error codes, resources consumed), plus a number of lines of logs and tracing information.
    When all these metrics are multiplied by hundreds or thousands of transactions,
    it may become difficult to maintain them. Plus, as said, each specific type of
    information you might want to look for (logs, metrics, and checks) is managed
    by a different stack, hence we may end up using different servers, storage, and
    configurations.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它需要非平凡的维护**：收集到的数据可能数量巨大。想想每个交易都会生成一系列指标（时间、错误代码、消耗的资源），再加上日志和跟踪信息的行数。当所有这些指标乘以数百或数千笔交易时，可能变得难以维护。此外，正如所说，你可能想要查找的每种具体类型的信息（日志、指标和检查）都由不同的堆栈管理，因此我们可能最终会使用不同的服务器、存储和配置。'
- en: '**The information collected may be hard to correlate**: Especially in the event
    of an issue, you may want to understand whether a specific transaction caused
    the issue and how the system behaved. While tracing makes it easy to correlate
    a transaction with each sub-call and subsystem, correlating tracing information
    with logging information plus metrics and health checks will still be trouble.
    Moreover, comparing different kinds of data (such as timespans with KPIs and messages)
    can be hard, especially in user interfaces.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集到的信息可能难以关联**：特别是在出现问题时，你可能想知道是否是某个特定的交易导致了问题，以及系统是如何表现的。虽然跟踪可以轻松地将交易与每个子调用和子系统关联起来，但将跟踪信息与日志信息、指标和健康检查关联起来仍然会带来麻烦。此外，比较不同类型的数据（如时间段与KPI和消息）可能很困难，尤其是在用户界面中。'
- en: Last but not least, it's crucial to correlate the platform information with
    the related features implemented. In the next section, we are going to look a
    bit more into what kind of information is worth collecting, and how to categorize
    it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，将平台信息与相关实现的功能关联起来至关重要。在下一节中，我们将更深入地探讨哪些信息值得收集，以及如何对其进行分类。
- en: Service monitoring
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务监控
- en: A very important consideration is what to monitor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的考虑因素是监控什么。
- en: Indeed, it's very important to collect as much data as possible, in terms of
    metrics and KPIs, as they may reveal interesting trends, and can be very useful
    if something unpredicted happens. But at the same time, business users are mostly
    interested in different kinds of metrics and information, such as the number of
    transactions per second (or per hour, or per day), the amount of money that passes
    through the platform, the number of concurrent users, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尽可能多地收集数据非常重要，无论是从指标还是KPI的角度来看，因为它们可能会揭示有趣的趋势，如果发生不可预测的事情，它们将非常有用。但与此同时，商业用户对各种指标和信息更感兴趣，例如每秒（或每小时、每天）的交易数量，通过平台流通的金额，并发用户数量等等。
- en: 'Hence, there are two different kinds of KPIs to look for, sometimes with a
    blurred boundary between them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要寻找两种不同类型的KPI，有时它们之间的界限可能模糊：
- en: '**Technical information**: Things such as the memory used, the number of threads,
    the number of connections, and so on. These things are useful for sizing and scaling
    systems and trying to forecast whether our system will perform well or some interventions
    are needed.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术信息**：如内存使用量、线程数量、连接数量等等。这些信息对于系统的大小和扩展以及尝试预测我们的系统是否会表现良好或需要干预非常有用。'
- en: '**Business information**: Defining what information is business information
    heavily depends on the application realm, but usually includes the average transaction
    time, the number of concurrent users, the number of new users, and so on.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商业信息**：定义什么是商业信息在很大程度上取决于应用领域，但通常包括平均交易时间、并发用户数量、新用户数量等等。'
- en: From a technical standpoint, you can use the same frameworks (especially ones
    for collecting metrics) in order to collect both technical and business information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，你可以使用相同的框架（特别是用于收集指标的框架）来收集技术和商业信息。
- en: But it's very important (and not so easy to do) to try to correlate one kind
    of metric with another.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但尝试将一种指标与另一种指标关联起来非常重要（而且并不容易做到）。
- en: In other words, it could be useful to have a map (even simple documentation
    such as a web page can be enough) that documents where each feature is hosted,
    and how specific business information is related to a set of technical information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，拥有一个地图（即使是简单的文档，如网页也足够）来记录每个功能托管的位置，以及特定商业信息如何与一系列技术信息相关联，可能是有用的。
- en: 'Let''s look at an example: if we have a business KPI about the transaction
    time of a specific functionality, it is important to understand which servers
    provide that functionality, and which specific set of microservices (or applications)
    implements it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：如果我们有一个关于特定功能交易时间的业务KPI，了解哪些服务器提供了该功能，以及哪些特定的微服务集（或应用程序）实现了它，这一点非常重要。
- en: In this way, you can link a business metric (such as the transaction time) to
    a set of technical metrics (such as the memory used by a number of JVMs, used
    threads, CPU consumption on the servers that are running such JVMs, and more).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以将业务指标（如交易时间）与一系列技术指标（如多个JVM使用的内存、使用的线程、运行这些JVM的服务器上的CPU消耗等）联系起来。
- en: By doing that, you can better correlate a change in performance in that particular
    feature (in our case, transactions going slower) to a specific subset of technical
    information (such as an increase in CPU usage on one particular server).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以更好地将特定功能（在我们的案例中，是交易变慢）的性能变化与特定的技术信息子集（如特定服务器上CPU使用量的增加）相关联。
- en: This will help in troubleshooting and quickly fixing production issues (by scaling
    the resources on impacted systems).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于故障排除和快速修复生产问题（通过扩展受影响系统的资源）。
- en: 'Other than this, business metrics are simply valuable for some users: they
    may be used for forecasting the economic performance of the platform, the expected
    growth, and similar parameters. For this reason, it''s common to store such information
    on specific data stores (such as big data or data lakes), where they can be correlated
    with other information, which is analyzed and further studied.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，业务指标对某些用户来说非常有价值：它们可能被用来预测平台的财务表现、预期的增长以及类似的参数。因此，通常将这些信息存储在特定的数据存储中（如大数据或数据湖），这样它们就可以与其他信息相关联，这些信息被分析并进一步研究。
- en: This completes the topics that were planned for this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本章计划讨论的主题。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at some interesting considerations about monitoring
    and tracing our applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了关于监控和追踪我们应用程序的一些有趣考虑因素。
- en: We started by reviewing some basic concepts about logging in Java, and why log
    aggregation is a good thing to do in microservices and cloud-native applications.
    We then moved on to the concept of metrics and health checks, and how applications
    can provide data in real time on the performance and health of our modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾了关于Java日志记录的一些基本概念，以及为什么在微服务和云原生应用程序中进行日志聚合是一件好事。然后，我们转向指标和健康检查的概念，以及应用程序如何提供有关我们模块性能和健康状况的实时数据。
- en: We then discussed tracing, which is very important when it comes to troubleshooting
    and managing distributed applications (such as microservices applications). APM
    was the next topic and is about putting all the information together (such as
    metrics, health checks, and logs) to create an overview of the application insights.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了追踪，这在故障排除和管理分布式应用程序（如微服务应用程序）时非常重要。APM是下一个话题，它涉及将所有信息（如指标、健康检查和日志）汇总在一起，以创建应用程序洞察的概览。
- en: Last but not least, we saw how service monitoring involves linking business
    information with the technical KPIs behind it, to support troubleshooting and
    draw more insights from the collected data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们看到了服务监控如何涉及将业务信息与背后的技术KPI联系起来，以支持故障排除并从收集的数据中获得更多见解。
- en: In the next chapter, we are going to see what's new in the latest version of
    the Java technology.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到Java技术最新版本中的新内容。
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Hanif Jetha, *How To Set Up an Elasticsearch, Fluentd and Kibana (EFK) Logging
    Stack on Kubernetes* ([https://www.digitalocean.com/community/tutorials/how-to-set-up-an-elasticsearch-fluentd-and-kibana-efk-logging-stack-on-kubernetes](https://www.digitalocean.com/community/tutorials/how-to-set-up-an-elasticsearch-fluentd-and-kibana-efk-logging-stack-on-kubernetes))
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hanif Jetha，*如何在Kubernetes上设置Elasticsearch、Fluentd和Kibana（EFK）日志堆栈* ([https://www.digitalocean.com/community/tutorials/how-to-set-up-an-elasticsearch-fluentd-and-kibana-efk-logging-stack-on-kubernetes](https://www.digitalocean.com/community/tutorials/how-to-set-up-an-elasticsearch-fluentd-and-kibana-efk-logging-stack-on-kubernetes))
- en: 'Himanshu Shukla, *#Microservices : Observability Patterns* ([https://medium.com/@greekykhs/microservices-observability-patterns-eff92365e2a8](mailto:https://medium.com/@greekykhs/microservices-observability-patterns-eff92365e2a8))'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Himanshu Shukla，*#微服务：可观察性模式* ([https://medium.com/@greekykhs/microservices-observability-patterns-eff92365e2a8](mailto:https://medium.com/@greekykhs/microservices-observability-patterns-eff92365e2a8))
- en: '*MicroProfile Metrics* ([https://download.eclipse.org/microprofile/microprofile-metrics-2.3/microprofile-metrics-spec-2.3.html](https://download.eclipse.org/microprofile/microprofile-metrics-2.3/microprofile-metrics-spec-2.3.html))'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微服务指标规范* ([https://download.eclipse.org/microprofile/microprofile-metrics-2.3/microprofile-metrics-spec-2.3.html](https://download.eclipse.org/microprofile/microprofile-metrics-2.3/microprofile-metrics-spec-2.3.html))'
- en: '*The OpenTracing project* ([https://opentracing.io/](https://opentracing.io/))'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenTracing 项目* ([https://opentracing.io/](https://opentracing.io/))'
