- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Key Architectural Patterns in Microservices – DDD, CQRS, and Event Sourcing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的关键架构模式——领域驱动设计（DDD）、命令查询责任分离（CQRS）和事件溯源
- en: This chapter is all about appreciation of the backbone of microservices – the
    central patterns that make our software designs strong, scalable, and effective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这章全部关于欣赏微服务的骨架——那些使我们的软件设计强大、可扩展和有效的中心模式。
- en: So first off, we’ll want to delve into the world of domain-driven design. It’s
    an approach to software that fits business concerns to any given software project.
    It’s akin to ensuring our software speaks the same lingo as the business challenges
    it’s working to answer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将深入探讨领域驱动设计的世界。这是一种将业务关注点适应任何给定软件项目的方法。它类似于确保我们的软件与它试图解决的商业挑战使用相同的语言。
- en: Coming up is Command Query Responsibility Segregation. It’s a nice way to divide
    how we manipulate data in two – one for updating and another for retrieving. It
    divides our software duties in a cleaner, more efficient way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是命令查询责任分离。这是一种将我们如何操作数据分为两部分的不错方式——一个用于更新，另一个用于检索。它以更干净、更高效的方式划分了我们的软件职责。
- en: Next, there is Event Sourcing. We record each change as a series of events here.
    It is like an itemized account of everything that has happened – one which can
    be very powerful for looking back at the history of our data and choices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是事件溯源。我们在这里记录每个更改作为一个事件序列。它就像一个详细记录了所发生一切的清单——这对于回顾我们的数据和选择的历史可以非常强大。
- en: 'As we progress through this chapter, we will understand why architectural patterns
    are important and how to apply them in order to build our microservices correctly.
    We will learn not only what architectural patterns are but their practical application
    as well. In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本章，我们将了解架构模式为何重要，以及如何正确地应用它们来构建我们的微服务。我们将不仅学习什么是架构模式，还将学习它们的实际应用。在本章中，我们将涵盖以下主要主题：
- en: Introduction to architectural patterns in microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式简介
- en: '**Domain-Driven** **Design** (**DDD**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域驱动** **设计** （**DDD**）'
- en: '**Command Query Responsibility** **Segregation** (**CQRS**)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令查询责任** **分离** （**CQRS**）'
- en: Event Sourcing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源
- en: Brief overview of other architectural patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他架构模式的简要概述
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To better understand this chapter, it would be beneficial if you had knowledge
    in the following areas:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解本章，以下领域的知识将有所帮助：
- en: '**Solid understanding of microservice architecture principles**: Grasp the
    foundational concepts that underpin microservices'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对微服务架构原则的深入了解**：掌握支撑微服务的基础概念'
- en: '**Familiarity with software design patterns**: Know the common patterns that
    solve software design problems'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**熟悉软件设计模式**：了解解决软件设计问题的常见模式'
- en: '**Basic programming concepts**: Have a good command of the fundamental principles
    of programming'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本编程概念**：掌握编程的基本原则'
- en: '**Understanding of distributed systems**: Be aware of how distributed systems
    work and their challenges'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对分布式系统的理解**：了解分布式系统的工作原理及其挑战'
- en: '**Knowledge of microservices’ purpose and implementation**: Understand why
    microservices are used, how they are implemented, and their benefits'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务目的和实现的知识**：了解微服务为何被使用，如何实现，以及它们的优点'
- en: '**Grasp of microservice communication and operation**: Know how microservices
    communicate with each other and operate within a larger system'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掌握微服务通信和操作**：了解微服务如何相互通信并在更大的系统中操作'
- en: Introduction to architectural patterns in microservices
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构模式简介
- en: Alright, so in this section, we’re going to look at how to implement design
    patterns into microservices. To really understand this topic, let’s first go over
    some subheadings to help build up the big picture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以在这个部分，我们将探讨如何将设计模式应用到微服务中。为了真正理解这个主题，让我们首先回顾一些子标题，以帮助构建整体图景。
- en: Why do we need an architectural design in the first place?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么一开始就需要一个建筑设计呢？
- en: An architectural pattern is, simply put, a proven balanced solution from experience
    to tackle some recurring problem in software architecture. These patterns solve
    issues from hardware limitation to high availability and minimizing business risk.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，架构模式是经验证明的平衡解决方案，用于解决软件架构中的一些常见问题。这些模式从硬件限制到高可用性和最小化商业风险等问题都有所涉及。
- en: One significant advantage is that they offer ways of solving software problems
    since most of the basic architectural design problems have been already tested.
    They streamline the process through which tightly connected and communicating
    modules that work together with minimal coupling are created. This also helps
    to make the overall system easier to understand and maintain by allowing variations
    in the structure depending on what is actually needed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的优势是，它们提供了解决软件问题的方法，因为大多数基本架构设计问题已经过测试。它们通过简化创建紧密连接和通信的模块的过程，这些模块以最小的耦合协同工作。这也通过根据实际需要调整结构，有助于使整个系统更容易理解和维护。
- en: Another great advantage is that design patterns help increase the effectiveness
    of communication between developers and designers. When working on system design,
    if developers or designers refer to a pattern by its name, then everyone knows
    the general high-level design they’re talking about right away.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个巨大的优势是，设计模式有助于提高开发者和设计师之间沟通的有效性。当进行系统设计时，如果开发人员或设计师通过模式名称进行引用，那么每个人都能立即知道他们所讨论的一般高级设计。
- en: What are design patterns?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式是什么？
- en: '**Design patterns** are basically templates that developers use to solve common
    problems in software design. Each pattern shows you a typical solution that you
    can then customize for your own project’s needs. For example, if you often have
    to structure a program a certain way, a design pattern can provide a proven approach
    for you to modify as needed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**基本上是开发者用来解决软件设计中常见问题的模板。每个模式都展示了一种典型的解决方案，你可以根据自己项目的需求进行定制。例如，如果你经常需要以某种方式结构化程序，设计模式可以为你提供一个经过验证的方法，根据需要对其进行修改。'
- en: What are microservices?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务是什么？
- en: '**Microservices** are an architecture style where you basically break up an
    application into a bunch of small, independent services. Each service focuses
    on doing one specific thing really well and communicates with the other services
    through simple protocols. The big benefit is that teams can work on their own
    services separately without affecting the rest of the app.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是一种架构风格，你基本上是将应用程序拆分成许多小型、独立的微服务。每个服务专注于做一件特定的事情，并通过简单的协议与其他服务进行通信。最大的好处是团队可以在不影响应用程序其他部分的情况下，独立地工作在自己的服务上。'
- en: This approach allows teams to focus solely on their specific tasks without worrying
    about how changes might impact other parts of the application. They can iterate
    quickly on their code and features without the need for extensive coordination
    and testing across the entire codebase. When done right, microservices make the
    development process more efficient since teams have autonomy over their own services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许团队专注于他们的特定任务，而不必担心更改可能会对应用程序的其他部分产生什么影响。他们可以快速迭代代码和功能，而无需在整个代码库中进行广泛的协调和测试。如果做得正确，微服务可以使开发过程更高效，因为团队对自己的服务拥有自主权。
- en: The separation also makes the application more scalable and resilient. Since
    each service is independent, teams can update their code and deploy new versions
    without disrupting the other services. If one service experiences an outage or
    needs to be taken offline for maintenance, it doesn’t bring down the entire application.
    Companies are able to keep their software running smoothly even if some parts
    are temporarily unavailable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离也使得应用程序更具有可扩展性和弹性。由于每个服务都是独立的，团队可以更新他们的代码并部署新版本，而不会影响其他服务。如果一个服务出现故障或需要离线进行维护，它不会使整个应用程序崩溃。公司能够在某些部分暂时不可用的情况下，保持软件的平稳运行。
- en: Additionally, the modular design means the application can grow really large
    without everything getting too tangled and complex. New features don’t require
    changes throughout the codebase. Teams can simply build out additional services
    to handle new capabilities. With microservices, companies can build software really
    fast since teams don’t slow each other down by waiting on code reviews and deployments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模块化设计意味着应用程序可以变得非常大，而不会变得过于混乱和复杂。新功能不需要对整个代码库进行更改。团队可以简单地构建额外的服务来处理新的功能。有了微服务，公司可以非常快速地构建软件，因为团队不会因为等待代码审查和部署而相互拖慢进度。
- en: The tradeoff is that keeping the services separate takes more work upfront.
    There’s additional complexity in managing the communication between independent
    parts. However, for large applications, microservices provide benefits that outweigh
    the initial cost by enabling rapid, reliable development at scale.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代价是保持服务分离需要更多前期工作。管理独立部分之间的通信有额外的复杂性。然而，对于大型应用程序，微服务通过实现快速、可靠的规模化开发，提供了超过初始成本的益处。
- en: What are the principles behind microservices?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的原则是什么？
- en: 'The six main principles behind microservices are autonomy, loose coupling,
    reuse, fault tolerance, composability, and discoverability. Let me explain a bit
    more about each one:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务背后的六个主要原则是自主性、松耦合、重用、容错性、可组合性和可发现性。让我更详细地解释一下每一个：
- en: '**Autonomy** means that each microservice is independent and in control of
    its own runtime and database. This makes it faster and more reliable since it’s
    not dependent on other services. As long as it stays stateless, it can also scale
    up easily.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主性**意味着每个微服务都是独立的，并控制自己的运行时和数据库。这使得它更快、更可靠，因为它不依赖于其他服务。只要它保持无状态，它也可以轻松扩展。'
- en: '**Loose coupling** means the services don’t rely too much on each other. By
    using standardized APIs, one service can change without affecting the others.
    This allows for more flexibility and evolution over time. It also makes development
    and fixes faster.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**意味着服务之间依赖性不大。通过使用标准化的API，一个服务可以改变而不影响其他服务。这允许有更多的灵活性和随时间的演变。它也使得开发和修复更快。'
- en: '**Reuse** is still important but at a more specific domain level within the
    business. Teams can decide how to adapt services for new uses case by case. This
    guided reuse approach is better than a rigid predetermined model.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用**仍然很重要，但在业务中更具体的应用领域。团队可以决定如何根据每个新的用例来调整服务。这种有指导的重用方法比僵化的预定模型更好。'
- en: '**Fault tolerance** means each service can keep working even if another fails.
    Things like circuit breakers stop individual failures from spreading. This keeps
    the whole system reliable.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**意味着即使另一个服务失败，每个服务也可以继续工作。像断路器这样的东西可以阻止单个故障扩散。这保持了整个系统的可靠性。'
- en: '**Composability** means services can deliver value in different combinations.
    Multiple services working together become the new way of building applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**意味着服务可以以不同的组合方式提供价值。多个服务协同工作成为构建应用程序的新方式。'
- en: '**Discoverability** means each service clearly communicates what business problem
    it solves and how other teams can use its technical interface. This makes it easy
    for developers to understand the microservices’ functionality and how to consume
    the events it publishes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可发现性**意味着每个服务都清楚地传达它解决的业务问题和如何使用其技术接口。这使得开发者能够理解微服务的功能以及如何消费它发布的事件。'
- en: In summary, these six principles of autonomy, loose coupling, reuse, fault tolerance,
    composability, and discoverability form the foundation of microservices architecture.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这六个原则：自主性、松耦合、重用、容错性、可组合性和可发现性，构成了微服务架构的基础。
- en: Microservices design patterns
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: Up to this point, we have discussed why we need an architectural design, what
    design patterns and microservices are, and the principles behind microservices.
    In this section, our focus is on the microservice design patterns. That is, as
    previously explained, design patterns help in such a way that they fix the particular
    challenge of microservice architecture and also help to reduce the risk of failure
    in microservices – but only if we understand them clearly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了为什么我们需要架构设计，什么是设计模式以及微服务的原则。在本节中，我们的重点是微服务设计模式。也就是说，如前所述，设计模式以这种方式帮助解决微服务架构的特定挑战，并有助于降低微服务的失败风险——但前提是我们清楚地理解它们。
- en: The next question is what exactly those design patterns are. Well, I’d like
    to share a diagram that illustrates the big picture of design patterns in microservices
    architecture. It does not cover all design patterns, but the most common designs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是那些设计模式究竟是什么。好吧，我想分享一个图表，它展示了微服务架构中设计模式的全貌。它并不涵盖所有设计模式，但涵盖了最常见的模式。
- en: '![Figure 2.1: Common microservice design patterns](img/B18400_02_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：常见的微服务设计模式](img/B18400_02_01.jpg)'
- en: 'Figure 2.1: Common microservice design patterns'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：常见的微服务设计模式
- en: In previous sections, we talked about microservice architecture and the importance
    of having well-defined patterns when you are designing microservices. Microservices
    can get complicated very fast based on the fact that there are so many moving
    parts; design patterns help to take care of some specific problems while reducing
    the risks of failure. In this section, we would like to take a slightly deeper
    dive into some of the most common microservice design patterns that it’s good
    to have an awareness of.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了微服务架构以及在设计微服务时拥有良好定义模式的重要性。基于存在许多移动部件的事实，微服务可能会很快变得复杂；设计模式有助于处理一些特定问题，同时降低失败的风险。在本节中，我们想稍微深入探讨一些最常见且值得了解的微服务设计模式。
- en: We are going to talk about a couple of the most common microservice design patterns
    and give a bit of explanation about each of them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一些最常见的微服务设计模式，并对每个模式进行一些解释。
- en: Aggregator design pattern
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合设计模式
- en: The Aggregator pattern is useful when you need to display data from multiple
    microservices on a single page or interface. For example, if you have a dashboard
    that pulls in various metrics and statuses from different services, the Aggregator
    pattern allows you to collect that data in one place efficiently.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在一个页面或界面上显示来自多个微服务的多个数据时，聚合模式非常有用。例如，如果你有一个仪表板，它从不同的服务中拉取各种指标和状态，聚合模式允许你高效地将这些数据收集在一个地方。
- en: API Gateway design pattern
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 网关设计模式
- en: The API gateway acts as a single entry point or “front door” for your microservices.
    All requests must go through the API gateway, which handles authentication, authorization,
    monitoring, and routing requests to the appropriate services. This provides an
    extra layer of security compared to exposing services directly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关充当微服务的单一入口点或“前门”。所有请求都必须通过 API 网关，它处理身份验证、授权、监控并将请求路由到适当的服务。与直接暴露服务相比，这提供了一层额外的安全保护。
- en: Saga design pattern
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Saga 设计模式
- en: The Saga pattern is useful when you have a business process that involves multiple
    services, and the steps must be executed transactionally. For example, when posting
    a photo to a social profile, the Saga pattern coordinates saving the photo, updating
    the profile, and notifying followers all in a reliable way, even if some services
    fail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的业务流程涉及多个服务，并且步骤必须以事务方式执行时， Saga 模式非常有用。例如，当在社交资料上发布照片时，Saga 模式可以协调以可靠的方式保存照片、更新资料和通知关注者，即使某些服务失败。
- en: To sum up, there are so many different microservice design patterns out there
    these days. It can be tough to decide which ones might work best for your particular
    project. But I’ve found that oftentimes, you can actually use a couple of different
    patterns at the same time, depending on what you’re trying to accomplish.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如今有如此多的不同微服务设计模式。决定哪些可能最适合你的特定项目可能会很困难。但我发现，很多时候，你可以根据你试图达成的目标同时使用几个不同的模式。
- en: For example, let’s say you have a project with multiple independent services,
    all of which need to access the same database. In that case, a Gateway pattern
    might make sense for the database access to avoid having every service connect
    directly. That way you consolidate the database connections through a single service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个包含多个独立服务的项目，所有这些服务都需要访问同一个数据库。在这种情况下，使用网关模式来访问数据库可能是有意义的，这样可以避免每个服务都直接连接。这样，你可以通过单个服务来整合数据库连接。
- en: At the same time though, some of your services might work really well with a
    Client/Server pattern between them. Maybe one service acts as a server providing
    data to others functioning as clients. So, in that part of the architecture, Client/Server
    could be a good fit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同时，你的某些服务可能在与它们之间的客户端/服务器模式中工作得非常好。也许一个服务作为服务器向其他作为客户端的服务提供数据。因此，在这个架构部分，客户端/服务器可能是一个很好的选择。
- en: The main thing is to think about the goals and needs of each individual service
    or group of services. What patterns will help you achieve things such as loose
    coupling, scalability, fault tolerance, and the like? As long as you can clearly
    explain why you’ve selected the patterns that you have, and how they help address
    specific goals, then using more than one pattern in a project is totally reasonable.
    The patterns are there to serve your design – not the other way around.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要考虑每个单独的服务或服务组的目标和需求。哪些模式能帮助你实现松散耦合、可扩展性、容错性等目标？只要你能清楚地解释你为什么选择了这些模式，以及它们如何帮助解决特定的目标，那么在一个项目中使用多个模式是完全合理的。模式是为了服务于你的设计——而不是反过来。
- en: After discussing various microservice design patterns and their applications
    for specific architectural challenges, we will move on to the next section. Here,
    we will explore DDD, which will help us understand how each microservice can be
    responsible for domain-specific actions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了各种微服务设计模式和它们在特定架构挑战中的应用之后，我们将进入下一部分。在这里，我们将探索DDD，这将帮助我们了解每个微服务如何负责特定领域的操作。
- en: Exploring DDD
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索DDD
- en: We’re going to be breaking down DDD for you in a way that’s easy to understand.
    Now if you’ve never heard of DDD before, don’t stress – it’s mainly used for big
    projects that take around six months or longer to complete. But even if you’re
    just doing smaller stuff, learning the basics can still be helpful.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一种易于理解的方式为你分解DDD。现在，如果你之前从未听说过DDD，请不要担心——它主要用于需要六个月或更长时间才能完成的大型项目。但即使你只是做些小项目，学习基础知识仍然是有帮助的。
- en: DDD is all about structuring your code around the specific problem or “domain”
    that your software is trying to solve. In simpler terms, it’s organizing your
    code to match what your app is actually about.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的核心是围绕你的软件试图解决的特定问题或“领域”来结构化你的代码。用更简单的话说，就是组织你的代码以匹配你的应用程序实际上关注的内容。
- en: Firstly, we will discuss some basic terminologies such as domain and DDD, and
    then later, we will explore how to implement DDD. Finally, we will go over a real-world
    example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论一些基本术语，如领域和DDD，然后稍后我们将探讨如何实现DDD。最后，我们将讨论一个现实世界的例子。
- en: What is a domain exactly?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是领域？
- en: A **domain** refers to the main topic or area that your app focuses on. For
    example, if you’re building an ordering app, the domain would likely be online
    shopping or order processing. It’s important to really understand the domain too,
    because one company could be working in multiple domains at the same time, such
    as shopping, delivery, transportation, repairs – you get the idea.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域**指的是你的应用程序关注的主题或领域。例如，如果你正在构建一个订单应用程序，领域可能很可能是在线购物或订单处理。真正理解领域也很重要，因为一家公司可能同时在工作多个领域，如购物、配送、运输、维修——你懂的。'
- en: Sometimes a domain might seem too broad, such as “food,” for example. In these
    cases, you should specify the exact part of that industry you’re tackling. Now
    for really big domain models, you can break them into smaller *bounded contexts*
    to make things easier to manage. For example, within a food company, there may
    be separate contexts for the sales team and delivery team, each with its own experts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个领域可能看起来太宽泛，例如，“食品”就是一个例子。在这些情况下，你应该指定你正在处理的该行业的确切部分。现在对于非常大的领域模型，你可以将它们分解成更小的*边界上下文*，以便更容易管理。例如，在一家食品公司内部，可能有针对销售团队和配送团队的单独上下文，每个上下文都有自己的专家。
- en: These domain experts work closely with developers to nail the functionality.
    Dividing the domain into bounded contexts simplifies the work and keeps everything
    organized.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域专家与开发者紧密合作，确保功能的实现。将领域划分为边界上下文简化了工作并保持了组织性。
- en: So, in summary, DDD is a way to develop software for complex problems by focusing
    on domains and contexts to make sure your code matches the specifics of what you’re
    trying to solve.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，DDD是一种通过关注领域和上下文来开发复杂软件的方法，确保你的代码与你要解决的问题的具体性相匹配。
- en: What is DDD?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是DDD？
- en: We’re now going to talk about DDD. DDD is all about deeply linking your code
    to the core concepts or context of your business domain. The goal is to help handle
    complex scenarios by facilitating effective collaboration between the domain experts
    and developers. This way there’s less room for misunderstandings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论DDD。DDD的核心是将你的代码与业务领域的核心概念或上下文深度链接。目标是帮助通过促进领域专家和开发者之间的有效协作来处理复杂场景，这样误解的空间就会更小。
- en: DDD really shines in big projects with lots of moving parts, where you need
    experts weighing in and everyone working together. But it’s probably overkill
    for smaller solo projects that you can manage on your own. The key to successful
    collaboration is communication. With DDD, both the developers and experts (such
    as architecture and domain experts) share a common language that they use when
    discussing things, building the domain model, and writing the code. This helps
    speed up the feedback loop.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 在具有许多动态部分的大项目中特别出色，在这些项目中，你需要专家的意见，并且每个人都必须共同努力。但对于你可以独立管理的小型个人项目来说，可能就有些过度了。成功协作的关键是沟通。使用
    DDD，开发人员和专家（如架构和领域专家）在讨论事情、构建领域模型和编写代码时共享一种共同的语言。这有助于加快反馈循环。
- en: But you have to be careful. If you don’t keep enriching and defining that shared
    language, separate languages could start forming within the teams. And then it’s
    goodbye to effective communication – this causes inaccuracies and confusion. For
    example, the term “client” could mean a user in one context but a system service
    in another. So, it’s super important to clearly define what everything means.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但你必须小心。如果你不持续丰富和定义这种共享语言，团队内部可能会开始形成不同的语言。然后，有效的沟通就会告吹——这会导致不准确和混淆。例如，“客户端”一词在一个上下文中可能指用户，而在另一个上下文中可能指系统服务。因此，清楚地定义每一件事的含义非常重要。
- en: Also, each domain should have its own custom language to avoid conflicts. And
    we’ll want to establish boundaries between domains to prevent cross-contamination.
    One way to shield a domain is with an **Anti-Corruption Layer**. This layer acts
    like a translator between different domain models, using patterns like adapters,
    facades, or translators to help the domains communicate without polluting each
    other. This helps explain what DDD is all about.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个领域都应该有自己的定制语言以避免冲突。我们还将想要在领域之间建立边界，以防止交叉污染。保护领域的一种方法是通过 **反腐败层**。这一层充当不同领域模型之间的翻译者，使用适配器、外观或翻译者等模式来帮助领域之间进行通信而不相互污染。这有助于解释
    DDD 是什么。
- en: How to define DDD structure?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何定义 DDD 结构？
- en: 'In this section, we will break down the DDD structure for an online shopping
    app example that we will discuss later in this section. There are a few key layers
    we need to focus on to make our application run smoothly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分解一个在线购物应用程序的 DDD 结构示例，我们将在本节稍后讨论。我们需要关注几个关键层以确保我们的应用程序顺利运行：
- en: First up is the **UI layer**. This is what the customers see when they’re browsing
    on their phones or computers. It displays the products and lets them add stuff
    to their carts and checkout. It takes the user input and sends it to the next
    layer.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是 **UI 层**。这是当客户在手机或电脑上浏览时看到的。它显示产品，并允许他们添加商品到购物车并结账。它接收用户输入并将其发送到下一层。
- en: The next layer is the **application layer**. Now this layer doesn’t have any
    actual business logic, it just guides the user through the UI process and talks
    to other systems. It organizes all the objects and makes sure the tasks get done
    in the right order.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个层是 **应用层**。现在这一层没有实际的业务逻辑，它只是引导用户通过 UI 流程并与其他系统进行通信。它组织所有对象并确保任务以正确的顺序完成。
- en: Now we get to the **domain layer**, which is like the heart and soul of the
    whole operation. This layer has all the core concepts that make the business tick.
    It has things such as users, products, orders – basically anything related to
    the main functions of the app. Each entity has its own unique ID so it can be
    tracked no matter what else changes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们来到 **领域层**，这是整个操作的灵魂和核心。这一层拥有使业务运转的核心概念。它包括用户、产品、订单等与应用程序主要功能相关的一切。每个实体都有自己的唯一标识符，这样无论其他什么发生变化，都可以追踪。
- en: The services here also have predefined behaviors that everyone understands.
    The domain layer stands on its own and doesn’t rely on the other layers, but they
    can all depend on the domain layer since it’s got all the important business rules
    locked down.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的服务也有预定义的行为，每个人都能够理解。领域层独立存在，不依赖于其他层，但它们都可以依赖于领域层，因为领域层已经锁定了所有重要的业务规则。
- en: Finally, we’ve got the **infrastructure layer**. This layer facilitates the
    communication between all the other layers. It also provides things such as libraries
    to help the UI work smoothly. But it doesn’t actually have any business logic
    – it just supports the technical functions behind the scenes.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们还有**基础设施层**。这一层促进了所有其他层之间的通信。它还提供诸如库之类的工具，以帮助UI顺利工作。但事实上，它没有任何业务逻辑——它只是支持幕后技术功能。
- en: So, in summary – the UI layer talks to users, the application layer manages
    tasks, the domain layer handles the core business functions, and the infrastructure
    layer helps them all work together seamlessly. Make sure each layer stays focused
    on your app architecture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说——UI层与用户交流，应用层管理任务，领域层处理核心业务功能，基础设施层帮助它们无缝协作。确保每一层都专注于你的应用架构。
- en: '*Figure 2**.2* helps you understand the relationship between different layers
    visually:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2*帮助你从视觉上理解不同层之间的关系：'
- en: '![Figure 2.2: Relationship between the DDD layers](img/B18400_02_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：DDD层之间的关系](img/B18400_02_02.jpg)'
- en: 'Figure 2.2: Relationship between the DDD layers'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：DDD层之间的关系
- en: We’re now going to go through an example by following the DDD structure to make
    it clear and picturesque in our mind – we’re going to break down microservices
    using a real-world example of an online store.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过遵循DDD结构来通过一个示例来了解它，使其在我们心中清晰易懂——我们将通过一个在线商店的真实世界示例来分解微服务。
- en: 'We all know shopping online is huge these days, so let me walk through how
    an e-commerce site could be structured using a domain-driven design:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道现在网上购物非常流行，所以让我来介绍一下如何使用领域驱动设计来构建一个电子商务网站：
- en: First up, you’ve got to have a **User Service**. This handles all the account
    details – logging in, profiles, addresses, payment information, and all related
    details.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要有一个**用户服务**。这个服务处理所有账户详情——登录、个人资料、地址、支付信息以及所有相关细节。
- en: Next is the **Product Service**. This one is in charge of the product catalog
    – keeping track of inventory levels, product details, descriptions – all the information
    about the items you can buy.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**产品服务**。这个服务负责产品目录——跟踪库存水平、产品详情、描述——你可以购买的所有物品的信息。
- en: Then we have the **Order Service**. As you can probably guess, this one creates
    orders when people checkout. It also processes payments using different methods
    such as credit cards or PayPal. And of course, it ships out orders to customers.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们有**订单服务**。正如你可能猜到的，这个服务在人们结账时创建订单。它还使用不同的方式处理支付，例如信用卡或PayPal。当然，它还会将订单发送给客户。
- en: After that is the **Payment Service**. Now this one specifically focuses on
    processing payments from different sources such as Visa, Mastercard, or digital
    wallets. It interacts with the payment gateways.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**支付服务**。现在这个服务专门关注处理来自不同来源的支付，例如Visa、Mastercard或数字钱包。它与支付网关进行交互。
- en: The **Review Service** manages all the reviews, ratings, and feedback left by
    customers – people should be able to see what others think of a product before
    buying, right?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评论服务**管理所有客户留下的评论、评分和反馈——人们在购买之前应该能看到其他人对这个产品的看法，对吧？'
- en: And finally, we have the **Notification Service**. This one sends out emails
    or push notifications to let customers know about their orders, sales, new products
    – you name it – keeping everyone in the loop!
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有**通知服务**。这个服务会发送电子邮件或推送通知，让客户了解他们的订单、销售、新产品——你叫什么名字——让每个人都能跟上进度！
- en: '*Figure 2**.3* illustrates these microservices following the DDD approach:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3*展示了按照DDD方法这些微服务：'
- en: '![Figure 2.3: The services of the project in DDD structure](img/B18400_02_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：项目在DDD结构中的服务](img/B18400_02_03.jpg)'
- en: 'Figure 2.3: The services of the project in DDD structure'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：项目在DDD结构中的服务
- en: So, in summary, these are the main microservices an online store might use following
    a DDD approach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，这些是按照DDD方法可能使用的在线商店的主要微服务。
- en: We have a good understanding of a DDD approach now. We segregate the microservices
    per business domain. Next, we will explore CQRS – as you can understand from its
    name, we will again be segregating microservices, but in a different way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对DDD方法有了很好的理解。我们按业务领域划分微服务。接下来，我们将探索CQRS——正如你可以从其名称中理解的那样，我们再次将微服务划分，但方式不同。
- en: Learning about CQRS
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解CQRS
- en: In this section, we’re going to talk about CQRS, which is an awesome software
    architecture pattern! CQRS is based on separating the responsibilities of the
    commands and queries in a system. This means we slice our application logic vertically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论CQRS，这是一个出色的软件架构模式！CQRS基于在系统中分离命令和查询的责任。这意味着我们垂直切割我们的应用程序逻辑。
- en: By dividing commands and queries, our system becomes greatly efficient. Commands
    focus on data changes without worrying about queries. Queries focus only on reading
    data without impacting commands. Each part of the system optimizes itself, for
    its single purpose. It’s like dividing and conquering to make everything faster!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离命令和查询，我们的系统变得非常高效。命令专注于数据变更，而不必担心查询。查询只关注读取数据，而不影响命令。系统的每个部分都针对其单一目的进行优化。这就像分割并征服，使一切更快！
- en: In this section, we will discuss the context of CQRS with its cons and pros.
    Later on, we will see a real-world scenario and how CQRS help to solve real problems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论CQRS的背景，包括其优点和缺点。稍后，我们将看到一个真实场景以及CQRS如何帮助解决实际问题。
- en: What is the context of CQRS?
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS的背景是什么？
- en: You may be thinking, *“Why should I care about CQRS?”* The simple answer is
    efficiency and simplicity. We can easily optimize each part separately when we
    split the app into command and query parts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“我为什么要关心CQRS？”简单的答案是效率和简单性。当我们把应用程序分成命令和查询部分时，我们可以轻松地分别优化每一部分。
- en: 'Let’s talk about these two main components:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈这两个主要组件：
- en: The command side is all about actions – creating, updating, and deleting data.
    As we can see, these are the ‘do-er’ operations of our application.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令端全部关于动作——创建、更新和删除数据。正如我们所见，这些都是我们应用程序的“执行者”操作。
- en: On the other side, the query side is the ‘viewer’ or ‘reader’. It fetches the
    data, but doesn’t make any changes to the state of the data.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，查询端是“查看者”或“读者”。它获取数据，但不改变数据的状态。
- en: So, with such a clear separation, you can see how easy it is to optimize and
    scale commands and queries according to their needs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这样的清晰分离，你可以看到根据它们的需求优化和扩展命令和查询是多么容易。
- en: However, we must remember that CQRS isn’t a one-size-fits-all solution. If all
    other architecture designs of our system have unbalanced command and query operations,
    then we should choose this design. Otherwise, it will increase the complexity
    of our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须记住，CQRS并不是万能的解决方案。如果我们的系统中的其他所有架构设计都有不平衡的命令和查询操作，那么我们应该选择这种设计。否则，它将增加我们应用程序的复杂性。
- en: To wrap it up, CQRS is all about dividing your application into two parts –
    one for commands (doing) and one for queries (viewing). This separation can lead
    to more efficient, maintainable, and scalable applications. But remember, evaluating
    whether CQRS fits your project’s needs is crucial. And now in the next section,
    we will see the best practices and common mistakes when we implement CQRS in our
    solution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CQRS全部关于将你的应用程序分成两部分——一部分用于命令（执行）和另一部分用于查询（查看）。这种分离可以导致更高效、可维护和可扩展的应用程序。但请记住，评估CQRS是否符合你项目的需求是至关重要的。现在，在下一节中，我们将看到在解决方案中实施CQRS时的最佳实践和常见错误。
- en: What are best practices and common pitfalls?
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践和常见陷阱是什么？
- en: As all other architecture design patterns, there are some best practices to
    follow up and some common mistakes we need to consider while we are implementing
    this architecture design.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他架构设计模式一样，在实施此架构设计时，我们需要遵循一些最佳实践，并考虑一些常见的错误。
- en: 'Let’s start with best practices:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最佳实践开始：
- en: '**Start simple**: Begin with a plain approach. You don’t need to split every
    piece of your application into commands and queries from the beginning. You are
    still in the microservices realm and can determine each service’s needs individually.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从简单开始**：从简单的方法开始。你不需要一开始就把你应用程序的每一部分都分成命令和查询。你仍然处于微服务领域，并且可以单独确定每个服务的需求。'
- en: '**Keep communication clear**: Ensure the communication between the command
    and query sides is well defined. This relates to the next item because if you
    design your database well, you can build clear communication between the command
    and query sides.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持沟通清晰**：确保命令和查询端之间的沟通定义良好。这与下一项有关，因为如果你设计好数据库，你可以在命令和查询端之间建立清晰的沟通。'
- en: '**Optimize database design**: Design your database to suit the split nature
    of CQRS. Please consider this design carefully, this is not just creating a table
    – in this database design, one side of the code inserts data, and the other side
    of the code will view it. You need to pay attention to this database design more
    than other design patterns.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化数据库设计**：设计数据库以适应CQRS的分割特性。请仔细考虑这个设计，这不仅仅是创建一个表——在这个数据库设计中，代码的一侧插入数据，另一侧代码将查看它。你需要比其他设计模式更加关注这个数据库设计。'
- en: '**Regularly test and refine**: Continuously test and refine your implementation.
    This is an inevitable step for all implementations. You can only be comfortable
    with our designs if we test them.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期测试和改进**：持续测试和改进你的实现。这是所有实现不可避免的一步。只有当我们测试了它们，我们才能对我们的设计感到舒适。'
- en: 'While implementing CQRS, there are some mistakes we want to avoid:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施CQRS时，有一些错误是我们想要避免的：
- en: '**Overcomplication**: You need to be sure that your system is manageable and
    is doing what it needs to do, nothing more, nothing less.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度复杂化**：你需要确保你的系统是可管理的，并且正在做它需要做的事情，不多也不少。'
- en: '**Misjudging the scale**: Implementing CQRS in a system that doesn’t really
    need it is like using an 18-wheeler to drive to the grocery store. You must be
    very careful while assessing whether your application truly benefits from CQRS.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误判规模**：在一个实际上并不需要CQRS的系统中实施CQRS就像用18轮卡车去杂货店一样。在评估你的应用程序是否真正从CQRS中受益时，你必须非常小心。'
- en: '**Ignoring business logic separation**: You must keep our command and query
    responsibilities strictly separate. You need to keep checking this for each pull
    request we create and each code review you do, because if it gets mixed up, the
    application may soon become garbage.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽视业务逻辑分离**：你必须严格区分我们的命令和查询责任。你需要检查我们创建的每个pull request和每次代码审查，因为如果它们被混淆，应用程序可能会很快变成垃圾。'
- en: '**Underestimating the learning curve**: You must recognize that CQRS requires
    a learning curve for your team. You need learning tools for new joiners to touch
    base with them on our system.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低估学习曲线**：你必须认识到CQRS对你的团队来说需要一段学习曲线。你需要学习工具，让新加入的人能够了解我们的系统。'
- en: By following these best practices and avoiding common pitfalls, you can make
    your CQRS implementation successful. It’s about finding that sweet spot for making
    your system efficient without overcomplicating it. Remember, the goal is to create
    a system that’s as smooth and efficient as a well-tuned car, ready to take you
    wherever you need to go.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践并避免常见陷阱，你可以使你的CQRS实现成功。这关乎找到那个甜蜜点，使你的系统既高效又不过度复杂化。记住，目标是创建一个像经过精心调校的汽车一样平滑高效的系统，随时准备带你去你需要去的地方。
- en: What are the benefits of the CQRS design pattern?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS设计模式的优点是什么？
- en: 'With CQRS, you get some totally awesome features including the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CQRS，你将获得一些非常棒的功能，包括以下内容：
- en: '**Independent scaling** – CQRS allows the read and write workloads to scale
    separately, which means fewer slowdowns.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立扩展** – CQRS允许读取和写入工作负载分别扩展，这意味着更少的减速。'
- en: '**Optimized schemas** – The read side can have a schema perfectly optimized
    for querying, while the write side focuses on updates. With CQRS, you can scale
    the command side (write operations) by adding more instances or resources dedicated
    to handling these commands without necessarily increasing the load on the query
    side querying, while the write side focuses on updates.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化模式** – 读取端可以有一个针对查询完美优化的模式，而写入端则专注于更新。使用CQRS，你可以通过添加更多实例或资源来扩展命令端（写入操作），而不必增加查询端的负载，同时写入端专注于更新。'
- en: '**Security** – It’s way easier to make sure only the right people are making
    writes to the data.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性** – 确保只有正确的人对数据进行写入要容易得多。'
- en: '**Separation of concerns** – Splitting read and write means models that are
    so much easier to maintain and adapt. Most complex business logic goes in the
    write model, while reading is simple and sweet.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离** – 分割读取和写入意味着模型更容易维护和适应。大多数复杂业务逻辑都放在写入模型中，而读取则是简单而甜蜜的。'
- en: Using these patterns together maximizes performance at the cost of more complex
    implementation. But it ensures your domain model and data are adaptable to any
    future changes!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些模式结合起来，在增加复杂实现成本的同时最大化性能。但它确保你的领域模型和数据能够适应任何未来的变化！
- en: Up to now, we have learned about CQRS, its benefits, best practices, and common
    pitfalls. But CQRS has a twin brother, and they are mostly used together – namely,
    Event Sourcing. In the next section, we will learn about the core concepts of
    Event Sourcing and how they work together with CQRS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了CQRS，它的好处、最佳实践和常见陷阱。但CQRS有一个孪生兄弟，它们通常一起使用——即事件溯源。在下一节中，我们将学习事件溯源的核心概念以及它是如何与CQRS协同工作的。
- en: Understanding Event Sourcing
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件溯源
- en: In this section, we’re going to talk about Event Sourcing. We will also examine
    **Event-Driven Architecture** (**EDA**) and will break down the differences between
    EDA and Event Sourcing. Additionally, we mentioned CQRS previously, but in this
    section we will learn where CQRS fits into the whole picture, and I’ll explain
    it all in a way that’s easy to understand.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论事件溯源。我们还将检查**事件驱动架构**（**EDA**），并分析EDA与事件溯源之间的区别。此外，我们之前提到了CQRS，但在这个章节中，我们将学习CQRS在整个架构中的位置，我将用简单易懂的方式解释这一切。
- en: Event-Driven Architecture
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: In this section, we’re going to break down some key concepts in EDA. *Figure
    2**.4* shows some basic examples of events and commands in this architecture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分解EDA中的几个关键概念。*图2*.*4*展示了该架构中事件和命令的一些基本示例。
- en: '![Figure 2.4: Examples of events and commands](img/B18400_02_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：事件和命令的示例](img/B18400_02_04.jpg)'
- en: 'Figure 2.4: Examples of events and commands'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：事件和命令的示例
- en: First up, we have **events**. Events are basically things that happen – such
    as a user logging in, or an order being placed. Then we have **commands**. Commands
    are like orders or requests, telling something else to do something.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有**事件**。事件基本上是发生的事情——例如用户登录或订单被下。然后我们有**命令**。命令就像订单或请求，告诉其他事物去做某事。
- en: Events can be communicated as event notifications, and commands as messages.
    These are pretty similar – they both contain information. Sometimes an event notification
    is called a message too. In practice, people often just call both events. But
    technically, an event is something that happens, not a notification about it.
    Events are different from commands, which are more about intention. But for this
    section, we’ll just call them events to keep it simple. These events can have
    data about what happened, or just be a notification. And they’re immutable, meaning
    they can’t be changed once created. EDA is based around these events. There’s
    some debate about whether it’s just events or includes other messages too. But
    for now, just focus on the events flowing through the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以以事件通知的形式进行通信，命令以消息的形式。它们非常相似——它们都包含信息。有时事件通知也被称为消息。在实践中，人们通常只称它们为事件。但从技术上讲，事件是发生的事情，而不是关于它的通知。事件与命令不同，命令更多地关于意图。但在这个章节中，我们将简单地称它们为事件以保持简单。这些事件可以包含关于发生的事情的数据，或者只是通知。它们是不可变的，这意味着一旦创建就不能更改。EDA围绕这些事件展开。关于它是否只是事件或包括其他消息也存在一些争议。但到目前为止，只需关注通过系统流动的事件即可。
- en: 'Okay, so in EDA, there are usually three main **components**, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以在EDA中，通常有三个主要**组件**，如上图所示：
- en: '![Figure 2.5: EDA components](img/B18400_02_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：EDA组件](img/B18400_02_05.jpg)'
- en: 'Figure 2.5: EDA components'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：EDA组件
- en: First, the **producer** creates the events. Then the **broker** redirects events
    to the right **consumers**, and consumers react to events and take action accordingly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**生产者**创建事件。然后**代理**将事件重定向到正确的**消费者**，消费者根据事件采取相应的行动。
- en: What is Event Sourcing?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是事件溯源？
- en: In this section, we will talk about Event Sourcing and how it can be useful
    for tracking changes in your apps. Basically, instead of just saving the final
    state, you can record every single change that happens as an event. These events
    get stored in something called an **event log**, which keeps them in order so
    you can see the full history. By reading through the event log from start to finish,
    you can literally rebuild the entire state of your app! This is what people call
    **event sourcing**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论事件溯源以及它如何有助于跟踪应用程序中的更改。基本上，除了保存最终状态外，您还可以将每个发生的变化记录为事件。这些事件存储在称为**事件日志**的东西中，它们按顺序排列，以便您可以查看完整的历史记录。通过从头到尾阅读事件日志，您可以实际上重建应用程序的整个状态！这就是人们所说的**事件溯源**。
- en: Let’s now go through an example event log schema and then talk a bit about one
    of the main features of Event Sourcing – parallel processing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过一个示例事件日志架构，然后简要谈谈事件溯源的主要功能之一——并行处理。
- en: Example of event log schema
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件日志模式示例
- en: Let’s take the example of an e-commerce store again. Say you want to keep track
    of inventory levels for all your products. Well, you could have a `ProductAdded`
    event that stores the product ID and how many products were added whenever you
    stock up. And when someone buys something, you’d log a `ProductPurchased` event
    with the ID and amount. By replaying all these events in order, you can always
    know the current inventory levels no matter what. Event sourcing is super useful
    for anything where you need the full audit trail of all changes over time. This
    is definitely something worth checking out if you want your apps to have that
    kind of historical data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以电子商务商店为例。假设您想跟踪所有产品的库存水平。嗯，您可以有`ProductAdded`事件，该事件存储产品ID和每次补货时添加了多少产品。当有人购买东西时，您会记录一个带有ID和数量的`ProductPurchased`事件。通过按顺序重新播放所有这些事件，您可以始终知道当前的库存水平，无论发生什么。事件溯源对于需要随时间变化的全部变更审计跟踪的任何事物都非常有用。如果您希望您的应用具有那种类型的历史数据，这绝对值得一试。
- en: '*Figure 2**.6* shows how the events log orders the inventory.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6*展示了事件日志如何排序库存。'
- en: '![Figure 2.6: Event log – detailed example](img/B18400_02_06.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：事件日志——详细示例](img/B18400_02_06.jpg)'
- en: 'Figure 2.6: Event log – detailed example'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：事件日志——详细示例
- en: Now let me break this down for you real quick. First, we add some products to
    our inventory – let’s say we add 10 products. Later on, some customers start buying
    those products. We get a purchase event for one product, then another purchase
    event for another product. Now here’s the cool part – we can look at our event
    log at any time and figure out what our current inventory is! We know we started
    with 10 products. Then we had two purchase events, so that means we must have
    eight products left now.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我快速为您分解一下。首先，我们在我们的库存中添加一些产品——比如说我们添加了10个产品。后来，一些客户开始购买这些产品。我们得到了一个关于一个产品的购买事件，然后又得到了另一个关于另一个产品的购买事件。现在这里有个有趣的部分——我们可以在任何时间查看我们的事件日志，并找出我们当前的库存是什么！我们知道我们开始时有10个产品。然后我们有两个购买事件，这意味着我们现在必须有8个产品了。
- en: The key thing about Event Sourcing is that we can reset our inventory to zero
    at any time. We can delete how many products we have. But as long as we have that
    event log, we can always go back and recalculate how many products we should have
    based on all the events!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的关键之处在于我们可以在任何时候将库存重置为零。我们可以删除我们有多少产品。但只要我们有那个事件日志，我们就可以随时回去重新计算我们应该有多少产品，基于所有的事件！
- en: So, in summary, Event Sourcing uses an event log to keep track of everything
    that happens, so you can always go back in time and see what your data looked
    like at any point and check the previous states of your data. For example, let’s
    say on day 1 you added 10 products to your inventory. On day 2, someone bought
    one product. And on day 3, someone else grabbed another product. With Event Sourcing,
    you can look back and see exactly what your inventory looked like on day 2 or
    even day 1\. This is super useful for debugging or replicating your data somewhere
    else. All you have to do is replay the log of events – there’s no need to manually
    set everything up from scratch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，事件溯源使用事件日志来跟踪所有发生的事情，这样您就可以随时回到过去，查看数据在任何时刻的样子，并检查数据的先前状态。例如，假设在第一天您向库存中添加了10个产品。第二天，有人购买了一个产品。第三天，另一个人又购买了一个产品。使用事件溯源，您可以回顾并确切地看到第二天或甚至第一天库存的样子。这对于调试或在其他地方复制数据非常有用。您所要做的就是重新播放事件日志——无需手动从头开始设置一切。
- en: Parallel processing
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行处理
- en: Parallel processing is a super useful feature of Event Sourcing when you have
    multiple apps or services reading from the same data source. Instead of each app
    having to wait their turn to read stuff, they can all read at the same time in
    parallel. This is perfect if you have way more readers than writers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理是事件溯源的一个非常有用的功能，当您有多个应用或服务从相同的数据源读取时。而不是每个应用都必须等待它们的轮次来读取东西，它们可以并行地同时读取。如果您有远多于写入者的读取者，这非常完美。
- en: 'Let’s say you have an event log that tracks everything happening in your system.
    Instead of one app reading the log and then the next, they can all read simultaneously,
    as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个跟踪您系统中所有发生的事件的日志。而不是一个应用读取日志然后下一个应用读取，它们可以同时读取，如下所示：
- en: '![Figure 2.7: Parallel processing feature](img/B18400_02_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：并行处理功能](img/B18400_02_07.jpg)'
- en: 'Figure 2.7: Parallel processing feature'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：并行处理功能
- en: As long as the data in the log doesn’t change, you can have tons of parallel
    reading, no problem. This comes in super clutch because it means each app can
    independently grab what it needs from the log and do its own process without getting
    in the way of the others. They can process in parallel. As long as the log only
    ever adds new events and doesn’t modify old ones, everything stays consistent.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只要日志中的数据不发生变化，就可以进行大量的并行读取，没有问题。这非常关键，因为它意味着每个应用程序都可以独立地从日志中获取它所需的内容，并执行自己的处理，而不会干扰其他应用程序。它们可以并行处理。只要日志只添加新事件而不修改旧事件，一切都会保持一致。
- en: So, parallel reading is a great way to maximize your throughput and take full
    advantage of all your resources.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，并行读取是最大化吞吐量和充分利用所有资源的一种很好的方法。
- en: Differences between Event-Driven Architecture and Event Sourcing
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构和 Event Sourcing 之间的区别
- en: EDA is all about components communicating through events. When something important
    happens in the system, it emits an event. Other components can then **subscribe**
    to those events and react accordingly. This loose coupling makes EDA great for
    scalability and real-time responsiveness. You see it a lot in microservices, messaging
    systems, and IoT apps.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: EDA 是关于组件通过事件进行通信的。当系统中发生重要事件时，它会发出一个事件。其他组件可以订阅这些事件并相应地做出反应。这种松散耦合使得 EDA 对于可扩展性和实时响应性非常出色。你在微服务、消息系统和物联网应用程序中经常看到它。
- en: With Event Sourcing, instead of just storing the current data state, it stores
    a log of all the events that changed the data over time. So, the current state
    is reconstructed by replaying all those past events. This is useful for auditing,
    having different versions, and analyzing historical data. Event Sourcing also
    works well with CQRS, which separates reading from writing. The write side stores
    events while the read side is optimized for queries.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Event Sourcing 中，除了存储当前数据状态外，它还存储了随时间变化而改变数据的所有事件的日志。因此，当前状态是通过重新播放所有这些过去的事件来重建的。这对于审计、拥有不同的版本和分析历史数据非常有用。Event
    Sourcing 还与 CQRS（将读取和写入分离）很好地协同工作。写入端存储事件，而读取端针对查询进行了优化。
- en: While both EDA and Event Sourcing involve events, they focus on different things.
    EDA is more about how components communicate through events. Event Sourcing is
    about persisting event logs to represent state changes over time to benefit from
    things including auditing and versions. You can have Event Sourcing as part of
    an event-driven system, but they each solve their own problems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 EDA 和 Event Sourcing 都涉及事件，但它们关注的重点不同。EDA 更多的是关于组件如何通过事件进行通信。Event Sourcing
    是关于将事件日志持久化以表示随时间变化的状态变化，从而受益于包括审计和版本在内的东西。你可以将 Event Sourcing 作为事件驱动系统的一部分，但它们各自解决自己的问题。
- en: A real-world example of the Event Sourcing pattern
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Event Sourcing 模式的真实世界示例
- en: In Event Sourcing, every single change is written down in order so that we can
    always look back and see how things changed with timelines. We will understand
    this better with a story about someone named Sarah and how she interacts with
    an online platform. Her activities, say putting up a status or adding contact
    details, are recorded as a series of events. Every event is part of a transaction
    and has a single sequence ID ensuring that every change is tracked to chronology.
    In our following example, every event is kept in **Java Script Object Notation**
    (**JSON**) format.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Event Sourcing 中，每一个变化都是按顺序记录下来的，这样我们就可以始终回顾并看到事物是如何随着时间线而变化的。我们可以通过一个名叫莎拉的人的故事来更好地理解这一点，以及她如何与一个在线平台互动。她的活动，比如发布状态或添加联系信息，都被记录为一系列事件。每个事件都是交易的一部分，并有一个唯一的序列
    ID，确保每个变化都能追踪到时间顺序。在我们的下一个示例中，每个事件都保持为 **JavaScript 对象表示法**（**JSON**）格式。
- en: 'Here is the list of events created by Sarah’s operation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是莎拉操作创建的事件列表：
- en: '**Event 1 – Account Creation** – The journey begins with Sarah creating her
    account:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件 1 – 账户创建** – 旅程始于莎拉创建她的账户：'
- en: '[PRE0]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Event 2 – Email Update** – Shortly after, Sarah updates her email address:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件 2 – 电子邮件更新** – 稍后，莎拉更新了她的电子邮件地址：'
- en: '[PRE1]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Event 3 – Add Mailing Address** – Sarah then adds a mailing address to her
    profile:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件 3 – 添加邮寄地址** – 然后，莎拉在她的个人资料中添加了一个邮寄地址：'
- en: '[PRE2]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Event 4 – Name Update** – Later, she decides to update her name on the profile:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件 4 – 更新姓名** – 之后，她决定更新个人资料中的姓名：'
- en: '[PRE3]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Event 5 – Phone Number Added** – Finally, Sarah adds her phone number:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件 5 – 添加电话号码** – 最后，莎拉添加了她的电话号码：'
- en: '[PRE4]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we process these events in the sequence in which they were recorded, we
    are able to reconstruct the current state of Sarah’s profile at any point in time.
    Every event is immutable so once an event is put to record, it cannot be changed.
    This account gives a very clear and comprehensive history of how Sarah’s profile
    has changed with time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按照事件记录的顺序处理这些事件时，我们能够重建 Sarah 的个人资料在任何时间点的当前状态。每个事件都是不可变的，所以一旦事件被记录，就不能更改。这个账户提供了关于
    Sarah 个人资料随时间变化的非常清晰和全面的历史记录。
- en: In conclusion, Event Sourcing presents a very strong framework for recording
    as well as managing changes to the states of systems. It excels in scenarios requiring
    detailed audit trails and historical data analysis. Event Sourcing logs every
    change as a distinct event, providing a powerful overview of data evolution, allowing
    the systems not only to present the current state but to revisit and analyze the
    past states. This, therefore, is an invaluable approach to complex systems where
    understanding the journey of data is as important as the system itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，事件溯源提供了一个非常强大的框架，用于记录和管理系统状态的变化。它在需要详细审计跟踪和历史数据分析的场景中表现出色。事件溯源将每个更改记录为一个独立的事件，提供了数据演化的强大概览，使系统不仅能够展示当前状态，还能够回顾和分析过去的状态。因此，这是一种对复杂系统非常有价值的方法，其中理解数据的旅程与系统本身一样重要。
- en: The relation of Event Sourcing with CQRS
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源与 CQRS 的关系
- en: We mentioned, at the beginning of *Event Sourcing* section, that we will discover
    how CQRS fits into the larger picture, so let’s now combine all of the concepts
    we learned in the previous sections. Alright! Basically, with CQRS, the way you
    write data is different from how you read it. In the past, you might have just
    used one database for everything. You could do operations such as inserting data
    and then get it right back out of the same place, and that works fine if you’re
    just doing basic create, read, update, and delete operations. But sometimes you
    might want to scale how much you can write versus read separately. Or maybe you
    need different views of the data for reading versus writing. That’s where CQRS
    comes in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *事件溯源* 部分的开头提到，我们将发现 CQRS 如何融入更大的图景，所以现在让我们结合在前几节中学到的所有概念。好的！基本上，在 CQRS
    中，你写入数据的方式与读取数据的方式不同。在过去，你可能只是使用一个数据库来处理所有事情。你可以执行诸如插入数据然后立即从同一位置获取数据等操作，如果你只是进行基本的创建、读取、更新和删除操作，这工作得很好。但有时你可能想分别扩展写入和读取的量。或者你可能需要为读取和写入提供不同的数据视图。这就是
    CQRS 发挥作用的地方。
- en: '*Figure 2**.8* shows how commands and queries interact with the database:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.8* 展示了命令和查询如何与数据库交互：'
- en: '![Figure 2.8: Representation of CQRS pattern](img/B18400_02_08.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：CQRS 模式的表示](img/B18400_02_08.jpg)'
- en: 'Figure 2.8: Representation of CQRS pattern'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：CQRS 模式的表示
- en: The basic idea is that you split up how you write data from how you query or
    get data out. So you could write to one database that’s optimized for the speed
    of inserts, and then have a separate database setup just for reading where you
    combine data from other services to give customized views of the information.
    Separating writing and reading gives you more flexibility to scale both independently
    based on your specific needs. It also lets you transform the data in different
    ways for different uses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的想法是，你将数据写入的方式与查询或获取数据的方式分开。因此，你可以写入一个针对插入速度优化的数据库，然后设置一个单独的数据库，专门用于读取，在那里你可以结合来自其他服务的多个数据源，以提供定制的信息视图。将写入和读取分开，使你能够根据具体需求独立扩展。它还允许你以不同的方式对数据进行转换，以适应不同的用途。
- en: So, let’s say we have a few services – we have a Payment service, Shipping service,
    and Order service. Each of these services is keeping track of what’s going on
    in their part of the process using an event log.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设我们有一些服务——我们有一个支付服务、运输服务和订单服务。每个服务都在使用事件日志跟踪其流程部分的情况。
- en: The Payment service knows what payments went through and which ones failed.
    The Shipping service knows where all the deliveries are at. The Order service
    has the full history of orders for each user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 支付服务知道哪些支付成功，哪些失败。运输服务知道所有交付的位置。订单服务拥有每个用户的完整订单历史。
- en: Now we want to make a page that shows a user all their past orders in one place.
    Well, to do that, our Orders review feature is going to use all three services
    to show all past orders in one place. It’s going to ask the Payment service for
    the payment information, the Shipping service for shipping statuses, and the Order
    service for the basic order details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要创建一个页面，让用户在一个地方查看他们所有的历史订单。嗯，为了做到这一点，我们的订单回顾功能将使用所有三个服务来在一个地方显示所有历史订单。它将向支付服务请求支付信息，向运输服务请求运输状态，以及向订单服务请求基本订单详情。
- en: '![Figure 2.9: Zoom in on the service side](img/B18400_02_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：放大服务端](img/B18400_02_09.jpg)'
- en: 'Figure 2.9: Zoom in on the service side'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：放大服务端
- en: Then it takes all that data and combines it into one nice clean page for the
    user to see the full story of their order history in one spot. Pretty cool how
    even though each service handles its own part independently using events, we can
    still tie them all together to give the user a unified view!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将所有这些数据合并成一个整洁的页面，让用户能够在一个地方看到他们订单历史的全貌。即使每个服务独立使用事件处理自己的部分，我们仍然可以将它们全部结合起来，为用户提供一个统一的视图！
- en: The main benefit of using CQRS is that it allows you to split the reads and
    the writes in different systems. This allows you to scale them independently.
    If you’re having more reads than writes, or the other way around, you can scale
    each of these parts independently. You can also have different logic – you can
    have additional processing when you write, or additional layers or capabilities
    when you’re reading. You can also get information from different systems.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CQRS的主要好处是它允许你在不同的系统中分离读取和写入。这允许你独立扩展它们。如果你有更多的读取而不是写入，或者相反，你可以独立扩展这些部分。你也可以有不同的逻辑——你可以在写入时进行额外的处理，或者在你读取时添加额外的层或功能。你也可以从不同的系统中获取信息。
- en: 'Finally, let’s take a look at how the Event Sourcing and CQRS patterns work
    together in the bigger picture:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看事件溯源和CQRS模式在更大图景中是如何协同工作的：
- en: '![Figure 2.10: Event Sourcing pattern with CQRS](img/B18400_02_10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：带有CQRS的事件溯源模式](img/B18400_02_10.jpg)'
- en: 'Figure 2.10: Event Sourcing pattern with CQRS'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：带有CQRS的事件溯源模式
- en: 'Let’s walk through together through this diagram:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起通过这个图表来了解一下：
- en: '**UI**: User Interface'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI**: 用户界面'
- en: First up, the UI is like the front desk of our office. This is where you, the
    user, go to interact. You can either give instructions (commands) or ask for information
    (queries).
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，用户界面就像我们办公室的前台。这是您，用户，进行交互的地方。您可以下达指令（命令）或请求信息（查询）。
- en: '**Command**: Getting things done'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**: 完成任务'
- en: Issuing commands through the UI is like sending off requests to get something
    done – maybe adding a new file or updating an existing one. This command is taken
    up by the system, does its magic, and updates our “write” database, where we keep
    track of all these changes.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过用户界面下达命令就像发送请求去完成某事——比如添加一个新文件或更新一个现有文件。这个命令被系统接收，执行其魔法，并更新我们的“写入”数据库，我们在那里跟踪所有这些变化。
- en: '**Query**: Asking for information'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**: 请求信息'
- en: Now if it is information you are interested in, that’s a query. It’s like asking
    someone at the office to pull out a file for you. This information is pulled from
    another database specially designed for reading purposes. It’s faster and cleaner,
    sort of like having a set of files ready for viewing each time.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果你感兴趣的是信息，那就是一个查询。这就像在办公室里请求某人帮你拿出一个文件。这个信息是从专门为读取目的设计的另一个数据库中提取的。它更快、更干净，有点像每次都准备好一套文件供查看。
- en: '**Event Sourcing**: Detailed record keeping'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件溯源**: 详细记录'
- en: And now, the interesting part. Rather than keeping only the latest update, in
    Event Sourcing, a detailed log of every single individual change is kept by the
    system – more like a diary entry for every single action. Each such action, adding
    or taking something away, is recorded as an event.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，到了有趣的部分。在事件溯源中，系统会保留每个单独变化的详细日志，而不是只保留最新的更新——更像是每个单独动作的日记条目。每个这样的动作，添加或移除某些东西，都被记录为一个事件。
- en: '**Event Store or Log**: The system’s memory'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储或日志**: 系统的记忆'
- en: The Log or Event Store is literally the memory of the system. It holds on to
    all these event records. If there ever were a need, one could scroll back through
    this log and see its full history of changes or even replay them to understand
    how the system got to its current state.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 日志或事件存储实际上是系统的记忆。它保存了所有这些事件记录。如果需要，可以滚动查看这个日志，查看其完整的历史变化，甚至可以回放它们来了解系统是如何到达当前状态的。
- en: '**Publishing Events**: Spreading the news'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布事件**：传播新闻'
- en: Upon successful processing of a command, the system doesn’t just update the
    database, but also broadcasts an event. It functions as an announcement shouting
    at the world what has just changed.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在成功处理命令后，系统不仅更新数据库，还广播一个事件。它就像是对全世界喊出刚刚发生了什么变化的公告。
- en: '**Event Handler or Bus**: The messenger'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理器或总线**：信使'
- en: The event bus or handler is no different than an office messenger. It captures
    the event and delivers the news to all relevant places so that the read database
    is updated with the latest information.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件总线或处理器与办公室信使没有区别。它捕获事件并将消息传递到所有相关的地方，以便读取数据库更新为最新信息。
- en: '**Database (Read)**: Optimized for quick access'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库（读取）**：优化快速访问'
- en: The read database is there to make access to information rapid and easy. It
    is different from the write database, and it’s set up to enable you to pull information
    swiftly and without hesitation.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 读取数据库的存在是为了使信息访问快速且容易。它与写入数据库不同，并且被设置成能够让您迅速且毫不犹豫地获取信息。
- en: '**Materialized View**: Information ready to go'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物化视图**：准备就绪的信息'
- en: Finally, we come with the materialized view. It’s a snapshot of the data essentially
    already prepared and optimized for your queries. Think of it as a summary report,
    ready at your fingertips.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们带来了物化视图。它是数据的快照，本质上已经准备并优化了您的查询。把它想象成一个总结报告，随时可用。
- en: '*Figure 2**.10* shows a smart and efficient system, where tasking is neatly
    divided among all the other resources that facilitate and manage the interrogations
    you make to that data warehouse *and* the actual data warehouse itself. On the
    one side, you have commands changing things and on the other side, you have queries
    getting information. And in Event Sourcing, there’s a complete history of every
    change. It’s like running a smooth, highly efficient, organized, and transparent
    company office workflow where nothing is misplaced or lost in the process.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.10* 展示了一个智能且高效的系统，其中任务被巧妙地分配给所有其他便于管理和执行对数据仓库查询以及数据仓库本身的资源。在一侧，您有改变事物的命令，在另一侧，您有获取信息的查询。在事件源中，每个变化的完整历史都有记录。它就像是一个运行顺畅、高效、有组织且透明的公司办公室工作流程，在这个过程中没有任何东西被放置不当或丢失。'
- en: A real-world example of CQRS with Event Sourcing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源模式下的CQRS的真实世界示例
- en: In this section, I’m going to provide a real-world example diagram of a banking
    system using CQRS with Event Sourcing. We’re going to focus on the bank account
    side. Take, for instance, a bank that has to do with opening accounts, depositing
    money, processing transactions, and closing accounts. To execute these tasks adequately,
    the bank puts into practice a system based on CQRS combined with Event Sourcing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将提供一个使用CQRS和事件源的真实世界银行系统示例图。我们将关注银行账户方面。以一个涉及开设账户、存钱、处理交易和关闭账户的银行为例。为了充分执行这些任务，银行实施了一个基于CQRS和事件源的系统。
- en: 'The following diagram shows how the system works:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了系统的工作方式：
- en: '![Figure 2.11: Banking example using the CQRS pattern with Event Sourcing](img/B18400_02_11.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11：使用事件源模式的CQRS模式的银行示例](img/B18400_02_11.jpg)'
- en: 'Figure 2.11: Banking example using the CQRS pattern with Event Sourcing'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：使用事件源模式的CQRS模式的银行示例
- en: 'Let’s break down this diagram in simple terms:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用简单的话来分解这个图：
- en: '`OpenAccountCommand` is like walking into the bank and saying, *“I want to
    open a new account.”* These commands are part of the **Bank Account Command API**,
    which is just some fancy way of saying that this system understands and handles
    what you ask your bank to do.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenAccountCommand`就像走进银行并说，“我想开设一个新账户。”这些命令是**银行账户命令API**的一部分，这只是说这个系统理解并处理您要求银行做的事情的一种花哨的说法。'
- en: '**Command Handler**: This could be considered as the bank employees who take
    your request and initiate the process. The handler ensures all steps necessary
    for your command are taken.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令处理器**：这可以被认为是银行员工，他们接受您的请求并启动流程。处理器确保执行您命令所需的所有步骤。'
- en: '**EventStore**: Everything that a user does (such as opening an account) gets
    stored as an *event* in a special database called the *EventStore*. It’s like
    a meticulous diary of everything that happens.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储**：用户所做的每一件事（例如开设账户）都会以*事件*的形式存储在一个称为*事件存储*的特殊数据库中。它就像一本详尽的日记，记录了所有发生的事情。'
- en: '**Event Publisher**: This is a loudspeaker in the bank, which tells everyone
    what has just happened. For example, when you open an account, then the event
    publisher goes and tells the whole system, *“Hey, a new account* *was opened!”*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件发布者**：这是银行中的一个扩音器，它会告诉每个人刚刚发生了什么。例如，当你开设账户时，事件发布者就会告诉整个系统，“嘿，一个新的账户*被开设了！”*'
- en: '**Apache Kafka Message Queue Broker**: Apache Kafka is like the mail system
    at a bank that makes sure messages (events) go to the right department. It’s really
    efficient and even if the bank’s super busy, every single message gets through.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Kafka消息队列代理**：Apache Kafka就像银行的邮件系统，确保消息（事件）被发送到正确的部门。它非常高效，即使银行非常繁忙，每一条消息都能被传递。'
- en: '**Event Consumer**: This component of the system is a listener. It listens
    for any announcements (events) that are pertinent to it.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件消费者**：这个系统组件是一个监听器。它监听任何与之相关的公告（事件）。'
- en: '**Event Handler**: If the event consumer is like the employee listening for
    an announcement, then the event handler is the actual employee that takes that
    information and updates the bank’s records accordingly.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理器**：如果事件消费者就像是在听公告的员工，那么事件处理器就是那个实际接收信息并相应更新银行记录的员工。'
- en: '`FindAllAccountsQueries`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindAllAccountsQueries`。'
- en: '**Query Handler**: This is much the same as the customer service representative
    that accepts your query and looks up the information for you.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询处理器**：这与接受你的查询并为你查找信息的客户服务代表非常相似。'
- en: '**Read Database**: This is a separate database where the bank holds information
    that can be read – for example, your account balance, or even a list of all the
    accounts. It is organized such that any form of information can be reached easily
    and quickly.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取数据库**：这是一个独立的数据库，银行在这里保存可以读取的信息——例如，你的账户余额，甚至所有账户的列表。它组织得很好，任何形式的信息都可以轻松快速地获取。'
- en: The preceding diagram essentially just details two different processes in the
    bank’s system – one for doing things (for example, the process of opening an account)
    and another for querying things (such as how much money you have in your account).
    They work together but are separate, making the whole bank system run smoothly
    and efficiently. The “doing” part records whatever happens as events and remembers
    everything, while the “asking” part uses a simplified database in order to give
    you quick answers to your questions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表基本上只是详细说明了银行系统中两个不同的过程——一个是执行事务（例如，开设账户的过程）另一个是查询事务（例如，查询你账户中的金额）。它们协同工作但又是独立的，使得整个银行系统运行得既顺畅又高效。执行部分将发生的一切记录为事件并记住所有信息，而查询部分则使用简化的数据库来快速回答你的问题。
- en: Up to now, we have learned about some commonly used architecture designs that
    are used in microservice architecture. In the next section, we will briefly discuss
    some other architectural designs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了一些在微服务架构中常用的架构设计。在下一节中，我们将简要讨论一些其他架构设计。
- en: Brief overview of other architectural patterns
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他架构模式的简要概述
- en: In this section, we’re going to mention some additional architectural patterns.
    Using patterns is helpful because it makes your development way more efficient
    and productive. It also helps optimize costs and improve planning – basically,
    it just makes everything easier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提到一些额外的架构模式。使用模式有助于提高开发效率和生产率。它还有助于优化成本和提高规划——基本上，它使一切变得更简单。
- en: There are tons of different enterprise patterns you can check out. To help you
    pick the right ones for your project, I have rounded up summaries of a few of
    them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的企业模式可供选择。为了帮助您为项目选择正确的模式，我已经汇总了一些模式的摘要。
- en: Service Oriented Architecture (SOA) design pattern
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务的架构（SOA）设计模式
- en: Service-oriented design patterns are kind of like building with LEGO blocks
    for software. You break the whole program down into smaller reusable pieces called
    **services**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构模式有点像用乐高积木构建软件。你将整个程序分解成更小的可重用组件，称为**服务**。
- en: Each service has its own specific job to do. It can work on its own without
    needing the whole program. But these services talk to each other to get everything
    done together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都有自己的特定任务。它可以独立工作，不需要整个程序。但这些服务会互相交流，以完成所有工作。
- en: It’s kind of like if you had a big project and broke it into parts for different
    people. Each person focuses just on their part without worrying what the others
    are doing. Then it all comes together in the end.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像如果你有一个大项目，然后把它分成不同的部分供不同的人处理。每个人只关注他们自己的部分，而不担心其他人正在做什么。最后，所有部分都会汇集在一起。
- en: This makes the software more flexible and easier to change later. Just as with
    LEGO blocks, you can use the same pieces to build lots of different things without
    always starting from scratch. It’s easier to swap things in and out.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得软件更加灵活，并且以后更容易更改。就像乐高积木一样，你可以使用相同的部件来构建很多不同的东西，而不必总是从头开始。交换东西更容易。
- en: 'In *Figure 2**.12*, we can see the general design of SOA:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 2.12*中，我们可以看到 SOA 的一般设计：
- en: '![Figure 2.12: Example of the SOA design pattern](img/B18400_02_12.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12：SOA 设计模式的示例](img/B18400_02_12.jpg)'
- en: 'Figure 2.12: Example of the SOA design pattern'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：SOA 设计模式的示例
- en: As we can see, there is an **Event Service Bus** (**ESB**) in between the services
    and the users. It delegates the tasks among the services. There is a **Shared**
    layer between the services and database systems. Through this layer, all services
    can reach all the data they need, even data that wasn’t created by that given
    service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在服务和用户之间有一个**事件服务总线（ESB**）。它将任务在服务之间进行委派。在服务和数据库系统之间有一个**共享**层。通过这一层，所有服务都可以访问它们所需的所有数据，即使这些数据不是由该服务创建的。
- en: So in summary, this pattern breaks programs into smaller communicating services,
    much like breaking projects into parts or building with reusable blocks. It makes
    software simpler to work with as it changes over time.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，这个模式将程序分解成更小的通信服务，就像将项目分解成部分或使用可重复使用的积木来构建一样。随着时间的推移，这使得软件更容易使用。
- en: The Circuit Breaker pattern
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路断路器模式
- en: The Circuit Breaker pattern is all about building software that can handle problems
    without crashing. Circuit breakers in code work similarly to those in electrical
    circuits. A lot of programs these days rely on lots of different parts all working
    together over a network, right? But sometimes one of those parts can crash. With
    the Circuit Breaker pattern, your program is constantly checking that the different
    pieces are communicating okay. If it notices the same part is erroring out over
    and over, it will temporarily block any more requests to that part. This keeps
    the whole system from getting overwhelmed by one small glitch. Instead of everything
    grinding to a halt, the program can keep chugging along while that problem part
    gets its act together. Pretty handy for creating software that bends but doesn’t
    break!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式完全是关于构建能够处理问题而不会崩溃的软件。代码中的断路器与电路中的断路器工作方式相似。如今，许多程序都依赖于许多不同的部分在网络中协同工作，对吧？但有时其中一个部分可能会崩溃。使用电路断路器模式，你的程序会持续检查不同的部分是否正在正常通信。如果它注意到同一个部分反复出现错误，它将暂时阻止对该部分的任何更多请求。这可以防止整个系统因为一个小故障而超负荷运行。而不是让一切停滞不前，程序可以在那个问题部分整理好之前继续运行。对于创建既能弯曲又不会断裂的软件来说，这非常方便！
- en: In order to understand this pattern better, see *Figure 2**.13:*
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个模式，请参阅*图 2.13*：
- en: '![Figure 2.13: Example of the Circuit Breaker pattern](img/B18400_02_13.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13：电路断路器模式的示例](img/B18400_02_13.jpg)'
- en: 'Figure 2.13: Example of the Circuit Breaker pattern'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：电路断路器模式的示例
- en: In the Circuit Breaker pattern, as shown in our diagram, **Service A** is the
    main one responsible for dealing with users’ requests and has some critical internal
    components such **Health Checker** and **Request Processor** looking after the
    system healthiness and how it interacts with the users. This **Service A** is
    mediated by the key player, the **Circuit Breaker**, which watches for failed
    requests and as soon as a certain number is reached, it trips just like a real
    circuit breaker, stopping any further requests from taking place to prevent the
    system from getting overloaded, thus allowing for recovery time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路断路器模式中，如我们的图所示，**服务A**是负责处理用户请求的主要服务，并有一些关键内部组件，如**健康检查器**和**请求处理器**，负责监控系统的健康状态以及它与用户的交互。这个**服务A**由关键玩家**电路断路器**所中介，它监视失败的请求，一旦达到一定数量，就会像真正的电路断路器一样跳闸，停止任何进一步的请求，以防止系统过载，从而允许恢复时间。
- en: This mechanism aimed not only at protecting **Service A** but also a way of
    safeguarding the external dependencies such as **Service B** and databases from
    being overwhelmed. It’s a failsafe that helps bring stability to a system, and
    in turn, prevents the other services that comprise the microservices architecture
    from falling over like dominoes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制不仅旨在保护**服务A**，而且也是一种保护外部依赖（如**服务B**和数据库）免受压垮的方法。这是一个安全措施，有助于使系统稳定，从而防止构成微服务架构的其他服务像多米诺骨牌一样倒塌。
- en: The Layered design pattern
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层设计模式
- en: The Layered design pattern is a way for programmers to structure their code
    in an organized fashion. Basically what it does is break the software up into
    different levels, each with its own specific job.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 分层设计模式是程序员以有组织的方式结构化代码的一种方法。基本上，它所做的就是将软件分解成不同的层级，每个层级都有自己的特定任务。
- en: The levels are stacked on top of each other, with the lower levels providing
    services for the higher ones. So, the bottom level would focus on things such
    as data access or hardware interfaces. Then the next level up could use those
    lower services to do things such as business logic, while the top levels are more
    about interfaces, such as the user interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 层级是层层叠放的，较低层级为较高层级提供服务。因此，最底层的重点将放在数据访问或硬件接口等方面。然后，下一层级可以使用这些较低层级的服务来完成诸如业务逻辑等任务，而顶层则更多地关注接口，例如用户界面。
- en: By separating everything like this, it makes the code easier to manage and maintain.
    Programmers can work on individual levels without worrying too much about the
    other pieces. And it’s easier to reuse code since each level has a clear purpose.
    If you need to update how data is stored, you only have to change the bottom level
    rather than digging through the whole program.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式将一切分开，使得代码更容易管理和维护。程序员可以在单个层级上工作，而不必过多担心其他部分。由于每个层级都有一个明确的目的，因此代码的重用也更容易。如果你需要更新数据的存储方式，你只需更改底层而不是在整个程序中挖掘。
- en: Overall it promotes a logical structure where each new level you build on top
    of relies on the work done below. This hierarchical setup helps organize large
    and complex software systems into understandable and manageable chunks.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，它促进了一种逻辑结构，其中每个新构建的层级都依赖于下面的工作。这种分层设置有助于将大型和复杂的软件系统组织成可理解和可管理的块。
- en: 'In the following *Figure 2**.14*, we can see what the layered design pattern
    looks like overall:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的**图2.14**中，我们可以看到分层设计模式的整体样子：
- en: '![Figure 2.14: Example of the Layered design pattern](img/B18400_02_14.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14：分层设计模式的示例](img/B18400_02_14.jpg)'
- en: 'Figure 2.14: Example of the Layered design pattern'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：分层设计模式的示例
- en: As you can see in the diagram, each layer is isolated from the others, and they
    can’t skip one layer and communicate with another one directly. So, by this design,
    you can keep user interactions in the controller layer, perform the business logic
    in the application layer, and keep database operations in the data layer.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，每一层都是相互隔离的，它们不能跳过一层直接与另一层通信。因此，通过这种设计，你可以将用户交互保持在控制器层，执行业务逻辑在应用层，并将数据库操作保持在数据层。
- en: The MVC design pattern
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: '**MVC** stands for **Model-View-Controller** and basically splits everything
    into three parts. It is such a common design pattern for building web and mobile
    applications!'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**代表**模型-视图-控制器**，基本上将一切分为三个部分。这是构建Web和移动应用的一种非常常见的设计模式！'
- en: The Model is where all the important stuff is stored, such as user accounts,
    posts, products – you name it! That’s the core data and logic of the app.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是存储所有重要内容的地方，例如用户账户、帖子、产品——你叫什么名字！这是应用程序的核心数据和逻辑。
- en: The View is what the user sees on their screen – things such as HTML, CSS, and
    maybe templates if it’s a single-page app. This renders the Model data so users
    can view it all.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是用户在屏幕上看到的内容——例如HTML、CSS，如果是单页应用，可能还有模板。它渲染模型数据，以便用户可以查看。
- en: Then we’ve got the Controller! This handles everything the user does including
    clicks, forms, and API calls. When something happens, the Controller figures it
    out, updates the Model if needed, and tells the View to change up.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有了控制器！它处理用户所做的所有操作，包括点击、表单和API调用。当发生某些事情时，控制器会找出原因，如果需要，更新模型，并告诉视图进行更改。
- en: By separating the code out like this, it stays super clean and organized over
    time. You can tweak one part without messing up the others as much. Plus it gives
    flexibility to reuse or swap pieces in and out.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样分离代码，随着时间的推移，代码保持超级干净和有序。你可以调整一部分而不太影响其他部分。此外，它还提供了灵活性，可以重新使用或替换其中的部分。
- en: '*Figure 2**.15* shows an example MVC design, and we will next discuss how the
    request returns to a view:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.15* 展示了一个MVC设计的示例，接下来我们将讨论请求如何返回视图：'
- en: '![Figure 2.15: Example of MVC design pattern](img/B18400_02_15.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15：MVC设计模式的示例](img/B18400_02_15.jpg)'
- en: 'Figure 2.15: Example of MVC design pattern'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：MVC设计模式的示例
- en: In the preceding diagram, we can see a very similar diagram to the previous
    Layered architecture design pattern. However, here, we don’t have an application
    layer. The business logic is divided between the controller and model layers.
    When the user makes a request, after the business logic has been applied, the
    controller returns a view, which can be a web page or a JSON object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个与之前分层架构设计模式非常相似的图。然而，在这里，我们没有应用层。业务逻辑在控制器和模型层之间划分。当用户发起请求，并在应用业务逻辑之后，控制器返回一个视图，这可能是一个网页或JSON对象。
- en: In summary, MVC is the best pattern for building user interfaces in a way that’s
    maintainable and organized for the long run. It really makes app development a
    total breeze!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，MVC是构建用户界面的最佳模式，它使应用程序开发变得非常容易，并且可以长期维护和有序。
- en: The Saga design pattern
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Saga设计模式
- en: The Saga design pattern is so cool for building distributed systems! It helps
    manage long transactions and keeps data consistent between different services.
    Maintaining atomicity and consistency is tough when you have multiple related
    steps spread across multiple services. But Saga has you covered!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Saga设计模式对于构建分布式系统来说非常酷！它有助于管理长事务，并保持不同服务之间的数据一致性。当你在多个服务中分散多个相关步骤时，维护原子性和一致性是困难的。但Saga为你解决了这个问题！
- en: Saga is perfect when you have a big distributed system made up of many microservices.
    Sometimes you need a business transaction that involves multiple steps happening
    across different services. No problem! With Saga, you can break the transaction
    into a sequence of smaller transactions, with each one fully contained within
    a single service. It coordinates all data flows to make sure each request lines
    up properly in the end, without needing complicated distributed transactions.
    Distributed transactions can be complex and hard to scale, but Saga avoids all
    that for smooth sailing.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个由许多微服务组成的大型分布式系统时，Saga模式是完美的。有时你需要一个涉及多个步骤的业务事务，这些步骤发生在不同的服务中。没问题！使用Saga，你可以将事务分解为一系列较小的交易，每个交易都完全包含在单个服务中。它协调所有数据流，确保每个请求最终正确对齐，而不需要复杂的分布式事务。分布式事务可能很复杂且难以扩展，但Saga避免了所有这些，以确保顺利航行。
- en: 'As reflected in *Figure 2**.16*, the Saga design pattern is a technique to
    deal with complex, multi-service transactions such as the order, payment, and
    shipping services in an e-commerce context:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.16* 所示，Saga设计模式是一种处理复杂、多服务交易的技术，例如电子商务环境中的订单、支付和运输服务：
- en: '![Figure 2.16: Example of the Saga design pattern](img/B18400_02_16.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16：Saga设计模式的示例](img/B18400_02_16.jpg)'
- en: 'Figure 2.16: Example of the Saga design pattern'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：Saga设计模式的示例
- en: Let’s break down the preceding diagram. The order service initiates a multi-step
    transaction, each step of which gets handled by a different service. They communicate
    through event streams, making sure every step of the transaction happens in order.
    If anything goes wrong with any step, special actions (some abstraction saying
    what happened would be needed, not shown on the diagram) should be taken to *undo*
    previous steps that ensure everything *reverts*. Each service has its own database,
    hence they can operate independently, while the Saga pattern ensures that the
    entire transaction either fully succeeds or is properly compensated in case of
    any hiccups. This is key in managing complicated transactions in systems where
    there are different services that have to work together seamlessly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的图。订单服务启动一个多步骤事务，每个步骤都由不同的服务处理。它们通过事件流进行通信，确保事务的每个步骤按顺序发生。如果任何步骤出现问题，应采取特殊措施（需要一些抽象来说明发生了什么，但图上未显示）来*撤销*确保一切*恢复*的先前步骤。每个服务都有自己的数据库，因此它们可以独立操作，而
    Saga 模式确保整个事务要么完全成功，要么在出现任何问题时得到适当的补偿。这对于管理系统中不同服务必须无缝协作的复杂事务至关重要。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s review what we have learned in this chapter and then look forward to
    the things that we’ll cover next. Here’s what we learned:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章学到的内容，并展望接下来我们将要讨论的内容。以下是我们的学习成果：
- en: '**DDD**: A strategy to ensure that our software development work aligns properly
    with the specific requirements of a business. This method guides us to create
    software that really serves its intended purpose.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DDD**：确保我们的软件开发工作与特定业务需求正确对齐的策略。这种方法指导我们创建真正服务于其预期目的的软件。'
- en: '**CQRS**: We learned to manage data effectively, separating the operations
    that change data (commands) from those that retrieve them (queries). This separation
    aims to empower the performance and reliability of our systems, making them more
    feasible in terms of their actual use case scenarios.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CQRS**：我们学会了有效地管理数据，将更改数据的操作（命令）与检索它们的操作（查询）分开。这种分离旨在提高我们系统的性能和可靠性，使其在实际用例场景中更具可行性。'
- en: '**Event Sourcing**: This pattern involves the logging of every change in the
    system as an event. It particularly shines when you are tracking changes over
    time and is a fundamental building block for systems where understanding the history
    of decisions and actions throughout their lifetime is core to their operation.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件溯源**：这种模式涉及将系统中的每次更改都记录为事件。当你跟踪随时间的变化时，它特别出色，并且是理解整个生命周期中决策和行动历史的基本构建块，这对于系统的操作至关重要。'
- en: '**Benefits of design architectures**: We learned how to structure robust, efficient,
    and business-aligned systems, how to structure software in order to manage data
    better, and how to share the expected functional and nonfunctional requirements
    of modern business applications.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计架构的好处**：我们学会了如何构建健壮、高效且与业务对齐的系统，如何构建软件以更好地管理数据，以及如何共享现代商业应用程序预期的功能和非功能需求。'
- en: Now we look forward to [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), where
    we will learn about building reactive REST APIs using Spring Boot and delve into
    the principles of asynchronous systems and back-pressure. This chapter focuses
    on advanced principles and concepts for designing web applications considering
    our understanding of software architecture from *Chapters 1* and *2* in order
    to develop applications that are both responsive and efficient.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们期待着阅读[*第3章*](B18400_03.xhtml#_idTextAnchor064)，我们将学习如何使用Spring Boot构建响应式的REST
    API，并深入探讨异步系统和背压原理。本章重点介绍设计网络应用程序的高级原理和概念，考虑到我们从*第1章*和*第2章*中获得的软件架构理解，以便开发既响应又高效的应用程序。
