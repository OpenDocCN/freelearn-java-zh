- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: WebSockets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets
- en: Traditionally, web applications have been developed using the request/response
    model followed by HTTP. In this traditional request/response model, the request
    is always initiated by the client, then the server sends a response back to the
    client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Web应用程序是使用HTTP之后的请求/响应模型开发的。在这个传统的请求/响应模型中，请求始终由客户端发起，然后服务器将响应发送回客户端。
- en: There has never been any way for the server to send data to the client independently,
    that is, without having to wait for a request, until now. The WebSocket protocol
    allows full-duplex, two-way communication between the client (browser) and the
    server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从未有过独立向客户端发送数据的方式，也就是说，不需要等待请求，直到现在。WebSocket协议允许客户端（浏览器）和服务器之间进行全双工、双向通信。
- en: The Jakarta API for WebSocket allows us to develop WebSocket endpoints in Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta API for WebSocket允许我们在Java中开发WebSocket端点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing WebSocket server endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发WebSocket服务器端点
- en: Developing WebSocket clients in JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript开发WebSocket客户端
- en: Developing WebSocket clients in Java
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java开发WebSocket客户端
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src)。
- en: Developing WebSocket server endpoints
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发WebSocket服务器端点
- en: 'There are two ways we can implement a WebSocket server endpoint via the Jakarta
    API for WebSocket: we can either develop an endpoint programmatically, in which
    case we need to extend the `jakarta.websocket.Endpoint` class, or we can annotate
    **Plain Old Java Objects** (**POJOs**) with WebSocket-specific annotations. These
    two approaches are very similar, therefore we will be discussing in detail only
    the annotation approach, and will briefly explain how to develop WebSocket server
    endpoints programmatically later in the chapter.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式使用 Jakarta API 为 WebSocket 实现WebSocket服务器端点：我们既可以编程式地开发端点，在这种情况下，我们需要扩展`jakarta.websocket.Endpoint`类，或者我们可以使用WebSocket特定的注解来注解**普通Java对象**（**POJOs**）。这两种方法非常相似，因此我们只将详细讨论注解方法，并在本章后面简要解释如何编程式地开发WebSocket服务器端点。
- en: In this chapter, we will develop a simple web-based chat application that takes
    full advantage of the Jakarta API for WebSocket.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的基于Web的聊天应用程序，充分利用Jakarta API for WebSocket。
- en: Developing an annotated WebSocket server endpoint
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发注解WebSocket服务器端点
- en: 'The following Java class illustrates how we can develop a WebSocket server
    endpoint by annotating a Java class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Java类演示了我们可以通过注解Java类来开发WebSocket服务器端点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class-level `@ServerEndpoint` annotation indicates that the class is a WebSocket
    server endpoint. The `"/websocketchat"`, in this example). WebSocket clients will
    use this URI to communicate with our endpoint.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@ServerEndpoint`注解表示该类是一个WebSocket服务器端点。在这个例子中，`"/websocketchat"`（即）。WebSocket客户端将使用此URI与我们的端点进行通信。
- en: The `@OnOpen` annotation is used to indicate a method that needs to be executed
    whenever a WebSocket connection is opened from any of the clients. In our example,
    we are simply sending some output to the server log, but of course, any valid
    server-side Java code can be placed here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnOpen`注解用于指示每当从任何客户端打开WebSocket连接时需要执行的方法。在我们的例子中，我们只是向服务器日志发送一些输出，但当然，任何有效的服务器端Java代码都可以放在这里。'
- en: Any method annotated with the `@OnMessage` annotation will be invoked whenever
    our server endpoint receives a message from any of the clients. Since we are developing
    a chat application, our code simply broadcasts the message it receives to all
    connected clients.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任何带有`@OnMessage`注解的方法将在我们的服务器端点从任何客户端接收到消息时被调用。由于我们正在开发一个聊天应用程序，我们的代码只是将接收到的消息广播给所有已连接的客户端。
- en: In our example, the `processMessage()` method is annotated with `@OnMessage`,
    and it takes two parameters, an instance of a class implementing the `jakarta.websocket.Session`
    interface, and a `String` containing the message that was received. Since we are
    developing a chat application, our WebSocket server endpoint simply broadcasts
    the received message to all connected clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`processMessage()`方法被注解为`@OnMessage`，它接受两个参数，一个实现`jakarta.websocket.Session`接口的类的实例，以及一个包含接收到的消息的`String`。由于我们正在开发一个聊天应用程序，我们的WebSocket服务器端点只是将接收到的消息广播给所有已连接的客户端。
- en: The `getOpenSessions()` method of the `Session` interface returns a `Set` of
    `Session` objects representing all open sessions, we iterate through this set
    to broadcast the received message back to all connected clients by invoking the
    `getBasicRemote()` method on each `Session` instance, then invoking the `sendText()`
    method on the resulting `RemoteEndpoint.Basic` implementation returned by this
    call.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口的`getOpenSessions()`方法返回一个包含所有打开会话的`Set`集合，我们遍历这个集合，通过在每个`Session`实例上调用`getBasicRemote()`方法，然后调用此调用返回的`RemoteEndpoint.Basic`实现上的`sendText()`方法，将接收到的消息广播回所有已连接的客户端。'
- en: The `getOpenSessions()` method on the `Session` interface returns all the open
    sessions at the time the method was invoked. It is possible for one or more of
    the sessions to have closed after the method was invoked, so it is recommended
    to invoke the `isOpen()` method on a `Session` implementation before attempting
    to send data back to the client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口上的`getOpenSessions()`方法在调用该方法时返回所有打开的会话。在方法调用之后，一个或多个会话可能已经关闭，因此建议在尝试向客户端发送数据之前，在`Session`实现上调用`isOpen()`方法。'
- en: Finally, we need to annotate a method with the `@OnClose` annotation to handle
    the event when a client disconnects from the server endpoint. In our example,
    we simply log a message to the server log.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`@OnClose`注解来标注一个方法，以处理客户端从服务器端点断开连接的事件。在我们的示例中，我们只是简单地将一条消息记录到服务器日志中。
- en: There is one additional annotation we didn’t use in our example. The `@OnError`
    annotation is used to indicate a method that needs to be invoked in case of an
    error when sending or receiving data to or from the client.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中没有使用的一个附加注解。`@OnError`注解用于指示在向客户端发送或从客户端接收数据时发生错误时需要调用的方法。
- en: As we can see, developing an annotated WebSocket server endpoint is straightforward.
    We simply need to add a few annotations and the application server will invoke
    our annotated methods as necessary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，开发注解WebSocket服务器端点很简单。我们只需添加几个注解，应用程序服务器就会根据需要调用我们的注解方法。
- en: If we wish to develop a WebSocket server endpoint programmatically, we need
    to write a Java class that extends `jakarta.websocket.Endpoint`. This class has
    `onOpen()`, `onClose()`, and `onError()` methods that are called at the appropriate
    times during the endpoint’s lifecycle. There is no method equivalent to the `@OnMessage`
    annotation – to handle incoming messages from the clients, the `addMessageHandler()`
    method needs to be invoked in the session, passing an instance of a class implementing
    the `jakarta.websocket.MessageHandler` interface (or one of its subinterfaces)
    as its sole parameter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望以编程方式开发WebSocket服务器端点，我们需要编写一个扩展`jakarta.websocket.Endpoint`的Java类。这个类有`onOpen()`、`onClose()`和`onError()`方法，这些方法在端点生命周期中的适当时间被调用。没有与`@OnMessage`注解等效的方法——要处理来自客户端的传入消息，需要在会话中调用`addMessageHandler()`方法，传递一个实现`jakarta.websocket.MessageHandler`接口（或其子接口）的类的实例作为其唯一参数。
- en: In general, it is more straightforward to develop annotated WebSocket endpoints
    as opposed to their programmatic counterparts. Therefore, we recommend the annotated
    approach whenever possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与它们的程序化对应物相比，开发注解WebSocket端点更为直接。因此，我们建议尽可能使用注解方法。
- en: Now that we have seen how to develop WebSocket endpoints, we will focus our
    attention on developing WebSocket clients.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何开发WebSocket端点，我们将把注意力集中在开发WebSocket客户端上。
- en: Developing WebSocket clientsin JavaScript
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中开发WebSocket客户端
- en: Most WebSocket clients are implemented as web pages taking advantage of the
    JavaScript WebSocket API. We will cover how to do this in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数WebSocket客户端都是作为利用JavaScript WebSocket API的网页实现的。我们将在下一节中介绍如何实现这一点。
- en: The Jakarta API for WebSocket provides a client API that allows us to develop
    WebSocket clients as standalone Java applications. We will be covering this capability
    later in the chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta API为WebSocket提供了一个客户端API，允许我们开发作为独立Java应用程序的WebSocket客户端。我们将在本章后面介绍这一功能。
- en: Developing JavaScript client-side WebSocket code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发JavaScript客户端WebSocket代码
- en: In this section, we will cover how to develop client-side JavaScript code to
    interact with the WebSocket endpoint we developed in the previous section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何开发客户端JavaScript代码，以与我们在上一节中开发的WebSocket端点交互。
- en: The client page for our WebSocket example is implemented as a JSF page using
    HTML5-friendly markup (as explained in [*Chapter 7*](B21231_07.xhtml#_idTextAnchor100)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们WebSocket示例的客户端页面是使用HTML5友好的标记实现的JSF页面（如[*第7章*](B21231_07.xhtml#_idTextAnchor100)中所述）。
- en: As illustrated in *Figure 9**.1*, our client page consists of a text area where
    we can see what the users of our application are saying (it is, after all, a chat
    application), and a text-input box that we can use to send messages to other users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图9.1**所示，我们的客户端页面由一个文本区域组成，我们可以在这里看到我们应用的用户在说什么（毕竟，这是一个聊天应用），以及一个文本输入框，我们可以用它向其他用户发送消息。
- en: '![Figure 9.1 – Javascript WebSocket client](img/B21231_9_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – JavaScript WebSocket客户端](img/B21231_9_01.jpg)'
- en: Figure 9.1 – Javascript WebSocket client
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.1** – JavaScript WebSocket客户端'
- en: 'The JavaScript code for our client page looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端页面的JavaScript代码如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last line of our JavaScript code (`window.addEventListener("load", init);`)
    sets our JavaScript `init()` function to get executed as soon as the page loads.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们JavaScript代码的最后一行（`window.addEventListener("load", init);`）将我们的JavaScript
    `init()`函数设置为在页面加载时立即执行。
- en: In the `init()` function, we initialize a new JavaScript WebSocket object, passing
    the URI of our server endpoint as a parameter. This lets our JavaScript code know
    the location of our server endpoint.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`函数中，我们初始化一个新的JavaScript WebSocket对象，将我们的服务器端点URI作为参数传递。这使我们的JavaScript代码知道我们的服务器端点的位置。
- en: The JavaScript WebSocket object has a number of function types used to handle
    different events such as opening the connection, receiving a message, and handling
    errors. We need to set these types to our own JavaScript functions so that we
    can handle these events, which is what we do in our `init()` method right after
    invoking the constructor for the JavaScript WebSocket object. In our example,
    the functions we assigned to the WebSocket object simply delegate their functionality
    to stand-alone JavaScript functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript WebSocket对象有几种函数类型，用于处理不同的事件，如打开连接、接收消息和处理错误。我们需要将这些类型设置到我们自己的JavaScript函数中，以便我们可以处理这些事件，这正是我们在调用JavaScript
    WebSocket对象构造函数后立即在`init()`方法中做的。在我们的例子中，我们分配给WebSocket对象的函数只是将它们的功能委托给独立的JavaScript函数。
- en: Our `websocketOpen()` function is called whenever the WebSocket connection is
    opened. In our example, we simply send a message to the browser’s JavaScript console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebSocket连接打开时，会调用我们的`websocketOpen()`函数。在我们的例子中，我们只是向浏览器JavaScript控制台发送一条消息。
- en: Our `webSocketMessage()` function is invoked whenever the browser receives a
    WebSocket message from our WebSocket endpoint. In our example, we update the contents
    of the text area that has the ID of the chat window with the contents of the message.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器从我们的WebSocket端点接收到WebSocket消息时，会调用我们的`webSocketMessage()`函数。在我们的例子中，我们使用消息的内容更新具有聊天窗口ID的文本区域的内文。
- en: Our `websocketError()` function is called whenever there is a WebSocket-related
    error. In our example, we simply send a message to the browser’s JavaScript console.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生与WebSocket相关的错误时，会调用我们的`websocketError()`函数。在我们的例子中，我们只是向浏览器JavaScript控制台发送一条消息。
- en: Our JavaScript `sendMessage()` function sends a message to the WebSocket server
    endpoint containing both the username and the contents of the text input with
    the ID of `chatinput`. This function is called when the user clicks on the button
    with the ID of `sendBtn`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sendMessage()`JavaScript函数向WebSocket服务器端点发送一条消息，其中包含用户名和具有`chatinput` ID的文本输入的内容。当用户点击具有`sendBtn`
    ID的按钮时，会调用此函数。
- en: Our `closeConnection()` JavaScript function closes the connection to our WebSocket
    server endpoint.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`closeConnection()`JavaScript函数关闭了与我们的WebSocket服务器端点的连接。
- en: As we can see from this example, writing client-side JavaScript code to interact
    with WebSocket endpoints is fairly straightforward.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，编写客户端JavaScript代码与WebSocket端点交互相当简单。
- en: Developing WebSocket clients in Java
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中开发WebSocket客户端
- en: Although developing web-based WebSocket clients is currently the most common
    way of developing WebSocket clients, the Jakarta API for WebSocket provides a
    client API we can use to develop WebSocket clients in Java.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前开发基于Web的WebSocket客户端是开发WebSocket客户端最常见的方式，但Jakarta API为WebSocket提供了一个客户端API，我们可以使用它来开发Java
    WebSocket客户端。
- en: In this section, we will be developing a simple graphical WebSocket client using
    the client API of the Jakarta API for WebSocket. *Figure 9**.2* illustrates the
    GUI of our Java WebSocket client.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Jakarta API for WebSocket的客户端API开发一个简单的图形WebSocket客户端。*图9.2*展示了我们的Java
    WebSocket客户端的GUI。
- en: '![ Figure 9.2 – WebSocket client developed in Java](img/B21231_9_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用Java开发的WebSocket客户端](img/B21231_9_02.jpg)'
- en: Figure 9.2 – WebSocket client developed in Java
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用Java开发的WebSocket客户端
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We won’t be covering the GUI code, since it is not relevant to the discussion.
    The complete code for the example, including the GUI code, can be downloaded from
    the book’s GitHub repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍GUI代码，因为它与讨论无关。示例的完整代码，包括GUI代码，可以从本书的GitHub仓库下载。
- en: Just as with WebSocket server endpoints, Java WebSocket clients can be developed
    either programmatically or by using annotations. Once again, we will cover only
    the annotation approach. Developing a programmatic client is very similar to the
    way programmatic server endpoints are developed, which is to say, programmatic
    clients must extend `jakarta.websocket.Endpoint` and override the appropriate
    methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像WebSocket服务器端点一样，Java WebSocket客户端可以通过编程方式或使用注解来开发。再次强调，我们只介绍注解方法。开发程序客户端的方式与开发程序服务器端点的方式非常相似，也就是说，程序客户端必须扩展`jakarta.websocket.Endpoint`并重写适当的方法。
- en: 'Without further ado, here is the code for our Java WebSocket client:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，以下是我们的Java WebSocket客户端代码：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class-level `@ClientEndPoint` annotation denotes our class as a WebSocket
    client. All Java WebSocket clients must be annotated with this annotation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@ClientEndPoint`注解将我们的类标记为WebSocket客户端。所有Java WebSocket客户端都必须使用此注解。
- en: The code to establish a connection to the WebSocket server endpoint is in our
    class constructor. First, we need to invoke `ContainerProvider.getWebSocketContainer()`
    to obtain an instance of `jakarta.websocket.WebSocketContainer`. We then establish
    the connection by invoking the `connectToServer()` method on our `WebSocketContainer`
    instance, passing a class annotated with `@ClientEndpoint` as the first parameter
    (in our example, we use `this`, since the connection code is inside our WebSocket
    Java client code), and an `URI` object containing the WebSocket server endpoint
    URI as the second parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 建立与WebSocket服务器端点连接的代码位于我们的类构造函数中。首先，我们需要调用`ContainerProvider.getWebSocketContainer()`来获取`jakarta.websocket.WebSocketContainer`的实例。然后，通过在`WebSocketContainer`实例上调用`connectToServer()`方法来建立连接，将一个被`@ClientEndpoint`注解的类作为第一个参数（在我们的例子中，我们使用`this`，因为连接代码位于我们的WebSocket
    Java客户端代码中），以及包含WebSocket服务器端点URI的`URI`对象作为第二个参数。
- en: After the connection is established, we are ready to respond to WebSocket events.
    Alert readers may have noticed that we are using the exact same annotations we
    used to develop our server endpoint again in our client code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们就可以准备响应WebSocket事件了。细心的读者可能已经注意到，我们在客户端代码中再次使用了我们用于开发服务器端点相同的注解。
- en: Any method annotated with the `@OnOpen` annotation will be invoked automatically
    when the connection to the WebSocket server endpoint is established, the method
    must return void and can have an optional parameter of type `jakarta.websocket.Session`.
    In our example, we initialize a class variable with the `Session` instance we
    received as a parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被`@OnOpen`注解的方法，在WebSocket服务器端点连接建立时都会自动被调用，该方法必须返回void，并且可以有一个可选的`jakarta.websocket.Session`类型参数。在我们的例子中，我们使用接收到的`Session`实例初始化一个类变量。
- en: Methods annotated with the `@OnClose` annotation are invoked whenever the WebSocket
    session is closed. The annotated method can have optional parameters of type `jakarta.websocket.Session`
    and type `CloseReason`. In our example, we chose to use only the `CloseReason`
    optional parameter, since this class has a handy `getReasonPhrase()` method that
    provides a short explanation of why the session was closed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 被`@OnClose`注解的方法在WebSocket会话关闭时被调用。被注解的方法可以有一个可选的`jakarta.websocket.Session`类型参数和一个`CloseReason`类型参数。在我们的例子中，我们选择只使用`CloseReason`可选参数，因为这个类有一个方便的`getReasonPhrase()`方法，可以提供会话关闭的简短解释。
- en: The `@OnError` annotation is used to indicate that a method will be called when
    an error occurs. Methods annotated with `@OnError` must have a parameter of type
    `java.lang.Throwable` (the parent class of `java.lang.Exception`), and can have
    an optional parameter of type `Session`. In our example, we simply send the stack
    trace of the `Throwable` parameter to `stderr`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnError`注解用于指示当发生错误时将调用该方法。带有`@OnError`注解的方法必须有一个类型为`java.lang.Throwable`（`java.lang.Exception`的父类）的参数，并且可以有一个类型为`Session`的可选参数。在我们的示例中，我们只是将`Throwable`参数的堆栈跟踪发送到`stderr`。'
- en: Methods annotated with `@OnMessage` are invoked whenever an incoming WebSocket
    message is received. `@OnMessage` methods can have different parameters depending
    on the type of message received and how we wish to handle it. In our example,
    we used the most common case, receiving a text message. In this particular case,
    we need a `String` parameter that will hold the contents of the message, and an
    optional `Session` parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到传入的WebSocket消息时，带有`@OnMessage`注解的方法将被调用。`@OnMessage`方法可以根据接收到的消息类型以及我们希望如何处理它来具有不同的参数。在我们的示例中，我们使用了最常见的情况，接收文本消息。在这种情况下，我们需要一个`String`参数来保存消息的内容，以及一个可选的`Session`参数。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the JavaDoc documentation for `@OnMessage` at [https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage)
    for information on how to handle other types of messages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何处理其他类型消息的信息，请参阅`@OnMessage`的JavaDoc文档，网址为[https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage)。
- en: In our example, we simply update the chat window text area, appending the received
    message to its contents.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只是更新了聊天窗口的文本区域，将接收到的消息追加到其内容中。
- en: To send a WebSocket message, we invoke the `getBasicRemote()` method on our
    Session instance, then invoke the `sendText()` method on the resulting `RemoteEndpoint.Basic`
    implementation returned by this call (if this looks familiar, it is because we
    did exactly the same thing in the WebSocket server endpoint code). In our example,
    we do this in the `sendMessage()` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送WebSocket消息，我们在Session实例上调用`getBasicRemote()`方法，然后在该调用返回的`RemoteEndpoint.Basic`实现上调用`sendText()`方法（如果这看起来很熟悉，那是因为我们在WebSocket服务器端点代码中确实做了完全相同的事情）。在我们的示例中，我们在`sendMessage()`方法中这样做。
- en: Additional information about the Jakarta API for WebSocket
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Jakarta API for WebSocket的附加信息
- en: In this chapter, we covered the bulk of the functionality provided by the Jakarta
    API for WebSocket. For additional information, refer to the user guide for Tyrus,
    a popular open source Jakarta API for WebSocket implementation, at [https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/](https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Jakarta API for WebSocket提供的功能的大部分。有关更多信息，请参阅Tyrus的用户指南，这是一个流行的开源Jakarta
    API for WebSocket实现，网址为[https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/](https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/)。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the Jakarta API for WebSocket, a Jakarta EE API
    for developing WebSocket server endpoints and clients:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Jakarta API for WebSocket，这是一个用于开发WebSocket服务器端点和客户端的Jakarta EE API：
- en: We first saw how to develop WebSocket server endpoints by taking advantage of
    the Jakarta API for WebSockets
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先了解了如何利用Jakarta API for WebSockets开发WebSocket服务器端点
- en: Then, we covered how to develop web-based WebSocket clients using JavaScript
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们介绍了如何使用JavaScript开发基于Web的WebSocket客户端
- en: Finally, we explained how to develop WebSocket client applications in Java
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们解释了如何在Java中开发WebSocket客户端应用程序
- en: WebSockets allow us to implement real-time, two-way communication between a
    web browser and a web server. As we saw in this chapter, the Jakarta EE WebSocket
    API takes care of the low-level details allowing us to develop WebSocket endpoints
    via a few simple annotations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets使我们能够实现网页浏览器和网页服务器之间的实时、双向通信。正如我们在本章中看到的，Jakarta EE WebSocket API负责处理底层细节，使我们能够通过几个简单的注解来开发WebSocket端点。
