- en: '*Chapter 1*: Getting Started with Java 17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Java 17 入门'
- en: This chapter is about how to start learning Java 17 and Java in general. We
    will begin with the basics, first explaining what Java is and its main terms,
    followed by how to install the necessary tools to write and run (execute) a program.
    In this respect, Java 17 is not much different from the previous Java versions,
    so this chapter’s content applies to the older versions too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何开始学习 Java 17 以及 Java 的一般知识。我们将从基础知识开始，首先解释什么是 Java 以及其主要术语，然后介绍如何安装编写和运行（执行）程序所需的工具。在这方面，Java
    17 与之前的 Java 版本没有太大区别，因此本章的内容也适用于旧版本。
- en: We will describe and demonstrate all the necessary steps for building and configuring
    a Java programming environment. This is the bare minimum that should have on your
    computer to start programming. We also describe the basic Java language constructs
    and illustrate them with examples that can be executed immediately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述并演示构建和配置 Java 编程环境所需的所有必要步骤。这是您计算机上开始编程所需的最基本内容。我们还描述了基本的 Java 语言结构，并通过可以立即执行的示例来展示它们。
- en: 'The best way to learn a programming language—or any language, for that matter—is
    to use it, and this chapter guides readers on how they can do this with Java.
    We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一种编程语言——或者任何语言，最好的方式是使用它，本章将指导读者如何使用 Java 来实现这一点。在本章中，我们将涵盖以下主题：
- en: How to install and run Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和运行 Java
- en: How to install and run an **integrated development environment** (**IDE**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和运行集成开发环境（**IDE**）
- en: Java primitive types and operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 原始类型和运算符
- en: String types and literals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型和字面量
- en: '**Identifiers** (**IDs**) and variables'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**（**IDs**）和变量'
- en: Java statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 语句
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，您需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: An IDE or your preferred code editor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 IDE 或您偏好的代码编辑器
- en: The instructions for how to set up a Java `examples/src/main/java/com/packt/learnjava/ch01_start`
    folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置 Java `examples/src/main/java/com/packt/learnjava/ch01_start` 文件夹的说明。
- en: How to install and run Java
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装和运行 Java
- en: 'When somebody says “*Java*”, they may mean quite different things. They could
    be referring to any of the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人说“*Java*”时，他们可能意味着完全不同的事情。他们可能指的是以下任何一个：
- en: '**Java programming language**: A high-level programming language that allows
    an intent (a program) to be expressed in a human-readable format that can be translated
    into binary code that is executable by a computer'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 编程语言**：一种高级编程语言，允许用人类可读的格式表达意图（程序），该格式可以被翻译成计算机可执行的二进制代码'
- en: '**Java compiler**: A program that can read a text written in the Java programming
    language and translate it into bytecode that can be interpreted by the **Java
    Virtual Machine** (**JVM**) into binary code that is executable by a computer'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 编译器**：一个程序，可以读取用 Java 编程语言编写的文本，并将其翻译成可以被 Java 虚拟机（**JVM**）解释的二进制代码，该代码可以被计算机执行'
- en: '**JVM**: A program that reads bytecode of the compiled Java program and interprets
    it into binary code that is executable by a computer'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM**：一个程序，读取编译好的 Java 程序的字节码，并将其解释成计算机可执行的二进制代码'
- en: '**Java Development Kit** (**JDK**): A collection of programs (tools and utilities),
    including the Java compiler, the JVM, and supporting libraries, which allow the
    compilation and execution of a program written in the Java language'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）：一组程序（工具和实用程序），包括 Java 编译器、JVM 和支持库，允许用 Java 语言编写的程序进行编译和执行'
- en: The following section walks you through the installation of the JDK of Java
    17 and the basic related terms and commands.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将指导您安装 Java 17 的 JDK 以及相关的基本术语和命令。
- en: What is the JDK and why do we need it?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 是什么以及为什么我们需要它？
- en: As we have mentioned already, the JDK includes a Java compiler and the JVM.
    The task of the compiler is to read a `.java` file that contains the text of a
    program written in Java (called source code) and transform (compile) it into bytecode
    stored in a `.class` file. The JVM can then read the `.class` file, interpret
    the bytecode into binary code, and send it to the operating system for execution.
    Both the compiler and the JVM have to be invoked explicitly from the command line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，JDK包括Java编译器和JVM。编译器的任务是读取包含用Java编写的程序文本的`.java`文件（称为源代码），并将其转换（编译）成存储在`.class`文件中的字节码。然后JVM可以读取`.class`文件，将字节码解释成二进制代码，并将其发送到操作系统执行。编译器和JVM都必须从命令行显式调用。
- en: 'The hierarchy of languages used by Java programs goes like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序使用的语言层次结构如下：
- en: You write Java code (`.java` file).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你编写Java代码（`.java`文件）。
- en: The compiler converts your Java code into bytecode (`.class` file).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器将你的Java代码转换成字节码（`.class`文件）。
- en: The JVM converts the bytecode into machine-level assembly instructions (run
    on hardware).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM将字节码转换成机器级汇编指令（在硬件上运行）。
- en: 'Have a look at the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '`int a = b + c;`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`int a = b + c;`'
- en: 'When you write the preceding code, the compiler adds the following bytecode
    to the `.class` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写前面的代码时，编译器会将以下字节码添加到`.class`文件中：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Write once, run anywhere* is the most famous programming marketing jingle
    driving worldwide adoption. Oracle claims more than 10 million developers use
    Java, which runs on 13 billion devices. You write Java and compile it into bytecode
    in `.class` files. There is a different JVM for Windows, Mac, Unix, Linux, and
    more, but the same `.class` file works on all of them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次编写，到处运行* 是最著名的编程营销口号，推动了全球的采用。Oracle声称超过1000万开发者使用Java，它在130亿台设备上运行。你编写Java代码，并将其编译成`.class`文件中的字节码。对于Windows、Mac、Unix、Linux等操作系统，都有不同的JVM，但相同的`.class`文件可以在所有这些操作系统上运行。'
- en: To support the `.java` file compilation and its bytecode execution, the JDK
    installation also includes standard Java libraries called the **Java Class Library**
    (**JCL**). If the program uses a third-party library, it has to be present during
    compilation and execution. It has to be referred from the same command line that
    invokes the compiler, and later when the bytecode is executed by the JVM. JCL,
    on the other hand, does not need to be referred to explicitly. It is assumed that
    the standard Java libraries reside in the default location of the JDK installation
    so that the compiler and the JVM know where to find them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`.java`文件的编译及其字节码执行，JDK安装还包括称为**Java类库**（**JCL**）的标准Java库。如果程序使用第三方库，它必须在编译和执行期间存在。它必须从调用编译器的相同命令行引用，后来当字节码由JVM执行时也是如此。另一方面，JCL不需要显式引用。假设标准Java库位于JDK安装的默认位置，以便编译器和JVM知道它们的位置。
- en: If you do not need to compile a Java program and would like to run only the
    already compiled `.class` files, you can download and install the **Java Runtime
    Environment** (**JRE**). For example, it consists of a subset of the JDK and does
    not include a compiler.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要编译Java程序，只想运行已经编译好的`.class`文件，你可以下载并安装**Java运行环境**（**JRE**）。例如，它包括JDK的一个子集，但不包括编译器。
- en: Sometimes, the JDK is referred to as a **software development kit** (**SDK**),
    which is a general name for a collection of software tools and supporting libraries
    that allow the creation of an executable version of source code written using
    a certain programming language. So, the JDK is an SDK for Java. This means it
    is possible to call the JDK an SDK.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，JDK被称为**软件开发工具包**（**SDK**），这是一个集合软件工具和支持库的通用名称，允许使用某种编程语言编写的源代码创建可执行版本。因此，JDK是Java的SDK。这意味着可以将JDK称为SDK。
- en: 'You may also hear the terms *Java platform* and *Java edition* applied to the
    JDK. A typical platform is an operating system that allows a software program
    to be developed and executed. Since the JDK provides its own operating environment,
    it is called a platform too. An edition is a variation of a Java platform (JDK)
    assembled for a specific purpose. There are four Java platform editions, as listed
    here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能听到将*Java平台*和*Java版本*应用于JDK的术语。一个典型的平台是一个操作系统，它允许软件开发和执行。由于JDK提供了自己的操作系统环境，因此它也被称为平台。版本是针对特定目的组装的Java平台（JDK）的变体。这里有四个Java平台版本，如下所示：
- en: '**Java Platform SE** (**Java SE**): This includes the JVM, JCL, and other tools
    and utilities.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台SE** (**Java SE**): 这包括JVM、JCL以及其他工具和实用程序。'
- en: '**Java Platform Enterprise Edition** (**Java EE**): This includes Java SE,
    servers (computer programs that provide services to the applications), JCL, other
    libraries, code samples, tutorials, and other documentation for developing and
    deploying large-scale, multi-tiered, and secure network applications.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台企业版** (**Java EE**): 这包括Java SE、服务器（为应用程序提供服务的计算机程序）、JCL、其他库、代码示例、教程和其他用于开发部署大规模、多层和安全的网络应用程序的文档。'
- en: '**Java Platform Micro Edition** (**Java ME**): This is a subset of Java SE
    with some specialized libraries for developing and deploying Java applications
    for embedded and mobile devices, such as phones, personal digital assistants,
    TV set-top boxes, printers, and sensors. A variation of Java ME (with its own
    JVM implementation) is called the Android SDK, which was developed by Google for
    Android programming.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台微型版** (**Java ME**): 这是Java SE的一个子集，包含一些用于开发并将Java应用程序部署到嵌入式和移动设备（如手机、个人数字助理、机顶盒、打印机和传感器）的专用库。Java
    ME的一个变体（具有自己的JVM实现）称为Android SDK，它是Google为Android编程开发的。'
- en: '**Java Card**: This is the smallest of the Java editions and is intended for
    developing and deploying Java applications onto small embedded devices such as
    smart cards. It has two editions: Java Card Classic Edition, for smart cards,
    (based on **International Organization for Standardization** (**ISO**) *7816*
    and ISO *14443* communication), and Java Card Connected Edition, which supports
    a web application model and **Transmission Control Protocol/Internet Protocol**
    (**TCP/IP**) as a basic protocol and runs on high-end secure microcontrollers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Card**: 这是Java版本中最小的一个，旨在开发并将Java应用程序部署到小型嵌入式设备上，例如智能卡。它有两个版本：Java Card经典版，用于智能卡（基于**国际标准化组织**
    (**ISO**) 7816和ISO 14443通信），以及Java Card连接版，它支持Web应用程序模型，并以**传输控制协议/互联网协议** (**TCP/IP**)作为基本协议，运行在高性能安全微控制器上。'
- en: So, to install Java means to install the JDK, which also means to install the
    Java platform on one of the listed editions. In this book, we are going to talk
    about and use only Java SE (which includes the JVM, JCL, and other tools and utilities
    necessary to compile your Java program into bytecode, interpret it into binary
    code, and automatically send it to your operating system for execution).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，安装Java意味着安装JDK，这也意味着在列出的版本之一上安装Java平台。在这本书中，我们将讨论并使用Java SE（它包括JVM、JCL以及其他将您的Java程序编译成字节码、解释成二进制代码并将其自动发送到您的操作系统以执行所需的工具和实用程序）。
- en: Installing Java SE
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Java SE
- en: All the recently released JDKs are listed on the official Oracle page at [https://www.oracle.com/java/technologies/downloads/#java17](https://www.oracle.com/java/technologies/downloads/#java17)
    (we will call this the *installation home page* for further references in later
    chapters).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最近发布的JDK都在官方Oracle页面上列出，请参阅[https://www.oracle.com/java/technologies/downloads/#java17](https://www.oracle.com/java/technologies/downloads/#java17)（我们将在后续章节中将其称为*安装主页*）。
- en: 'Here are the steps that need to be followed to install Java SE:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Java SE需要遵循以下步骤：
- en: Select the Java SE tab with your operating system.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的操作系统选择Java SE选项卡。
- en: Click on the link to the installer that fits your operating system and the format
    (extension) you are familiar with.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击适合您操作系统和熟悉格式的（扩展名）安装程序的链接。
- en: If in doubt, click the **Installation Instructions** link below and read the
    installation instructions for your operating system.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有疑问，请点击下面的**安装说明**链接，并阅读您操作系统的安装说明。
- en: Follow the steps that correspond to your operating system.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照与您的操作系统对应的步骤进行操作。
- en: 'The JDK is installed successfully when the `java -version` command on your
    computer displays the correct Java version, as demonstrated in the following example
    screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的计算机上的`java -version`命令显示正确的Java版本时，JDK安装成功，如下面的示例截图所示：
- en: '![](img/B18388_Figure_1.1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.1.jpg)'
- en: Commands, tools, and utilities
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令、工具和实用程序
- en: If you follow the installation instructions, you may have noticed a link (`bin`
    directory contains all executables that constitute Java commands, tools, and utilities.
    If the `bin` directory is not added to the `PATH` environment variable automatically,
    consider doing so manually so that you can launch a Java executable from any directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循安装说明，你可能已经注意到一个链接（`bin` 目录包含构成 Java 命令、工具和实用程序的 所有可执行程序。如果 `bin` 目录没有自动添加到
    `PATH` 环境变量中，请考虑手动添加，这样你就可以从任何目录启动 Java 可执行程序。
- en: In the previous section, we have already demonstrated the `java -version` Java
    command. A list of the other Java executables available (commands, tools, and
    utilities) can be found in the Java SE documentation ([https://www.oracle.com/technetwork/java/javase/documentation/index.html](https://www.oracle.com/technetwork/java/javase/documentation/index.html))
    by clicking the **Java Platform Standard Edition Technical Documentation** site
    link, and then the **Tools Reference link** on the next page. You can learn more
    about each executable tool by clicking its link.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经展示了 `java -version` Java 命令。其他可用的 Java 可执行程序（命令、工具和实用程序）的列表可以在 Java
    SE 文档中找到（[https://www.oracle.com/technetwork/java/javase/documentation/index.html](https://www.oracle.com/technetwork/java/javase/documentation/index.html)），通过点击
    **Java 平台标准版技术文档** 网站链接，然后点击下一页上的 **工具参考链接**。你可以通过点击其链接来了解更多关于每个可执行工具的信息。
- en: 'You can also run each of the listed executables on your computer using one
    of the following options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下选项之一在你的计算机上运行列出的每个可执行程序：
- en: '`-?`, `-h`, `--help`, or `-help`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`-?`, `-h`, `--help` 或 `-help`'
- en: These will display a brief description of the executable and all its options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将显示可执行程序的简要描述及其所有选项。
- en: 'The most important Java commands are listed here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了最重要的 Java 命令：
- en: '`javac`: This reads a `.java` file, compiles it, and creates one or more corresponding
    `.class` files, depending on how many Java classes are defined in the `.java`
    file.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`: 这将读取 `.java` 文件，编译它，并创建一个或多个相应的 `.class` 文件，具体取决于 `.java` 文件中定义了多少个
    Java 类。'
- en: '`java`: This executes a `.class` file.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`: 这将执行 `.class` 文件。'
- en: These are the commands that make programming possible. Every Java programmer
    must have a good understanding of their structure and capabilities, but if you
    are new to Java programming and use an IDE (see the *How to install and run an
    IDE* section), you do not need to master these commands immediately. A good IDE
    hides them from you by compiling a `.java` file automatically every time you make
    a change to it. It also provides a graphical element that runs the program every
    time you click it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使编程成为可能命令。每个 Java 程序员都必须对其结构和功能有良好的理解，但如果你是 Java 编程的新手并使用 IDE（见 *如何安装和运行
    IDE* 部分），你不需要立即掌握这些命令。一个好的 IDE 通过每次你对其 `.java` 文件进行更改时自动编译它来隐藏它们。它还提供了一个图形元素，每次你点击它时都会运行程序。
- en: Another very useful Java tool is jcmd. This facilitates communication with,
    and diagnosis of, any currently running Java processes (JVM) and has many options.
    But in its simplest form, without any option, it lists all currently running Java
    processes and their **process IDs** (**PIDs**). You can use it to see whether
    you have runaway Java processes. If you have, you can then kill such a process
    using the PID provided.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的 Java 工具是 jcmd。它便于与任何当前运行的 Java 进程（JVM）进行通信和诊断，并且有许多选项。但在最简单的形式下，不使用任何选项，它将列出所有当前运行的
    Java 进程及其 **进程 ID**（**PID**）。你可以用它来查看你是否存在失控的 Java 进程。如果有，你可以使用提供的 PID 来终止这样的进程。
- en: How to install and run an IDE
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装和运行 IDE
- en: What used to be just a specialized editor that allowed checking the syntax of
    a written program the same way a Word editor checks the syntax of an English sentence
    gradually evolved into an IDE. This bears its main function in the name. It integrates
    all the tools necessary for writing, compiling, and then executing a program under
    one **graphical user interface** (**GUI**). Using the power of Java compiler,
    the IDE identifies syntax errors immediately and then helps to improve code quality
    by providing context-dependent help and suggestions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最初只是一个专门编辑器，允许以与 Word 编辑器检查英语句子语法相同的方式检查编写程序的语法，逐渐演变成集成开发环境（IDE）。它的主要功能体现在名称上。它将编写、编译和执行程序所需的所有工具集成在一个
    **图形用户界面**（**GUI**）下。利用 Java 编译器的功能，IDE 可以立即识别语法错误，并通过提供上下文相关的帮助和建议来帮助提高代码质量。
- en: Selecting an IDE
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 IDE
- en: 'There are several IDEs available for a Java programmer, such as NetBeans, Eclipse,
    IntelliJ IDEA, BlueJ, DrJava, JDeveloper, JCreator, jEdit, JSource, and jCRASP,
    to name a few. You can read a review of the top Java IDEs and details about each
    by following this link: [https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers](https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers).
    The most popular ones are NetBeans, Eclipse, and IntelliJ IDEA.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 程序员来说，有多个 IDE 可用，例如 NetBeans、Eclipse、IntelliJ IDEA、BlueJ、DrJava、JDeveloper、JCreator、jEdit、JSource
    和 jCRASP 等。您可以通过以下链接阅读顶级 Java IDE 的评测和每个 IDE 的详细信息：[https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers](https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers)。最受欢迎的当属
    NetBeans、Eclipse 和 IntelliJ IDEA。
- en: NetBeans development started in 1996 as a Java IDE student project at Charles
    University in Prague. In 1999, the project and the company created around the
    project were acquired by Sun Microsystems. After Oracle acquired Sun Microsystems,
    NetBeans became open source, and many Java developers have since contributed to
    the project. It was bundled with JDK 8 and became an official IDE for Java development.
    In 2016, Oracle donated it to the Apache Software Foundation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的开发始于 1996 年，当时在布拉格的查尔斯大学作为 Java IDE 学生项目启动。1999 年，该项目及其周围的公司被 Sun
    Microsystems 收购。在 Oracle 收购 Sun Microsystems 之后，NetBeans 成为了开源项目，许多 Java 开发者随后为该项目做出了贡献。它随
    JDK 8 一起捆绑发布，并成为了 Java 开发的官方 IDE。2016 年，Oracle 将其捐赠给了 Apache 软件基金会。
- en: There is a NetBeans IDE for Windows, Linux, Mac, and Oracle Solaris. It supports
    multiple programming languages and can be extended with plugins. As of the time
    of writing, NetBeans is bundled only with JDK 8, but NetBeans 8.2 can work with
    JDK 9 too and uses features introduced with JDK 9 such as Jigsaw, for example.
    On [netbeans.apache.org](http://netbeans.apache.org), you can read more about
    the NetBeans IDE and download the latest version, which is 12.5 as of the time
    of this writing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans IDE 支持Windows、Linux、Mac 和 Oracle Solaris 系统。它支持多种编程语言，并且可以通过插件进行扩展。截至撰写本文时，NetBeans
    仅与 JDK 8 捆绑，但 NetBeans 8.2 也可以与 JDK 9 一起使用，并使用 JDK 9 引入的特性，例如 Jigsaw。在 [netbeans.apache.org](http://netbeans.apache.org)
    上，您可以了解更多关于 NetBeans IDE 的信息，并下载最新版本，撰写本文时版本为 12.5。
- en: '*Eclipse* is the most widely used Java IDE. The list of plugins that add new
    features to the IDE is constantly growing, so it is not possible to enumerate
    all the IDE’s capabilities. The Eclipse IDE project has been developed since 2001
    as **open source software** (**OSS**). A non-profit, member-supported corporation
    Eclipse Foundation was created in 2004 to provide the infrastructure (**version
    control systems** (**VCSs**), code review systems, build servers, download sites,
    and so on) and a structured process. None of the 30-something employees of the
    Eclipse Foundation is working on any of the 150 Eclipse-supported projects.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse* 是最广泛使用的 Java IDE。为 IDE 添加新功能的插件列表不断增长，因此无法一一列举 IDE 的所有功能。Eclipse
    IDE 项目自 2001 年以来作为 **开源软件**（**OSS**）进行开发。2004 年，成立了非营利性、会员支持的 Eclipse 基金会，以提供基础设施（**版本控制系统**（**VCSs**）、代码审查系统、构建服务器、下载站点等）和结构化流程。Eclipse
    基金会的 30 多名员工中没有人在 150 个 Eclipse 支持的项目上工作。'
- en: The sheer number and variety of Eclipse IDE plugins create a certain challenge
    for a beginner because you have to find your way around different implementations
    of the same—or similar—features that can, on occasion, be incompatible and may
    require deep investigation, as well as a clear understanding of all the dependencies.
    Nevertheless, the Eclipse IDE is very popular and has solid community support.
    You can read about the Eclipse IDE and download the latest release from [www.eclipse.org/ide](http://www.eclipse.org/ide).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse IDE 插件的数量和种类繁多，对于初学者来说构成了一定的挑战，因为您需要熟悉不同实现方式相同或类似的功能，这些功能有时可能不兼容，可能需要进行深入调查，并清楚了解所有依赖关系。尽管如此，Eclipse
    IDE 非常受欢迎，并且拥有坚实的社区支持。您可以在 [www.eclipse.org/ide](http://www.eclipse.org/ide) 上了解
    Eclipse IDE 并下载最新版本。
- en: 'IntelliJ IDEA has two versions: a paid one and a free community edition. The
    paid version is consistently ranked as the best Java IDE, but the community edition
    is listed among the three leading Java IDEs too. The JetBrains software company
    that develops the IDE has offices in Prague, Saint Petersburg, Moscow, Munich,
    Boston, and Novosibirsk. The IDE is known for its deep intelligence that is “*giving
    relevant suggestions in every context: instant and clever code completion, on-the-fly
    code analysis, and reliable refactoring tools*”, as stated by the authors while
    describing the product on their website ([www.jetbrains.com/idea](http://www.jetbrains.com/idea)).
    In the *Installing and configuring IntelliJ IDEA* section, we will walk you through
    the installation and configuration of IntelliJ IDEA’s community edition.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 有两个版本：付费版和免费社区版。付费版一直被评为最佳 Java IDE，但社区版也被列为三大领先 Java IDE 之一。开发该
    IDE 的 JetBrains 软件公司在布拉格、圣彼得堡、莫斯科、慕尼黑、波士顿和诺沃西比尔斯克设有办事处。该 IDE 以其深入智能而闻名，正如作者在网站上描述产品时所说：“*在任何上下文中提供相关建议：即时且聪明的代码补全、即时代码分析以及可靠的重构工具*”。在*安装和配置
    IntelliJ IDEA*部分，我们将向您介绍 IntelliJ IDEA 社区版的安装和配置过程。
- en: Installing and configuring IntelliJ IDEA
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 IntelliJ IDEA
- en: 'These are the steps you need to follow in order to download and install IntelliJ
    IDEA:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要遵循的步骤来下载和安装 IntelliJ IDEA：
- en: Download an installer of the IntelliJ community edition from [www.jetbrains.com/idea/download](http://www.jetbrains.com/idea/download).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [www.jetbrains.com/idea/download](http://www.jetbrains.com/idea/download)
    下载 IntelliJ IDEA 社区版的安装程序。
- en: Launch the installer and accept all the default values.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动安装程序并接受所有默认值。
- en: Select `.java` on the **Installation Options** screen. We assume you have installed
    the JDK already, so you do not check the **Download and install JRE** option.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**安装选项**屏幕上选择`.java`。我们假设你已经安装了 JDK，所以你不需要勾选**下载并安装 JRE**选项。
- en: The last installation screen has a **Run IntelliJ IDEA** checkbox that you can
    check to start the IDE automatically. Alternatively, you can leave the checkbox
    unchecked and launch the IDE manually once the installation is complete.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个安装屏幕有一个**运行 IntelliJ IDEA**复选框，你可以勾选以自动启动IDE。或者，你可以在安装完成后手动启动IDE，不勾选复选框。
- en: When the IDE starts for the first time, it provides you with an **Import IntelliJ
    IDEA settings** option. Check the **Do not import settings** checkbox if you have
    not used IntelliJ IDEA before.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当IDE首次启动时，它会提供一个**导入 IntelliJ IDEA 设置**选项。如果你之前没有使用过 IntelliJ IDEA，请勾选**不导入设置**复选框。
- en: The next couple of screens ask whether you accept the **JetBrains Privacy Policy**
    and whether you would like to pay for the license or prefer to continue to use
    the free community edition or free trial (this depends on the particular download
    you get).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几个屏幕会询问你是否接受**JetBrains隐私政策**，以及你是否愿意为许可证付费或更喜欢继续使用免费社区版或免费试用版（这取决于你下载的具体版本）。
- en: 'Answer the questions whichever way you prefer, and if you accept the privacy
    policy, the **Customize IntelliJ IDEA** screen will ask you to choose a theme:
    **white (IntelliJ)** or **dark (Darcula)**.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照你喜欢的任何方式回答问题，如果你接受隐私政策，**自定义 IntelliJ IDEA**屏幕将要求你选择一个主题：**白色（IntelliJ）**或**深色（Darcula）**。
- en: Accept the default settings.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受默认设置。
- en: If you decide to change the set values, you can do so later by selecting from
    the topmost menu, **File** | **Settings**, on Windows, or **Preferences** on Linux
    and macOS.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你决定更改设置值，你可以在稍后通过选择最顶部的菜单**文件** | **设置**（在 Windows 上）或**首选项**（在 Linux 和 macOS
    上）来更改。
- en: Creating a project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Before you start writing your program, you need to create a project. There
    are several ways to create a project in IntelliJ IDEA, which is the same for any
    IDE, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写程序之前，你需要创建一个项目。在 IntelliJ IDEA 中创建项目有几种方法，这与任何 IDE 都相同，如下所示：
- en: '**New Project**: This creates a new project from scratch.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新建项目**：这将从零开始创建一个新项目。'
- en: '**Open**: This facilitates reading of the existing project from the filesystem.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开**：这有助于从文件系统中读取现有项目。'
- en: '**Get from VCS**: This facilitates reading of the existing project from the
    VCS.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从版本控制系统获取**：这有助于从版本控制系统读取现有项目。'
- en: In this book, we will walk you through the first option only—using the sequence
    of guided steps provided by the IDE. Options *2* and *3* include many settings
    that are automatically set by importing an existing project that has those settings.
    Once you have learned how to create a new project from scratch, the other ways
    to bring up a project in the IDE will be very easy for you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将向您介绍第一个选项——使用 IDE 提供的引导步骤序列。选项 *2* 和 *3* 包含许多由导入具有这些设置的现有项目自动设置的设置。一旦你学会了如何从头创建新项目，IDE
    中启动项目的其他方式对你来说将会非常容易。
- en: 'Start by clicking the **New Project** link and proceed further as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先点击 **新建项目** 链接，然后按照以下步骤继续操作：
- en: Select **Maven** in the left panel and a value for **Project SDK** (Java Version
    17, if you have installed JDK 17 already), and click **Next**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择 **Maven**，并为 **项目 SDK**（如果你已经安装了 JDK 17，则为 Java 版本 17）选择一个值，然后点击 **下一步**。
- en: 'Maven is a project configuration tool whose primary function is to manage project
    dependencies. We will talk about it shortly. For now, we will use its other responsibility:
    to define and hold the project code identity using three **Artifact Coordinates**
    properties (see next).'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Maven 是一个项目配置工具，其主要功能是管理项目依赖。我们将在稍后讨论它。现在，我们将使用它的另一个职责：使用三个 **工件坐标** 属性（见下文）定义和保存项目代码身份。 '
- en: Type the project name—for example, `myproject`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称——例如，`myproject`。
- en: Select the desired project location in the **Location field** setting (this
    is where your new code will reside).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **位置字段** 设置中选择所需的项目位置（这是你的新代码将驻留的地方）。
- en: 'Click `GroupId`: This is the base package name that identifies a group of projects
    within an organization or an open source community. In our case, l et''s type
    `com.mywork`.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `GroupId`：这是标识组织内部或开源社区中一组项目的基包名。在我们的案例中，让我们输入 `com.mywork`。
- en: '`ArtifactId`: To identify a particular project within the group. Leave it as
    `myproject`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArtifactId`：用于标识组内的特定项目。将其保留为 `myproject`。'
- en: '`Version`: To identify the version of the project. Leave it as `1.0-SNAPSHOT`.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`版本`：用于标识项目的版本。将其保留为 `1.0-SNAPSHOT`。'
- en: The main goal is to make the identity of a project unique among all projects
    in the world. To help avoid a `GroupId` clash, the convention requires that you
    start building it from the organization domain name in reverse. For example, if
    a company has a `company.com` domain name, the `GroupId` properties of its projects
    should start with `com.company`. That is why for this demonstration we use `com.mywork`,
    and for the code in this book, we use the `com.packt.learnjava` `GroupID` value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是使项目的身份在世界所有项目中独一无二。为了避免 `GroupId` 冲突，约定要求你从组织域名反向开始构建。例如，如果一家公司有一个 `company.com`
    域名，其项目的 `GroupId` 属性应该以 `com.company` 开头。这就是为什么在这个演示中我们使用 `com.mywork`，而在本书中的代码，我们使用
    `com.packt.learnjava` 的 `GroupID` 值。
- en: Click **Finish**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成**。
- en: 'You will see the following project structure and generated `pom.xml` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下项目结构和生成的 `pom.xml` 文件：
- en: '![](img/B18388_Figure_1.2.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.2.jpg)'
- en: Now, if somebody would like to use the code of your project in their application,
    they would refer to it by the three values shown, and Maven (if they use it) will
    bring it in (if you upload your project to the publicly shared Maven repository,
    of course). Read more about Maven at [https://maven.apache.org/guides](https://maven.apache.org/guides).
    Another function of the `GroupId` value is to define the root directory of the
    folders tree that holds your project code. The `java` folder under `main` will
    hold the application code, while the `java` folder under `test` will hold the
    test code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人想在他们的应用程序中使用你的项目代码，他们将通过显示的三个值来引用它，并且 Maven（如果他们使用它）将把它引入（当然，如果你将你的项目上传到公开共享的
    Maven 仓库的话）。有关 Maven 的更多信息，请参阅 [https://maven.apache.org/guides](https://maven.apache.org/guides)。`GroupId`
    值的另一个功能是定义包含你的项目代码的文件夹树根目录。`main` 下的 `java` 文件夹将包含应用程序代码，而 `test` 下的 `java` 文件夹将包含测试代码。
- en: 'Let’s create our first program using the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建我们的第一个程序：
- en: 'Right-click on `java`, select **New**, and then click **Package**, as illustrated
    in the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `java`，选择 **新建**，然后点击 **包**，如图所示：
- en: '![](img/B18388_Figure_1.3.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.3.jpg)'
- en: In the `com.mywork.myproject` and press *Enter*.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.mywork.myproject` 中按下 *Enter*。
- en: 'You should see in the left panel the following set of new folders:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在左侧面板中看到以下一组新文件夹：
- en: '![](img/B18388_Figure_1.4.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.4.jpg)'
- en: 'Right-click on `com.mywork.myproject`, select **New**, and then click **Java
    Class**, as illustrated in the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`com.mywork.myproject`，选择**新建**，然后点击**Java类**，如下面的截图所示：
- en: '![](img/B18388_Figure_1.5.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.5.jpg)'
- en: In the input window provided, type `HelloWorld`, as follows:![](img/B18388_Figure_1.6.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的输入窗口中，键入`HelloWorld`，如下所示：![](img/B18388_Figure_1.6.jpg)
- en: 'Press *Enter* and you will see your first Java class, `HelloWorld`, created
    in the `com.mywork.myproject` package, as illustrated in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*键，您将看到在`com.mywork.myproject`包中创建的第一个Java类`HelloWorld`，如下面的截图所示：
- en: '![](img/B18388_Figure_1.7.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.7.jpg)'
- en: 'The package reflects the Java class location in the filesystem. We will talk
    about this more in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java
    Object-Oriented Programming (OOP)*. Now, in order to run a program, we create
    a `main()` method. If present, this method can be executed to serve as an entry
    point into the application. It has a certain format, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该包反映了Java类在文件系统中的位置。我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中更详细地讨论这一点。现在，为了运行一个程序，我们创建一个`main()`方法。如果存在，此方法可以被执行，作为进入应用程序的入口点。它具有特定的格式，如下所示：
- en: '![](img/B18388_Figure_1.8.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.8.jpg)'
- en: 'This has to have the following attributes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须具有以下属性：
- en: '`public`: Freely accessible from outside the package'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：可以从包外部自由访问'
- en: '`static`: Should be able to be called without creating an object of the class
    it belongs to'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`：应该能够在不创建它所属的类对象的情况下调用'
- en: 'It should also have the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它还应该有以下内容：
- en: Return `void` (nothing)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`void`（无）
- en: Accept a `String` array as an input, or `varargs`, as we have done. We will
    talk about `varargs` in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. For now, suffice to say that `String[]
    args` and `String... args` essentially define the same input format.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个`String`数组作为输入，或者`varargs`，正如我们所做的那样。我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中讨论`varargs`。现在，只需说`String[]
    args`和`String... args`基本上定义了相同的输入格式。
- en: We explain how to run the `main` class using a command line in the *Executing
    examples from the command line* section. You can read more about Java command-line
    arguments in the official Oracle documentation at [https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html](https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html).
    It is also possible to run the examples from IntelliJ IDEA.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用命令行执行示例*部分，我们解释了如何使用命令行运行`main`类。您可以在官方Oracle文档中了解更多关于Java命令行参数的信息：[https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html](https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html)。您也可以从IntelliJ
    IDEA中运行这些示例。
- en: Notice the two green triangles to the left in the screenshot shown next. By
    clicking any of them, you can execute the `main()` method. For example, let’s
    display `Hello, world!`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意下一张截图左侧的两个绿色三角形。通过单击其中的任何一个，您可以执行`main()`方法。例如，让我们显示`Hello, world!`。
- en: 'In order to do this, type the following line inside the `main()` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请在`main()`方法中键入以下行：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows how the program should look afterward:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序运行后的样子：
- en: '![](img/B18388_Figure_1.9.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.9.jpg)'
- en: 'Then, click one of the green triangles, and you should get the following output
    in the Terminal area:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击一个绿色三角形，您应该在终端区域得到以下输出：
- en: '![](img/B18388_Figure_1.10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.10.jpg)'
- en: 'From now on, every time we are going to discuss code examples, we will run
    them the same way, by using the `main()` method. While doing this, we will not
    capture a screenshot but put the result in comments, because such a style is easier
    to follow. For example, the following code snippet displays how the previous code
    demonstration would look in this style:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们将讨论代码示例时，我们都会以相同的方式运行它们，即使用`main()`方法。在这样做的时候，我们不会捕获截图，而是将结果放在注释中，因为这种风格更容易跟随。例如，以下代码片段显示了之前的代码演示将以这种方式看起来：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is possible to add a comment (any text) to the right of the code line separated
    by a double slash `//`. The compiler does not read this text and just keeps it
    as it is. The presence of a comment does not affect performance and is used to
    explain the programmer’s intent to humans.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在代码行的右侧添加注释（任何文本），用双斜杠`//`分隔。编译器不会读取此文本，只是将其保持原样。注释的存在不会影响性能，并且用于向人类解释程序员的意图。
- en: Importing a project
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入项目
- en: We are going to demonstrate project importing using the source code for this
    book. We assume that you have Maven installed ([https://maven.apache.org/install.html](https://maven.apache.org/install.html))
    on your computer and that you have Git ([https://gist.github.com/derhuerst/1b15ff4652a867391f03](https://gist.github.com/derhuerst/1b15ff4652a867391f03))
    installed too, and can use it. We also assume that you have installed JDK 17,
    as was described in the *Installing Java SE* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本书的源代码演示项目导入。我们假设您已在计算机上安装了Maven([https://maven.apache.org/install.html](https://maven.apache.org/install.html))和Git([https://gist.github.com/derhuerst/1b15ff4652a867391f03](https://gist.github.com/derhuerst/1b15ff4652a867391f03))，并且可以使用它们。我们还假设您已安装了JDK
    17，正如在*安装Java SE*部分所述。
- en: 'To import the project with the code examples for this book, follow these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入本书的代码示例项目，请按照以下步骤操作：
- en: Go to the source repository ([https://github.com/PacktPublishing/Learn-Java-17-Programming](https://github.com/PacktPublishing/Learn-Java-17-Programming))
    and click the **Code** drop-down menu, as shown in the following screenshot:![](img/B18388_Figure_1.11.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往源代码库([https://github.com/PacktPublishing/Learn-Java-17-Programming](https://github.com/PacktPublishing/Learn-Java-17-Programming))，点击**代码**下拉菜单，如图所示![图片](img/B18388_Figure_1.11.jpg)
- en: 'Copy the provided **Uniform Resource Locator** (**URL**) (click the *copy*
    symbol to the right of the URL), as illustrated in the following screenshot:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制提供的**统一资源定位符**（**URL**）（点击URL右侧的*复制*符号），如图所示：
- en: '![](img/B18388_Figure_1.12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.12.jpg)'
- en: 'Select a directory on your computer where you would like the source code to
    be placed and then run the `git clone https://github.com/PacktPublishing/Learn-Java-17-Programming.git`
    Git command and observe similar output to that shown in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您希望在计算机上放置源代码的目录，然后运行`git clone https://github.com/PacktPublishing/Learn-Java-17-Programming.git`
    Git命令，并观察以下截图所示的类似输出：
- en: '![](img/B18388_Figure_1.13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.13.jpg)'
- en: A new `Learn-Java-17-Programming` folder is created.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个新的`Learn-Java-17-Programming`文件夹。
- en: Alternatively, instead of cloning, you can download the source as a `.zip` file
    using the `Download ZIP` link shown in the screenshot just before. Unarchive the
    downloaded source in a directory on your computer where you would like the source
    code to be placed, and then rename the newly created folder by removing the `-master`
    suffix from its name, making sure that the folder’s name is `Learn-Java-17-Programming`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以选择不克隆，而是使用截图所示的前一个“下载ZIP”链接下载源代码作为`.zip`文件。在您希望在计算机上放置源代码的目录中解压缩下载的源代码，然后通过从其名称中移除`-master`后缀来重命名新创建的文件夹，确保文件夹的名称为`Learn-Java-17-Programming`。
- en: The new `Learn-Java-17-Programming` folder contains the Maven project with all
    the source code from this book. If you prefer, you can rename this folder however
    you like. In our case, we renamed it `LearnJava` for brevity.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`Learn-Java-17-Programming`文件夹包含本书的所有源代码。如果您愿意，可以随意重命名此文件夹。在我们的例子中，我们将其重命名为`LearnJava`以简化。
- en: Now, run IntelliJ IDEA and click `LearnJava`, in our case), then click the **Open**
    button.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行IntelliJ IDEA，点击`LearnJava`（在我们的例子中），然后点击**打开**按钮。
- en: 'If the following popup shows in the bottom-right corner, click **Load**:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在右下角出现以下弹出窗口，请点击**加载**：
- en: '![](img/B18388_Figure_1.14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.14.jpg)'
- en: 'Also, click **Trust project...**, as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，点击**信任项目...**，如图所示：
- en: '![](img/B18388_Figure_1.15.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.15.jpg)'
- en: Then, click the **Trust Project** button on the following popup:![](img/B18388_Figure_1.16.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击弹出的窗口中的**信任项目**按钮![图片](img/B18388_Figure_1.16.jpg)
- en: 'Now, go to **Project Structure** (cogwheel symbol in the upper-right corner)
    and make sure that Java 17 is selected as an SDK, as shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到**项目结构**（右上角的齿轮符号）并确保已选择Java 17作为SDK，如图所示：
- en: '![](img/B18388_Figure_1.17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.17.jpg)'
- en: Click **Apply** and make sure that the default **Project SDK** is set to Java
    **version 17** and **Project language level** is set to **17**, as in the following
    screenshot:![](img/B18388_Figure_1.18.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**并确保默认的**项目SDK**设置为Java **版本 17**，**项目语言级别**设置为**17**，如图所示![图片](img/B18388_Figure_1.18.jpg)
- en: 'Click `LearnJava` module by selecting it and clicking `"-"`, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`LearnJava`模块并点击“-”，如下所示：
- en: '![](img/B18388_Figure_1.19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.19.jpg)'
- en: 'Confirm the `LearnJava` module removal on the popup by clicking **Yes**, as
    follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中通过点击**是**确认移除`LearnJava`模块，如下所示：
- en: '![](img/B18388_Figure_1.20.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.20.jpg)'
- en: Here's how the final list of modules should look:![](img/B18388_Figure_1.21.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终模块列表应如下所示![图片](img/B18388_Figure_1.21.jpg)
- en: 'Click **OK** in the bottom-right corner and get back to your project. Click
    examples in the left pane and continue going down the source tree until you see
    the following list of classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角点击**确定**按钮，然后返回到您的项目。在左侧面板中点击examples，继续向下查看源树，直到您看到以下类列表：
- en: '![](img/B18388_Figure_1.22.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.22.jpg)'
- en: 'Click on the green arrow in the right pane and execute the `main()` method
    of any class you want. For example, let’s execute the `main()` method of the `PrimitiveTypes`
    class. The result you will be able to see in the **Run** window should be similar
    to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧面板中点击绿色箭头并执行任何类中的`main()`方法。例如，让我们执行`PrimitiveTypes`类的`main()`方法。您将在**运行**窗口中看到的输出应该类似于以下内容：
- en: '![](img/B18388_Figure_1.23.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.23.jpg)'
- en: Executing examples from the command line
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行执行示例
- en: 'To execute the examples from the command line, go to the `examples` folder,
    where the `pom.xml` file is located, and run the `mvn clean package` command.
    If the command is executed successfully, you can run any `main()` method in any
    of the programs in the `examples` folder from the command line. For example, to
    execute the `main()` method in the `ControlFlow.java` file, run the following
    command as one line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行执行示例，请转到包含`pom.xml`文件的`examples`文件夹，并运行`mvn clean package`命令。如果命令执行成功，您可以从命令行运行`examples`文件夹中任何程序的`main()`方法。例如，要执行`ControlFlow.java`文件中的`main()`方法，请按以下命令执行：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see the following results:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下结果：
- en: '![](img/B18388_Figure_1.24.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_1.24.jpg)'
- en: This way, you can run any class that has the `main()` method in it. The content
    of the `main()` method will be executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以运行任何包含`main()`方法的类。`main()`方法的内容将被执行。
- en: Java primitive types and operators
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java原始类型和运算符
- en: With all the main programming tools in place, we can start talking about Java
    as a language. The language syntax is defined by the *Java Language Specification*,
    which you can find at [https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs).
    Don’t hesitate to refer to it every time you need some clarification—it is not
    as daunting as many people assume.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有主要的编程工具都已就绪的情况下，我们可以开始讨论Java作为一种语言。该语言的语法由**Java语言规范**定义，您可以在[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)找到它。不要犹豫，每次需要澄清时都参考它——它并不像许多人想象的那样令人畏惧。
- en: 'All the values in Java are divided into two categories: reference types and
    primitive types. We start with primitive types and operators as the natural entry
    point to any programming language. In this chapter, we will also discuss one reference
    type called `String` (see the *String types and literals* section).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有值分为两类：引用类型和原始类型。我们以原始类型和运算符作为任何编程语言的自然入口点。在本章中，我们还将讨论一个名为`String`的引用类型（见**String类型和字面量**部分）。
- en: 'All primitive types can be divided into two groups: Boolean types and numeric
    types.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始类型可以分为两组：布尔类型和数值类型。
- en: Boolean types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'There are only two Boolean type values in Java: `true` and `false`. Such a
    value can only be assigned to a variable of a `boolean` type, as in the following
    example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Java中只有两个布尔类型值：`true`和`false`。这样的值只能分配给`boolean`类型的变量，如下例所示：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `boolean` variable is typically used in control flow statements, which we
    are going to discuss in the *Java statements* section. Here is one example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`类型的变量通常用于控制流语句中，我们将在**Java语句**部分讨论这些。以下是一个例子：'
- en: '[PRE8]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we assign to the `b` variable the result of the evaluation
    of the `x > 2` expression. If the value of `x` is greater than `2`, the `b` variable
    gets the assigned value, `true`. Then, the code inside the braces (`{}`) is executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`x > 2`表达式的评估结果赋值给`b`变量。如果`x`的值大于`2`，则`b`变量将获得分配的值，`true`。然后，花括号`{}`内的代码将被执行。
- en: Numeric types
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'Java numeric types form two groups: integral types (`byte`, `char`, `short`,
    `int`, and `long`) and floating-point types (`float` and `double`).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java数值类型分为两组：整数类型（`byte`、`char`、`short`、`int`和`long`）和浮点类型（`float`和`double`）。
- en: Integral types
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'Integral types consume the following amount of memory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型消耗以下内存量：
- en: '`byte`: 8 bits'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`: 8位'
- en: '`char`: 16 bits'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`: 16位'
- en: '`short`: 16 bits'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`: 16位'
- en: '`int`: 32 bits'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 32位'
- en: '`long`: 64 bits'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`: 64位'
- en: 'The `char` type is an unsigned integer that can hold a value (called a code
    point) from 0 to 65,535 inclusive. It represents a Unicode character, which means
    there are 65,536 Unicode characters. Here are three records from the basic Latin
    list of Unicode characters:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型是一个无符号整数，可以存储一个值（称为码点），范围从0到65,535（包含）。它表示一个Unicode字符，这意味着有65,536个Unicode字符。以下是基本拉丁字符集的三个记录：'
- en: '![](img/B18388_Table_1.1.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Table_1.1.jpg)'
- en: 'The following code demonstrates the properties of the `char` type (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `charType()` method):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`char`类型的属性（执行`com.packt.learnjava.ch01_start.PrimitiveTypes`类的`main()`方法——查看`charType()`方法）：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last two lines from the preceding code example explain why the `char` type
    is considered an integral type because `char` values can be used in arithmetic
    operations. In such a case, each `char` value is represented by its code point.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码示例的最后两行解释了为什么`char`类型被认为是整型，因为`char`值可以用于算术运算。在这种情况下，每个`char`值由其码点表示。
- en: 'The range of values of other integral types is shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其他整型的值范围如下所示：
- en: '`byte`: from -128 to 127 inclusive'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`: 从 -128 到 127（包含）'
- en: '`short`: from -32,768 to 32,767 inclusive'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`: 从 -32,768 到 32,767（包含）'
- en: '`int`: from -2.147.483.648 to 2.147.483.647 inclusive'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 从 -2,147,483,648 到 2,147,483,647（包含）'
- en: '`long`: from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`: 从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（包含）'
- en: 'You can always retrieve the maximum and minimum value of each primitive type
    from a corresponding Java constant, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see the `minMax()` method):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从相应的Java常量中检索到每种原始类型的最大和最小值，如下所示（执行`com.packt.learnjava.ch01_start.PrimitiveTypes`类的`main()`方法——查看`minMax()`方法）：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The construct (`int`) in the last two lines is an example of cast operator usage.
    It forces the conversion of a value from one type to another in cases where such
    a conversion is not always guaranteed to be successful. As you can see from our
    examples, some types allow bigger values than other types. But a programmer may
    know that the value of a certain variable can never exceed the maximum value of
    the target type, and the cast operator is the way the programmer can force their
    opinion on the compiler. Otherwise, without a cast operator, the compiler would
    raise an error and would not allow the assignment. However, the programmer may
    be mistaken and the value may become bigger. In such a case, a runtime error will
    be raised during execution time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行中的构造（`int`）是使用类型转换运算符的示例。它强制将一个值从一种类型转换为另一种类型，在这种情况下，这种转换并不总是保证成功。正如您从我们的示例中看到的那样，某些类型允许比其他类型更大的值。但是，程序员可能知道某个变量的值永远不会超过目标类型的最大值，类型转换运算符是程序员强制其意见于编译器的方式。否则，如果没有类型转换运算符，编译器将引发错误，不允许赋值。然而，程序员可能会犯错误，值可能会变得更大。在这种情况下，执行时将引发运行时错误。
- en: There are types that, in principle, cannot be cast to other types, though, or
    at least not to all types—for example, a Boolean type value cannot be cast to
    an integral type value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原则上某些类型不能转换为其他类型，或者至少不能转换为所有类型——例如，布尔类型值不能转换为整型值。
- en: Floating-point types
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'There are two types in this group of primitive types—`float` and `double`.
    These consume the following amount of memory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原始类型组中有两种类型——`float`和`double`。它们消耗以下内存量：
- en: '`float`: 32 bit'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`: 32位'
- en: '`double`: 64 bit'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`: 64位'
- en: 'Their positive maximum and minimum possible values are shown here (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `minMax()` method):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的正最大和最小可能值如下所示（执行`com.packt.learnjava.ch01_start.PrimitiveTypes`类的`main()`方法——查看`minMax()`方法）：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The maximum and minimum negative values are the same as those just shown, only
    with a minus sign (`-`) in front of them. So, effectively, the `Float.MIN_VALUE`
    and `Double.MIN_VALUE` values are not the minimal values, but the precision of
    the corresponding type. A zero value can be either 0.0 or -0.0 for each of the
    floating-point types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最大和最小的负值与上面显示的相同，只是在它们前面有一个负号（`-`）。因此，实际上，`Float.MIN_VALUE`和`Double.MIN_VALUE`的值不是最小值，而是相应类型的精度。对于每个浮点类型，零值可以是0.0或-0.0。
- en: 'A special feature of the floating-point type is the presence of a dot (`.`)
    that separates integer and fractional parts of the number. By default, in Java,
    a number with a dot is assumed to be a `double` type. For example, the following
    is assumed to be a `double` value:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的一个特殊特性是存在一个点 (`.`)，它将数字的整数部分和小数部分分开。在 Java 中，默认情况下，带点的数字被认为是 `double` 类型。例如，以下被认为是
    `double` 值：
- en: '`42.3`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`42.3`'
- en: 'This means that the following assignment causes a compilation error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下赋值会导致编译错误：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To indicate that you would like it to be treated as a `float` type, you need
    to add either `f` or `F`. For example, the following assignments do not cause
    an error (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `casting()` method):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示您希望将其视为 `float` 类型，您需要添加 `f` 或 `F`。例如，以下赋值不会导致错误（执行 `com.packt.learnjava.ch01_start.PrimitiveTypes`
    类的 `main()` 方法——请参阅 `casting()` 方法）：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you may have noticed from the preceding example, `d` and `D` indicate a `double`
    type, but we were able to cast them to the `float` type because we are confident
    that `42.3` is well inside the range of possible `float`-type values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已从前面的示例中注意到，`d` 和 `D` 表示 `double` 类型，但我们能够将它们转换为 `float` 类型，因为我们确信 `42.3`
    在可能的 `float` 类型值范围内。
- en: Default values of primitive types
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型的默认值
- en: 'In some cases, a variable has to be assigned a value even when a programmer
    did not want to do that. We will talk about such cases in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. The default primitive type value in
    such cases is outlined here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，即使程序员不希望这样做，变量也必须被赋予一个值。我们将在 [*第 2 章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java
    面向对象编程 (OOP)* 中讨论此类情况。在这种情况下，原始类型的默认值如下概述：
- en: '`byte`, `short`, `int`, and `long` types have a default value of 0.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`, `short`, `int`, 和 `long` 类型具有默认值 0。'
- en: The `char` type has a default value of `\u0000`, with the code point 0\.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 类型具有默认值 `\u0000`，代码点为 0。'
- en: '`float` and `double` types have a default value of 0.0.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 类型具有默认值 0.0。'
- en: The `boolean` type has a default value of `false`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean` 类型具有默认值 `false`。'
- en: Literals of primitive types
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型字面量
- en: 'The representation of a value is called a literal. The `boolean` type has two
    literals: `true` and `false`. Literals of `byte`, `short`, `int`, and `long` integral
    types have an `int` type by default, as illustrated here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 值的表示称为字面量。`boolean` 类型有两个字面量：`true` 和 `false`。`byte`、`short`、`int` 和 `long`
    整数类型的字面量默认为 `int` 类型，如下所示：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In addition, to indicate a literal of a `long` type, you can append the letter
    `l` or `L` to the end, like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了表示 `long` 类型的字面量，您可以在末尾附加字母 `l` 或 `L`，如下所示：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The letter `l` can be easily confused with the number `1`, so using `L` (instead
    of `l`) for this purpose is a good practice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 `l` 容易与数字 `1` 混淆，因此使用 `L`（而不是 `l`）来表示此目的是一种良好的做法。
- en: 'So far, we have expressed integral literals in a decimal number system. Meanwhile,
    literals of `byte`, `short`, `int`, and `long` types can also be expressed in
    binary (base 2, digits 0-1), octal (base 8, digits 0-7), and hexadecimal (base
    16, digits 0-9, and a-f) number systems. A binary literal starts with 0b (or 0B),
    followed by the value expressed in a binary system. For example, the decimal 42
    is expressed as 101010 = 2^0*0 + 2^1*1 + 2^2*0 + 2^3 *1 + 2^4 *0 + 2^5 *1 (we
    start from the right 0). An octal literal starts with 0, followed by the value
    expressed in an octal system, so 42 is expressed as 52 = 8^0*2+ 8^1*5\. A hexadecimal
    literal starts with 0x (or with 0X), followed by a value expressed in a hexadecimal
    system. So, 42 is expressed as 2a = 16^0*a + 16^1*2 because, in the hexadecimal
    system, the symbols `a` to `f` (or `A` to `F`) map to the decimal values 10 to
    15\. Here is the demonstration code (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `literals()` method):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用十进制数系统表示整数字面量。同时，`byte`、`short`、`int` 和 `long` 类型的字面量也可以用二进制（基数为
    2，数字为 0-1）、八进制（基数为 8，数字为 0-7）和十六进制（基数为 16，数字为 0-9 和 a-f）数制表示。二进制字面量以 0b（或 0B）开头，后跟用二进制系统表示的值。例如，十进制的
    42 表示为 101010 = 2^0*0 + 2^1*1 + 2^2*0 + 2^3 *1 + 2^4 *0 + 2^5 *1（我们从右边开始计数 0）。八进制字面量以
    0 开头，后跟用八进制系统表示的值，因此 42 表示为 52 = 8^0*2+ 8^1*5。十六进制字面量以 0x（或 0X）开头，后跟用十六进制系统表示的值。因此，42
    表示为 2a = 16^0*a + 16^1*2，因为在十六进制系统中，符号 `a` 到 `f`（或 `A` 到 `F`）映射到十进制值 10 到 15。以下为演示代码（执行
    `com.packt.learnjava.ch01_start.PrimitiveTypes` 类的 `main()` 方法——请参阅 `literals()`
    方法）：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, Java provides methods that convert decimal system values to
    systems with different bases. All these expressions of numeric values are called
    literals.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Java 提供了将十进制系统值转换为不同基数的系统的方法。所有这些数值表达都称为字面量。
- en: 'One feature of numeric literals makes them human-friendly. If the number is
    large, it is possible to break it into triples separated by an underscore (`_`)
    sign. Observe the following, for example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 数值字面量的一项特性使它们对人类友好。如果数字很大，可以将其分成由下划线（`_`）分隔的三部分。例如，观察以下内容：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The compiler ignores an embedded underscore sign.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器忽略嵌入的下划线符号。
- en: 'The `char` type has two kinds of literals: a single character or an escape
    sequence. We have seen examples of `char`-type literals when discussing numeric
    types, and you can see some others here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型有两种字面量：单个字符或转义序列。我们在讨论数值类型时已经看到了 `char` 类型的字面量示例，您还可以在此处看到一些其他示例：'
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, the character has to be enclosed in single quotes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字符必须用单引号括起来。
- en: 'An escape sequence starts with a backslash (`\`) followed by a letter or another
    character. Here is a full list of escape sequences:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 转义序列以反斜杠（`\`）开头，后跟字母或另一个字符。以下是一个完整的转义序列列表：
- en: '`\`b: backspace BS, Unicode escape `\u0008`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`: 退格 BS，Unicode 转义 `\u0008`'
- en: '\t: horizontal tab HT, Unicode escape `\u0009`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`: 水平制表符 HT，Unicode 转义 `\u0009`'
- en: '\n: line feed LF, Unicode escape `\u000a`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`: 换行 LF，Unicode 转义 `\u000a`'
- en: '\f: form feed FF, Unicode escape `\u000c`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\f`: 页面分隔 FF，Unicode 转义 `\u000c`'
- en: '\r: carriage return CR, Unicode escape `\u000d`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`: 回车 CR，Unicode 转义 `\u000d`'
- en: '\”: double quote “, Unicode escape `\u0022`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`: 双引号 “，Unicode 转义 `\u0022`'
- en: '\’: single quote ‘, Unicode escape `\u0027`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\‘`: 单引号 ‘，Unicode 转义 `\u0027`'
- en: '\\: backslash \, Unicode escape `\u005c`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`: 反斜杠 \，Unicode 转义 `\u005c`'
- en: 'From the eight escape sequences, only the last three are represented by a symbol.
    They are used when this symbol cannot be otherwise displayed. Observe the following,
    for example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在八个转义序列中，只有最后三个由符号表示。它们在无法以其他方式显示此符号时使用。例如，观察以下内容：
- en: '[PRE79]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The rest are used more as control codes that direct the output device to do
    something, as in the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的更多用作控制代码，指导输出设备执行某些操作，如下例所示：
- en: '[PRE82]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, `\b` deletes a previous symbol, `\t` inserts a tab space, `\n`
    breaks the line and begins the new one, `\f` forces the printer to eject the current
    page and to continue printing at the top of another, and `\r` starts the current
    line anew.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`\b` 删除前一个符号，`\t` 插入制表符空格，`\n` 换行并开始新的一行，`\f` 强制打印机退出当前页面并在另一页顶部继续打印，而
    `\r` 则从当前行的开头开始。
- en: New compact number format
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的紧凑数字格式
- en: The `java.text.NumberFormat` class presents numbers in various formats. It also
    allows formats to be adjusted to those provided, including locales. A new feature
    added to this class in Java 12 is called a compact or short number format.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.text.NumberFormat` 类以各种格式呈现数字。它还允许调整格式以适应提供的格式，包括区域设置。Java 12 中添加到此类的新功能称为紧凑或短数字格式。'
- en: 'It represents a number in a locale-specific, human-readable form. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `newNumberFormat()` method):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 它以区域特定、人类可读的形式表示数字。例如，观察以下内容（执行 `com.packt.learnjava.ch01_start.PrimitiveTypes`
    类的 `main()` 方法——见 `newNumberFormat()` 方法）：
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, to access this capability, you have to acquire a particular
    instance of the `NumberFormat` class, sometimes based on the locale and style
    provided.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要访问此功能，您必须获取 `NumberFormat` 类的特定实例，有时基于提供的区域设置和样式。
- en: Operators
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: 'There are 44 operators in Java. These are listed in the following table:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中有 44 个运算符。以下表格列出了它们：
- en: '![](img/B18388_Table_1.2.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Table_1.2.jpg)'
- en: We will not describe the not-often-used `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`
    assignment operators and bitwise operators, but you can read about them in the
    Java specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Arrow ( `->`) and method reference (`::`) operators will be described in [*Chapter
    14*](B18388_14_ePub.xhtml#_idTextAnchor296), *Java Standard Streams*. The `new`
    instance creation operator, the `.` field access/method invocation operator, and
    the `instanceof` type comparison operator will be discussed in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. As for the cast operator, we have already
    described it in the *Integral types* section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会描述不常使用的 `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=` 赋值运算符和位运算符，但你可以在 Java 规范中阅读有关它们的内容（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。箭头（`->`）和方法引用（`::`）运算符将在
    [*第 14 章*](B18388_14_ePub.xhtml#_idTextAnchor296)，*Java 标准流* 中描述。`new` 实例创建运算符、`.`
    字段访问/方法调用运算符和 `instanceof` 类型比较运算符将在 [*第 2 章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java
    面向对象编程 (OOP)* 中讨论。至于类型转换运算符，我们已经在 *整型* 部分中描述过。
- en: Arithmetic unary (+ and -) and binary (+, -, *, /, and %) operators
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术一元（+ 和 -）和二元（+、-、*、/ 和%）运算符
- en: 'Most of the arithmetic operators and positive and negative signs (unary operators)
    are quite familiar to us. The modulus operator (`%`) divides the left-hand operand
    by the right-hand operand and returns the remainder, as follows (execute the `main()`
    method of the `com.packt.learnjava.ch01_start.Operators` class—see the `integerDivision()`
    method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算术运算符和正负号（一元运算符）对我们来说都很熟悉。取模运算符（`%`）将左操作数除以右操作数并返回余数，如下所示（执行 `com.packt.learnjava.ch01_start.Operators`
    类的 `main()` 方法——见 `integerDivision()` 方法）：
- en: '[PRE96]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It is also worth mentioning that the division of two integer numbers in Java
    loses the fractional part because Java assumes the result should be an integer
    number `2`, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Java 中两个整数相除会丢失分数部分，因为 Java 假设结果应该是一个整数数字 `2`，如下所示：
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you need the fractional part of the result to be preserved, convert one
    of the operands into a floating-point type. Here are a few ways (among many) in
    which to do this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要保留结果的分数部分，将其中一个操作数转换为浮点类型。这里有几种方法（许多方法中的一种）可以实现这一点：
- en: '[PRE100]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Increment and decrement unary operators (++ and --)
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量和减量一元运算符（++ 和 --）
- en: 'The `++` operator increases the value of an integral type by 1, while the `--`
    operator decreases it by 1\. If placed before the variable (prefix), it changes
    its value by 1 before the variable value is returned. But when placed after the
    variable (postfix), it changes its value by 1 after the variable value is returned.
    Here are a few examples (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `incrementDecrement()` method):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 运算符将整型值增加 1，而 `--` 运算符将其减少 1。如果放在变量之前（前缀），则在返回变量值之前改变其值。但如果是放在变量之后（后缀），则在返回变量值之后改变其值。以下是一些示例（执行
    `com.packt.learnjava.ch01_start.Operators` 类的 `main()` 方法——见 `incrementDecrement()`
    方法）：'
- en: '[PRE105]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Equality operators (== and !=)
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等于运算符（== 和 !=）
- en: 'The `==` operator means equals, while the `!=` operator means not equals. They
    are used to compare values of the same type and return a `true` Boolean value
    if the operand’s values are `equal`, or `false` otherwise. Observe the following,
    for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`,
    class—see the `equality()` method):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 运算符表示等于，而 `!=` 运算符表示不等于。它们用于比较相同类型的值，如果操作数的值相等，则返回 `true` 布尔值，否则返回 `false`。例如，观察以下内容（执行
    `com.packt.learnjava.ch01_start.Operators` 类的 `main()` 方法——见 `equality()` 方法）：'
- en: '[PRE114]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Exercise caution, though, while comparing values of floating-point types, especially
    when you compare the results of calculations. Using relational operators (`<`,
    `>`, `<=`, and `>=`) in such cases is much more reliable, because calculations
    such as 1/3—for example—result in a never-ending fractional part 0.33333333...
    and ultimately depend on precision implementation (a complex topic that is beyond
    the scope of this book).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在比较浮点类型值时，要小心谨慎，尤其是在比较计算结果时。在这种情况下使用关系运算符（`<`、`>`、`<=` 和 `>=`）要更可靠，因为像 1/3
    这样的计算会产生一个永不结束的分数部分 0.33333333...，并且最终取决于精度实现（这是一个超出本书范围的主题）。
- en: Relational operators (<, >, <=, and >=)
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系运算符（<、>、<= 和 >=）
- en: 'Relational operators compare values and return a Boolean value. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `relational()` method):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符比较值并返回一个布尔值。观察以下示例，例如（执行 `com.packt.learnjava.ch01_start.Operators` 类的
    `main()` 方法——见 `relational()` 方法）：
- en: '[PRE120]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Logical operators (!, &, and |)
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑操作符（!、& 和 |）
- en: 'Logical operators can be defined as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑操作符可以定义为如下：
- en: The `!` binary operator returns `true` if the operand is `false`; otherwise,
    it returns `false`.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` 二进制操作符如果操作数是 `false` 则返回 `true`；否则返回 `false`。'
- en: The `&` binary operator returns `true` if both of the operands are `true`.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&` 二进制操作符如果两个操作数都是 `true` 则返回 `true`。'
- en: The `|` binary operator returns `true` if at least one of the operands is `true`.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|` 二进制操作符如果至少有一个操作数是 `true` 则返回 `true`。'
- en: 'Here is an example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `logical()` method):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例（执行 `com.packt.learnjava.ch01_start.Operators` 类的 `main()` 方法——见 `logical()`
    方法）：
- en: '[PRE130]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Conditional operators (&&, ||, and ? :)
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '条件操作符（&&、|| 和 ? :) '
- en: 'The `&&` and `||` operators produce the same results as the `&` and `|` logical
    operators we have just demonstrated, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.Operators` class—see the `conditional()` method):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 和 `||` 操作符产生与刚刚演示的 `&` 和 `|` 逻辑操作符相同的结果，如下所示（执行 `com.packt.learnjava.ch01_start.Operators`
    类的 `main()` 方法——见 `conditional()` 方法）：'
- en: '[PRE139]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The difference is that the `&&` and `||` operators do not always evaluate the
    second operand. For example, in the case of the `&&` operator, if the first operand
    is `false`, the second operand is not evaluated because the result of the whole
    expression will be `false` anyway. Similarly, in the case of the `||` operator,
    if the first operand is `true`, the whole expression will be clearly evaluated
    to `true` without evaluating the second operand. We can demonstrate this in the
    following code snippet:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于 `&&` 和 `||` 操作符并不总是评估第二个操作数。例如，在 `&&` 操作符的情况下，如果第一个操作数是 `false`，则不会评估第二个操作数，因为整个表达式的结果无论如何都将为
    `false`。同样，在 `||` 操作符的情况下，如果第一个操作数是 `true`，则整个表达式将明确地评估为 `true`，而无需评估第二个操作数。我们可以在以下代码片段中演示这一点：
- en: '[PRE146]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `? :` operator is called a ternary operator. It evaluates a condition (before
    the `?` sign), and if it results in `true`, assigns to a variable the value calculated
    by the first expression (between the `?` and `:` signs); otherwise, it assigns
    a value calculated by the second expression (after the `:` sign), as illustrated
    in the following code snippet:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`? :` 操作符被称为三元操作符。它评估一个条件（在 `?` 符号之前），如果结果为 `true`，则将第一个表达式（在 `?` 和 `:` 符号之间）计算出的值赋给变量；否则，将第二个表达式（在
    `:` 符号之后）计算出的值赋给变量，如下面的代码片段所示：'
- en: '[PRE151]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Assignment operators (=, +=, -=, *=, /=, and %=)
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值操作符（=、+=、-=、*=、/= 和 %=）
- en: 'The `=` operator just assigns a specified value to a variable, like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`=` 操作符只是将指定的值赋给一个变量，如下所示：'
- en: '[PRE154]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Other assignment operators calculate a new value before assigning it, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 其他赋值操作符在赋值之前计算一个新的值，如下所示：
- en: '`x += 42` assigns to `x` the result of the `x = x + 42` addition operation.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x += 42` 将 `x` 赋值为 `x = x + 42` 加法操作的结果。'
- en: '`x -= 42` assigns to `x` the result of the `x = x - 42` subtraction operation.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -= 42` 将 `x` 赋值为 `x = x - 42` 减法操作的结果。'
- en: '`x *= 42` assigns to `x` the result of the `x = x * 42` multiplication operation.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x *= 42` 将 `x` 赋值为 `x = x * 42` 乘法操作的结果。'
- en: '`x /= 42` assigns to `x` the result of the `x = x / 42` division operation.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x /= 42` 将 `x` 赋值为 `x = x / 42` 除法操作的结果。'
- en: '`x %= 42` assigns the remainder of the `x = x + x % 42` division operation.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x %= 42` 将 `x` 赋值为 `x = x + x % 42` 除法操作的余数。'
- en: 'Here is how these operators work (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `assignment()` method):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用这些操作符的（执行 `com.packt.learnjava.ch01_start.Operators` 类的 `main()` 方法——见
    `assignment()` 方法）：
- en: '[PRE155]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: String types and literals
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串类型和字面量
- en: We have just described the primitive value types of the Java language. All the
    other value types in Java belong to a category of reference types. Each reference
    type is a more complex construct than just a value. It is described by a class,
    which serves as a template for creating an object, and a memory area that contains
    values and methods (the processing code) defined in the class. An object is created
    by the `new` operator. We will talk about classes and objects in more detail in
    [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述了Java语言的原始值类型。Java中的所有其他值类型都属于引用类型类别。每个引用类型都比一个值更复杂。它由一个类描述，该类作为创建对象的模板，并包含在类中定义的值和方法（处理代码）。对象是通过`new`运算符创建的。我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中更详细地讨论类和对象。
- en: In this chapter, we will talk about one of the reference types called `String`.
    It is represented by the `java.lang.String` class, which belongs, as you can see,
    to the most foundational package of the JDK, `java.lang`. The reason we’re introducing
    the `String` class so early is that it behaves in some respects very similar to
    primitive types, despite being a reference type.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一种称为`String`的引用类型。它由`java.lang.String`类表示，正如你所看到的，它属于JDK最基础的包`java.lang`。我们之所以这么早引入`String`类，是因为它在某些方面与原始类型非常相似，尽管它是一个引用类型。
- en: A reference type is so-called because, in the code, we do not deal with values
    of this type directly. A value of a reference type is more complex than a primitive-type
    value. It is called an object and requires more complex memory allocation, so
    a reference-type variable contains a memory reference. It points (refers) to the
    memory area where the object resides, hence the name.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型之所以被称为引用类型，是因为在代码中，我们并不直接处理这种类型的值。引用类型的值比原始类型的值更复杂。它被称为对象，需要更复杂的内存分配，因此引用类型变量包含一个内存引用。它指向（引用）对象所在的内存区域，因此得名。
- en: This nature of the reference type requires particular attention when a reference-type
    variable is passed into a method as a parameter. We will discuss this in more
    detail in [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*.
    For now, we will see how `String`, being a reference type, helps to optimize memory
    usage by storing each `String` value only once.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当将引用类型变量作为参数传递给方法时，这种引用类型的特性需要特别注意。我们将在[*第3章*](B18388_03_ePub.xhtml#_idTextAnchor079)，*Java基础知识*中更详细地讨论这个问题。现在，我们将看看`String`作为引用类型，如何通过只存储每个`String`值一次来帮助优化内存使用。
- en: String literals
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: The `String` class represents character strings in Java programs. We have seen
    several such strings. We have seen `Hello, world!`, for example. That is a `String`
    literal.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类在Java程序中表示字符字符串。我们已经看到了几个这样的字符串。例如，我们看到了`Hello, world!`。这是一个`String`字面量。'
- en: 'Another example of a literal is `null`. Any reference class can refer to a
    `null` literal. It represents a reference value that does not point to any object.
    In the case of a `String` type, it looks like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量的另一个例子是`null`。任何引用类型都可以引用`null`字面量。它表示一个不指向任何对象的引用值。对于`String`类型，它看起来是这样的：
- en: '[PRE166]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'But a literal that consists of characters enclosed in double quotes (`"abc"`,
    `"123"`, and `"a42%$#"`, for example) can only be of a `String` type. In this
    respect, the `String` class, being a reference type, has something in common with
    primitive types. All `String` literals are stored in a dedicated section of memory
    called a string pool, and two literals are equally spelled to represent the same
    value from the pool (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `compareReferences()` method):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 但由双引号括起来的字面量（例如`"abc"`，`"123"`，和`"a42%$#"`）只能为`String`类型。在这方面，`String`类作为引用类型，与原始类型有共同之处。所有`String`字面量都存储在内存的一个专用部分，称为字符串池中，两个字面量如果拼写相同则表示池中的相同值（执行`com.packt.learnjava.ch01_start.StringClass`类的`main()`方法——参见`compareReferences()`方法）：
- en: '[PRE167]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The JVM authors have chosen such an implementation to avoid duplication and
    improve memory usage. The previous code examples look very much like operations
    involving primitive types, don’t they? But when a `String` object is created using
    a `new` operator, the memory for the new object is allocated outside the string
    pool, so references of two `String` objects—or any other objects, for that matter—are
    always different, as we can see here:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的作者选择了这样的实现方式以避免重复并提高内存使用率。之前的代码示例看起来非常像涉及原始类型的操作，不是吗？但是当使用`new`运算符创建`String`对象时，新对象的内存是在字符串池之外分配的，因此两个`String`对象或任何其他对象的引用总是不同的，正如我们在这里看到的：
- en: '[PRE171]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'If necessary, it is possible to move the string value created with the `new`
    operator to the string pool using the `intern()` method, like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以使用`intern()`方法将使用`new`运算符创建的字符串值移动到字符串池中，如下所示：
- en: '[PRE175]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: In the previous code snippet, the `intern()` method attempted to move the newly
    created `"abc"` value into the string pool but discovered that such a literal
    exists there already, so it reused the literal from the string pool. That is why
    the references in the last line in the preceding example are equal.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，`intern()`方法试图将新创建的`"abc"`值移动到字符串池中，但发现这样的字面量已经存在那里，因此它重用了字符串池中的字面量。这就是为什么前一个示例中最后一行的引用是相等的。
- en: 'The good news is that you probably will not need to create `String` objects
    using the `new` operator, and most Java programmers never do this. But when a
    `String` object is passed into your code as an input and you have no control over
    its origin, comparison by reference only may cause an incorrect result (if the
    strings have the same spelling but were created by the `new` operator). That is
    why, when the equality of two strings by spelling (and case) is necessary, to
    compare two literals or `String` objects, the `equals()` method is a better choice,
    as illustrated here:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你可能不需要使用`new`运算符创建`String`对象，大多数Java程序员也从不这样做。但是当`String`对象作为输入传递到你的代码中，而你无法控制其来源时，仅通过引用进行比较可能会导致错误的结果（如果字符串拼写相同但由`new`运算符创建）。这就是为什么当需要通过拼写（和大小写）比较两个字符串时，`equals()`方法是一个更好的选择，如下所示：
- en: '[PRE178]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: We will talk about the `equals()` method and other methods of the `String` class
    shortly.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快讨论`equals()`方法和`String`类的其他方法。
- en: 'Another feature that makes `String` literals and objects look like primitive
    values is that they can be added using the `+` arithmetic operator, like this
    (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `operatorAdd()` method):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使字符串字面量和对象看起来像原始值的功能是，它们可以使用`+`算术运算符进行相加，如下所示（执行`com.packt.learnjava.ch01_start.StringClass`类的`main()`方法——查看`operatorAdd()`方法）：
- en: '[PRE185]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: No other arithmetic operator can be applied to a `String` literal or an object.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 不能将其他算术运算符应用于字符串字面量或对象。
- en: 'A new `String` literal, called a text block, was introduced with Java 15\.
    It facilitates the preservation of indents and multiple lines without adding white
    spaces in quotes. For example, here is how a programmer would add indentation
    before Java 15 and use `\n` to break the line:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Java 15引入了一个新的字符串字面量，称为文本块。它便于保留缩进和换行，而不在引号中添加空白。例如，以下是程序员在Java 15之前如何添加缩进以及如何使用`\n`来换行的示例：
- en: '[PRE196]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'And here is how the same result is achieved with Java 15:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用Java 15实现相同结果的示例：
- en: '[PRE201]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: To see how it works, execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `textBlock()` method.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它是如何工作的，请执行`com.packt.learnjava.ch01_start.StringClass`类的`main()`方法——查看`textBlock()`方法。
- en: String immutability
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串不可变性
- en: Since all `String` literals can be shared, the JVM authors make sure that, once
    stored, a `String` variable cannot be changed. This helps not only avoid the problem
    of concurrent modification of the same value from different places of the code
    but also prevents unauthorized modification of a `String` value, which often represents
    a username or password.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有字符串字面量都可以共享，JVM的作者确保一旦存储，字符串变量就不能更改。这不仅有助于避免代码不同地方对同一值的并发修改问题，还能防止对字符串值（通常代表用户名或密码）的未授权修改。
- en: 'The following code looks like a `String` value modification:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码看起来像是对`String`值进行修改：
- en: '[PRE208]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'But, behind the scenes, the original `"abc"` literal remains intact. Instead,
    a few new literals were created: `"def"`, `"abcdef"`, `"123"`, and `"abcdef123"`.
    To prove this, we have executed the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在幕后，原始的`"abc"`字面量仍然保持不变。相反，创建了一些新的字面量：`"def"`、`"abcdef"`、`"123"`和`"abcdef123"`。为了证明这一点，我们执行了以下代码：
- en: '[PRE213]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: As you can see, the `r1` and `r2` variables refer to different memories, and
    the objects they refer to are spelled differently too.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`r1`和`r2`变量指向不同的内存，它们所指向的对象的拼写也不同。
- en: We will talk more about strings in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B18388_05_ePub.xhtml#_idTextAnchor121)，*字符串、输入/输出和文件*中更多地讨论字符串。
- en: IDs and variables
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDs和变量
- en: From our school days, we have an intuitive understanding of what a variable
    is. We think of it as a name that represents a value. We solve problems using
    such variables as *x* gallons of water or *n* miles of distance, and similar.
    In Java, the name of a variable is called an ID and can be constructed by certain
    rules. Using an ID, a variable can be declared (defined) and initialized.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的学校时代起，我们就对变量有一个直观的理解。我们把它看作是一个代表值的名称。我们使用像*x*加仑的水或*n*英里的距离这样的变量来解决问题，等等。在Java中，变量的名称被称为ID，可以按照某些规则构建。使用ID，可以声明（定义）并初始化变量。
- en: ID
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ID
- en: According to the *Java Language Specification* ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    an ID (a variable name) can be a sequence of Unicode characters that represent
    letters, digits 0-9, a dollar sign (`$`), or an underscore (`_`).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*Java语言规范*([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs))，ID（变量名）可以是一系列表示字母、数字0-9、美元符号（`$`）或下划线（`_`）的Unicode字符。
- en: 'Other limitations are outlined here:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 其他限制在此概述：
- en: The first symbol of an ID cannot be a digit.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID的第一个符号不能是数字。
- en: An ID cannot have the same spelling as a keyword (see the *Java keywords* section
    of [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*).
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID不能与关键字有相同的拼写（参见[*第3章*](B18388_03_ePub.xhtml#_idTextAnchor079)，*Java基础*）中的*Java关键字*部分）。
- en: It cannot be spelled as a `true` or `false` Boolean literal or as a `null` literal.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能被拼写为`true`或`false`布尔字面量，也不能被拼写为`null`字面量。
- en: And since Java 9, an ID cannot be just an underscore (`_`).
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且自从Java 9以来，ID不能只是一个下划线（`_`）。
- en: 'Here are a few unusual but legal examples of IDs:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不寻常但合法的ID示例：
- en: '[PRE219]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Variable declaration (definition) and initialization
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明（定义）和初始化
- en: A variable has a name (an ID) and a type. Typically, it refers to the memory
    where a value is stored, but may refer to nothing (`null`) or not refer to anything
    at all (then, it is not initialized). It can represent a class property, an array
    element, a method parameter, and a local variable. The last one is the most frequently
    used kind of variable.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 变量有一个名称（ID）和一个类型。通常，它指的是存储值的内存，但也可能什么也不指（即`null`）或者根本不指任何东西（那么，它就没有初始化）。它可以代表类属性、数组元素、方法参数和局部变量。最后一个是使用最频繁的变量类型。
- en: Before a variable can be used, it has to be declared and initialized. In some
    other programming languages, a variable can also be defined, so Java programmers
    sometimes use the word *definition* as a synonym of declaration, which is not
    exactly correct.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量可以使用之前，它必须被声明和初始化。在其他一些编程语言中，变量也可以被定义，因此Java程序员有时使用单词*定义*作为声明的同义词，这并不完全正确。
- en: 'Here is a terminology review with examples:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个术语回顾和示例：
- en: '[PRE223]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Initialization and assignment look the same. The difference is in their sequence:
    the first assignment is called initialization. Without an initialization, a variable
    cannot be used.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和赋值看起来相同。它们之间的区别在于它们的顺序：第一个赋值称为初始化。如果没有初始化，变量就不能使用。
- en: 'Declaration and initialization can be combined in a single statement. Observe
    the following, for example:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 声明和初始化可以合并为单个语句。例如，观察以下内容：
- en: '[PRE226]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: var type holder
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: var类型持有者
- en: 'In Java 10, a sort of type holder, `var`, was introduced. The *Java Language
    Specification* defines it thus: “*var is not a keyword, but an identifier with
    special meaning as the type of a local variable declaration*.”'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 10中，引入了一种类型持有者，`var`。*Java语言规范*这样定义它：“*var不是一个关键字，但是一个具有特殊意义的标识符，用作局部变量声明的类型*。”
- en: 'In practical terms, it lets a compiler figure out the nature of the declared
    variable, as follows (see the `var()` method in the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，它让编译器能够确定声明的变量的性质，如下所示（参见`com.packt.learnjava.ch01_start.PrimitiveTypes`类中的`var()`方法）：
- en: '[PRE230]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: In the preceding example, the compiler can reasonably assume that `x` has the
    `int` primitive type.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，编译器可以合理地假设`x`具有`int`原始类型。
- en: 'As you may have guessed, to accomplish that, a declaration on its own would
    not suffice, as we can see here:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，为了完成这个任务，仅仅声明是不够的，正如我们在这里可以看到的：
- en: '[PRE231]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: That is, without initialization, the compiler cannot figure out the type of
    the variable when `var` is used.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，没有初始化，当使用`var`时，编译器无法确定变量的类型。
- en: Java statements
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语句
- en: 'A Java statement is a minimal construct that can be executed. It describes
    an action and ends with a semicolon (`;`). We have seen many statements already.
    For example, here are three statements:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java语句是最小可执行结构。它描述了一个动作并以分号（`;`）结束。我们已经看到了许多语句。例如，以下有三个语句：
- en: '[PRE232]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The first line is a declaration statement combined with an assignment statement.
    The second line is also a declaration statement combined with an assignment statement
    and method invocation statement. The third line is just a method invocation statement.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个声明语句与赋值语句的组合。第二行也是一个声明语句与赋值语句和方法调用语句的组合。第三行只是一个方法调用语句。
- en: 'Here is a list of Java statement types:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Java语句类型列表：
- en: An empty statement that consists of only one symbol, `;` (semicolon)
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只包含一个符号（`;`，分号）的空语句
- en: A class or interface declaration statement (we will talk about this in [*Chapter
    2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*)
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类或接口声明语句（我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*）中讨论这个问题。
- en: 'A local variable declaration statement: `int x`;'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个局部变量声明语句：`int x`;
- en: 'A synchronized statement: this is beyond the scope of this book'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个同步语句：这超出了本书的范围
- en: An expression statement
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表达式语句
- en: A control flow statement
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制流语句
- en: 'An expression statement can be one of the following:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表达式语句可以是以下之一：
- en: 'A method invocation statement: `someMethod();`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法调用语句：`someMethod();`
- en: 'An assignment statement: `n = 23.42f;`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个赋值语句：`n = 23.42f;`
- en: 'An object creation statement: `new String("abc");`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象创建语句：`new String("abc");`
- en: 'A unary increment or decrement statement: `++x ; or --x; or x++; or x--;`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元增量或减量语句：`++x`；或`--x`；或`x++`；或`x--;`
- en: We will talk more about expression statements in the *Expression statements*
    section.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*表达式语句*部分更多地讨论表达式语句。
- en: 'A control flow statement can be one of the following:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 一个控制流语句可以是以下之一：
- en: 'A selection statement: `if-else` or `switch-case`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选择语句：`if-else`或`switch-case`
- en: 'An iteration statement: `for`, `or while`, or `do-while`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代语句：`for`、`while`或`do-while`
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个异常处理语句：`throw`、`try-catch`或`try-catch-finally`
- en: 'A branching statement: `break`, `continue`, or `return`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分支语句：`break`、`continue`或`return`
- en: We will talk more about control statements in the *Control flow statements*
    section.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*控制流语句*部分更多地讨论控制语句。
- en: Expression statements
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'An expression statement consists of one or more expressions. An expression
    typically includes one or more operators. It can be evaluated, which means it
    can produce a result of one of the following types:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表达式语句由一个或多个表达式组成。一个表达式通常包括一个或多个运算符。它可以被评估，这意味着它可以产生以下类型之一的结果：
- en: 'A variable: `x = 1`, for example'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量：例如`x = 1`
- en: 'A value: `2*2`, for example'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值：例如`2*2`
- en: 'It returns nothing when the expression is an invocation of a method that returns
    `void`. Such a method is said to produce only a side effect: `void someMethod()`,
    for example.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式是一个返回`void`的方法调用时，它不返回任何内容。这样的方法被称为只产生副作用：例如`void someMethod()`。
- en: 'Consider the following expression:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式：
- en: '[PRE235]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The preceding expression assigns a value to an `x` variable and has a side effect
    of adding 1 to the value of the `y` variable.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式将一个值赋给`x`变量，并且副作用是将`y`变量的值增加1。
- en: 'Another example would be a method that prints a line, like this:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个打印行的方法，如下所示：
- en: '[PRE236]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The `println()` method returns nothing and has a side effect of printing something.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`println()`方法不返回任何内容，并且有一个打印某些内容的副作用。'
- en: 'By its form, an expression can be one of the following:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 从其形式来看，一个表达式可以是以下之一：
- en: 'A primary expression: a literal, a new object creation, a field or method access
    (invocation).'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个原始表达式：一个字面量、一个新的对象创建、一个字段或方法访问（调用）。
- en: 'A unary operator expression: `x++`, for example.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元运算符表达式：例如`x++`。
- en: 'A binary operator expression: `x*y`, for example.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个二元运算符表达式：例如`x*y`。
- en: 'A ternary operator expression: `x > y ? true : false`, for example.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符表达式：例如 `x > y ? true : false`。'
- en: 'A lambda expression: `x -> x + 1` (see [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*).'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 lambda 表达式：`x -> x + 1`（见[*第14章*](B18388_14_ePub.xhtml#_idTextAnchor296)，*Java
    标准流*）。
- en: If an expression consists of other expressions, parentheses are often used to
    identify each of the expressions clearly. This way, it is easier to understand
    and to set the expressions’ precedence.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个表达式由其他表达式组成，通常使用括号来清楚地标识每个表达式。这样，更容易理解并设置表达式的优先级。
- en: Control flow statements
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流语句
- en: When a Java program is executed, it is executed statement by statement. Some
    statements have to be executed conditionally, based on the result of an expression
    evaluation. Such statements are called control flow statements because, in computer
    science, a control flow (or flow of control) is the order in which individual
    statements are executed or evaluated.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 程序执行时，它是逐语句执行的。一些语句必须根据表达式评估的结果有条件地执行。这类语句被称为控制流语句，因为在计算机科学中，控制流（或控制流程）是指单个语句执行或评估的顺序。
- en: 'A control flow statement can be one of the following:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语句可以是以下之一：
- en: 'A selection statement: `if-else` or `switch-case`'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句：`if-else` 或 `switch-case`
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代语句：`for`、`while` 或 `do-while`
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个异常处理语句：`throw`、`try-catch` 或 `try-catch-finally`
- en: 'A branching statement: `break`, `continue`, or `return`'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分支语句：`break`、`continue` 或 `return`
- en: Selection statements
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'Selection statements are based on an expression evaluation and have four variations,
    as outlined here:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句基于表达式评估，有四种变体，如下概述：
- en: '`if` (expression) {do something}'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` (表达式) {执行某些操作}'
- en: '`if` (expression) {do something} `else` {do something else}'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` (表达式) {执行某些操作} `else` {执行其他操作}'
- en: '`if` (expression) {do something} `else if` {do something else} `else` {do something
    else}'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` (表达式) {执行某些操作} `else if` {执行其他操作} `else` {执行其他操作}'
- en: '`switch...case` statement'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch...case` 语句'
- en: 'Here are some examples of `if` statements:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `if` 语句的示例：
- en: '[PRE237]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'A `switch...case` statement is a variation of an `if...else` statement, as
    illustrated here:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch...case` 语句是 `if...else` 语句的一种变体，如下所示：'
- en: '[PRE252]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: As you can see, the `switch...case` statement forks the execution flow based
    on the value of the variable. The `break` statement allows the `switch...case`
    statement to be executed. Otherwise, all the following cases would be executed.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`switch...case` 语句根据变量的值分支执行流程。`break` 语句允许执行 `switch...case` 语句。否则，将执行所有后续的情况。
- en: 'In Java 14, a new `switch...case` statement has been introduced in a less verbose
    form, as illustrated here:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 14 中，引入了一种新的 `switch...case` 语句，其形式更为简洁，如下所示：
- en: '[PRE266]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: As you can see, it uses an arrow (`->`) and does not use a `break` statement.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用箭头 (`->`) 而不使用 `break` 语句。
- en: 'Execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `selection()` method that calls the `switchStatement()` method with
    different parameters, as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `com.packt.learnjava.ch01_start.ControlFlow` 类的 `main()` 方法——查看调用 `switchStatement()`
    方法并传递不同参数的 `selection()` 方法，如下所示：
- en: '[PRE275]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: You can see the results from the comments.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从注释中看到结果。
- en: 'If several lines of code have to be executed in each case, you can just put
    braces (`{}`) around the block of code, as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个情况下需要执行多行代码，您只需在代码块周围放置大括号 (`{}`)，如下所示：
- en: '[PRE278]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The Java 14 `switch...case` statement can even return a value, thus becoming
    in effect a `switch` expression. For example, here is a case when another variable
    has to be assigned based on the `switch...case` statement result:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Java 14 的 `switch...case` 语句甚至可以返回一个值，从而实际上成为了一个 `switch` 表达式。例如，以下是一个基于 `switch...case`
    语句结果来分配另一个变量的情况：
- en: '[PRE288]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'If we execute the `switchExpression1()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `switchExpression1()` 方法（请参阅 `com.packt.learnjava.ch01_start.ControlFlow`
    类的 `selection()` 方法），结果将如下所示：
- en: '[PRE296]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The following example of a `switch` expression is based on a constant:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `switch` 表达式的示例基于一个常量：
- en: '[PRE299]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'If we execute the `switchExpression2()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `switchExpression2()` 方法（请参阅 `com.packt.learnjava.ch01_start.ControlFlow`
    类的 `selection()` 方法），结果将如下所示：
- en: '[PRE309]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Here’s yet another example of a `switch` expression, this time based on the
    `enum` value:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个 `switch` 表达式的示例，这次基于 `enum` 值：
- en: '[PRE312]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'If we execute the `switchExpression3()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `switchExpression3()` 方法（请参阅 `com.packt.learnjava.ch01_start.ControlFlow`
    类的 `selection()` 方法），结果将看起来像这样：
- en: '[PRE320]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'In case a block of code has to be executed based on a particular input value,
    it is not possible to use a `return` statement because it is reserved already
    for the returning value from a method. That is why, to return a value from a block,
    we have to use a `yield` statement, as shown in the following example:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要根据特定的输入值执行一段代码块，则不能使用 `return` 语句，因为它已经被保留用于从方法返回值。这就是为什么，要从代码块返回一个值，我们必须使用
    `yield` 语句，如下面的示例所示：
- en: '[PRE323]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'If we execute the `switchExpression4()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `switchExpression4()` 方法（请参阅 `com.packt.learnjava.ch01_start.ControlFlow`
    类的 `selection()` 方法），结果将看起来像这样：
- en: '[PRE333]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: Iteration statements
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代语句
- en: 'An iteration statement can take one of the following three forms:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句可以采取以下三种形式之一：
- en: A `while` statement
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 语句'
- en: A `do...while` statement
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do...while` 语句'
- en: A `for` statement, also called a `loop` statement
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 语句，也称为循环语句'
- en: 'A `while` statement looks like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句看起来是这样的：'
- en: '[PRE335]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Here is a specific example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `iteration()` method):'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具体的示例（执行 `com.packt.learnjava.ch01_start.ControlFlow` 类的 `main()` 方法——请参阅
    `iteration()` 方法）：
- en: '[PRE338]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: In some examples, instead of the `println()` method, we use the `print()` method,
    which does not feed another line (does not add a line feed control at the end
    of its output). The `print()` method displays the output in one line.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些示例中，我们使用 `print()` 方法而不是 `println()` 方法，`print()` 方法不会换行（不会在其输出末尾添加换行控制）。`print()`
    方法在单行中显示输出。
- en: 'A `do...while` statement has a very similar form, as we can see here:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while` 语句具有非常相似的形式，如下所示：'
- en: '[PRE343]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'It differs from a `while` statement by always executing the block of statements
    at least once before evaluating the expression, as illustrated in the following
    code snippet:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `while` 语句的不同之处在于，它总是在评估表达式之前至少执行一次语句块，如下面的代码片段所示：
- en: '[PRE346]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'As you can see, it behaves the same way when the expression is `true` at the
    first iteration. But if the expression evaluates to `false`, the results are different,
    as we can see here:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当第一次迭代表达式为 `true` 时，它表现相同。但如果表达式评估为 `false`，结果将不同，如下所示：
- en: '[PRE351]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '`for` statement syntax looks like this:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句的语法如下所示：'
- en: '[PRE361]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'Here is how a `for` statement works:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `for` 语句的工作方式：
- en: '`init` statements initialize a variable.'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init` 语句初始化一个变量。'
- en: 'A Boolean expression is evaluated using the current variable value: if `true`,
    the block of statements is executed; otherwise, the `for` statement exits.'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前变量的值评估布尔表达式：如果为 `true`，则执行语句块；否则，`for` 语句退出。
- en: '`update` statements update the variable, and the Boolean expression is evaluated
    again with this new value: if `true`, the block of statements is executed; otherwise,
    the `for` statement exits.'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update` 语句更新变量，然后使用这个新值再次评估布尔表达式：如果为 `true`，则执行语句块；否则，`for` 语句退出。'
- en: Unless exited, the final step is repeated.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非退出，否则最后一步会重复。
- en: 'As you can see here, if you aren’t careful, you can get into an infinite loop:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果不小心，可能会进入无限循环：
- en: '[PRE364]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'So, you have to make sure that the Boolean expression guarantees eventual exit
    from the loop, like this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你必须确保布尔表达式保证最终退出循环，如下所示：
- en: '[PRE367]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'The following example demonstrates multiple initialization and `update` statements:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了多个初始化和 `update` 语句：
- en: '[PRE370]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'And here is a variation of the preceding code for statements for demonstration
    purposes:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的变体，用于演示目的：
- en: '[PRE373]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: If the `getInitialValue()` method is implemented like `int getInitialValue(){
    return -2; }`, then the preceding two `for` statements produce exactly the same
    results.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `getInitialValue()` 方法实现如下 `int getInitialValue(){ return -2; }`，那么前面的两个
    `for` 语句将产生完全相同的结果。
- en: 'To iterate over an array of values, you can use an array index, like so:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历一个值数组，你可以使用数组索引，如下所示：
- en: '[PRE377]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Alternatively, you can use a more compact form of a `for` statement that produces
    the same result, as follows:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用更紧凑的 `for` 语句形式，产生相同的结果，如下所示：
- en: '[PRE381]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'This last form is especially useful with a collection, as shown here:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后的形式在处理集合时特别有用，如下所示：
- en: '[PRE385]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: We will talk about collections in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*中讨论集合。
- en: Exception-handling statements
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理语句
- en: 'In Java, there are classes called exceptions that represent events that disrupt
    the normal execution flow. They typically have names that end with `Exception`:
    `NullPointerException`, `ClassCastException`, `ArrayIndexOutOfBoundsException`,
    to name but a few.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有一些称为异常的类，它们代表中断正常执行流程的事件。它们通常以`Exception`结尾：`NullPointerException`、`ClassCastException`、`ArrayIndexOutOfBoundsException`等，仅举几例。
- en: All the exception classes extend the `java.lang.Exception` class, which, in
    turn, extends the `java.lang.Throwable` class (we will explain what this means
    in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*). That’s why all exception objects have common behavior. They
    contain information about the cause of the exceptional condition and the location
    of its origination (line number of the source code).
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的异常类都扩展了`java.lang.Exception`类，该类反过来又扩展了`java.lang.Throwable`类（我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中解释这意味着什么）。这就是为什么所有异常对象都有共同的行为。它们包含有关异常条件的原因及其起源位置（源代码的行号）的信息。
- en: Each exception object can be generated (thrown) either automatically by the
    JVM or by the application code, using the `throw` keyword. If a block of code
    throws an exception, you can use a `try-catch` or `try-catch-finally` construct
    to capture the thrown exception object and redirect the execution flow to another
    branch of code. If the surrounding code does not catch the exception object, it
    propagates all the way out of the application into the JVM and forces it to exit
    (and abort the application execution). So, it is good practice to use `try-catch`
    or `try-catch-finally` in all the places where an exception can be raised and
    you do not want your application to abort execution.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异常对象都可以由JVM或使用`throw`关键字的应用代码自动生成（抛出）。如果代码块抛出异常，可以使用`try-catch`或`try-catch-finally`结构来捕获抛出的异常对象，并将执行流程重定向到另一段代码。如果周围的代码没有捕获异常对象，它将一直传播到应用程序中的JVM，并强制其退出（并中止应用程序执行）。因此，在可能抛出异常且不希望应用程序中止执行的所有地方使用`try-catch`或`try-catch-finally`是一种良好的做法。
- en: 'Here is a typical example of exception handling:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的异常处理示例：
- en: '[PRE389]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: In the preceding code snippet, normal processing flow will be not executed in
    the case of `x > 10`. Instead, the `do what has to be done` block will be executed.
    But, in the `x <= 10` case, the normal processing flow block will be run and the
    `do what has to be done` block will be ignored.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，如果`x > 10`，则不会执行正常的处理流程。相反，将执行`do what has to be done`块。但是，在`x <=
    10`的情况下，将运行正常的处理流程块，而`do what has to be done`块将被忽略。
- en: 'Sometimes, it is necessary to execute a block of code anyway, whether an exception
    was thrown/caught or not. Instead of repeating the same code block in two places,
    you can put it in a `finally` block, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.ControlFlow` class—see the `exception()` method):'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，无论是否抛出/捕获异常，都需要执行一段代码。而不是在两个地方重复相同的代码块，可以将它放在`finally`块中，如下所示（执行`com.packt.learnjava.ch01_start.ControlFlow`类的`main()`方法——请参阅`exception()`方法）：
- en: '[PRE399]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: We will talk about exception handling in more detail in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110),
    *Exception Handling*.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B18388_04_ePub.xhtml#_idTextAnchor110)，*异常处理*中更详细地讨论异常处理。
- en: Branching statements
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支语句
- en: Branching statements allow breaking of the current execution flow and continuation
    of execution from the first line after the current block or from a certain (labeled)
    point of the control flow.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 分支语句允许中断当前执行流程，并从当前块之后的第一个语句或控制流程的某个（标记的）点继续执行。
- en: 'A branching statement can be one of the following:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 分支语句可以是以下之一：
- en: '`break`'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`continue`'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`return`'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`'
- en: 'We have seen how `break` was used in `switch-case` statements. Here is another
    example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `branching()` method):'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`break`在`switch-case`语句中的应用。这里还有一个例子（执行`com.packt.learnjava.ch01_start.ControlFlow`类的`main()`方法——请参阅`branching()`方法）：
- en: '[PRE413]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: If we need to find the first list element that contains `"3"`, we can stop executing
    as soon as the `s.contains("3")` condition is evaluated to `true`. The remaining
    list elements are ignored.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要找到第一个包含 `"3"` 的列表元素，我们可以在 `s.contains("3")` 条件评估为 `true` 时立即停止执行。剩余的列表元素将被忽略。
- en: 'In a more complicated scenario, with nested `for` statements, it is possible
    to set a label (with `a : column`) that indicates which `for` statement has to
    be exited, as follows:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '在更复杂的场景中，有嵌套的 `for` 循环时，可以设置一个标签（使用 `a : column`），指明哪个 `for` 循环需要退出，如下所示：'
- en: '[PRE423]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: We have chosen a label name of `exit`, but we could call it any other name too.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了标签名为 `exit`，但也可以叫其他任何名字。
- en: 'A `continue` statement works similarly, as follows:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句的工作方式类似，如下所示：'
- en: '[PRE439]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: It differs from `break` by stating which of the `for` statements need to continue
    and not exit.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `break` 的不同之处在于指明哪个 `for` 循环需要继续而不是退出。
- en: 'A `return` statement is used to return a result from a method, as follows:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句用于从方法返回结果，如下所示：'
- en: '[PRE459]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'As you can see, there can be several `return` statements in a method, each
    returning a different value in different circumstances. If the method returns
    nothing (`void`), a `return` statement is not required, although it is frequently
    used for better readability, as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个方法中可以有多个 `return` 语句，每个 `return` 语句在不同的环境下返回不同的值。如果方法不返回任何内容（`void`），则不需要
    `return` 语句，尽管它经常被用于提高可读性，如下所示：
- en: '[PRE468]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Execute the `returnDemo()` method by running the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class (see the `branching()` method). The results are going to look like this:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `com.packt.learnjava.ch01_start.ControlFlow` 类的 `main()` 方法来执行 `returnDemo()`
    方法（请参阅 `branching()` 方法）。结果将如下所示：
- en: '[PRE480]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Statements are the building blocks of Java programming. They are like sentences
    in English—complete expressions of intent that can be acted upon. They can be
    compiled and executed. Programming is like expressing an action plan in statements.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是 Java 编程的构建块。它们就像英语中的句子——可以执行的动作的完整意图表达。它们可以被编译和执行。编程就像在语句中表达一个行动计划。
- en: With this, the explanation of the basics of Java is concluded. Congratulations
    on getting through it!
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Java 基础的讲解就结束了。恭喜您完成了这一过程！
- en: Summary
  id: totrans-920
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the exciting world of Java programming. We started
    with explaining the main terms, and then explained how to install the necessary
    tools—the JDK and the IDE—and how to configure and use them.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了激动人心的 Java 编程世界。我们首先解释了主要术语，然后解释了如何安装必要的工具——JDK 和 IDE——以及如何配置和使用它们。
- en: With a development environment in place, we have provided readers with the basics
    of Java as a programming language. We have described Java primitive types, the
    `String` type, and their literals. We have also defined what an ID is and what
    a variable is and finished with a description of the main types of Java statements.
    All the points of the discussion were illustrated by specific code examples.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立开发环境后，我们向读者提供了 Java 作为编程语言的基础知识。我们描述了 Java 原始类型、`String` 类型及其字面量。我们还定义了什么是
    ID 以及什么是变量，并以 Java 语句的主要类型结束，所有讨论点都通过具体的代码示例进行了说明。
- en: In the next chapter, we are going to talk about the `final` keyword.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 `final` 关键字。
- en: Quiz
  id: totrans-924
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: What does JDK stand for?
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JDK 代表什么？
- en: Java Document Kronos
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 文档克洛诺斯
- en: June Development Karate
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 六月开发空手道
- en: Java Development Kit
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 开发工具包
- en: Java Developer Kit
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 开发工具包
- en: What does JCL stand for?
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JCL 代表什么？
- en: Java Classical Library
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 古典库
- en: Java Class Library
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 类库
- en: Junior Classical Liberty
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初级古典自由
- en: Java Class Libras
  id: totrans-934
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 类库
- en: What does Java SE stand for?
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java SE 代表什么？
- en: Java Senior Edition
  id: totrans-936
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 高级版
- en: Java Star Edition
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 星版
- en: Java Structural Elections
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 结构选举
- en: Java Standard Edition
  id: totrans-939
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 标准版
- en: What does IDE stand for?
  id: totrans-940
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE 代表什么？
- en: Initial Development Edition
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始开发版
- en: Integrated Development Environment
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: International Development Edition
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 国际开发版
- en: Integrated Development Edition
  id: totrans-944
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成开发版
- en: What are Maven's functions?
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven 的功能有哪些？
- en: Project building
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目构建
- en: Project configuration
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目配置
- en: Project documentation
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文档
- en: Project cancellation
  id: totrans-949
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目取消
- en: Which of the following are Java primitive types?
  id: totrans-950
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是 Java 原始类型？
- en: '`boolean`'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`布尔`'
- en: '`numeric`'
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`数值`'
- en: '`integer`'
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`整数`'
- en: '`string`'
  id: totrans-954
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`字符串`'
- en: Which of the following are Java numeric types?
  id: totrans-955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是 Java 数值类型？
- en: '`long`'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`长`'
- en: '`bit`'
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`位`'
- en: '`short`'
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`短`'
- en: '`byte`'
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`字节`'
- en: What is a *literal*?
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *字面量*？
- en: A letter-based string
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于字母的字符串
- en: A number-based string
  id: totrans-962
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于数字的字符串
- en: A variable representation
  id: totrans-963
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的表示
- en: A value representation
  id: totrans-964
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值的表示
- en: Which of the following are literals?
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是字面量？
- en: '`\\`'
  id: totrans-966
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\\`'
- en: '`2_0`'
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2_0`'
- en: '`2__0f`'
  id: totrans-968
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2__0f`'
- en: '`\f`'
  id: totrans-969
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\f`'
- en: Which of the following are Java operators?
  id: totrans-970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是Java运算符？
- en: '`%`'
  id: totrans-971
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%`'
- en: '`$`'
  id: totrans-972
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$`'
- en: '`&`'
  id: totrans-973
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&`'
- en: '`->`'
  id: totrans-974
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`->`'
- en: What does the following code snippet print?
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE486]'
  id: totrans-976
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '`0`'
  id: totrans-977
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`1`'
  id: totrans-978
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`2`'
  id: totrans-979
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2`'
- en: '`3`'
  id: totrans-980
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`3`'
- en: What does the following code snippet print?
  id: totrans-981
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE487]'
  id: totrans-982
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '`false true`'
  id: totrans-983
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false true`'
- en: '`false false`'
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false false`'
- en: '`true false`'
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`true false`'
- en: '`true true`'
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`true true`'
- en: What does the following code snippet print?
  id: totrans-987
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE488]'
  id: totrans-988
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '`1`'
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`2`'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2`'
- en: '`3`'
  id: totrans-991
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`3`'
- en: '`4`'
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4`'
- en: What is the result of the following code snippet?
  id: totrans-993
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段的结果是什么？
- en: '[PRE489]'
  id: totrans-994
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '`a`'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`'
- en: '`abc-bc`'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`abc-bc`'
- en: Compilation error
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Execution error
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行错误
- en: What does the following code snippet print?
  id: totrans-999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE490]'
  id: totrans-1000
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '`1`'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`2`'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2`'
- en: '`3`'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`3`'
- en: '`4`'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4`'
- en: Which of the following are correct IDs?
  id: totrans-1005
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是正确的ID？
- en: '`int __` (two underscores)'
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int __` (两个下划线)'
- en: '`2a`'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2a`'
- en: '`a2`'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a2`'
- en: '`$`'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$`'
- en: What does the following code snippet print?
  id: totrans-1010
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE491]'
  id: totrans-1011
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '`20 -1 21 0`'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`20 -1 21 0`'
- en: Endless loop
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限循环
- en: '`21 0`'
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`21 0`'
- en: '`20 -1`'
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`20 -1`'
- en: What does the following code snippet print?
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE492]'
  id: totrans-1017
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Compilation error
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: 'The `x` value is out of the range: 11'
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`的值超出范围：11'
- en: 'The `x` value is within the range: 11'
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`的值在范围内：11'
- en: Execution time error
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行时间错误
- en: What does the following code snippet print?
  id: totrans-1022
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE493]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '`result = 22`'
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result = 22`'
- en: '`result = 23`'
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result = 23`'
- en: '`result = 32`'
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result = 32`'
- en: '`result = 33`'
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result = 33`'
- en: 'Select all the following statements that are correct:'
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择以下所有正确的语句：
- en: A variable can be declared.
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以被声明。
- en: A variable can be assigned.
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以被赋值。
- en: A variable can be defined.
  id: totrans-1045
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以被定义。
- en: A variable can be determined.
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以被确定。
- en: 'Select all the correct Java statement types from the following:'
  id: totrans-1047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下选项中选择所有正确的Java语句类型：
- en: An executable statement
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可执行语句
- en: A selection statement
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择语句
- en: A method end statement
  id: totrans-1050
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法结束语句
- en: An increment statement
  id: totrans-1051
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增量语句
