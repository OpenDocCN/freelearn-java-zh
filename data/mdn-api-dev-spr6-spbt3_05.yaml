- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Asynchronous API Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步API设计
- en: So far, we have developed RESTful web services based on the imperative model,
    where calls are synchronous. What if you want to make code async and non-blocking?
    This is what we are going to do in this chapter. You’ll learn about asynchronous
    API design in this chapter, where calls are asynchronous and non-blocking. We’ll
    develop these APIs using Spring **WebFlux**, which is based on Project Reactor
    ([https://projectreactor.io](https://projectreactor.io)). Reactor is a library
    for building non-blocking apps on a **Java virtual** **machine** (**JVM**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经基于命令式模型开发了RESTful Web服务，其中调用是同步的。如果你想要使代码异步和非阻塞，我们将在本章中介绍这一点。你将学习本章中的异步API设计，其中调用是异步和非阻塞的。我们将使用基于Project
    Reactor ([https://projectreactor.io](https://projectreactor.io))的Spring **WebFlux**来开发这些API。Reactor是一个用于在**Java虚拟机**（**JVM**）上构建非阻塞应用程序的库。
- en: First, we’ll walk through the reactive programming fundamentals, and then we’ll
    migrate the existing e-commerce REST API (which we learned about in [*Chapter
    4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business Logic for APIs*) to an
    asynchronous (reactive) API to make things easier by comparing the existing (imperative)
    way and reactive way of programming. The code will make use of R2DBC for database
    persistence, which supports reactive programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍响应式编程的基础知识，然后我们将通过比较现有的（命令式）编程方式和响应式编程方式，将现有的电子商务REST API（我们在[*第4章*](B19349_04.xhtml#_idTextAnchor097)，*为API编写业务逻辑）迁移到异步（响应式）API，以简化事情。代码将使用支持响应式编程的R2DBC进行数据库持久化。
- en: 'We’ll discuss the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Understanding Reactive Streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解响应式流
- en: Exploring Spring WebFlux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Spring WebFlux
- en: Understanding `DispatcherHandler`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`DispatcherHandler`
- en: Controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Functional endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能端点
- en: Implementing reactive APIs for our e-commerce app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的电子商务应用实现响应式API
- en: By the end of this chapter, you will have learned how to develop and implement
    reactive APIs and explored async APIs. You will also be able to implement reactive
    controllers and functional endpoints and make use of R2DBC for database persistence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何开发和实现响应式API，并探索异步API。你还将能够实现响应式控制器和功能端点，并利用R2DBC进行数据库持久化。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05)找到。
- en: Understanding Reactive Streams
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解响应式流
- en: Normal Java code achieves asynchronicity by using thread pools. Your web server
    uses a thread pool to serve requests – it assigns a thread to each incoming request.
    The application uses the thread pool for database connections too. Each database
    call uses a separate thread and waits for the result. Therefore, each web request
    and database call uses its own thread. However, there is a wait associated with
    this and, therefore, these are blocking calls. The thread waits and utilizes the
    resources until a response is received back from the database or a response object
    is written. This is kind of a limitation when you scale as you can only use the
    resources available to the JVM. You overcome this limitation by using a load balancer
    with other instances of the service, which is a type of horizontal scaling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的Java代码通过使用线程池来实现异步性。你的Web服务器使用线程池来处理请求——它为每个传入的请求分配一个线程。应用程序也使用线程池来处理数据库连接。每个数据库调用都使用一个单独的线程并等待结果。因此，每个Web请求和数据库调用都使用自己的线程。然而，这伴随着等待，因此这些是阻塞调用。线程等待并利用资源，直到从数据库收到响应或写入响应对象。当你进行扩展时，这是一个限制，因为你只能使用JVM可用的资源。通过使用带有服务其他实例的负载均衡器来克服这种限制，这是一种水平扩展的类型。
- en: In the last decade, there has been a rise in client-server architecture. Lots
    of IoT-enabled devices, smartphones that have native apps, first-class web apps,
    and traditional web applications have emerged. Applications not only have third-party
    services but also have various sources of data, which leads to higher-scale applications.
    On top of that, microservice-based architecture has increased communication among
    services themselves. You need lots of resources to serve this higher network communication
    demand. This makes scaling a necessity. Threads are expensive and not infinite.
    You don’t want to block them for effective utilization. For example, let’s say
    your code is calling the database for data. In this case, the call waits until
    you get the response in the blocking call. However, a non-blocking call doesn’t
    block anything. It responds only when a response is received from the dependent
    code (the database in this case). The system can serve other calls during this
    time. This is where asynchronicity helps. In asynchronous calls, threads become
    free as soon as a call is done and use a callback utility (common in JavaScript).
    When data is available at the source, it pushes the data. Project Reactor is based
    on **Reactive Streams**. Reactive Streams uses the **publisher-subscriber model**,
    where the source of data, the publisher, pushes the data to the subscriber.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，客户端-服务器架构有所增长。大量的物联网设备、具有原生应用的智能手机、一流的网络应用和传统的网络应用纷纷涌现。应用不仅拥有第三方服务，还有各种数据来源，这导致了更高规模的应用。除此之外，基于微服务的架构增加了服务之间的通信。你需要大量的资源来满足这种更高的网络通信需求。这使得扩展成为必要。线程很昂贵，且不是无限的。你不想阻塞它们以实现有效利用。例如，假设你的代码正在调用数据库以获取数据。在这种情况下，调用会等待直到你在阻塞调用中收到响应。然而，非阻塞调用不会阻塞任何东西。它仅在从依赖代码（在这种情况下是数据库）收到响应时才响应。在这段时间内，系统可以服务其他调用。这就是异步性发挥作用的地方。在异步调用中，一旦调用完成，线程就会变得空闲，并使用回调实用工具（在JavaScript中很常见）。当数据在源处可用时，它会推送数据。Reactor项目基于**响应式流**。响应式流使用**发布者-订阅者模型**，其中数据源，即发布者，将数据推送到订阅者。
- en: You might be aware that, on the other hand, Node.js uses a single thread to
    make use of most resources. It is based on an asynchronous non-blocking design,
    known as an **event loop**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，另一方面，Node.js使用单个线程来利用大多数资源。它基于异步非阻塞设计，称为**事件循环**。
- en: Reactive APIs are also based on an event loop design and use push-style notifications.
    If you look closely, Reactive Streams also supports Java stream (a sequence of
    objects pipelined to produce the desired results by performing various operations)
    operations, such as `map`, `flatMap`, and `filter`. Internally, Reactive Streams
    uses a push style, whereas Java streams work according to a pull model; that is,
    items are pulled from the source, such as a Java collection. In reactive programming,
    the source (publisher) pushes the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式API也基于事件循环设计，并使用推送式通知。如果你仔细观察，响应式流还支持Java流操作，如`map`、`flatMap`和`filter`。内部，响应式流使用推送式，而Java流则根据拉模型工作；也就是说，项目是从源（如Java集合）中拉取的。在响应式编程中，源（发布者）推送数据。
- en: In Reactive Streams, streams of data are asynchronous and non-blocking and support
    backpressure. (Refer to the *Subscriber* subsection of this chapter for an explanation
    of backpressure.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式流中，数据流是异步和非阻塞的，并支持背压。（有关背压的解释，请参阅本章的*订阅者*子节。）
- en: 'There are four basic types of interfaces as per the Reactive Streams specification:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据响应式流规范，有四种基本类型的接口：
- en: Publisher
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者
- en: Subscriber
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者
- en: Subscription
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: Processor
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器
- en: Let’s have a look at each of these types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类型中的每一个。
- en: Publisher
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布者
- en: A publisher provides a stream of data to one or more subscribers. A subscriber
    uses the `subscribe()` method to subscribe to a publisher. Each subscriber should
    only subscribe once to a publisher.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者向一个或多个订阅者提供数据流。订阅者使用`subscribe()`方法订阅发布者。每个订阅者只能向一个发布者订阅一次。
- en: Most importantly, the publisher pushes data according to the demand received
    from subscribers. Reactive Streams are lazy; therefore, the publisher will only
    push an element if there is a subscriber.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，发布者根据从订阅者收到的需求推送数据。响应式流是懒加载的；因此，只有当有订阅者时，发布者才会推送元素。
- en: 'A `Publisher` interface is defined as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`接口定义如下：'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `Publisher` interface contains the `subscribe` method. Let’s find
    out about the `Subscriber` type in the next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`发布者`接口包含`subscribe`方法。让我们在下一小节中了解`订阅者`类型。
- en: Subscriber
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅者
- en: 'The subscriber consumes the data pushed by the publisher. Publisher-subscriber
    communication works as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者消费发布者推送的数据。发布者-订阅者通信工作如下：
- en: When a `Subscriber` instance is passed to the `Publisher.subscribe()` method,
    it triggers the `onSubscribe()` method. It contains a `Subscription` parameter,
    which controls the backpressure, that is, how much data a subscriber demands from
    the publisher.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个`订阅者`实例传递给`Publisher.subscribe()`方法时，它会触发`onSubscribe()`方法。它包含一个`Subscription`参数，该参数控制背压，即订阅者从发布者那里请求的数据量。
- en: After the first step, `Publisher` waits for the `Subscription.request(long)`
    call. It only pushes data to `Subscriber` after the `Subscription.request()` call
    is made. This method indicates to the `Publisher` how many items the subscriber
    is ready to receive at a time.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步之后，`发布者`等待`Subscription.request(long)`调用。它只有在`Subscription.request()`调用之后才会向`订阅者`推送数据。此方法指示`发布者`订阅者一次可以接收多少项。
- en: Normally, the publisher pushes the data to the subscriber, irrespective of whether
    the subscriber can handle it safely or not. However, the subscriber knows best
    how much data it can handle safely; therefore, in Reactive Streams, `Subscriber`
    uses the `Subscription` instance to communicate the demand for the number of elements
    to `Publisher`. This is known as **back-pressure** or **flow control**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，发布者将数据推送到订阅者，无论订阅者是否能够安全处理。然而，订阅者最清楚它能安全处理多少数据；因此，在Reactive Streams中，`订阅者`使用`Subscription`实例将元素数量的需求传达给`发布者`。这被称为**背压**或**流量控制**。
- en: You must be wondering, what if `Publisher` asks `Subscriber` to slow down but
    it can’t? In that case, `Publisher` must decide whether to fail, drop, or buffer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，如果`发布者`要求`订阅者`减速，但`订阅者`无法做到，那会怎样？在这种情况下，`发布者`必须决定是失败、放弃还是缓冲。
- en: Once the demand is made in *step 2*, `Publisher` sends the data notifications
    and the `onNext()` method is used to consume the data. This method will be triggered
    until the data notifications are pushed by `Publisher` according to the demand
    communicated by `Subscription.request()`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在*步骤2*中提出需求，`发布者`会发送数据通知，并使用`onNext()`方法来消费数据。此方法将在`发布者`根据`Subscription.request()`传达的需求推送数据通知之前被触发。
- en: 'At the end, either `onError()` or `onCompletion()` will be triggered as the
    terminal state. No notification will be sent after one of these invocations has
    been triggered even if you call `Subscription.request()`. The following are the
    terminal methods:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，无论是`onError()`还是`onCompletion()`都会被触发，作为终端状态。在这些调用之一被触发后，即使调用`Subscription.request()`也不会发送任何通知。以下是一些终端方法：
- en: '`onError()` will be invoked the moment any error occurs'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦发生任何错误，`onError()`将被调用
- en: '`onCompletion()` will be invoked when all elements are pushed'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有元素都推送完毕时，`onCompletion()`将被调用
- en: 'The `Subscriber` interface is defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`订阅者`接口被定义为如下：'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Subscription
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅
- en: A subscription is a mediator between the publisher and subscriber. It is the
    subscriber’s responsibility to invoke the `Subscription.subscriber()` method and
    let the publisher know of the demand. It can be invoked as and when required by
    the subscriber.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是发布者和订阅者之间的调解者。订阅者的责任是调用`Subscription.subscriber()`方法，并让发布者知道需求。它可以根据订阅者的需要随时调用。
- en: The `cancel()` method asks the publisher to stop sending data notifications
    and to clean up the resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel()`方法要求发布者停止发送数据通知并清理资源。'
- en: 'A subscription is defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅被定义为如下：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Processor
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器
- en: 'The processor is a bridge between the publisher and subscriber and represents
    the processing stage. It works as both a publisher and subscriber and obeys the
    contract defined by both. It is defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是发布者和订阅者之间的桥梁，代表处理阶段。它既作为发布者又作为订阅者工作，并遵守双方定义的合同。它被定义为如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s have a look at the following example. Here, we are creating `Flux` by
    using the `Flux.just()` static factory method. `Flux` is a type of publisher in
    Project Reactor. This publisher contains four integer elements. Then, we use the
    `reduce` operator (like we do in Java streams) to perform a `sum` operation on
    it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。在这里，我们通过使用`Flux.just()`静态工厂方法创建`Flux`。`Flux`是Project Reactor中的一个发布者类型。这个发布者包含四个整数元素。然后，我们使用`reduce`操作符（就像我们在Java流中做的那样）对它执行`求和`操作：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run the previous code, it prints the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，它将打印以下输出：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking at the output, when `Publisher` is subscribed, `Subscriber` sends an
    unbounded `Subscription.request()`. When the first element is notified, `onNext()`
    is called, and so on. At the end, when the publisher is done with the push elements,
    the `onComplete()` event is called. This is how Reactive Streams works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 观察输出，当`Publisher`被订阅时，`Subscriber`发送无界的`Subscription.request()`。当第一个元素被通知时，调用`onNext()`，依此类推。最后，当发布者完成推送元素时，调用`onComplete()`事件。这就是响应式流的工作方式。
- en: Now that you have an idea of how Reactive Streams works, let’s see how and why
    Spring makes use of Reactive Streams in the Spring WebFlux module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了响应式流的工作原理，让我们看看Spring WebFlux模块是如何以及为什么使用响应式流的。
- en: Exploring Spring WebFlux
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Spring WebFlux
- en: Existing Servlet APIs are blocking APIs. They use input and output streams,
    which block APIs. Servlet 3.0 containers evolve and use the underlying event loop.
    Async requests are processed asynchronously but read and write operations still
    use blocking input/output streams. The *Servlet 3.1* container has evolved further,
    supporting asynchronicity and having the non-blocking I/O stream APIs. However,
    there are certain Servlet APIs, such as `request.getParameters()`, which parse
    the blocking request body and provide synchronous contracts such as `Filter`.
    The **Spring MVC** framework is based on the Servlet API and Servlet containers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的Servlet API是阻塞API。它们使用输入和输出流，这些是阻塞API。Servlet 3.0容器不断进化，并使用底层的事件循环。异步请求异步处理，但读写操作仍然使用阻塞的输入/输出流。*Servlet
    3.1*容器进一步进化，支持异步性，并具有非阻塞I/O流API。然而，某些Servlet API，如`request.getParameters()`，解析阻塞请求体，并提供如`Filter`之类的同步合约。**Spring
    MVC**框架基于Servlet API和Servlet容器。
- en: Therefore, Spring provides **Spring WebFlux**, which is fully non-blocking and
    provides backpressure functionality. It provides concurrency with a small number
    of threads and scales with fewer hardware resources. WebFlux provides fluent,
    functional, and continuation-style APIs to support the declarative composition
    of asynchronous logic. Writing asynchronous functional code is more complex than
    writing imperative-style code. However, once you get hands-on with it, you will
    love it because it allows you to write precise and readable code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Spring提供了**Spring WebFlux**，这是一个完全非阻塞的，并提供背压功能的框架。它使用少量线程提供并发性，并且随着硬件资源的减少而扩展。WebFlux提供了流畅的、函数式的和延续风格的API，以支持声明式异步逻辑的组合。编写异步函数式代码比编写命令式代码更复杂。然而，一旦你上手了，你会爱上它，因为它允许你编写精确且易于阅读的代码。
- en: Both Spring WebFlux and Spring MVC can co-exist; however, to ensure the effective
    use of reactive programming, you should never mix a reactive flow with blocking
    calls.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux和Spring MVC可以共存；然而，为了确保响应式编程的有效使用，你绝不应该将响应式流程与阻塞调用混合。
- en: 'Spring WebFlux supports the following features and archetypes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持以下特性和架构：
- en: The event loop concurrency model
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环并发模型
- en: Both annotated controllers and functional endpoints
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既有注解控制器也有功能端点
- en: Reactive clients
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式客户端
- en: Netty and Servlet 3.1 container-based web servers, such as Tomcat, Undertow,
    and Jetty
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Netty和Servlet 3.1容器（如Tomcat、Undertow和Jetty）的Web服务器
- en: Now that you have some idea about WebFlux, you can deep dive into learning how
    WebFlux works by understanding reactive APIs and Reactor Core. Let’s first explore
    reactive APIs. You’ll explore Reactor Core in a subsequent subsection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对WebFlux有了些了解，你可以通过理解响应式API和Reactor Core来深入了解WebFlux的工作原理。让我们首先探索响应式API。你将在后续小节中探索Reactor
    Core。
- en: Understanding reactive APIs
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解响应式API
- en: Spring WebFlux APIs are reactive APIs and accept `Publisher` as the plain input.
    WebFlux then adapts it to a type supported by a reactive library such as Reactor
    Core or RxJava. It then processes the input and returns the output in a format
    supported by the reactive library. This allows WebFlux APIs to be interoperable
    with other reactive libraries.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux API是响应式API，接受`Publisher`作为普通输入。WebFlux然后将其适配为响应式库（如Reactor Core或RxJava）支持的类型。然后处理输入，并以响应式库支持的格式返回输出。这使得WebFlux
    API可以与其他响应式库互操作。
- en: By default, Spring WebFlux uses Reactor ([https://projectreactor.io](https://projectreactor.io))
    as a core dependency. Project Reactor provides the Reactive Streams library. As
    stated in the previous paragraph, WebFlux accepts the input as `Publisher`, then
    adapts it to a Reactor type, and then returns it as a `Mono` or `Flux` output.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring WebFlux 使用 Reactor ([https://projectreactor.io](https://projectreactor.io))
    作为核心依赖。Project Reactor 提供了响应式流库。如前所述，WebFlux 接受输入作为 `Publisher`，然后将其适配为 Reactor
    类型，然后作为 `Mono` 或 `Flux` 输出返回。
- en: You know that `Publisher` in Reactive Streams pushes the data to its subscribers
    based on demand. It can push one or more (possibly infinite) elements. Project
    Reactor takes it further and provides two `Publisher` implementations, namely
    `Mono` and `Flux`. `Mono` can return either `0` or `1` to `Subscriber`, whereas
    `Flux` returns `0` to `N` elements. Both are abstract classes that implement the
    `CorePublisher` interface. The `CorePublisher` interface extends the publisher.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道在响应式流中，`Publisher` 根据需求将数据推送到其订阅者。它可以推送一个或多个（可能是无限个）元素。Project Reactor 进一步扩展了这一点，并提供了两个
    `Publisher` 实现，即 `Mono` 和 `Flux`。`Mono` 可以返回 `0` 或 `1` 个元素给 `Subscriber`，而 `Flux`
    返回 `0` 到 `N` 个元素。这两个都是实现了 `CorePublisher` 接口的抽象类。`CorePublisher` 接口扩展了发布者。
- en: 'Normally, we have the following methods in the repository:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在仓库中有以下方法：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These can be replaced with `Mono` and `Flux`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以替换为 `Mono` 和 `Flux`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Streams can be either hot or cold based on whether the source can be restarted
    or not. The source is restarted if there are multiple subscribers for cold streams,
    while the same source is used for multiple subscribers in hot streams. Project
    Reactor streams are, by default, cold. Therefore, once you consume a stream, you
    can’t reuse it until it’s restarted. However, Project Reactor allows you to turn
    a cold stream into a hot one by using `cache()` methods. Both `Mono` and `Flux`
    abstract classes support cold and hot streams.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据源是否可以重新启动，流可以是热流或冷流。如果冷流有多个订阅者，则源会被重新启动，而在热流中，多个订阅者使用相同的源。Project Reactor
    流默认是冷流。因此，一旦你消费了一个流，你无法重用它，直到它重新启动。然而，Project Reactor 允许你使用 `cache()` 方法将冷流转换为热流。`Mono`
    和 `Flux` 抽象类都支持冷流和热流。
- en: 'Let’s understand the cold and hot stream concepts with some examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来理解冷流和热流的概念：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have created a `Flux` object, `fluxInt`, that contains three numbers.
    Then, we are performing two operations separately – `sum` and `max`. You can see
    that there are two subscribers. By default, Project Reactor streams are cold;
    therefore, when a second subscriber registers, it restarts, as shown in the following
    output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含三个数字的 `Flux` 对象，`fluxInt`。然后，我们分别执行两个操作——`sum` 和 `max`。你可以看到有两个订阅者。默认情况下，Project
    Reactor 流是冷流；因此，当第二个订阅者注册时，它会重新启动，如下面的输出所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The source is created in the same program, but what if the source is somewhere
    else, such as in an HTTP request, or you don’t want to restart the source? In
    these cases, you can turn the cold stream into a hot stream by using `cache()`,
    as shown in the next code block. The only difference between the following code
    and the previous code is that we have added a `cache()` call to `Flux.just()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 源是在同一程序中创建的，但如果源在其他地方，比如在 HTTP 请求中，或者你不想重新启动源怎么办？在这些情况下，你可以使用 `cache()` 将冷流转换为热流，如下面的代码块所示。以下代码与之前代码的唯一区别是我们向
    `Flux.just()` 添加了一个 `cache()` 调用：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, look at the output. The source has not restarted; instead, the same source
    is used again:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看输出。源没有重新启动；相反，再次使用了相同的源：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have got to the crux of reactive APIs, let’s see what Spring WebFlux’s
    Reactive Core consists of.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经触及了响应式 API 的核心，让我们看看 Spring WebFlux 的响应式核心包含什么。
- en: Reactive Core
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式核心
- en: 'Reactive Core provides a foundation for developing a reactive web application
    with Spring. A web application needs three levels of support for serving HTTP
    web requests:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式核心为使用 Spring 开发响应式 Web 应用程序提供了一个基础。Web 应用程序需要三个级别的支持来服务 HTTP 网络请求：
- en: 'Handling web requests by the server using the following:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用以下方式处理网络请求：
- en: '`HttpHandler`: An interface of the `reactor.core.publisher.Mono` package that
    is an abstraction of a request/response handler over different HTTP server APIs,
    such as Netty or Tomcat:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpHandler`：`reactor.core.publisher.Mono` 包中的一个接口，它是对不同 HTTP 服务器 API（如 Netty
    或 Tomcat）上的请求/响应处理程序的抽象：'
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`WebHandler`: An interface of the `org.springframework.web.server` package
    that provides support for user sessions, request and session attributes, a locale
    and principal for the request, form data, and so on. You can find more information
    about `WebHandler` at [https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api).'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebHandler`：`org.springframework.web.server`包中的一个接口，它为用户会话、请求和会话属性、请求的本地化和主体、表单数据等提供支持。您可以在[https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api)找到有关`WebHandler`的更多信息。'
- en: Handling of a web request call by the client using `WebClient`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用`WebClient`处理网络请求调用。
- en: Codecs (`Encoder`, `Decoder`, `HttpMessageWriter`, `HttpMessageReader`, and
    `DataBuffer`) for the serialization and deserialization of content at both the
    server and client levels for the request and response.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在服务器和客户端级别对请求和响应内容进行序列化和反序列化的编解码器（`Encoder`、`Decoder`、`HttpMessageWriter`、`HttpMessageReader`和`DataBuffer`）。
- en: These components are at the core of Spring WebFlux. WebFlux application configuration
    also contains the following beans – `webHandler` (`DispatcherHandler`), `WebFilter`,
    `WebExceptionHandler`, `HandlerMapping`, `HandlerAdapter`, and `HandlerResultHandler`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件是Spring WebFlux的核心。WebFlux应用程序配置还包含以下bean - `webHandler` (`DispatcherHandler`)、`WebFilter`、`WebExceptionHandler`、`HandlerMapping`、`HandlerAdapter`和`HandlerResultHandler`。
- en: For REST service implementation, there are specific `HandlerAdapter` instances
    for the following web servers – Tomcat, Jetty, Netty, and Undertow. A web server
    such as Netty, which supports Reactive Streams, handles the subscriber’s demands.
    However, if the server handler does not support Reactive Streams, then the `org.
    springframework.http.server.reactive.ServletHttpHandlerAdapter` HTTP `HandlerAdapter`
    is used. `HandlerAdapter` handles the adaptation between Reactive Streams and
    the Servlet 3.1 container async I/O and implements a `Subscriber` class. `HandlerAdapter`
    uses the OS TCP buffers. OS TCP uses its own backpressure (control flow); that
    is, when the buffer is full, the OS uses the TCP backpressure to stop incoming
    elements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST服务实现，以下Web服务器有特定的`HandlerAdapter`实例 - Tomcat、Jetty、Netty和Undertow。支持反应式流的Web服务器，如Netty，处理订阅者的需求。然而，如果服务器处理程序不支持反应式流，则使用`org.springframework.http.server.reactive.ServletHttpHandlerAdapter`
    HTTP `HandlerAdapter`。`HandlerAdapter`处理反应式流和Servlet 3.1容器异步I/O之间的适配，并实现一个`Subscriber`类。`HandlerAdapter`使用OS
    TCP缓冲区。OS TCP使用自己的背压（控制流）；也就是说，当缓冲区满时，操作系统使用TCP背压来停止传入的元素。
- en: The browser, or any HTTP client, consumes REST APIs using the HTTP protocol.
    When a request is received by the web server, it forwards it to the Spring WebFlux
    application. Then, WebFlux builds the reactive pipeline that goes to the controller.
    `HttpHandler` is an interface between WebFlux and the web server that communicates
    using the HTTP protocol. If the underlying server supports Reactive Streams, such
    as Netty, then the subscription is done by the server natively. Else, WebFlux
    uses `ServletHttpHandlerAdapter` for Servlet 3.1 container-based servers. `ServletHttpHandlerAdapter`
    then adapts the streams to async I/O Servlet APIs and vice versa. Then, the subscription
    of Reactive Streams happens with `ServletHttpHandlerAdapter`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器或任何HTTP客户端都使用HTTP协议来消费REST API。当网络服务器接收到请求时，它将其转发到Spring WebFlux应用程序。然后，WebFlux构建通往控制器的反应式管道。`HttpHandler`是WebFlux与网络服务器之间的接口，它使用HTTP协议进行通信。如果底层服务器支持反应式流，例如Netty，则服务器会原生地完成订阅。否则，WebFlux使用`ServletHttpHandlerAdapter`来适配Servlet
    3.1容器化服务器。`ServletHttpHandlerAdapter`随后将流适配到异步I/O Servlet API，反之亦然。然后，通过`ServletHttpHandlerAdapter`进行反应式流的订阅。
- en: Therefore, in summary, `Mono`/`Flux` streams are subscribed by WebFlux internal
    classes, and when the controller sends a `Mono`/`Flux` stream, these classes convert
    it into HTTP packets. The HTTP protocol does support event streams. However, for
    other media types, such as JSON, Spring WebFlux subscribes the `Mono`/`Flux` streams
    and waits until `onComplete()` or `onError()` is triggered. Then, it serializes
    the whole list of elements, or a single element in the case of `Mono`, in one
    HTTP response.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，`Mono`/`Flux` 流由 WebFlux 内部类订阅，当控制器发送 `Mono`/`Flux` 流时，这些类将其转换为 HTTP
    数据包。HTTP 协议支持事件流。然而，对于其他媒体类型，如 JSON，Spring WebFlux 订阅 `Mono`/`Flux` 流，并等待触发 `onComplete()`
    或 `onError()`。然后，它将整个元素列表序列化，或者对于 `Mono` 的情况，在一个 HTTP 响应中序列化单个元素。
- en: Spring WebFlux needs a component like `DispatcherServlet` in Spring MVC – a
    front controller. Let’s discuss this in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 需要一个类似于 Spring MVC 中的 `DispatcherServlet` 的组件——一个前端控制器。让我们在下一节中讨论这个问题。
- en: Understanding DispatcherHandler
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `DispatcherHandler`
- en: '`DispatcherHandler`, a front controller in Spring WebFlux, is the equivalent
    of `DispatcherServlet` in the Spring MVC framework. `DispatcherHandler` contains
    an algorithm that makes use of special components – `HandlerMapping` (maps requests
    to the handler), `HandlerAdapter` (a `DispatcherHandler` helper to invoke a handler
    mapped to a request), and `HandlerResultHandler` (a palindrome of words, for processing
    the result and forming results) – for processing requests. The `DispatcherHandler`
    component is identified by a bean named `webHandler`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherHandler` 是 Spring WebFlux 中的前端控制器，相当于 Spring MVC 框架中的 `DispatcherServlet`。`DispatcherHandler`
    包含一个算法，该算法利用特殊组件——`HandlerMapping`（将请求映射到处理器）、`HandlerAdapter`（`DispatcherHandler`
    的助手，用于调用映射到请求的处理器）和 `HandlerResultHandler`（用于处理结果并形成结果）——来处理请求。`DispatcherHandler`
    组件由名为 `webHandler` 的 bean 标识。'
- en: 'It processes requests in the following way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它以以下方式处理请求：
- en: A web request is received by `DispatcherHandler`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络请求由 `DispatcherHandler` 接收。
- en: '`DispatcherHandler` uses `HandlerMapping` to find a matching handler for the
    request and uses the first match.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DispatcherHandler` 使用 `HandlerMapping` 来查找与请求匹配的处理器，并使用第一个匹配项。'
- en: It then uses the respective `HandlerAdapter` to process the request, which exposes
    `HandlerResult` (the value returned by `HandlerAdapter` after processing). The
    return value could be one of the following – `ResponseEntity`, `ServerResponse`,
    values returned from `@RestController`, or values (`CharSequence`, `view`, `map`,
    and so on) returned by a view resolver.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它使用相应的 `HandlerAdapter` 来处理请求，该适配器在处理后会暴露 `HandlerResult`（`HandlerAdapter`
    处理请求后返回的值）。返回值可能是以下之一——`ResponseEntity`、`ServerResponse`，或者来自 `@RestController`
    的值，或者来自视图解析器的值（`CharSequence`、`view`、`map` 等等）。
- en: Then, it makes use of the respective `HandlerResultHandler` to write the response
    or render a view based on the `HandlerResult` type received from *step 2*. `ResponseEntityResultHandler`
    is used for `ResponseEntity`, `ServerResponseResultHandler` is used for `ServerResponse`,
    `ResponseBodyResultHandler` is used for values returned by the `@RestController`
    or `@ResponseBody` annotated method, and `ViewResolutionResultHandler` is used
    for values returned by the view resolver.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它利用相应的 `HandlerResultHandler` 根据从 *步骤 2* 收到的 `HandlerResult` 类型来写入响应或渲染视图。`ResponseEntityResultHandler`
    用于 `ResponseEntity`，`ServerResponseResultHandler` 用于 `ServerResponse`，`ResponseBodyResultHandler`
    用于由 `@RestController` 或 `@ResponseBody` 注解的方法返回的值，而 `ViewResolutionResultHandler`
    用于视图解析器返回的值。
- en: The request is completed.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求完成。
- en: You can create REST endpoints in Spring WebFlux using either an annotated controller
    such as Spring MVC or functional endpoints. Let’s explore these in the next sections.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Spring WebFlux 中使用注解控制器（如 Spring MVC）或功能端点来创建 REST 端点。让我们在下一节中探讨这些内容。
- en: Controllers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: The Spring team has kept the same annotations for both Spring MVC and Spring
    WebFlux as these annotations are non-blocking. Therefore, you can use the same
    annotations we used in previous chapters to create REST controllers. In Spring
    WebFlux, the annotation runs on Reactive Core and provides a non-blocking flow.
    However, you, as the developer, have the responsibility of maintaining a fully
    non-blocking flow and the reactive chain (pipeline). Any blocking calls in a reactive
    chain will convert the reactive chain into a blocking call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 团队为 Spring MVC 和 Spring WebFlux 保留了相同的注解，因为这些注解是非阻塞的。因此，你可以使用我们在前几章中使用过的相同注解来创建
    REST 控制器。在 Spring WebFlux 中，注解运行在响应式核心上，并提供非阻塞流。然而，作为开发人员，你有责任维护一个完全非阻塞的流和响应式链（管道）。任何在响应式链中的阻塞调用都将将响应式链转换为阻塞调用。
- en: 'Let’s create a simple REST controller that supports non-blocking and reactive
    calls:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的支持非阻塞和响应式调用的 REST 控制器：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see that it uses all the annotations that we have used in Spring MVC:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，它使用了我们在 Spring MVC 中使用过的所有注解：
- en: '`@RestController` is used to mark a class as a REST controller. Without this,
    the endpoint won’t register, and the request will be returned as `NOT` `FOUND
    404`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController` 用于标记一个类为 REST 控制器。如果没有这个注解，端点将不会注册，请求将返回 `NOT FOUND 404`。'
- en: '`@RequestMapping` is used to define the path and HTTP method. Here, you can
    also use `@PostMapping` with just the path. Similarly, for each of the HTTP methods,
    there is a respective mapping, such as `@GetMapping`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping` 用于定义路径和 HTTP 方法。在这里，你也可以仅使用路径使用 `@PostMapping`。同样，对于每个 HTTP
    方法，都有一个相应的映射，例如 `@GetMapping`。'
- en: The `@RequestBody` annotation marks a parameter as a request body, and an appropriate
    codec will be used for conversion. Similarly, there are `@PathVariable` and `@RequestParam`
    for the path parameter and query parameter, respectively.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestBody` 注解将一个参数标记为请求体，并使用适当的编解码器进行转换。同样，`@PathVariable` 和 `@RequestParam`
    分别用于路径参数和查询参数。'
- en: We are going to use an annotation-based model to write the REST endpoints. You’ll
    get a closer look when we implement the e-commerce app controllers using WebFlux.
    Spring WebFlux also provides a way to write a REST endpoint using a functional
    programming style, which you’ll explore in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于注解的模型来编写 REST 端点。当我们使用 WebFlux 实现电子商务应用控制器时，你将更详细地了解它。Spring WebFlux
    还提供了一种使用函数式编程风格编写 REST 端点的方法，你将在下一节中探索。
- en: Functional endpoints
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式端点
- en: The REST controllers we coded using Spring MVC were written in imperative-style
    programming. Reactive programming, on the other hand, is functional-style programming.
    Therefore, Spring WebFlux also allows an alternative way to define REST endpoints,
    using functional endpoints. These also use the same Reactive Core foundation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Spring MVC 编写的 REST 控制器是命令式编程风格的。另一方面，响应式编程是函数式编程风格。因此，Spring WebFlux 也允许使用函数式端点来定义
    REST 端点。这些端点也使用相同的响应式核心基础。
- en: 'Let’s see how we can write the same `Order` REST endpoint of the sample e-commerce
    app, using a functional endpoint:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用函数式端点编写示例电子商务应用的相同 `Order` REST 端点：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, you can see that the `RouterFunctions.route()` builder
    allows you to write all the REST routes in a single statement using the functional
    programming style. Then, it uses the method reference of the handler class to
    process the request, which is the same as the `@RequestMapping` body of an annotation-based
    model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到 `RouterFunctions.route()` 构建器允许你使用函数式编程风格在一个语句中编写所有的 REST 路由。然后，它使用处理类的方法引用来处理请求，这与基于注解模型的
    `@RequestMapping` 主体相同。
- en: 'Let’s add the following code to the `OrderHandler` methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `OrderHandler` 方法中添加以下代码：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike the `@RequestMapping()` mapping methods in the REST controller, handler
    methods don’t have multiple parameters, such as body, path, or query parameters.
    They just have a `ServerRequest` parameter, which can be used to extract the body,
    path, and query parameters. In the `addOrder` method, the `Order` object is extracted
    using `request.bodyToMono()`, which parses the request body and then converts
    it into an `Order` object. Similarly, the `getOrderById()` method retrieves the
    `order` object identified by the given ID from a server request object by calling
    `request. pathVariable("id")`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST控制器中的`@RequestMapping()`映射方法不同，处理方法没有多个参数，如body、path或查询参数。它们只有一个`ServerRequest`参数，可以用来提取body、path和查询参数。在`addOrder`方法中，使用`request.bodyToMono()`提取`Order`对象，它解析请求体并将其转换为`Order`对象。同样，`getOrderById()`方法通过调用`request.pathVariable("id")`从服务器请求对象中检索由给定ID标识的`order`对象。
- en: Now, let’s discuss the response. The handler method uses the `ServerResponse`
    object in comparison to `ResponseEntity` in Spring MVC. Therefore, the `ok()`
    static method looks like it’s from `ResponseEntity`, but it is from `org.springframework.
    web.reactive.function.server.ServerResponse.ok`. The Spring team has tried to
    keep the API as similar as possible to Spring MVC; however, the underlying implementation
    differs and provides a non-blocking reactive interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论响应。处理方法使用`ServerResponse`对象，而不是Spring MVC中的`ResponseEntity`。因此，`ok()`静态方法看起来像是来自`ResponseEntity`，但实际上来自`org.springframework.web.reactive.function.server.ServerResponse.ok`。Spring团队试图使API尽可能类似于Spring
    MVC；然而，底层实现不同，提供了一个非阻塞的反应式接口。
- en: The last point about these handler methods is the way a response is written.
    It uses a functional style instead of an imperative style and makes sure that
    the reactive chain does not break. The repository returns the `Mono` object (a
    publisher) in both cases as a response wrapped inside `ServerResponse`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些处理方法最后一点是响应的编写方式。它使用函数式风格而不是命令式风格，并确保反应式链不会断裂。在两种情况下，仓库都返回`Mono`对象（一个发布者），作为包裹在`ServerResponse`中的响应。
- en: You can find interesting code in the `getOrderById()` handler method. It performs
    a `flatMap` operation on the received `Mono` object from the repository. It converts
    it from an entity into a model, then wraps it in a `ServerResponse` object, and
    returns the response. You must be wondering what happens if the repository returns
    null. The repository returns `Mono` as per the contract, which is similar in nature
    to the Java `Optional` class. Therefore, the `Mono` object can be empty but not
    null, as per the contract. If the repository returns an empty `Mono`, then the
    `switchIfEmpty()` operator will be used and a `NOT FOUND 404` response will be
    sent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`getOrderById()`处理方法中找到有趣的代码。它对从仓库接收到的`Mono`对象执行`flatMap`操作。它将其从实体转换为模型，然后将其包装在`ServerResponse`对象中，并返回响应。你可能想知道如果仓库返回null会发生什么。根据契约，仓库返回`Mono`，这与Java的`Optional`类性质相似。因此，根据契约，`Mono`对象可以是空的但不能为null。如果仓库返回一个空的`Mono`，则将使用`switchIfEmpty()`操作符，并发送`NOT
    FOUND 404`响应。
- en: In the case of an error, there are different error operators that can be used,
    such as `doOnError()` or `onErrorReturn()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在出错的情况下，可以使用不同的错误操作符，例如`doOnError()`或`onErrorReturn()`。
- en: We have discussed the logic flow using the `Mono` type; the same explanation
    will apply if you use the `Flux` type in place of the `Mono` type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用`Mono`类型进行逻辑流程；如果你用`Flux`类型代替`Mono`类型，同样的解释也适用。
- en: We have discussed a lot of theory relating to reactive, asynchronous, and non-blocking
    programming in a Spring context. Let’s jump into coding and migrate the e-commerce
    API developed in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business
    Logic for APIs*, to a reactive API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在Spring环境中与反应式、异步和非阻塞编程相关的许多理论。现在让我们开始编码，将第[*第4章*](B19349_04.xhtml#_idTextAnchor097)中开发的电子商务API，*为API编写业务逻辑*，迁移到反应式API。
- en: Implementing reactive APIs for our e-commerce app
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的电子商务应用实现反应式API
- en: Now that you have an idea of how Reactive Streams works, we can go ahead and
    implement REST APIs that are asynchronous and non-blocking.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了Reactive Streams的工作原理，我们可以继续实现异步和非阻塞的REST API。
- en: You’ll recall that we are following the design-first approach, so we need the
    API design specification first. However, we can reuse the e-commerce API specification
    we created previously in [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API
    Specifications* *and Implementation*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们正在遵循设计优先的方法，因此我们首先需要API设计规范。然而，我们可以重用我们在[*第3章*](B19349_03.xhtml#_idTextAnchor080)中创建的电子商务API规范，*API规范和实现*。
- en: OpenAPI Codegen is used to generate the API interface/contract that creates
    the Spring MVC-compliant API Java interfaces. Let’s see what changes we need to
    do to generate the reactive API interfaces.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI Codegen用于生成创建符合Spring MVC规范的API Java接口的API接口/合约。让我们看看我们需要进行哪些更改来生成reactive
    API接口。
- en: Changing OpenAPI Codegen for reactive APIs
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改OpenAPI Codegen以支持reactive API
- en: 'You need to tweak a few OpenAPI Codegen configurations to generate Spring WebFlux-compliant
    Java interfaces, as shown next:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要调整一些OpenAPI Codegen配置以生成符合Spring WebFlux规范的Java接口，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json)'
- en: Reactive API support is only there if you opt for `spring-boot` as the library.
    Also, you need to set the `reactive` flag to `true`. By default, the `reactive`
    flag is `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你选择`spring-boot`作为库时，才会提供Reactive API支持。此外，你需要将`reactive`标志设置为`true`。默认情况下，`reactive`标志是`false`。
- en: 'Now, you can run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行以下命令：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will generate Reactive Streams-compliant Java interfaces, which are annotation-based
    REST controller interfaces. When you open any API interface, you’ll find `Mono`/`Flux`
    reactor types in it, as shown in the following code block for the `OrderAPI` interface:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成符合Reactive Streams规范的Java接口，这些接口是基于注解的REST控制器接口。当你打开任何API接口时，你会在其中找到`Mono`/`Flux`反应器类型，如下面的`OrderAPI`接口代码块所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will have observed another change: an additional parameter, `ServerWebExchange`,
    is also required for reactive controllers.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你会观察到另一个变化：对于reactive控制器，还需要一个额外的参数，`ServerWebExchange`。
- en: Now, when you compile your code, you may find compilation errors because we
    haven’t yet added the dependencies required for reactive support. Let’s learn
    how to add them in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你编译你的代码时，你可能会发现编译错误，因为我们还没有添加所需的reactive支持依赖项。让我们在下一节中学习如何添加它们。
- en: Adding Reactive dependencies to build.xml
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在build.xml中添加Reactive依赖
- en: First, we’ll remove `spring-boot-starter-web` as we don’t need Spring MVC now.
    Second, we’ll add `spring-boot-starter-webflux` and `reactor-test` for Spring
    WebFlux and Reactor support tests, respectively. Once these dependencies are added
    successfully, you should not see any compilation errors in the OpenAPI-generated
    code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将移除`spring-boot-starter-web`，因为我们现在不需要Spring MVC。其次，我们将添加`spring-boot-starter-webflux`和`reactor-test`以支持Spring
    WebFlux和Reactor支持测试。一旦成功添加这些依赖项，你就不应该在OpenAPI生成的代码中看到任何编译错误。
- en: 'You can add the required reactive dependencies to `build.gradle`, as shown
    next:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所需的reactive依赖项添加到`build.gradle`中，如下所示：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle)'
- en: We need to have a complete reactive pipeline from the REST controller to the
    database. However, existing JDBC and Hibernate dependencies only support blocking
    calls. JDBC is a fully blocking API. Hibernate is also blocking. Therefore, we
    need to have reactive dependencies for the database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从REST控制器到数据库的完整reactive管道。然而，现有的JDBC和Hibernate依赖项仅支持阻塞调用。JDBC是一个完全阻塞的API。Hibernate也是阻塞的。因此，我们需要为数据库提供reactive依赖项。
- en: Hibernate Reactive ([https://github.com/hibernate/hibernate-reactive](https://github.com/hibernate/hibernate-reactive))
    was released after the first edition of this book. Hibernate Reactive supports
    PostgreSQL, MySQL/MariaDB, Db2 11.5+, CockroachDB 22.1+, MS SQL Server 2019+,
    and Oracle Database 21+. Hibernate Reactive does not support H2 at the time of
    writing. Therefore, we will simply use Spring Data, a Spring framework that provides
    the `spring-data-r2dbc` library for working with Reactive Streams.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Reactive（[https://github.com/hibernate/hibernate-reactive](https://github.com/hibernate/hibernate-reactive)）是在本书第一版之后发布的。Hibernate
    Reactive支持PostgreSQL、MySQL/MariaDB、Db2 11.5+、CockroachDB 22.1+、MS SQL Server 2019+和Oracle
    Database 21+。在撰写本文时，Hibernate Reactive不支持H2。因此，我们将简单地使用Spring Data，这是一个提供`spring-data-r2dbc`库以处理响应式流的Spring框架。
- en: Many NoSQL databases, such as MongoDB, already provide a reactive database driver.
    An R2DBC-based driver should be used for relational databases in place of JDBC
    for fully non-blocking/reactive API calls. **R2DBC** stands for **Reactive Relational
    Database Connectivity**. R2DBC is a reactive API open specification that establishes
    a **Service Provider Interface** (**SPI**) for database drivers. Almost all the
    popular relational databases support R2DBC drivers – H2, Oracle Database, MySQL,
    MariaDB, SQL Server, PostgreSQL, and R2DBC Proxy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 许多NoSQL数据库，如MongoDB，已经提供了响应式数据库驱动程序。对于关系数据库，应使用基于R2DBC的驱动程序来替代JDBC，以实现完全非阻塞/响应式API调用。**R2DBC**代表**响应式关系数据库连接**。R2DBC是一个响应式API开放规范，它为数据库驱动程序建立了一个**服务提供者接口**（**SPI**）。几乎所有流行的关系数据库都支持R2DBC驱动程序——H2、Oracle
    Database、MySQL、MariaDB、SQL Server、PostgreSQL和R2DBC Proxy。
- en: 'Let’s add the R2DBC dependencies for Spring Data and H2 to the `build.gradle`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`build.gradle`文件中添加Spring Data和H2的R2DBC依赖项：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can write end-to-end (from the controller to the repository) code without
    any compilation errors. Let’s add global exception handling before we jump into
    writing an implementation for API Java interfaces.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写端到端（从控制器到仓库）的代码，而不会出现任何编译错误。在我们开始编写API Java接口的实现之前，让我们先添加全局异常处理。
- en: Handling exceptions
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: We’ll add the global exception handler the way it was added in Spring MVC in
    [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API Specifications and Implementation*.
    Before that, you must be wondering how to handle exceptions in a reactive pipeline.
    Reactive pipelines are a flow of streams and you can’t add exception handling
    the way you do in imperative code. You need to raise the error in a pipeline flow
    only.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与在[*第3章*](B19349_03.xhtml#_idTextAnchor080)中添加Spring MVC全局异常处理相同的方式添加全局异常处理器，*API规范和实现*。在此之前，你可能想知道如何在响应式管道中处理异常。响应式管道是一系列流，你不能像在命令式代码中那样添加异常处理。你需要在管道流程中仅提出错误。
- en: 'Check out the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, a `flatMap` operation is performed. An error should be thrown if `card`
    is not valid, that is, if `card` does not have the requested `ID`. Here, `Mono.error()`
    is used because the pipeline expects `Mono` as a returned object. Similarly, you
    can use `Flux.error()` if `Flux` is expected as the returned type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，执行了一个`flatMap`操作。如果`card`无效，即`card`没有请求的`ID`，则应该抛出一个错误。在这里，使用了`Mono.error()`，因为管道期望返回`Mono`对象。同样，如果你期望返回类型为`Flux`，也可以使用`Flux.error()`。
- en: 'Let’s assume you are expecting an object from a service or repository call,
    but instead, you receive an empty object. Then, you can use the `switchIfEmpty()`
    operator, as shown in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你期待从服务或仓库调用中获取一个对象，但结果却收到了一个空对象。这时，你可以使用`switchIfEmpty()`操作符，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the code expects a `Mono` object of the `List` type from the `item` repository.
    However, if the returned object is empty, then it simply throws the `ResourceNotFoundException.switchIfEmpty()`
    exception and accepts the alternate `Mono` instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码期望从`item`仓库中获取`List`类型的`Mono`对象。然而，如果返回的对象为空，则它将简单地抛出`ResourceNotFoundException.switchIfEmpty()`异常，并接受替代的`Mono`实例。
- en: 'By now, you might have a question about the type of exception. It throws a
    runtime exception. See the `ResourceNotFoundException` class declaration here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能对异常的类型有所疑问。它会抛出一个运行时异常。请在此处查看`ResourceNotFoundException`类的声明：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, you can also use `onErrorReturn()`, `onErrorResume()`, or similar
    error operators from Reactive Streams. Look at the use of `onErrorReturn()` in
    the next code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以使用来自响应式流的`onErrorReturn()`、`onErrorResume()`或类似的错误操作符。看看下一个代码块中`onErrorReturn()`的使用：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All exceptions should be handled, and an error response should be sent to the
    user. We’ll have a look at the global exception handler first, in the following
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有异常都应该被处理，并且应该向用户发送错误响应。我们将在下一节中查看全局异常处理器。
- en: Handling global exceptions for controllers
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理控制器的全局异常
- en: We created a global exception handler using `@ControllerAdvice` in Spring MVC.
    We’ll take a slightly different route for handling errors in Spring WebFlux. First,
    we’ll create the `ApiErrorAttributes` class, which can also be used in Spring
    MVC. This class extends `DefaultErrorAttributes`, which is a default implementation
    of the `ErrorAttributes` interface. The `ErrorAttributes` interface provides a
    way to handle maps, a map of error fields, and their values. These error attributes
    can then be used to display an error to the user or for logging.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Spring MVC 中使用 `@ControllerAdvice` 创建了一个全局异常处理器。对于 Spring WebFlux 中的错误处理，我们将采取不同的路线。首先，我们将创建
    `ApiErrorAttributes` 类，这个类也可以在 Spring MVC 中使用。这个类扩展了 `DefaultErrorAttributes`，它是
    `ErrorAttributes` 接口的一个默认实现。`ErrorAttributes` 接口提供了一种处理映射、错误字段映射及其值的方式。这些错误属性可以用来向用户显示错误或用于日志记录。
- en: 'The following attributes are provided by the `DefaultErrorAttributes` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultErrorAttributes` 类提供了以下属性：'
- en: '`timestamp`: The time that the error was captured'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`: 错误被捕获的时间'
- en: '`status`: The status code'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 状态码'
- en: '`error`: An error description'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 错误描述'
- en: '`exception`: The class name of the root exception (if configured)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception`: 根异常的类名（如果已配置）'
- en: '`message`: The exception message (if configured)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 异常消息（如果已配置）'
- en: '`errors`: Any `ObjectError` from a `BindingResult` exception (if configured)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errors`: 来自 `BindingResult` 异常的任何 `ObjectError`（如果已配置）'
- en: '`trace`: The exception stack trace (if configured)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace`: 异常堆栈跟踪（如果已配置）'
- en: '`path`: The URL path when the exception was raised'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 异常被抛出的 URL 路径'
- en: '`requestId`: The unique ID associated with the current request'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestId`: 与当前请求关联的唯一 ID'
- en: 'We have added two default values to the status and message – an internal server
    error and a generic error message (`The system is unable to complete the request.
    Contact system support.`), respectively – to `ApiErrorAttributes`, as shown next:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向状态和消息中添加了两个默认值——一个内部服务器错误和一个通用错误消息（`系统无法完成请求。请联系系统支持。`），分别添加到 `ApiErrorAttributes`
    中，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java)'
- en: Now, we can use this `ApiErrorAttributes` class in a custom global exception
    handler class. We’ll create the `ApiErrorWebExceptionHandler` class, which extends
    the `AbstractErrorWebExceptionHandler` abstract class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在自定义的全局异常处理器类中使用这个 `ApiErrorAttributes` 类。我们将创建 `ApiErrorWebExceptionHandler`
    类，它扩展了 `AbstractErrorWebExceptionHandler` 抽象类。
- en: 'The `AbstractErrorWebExceptionHandler` class implements the `ErrorWebExcepti``     onHandler` and `InitializingBean` interfaces. `ErrorWebExceptionHandler` is a
    functional interface that extends the `WebExceptionHandler` interface, which indicates
    that `WebExceptionHandler` is used for rendering exceptions. `WebExceptionHandler`
    is a contract for handling exceptions when server exchange processing takes place.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractErrorWebExceptionHandler` 类实现了 `ErrorWebExceptionHandler` 和 `InitializingBean`
    接口。`ErrorWebExceptionHandler` 是一个扩展了 `WebExceptionHandler` 接口的功能接口，这表明 `WebExceptionHandler`
    用于渲染异常。`WebExceptionHandler` 是在服务器交换处理过程中处理异常的契约。'
- en: The `InitializingBean` interface is a part of the Spring core framework. It
    is used by components that react when all properties are populated. It can also
    be used to check whether all the mandatory properties are set.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializingBean` 接口是 Spring 核心框架的一部分。它被用于当所有属性被填充时做出反应的组件。它也可以用来检查是否设置了所有必需的属性。'
- en: 'Now that we have studied the basics, let’s jump into writing the `ApiErrorAttributes`
    class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了基础知识，让我们开始编写 `ApiErrorAttributes` 类：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java)'
- en: The first important observation about this code is that we have added the `@Order`
    annotation, which tells us the preference of execution. `ResponseStatusExceptionHandler`
    is placed at the `0` index by the Spring Framework and `DefaultErrorWebExceptionHandler`
    is ordered at the `-1` index. Both are exception handlers like the one we have
    created. If you don’t give an order of precedence to `ApiErrorWebExceptionHandler`
    superseding both, then it won’t ever execute. Therefore, the order of precedence
    is set at `-2`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码的第一个重要观察是，我们添加了`@Order`注解，它告诉我们执行的优先级。Spring框架将`ResponseStatusExceptionHandler`放置在`0`索引处，而`DefaultErrorWebExceptionHandler`则按`-1`索引排序。这两个都是像我们创建的那样异常处理器。如果你不给`ApiErrorWebExceptionHandler`设置优先级，以超过两者，那么它将永远不会执行。因此，优先级设置为`-2`。
- en: 'Next, this class overrides the `getRoutingFunction()` method, which calls the
    privately defined `renderErrorResponse()` method, where we have our own custom
    implementation for error handling, as shown next:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，此类覆盖了`getRoutingFunction()`方法，它调用私有定义的`renderErrorResponse()`方法，其中我们有自己的自定义错误处理实现，如下所示：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java
- en: Here, first, we extract the error attributes in `errorPropertiesMap`. This will
    be used when we form the error response. Next, we capture the occurred exception
    using `throwable`. Then, we check the type of the exception and assign an appropriate
    code to it. We keep the default as `GenericError`, which is nothing more than
    `InternalServerError`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先，我们从`errorPropertiesMap`中提取错误属性。这将在我们形成错误响应时使用。接下来，我们使用`throwable`捕获发生的异常。然后，我们检查异常的类型，并为其分配适当的代码。我们保留默认的`GenericError`，这不过是`InternalServerError`。
- en: 'Next, we use a `switch` statement to form an error response based on the raised
    exception, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`switch`语句根据引发的异常形成错误响应，如下所示：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Probably in the next version of Java, we will be able to combine the `if-else`
    and `switch` blocks to make the code more concise. You can also create a separate
    method that takes `errorPropertiesMap` as an argument and returns the formed server
    response based on it. Then, you can use `switch`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的下一个版本中，我们可能能够将`if-else`和`switch`块结合起来，使代码更加简洁。你还可以创建一个单独的方法，该方法接受`errorPropertiesMap`作为参数，并根据它返回形成的服务器响应。然后，你可以使用`switch`。
- en: Custom application exception classes, such as `CustomerNotFoundException`, and
    other exception-handling-supported classes, such as `ErrorCode` and `Error`, are
    being used from the existing code (from [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic* *for APIs*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正在使用来自现有代码的自定义应用程序异常类，例如`CustomerNotFoundException`，以及其他异常处理支持的类，例如`ErrorCode`和`Error`（来自[*第4章*](B19349_04.xhtml#_idTextAnchor097)，*为API编写业务逻辑*）。
- en: Now that we have studied exception handling, we can concentrate on HATEOAS.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了异常处理，我们可以专注于HATEOAS。
- en: Adding hypermedia links to an API response
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在API响应中添加超媒体链接
- en: HATEOAS support for reactive APIs exists and is a bit like what we did in the
    previous chapter using Spring MVC. We create these assemblers again for HATEOAS
    support. We also use the HATEOAS assembler classes to convert a model into an
    entity and vice versa.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反应式API，存在HATEOAS支持，这与我们在上一章中使用Spring MVC所做的是类似的。我们再次创建这些组装器以支持HATEOAS。我们还使用HATEOAS组装器类将模型转换为实体，反之亦然。
- en: Spring WebFlux provides the `ReactiveRepresentationModelAssembler` interface
    for forming hypermedia links. We would override its `toModel()` method to add
    the links to response models.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux提供了用于形成超媒体链接的`ReactiveRepresentationModelAssembler`接口。我们将覆盖其`toModel()`方法，向响应模型添加链接。
- en: 'Here, we will do some groundwork for populating the links. We will create an
    `HateoasSupport` interface with a single default method, as shown next:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将做一些基础工作来填充链接。我们将创建一个具有单个默认方法的`HateoasSupport`接口，如下所示：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java)'
- en: Here, this class contains a single default method, `getUriCompononentBuilder()`,
    which accepts `ServerWebExchange` as an argument and returns the `UriComponentsBuilder`
    instance. This instance can then be used to extract the server URI that would
    be used to add the links with a protocol, host, and port. If you remember, the
    `ServerWebExchange` argument was added to controller methods. This interface is
    used to get the HTTP request, response, and other attributes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个类包含一个默认方法，`getUriCompononentBuilder()`，它接受`ServerWebExchange`作为参数，并返回`UriComponentsBuilder`实例。然后，可以使用此实例提取用于添加带有协议、主机和端口的链接的服务器URI。如果您还记得，`ServerWebExchange`参数被添加到控制器方法中。此接口用于获取HTTP请求、响应和其他属性。
- en: 'Now, we can use these two interfaces – `HateoasSupport` and `ReactiveRepresentation``     ModelAssembler` – to define the representation model assemblers.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这两个接口——`HateoasSupport`和`ReactiveRepresentation` ModelAssembler——来定义表示模型组装器。
- en: 'Let’s define the address’s representational model assembler, as shown next:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义地址的表示模型组装器，如下所示：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java)'
- en: Here, we have defined another private method, `getServerUri()`, which extracts
    the server URI from `UriComponentBuilder`, which itself is returned from the default
    `getUriComponentBuilder()` method of the `HateoasSupport` interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了另一个私有方法，`getServerUri()`，它从`UriComponentBuilder`中提取服务器URI，而`UriComponentBuilder`本身是由`HateoasSupport`接口的默认`getUriComponentBuilder()`方法返回的。
- en: 'Now, we can override the `toModel()` method, as shown in the following code
    block:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以覆盖`toModel()`方法，如下面的代码块所示：
- en: AddressRepresentationModelAssembler.java
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: AddressRepresentationModelAssembler.java
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `toModel()` method returns the `Mono<Address>` object with hypermedia links
    formed from the `AddressEntity` instance using the `entityToModel()` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`toModel()`方法返回一个包含超媒体链接的`Mono<Address>`对象，这些链接是通过使用`entityToModel()`方法从`AddressEntity`实例形成的。'
- en: '`entityToModel()` copies the properties from the entity instance to the model
    instance. Most importantly, it adds hypermedia links to the model using the `resource.add()`
    method. The `add()` method takes the `org.springframework.hateoas.Link` instance
    as an argument. Then, we use the `Link` class’s `of()` static factory method to
    form the link. You can see that a server URI is used here to add it to the link.
    You can form as many links as you want and add these to the resource using the
    `add()` method.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`entityToModel()`将实体实例的属性复制到模型实例。最重要的是，它使用`resource.add()`方法向模型添加超媒体链接。`add()`方法接受`org.springframework.hateoas.Link`实例作为参数。然后，我们使用`Link`类的`of()`静态工厂方法来形成链接。您可以看到这里使用服务器URI来添加到链接中。您可以形成尽可能多的链接，并使用`add()`方法将这些链接添加到资源中。'
- en: 'The `ReactiveRepresentationModelAssembler` interface provides the `toCollectionModel()`
    method with a default implementation that returns the `Mono<CollectionModel<D>>`
    collection model. However, we can also add the `toListModel()` method, as shown
    here, which returns the list of addresses using `Flux`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactiveRepresentationModelAssembler`接口提供了`toCollectionModel()`方法，它有一个默认实现，返回`Mono<CollectionModel<D>>`集合模型。然而，我们也可以添加`toListModel()`方法，如下所示，它使用`Flux`返回地址列表：'
- en: AddressRepresentationModelAssembler.java
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: AddressRepresentationModelAssembler.java
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method internally uses the `entityToModel()` method. Similarly, you can
    create a representation model assembler for other API models. You can find all
    these models at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法内部使用`entityToModel()`方法。同样，你可以为其他API模型创建表示模型装配器。你可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas)找到所有这些模型。
- en: Now that we are done with the basic code infrastructure, we can develop the
    API implementation based on the interfaces generated by OpenAPI Codegen. Here,
    we’ll first develop the repositories that will be consumed by the services. At
    the end, we’ll write the controller implementation. Let’s start with the repositories.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了基本的代码基础设施，我们可以根据OpenAPI Codegen生成的接口开发API实现。在这里，我们首先将开发将被服务消费的仓库。最后，我们将编写控制器实现。让我们从仓库开始。
- en: Defining an entity
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实体
- en: 'Entities are defined in more or less the same way as we defined and used them
    in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business Logic for
    APIs*. However, instead of using Hibernate mappings and JPA, we’ll use Spring
    Data annotations, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的定义方式与我们在[*第4章*](B19349_04.xhtml#_idTextAnchor097)，“为API编写业务逻辑”中定义和使用它们的方式大致相同。然而，我们不会使用Hibernate映射和JPA，而是使用Spring
    Data注解，如下所示：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java)'
- en: Here, because we are using Spring Data in place of Hibernate, we use Spring
    Data annotations, namely `@Table`, to associate an entity class to a table name,
    and `@Column` for mapping a field to a column of the table. As is obvious, `@Id`
    is used as the identifier column. Similarly, you can define the other entities.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，因为我们使用Spring Data代替Hibernate，所以我们使用Spring Data注解，即`@Table`来关联实体类和表名，以及`@Column`来映射字段到表的列。显然，`@Id`用作标识列。同样，你可以定义其他实体。
- en: After defining the entities, let’s add repositories in the next subsection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了实体之后，我们将在下一小节中添加仓库。
- en: Adding repositories
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加仓库
- en: A repository is an interface between our application code and database. It is
    the same as the respository you used in Spring MVC. However, we are writing the
    code using the reactive paradigm. Therefore, it is necessary to have repositories
    that use an R2DBC-/reactive-based driver and return instances of reactive types
    on top of Reactive Streams. This is the reason why we can’t use JDBC.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是我们应用程序代码和数据库之间的接口。它与你在Spring MVC中使用的仓库相同。然而，我们正在使用反应式范式编写代码。因此，需要具有使用R2DBC-/反应式驱动程序的仓库，并在Reactive
    Streams之上返回反应式类型实例。这就是为什么我们不能使用JDBC的原因。
- en: Spring Data R2DBC provides different repositories for Reactor and RxJava, for
    example, `ReactiveCrudRepository` and `ReactiveSortingRepository` and `RxJava2CrudRepository`
    and `RxJava3CrudRepository`. Also, you can write your own custom implementation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data R2DBC为Reactor和RxJava提供了不同的仓库，例如`ReactiveCrudRepository`、`ReactiveSortingRepository`、`RxJava2CrudRepository`和`RxJava3CrudRepository`。此外，你也可以编写自己的自定义实现。
- en: We are going to use `ReactiveCrudRepository` and also write a custom implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ReactiveCrudRepository`并编写一个自定义实现。
- en: We’ll write repositories for the `Order` entity. For other entities, you can
    find the repositories at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`Order`实体编写仓库。对于其他实体，你可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository)找到仓库。
- en: 'First, let’s write the CRUD repository for the `Order` entity, as shown next:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为`Order`实体编写CRUD仓库，如下所示：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java)'
- en: This is as simple as shown. The `OrderRepository` interface extends `ReactiveCrudRepository`
    and our own custom repository interface, `OrderRepositoryExt`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像显示的那样简单。`OrderRepository`接口扩展了`ReactiveCrudRepository`和我们的自定义仓库接口`OrderRepositoryExt`。
- en: We’ll discuss `OrderRepositoryExt` a bit later; let’s discuss `OrderRepository`
    first. We have added one extra method, `findByCustomerId()`, to the `OrderRepository`
    interface, which finds the order by the given customer ID. The `ReactiveCrudRepository`
    interface and the `Query()` annotation are part of the Spring Data R2DBC library.
    `Query()` consumes native SQL queries, unlike the repository we created in the
    previous chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论`OrderRepositoryExt`；让我们先讨论`OrderRepository`。我们在`OrderRepository`接口中添加了一个额外的方法`findByCustomerId()`，通过给定的客户ID查找订单。`ReactiveCrudRepository`接口和`Query()`注解是Spring
    Data R2DBC库的一部分。`Query()`消耗原生SQL查询，与我们在上一章中创建的仓库不同。
- en: 'We can also write our own custom repository. Let’s write a simple contract
    for it, as shown next:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写自己的自定义仓库。让我们为它编写一个简单的合约，如下所示：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java)'
- en: Here, we have written two method signatures – the first one inserts a new order
    record in the database and the second one updates the order item and cart item
    mapping. The idea is that once an order is placed, items should be removed from
    the cart and added to the order. If you want, you can also combine both operations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们编写了两个方法签名——第一个将新订单记录插入数据库，第二个更新订单项和购物车项的映射。想法是，一旦下单，项目应该从购物车中移除并添加到订单中。如果您愿意，您也可以合并这两个操作。
- en: 'Let’s first define the `OrderRepositoryExtImpl` class, which extends the `OrderRepositoryExt`
    interface, as shown in the following code block:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义`OrderRepositoryExtImpl`类，它扩展了`OrderRepositoryExt`接口，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java)'
- en: We have just defined a few class properties and added these properties in the
    constructor as an argument for constructor-based dependency injection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一些类属性，并在构造函数中将这些属性作为参数添加，用于基于构造函数的依赖注入。
- en: 'As per the contract, it receives `Mono<NewOrder>`. Therefore, we need to add
    a method that converts a model into an entity to the `OrderRepositoryExtImpl`
    class. We also need an extra argument as `CartEntity` contains the cart items.
    Here it is:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据合同，它接收`Mono<NewOrder>`。因此，我们需要在`OrderRepositoryExtImpl`类中添加一个将模型转换为实体的方法。我们还需要一个额外的参数，因为`CartEntity`包含了购物车中的商品。下面是代码：
- en: OrderRepositoryExtImpl.java
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: OrderRepositoryExtImpl.java
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This method is straightforward except for the code where the total is set.
    The total is calculated using the stream. Let’s break it down to understand it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很简单，除了设置总额的代码。总额是通过流计算的。让我们分解它以了解它：
- en: First, it takes the items from `CartEntity`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它从`CartEntity`中获取项目。
- en: Then, it creates streams from items.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它从项目中创建流。
- en: It creates a map with the key as the product ID and the value as the product
    of the quantity and price.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个以产品ID为键，以数量和价格的乘积为值的映射。
- en: It takes the value from the map and converts it into a stream.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从映射中获取值并将其转换为流。
- en: It performs the reduce operation by adding a method to `BigDecimal`. It then
    gives the total amount.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过向`BigDecimal`添加一个方法来执行reduce操作。然后给出总金额。
- en: If values are not present, then it simply returns `0`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有值，它将简单地返回`0`。
- en: 'After the `toEntity()` method, we also need another mapper that reads rows
    from the database and converts them into `OrderEntity`. For this purpose, we’ll
    write `BiFunction`, which is a part of the `java.util.function` package:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toEntity()`方法之后，我们还需要另一个映射器，它从数据库中读取行并将它们转换为`OrderEntity`。为此，我们将编写`BiFunction`，它是`java.util.function`包的一部分：
- en: OrderRepositoryExtImpl.java
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: OrderRepositoryExtImpl.java
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we have overridden the `apply()` method, which returns `OrderEntity`,
    by mapping properties from the row to `OrderEntity`. The second parameter of the
    `apply()` method is not used because it contains metadata that we don’t need.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过将行属性映射到`OrderEntity`来覆盖了`apply()`方法，它返回`OrderEntity`。`apply()`方法的第二个参数没有被使用，因为它包含我们不需要的元数据。
- en: 'Let’s first implement the `updateMapping()` method from the `OrderRepositoryExt`
    interface:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现`OrderRepositoryExt`接口中的`updateMapping()`方法：
- en: OrderRepositoryExtImpl.java
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: OrderRepositoryExtImpl.java
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we have created a pipeline of Reactive Streams and performed two back-to-back
    database operations. First, it creates the order item mapping using `OrderItemRepository`,
    and then it removes the cart item mapping using `ItemRepository`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个响应式流的管道并执行了两个连续的数据库操作。首先，它使用`OrderItemRepository`创建订单项映射，然后使用`ItemRepository`删除购物车项映射。
- en: Java streams are used to create an input list of `OrderItemEntity` instances
    in the first operation, and a list of item IDs in the second operation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个操作中，Java流用于创建`OrderItemEntity`实例的输入列表，在第二个操作中创建项目ID列表。
- en: 'So far, we have made use of `ReactiveCrudRepository` methods. Let’s implement
    a custom method using an entity template, as shown next:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了`ReactiveCrudRepository`方法。让我们使用实体模板实现一个自定义方法，如下所示：
- en: OrderRepositoryExtImpl.java
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: OrderRepositoryExtImpl.java
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we override the `insert()` method from the `OrderRepositoryExt` interface.
    The `insert()` method is filled with fluent, functional, and reactive APIs. The
    `insert()` method receives a `NewOrder` model `Mono` instance as an argument that
    contains the payload for creating a new order. Spring Data R2DBC does not allow
    fetching nested entities. However, you can write a custom repository for `Cart`
    in the same way you have written for `Order` that can fetch `Cart` and its items
    together.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们覆盖了`OrderRepositoryExt`接口中的`insert()`方法。`insert()`方法使用流畅的、函数式的和响应式的API填充。`insert()`方法接收一个包含创建新订单负载的`NewOrder`模型`Mono`实例作为参数。Spring
    Data R2DBC不允许获取嵌套实体。然而，你可以像为`Order`编写的那样编写一个自定义的`Cart`存储库，它可以一起获取`Cart`及其项目。
- en: We are using `ReactiveCrudRepository` for `Cart` and `Item` entities. Therefore,
    we are fetching them one by one. First, we use the item repository to fetch the
    cart items based on the given customer ID. `Customer` has a one-to-one mapping
    with `Cart`. Then, we fetch the `Cart` entity using `CartRepository` by using
    the customer ID.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`ReactiveCrudRepository`为`Cart`和`Item`实体。因此，我们逐个获取它们。首先，我们使用项目存储库根据给定的客户ID获取购物车项目。`Customer`与`Cart`有一个一对一的映射。然后，我们使用`CartRepository`通过客户ID获取`Cart`实体。
- en: We get the two separate Mono objects – `Mono<List<ItemEntity>>` and `Mono<CartEntity>`.
    Now, we need to combine them. `Mono` has a `zip()` operator, which allows you
    to take two `Mono` objects and then use the Java `BiFunction` to merge them. `zip()`
    returns a new `Mono` object only when both the given `Mono` objects produce the
    item. `zip()` is polymorphic and therefore other forms are also available.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两个单独的`Mono`对象 - `Mono<List<ItemEntity>>`和`Mono<CartEntity>`。现在，我们需要将它们组合起来。`Mono`有一个`zip()`操作符，它允许你取两个`Mono`对象，然后使用Java的`BiFunction`来合并它们。`zip()`仅在给定的两个`Mono`对象都产生项目时返回一个新的`Mono`对象。`zip()`是多态的，因此也有其他形式可用。
- en: 'We have the cart and its items, plus the `NewOrder` payload. Let’s insert these
    items into a database, as shown in the next code block:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了购物车及其项目，以及`NewOrder`负载。让我们将这些项目插入到数据库中，如下所示：
- en: OrderRepositoryExtImpl.java
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: OrderRepositoryExtImpl.java
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we again use `Mono.zip()` to create an `OrderEntity` instance. Now, we
    can use values from this instance to insert into the `orders` table.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`Mono.zip()`创建一个`OrderEntity`实例。现在，我们可以使用此实例的值插入到`orders`表中。
- en: There are two ways to interact with the database to run SQL queries – by using
    either `DatabaseClient` or `R2dbcEntityTemplate`. Now, `DatabaseClient` is a lightweight
    implementation that uses the `sql()` method to deal with SQL directly, whereas
    `R2dbcEntityTemplate` provides a fluent API for CRUD operations. We have used
    both classes to demonstrate their usage.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库交互以运行SQL查询有两种方式——使用`DatabaseClient`或`R2dbcEntityTemplate`。现在，`DatabaseClient`是一个轻量级实现，它使用`sql()`方法直接处理SQL，而`R2dbcEntityTemplate`提供了一个用于CRUD操作的流畅API。我们已经使用了这两个类来展示它们的用法。
- en: First, we use `DatabaseClient.sql()` to insert the new order into the `orders`
    table. We use `OrderMapper` to map the row returned from the database to the entity.
    Then, we use the `then()` reactive operator to select the newly inserted record
    and then map it back to `orderEntity` using the `R2dbcEntityTemplate.selectOne()`
    method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`DatabaseClient.sql()`将新订单插入到`orders`表中。我们使用`OrderMapper`将数据库返回的行映射到实体。然后，我们使用`then()`反应性操作符选择新插入的记录，然后使用`R2dbcEntityTemplate.selectOne()`方法将其映射回`orderEntity`。
- en: Similarly, you can create repositories for other entities. Now, we can use these
    repositories in services. Let’s define services in the next subsection.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以为其他实体创建存储库。现在，我们可以在服务中使用这些存储库。让我们在下一小节中定义服务。
- en: Adding services
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加服务
- en: 'Let’s add a service for `Order`. There is no change in the `OrderService` interface,
    as shown next. You just need to make sure that interface method signatures have
    reactive types as returned types to keep the non-blocking flow in place:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Order`添加一个服务。`OrderService`接口没有变化，如下所示。你只需要确保接口方法签名具有作为返回类型的反应性类型，以保持非阻塞流程：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java)'
- en: 'Next, you are going to implement each of these four methods described in `OrderService`.
    Let’s first implement the first two methods of `OrderService` in the following
    way:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将实现`OrderService`中描述的每个方法。让我们首先以下这种方式实现`OrderService`的前两个方法：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java)'
- en: 'The first two are straightforward; we just use the `OrderRepository` instance
    to call the respective methods. In an idle scenario, the overridden `updateMapping`
    method will trigger the rest of the process after updating the mappings:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法很简单；我们只是使用`OrderRepository`实例来调用相应的方法。在空闲场景中，重写的`updateMapping`方法将在更新映射后触发其余过程：
- en: Initiate the payment.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动支付。
- en: Once the payment is authorized, change the status to `paid`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦支付被授权，将状态更改为`已支付`。
- en: Initiate the shipment and changed the status to `Shipment Initiated` or `Shipped`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动运输并将状态更改为`运输启动`或`已运输`。
- en: As our application is not a real-world app and we are writing for learning purposes,
    we are not writing the code for executing all three steps. For simplicity, we
    are just updating the mapping.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序不是一个真实世界的应用程序，我们是为了学习目的而编写的代码，所以我们没有编写执行所有三个步骤的代码。为了简单起见，我们只是更新映射。
- en: 'Let’s implement the third one (`getOrdersByCustomerId`). This is a bit tricky,
    as shown next:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现第三个方法（`getOrdersByCustomerId`）。这有点棘手，如下所示：
- en: OrderServiceImpl.java
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: OrderServiceImpl.java
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The previous method looks complicated, but it’s not. What you are doing here
    is basically fetching data from multiple repositories and then populating the
    nested entities inside `OrderEntity`. This is done with the `zipWith()` operator
    by using either the `map()` operator alongside it or `BiFunction` as a separate
    argument.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个方法看起来很复杂，但实际上并不复杂。你在这里做的基本上是从多个仓库中获取数据，然后使用`zipWith()`操作符，通过与之并用的`map()`操作符或作为单独参数的`BiFunction`来填充`OrderEntity`内部的嵌套实体。
- en: The preceding method first fetches the orders by using the customer ID, then
    flat maps the orders to populate its nested entities such as `Customer`, `Order`,
    and `Items`. Therefore, we are using `zipWith()` inside the `flatMap()` operator.
    If you observe the first `zipWith()`, it fetches the user entity and then sets
    the nested user entity’s property using the `map()` operator. Similarly, other
    nested entities are populated.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个方法首先使用客户ID获取订单，然后使用`flatMap()`操作符将订单扁平化以填充其嵌套实体，如`Customer`、`Order`和`Items`。因此，我们在`flatMap()`操作符内部使用`zipWith()`。如果你观察第一个`zipWith()`，它会获取用户实体，然后使用`map()`操作符设置嵌套用户实体的属性。同样，其他嵌套实体也被填充。
- en: In the last `zipWith()` operator, we are using `BiFunction` `biOrderItems` to
    set the `item` entities in the `OrderEntity` instance.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个`zipWith()`操作符中，我们使用`BiFunction` `biOrderItems`来设置`OrderEntity`实例中的`item`实体。
- en: 'The same algorithm is used to implement the last method (`getOrderById`) of
    the `OrderService` interface, as shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口`OrderService`的最后一个方法（`getOrderById`）使用了相同的算法，如下面的代码所示：
- en: OrderServiceImpl.java
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: OrderServiceImpl.java
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So far, you have used the `zipWith()` operator to merge different objects.
    You may find another way to merge two `Mono` instances using the `Mono.zip()`
    operator, as shown next:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了`zipWith()`操作符来合并不同的对象。你可能发现另一种使用`Mono.zip()`操作符合并两个`Mono`实例的方法，如下所示：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java)'
- en: This example is taken from the `CartServiceImpl` class. Here, we make two separate
    calls – one using the `cart` repository and another one from the `item` repository.
    As a result, these two calls produce two `Mono` instances and merge them using
    the `Mono.zip()` operator. This we call directly using `Mono`; the previous example
    was used on `Mono`/`Flux` instances with the `zipWith()` operator.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是从`CartServiceImpl`类中提取的。在这里，我们进行了两次独立的调用——一次使用`cart`仓库，另一次使用`item`仓库。结果，这两个调用产生了两个`Mono`实例，并使用`Mono.zip()`操作符将它们合并。我们直接使用`Mono`来调用这个操作；上一个例子是在`Mono`/`Flux`实例上使用`zipWith()`操作符。
- en: Using similar techniques, the remaining services have been created. You can
    find them at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的技术，创建了剩余的服务。你可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service)找到它们。
- en: You have implemented async services that allow you to perform async operations,
    including database calls. Now, you can consume these service classes in controllers.
    Let’s move our focus on to the last development subsection (controllers) of our
    reactive API implementation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经实现了允许你执行异步操作（包括数据库调用）的异步服务。现在，你可以在控制器中消费这些服务类。让我们将我们的重点转移到我们的反应式API实现开发的最后一个子部分（控制器）。
- en: Adding controller implementations
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制器实现
- en: REST controller interfaces are already generated by the OpenAPI Codegen tool.
    We can now create an implementation of those interfaces. The only different thing
    while implementing the reactive controller is having the reactive pipelines to
    call the services and assemblers. You should also only return `ResponseEntity`
    objects wrapped in either `Mono` or `Flux` based on the generated contract.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: REST控制器接口已经由OpenAPI Codegen工具生成。我们现在可以创建这些接口的实现。在实现反应式控制器时，唯一的不同之处在于需要具有反应式管道来调用服务和组装器。您还应该仅根据生成的契约返回封装在`Mono`或`Flux`中的`ResponseEntity`对象。
- en: 'Let’s implement `OrderApi`, which is the controller interface for the `Orders`
    REST API:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`OrderApi`，这是`Orders` REST API的控制接口：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java)'
- en: Here, `@RestController` is a trick that combines `@Controller` and `@ResponseBody`.
    These are the same annotations we used in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic for APIs*, to create the REST controller. However, the
    methods have different signatures now to apply the reactive pipelines. Make sure
    you don’t break the reactive chain of calls or add any blocking calls. If you
    do, either the REST call will not be fully non-blocking or you may see undesired
    results.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@RestController`是一个结合了`@Controller`和`@ResponseBody`的技巧。这些是我们用于在[*第4章*](B19349_04.xhtml#_idTextAnchor097)，“为API编写业务逻辑”中创建REST控制器所使用的相同注解。然而，现在方法有不同的签名，以便应用反应式管道。确保您不要打破调用链的反应式性或添加任何阻塞调用。如果您这样做，要么REST调用将不会完全非阻塞，或者您可能会看到不期望的结果。
- en: 'We use constructor-based dependency injection to inject the order service and
    assembler. Let’s add the method implementations:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于构造函数的依赖注入来注入订单服务和组装器。让我们添加方法实现：
- en: OrderController.java
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: OrderController.java
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Both the method argument and return type are reactive types (`Mono`), used as
    a wrapper. Reactive controllers also have an extra parameter, `ServerWebExchange`,
    which we discussed earlier.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的参数和返回类型都是反应式类型（`Mono`），用作包装器。反应式控制器还有一个额外的参数，`ServerWebExchange`，我们之前讨论过。
- en: In this method, we simply pass the `newOrder` instance to the service. We have
    used `cache()` because we need to subscribe to it more than once. We get the newly
    created `EntityOrder` through the `addOrder()` call. Then, we use the `zipWhen()`
    operator, which performs the `updateMapping` operation using the newly created
    order entity. At the end, we send the `Order` object by wrapping it inside `ResponseEntity`.
    Also, it returns `NOT FOUND 404` when an empty instance is returned.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们简单地将`newOrder`实例传递给服务。我们使用了`cache()`，因为我们需要多次订阅它。我们通过`addOrder()`调用获取新创建的`EntityOrder`。然后，我们使用`zipWhen()`运算符，它使用新创建的订单实体执行`updateMapping`操作。最后，我们通过将`Order`对象封装在`ResponseEntity`中发送它。如果返回一个空实例，它还会返回`NOT
    FOUND 404`。
- en: 'Let’s have a look at other method implementations of the `order` API interface:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`order` API接口的其他方法实现：
- en: OrderController.java
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: OrderController.java
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the previous code, both methods are kind of similar in nature; the service
    returns `OrderEntity` based on the given customer ID and order ID, respectively.
    It then gets converted into a model and is wrapped inside `ResponseEntity` and
    `Mono`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个方法在本质上有些相似；服务根据给定的客户ID和订单ID分别返回`OrderEntity`。然后它被转换成模型，并封装在`ResponseEntity`和`Mono`中。
- en: Similarly, other REST controllers are implemented using the same approach. You
    can find the rest of them at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，其他REST控制器也是使用相同的方法实现的。您可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller)找到它们的其余部分。
- en: We are almost done with the reactive API implementation. Let’s look into some
    of the other minor changes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了反应式API的实现。让我们看看一些其他的细微变化。
- en: Adding H2 Console to an application
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将H2控制台添加到应用程序中
- en: 'The H2 Console app is not available by default in Spring WebFlux the way it
    is available in Spring MVC. However, you can add it by defining the bean on your
    own, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: H2控制台应用程序在Spring WebFlux中默认不可用，就像它在Spring MVC中可用一样。然而，你可以通过定义自己的bean来添加它，如下所示：
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java)'
- en: The previous code (`H2ConsoleComponent`) is straightforward; we have added the
    `start()` and `stop()` methods, which are executed on `ContextRefreshEvent` and
    `ContextStopEvent`, respectively. `ContextRefreshEvent` is an application event
    that gets fired when `ApplicationContext` is refreshed or initialized. `ContextStopEvent`
    is also an application event that gets fired when `ApplicationContext` is closed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码（`H2ConsoleComponent`）很简单；我们添加了`start()`和`stop()`方法，它们分别在`ContextRefreshEvent`和`ContextStopEvent`上执行。`ContextRefreshEvent`是一个应用程序事件，当`ApplicationContext`刷新或初始化时被触发。`ContextStopEvent`也是一个应用程序事件，当`ApplicationContext`关闭时被触发。
- en: The `start()` method creates the web server using the H2 library and starts
    it on a given port. The `stop()` method stops the H2 web server, that is, the
    H2 Console app.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`方法使用H2库创建网络服务器，并在指定的端口上启动它。`stop()`方法停止H2网络服务器，即H2控制台应用程序。'
- en: You need a different port to execute H2 Console, which can be configured by
    adding the `modern.api.h2.console.port=8081` property to the `application.properties`
    file. The `h2ConsolePort` property is annotated with `@Value("${modern.api.h2.console.port:8081}")`;
    therefore, the value configured in `application.properties` will be picked and
    assigned to `h2ConsolePort` when the `H2ConsoleComponent` bean is initialized
    by the Spring Framework. The value `8081` will be assigned if the property is
    not defined in the `application.properties` file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个不同的端口来执行H2控制台，这可以通过将`modern.api.h2.console.port=8081`属性添加到`application.properties`文件中来配置。`h2ConsolePort`属性被注解为`@Value("${modern.api.h2.console.port:8081}")`；因此，当Spring框架初始化`H2ConsoleComponent`bean时，将选择并分配`application.properties`中配置的值到`h2ConsolePort`。如果`application.properties`文件中没有定义该属性，则分配的值将是`8081`。
- en: Since we are discussing `application.properties`, let’s have a look at some
    of the other changes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论`application.properties`，让我们看看一些其他的更改。
- en: Adding application configuration
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加应用程序配置
- en: 'We are going to use Flyway for database migration. Let’s add the configuration
    required for it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Flyway进行数据库迁移。让我们添加所需的配置：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties)'
- en: You must be wondering why we are using JDBC here, instead of R2DBC. This is
    because Flyway hasn’t yet started supporting R2DBC (at the time of writing). You
    can change it to R2DBC once support is added.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在这里使用JDBC，而不是R2DBC。这是因为Flyway还没有开始支持R2DBC（在撰写本文时）。一旦添加了支持，你可以将其更改为R2DBC。
- en: We have specified the `ecomm` schema and set a blank username and password.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了`ecomm`模式，并设置了一个空的用户名和密码。
- en: 'Similarly, you can add the Spring Data configuration in the `application.properties`
    file:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在`application.properties`文件中添加Spring Data配置：
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Spring Data supports R2DBC; therefore, we are using an R2DBC-based URL. We have
    set `io.r2dbc:r2dbc-h2` for the driver to H2 and set a blank username and password.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data支持R2DBC；因此，我们使用基于R2DBC的URL。我们将`io.r2dbc:r2dbc-h2`设置为H2的驱动程序，并设置了一个空的用户名和密码。
- en: 'Similarly, we have added the following logging properties to `logback-spring.xml`
    to add debug statements to the console for Spring R2DBC and H2:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们已经将以下日志属性添加到`logback-spring.xml`中，以向控制台添加Spring R2DBC和H2的调试语句：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This concludes our implementation of reactive RESTful APIs. Now, you can test
    them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们反应式RESTful API实现的结束。现在，您可以测试它们了。
- en: Testing reactive APIs
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试反应式API
- en: 'Now, you must be looking forward to testing. You can find the API client collection
    at the following location. You can import it and then test the APIs using any
    API client that supports the HAR-type file import:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您一定期待着测试。您可以在以下位置找到API客户端集合。您可以导入它，然后使用支持HAR类型文件导入的任何API客户端来测试API。
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har)'
- en: Building and running the Chapter 05 code
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 构建05章代码并运行
- en: You can build the code by running `gradlew clean build` from the root of the
    project and run the service using `java -jar build/libs/Chapter05-0.0.1-SNAPSHOT.jar`.
    Make sure to use Java 17 in the path.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在项目的根目录下运行`gradlew clean build`来构建代码，并使用`java -jar build/libs/Chapter05-0.0.1-SNAPSHOT.jar`来运行服务。请确保在路径中使用Java
    17。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: I hope you enjoyed learning about reactive API development with an asynchronous,
    non-blocking, and functional paradigm. At first glance, you may find it complicated
    if you are not very familiar with the fluent and functional paradigm, but with
    practice, you’ll start writing only functional-style code. Definitely, familiarity
    with Java streams and functions will help you to grasp the concepts easily.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您喜欢使用异步、非阻塞和函数式范式学习反应式API开发。乍一看，如果您不太熟悉流畅和函数式范式，可能会觉得它很复杂，但通过实践，您将开始只编写函数式风格的代码。当然，熟悉Java流和函数将帮助您轻松掌握这些概念。
- en: Now that you have reached the end of this chapter, you have the skills to write
    functional and reactive code. You can write reactive, asynchronous, and non-blocking
    code and REST APIs. You also learned about R2DBC, which will become more solid
    and enhanced in the future as long as reactive programming continues to be used.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经到达本章的结尾，您已经拥有了编写函数式和反应式代码的技能。您可以编写反应式、异步和非阻塞的代码以及REST API。您还了解了R2DBC，只要继续使用反应式编程，它将在未来变得更加稳固和增强。
- en: In the next chapter, we’ll explore the security aspect of RESTful service development.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨RESTful服务开发的安全性方面。
- en: Questions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do you really need the reactive paradigm for application development?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您真的需要反应式范式来进行应用程序开发吗？
- en: Are there any disadvantages to using the reactive paradigm?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用反应式范式有什么缺点吗？
- en: Who plays the role of the subscriber in the case of an HTTP request in Spring
    WebFlux?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring WebFlux中，对于HTTP请求的情况，谁扮演订阅者的角色？
- en: Answers
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Yes, it is required only if you need vertical scaling. In the cloud, you pay
    to use the resources, and reactive applications help you to use resources optimally.
    This is a new way of achieving scale. You need a small number of threads compared
    to non-reactive applications. The cost of connection to a database, I/O, or any
    external source is a callback; therefore, reactive-based applications do not require
    much memory. However, while reactive programming is superior in terms of vertical
    scaling, you should continue using your existing or non-reactive applications.
    Even Spring recommends that. There is no new or old style; both can co-exist.
    However, when you need scaling for any special component or application, you can
    go the reactive way. A few years back, Netflix replaced the Zuul API gateway with
    the reactive Zuul2 API gateway. This helped them to achieve scale. However, they
    still have/use non-reactive applications.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，只有在您需要垂直扩展时才需要。在云中，您为使用资源付费，反应式应用程序帮助您优化资源使用。这是一种实现扩展的新方法。与无反应式应用程序相比，您需要的线程数量较少。连接到数据库、I/O或任何外部源的成本是一个回调；因此，基于反应式应用程序不需要太多内存。然而，尽管在垂直扩展方面反应式编程更优越，您应该继续使用现有的或非反应式应用程序。甚至Spring也建议这样做。没有新或旧的风格；两者可以共存。然而，当您需要扩展任何特殊组件或应用程序时，您可以选择反应式方法。几年前，Netflix用反应式的Zuul2
    API网关替换了Zuul API网关。这帮助他们实现了扩展。然而，他们仍然/使用非反应式应用程序。
- en: There are pros and cons to everything. Reactive is no exception. Reactive code
    is not easy to write compared to the imperative style. It is very difficult to
    debug because it does not use a single thread. However, if you have developers
    who are proficient in the reactive paradigm, this isn’t an issue.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何事物都有其利弊。反应式编程也不例外。与命令式风格相比，反应式代码编写起来并不容易。由于它不使用单个线程，因此调试起来非常困难。然而，如果你有精通反应式范式的开发者，这并不是一个问题。
- en: WebFlux internal classes subscribe to `Mono`/`Flux` streams sent by the controller
    and convert them into HTTP packets. The HTTP protocol does support event streams.
    However, for other media types, such as JSON, Spring WebFlux subscribes `Mono`/`Flux`
    streams and waits till `onComplete()` or `onError()` is triggered. Then, it serializes
    the whole list of elements, or a single element in the case of `Mono`, in one
    HTTP response. You can learn more about it in the *Reactive* *Core* section.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebFlux内部类订阅由控制器发送的`Mono`/`Flux`流，并将它们转换为HTTP数据包。HTTP协议确实支持事件流。然而，对于其他媒体类型，如JSON，Spring
    WebFlux订阅`Mono`/`Flux`流，并等待`onComplete()`或`onError()`被触发。然后，它将整个元素列表序列化，或者对于`Mono`，将单个元素序列化到一个HTTP响应中。你可以在*反应式*
    *核心*部分了解更多相关信息。
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Project Reactor: [https://projectreactor.io](https://projectreactor.io)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Reactor：[https://projectreactor.io](https://projectreactor.io)
- en: 'Spring Reactive documentation: [https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Reactive文档：[https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)
- en: 'Spring Data R2DBC – reference documentation: [https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/](https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data R2DBC – 参考文档：[https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/](https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/)
- en: '*Hands-On Reactive Programming in Spring* *5*: [https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951](https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Spring 5实战反应式编程》* 第5版：[https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951](https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951)'
- en: '*Learn Java 17 Programming – Second* *Edition*: [https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432](https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Java 17编程学习——第二版》*: [https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432](https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432)'
- en: Part 2 – Security, UI, Testing, and Deployment
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 安全性、UI、测试和部署
- en: In this part, you will learn how to secure REST APIs with JWTs and Spring Security.
    After completing this part, you will also be able to authorize REST endpoints
    based on user roles. You will learn how APIs are consumed by the UI app, and you
    will learn how to automate the unit testing and integration testing of APIs. By
    the end of this part, you will be able to containerize the built app and then
    deploy it in a Kubernetes cluster.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将学习如何使用JWT和Spring Security保护REST API。完成这部分后，你还将能够根据用户角色授权REST端点。你将了解UI应用如何消费API，以及如何自动化API的单元测试和集成测试。到这部分结束时，你将能够将构建的应用容器化，然后在Kubernetes集群中部署它。
- en: 'This part contains the following chapters:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 6*](B19349_06.xhtml#_idTextAnchor148), *Securing REST Endpoints Using
    Authorization and Authentication*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19349_06.xhtml#_idTextAnchor148), *使用授权和认证保护REST端点*'
- en: '[*Chapter 7*](B19349_07.xhtml#_idTextAnchor169), *Designing a User Interface*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19349_07.xhtml#_idTextAnchor169), *设计用户界面*'
- en: '[*Chapter 8*](B19349_08.xhtml#_idTextAnchor201), *Testing APIs*'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19349_08.xhtml#_idTextAnchor201), *测试API*'
- en: '[*Chapter 9*](B19349_09.xhtml#_idTextAnchor215), *Deployment of Web Services*'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19349_09.xhtml#_idTextAnchor215), *Web服务的部署*'
