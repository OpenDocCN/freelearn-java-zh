- en: Chapter 11. JSF 2.2 Resource Library Contracts – Themes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. JSF 2.2 资源库合约 – 主题
- en: Starting with version 2.0, JSF developers exploit Facelets as the default **View
    Declaration Language** (**VDL**). Facelets provide many advantages, but we are
    especially interested in using **Facelet templates**, which represent a mix of
    XHTML and other resources such as CSS, JS, and images. A Facelet template acts
    as a base (or a model) for the application pages. Practically, it represents a
    piece of reusable code that serves as a consistent and standard look and feel
    for the application pages. In the final chapter of this book, we will get more
    into the details of Facelets and templating, while in this chapter we will focus
    on the new JSF 2.2 feature known as **Resource Library Contracts**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0开始，JSF开发者利用Facelets作为默认的**视图声明语言**（**VDL**）。Facelets提供了许多优势，但我们特别感兴趣的是使用**Facelet模板**，它代表了一种XHTML和其他资源（如CSS、JS和图像）的混合。Facelet模板充当应用程序页面的基础（或模型）。实际上，它代表了一段可重用的代码，为应用程序页面提供了一致和标准的视觉和感觉。在本书的最后一章中，我们将更深入地探讨Facelets和模板的细节，而本章我们将重点介绍新的JSF
    2.2特性，称为**资源库合约**。
- en: This new feature fortifies and simplifies the implementation of **themes** (such
    as PrimeFaces or RichFaces) by allowing us to easily decorate and use Facelet
    templates over the entire application in a reusable and flexible approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新特性通过允许我们以可重用和灵活的方式轻松装饰和使用整个应用程序中的Facelet模板，从而加强了并简化了**主题**（如PrimeFaces或RichFaces）的实现。
- en: 'In this chapter, you will see how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到如何执行以下操作：
- en: Work with contracts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与合约一起工作
- en: Style the JSF tables and UI components using contracts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合约样式JSF表格和UI组件
- en: Style contracts across different kinds of devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同设备间的样式合约
- en: Write contracts for composite components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组合组件编写合约
- en: Write a theme switcher
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写主题切换器
- en: Configure contracts in XML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML中配置合约
- en: Package contracts in JARs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将合约打包到JAR中
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Further, keep in mind to correctly interpret the *contracts* word in the current
    context. It can be used to define the concepts such as the `contracts` folder,
    the `contracts` attribute, or the `<contracts>` tag. Sometimes, it may get confusing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意正确理解当前上下文中的*合约*一词。它可以用来定义诸如`contracts`文件夹、`contracts`属性或`<contracts>`标签等概念。有时，它可能会令人困惑。
- en: Working with contracts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与合约一起工作
- en: Contracts consist of templates and CSS files that are grouped under the `contracts`
    folder. In order to define contracts, we need to respect some conventions under
    the root directory of Web application. The most important conventions (for example,
    names, structure, and content) concern folders that are involved in the defining
    of contracts. All contracts are stored under a special folder—named `contracts`—placed
    directly under the Web root of the application, or under the `META-INF` folder
    that resides in a JAR file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 合约由模板和CSS文件组成，这些文件组成了`contracts`文件夹。为了定义合约，我们需要在Web应用的根目录下遵守一些约定。最重要的约定（例如，名称、结构和内容）涉及参与定义合约的文件夹。所有合约都存储在一个特殊的文件夹中——命名为`contracts`——直接位于应用的Web根目录下，或者位于JAR文件中的`META-INF`文件夹下。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can alter the location and the name of this folder via `WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`
    context parameter. The value of this context parameter must not start with a slash
    (`/`), though it may contain a slash. The runtime will interpret this value as
    a path relative to the Web root of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`上下文参数来更改此文件夹的位置和名称。尽管这个上下文参数可以包含斜杠（`/`），但它的值不能以斜杠开头。运行时将此值解释为相对于应用Web根目录的路径。
- en: Commonly, under the `contracts` folder, we define a subfolder for each contract
    (the subfolder's name represents the contract's name), which contains the contract's
    artifacts such as the CSS, JS, images, and XHTML templates (you can separate resources
    such as CSS, JS, and images from the XHTML templates by adding them into representative
    subfolders).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在`contracts`文件夹下，我们为每个合约定义一个子文件夹（子文件夹的名称代表合约的名称），其中包含合约的工件，如CSS、JS、图像和XHTML模板（您可以通过将它们添加到代表子文件夹中，将CSS、JS和图像等资源与XHTML模板分开）。
- en: 'In the following screenshot, you can see the folder structure for two contracts
    (`rafa1` and `rafa2`) in the same application, named `ch11_1`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到同一应用程序中两个合约（`rafa1`和`rafa2`）的文件夹结构，命名为`ch11_1`：
- en: '![Working with contracts](img/6466EN_11_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![与合约一起工作](img/6466EN_11_01.jpg)'
- en: 'In our example, the source code for `rafa1/template.xhtml` and `rafa2/template.xhtml`
    is identical (of course, this is not mandatory); however, they just use different
    CSS files. These XHTML files serve as templates for the application pages. The
    listing of `rafa1/template.xhtml` is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`rafa1/template.xhtml` 和 `rafa2/template.xhtml` 的源代码是相同的（当然，这并非强制要求）；然而，它们只是使用了不同的
    CSS 文件。这些 XHTML 文件作为应用页面的模板。以下是 `rafa1/template.xhtml` 的列表：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Further, you can use the contracts directly in the application web pages, thanks
    to the new JSF 2.2 attribute of the `<f:view>` tag named `contracts` (this has
    to be placed in the template client). The value of this attribute should be the
    contract name that you want to use. For example, if you want to use the contract
    named `rafa2`, you can write this in the `index.xhtml` page as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以直接在应用网页中使用合约，归功于 `<f:view>` 标签的新 JSF 2.2 属性 `contracts`（这必须放在模板客户端）。此属性的值应该是你想要使用的合约名称。例如，如果你想使用名为
    `rafa2` 的合约，你可以在 `index.xhtml` 页面上这样写：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to use the contract named `rafa1`, you just need to specify this name
    as the value of the `contracts` attribute.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用名为 `rafa1` 的合约，你只需将此名称指定为 `contracts` 属性的值。
- en: The complete application is named `ch11_1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为 `ch11_1`。
- en: Styling tables with contracts
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合约来设置表格样式
- en: 'Now that you know how to write and use contracts, you can try to play around
    with this great feature for creating different kinds of styles/themes for your
    pages. Most of the time, creating cool themes involves two things: having a cool
    and flexible templating mechanism and having solid knowledge of CSS and JS.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写和使用合约，你可以尝试玩转这个伟大的功能，为你的页面创建不同种类的样式/主题。大多数时候，创建酷炫的主题涉及两个因素：拥有一个酷炫且灵活的模板机制，以及拥有扎实的
    CSS 和 JS 知识。
- en: 'For example, we can try to write two cool themes for the JSF tables. First,
    we''ll define two contracts named `tableBlue` and `tableGreen`. The XHTML template,
    in both the cases, will have the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以尝试为 JSF 表格编写两个酷炫的主题。首先，我们将定义两个名为 `tableBlue` 和 `tableGreen` 的合约。在两种情况下，XHTML
    模板都将包含以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you can use the `tableBlue` or `tableGreen` contract, as shown in the
    following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `tableBlue` 或 `tableGreen` 合约，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如以下截图所示：
- en: '![Styling tables with contracts](img/6466EN_11_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用合约设置表格样式](img/6466EN_11_02.jpg)'
- en: 'As you can see, there is no need to specify a class or a style attribute for
    `<h:dataTable>`. The idea is pretty simple; JSF renders `<h:dataTable>` using
    HTML tags such as `<table>`, `<tr>`, `<td>`, `<tbody>`, `<thead>`, and `<tfoot>`.
    So, if we write a CSS style sheet that customizes the aspect of these HTML tags,
    then we will obtain the desired results. For `<h:dataTable>`, a basic CSS may
    contain the following classes (`content` matches the value of the `name` attribute
    of the `<ui:define>` component):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有必要为 `<h:dataTable>` 指定一个类或样式属性。这个想法很简单；JSF 使用 HTML 标签如 `<table>`、`<tr>`、`<td>`、`<tbody>`、`<thead>`
    和 `<tfoot>` 来渲染 `<h:dataTable>`。因此，如果我们编写一个自定义这些 HTML 标签外观的 CSS 样式表，那么我们将获得期望的结果。对于
    `<h:dataTable>`，基本的 CSS 可能包含以下类（`content` 与 `<ui:define>` 组件的 `name` 属性值匹配）：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sometimes, you may need to add pagination to your tables. JSF doesn''t provide
    attributes for this task (unlike the `<p:dataTable>` tag in PrimeFaces). But,
    as an example, you may fix this issue if you write a footer, like the following
    code snippet—of course, the `<div>` content should be dynamically generated and
    controlled (for more details, see [Chapter 6](ch06.html "Chapter 6. Working with
    Tabular Data"), *Working with Tabular Data*):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要给你的表格添加分页。JSF 不提供用于此任务的属性（与 PrimeFaces 中的 `<p:dataTable>` 标签不同）。但是，作为一个例子，如果你编写一个类似于以下代码片段的页脚，你可能可以解决这个问题——当然，`<div>`
    内容应该是动态生成并控制的（更多详情请见[第 6 章](ch06.html "第 6 章。处理表格数据")，*处理表格数据*）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you need to add a few CSS classes to control the pagination aspect, as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要添加一些 CSS 类来控制分页方面，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下截图所示：
- en: '![Styling tables with contracts](img/6466EN_11_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用合约设置表格样式](img/6466EN_11_03.jpg)'
- en: Special thanks to Eli Geske, the author of *Learning DHTMLX Suite UI* ([http://www.packtpub.com/learning-dhtmlx-suite-ui/book](http://www.packtpub.com/learning-dhtmlx-suite-ui/book)).
    His free online CSS3 table generator (you can find HTML Table Style Generator
    at [http://tablestyler.com/](http://tablestyler.com/)) was really useful to accomplish
    the result in this section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 特别感谢Eli Geske，他是《学习DHTMLX Suite UI》一书的作者([http://www.packtpub.com/learning-dhtmlx-suite-ui/book](http://www.packtpub.com/learning-dhtmlx-suite-ui/book))。他的免费在线CSS3表格生成器（你可以在
    [http://tablestyler.com/](http://tablestyler.com/) 找到HTML表格样式生成器）在本节的成果中非常有用。
- en: The complete application is named `ch11_3`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch11_3`。
- en: Styling UI components with contracts
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合约样式化UI组件
- en: 'Based on the preceding example, we can write styles/themes for all the JSF
    UI components. In this section, you can see an example that focuses on JSF UI
    components that usually appear in forms such as `<h:inputText>`, `<h:inputTextarea>`,
    `<h:selectOneMenu>`, `<h:selectManyCheckbox>`, and so on. Practically, we want
    to obtain something like the following screenshot (this is just a sample form):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的示例，我们可以为所有的JSF UI组件编写样式/主题。在本节中，你可以看到一个专注于通常出现在表单中的JSF UI组件的示例，例如 `<h:inputText>`、`<h:inputTextarea>`、`<h:selectOneMenu>`、`<h:selectManyCheckbox>`
    等。实际上，我们希望得到以下截图（这只是一个示例表单）：
- en: '![Styling UI components with contracts](img/6466EN_11_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用合约样式化UI组件](img/6466EN_11_04.jpg)'
- en: 'We start by defining a new contract named `jsfui`. The template is pretty simple,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的合约名为 `jsfui`。模板相当简单，如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we just need to write the CSS classes that correspond to the HTML elements
    rendered by JSF, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要编写与JSF渲染的HTML元素对应的CSS类，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can easily add CSS classes for the rest of UI components. Further, you
    can write JSF forms with a custom theme, just by specifying the theme name as
    the value of the `contracts` attribute:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地为其他UI组件添加CSS类。此外，你只需指定主题名称作为 `contracts` 属性的值，就可以编写具有自定义主题的JSF表单：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is named `ch11_2`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch11_2`。
- en: Styling contracts across different devices
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同设备上样式化合约
- en: In the preceding examples, we saw how to write the JSF contracts and how to
    use them by explicitly setting them by name in the `contracts` attribute of the
    `<f:view>` tag. Sometimes, you may need to dynamically set a contract (theme);
    for example, you may need to choose the right contract based on the device type
    that should display the application (PC, tablet, smartphone, mobile phone, and
    so on). In this case, you need to provide the `contracts` attribute value from
    a managed bean.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何编写JSF合约以及如何通过在 `<f:view>` 标签的 `contracts` 属性中显式设置它们来使用它们。有时，你可能需要动态设置一个合约（主题）；例如，你可能需要根据应该显示应用程序的设备类型（PC、平板电脑、智能手机、手机等）来选择正确的合约。在这种情况下，你需要从管理Bean中提供
    `contracts` 属性值。
- en: 'It is beyond the scope of this book to provide a powerful code (or algorithm)
    for detecting device types, resolutions, and so on. With minimum involvement in
    the mobile area, we will try to write a JSF application capable of choosing the
    right contract depending on the device type. Practically, we will define the following
    four contracts (do not consider the following associations between resolutions
    and devices as a certified or authorized decision):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提供用于检测设备类型、分辨率等的有力代码（或算法）超出了本书的范围。在最小程度地参与移动领域的情况下，我们将尝试编写一个JSF应用程序，使其能够根据设备类型选择正确的合约。实际上，我们将定义以下四个合约（不要将以下分辨率与设备之间的关联视为认证或授权的决定）：
- en: '`contracts/browserpc`: This contract applies to PCs (it will be the default)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/browserpc`：此合约适用于PC（它将是默认的）'
- en: '`contracts/Device640`: This contract applies to tablets (we suppose that, for
    any kind of tablet, a resolution of 640 pixels width is a reasonable choice)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/Device640`：此合约适用于平板电脑（我们假设对于任何类型的平板电脑，640像素的宽度是一个合理的选择）'
- en: '`contracts/Device480`: This contract applies to smartphones (we suppose that,
    for any kind of smartphone, a resolution of 480 pixels width is a reasonable choice)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/Device480`：此合约适用于智能手机（我们假设对于任何类型的智能手机，480像素的宽度是一个合理的选择）'
- en: '`contracts/Device320`: This contract applies to normal mobile phones (we suppose
    that, for any kind of mobile phone, a resolution of 320 pixels width is a reasonable
    choice)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/Device320`：此合约适用于普通手机（我们假设对于任何类型的手机，320像素的宽度是一个合理的选择）'
- en: 'Now, we will write a simple managed bean that will detect the device type based
    on the helper class named `UAgentInfo` (visit [http://blog.mobileesp.com/](http://blog.mobileesp.com/)).
    Basically, this class detects different kinds of devices based on the HTTP request
    headers, `User-Agent` and `Accept`. Based on this detection, we can set a managed
    bean property with the name of the correct contract. The managed bean code is
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个简单的托管Bean，它将根据名为`UAgentInfo`的辅助类（访问[http://blog.mobileesp.com/](http://blog.mobileesp.com/)）检测设备类型。基本上，这个类根据HTTP请求头部的`User-Agent`和`Accept`检测不同类型的设备。基于这种检测，我们可以设置一个名为正确合约的托管Bean属性。托管Bean的代码如下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each of these contracts contains an XHTML template and a CSS file named `styles.css`.
    Each CSS file contains classes for styling the output for a resolution type. The
    template is the same for all contracts and is pretty simple, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合约都包含一个XHTML模板和一个名为`styles.css`的CSS文件。每个CSS文件包含用于为分辨率类型设置样式的类。模板对所有合约都是相同的，相当简单，如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's take a simple page, as shown in the following screenshot. (The JSF code
    is straightforward and you can see it in the complete application named `ch11_4`.)
    This view is for desktop browsers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下屏幕截图中的简单页面。（JSF代码很简单，你可以在名为`ch11_4`的完整应用程序中看到它。）这个视图是为桌面浏览器设计的。
- en: '![Styling contracts across different devices](img/6466EN_11_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![在不同设备上设置样式合约](img/6466EN_11_05.jpg)'
- en: 'The relevant JSF code for this page consists of adding the right contract:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面的相关JSF代码包括添加正确的合约：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Done! Now, you can easily perform some test using a mobile emulator, such as
    Opera Mobile Operator. In the following screenshot, you can see the same page
    as that on a Samsung Galaxy Tab, at a resolution of 1024x600 (PPI: 240):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，你可以轻松地使用移动模拟器进行一些测试，例如Opera Mobile Operator。在以下屏幕截图中，你可以看到与三星Galaxy Tab上相同的页面，分辨率为1024x600（PPI：240）：
- en: '![Styling contracts across different devices](img/6466EN_11_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![在不同设备上设置样式合约](img/6466EN_11_06.jpg)'
- en: 'Further, the same page can be rendered for mobile phone devices: shown on the
    left is Motorola Atrix4G at a resolution of 540x960 (PPI: 267) and on the right
    is a Nokia N9 mobile phone at resolution of 320x480 (PPI: 252):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，相同的页面还可以为手机设备渲染：左侧是分辨率为540x960（PPI：267）的摩托罗拉Atrix4G，右侧是分辨率为320x480（PPI：252）的诺基亚N9手机：
- en: '![Styling contracts across different devices](img/6466EN_11_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![在不同设备上设置样式合约](img/6466EN_11_07.jpg)'
- en: 'Notice that we can reduce the preceding example to a single contract and without
    a managed bean, by using responsive CSS. Instead of using four contracts (`browserpc`,
    `Device640`, `Device480`, and `Device320`), you can use a single contract; let''s
    name it `alldevices`. We place two CSS files under the `alldevices` contract:
    a general CSS file (`styles.css`) and the responsive CSS file (`responsive.css`).
    Further, we modify the `template.xhtml` file to load both the CSS files using
    the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用响应式CSS将前面的示例简化为一个合约，并且不需要托管Bean。而不是使用四个合约（`browserpc`、`Device640`、`Device480`和`Device320`），我们可以使用一个单一的合约；让我们称它为`alldevices`。我们在`alldevices`合约下放置两个CSS文件：一个通用CSS文件（`styles.css`）和一个响应式CSS文件（`responsive.css`）。此外，我们修改`template.xhtml`文件，使用以下代码加载这两个CSS文件：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the final step, we set this contract on the JSF page of the application,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们在应用程序的JSF页面上设置此合约，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Done! The complete application is named `ch11_5`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序名为`ch11_5`。
- en: Another approach consists of writing a custom `RenderKitFactory` class, a custom
    `RenderKit` class and a set of custom `Renderers` classes—one for each device.
    For example, using these artifacts, the application named `ch11_15` shows you
    how to render, for different devices, the Temperature custom component developed
    in [Chapter 10](ch10.html "Chapter 10. JSF Custom Components"), *JSF Custom Components*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法包括编写一个自定义的`RenderKitFactory`类、一个自定义的`RenderKit`类以及一组自定义的`Renderers`类——每个设备一个。例如，使用这些工具，名为`ch11_15`的应用程序展示了如何为不同设备渲染在第10章（[第10章](ch10.html
    "第10章。JSF自定义组件")，*JSF自定义组件*）中开发的温度自定义组件。
- en: Writing contracts for composite components
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写复合组件的合约
- en: 'In this section, you will see how to write contracts for composite components.
    For this, we will use the Temperature composite component developed in [Chapter
    10](ch10.html "Chapter 10. JSF Custom Components"), *JSF Custom Components*. The
    implementation section in the code is given as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何编写复合组件的合约。为此，我们将使用在第10章（[第10章](ch10.html "第10章。JSF自定义组件")，*JSF自定义组件*）中开发的温度复合组件。代码中的实现部分如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The IDs of subcomponents are used to define the CSS file used for styling the
    composite component. Therefore, we need to write the following CSS classes. Notice
    how we exploit CSS wildcards to find the subcomponents.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 子组件的 ID 用于定义用于样式化复合组件的 CSS 文件。因此，我们需要编写以下 CSS 类。注意我们如何利用 CSS 通配符来查找子组件。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Further, we place this CSS file under the same contract with the following
    XHTML template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将此 CSS 文件放置在与以下 XHTML 模板相同的合同下：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, use the composite component as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如下所示使用复合组件：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that we have defined two contracts: `tempStyleGray` (first bar in the
    following screenshot) and `tempStyleGreen` (second bar in the following screenshot):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经定义了两个合同：`tempStyleGray`（以下截图中的第一个条形图）和 `tempStyleGreen`（以下截图中的第二个条形图）：
- en: '![Writing contracts for composite components](img/6466EN_11_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![为复合组件编写合同](img/6466EN_11_08.jpg)'
- en: The complete application is named `ch11_6`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch11_6`。
- en: Writing a theme switcher
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写主题切换器
- en: If you are a PrimeFaces fan, then I'm sure you have seen the PrimeFaces theme
    switcher. Basically, a theme switcher is represented by a drop-down menu that
    contains themes' names and thumbnails. End users can switch between application's
    themes just by selecting it from the list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 PrimeFaces 的粉丝，那么我确信你已经看到了 PrimeFaces 主题切换器。基本上，主题切换器由一个包含主题名称和缩略图的下拉菜单表示。最终用户只需从列表中选择即可在应用程序的主题之间切换。
- en: 'In this section, you will see how to develop a theme switcher using the JSF
    2.2 contracts. The goal is to obtain a theme switcher so that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到如何使用 JSF 2.2 合同开发主题切换器。目标是获得一个主题切换器，以便：
- en: It can be added as a JAR in any JSF 2.2 application
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为 JAR 添加到任何 JSF 2.2 应用程序中
- en: It can automatically detect and list the themes of an application
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动检测并列出应用程序的主题
- en: It can give a nice look and feel, as shown in the following screenshot (shown
    on the left-hand side is the PrimeFaces theme switcher, and on the right-hand
    side is our theme switcher)![Writing a theme switcher](img/6466EN_11_09.jpg)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以提供很好的外观和感觉，如下面的截图所示（左侧显示的是 PrimeFaces 主题切换器，右侧显示的是我们的主题切换器）![编写主题切换器](img/6466EN_11_09.jpg)
- en: Obviously, this kind of a drop-down menu cannot be generated using the built-in
    `<h:selectOneMenu>` tag. In order to customize a drop-down menu with images and
    description, we can write a dedicated `Renderer`, or try to use a JavaScript plugin
    capable of rendering it like in the preceding screenshot. Well, the second option
    is much easier to accomplish and doesn't require us to reinvent the wheel. Practically,
    we can use a free and cool jQuery plugin named **ddSlick** ([http://designwithpc.com/Plugins/ddSlick](http://designwithpc.com/Plugins/ddSlick)),
    which is a free light-weight jQuery plugin that allows you to create a custom
    drop-down menu with images and description. There are many other such plugins
    that do the same thing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种下拉菜单不能使用内置的 `<h:selectOneMenu>` 标签生成。为了自定义包含图像和描述的下拉菜单，我们可以编写一个专门的 `Renderer`，或者尝试使用一个能够像前面截图那样渲染它的
    JavaScript 插件。好吧，第二个选项更容易实现，而且不需要我们重新发明轮子。实际上，我们可以使用一个免费且酷的 jQuery 插件 **ddSlick**
    ([http://designwithpc.com/Plugins/ddSlick](http://designwithpc.com/Plugins/ddSlick))，这是一个免费轻量级的
    jQuery 插件，允许您创建一个包含图像和描述的自定义下拉菜单。还有许多其他这样的插件可以做到同样的事情。
- en: 'Basically, this plugin is capable of transforming a simple drop-down menu (defined
    using `<select>` and `<option>`) into a fancy drop-down menu that contains images
    and descriptions. For this, we start with a pure HTML5 `<select>` tag, as shown
    in the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个插件可以将一个简单的下拉菜单（使用 `<select>` 和 `<option>` 定义）转换成一个包含图像和描述的精美下拉菜单。为此，我们从以下代码片段中的纯
    HTML5 `<select>` 标签开始：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When this `<select>` tag passes through ddSlick, it will result in the desired
    drop-down menu. Basically, ddSlick will render the `<select>` tag as a `<ul>`
    tag and each `<option>` tag as `<li>`. The images and descriptions are rendered
    using `<img>` and `<small>`, while the option's text is rendered using `<label>`.
    Moreover, an input hidden will be generated for each `<option>` value. The HTML5
    attributes `data-imagesrc` and `data-description` are used to tell ddSlick what
    images and descriptions to use for each `<option>`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个 `<select>` 标签通过 ddSlick 处理时，将生成所需的下拉菜单。基本上，ddSlick 将 `<select>` 标签渲染为 `<ul>`
    标签，每个 `<option>` 标签作为 `<li>`。图像和描述使用 `<img>` 和 `<small>` 渲染，而选项文本使用 `<label>`
    渲染。此外，将为每个 `<option>` 值生成一个隐藏的输入。HTML5 属性 `data-imagesrc` 和 `data-description`
    用于告诉 ddSlick 为每个 `<option>` 使用哪些图像和描述。
- en: 'It is important to understand how ddSlick works, because we will wrap it into
    a composite component named `ThemeSwitcher`. The interface section is very simple
    and contains a single attribute named `theme`. This attribute represents the selected
    theme, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 理解ddSlick的工作原理非常重要，因为我们将将其封装成一个名为`ThemeSwitcher`的复合组件。接口部分非常简单，包含一个名为`theme`的单个属性。这个属性代表所选的主题，如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the implementation section, we accomplish several tasks. First, we load
    the JavaScript libraries needed by our component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现部分，我们完成了几个任务。首先，我们加载组件所需的JavaScript库：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Further, we define HTML''s `<select>` component encapsulated in `<h:form>`
    (ideally, this component is not used in `<h:form>` with other components; therefore,
    we don''t have to worry about the nested forms):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了HTML中的`<select>`组件，它被封装在`<h:form>`中（理想情况下，这个组件不应该与`<h:form>`中的其他组件一起使用；因此，我们不必担心嵌套表单）：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The contracts are automatically detected and added as `<option>` using the
    `<ui:repeat>` component. The selected theme (`<option>`) is submitted to a managed
    bean using a hidden field, `<h:inputHidden>`. After submission (via AJAX or non-AJAX),
    the entire page is loaded and the `contracts` attribute (of `<f:view>`) will receive
    and apply the selected theme. For this, we need a little JavaScript code. First,
    we call the `ddslick` method, which will do the magic of transforming the boring
    drop-down menu into a cool one. Further, we indicate a JavaScript callback method,
    which will be automatically called when a theme is selected. In this method, we
    refresh the value of the hidden field, and submit the form (via AJAX or non-AJAX):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 合约会自动检测并添加为`<option>`，使用`<ui:repeat>`组件。所选的主题（`<option>`）通过隐藏字段`<h:inputHidden>`提交给管理Bean。提交后（通过AJAX或非AJAX），整个页面将被加载，`contracts`属性（`<f:view>`）将接收并应用所选的主题。为此，我们需要一点JavaScript代码。首先，我们调用`ddslick`方法，它将把无聊的下拉菜单变成酷炫的。进一步，我们指示一个JavaScript回调方法，当选择主题时将自动调用。在这个方法中，我们刷新隐藏字段的值，并提交表单（通过AJAX或非AJAX）：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It was very handy to work with this callback method to submit the selected theme,
    since ddSlick provides this feature out of the box. There are many other possibilities
    such as writing a value change listener, firing a custom event, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个回调方法提交所选主题非常方便，因为ddSlick提供了这个功能。还有许多其他可能性，例如编写值变化监听器、触发自定义事件等。
- en: 'I''m sure that you notice that our composite components indicate the presence
    of a backing component. This component is responsible to detect the application''s
    contracts and add their names into `List`. This list is transformed in `<option>`
    by `<ui:repeat>`. Its code is pretty straightforward, which is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到我们的复合组件指示了存在一个后端组件。这个组件负责检测应用程序的合约并将它们的名称添加到`List`中。这个列表通过`<ui:repeat>`转换为`<option>`。其代码相当简单，如下所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A developer who wants to use this `ThemeSwitcher` component must add, in each
    contract, a PNG image with the same name as the contract (recommended size is
    40 x 40 pixels). By convention, for each contract, the `ThemeSwitcher` component
    will look for such an image to display it next to the theme name and description.
    You can improve this backing component to ensure that such images exist. Moreover,
    you can extend its functionality in order to allow the user of the component to
    provide custom descriptions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用这个`ThemeSwitcher`组件的开发者必须在每个合约中添加一个与合约同名的PNG图像（推荐大小为40 x 40像素）。按照惯例，对于每个合约，`ThemeSwitcher`组件将寻找这样的图像，并在主题名称和描述旁边显示它。你可以改进这个后端组件以确保这些图像存在。此外，你可以扩展其功能，以便允许组件用户提供自定义描述。
- en: Done! The complete application is named `ch11_10`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序命名为`ch11_10`。
- en: 'The `ThemeSwitcher` composite component was packaged as a JAR file and used
    as an example in the `ch11_7` application as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeSwitcher`复合组件被打包成JAR文件，并在`ch11_7`应用程序中作为示例使用，如下所示：'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ThemeSwitcherBean` source code is very simple, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeSwitcherBean`的源代码非常简单，如下所示：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the `ch11_7` application is shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch11_7`应用程序的输出在以下屏幕截图中显示：'
- en: '![Writing a theme switcher](img/6466EN_11_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![编写主题切换器](img/6466EN_11_10.jpg)'
- en: If you decide to programmatically alter the `contracts` attribute value of `<f:view>`,
    you don't need this bean anymore. Moreover, if you consider a disadvantage in
    loading this jQuery plugin, you can write pure JavaScript code. Or, if you want
    a JavaScript code, a custom renderer can be a good choice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定通过编程方式更改 `<f:view>` 的 `contracts` 属性值，你不再需要这个 Bean。此外，如果你认为加载这个 jQuery
    插件有缺点，你可以编写纯 JavaScript 代码。或者，如果你想有 JavaScript 代码，自定义渲染器可能是一个不错的选择。
- en: A `ThemeSwitcher` component example, based on pure JavaScript, is developed
    in the application named `ch11_11` and is exemplified as a JAR file in the application
    named `ch11_12`. The example modifies the free JavaScript UI library named `iconselect.js`
    ([http://bug7a.github.io/iconselect.js/](http://bug7a.github.io/iconselect.js/))
    and uses the complete rewritten iScroll 4 library ([http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)).
    Both of these libraries are pure JavaScript; they don't use additional libraries
    such as jQuery. Moreover, they are very small, free to be copied, modified, distributed,
    adapted, and commercially used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于纯 JavaScript 的 `ThemeSwitcher` 组件示例在名为 `ch11_11` 的应用程序中开发，并在名为 `ch11_12`
    的应用程序中以 JAR 文件的形式展示。该示例修改了名为 `iconselect.js` 的免费 JavaScript UI 库（[http://bug7a.github.io/iconselect.js/](http://bug7a.github.io/iconselect.js/））和完全重写的
    iScroll 4 库（[http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)）。这两个库都是纯
    JavaScript；它们不使用如 jQuery 这样的附加库。此外，它们非常小，可以免费复制、修改、分发、改编和商业使用。
- en: The composite component that wraps these libraries can be used as shown in the
    following code. Notice that you can customize the aspect (which is a grid) and
    you can optionally specify which contracts to be ignored (not listed in theme
    switcher).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹这些库的复合组件可以像以下代码所示那样使用。请注意，你可以自定义方面（即网格），并且你可以选择指定要忽略哪些合同（不在主题切换器中列出）。
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Writing a theme switcher](img/6466EN_11_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![编写主题切换器](img/6466EN_11_11.jpg)'
- en: 'If you don''t want any JavaScript code, you can write a custom `Renderer` code
    or extend the existing `MenuRenderer` code (Mojarra or MyFaces implementation)
    or write a composite component that uses the JSF UI components to create a nice
    theme switcher. Writing a custom `Renderer` code (or extending the `MenuRenderer`
    code) doesn''t seem to be an easy job, and I don''t know if it deserves the effort.
    But writing a composite component based on JSF UI components is pretty simple.
    You can see such an implementation in the application named `ch11_13` and exemplified
    as a JAR file in the application named `ch11_14`. In this example, the themes
    are listed in a `<h:dataTable>` component, as you can see in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想有任何 JavaScript 代码，你可以编写自定义的 `Renderer` 代码或扩展现有的 `MenuRenderer` 代码（Mojarra
    或 MyFaces 实现）或编写一个使用 JSF UI 组件创建良好主题切换器的复合组件。编写自定义 `Renderer` 代码（或扩展 `MenuRenderer`
    代码）似乎不是一件容易的事情，我不知道它是否值得付出努力。但是，基于 JSF UI 组件编写复合组件相当简单。你可以在名为 `ch11_13` 的应用程序中看到这样的实现，并在名为
    `ch11_14` 的应用程序中以 JAR 文件的形式展示。在这个例子中，主题列在 `<h:dataTable>` 组件中，如下截图所示：
- en: '![Writing a theme switcher](img/6466EN_11_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![编写主题切换器](img/6466EN_11_12.jpg)'
- en: Configuring contracts in XML
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 XML 中配置合同
- en: 'Contracts can be associated with the JSF pages, as you saw in the previous
    sections. As an alternative, we can accomplish the same thing by configuring contracts
    in the `faces-config.xml` file. For example, let''s suppose that we have three
    contracts: `default`, `tableGreen`, and `tableBlue`. Their association with different
    pages is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 合同可以与 JSF 页面相关联，正如你在前面的章节中看到的。作为替代，我们可以在 `faces-config.xml` 文件中配置合同来完成相同的事情。例如，假设我们有三个合同：`default`、`tableGreen`
    和 `tableBlue`。它们与不同页面的关联如下：
- en: The `default` contract is associated with the `tables/defaultTablePage.xhtml`
    page
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default` 合同与 `tables/defaultTablePage.xhtml` 页面相关联'
- en: The `tableGreen` contract is associated with the `greenTablePage.xhtml` page
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tableGreen` 合同与 `greenTablePage.xhtml` 页面相关联'
- en: The `tableBlue` contract is associated with the `blueTablePage.xhtml` page
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tableBlue` 合同与 `blueTablePage.xhtml` 页面相关联'
- en: 'In `faces-config.xml`, we can do these associations using a few tags—the following
    example code speaks for itself:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `faces-config.xml` 中，我们可以使用几个标签来完成这些关联——以下示例代码自说自话：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a note, take a quick look at the third association. Notice how you can associate
    a contract with all the XHTML pages from a folder using the `*` wildcard. Do not
    try to use EL in `<contracts>`. It will not work!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为备注，快速看一下第三个关联。注意您如何可以使用 `*` 通配符将合同与文件夹中的所有 XHTML 页面关联起来。不要尝试在 `<contracts>`
    中使用 EL。这是不会工作的！
- en: The complete application is named `ch11_8`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch11_8`。
- en: Packaging contracts in JARs
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将合同打包到 JAR 文件中
- en: 'In order to distribute contracts, you can place them into a JAR file. This
    is a very simple job that can be accomplished in just three steps, which are as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发合同，您可以将它们放入一个 JAR 文件中。这是一个非常简单的任务，只需三个步骤即可完成，具体如下：
- en: Consider an empty JAR file.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个空的 JAR 文件。
- en: Create, in JAR, a folder named `META-INF`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JAR 中创建一个名为 `META-INF` 的文件夹。
- en: Copy the `contracts` folder from your application into `META-INF`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序中的 `contracts` 文件夹复制到 `META-INF`。
- en: 'For example, a JAR file that contains the `default`, `tableGreen`, and `tableBlue`
    contract folders has the structure shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个包含 `default`、`tableGreen` 和 `tableBlue` 合同文件夹的 JAR 文件，其结构如下所示（请参考以下截图）：
- en: '![Packaging contracts in JARs](img/6466EN_11_13.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![将合同打包到 JAR 文件中](img/6466EN_11_13.jpg)'
- en: A complete example that uses this JAR file is named `ch11_9`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 JAR 文件的一个完整示例命名为 `ch11_9`。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope that you have enjoyed this penultimate chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这个倒数第二章。
- en: The JSF 2.2 Resource Library Contracts is one of the big ticket features. For
    a long time, JSF developers requested for a mechanism that allows writing and
    using themes in JSF, just like in other systems. As you just saw, JSF 2.2 contracts
    open a door in this direction and encourage developers to write and use themes.
    Of course, there are many other things that should be added, such as a theme repository,
    administration console for themes, switch between themes on the fly, and so on.
    But, this is a good start!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 资源库合同是其中一个重要特性。长期以来，JSF 开发者一直要求有一个机制，允许在 JSF 中编写和使用主题，就像在其他系统中一样。正如您刚才看到的，JSF
    2.2 合同在这一方向上打开了一扇门，并鼓励开发者编写和使用主题。当然，还有很多其他事情应该添加，例如主题仓库、主题管理控制台、动态切换主题等等。但，这是一个良好的开端！
- en: See you in the final chapter where we will discuss about Facelets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家在最后一章中，我们将讨论关于 Facelets 的内容。
