- en: Developing Your First Application with Quarkus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus开发你的第一个应用程序
- en: In this chapter, we will be creating our first Quarkus application using the
    tooling that's available to us. As you will soon see, this is a pretty simple
    process that can be bootstrapped from the command line and doesn't require you
    to download any external tools. By using this process, we will be able to compile
    an application into a native executable and have solid evidence of how fast and
    thin a Java application can be when it's turned into native code by Quarkus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们可用的工具来创建我们的第一个Quarkus应用程序。正如你很快就会看到的，这是一个相当简单的流程，可以从命令行启动，不需要你下载任何外部工具。通过使用这个流程，我们将能够将应用程序编译成原生可执行文件，并证明当Quarkus将其转换为原生代码时，Java应用程序可以有多快和多轻。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the Quarkus Maven plugin to bootstrap our projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Quarkus Maven插件启动我们的项目
- en: Alternative methods to kick-start your projects (Quarkus CLI)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动项目的替代方法（Quarkus CLI）
- en: Creating and executing our first Quarkus application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和执行我们的第一个Quarkus应用程序
- en: Debugging the application from our IDE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的IDE调试应用程序
- en: Testing the application with an extension of the JUnit test framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit测试框架的扩展测试应用程序
- en: Turning our application into native code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序转换为原生代码
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章项目的源代码，地址为[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02)。
- en: Getting started with the Quarkus Maven plugin
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus Maven插件入门
- en: 'In order to scaffold our first Quarkus application, we will be using Maven,
    which is the most common software and release management tool available. It is
    used by a variety of developers, mostly because it offers the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的第一个Quarkus应用程序，我们将使用Maven，这是最常见的一种软件和发布管理工具。它被各种开发者所使用，主要是因为它提供了以下功能：
- en: A standard structure for all your projects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有项目的标准结构
- en: Centralized and automatic management of dependencies
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项的集中和自动管理
- en: Maven is distributed in several formats for the user's convenience. You can
    download it from [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Maven以几种格式分发给用户方便使用。你可以从[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)下载它。
- en: 'Once you''ve downloaded Maven, do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Maven后，执行以下操作：
- en: 'Unzip the distribution archive (for example, `apache-maven-3.6.1-bin.zip`)
    to the directory that you want Maven to be installed in (for example, in your
    `$HOME/apache` folder):'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分发存档（例如，`apache-maven-3.6.1-bin.zip`）解压缩到你想安装Maven的目录中（例如，在你的`$HOME/apache`文件夹中）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the Maven libraries to your system path, as shown in the following code.
    This will update the `PATH` environment variable:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Maven库添加到你的系统路径中，如下面的代码所示。这将更新`PATH`环境变量：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you have completed your installation, you need to check whether Maven
    has been correctly installed or not. Run `mvn --version` to verify this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成安装后，你需要检查Maven是否已正确安装。运行`mvn --version`来验证这一点：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you get the preceding output, then you have just verified that Maven is installed
    on your system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了前面的输出，那么你刚刚验证了Maven已经安装在你的系统上。
- en: Launching the Quarkus Maven plugin
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Quarkus Maven插件
- en: 'Now that Maven has been set up, we can bootstrap our first Quarkus application
    by means of its Maven plugin. A Maven plugin provides a set of goals that can
    be executed to compile and build our artifacts or extend our project with some
    features. Each plugin, like every Maven component, is based on the following coordinates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Maven已经设置好了，我们可以通过其Maven插件启动我们的第一个Quarkus应用程序。Maven插件提供了一组目标，可以执行以编译和构建我们的工件或扩展我们的项目以添加一些功能。每个插件，就像每个Maven组件一样，基于以下坐标：
- en: '`groupId`: The ID of the project''s group. This often matches the ID of the
    package root directory.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupId`：项目组的ID。这通常与包根目录的ID相匹配。'
- en: '`artifactId`: The ID of the artifact. This often matches with the final artifact
    name.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifactId`：工件ID。这通常与最终工件名称相匹配。'
- en: '`version`: The version of the artifact under the specified group.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：指定组下工件版本。'
- en: 'You can reference a Maven plugin from the command line by indicating the `<groupId>:<artifactId>`
    coordinates. For Quarkus, the `<groupId>:<artifactId>` combination is `io.quarkus:quarkus-maven-plugin`.
    You can check the available goals and the latest version of it with the following
    command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定 `<groupId>:<artifactId>` 坐标从命令行引用 Maven 插件。对于 Quarkus，`<groupId>:<artifactId>`
    组合是 `io.quarkus:quarkus-maven-plugin`。您可以使用以下命令检查可用的目标和最新版本：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The source code of our first application can be located in the `Chapter02/hello-rest`
    folder of this book''s GitHub repository. For reference, we have created the application
    using the Maven plugin and configured the following set of arguments:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个应用程序的源代码可以位于本书 GitHub 存储库的 `Chapter02/hello-rest` 文件夹中。为了参考，我们使用 Maven
    插件创建了应用程序，并配置了以下参数集：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a result of the preceding command, the following directory structure has
    been generated in the `hello-rest` folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的命令，`hello-rest` 文件夹中已生成以下目录结构：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the next section of this chapter, we will learn how to import the project
    into IntelliJ IDEA (the steps are pretty much the same in any IDE, though). Right
    now, let''s stick to the preceding tree view of the project and look at the files
    that are included in this project:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将学习如何将项目导入 IntelliJ IDEA（尽管在任意 IDE 中步骤大致相同）。现在，让我们继续查看项目的前一个树视图，并查看包含在本项目中的文件：
- en: A **Project Object Model** (`pom.xml`) with the project configuration
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **项目对象模型** (`pom.xml`)，包含项目配置
- en: A sample REST service named `SimpleRest.java` and a test class for it named
    `SimpleRestTest.java`, as well as a wrapper class named `NativeSimpleRestIT.java`
    for executing the test against the native executable application
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `SimpleRest.java` 的示例 REST 服务以及为其创建的测试类 `SimpleRestTest.java`，以及一个名为 `NativeSimpleRestIT.java`
    的包装类，用于在原生可执行应用程序上执行测试
- en: A placeholder for the configuration file (`application.properties`)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件占位符（`application.properties`）
- en: An `index.html` file to indicate where we can add static web content
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `index.html` 文件，指示我们可以添加静态网页内容
- en: A `Dockerfile` so that we can create a container out of our applications
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Dockerfile`，以便我们可以从我们的应用程序创建容器
- en: A Maven wrapper file (`mvnw/mvnw.cmd`) to allow us to execute Maven goals without
    prior installation of it
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 包装文件（`mvnw/mvnw.cmd`），允许我们在不预先安装 Maven 的情况下执行 Maven 目标
- en: The `pom.xml` file will be added to the root of your project. There, you will
    find an upper `dependencyManagement` section, which imports Quarkus' **Bill Of
    Materials**. This allows us to automatically link the exact version of each Quarkus
    extension.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml` 文件将被添加到项目的根目录。在那里，您将找到一个上层的 `dependencyManagement` 部分，它导入 Quarkus
    的 **物料清单**。这允许我们自动链接每个 Quarkus 扩展的确切版本。'
- en: In the 1.0.0.Final version of Quarkus, you will reference the `artifactId` named
    `quarkus-universe-bom`, which belongs to `groupId io.quarkus`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 的 1.0.0.Final 版本中，您将引用名为 `quarkus-universe-bom` 的 `artifactId`，它属于
    `groupId io.quarkus`。
- en: 'Here, `quarkus-maven-plugin` has also been included to allow you to package
    your application and generate the native executable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已经包含了 `quarkus-maven-plugin`，以便您可以对您的应用程序进行打包并生成原生可执行文件：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Moving into the dependencies section, you will see that the only runtime dependency
    that''s been added is the following one, which allows you to execute a basic REST
    application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 进入依赖关系部分，您将看到添加的唯一运行时依赖项如下，它允许您执行基本的 REST 应用程序：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**RESTEasy** is a portable implementation of the JAX-RS specification that
    is included by default in the WildFly application server ([http://www.wildfly.org](http://www.wildfly.org)).
    You can use it to provide a representation of your service through the standard
    HTTP methods using stateless communication.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**RESTEasy** 是 JAX-RS 规范的可移植实现，默认包含在 WildFly 应用服务器中（[http://www.wildfly.org](http://www.wildfly.org)）。您可以使用它通过标准
    HTTP 方法使用无状态通信来提供您服务的表示。'
- en: Besides `quarkus-resteasy`, some other libraries have been included in your
    `pom.xml` file for the purpose of testing your applications. This will be discussed
    more in detail in the *Testing Quarkus applications* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `quarkus-resteasy` 之外，一些其他库也被包含在您的 `pom.xml` 文件中，目的是测试您的应用程序。这将在 *测试 Quarkus
    应用程序* 部分中更详细地讨论。
- en: To add additional libraries to your project, besides editing the `pom.xml` file,
    you can also use `add-extension`, which can be found in Quarkus' Maven plugin.
    An example of this is `$ mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-jsonp,io.quarkus:quarkus-smallrye-health"`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要向您的项目添加额外的库，除了编辑 `pom.xml` 文件外，您还可以使用 `add-extension`，这在 Quarkus 的 Maven 插件中可以找到。一个例子是
    `$ mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-jsonp,io.quarkus:quarkus-smallrye-health"`。
- en: 'The following `SimpleRest` class has been automatically generated for you in
    `src/main/java/com/packt/quarkus/Chapter02`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `SimpleRest` 类已经为您自动生成在 `src/main/java/com/packt/quarkus/Chapter02`：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it's a very simple REST endpoint that leverages the JAX-RS API
    to produce a `TEXT_PLAIN` resource when the `/helloworld GET` requests lands on
    the default port.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的 REST 端点，它利用 JAX-RS API 在 `/helloworld GET` 请求落在默认端口时生成 `TEXT_PLAIN`
    资源。
- en: '**Simpler than JAX-RS!**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**比 JAX-RS 更简单！**'
- en: As we mentioned previously, Quarkus simplifies code development to provide sensible
    defaults. However, we don't need to declare an `ApplicationScoped` class to bootstrap
    the REST service anymore since we will get it as the default option.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Quarkus 简化了代码开发以提供合理的默认值。然而，我们不再需要声明一个 `ApplicationScoped` 类来启动 REST
    服务，因为我们将会以默认选项获得它。
- en: Running the application
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Now, we are ready to run our application. Execute the `compile` and `quarkus:dev`
    goals to build it and run it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行我们的应用程序。执行 `compile` 和 `quarkus:dev` 目标来构建并运行它：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After a few seconds, the application will be compiled and executed, as shown
    in the following log:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，应用程序将被编译并执行，如下面的日志所示：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can request the provided endpoint with the browser or a tool such
    as `curl`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用浏览器或像 `curl` 这样的工具请求提供的端点：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can stop the application with *Ctrl* + *C*, although we recommend keeping
    it running as we will be testing the **hot reload** feature soon!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 *Ctrl* + *C* 停止应用程序，尽管我们建议保持其运行，因为我们很快将测试 **热重载** 功能！
- en: Using the Maven plugin to generate a Gradle project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 插件生成 Gradle 项目
- en: The Quarkus Maven plugin is pretty agnostic in spite of its name. As a matter
    of fact, you can also use it to generate **Gradle** projects. A comparison between
    the two tools is out of the scope of this book; however, a large number of developers
    prefer Gradle as a build tool since it's modeled in a way that is extensible in
    the most fundamental ways and has outstanding performance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为 Quarkus Maven 插件，但它相当中立。实际上，您也可以使用它来生成 **Gradle** 项目。这两个工具的比较超出了本书的范围；然而，许多开发者更喜欢
    Gradle 作为构建工具，因为它以最基本的方式是可扩展的，并且具有出色的性能。
- en: 'That being said, you can generate a Gradle project by simply setting the `buildTool`
    option to `gradle`, which otherwise defaults to `maven`. Here''s how you can generate
    your project with Gradle:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，您可以通过将 `buildTool` 选项设置为 `gradle` 来简单地生成 Gradle 项目，否则默认为 `maven`。以下是您如何使用
    Gradle 生成项目的方法：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting `build.gradle` file defines the set of available repositories
    and dependencies and sets the core project attributes such as `quarkusPlatformGroupId`,
    `quarkusPlatformArtifactId`, and `quarkusPlatformVersion` as variables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `build.gradle` 文件定义了可用的存储库和依赖项集合，并设置了核心项目属性，如 `quarkusPlatformGroupId`、`quarkusPlatformArtifactId`
    和 `quarkusPlatformVersion` 作为变量：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All the preceding variables are retrieved from the `gradle.properties` file,
    which is located at the root of your project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的变量都是从位于项目根目录的 `gradle.properties` 文件中检索的。
- en: 'As you can see from the configuration, a plugin is also included in the default
    project so that you can easily build your application and start it in development
    mode, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从配置中看到的，默认项目中还包括了一个插件，这样您就可以轻松构建您的应用程序并在开发模式下启动，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, it is worth mentioning that the Gradle extension is still under development,
    so you may see some changes or updates in the next Quarkus releases.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，Gradle 扩展仍在开发中，因此您可能会在下一个 Quarkus 版本中看到一些更改或更新。
- en: Now, we will learn how to easily bootstrap our project (either Maven or Gradle)
    using the online Quarkus project generator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何轻松地使用在线 Quarkus 项目生成器启动我们的项目（无论是 Maven 还是 Gradle）。
- en: Kick-starting applications using the Quarkus online application
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quarkus 在线应用程序启动应用程序
- en: 'Another option for bootstrapping your Quarkus application is using the online
    application, which is available at the following address: [https://code.quarkus.io/](https://code.quarkus.io/).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的Quarkus应用程序的另一种选项是使用在线应用程序，该应用程序可在以下地址找到：[https://code.quarkus.io/](https://code.quarkus.io/)。
- en: 'By landing on that page, you will be able to generate a basic project with
    an initial endpoint, as well as all the extensions that you checked out in the
    user interface:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问该页面，您将能够生成一个具有初始端点和您在用户界面中检查的所有扩展的基本项目：
- en: '![](img/3c622c55-3ea0-45d9-9a42-06292b82d133.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c622c55-3ea0-45d9-9a42-06292b82d133.png)'
- en: As shown in the preceding screenshot, by default, just the **RESTEasy** extension
    is selected. From the top-left corner of the interface, you can configure your
    project coordinates (`groupId`, `artifactId`) and the build tool, which can be
    either Maven or Gradle. More options are available through the CONFIGURE MORE
    OPTIONS panel, which lets you configure the package name and the version for the
    project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，默认情况下，仅选中了**RESTEasy**扩展。从界面的左上角，您可以配置您的项目坐标（`groupId`，`artifactId`）和构建工具，这可以是Maven或Gradle。更多选项可通过“更多配置选项”面板获得，该面板允许您配置包名和项目的版本。
- en: By scrolling down the list of available extensions, you can also choose to experiment
    with alternative languages, such as Kotlin or Scala, to develop your Quarkus applications.
    These options are still work in progress, so consider that their API and/or configuration
    may change as the extension matures. The Quarkus team, however, does appreciate
    your feedback if you have tested any preview extension.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过滚动查看可用扩展列表，您还可以选择尝试使用其他语言，如Kotlin或Scala，来开发您的Quarkus应用程序。这些选项仍在开发中，因此请考虑，随着扩展的成熟，它们的API和/或配置可能会发生变化。然而，Quarkus团队非常感谢您对任何预览扩展的测试反馈。
- en: 'When you are done setting your options, just click on Start a new application
    to download the artifact as a compressed folder:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置完选项后，只需单击“启动新应用程序”即可将工件作为压缩文件夹下载：
- en: '![](img/fa7d5fd7-53b9-45db-aa92-46af103a3160.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa7d5fd7-53b9-45db-aa92-46af103a3160.png)'
- en: Now, you can just unpack it and import it into your favorite IDE. We will do
    this in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需将其解包并导入您喜欢的IDE中。我们将在下一节中这样做。
- en: Testing live reload from your IDE
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的IDE中测试实时重新加载
- en: In this section, we will use the live reload feature of Quarkus. For this purpose,
    we will import the project into our IDE so that we can apply some changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Quarkus的实时重新加载功能。为此，我们将项目导入到我们的IDE中，以便我们可以应用一些更改。
- en: 'Navigate to File | Open and point to the folder where you created the Maven
    project. It will be automatically imported into your IDE. Here is the Files tab
    view of your Java classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到文件 | 打开，并指向您创建Maven项目的文件夹。它将自动导入到您的IDE中。以下是您的Java类的文件标签视图：
- en: '![](img/67711f22-3b2e-4118-ba1c-3d3d6730d0be.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67711f22-3b2e-4118-ba1c-3d3d6730d0be.png)'
- en: 'Now, let''s look at how live reload works with Quarkus. For this, let''s apply
    a simple change to our code. Here, we have modified the return value for the `hello`
    method, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Quarkus的实时重新加载是如何工作的。为此，让我们对我们的代码进行简单的修改。在这里，我们已修改了`hello`方法的返回值，如下所示：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Hopefully, you haven''t stopped your server. Now, try to call the service once
    more:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您没有停止您的服务器。现在，再次尝试调用该服务：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, when running in development mode, you can have a live reload
    of your application. Amazing, isn't it?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在开发模式下运行时，您可以实时重新加载您的应用程序。令人惊叹，不是吗？
- en: Live reload also works for resource files such as web pages or the configuration
    property file. Requesting the service triggers a scan of the workspace, and if
    any changes are detected, the Java files are recompiled and the application is
    redeployed. Your request is then serviced by the redeployed application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实时重新加载也适用于资源文件，如网页或配置属性文件。请求服务将触发工作区扫描，如果检测到任何更改，Java文件将被重新编译，应用程序将被重新部署。然后，您的请求将由重新部署的应用程序处理。
- en: Debugging applications
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序调试
- en: 'When running in development mode, Quarkus will automatically listen for a debugger
    on port `5005`. You can check that the debugging is active with a basic shell
    command, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下运行时，Quarkus将自动监听端口`5005`上的调试器。您可以使用以下基本shell命令检查调试是否激活：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s undo these changes in the `hello` method and include another `hello`
    method, which receives a parameter to be inspected as input:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`hello`方法中撤销这些更改，并包含另一个`hello`方法，该方法接收一个要检查的输入参数：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By using the `@PathParam` expression in our REST service, we will be able to
    debug the value of this expression as a method variable from within our IDE. Now,
    place a breakpoint on the logging statement, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的 REST 服务中使用 `@PathParam` 表达式，我们将能够从我们的 IDE 中作为方法变量调试这个表达式的值。现在，放置一个断点在日志语句上，如下截图所示：
- en: '![](img/72d2ab1d-e6b6-460a-8d49-938e69a36da4.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72d2ab1d-e6b6-460a-8d49-938e69a36da4.png)'
- en: 'Next, in order to attach the IntelliJ IDEA to the debugger, you have to connect
    to the debugger''s port. In IntelliJ IDEA, you can do this in various ways. The
    simplest way is to select Run | Attach to Process. The runnable process of your
    application will be detected, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了将 IntelliJ IDEA 连接到调试器，你必须连接到调试器的端口。在 IntelliJ IDEA 中，你可以通过多种方式做到这一点。最简单的方法是选择
    Run | Attach to Process。你的应用程序的可运行进程将被检测，如下截图所示：
- en: '![](img/78ff72c9-472d-4f4f-9abf-9b5fb326f637.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78ff72c9-472d-4f4f-9abf-9b5fb326f637.png)'
- en: 'Select it and check that you managed to attach to it successfully. You can
    do this from the Debugger Console:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择它并检查你是否成功附加到了它。你可以从调试器控制台这样做：
- en: '![](img/5f7147f7-c716-4343-b4a1-25d0b2d4da2c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f7147f7-c716-4343-b4a1-25d0b2d4da2c.png)'
- en: 'Now, invoke the application by adding an extra parameter at the end of it so
    that you hit the breakpoint:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在末尾添加一个额外的参数来调用应用程序，以便你能够触发断点：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the debugger prompt, you can inspect the class and method variables from
    its console. You can also control the execution path (Step Over, Step Into, Stop,
    and many more) by clicking on the buttons located on the left-hand side of the
    Debugger Console, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试器提示符，你可以从其控制台检查类和方法变量。你也可以通过点击调试器控制台左侧的按钮来控制执行路径（Step Over，Step Into，Stop
    等）：
- en: '![](img/ed190009-53dc-4505-b590-30e79d11bd96.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed190009-53dc-4505-b590-30e79d11bd96.png)'
- en: If you want to wait for the debugger to attach before starting your Quarkus
    application, you can pass `-Ddebug` on the command line. As soon as your IDE's
    debugger connects, the Quarkus Augmentor will start and your application will
    be executed. On the other hand, if you don't want the debugger at all, you can
    use `-Ddebug=false`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在启动 Quarkus 应用程序之前等待调试器附加，你可以在命令行上传递 `-Ddebug`。一旦你的 IDE 的调试器连接，Quarkus Augmentor
    将启动，你的应用程序将被执行。另一方面，如果你根本不需要调试器，你可以使用 `-Ddebug=false`。
- en: Testing Quarkus applications
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Quarkus 应用程序
- en: 'Along with the sample endpoint, the Maven plugin automatically included a test
    class for our REST service:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了示例端点外，Maven 插件还自动包含了一个用于我们 REST 服务的测试类：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Under the hood, this test class uses JUnit as the core testing framework and
    the REST Assured library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这个测试类使用 JUnit 作为核心测试框架和 REST Assured 库：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**REST Assured** is a Java library that can be used to write powerful tests
    for REST APIs using a flexible **Domain Specific Language** (**DSL**). The Fluent
    API that''s available in REST Assured supports the standard patterns from **Behavior-Driven
    Development** (**BDD**) with its `Given/When/Then` syntax. The resulting test
    is simple to read and can include all the steps that we need in order to build
    the test with just one line of code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST Assured** 是一个 Java 库，可以用来使用灵活的 **领域特定语言**（**DSL**）编写强大的 REST API 测试。REST
    Assured 中可用的流畅 API 支持来自 **行为驱动开发**（**BDD**）的标准模式，使用 `Given/When/Then` 语法。生成的测试易于阅读，并且可以包含我们构建测试所需的全部步骤，只需一行代码即可。'
- en: 'Now, we can verify the response body''s content and check that the HTTP response
    status code is 200\. We can verify the test''s execution by running the following
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证响应体的内容并检查 HTTP 响应状态码是否为 200。我们可以通过运行以下命令来验证测试的执行：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following output in your console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台看到以下输出：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the test started the Quarkus runtime on the local IP address
    at port `8081`. Therefore, it doesn't interfere with the development/production
    environment that runs on port `8080` by default.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试在本地 IP 地址的端口 `8081` 上启动了 Quarkus 运行时。因此，它不会干扰默认在端口 `8080` 上运行的开发/生产环境。
- en: 'You can mix and match multiple conditions in your tests by concatenating them
    using the `and()` method. This method works as simple syntactic sugar, that is,
    it helps make the code more readable. Here''s an example of how to include a check
    on the header''s `Content-Length`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `and()` 方法将多个条件混合匹配在你的测试中。这个方法作为一个简单的语法糖，也就是说，它有助于使代码更易读。以下是一个如何包含对头部
    `Content-Length` 的检查的示例：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By using parameterized tests, you can test multiple scenarios within a single
    method by providing different sets of records. REST Assured supports two different
    types of parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用参数化测试，您可以在单个方法中通过提供不同的记录集来测试多个场景。REST Assured 支持两种不同类型的参数：
- en: '**Query parameters**: These can be appended at the end of a RESTful API endpoint
    and are identified by the question mark in front of them. Here''s an example:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询参数**：这些参数可以附加在 RESTful API 端点的末尾，并且通过它们前面的问号来识别。以下是一个示例：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, using query parameters only requires that we specify their name
    and value by concatenating the `param()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用查询参数只需要我们通过连接 `param()` 方法来指定它们的名称和值。
- en: '**Path parameters**: These are specified in a similar fashion, that is, by
    including the `pathParam()` method with the parameter name/value combination:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径参数**：这些参数以类似的方式指定，即通过包含 `pathParam()` 方法以及参数名称/值组合：'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, it''s worth mentioning that, since Quarkus aims at top performance,
    you can also validate your tests based on the response time. This can be done
    by concatenating `time()` to your condition. Here is an example that sets the
    time to be less than one second when it comes to returning the response:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，由于 Quarkus 致力于最高性能，您还可以根据响应时间验证您的测试。这可以通过将 `time()` 连接到条件来实现。以下是一个示例，当返回响应时将时间设置为小于一秒：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, we have covered the most common testing scenarios that we can
    build with the REST Assured API. If you want to checkout some more advanced patterns,
    we recommend having a look at its Wiki, which is available at [https://github.com/rest-assured/rest-assured/wiki/usage](https://github.com/rest-assured/rest-assured/wiki/usage).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了我们可以使用 REST Assured API 构建的常见测试场景。如果您想查看更多高级模式，我们建议查看其 Wiki，它可在 [https://github.com/rest-assured/rest-assured/wiki/usage](https://github.com/rest-assured/rest-assured/wiki/usage)
    找到。
- en: Choosing a different port for testing
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择不同的端口进行测试
- en: 'You can change the default port that''s used for testing by Quarkus (`8081`)
    by setting an appropriate value in the `src/main/resources/application.properties`
    file, which is the general configuration file for Quarkus. For example, in order
    to shift the test port to `9081`, you would need to add the following information
    to `application.properties`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `src/main/resources/application.properties` 文件中设置适当的值来更改 Quarkus 用于测试的默认端口（`8081`），这是
    Quarkus 的通用配置文件。例如，要将测试端口更改为 `9081`，您需要在 `application.properties` 中添加以下信息：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As an alternative, you can also use the same property at startup by passing
    the `-Dquarkus.http.test-port=9081` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，您也可以在启动时通过传递 `-Dquarkus.http.test-port=9081` 标志来使用相同的属性。
- en: Turning your application into a native executable
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序转换为原生可执行文件
- en: 'Now, it''s time to check what Quarkus can do to turn our bytecode into a native
    executable. This kind of magic is done under the hood by a Maven profile named
    `native`, which is included out of the box when you scaffold your application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候检查 Quarkus 如何将我们的字节码转换为原生可执行文件了。这种魔法是通过一个名为 `native` 的 Maven 配置文件在幕后完成的，该配置文件在您搭建应用程序时默认包含：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In addition, `maven-failsafe-plugin` has been automatically configured to run
    `integration-test goal` since we've set the path where the native image has been
    built as the system property.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`maven-failsafe-plugin` 已经自动配置为运行 `integration-test goal`，因为我们已经设置了构建原生图像的路径作为系统属性。
- en: Before building your executable, verify that you have set `GRAALVM_HOME` in
    your environment, as described in the previous chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建您的可执行文件之前，请确保您已经按照前一章所述在环境中设置了 `GRAALVM_HOME`。
- en: 'Next, create a native executable by executing the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过执行以下命令创建一个原生可执行文件：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The plugin will start analyzing the classes and packaging that's used in your
    application, along with the call tree. The resulting output will be a super lean
    executable that contains just a thin JVM layer (narrow enough to just execute
    the application) and the application itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 插件将开始分析您应用程序中使用的类和打包，以及调用树。生成的输出将是一个超级精简的可执行文件，它只包含一个薄薄的 JVM 层（足够窄，仅用于执行应用程序）以及应用程序本身。
- en: 'You should see something similar to the following at the end of your output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输出的末尾看到类似以下的内容：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Along with the JAR file containing the compressed bytecode for your application,
    the following executable will be generated in the `target` folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含您应用程序压缩字节码的 JAR 文件外，以下可执行文件将在 `target` 文件夹中生成：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The actual name of your application can be varied by setting the `native.image.path`
    environment variable in your `pom.xml` file, which is `${project.build.directory}/${project.build.finalName}-runner`
    by default.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您应用程序的实际名称可以通过在`pom.xml`文件中设置`native.image.path`环境变量来改变，默认值为`${project.build.directory}/${project.build.finalName}-runner`。
- en: 'As you can see, with approximately 20 MB, we have an executable application
    runtime that contains all the libraries and just what it needs from the JVM to
    run our application. You can execute it with the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个大约20 MB的可执行应用程序运行时，它包含所有库以及从JVM运行我们的应用程序所需的一切。您可以使用以下命令执行它：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In as little as 0.006s, we got our service up and running. This can be seen
    in the console log:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅0.006秒，我们就让我们的服务启动并运行。这可以在控制台日志中看到：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s check the memory usage of this compact application by executing the
    `ps` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行`ps`命令来检查这个紧凑型应用程序的内存使用情况：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the output I have collected from my laptop:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我从我的笔记本电脑收集到的输出：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although the output may vary depending on your environment, the **Resident Set
    Size** (**RSS**) shows that the process is taking about 18 MB of memory, which
    is a fraction of the minimum memory size required for a Java application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管输出可能因您的环境而异，但**常驻集大小**（**RSS**）显示该进程正在使用大约18 MB的内存，这仅是Java应用程序所需的最小内存大小的一小部分。
- en: 'Now, let''s execute it to check the result:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行它以检查结果：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the result didn't change when we turned our application into
    a native application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们将我们的应用程序转换为本地应用程序时，结果并没有改变。
- en: Executing integration tests against the native executable
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对本地可执行文件执行集成测试
- en: Interestingly, native executable code can be tested. When you generated the
    sample project, a `Native<project>Test` class name was included in the test folder.
    This class differs from Java tests as it's annotated with the `@NativeImageTest`
    annotation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，本地可执行代码可以测试。当您生成示例项目时，测试文件夹中包含了一个名为`Native<project>Test`的类名。这个类与Java测试不同，因为它被注解为`@NativeImageTest`注解。
- en: As a result of the Maven failsafe plugin configuration, all rests ending in
    **IT* or annotated with `@NativeImageTest` will be run against the native executable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Maven failsafe插件的配置，所有以**IT**结尾或用`@NativeImageTest`注解的rest都将针对本地可执行文件运行。
- en: 'In terms of code, there''s no need to make any changes as it uses inheritance
    to execute the native executable tests from our `SimpleRestTest` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，无需进行任何更改，因为它使用继承来执行来自我们的`SimpleRestTest`类的本地可执行测试：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `verify` goal is required to test native executables. Before that, make
    sure you have exported the path where GraalVM has been installed into your environment:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify`目标用于测试本地可执行文件。在此之前，请确保您已将GraalVM安装路径导出到您的环境中：'
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, you can run the `verify` goal to test the native executable application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`verify`目标来测试本地可执行应用程序：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check that the outcome is the same one that we produced in the *Testing Quarkus
    applications* section, earlier in this chapter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查结果是否与本章前面*测试Quarkus应用程序*部分中产生的结果相同：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! We have just managed to test our sample application in both scenarios
    (JVM and native executable).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们刚刚成功测试了我们的示例应用程序在两种场景（JVM和本地可执行）下。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through our first proof of concept Quarkus project,
    which was generated through `quarkus-maven-plugin`. The default application is
    a prototype of the REST service with all the minimal functionalities and a `Test`
    class that we have progressively enriched. In the second part of this chapter,
    we saw how to turn the Java application code into a thin native executable using
    the appropriate native profile of `quarkus-maven-plugin`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了我们的第一个概念验证Quarkus项目，该项目是通过`quarkus-maven-plugin`生成的。默认应用程序是一个具有所有最小功能和一个我们逐步丰富`Test`类的REST服务的原型。在本章的第二部分，我们看到了如何使用`quarkus-maven-plugin`的适当本地配置将Java应用程序代码转换为瘦型本地可执行文件。
- en: So far, we have only scratched the surface of what we can do with Quarkus. Now,
    it's time to move on and learn how to create a Container image out of our native
    application and deploy it in a Kubernetes environment. This is what we are going
    to discuss in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是触及了我们可以用Quarkus做到的事情的表面。现在，是时候继续前进，学习如何从我们的本地应用程序创建容器镜像，并在Kubernetes环境中部署它。这就是我们将在下一章中讨论的内容。
