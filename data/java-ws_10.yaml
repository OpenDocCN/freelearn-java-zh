- en: 10\. Encryption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 加密
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses Java's support for encryption. It does this first, by
    defining symmetric and asymmetric key encryption, then teaching you to implement
    those encryptions **Advanced Encryption Standard** (**AES**) and **Rivest-Shamir-Adleman**
    (**RSA**), respectively. You will further learn to differentiate between block
    and stream ciphers, so that you may utilize them appropriately when encrypting
    your files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论Java对加密的支持。它首先通过定义对称密钥加密和非对称密钥加密来实现这一点，然后教你如何实现这些加密**高级加密标准**（**AES**）和**RSA**（**Rivest-Shamir-Adleman**），分别。你还将进一步学习区分块密码和流密码，以便在加密文件时能够适当使用它们。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Encryption is the process of scrambling data so that it can be sent in plain
    sight between two or more parties without anyone else being able to understand
    what was sent. Today, almost everything you do online is encrypted—be it reading
    an email, sending a photo to a popular social network, or downloading source code.
    Most serious websites today are also encrypted. Applying encryption to your software
    is vital for safeguarding your integrity, data, and business, as well as that
    of your customer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将数据打乱的过程，以便可以在两个或多个当事人之间公开发送，而其他人无法理解发送了什么。如今，你在网上做的几乎所有事情都是加密的——无论是阅读电子邮件、将照片发送到流行的社交网络，还是下载源代码。今天的大多数严肃网站也都是加密的。将加密应用于你的软件对于保护你的完整性、数据、业务以及客户的利益至关重要。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encryption is a very complicated topic that gets more complex every year as
    we try to safeguard our applications from new malicious code and individuals.
    This chapter will not go into detail about how encryption should be implemented
    in software. Instead, we will explain how you can use the APIs that are available
    within Java.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是一个非常复杂的话题，每年都在变得更加复杂，因为我们试图保护我们的应用程序免受新的恶意代码和个人的侵害。本章不会详细介绍如何在软件中实现加密。相反，我们将解释如何使用Java中可用的API。
- en: In Java, we have a collection of classes and interfaces that have been specifically
    created for handling most security-related cases on the Java platform—they're
    all gathered in what is called the **Java Cryptography Architecture** (**JCA**).
    Within the JCA lies the foundation for building secure applications in Java. Several
    other secure libraries within Java use the JCA to implement their security. With
    the JCA, you can either create your own custom security providers or use the already
    available standard providers. In most cases, using the standard providers is enough.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们有一系列专门为处理Java平台上的大多数安全相关案例而创建的类和接口——它们都被收集在被称为**Java密码架构**（**JCA**）的地方。在JCA中，为在Java中构建安全应用程序奠定了基础。Java中还有其他几个安全库使用JCA来实现它们的安全性。使用JCA，你可以创建自己的自定义安全提供者或使用已提供的标准提供者。在大多数情况下，使用标准提供者就足够了。
- en: Plaintext
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明文
- en: In cryptographic terms, plaintext means the data that you wish to encrypt. Cleartext
    is another popular term that is used interchangeably with plaintext depending
    on who you ask.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学术语中，明文是指你希望加密的数据。明文是另一个常用的术语，其使用与明文可以互换，这取决于你询问的对象。
- en: Ciphertext
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密文
- en: This is the encrypted version of plaintext. This is the data that is safe to
    send to the receiving party.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是明文的加密版本。这是可以安全发送给接收方的数据。
- en: Ciphers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码
- en: A cipher is a mathematical function, or algorithm, that is used to encrypt plaintext
    data into ciphertext. However, a cipher is not enough to create ciphertext from
    plaintext – you also require a key that defines the unique way your encryption
    will work. All keys are generated uniquely. Depending on the type of cipher you
    make, you'll have one or two keys to encrypt and decrypt your data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 密码是一种数学函数或算法，用于将明文数据加密成密文。然而，仅使用密码从明文创建密文是不够的——你还需要一个密钥来定义你的加密将如何独特地工作。所有密钥都是唯一生成的。根据你选择的密码类型，你可能需要一个或两个密钥来加密和解密你的数据。
- en: 'To initialize a cipher in Java, you''ll need to know three things about it:
    the algorithm used, the mode, and the type of padding. Different ciphers work
    in different ways, so defining the correct transformation is critical to avoid
    causing exceptions or creating insecure applications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中初始化一个密码，你需要了解关于它的三个信息：使用的算法、模式和填充类型。不同的密码以不同的方式工作，因此定义正确的转换对于避免引发异常或创建不安全的应用程序至关重要：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The algorithms or ciphers are kept in what we call cryptographic providers (or
    just providers). Depending on the system in which the application is running,
    you may not have access to all kinds of ciphers out of the box. In some cases,
    you may even have to install additional providers to access the cipher you wish
    you use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 算法或加密算法存储在我们所说的加密提供程序（或简称提供程序）中。根据应用程序运行的系统，您可能无法直接访问所有类型的加密算法。在某些情况下，您甚至可能需要安装额外的提供程序才能访问您希望使用的加密算法。
- en: 'However, every **Java Virtual Machine** (**JVM**) does come with a set of available
    ciphers with different transformations. At the very least, you''ll always find
    the following transformations available on any JVM today:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个 **Java 虚拟机**（**JVM**）都附带了一套具有不同转换的可用加密算法。至少，您现在在任何 JVM 上都可以找到以下转换：
- en: AES/CBC/NoPadding
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES/CBC/NoPadding
- en: AES/CBC/PKCS5Padding
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES/CBC/PKCS5Padding
- en: AES/ECB/NoPadding
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES/ECB/NoPadding
- en: AES/ECB/PKCS5Padding
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES/ECB/PKCS5Padding
- en: AES/GCM/NoPadding
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES/GCM/NoPadding
- en: DES/CBC/NoPadding
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES/CBC/NoPadding
- en: DES/CBC/PKCS5Padding
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES/CBC/PKCS5Padding
- en: DES/ECB/NoPadding
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES/ECB/NoPadding
- en: DES/ECB/PKCS5Padding
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES/ECB/PKCS5Padding
- en: DESede/CBC/NoPadding
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESede/CBC/NoPadding
- en: DESede/CBC/PKCS5Padding
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESede/CBC/PKCS5Padding
- en: DESede/ECB/NoPadding
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESede/ECB/NoPadding
- en: DESede/ECB/PKCS5Padding
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESede/ECB/PKCS5Padding
- en: RSA/ECB/PKCS1Padding
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA/ECB/PKCS1Padding
- en: RSA/ECB/OAEPWithSHA-1AndMGF1Padding
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA/ECB/OAEPWithSHA-1AndMGF1Padding
- en: RSA/ECB/OAEPWithSHA-256AndMGF1Padding
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA/ECB/OAEPWithSHA-256AndMGF1Padding
- en: Keys
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥
- en: 'Every cipher requires at least one key to encrypt the plaintext and decrypt
    the ciphertext. Depending on the type of cipher, the key can be either symmetric
    or asymmetric. Usually, you''ll work with keys stored in non-volatile memory,
    but you can also generate keys from code. In the JCA, there is a simple command
    that is used to generate a key for a specific cipher:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加密算法至少需要一个密钥来加密明文和解密密文。根据加密算法的类型，密钥可以是对称的或非对称的。通常，您会处理存储在非易失性内存中的密钥，但您也可以从代码中生成密钥。在
    JCA 中，有一个简单的命令用于为特定加密算法生成密钥：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Symmetric Key Encryption
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: Symmetric encryption is usually considered less safe than asymmetric encryption.
    This is not because the algorithms are less secure than asymmetric encryption,
    but because the key that is used to unlock the content must be shared by more
    than one party. The following diagram illustrates how symmetric encryption works,
    in general terms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密通常被认为比非对称加密不安全。这并不是因为算法比非对称加密不安全，而是因为用于解锁内容的密钥必须由多个实体共享。以下图表以一般术语说明了对称加密的工作原理。
- en: '![Figure 10.1: Symmetric encryption](img/C13927_10_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：对称加密](img/C13927_10_01.jpg)'
- en: 'Figure 10.1: Symmetric encryption'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：对称加密
- en: 'You can create keys for symmetric encryption in this way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过这种方式创建对称加密的密钥：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One of the most popular symmetric encryption methods today is the **Advanced
    Encryption Standard** (**AES**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最受欢迎的对称加密方法之一是 **高级加密标准**（**AES**）。
- en: 'Exercise 1: Encrypting the String Using Advanced Encryption Standard'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：使用高级加密标准加密字符串
- en: 'In this exercise, we will encrypt the "`My secret message`" string using AES:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 AES 加密字符串 "`My secret message`"：
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project opened, then select `File` -> `New`
    -> `Project` from the menu.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 IntelliJ 已经启动但没有打开项目，则选择 `创建新项目`。如果 IntelliJ 已经打开了项目，则从菜单中选择 `文件` -> `新建`
    -> `项目`。
- en: In `New Project Dialog`, select a Java project. Click on `Next`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新建项目对话框` 中，选择 Java 项目。单击 `下一步`。
- en: Check the box to create the project from a template. Select `Command Line App`.
    Then, click on `Next`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开复选框以从模板创建项目。选择 `命令行应用程序`。然后，单击 `下一步`。
- en: Give the new project the name `Chapter10`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新项目命名为 `Chapter10`。
- en: IntelliJ will give you a default project location; if you wish to select your
    own, you can enter it here.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliJ 会为您提供一个默认的项目位置；如果您想选择自己的位置，可以在这里输入。
- en: Set the package name to `com.packt.java.chapter10`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名设置为 `com.packt.java.chapter10`。
- en: Click on `Finish`. IntelliJ will create your project called `Chapter10` with
    the standard folder structure. IntelliJ will also create the main entry point
    for your application, called `Main.java`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 `完成`。IntelliJ 将创建名为 `Chapter10` 的项目，并具有标准文件夹结构。IntelliJ 还将为您的应用程序创建主入口点，称为
    `Main.java`。
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件重命名为 `Exercise1.java`。完成时，它应该看起来像这样：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Decide on the algorithm that you want to use for your encryption – in this
    example, we''re using AES –then, generate the key for the encryption. Generating
    the key may cause an exception if the selected algorithm isn''t supported by any
    of the providers on the system:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定您想要用于加密的算法——在这个例子中，我们使用AES——然后，生成加密密钥。如果选定的算法不被系统上的任何提供者支持，生成密钥可能会抛出异常：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, we're using a variable to store the key. However, in most
    real-life scenarios, you'll likely use a less volatile form of storage—such as
    a file or database.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用一个变量来存储密钥。然而，在大多数实际场景中，您可能会使用一种更稳定的存储形式——例如文件或数据库。
- en: 'The next step is to define the actual encryption transformation to use. As
    mentioned previously, the transformation contains information about how to handle
    the cipher. In this case, we''re using AES, which is a block cipher, so we need
    to define how to apply the key to each block of the plaintext data. Additionally,
    we need to define whether there should be any padding, and what that padding should
    look like:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义实际要使用的加密转换。如前所述，转换包含有关如何处理加密器的信息。在这种情况下，我们使用AES，它是一种分组密码，因此我们需要定义如何将密钥应用于明文数据的每个块。此外，我们还需要定义是否应该有任何填充，以及这种填充应该是什么样子：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We already chose AES as the algorithm, so we're starting the transformation
    with that. Following this, we've decided to go for the less-safe **Electronic
    Code Book** (**ECB**) transformation mode, which means we're applying the key
    in the same way for each block of plaintext data. Finally, we've defined that
    we'll use no padding if a block in the plaintext data is shorter than the cipher
    block length.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经选择了AES作为算法，所以我们从那个开始转换。在此之后，我们决定采用不太安全的**电子密码本**（**ECB**）转换模式，这意味着我们将以相同的方式为每个明文数据块应用密钥。最后，我们定义，如果明文数据块短于密文块长度，我们将不使用填充。
- en: 'Query the system for the cipher with the suggested transformation. This method
    can throw both `NoSuchAlgorithmException` and `NoSuchPaddingException.` Make sure
    to handle this if that is the case:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询系统以获取建议的转换的加密器。此方法可能会抛出`NoSuchAlgorithmException`和`NoSuchPaddingException`。如果出现这种情况，请确保处理：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Encrypting and decrypting is almost identical when compared to the Java API.
    When encrypting a plaintext file, you initiate the cipher in encryption mode,
    and when decrypting a ciphertext file, you initiate the cipher in decryption mode.
    This may cause `InvalidKeyException` if the key is wrong:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Java API相比，加密和解密几乎相同。当加密明文文件时，您在加密模式下初始化加密器，当解密密文文件时，您在解密模式下初始化加密器。如果密钥错误，这可能会导致`InvalidKeyException`：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In fact, encrypting your text is a two-step process, and you always need to
    adjust your work depending on the actual bytes of the data. Since we''re working
    on a `String`, you will need to get the actual bytes of this `String`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，加密您的文本是一个两步过程，并且您始终需要根据实际数据字节调整您的工作。由于我们正在处理一个`String`，您将需要获取这个`String`的实际字节：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you may have noticed, there are a lot of things that could go wrong when
    working with encryption. Usually, you should handle these exceptions gracefully,
    but in this case, we'll just print them.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，在使用加密时可能会出现很多问题。通常，您应该优雅地处理这些异常，但在这个例子中，我们只是将它们打印出来。
- en: 'Now, the last thing to do is print the encrypted version of the text to verify
    that you''ve encrypted the data. You should see gibberish in the terminal. That''s
    fine; it just means you''ve succeeded in hiding the plaintext message in a ciphertext
    file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后要做的就是打印文本的加密版本以验证您已加密数据。您应该在终端中看到乱码。这是正常的；这意味着您已成功将明文消息隐藏在密文文件中：
- en: What happens if you change the transformation padding to `NoPadding`?
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您将转换填充更改为`NoPadding`，会发生什么？
- en: What happens if you keep the `PKCS5Padding` but change the plaintext message
    to "`This is 16 bytes`"?
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您保留`PKCS5Padding`但将明文消息更改为"`This is 16 bytes`"，会发生什么？
- en: Try to decrypt the message by instead initializing the cipher to `MODE_DECRYPT`,
    and then passing the ciphertext rather than the plaintext message. Remember, you
    need to use the same key for this process to work; otherwise, you'll see gibberish
    again.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试通过将加密器初始化为`MODE_DECRYPT`而不是明文消息来传递密文来解密消息。记住，您需要使用相同的密钥才能使此过程正常工作；否则，您将再次看到乱码。
- en: Block Ciphers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组密码
- en: AES is a block cipher, meaning that encryption is handled on one block of plaintext
    at a time. A block size depends on the key size; that is, a larger key means a
    larger block.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: AES是一种分组密码，这意味着加密是逐个处理一个明文块的。块大小取决于密钥大小；也就是说，更大的密钥意味着更大的块。
- en: Initialization Vectors
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化向量
- en: Some of the transformation modes for block ciphers require you to work with
    an initialization vector – it's an improvement that handles the obvious repeat
    pattern of the ECB mode. This is easily visualized by an image showing the difference
    in encryption using AES/ECB and AES/CBC.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分组密码的转换模式要求你使用初始化向量——这是对ECB模式明显重复模式的改进。这可以通过一个显示AES/ECB和AES/CBC加密差异的图像来直观地展示。
- en: CBC refers to **Cipher Block Chaining** and, in short, it scrambles the current
    block of data based on the previous block of data. Or, if it was the first block,
    it scrambles the data based on the initialization vector.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CBC指的是**分组密码链**，简而言之，它是根据前一个数据块来混淆当前数据块的。或者，如果是第一个数据块，则是根据初始化向量来混淆数据。
- en: Stream Ciphers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流密码
- en: A stream cipher, on the other hand, works by encrypting each byte at a time.
    There is a theoretical discussion about what is known as "the one-time pad," which
    represents the ideal stream encryption. These are, in theory, extremely secure,
    but are also very impractical, as the key must be the same length as the plaintext
    data. With large plaintext data, such keys are impossible to use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，流密码通过逐个字节加密来工作。有一个关于被称为“一次性密码”的理论讨论，它代表了理想的流加密。在理论上，这些非常安全，但也很不实用，因为密钥必须与明文数据长度相同。对于大量明文数据，这样的密钥是无法使用的。
- en: Asymmetric Key Encryption
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称密钥加密
- en: In asymmetric key encryption, the private key is held by one party only—the
    receiver or owner of the data. The sender of the data, who is not considered the
    owner, uses what we call a public key to encrypt the data. The public key can
    be held by anyone without jeopardizing any previously encrypted messages. This
    is considered a more secure way of handling encryption, as only the receiver can
    decrypt the message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在非对称密钥加密中，私钥只由一方持有——接收者或数据的所有者。数据发送者，即不被视为所有者的一方，使用我们所说的公钥来加密数据。公钥可以被任何人持有，而不会危及任何之前加密的消息。这被认为是一种更安全的加密处理方式，因为只有接收者才能解密消息。
- en: 'Exercise 2: Encrypting the String Using the RSA Asymmetric Key Encryption'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：使用RSA非对称密钥加密加密字符串
- en: 'Encrypt the "`My secret message`" message using the **Rivest–Shamir–Adleman**
    (**RSA**) asymmetric key encryption. This is a public/private key combination:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Rivest–Shamir–Adleman**（**RSA**）非对称密钥加密来加密"`My secret message`"消息。这是一个公钥/私钥组合：
- en: Open the `Chapter10` project in IDEA if it's not already open.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开IDEA中的`Chapter10`项目。
- en: Create a new Java class using the `File -> New -> Java Class` menu.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`File -> New -> Java Class`菜单创建一个新的Java类。
- en: 'Enter `Exercise2` as `Name`, and then select `OK`. You should now have an empty
    class in your project:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Name`设置为`Exercise2`，然后选择`OK`。现在你应该在你的项目中有一个空的类：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a `main` method—you''ll write all your code in that for this exercise:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main`方法——你将在其中编写所有代码进行这个练习：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declare a plaintext `String` with the content "`My secret message`":'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个包含内容"`My secret message`"的明文`String`：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add another string "RSA" in which you''ll write the algorithm for this exercise:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加另一个字符串"RSA"，你将在那里编写这个练习的算法：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because RSA is an asymmetric form of key encryption, you need to generate a
    key pair instead of a key. Catch the exception if the algorithm is not found:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为RSA是一种非对称密钥加密形式，所以你需要生成一个密钥对而不是一个密钥。如果找不到算法，请捕获异常：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the transformation; we''ll go with electronic code block and `PKCS1Padding`
    for this exercise:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义转换；在这个练习中，我们将使用电子密码本和`PKCS1Padding`：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a cipher for the algorithm and initialize it with the chosen transformation.
    Remember to always use the public key when encrypting with RSA:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为算法创建一个密文并使用所选的转换初始化它。记住，在用RSA加密时始终使用公钥：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, encrypt the plaintext into ciphertext, you'll notice that the ciphertext
    is much larger when using RSA than AES. This is because of the key size.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将明文加密成密文，你会注意到使用RSA加密的密文比AES加密的密文大得多。这是因为密钥大小的原因。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also use the decrypt logic for RSA. Remember to use the private key
    when decrypting; otherwise, it will not work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用RSA的解密逻辑。记住，在解密时使用私钥；否则，它将不起作用。
- en: Encrypting Files
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密文件
- en: Encrypting files is very much like encrypting strings. However, with large files,
    it may be wise to empty the cipher streams. However, if the file is too large,
    or if there are multiple files, then it may be wise to apply `CipherStreams`—not
    to be confused with Stream Cipher.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文件非常类似于加密字符串。然而，对于大文件，清空加密流可能更明智。但如果文件太大，或者有多个文件，那么应用`CipherStreams`可能更明智——不要与流加密混淆。
- en: '`CipherStreams` inherit most of their behavior from `InputStream` and `OutputStream`
    of Java, with the modification that you can decrypt a file you read, or encrypt
    a file you write with the supplied cipher.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CipherStreams`继承了Java的`InputStream`和`OutputStream`的大部分行为，修改之处在于你可以使用提供的加密解密你读取的文件，或者加密你写入的文件。'
- en: 'Exercise 3: Encrypting a File'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3：加密文件
- en: The following exercise displays how to encrypt a file. You can find this file
    in the code repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习展示了如何加密一个文件。你可以在代码仓库中找到这个文件。
- en: Open the `Chapter10` project in IDEA if it's not already open.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开IDEA中的`Chapter10`项目。
- en: Create a new Java class, using the `File` | `New` | `Java Class` menu.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`File` | `New` | `Java Class` 菜单创建一个新的Java类。
- en: 'Enter `Exercise3` as Name, and then select `OK`. You should now have an empty
    class in your project:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称输入为`Exercise3`，然后选择`OK`。现在你应该在你的项目中有一个空的类：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a `main` method in which you''ll write the code for this exercise:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main`方法，在其中编写这个练习的代码：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the algorithm to use for your encryption; we''ll go back to AES for
    this exercise and generate the key:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于加密的算法；在这个练习中我们将回到AES并生成密钥：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Get an instance of the cipher and initialize it for encryption:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取加密实例并初始化它以进行加密：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a file for the encryption; you can download the `plaintext.txt` file
    from the book''s GitHub repository if you wish. Alternatively, you can just create
    your own text file using lipsum—or even better, copy a document from your computer.
    We''re placing these files in the "`res`" folder of your project:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于加密的文件；如果你愿意，可以从书籍的GitHub仓库下载`plaintext.txt`文件。或者，你也可以使用lipsum创建自己的文本文件——甚至更好的是，从你的电脑上复制一个文档。我们将把这些文件放在你项目的"`res`"文件夹中：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In addition to this, create a file that will hold the encrypted contents. Make
    sure the file doesn''t already exist:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个将保存加密内容的文件。确保该文件不存在：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now it''s time to add the cipher streams. In this instance, we need `FileInputStream`
    to read the contents of the `plaintext.txt` file, `FileOutputStream` to write
    an initialization vector, and `CipherOutputStream` to perform the encryption:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候添加加密流了。在这个例子中，我们需要`FileInputStream`来读取`plaintext.txt`文件的内容，`FileOutputStream`来写入初始化向量，以及`CipherOutputStream`来执行加密：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write the initialization vector; you will find it in the initialized cipher.
    Make sure to use `FileOutputStream` as we do not want to encrypt these bytes:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写初始化向量；你将在初始化的加密中找到它。确保使用`FileOutputStream`，因为我们不希望加密这些字节：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, write the contents of `FileInputStream` to `CipherOutputStream`, allowing
    the contents to be encrypted in the process:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`FileInputStream`的内容写入`CipherOutputStream`，允许在过程中加密内容：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are numerous ways of working with files in Java, and this is just one
    way of encrypting the contents. If you have larger files, perhaps `BufferedReader`
    would be a good option to use.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中处理文件有众多方法，这只是加密内容的一种方式。如果你有更大的文件，也许使用`BufferedReader`会是一个不错的选择。
- en: Instead of encrypting a file, use the cipher streams to encrypt a whole folder.
    Perhaps the best practice here is to first compress the folder into a ZIP archive
    and then encrypt that file.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是加密文件，而是使用加密流来加密整个文件夹。也许最好的做法是首先将文件夹压缩成ZIP存档，然后加密那个文件。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The JCA contains everything you need to work with encryption. In this chapter,
    you've only really scratched the surface of this major framework. This is just
    enough to get you started, but if you intend to progress further into the complexities
    of this framework, you will first need to develop a greater understanding of cryptography.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JCA包含了你需要用于加密的一切。在本章中，你只是刚刚触及了这个主要框架的表面。这已经足够让你开始，但如果你打算进一步深入这个框架的复杂性，你将首先需要更深入地了解密码学。
- en: In the next chapter, we will cover the launching of processes, as well as sending
    input and capturing the output of child processes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍进程的启动，以及向子进程发送输入和捕获输出。
- en: XRB39
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: XRB39
