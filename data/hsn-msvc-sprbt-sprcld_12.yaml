- en: Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway将微服务隐藏在边缘服务器后面
- en: In this chapter, we will learn how to use Spring Cloud Gateway as an edge server,
    that is, to control what APIs are exposed from our microservices-based system
    landscape. We will see how microservices that have public APIs will be made accessible
    from the outside through the edge server, while microservices that have private
    APIs only will be accessible from the inside of the microservice landscape. In
    our system landscape, this means that the product composite service and the discovery
    service, Netflix Eureka, will be exposed through the edge server. The three core
    services—`product`, `recommendation`, and `review`—will be hidden from the outside.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Spring Cloud Gateway作为边缘服务器，即控制从我们的基于微服务的系统架构中暴露哪些API。我们将了解具有公共API的微服务将通过边缘服务器从外部访问，而只有私有API的微服务只能从微服务架构的内部访问。在我们的系统架构中，这意味着产品组合服务和企业级Eureka服务将通过边缘服务器暴露。三个核心服务—`product`、`recommendation`和`review`—将对外隐藏。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding an edge server to our system landscape
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到我们的系统架构中
- en: Setting up a Spring Cloud Gateway, including configuring routing rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个Spring Cloud Gateway，包括配置路由规则
- en: Trying out the edge server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试边缘服务器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave,
    but should be straightforward to modify in order to run on another platform such
    as Linux or Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但应该很容易修改以在其他平台如Linux或Windows上运行。
- en: No new tools need to be installed in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10)。
- en: 'To be able to run the commands as described in this book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following are sample commands:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照本书描述运行命令，将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。以下是一些示例命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, which is the latest available version of the Spring
    components at the time of writing this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0, SR1（也称为**Greenwich**版本），Spring
    Boot 2.1.3和Spring 5.1.5，这些是编写本章时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/gateway`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter10` but
    are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, and import and log statements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都来自`$BOOK_HOME/Chapter10`的源代码，但在许多情况下，为了删除源代码中不相关部分，例如注释、导入和日志声明，都对代码进行了编辑。
- en: If you want to see the changes applied to the source code in [Chapter 10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using
    Spring Cloud Gateway to Hide Microservices Behind an Edge Server*, that is, see what
    it took to add Spring Cloud Gateway as an edge server to the microservices landscape, you
    can compare it with the source code for [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter09` and `$BOOK_HOME/Chapter10`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)中应用于源代码的更改，*使用Spring
    Cloud Gateway将微服务隐藏在边缘服务器后面*，也就是说，看看添加Spring Cloud Gateway作为边缘服务器到微服务架构中需要做些什么，你可以将其与[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)的源代码*使用Netflix
    Eureka和Ribbon添加服务发现*进行比较。你可以使用你喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter09`和`$BOOK_HOME/Chapter10`。
- en: Adding an edge server to our system landscape
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的系统架构中添加边缘服务器
- en: 'In this section we will see how the edge server is added to the system landscape
    and how it affects the way external clients access the public APIs that the microservices
    expose. All incoming requests will now be routed through the edge server, as illustrated
    by the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何将边缘服务器添加到系统架构中以及它如何影响外部客户端访问微服务公开API的方式。所有传入请求现在都将通过边缘服务器路由，如下面的diagram所示：
- en: '![](img/3ec7ce9c-d8a1-48bd-a0af-932a2b44ed6b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ec7ce9c-d8a1-48bd-a0af-932a2b44ed6b.png)'
- en: As we can see from the preceding diagram, external clients send all their requests
    to the edge server. The edge server can route the incoming requests based on the
    URL path. For example, requests with a URL that starts with `/product-composite/`
    are routed to the **Product Composite** microservice, and a request with a URL
    that starts with `/eureka/` is routed to the **Discovery Server** based on Netflix
    Eureka.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面 diagram 可以看出，外部客户端将其所有请求发送到边缘服务器。边缘服务器可以根据URL路径来路由传入的请求。例如，以`/product-composite/`开头的URL的请求会被路由到**产品组合**微服务，以`/eureka/`开头的URL的请求会基于Netflix
    Eureka被路由到**发现服务器**。
- en: 'In the previous [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*, we exposed both the `product-composite`
    service and the discovery service, Netflix Eureka, to the outside. When we introduce
    the edge server in this chapter, this will no longer be the case.  This is implemented
    by removing the following port declarations for the two services in the Docker
    Compose files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)中，*使用Netflix Eureka和Ribbon添加服务发现*，我们向外部暴露了`product-composite`服务和发现服务，Netflix
    Eureka。当我们在本章中引入边缘服务器时，这将不再适用。这是通过删除两个服务在Docker Compose文件中的以下端口声明来实现的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the edge serve added to the system landscape, we will learn how to set
    up an edge server based on Spring Cloud Gateway in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中添加了边缘服务器后，我们将在下一节学习如何基于Spring Cloud Gateway设置边缘服务器。
- en: Setting up a Spring Cloud Gateway
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway
- en: In this section, we will learn how to set up an edge server based on Spring
    Cloud Gateway.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何基于Spring Cloud Gateway设置边缘服务器。
- en: 'Setting up a Spring Cloud Gateway as an edge server is straightforward and
    can be done by means of the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway作为边缘服务器是直接的，可以通过以下步骤完成：
- en: Create a Spring Boot project using Spring Initializr as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices—*refer to the *Using Spring Initializr to generate skeleton code*
    section.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在第3章中描述的Spring Initializr创建Spring Boot项目，*创建一组协作的微服务—*参考*使用Spring Initializr生成骨架代码*部分。
- en: Add a dependency to `spring-cloud-starter-gateway`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`spring-cloud-starter-gateway`依赖。
- en: To be able to locate microservices instances though Netflix Eureka, also add
    the `spring-cloud-starter-netflix-eureka-client` dependency.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够通过Netflix Eureka定位微服务实例，也请添加`spring-cloud-starter-netflix-eureka-client`依赖。
- en: 'Add the edge server to the common build file, `settings.gradle`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通用构建文件`settings.gradle`中添加边缘服务器：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add a Dockerfile with the same content as for our microservices.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Dockerfile中添加与我们的微服务相同内容。
- en: 'Add the edge server to our three Docker Compose files:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的三个Docker Compose文件中添加边缘服务器：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Port `8080` of the edge server is exposed outside the Docker engine. The memory
    limit of 350 MB is to ensure that all containers in this and the coming chapters
    will fit in the 6 GB of memory that we have allocated to the Docker engine
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器的`8080`端口暴露在Docker引擎外部。350 MB的内存限制是为了确保本章及接下来的章节中的所有容器都能容纳在我们为Docker引擎分配的6
    GB内存中。
- en: Add configuration for routing rules and more; refer to the *Configuring a Spring
    Cloud Gateway* section as we proceed in this chapter.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加路由规则配置等；参考本章后续的*配置Spring Cloud Gateway*部分。
- en: Since the edge server will handle all incoming traffic, we will move the composite health
    check from the product composite service to the edge server. This is described
    in *Adding a composite health check* section.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于边缘服务器将处理所有传入流量，我们将把复合健康检查从产品复合服务移动到边缘服务器。这在*添加复合健康检查*部分有所描述。
- en: You can find the source code for the Spring Cloud Gateway in `$BOOK_HOME/Chapter10/spring-cloud/gateway`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到Spring Cloud Gateway的源代码在`$BOOK_HOME/Chapter10/spring-cloud/gateway`。
- en: Adding a composite health check
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复合健康检查
- en: With an edge server in place, external health check requests also have to go through
    the edge server. Therefore, the composite health check that checks the status
    of all microservices been moved from the `product-composite` service to the edge
    server. See [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices—*refer to the *Adding a health API* section for implementation
    details of the composite health check.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了边缘服务器后，外部的健康检查请求也必须通过边缘服务器。因此，检查所有微服务状态的复合健康检查从`product-composite`服务移动到了边缘服务器。参考[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)*开发反应式微服务*，参考*添加健康API*部分实现复合健康检查的细节。
- en: 'The following has been added to the edge server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容已添加到边缘服务器：
- en: 'The `se.magnus.springcloud.gateway.HealthCheckConfiguration` class has been
    added, which declares the health indicator:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新增了`se.magnus.springcloud.gateway.HealthCheckConfiguration`类，该类声明了一个健康指标：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added the `product-composite` service to the composite health check!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在复合健康检查中添加了`product-composite`服务。
- en: 'The main application class, `se.magnus.springcloud.gateway.GatewayApplication`, declares
    a `WebClient.builder` bean to be used by the implementation of the health indicator
    as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主应用类`se.magnus.springcloud.gateway.GatewayApplication`声明了一个`WebClient.builder`bean，供健康指标的实现使用：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding source code, we see that `WebClient.builder` is annotated
    with `@LoadBalanced`, which makes it aware of microservice instances registered
    in the discovery server, Netflix Eureka. Refer to the *Service discovery with
    Netflix Eureka in Spring Cloud* section in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon, *for details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的源代码中，我们可以看到`WebClient.builder`被注解为`@LoadBalanced`，这使得它能够意识到注册在发现服务器Netflix
    Eureka中的微服务实例。参考[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)*使用Netflix Eureka进行服务发现*部分的*使用Spring
    Cloud与Netflix Eureka和Ribbon添加服务发现*。
- en: With a composite health check in place in the edge server, we are ready to look
    at the configuration that can be set up for a Spring Cloud Gateway.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘服务器中设置了复合健康检查后，我们就可以看看可以为Spring Cloud Gateway设置的配置了。
- en: Configuring a Spring Cloud Gateway
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Gateway
- en: 'When it comes to configuring a Spring Cloud Gateway, the most important thing is setting
    up the routing rules. We also need to set up a few other things in the configuration:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到配置Spring Cloud Gateway时，最重要的是设置路由规则。我们还需要在配置中设置其他几件事：
- en: Since Spring Cloud Gateway will use Netflix Eureka to find the microservices
    it will route traffic to, so it must be configured as a Eureka client in the same
    way as described in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*—refer to the *Configuration
    of clients to the Eureka server* section.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Spring Cloud Gateway将使用Netflix Eureka查找它将路由流量的微服务，所以它必须像描述的那样配置为Eureka客户端[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)*使用Netflix
    Eureka和Ribbon添加服务发现*，参考*配置Eureka服务器客户端*部分。
- en: 'Configure Spring Boot Actuator for development usage as described in [Chapter
    7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive Microservices—*refer
    to the *Adding a health API* section:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如第7章所述，为开发用途配置Spring Boot Actuator *开发反应式微服务*：参考*添加健康API*部分。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Configure log levels so that we can see log messages from interesting parts
    of the internal processing in the Spring Cloud Gateway, for example, how it decides
    where to route incoming requests to:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置日志级别，以便我们可以看到Spring Cloud Gateway内部处理中有趣部分的发出的日志消息，例如，它是如何决定将传入请求路由到哪里的：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the full source code, refer to the configuration file: `src/main/resources/application.yml`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅配置文件：`src/main/resources/application.yml`。
- en: Routing rules
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由规则
- en: Setting up routing rules can be done in two ways; programmatically, using a
    Java DSL, or by configuration. Using the Java DSL to set up the routing rules
    programmatically can be useful in cases where the rules are stored in external
    storage, such as a database, or are given at runtime, for example, via a RESTful
    API or a message sent to the gateway. In most cases, I find it convenient to declare
    the routes in the configuration file, `src/main/resources/application.yml`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置路由规则可以采用两种方法；编程方式，使用Java DSL，或者通过配置。使用Java DSL编程方式设置路由规则在规则存储在外部存储中时很有用，例如数据库，或者在运行时给定，例如，通过RESTful
    API或发送给网关的消息。在大多数情况下，我发现声明路由在配置文件中很方便，该配置文件位于`src/main/resources/application.yml`。
- en: 'A **route** is defined by the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**路由**由以下内容定义：
- en: '**Predicates**, which select a route based on information in the incoming HTTP
    request'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谓词**，根据传入HTTP请求中的信息选择路由。'
- en: '**Filters**, which can modify both the request and/or the response'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤器**，可以修改请求和/或响应。'
- en: A **destination URI**, which describes where to send a request
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标URI**，描述请求发送到哪里。'
- en: An **ID**, that is, the name of the route
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**ID**，即路由的名称。
- en: For a full list of available predicates and filters, refer to the reference
    documentation: [https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的谓词和过滤器的完整列表，请参阅参考文档：[https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html)。
- en: Routing requests to the product-composite API
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到product-composite API
- en: 'If we, for example, want to route incoming requests where the URL path starts
    with `/product-composite/` to our `product-composite` service, we can specify
    a routing rule like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将URL路径以`/product-composite/`开头的传入请求路由到我们的`product-composite`服务，我们可以指定一个像这样的路由规则：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are some points to take from the preceding code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些从前面代码中需要注意的要点：
- en: '`id: product-composite`: The name of the route is `product-composite`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: product-composite`：路由的名称是`product-composite`。'
- en: '`uri: lb://product-composite`: If the route is selected by its predicates,
    the request will be routed to the service that is named `product-composite` in
    the discovery service, that is, Netflix Eureka. `lb://` is used to direct Spring
    Cloud Gateway to use the client-side load balancer to look up the destination
    in the discovery service.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri: lb://product-composite`：如果路由通过其谓词被选中，请求将被路由到在发现服务中名为`product-composite`的服务，即Netflix
    Eureka。`lb://`用于指示Spring Cloud Gateway使用客户端负载均衡器在发现服务中查找目的地。'
- en: '`predicates:- Path=/product-composite/**` is used to specify what requests
    this route should match. `**` matches zero or more elements in the path.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predicates:- Path=/product-composite/**` 用于指定此路由应该匹配哪些请求。`**`匹配路径中的零个或多个元素。'
- en: Routing requests to the Eureka server's API and web page
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到Eureka服务器的API和网页
- en: 'Eureka exposes both an API and a web page for its clients. To provide a clean
    separation between the API and the web page in Eureka, we will set up routes as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka为它的客户端提供了API和网页。为了在Eureka中提供API和网页之间的清晰分离，我们将按以下方式设置路由：
- en: Requests sent to the edge server with the path starting with `/eureka/api/`
    should be handled as a call to the Eureka API.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到边缘服务器，路径以`/eureka/api/`开头的请求应被视为对Eureka API的调用。
- en: Requests sent to the edge server with the path starting with `/eureka/web/`
    should be handled as a call to the Eureka web page.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到边缘服务器，路径以`/eureka/web/`开头的请求应被视为对Eureka网页的调用。
- en: 'API requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rule for the Eureka API looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: API请求将被路由到`http://${app.eureka-server}:8761/eureka`。Eureka API的路由规则如下所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `{segment}` part in the `Path` value matches zero or more elements in the
    path and will be used to replace the `{segment}` part in the `SetPath` value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`{segment}`部分在`Path`值中匹配路径中的零个或多个元素，并将用于替换`SetPath`值中的`{segment}`部分。'
- en: 'Web page requests will be routed to `http://${app.eureka-server}:8761`. The
    web page will load several web resources, such as `.js`, `.css`, and `.png` files.
    These requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rules for the Eureka web page look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 网页请求将被路由到`http://${app.eureka-server}:8761`。网页将加载几个网页资源，如`.js`、`.css`和`.png`文件。这些请求将被路由到`http://${app.eureka-server}:8761/eureka`。Eureka网页的路由规则看起来像这样：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the preceding configuration, we can take the following notes: The `${app.eureka-server}`
    property is resolved by Spring''s property mechanism depending on what Spring
    profile is activated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，我们可以得出以下结论：`${app.eureka-server}`属性取决于激活的Spring配置文件，由Spring的属性机制解析：
- en: When running the services on the same host without using Docker, for example,
    for debugging purposes, the property will be translated to `localhost` using the
    `default` profile.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在同一主机上运行服务而不使用Docker时，例如，用于调试目的，属性将被翻译为使用`default`配置文件的`localhost`。
- en: When running the services as Docker containers, the Netflix Eureka server will
    run in a container with the DNS name `eureka`. Therefore, the property will be
    translated into `eureka` using the `docker` profile.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当以Docker容器的形式运行服务时，Netflix Eureka服务器将在具有DNS名称`eureka`的容器中运行。因此，属性将被翻译为`eureka`，使用`docker`配置文件。
- en: 'The relevant parts in the `application.yml` file that defines this translation
    look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义此翻译的`application.yml`文件的相关部分看起来像这样：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Routing requests with predicates and filters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用谓词和过滤器路由请求
- en: To learn a bit more about the routing capabilities in Spring Cloud Gateway,
    we will try out host-based routing; that is, where Spring Cloud Gateway uses the
    hostname of the incoming request to determine where to route the request. We will
    use one of my favorite websites for testing HTTP codes: [http://httpstat.us/](http://httpstat.us/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多关于Spring Cloud Gateway中的路由功能，我们将尝试基于主机的路由；也就是说，Spring Cloud Gateway使用传入请求的主机名来确定如何路由请求。我们将使用一个我喜欢的用于测试HTTP代码的网站：[http://httpstat.us/](http://httpstat.us/)。
- en: 'A call to `http://httpstat.us/${CODE}` simply returns a response with the `${CODE}`
    HTTP code and a response body containing the HTTP code and a corresponding descriptive
    text. For example, see the following `curl` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对`http://httpstat.us/${CODE}`的调用简单地返回具有`${CODE}` HTTP代码和包含HTTP代码及相关描述性文本的响应体。例如，请看以下的`curl`命令：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will return the HTTP code 200, and a response body with the text, 200 OK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回HTTP代码200，以及包含文本`200 OK`的响应体。
- en: 'Let''s assume that we want to route calls to `http://${hostname}:8080/headerrouting` as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将调用`http://${hostname}:8080/headerrouting`的路由如下：
- en: Calls to the `i.feel.lucky` host should return 200 OK.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`i.feel.lucky`主机的调用应返回200 OK。
- en: Calls to the `im.a.teapot` host should return `418 I'm a teapot`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`im.a.teapot`主机的调用应返回`418 I'm a teapot`。
- en: Calls to all other hostnames should return `501 Not Implemented`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有其他主机名的调用应返回`501 Not Implemented`。
- en: 'To implement these routing rules in Spring Cloud Gateway, we can use the `Host` route predicate
    to select requests with specific hostnames, and the `SetPath` filter to set the
    desired HTTP code in the request path. This can be done as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Gateway中实现这些路由规则时，我们可以使用`Host`路由谓词来选择具有特定主机名的请求，并使用`SetPath`过滤器来设置请求路径中的期望HTTP代码。这可以按以下方式完成：
- en: 'To make calls to `http://i.feel.lucky:8080/headerrouting` return 200 OK, we
    can set up the following route:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使对`http://i.feel.lucky:8080/headerrouting`的调用返回200 OK，我们可以设置以下路由：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make calls to `http://im.a.teapot:8080/headerrouting` return `418 I''m a
    teapot`, we can set up the following route:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使对`http://im.a.teapot:8080/headerrouting`的调用返回`418 I'm a teapot`，我们可以设置以下路由：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, to make calls to all other hostnames return `501 Not Implemented`,
    we can set up the following route:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使所有其他主机名的调用返回`501 Not Implemented`，我们可以设置以下路由：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Okay, that was quite a bit of configuration, so now let's try it out!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那有很多配置，现在让我们试试吧！
- en: Trying out the edge server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试边缘服务器
- en: 'To try out the edge server, we perform the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试边缘服务器，我们执行以下步骤：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统架构，并使用以下命令运行常规测试：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Expect output similar to what we have seen in previous chapters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 期待输出与我们在前面的章节中看到类似的输出：
- en: '![](img/fa1b108b-8607-4ced-a8b6-b24fc43ce34d.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa1b108b-8607-4ced-a8b6-b24fc43ce34d.png)'
- en: 'With the system landscape including the edge server, let''s explore the following
    topics:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在包括边缘服务器的系统景观中，让我们探讨以下主题：
- en: Examine what is exposed by the edge server outside of the system landscape running
    in the Docker engine.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查边缘服务器在 Docker 引擎中运行的系统景观外部暴露了什么。
- en: 'Try out some of the most frequently used routing rules as follows:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一些最常用的路由规则：
- en: Use URL-based routing to call our APIs through the edge server.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 URL 的路由通过边缘服务器调用我们的 API。
- en: Use URL-based routing to call Netflix Eureka through the edge server, both using
    its API and web-based UI.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 URL 的路由调用通过边缘服务器的 Netflix Eureka，包括使用其 API 和基于网页的 UI。
- en: Use header-based routing to see how we can route requests based on the hostname
    in the request.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于头部的路由查看我们如何根据请求中的主机名路由请求。
- en: Examining what is exposed outside the Docker engine
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Docker 引擎外部暴露了什么
- en: 'To understand what the edge server exposes to the outside of the system landscape,
    perform the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解边缘服务器向系统景观外部暴露了什么，请执行以下步骤：
- en: 'Use the `docker-compose ps` command to see that what ports are exposed by our
    services:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker-compose ps` 命令来看看我们的服务暴露了哪些端口：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see in the following output, only the edge server (named `gateway`) exposes
    its port (`8080`) outside the Docker engine:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在下面的输出中所看到的，只有边缘服务器（名为 `gateway`）在其外部暴露了端口（`8080`）：
- en: '![](img/635db56b-5896-497a-a15d-2ca63833a1e8.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/635db56b-5896-497a-a15d-2ca63833a1e8.png)'
- en: 'If we want to see what routes the edge server has set up, we can use the `/actuator/gateway/routes` API.
    The response from this API is rather verbose. To limit the response to information
    we are interested in, we can apply a `jq` filter. In the following example, I
    have selected the `id` of the route and the first predicate in the route:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看边缘服务器设置的路由，我们可以使用 `/actuator/gateway/routes` API。此 API 的响应相当详细。为了限制响应只包含我们感兴趣的信息，我们可以应用一个
    `jq` 过滤器。在下面的示例中，我选择了路由的 `id` 和路由中的第一个谓词：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will respond with the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将回应以下内容：
- en: '![](img/7e1c7cfb-3eb6-4299-9199-b4415b1b20b3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e1c7cfb-3eb6-4299-9199-b4415b1b20b3.png)'
- en: This gives us a good overview of the actual routes configured in the edge server.
    Now, let's try out the routes!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对边缘服务器中配置的实际路由有了一个很好的概览。现在，让我们尝试一下这些路由！
- en: Trying out the routing rules
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试路由规则
- en: In this section, we will try out the edge server and the routes it exposes to
    the outside of the system landscape. Let's start with calling the product composite
    API, then call the Eureka API and visit its web page, and conclude with testing
    the routes that are based on hostnames.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试边缘服务器及其向系统景观外部暴露的路由。让我们先调用产品组合 API，然后调用 Eureka API 并访问其网页，最后测试基于主机名的路由。
- en: Calling the product composite API through the edge server
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用产品组合 API
- en: 'Let''s perform the following steps to call the product composite API through
    the edge server as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤通过边缘服务器调用产品组合 API：
- en: 'To be able to see what is going on in the edge server, we can follow its log
    output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够看到边缘服务器中发生的情况，我们可以跟踪其日志输出：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, make the call to the product composite API through the edge server:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过边缘服务器调用产品组合 API：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Expect the normal type of response from the composite product API:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望从组合产品 API 获得正常类型的响应：
- en: '![](img/20e4c6a4-4714-4990-b85f-964445d04b6a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20e4c6a4-4714-4990-b85f-964445d04b6a.png)'
- en: 'We should be able to find the following interesting information in the log
    output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能在日志输出中找到以下有趣的信息：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the log output, we can see the pattern matching based on the predicate
    we specified in the configuration, and we can see what microservice instance the
    edge server selected from the available instances in the discovery server—in this
    case, `http://b8013440aea0:8080/product-composite/2`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志输出中，我们可以看到基于我们在配置中指定的谓词的模式匹配，我们还可以看到边缘服务器从发现服务器中可用的实例中选择了哪个微服务实例——在本例中，`http://b8013440aea0:8080/product-composite/2`。
- en: Calling Eureka through the edge server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用 Eureka
- en: 'To call Eureka through an edge server, perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过边缘服务器调用 Eureka，请执行以下步骤：
- en: 'First, call the Eureka API through the edge server to see what instances are
    currently registered in the discovery server:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过边缘服务器调用 Eureka API 以查看目前在发现服务器中注册的实例：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect a response along the lines of the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望得到如下类似的响应：
- en: '![](img/d8b40a4a-a897-408e-9131-8dd8b7f52041.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8b40a4a-a897-408e-9131-8dd8b7f52041.png)'
- en: Note that the edge server (named `gateway`) is also present in the response.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，边缘服务器（名为`gateway`）也包含在响应中。
- en: 'Next, open the Eureka web page in a web browser using the URL, `http://localhost:8080/eureka/web`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用URL`http://localhost:8080/eureka/web`在Web浏览器中打开Eureka网页：
- en: '![](img/c1f75e90-3c3a-42c1-aac1-432c7428230e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f75e90-3c3a-42c1-aac1-432c7428230e.png)'
- en: From the preceding screenshot, we can see the Eureka web page reporting the
    same available instances as the API response in the previous step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到Eureka网页报告的可用实例与上一步的API响应相同。
- en: Routing based on the host header
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主机头的路由
- en: Let's wrap up by testing the route setup based on the hostname used in the requests!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试基于请求中使用的主机名的路由设置来结束！
- en: 'Normally, the hostname in the request is set automatically in the `Host` header by
    the HTTP client. When testing the edge server locally, the hostname will be `localhost`—that
    is not so useful when testing hostname-based routing. But we can cheat by specifying
    another hostname in the `Host` header in the call to the API. Let''s see how this
    can be done:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，请求中的主机名会在HTTP客户端的`Host`头自动设置。当在本地测试边缘服务器时，主机名将是`localhost`——这对于测试基于主机名的路由来说并不很有用。但是我们可以通过在API调用中指定另一个主机名来欺骗，从而在`Host`头中实现。让我们看看如何做到这一点：
- en: 'To call for the `i.feel.lucky` hostname, use this code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用`i.feel.lucky`主机名，请使用此代码：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Expect the response 200 OK. For the hostname `im.a.teapot`, use the following
    command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期响应为200 OK。对于主机名`im.a.teapot`，使用以下命令：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Expect the response `418 I'm a teapot`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预期响应为`418 I'm a teapot`。
- en: 'Finally, if not specifying any `Host` header, use `localhost` as the `Host`
    header:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果不指定任何`Host`头，请将`localhost`作为`Host`头：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Expect the response `501 Not Implemented`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 预期响应为`501 Not Implemented`。
- en: 'We can also use `i.feel.lucky` and `im.a.teapot` as real hostnames in the requests
    if we add them to the local `/etc/hosts` file and specify that they should be
    translated into the same IP address as `localhost`, that is `127.0.0.1`. Run the
    following command to add a row to the `/etc/hosts` file with the required information:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以在请求中使用`i.feel.lucky`和`im.a.teapot`作为真实的主机名，如果我们添加它们到本地的`/etc/hosts`文件，并指定它们应该被翻译成与`localhost`相同的IP地址，即`127.0.0.1`。运行以下命令以在`/etc/hosts`文件中添加所需信息的行：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now perform the same routing based on the hostname, but without specifying
    the `Host` header. Try it out by running the following commands:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以根据主机名进行相同的路由，但不必指定`Host`头。尝试通过运行以下命令来实现：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Expect the same response as previously, that is, 200 OK and `418 I'm a teapot`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 预期与先前相同的响应，即200 OK和`418 I'm a teapot`。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统景观的系统：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, clean up the `/etc/hosts` file from the DNS name translation we added
    for the hostnames, `i.feel.lucky` and `im.a.teapot`. Edit the `/etc/hosts` file and
    remove the line we added: `127.0.0.1 i.feel.lucky im.a.teapot`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还应清理为`i.feel.lucky`和`im.a.teapot`主机名添加的DNS名称翻译的`/etc/hosts`文件。编辑`/etc/hosts`文件，删除我们添加的行：`127.0.0.1
    i.feel.lucky im.a.teapot`。
- en: These tests of the routing capabilities in the system landscape's edge server
    end the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试系统景观中边缘服务器的路由功能结束了本章。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how Spring Cloud Gateway can be used as an edge
    server to control what services are allowed to be called from the outside of the
    system landscape. Based on predicates, filters, and destination URIs, we can define
    routing rules in a very flexible way. If we want to, we can configure Spring Cloud
    Gateway to use a discovery service such as Netflix Eureka to look up the target
    microservice instances.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Spring Cloud Gateway如何可以作为边缘服务器使用，以控制哪些服务被允许从系统景观的外部调用。基于断言、过滤器和目标URI，我们可以非常灵活地定义路由规则。如果我们愿意，我们可以配置Spring
    Cloud Gateway以使用诸如Netflix Eureka之类的发现服务来查找目标微服务实例。
- en: One important question still unanswered is how we prevent unauthorized access
    to the APIs exposed by the edge server and how we can prevent third parties from
    intercepting the traffic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的问题尚未回答，那就是我们如何防止未经授权访问边缘服务器暴露的API，以及我们如何防止第三方拦截流量。
- en: In the next chapter, we will see how we can secure access to the edge server
    using standard security mechanisms such as HTTPS, OAuth, and OpenID Connect.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何使用诸如HTTPS、OAuth和OpenID Connect等标准安全机制来保护边缘服务器的访问。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the elements used to build a routing rule in Spring Cloud Gateway called?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成Spring Cloud Gateway中路由规则的元素是什么？
- en: What are they used for?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们有什么用途？
- en: How can we instruct Spring Cloud Gateway to locate microservice instances through
    a discovery service such as Netflix Eureka?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何指导 Spring Cloud Gateway 通过像 Netflix Eureka 这样的服务发现机制来定位微服务实例？
- en: In a Docker environment, how can we ensure that external HTTP requests to the
    Docker engine can only reach the edge server?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker 环境中，我们如何确保对外部 HTTP 请求只能到达 Docker 引擎的边缘服务器？
- en: How do we change the routing rules so that the edge server accepts calls to
    the `product-composite` service on the `http://$HOST:$PORT/api/product` URL instead
    of the currently used `http://$HOST:$PORT/product-composite`?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更改路由规则，使得边缘服务器接受对 `http://$HOST:$PORT/api/product` URL 的 `product-composite`
    服务的调用，而不是目前使用的 `http://$HOST:$PORT/product-composite`？
