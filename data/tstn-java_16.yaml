- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Deploying Java in Standalone Packages and Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在独立包和容器中部署 Java
- en: In this last chapter, we will look at different ways to package and distribute
    a Java application. We have already seen JAR files for desktop applications and
    WAR files for web applications, along with how to deploy them. While this approach
    can be sufficient for deployment, there are situations where this traditional
    approach can be improved upon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将探讨不同的打包和分发 Java 应用程序的方法。我们已经看到了桌面应用程序的 JAR 文件和网络应用程序的 WAR 文件，以及如何部署它们。虽然这种方法对于部署来说是足够的，但在某些情况下，这种传统方法可以改进。
- en: Java is big. There are numerous libraries in the Java SE distribution, although
    it is likely that your application only needs some of them. The same can be said
    for third-party or external libraries. Modern packaging using the Java module
    approach allows you to produce JAR or WAR files that only contain parts of a library
    that you will use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 很大。Java SE 分发中包含许多库，尽管你的应用程序可能只需要其中的一些。第三方或外部库也是如此。现代使用 Java 模块方法的打包允许你生成只包含你将使用的库部分的
    JAR 或 WAR 文件。
- en: In the case of web applications, this type of packaging can reduce the size
    of a WAR file to contain only the required modules from a required external library,
    rather than the entire library. In the case of desktop applications, it is required
    that the Java language must already be installed on a computer. The Java runtime
    is now modularized. This allows you to create executable applications that do
    not require an installed version of Java to run but, rather, include it as part
    of the packaged installer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序的情况下，这种打包方式可以将 WAR 文件的大小减少到仅包含所需外部库中的所需模块，而不是整个库。在桌面应用程序的情况下，要求计算机上已经安装了
    Java 语言。Java 运行时现在已经模块化。这允许你创建不需要安装 Java 版本即可运行的可执行应用程序，而是将其作为打包安装程序的一部分。
- en: Finally, we will look at the Docker container system. Imagine a team of developers,
    each with different **operating systems** (**OSes**), working on an application.
    While Java is *write once, run anywhere*, it is sometimes advantageous to have
    every developer working in an identical environment. Docker containers help meet
    this need. Furthermore, you can deploy these containers to a cloud. While we will
    not look at cloud deployment, understanding how containers work prepares you for
    working within the cloud.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨 Docker 容器系统。想象一个由不同 **操作系统**（**OSes**）的开发商组成的团队，他们正在开发一个应用程序。虽然 Java
    是 *一次编写，到处运行*，但有时让每个开发商在相同的环境中工作是有利的。Docker 容器有助于满足这一需求。此外，你可以将这些容器部署到云端。虽然我们不会探讨云部署，但了解容器的工作原理将使你为在云中工作做好准备。
- en: 'We will cover the following in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下内容：
- en: Exploring what modular Java is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模块化 Java 是什么
- en: Creating a custom JRE with `jlink`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `jlink` 创建自定义 JRE
- en: Packaging with an installer using `jpackage`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `jpackage` 进行打包安装
- en: Using the Docker container system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器系统
- en: Working with Docker images
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Docker 镜像一起工作
- en: Creating a Docker image
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: Publishing an image
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布镜像
- en: We will use a modified version of `BankSwing`, originally from [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254),
    *Desktop Graphical User Interface Coding with Swing and JavaFX*, and now renamed
    `BankSwingJUL` in this chapter, to explore modules and packages. To look at Docker,
    we will use `JSF_FinancialCalculator`, unchanged from the previous chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 [*第 13 章*](B19088_13.xhtml#_idTextAnchor254)，*使用 Swing 和 JavaFX 进行桌面图形用户界面编码*，最初名为
    `BankSwing`，在本章中重命名为 `BankSwingJUL` 的修改版本来探索模块和包。为了查看 Docker，我们将使用上一章未更改的 `JSF_FinancialCalculator`。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the following for this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下内容来完成本章：
- en: Java 17.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17。
- en: A text editor.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器。
- en: Maven 3.8.6 or a newer version.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.8.6 或更高版本。
- en: 'For `jpackage`:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于 `jpackage`:'
- en: '`rpm-build` package'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpm-build` 软件包'
- en: '`fakeroot` package'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fakeroot` 软件包'
- en: '**macOS**: Xcode command-line tools'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**: Xcode 命令行工具'
- en: Docker Desktop [(https://www.docker.com](https://www.docker.com/)/). To use
    Docker, you will need to create an account. The free Personal account is sufficient.
    Once you have an account, you can download Docker Desktop. There is a version
    for every OS.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop [(https://www.docker.com](https://www.docker.com/)/)。要使用 Docker，你需要创建一个账户。免费的个人账户就足够了。一旦你有了账户，你就可以下载
    Docker Desktop。每个操作系统都有一个版本。
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16)找到。
- en: Exploring what modular Java is
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模块化Java是什么
- en: Up to this point, we saw code in classes that consists of class fields and methods.
    Then, we grouped these classes into packages and, finally, as a JAR or WAR file.
    Modular Java introduces a new grouping called **modules**. A module is a JAR file
    but with a module descriptor. There is also an automatic module that has a module
    name in its manifest file. This feature of Java is called the **Java Platform
    Module** **System** (**JPMS**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了由类字段和方法组成的类中的代码。然后，我们将这些类分组到包中，最后作为一个JAR或WAR文件。模块化Java引入了一个新的分组，称为**模块**。模块是一个JAR文件，但包含模块描述符。还有一个自动模块，其清单文件中有模块名称。这个Java特性被称为**Java平台模块系统**（**JPMS**）。
- en: Up until now, we used Maven to build our applications. Maven is a build tool
    that downloads any libraries we need and ensures that our code will compile successfully.
    What it does not do is determine whether all the required external libraries,
    such as Java itself, are present. Its primary job ends when the code successfully
    compiles. The JPMS, on the other hand, focuses on the libraries required to successfully
    run a program. Unlike Maven, JPMS checks that libraries coded as modules are present
    or will be present when the code runs. This leads to the question, what is a module?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Maven构建我们的应用程序。Maven是一个构建工具，它会下载我们需要的任何库，并确保我们的代码可以成功编译。它不做的是确定所有必需的外部库，例如Java本身，是否都存在。它的主要工作在代码成功编译后结束。另一方面，JPMS专注于成功运行程序所需的库。与Maven不同，JPMS检查作为模块编写的库是否存在或将在代码运行时存在。这引出了一个问题，什么是模块？
- en: A module is a JAR file. There are minor differences between a regular JAR file
    and a module JAR file. At a minimum, a module file must have a file named `module-info.java`
    in the `src/main/java` folder. One purpose of this file is to list the required
    modules. There may not be any required modules, but the presence of this file
    denotes that this project can be a module. Not every library coded in Java has
    been recoded to be a module, but many new libraries are coded this way. A module
    file can be used as an ordinary JAR file or as a module when using JPMS tools.
    You do not need two versions of a library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个JAR文件。普通JAR文件和模块JAR文件之间有一些细微的差别。至少，模块文件必须在`src/main/java`文件夹中包含一个名为`module-info.java`的文件。这个文件的一个目的是列出所需的模块。可能没有所需的模块，但这个文件的存在表示该项目可以是一个模块。并非所有用Java编写的库都已被重新编码为模块，但许多新的库都是这样编写的。模块文件可以用作普通JAR文件，也可以在使用JPMS工具时用作模块。你不需要两个版本的库。
- en: At one time, there were two versions of Java available to users. There is the
    JDK that contains the JVM and all the required developer tools, such as the Java
    compiler. The second version was the **Java Runtime Edition** (**JRE**). As its
    name implies, the JRE contains all the necessary libraries to run almost any Java
    program. The JRE was significantly smaller, coming in at around 90 MB, while the
    full JDK is around 300 MB. With the introduction of the JPMS, the JRE was no longer
    available as a download. Times change, and some Java distributions now contain
    a JRE again.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，用户有Java的两个版本可用。有一个包含JVM和所有必需的开发工具，如Java编译器的JDK。第二个版本是**Java运行时版**（**JRE**）。正如其名称所暗示的，JRE包含运行几乎任何Java程序所需的所有库。JRE的大小显著减小，大约为90
    MB，而完整的JDK大约为300 MB。随着JPMS的引入，JRE不再作为下载提供。时代在变化，现在一些Java发行版又包含了JRE。
- en: 'With the JRE significantly smaller than the JDK, what can modules do for us?
    The reason is related to why the JRE was dropped from Java distributions. With
    the JPMS, you can construct your own custom JRE, including only those modules
    you need. So, what are the modules in the Java language? In a terminal/console
    window, enter the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JRE比JDK小得多，模块能为我们做什么呢？原因与为什么JRE从Java发行版中删除有关。使用JPMS，你可以构建自己的自定义JRE，只包含你需要的模块。那么，Java语言中的模块是什么呢？在终端/控制台窗口中，输入以下内容：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will now get a list of every module. On my Windows 11 system, there are
    71 modules listed – 22 that begin with `java` and 49 that begin with `jdk`. To
    build a custom JRE, you need to know which modules your program uses. Retrieve
    from this chapter’s GitHub the `BankSwingJUL` project. The only difference from
    the [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254) version is that `JUL` replaces
    `log4j2`. I have done this to reduce the number of modules required to just those
    in the Java distribution. Build the project, and you should find in the `target`
    folder a JAR file named `BankSwingJUL-0.1-SNAPSHOT.jar`. Open a terminal/console
    window in the `target` folder and enter the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将获得每个模块的列表。在我的Windows 11系统上，有71个模块被列出——22个以`java`开头，49个以`jdk`开头。为了构建自定义JRE，你需要知道你的程序使用了哪些模块。从本章的GitHub获取`BankSwingJUL`项目。与[*第13章*](B19088_13.xhtml#_idTextAnchor254)版本的不同之处在于`JUL`替换了`log4j2`。我这样做是为了将所需的模块数量减少到Java发行版中的那些。构建项目，你应该在`target`文件夹中找到一个名为`BankSwingJUL-0.1-SNAPSHOT.jar`的JAR文件。在`target`文件夹中打开一个终端/控制台窗口，并输入以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will begin with a summary of the Java modules you will need:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将开始于你需要用到的Java模块的摘要：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The remainder of the output looks at every class in the project, showing you
    what Java classes you are using and what module they belong to. The `java.base`
    module is the home to the core set of classes. The `java.desktop` module is the
    home of Swing, while `java.logging` module is the home of JUL. Now, it’s time
    to create our custom JRE.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的剩余部分将查看项目中的每个类，显示你正在使用的Java类以及它们所属的模块。`java.base`模块是核心类集的家园。`java.desktop`模块是Swing的家园，而`java.logging`模块是JUL的家园。现在，是时候创建我们的自定义JRE了。
- en: Creating a custom JRE with jlink
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jlink创建自定义JRE
- en: 'We will use the `jlink` tool that is part of the Java JDK to create our custom
    JRE. We will begin by creating a JRE that contains all the required modules:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Java JDK的一部分`jlink`工具来创建我们的自定义JRE。我们将首先创建一个包含所有必需模块的JRE：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is one line. In Linux, you can enter a multiline command using the backslash
    (`\`), while in Windows, you use the caret (`^`). The output of this command will
    be a folder named `jdk-17.0.2-jre` that contains a JRE of only 76 MB. This is
    smaller than the original JRE, but we do not want all the Java modules; we just
    need three. Here is our new command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行。在Linux中，你可以使用反斜杠（`\`）输入多行命令，而在Windows中，你使用撇号（`^`）。此命令的输出将是一个名为`jdk-17.0.2-jre`的文件夹，其中包含仅76
    MB的JRE。这比原始JRE小，但我们不需要所有Java模块；我们只需要三个。以下是我们的新命令：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will now have a new JRE in the `jdk-17.0.2-minimaljre` folder that is only
    41 MB. Now, we need to use our custom JRE with our application. To test whether
    our JRE is working, you can execute the application by first opening a terminal/console
    window in the `bin` folder of the custom JRE you have created. Issue the following
    command to run your code. Take note that the paths are for Windows, so they must
    be adjusted for Linux or Mac:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`jdk-17.0.2-minimaljre`文件夹中有一个新的JRE，大小仅为41 MB。现在，我们需要使用我们的自定义JRE与我们的应用程序一起使用。为了测试我们的JRE是否工作，你可以在自定义JRE的`bin`文件夹中打开一个终端/控制台窗口，然后执行以下命令来运行你的代码。请注意，路径是为Windows准备的，因此它们必须根据Linux或Mac进行调整：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a single-line command. If all is well, your `BankSwingJUL` app will
    run. Now, it’s time to wrap up the application into a single executable file that
    contains both our application and the JRE. This will allow us to distribute our
    applications without requiring the recipient of our program to first install Java.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单行命令。如果一切顺利，你的`BankSwingJUL`应用将运行。现在，是时候将应用程序打包成一个包含我们的应用程序和JRE的单个可执行文件了。这将使我们能够在不需要接收者首先安装Java的情况下分发我们的应用程序。
- en: Packaging with an installer using jpackage
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jpackage进行打包
- en: With our custom JRE created, we are now ready to create a custom installable
    package. You can create these for Windows, Linux, or Mac. You must use the OS
    that is the target of your package. In addition, there are additional steps for
    each OS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义JRE创建完成后，我们现在可以创建自定义的可安装包了。你可以为Windows、Linux或Mac创建这些包。你必须使用你的包的目标操作系统。此外，每个操作系统都有额外的步骤。
- en: Windows requires you to install the WiX toolset. You can find this at [https://wixtoolset.org/](https://wixtoolset.org/).
    Download the latest version and install it. When you run `jpackage`, it will produce
    an EXE file. You can distribute this file, and when run, it will install all that
    is necessary to run the program in the `C:\Program Files` directory. An executable
    EXE file will be in the folder, and this is how you will run your program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Windows需要您安装WiX工具集。您可以在[https://wixtoolset.org/](https://wixtoolset.org/)找到它。下载最新版本并安装。当您运行`jpackage`时，它将生成一个EXE文件。您可以分发此文件，当运行时，它将在`C:\Program
    Files`目录中安装运行程序所需的所有内容。可执行EXE文件将位于文件夹中，这就是您运行程序的方式。
- en: Linux users, depending on the version they are using, will need the `rpm-build`
    or `fakeroot` package. When you run `jpackage`, it will produce a DEB file for
    Debian Linux or an RPM file for other distros. You can distribute this file, and
    when run, it will install all that is necessary to run the program in the `/opt/application-name`
    directory. An executable file will be in the folder, and this is how you will
    run your program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户，根据他们使用的版本，可能需要`rpm-build`或`fakeroot`包。当您运行`jpackage`时，它将为Debian Linux生成一个DEB文件，或其他发行版生成一个RPM文件。您可以分发此文件，当运行时，它将在`/opt/application-name`目录中安装运行程序所需的所有内容。可执行文件将位于文件夹中，这就是您运行程序的方式。
- en: Mac users require the Xcode command-line tools. When you run `jpackage`, it
    will produce a DMG file. You can distribute this file, and when run, it will install
    all that is necessary to run the program in the `/Applications/application-name`
    directory. An executable file will be in the folder, and this is how you will
    run your program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mac用户需要Xcode命令行工具。当您运行`jpackage`时，它将生成一个DMG文件。您可以分发此文件，当运行时，它将在`/Applications/application-name`目录中安装运行程序所需的所有内容。可执行文件将位于文件夹中，这就是您运行程序的方式。
- en: In all three cases, it is not necessary to have Java installed. Even if you
    do, you will be using the custom JRE.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种情况下，没有必要安装Java。即使安装了，您也将使用自定义的JRE。
- en: 'To create an installer package with `jpackage`, you simply enter the following
    on the command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`jpackage`创建安装程序包，您只需在命令行中输入以下内容：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a single-line command. Here is a rundown of the parameters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单行命令。以下是参数的概述：
- en: '`--name`: The name of the executable file with `-1.0` added. Use `–app-version`
    followed by a version designation to override this.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：添加`-1.0`的可执行文件名称。使用`--app-version`后跟版本标识来覆盖此名称。'
- en: '`--input`: The location of the JAR file you are packaging.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--input`：您要打包的JAR文件的存放位置。'
- en: '`--main-jar`: The name of the JAR file that contains the class with the `main`
    method. If you do not have a `MANIFEST.MF` file in your JAR file that lists the
    class with a `main` method, you can use `–main-class`, followed by the name of
    the class that contains the `main` method.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--main-jar`：包含具有`main`方法的类的JAR文件的名称。如果您在JAR文件中没有包含具有`main`方法类的`MANIFEST.MF`文件，您可以使用`--main-class`后跟包含`main`方法的类的名称。'
- en: '`--runtime-image`: This is the path and name of the JRE folder you created
    with `jlink`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--runtime-image`：这是您使用`jlink`创建的JRE文件夹的路径和名称。'
- en: '`--dest`: By default, the packaged application will be found in whatever folder
    you issued the `jpackage` command. You can choose the folder you want with this
    parameter.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dest`：默认情况下，打包的应用程序将位于您发出`jpackage`命令的任何文件夹中。您可以使用此参数选择您想要的文件夹。'
- en: Upon the successful conclusion of this command, you will have an executable
    package that will install your program, with an executable file to run it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令成功完成后，您将拥有一个可执行的程序包，该程序包将安装您的程序，并包含一个可执行文件来运行它。
- en: Web applications depend on an application server and not the JRE to run. For
    this reason, we cannot use `jpackage`. This is where our next choice for packaging
    comes in, the Docker container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序依赖于应用程序服务器而不是JRE来运行。因此，我们不能使用`jpackage`。这就是我们的下一个打包选择，Docker容器。
- en: Using the Docker container system
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器系统
- en: Docker is a platform-as-a-service system that allows you to construct an image
    of a running application that can run in a virtualized Linux container. These
    images can be run on any computer that supports Docker containers. This includes
    Windows and Linux distributions. This image can contain everything necessary to
    run the program. In this section, we will create an image with a Java application
    server, a Java JDK, and our `JSF_FinancialCalculator` web application and deploy
    it in a container. Why this is significant is that most cloud providers, such
    as AWS, support the deployment of cloud applications in Docker containers. We
    will not be discussing cloud deployment, as the various cloud providers work differently.
    What they share is the use of Docker.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个平台即服务系统，允许你构建一个运行中的应用程序的镜像，该镜像可以在虚拟化的Linux容器中运行。这些镜像可以在支持Docker容器的任何计算机上运行。这包括Windows和Linux发行版。这个镜像可以包含运行程序所需的一切。在本节中，我们将创建一个包含Java应用服务器、Java
    JDK和我们的`JSF_FinancialCalculator` Web应用程序的镜像，并在容器中部署它。这之所以重要，是因为大多数云提供商，如AWS，都支持在Docker容器中部署云应用程序。我们不会讨论云部署，因为不同的云提供商工作方式不同。他们共同点是使用Docker。
- en: The first step is to install the Docker system. The easiest way is to download
    and install the Docker Desktop system from [https://www.docker.com/](https://www.docker.com/).
    There is a version each for Windows, Mac, and Linux, and they contain a GUI interface
    as well as command-line tools. On a Windows 10 or 11 system that supports WSL2,
    the command-line tools are available in both, a Windows terminal and a WSL2 Linux
    Terminal. This means that, except for how paths to files are described, all commands
    work the same on all OSes. Now, take a moment and install Docker.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装Docker系统。最简单的方法是从[https://www.docker.com/](https://www.docker.com/)下载并安装Docker
    Desktop系统。它为Windows、Mac和Linux都提供了版本，它们包含GUI界面以及命令行工具。在支持WSL2的Windows 10或11系统上，命令行工具在Windows终端和WSL2
    Linux终端中都可用。这意味着，除了文件路径的描述方式不同外，所有命令在所有操作系统上都是相同的。现在，花点时间安装Docker。
- en: Working with Docker images
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Docker镜像一起工作
- en: While we could build an image from scratch, there is another way. Many organizations
    that create software that is destined for the cloud make available pre-built images.
    To these images, we can add our application. In our case, we want a pre-built
    image with Java 17 and an application server. We will use an image from Payara.
    This company provides a server based on GlassFish, with enhancements in both an
    open source community version and a commercial paid version.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以从头开始构建镜像，但还有另一种方法。许多为云而创建软件的组织会提供预构建的镜像。我们可以将这些镜像添加到我们的应用程序中。在我们的例子中，我们想要一个包含Java
    17和应用服务器的预构建镜像。我们将使用来自Payara的镜像。这家公司提供基于GlassFish的服务器，在开源社区版本和商业付费版本中都进行了增强。
- en: Images on Docker Hub may have been created for malicious reasons. While Docker
    provides a service to scan for vulnerabilities, you should also scan any executable
    files in an image for potentially malicious behavior. The Docker plan you have
    signed up for determines how many images you can pull from or push to the Hub.
    With the free Personal subscription, you may have an unlimited number of public
    repositories you can push, but you are restricted to no more than 400 image pulls
    a day. The commercial subscriptions increase the number of pulls from the repository
    and can carry out vulnerability scans on your image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub上的镜像可能是出于恶意目的而创建的。虽然Docker提供了一种扫描漏洞的服务，但你仍应扫描镜像中的任何可执行文件，以检查潜在的恶意行为。你注册的Docker计划决定了你可以从或推送到Hub的镜像数量。使用免费的个人订阅，你可能可以推送无限数量的公共仓库，但每天的限制为400次镜像拉取。商业订阅增加了从仓库拉取的次数，并可以对您的镜像执行漏洞扫描。
- en: Start Docker Desktop. It comes with an image and container that contains a basic
    web server that has the documentation pages for Docker. We will do most of our
    setup on the command line, while the desktop GUI is useful for seeing what the
    state of Docker images and containers are.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Docker Desktop。它包含一个包含基本Web服务器的镜像和容器，该服务器具有Docker的文档页面。我们将大部分设置工作在命令行上完成，而桌面GUI对于查看Docker镜像和容器的状态非常有用。
- en: 'The first step is to download the image we will modify by adding the `JSF_FinancialCalculator`
    application. We will use this program unchanged from the previous chapter. Here
    is the command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是下载我们将要修改的镜像，通过添加`JSF_FinancialCalculator`应用程序。我们将使用这个程序，与上一章保持不变。以下是命令：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you visit [https://hub.docker.com/r/payara/server-full/tags](https://hub.docker.com/r/payara/server-full/tags),
    you can see all the versions of the Payara server available. As you can see from
    the previous command, we are pulling the `server-full:6.2023.2-jdk17` image that
    contains both the server and Java 17\. In Docker, a successful command returns
    a long stream of digits.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 [https://hub.docker.com/r/payara/server-full/tags](https://hub.docker.com/r/payara/server-full/tags)，你可以看到所有可用的
    Payara 服务器版本。正如你从之前的命令中看到的，我们正在拉取包含服务器和 Java 17 的 `server-full:6.2023.2-jdk17`
    镜像。在 Docker 中，成功的命令返回一串长数字。
- en: 'Now, we need to run this image in a container. While you can run multiple containers,
    network applications that use TCP ports can result in conflicts. For this reason,
    I recommend stopping any containers that are currently running. Using the Docker
    Desktop, select the container list from the menu and look for any containers listed
    as **Running**, and then stop them by clicking on the square button in the **Actions**
    column. You can also stop a container by entering the following at the command
    line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在一个容器中运行这个镜像。虽然你可以运行多个容器，但使用 TCP 端口的网络应用程序可能会导致冲突。因此，我建议停止任何正在运行的容器。使用
    Docker Desktop，从菜单中选择容器列表，查找任何列为 **运行中** 的容器，然后通过点击 **操作** 列中的方块按钮来停止它们。你还可以通过在命令行中输入以下内容来停止容器：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `my_container` is replaced by the name of a running container or image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`my_container` 被替换为正在运行的容器或镜像的名称。
- en: 'We now want to wrap this image in a container and run the image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在希望将这个镜像包装在一个容器中并运行这个镜像：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a single-line command. The `--name` switch allows you to assign a name
    to the container. If you leave this switch out, Docker will assign a random name.
    The `-p` switch maps a port in the container to a port of the computer. In this
    example, we are mapping to the same port. The name of the image is the same as
    the name of the image we pulled down. Assuming that there were no errors, you
    can now test the container. Go to your browser and first visit the Payara home
    page by entering `http://localhost:8080`. Next, visit the admin console page at
    `https://localhost:4848`. You may get a warning from your browser, as the TLS
    certificate is self-signed. Ignore the warning and you should get to the sign-in
    page. The username and password are both `admin`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单行命令。`--name` 开关允许你为容器分配一个名称。如果你省略了这个开关，Docker 将分配一个随机名称。`-p` 开关将容器中的端口映射到计算机的端口。在这个例子中，我们将它们映射到相同的端口。镜像的名称与我们所拉取的镜像名称相同。假设没有错误，你现在可以测试容器了。打开你的浏览器，首先通过输入
    `http://localhost:8080` 访问 Payara 主页。接下来，访问管理控制台页面 `https://localhost:4848`。你的浏览器可能会发出警告，因为
    TLS 证书是自签名的。忽略警告，你应该会到达登录页面。用户名和密码都是 `admin`。
- en: Under `JSF_FinancialCalculator` example in the previous chapter, which you can
    find in the project’s `target` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的 `JSF_FinancialCalculator` 示例中，你可以在项目的 `target` 文件夹中找到它。
- en: You can now verify that the application has been properly deployed by entering
    in your browser `http://localhost:8080/JSF_FinancialCalculator`. The name of the
    project must match the name of the WAR file. If all works and the calculator opens
    in your browser, you can now create your own container based on the `payara/server-full:6.2023.2-jdk17`
    image, which will contain the calculator app installed on the server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过在浏览器中输入 `http://localhost:8080/JSF_FinancialCalculator` 来验证应用程序是否已正确部署。项目名称必须与
    WAR 文件名称匹配。如果一切正常，计算器在你的浏览器中打开，你现在可以基于 `payara/server-full:6.2023.2-jdk17` 图像创建自己的容器，该容器将包含服务器上安装的计算器应用程序。
- en: Creating a Docker image
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Docker 图像
- en: 'Now, we are ready to create our own image. First, we need to stop the container
    we just used:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建自己的镜像。首先，我们需要停止我们刚刚使用的容器：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In a terminal/console, enter the following command to create your new container,
    which will contain the Payara image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端/控制台中，输入以下命令来创建你的新容器，该容器将包含 Payara 图像：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The name `transition` is arbitrary and can be anything you want. You now have
    a new container based on the Payara image. We want to modify this container to
    include the calculator application. The first step is to run this new container:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `transition` 是任意的，可以是任何你想要的内容。你现在有一个基于 Payara 图像的新容器。我们希望修改这个容器以包含计算器应用程序。第一步是运行这个新容器：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most common error that occurs here is if another container is listening
    to the same ports. Ensure that any containers or images with Payara are not running.
    The Docker Desktop app can show you which containers or images are running.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里最常发生的错误是如果另一个容器正在监听相同的端口。确保任何运行Payara的容器或镜像都没有运行。Docker Desktop应用程序可以显示哪些容器或镜像正在运行。
- en: Just as we did when we tested the Payara image, use your browser to open the
    admin console of Payara. Now, deploy the `JSF_FinancialCalculator` WAR file to
    the server. Verify that it is running successfully by visiting the application’s
    web page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在测试Payara镜像时做的那样，使用您的浏览器打开Payara的管理控制台。现在，将`JSF_FinancialCalculator` WAR文件部署到服务器上。通过访问应用程序的网页来验证它是否成功运行。
- en: 'Now, make the change to the image in the container, the addition of the web
    app, permanent by entering the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过输入以下内容，将容器中的镜像更改，将Web应用程序的添加永久化：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is one last step. Enter the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步。输入以下内容：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will see an entry with `<none>` for both `REPOSITORY` and `TAG`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`REPOSITORY`和`TAG`都显示为`<none>`的条目：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To resolve this, and as the final step in creating an image, assign a tag name
    and image ID by entering the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并在创建镜像的最后一步，通过输入以下内容来分配一个标签名称和镜像ID：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take note that the hexadecimal number that must be used can be found in the
    table from the previous `docker images` command. When you run `docker images`
    after `docker tag`, the table will show the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须使用的十六进制数字可以在之前的`docker images`命令的表中找到。在运行`docker tag`之后运行`docker images`，表将显示以下内容：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You now have a configured image in your local repository. For anyone to use
    your image, you must publish it on the Docker Hub website.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经在本地仓库中配置了一个镜像。为了任何人都能使用您的镜像，您必须在Docker Hub网站上发布它。
- en: Publishing an image
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布一个镜像
- en: As already noted, for security reasons, any image you use as the basis of a
    new image must be scanned for vulnerabilities, especially any executable code
    in the image. The free Personal tier allows you to have an unlimited number of
    public images. The paid tiers support private images. The first step in publishing
    is to create a repository on the Hub. To do this, open your browser and go to
    [https://hub.docker.com/](https://hub.docker.com/). Sign into your account if
    needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，出于安全原因，您用作新镜像基础的任何镜像都必须进行漏洞扫描，特别是镜像中的任何可执行代码。免费的个人版允许您拥有无限数量的公共镜像。付费层支持私有镜像。发布的第一步是在Hub上创建一个仓库。为此，打开您的浏览器并转到[https://hub.docker.com/](https://hub.docker.com/)。如果需要，请登录您的账户。
- en: Next, select **Repositories** from the choices at the top of the web page. You
    will now see any repositories you may have already created. Click on **Create
    repository**. On this page, you must fill in the form, entering a name for the
    container along with an optional description. It also shows your Docker username.
    Ensure that **Public** is the choice for the repo type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从网页顶部的选项中选择**仓库**。您现在将看到您可能已经创建的任何仓库。点击**创建仓库**。在此页面上，您必须填写表格，输入容器的名称以及可选的描述。它还显示了您的Docker用户名。确保**公共**是仓库类型的选项。
- en: 'Now, you can push your image to the Hub. There are three steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将您的镜像推送到Hub。这里有三个步骤：
- en: 'Log in to Docker Hub:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Docker Hub：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Replace `my_username` with your Docker username. You will now be asked for your
    password. You will receive confirmation of a successful login.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将`my_username`替换为您的Docker用户名。您现在将被要求输入您的密码。您将收到成功登录的确认。
- en: 'Next, you need to change the tag for your image, `transition-image`, to match
    the name of the repository you created, `omniprof/transitioning_to_java`. The
    name consists of your username and the name of the repository:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要更改您的镜像标签`transition-image`，以匹配您创建的仓库名称`omniprof/transitioning_to_java`。该名称由您的用户名和仓库名称组成：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now comes the final step, pushing your image into the Hub:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是最后一步，将您的镜像推送到Hub：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To determine whether you were successful, visit Docker Hub and select `omniprof/transitioning_to_java`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定您是否成功，请访问Docker Hub并选择`omniprof/transitioning_to_java`。
- en: You now have a Docker image that can be shared with your team or clients.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个可以与您的团队或客户共享的Docker镜像。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at what modular Java means. We took advantage of
    the fact that Java itself has been modularized. This allows you to construct a
    JRE with `jlink` that is significantly smaller than the JDK. You can even make
    it smaller by only including the modules your code depends on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了模块化Java的含义。我们利用了Java自身已经模块化的这一事实。这使得你可以使用`jlink`构建一个比JDK小得多的JRE。你甚至可以通过只包含你的代码所依赖的模块来进一步减小其大小。
- en: We then looked at two ways to distribute your code. The first employed `jpackage`
    to create an installer for your application. The installer can include your custom
    JRE and will install your program, along with an executable file to run the application.
    This is usually the best way to distribute desktop applications.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后探讨了两种分发代码的方法。第一种方法是使用`jpackage`为你的应用程序创建一个安装程序。安装程序可以包含你定制的JRE，并将安装你的程序，以及一个可执行文件来运行应用程序。这通常是分发桌面应用程序的最佳方式。
- en: The second distribution method uses the Docker container system. Docker allows
    us to construct and publish an image that includes not only our code and a JDK
    but also any other programs required. In our example, the extra program was an
    application server to which the finance application was installed. The images
    we construct are published to a repository, such as Docker Hub. Anyone running
    Docker on any OS can now pull our image and have it run in a Docker container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种分发方法使用Docker容器系统。Docker允许我们构建和发布一个包含不仅我们的代码和JDK，还包括任何其他所需程序的镜像。在我们的例子中，额外的程序是一个安装了财务应用程序的应用服务器。我们构建的镜像被发布到仓库中，例如Docker
    Hub。现在，任何在任意操作系统上运行Docker的人都可以拉取我们的镜像，并在Docker容器中运行它。
- en: This also leads us to the end of this book. My goal was to provide a reference
    to experienced developers in need of learning about and understanding Java. There
    is still much to learn, but my hope is that this book has put you on the right
    path.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这也带我们来到了本书的结尾。我的目标是提供一个参考，帮助那些需要学习和理解Java的资深开发者。还有很多东西要学习，但我希望这本书能让你走上正确的道路。
- en: Further reading
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Multi-Module Maven Application with Java* *Modules*: [https://www.baeldung.com/maven-multi-module-project-java-jpms](https://www.baeldung.com/maven-multi-module-project-java-jpms)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Java模块的多模块Maven应用程序* 模块：[https://www.baeldung.com/maven-multi-module-project-java-jpms](https://www.baeldung.com/maven-multi-module-project-java-jpms)'
- en: '*Java Platform, Standard Edition – Packaging Tool User’s* *Guide*: [https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf](https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java平台，标准版 – 打包工具用户指南*：[https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf](https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf)'
- en: '*Docker* *docs*: [https://docs.docker.com/](https://docs.docker.com/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker* 文档：[https://docs.docker.com/](https://docs.docker.com/)'
