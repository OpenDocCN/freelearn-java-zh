- en: '*Chapter 9*: JVM Structure and Garbage Collection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第九章*：JVM结构和垃圾回收'
- en: This chapter will provide you with an overview of the structure and behavior
    of a **Java virtual machine** (**JVM**), which are more complex than you may expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供一个关于**Java虚拟机**（**JVM**）结构和行为的概述，这些结构和行为可能比你想象的要复杂。
- en: A JVM executes instructions according to the coded logic. It also finds and
    loads the `.class` files that are requested by the application into memory, verifies
    them, interprets the bytecode (that is, it translates them into platform-specific
    binary code), and passes the resulting binary code to the central processor (or
    processors) for execution. It uses several service threads in addition to the
    application threads. One of the service threads, called **garbage collection**
    (**GC**), performs the important step of releasing the memory from unused objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JVM根据编码逻辑执行指令。它还会找到并加载应用程序请求的`.class`文件到内存中，验证它们，解释字节码（即，将它们转换为特定平台的二进制代码），并将生成的二进制代码传递给中央处理器（或多个处理器）以执行。除了应用程序线程外，它还使用几个服务线程。其中一个服务线程被称为**垃圾回收**（**GC**），执行释放未使用对象内存的重要步骤。
- en: By completing this chapter, you will understand what constitutes Java application
    execution, the Java processes inside the JVM and GC, and how the JVM works in
    general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，你将了解构成Java应用程序执行的内容，JVM内部的Java进程和GC，以及JVM的一般工作原理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Java application execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java应用程序执行
- en: Java processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java进程
- en: JVM’s structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM的结构
- en: Garbage collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To execute the code examples provided in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章提供的代码示例，你需要以下内容：
- en: A computer with Microsoft Windows, Apple macOS, or the Linux operating system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备Microsoft Windows、Apple macOS或Linux操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE版本17或更高
- en: An IDE or code editor of your choice
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的IDE或代码编辑器
- en: The instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files that contain the code examples for this chapter are available
    on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch09_jvm` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)“Java 17入门”中提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的代码示例文件可在GitHub的[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)仓库中的`examples/src/main/java/com/packt/learnjava/ch09_jvm`文件夹找到。
- en: Java application execution
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java应用程序执行
- en: 'Before we learn how the JVM works, let’s review how to run an application,
    bearing in mind that the following statements are used as synonyms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习JVM的工作原理之前，让我们回顾一下如何运行应用程序，同时记住以下语句是同义词：
- en: Run/execute/start the main class.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动主类。
- en: Run/execute/start the main method.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动`main()`方法。
- en: Run/execute/start/launch an application.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动/启动应用程序。
- en: Run/execute/start/launch the JVM or a Java process.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动/启动JVM或Java进程。
- en: There are also several ways to do this. In [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*, we showed you how to run the `main(String[])`
    method using IntelliJ IDEA. In this chapter, we will just repeat some of what
    has been said already and add other variations that might be helpful for you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种方法可以做到这一点。在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)“Java 17入门”中，我们展示了如何使用IntelliJ
    IDEA运行`main(String[])`方法。在本章中，我们将重复一些已经说过的话，并添加一些可能对你有帮助的变体。
- en: Using an IDE
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IDE
- en: 'Any IDE allows you to run the `main()` method. In IntelliJ IDEA, it can be
    done in three ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何IDE都允许你运行`main()`方法。在IntelliJ IDEA中，可以通过以下三种方式实现：
- en: 'Click the green triangle next to the `main()` method''s name:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`main()`方法名称旁边的绿色三角形：
- en: '![](img/B18388_Figure_9.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.1.jpg)'
- en: Once you have executed the `main()` method using the green triangle at least
    once, the name of the class will be added to the drop-down menu (on the top line,
    to the left of the green triangle):![](img/B18388_Figure_9.2.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你至少使用绿色三角形执行了`main()`方法一次，类的名称将被添加到下拉菜单中（在顶部行，绿色三角形的左侧）：![图片](img/B18388_Figure_9.2.jpg)
- en: 'Open the **Run** menu and select the name of the class. There are several options
    you can select:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**运行**菜单并选择类的名称。你可以选择以下几种选项：
- en: '![](img/B18388_Figure_9.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.3.jpg)'
- en: 'In the previous screenshot, you can also see the `main()` method at the start,
    plus some other options:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您还可以看到开始的 `main()` 方法，以及一些其他选项：
- en: '![](img/B18388_Figure_9.4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.4.jpg)'
- en: 'The **Program arguments** field allows for setting a parameter in the java
    command. For example, let’s set one two three in this field:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序参数** 字段允许在 java 命令中设置一个参数。例如，让我们在这个字段中设置 one two three：'
- en: '![](img/B18388_Figure_9.5.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.5.jpg)'
- en: 'This setting will result in the following java command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将导致以下 java 命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can read these parameters in the main() method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 main() 方法中读取这些参数：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another possible setting on the **Edit Configurations** screen is in the **Environment
    variables** field. The environment variables that can be accessed from the application
    using System.getenv(). For example, let’s set the environment variables x and
    y , as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **编辑配置** 屏幕上，另一个可能的设置是在 **环境变量** 字段中。可以从应用程序中使用 System.getenv() 访问的环境变量。例如，让我们设置环境变量
    x 和 y ，如下所示：
- en: '![](img/B18388_Figure_9.6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.6.jpg)'
- en: 'If done as shown in the preceding screenshot, the values of x and y can be
    read not only in the main() method, but anywhere in the application using the
    System.getenv(“varName”) method. In our case, the values of x and y can be retrieved
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像前面的截图所示完成，x 和 y 的值不仅可以在 main() 方法中读取，还可以在任何使用 System.getenv(“varName”) 方法的应用程序中读取。在我们的情况下，x
    和 y 的值可以按以下方式检索：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `java` command options. For example, if you input `-Xlog:gc`, the IDE will
    form the following `java` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`java` 命令选项。例如，如果您输入 `-Xlog:gc`，IDE 将形成以下 `java` 命令：'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-Xlog:gc` option requires the GC log to be displayed. We will use this
    option in the next section to demonstrate how GC works. The `-cp .` option (`.class`
    file is located in the `com/packt/learnjava/ch09_jvm` folder, where `com` is the
    subfolder of the current directory. The classpath can include many locations where
    the JVM has to look for the `.class` files that are necessary for the application’s
    execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Xlog:gc` 选项需要显示 GC 日志。我们将在下一节中使用此选项来演示 GC 的工作原理。`-cp .` 选项（`.class` 文件位于
    `com/packt/learnjava/ch09_jvm` 文件夹中，其中 `com` 是当前目录的子文件夹。类路径可以包括 JVM 必须查找的 `.class`
    文件的位置，这些文件对于应用程序的执行是必要的）。'
- en: 'Use **Modify options** link to show **VM options** as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **修改选项** 链接来显示以下 **虚拟机选项**：
- en: '![](img/B18388_Figure_9.7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.7.jpg)'
- en: 'For this demonstration, let’s set the value `-DsomeParameter=42` in the **VM
    options** field as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，让我们在 **虚拟机选项** 字段中设置值 `-DsomeParameter=42`，如下面的截图所示：
- en: '![](img/B18388_Figure_9.8.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.8.jpg)'
- en: 'Now the value of someParameter can be read not only in the `main()` method,
    but anywhere in the application code as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，someParameter 的值不仅可以在 `main()` 方法中读取，还可以在任何应用程序代码中如下所示：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are other parameters of the java command that can be set on the **Edit
    Configurations** screen, too. We encourage you to spend some time on that screen
    and view the possible options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **编辑配置** 屏幕上，还可以设置其他 java 命令参数。我们鼓励您花些时间在那个屏幕上查看可能的选择。
- en: Using the command line with classes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行与类
- en: 'Now, let’s run `MyApplication` from the command line. To remind you, the main
    class looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从命令行运行 `MyApplication`。为了提醒您，主类看起来如下：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, it must be compiled using the `javac` command. The command line looks
    as follows on Linux-type platforms (provided you open the Terminal window in the
    root of the project, in the folder where `pom.xml` resides):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须使用 `javac` 命令进行编译。在 Linux 类型的平台上，命令行看起来如下（假设您在项目的根目录中打开终端窗口，在 `pom.xml`
    所在的文件夹中）：
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On Windows, the command looks similar:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，命令看起来类似：
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The compiled `MyApplication.class` file is placed in the same folder as `MyApplication.java`.
    Now, we can execute the compiled class with the `java` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的 `MyApplication.class` 文件放在与 `MyApplication.java` 相同的文件夹中。现在，我们可以使用 `java`
    命令执行编译后的类：
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that `-cp` points to the `src/main/java` folder (the path is relative
    to the current folder), where the package of the main class starts. The result
    is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `-cp` 指向 `src/main/java` 文件夹（路径相对于当前文件夹），其中主类的包开始。结果是如下所示：
- en: '![](img/B18388_Figure_9.9.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_9.9.jpg)'
- en: We can also put both compiled classes in a `.jar` file and run them from there.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这两个编译后的类放入一个 `.jar` 文件中，并从那里运行它们。
- en: Using the command line with JAR files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行与 JAR 文件
- en: Keeping the compiled files in a folder as `.class` files is not always convenient,
    especially when many compiled files of the same framework belong to different
    packages and are distributed as a single library. In such cases, the compiled
    `.class` files are usually archived together in a `.jar` file. The format of such
    an archive is the same as the format of a `.zip` file. The only difference is
    that a `.jar` file also includes a manifest file that contains metadata describing
    the archive (we will talk more about the manifest in the next section).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将编译文件保留在文件夹中作为 `.class` 文件并不总是方便，尤其是当许多相同框架的编译文件属于不同的包并且作为单个库分发时。在这种情况下，编译的
    `.class` 文件通常一起存档在 `.jar` 文件中。这种存档的格式与 `.zip` 文件的格式相同。唯一的区别是 `.jar` 文件还包括一个包含描述存档元数据的清单文件（我们将在下一节中更多地讨论清单）。
- en: 'To demonstrate how to use it, let’s create a `.jar` file with the `ExampleClass.class`
    file and another `.jar` file with `MyApplication.class` in it, using the following
    commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用它，让我们使用以下命令创建一个包含 `ExampleClass.class` 文件的 `.jar` 文件，以及一个包含 `MyApplication.class`
    的另一个 `.jar` 文件：
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that we need to run the `jar` command in the folder where the package
    of the `.class` file begins.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们需要在 `.class` 文件包开始的文件夹中运行 `jar` 命令。
- en: 'Now, we can run the application, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式运行应用程序：
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `.jar` files are in the current folder. If we would like to execute the
    application from another folder (let’s go back to the root directory, `cd ../../..`),
    the command should look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`.jar` 文件位于当前文件夹中。如果我们想从另一个文件夹中执行应用程序（让我们回到根目录，`cd ../../..`），命令应该看起来像这样：'
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that every `.jar` file must be listed on the classpath individually.
    To specify just a folder where all the `.jar` files reside (as is the case with
    the `.class` files) is not good enough. You must add an asterisk (the wildcard
    symbol, `*`) too, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个 `.jar` 文件都必须单独列在类路径上。仅仅指定一个包含所有 `.jar` 文件的文件夹（就像 `.class` 文件的情况一样）是不够的。你还必须添加一个星号（通配符符号，`*`），如下所示：
- en: '[PRE43]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note the quotes around the path to the folder containing the `.jar` files. Without
    quotes, this will not work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件夹路径周围的引号，包含 `.jar` 文件的文件夹路径。如果没有引号，这将不会工作。
- en: Using the command line with an executable JAR file
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可执行 JAR 文件的命令行
- en: 'It is possible to avoid specifying the main class in the command line. Instead,
    we can create an executable `.jar` file. This can be accomplished by placing the
    name of the main class – the one you need to run and that contains the `main()`
    method – into the manifest file. Here are the steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能避免在命令行中指定主类。相反，我们可以创建一个可执行的 `.jar` 文件。这可以通过将主类的名称放入清单文件中实现——你需要运行的那个包含 `main()`
    方法的类。以下是步骤：
- en: 'Create a text file called `manifest.txt` (the name doesn''t matter, but this
    name makes the intent clear) that contains the following line:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `manifest.txt` 的文本文件（名称不重要，但这个名字可以使意图更清晰），其中包含以下行：
- en: '[PRE45]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There must be a space after the colon (`:`), and there must be an invisible
    newline symbol at the end, so make sure you have pressed the *Enter* key and your
    cursor has jumped to the beginning of the next line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒号（`:`）之后必须有一个空格，并且在末尾必须有一个不可见的换行符号，所以请确保你已经按下了 *Enter* 键，并且你的光标已经跳到了下一行的开头。
- en: 'Execute the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE46]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the sequence of `jar` command options (`fm`) and the sequence of the
    `myapp.jar manifest.txt` files. They must be the same because `f` stands for the
    file that the `jar` command is going to create, while `m` stands for the manifest
    source. If you include options with `mf`, then the files must be listed as `manifest.txt
    myapp.jar`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `jar` 命令选项（`fm`）的顺序和 `myapp.jar manifest.txt` 文件的顺序。它们必须相同，因为 `f` 代表 `jar`
    命令将要创建的文件，而 `m` 代表清单源。如果你包含 `mf` 选项，那么文件必须列出为 `manifest.txt myapp.jar`。
- en: 'Now, we can run the application using the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行应用程序：
- en: '[PRE47]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The other way to create an executable `.jar` file is much easier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可执行 `.jar` 文件的另一种方法更容易：
- en: '[PRE48]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding command generates a manifest with the specified main class name
    automatically: the `c` option stands for `f` option stands for `e` option indicates
    an **application entry point**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会自动生成包含指定主类名的清单：`c` 选项代表 `f` 选项，`e` 选项表示 **应用程序入口点**。
- en: Java processes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 进程
- en: As you may have already guessed, JVM does not know anything about the Java language
    and source code. It only knows how to read bytecode. It reads the bytecode and
    other information from `.class` files, transforms (interprets) the bytecode into
    a sequence of binary code instructions that are specific to the current platform
    (where JVM is running), and passes the resulting binary code to the microprocessor
    that executes it. When talking about this transformation, programmers often refer
    to it as a **Java process** or just **process**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，JVM 对 Java 语言和源代码一无所知。它只知道如何读取字节码。它从 `.class` 文件中读取字节码和其他信息，将字节码转换（解释）成特定于当前平台（JVM
    运行的位置）的二进制代码指令序列，并将生成的二进制代码传递给执行它的微处理器。当谈论这种转换时，程序员通常将其称为 **Java 进程** 或简称为 **进程**。
- en: The JVM is often referred to as a `java` command is executed, a new instance
    of JVM is launched that’s dedicated to running the particular application as a
    separate process with its own allocated memory (the size of the memory is set
    as a default value or passed in as a command option). Inside this Java process,
    multiple threads are running, each with its own allocated memory. Some are service
    threads that are created by the JVM; others are application threads that are created
    and controlled by the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `java` 命令时，通常会启动一个新的 JVM 实例，该实例专门用于以单独的进程运行特定应用程序，并为其分配自己的内存（内存大小设置为默认值或作为命令选项传入）。在这个
    Java 进程内部，多个线程正在运行，每个线程都有自己的分配内存。有些是 JVM 创建的服务线程；其他的是由应用程序创建和控制的线程。
- en: That is the big picture of the JVM executing the compiled code. But if you look
    closer and read the JVM specification, you will discover that the word *process*,
    concerning the JVM, is used to describe the JVM internal processes too. The JVM
    specification identifies several other processes running inside the JVM that are
    usually not mentioned by programmers, except maybe the **class loading process**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 JVM 执行编译代码的大致情况。但如果你仔细观察并阅读 JVM 规范，你会发现，关于 JVM，"进程" 这个词也被用来描述 JVM 内部进程。JVM
    规范确定了 JVM 内部运行的几个其他进程，通常程序员不会提及，除非是 **类加载过程**。
- en: This is because most of the time, we can successfully write and execute Java
    programs without knowing anything about the internal JVM processes. But once in
    a while, some general understanding of the JVM’s internal workings helps us identify
    the root cause of certain issues. That is why in this section, we will provide
    a short overview of all the processes that happen inside the JVM. Then, in the
    following sections, we will discuss the JVM’s memory structure and other aspects
    of its functionality that may be useful to a programmer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数时候，我们可以成功地编写和执行 Java 程序，而不必了解 JVM 内部进程的任何信息。但偶尔，对 JVM 内部工作原理的一些基本理解有助于我们识别某些问题的根本原因。这就是为什么在本节中，我们将简要概述
    JVM 内部发生的所有进程。然后，在接下来的章节中，我们将讨论 JVM 的内存结构及其功能的其他方面，这些可能对程序员有所帮助。
- en: 'Two subsystems run the JVM’s internal processes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两个子系统运行 JVM 的内部进程：
- en: '`.class` file and populates a method area in JVM’s memory with the class-related
    data:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.class` 文件并在 JVM 内存中的方法区域填充与类相关的数据：'
- en: Static fields
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态字段
- en: Method bytecode
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法字节码
- en: Class metadata that describes the class
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述类的类元数据
- en: '**The execution engine**: This executes the bytecode using the following properties:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行引擎**：它使用以下属性执行字节码：'
- en: A heap area for object instantiation
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于对象实例化的堆区域
- en: Java and native method stacks for keeping track of the methods that have been
    called
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于跟踪已调用方法的 Java 和本地方法栈
- en: A GC process that reclaims memory
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个回收内存的 GC 进程
- en: 'Some of the processes that run inside the main JVM process are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 JVM 进程中运行的某些进程如下：
- en: 'Processes that are performed by the classloader, such as the following:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器执行的进程，如下所示：
- en: Classloading
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载
- en: Class linking
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类链接
- en: Class initialization
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类初始化
- en: 'Processes that are performed by the execution engine, such as the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎执行的进程，如下所示：
- en: Class instantiation
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例化
- en: Method execution
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法执行
- en: GC
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC
- en: Application termination
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: The JVM Architecture
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JVM 架构
- en: The JVM architecture can be described as having two subsystems – the **classloader** and
    the **execution engine** – that run the service processes and application threads
    using runtime data memory areas such as the method area, heap, and application
    thread stacks. **Threads** are lightweight processes that require less resource
    allocation than the JVM execution process.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JVM 架构可以描述为有两个子系统——**类加载器**和**执行引擎**——它们使用运行时数据内存区域（如方法区、堆和应用线程栈）来运行服务进程和应用线程。**线程**是轻量级进程，比
    JVM 执行过程需要的资源分配更少。
- en: This list may give you the impression that these processes are executed sequentially.
    To some degree, this is true, if we’re talking about one class only. It is not
    possible to do anything with a class before loading it. We can only execute a
    method after all the previous processes have been completed. However, GC, for
    example, does not happen immediately once an object has stopped being used (see
    the *Garbage collection* section). Also, an application can exit any time when
    an unhandled exception or some other error occurs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能会给你一种印象，这些过程是按顺序执行的。在某种程度上，这是真的，如果我们只谈论一个类的话。在加载类之前，我们无法对类做任何事情。我们只能在所有前面的过程完成后执行一个方法。然而，例如，GC
    并不是一旦一个对象停止使用就立即发生（参见 *垃圾回收* 部分）。此外，当发生未处理的异常或其他错误时，应用程序可以随时退出。
- en: Only the classloader processes are regulated by the JVM specification. The execution
    engine’s implementation is largely at the discretion of each vendor. It is based
    on the language semantics and the performance goals that have been set by the
    implementation authors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只有类加载器过程受 JVM 规范的约束。执行引擎的实现主要取决于每个供应商。它基于实现作者设定的语言语义和性能目标。
- en: The processes of the execution engine are in a realm that’s not regulated by
    the JVM specification. There is common sense, tradition, known and proven solutions,
    and a Java language specification that can guide a JVM vendor’s implementation
    decision. But there is no single regulatory document. The good news is that the
    most popular JVMs use similar solutions – or at least that’s how it looks at a
    high level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎的过程处于一个不受 JVM 规范约束的领域。这里有常识、传统、已知和经过验证的解决方案，以及一个可以指导 JVM 供应商实现决策的 Java 语言规范。但是没有单一的管理文件。好消息是，最流行的
    JVM 使用类似的解决方案——至少从高层次上看是这样的。
- en: With this in mind, let’s discuss each of the seven processes listed previously
    in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们更详细地讨论之前列出的七个过程。
- en: Classloading
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类加载
- en: According to the JVM specification, the loading phase includes finding the `.class`
    file by its name (in the locations listed on a classpath) and creating its representation
    in memory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JVM 规范，加载阶段包括通过其名称（在类路径上列出的位置）找到 `.class` 文件，并在内存中创建其表示。
- en: The first class to be loaded is the one that’s passed in the command line, with
    the `main(String[])` method in it. The classloader reads the `.class` file, parses
    it, and populates the method area with static fields and method bytecode. It also
    creates an instance of `java.lang.Class` that describes the class. Then, the classloader
    links the class (see the *Class linking* section), initializes it (see the *Class
    initialization* section), and then passes it to the execution engine to run its
    bytecode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要加载的类是命令行中传递的，其中包含 `main(String[])` 方法。类加载器读取 `.class` 文件，解析它，并将静态字段和方法字节码填充到方法区。它还创建了一个
    `java.lang.Class` 实例，描述了这个类。然后，类加载器将类链接（参见 *类链接* 部分），初始化它（参见 *类初始化* 部分），然后将其传递给执行引擎以运行其字节码。
- en: The `main(String[])` method is an entrance door into the application. If it
    calls a method of another class, that class has to be found on the classpath,
    loaded, and initialized; only then can its method be executed too. If this – just
    loaded – method calls a method of another class, that class has to be found, loaded,
    and initialized too, and so on. That is how a Java application starts and gets
    going.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`main(String[])` 方法是进入应用程序的入口。如果它调用另一个类的某个方法，那么这个类必须在类路径上找到、加载和初始化；只有在这种情况下，它的方法才能被执行。如果这个刚刚加载的方法调用另一个类的某个方法，那么这个类也必须被找到、加载和初始化，依此类推。这就是
    Java 应用程序开始并运行的方式。'
- en: The main(String[]) Method
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`main(String[])` 方法'
- en: Every class can have a `main(String[])` method and often does. Such a method
    is used to run the class independently as a standalone application for testing
    or demonstration purposes. The presence of such a method does not make the class `main`.
    The class only becomes `main` if it's been identified as such in a `java` command
    line or a `.jar` file manifest.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都可以有一个`main(String[])`方法，并且通常都有。这样的方法用于将类独立运行作为独立的应用程序进行测试或演示。存在这样的方法并不会使类成为`main`。只有当在`java`命令行或`.jar`文件清单中将其识别为`main`时，类才成为`main`。
- en: That being said, let’s continue discussing the loading process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续讨论加载过程。
- en: If you look in the API of `java.lang.Class`, you will not see a public constructor
    there. The classloader creates its instance automatically. This is the same instance
    that is returned by the `getClass()` method, which you can invoke on any Java
    object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`java.lang.Class`的API，你将不会在那里看到一个公共构造函数。类加载器会自动创建其实例。这就是`getClass()`方法返回的实例，你可以在任何Java对象上调用它。
- en: It does not carry the class’s static data (which is maintained in the method
    area), nor state values (they are in an object that’s created during the execution).
    It does not contain method bytecode either (this is stored in the method area
    too). Instead, the `Class` instance provides metadata that describes the class
    – its name, package, fields, constructors, method signatures, and so on. This
    metadata is useful not only for the JVM but also for the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它不携带类的静态数据（这些数据存储在方法区），也不携带状态值（它们存储在执行过程中创建的对象中）。它也不包含方法字节码（这些也存储在方法区）。相反，`Class`实例提供了描述类的元数据——它的名称、包、字段、构造函数、方法签名等。这些元数据不仅对JVM有用，对应用程序也有用。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the data that's created by the classloader in memory and maintained by the
    execution engine is called a **binary representation of the type**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由类加载器在内存中创建并由执行引擎维护的所有数据称为**类型的二进制表示**。
- en: If the `.class` file contains errors or does not adhere to a certain format,
    the process is terminated. This means that the loaded class format and its bytecode
    have been validated by the loading process already. More verification follows
    at the beginning of the next process, called **class linking**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.class`文件包含错误或不符合某种格式，则终止该过程。这意味着加载过程已经验证了加载的类格式及其字节码。在下一个过程的开始处还有更多的验证，称为**类链接**。
- en: 'Here is a high-level description of the loading process. It performs three
    tasks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对加载过程的概述。它执行三个任务：
- en: Finds and reads the `.class` file
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并读取`.class`文件
- en: Parses it according to the internal data structure in the method area
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据方法区内部数据结构解析它
- en: Creates an instance of `java.lang.Class` with the class metadata
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有类元数据的`java.lang.Class`实例
- en: Class linking
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类链接
- en: According to the JVM specification, class linking resolves the references of
    the loaded class so that the methods of the class can be executed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JVM规范，类链接解决了加载类的引用，以便可以执行类的方法。
- en: 'Here is a high-level description of the linking process. It performs three
    tasks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对链接过程的概述。它执行三个任务：
- en: '`.class` file was produced by the Java compiler and all the instructions satisfy
    the constraints and requirements of the language, there is no guarantee that the
    loaded file was produced by the known compiler implementation or a compiler at
    all. That’s why the first step of the linking process is verification. This makes
    sure that the binary representation of the class is structurally correct, which
    means the following:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.class`文件是由Java编译器生成的，并且所有指令都满足语言的约束和要求，但这并不能保证加载的文件是由已知的编译器实现生成的，或者是由编译器生成的。这就是为什么链接过程的第一步是验证。这确保了类的二进制表示在结构上是正确的，这意味着以下内容：'
- en: The arguments of each method's invocation are compatible with the method descriptor.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法调用的参数与方法描述符兼容。
- en: The return instruction matches the return type of its method.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回指令与其方法的返回类型匹配。
- en: Some other checks and verification processes, which vary depending on the JVM
    vendor.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他检查和验证过程，这些过程因JVM供应商而异。
- en: '**Prepares the static fields in the method area**: Once verification has been
    completed, the interface or class (static) variables are created in the method
    area and initialized to the default values of their types. The other kinds of
    initialization, such as the explicit assignments that are specified by a programmer
    and static initialization blocks, are deferred to the process called **class initialization**
    (see the *Class initialization* section).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备方法区中的静态字段**：一旦验证完成，接口或类（静态）变量将在方法区中创建并初始化为其类型的默认值。其他类型的初始化，例如程序员指定的显式赋值和静态初始化块，将延迟到称为**类初始化**的过程（参见*类初始化*部分）。'
- en: '**Resolves symbolic references into concrete references that point to the method
    area**: If the loaded bytecode refers to other methods, interfaces, or classes,
    the symbolic references are resolved into concrete references that point to the
    method area, which is done by the resolution process. If the referred interfaces
    and classes haven’t been loaded yet, the classloader finds and loads them as needed.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将符号引用解析为指向方法区的具体引用**：如果加载的字节码引用了其他方法、接口或类，符号引用将被解析为指向方法区的具体引用，这是通过解析过程完成的。如果引用的接口和类尚未加载，类加载器将根据需要找到并加载它们。'
- en: Class initialization
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类初始化
- en: According to the JVM specification, initialization is accomplished by executing
    the class initialization methods. This happens when the programmer-defined initialization
    (in static blocks and static assignments) is performed, unless the class was already
    initialized at the request of another class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JVM 规范，初始化是通过执行类初始化方法来完成的。这发生在程序员定义的初始化（在静态块和静态赋值中）执行时，除非类已经被另一个类的请求初始化。
- en: The last part of this statement is important because the class may be requested
    several times by different (already loaded) methods, and also because JVM processes
    are executed by different threads and may access the same class concurrently.
    So, **coordination** (also called **synchronization**) between different threads
    is required, which substantially complicates the JVM implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的最后部分很重要，因为类可能被不同的（已经加载的）方法多次请求，也因为 JVM 进程是由不同的线程执行的，并且可能并发访问同一个类。因此，需要在不同线程之间进行**协调**（也称为**同步**），这大大增加了
    JVM 实现的复杂性。
- en: Class instantiation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类实例化
- en: This step may never happen. Technically, an instantiation process, triggered
    by the `new` operator, is the first step of the execution process. If the `main(String[])`
    method (which is static) uses only the static methods of other classes, this instantiation
    never happens. That’s why it is reasonable to identify this process as separate
    from the execution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能永远不会发生。技术上，由`new`运算符触发的实例化过程是执行过程的第一步。如果`main(String[])`方法（它是静态的）只使用其他类的静态方法，则这种实例化永远不会发生。这就是为什么将这个过程识别为与执行过程分开是合理的。
- en: 'This activity has very specific tasks:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动有非常具体的任务：
- en: Allocating memory for the object (its state) in the heap area
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆区域为对象（其状态）分配内存
- en: Initializing the instance fields to the default values
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例字段初始化为默认值
- en: Creating thread stacks for Java and native methods
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Java 和本地方法创建线程栈
- en: Execution starts when the first method (not a constructor) is ready to be executed.
    For every application thread, a dedicated runtime stack is created, where every
    method call is captured in a stack frame. For example, if an exception occurs,
    we get data from the current stack frames when we call the `printStackTrace()`
    method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个方法（不是构造函数）准备好执行时，执行开始。对于每个应用程序线程，都会创建一个专用的运行时栈，其中每个方法调用都捕获在一个栈帧中。例如，如果发生异常，当我们调用`printStackTrace()`方法时，我们会从当前的栈帧中获取数据。
- en: Method execution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法执行
- en: The first application thread (called the `main(String[])` method starts executing.
    It can create other application threads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应用程序线程（称为`main(String[])`方法开始执行。它可以创建其他应用程序线程。
- en: The execution engine reads the bytecode, interprets it, and sends the binary
    code to the microprocessor for execution. It also maintains a count of how many
    times and how often each method was called. If the count exceeds a certain threshold,
    the execution engine uses a compiler, called the **just-in-time** (**JIT**) compiler,
    which compiles the method bytecode into native code. This way, the next time the
    method is called, it will be ready without needing an interpretation. This substantially
    improves code performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎读取字节码，解释它，并将二进制代码发送到微处理器执行。它还维护了一个计数器，记录每个方法被调用的次数和频率。如果计数器超过某个阈值，执行引擎会使用一个称为**即时编译器**（**JIT**）的编译器，将方法字节码编译成本地代码。这样，下次调用该方法时，它将无需解释即可准备好。这大大提高了代码性能。
- en: The instruction that’s currently being executed and the address of the next
    instruction are maintained in the **program counter** (**PC**) registers. Each
    thread has dedicated PC registers. It also improves performance and keeps track
    of the execution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在执行的指令和下一条指令的地址被保存在**程序计数器**（**PC**）寄存器中。每个线程都有专门的PC寄存器。这也提高了性能并跟踪执行情况。
- en: Garbage collection
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: The garbage collector identifies the objects that are not referenced anymore
    and can be removed from the memory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器识别出不再被引用的对象，并可以从内存中移除。
- en: There is a Java static method, `System.gc()`, that can be used programmatically
    to trigger the GC, but its immediate execution is not guaranteed. Every GC cycle
    affects the application’s performance, so the JVM must maintain a balance between
    memory availability and the ability to execute the bytecode quickly enough.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Java静态方法`System.gc()`，可以用来程序化地触发GC，但其立即执行并不保证。每次GC周期都会影响应用程序的性能，因此JVM必须在内存可用性和快速执行字节码的能力之间保持平衡。
- en: Application termination
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: 'There are several ways an application can be terminated (and the JVM stopped
    or exited) programmatically:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过多种方式被终止（以及JVM停止或退出）：
- en: Normal termination, without an error status code
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常终止，没有错误状态码
- en: Abnormal termination, because of an unhandled exception
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非正常终止，由于未处理的异常
- en: Forced programmatic exit, with or without an error status code
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制程序化退出，带或不带错误状态码
- en: If there are no exceptions and infinite loops, the `main(String[])` method completes
    with a return statement or after its last statement is executed. As soon as this
    happens, the main application thread passes the control flow to the JVM and the
    JVM stops executing too. That is the happy ending, and many applications enjoy
    it in real life. Most of our examples, except those when we have demonstrated
    exceptions or infinite loops, have exited successfully too.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有异常和无限循环，`main(String[])`方法会通过返回语句或在其最后一条语句执行后完成。一旦发生这种情况，主应用程序线程将控制流传递给JVM，JVM也会停止执行。这就是美好的结局，许多应用程序在现实生活中也享受到了它。我们的大部分示例，除了我们演示异常或无限循环的情况外，也都成功退出了。
- en: However, there are other ways a Java application can exit, some of them quite
    graceful too – others not so much. If the main application thread created child
    threads or, in other words, a programmer has written code that generates other
    threads, even a graceful exit may not be easy. It all depends on the kind of child
    threads that have been created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java应用程序还有其他退出方式，其中一些相当优雅——而另一些则不然。如果主应用程序线程创建了子线程，或者说，程序员编写的代码生成了其他线程，即使是优雅的退出也可能不容易。这完全取决于创建的子线程类型。
- en: If any of them is a user thread (the default), then the JVM instance continues
    to run even after the main thread exits. Only after all the user threads have
    been completed does the JVM instance stop. The main thread can request the child
    user thread to complete. But until it exits, the JVM continues running. And this
    means that the application is still running too.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何一个是一个用户线程（默认），那么即使主线程退出后，JVM实例也会继续运行。只有当所有用户线程都完成后，JVM实例才会停止。主线程可以请求子用户线程完成。但在它退出之前，JVM会继续运行。这意味着应用程序仍在运行。
- en: But if all the child threads are daemon threads, or no child threads are running,
    the JVM instance stops running as soon as the main application thread exits.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果所有子线程都是守护线程，或者没有子线程正在运行，那么一旦主应用程序线程退出，JVM实例就会停止运行。
- en: 'How the application exits in the case of an exception depends on the code design.
    We touched on this in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception
    Handling*, while discussing the best practices of exception handling. If the thread
    captures all the exceptions in a try-catch block in `main(String[])` or a similarly
    high-level method, then it is up to the application (and the programmer who wrote
    the code) to decide how best to proceed – to try to change the input data and
    repeat the block of code that generated the exception, to log the error and continue,
    or to exit. If, on the other hand, the exception remains unhandled and propagates
    into the JVM code, the thread (where the exception occurred) stops executing and
    exits. What happens next depends on the type of thread and some other conditions.
    The following are four possible options:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在异常情况下的退出方式取决于代码设计。我们在[*第4章*](B18388_04_ePub.xhtml#_idTextAnchor110)“异常处理”中讨论了异常处理的最佳实践时提到了这一点。如果线程在`main(String[])`或类似高级方法中的try-catch块中捕获了所有异常，那么如何最好地继续取决于应用程序（以及编写代码的程序员）——尝试更改输入数据并重复生成异常的代码块，记录错误并继续，或者退出。另一方面，如果异常未得到处理并传播到JVM代码中，发生异常的线程将停止执行并退出。接下来发生什么取决于线程的类型和一些其他条件。以下有四种可能的选择：
- en: If there are no other threads, the JVM stops executing and returns an error
    code and the stack trace.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有其他线程，JVM将停止执行并返回错误码和堆栈跟踪。
- en: If the thread with an unhandled exception was not the main one, other threads
    (if present) continue running.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未处理的异常的线程不是主线程，其他线程（如果存在）将继续运行。
- en: If the main thread has thrown an unhandled exception and the child threads (if
    present) are daemons, they exit too.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主线程抛出了未处理的异常，并且子线程（如果存在）是守护线程，它们也会退出。
- en: If there is at least one user child thread, the JVM continues running until
    all the user threads exit.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少有一个用户子线程，JVM将继续运行，直到所有用户线程退出。
- en: 'There are also ways to programmatically force the application to stop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也有方法可以编程强制应用程序停止：
- en: '`System.exit(0);`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.exit(0);`'
- en: '`Runtime.getRuntime().exit(0);`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runtime.getRuntime().exit(0);`'
- en: '`Runtime.getRuntime().halt(0);`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runtime.getRuntime().halt(0);`'
- en: 'All these methods force the JVM to stop executing any thread and exit with
    a status code passed in as the parameter (`0`, in our examples):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都强制JVM停止执行任何线程，并以作为参数传入的状态码退出（在我们的示例中为`0`）：
- en: Zero indicates normal termination
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零表示正常终止
- en: A nonzero value indicates an abnormal termination
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非零值表示异常终止
- en: If the Java command was launched by some script or another system, the value
    of the status code can be used to automate the decision-making regarding the next
    step. But that is already outside the application and Java code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java命令是由某个脚本或其他系统启动的，可以使用状态码的值来自动化关于下一步决策的决定。但这已经超出了应用程序和Java代码的范围。
- en: 'The first two methods have identical functionality because this is how `System.exit()`
    is implemented:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法具有相同的功能，因为这是`System.exit()`的实现方式：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To see the source code in the IDE, just click on the method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IDE中查看源代码，只需单击方法。
- en: The JVM exits when some thread invokes the `exit()` method of the `Runtime`
    or `System` classes, or the `halt()` method of the `Runtime` class, and the exit
    or halt operation is permitted by the security manager. The difference between
    `exit()` and `halt()` is that `halt()` forces the JVM to exit immediately, while
    `exit()` performs additional actions that can be set using the `Runtime.addShutdownHook()`
    method. But these options are rarely used by mainstream programmers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个线程调用`Runtime`或`System`类的`exit()`方法，或者`Runtime`类的`halt()`方法，并且安全管理器允许退出或挂起操作时，JVM退出。`exit()`和`halt()`之间的区别在于`halt()`强制JVM立即退出，而`exit()`执行一些额外的操作，这些操作可以使用`Runtime.addShutdownHook()`方法设置。但主流程序员很少使用这些选项。
- en: JVM’s structure
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM的结构
- en: The structure of the JVM can be described in terms of its runtime data structure
    in memory and the two subsystems that use the runtime data – the classloader and
    the execution engine.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用内存中的运行时数据结构及其使用的两个子系统（类加载器和执行引擎）来描述JVM的结构。
- en: Runtime data areas
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时数据区域
- en: 'Each of the runtime data areas of JVM memory belongs to one of two categories:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JVM内存的每个运行时数据区域属于以下两个类别之一：
- en: '**Shared areas**, which include the following:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享区域**，包括以下内容：'
- en: '**Method area**: Class metadata, static fields, and method bytecode'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法区**：类元数据、静态字段和方法字节码'
- en: '**Heap area**: Objects (states)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆区**：对象（状态）'
- en: '**Unshared areas** that are dedicated to a particular application thread, which
    include the following:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未共享区域**，这些区域专门用于特定的应用程序线程，包括以下内容：'
- en: '**Java stack**: Current and caller frames, with each frame keeping the state
    of Java (non-native) method invocation:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 栈**：当前和调用帧，每个帧保持 Java（非本地）方法调用的状态：'
- en: Values of local variables
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量的值
- en: Method parameter values
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法参数值
- en: Values of operands for intermediate calculations (operand stack)
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间计算的操作数值（操作数栈）
- en: Method return value (if any)
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法返回值（如果有）
- en: '**PC register**: The next instruction to execute'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器**：下一个要执行的指令'
- en: '**Native method stack**: The state of the native method invocations'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地方法栈**：本地方法调用的状态'
- en: We have already discussed that a programmer must be careful when using reference
    types and not modify the object itself unless it needs to be done. In a multi-threaded
    application, if a reference to an object can be passed between threads, we must
    be extra careful because of the possibility of the same data being modified concurrently.
    On the bright side, though, such a shared area can be – and often is – used as
    the method of communication between threads.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，程序员在使用引用类型时必须小心，除非需要修改对象本身，否则不要修改对象。在多线程应用程序中，如果对象的引用可以在线程之间传递，我们必须格外小心，因为可能存在相同数据被并发修改的可能性。然而，从积极的一面来看，这样的共享区域可以——并且通常被用作线程之间通信的方法。
- en: Classloaders
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类加载器
- en: 'The classloader performs the following three functions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器执行以下三个功能：
- en: Reads a `.class` file
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 `.class` 文件
- en: Populates the method area
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充方法区
- en: Initializes static fields that haven’t been initialized by a programmer
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化程序员未初始化的静态字段
- en: Execution engine
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The execution engine does the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎执行以下操作：
- en: Instantiates objects in the heap area
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆区域实例化对象
- en: Initializes static and instance fields using initializers written by the programmer
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用程序员编写的初始化器初始化静态和实例字段
- en: Adds/removes frames to/from the Java stack
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向/从 Java 栈中添加/删除帧
- en: Updates the PC register with the next instruction to execute
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新程序计数器，以执行下一个指令
- en: Maintains the native method stack
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护本地方法栈
- en: Keeps count of method calls and compiles popular ones
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录方法调用次数并编译流行的调用
- en: Finalizes objects
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止对象
- en: Runs GC
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 GC
- en: Terminates the application
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止应用程序
- en: Garbage collection
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Automatic memory management is an important aspect of the JVM that relieves
    the programmer from the need to do so programmatically. In Java, the process that
    cleans up memory and allows it to be reused is called **GC**.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 自动内存管理是 JVM 的重要方面，它减轻了程序员需要程序化地执行此操作的负担。在 Java 中，清理内存并允许其重用的过程称为 **GC**。
- en: Responsiveness, throughput, and stop-the-world
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应性、吞吐量和停止世界
- en: 'The effectiveness of GC affects two major application characteristics – **responsiveness**
    and **throughput**:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: GC 的有效性影响两个主要的应用程序特性——**响应性**和**吞吐量**：
- en: '**Responsiveness**: This is measured by how quickly an application responds
    (brings the necessary data) to the request; for example, how quickly a website
    returns a page, or how quickly a desktop application responds to an event. The
    smaller the response time, the better the user experience.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：这是通过应用程序响应速度（提供必要的数据）来衡量的；例如，网站返回页面有多快，或者桌面应用程序对事件的响应有多快。响应时间越短，用户体验越好。'
- en: '**Throughput**: This indicates the amount of work an application can do in
    a unit of time; for example, how many requests a web application can serve, or
    how many transactions the database can support. The bigger the number, the more
    value the application can potentially generate and the more user requests it can
    support.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：这表示应用程序在单位时间内可以完成的工作量；例如，Web 应用程序可以处理多少请求，或者数据库可以支持多少事务。数字越大，应用程序潜在的价值越高，它可以支持的用户请求也越多。'
- en: Meanwhile, GC needs to move data around, which is impossible to accomplish while
    allowing data processing to occur because the references are going to change.
    That’s why GC needs to stop application thread execution once in a while for a
    while. This is called **stop-the-world**. The longer these periods are, the quicker
    GC does its job and the longer an application freeze lasts, which can eventually
    grow big enough to affect both the application’s responsiveness and throughput.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，垃圾回收（GC）需要移动数据，这在允许数据处理进行的同时是不可能的，因为引用将会改变。这就是为什么GC需要时不时地停止应用程序线程执行一段时间。这被称为**停止世界**。这些周期越长，GC完成其工作的速度越快，应用程序冻结的时间越长，这最终可能足够大，以至于影响应用程序的响应性和吞吐量。
- en: Fortunately, it is possible to tune the GC’s behavior using Java command options,
    but that is outside the scope of this book. Instead, we will provide a high-level
    view of the main activity of GC – inspecting objects in the heap and removing
    those that don’t have references in any thread stack.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过Java命令选项调整GC的行为，但这超出了本书的范围。相反，我们将提供一个GC主要活动的概述——检查堆中的对象，并移除那些在任何线程堆栈中没有引用的对象。
- en: Object age and generation
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象年龄和代际
- en: The basic GC algorithm determines *how old* each object is. The term **age**
    refers to the number of collection cycles the object has survived.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的GC算法确定每个对象的**年龄**。术语**年龄**指的是对象存活了多少次收集周期。
- en: 'When the JVM starts, the heap is empty and is divided into three sections:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM启动时，堆是空的，并被分为三个部分：
- en: The young generation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年轻一代
- en: The old or tenured generation
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 老一代或资深一代
- en: Humongous regions for holding objects that are 50% the size of a standard region
    or larger
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用来存放大小为标准区域50%或更大的物体的巨大区域
- en: 'The young generation has three areas:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 年轻一代有三个区域：
- en: An Eden space
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个伊甸园空间
- en: Survivor 0 (S0)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸存者0（S0）
- en: Survivor 1 (S1)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸存者1（S1）
- en: The newly created objects are placed in Eden. When it is filling up, a minor
    GC process starts. It removes the unreferred and circular referred objects and
    moves the others to the S1 area. During the next minor collection, S0 and S1 switch
    roles. The referenced objects are moved from Eden and S1 to S0.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象被放置在伊甸园。当它开始填满时，一个小的GC过程开始。它移除未引用的和循环引用的对象，并将其他对象移动到S1区域。在下一次小收集期间，S0和S1交换角色。引用对象从伊甸园和S1移动到S0。
- en: During each of the minor collections, the objects that have reached a certain
    age are moved to the old generation. As a result of this algorithm, the old generation
    contains objects that are older than a certain age. This area is bigger than the
    young generation and, because of that, the GC process is more expensive and happens
    not as often as in the young generation. But it is checked eventually (after several
    minor collections). The unreferenced objects are removed and the memory is defragmented.
    Cleaning up the old generation is considered a major collection.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次小收集期间，达到一定年龄的对象被移动到老一代。由于这个算法，老一代包含比一定年龄更老的对象。这个区域比年轻一代大，因此GC过程更昂贵，并且不像在年轻一代那样频繁发生。但最终会进行检查（在几次小收集之后）。未引用的对象被移除，内存被碎片化。清理老一代被认为是主要收集。
- en: When stop-the-world is unavoidable
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当停止世界不可避免时
- en: 'Some objects are collected in the old generation concurrently, while some are
    collected using stop-the-world pauses. The steps are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象在老一代并发收集，而另一些则使用停止世界的暂停进行收集。步骤如下：
- en: '**Initial marking**: This marks the survivor regions (root regions) that may
    have references to objects in the old generation. This is done using a stop-the-world
    pause.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始标记**：这标记了可能包含指向老一代对象引用的幸存区域（根区域）。这是通过停止世界的暂停完成的。'
- en: '**Scanning**: This searches survivor regions for references to the old generation.
    This is done concurrently while the application continues to run.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫描**：这搜索幸存区域以查找对老一代的引用。这是在应用程序继续运行的同时并行的。'
- en: '**Concurrent marking**: This marks live objects over the entire heap and is
    done concurrently while the application continues to run.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**并发标记**：这标记了整个堆中的活动对象，并且是在应用程序继续运行的同时并行的。'
- en: '**Remark**: At this stage, the live objects have been marked, which is done
    using a stop-the-world pause.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重标记**：在这个阶段，活动对象已经被标记，这是通过停止世界的暂停完成的。'
- en: '**Cleanup**: This calculates the age of live objects, frees regions (using
    stop-the-world), and returns them to the free list. This is done concurrently.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理**：这计算活动对象的生命周期，释放区域（使用停止世界），并将它们返回到空闲列表。这是并发执行的。'
- en: To help with GC tuning, the JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler. But fortunately, the
    JVM vendors improve and tune the GC process all the time, so most of the applications
    work just fine with the default GC behavior.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助GC调整，JVM为垃圾收集器、堆大小和运行时编译器提供了平台相关的默认选择。但幸运的是，JVM供应商一直在改进和调整GC过程，所以大多数应用程序使用默认的GC行为都能正常工作。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how a Java application can be executed using an
    IDE or the command line. Now, you can write applications and launch them in a
    manner that’s appropriate for the given environment. Knowledge about the JVM structure
    and its processes – classloading, linking, initialization, execution, GC, and
    application termination – provided you with better control over the application’s
    execution and transparency regarding the performance and current state of the
    JVM.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用IDE或命令行执行Java应用程序。现在，你可以根据给定环境以适当的方式编写应用程序并启动它们。关于JVM结构和其过程（类加载、链接、初始化、执行、GC和应用终止）的知识，为你提供了更好的应用程序执行控制和对JVM性能和当前状态的透明度。
- en: In the next chapter, we will discuss and demonstrate how to manage – insert,
    read, update, and delete – data in a database from a Java application. We will
    also provide a short introduction to the SQL language and its basic database operations,
    including how to connect to a database, how to create the database’s structure,
    how to write database expressions using SQL, and how to execute them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并演示如何从Java应用程序中管理数据库中的数据——插入、读取、更新和删除。我们还将简要介绍SQL语言及其基本数据库操作，包括如何连接到数据库、如何创建数据库结构、如何使用SQL编写数据库表达式以及如何执行它们。
- en: Quiz
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: 'Select all of the correct statements:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: An IDE executes Java code without compiling it.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个IDE可以在不编译的情况下执行Java代码。
- en: An IDE uses installed Java to execute the code.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个IDE使用已安装的Java来执行代码。
- en: An IDE checks the code without using the Java installation.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个IDE在不需要Java安装的情况下检查代码。
- en: An IDE uses the compiler of the Java installation.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个集成开发环境（IDE）使用Java安装的编译器。
- en: 'Select all of the correct statements:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: All the classes that are used by the application must be listed on the classpath.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用的所有类必须在类路径上列出。
- en: The locations of all the classes that are used by the application must be listed
    on the classpath.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用的所有类的位置必须在类路径上列出。
- en: The compiler can find a class if it is in the folder that’s listed on the classpath.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类在类路径上列出的文件夹中，编译器可以找到该类。
- en: The classes of the main package do not need to be listed on the classpath.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主包中的类不需要在类路径上列出。
- en: 'Select all of the correct statements:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: All the `.jar` files that are used by the application must be listed on the
    classpath.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用的所有`.jar`文件必须在类路径上列出。
- en: The locations of all the `.jar` files that are used by the application must
    be listed on the classpath.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用的所有`.jar`文件的位置必须在类路径上列出。
- en: The JVM can only find a class if it is in the `.jar` file that’s listed on the
    classpath.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类在类路径上列出的`.jar`文件中，JVM才能找到该类。
- en: Every class can contain the `main()` method.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类都可以包含`main()`方法。
- en: 'Select all of the correct statements:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Every `.jar` file that contains a manifest is executable.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含清单的每个`.jar`文件都是可执行的。
- en: If the `-jar` option is used by the `java` command, the classpath option is
    ignored.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`java`命令使用`-jar`选项，则忽略类路径选项。
- en: Every `.jar` file has a manifest.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`.jar`文件都有一个清单。
- en: An executable `.jar` is a ZIP file with a manifest.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可执行的`.jar`文件是一个包含清单的ZIP文件。
- en: 'Select all of the correct statements:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Classloading and linking can work in parallel on different classes.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载和链接可以在不同的类上并行工作。
- en: Classloading moves the class to the execution area.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载将类移动到执行区域。
- en: Class linking connects two classes.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类链接连接两个类。
- en: Class linking uses memory references.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类链接使用内存引用。
- en: 'Select all of the correct statements:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Class initialization assigns values to instance properties.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类初始化为实例属性赋值。
- en: Class initialization happens every time the class is referred to by another
    class.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当另一个类引用该类时，都会发生类初始化。
- en: Class initialization assigns values to static properties.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类初始化为静态属性赋值。
- en: Class initialization provides data to the instance of `java.lang.Class`.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类初始化为`java.lang.Class`的实例提供数据。
- en: 'Select all of the correct statements:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Class instantiation may never happen.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类实例化可能永远不会发生。
- en: Class instantiation includes object property initialization.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类实例化包括对象属性初始化。
- en: Class instantiation includes memory allocation on a heap.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类实例化包括在堆上进行内存分配。
- en: Class instantiation includes executing constructor code.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类实例化包括执行构造函数代码。
- en: 'Select all of the correct statements:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Method execution includes binary code generation.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法执行包括二进制代码生成。
- en: Method execution includes source code compilation.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法执行包括源代码编译。
- en: Method execution includes reusing the binary code that’s produced by the JIT
    compiler.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法执行包括重用JIT编译器产生的二进制代码。
- en: Method execution counts how many times every method was called.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法执行统计每个方法被调用的次数。
- en: 'Select all of the correct statements:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Garbage collection starts immediately after the `System.gc()` method is called.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`System.gc()`方法后，垃圾回收立即开始。
- en: The application can be terminated with or without an error code.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序可以带错误代码或不带错误代码终止。
- en: The application exits as soon as an exception is thrown.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦抛出异常，应用程序就会立即退出。
- en: The main thread is a user thread.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程是一个用户线程。
- en: 'Select all of the correct statements:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The JVM has memory areas shared across all threads.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM具有所有线程共享的内存区域。
- en: The JVM has memory areas not shared across threads.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM具有线程之间不共享的内存区域。
- en: Class metadata is shared across all threads.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类元数据在所有线程之间共享。
- en: Method parameter values are not shared across threads.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法参数值在所有线程之间不共享。
- en: 'Select all of the correct statements:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The classloader populates the method area.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载器填充方法区。
- en: The classloader allocates memory on a heap.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载器在堆上分配内存。
- en: The classloader writes to the `.class` file.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载器写入`.class`文件。
- en: The classloader resolves method references.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载器解析方法引用。
- en: 'Select all of the correct statements:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The execution engine allocates memory on a heap.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行引擎在堆上分配内存。
- en: The execution engine terminates the application.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行引擎终止应用程序。
- en: The execution engine runs garbage collection.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行引擎运行垃圾回收。
- en: The execution engine initializes static fields that haven’t been initialized
    by a programmer.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行引擎初始化程序员未初始化的静态字段。
- en: 'Select all of the correct statements:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The number of transactions per second that a database can support is a throughput
    measure.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库每秒可以支持的交易数量是一个吞吐量度量。
- en: When the garbage collector pauses the application, it is called stop-all-things.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当垃圾回收器暂停应用程序时，它被称为停止一切。
- en: How slowly the website returns data is a responsiveness measure.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站返回数据有多慢是一个响应性度量。
- en: The garbage collector clears the CPU queue of jobs.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收器清除作业的CPU队列。
- en: 'Select all of the correct statements:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Object age is measured by the number of seconds since the object was created.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象年龄是通过对象创建以来的秒数来衡量的。
- en: The older the object, the more probable it is going to be removed from memory.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象越老，它被从内存中移除的可能性就越大。
- en: Cleaning the old generation is a major collection.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理旧生代是一项主要收集。
- en: Moving an object from one area of the young generation to another area of the
    young generation is a minor collection.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象从一个年轻代区域移动到另一个年轻代区域是轻微的收集。
- en: 'Select all of the correct statements:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The garbage collector can be tuned by setting the parameters of the `javac`
    command.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过设置`javac`命令的参数来调整垃圾回收器。
- en: The garbage collector can be tuned by setting the parameters of the `java` command.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收器可以通过设置`java`命令的参数进行调整。
- en: The garbage collector works with its logic and cannot change its behavior based
    on the set parameters.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收器根据其逻辑工作，不能根据设置的参数改变其行为。
- en: Cleaning the old generation area requires a stop-the-world pause.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理旧生代区域需要停止世界的暂停。
