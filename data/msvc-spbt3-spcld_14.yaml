- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Understanding Distributed Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分布式追踪
- en: In this chapter, we will learn how to use distributed tracing to better understand
    how our microservices cooperate, for example, in fulfilling a request sent to
    the external API. Being able to utilize distributed tracing is essential for being
    able to manage a system landscape of cooperating microservices. As already described
    in *Chapter 8*, *Introduction to Spring Cloud*, Micrometer Tracing will be used
    to collect trace information, and Zipkin will be used for the storage and visualization
    of said trace information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用分布式追踪更好地理解我们的微服务如何协作，例如，在完成发送到外部API的请求时。能够利用分布式追踪对于管理协作微服务的系统景观至关重要。正如已在*第8章*，*Spring
    Cloud简介*中描述的那样，Micrometer Tracing将被用于收集追踪信息，而Zipkin将被用于存储和可视化这些追踪信息。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Introducing distributed tracing with Micrometer Tracing and Zipkin.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Micrometer Tracing和Zipkin引入分布式追踪。
- en: How to add distributed tracing to the source code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将分布式追踪添加到源代码中。
- en: How to programmatically add information to the traces.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以编程方式向追踪添加信息。
- en: How to perform distributed tracing, visualizing both successful and unsuccessful
    API requests. We will see how both synchronous and asynchronous processing can
    be visualized.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行分布式追踪，可视化成功和失败的API请求。我们将看到同步和异步处理如何被可视化。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS的安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter14`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自`$BOOK_HOME/Chapter14`的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add distributed tracing using Micrometer Tracing
    and Zipkin, you can compare it with the source code for *Chapter 13*, *Improving
    Resilience Using Resilience4j*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter13` and `$BOOK_HOME/Chapter14`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，即查看如何使用Micrometer Tracing和Zipkin添加分布式追踪，你可以将其与*第13章*，*使用Resilience4j提高弹性*的源代码进行比较。你可以使用你喜欢的`diff`工具比较两个文件夹，`$BOOK_HOME/Chapter13`和`$BOOK_HOME/Chapter14`。
- en: Introducing distributed tracing with Micrometer Tracing and Zipkin
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Micrometer Tracing和Zipkin引入分布式追踪
- en: 'To recapitulate *Chapter 8*, *Introduction to Spring Cloud*, in reference to
    the *Using Micrometer Tracing and Zipkin for distributed tracing* section, the
    tracing information from a complete workflow is called a **trace** or a **trace
    tree**, and sub-parts of the tree, for example, the basic units of work, are called
    **spans**. Spans can consist of sub-spans forming the trace tree. Metadata can
    be added to a trace and its spans as key-value pairs called **tags**. The Zipkin
    UI can visualize a trace tree and its spans as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾*第8章*，*Spring Cloud简介*中关于*使用Micrometer Tracing和Zipkin进行分布式追踪*的部分，一个完整工作流程的追踪信息被称为**追踪**或**追踪树**，而树中的子部分，例如工作的基本单元，被称为**跨度**。跨度可以由形成追踪树的子跨度组成。可以在追踪及其跨度中添加元数据，作为键值对称为**标签**。Zipkin
    UI可以如下可视化追踪树及其跨度：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_14_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_14_01.png)'
- en: 'Figure 14.1: Example of a trace with its spans'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：带有其跨度的追踪示例
- en: Micrometer Tracing is used to collect trace information, propagate trace contexts
    (for example, trace and span IDs) in calls to other microservices and export the
    trace information into trace analysis tools like Zipkin. The handling of the trace
    information is done under the hood, by a **tracer**. Micrometer supports auto-configuration
    of tracers based on **OpenTelemetry** ([https://opentelemetry.io/](https://opentelemetry.io/))
    or **OpenZipkin Brave (**[https://github.com/openzipkin/brave](https://github.com/openzipkin/brave)**)**.
    Exporting the trace information into a trace analysis tool is done by a **reporter**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer跟踪用于收集跟踪信息，在调用其他微服务时传播跟踪上下文（例如，跟踪和跨度ID），并将跟踪信息导出到像Zipkin这样的跟踪分析工具。跟踪信息的处理是在底层由**跟踪器**完成的。Micrometer支持基于**OpenTelemetry**([https://opentelemetry.io/](https://opentelemetry.io/))或**OpenZipkin
    Brave**([https://github.com/openzipkin/brave](https://github.com/openzipkin/brave))的自动配置跟踪器。将跟踪信息导出到跟踪分析工具是由**报告器**完成的。
- en: By default, trace headers are propagated between microservices using **W3C trace
    context** headers ([https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/)),
    most importantly the `traceparent` header, but can be configured to use OpenZipkin’s
    `B3` headers. In this chapter, we will use the W3C trace context headers. In *Chapter
    18,* we will use the `B3` headers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，跟踪头通过使用**W3C跟踪上下文**头（[https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/))在微服务之间传播，最重要的是`traceparent`头，但也可以配置为使用OpenZipkin的`B3`头。在本章中，我们将使用W3C跟踪上下文头。在*第18章*中，我们将使用`B3`头。
- en: 'A sample W3C trace context `traceparent` header looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例W3C跟踪上下文`traceparent`头看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The value of the `traceparent` header contains four parts, separated by a `-`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceparent`头的值包含四个部分，由`-`分隔：'
- en: '`00`, indicates the version used. Will always be “`00`" using the current specification.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`，表示使用的版本。根据当前规范，始终是“`00`"。'
- en: '`124…810`, is the trace ID.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`124…810`是跟踪ID。'
- en: '`fbe…b20` is the span ID.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fbe…b20`是跨度ID。'
- en: '`01`, the last part, contains various flags. The only flag supported by the
    current specification is a flag named `sampled`, with the value `01`. It means
    that the caller is recording the trace data for this request. We will configure
    our microservices to record trace data for all requests, so this flag will always
    have the value of `01`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`，最后一部分包含各种标志。当前规范支持的唯一标志是名为`sampled`的标志，其值为`01`。这意味着调用者正在记录此请求的跟踪数据。我们将配置我们的微服务以记录所有请求的跟踪数据，因此此标志始终具有`01`的值。'
- en: 'Use of OpenZipkin Brave `B3` headers will look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenZipkin Brave `B3`头的样子如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The header names are self-explanatory, and we can see that headers are not only
    provided for the trace and span ID but also for the parent span’s ID.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 头名称是自解释的，我们可以看到头不仅提供了跟踪和跨度ID，还提供了父跨度ID。
- en: Traces and spans are created automatically by Spring Boot for incoming traffic,
    both for incoming HTTP requests and messages received by Spring Cloud Stream.
    If an incoming request contains a trace ID, it will be used when creating spans;
    if not, a new trace id will be created. Trace and span IDs are automatically propagated
    to outgoing traffic, either as HTTP requests or by sending messages using Spring
    Cloud Stream.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪和跨度由Spring Boot自动为传入流量创建，无论是传入的HTTP请求还是Spring Cloud Stream接收到的消息。如果传入请求包含跟踪ID，它将在创建跨度时使用；如果没有，将创建一个新的跟踪ID。跟踪和跨度ID将自动传播到传出流量，无论是作为HTTP请求还是通过使用Spring
    Cloud Stream发送消息。
- en: If required, extra trace info can be added programmatically, either by adding
    custom spans or by adding custom tags to all spans created by a microservice.
    This is done by using **Micrometer Observability** ([https://micrometer.io/docs/observation](https://micrometer.io/docs/observation))
    and its `Observation` API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以通过编程方式添加额外的跟踪信息，无论是通过添加自定义跨度，还是通过向由微服务创建的所有跨度添加自定义标签。这是通过使用**Micrometer可观察性**([https://micrometer.io/docs/observation](https://micrometer.io/docs/observation))及其`Observation`
    API来完成的。
- en: The initial release of Micrometer Tracing together with Spring Boot 3 came with
    some limitations for supporting distributed tracing in reactive clients. This
    affects the microservices used in this book that use Project Reactor under the
    hood. In the section *Adding workarounds for lacking support of reactive clients*,
    we will learn how to mitigate these shortcomings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer跟踪的初始版本与Spring Boot 3一起发布时，在支持反应式客户端的分布式跟踪方面存在一些限制。这影响了本书中使用的底层使用Project
    Reactor的微服务。在*添加对反应式客户端缺乏支持的解决方案*部分，我们将学习如何缓解这些不足。
- en: Zipkin comes with native support for storing trace information either in memory,
    or in a database such as Apache Cassandra, Elasticsearch, or MySQL. Added to this,
    a number of extensions are available. For details, refer to [https://zipkin.io/pages/extensions_choices.html](https://zipkin.io/pages/extensions_choices.html).
    In this chapter, we will store the trace information in memory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 内置了对存储跟踪信息原生的支持，无论是存储在内存中，还是存储在 Apache Cassandra、Elasticsearch 或 MySQL
    等数据库中。除此之外，还有许多扩展可用。有关详细信息，请参阅 [https://zipkin.io/pages/extensions_choices.html](https://zipkin.io/pages/extensions_choices.html)。在本章中，我们将存储跟踪信息在内存中。
- en: With Micrometer Tracing and Zipkin introduced, let’s see what changes are required
    in the source code to enable distributed tracing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入 Micrometer 跟踪和 Zipkin 之后，让我们看看在源代码中需要做出哪些更改才能启用分布式跟踪。
- en: Adding distributed tracing to the source code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将分布式跟踪添加到源代码
- en: 'In this section, we will learn how to update the source code to enable distributed
    tracing. This can be done with the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何更新源代码以启用分布式跟踪。这可以通过以下步骤完成：
- en: Add dependencies to the build files to bring in Micrometer Tracing with a tracer
    implementation and a reporter.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将依赖项添加到构建文件中，以引入带有跟踪器实现和报告器的 Micrometer 跟踪。
- en: Add a Zipkin server to the Docker Compose files.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Zipkin 服务器添加到 Docker Compose 文件中。
- en: Configure the microservices to send trace information to Zipkin.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置微服务以将跟踪信息发送到 Zipkin。
- en: Add workarounds for the lacking support of reactive clients.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为缺乏对反应式客户端的支持添加解决方案。
- en: Add code for creating custom spans and custom tags in existing spans.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有跨度中添加创建自定义跨度自定义标签的代码。
- en: We will go through each of the steps in turn.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次介绍每个步骤。
- en: Adding dependencies to build files
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将依赖项添加到构建文件中。
- en: To be able to utilize Micrometer Tracing and the ability to export trace information
    to Zipkin, we need to add a dependency to the selected tracer and reporter to
    the Gradle project build files, `build.gradle`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够利用 Micrometer 跟踪和将跟踪信息导出到 Zipkin 的能力，我们需要将所选跟踪器和报告器的依赖项添加到 Gradle 项目构建文件
    `build.gradle` 中。
- en: 'This is accomplished by adding the following two lines:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过添加以下两行来完成：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the review service, a dependency has also been added to enable trace information
    regarding SQL database operations. It looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于审查服务，还添加了一个依赖项以启用有关 SQL 数据库操作的跟踪信息。它看起来像：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This library can create spans for the SQL operations executed by the review
    service. These spans will contain information about the SQL query that was executed
    and its execution time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库可以为审查服务执行的 SQL 操作创建跨度。这些跨度将包含有关已执行的 SQL 查询及其执行时间的信息。
- en: Adding configuration for Micrometer Tracing and Zipkin
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Micrometer 跟踪和 Zipkin 的配置
- en: 'Configuration for using Micrometer Tracing and Zipkin is added to the common
    configuration file, `config-repo/application.yml`. In the default profile, it
    is specified that trace information will be sent to Zipkin using the following
    URL:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Micrometer 跟踪和 Zipkin 的配置已添加到通用配置文件 `config-repo/application.yml` 中。在默认配置文件中，指定了跟踪信息将通过以下
    URL 发送到 Zipkin：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By default, Micrometer Tracing only sends 10% of the traces to Zipkin. To ensure
    that all traces are sent to Zipkin, the following property is added to the default
    profile:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Micrometer 跟踪只发送 10% 的跟踪到 Zipkin。为了确保所有跟踪都发送到 Zipkin，以下属性被添加到默认配置文件中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We also want trace and span IDs to be written to logs; this will enable us to
    correlate log output from cooperating microservices that, for example, fulfill
    a request sent to the external API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将跟踪和跨度 ID 写入日志；这将使我们能够关联来自协作微服务的日志输出，例如，满足发送到外部 API 的请求。
- en: We will investigate how to use this in *Chapter 19**, Centralized Logging with
    the EFK Stack*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 19 章* 中研究如何使用它，即使用 EFK 栈进行集中式日志记录。
- en: 'We can include the trace and span IDs in the log output by specifying the following
    log format:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定以下日志格式来在日志输出中包含跟踪和跨度 ID：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the above log format, the log output will look like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述日志格式，日志输出将如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Where `product-composite` is the name of the microservice, `01234` is the trace
    ID, and `56789` is the span ID.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite` 是微服务的名称，`01234` 是跟踪 ID，`56789` 是跨度 ID。'
- en: 'To reduce the log output, we also change the log level from `DEBUG` to `INFO`
    for each microservice’s configuration file in the `config-repo`. This makes it
    easier to verify that trace and span IDs are added as expected. This change is
    applied by the line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少日志输出，我们还更改了 `config-repo` 中每个微服务的配置文件的日志级别，从 `DEBUG` 更改为 `INFO`。这使得验证跟踪和跨度
    ID 是否按预期添加变得更加容易。此更改通过以下行应用：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the `product-composite` microservice, the log level for the `HttpWebHandlerAdapter`
    class has been changed from `TRACE` to `INFO` for the same reason:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `product-composite` 微服务，由于相同的原因，`HttpWebHandlerAdapter` 类的日志级别已从 `TRACE`
    更改为 `INFO`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding Zipkin to the Docker Compose files
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Zipkin 添加到 Docker Compose 文件中
- en: 'To run the Zipkin server as a Docker container, we will use a Docker image,
    `openzipkin/zipkin`, published by the Zipkin project. Refer to [https://hub.docker.com/r/openzipkin/zipkin](https://hub.docker.com/r/openzipkin/zipkin)
    for details. The definition of the Zipkin server appears as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Zipkin 服务器作为 Docker 容器运行，我们将使用 Zipkin 项目发布的 Docker 镜像 `openzipkin/zipkin`。有关详细信息，请参阅
    [https://hub.docker.com/r/openzipkin/zipkin](https://hub.docker.com/r/openzipkin/zipkin)。Zipkin
    服务器的定义如下：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s explain the preceding source code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下前面的源代码：
- en: The version of the Docker image, `openzipkin/zipkin`, is specified to be version
    2.24.0.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像 `openzipkin/zipkin` 的版本指定为 2.24.0。
- en: The `STORAGE_TYPE=mem` environment variable is used to specify that Zipkin will
    keep all trace information in memory.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `STORAGE_TYPE=mem` 环境变量来指定 Zipkin 将在内存中保留所有跟踪信息。
- en: The memory limit for Zipkin is increased to 1,024 MB, compared to 512 MB for
    all other containers. The reason for this is that since Zipkin is configured to
    keep all trace information in memory, it will consume more memory than the other
    containers after a while.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin 的内存限制增加到 1,024 MB，而所有其他容器的内存限制为 512 MB。原因是 Zipkin 被配置为在内存中保留所有跟踪信息，因此一段时间后它将比其他容器消耗更多的内存。
- en: If Zipkin happens to run out of memory and stops, we have applied a restart
    policy that requests the Docker engine to always restart the container. This will
    apply both if the container itself crashes or if the Docker engine is restarted.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Zipkin 碰巧耗尽内存并停止，我们已经应用了一个重启策略，要求 Docker 引擎始终重启容器。这既适用于容器本身崩溃的情况，也适用于 Docker
    引擎重启的情况。
- en: Zipkin exposes the HTTP port `9411` for web browsers to access its web user
    interface.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin 将 HTTP 端口 `9411` 暴露给网络浏览器，以便访问其网络用户界面。
- en: While it is OK to store the trace information in Zipkin in memory for development
    and test activities, Zipkin should be configured to store trace information in
    a database in a production environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在开发和测试活动中将跟踪信息存储在 Zipkin 的内存中是可以的，但 Zipkin 应该配置为在生产环境中将跟踪信息存储在数据库中。
- en: Adding workarounds for lacking support of reactive clients
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对缺乏反应式客户端支持的解决方案
- en: As mentioned above, the current versions of Spring Boot, Project Reactor, and
    Micrometer Tracing do not yet work together perfectly. Therefore, a couple of
    workarounds have been applied to the source code for reactive clients. That is,
    the four microservices and the gateway. The problems are mainly related to the
    complexity of propagating trace contexts (for example, trace and span IDs) between
    different threads involved in reactive asynchronous processing, specifically if
    parts of the processing involve imperative synchronous processing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，当前版本的 Spring Boot、Project Reactor 和 Micrometer Tracing 还未完全协同工作。因此，已经对反应式客户端的源代码应用了一些解决方案。也就是说，四个微服务和网关。问题主要与在反应式异步处理中涉及的不同线程之间传播跟踪上下文（例如跟踪和跨度
    ID）的复杂性有关，特别是如果处理的部分涉及命令式同步处理。
- en: If all processing of a request is done with a synchronous implementation, using
    one and the same thread for all processing, propagating trace context is not an
    issue. A `ThreadLocal` variable can be used to store the trace context. The trace
    context can be retrieved from the `ThreadLocal` variable in any place of the implementation
    since all code runs in one and the same thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个请求的所有处理都使用同步实现，即使用同一个线程进行所有处理，那么传播跟踪上下文不是问题。可以使用 `ThreadLocal` 变量来存储跟踪上下文。由于所有代码都在同一个线程中运行，因此可以在实现中的任何地方从
    `ThreadLocal` 变量中检索跟踪上下文。
- en: An example of this mix of reactive and imperative processing is the implementation
    of the `review` microservice, where calls to the underlying SQL database are done
    synchronously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反应式和命令式处理混合的例子是 `review` 微服务的实现，其中对底层 SQL 数据库的调用是同步进行的。
- en: 'If you are interested in understanding the challenges in more detail, see the
    three-part blog series “*Unified Bridging between Reactive and Imperative*” published
    by the Spring team. It can be found here: [https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive](https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更详细地了解挑战，请参阅Spring团队发布的“*统一连接反应式和非反应式*”三篇博客系列。它可以在以下链接找到：[https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive](https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive)。
- en: It is also worth noting that the predecessor of Micrometer Tracing, Spring Cloud
    Sleuth, has better support for reactive clients than the current versions of Spring
    Boot, Project Reactor, and Micrometer Tracing. Hopefully, the coming versions
    will soon address these shortcomings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Micrometer Tracing的前身Spring Cloud Sleuth比当前版本的Spring Boot、Project Reactor和Micrometer
    Tracing对反应式客户端的支持更好。希望即将推出的版本将很快解决这些不足。
- en: 'If you have a code base that already uses Spring Cloud Sleuth, you can find
    migration guidelines here: [https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide](https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个已经使用Spring Cloud Sleuth的代码库，你可以在以下链接找到迁移指南：[https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide](https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide)。
- en: 'To address many of the challenges with context propagation, we can turn on
    automatic context propagation by calling the method `Hooks.enableAutomaticContextPropagation()`
    in a reactive client’s `main()` method. For details, see the blog series “*Unified
    Bridging between Reactive and Imperative*” referred to above. For the `product-composite`
    service, it looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决上下文传播的许多挑战，我们可以在反应式客户端的`main()`方法中调用`Hooks.enableAutomaticContextPropagation()`方法来开启自动上下文传播。有关详细信息，请参阅上述提到的“*统一连接反应式和非反应式*”博客系列。对于`product-composite`服务，它看起来是这样的：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, for the `product-composite` service, one problem remains. To ensure
    that a `WebClient` instance is correctly instrumented for observation, for example,
    to be able to propagate the current trace and span IDs as headers in an outgoing
    request, the `WebClient.Builder` instance is expected to be injected using auto-wiring.
    Unfortunately, when using Eureka for service discovery, the `WebClient.Builder`
    instance is recommended to be created as a bean annotated with `@LoadBalanced`
    as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`product-composite`服务，仍然存在一个问题。为了确保`WebClient`实例被正确地用于观察，例如，能够将当前的跟踪和跨度ID作为出站请求的头部传播，期望使用自动装配将`WebClient.Builder`实例注入。不幸的是，当使用Eureka进行服务发现时，建议将`WebClient.Builder`实例创建为一个带有`@LoadBalanced`注解的bean，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, there is a conflict in how to create a `WebClient` instance when used with
    both Eureka and Micrometer Tracing. To resolve this conflict, the `@LoadBalanced`
    bean can be replaced by a load-balancer-aware exchange-filter function, `ReactorLoadBalancerExchangeFilterFunction`.
    An exchange-filter function can be set on an auto-wired `WebClient.Builder` instance
    like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用Eureka和Micrometer Tracing时创建`WebClient`实例的方式存在冲突。为了解决这个冲突，可以将`@LoadBalanced`
    bean替换为一个负载均衡器感知的交换过滤器函数`ReactorLoadBalancerExchangeFilterFunction`。可以在自动装配的`WebClient.Builder`实例上设置交换过滤器函数，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that the application class, `ProductCompositeServiceApplication`,
    registers a `WebClient` bean instead of a `WebClient.Builder` bean. This affects
    the `ProductCompositeIntegration` class; it now needs to auto-wire a `WebClient`
    bean instead of a `WebClient.Builder` bean.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序类`ProductCompositeServiceApplication`注册了一个`WebClient` bean而不是`WebClient.Builder`
    bean。这影响了`ProductCompositeIntegration`类；现在它需要自动装配一个`WebClient` bean而不是`WebClient.Builder`
    bean。
- en: To get access to the `ReactorLoadBalancerExchangeFilterFunction` function, a
    dependency to `org.springframework.cloud:spring-cloud-starter-loadbalancer` has
    been added to the build file, `build.gradle`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`ReactorLoadBalancerExchangeFilterFunction`函数，需要在构建文件`build.gradle`中添加对`org.springframework.cloud:spring-cloud-starter-loadbalancer`的依赖。
- en: Adding custom spans and custom tags to existing spans
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向现有跨度添加自定义跨度以及自定义标签
- en: Besides relying on the built-in support for creating traces and spans for the
    ongoing processing, we can also use the `Observation` API provided by Micrometer
    Observability to, for example, add our own spans or add custom tags to existing
    spans created by a microservice. The `Observation` API is implemented behind a
    Java interface with the same name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了依赖于内置的创建跟踪和跨度的支持，我们还可以使用Micrometer Observability提供的 `Observation` API，例如，添加我们自己的跨度或向由微服务创建的现有跨度添加自定义标签。`Observation`
    API是在具有相同名称的Java接口后面实现的。
- en: Let’s first see how to add a custom span, and after that, see how we can add
    custom tags to all spans created by a microservice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何添加自定义跨度，然后看看我们如何可以向由微服务创建的所有跨度添加自定义标签。
- en: 'For any observation to take place using the `Observation` API, observation
    objects need to be registered in an `ObservationRegistry` bean. An `ObservationRegistry`
    bean can be injected using auto-wiring like in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Observation` API进行任何观察，观察对象需要在一个 `ObservationRegistry` bean中注册。可以使用自动装配，如以下示例所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding a custom span
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义跨度
- en: To add a custom span, the `Observation` interface provides a static method,
    `createNotStarted()`, that can be used to create a span. To execute the span,
    an `observe()` method can be used to provide the code that the span shall cover.
    If the code doesn’t return any value, it can be specified as a `Runnable` function;
    otherwise, it needs to be specified as a `Supplier` function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加自定义的跨度，`Observation` 接口提供了一个静态方法 `createNotStarted()`，可以用来创建跨度。要执行跨度，可以使用
    `observe()` 方法提供跨度应覆盖的代码。如果代码不返回任何值，它可以指定为一个 `Runnable` 函数；否则，需要指定为一个 `Supplier`
    函数。
- en: 'An example of the creation of a custom span for the execution of a minimalistic
    `Supplier` function looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于执行最小化 `Supplier` 函数的自定义跨度的示例如下：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `registry` parameter is a bean of type `ObservationRegistry` and is auto-wired
    as described above.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`registry` 参数是一个类型为 `ObservationRegistry` 的bean，并且如上所述自动装配。'
- en: 'The execution of this code will result in log output like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码将产生如下日志输出：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the log output, we can see that both log statements refer to the same trace
    ID, `9761b2b2b2da59c5096e78252c48ab3d`, but specifies different span IDs, `d8bcbd9cde9fe2d7`
    being the span ID of the custom span!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志输出中，我们可以看到这两个日志语句都引用了相同的跟踪ID，`9761b2b2b2da59c5096e78252c48ab3d`，但指定了不同的跨度ID，`d8bcbd9cde9fe2d7`
    是自定义跨度的跨度ID！
- en: If we want to add metadata regarding the span, we can specify it by adding a
    contextual name and a set of tags as key-value pairs. The contextual name will
    be the name of the span and it can be used to identify the span when a trace tree
    is visualized in Zipkin. If the possible values for the information are bounded,
    limited to a finite number of alternatives, the tag should be specified using
    the `lowCardinalityKeyValue()` method. For unbounded values, the `highCardinalityKeyValue()`
    method should be used. Calling these methods will result in tags being added to
    the current span, while low-cardinality values will also be tagged to metrics
    created by the observation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加有关跨度的元数据，我们可以通过添加上下文名称和一组键值对形式的标签来指定。上下文名称将是跨度的名称，并且可以在Zipkin中可视化跟踪树时用来识别跨度。如果信息的可能值是有限的，限制在有限数量的替代方案中，则应使用
    `lowCardinalityKeyValue()` 方法指定标签。对于无界值，应使用 `highCardinalityKeyValue()` 方法。调用这些方法将在当前跨度中添加标签，而低基数值也将被添加到由观察创建的指标中。
- en: We will investigate how to use metrics in *Chapter 20**, Monitoring Microservices*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究如何在**第20章**，监控微服务中，使用指标。
- en: 'An example of specifying information as tags looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息指定为标签的示例如下：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the example above, we can see that:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的示例中，我们可以看到：
- en: The contextual name is set to `"product info"`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文名称设置为 `"product info"`。
- en: A key, `"template-url"`, that only has a few possible values, is specified with
    the `lowCardinalityKeyValue()` method. In our case, it has only three possible
    values for the create, get, and delete methods.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lowCardinalityKeyValue()` 方法指定了一个只有几个可能值的键，`"template-url"`。在我们的案例中，它为创建、获取和删除方法提供了三个可能的值。
- en: A key, `"actual-url"`, with an unlimited number of values depending on the specified
    `productId`, has been specified with the `highCardinalityKeyValue()` method.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `highCardinalityKeyValue()` 方法指定了一个键 `"actual-url"`，其值数量无限，取决于指定的 `productId`。
- en: 'Let’s apply this to the `product-composite` service to create a custom span
    that provides the `productId` as a tag. Since the number of product IDs is unlimited,
    we will specify it using the `highCardinalityKeyValue()` method. We will create
    a span that specifies the current `productId` for each of the three API methods
    for creating, retrieving, and deleting composite products. The creation of a custom
    span that contains one high-cardinality tag is handled by a utility class, `ObservationUtil`.
    The utility class is placed in the package `se.magnus.microservices.composite.product.services.tracing`.
    The utility method `observe()` in this class looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此应用于 `product-composite` 服务，创建一个提供 `productId` 作为标签的自定义跨度。由于产品 ID 的数量是无限的，我们将使用
    `highCardinalityKeyValue()` 方法指定它。我们将创建一个指定每个三个 API 方法（创建、检索和删除复合产品）的当前 `productId`
    的跨度。包含一个高基数标签的自定义跨度的创建由实用类 `ObservationUtil` 处理。实用类位于包 `se.magnus.microservices.composite.product.services.tracing`
    中。该类中的实用方法 `observe()` 看起来是这样的：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `observe()` method wraps the call to the method `Observation.createNotStarted()`.
    The use of this method is explained in the example above, so it needs no further
    explanation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`observe()` 方法包装了对 `Observation.createNotStarted()` 方法的调用。该方法的用法在上面的示例中已解释，因此无需进一步解释。'
- en: 'This utility method is used in the `ProductCompositeServiceImpl` class by a
    helper method `observationWithProductInfo()` that applies common values to the
    `ProductCompositeServiceImpl` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用方法由 `ProductCompositeServiceImpl` 类中的辅助方法 `observationWithProductInfo()`
    使用，该方法将常用值应用于 `ProductCompositeServiceImpl` 类：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, the helper method is used by the three API methods, `createProduct()`,
    `getProduct()`, and `deleteProduct()`. The custom span is created by wrapping
    the existing code in each method. The existing code has been moved to corresponding
    “internal” methods to simplify the structure of the solution. The “internal” methods
    are called by the `observationWithProductInfo()` method. For the `getProduct()`,
    the implementation now looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，辅助方法被三个 API 方法 `createProduct()`、`getProduct()` 和 `deleteProduct()` 使用。自定义跨度是通过在每个方法中包装现有代码创建的。现有代码已被移动到相应的“内部”方法以简化解决方案的结构。“内部”方法由
    `observationWithProductInfo()` 方法调用。对于 `getProduct()`，实现现在看起来是这样的：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If compared with the corresponding implementation in *Chapter 13*, we can see
    that the changes required to create a custom span are limited to adding a new
    “*inner*” method and calling it from the `observationWithProductInfo()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与第 13 章中的相应实现进行比较，我们可以看到创建自定义跨度所需的变化仅限于添加一个新的“*内部*”方法，并从 `observationWithProductInfo()`
    方法调用它：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, adding a custom span to existing code can be made with a very small change,
    given a proper utility method that handles the details of setting up a custom
    span. When we try out the distributed tracing later in this chapter, we will see
    this custom span in action. With a custom span in place, let’s see how we can
    add custom tags to any span created in a microservice!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过提供一个适当的实用方法来处理设置自定义跨度的细节，我们可以通过非常小的更改将自定义跨度添加到现有代码中。当我们在本章后面尝试分布式跟踪时，我们将看到这个自定义跨度的实际应用。有了自定义跨度，让我们看看我们如何向微服务中创建的任何跨度添加自定义标签！
- en: Adding custom tags to existing spans
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向现有跨度添加自定义标签
- en: If we want to add some custom information to all spans that are created by a
    microservice, we can use an `ObservationFilter`. It needs to be registered in
    the `ObservationRegistry` bean using an `ObservationRegistryCustomizer` bean.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向由微服务创建的所有跨度添加一些自定义信息，我们可以使用 `ObservationFilter`。它需要使用 `ObservationRegistryCustomizer`
    Bean 在 `ObservationRegistry` Bean 中注册。
- en: 'Let’s apply a filter that registers the current version of the `product-composite`
    microservice as a tag on every span it creates. We need to do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用一个过滤器，将 `product-composite` 微服务的当前版本注册为标签，应用于它创建的每个跨度。我们需要做以下事情：
- en: Update the build file to make Gradle create build info, including the current
    version specified by the `version` property in the `build.gradle` file.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新构建文件，以便 Gradle 创建构建信息，包括在 `build.gradle` 文件中由 `version` 属性指定的当前版本。
- en: Create a filter that adds the current version as a low-cardinality tag to all
    spans.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个过滤器，将当前版本作为低基数标签添加到所有跨度中。
- en: Create a registry configuration bean that registers the filter.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个注册配置 Bean，用于注册该过滤器。
- en: 'To make Gradle create build info, the following is added to the build file,
    `build.gradle`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Gradle 创建构建信息，以下内容被添加到构建文件 `build.gradle` 中：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This addition will result in the file `build/resources/main/META-INF/build-info.properties`
    being created when the `./gradlew build` command is executed. This file will specify
    the current version as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`./gradlew build`命令时，这将导致创建文件`build/resources/main/META-INF/build-info.properties`。此文件将指定当前版本为：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The build info file will be bundled into the microservice’s JAR file, and its
    information can be accessed using a `BuildProperties` bean.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 构建信息文件将被捆绑到微服务的JAR文件中，其信息可以通过`BuildProperties` Bean访问。
- en: 'The filter looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器看起来像这样：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the source code above, we can see that:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的源代码中，我们可以看到：
- en: A `BuildProperties` bean is injected into the filter’s constructor.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`BuildProperties` Bean被注入到过滤器的构造函数中。
- en: The filter’s `map()` method retrieves the microservice version from using the
    `BuildProperties` bean and sets it as a low-cardinality tag on the provided observation
    context.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器的`map()`方法从`BuildProperties` Bean中检索微服务版本，并将其设置为提供的观察上下文上的低基数标签。
- en: 'The registry configuration bean looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注册配置Bean看起来像这样：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From the source code above, we can learn that:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的源代码中，我们可以了解到：
- en: A `BuildProperties` bean is also injected into the configuration class’s constructor.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildProperties` Bean也被注入到配置类的构造函数中。'
- en: In the `customize()` method, the filter is created and registered. The filter
    also gets the `BuildProperties` bean injected here.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`customize()`方法中，创建并注册了过滤器。过滤器还在这里注入了`BuildProperties` Bean。
- en: The filter and the registry configuration bean can be found in the `se.magnus.microservices.composite.product.services.tracing`
    package. When we try out the distributed tracing later in this chapter, we will
    see this observation filter in action.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器和注册配置Bean可以在`se.magnus.microservices.composite.product.services.tracing`包中找到。当我们在本章后面尝试分布式跟踪时，我们将看到这个观察过滤器的作用。
- en: For more ways of handling custom spans, for example, setting up predicates for
    when to apply an observation filter or using annotations to describe an observation,
    see [https://micrometer.io/docs/observation](https://micrometer.io/docs/observation).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于处理自定义跨度更多的方式，例如，设置何时应用观察过滤器的谓词或使用注解来描述观察，请参阅[https://micrometer.io/docs/observation](https://micrometer.io/docs/observation)。
- en: That’s what it takes to add distributed tracing using Micrometer Tracing and
    Zipkin, so let’s try it out in the next section!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Micrometer Tracing和Zipkin添加分布式跟踪所需的所有步骤，所以让我们在下一节中尝试一下！
- en: Trying out distributed tracing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试分布式跟踪
- en: 'With the necessary changes to the source code in place, we can try out distributed
    tracing. We will do this by performing the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中进行必要的更改后，我们可以尝试分布式跟踪。我们将通过以下步骤来完成：
- en: Build, start, and verify the system landscape.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建、启动和验证系统景观。
- en: Send a successful API request and see what trace information we can find in
    Zipkin related to this API request.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个成功的API请求并查看在Zipkin中与该API请求相关的跟踪信息。
- en: Send an unsuccessful API request and see what error information we can find.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个失败的API请求并查看我们可以找到的错误信息。
- en: Send a successful API request that triggers asynchronous processing and see
    how its trace information is represented.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个触发异步处理的成功API请求并查看其跟踪信息是如何表示的。
- en: We will discuss these steps in detail in the upcoming sections.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讨论这些步骤。
- en: Starting up the system landscape
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动系统景观
- en: 'Let’s start up the system landscape. Build the Docker images with the following
    commands:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动系统景观。使用以下命令构建Docker镜像：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the system landscape in Docker and run the usual tests with the following
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中启动系统景观并使用以下命令运行常规测试：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够调用API之前，我们需要一个访问令牌。运行以下命令以获取访问令牌：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As noticed in previous chapters, an access token issued by the authorization
    server is valid for one hour. So, if you start to get `401 Unauthorized` errors
    after a while, it is probably time to acquire a new access token.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，授权服务器颁发的访问令牌有效期为一个小时。因此，如果你过一会儿开始收到`401 未授权`错误，可能就是时候获取一个新的访问令牌了。
- en: Sending a successful API request
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送一个成功的API请求
- en: 'Now, we are ready to send a normal request to the API. Run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好向API发送正常请求。运行以下命令：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Expect the command to return the HTTP status code for success, `200`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 期望命令返回成功的HTTP状态码`200`。
- en: 'We can now launch the Zipkin UI to look into what trace information has been
    sent to Zipkin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启动Zipkin UI来查看已发送到Zipkin的跟踪信息：
- en: 'Open the following URL in your web browser: `http://localhost:9411/zipkin/`.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下URL：`http://localhost:9411/zipkin/`。
- en: 'To find the trace information for our request, we can search for traces that
    have passed through the `gateway` service. Perform the following steps:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到我们请求的跟踪信息，我们可以搜索通过`gateway`服务经过的跟踪。执行以下步骤：
- en: Click on the large plus sign (a white **+** sign on a red background) and select
    **serviceName** and then **gateway**.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击大加号（红色背景上的白色**+**号）并选择**serviceName**然后**gateway**。
- en: Click on the **RUN****QUERY** button.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**RUN****QUERY**按钮。
- en: Click on the **Start Time** header to see the results ordered by the latest
    first (a down arrow should be visible to the left of the **Start Time** header).
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始时间**标题以按最新顺序查看结果（**开始时间**标题左侧应可见向下箭头）。
- en: 'The response from finding traces should look like the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查找跟踪的响应应类似于以下截图：
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_02.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图描述自动生成](img/B19825_14_02.png)'
- en: 'Figure 14.2: Searching for distributed traces using Zipkin'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：使用Zipkin搜索分布式跟踪
- en: 'The trace information from our preceding API request is the first one in the
    list. Click on its **SHOW** button to see details pertaining to the trace:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们先前API请求的跟踪信息是列表中的第一个。点击其**SHOW**按钮以查看与跟踪相关的详细信息：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_14_03.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_14_03.png)'
- en: 'Figure 14.3: Sample distributed trace visualized in Zipkin'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：在Zipkin中可视化的示例分布式跟踪
- en: 'In the detailed trace information view, we can observe the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细的跟踪信息视图中，我们可以观察到以下内容：
- en: The request was received by the `gateway` service.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被`gateway`服务接收。
- en: The `gateway` service delegated the processing of the request to the `product-composite`
    service.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gateway`服务将请求的处理委托给了`product-composite`服务。'
- en: 'The `product-composite` service, in turn, sent three parallel requests to the
    core services: `product`, `recommendation`, and `review`. See spans named **product-composite:
    http get**.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product-composite`服务反过来向核心服务发送了三个并行请求：`product`、`recommendation`和`review`。查看名为**product-composite:
    http get**的跨度。'
- en: Once the `product-composite` service received the response from all three core
    services, it created a composite response and sent it back to the caller through
    the `gateway` service.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`product-composite`服务从所有三个核心服务收到响应，它就创建了一个组合响应并通过`gateway`服务将其发送回调用者。
- en: 'The custom span created in the previous section is named **product-composite:
    product info**. Click on it to see its tags. In the details view to the right,
    we can see both the tag created by the custom span, **productId = 1**, and the
    tag created by the observation filter **build.version = 1.0.0-SNAPSHOT**.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在上一节中创建的自定义跨度名为**product-composite: product info**。点击它以查看其标签。在右侧的详细信息视图中，我们可以看到由自定义跨度创建的标签**productId
    = 1**和由观察过滤器创建的标签**build.version = 1.0.0-SNAPSHOT**。'
- en: To verify that the tag created by the observation filter works as expected,
    click on other spans created by the `product-composite` service, and verify that
    the **build.version** is present.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证由观察过滤器创建的标签是否按预期工作，点击由`product-composite`服务创建的其他跨度，并验证**build.version**是否存在。
- en: 'Select the span named **review: query** to see a span reported by the `review`
    microservice’s database layer:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择名为**review: query**的跨度以查看由`review`微服务的数据库层报告的跨度：'
- en: '![Graphical user interface  Description automatically generated](img/B19825_14_04.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成](img/B19825_14_04.png)'
- en: 'Figure 14.4: A span that describes the execution of a SQL query'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：描述SQL查询执行的跨度
- en: In the span’s list of tags, we can see the actual SQL query it has performed.
    We can also see its execution time of 0.8 ms. Rather valuable information!
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在跨度的标签列表中，我们可以看到其实际执行的SQL查询。我们还可以看到其执行时间为0.8毫秒。非常有价值的信息！
- en: 'To better understand how trace and span IDs are propagated between microservices,
    we can change the logging configuration of the `product-composite` service so
    that HTTP headers in outgoing requests are written to its log. This can be achieved
    by taking the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解跟踪和跨度ID在微服务之间是如何传播的，我们可以更改`product-composite`服务的日志配置，以便将出站请求的HTTP头写入其日志。这可以通过以下步骤实现：
- en: 'Add the following two lines to the configuration file `config-repo/product-composite.yml`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两行添加到配置文件`config-repo/product-composite.yml`中：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The two lines already exist in the configuration file but are commented out.
    They are preceded by the following comment:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两行已经存在于配置文件中，但已被注释掉。它们前面有以下注释：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Find the preceding comment in the configuration file and uncomment the two lines
    below it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置文件中找到前面的注释，并取消注释其下方的两行。
- en: 'After that, restart the `product-composite` service:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，重新启动`product-composite`服务：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Display the log output from the `product-composite` service:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示`product-composite`服务的日志输出：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Rerun the above `curl` request and you will see the log output containing the
    `traceparent` HTTP header mentioned above. For example, a request sent to the
    `recommendation` service:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行上述`curl`请求，你将看到包含上述提到的`traceparent` HTTP头部的日志输出。例如，发送到`recommendation`服务的请求：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the sample log output, we can see the value of the `traceparent` HTTP header,
    where the trace ID is set to `e1420dcc38901378e888b8ce7022510e`, and the span
    ID is set to `06867b65cf84b552`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例日志输出中，我们可以看到`traceparent` HTTP头部的值，其中跟踪ID设置为`e1420dcc38901378e888b8ce7022510e`，而跨度ID设置为`06867b65cf84b552`。
- en: If you don’t want to keep the logging of the `traceparent` HTTP header, comment
    out the two lines in `config-repo/product-composite.yml` and restart the `product-composite`
    service.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你不想保留`traceparent` HTTP头部的日志记录，请在`config-repo/product-composite.yml`中注释掉两行，并重新启动`product-composite`服务。
- en: Sending an unsuccessful API request
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送一个不成功的API请求
- en: 'Let’s see what the trace information looks like if we make an unsuccessful
    API request; for example, searching for a product that causes a timeout:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们发起一个失败的API请求，跟踪信息会是什么样子；例如，搜索一个导致超时的产品：
- en: 'Send an API request for product ID `1` and enforce a delay of three seconds,
    which will trigger the time limiter, and verify that it returns the HTTP status
    code `500`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个针对产品ID `1`的API请求，并强制延迟三秒，这将触发时间限制器，并验证它返回的HTTP状态码为`500`：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the Zipkin UI, go back to the search page (use the back button in the web
    browser) and click on the **RUN QUERY** button again. To see the results ordered
    by the latest first, click on the **Start Time** header.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Zipkin UI中，返回到搜索页面（使用网络浏览器的后退按钮），然后再次点击**RUN QUERY**按钮。要按最新顺序查看结果，请点击**Start
    Time**标题。
- en: 'Expect a result similar to the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果将与以下截图类似：
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_05.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B19825_14_05.png)'
- en: 'Figure 14.5: Finding a failed request using Zipkin'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：使用Zipkin查找失败的请求
- en: 'You should see the failed request at the top of the returned list. Note that
    its duration bar is red, indicating that an error has occurred. Click on its **SHOW**
    button to see details:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会在返回列表的顶部看到失败的请求。注意，其持续时间条是红色的，表示发生了错误。点击其**SHOW**按钮查看详细信息：
- en: '![A screenshot of a computer error  Description automatically generated](img/B19825_14_06.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![计算机错误截图  自动生成的描述](img/B19825_14_06.png)'
- en: 'Figure 14.6: Viewing a trace of a failed request using Zipkin'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：使用Zipkin查看失败的请求的跟踪
- en: 'Here, we can see a span, **product-composite: secured request**, with an error
    symbol in front of it (a red circle with an exclamation mark).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们可以看到一个带有错误符号的跨度，**product-composite: secured request**（一个带有感叹号的红色圆圈）。'
- en: Click on the span to see its tags. You will find a tag named **error** that
    clearly indicates that the error is caused by a timeout that occurred after two
    seconds.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击跨度以查看其标签。你将找到一个名为**error**的标签，它清楚地表明错误是由两秒后发生的超时引起的。
- en: Sending an API request that triggers asynchronous processing
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送一个触发异步处理的API请求
- en: The third type of request that is interesting to see represented in the Zipkin
    UI is a request where parts of its processing are done asynchronously. Let’s try
    a delete request, where the delete process in the core services is done asynchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zipkin UI中，有趣的是看到第三种请求类型，这种请求的部分处理是异步完成的。让我们尝试一个删除请求，其中核心服务的删除过程是异步完成的。
- en: The `product-composite` service sends a delete event to each of the three core
    services over the message broker and each core service picks up the delete event
    and processes it asynchronously. Thanks to Micrometer Tracing, trace information
    is added to the events that are sent to the message broker, resulting in a coherent
    view of the total processing of the delete request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite`服务通过消息代理向三个核心服务的每个服务发送删除事件，每个核心服务都会接收到删除事件并异步处理它。多亏了Micrometer
    Tracing，跟踪信息被添加到发送到消息代理的事件中，从而形成了对删除请求总处理的连贯视图。'
- en: 'Perform the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Run the following command to delete the product with a product ID of `12345`
    and verify that it returns the HTTP status code for the request being accepted,
    `202`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以删除产品ID为`12345`的产品，并验证它返回请求被接受的HTTP状态码`202`：
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember that the delete operation is idempotent, that is, it will succeed even
    if the product doesn’t exist!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，删除操作是幂等的，也就是说，即使产品不存在，它也会成功！
- en: 'In the Zipkin UI, go back to the search page (use the back button in the web
    browser) and click on the **RUN QUERY** button again. To see the results ordered
    by the latest first, click on the **Start Time** header. Expect a result like
    the following screenshot:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Zipkin UI中，返回搜索页面（使用网络浏览器的后退按钮）并再次点击**运行查询**按钮。要按最新顺序查看结果，请点击**开始时间**标题。预期结果如下截图所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_07.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B19825_14_07.png)'
- en: 'Figure 14.7: Finding a delete request using Zipkin'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：使用Zipkin查找删除请求
- en: 'You should see the delete request at the top of the returned list. Note that
    the root service name, **gateway**, is suffixed by the HTTP method used, **delete**.
    Click on its **SHOW** button to see details:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在返回列表的顶部看到删除请求。请注意，根服务名称**gateway**由使用的HTTP方法**delete**后缀。点击其**显示**按钮以查看详细信息：
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_14_08.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B19825_14_08.png)'
- en: 'Figure 14.8: Viewing a delete request using Zipkin'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：使用Zipkin查看删除请求
- en: 'Here, we can see the trace information for processing the delete request:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到处理删除请求的跟踪信息：
- en: The request was received by the `gateway` service.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被`gateway`服务接收。
- en: The `gateway` service delegated the processing of the request to the `product-composite`
    service.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gateway`服务将请求的处理委托给了`product-composite`服务。'
- en: 'The `product-composite` service has created a custom span named **product-composite:
    product info**, as expected.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如预期，`product-composite`服务创建了一个名为**product-composite: product info**的自定义span。'
- en: The `product-composite` service, in turn, published three events on the message
    broker (RabbitMQ, in this case). See spans with names suffixed with **send**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`product-composite`服务在消息代理（在本例中为RabbitMQ）上发布了三个事件。查看以**send**结尾的span。
- en: The `product-composite` service is now done and returns an HTTP `success` status
    code, `200`, through the `gateway` service back to the caller. Note that this
    is done before all processing is completed by the core services!
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product-composite`服务现在已完成，并通过`gateway`服务返回给调用者一个HTTP `成功`状态码，`200`。请注意，这是在核心服务完成所有处理之前完成的！'
- en: The core services (`product`, `recommendation`, and `review`) receive the `delete`
    events and start to process them asynchronously, that is, independently of one
    another. See spans with names suffixed with **receive**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心服务（`product`、`recommendation`和`review`）接收`delete`事件并开始异步处理它们，即相互独立。查看以**receive**结尾的span。
- en: To confirm the involvement of the message broker, click on the first product
    span:![A screenshot of a computer  Description automatically generated](img/B19825_14_09.png)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认消息代理的参与，请点击第一个产品span：![计算机屏幕截图  自动生成描述](img/B19825_14_09.png)
- en: 'Figure 14.9: Viewing information about the asynchronous processing of an event
    using Zipkin'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.9：使用Zipkin查看事件异步处理的信息
- en: The selected span contains a tag named **peer.service** that reveals that RabbitMQ
    is used, and the tag **spring.rabbit.listener.id** points out that the messages
    are received by the consumer group **productsGroup**.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选定的span包含一个名为**peer.service**的标签，揭示了RabbitMQ的使用，而标签**spring.rabbit.listener.id**指出消息由消费者组**productsGroup**接收。
- en: Finally, to see the `traceparent` header in a message sent through RabbitMQ,
    we can inspect the message stored in the audit queue for the products. Open [http://localhost:15672/#/queues/%2F/products.auditGroup](http://localhost:15672/#/queues/%2F/products.auditGroup)
    in your web browser.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了在通过RabbitMQ发送的消息中查看`traceparent`头，我们可以检查存储在产品审计队列中的消息。在您的网页浏览器中打开[http://localhost:15672/#/queues/%2F/products.auditGroup](http://localhost:15672/#/queues/%2F/products.auditGroup)。
- en: 'Click on the button named **Get Messages(s)** to see the oldest message in
    the queue. The web page should look like the following:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击名为**Get Messages(s)**的按钮以查看队列中最旧的消息。网页应如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_14_10.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_14_10.png)'
- en: 'Figure 14.10: A message with a traceparent header in RabbitMQ'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：RabbitMQ中的带有traceparent头的消息
- en: In the **Properties** section, you will find the **traceparent** header for
    this message. In this case, the trace ID is **99a9f2501e4d454643184c6b1cb0a232**
    and the span ID is **7458430fe56d6df1**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**部分，您将找到此消息的**traceparent**头。在这种情况下，追踪ID是**99a9f2501e4d454643184c6b1cb0a232**，跨度ID是**7458430fe56d6df1**。
- en: This completes the tests of distributed tracing for this chapter!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本章的分布式追踪测试！
- en: The Zipkin UI contains much more functionality for finding traces of interest!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin UI包含更多用于查找感兴趣追踪的功能！
- en: To get more accustomed to the Zipkin UI, try out the query functionality by
    clicking on the plus sign and selecting **tagQuery**. For example, to find requests
    that failed on a `403 - Forbidden` error, set its value to `tagQuery=http.status_code=403`,
    searching for traces that failed on a Forbidden (`403`) error. Also, try setting
    limits for the lookback range (start and end time) and the maximum number of hits
    by clicking on the cogwheel icon to the right of the **RUN QUERY** button.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更熟悉Zipkin UI，通过点击加号并选择**tagQuery**来尝试查询功能。例如，为了找到在`403 - Forbidden`错误上失败的请求，将其值设置为`tagQuery=http.status_code=403`，搜索在禁止（`403`）错误上失败的追踪。还可以尝试通过点击**RUN
    QUERY**按钮右侧的齿轮图标来设置回溯范围（开始和结束时间）和最大命中数限制。
- en: 'Wrap up the tests by bringing down the system landscape. Run the following
    command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭系统环境来总结测试。运行以下命令：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use distributed tracing to understand how
    our microservices cooperate. We learned how to use Micrometer Tracing to collect
    trace information, and Zipkin to store and visualize the trace information.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用分布式追踪来理解我们的微服务是如何协作的。我们学习了如何使用Micrometer Tracing来收集追踪信息，以及使用Zipkin来存储和可视化追踪信息。
- en: We saw how adding Micrometer Tracing to microservices is affected by adding
    a couple of dependencies to the build files and setting up a few configuration
    parameters. Reactive microservices are currently not fully supported, but we learned
    how to work around the most important issues. If required, we can use the `Observation`
    API to create custom spans or add tags to all spans created by a microservice.
    We also saw how the Zipkin UI makes it very easy to identify which part of a complex
    workflow caused either an unexpectedly long response time or an error. Both synchronous
    and asynchronous workflows can be visualized with the Zipkin UI.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过在构建文件中添加几个依赖项并设置一些配置参数来将Micrometer Tracing添加到微服务中。目前，反应式微服务尚未完全支持，但我们学习了如何解决最重要的问题。如果需要，我们可以使用`Observation`
    API来创建自定义跨度或为微服务创建的所有跨度添加标签。我们还看到了Zipkin UI如何使识别复杂工作流中导致意外长响应时间或错误的特定部分变得非常容易。Zipkin
    UI可以可视化同步和异步工作流。
- en: In the next chapter, we will learn about container orchestrators, specifically
    Kubernetes. We will learn how to use Kubernetes to deploy and manage microservices,
    while also improving important runtime characteristics such as scalability, high
    availability, and resilience.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习容器编排器，特别是Kubernetes。我们将学习如何使用Kubernetes来部署和管理微服务，同时提高重要的运行时特性，如可伸缩性、高可用性和弹性。
- en: Questions
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of the `management.tracing.sampling.probability` configuration
    parameter?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`management.tracing.sampling.probability`配置参数的目的是什么？'
- en: How can you identify the longest-running request after executing the `test-em-all.bash`
    test script?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在执行`test-em-all.bash`测试脚本后识别运行时间最长的请求？
- en: How can we find requests that have been interrupted by a timeout introduced
    in *Chapter 13*, *Improving Resilience Using Resilience4j*?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何找到被*第13章*，*使用Resilience4j提高弹性*中引入的超时中断的请求？
- en: What does the trace look like for an API request when the circuit breaker introduced
    in *Chapter 13*, *Improving Resilience Using Resilience4j*, is open?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*第13章*，*使用Resilience4j提高弹性*中引入的断路器打开时，API请求的跟踪看起来是什么样子？
- en: How can we locate APIs that failed on the caller not being authorized to perform
    the request?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何定位那些在调用者未被授权执行请求时失败的API？
- en: How can we programmatically add trace information?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何以编程方式添加跟踪信息？
