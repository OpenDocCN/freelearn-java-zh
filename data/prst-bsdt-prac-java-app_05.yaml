- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Jakarta EE and JPA – State of Affairs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta EE 和 JPA – 状况
- en: 'Java, both in language and platform, has improved significantly in enabling
    an effective developer experience and creating highly performant stateful applications.
    Remarkable improvements become evident when examining the evolution of Java database
    integration capabilities and developer experience: look back to the introduction
    of `1.1` and compare it with the most modern experience offered by **Jakarta Enterprise
    Edition** (**Jakarta** **EE**), **MicroProfile**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java，无论是语言还是平台，在提供有效的开发体验和创建高性能的持久化应用方面都取得了显著进步。当检查 Java 数据库集成能力和开发体验的演变时，这些显著的改进变得显而易见：回顾一下
    `1.1` 的引入，并将其与 **Jakarta 企业版**（**Jakarta EE**）、**MicroProfile** 提供的最现代体验进行比较。
- en: This chapter presents an introduction and overview of the present and future
    of the main enablers of Java’s evolution and constant growth—Jakarta EE, formerly
    Java EE, and Eclipse MicroProfile. From one side, the Eclipse Foundation and Jakarta
    EE target enterprise organizations’ need for stability and reliability. Conversely,
    there’s Eclipse MicroProfile, with fast interactions and constant innovation.
    In parallel, the Jakarta EE platform keeps evolving and adopting comprehensive
    MicroProfile technologies. All this is happening as you read, so it’s time to
    finally comprehend what’s happening in the open community and what to expect from
    a data solution perspective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Java 进化和持续增长的主要推动者——Jakarta EE（以前称为 Java EE）和 Eclipse MicroProfile 的现在和未来。一方面，Eclipse
    基金会和 Jakarta EE 针对企业组织对稳定性和可靠性的需求。另一方面，有 Eclipse MicroProfile，它具有快速交互和持续创新。同时，Jakarta
    EE 平台也在不断发展和采用全面的 MicroProfile 技术。所有这些都在你阅读的同时发生，因此现在是时候最终理解开放社区正在发生的事情，以及从数据解决方案的角度可以期待什么了。
- en: Java engineers seeking to deliver scalable enterprise solutions that smoothly
    enable distributed architectures mostly rely on a platform that can support cloud-native
    and traditional solutions. In the corporate world, given the long-term adoption
    of Java, there’s a frequent requirement for flexible technologies that can bring
    the best out of existing technologies and infrastructure without giving up on
    the opportunity of delivering new cloud-native solutions. In this context, the
    Jakarta EE platform is a great choice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 寻求提供可扩展企业解决方案的 Java 工程师，这些解决方案能够平滑地启用分布式架构，通常依赖于一个能够支持云原生和传统解决方案的平台。在商业世界中，鉴于
    Java 的长期采用，经常需要灵活的技术，这些技术能够在不放弃提供新的云原生解决方案机会的情况下，最大限度地发挥现有技术和基础设施的潜力。在这种情况下，Jakarta
    EE 平台是一个很好的选择。
- en: The specification of Jakarta EE is huge and impacts the whole Java community;
    it is essential to highlight that if you’re using Spring, Micronaut, or Quarkus,
    you’re using Jakarta EE even indirectly. In this chapter, we’ll check the specifications
    that Jakarta EE covers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 的规范非常庞大，影响了整个 Java 社区；重要的是要强调，如果你在使用 Spring、Micronaut 或 Quarkus，即使间接地，你也在使用
    Jakarta EE。在本章中，我们将检查 Jakarta EE 覆盖的规范。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Jakarta EE overview
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta EE 概述
- en: Framework unveiled—reflection versus reflectionless solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架揭晓——反射与非反射解决方案
- en: '**Java Persistence API** (**JPA**) state of affairs'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 持久化 API**（**JPA**）状况'
- en: The power of JPA with Quarkus and Panache cloud-native runtimes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus 和 Panache 云原生运行时带来的 JPA 力量
- en: General JPA-related performance considerations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般 JPA 相关性能考虑
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Java 17
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: Git
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的集成开发环境（IDE）
- en: 'The code for this chapter can be found in the following GitHub repository:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 仓库中找到：
- en: "[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-05](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter\uFEFF\
    -05)"
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-05](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-05)'
- en: Jakarta EE overview
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta EE 概述
- en: At the heart of Jakarta EE lies its collection of specifications, each addressing
    specific aspects of enterprise architecture. These specifications, commonly called
    the “EE specifications,” are designed to cover various use cases encountered in
    enterprise application development. They provide standardized approaches and guidelines
    for implementing key functionalities, ensuring interoperability and portability
    across different implementations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 的核心是其一系列规范，每个规范都针对企业架构的特定方面。这些通常被称为“EE 规范”的规范旨在涵盖企业应用程序开发中遇到的各种用例。它们提供了实施关键功能的标准化方法和指南，确保在不同实现之间具有互操作性和可移植性。
- en: 'The Jakarta EE specifications cater to a broad spectrum of enterprise architecture
    needs, including the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 规范满足企业架构的广泛需求，包括以下方面：
- en: '**Web applications**: The Jakarta Servlet specification provides a platform-independent
    API for building web applications. It defines how web requests and responses are
    handled, allowing developers to create dynamic, interactive, secure web-based
    solutions.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 应用程序**: Jakarta Servlet 规范提供了一个平台无关的 API，用于构建 Web 应用程序。它定义了如何处理 Web 请求和响应，允许开发者创建动态、交互式、安全的基于
    Web 的解决方案。'
- en: '**Enterprise integration**: The **Jakarta Messaging** (**JMS**) specification
    provides a messaging system enabling seamless communication between distributed
    application components. It ensures a reliable and asynchronous exchange of information,
    facilitating integration across disparate systems.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业集成**: Jakarta 消息（JMS）规范提供了一个消息系统，使分布式应用程序组件之间的通信无缝。它确保了可靠和异步的信息交换，促进了不同系统之间的集成。'
- en: '**Persistence**: The JPA specification simplifies database access and manipulation
    by providing an **object-relational mapping** (**ORM**) framework. It allows developers
    to interact with relational databases using Java objects, abstracting the underlying
    SQL operations. We can include the Jakarta Bean Validation specification to define
    constraints on Java driven by annotations; further more, new specifications are
    coming to support NoSQL and **domain-driven design** (**DDD**) repositories.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**: JPA 规范通过提供一个 **对象关系映射**（ORM）框架简化了数据库访问和操作。它允许开发者使用 Java 对象与关系数据库进行交互，抽象了底层的
    SQL 操作。我们还可以包括 Jakarta Bean Validation 规范来定义由注解驱动的 Java 约束；此外，新的规范正在出现以支持 NoSQL
    和 **领域驱动设计**（DDD）存储库。'
- en: '**Dependency injection (DI)**: The Jakarta **Contexts Dependency Injection**
    (**CDI**) specification facilitates loose coupling and promotes modular development
    by managing object creation, wiring, and life cycle management. It enables the
    easy integration of different components within an application, enhancing maintainability
    and testability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入（DI）**: Jakarta 上下文依赖注入（CDI）规范通过管理对象创建、连接和生命周期管理来促进松散耦合并推动模块化开发。它使得在应用程序中轻松集成不同的组件成为可能，增强了可维护性和可测试性。'
- en: '**Security**: The Jakarta Security specification offers a comprehensive set
    of APIs and services for securing enterprise applications. It provides authentication,
    authorization, and data protection mechanisms, helping developers build secure
    applications and protect sensitive information.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**: Jakarta 安全规范提供了一套全面的 API 和服务，用于保护企业应用程序。它提供了身份验证、授权和数据保护机制，帮助开发者构建安全的应用程序并保护敏感信息。'
- en: '**RESTful web services**: The **Jakarta RESTful Web Services** (**JAX-RS**)
    specification simplifies the development of web services using the **Representational
    State Transfer** (**REST**) architectural style. It provides a set of annotations
    and APIs for building scalable, lightweight, and interoperable web APIs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful 网络服务**: Jakarta RESTful 网络服务（JAX-RS）规范简化了使用 **表示状态转换**（REST）架构风格开发网络服务的过程。它提供了一套注解和
    API，用于构建可扩展、轻量级和互操作的网络 API。'
- en: 'The following diagram shows an overview of Jakarta EE 10 API, where you see
    the huge number of specifications that can help you as a software engineer; another
    area of the diagram is related to profiles. Currently, there are three profiles
    that you can use based on your needs:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了 Jakarta EE 10 API 的概述，其中你可以看到大量可以帮助你作为软件工程师的规范；图表的另一个区域与配置文件相关。目前，根据你的需求，你可以使用三个配置文件：
- en: "![Figure 5.1 \uFEFF– Jakarta EE 10 specification](img/Figure_5.01_B19375.jpg)"
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Jakarta EE 10 规范](img/Figure_5.01_B19375.jpg)'
- en: Figure 5.1 – Jakarta EE 10 specification
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Jakarta EE 10 规范
- en: These are just a few examples of the extensive specifications available in Jakarta
    EE. Each specification addresses specific requirements, ensuring developers have
    the tools and guidelines to tackle various enterprise architecture challenges.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是Jakarta EE中广泛规范的一小部分示例。每个规范都针对特定需求，确保开发者拥有解决各种企业架构挑战的工具和指南。
- en: By adhering to Jakarta EE specifications, developers can create portable applications
    across different application servers and vendors, allowing flexibility and scalability.
    The specifications foster interoperability and compatibility, enabling seamless
    integration with other systems and services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Jakarta EE规范，开发者可以在不同的应用程序服务器和供应商之间创建可移植的应用程序，从而实现灵活性和可扩展性。这些规范促进了互操作性和兼容性，使得与其他系统和服务的无缝集成成为可能。
- en: Those specifications will help you with modern concepts, approaches, and architectural
    models. In the Jakarta EE 10 API, we have the CDI Lite specification, where the
    goal is to reduce reflection, but what is wrong with reflection? In the next section,
    let’s talk about this in more detail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规范将帮助您了解现代概念、方法和架构模型。在Jakarta EE 10 API中，我们有CDI Lite规范，其目标是减少反射，但反射有什么问题呢？在下一节中，我们将更详细地讨论这个问题。
- en: Framework unveiled – reflection versus reflectionless solutions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架揭晓——反射与非反射解决方案
- en: Java frameworks are crucial in simplifying and accelerating application development
    by providing reusable components, predefined structures, and standard methodologies.
    These frameworks encapsulate common functionalities and design patterns, allowing
    developers to focus on business logic rather than low-level implementation details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Java框架对于简化并加速应用程序开发至关重要，它们通过提供可重用组件、预定义结构和标准方法来实现这一点。这些框架封装了常见功能性和设计模式，使开发者能够专注于业务逻辑，而不是底层实现细节。
- en: One fundamental concept in Java programming and many Java frameworks is reflection.
    Reflection enables a program to examine and modify its structure and behavior
    at runtime dynamically. It provides a mechanism for inspecting and manipulating
    classes, interfaces, methods, and fields, even if they are unknown at compile
    time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程和许多Java框架中的一个基本概念是反射。反射允许程序在运行时动态地检查和修改其结构和行为。它提供了一种检查和操作类、接口、方法和字段的方法，即使它们在编译时未知。
- en: 'Reflection is essential to developers for several reasons. Here, we list some
    of these:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 反射对开发者来说至关重要，以下列出了一些原因：
- en: '**Dynamic code execution**: Reflection allows developers to instantiate classes,
    invoke methods, and access fields at runtime. This flexibility enables the creation
    of flexible, extensible, and customizable applications. For example, frameworks
    such as Spring and Hibernate heavily rely on reflection to dynamically create
    and wire dependencies, perform data mapping, and handle various aspects of application
    behavior.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态代码执行**：反射允许开发者动态地实例化类、调用方法和访问字段。这种灵活性使得创建灵活、可扩展和可定制的应用程序成为可能。例如，Spring和Hibernate等框架严重依赖反射来动态创建和连接依赖项、执行数据映射和处理应用程序行为的各个方面。'
- en: '**Metadata extraction**: Reflection enables the extraction of metadata associated
    with classes, methods, and fields. This metadata may include information such
    as annotations, modifiers, generic types, and method signatures. By analyzing
    this metadata, developers can implement advanced application functionalities and
    behavior. For instance, frameworks such as JUnit use reflection to discover and
    execute test cases based on annotations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据提取**：反射允许提取与类、方法和字段关联的元数据。这些元数据可能包括诸如注解、修饰符、泛型类型和方法签名等信息。通过分析这些元数据，开发者可以实现高级应用程序功能和行为。例如，JUnit等框架使用反射根据注解发现和执行测试用例。'
- en: '**Frameworks and annotations**: Java frameworks often utilize annotations,
    markers added to classes, methods, or fields to provide additional information
    or configure specific behaviors. Frameworks such as Spring, JPA, and Java Servlet
    extensively use annotations and reflection to simplify configuration and customization.
    Reflection allows frameworks to scan and process these annotations at runtime,
    enabling automatic configuration, DI, and **Aspect-Oriented** **Programming**
    (**AOP**).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和注解**：Java框架通常利用注解，即在类、方法或字段上添加的标记，以提供额外信息或配置特定行为。例如，Spring、JPA和Java Servlet等框架广泛使用注解和反射来简化配置和定制。反射允许框架在运行时扫描和处理这些注解，实现自动配置、依赖注入（DI）和**面向切面编程**（AOP）。'
- en: However, while reflection offers excellent flexibility and power, it can impact
    the performance of Java applications during startup. The process of introspecting
    classes and loading metadata dynamically can introduce significant overhead, especially
    in serverless or cloud-native environments where fast startup times are crucial.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管反射提供了卓越的灵活性和功能，但它可能会影响 Java 应用程序在启动时的性能。检查类和动态加载元数据的过程可能会引入显著的开销，尤其是在快速启动时间至关重要的无服务器或云原生环境中。
- en: Why does this matter? Native compilation for Java applications
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要？Java 应用的原生编译
- en: A great example is the creation of natively executable Java applications, where
    developers use **Java virtual machines** (**JVMs**) such as GraalVM (Oracle) and
    Mandrel (Red Hat) to compile these applications and generate native binaries.
    This process, based on **ahead-of-time** (**AOT**) compilation, results in the
    inability to use some behaviors during runtime—including reflection. The AOT compiler
    does static code analysis during build time to create a native executable, which
    means that all processing done via dynamic loading (such as reflection, the **Java
    Native Interface** (**JNI**), or proxies) represents potential issues for this
    use case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是创建原生可执行 Java 应用程序，其中开发者使用 **Java 虚拟机**（**JVM**）如 GraalVM（Oracle）和 Mandrel（Red
    Hat）来编译这些应用程序并生成原生二进制文件。这个过程基于**即时**（**AOT**）编译，导致在运行时无法使用某些行为——包括反射。AOT 编译器在构建时进行静态代码分析以创建原生可执行文件，这意味着通过动态加载（如反射、**Java
    原生接口**（**JNI**）或代理）完成的任何处理都代表了这个用例的潜在问题。
- en: To address this issue, frameworks such as Quarkus and Micronaut have adopted
    an alternative approach known as the **build-time** or **compile-time** approach.
    Instead of relying on *runtime* reflection, these frameworks leverage annotations
    to capture necessary metadata *during the build process*. Doing so eliminates
    costly reflection operations at runtime and delivers faster startup times and
    improved performance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Quarkus 和 Micronaut 等框架采用了另一种被称为**构建时**或**编译时**的方法。这些框架不是依赖于**运行时**反射，而是利用注解在构建过程中捕获必要的元数据。这样做消除了运行时昂贵的反射操作，并提供了更快的启动时间和改进的性能。
- en: 'The next diagram illustrates how both approaches work, where with reflection
    Java reads the annotations and any metadata in real time, generating more flexibility
    and pluggability on reading time; this demands more memory and warmup time. We
    can read this information at the build time, where we get a better warmup and
    save more memory at the start; however, we lose our flexibility with reflection.
    As usual, this is a point of trade-off analysis:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表说明了这两种方法是如何工作的，其中使用反射时，Java 会实时读取注解和任何元数据，从而在读取时提供更多的灵活性和可插拔性；这需要更多的内存和预热时间。我们可以在构建时读取这些信息，这样在启动时可以获得更好的预热并节省更多内存；然而，我们失去了反射的灵活性。通常，这是一个权衡分析的点：
- en: "![Figure 5.2 \uFEFF– Reading Java annotations \uFEFFat runtime versus build\
    \ time](img/Figure_5.02_B19375.jpg)"
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 运行时与构建时读取 Java 注解](img/Figure_5.02_B19375.jpg)'
- en: Figure 5.2 – Reading Java annotations at runtime versus build time
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 运行时与构建时读取 Java 注解
- en: Reflection is a powerful mechanism in Java programming and frameworks. It enables
    dynamic code execution, metadata extraction, and the utilization of annotations
    for configuration and customization. While reflection can impact startup performance
    in specific scenarios, frameworks such as Quarkus and Micronaut have introduced
    build-time reflection as a solution, allowing developers to leverage the benefits
    of annotations without sacrificing performance. This approach, enabled by CDI
    Lite, promotes efficient usage of Java in serverless and cloud-native environments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是 Java 编程和框架中的一个强大机制。它允许动态代码执行、元数据提取以及利用注解进行配置和定制。虽然反射可能在特定场景中影响启动性能，但 Quarkus
    和 Micronaut 等框架已经引入了构建时反射作为解决方案，允许开发者利用注解的好处而不牺牲性能。这种由 CDI Lite 启用的方法，促进了在无服务器和云原生环境中高效使用
    Java。
- en: Jakarta EE platform constant evolution – CDI Lite
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 平台持续进化 – CDI Lite
- en: Based on the needs and impacts highlighted so far, the Jakarta EE platform released
    as version 10 has changes to the CDI specification that accommodate many behaviors
    helpful for this scenario. The CDI Lite specification brings behaviors needed
    by these frameworks and aims to provide a lightweight version of CDI. CDI Lite
    leverages *compile-time reflection* to eliminate the runtime overhead associated
    with full CDI implementations, making it suitable for resource-constrained environments
    and serverless architectures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于迄今为止突出显示的需求和影响，作为版本 10 发布的雅加达 EE 平台对 CDI 规范进行了更改，以适应许多有助于此场景的行为。CDI Lite 规范提供了这些框架所需的行为，旨在提供
    CDI 的轻量级版本。CDI Lite 利用 *编译时反射* 来消除与完整 CDI 实现相关的运行时开销，使其适用于资源受限的环境和无服务器架构。
- en: Developers can choose between frameworks that employ reflection or follow a
    reflectionless approach when developing Java applications. This comparison table
    will explore critical aspects such as annotation reading, warmup flexibility,
    and encapsulation in these two Java frameworks. Understanding the trade-offs and
    advantages of each approach can help developers make informed decisions based
    on their project requirements and development preferences.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在开发 Java 应用程序时可以选择使用反射或采用无反射方法的框架。此比较表将探讨这两个 Java 框架的关键方面，如注解读取、预热灵活性和封装。
- en: '|  | **Reflection** | **Reflectionless** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  | **反射** | **无反射** |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Read Java annotations | Real-time | Build time |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 读取 Java 注解 | 实时 | 构建 |'
- en: '| Warmup (extra time required by the framework on startup) | It has a slow
    startup | It has a faster startup |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 预热（框架启动时所需额外时间） | 启动速度慢 | 启动速度快 |'
- en: '| Flexibility | Pluggability in real time | Limitation by build time |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性 | 实时插拔性 | 构建时限制 |'
- en: '| Encapsulation | Strong encapsulation | More limitations at the Java encapsulation
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 封装 | 强封装 | Java 封装的限制更多 |'
- en: Table 5.1 – Reflection versus reflectionless solution
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – 反射与无反射解决方案比较
- en: 'When we talk about the application, we’re not sure about the architecture style,
    such as microservices or monolith, or whether we’ll use a real-time or build-time
    Java application; however, for the majority of the solutions, we’ll use any persistence
    engine. Let’s now discuss in more detail the most mature Jakarta persistence specification:
    JPA.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论应用程序时，我们不确定架构风格，如微服务或单体，或者我们将使用实时或构建时 Java 应用程序；然而，对于大多数解决方案，我们将使用任何持久化引擎。现在让我们更详细地讨论最成熟的雅加达持久化规范：JPA。
- en: JPA state of affairs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA 状态
- en: JPA is a crucial Jakarta EE specification and the most mature data specification
    for enterprise applications. It provides a standardized and robust approach to
    ORM in Java, enabling developers to interact seamlessly with relational databases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 是一个关键的雅加达 EE 规范，也是企业应用中最成熟的数据规范。它为 Java 中的 ORM 提供了一种标准化且稳健的方法，使开发者能够无缝地与关系数据库交互。
- en: 'When working with the integration between Java applications and relational
    databases, several aspects need to be taken into consideration, such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Java 应用程序和关系数据库之间的集成工作时，需要考虑以下几个方面：
- en: '**Configuration management**: How the configurations are externalized in order
    to be easily yet securely changed based on the environment in which it is being
    deployed (dev, prod, and so on).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**：如何将配置外部化，以便根据部署的环境（开发、生产等）轻松且安全地更改。'
- en: '**Connection handling**: Improper handling of connections with the database
    may lead to extra processing time, as it is expensive. This need is related to
    the requirement of managing open, close, and track connections with the database
    in order to use resources effectively and avoid having too many open and idle
    connections or not enough connections available to the application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接处理**：不正确处理与数据库的连接可能导致额外的处理时间，因为这是昂贵的。这一需求与有效管理数据库的打开、关闭和跟踪连接以使用资源并避免有太多打开和空闲连接或应用程序可用连接不足的要求相关。'
- en: '**Mapping classes to database tables**: As we saw in previous chapters, mapping
    objects may be implemented in multiple ways and provide a higher or lower level
    of flexibility and abstraction.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将类映射到数据库表**：正如我们在前面的章节中看到的，映射对象可以以多种方式实现，并提供更高或更低级别的灵活性和抽象。'
- en: '**Mapping the relation between classes**: OOP brings concepts such as hierarchy,
    which is not available in a relational database schema. Depending on the way these
    classes are configured, data management can have higher complexity and maintenance
    costs.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射类之间的关系**：面向对象编程（OOP）引入了层次等概念，这在关系数据库模式中是不可用的。根据这些类配置的方式，数据管理可能会具有更高的复杂性和维护成本。'
- en: '**Transaction management**: Managing transactions and assuring atomicity and
    rollbacks at the application layer.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务管理**：在应用层管理事务，并确保原子性和回滚。'
- en: '**Code generation**: Developers can either write pure SQL queries or rely on
    abstractions to speed up the development time. Currently, some frameworks can
    abstract most basic CRUD queries. Unfortunately, if misused, code generation may
    lead to slow queries and restrictions on the proper usage of private methods.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：开发者可以编写纯 SQL 查询或依赖抽象来加快开发速度。目前，一些框架可以抽象出大多数基本的 CRUD 查询。不幸的是，如果误用，代码生成可能会导致查询缓慢和对私有方法正确使用的限制。'
- en: '**Fetching strategies**: Allows the retrieval of data in ways to take the best
    advantage of memory consumption, and when properly used, brings performance improvements
    as data will only be fetched from the database when needed. This is related to
    the well-known lazy/eager fetching modes available, for example, on Hibernate.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取策略**：允许以最佳方式检索数据，以充分利用内存消耗，并且当正确使用时，可以带来性能提升，因为数据仅在需要时才会从数据库中检索。这与Hibernate上可用的众所周知的延迟/预取模式相关。'
- en: '**Decoupling business logic from technical aspects**: Based on their goals,
    a developer can create extremely flexible and customized code (for example, using
    JDBC) in exchange for negatively impacting code coupling between the data persistence
    layer and the business logic layer.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦业务逻辑和技术方面**：根据他们的目标，开发者可以创建极其灵活和定制的代码（例如，使用 JDBC），以换取对数据持久化层和业务逻辑层之间代码耦合的负面影响。'
- en: Considering these recurrent needs of Java developers and the possibility to
    create reproducible good practices that could be easily and largely adopted, the
    JPA specification has evolved since its creation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Java 开发者的这些反复需求以及创建可重复的、易于广泛采用的优秀实践的可能性，JPA 规范自其创建以来已经发展。
- en: 'The following diagram shows the ecosystem of JPA as the most mature persistence
    specification in the Jakarta EE world; several vendors and frameworks use it,
    and we can also apply several persistence patterns such as Active Record, Repository,
    and Mapper:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 JPA 作为 Jakarta EE 世界中最成熟的持久化规范；多个供应商和框架使用它，我们还可以应用多种持久化模式，如 Active Record、Repository
    和 Mapper：
- en: "![Figure 5.3 \uFEFF– JPA timeline and landscape](img/Figure_5.03_B19375.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – JPA 时间线和景观](img/Figure_5.03_B19375.jpg)'
- en: Figure 5.3 – JPA timeline and landscape
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – JPA 时间线和景观
- en: When combined with frameworks such as Spring and Quarkus, JPA offers the flexibility
    to implement different design approaches, including Active Record, Mapper, and
    Repository patterns. Let’s delve into these design approaches and explore how
    JPA can operate by reading annotations using reflection or at build time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Spring 和 Quarkus 等框架结合使用时，JPA 提供了实现不同设计方法（包括 Active Record、Mapper 和 Repository
    模式）的灵活性。让我们深入了解这些设计方法，并探讨 JPA 如何通过反射或构建时读取注解来操作。
- en: JPA and database mapping patterns
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA 和数据库映射模式
- en: 'When working with JPA, developers mostly adopt three design options: Active
    Record, Mapper, and Repository. Notice that due to JPA capabilities such as mapping
    entities and their relationships to each other, abstractions for basic database
    operations, and exception-handling mechanisms, adopting the patterns becomes simpler.
    Let’s take a closer look at this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 JPA 进行开发时，开发者通常采用三种设计选项：Active Record、Mapper 和 Repository。请注意，由于 JPA 具有映射实体及其相互关系、抽象基本数据库操作和异常处理机制等功能，采用这些模式变得更加简单。让我们更深入地了解一下：
- en: '**Active Record with JPA**: In this approach, the domain model class encapsulates
    the persistence logic, following the Active Record pattern. It simplifies database
    operations as the domain classes are active participants and are responsible for
    handling CRUD operations and relationships directly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 JPA 的 Active Record**：在这种方法中，领域模型类封装了持久化逻辑，遵循 Active Record 模式。它简化了数据库操作，因为领域类是活跃的参与者，并直接负责处理
    CRUD 操作和关系。'
- en: When relying on JPA, it is possible to annotate a domain class with JPA annotations
    such as `@Entity` to mark it as a persistent entity. The domain class can also
    be annotated with `@Table`, which will define which is the corresponding database
    table that should be mapped to this entity. These annotations’ metadata enables
    JPA to map the object attributes to the respective database columns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖JPA时，可以通过使用JPA注解如`@Entity`来注解领域类，将其标记为持久化实体。领域类还可以注解为`@Table`，这将定义与该实体对应的数据库表，该表应映射到该实体。这些注解的元数据使JPA能够将对象属性映射到相应的数据库列。
- en: '**Mapper**: According to the Mapper pattern, the domain model and the persistence
    logic should be separated with the help of new and dedicated mapper classes.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mapper**：根据Mapper模式，领域模型和持久化逻辑应该通过新的专用mapper类进行分离。'
- en: JPA, in combination with frameworks such as Spring and Quarkus, allows developers
    to configure and manage these mappers. The mappers handle the conversion between
    the domain objects and the database tables, abstracting the persistence details
    from the domain model. JPA’s `EntityManager` and `EntityManagerFactory` classes
    provide the necessary APIs to perform database operations, while the mapper classes
    facilitate the mapping between the database and the domain model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JPA与Spring和Quarkus等框架结合使用，允许开发者配置和管理这些mapper。mapper处理领域对象和数据库表之间的转换，从领域模型中抽象出持久化细节。JPA的`EntityManager`和`EntityManagerFactory`类提供了执行数据库操作所需的API，而mapper类则促进了数据库和领域模型之间的映射。
- en: '**Repositories**: The Repository pattern suggests introducing a layer of abstraction
    between the application domain layers and the data access layer.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Repositories**：Repository模式建议在应用程序领域层和数据访问层之间引入一层抽象。'
- en: When developing with JPA, developers can define repository interfaces that act
    as contracts specifying the available CRUD operations and queries. JPA’s `EntityManager`
    class is the underlying mechanism for executing queries and managing transactions,
    enabling efficient and scalable data access.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JPA进行开发时，开发者可以定义充当合同并指定可用CRUD操作和查询的仓库接口。JPA的`EntityManager`类是执行查询和管理事务的底层机制，它使数据访问高效且可扩展。
- en: Frameworks such as Spring Data JPA and Quarkus support repositories and can
    automatically generate the necessary implementation code based on the defined
    interfaces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Spring Data JPA和Quarkus等框架支持仓库，并且可以根据定义的接口自动生成必要的实现代码。
- en: When considering the usage of frameworks to implement patterns, we should be
    aware of the pros and cons. We will delve into a detailed code example, but before
    that, let’s check the items to be aware of.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑使用框架来实现设计模式时，我们应该意识到其优缺点。我们将深入探讨一个详细的代码示例，但在那之前，让我们检查需要注意的事项。
- en: Based on the application use case and requirements, it would be recommended
    to know what happens under the covers and what limitations your application will
    inherit from the framework you are choosing. When using Active Record with Panache
    and Quarkus, for instance, your entity might be extending the `PanacheEntity`
    class. With Repository, it might be extending `JpaRepository`, a generic Spring
    Data JPA interface. By knowing the chosen framework implementation details, you
    can better identify where you are opting to tightly couple your application code
    with the framework, by using exclusive annotations or dependencies. You’d be aware
    whether and if so, to what extent there will be a violation of the principle of
    **separation of concerns** (**SoC**), or for instance, the extra effort that will
    be needed in case of the need of migration to a different persistence framework.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用用例和需求，了解底层发生的事情以及你的应用程序将从你选择的框架中继承的限制是很重要的。例如，当使用Active Record与Panache和Quarkus一起使用时，你的实体可能扩展了`PanacheEntity`类。使用Repository时，可能扩展了`JpaRepository`，这是一个通用的Spring
    Data JPA接口。通过了解所选框架的实现细节，你可以更好地识别你选择将应用程序代码与框架紧密耦合的地方，通过使用专用的注解或依赖项。你会知道是否以及到什么程度会违反**关注点分离**（**SoC**）的原则，或者例如，在需要迁移到不同的持久化框架时所需的额外工作量。
- en: 'The pros and cons we learned about in *Chapter* 4 apply here as well: Active
    Record will be less complex than Repository, whereas adopting Repository can result
    in better SoC than Active Record, resulting in enhanced maintainability and testability.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中学到的优缺点在这里同样适用：Active Record将比Repository更简单，而采用Repository可以比Active Record带来更好的SoC，从而提高可维护性和可测试性。
- en: We’ll delve into a comprehensive code sample to clarify the trade-offs between
    choosing the convenience offered by frameworks versus adhering to well-known coding
    best practices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入一个全面的代码示例，以阐明在框架提供的便利性和遵循众所周知的编码最佳实践之间权衡的细节。
- en: The power of JPA with Quarkus and Panache cloud-native runtimes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus和Panache云原生运行时的JPA力量
- en: To demonstrate how modern persistence frameworks enable developers to rely on
    their knowledge of JPA, let’s take a look at Quarkus and Panache, and the experience
    of developing cloud-native Java services with accelerated development speed. Within
    this context, we’ll evaluate key aspects of design pattern implementation, automatically
    generated persistence code, and some potential drawbacks to take into consideration
    when designing a solution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示现代持久化框架如何使开发者能够依赖他们对JPA的了解，让我们来看看Quarkus和Panache，以及使用加速开发速度开发云原生Java服务的体验。在这个背景下，我们将评估设计模式实现的关键方面、自动生成的持久化代码，以及在设计解决方案时需要考虑的一些潜在缺点。
- en: You can either follow along or create a brand-new project to try the following
    code. If you haven’t used Quarkus and Panache yet, you may notice quite a difference
    in the development experience of a lightweight runtime compared to traditional
    application servers, and the simplicity of coding straightforward CRUD scenarios
    with Panache.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以跟随操作或创建一个全新的项目来尝试以下代码。如果您还没有使用过Quarkus和Panache，您可能会注意到与传统的应用服务器相比，轻量级运行时的开发体验有相当大的差异，以及使用Panache编写简单的CRUD场景的简单性。
- en: 'Details on how to create the project can be found in the project’s repository:
    [https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md](https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md).
    Now, let’s dive into it.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何创建项目的详细信息可以在项目的仓库中找到：[https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md](https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md)。现在，让我们深入探讨。
- en: 'The microservice we’re about to see will be used to manage *books* and *magazines*,
    and we’ll explore two different database design patterns using JPA: Repository
    and Active Record.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的微服务将用于管理*书籍*和*杂志*，我们将使用JPA探索两种不同的数据库设计模式：仓库模式和活动记录模式。
- en: Setting up the new service
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置新服务
- en: As we will rely on features for persistence and REST endpoints (easily generated
    through the Quarkus starter page), the project needs dependencies to handle such
    capabilities. Interestingly, much of the hard work will be automatically generated
    by the frameworks, which in turn, are actually based on well-known specifications
    and technologies such as RESTEasy, JSON-B, Hibernate ORM, Hibernate Validator,
    Panache, and JDBC.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将依赖持久化和REST端点（通过Quarkus启动页面轻松生成）的功能，项目需要依赖项来处理这些功能。有趣的是，大部分艰苦的工作将由框架自动生成，而这些框架实际上基于众所周知的规范和技术，如RESTEasy、JSON-B、Hibernate
    ORM、Hibernate Validator、Panache和JDBC。
- en: The underlying storage will be handled by H2, an in-memory data storage, which
    should be useful for learning purposes as it doesn’t require installation of external
    databases or usage of Docker to bootstrap one database instance. However, remember
    that H2 is not recommended for production usage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基础存储将由H2内存数据存储处理，这对于学习目的应该是很有用的，因为它不需要安装外部数据库或使用Docker来启动一个数据库实例。然而，请记住，H2不建议用于生产环境。
- en: The first difference shows up in the Quarkus project’s configuration (`src/main/resources/application.properties`),
    as developers can rely on a single properties configuration file to have `h2`
    as the database kind and `memory` as the JDBC URL. This approach enables changes
    to the underlying database technology without any code modification (for example,
    from H2 to PostgreSQL, MariaDB, or others).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个差异出现在Quarkus项目的配置（`src/main/resources/application.properties`）中，因为开发者可以依赖一个单一的属性配置文件来将`h2`作为数据库类型，将`memory`作为JDBC
    URL。这种方法使得在不修改任何代码的情况下（例如，从H2到PostgreSQL、MariaDB或其他数据库）更改底层数据库技术。
- en: Another positive aspect is that this configuration style relies on the Eclipse
    MicroProfile Configuration specification, which has out-of-the-box support for
    overwriting the application’s properties based on the environment in which the
    application is running—in other words, this is how sensible data (such as the
    username and password) within production environments can remain confidential
    and not be configured directly at the application level.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个积极方面是，这种配置风格依赖于Eclipse MicroProfile Configuration规范，该规范提供了对基于应用程序运行环境的属性覆盖的即插即用支持——换句话说，这就是如何在生产环境中的敏感数据（如用户名和密码）保持机密性，并且不在应用程序级别直接配置。
- en: 'The property configuration could be set up as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 属性配置可以设置如下：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Persistent entities and database operations
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化实体和数据库操作
- en: With the foundation ready to go, the project’s entities are created next. We’ll
    start by checking the two patterns from this moment forward, where you can observe
    the `Book` entity is implemented using Active Record, and `Magazine` using the
    Repository pattern.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施准备就绪后，接下来创建项目实体。从现在开始，我们将检查两个模式，你可以观察到`Book`实体使用Active Record实现，而`Magazine`使用Repository模式。
- en: 'The `Book` class is represented as follows. Note that even though it brings
    the `@Entity` annotation, there are no additional attribute-level annotations.
    Also, the `Book` entity “knows” its database operations, including, for instance,
    how to search for books by name and book release:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book`类如下所示。请注意，尽管它带来了`@Entity`注解，但没有额外的属性级注解。此外，`Book`实体“知道”其数据库操作，例如如何通过名称和书籍发布搜索书籍：'
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you’ll see next, the `Magazine` class uses classic JPA annotations such
    as `@Entity` and `@id` (so far, nothing new under the sun). The reason why the
    `Book` entity does not require an `@id` annotation is that it inherits such capability
    from the class it extends, `PanacheEntity`. `PanacheEntity` handles several operations,
    through heritage, including the `id` attribute:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你接下来会看到的，`Magazine`类使用经典的JPA注解，如`@Entity`和`@id`（到目前为止，太阳下无新事）。`Book`实体不需要`@id`注解的原因是它从它扩展的类`PanacheEntity`继承了这种能力。`PanacheEntity`通过继承处理多个操作，包括`id`属性：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Differently from the class being implemented with Active Record where the database
    operation will be at the entity itself, the `Magazine` class requires an additional
    class to do such data manipulation—a `Repository` class. The `MagazineRepository`
    class has to implement the essential database procedures, plus the queries (such
    as `find by release and name`, as available in the `Book` class). As we are using
    the `PanacheRepository` class, we can save some time on the basic operations as
    they will be automatically generated by Panache later on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用Active Record实现的类不同，其中数据库操作将在实体本身进行，`Magazine`类需要额外的类来进行此类数据操作——一个`Repository`类。`MagazineRepository`类必须实现基本数据库过程，以及查询（如`Book`类中可用的`find
    by release and name`）。由于我们使用`PanacheRepository`类，我们可以在基本操作上节省一些时间，因为Panache稍后会自动生成它们。
- en: 'The `MagazineRepository` code is presented here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`MagazineRepository`代码：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Exposing REST endpoints for data manipulation
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露REST端点以进行数据操作
- en: Finally, to manipulate data through the classes we’ve checked so far, the application
    exposes REST APIs. The endpoints are `BookResource` and `MagazineResource`, which
    should expose the same database operations for `Book` and `Magazine` so that we
    can evaluate the differences in the usage of each approach. The first difference
    that can be mentioned is that, while we don’t need to inject anything in order
    to use the `BookResource` endpoint, to manipulate the `Magazine` entity, the developer
    must inject the respective `repository` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了通过我们迄今为止检查的类来操作数据，应用程序暴露了REST API。端点是`BookResource`和`MagazineResource`，它们应该暴露与`Book`和`Magazine`相同的数据库操作，以便我们可以评估每种方法使用的差异。可以提到的第一个差异是，虽然我们不需要注入任何内容就可以使用`BookResource`端点，但要操作`Magazine`实体，开发者必须注入相应的`repository`类。
- en: First, observe how the `BookResource` endpoint allows interactions with `Book`,
    the entity implemented with Active Record. You’ll notice as a negative aspect
    the fact that there is a tighter coupling between the endpoint and the Active
    Record. As a positive point, notice how it allows the app to be simpler, with
    fewer layers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，观察`BookResource`端点如何允许与使用Active Record实现的实体`Book`进行交互。你会注意到一个负面方面是端点与Active
    Record之间存在更紧密的耦合。作为一个积极点，注意它如何使应用程序更简单，层次更少。
- en: 'The `BookResource` class includes the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookResource` 类包括以下内容：'
- en: 'Three `GET` endpoints: `findAll`, `findByName`, and `findByYear`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个 `GET` 端点：`findAll`、`findByName` 和 `findByYear`
- en: One `POST` and one `DELETE` method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `POST` 和一个 `DELETE` 方法
- en: 'The code is shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, observe that the `Book` entity already offers the methods
    that execute operations against the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意 `Book` 实体已经提供了执行数据库操作的方法。
- en: Now, let’s move on to the `MagazineResource` endpoint, which covers the Repository
    pattern. Observe that even though this is a simple example project, it will increase
    the complexity of the business requirements and time with the erosion of architecture
    in real life. It reminds us of [*Chapter 4*](B19375_04.xhtml#_idTextAnchor076),
    where we covered more about the layers and their trade-offs, so the same layer
    that can help us, in isolation, break what into pieces might impact more complex
    code. As the application expands and incorporates additional layers such as the
    service layer, or as it adopts a hexagonal model, it becomes crucial to carefully
    analyze the trade-offs and pay close attention to the design of persistence layers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向 `MagazineResource` 端点，它涵盖了仓库模式。请注意，尽管这是一个简单的示例项目，但在现实生活中，随着架构的侵蚀，它将增加业务需求的复杂性和时间。这让我们想起了[*第4章*](B19375_04.xhtml#_idTextAnchor076)，在那里我们讨论了更多关于层及其权衡的内容，所以那个可以单独帮助我们分解问题的层可能会对更复杂的代码产生更大的影响。随着应用程序的扩展和采用额外的层，如服务层，或者采用六边形模型，仔细分析权衡并密切关注持久化层的设计变得至关重要。
- en: 'Here is the implementation of the `MagazineResource` endpoint:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `MagazineResource` 端点的实现：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Key points to observe in the preceding class are set out here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中需要注意的关键点如下：
- en: The developer is required to inject an instance of the `MagazineRepository`
    endpoint
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者需要注入 `MagazineRepository` 端点的一个实例。
- en: The developer must implement the class and the methods that are needed, obtaining
    a greater level of control and customization of the underlying implementation,
    plus code with better SoC between the domain entity and the database integration
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者必须实现所需的类和方法，从而获得对底层实现的更高控制度和定制度，以及更好的 SoC（分离关注点）代码，在领域实体和数据库集成之间。
- en: At this point, the application is ready, and all operations are ready to be
    accessed via REST and by correctly manipulating data through the methods defined
    by the developer and provided out of the box by Panache.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序已准备就绪，所有操作都可通过 REST 访问，并且可以通过开发者定义的方法和 Panache 提供的内置方法正确地操作数据。
- en: Even faster development speed – automatic endpoint generation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快的开发速度——自动端点生成
- en: Panache allows even more development speed for standard scenarios, combining
    the benefits of Active Record we’ve seen with the automatic generation of REST
    endpoints. The following capabilities are offered by the `quarkus-hibernate-orm-rest-data-panache`
    Quarkus extension, instead of the previously used `quarkus-hibernate-orm-panache`
    extension.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Panache 允许在标准场景下实现更快的开发速度，结合了我们之前看到的 Active Record 的好处以及基于 Panache 实体的自动生成 REST
    端点。`quarkus-hibernate-orm-rest-data-panache` Quarkus 扩展提供了以下功能，而不是之前使用的 `quarkus-hibernate-orm-panache`
    扩展。
- en: The speed at which a developer can deliver a completely usable CRUD service
    is extremely noticeable when compared to the previous approach, and even more
    so if compared to traditional EE application servers. With the following steps,
    a developer should be able to create a whole CRUD for *newsletters* in just a
    few minutes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，开发者交付一个完全可用的 CRUD 服务的速度非常明显，与传统的 EE 应用服务器相比更是如此。通过以下步骤，开发者应该能够在几分钟内创建一个完整的
    *通讯录* CRUD。
- en: 'Taking into consideration the existing project, a new `Newsletter` class could
    be created as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到现有项目，可以创建一个新的 `Newsletter` 类，如下所示：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It relies on the Active Record implementation as well. On top of that, it combines
    Quarkus and Panache capabilities for automatically generating REST endpoints based
    on Panache entities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它依赖于 Active Record 实现。在此基础上，它结合了 Quarkus 和 Panache 的能力，基于 Panache 实体自动生成 REST
    端点。
- en: 'To achieve the same results as the examples covered before, the following REST
    operations should be available:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到之前示例中提到的相同结果，以下 REST 操作应该是可用的：
- en: 'Three `GET` resources: `findAll`, `findById`, and `getCount`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个 `GET` 资源：`findAll`、`findById` 和 `getCount`
- en: '`POST`, `PUT`, and `DELETE`, to enable inserting, updating, and deleting newsletters,
    respectively'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`、`PUT` 和 `DELETE` 方法，分别用于插入、更新和删除通讯录'
- en: 'To achieve this objective, all that is needed is a new interface that extends
    the `PanacheEntityResource` interface. The interface indicates the Panache entity
    that is the `id` attribute type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个目标，所需的就是一个新的接口，该接口扩展了 `PanacheEntityResource` 接口。该接口指示 Panache 实体是 `id`
    属性类型：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And that’s all! If running Quarkus using dev mode, the developer should already
    be able to validate the results simply by refreshing the page and checking the
    `swagger-ui` page and the new endpoints, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果使用 dev 模式运行 Quarkus，开发者应该已经能够通过刷新页面并检查 `swagger-ui` 页面和新端点来简单地验证结果，如图所示：
- en: "![Figure 5.4 \uFEFF– New endpoints automatically generated by Panache](img/Figure_5.04_B19375.jpg)"
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 由 Panache 自动生成的新的端点](img/Figure_5.04_B19375.jpg)'
- en: Figure 5.4 – New endpoints automatically generated by Panache
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 由 Panache 自动生成的新的端点
- en: 'Now, be aware that when choosing to go down this route, all the attributes
    are configured as public attributes. And here’s your trade-off when using such
    an approach: unless you add extra code to be able to handle the usage of private
    attributes, you will opt for development speed in exchange for completely giving
    up on encapsulation, no access control, increased code coupling (as changes to
    the class may result in potential changes to other classes), and limited control
    and data integrity (the attribute can be directly modified).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，当选择走这条路时，所有属性都被配置为公共属性。使用这种方法时，你需要权衡的是：除非你添加额外的代码来处理私有属性的使用，否则你将选择开发速度，完全放弃封装、没有访问控制、增加代码耦合（因为类别的更改可能会导致其他类别的潜在更改），以及有限的控制和数据完整性（属性可以被直接修改）。
- en: 'You may think it is as simple as configuring the attributes as private and
    adding public getters and setters. True—this is mostly the same. But you would
    lack encapsulation in the very same way (as the setter is still public) with “dumb”
    getters and setters. Plus, that is exactly what Panache (in the current version
    at the time of writing) does under the covers: it generates `getter` and `setter`
    attributes and rewrites every usage of these attributes to the respective `getter`
    and `setter` attribute.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这就像将属性配置为私有并添加公共的 getter 和 setter 一样简单。确实如此——这基本上是相同的。但你会以相同的方式（因为 setter
    仍然是公共的）缺乏封装，使用“愚蠢”的 getter 和 setter。此外，这正是 Panache（在撰写本文时的当前版本）在幕后所做的事情：它生成 `getter`
    和 `setter` 属性，并将这些属性的每个使用都重写为相应的 `getter` 和 `setter` 属性。
- en: Panache is very powerful and allows developers to also be more efficient when
    writing queries, where it would be possible—for example—to use code such as `Newsletter.find("order
    by author")`, or `Newletter.find("author = ?1 and headline = ?2", "karina", "Java
    lives!")`, or, even better, `Newsletter.find("author", "karina")`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Panache 非常强大，并允许开发者在编写查询时也变得更加高效，例如可以使用如下代码：`Newsletter.find("order by author")`，或者`Newsletter.find("author
    = ?1 and headline = ?2", "karina", "Java lives!")`，或者更好的是，`Newsletter.find("author",
    "karina")`。
- en: 'You have seen the amazing experience Java developers can get from modern runtime
    technologies and how effective it can be to create from scratch a completely new
    stateful service while relying on existing knowledge of JPA. Next, we’ll slightly
    shift to another topic, highlighting considerations on concerns commonly faced
    by most developers and architects who have ever worked with JPA: performance and
    scalability.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 Java 开发者可以从现代运行时技术中获得惊人的体验，以及从头开始创建一个全新的有状态服务是多么有效，同时依靠现有的 JPA 知识。接下来，我们将稍微转向另一个话题，强调大多数曾经使用过
    JPA 的开发者和架构师通常面临的问题的考虑因素：性能和可伸缩性。
- en: General JPA-related performance considerations
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用 JPA 相关性能考虑因素
- en: 'The following considerations apply not only to Panache but also to JPA-based
    applications in general. To help identify or go through the performance tuning
    process, you can always rely on the framework capabilities of outputting the DDLs
    being executed (database SQL operations) and the database operations statistics.
    Hibernate, for example, offers several configuration parameters such as `show_sql`,
    `generate_statistics`, `jdbc.batch_size`, `default_batch_fetch_size`, and `cache.use_query_cache`.
    In the following paragraphs, you’ll find considerations revolving around such
    configurations. For now, check here how some configuration could be applied to
    the sample Quarkus application example we just created. These properties allow
    the logging of DDLs and statistics:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下考虑不仅适用于Panache，也适用于基于JPA的应用程序。为了帮助识别或进行性能调整过程，你始终可以依赖框架的能力来输出正在执行的DDL（数据库SQL操作）和数据库操作统计信息。例如，Hibernate提供了多个配置参数，如`show_sql`、`generate_statistics`、`jdbc.batch_size`、`default_batch_fetch_size`和`cache.use_query_cache`。在接下来的段落中，你将找到围绕此类配置的考虑。现在，检查这里如何将一些配置应用于我们刚刚创建的示例Quarkus应用程序。这些属性允许记录DDL和统计信息：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that verbose logging configuration should not be used in production as
    it directly impacts application performance; plus, the application log categories
    can be configured individually to output only what you need. As an example, the
    preceding statistics configuration can help you identify slow execution DDLs.
    See one example of information you can obtain for each database operation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在生产环境中不应使用详尽的日志配置，因为它会直接影响应用程序性能；此外，可以单独配置应用程序日志类别，仅输出所需的内容。例如，前面的统计配置可以帮助你识别慢速执行的DDL。以下是一个你可以为每个数据库操作获取的信息示例：
- en: '`2023-06-19 02:10:25,402 DEBUG [org.hib.sta.int.StatisticsImpl] (executor-thread-1)
    HHH000117: HQL: SELECT COUNT(*) FROM dev.a4j.mastering.data.Newsletter, time:
    1ms,` `rows: 1`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`2023-06-19 02:10:25,402 DEBUG [org.hib.sta.int.StatisticsImpl] (executor-thread-1)
    HHH000117: HQL: SELECT COUNT(*) FROM dev.a4j.mastering.data.Newsletter, time:
    1ms,` `rows: 1`'
- en: If you are worried about performance, certify your code (either due to mapping
    or query parsing) is not *automatically generating slow-performing SQL queries*
    under the covers, *fetching unnecessary information* when not needed, or *automatically
    generating too many queries* instead of running a better-suited single one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心性能，请确保你的代码（无论是由于映射还是查询解析）在幕后不会*自动生成性能低下的SQL查询*，在不需要时*检索不必要的信息*，或者*自动生成过多的查询*而不是运行一个更适合的单个查询。
- en: Other than the persistence-related Java code itself, it is also possible to
    fine-tune your JPA data source connection by setting the number of connections
    to be opened by the application during startup, the connection pool size (so that
    open connections can be reused), and how you want the application (via your framework
    and class of choice) to identify and clean idle or unclosed connections.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与持久性相关的Java代码本身之外，还可以通过设置应用程序启动时打开的连接数、连接池大小（以便可以重用打开的连接）以及应用程序（通过你选择的框架和类）如何识别和清理空闲或未关闭的连接来微调你的JPA数据源连接。
- en: Another item to consider is batch operations. Let’s say each newsletter can
    contain several articles, and an author can create a new newsletter along with
    50 articles, all at once. In this case, instead of going back and forth between
    the application and the database 51 times to create all articles and the newsletter,
    it would be possible to do it only once to execute all operations. The same applies
    to querying data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的项目是批量操作。假设每份通讯可以包含几篇文章，作者可以一次性创建一份新的通讯和50篇文章。在这种情况下，而不是在应用程序和数据库之间来回51次以创建所有文章和通讯，只需执行一次操作即可完成所有操作。同样适用于查询数据。
- en: For applications with an intensive number of queries, focus on creating specific
    SQL queries that can perform better, and if the app requires several query executions,
    it is recommended to fine-tune the batch-and-fetch size on the application configuration.
    JDBC batch operations are a good approach to defining how many operations can
    be executed in a single database roundtrip.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查询密集型应用程序，专注于创建可以更好地执行的特定SQL查询，如果应用程序需要多次查询执行，建议在应用程序配置中微调批量获取大小。JDBC批量操作是定义单次数据库往返中可以执行多少操作的好方法。
- en: For applications with an intensive number of inserts, it is also possible to
    use bulk inserts, making sure to avoid long-running transactions or spending extra
    time each time the “flush” operation occurs (as `EntityManager` will have to handle
    the insert of a large set of objects at once). As applied to most fine-tuning
    configurations, the best way to evaluate which would be the best configuration
    to set on each application is to execute load tests and compare results. Still
    ,in the context of querying data, remember that caching frequently used queries
    helps reduce the number of database hits and improves performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有大量插入操作的应用程序，也可以使用批量插入，确保避免长时间运行的事务或每次“flush”操作时花费额外的时间（因为`EntityManager`将不得不一次性处理大量对象的插入）。对于大多数微调配置，评估每个应用程序上最佳配置的最佳方式是执行负载测试并比较结果。然而，在查询数据的上下文中，请记住，缓存常用查询有助于减少数据库访问次数并提高性能。
- en: 'In regard to caching in the JPA context, there are two types of cache: first-
    and second-level cache. The first-level cache relates to the objects contained
    within the `EntityManager` cache (session cache). It allows the app to save time
    when accessing objects that were recently accessed or manipulated within a session.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPA上下文中，关于缓存，有两种类型的缓存：一级缓存和二级缓存。一级缓存与`EntityManager`缓存（会话缓存）中包含的对象相关。它允许应用程序在访问会话中最近访问或操作的对象时节省时间。
- en: When working with distributed applications scaled up to many running instances,
    it may be beneficial to consider a second-level cache that allows the usage of
    a shared cache. Remember that caching features are not recommended for 100% of
    scenarios, because even though it may lead to significantly better performance,
    it will demand a good understanding of how to fine-tune the caching solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当与扩展到许多运行实例的分布式应用程序一起工作时，考虑使用允许使用共享缓存的二级缓存可能是有益的。请记住，缓存功能并不适用于所有场景，尽管它可能导致显著更好的性能，但它将要求对如何微调缓存解决方案有良好的理解。
- en: Finally, fine-tuning a cache solution means providing proper cache invalidation
    (to make sure the cache data is aligned with the underlying database’s current
    data), proper cache synchronization (as there may be multiple cache provider instances),
    eviction policies, and more. In scenarios where there is real-time or up-to-date
    data, take into consideration the challenges of cache usage and the introduced
    possibility of data staleness.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，微调缓存解决方案意味着提供适当的缓存失效（以确保缓存数据与底层数据库的当前数据保持一致），适当的缓存同步（因为可能有多个缓存提供程序实例），驱逐策略等。在存在实时或最新数据的场景中，考虑缓存使用带来的挑战以及引入的数据过时可能性。
- en: This brings us to the end of our Quarkus and JPA journey, where we have seen
    both Active Record and Repository patterns with JPA. We can see how easy Active
    Record can be, but at the same time, my entity knows and executes database operations.
    Thus, it has two responsibilities. This is fine when we talk about a redirect
    or any integral functions that do not require a huge demand of business complexity.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了Quarkus和JPA的旅程，在这个过程中，我们看到了JPA中的Active Record和Repository模式。我们可以看到Active
    Record是多么简单，但与此同时，我的实体知道并执行数据库操作。因此，它有两个职责。当我们谈论重定向或任何不需要巨大业务复杂性的集成函数时，这是可以的。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In conclusion, Jakarta EE is a robust platform that provides a comprehensive
    set of specifications, APIs, and tools for developing enterprise applications.
    Within the persistence layer, Jakarta EE shines with its mature JPA specification,
    which offers a standardized approach to ORM. With JPA, developers can leverage
    design patterns such as Active Record and Repository to simplify and streamline
    their data access operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Jakarta EE是一个强大的平台，它提供了一套全面的规范、API和工具，用于开发企业应用程序。在持久化层，Jakarta EE凭借其成熟的JPA规范而闪耀，该规范提供了一种标准化的ORM方法。使用JPA，开发者可以利用Active
    Record和Repository等设计模式来简化并优化他们的数据访问操作。
- en: When combined with the Quarkus framework, JPA in Jakarta EE demonstrates its
    capabilities in practice. Quarkus, known for its fast startup time and efficient
    resource utilization, enhances the development experience by seamlessly integrating
    with JPA. Developers can leverage the Active Record pattern, allowing their domain
    model classes to handle persistence operations directly. Alternatively, they can
    adopt the Repository pattern, which introduces an abstraction layer for flexible
    and scalable data access. By leveraging JPA within Quarkus, developers can efficiently
    interact with relational databases, ensure data integrity, and achieve optimal
    performance in their Jakarta EE applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Quarkus框架结合使用时，Jakarta EE中的JPA在实践上展示了其能力。以其快速的启动时间和高效的资源利用而闻名的Quarkus，通过无缝集成JPA来提升开发体验。开发者可以利用Active
    Record模式，使他们的领域模型类直接处理持久化操作。或者，他们可以采用Repository模式，该模式引入了一个抽象层，以实现灵活和可扩展的数据访问。通过在Quarkus中利用JPA，开发者可以高效地与关系型数据库交互，确保数据完整性，并在他们的Jakarta
    EE应用程序中实现最佳性能。
- en: Overall, with its mature JPA specification, Jakarta EE, in conjunction with
    the Quarkus framework, empowers developers to build robust and efficient persistence
    layers. The combination of Jakarta EE’s standardized approach to persistence and
    Quarkus’ streamlined development experience opens up a world of possibilities
    for creating scalable and high-performing enterprise applications. But how about
    NoSQL? Does Jakarta EE have support for it? Yes, it does; the following chapter
    will cover how to handle several NoSQL database types such as key-value, document,
    and graph with Java.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，凭借其成熟的JPA规范，结合Quarkus框架的Jakarta EE，赋予了开发者构建强大且高效的持久化层的力量。Jakarta EE对持久化的标准化方法与Quarkus的简化开发体验相结合，为创建可扩展且高性能的企业应用程序开辟了无限可能。但NoSQL呢？Jakarta
    EE是否支持它？是的，它支持；接下来的章节将介绍如何使用Java处理几种NoSQL数据库类型，如键值、文档和图。
