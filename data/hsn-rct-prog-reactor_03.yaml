- en: Data and Stream Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据和流处理
- en: In the previous chapter, we generated streams of data by using a Reactor Flux
    and then consumed it in a subscriber. Reactor also provides a diverse set of operators
    that can be used to manipulate data. These operators take a stream as input and
    then generate another stream of another type of data. In a nutshell, these operators
    provide a powerful way to compose readable data pipelines. There are various operators
    for filtering, mapping, and collecting data. All of them will be covered in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用 Reactor Flux 生成数据流，然后在订阅者中消费它。Reactor 还提供了一组多样的操作符，可以用来操作数据。这些操作符接收一个流作为输入，然后生成另一个类型的数据流。简而言之，这些操作符提供了一种强大的方式来组合可读的数据管道。有各种用于过滤、映射和收集数据的操作符。所有这些都会在本章中介绍。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Filtering data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据
- en: Converting data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换数据
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 标准版，JDK 8 或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1 或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 链接是 [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03)。
- en: Generating data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成数据
- en: Before we jump into working with various operators, let's first generate a stream
    of data. In order to do this, let's revisit our Fibonacci series from [Chapter
    1](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml), *Getting Started with Reactive
    Streams*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究各种操作符之前，让我们首先生成一个数据流。为了做到这一点，让我们回顾一下我们的斐波那契序列，来自 [第 1 章](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml)，*开始使用响应式流*。
- en: In number theory, Fibonacci numbers are characterized by the fact that every
    number after the first two numbers is the sum of the two preceding ones (that
    is, 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ,21 , 34 , 55 , 89 , 144, and so on).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在数论中，斐波那契数以这样一个事实为特征：从第一个两个数之后的每一个数都是前两个数的和（即，0 , 1 , 1 , 2 , 3 , 5 , 8 , 13
    ,21 , 34 , 55 , 89 , 144，等等）。
- en: 'The Flux generated API enables us to build a generator. These generators start
    the series from 0 and 1\. All numbers are printed to the console by a subscriber,
    which listens to all of the generated events. This is shown in the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 生成的 API 使我们能够构建一个生成器。这些生成器从 0 和 1 开始序列。所有数字都由订阅者打印到控制台，该订阅者监听所有生成的事件。这在上面的代码中有显示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s recap what is happening here, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这里正在发生的事情，如下所示：
- en: We create the Fibonacci series as `Flux<Long>` by using the `Flux.generate()`
    call. The API has a state and sink.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用 `Flux.generate()` 调用创建斐波那契序列作为 `Flux<Long>`。API 有状态和汇。
- en: The API takes a seed as `Tuple [0 , 1]`. It then emits the first argument of
    the pair by using the `Sink.next()` call.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 接收一个种子作为 `Tuple [0 , 1]`。然后通过调用 `Sink.next()` 来发出对的数据。
- en: The API also generates the next Fibonacci number, by aggregating the pair.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 还通过聚合对来生成下一个斐波那契数。
- en: The publisher marks the stream as complete when we generate negative numbers.
    This is due to their being out of range of the long data type.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们生成负数时，发布者将流标记为完成。这是由于它们超出了 long 数据类型的范围。
- en: 'We subscribe to the published numbers, then print the received number to the
    console. This is shown in the following screenshot:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们订阅发布的数字，然后将接收到的数字打印到控制台。这在上面的屏幕截图中有显示：
- en: '![](img/7b04e524-ec34-4575-9f90-592b33ebcfb0.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b04e524-ec34-4575-9f90-592b33ebcfb0.png)'
- en: Filtering data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数据
- en: 'Let''s start with the most simple operator for selecting data. There are different
    analogies of data filtration, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择数据的简单操作符开始。数据过滤有不同类型的类比，如下所示：
- en: Select or reject data based on a given condition
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据给定条件选择或拒绝数据
- en: Select or reject a subset of the generated data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择或拒绝生成数据的一个子集
- en: 'The preceding information is depicted in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面的信息：
- en: '![](img/6fac3048-5c21-41fd-b2cc-17f964c00fbe.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fac3048-5c21-41fd-b2cc-17f964c00fbe.png)'
- en: The filter() operator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: filter() 操作符
- en: The `filter()` operator enables selection of the data on the passed condition.
    The API takes a Boolean predicate, which is evaluated for every emitted value,
    in order to determine whether it is selected. Filtering is quite common. Let's
    suppose that we want to select dates based on a month range, or we want to select
    employee data based on employee IDs. In those cases, the Boolean predicate passed
    to the filter holds the selection logic. This can be quite flexible, and can be
    adapted to different needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`操作符允许根据传递的条件选择数据。API接受一个布尔谓词，该谓词对每个发出的值进行评估，以确定是否被选中。过滤操作相当常见。假设我们想根据月份范围选择日期，或者根据员工ID选择员工数据。在这些情况下，传递给`filter`的布尔谓词包含选择逻辑。这可以非常灵活，并且可以适应不同的需求。'
- en: 'Let''s extend our Fibonacci generator to only select even numbers, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的斐波那契生成器扩展到只选择偶数，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, the predicate performs a divisibility check. If the number
    is divisible by `2`, the operator performs a predicate evaluation in a synchronous
    manner. If the condition is satisfied, the value is passed to the subscriber.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，谓词执行可除性检查。如果数字能被`2`整除，操作符将以同步方式执行谓词评估。如果条件得到满足，值将被传递给订阅者。
- en: 'There is also a `FilterWhen`, which is an asynchronous manner of Boolean evaluation.
    This takes the input value and provides the Boolean publisher in return. This
    can be explained with the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`FilterWhen`，它是一种异步的布尔评估方式。它接受输入值并返回布尔发布者。这可以通过以下代码解释：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the predicate performs a less-than check. This is a deferred
    evaluation, and the result is returned as a `Mono<Boolean>`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，谓词执行小于检查。这是一个延迟评估，结果以`Mono<Boolean>`的形式返回。
- en: The take operator
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取操作符
- en: 'The filter methods discussed previously enable us to select data. If we want
    to select the top 10 elements, for example, we can use the `filter` operator,
    with a predicate that has a counter. Alternatively, there is a `take` operator
    for this purpose. The operator takes a number and selects the specified number
    of elements, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的过滤方法使我们能够选择数据。如果我们想选择前10个元素，例如，我们可以使用`filter`操作符，其中包含一个计数器谓词。或者，还有一个`take`操作符用于此目的。该操作符接受一个数字并选择指定数量的元素，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code will select the first `10` values to form the Fibonacci generator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将选择前`10`个值来形成斐波那契生成器。
- en: 'Now, let''s suppose that we want to select the last 10 elements. The `takeLast`
    operator is designed for this purpose. It also maintains a count and selects elements
    from the end of the series:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们只想选择最后10个元素。`takeLast`操作符就是为了这个目的而设计的。它也维护一个计数并从序列的末尾选择元素：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the stream is truly unbounded, there will not be any last elements. The operator
    only works when there is a normal close of the stream.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流确实是无界的，则不会有任何最后一个元素。该操作符仅在流正常关闭时才起作用。
- en: 'If we only want to select the last value, we can use the `takeLast(1)` operator.
    This operator will give back a Flux stream containing just one value. Alternatively,
    there is a `last()` operator, which gives back a Mono publisher that consists
    of the last published element. The use of the `last` operator is shown as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想选择最后一个值，我们可以使用`takeLast(1)`操作符。此操作符将返回一个只包含一个值的Flux流。或者，还有一个`last()`操作符，它返回一个包含最后一个发布元素的Mono发布者。`last`操作符的使用如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The skip operator
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过操作符
- en: 'Now that we have found ways to select data, let''s look at ways to reject data.
    The Reactor API offers diverse methods to reject data. There is a skip operator,
    with the following types:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了选择数据的方法，让我们看看拒绝数据的方法。Reactor API提供了多种拒绝数据的方法。有一个跳过操作符，有以下类型：
- en: '`Skip(count)`: This will reject the specified number of elements from the beginning
    of the stream.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip(count)`: 这将从流的开始处拒绝指定数量的元素。'
- en: '`Skip(Duration)`: This will reject elements for the said duration from the
    beginning of the stream.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip(Duration)`: 这将从流的开始处拒绝指定持续时间的元素。'
- en: '`SkipLast(count)`: This will reject a specified number of elements from the
    end of the stream.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipLast(count)`: 这将从流的末尾拒绝指定数量的元素。'
- en: '`SkipUntil(Boolean Predicate)`: This will reject elements until the first occurrence
    of the said condition is true.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipUntil(Boolean Predicate)`: 这将拒绝元素，直到满足所述条件的第一种情况为真。'
- en: 'The preceding commands are shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在以下代码中显示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code sample has the following variants:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例有以下变体：
- en: The first subscriber rejects the first `10` elements and prints the rest of
    them
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个订阅者拒绝前`10`个元素，并打印其余元素
- en: The second subscriber prints the elements after rejecting the elements for `10`
    milliseconds
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个订阅者打印拒绝`10`毫秒内的元素之后的元素
- en: The second subscriber prints the elements after the first data element goes
    beyond `100`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个订阅者打印第一个数据元素超过`100`之后的元素
- en: 'The output is shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了输出：
- en: '![](img/64301bd5-b071-48a0-87d1-9ff5e043f4be.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64301bd5-b071-48a0-87d1-9ff5e043f4be.png)'
- en: 'Until now, we have discussed generic ways to select and reject data. However,
    the Flux interface offers the following special operators for filtering data in
    specific scenarios:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了选择和拒绝数据的通用方法。然而，Flux接口为特定场景下的数据过滤提供了以下特殊操作符：
- en: '`distinct`: This operator is used to select unique elements of the passed data
    stream'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`: 此操作符用于选择传递的数据流中的唯一元素'
- en: '`distintUntilChanged`: This operator is used to select the first set of distinct
    items'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged`: 此操作符用于选择第一个唯一元素集'
- en: '`ignoreElements`: This operator is used to completely ignore the data elements'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreElements`: 此操作符用于完全忽略数据元素'
- en: '`single`: This operator is used to select only a single data element'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single`: 此操作符用于选择单个数据元素'
- en: '`elementAt`: This operator selects the element at the specified index of the
    stream'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementAt`: 此操作符选择流中指定索引处的元素'
- en: In the preceding section, we discussed ways to select or reject data. Reactor
    offers many operators for this purpose. It is often a good idea to check the API
    and determine whether there is an operator for the intended purpose rather than
    customize the predicate with the filter and skip methods.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了选择或拒绝数据的方法。Reactor提供了许多用于此目的的操作符。通常，检查API并确定是否存在用于预期目的的操作符，而不是使用过滤和跳过方法自定义谓词，是一个好主意。
- en: Converting data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换数据
- en: It is often necessary to convert data from one format to another. The reactor
    provides a vast set of operators to achieve this. Not only can we convert data
    but we can modify the amount of data elements as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要将数据从一种格式转换为另一种格式。Reactor提供了一套庞大的操作符来实现这一点。我们不仅可以转换数据，还可以修改数据元素的数量。
- en: The map() operator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map()`操作符'
- en: From the preceding Fibonacci example that was used to explain the `skip()` operator,
    suppose that we want to convert the first 10 elements into Roman numeral equivalents.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前用于解释`skip()`操作符的斐波那契示例中，假设我们想要将前10个元素转换为罗马数字等价物。
- en: 'Roman numerals are represented by seven letters: I, V, X, L, C, D, and M. These
    letters represent 1, 5, 10, 50, 100, 500, and 1,000, respectively. The seven letters
    can be combined to represent thousands of numbers. The Roman numeral scheme used
    letters as tally markers. Markers were combined to represent unit values.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字由七个字母表示：I、V、X、L、C、D和M。这些字母分别代表1、5、10、50、100、500和1,000。这七个字母可以组合起来表示成千上万的数字。罗马数字方案使用字母作为计数标记。标记组合起来表示单位值。
- en: 'We have a long number and we want to convert it to its Roman equivalent; this
    is where the `map()` operator is valuable. It applies a transformation to each
    and every value of the existing stream, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个长数字，我们想要将其转换为罗马数字等价物；这就是`map()`操作符有价值的地方。它将转换应用于现有流中的每个值，如下所示：
- en: '![](img/780c0950-35bd-4673-8a36-36c4d7f00c52.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/780c0950-35bd-4673-8a36-36c4d7f00c52.png)'
- en: 'In order to achieve this transformation, we need a `RomanNumberConvertor`.
    In the following code, we have defined a conversion from integers to their Roman
    equivalents:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种转换，我们需要一个`RomanNumberConvertor`。在下面的代码中，我们定义了从整数到其罗马数字等价物的转换：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we know how to convert an integer, we will define the `Map` function
    for our stream processor. The operator will take the long `Value` as an input
    and will then generate the Roman equivalent as a string:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何转换整数，我们将为我们的流处理器定义`Map`函数。该操作符将长`Value`作为输入，然后生成字符串形式的罗马数字等价物：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A couple of things are done in the preceding code, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中做了几件事情，如下所示：
- en: The `skip(1)` operator has been used. In the last section, we mentioned that
    this will skip the first element of the series. This happens because 0 has no
    Roman equivalent.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了`skip(1)`操作符。在上一个章节中，我们提到这将跳过序列的第一个元素。这是因为0没有罗马数字等价物。
- en: The `take(10)` operator has been used. This will select only 10 elements from
    the generated series. This is done to limit the number to less than 1,000.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了`take(10)`操作符。这将只从生成的序列中选择10个元素。这样做是为了将数字限制在1,000以下。
- en: The `map()` operator defines the conversion of `longValue` to the Roman-equivalent
    string.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`操作符定义了`longValue`到罗马等效字符串的转换。'
- en: 'All of the preceding operators have been chained together to generate one single
    stream. The output is shown in the following screenshot:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的前面操作符都被链接在一起以生成一个单一的流。输出如下面的截图所示：
- en: '![](img/4f6e72e7-d511-49bf-b8da-62cd79a3724e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f6e72e7-d511-49bf-b8da-62cd79a3724e.png)'
- en: As you can see in the preceding output, the value transformation from number
    to Roman numeral is applied to each item flowing through the stream.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，数值从数字到罗马数字的转换应用于流中流动的每个项目。
- en: The flatMap operator
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flatMap`操作符'
- en: The preceding transformation example that used the `map()` operator was effective
    when we had a one-to-one value conversion, but it could not handle a one-to-*n*
    value conversion. We can show this premise by generating a stream of factors for
    our Fibonacci numbers. Let's first revise what factorization is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的使用`map()`操作符的转换示例在有一对一值转换时是有效的，但它无法处理一对-*n*值转换。我们可以通过生成斐波那契数的因子流来展示这个前提。让我们首先回顾一下因式分解是什么。
- en: In number theory, factorization is the breakup of a composite number into a
    product of smaller numbers. For 6, for example, the factors are 1, 2, 3, and 6.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在数论中，因式分解是将合数分解为较小数字的乘积。例如，对于6，因数是1、2、3和6。
- en: 'Let''s try to convert Fibonacci numbers to their corresponding factors. Each
    number of the series must be converted to all possible factors. First, let''s
    build a simple function to compute factors:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将斐波那契数转换为它们对应的因子。序列中的每个数字都必须转换为所有可能的因子。首先，让我们构建一个简单的函数来计算因子：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we used the brute force method, which divides the specified
    number by all numbers less than or equal to the number. If the number is divisible,
    then the divisor is added to the list of factors. We can use this with a `map`
    operator, which is shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了暴力方法，该方法将指定的数字除以所有小于或等于该数字的数字。如果数字可以整除，则除数将被添加到因数列表中。我们可以使用`map`操作符来实现这一点，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The resulting output includes individual collections that contain factors of
    the Fibonacci number:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出包括包含斐波那契数因子的单独集合：
- en: '![](img/cde056ed-d1e7-4e13-96cb-26085c01d133.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cde056ed-d1e7-4e13-96cb-26085c01d133.png)'
- en: 'In order to make the generated factors a stream of integral factors, we must
    use the `flatMap` operator. This is shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使生成的因子成为整数因子的流，我们必须使用`flatMap`操作符。这如下面的代码所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, the following things are handled:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容被处理：
- en: '`flatMap` takes an integer and passes it to the factor generator. It expects
    a publisher of the other data type.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`接受一个整数并将其传递给因子生成器。它期望一个其他数据类型的发布者。'
- en: Factors are generated as a collection of integers.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因子作为整数集合生成。
- en: These integers are converted into a Flux using the `fromIterable` methods to
    match the expectations of the `FlatMap` method.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些整数被转换为Flux，使用`fromIterable`方法来匹配`FlatMap`方法的期望。
- en: 'The preceding code generates the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下输出：
- en: '![](img/d05bd4f4-d944-4686-ba87-db0e1e1b8a1b.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05bd4f4-d944-4686-ba87-db0e1e1b8a1b.png)'
- en: When using `flatMap`, it is essential to know what kind of Flux we are generating
    back. A simple change from `Flux.fromIterable` to `Flux.just` alters the complete
    behavior of the preceding code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`flatMap`时，了解我们正在生成哪种类型的Flux至关重要。将`Flux.fromIterable`简单地更改为`Flux.just`会改变前面代码的完整行为。
- en: The repeat operator
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重放操作符
- en: 'Reactor provides an operator to replay a stream of data. The `repeat` operator
    is designed for this purpose. It replays the steam upon receiving the completion
    event. Let''s suppose that we want to output the Fibonacci series twice. We will
    use the `repeat()` operator, with `2` as the argument to the `repeat()` operator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了一个操作符来重放数据流。`repeat`操作符是为了这个目的而设计的。它在接收到完成事件时重放流。假设我们想要输出斐波那契数列两次。我们将使用`repeat()`操作符，将`2`作为`repeat()`操作符的参数：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code generated the stream twice, as shown in the following output.
    It is important to note that the `repeat()` operator repeats a stream after receiving
    the completion event:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了两次流，如下所示输出。需要注意的是，`repeat()` 操作符在接收到完成事件后重复流：
- en: '![](img/f497e3c7-8d02-493e-bb9f-635828ea9e13.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f497e3c7-8d02-493e-bb9f-635828ea9e13.png)'
- en: 'Reactor also makes it possible to perform infinite repeats. The `repeat()`
    operator, invoked without any argument, replays the stream an infinite number
    of times:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 还使得执行无限重复成为可能。`repeat()` 操作符在没有任何参数的情况下，无限次数地回放流：
- en: '![](img/446a4439-972f-4885-80fa-c78956aa7099.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/446a4439-972f-4885-80fa-c78956aa7099.png)'
- en: There is also a predicate variant in which a Boolean provider is passed to the
    repeat operator. Upon completion, the provider is evaluated every time in order
    to discover whether the stream needs to be repeated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个谓词变体，其中将布尔提供者传递给重复操作符。在完成时，提供者每次都会被评估，以确定流是否需要重复。
- en: The collect operator
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`collect` 操作符'
- en: 'Reactor also provides operators that make it possible to accumulate data streams
    as collections. The most basic of these is the `collectList()` operator. The operator
    accumulates the data as a list, as shown in the following diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 还提供了使数据流作为集合累积的算子。其中最基本的是 `collectList()` 操作符。该操作符将数据累积为列表，如下所示图示：
- en: '![](img/cb2dce83-521a-4ec0-8b5a-9690ecc734dc.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb2dce83-521a-4ec0-8b5a-9690ecc734dc.png)'
- en: 'Let''s take our Fibonacci example and collect the data into a list. The collector
    method provides a Mono publisher that will emit a single list containing all of
    the published data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以斐波那契为例，将数据收集到列表中。收集器方法提供了一个 Mono 发布者，它将发出一个包含所有已发布数据的单个列表：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code performs the following actions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: The `take` operator selects the first 10 elements of the stream
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 操作符选择流中的前10个元素'
- en: It then accumulates them into a list, giving back a Mono publisher
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将它们累积到列表中，返回一个 Mono 发布者
- en: The list is provided to the subscriber, which prints it to the console
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表提供给订阅者，它将其打印到控制台
- en: 'The behavior is confirmed in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示输出确认了该行为：
- en: '![](img/8bf35886-454e-47ef-90f9-c0921fc23a04.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bf35886-454e-47ef-90f9-c0921fc23a04.png)'
- en: 'The `collectList()` operator aggregates the data in a list, but there is also
    a `CollectSortList` operator, which can collect data in a sorted list based on
    the natural order of the data. We can also provide a comparator to the `CollectSortedList`
    method to alter the order of the data, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectList()` 操作符将数据聚合到列表中，但还有一个 `CollectSortList` 操作符，可以根据数据的自然顺序收集数据到排序列表中。我们还可以向
    `CollectSortedList` 方法提供一个比较器来改变数据的顺序，如下所示代码：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code performs the following actions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: The `take` operator selects the first 10 elements of the stream
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 操作符选择流中的前10个元素'
- en: It then accumulates them into a `SortedList` by using the passed comparator
    function, giving back a Mono publisher
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用传递的比较函数将它们累积到 `SortedList` 中，返回一个 Mono 发布者
- en: The comparator function compares two long data types and reverses the evaluation
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较函数比较两个长数据类型并反转评估
- en: The list is provided to the subscriber, which prints it to the console
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表提供给订阅者，它将其打印到控制台
- en: 'Here, the subscriber receives a list in the reverse order of the data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，订阅者以数据的逆序接收列表：
- en: '![](img/3b0451f7-6cb7-423e-b425-9be7d015773f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b0451f7-6cb7-423e-b425-9be7d015773f.png)'
- en: The collectMap operator
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`collectMap` 操作符'
- en: 'Just like `collectlist()`, Reactor also provides `collectMap()` to accumulate
    data into a `java.util.Map`; `collectMap` takes a key generator function to create
    keys for the generated value elements. This is shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `collectlist()` 一样，Reactor 还提供了 `collectMap()` 来将数据累积到 `java.util.Map` 中；`collectMap`
    接受一个键生成函数来为生成的值元素创建键。如下所示代码：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code generates a `Map` with two keys that are represented as
    `even` and `odd`. It will keep the last even/odd number in the map. This is shown
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个包含两个键的 `Map`，键表示为 `even` 和 `odd`。它将保留地图中的最后一个偶数/奇数。如下所示：
- en: '![](img/2bab627b-6bdd-40a6-bf5d-4ee43acde4b4.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bab627b-6bdd-40a6-bf5d-4ee43acde4b4.png)'
- en: The `collectMap` command not only takes a `keyGeneator`, but also provides the
    option to pass a value generator. The value generator alters the original value
    of the data stream.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectMap` 命令不仅接受一个 `keyGenerator`，还提供了传递一个值生成器的选项。值生成器改变了数据流的原值。'
- en: 'There is also a `CollectMultiMap()` method, which collects data into a map
    of keys and lists them as values. Instead of overwriting the original value, it
    aggregates the values against the same key into a list. If executed with the `collectMultiMap`
    operator, the preceding code produces the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `CollectMultiMap()` 方法，它将数据收集到一个键的映射中，并将列表作为值列出。它不会覆盖原始值，而是将具有相同键的值聚合到一个列表中。如果使用
    `collectMultiMap` 运算符执行，前面的代码将产生以下输出：
- en: '![](img/04b9be62-26e1-4219-ba4d-2df87afd7cef.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04b9be62-26e1-4219-ba4d-2df87afd7cef.png)'
- en: In addition to the accumulators discussed previously, there is a generic `Collect`
    operator, which makes it possible to accumulate data into any format. This operator
    converts the Flux publisher back to a Mono publisher, emitting a single accumulated
    value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的累加器之外，还有一个通用的 `Collect` 运算符，它使得将数据累积到任何格式成为可能。此运算符将 Flux 发布者转换回 Mono
    发布者，并发出一个累积的单个值。
- en: The reduce operator
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reduce 运算符
- en: 'The preceding section covered value accumulation, whereas the reduce operation
    revolves around value consolidation. The reduce method makes it possible to aggregate
    the complete data stream into a single value. This is depicted as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节介绍了值累积，而 reduce 操作则围绕值合并。reduce 方法使得将完整的数据流聚合为单个值成为可能。如下所示：
- en: '![](img/b416e1ae-aa53-428c-beb9-8f70ea3b7805.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b416e1ae-aa53-428c-beb9-8f70ea3b7805.png)'
- en: 'Suppose that we want to generate a sum of Fibonacci numbers, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要生成斐波那契数的总和，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we did the following things:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下事情：
- en: The `take` operator selected the first 10 elements for the stream.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 运算符选择了流中的前 10 个元素。'
- en: The `reduce` operator took a Bifunction of the long type. The lambda expression
    returns the sum of the long values to generate the back sum.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce` 运算符接受一个长类型的 Bifunction。lambda 表达式返回长值的总和以生成回总和。'
- en: 'The `subscribe` operation received a `Mono<Long>`, which was printed on the
    console. This is depicted as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe` 操作接收一个 `Mono<Long>`，并在控制台上打印。如下所示：'
- en: '![](img/2a77eff6-a2a9-47c3-bc9b-aba8f8d6a5da.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a77eff6-a2a9-47c3-bc9b-aba8f8d6a5da.png)'
- en: There is also an overloaded `reduce` method, which can take an initial value
    as the starting point of the aggregation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个重载的 `reduce` 方法，它可以将一个初始值作为聚合的起始点。
- en: There is a special `count` operator that is responsible for returning the size
    of the stream.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的 `count` 运算符，负责返回流的大小。
- en: Conditional tests
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件测试
- en: 'Until now, we been discussed operators that work on original data. The Reactor
    framework provides Boolean operators that enable the testing of each of the data
    elements in the stream. There are two types of operators, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了在原始数据上工作的运算符。Reactor 框架提供了布尔运算符，可以测试流中的每个数据元素。有两种类型的运算符，如下所示：
- en: '`all`: This operator takes a predicate and confirms whether all of the elements
    meet the specified criteria. This is the logical `AND` operator for all data elements.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`：此运算符接受一个谓词，并确认所有元素是否满足指定的标准。这是所有数据元素的逻辑 `AND` 运算符。'
- en: '`any`: This operator takes a predicate and confirms whether any single element
    meets the specified criteria. This is a logical `OR` for all data elements.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`：此运算符接受一个谓词，并确认是否有任何单个元素满足指定的标准。这是所有数据元素的逻辑 `OR`。'
- en: 'The results of the preceding methods are consolidated into a single Boolean
    result, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输出被合并为一个单个布尔结果，如下所示：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we did the following things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下事情：
- en: The `take` operator selected the first `10` elements for the stream.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 运算符选择了流中的前 `10` 个元素。'
- en: The `all` operator took a Boolean predicate to confirm that all of the elements
    are greater than `0`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all` 运算符接受一个布尔谓词以确认所有元素都大于 `0`。'
- en: The `subscribe` operation received a `Mono<Boolean>`, which was printed on the
    console.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe` 操作接收一个 `Mono<Boolean>`，并在控制台上打印。'
- en: 'The output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/35894b33-c4f3-4993-8d02-e1eb146101e0.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35894b33-c4f3-4993-8d02-e1eb146101e0.png)'
- en: Appending data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据
- en: Until now, we have worked on data generated from a single Flux stream. Stream
    processing is not limited to one publisher. Reactor provides operators that make
    it possible to merge different publishers into one single stream of data. Values
    can be added either before the specified published values or after the published
    values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理来自单个Flux流的生成数据。流处理不仅限于一个发布者。Reactor提供了操作符，使得将不同的发布者合并成一个单一的数据流成为可能。值可以添加到指定的发布值之前或之后。
- en: The concatWith operator
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concatWith操作符
- en: 'The `concatWith` operator makes it possible to append a value event after the
    published values. It takes a publisher as input and appends the published values
    after the first publisher has completed, as shown in the following diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatWith`操作符使得在发布值之后附加一个值事件成为可能。它接受一个发布者作为输入，并在第一个发布者完成后，即`10`个元素之后，附加发布值，如下面的图所示：'
- en: '![](img/bb94a19a-ab39-4d9d-bce4-09bd97b7f150.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb94a19a-ab39-4d9d-bce4-09bd97b7f150.png)'
- en: 'Let''s suppose that we want to append some negative values at the end of our
    Fibonacci stream:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在Fibonacci流末尾附加一些负值：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we did the following things:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下几件事：
- en: The `take` operator selected the first `10` elements for the stream.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`操作符选择了流的前`10`个元素。'
- en: The `concatWith` operator took a publisher. It appended its values after the
    completion of the original stream, that is, after `10` elements.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concatWith`操作符接受一个发布者。它在原始流完成后附加其值，即`10`个元素之后。'
- en: The `subscribe` operation received a `Flux<Long>`, which was printed on the
    console.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`操作接收了一个`Flux<Long>`，它在控制台上打印出来。'
- en: Similar to `concatWith`, there is a `startWith` operator, which can be used
    to add values before the original stream values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与`concatWith`类似，还有一个`startWith`操作符，可以用于在原始流值之前添加值。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the wide range of operators available in Reactor.
    We started by looking at simple operators for selecting and rejecting data. We
    then looked at operators for converting data to other types. The converted data
    element does not need to be one-to-one mapped. There can be more than one element
    for each processed value. Next, we looked at operators that accumulate data. By
    the end of the chapter, we had covered aggregation and conditional tests for data.
    In a nutshell, we have covered the complete range of operators available in Reactor.
    In the next chapter we will look at the processors, which provide the necessary
    glue to bind Reactor components.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在Reactor中可用的各种操作符。我们首先查看用于选择和拒绝数据的简单操作符。然后，我们查看将数据转换为其他类型的操作符。转换后的数据元素不需要一对一映射。对于每个处理值，可以有多个元素。接下来，我们查看累积数据的操作符。到本章结束时，我们已经涵盖了数据的聚合和条件测试。简而言之，我们已经涵盖了Reactor中可用的所有操作符范围。在下一章中，我们将探讨处理器，它们提供了绑定Reactor组件所需的粘合剂。
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What operator is used to select data elements from a stream?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从流中选择数据元素的操作符是什么？
- en: What operator is used to reject data elements from a stream?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从流中拒绝数据元素的操作符是什么？
- en: What operators does Reactor offer for data conversion? How are these operators
    different from each other?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor提供了哪些数据转换操作符？这些操作符彼此之间有何不同？
- en: How can we perform data aggregation by using Reactor operators?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Reactor操作符执行数据聚合？
- en: What conditional operators are offered by Reactor?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor提供了哪些条件操作符？
