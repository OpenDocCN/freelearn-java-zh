- en: 'Chapter 10: Implementing User Interaction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：实现用户交互
- en: '**User interaction** constitutes a very important layer in software architecture.
    This layer comprises all the ways, such as web interfaces and mobile applications,
    that end users can approach and use our applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户交互**构成了软件架构中的一个非常重要的层。这一层包括所有终端用户可以接近和使用我们的应用程序的方式，例如Web界面和移动应用程序。'
- en: For this reason, user interaction needs to be implemented with very high attention
    to detail. A badly designed, poorly performing user interface will compromise
    the overall user experience, even if the rest of the application is well written
    and performs really well. And indeed, the user interface can use a number of different
    tricks to hide issues (such as performance issues) in other layers of the software
    architecture (that is, *the backend*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户交互需要非常注重细节地实现。一个设计糟糕、性能不佳的用户界面会损害整体的用户体验，即使应用程序的其他部分编写得很好并且性能真的很出色。实际上，用户界面可以使用许多不同的技巧来隐藏软件架构其他层（即*后端*）中存在的问题（如性能问题）。
- en: In this chapter, we are going to explore the most widely used technologies for
    Java applications, both for cloud-native and traditional applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Java应用程序最广泛使用的技术，无论是云原生应用程序还是传统应用程序。
- en: This will include frameworks built using the **Java Enterprise Edition** platform
    (such as **Jakarta Server Pages** and **Jakarta Server Faces**) and more modern
    JavaScript frameworks for single-page applications (React, in our case).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括使用**Java企业版**平台（如**Jakarta Server Pages**和**Jakarta Server Faces**）构建的框架，以及用于单页应用程序的更现代的JavaScript框架（在我们的例子中是React）。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: User interface architecture – backend versus frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面架构——后端与前端
- en: Web user interfaces using Jakarta Server Faces and Jakarta Server Pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jakarta Server Faces和Jakarta Server Pages构建的Web用户界面
- en: Introducing single-page applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍单页应用程序
- en: Learning about mobile application development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解移动应用程序开发
- en: Exploring IVR, chatbots, and voice assistants
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索IVR、聊天机器人和语音助手
- en: Omnichannel strategy in enterprise applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业应用程序的多渠道策略
- en: Let's start by concentrating on the architecture of the user interaction layer,
    or rather, where to put each component and functionality. We will touch on the
    architectural aspects of building frontend layers for our applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先集中精力研究用户交互层的架构，或者更确切地说，每个组件和功能应该放在哪里。我们将涉及为我们的应用程序构建前端层的架构方面。
- en: User interface architecture – backend versus frontend
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面架构——后端与前端
- en: It may seem silly to discuss where a **User Interface** (**UI**) must live.
    After all, it's almost a given – the UI is the forefront of our software architecture,
    providing the interaction with end users, and for this reason, it must stay at
    the front, hence the term *frontend*, which is used as a synonym for UI. And everybody
    agrees on that, without a doubt.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论一个**用户界面**（**UI**）必须存在于何处可能看起来很荒谬。毕竟，这几乎是肯定的——UI是软件架构的前沿，提供与最终用户的交互，因此它必须保持在最前面，这就是为什么我们使用*前端*这个术语，它被用作UI的同义词。毫无疑问，每个人都同意这一点。
- en: 'Except that it''s not that easy to draw a line as to where a UI starts and
    where it ends. And, depending on the particular implementation, a number of different
    components may provide the functionalities needed to build the experience we want
    to eventually present to our customers. The UI will be made of, more or less,
    the following components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它并不容易划出一条线来界定UI的起始和结束之处。而且，根据特定的实现方式，许多不同的组件可能提供构建我们最终希望向客户展示的体验所需的功能。UI将由以下组件组成，或多或少：
- en: '**Assets, also referred to as static files**: These are the pieces of the web
    application that must be sent (where relevant) to our clients. They include, usually,
    HTML files, JavaScript scripts, other graphical artifacts (images, CSS files,
    and movie clips), and even fully built, self-contained applications (as in the
    case of mobile apps).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产**，也称为静态文件：这些是必须发送到我们的客户端的Web应用程序的组成部分（在相关的情况下）。通常包括HTML文件、JavaScript脚本、其他图形元素（图像、CSS文件和电影剪辑），甚至完全构建的自包含应用程序（如移动应用程序的情况）。'
- en: '**Data**: This is the content shown using the assets. This implies having a
    way to retrieve updates (usually involving web services or similar technology).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是使用资产显示的内容。这意味着需要一种方式来检索更新（通常涉及Web服务或类似技术）。'
- en: '**Behavior**: This refers to how the UI reacts to user inputs and other events.
    This is a broader area that includes *interactivity* (what changes, and how, when
    our user does something), *validation* (checking user inputs for formal and substantial
    consistency), *navigation* (how different views, or pages, must be shown one after
    the other to implement the features requested by the user), and *security* (how
    to be sure that each user is properly identified and profiled, able to do only
    what they are allowed to do, and able to access only the appropriate set of data).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**：这指的是UI如何响应用户输入和其他事件。这是一个更广泛的概念，包括*交互性*（当用户做某事时，什么会改变以及如何改变），*验证*（检查用户输入的正式和实质性一致性），*导航*（如何依次显示不同的视图或页面以实现用户请求的功能），以及*安全*（如何确保每个用户都得到适当的识别和配置文件，只能做他们被允许做的事情，并且只能访问适当的数据集）。'
- en: The point is more or less this – different implementations will have different
    ways of providing assets to end users, different ways of providing (and collecting)
    data, and different implementations of behavior (such as navigation or validation
    being implemented on the client side or the server side). In this chapter, we
    will look at the most common ways to arrange all of those components to provide
    a good user experience. Our next section will be about the most traditional ways
    to implement this in Java Enterprise Edition – Jakarta Server Faces and Jakarta
    Server Pages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是或多或少这样——不同的实现将会有不同的方式向最终用户提供资源，不同的方式提供（和收集）数据，以及不同的行为实现（例如，在客户端或服务器端实现导航或验证）。在本章中，我们将探讨安排所有这些组件以提供良好用户体验的最常见方式。我们下一节将介绍在Java企业版中实现这一点的最传统方式——Jakarta
    Server Faces和Jakarta Server Pages。
- en: Web user interface using Jakarta Server Pages and Jakarta Server Faces
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jakarta Server Pages和Jakarta Server Faces的Web用户界面
- en: If you have ever worked with Java Enterprise applications developed from 2000
    to 2015, chances are you have seen **Java Server Pages** (**JSP**) and **Java
    Server Faces** (**JSF**) in action. Now widely considered legacy, these two technologies
    still appear widely in existing Java deployments and are worth knowing about,
    at least for historical reasons.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经与2000年至2015年间开发的Java企业应用程序合作过，那么你很可能已经看到了**Java Server Pages**（**JSP**）和**Java
    Server Faces**（**JSF**）的实际应用。现在这两个技术广泛被认为是过时的，但它们仍然在现有的Java部署中广泛使用，至少从历史的角度来看是值得了解的。
- en: Introducing basic Java web technology – Jakarta Server Pages
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍基本的Java Web技术——Jakarta Server Pages
- en: '**Jakarta Server Pages** (formerly Java Server Pages) is, in essence, a templating
    technology, allowing you to mix dynamic content written in Java with static content
    (usually written in HTML). By using JSP, an application server can build a web
    page to provide to a client (and visualize in a web browser). We already talked
    about JSP in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141), *Exploring
    Essential Java Architectural Patterns*, when talking about server-side **Model
    View Controller** (**MVC**). If you remember, JSP plays the role of the *View*
    in the MVC pattern. In the same context, we mentioned servlets as another core
    component, taking care of the *Controller* part of MVC.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jakarta Server Pages**（以前称为Java Server Pages）本质上是一种模板技术，允许你将用Java编写的动态内容与静态内容（通常用HTML编写）混合。通过使用JSP，应用服务器可以构建一个网页提供给客户端（并在网页浏览器中可视化）。我们已经在[*第6章*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)《探索Java关键架构模式》中讨论了JSP，当时我们谈到服务器端的**模型-视图-控制器**（**MVC**）。如果你还记得，JSP在MVC模式中扮演着*视图*的角色。在相同的情况下，我们还提到了servlet作为另一个核心组件，负责MVC的*控制器*部分。'
- en: It's now time to clarify the relationship between servlets and JSP. Assuming
    that most of you know what a servlet is, I will provide just a very brief description.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候阐明servlet和JSP之间的关系了。假设你们大多数人已经知道什么是servlet，我将只提供一个非常简短的描述。
- en: A `init()`, called when the servlet is loaded, and `destroy()`, called before
    the servlet is unloaded), while others are called when HTTP actions are performed
    against the servlet (such as `doPost(...)`, to handle an HTTP `POST` request,
    and `doGet(...)`, to do the same with a `GET` request).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当servlet被加载时调用的`init()`，以及在被卸载前调用的`destroy()`，而其他的是在针对servlet执行HTTP操作时调用的（例如，`doPost(...)`来处理HTTP
    `POST`请求，以及`doGet(...)`来处理`GET`请求）。
- en: So far so good! Servlets are specialized components, able to handle HTTP conversations,
    and for this reason, they are used to complement views (such as JSP files) in
    providing user experience features (such as form submission and page navigation).
    As we have discussed, it is common for a servlet to be the *controller*, whereas
    a JSP file is used as the *view*, although more sophisticated frameworks have
    been developed to deal with JSP, such as Struts and the Spring MVC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！Servlet是专门用于处理HTTP对话的组件，因此它们被用来补充视图（如JSP文件），以提供用户体验功能（如表单提交和页面导航）。正如我们讨论的，servlet通常作为*控制器*，而JSP文件则用作*视图*，尽管已经开发出更复杂的框架来处理JSP，如Struts和Spring
    MVC。
- en: But there is another point worth noting – JSP files are basically servlets themselves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一个值得注意的点——JSP文件本质上也是servlet。
- en: A JSP file, indeed, is just a different way to implement a servlet. Each JSP
    file, at runtime, is translated into a servlet by the application server running
    our code. As we discussed in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*, we need an application server fully or
    partially compliant with the JEE specification in order to run each JEE API (including
    the servlet and JSP APIs).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，JSP文件只是实现servlet的一种不同方式。在运行时，每个JSP文件都被运行我们代码的应用服务器转换成servlet。正如我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)中讨论的，*探索中间件和框架*，我们需要一个完全或部分符合JEE规范的应用服务器来运行每个JEE
    API（包括servlet和JSP API）。
- en: So, now that we know that JSP is a templating technology and that each JSP file
    is translated to a servlet, which outputs to the client what we have modeled in
    the template, it is time to see what a JSP file looks like.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了JSP是一种模板技术，并且每个JSP文件都被转换成servlet，它输出我们在模板中建模的内容，是时候看看JSP文件的样子了。
- en: A JSP file is somewhat similar to a `<% ... %>`, which is called a **scriptlet**
    and contains arbitrary Java code. A scriptlet is executed when a client requests
    a page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSP文件与`<% ... %>`有些相似，这被称为**脚本片段**，其中包含任意Java代码。当客户端请求页面时，脚本片段会被执行。
- en: 'Another tag used in JSP is marked using `<%= %>` and is called an `<%@ ...
    %>` and used to configure page metadata. A very basic JSP page might look like
    this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JSP中使用的另一个标签是用`<%= %>`标记的，称为`<%@ ... %>`，用于配置页面元数据。一个非常基本的JSP页面可能看起来像这样：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some things worth noticing are listed as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一些事项如下：
- en: At the top of the files, directives are used. They define some metadata (the
    page content type and the language used) and the Java packages to be imported
    and used on the page.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件顶部，使用指令。它们定义了一些元数据（页面内容类型和使用的语言）以及要在页面上导入和使用的Java包。
- en: There is some HTML code interleaved with the scripts. The code inside the script
    delimiters is largely recognizable to Java developers, as it simply formats a
    date.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本中穿插了一些HTML代码。脚本分隔符内的代码对Java开发者来说很容易识别，因为它只是格式化日期。
- en: In the first scriptlet, we define the `date` variable. We can then access it
    in the expression inside the `<h1>` HTML tag. The expression simply refers to
    the variable. The engine will then replace the variable value in that spot in
    the generated HTML page.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个脚本片段中，我们定义了`date`变量。然后我们可以在`<h1>`HTML标签内的表达式中访问它。该表达式简单地引用了变量。然后引擎将在生成的HTML页面中的该位置替换变量的值。
- en: 'In a real-world application, we can imagine some useful ways to use such syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可以想象一些使用这种语法的有用方式：
- en: We could use scriptlets to retrieve useful data by calling external services
    or using database connections.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用脚本片段通过调用外部服务或使用数据库连接来检索有用的数据。
- en: By using Java code in the scriptlets, it is easy to implement iterations (usually
    to display tabular data) and format data in a preferred way (both in scriptlets
    and expressions).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本片段中使用Java代码，可以轻松实现迭代（通常用于显示表格数据）并以首选方式（在脚本片段和表达式中）格式化数据。
- en: Java code in scriptlets can be used to get and validate data provided by the
    user (usually using HTML forms). Moreover, user sessions and security can be managed
    in different ways (usually by leveraging cookies).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本片段中的Java代码可以用来获取和验证用户提供的（通常使用HTML表单）数据。此外，用户会话和安全可以以不同的方式管理（通常通过利用cookie）。
- en: It's also worth noticing that JSP directives can be used to include other JSP
    files. In this way, the logic can be modularized and reused.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，JSP指令可以用来包含其他JSP文件。这样，逻辑可以模块化并重用。
- en: 'Moreover, JSP allows defining custom tag libraries. Such libraries are collections
    of personalized tags that embed custom logic that is executed when a tag is used.
    A widely used tag library is the one provided by default by the JSP implementation,
    which is the **Jakarta Standard Tag Library** (**JSTL**). In order to use a tag
    library (JSTL core, in this case), we need to use a directive to import it like
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSP允许定义自定义标签库。这样的库是包含个性化标签的集合，这些标签在标签被使用时执行自定义逻辑。一个广泛使用的标签库是JSP实现默认提供的，即**Jakarta
    Standard Tag Library**（**JSTL**）。为了使用标签库（在这种情况下是JSTL核心），我们需要使用指令来导入它，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The JSTL provides a set of tags that offer the following functionalities:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSTL提供了一套标签，提供了以下功能：
- en: '`Core` provides basic functionalities such as flow control (loops and conditional
    blocks) and exception handling.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Core`提供基本功能，如流程控制（循环和条件块）和异常处理。'
- en: '`JSTL` is used mostly for string manipulation and variable access.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSTL`主要用于字符串操作和变量访问。'
- en: '`SQL` implements basic database connection handling and data access.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL`实现基本的数据库连接处理和数据访问。'
- en: '`XML` is used for XML document manipulation and parsing.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XML`用于XML文档操作和解析。'
- en: '`Formatting` is a set of functions useful for formatting variables (such as
    dates and strings), according to character encodings and locale.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Formatting`是一组用于根据字符编码和区域设置格式化变量（如日期和字符串）的函数。'
- en: 'So, the date formatting that we did in our previous example can be summarized
    with the appropriate JSTL tags (included from the `Core` and `Formatting` collections)
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前示例中使用的日期格式化可以通过适当的JSTL标签（从`Core`和`Formatting`集合中包含）总结如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But even if JSTL tags are supposed to reduce the amount of Java code in JSP
    files, it's very hard to entirely remove *all* Java code. Java code mixed with
    presentation code is considered an antipattern to avoid, and it's not the only
    consideration to be made. In the next section, we will see why JSP is considered
    a legacy technology and almost every Java project today relies on different options
    for frontend development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使JSTL标签旨在减少JSP文件中的Java代码量，但完全删除*所有*Java代码仍然非常困难。将Java代码与展示代码混合被认为是应避免的反模式，而且这并不是唯一需要考虑的因素。在下一节中，我们将看到为什么JSP被认为是遗留技术，并且今天几乎每个Java项目都依赖于不同的前端开发选项。
- en: JSP – the downsides
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSP – 不足之处
- en: 'Now, it''s time to look at the bad news. There are a number of reasons why
    JSP is nowadays widely considered unsuitable for modern applications. I can summarize
    some of those reasons:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看坏消息了。有许多原因使得JSP如今被广泛认为不适合现代应用程序。我可以总结其中的一些原因：
- en: JSP allows for Java code to be interleaved with HTML code. For this reason,
    it becomes very easy to mix presentation logic with business logic. The result
    is often an ugly mess (especially in big applications), as it becomes tempting
    to have presentation logic slip into Java code (such as conditional formatting
    and complex loops), with the final result being JSP pages that are both hard to
    read and maintain.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP允许Java代码与HTML代码交织在一起。正因为如此，将展示逻辑与业务逻辑混合变得非常容易。结果通常是一个丑陋的混乱（尤其是在大型应用程序中），因为展示逻辑滑入Java代码（如条件格式化和复杂循环）变得很有诱惑力，最终结果是既难以阅读又难以维护的JSP页面。
- en: For similar reasons, a collaboration between different teams with different
    skills is very difficult. Frontend teams (such as graphic designers) are supposed
    to work on the HTML sections of a JSP file, while the same file could be being
    worked on by the backend team for adding business logic-related functionalities.
    This leads to a resource contention that is hard to solve, as each team may break
    the other team's implementations.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于类似的原因，不同技能团队之间的协作非常困难。前端团队（如图形设计师）应该负责处理JSP文件的HTML部分，而同一文件可能同时被后端团队修改以添加与业务逻辑相关的功能。这导致了一种难以解决的资源争用，因为每个团队都可能破坏其他团队的实现。
- en: Focusing on frontend development, the development cycle is cumbersome and has
    a slow turnaround. Frontend developers and graphic designers are used to editing
    an HTML file, refreshing the browser, and immediately seeing the result. With
    JSP, this is just not possible; usually, the project has to be rebuilt into an
    artifact (such as a `.war` file) and redeployed to an application server. There
    can be solutions to this particular issue (such as exploded deployments, where
    a `.war` file is deployed as an extracted folder), but they are usually implemented
    differently depending on the application server and may have some downsides (such
    as not covering all the different kinds of modifications to the file or incurring
    out-of-memory exceptions if performed too many times).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于前端开发，开发周期繁琐，且周转速度慢。前端开发人员和图形设计师习惯于编辑 HTML 文件，刷新浏览器，并立即看到结果。使用 JSP，这根本不可能；通常，项目必须重建为一个工件（如
    `.war` 文件），并重新部署到应用程序服务器。对于这个问题可能有解决方案（例如爆炸式部署，其中 `.war` 文件作为提取的文件夹部署），但它们通常根据应用程序服务器而有所不同，并且可能有一些缺点（例如，可能无法涵盖文件的所有不同类型的修改，或者在执行次数过多时可能导致内存不足异常）。
- en: This leads to another very important point – JSP files require an application
    server that is fully or partially implementing the JEE specification. **Apache
    Tomcat** is a common choice here. Indeed, instead of a basic web server serving
    static content (which is what is used with modern client-side frameworks, as we
    will see in a couple of sections), you will need a **Java Virtual Machine** (**JVM**)
    and an application server (such as Tomcat) running on top. This will mean slightly
    more powerful machines are needed, and fine-tuning and security testing must be
    performed more thoroughly (simply because Java application servers are more complex
    than static files serving web servers, not because Java is less secure per se).
    Furthermore, frontend developers will need to use this server (maybe on their
    local workstation) for development purposes (and that may not be the simplest
    thing to manage).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这引出了另一个非常重要的观点——JSP 文件需要一个完全或部分实现 JEE 规范的应用程序服务器。**Apache Tomcat** 是这里的一个常见选择。确实，你将需要一个
    **Java 虚拟机**（**JVM**）和一个运行在顶部的应用程序服务器（如 Tomcat），这意味着需要稍微更强大的机器，并且需要进行更彻底的微调和安全性测试（仅仅因为
    Java 应用程序服务器比静态文件服务的 Web 服务器更复杂，并不是因为 Java 本身就不安全）。此外，前端开发人员将需要使用这个服务器（可能在他们的本地工作站上）进行开发目的（这可能不是最简单的事情来管理）。
- en: JSP also lacks a simple way of sharing components between different pages and
    applications. Also, the JSP tags are usually a bit cumbersome to use, especially
    in complex applications.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP 缺乏在不同页面和应用程序之间共享组件的简单方法。此外，JSP 标签通常使用起来有些繁琐，尤其是在复杂的应用程序中。
- en: Moreover, the performance in JSP applications is overall worse when compared
    to single-page applications. Modern JavaScript frameworks for single-page applications
    are indeed designed to keep the data exchange with the server at a minimum – after
    you download the HTML files and assets for the first time, and only then, the
    data is exchanged. This is not so easy to achieve with just JSP, which, in general,
    is designed to render the server-side page and download it as a whole.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，与单页应用程序相比，JSP 应用程序的整体性能较差。现代单页应用程序的 JavaScript 框架确实是为了将数据与服务器之间的交换保持在最低限度而设计的——在你第一次下载
    HTML 文件和资产之后，然后才会进行数据交换。仅用 JSP 实现这一点并不容易，因为 JSP 通常是为了渲染服务器端页面并将其作为一个整体下载而设计的。
- en: Finally, the intrinsic nature of JSP makes things more complex from an architectural
    point of view. Since, in a JSP file, you can use Java code, which entails calling
    backend services and doing SQL queries, the flow of calls may become complex and
    convoluted. *Are you supposed to have connections from the frontend directly to
    the database?* *What about services exposed by the backend?* Instead of having
    a thin, simple frontend layer used mostly for visualization and interactivity,
    you will have business logic and data manipulation sprawling all over the frontend
    layer. Not the best situation from an architectural standpoint.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从架构角度来看，JSP 的内在特性使得事情变得更加复杂。因为在一个 JSP 文件中，你可以使用 Java 代码，这涉及到调用后端服务和执行 SQL
    查询，调用流程可能会变得复杂和混乱。*你真的需要从前端直接连接到数据库吗？* *后端暴露的服务怎么办？* 与之相反，你将拥有业务逻辑和数据操作散布在前端层，而不是一个薄薄的前端层，主要用于可视化和交互。从架构角度来看，这并不是最佳情况。
- en: So, now we have seen the basics of JSP, which is a complete template engine
    that's useful for defining HTML websites and providing some dynamic content written
    in Java. We've also understood what the limitations of the technology are. It
    is now worth noticing that JEE provides a more complex and complete framework
    for building web apps, which is Jakarta Server Faces.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经了解了 JSP 的基础知识，JSP 是一个完整的模板引擎，用于定义 HTML 网站，并提供一些用 Java 编写的动态内容。我们也已经了解了这项技术的局限性。现在值得注意的是，JEE
    提供了一个更复杂、更完整的框架来构建 Web 应用程序，这就是 Jakarta Server Faces。
- en: Jakarta Server Faces – a complex JEE web technology
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jakarta Server Faces – 一个复杂的 JEE Web 技术
- en: '**Jakarta Server Faces** (**JSF**) is a much more complete (and complex) framework
    compared to JSP. It implements the MVC pattern, and it is much more prescriptive
    and opinionated. This means that concepts such as variable binding, page navigation,
    security, and session handling are core concepts of the framework. It also provides
    a component-centric view, meaning that it provides reusable components, which
    include complex view functionalities such as tables, forms, inputs, and validation.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jakarta Server Faces** (**JSF**) 相比于 JSP 是一个更加完整（且复杂）的框架。它实现了 MVC 模式，并且更加具有指导性和观点性。这意味着诸如变量绑定、页面导航、安全和会话处理等概念是框架的核心概念。它还提供了一个以组件为中心的视图，这意味着它提供了可重用的组件，包括复杂的视图功能，如表格、表单、输入和验证。'
- en: As per the *view* component of the MVC pattern, JSF used to rely on JSP templating.
    In more recent implementations, this has been switched by default to **Facelets**,
    which is an XML-based templating technology.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 MVC 模式的 *视图* 组件，JSF 以前依赖于 JSP 模板。在更近的实现中，这已被默认切换到 **Facelets**，这是一种基于 XML
    的模板技术。
- en: The *controller* part of JSF is implemented by a special servlet, **FacesServlet**,
    which takes care of things such as resources initialization, life cycle, and request
    processing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 的 *控制器* 部分由一个特殊的 servlet，**FacesServlet**，实现，它负责资源初始化、生命周期和请求处理等事务。
- en: Finally, the *model* part of JSF is implemented using so-called *managed beans*,
    which are simply Java classes with a set of properties, getters, and setters.
    Managed beans are used to bind to pages and components in pages, containing values
    to be displayed, validating the user input, and handling events. Managed beans
    can be configured to live within different scopes, including a session (attached
    to an HTTP session), a request (the same, but with an HTTP request), and an application
    (living as long as the entire web application does).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JSF 的 *模型* 部分是通过所谓的 *管理 Bean* 实现的，这些管理 Bean 简单来说就是具有一组属性、获取器和设置器的 Java 类。管理
    Bean 用于绑定到页面和页面中的组件，包含要显示的值、验证用户输入和处理事件。管理 Bean 可以配置为在不同的范围内存在，包括会话（附加到 HTTP 会话）、请求（与
    HTTP 请求相同）和应用（在整个 Web 应用程序的生命周期内存在）。
- en: There are a number of different JSF implementations, with the most famous being
    the **Mojarra JSF** (backed by Oracle). Other projects extend such implementation,
    also providing a suite of reusable components. The most famous ones are **RichFaces**
    (backed by Red Hat and discontinued for many years), **IceFaces**, and **PrimeFaces**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 JSF 实现，其中最著名的是 **Mojarra JSF**（由 Oracle 支持）。其他项目扩展了这种实现，同时也提供了一套可重用的组件。最著名的是
    **RichFaces**（由 Red Hat 支持，许多年已停止开发），**IceFaces** 和 **PrimeFaces**。
- en: This is an overview of the internal architecture and basics of JSF. Without
    going into too much detail, let's analyze, as we have done for JSP, the downsides
    of JSF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 JSF 内部架构和基础的一个概述。在不深入太多细节的情况下，让我们像分析 JSP 一样，分析 JSF 的缺点。
- en: JSF – the downsides
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF – 缺点
- en: 'Let''s start by saying that, whereas JSP is currently considered legacy but
    sometimes still used here and there for basic tasks (for simple internal web interfaces
    such as administration panels), JSF is today avoided wherever possible. The reason
    for this is that, on top of the JSP''s downsides, JSF adds some more. This is
    what I can say about it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们说，虽然 JSP 目前被认为是过时的技术，但有时仍然用于一些基本任务（例如简单的内部网络界面，如管理面板），但 JSF 在今天尽可能避免使用。原因在于，除了
    JSP 的缺点之外，JSF 还增加了一些。以下是我对它的看法：
- en: '**JSF is very hard to learn**: While basic tasks are easy to perform, JSF does
    a lot of things behind the scenes, such as managing the life cycle of pages and
    building stateful sessions, that are very hard to master. For this reason, it''s
    common to use it in the wrong way or take advantage of only a small subset of
    all the features provided, making it overkill and difficult to manage for most
    web applications.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSF 非常难以学习**：虽然基本任务很容易完成，但 JSF 在幕后做了很多事情，例如管理页面生命周期和构建有状态的会话，这些都非常难以掌握。因此，它通常被错误地使用，或者只利用所有提供功能的一小部分，这使得它对于大多数网络应用来说都是过度设计且难以管理的。'
- en: '**JSF is difficult to test**: Unit tests can be written for some components
    (such as managed beans) but it is very hard to automate all the tests, especially
    on the *view* side (Facelets), mostly because it''s almost impossible to remove
    logic from that layer (and, as we know, having logic in the *view* layer is a
    terrible idea).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSF 难以测试**：可以为某些组件（如管理 Bean）编写单元测试，但自动执行所有测试非常困难，尤其是在*视图*方面（Facelets），主要是因为几乎不可能从该层中移除逻辑（而且，正如我们所知，在*视图*层中包含逻辑是一个糟糕的想法）。'
- en: '**JSF is hard to troubleshoot**: Since, as we said, JSF manages many things
    behind the scenes (above all, the binding of variables handled by the browser
    with the values contained in the managed beans), it''s really hard to understand
    the cause of things going wrong (such as variables not being updated and performance
    issues).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSF 难以调试**：由于，正如我们所说，JSF 在幕后管理很多事情（尤其是浏览器中处理的变量与托管 Bean 中包含的值之间的绑定），很难理解出错的原因（例如变量未更新和性能问题）。'
- en: '**JSF lacks a proper implementation for some small but very useful features**:
    The first things here that come to mind are AJAX communication (where some values
    on a web page are updated without the need of a full-page reload) and friendly
    URLs (when the URL of a page can be customized, which is helpful because it makes
    it easily readable and favored by search engines). For both of those features,
    there are some workarounds, but they are incomplete, not standard, and in general
    have been added late to the framework. Those are just two examples, but there
    are many; it''s all down to a general inflexibility of the framework.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSF 缺乏一些小但非常有用的特性的适当实现**：首先想到的是 AJAX 通信（在网页上的一些值可以在不重新加载整个页面的情况下更新）和友好的 URL（当页面的
    URL 可以自定义时，这很有帮助，因为它使得它易于阅读并且受到搜索引擎的青睐）。对于这两个特性，有一些解决方案，但它们是不完整的、非标准的，并且在一般情况下是在框架中较晚添加的。这些只是两个例子，但还有很多；这都归因于框架的一般僵化。'
- en: The preceding points are enough to understand why, as of today, almost everybody
    agrees with JSF being a legacy technology that must not be adopted in new projects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述要点足以说明为什么，到目前为止，几乎每个人都同意 JSF 是一种过时的技术，不应该在新项目中采用。
- en: For this reason, it is not worth providing code samples of JSF.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提供 JSF 的代码示例是没有意义的。
- en: In this section, we have looked at the two major web technologies built using
    the JEE framework. As we have seen, these technologies, even if they are still
    widely used, have some big limitations (especially JSF), mostly coming from their
    *monolithic* approach, meaning that they are tightly coupled with backend implementation,
    and their limited flexibility.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了使用 JEE 框架构建的两个主要网络技术。正如我们所见，这些技术，尽管它们仍然被广泛使用，但有一些很大的局限性（尤其是 JSF），主要来自它们的*单体*方法，这意味着它们与后端实现紧密耦合，并且它们的灵活性有限。
- en: In the next section, we will look at the widely used alternative to JEE native
    web technology – the single-page application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨广泛使用的 JEE 原生网络技术的替代品——单页应用程序。
- en: Introducing single-page applications
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍单页应用程序
- en: '**Single-Page Applications** (or **SPAs**) is a broad term that came about
    to simply describe the behavior of some solutions meant to create web UIs in a
    lighter, more modern way. The first characteristic of the SPA is the one that
    it relates to the name. An SPA, in general, bundles all the assets necessary to
    start user interaction into a single HTML document and sends it to the client.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（或**SPA**）是一个广泛的概念，用来简单地描述一些旨在以更轻量、更现代的方式创建网络 UI 的解决方案的行为。SPA 的第一个特征就是与它的名字相关。一般来说，SPA
    将启动用户交互所需的所有资产打包到一个单独的 HTML 文档中，并将其发送到客户端。'
- en: All the following interactions between the client and the server, including
    loading data, sending data back, and loading other assets (as images or CSS files),
    are performed within the page using JavaScript. For this reason, SPAs minimize
    the communication between the client and server (improving performances), avoid
    the full-page refresh, and allow for a simpler architectural model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的客户端和服务器之间的交互，包括加载数据、发送数据回服务器以及加载其他资源（如图像或CSS文件），都是通过JavaScript在页面内完成的。因此，SPA最小化了客户端和服务器之间的通信（提高性能），避免了整个页面的刷新，并允许更简单的架构模型。
- en: Indeed, a basic, static file-serving web server (such as **Apache HTTPD** or
    **NGINX**) is all you need on the frontend (no Java application server is needed).
    Moreover, the interaction between client and server is almost exclusively limited
    to web service calls (usually JSON over REST), hence mixing backend and frontend
    logic (such as doing SQL queries from the frontend layer) is highly discouraged.
    The most significant downside that I see with SPAs is that there is no standardization
    of them. Unlike JEE technologies, each framework here provides its own different
    approach.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在前端（不需要Java应用服务器）上，你只需要一个基本的、静态的文件服务型网络服务器（例如 **Apache HTTPD** 或 **NGINX**）。此外，客户端和服务器之间的交互几乎完全局限于对Web服务的调用（通常是REST上的JSON），因此混合后端和前端逻辑（例如从前端层执行SQL查询）是高度不建议的。我认为单页应用（SPA）最显著的缺点是它们没有标准化。与JEE技术不同，每个框架在这里都提供自己的不同方法。
- en: For this reason, there are a number of different, well-written, but incompatible
    implementations of frameworks for building SPAs. Most (if not all) heavily rely
    on JavaScript and are independent of what's used in the backend (provided that
    the backend can expose a compatible services layer, such as JSON over REST). In
    this context, we take for granted that a Java backend (JEE or something more modern,
    exposing a REST service) is provided.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在许多不同、编写良好但不兼容的框架实现，用于构建SPA。大多数（如果不是所有）都严重依赖JavaScript，并且与后端使用的任何技术无关（只要后端可以公开一个兼容的服务层，如REST上的JSON）。在这种情况下，我们假设提供了一个Java后端（JEE或更现代的版本，公开REST服务）。
- en: But it is not uncommon for simpler projects to go for a full-stack approach
    (using JavaScript also on the backend, usually running on a server such as **Node.js**)
    or using different backend technology (such as Python or PHP). For the sake of
    brevity in this chapter, we will explore just one SPA framework, **React**, which
    is backed by Facebook and widely used for building web applications, from small
    websites to large and popular platforms such as social networks. But it is worth
    noting that there are a number of similarly powerful alternatives (such as Angular,
    Vue, and Svelte), and since no standard is provided, there is no guarantee of
    the life cycle of any such technology, nor is it possible to easily move code
    written in one implementation to another. In order to start playing with SPAs,
    a preamble on the JavaScript ecosystem will be needed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于更简单的项目来说，采用全栈方法（在后台也使用JavaScript，通常在**Node.js**服务器上运行）或使用不同的后端技术（如Python或PHP）并不少见。为了本章的简洁性，我们将仅探讨一个SPA框架，**React**，它由Facebook支持，广泛用于构建从小型网站到大型和流行的平台（如社交网络）的Web应用程序。但值得注意的是，还有许多类似强大的替代方案（如Angular、Vue和Svelte），由于没有提供标准，无法保证任何此类技术的生命周期，也无法轻松地将一种实现中编写的代码移动到另一种实现中。为了开始尝试SPA，需要先对JavaScript生态系统有一个概述。
- en: Basics of the JavaScript ecosystem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript生态系统基础
- en: I suppose that most of the readers of this book are beginners or experienced
    Java developers and junior architects, with little or no exposure to JavaScript.
    Of course, JavaScript is a huge and interesting world that cannot be completely
    described in just a few paragraphs, so the goal of this section is just to give
    you the basics, enough for the next couple of sections, which will focus on React.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜这本书的大多数读者都是初学者或经验丰富的Java开发人员和初级架构师，对JavaScript接触很少或没有接触。当然，JavaScript是一个庞大而有趣的世界，无法在几段文字中完全描述，所以本节的目标只是给你一些基础知识，足够用于接下来的几节，这些章节将专注于React。
- en: JavaScript was born in 1995, mostly for programming inside a web browser. Originally
    designed for Netscape, it was of course then implemented as part of most major
    web browsers. Even if the name looks very similar, JavaScript doesn't share that
    much with the Java language, being interpreted (whereas Java is compiled into
    bytecode) and dynamically typed (so it checks for type safety at runtime, while
    Java is statically typed, checking for type safety at build time). And there are
    a number of other differences, including the object model, APIs, and dependency
    management. JavaScript has been standardized into a technical specification called
    **ECMAScript**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript诞生于1995年，主要用于在网页浏览器内编程。最初是为Netscape设计的，当然后来作为大多数主要网页浏览器的一部分得到实现。尽管名字看起来非常相似，但JavaScript与Java语言并没有太多相似之处，它是被解释的（而Java被编译成字节码）和动态类型的（所以它在运行时检查类型安全，而Java是静态类型的，在构建时检查类型安全）。还有许多其他差异，包括对象模型、API和依赖管理。JavaScript已经被标准化为一个名为**ECMAScript**的技术规范。
- en: Another important topic is Node.js. While, as mentioned, JavaScript was initially
    executed by engines embedded into web browsers, Node.js is a standalone engine,
    able to execute JavaScript code outside of a web browser. Node.js is used for
    server-side development, whereas JavaScript is used for developing server-side
    logic by implementing web services and integrating with other components such
    as databases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的话题是Node.js。正如之前提到的，JavaScript最初是在嵌入到网页浏览器中的引擎中执行的，而Node.js是一个独立的引擎，能够在网页浏览器之外执行JavaScript代码。Node.js用于服务器端开发，而JavaScript通过实现Web服务和与其他组件（如数据库）集成来开发服务器端逻辑。
- en: The reason I'm mentioning Node.js is not for its use as a backend server (or
    at least, this is not relevant in this particular context) but because it has
    evolved as a complete toolbox for JavaScript development. Indeed, it includes
    **Node Package Manager** (**npm**), which is a utility for dependency management
    in JavaScript (conceptually similar to Maven in the Java world).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到Node.js的原因并不是它作为后端服务器的用途（或者至少，在这个特定上下文中并不相关），而是因为它已经发展成为一个完整的JavaScript开发工具箱。确实，它包括**Node包管理器**（**npm**），这是一个JavaScript依赖管理的实用工具（在Java世界的Maven概念上类似）。
- en: Moreover, it's very often used as a local server for JavaScript development,
    being very lightweight and supporting the hot reloading of updates. Last but not
    least, a lot of client-side SPA frameworks (including React) distribute utilities
    for Node.js, such as command-line interfaces, useful for creating the skeleton
    of a new application, packaging it for distribution, and so on. Now that we have
    seen the basics of current JavaScript development, is time to have a look at the
    framework that we have selected for this chapter, React, in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它经常被用作JavaScript开发的本地服务器，非常轻量级，支持热更新。最后但同样重要的是，许多客户端SPA框架（包括React）为Node.js提供了实用工具，如命令行界面，这些界面对于创建新应用程序的框架、打包分发等非常有用。现在我们已经了解了当前JavaScript开发的基础，是时候看看本章所选的框架React了，下一节将详细介绍。
- en: Introducing the React framework
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍React框架
- en: '**React** (also known as **ReactJS**) is a JavaScript framework for building
    SPAs. A very interesting feature of React is that as well as being used to build
    web applications to be accessed using a web browser, React can be used (through
    the React Native project) to build native applications to be executed on mobile
    platforms (Android and iOS) and desktop (Windows and macOS).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**React**（也称为**ReactJS**）是一个用于构建单页应用（SPAs）的JavaScript框架。React的一个非常有趣的特点是，它不仅可以用来构建通过网页浏览器访问的Web应用，还可以（通过React
    Native项目）用来构建在移动平台（Android和iOS）和桌面（Windows和macOS）上执行的原生应用。'
- en: React is very simple in its approach, which is based on the concept of components
    (more about that soon). Moreover, it's also very efficient because it uses the
    concept of the **virtual DOM**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: React在方法上非常简单，其基础是组件的概念（关于这一点很快就会详细介绍）。此外，它也非常高效，因为它使用了**虚拟DOM**的概念。
- en: Many JavaScript frameworks create web pages and interactions by directly accessing
    and modifying the **Document Object Model** (**DOM**). The DOM is basically the
    standard object representing the HTML document rendered by the browser, in the
    form of a tree starting with an HTML tag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript框架通过直接访问和修改**文档对象模型**（**DOM**）来创建网页和交互。DOM基本上是浏览器渲染的HTML文档的标准对象表示，以HTML标签为起点，形成一个树状结构。
- en: React uses this alternative approach of building a custom object (called the
    virtual DOM) that is a partial representation of the DOM, modeling the desired
    state of the DOM itself (hence the appearance and behavior of the web application).
    React applications act on this representation. It is then the framework that compares
    the DOM to the virtual DOM and makes only the necessary updates to the DOM, changing
    it in an effective and efficient way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React使用这种替代方法来构建一个自定义对象（称为虚拟DOM），它是DOM的部分表示，模拟DOM本身期望的状态（因此是Web应用程序的外观和行为）。React应用程序作用于这个表示。然后是框架将DOM与虚拟DOM进行比较，并只对DOM进行必要的更新，以有效和高效的方式改变它。
- en: JavaScript syntax extension
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法扩展
- en: '**JavaScript Syntax Extension** (**JSX**) is a technology that''s widely used
    with React. It looks similar to HTML and offers the ability to mix JavaScript
    code with HTML tags. With this in mind, it can be seen as a template technology,
    not so different from JSP, which we saw a couple of sections ago. It''s also worth
    noting that, just as JSP transforms everything we write to Java code (and, specifically,
    to a servlet that uses Java code to output HTML), JSX does exactly the same, transforming
    JSX code into JavaScript code, producing the right HTML.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript语法扩展**（**JSX**）是与React广泛使用的技术。它看起来类似于HTML，并提供了将JavaScript代码与HTML标签混合的能力。考虑到这一点，它可以被视为一种模板技术，与我们在前面几节中看到的JSP没有太大区别。还值得注意的是，就像JSP将我们写的所有内容转换为Java代码（特别是使用Java代码输出HTML的servlet）一样，JSX也完全一样，将JSX代码转换为JavaScript代码，生成正确的HTML。'
- en: It's worth noting that in the JSX world, mixing JavaScript and HTML is not considered
    an antipattern but is instead encouraged (and often done). This is because even
    if you implement complex logic with JavaScript, such logic mostly entails frontend-related
    behaviors (such as when to show one component and optional formatting), so you
    are less likely to pollute frontend code with things that don't belong in the
    frontend (such as business logic).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在JSX的世界里，混合JavaScript和HTML并不被视为反模式，反而被鼓励（并且经常这样做）。这是因为即使你用JavaScript实现复杂的逻辑，这种逻辑大多涉及前端相关的行为（例如何时显示一个组件和可选的格式化），因此你不太可能将不属于前端的东西（如业务逻辑）污染前端代码。
- en: 'The reason JSX is so popular is that can be used to define React components
    with a very compact and understandable syntax. This is what a basic React component
    might look like without using JSX:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JSX之所以如此受欢迎，是因为它可以使用非常紧凑和易于理解的语法来定义React组件。这是一个基本的React组件可能的样子，不使用JSX：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And this is how to implement the same component with JSX:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用JSX实现相同组件的方法：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, the advantage in terms of readability and effectiveness is evident. And
    it would become more evident with more complex cases, such as with tags that include
    other tags (such as HTML lists or other nested tags).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可读性和有效性方面的优势是显而易见的。在更复杂的情况下，这种优势会更加明显，例如，在包含其他标签的标签中（如HTML列表或其他嵌套标签）。
- en: Readability and ease of use are not the only qualities of JSX. It's important
    to note that JSX will also prevent, by default, injection attacks. An **injection
    attack** is when, using various techniques, a malicious user injects into your
    page custom code (such as JavaScript code or arbitrary HTML content). JSX, by
    default, sanitizes the output, hence neutralizing such attacks with no efforts
    on the development side. Moreover, JSX is a pretty complete language that can
    embed conditions and loops, call other functions, and so on. It's a very powerful
    tool for building UIs in React.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性和易用性并不是JSX的唯一品质。重要的是要注意，JSX默认情况下还会防止注入攻击。**注入攻击**是指，通过各种技术，恶意用户将自定义代码（如JavaScript代码或任意HTML内容）注入到你的页面中。JSX默认情况下会清理输出，因此无需开发人员做出任何努力，就可以中和这种攻击。此外，JSX是一种相当完整的语言，可以嵌入条件和循环，调用其他函数等。它是构建React
    UI的非常强大的工具。
- en: Since we have mentioned React components, it's important now to explain what
    they are and how they work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经提到了React组件，现在解释它们是什么以及它们是如何工作的是很重要的。
- en: Introducing React components
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍React组件
- en: The **component** is a core concept of React. It is basically a small, embeddable
    piece of UI that includes structure, appearance, and behavior logic that can be
    reused.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是React的核心概念。它基本上是一个小型、可嵌入的UI片段，包括结构、外观和行为逻辑，可以重复使用。'
- en: 'From a technical point of view, React components are JavaScript functions or
    classes. Components take, by default, a `props` argument, which is basically an
    object encapsulating the (optional) properties to be passed to the component.
    So, this is a component modeled using `function` (and JSX):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，React 组件是 JavaScript 函数或类。组件默认接受一个 `props` 参数，它基本上是一个封装了要传递给组件的（可选）属性的（可选）对象。因此，这是一个使用
    `function`（和 JSX）建模的组件：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And this is the same component, using a class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样是使用类的一个组件：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you see, the component, whether defined as a function or a class, basically
    wraps around a JSX template representing the HTML code to be rendered. Whatever
    way you define it, you can then use it as a tag, in this case `<HelloWorld/>`,
    which will be replaced with what is evaluated by executing the component logic.
    It's worth knowing that to pass properties, you can simply use tag attributes,
    which will be passed as part of the `props` object. So, in our case, to pass `fullName`,
    it's enough to use the component as `<HelloWorld fullName="Giuseppe Bonocore"/>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，组件，无论是定义为函数还是类，基本上是围绕一个 JSX 模板包装的，该模板代表要渲染的 HTML 代码。无论你如何定义它，你都可以将其用作标签，在这种情况下是
    `<HelloWorld/>`，它将被执行组件逻辑评估的结果所替换。值得注意的是，要传递属性，你可以简单地使用标签属性，这些属性将作为 `props` 对象的一部分传递。因此，在我们的例子中，要传递
    `fullName`，只需将组件用作 `<HelloWorld fullName="Giuseppe Bonocore"/>` 即可。
- en: You may have noticed that when defined as a class, we are adding our presentation
    using the `render` method. By default, it is also possible to use the `constructor`
    method, which takes `props` as a parameter. Such a method can be used to initialize
    the component. If you need to manage a state in the component (such as when saving
    local variables), you can do so by accessing the `this.state` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当定义为类时，我们通过 `render` 方法添加我们的展示。默认情况下，也可以使用 `constructor` 方法，它接受 `props`
    作为参数。这种方法可以用来初始化组件。如果你需要在组件中管理状态（例如，当保存本地变量时），你可以通过访问 `this.state` 对象来实现。
- en: 'Such an object can be, of course, modified too, for which it is worth using
    the `this.setState` method, which will notify React that something in the state
    of the component has changed (and that maybe something in the view must be updated).
    This can be particularly useful when associated with UI events, such as the click
    of a button. The following code snippet represents a component with a button.
    Every time a user clicks on the button, a counter is incremented and saved into
    the local state of the component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的对象也可以被修改，为此值得使用 `this.setState` 方法，这将通知 React 组件的状态中发生了变化（也许视图中的某些内容需要更新）。当与
    UI 事件相关联时，这尤其有用，例如按钮的点击。以下代码片段表示一个带有按钮的组件。每次用户点击按钮时，计数器都会增加并保存到组件的本地状态中：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From here, of course, more complex combinations of event handling and internal
    state management can be designed. Last but not least, there are a number of other
    callbacks associated with the life cycle steps of the React component, such as
    `componentDidMount`, called after the component is rendered on the web page (but
    there are many other similar life cycle hooks).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从这里开始，可以设计更复杂的事件处理和内部状态管理的组合。最后但同样重要的是，还有许多与 React 组件生命周期步骤相关的回调函数，例如在组件在网页上渲染后调用的
    `componentDidMount`（但还有许多其他类似的生命周期钩子）。
- en: React app structure
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React 应用程序结构
- en: Now, we have some basic information on how to create a component and where to
    place our presentation markup and business logic. *But how should we start to
    create a basic React application and apply the concepts we have just learned about?*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一些关于如何创建组件以及在哪里放置我们的展示标记和业务逻辑的基本信息。*但是我们应该如何开始创建一个基本的 React 应用程序并应用我们刚刚学到的概念呢？*
- en: The most common and easy way is to use the `npm` utility, which, as we saw a
    couple of sections ago, comes with the Node.js server. In order to download and
    install the Node.js server, you can refer to the official website at [https://nodejs.org/it/download/](https://nodejs.org/it/download/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见和简单的方法是使用 `npm` 工具，正如我们在前面的几个部分中看到的，它随 Node.js 服务器一起提供。为了下载和安装 Node.js 服务器，你可以参考官方网站
    [https://nodejs.org/it/download/](https://nodejs.org/it/download/)。
- en: 'Once you have a working setup of Node, it is enough to run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 Node 的工作环境，只需运行以下命令即可：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You'll need to change `myAppName` as needed, of course. Node.js (and `npm`)
    will then download all the necessary dependencies and create the folder structure
    and scaffolding for a basic React application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要根据需要更改 `myAppName`。Node.js（和 `npm`）将下载所有必要的依赖项并创建基本 React 应用程序的结构和脚手架。
- en: 'Such a structure might look as follows (some files are omitted):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结构可能如下所示（省略了一些文件）：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The most important files are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的文件如下：
- en: '`README.md` is the autogenerated *readme* file associated with your project
    and is used for documentation purposes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md` 是与您的项目关联的自动生成的 *readme* 文件，用于文档目的。'
- en: '`node_modules` contains the JavaScript dependencies.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules` 包含 JavaScript 依赖项。'
- en: '`Package.json` contains the project metadata, including the dependencies needed.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json` 包含项目元数据，包括所需的依赖项。'
- en: '`public/index.html` is the page template.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public/index.html` 是页面模板。'
- en: '`src/index.js` is the JavaScript file executed as the first file (the entry
    point).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/index.js` 是作为第一个文件（入口点）执行的 JavaScript 文件。'
- en: '`src/App.js` is a de facto standard generated by the `create app` utility.
    It is basically a macro component that includes all the components and references
    in an `index.js` file.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/App.js` 是由 `create app` 工具生成的实际标准。它基本上是一个宏组件，它包括所有组件并在 `index.js` 文件中引用。'
- en: So, that is the standard empty folder structure. In order to add our custom
    components, as per our previous example, we can create a `components` subfolder
    in `src`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是标准的空文件夹结构。为了添加我们自定义的组件，根据我们之前的示例，我们可以在 `src` 中创建一个 `components` 子文件夹。
- en: Each file containing a component will be a `.js` file named using the name of
    the component (*with a capital initial letter*). For our previous component example,
    that would be `Counter.js`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包含组件的每个文件都将是一个以组件名称命名的 `.js` 文件（*首字母大写*）。对于我们之前的组件示例，那将是 `Counter.js`。
- en: 'The file should declare the imported dependencies (at least React):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件应声明导入的依赖项（至少 React）：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, make this component available to other components (the last line in the
    file):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使此组件可供其他组件使用（文件中的最后一行）：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to use such components in our app, we will need to import them into
    our `App.js` file as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中使用此类组件，我们需要将它们导入到我们的 `App.js` 文件中，如下所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can then use them as a tag (`<Counter/>`) in our JSX content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将它们用作标签（`<Counter/>`）在我们的 JSX 内容中。
- en: 'Finally, in order to test our React application, you can execute this command
    from inside the project folder:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试我们的 React 应用程序，您可以从项目文件夹中执行此命令：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will execute the `node.js` server and launch your browser to the right
    page (`http://localhost:3000/`) to see your application running. Another important
    aspect of a React application is how to interact with the backend APIs. We will
    look at this in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `node.js` 服务器并将浏览器打开到正确的页面（`http://localhost:3000/`）以查看您的应用程序正在运行。React
    应用程序的一个重要方面是如何与后端 API 交互。我们将在下一节中探讨这一点。
- en: Interacting with REST APIs
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 REST API 交互
- en: What we have looked at so far is basically presentation and behavior. A very
    important feature to consider, in order to implement a real application, is making
    requests to a backend. A common way to do that is to call REST APIs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所看到的基本上是展示和行为。为了实现一个真实的应用程序，一个非常重要的特性是向后端发送请求。一个常见的方法是调用 REST API。
- en: The standard way to call a REST API from a React application is by using the
    `axios` library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从 React 应用程序调用 REST API 的标准方式是使用 `axios` 库。
- en: 'To install the `axios` dependency in React, you can use the `npm` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 React 中安装 `axios` 依赖项，您可以使用 `npm` 命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will then need to import the library into the component that is going to
    make REST requests:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将库导入到将要进行 REST 请求的组件中：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And you can then use `axios` to make the usual REST calls (`GET`, `POST`, and
    so on). This is a quick snippet of a REST `get` call reading from an API and saving
    data to the local state:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `axios` 进行常规的 REST 调用（`GET`、`POST` 等）。这是一个快速片段，用于从 API 读取数据并将其保存到本地状态中的
    REST `get` 调用：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, this example can be extended to make use of other REST verbs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子可以扩展以使用其他 REST 动词。
- en: React – where to go from here
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React –从这里开始
- en: 'The goal of the previous sections was to give you a taste of what it''s like
    to program a web interface using a client-side JavaScript framework. React is
    one of the most popular choices at the time of writing, so I think it''s a good
    investment to learn at least the basics of it. However, what we have just learned
    is far from being complete. Here are a few more topics that I suggest exploring
    in more depth:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节的目标是让您体验一下使用客户端 JavaScript 框架编写网络界面的感觉。React 在撰写本文时是最受欢迎的选择之一，因此我认为学习至少它的基础知识是一个很好的投资。然而，我们刚刚学到的内容远未完整。以下是我建议更深入探索的几个更多主题：
- en: Forms and event handling, in order to implement rich user interaction, including
    validation and file uploads
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单和事件处理，以便实现丰富的用户交互，包括验证和文件上传
- en: Advanced visualizations, such as lists, tables, and conditional formatting
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级可视化，如列表、表格和条件格式化
- en: Packaging and deploying to production, with considerations about file size optimization,
    progressive web apps, and best practices
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和部署到生产环境，考虑到文件大小优化、渐进式网络应用程序和最佳实践
- en: React Native, or how to target alternative platforms to web browsers, such as
    Android, iPhone, and desktop apps
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native，或者如何针对替代平台，如 Android、iPhone 和桌面应用程序
- en: Routing (provided by the React Router dependency), which provides a way to implement
    navigation between different views
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由（由 React Router 依赖项提供），它提供了一种在不同视图之间实现导航的方法
- en: In some cases, React provides a solution, while other times third-party plugins
    are required. There are a number of resources online; I suggest starting with
    the official React website and the other resources listed in the *Further reading*
    section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，React 提供了解决方案，而其他时候则需要第三方插件。网上有许多资源；我建议从官方 React 网站和 *进一步阅读* 部分列出的其他资源开始。
- en: 'Let''s quickly recap the evolution of frontend development in Java over time:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下 Java 前端开发随时间的发展：
- en: '![Figure 10.1 – The evolution of frontend development in Java'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.1 – The evolution of frontend development in Java]'
- en: '](img/Figure_10.1_B16354.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_10.1_B16354.jpg]'
- en: Figure 10.1 – The evolution of frontend development in Java
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.1 – The evolution of frontend development in Java
- en: As we can see, **Servlet** was the first approach and is still somewhat used,
    regardless of its limitations, for basic use cases and as a supporting technology
    for more complex frameworks. The same is true for **JSP** (introduced shortly
    after **Servlet**), which provides some advantages (such as having a markup language
    that allows for development without directly using Java code).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**Servlet** 是第一种方法，尽管有其局限性，但仍然在某些基本用例和作为更复杂框架的辅助技术中有所使用。对于在 **Servlet**
    之后不久引入的 **JSP** 也是如此，它提供了一些优势（例如，拥有一种标记语言，允许在不直接使用 Java 代码的情况下进行开发）。
- en: The usage of JSP has slowed down over time, but it's still used for some use
    cases. **JSF** started getting traction after **JSP** but stopped gaining popularity
    soon after, and it is now almost completely abandoned and basically only used
    in legacy applications. SPAs (based on frameworks such as React) have since emerged
    and are now very popular and widely used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，JSP 的使用已经放缓，但它仍然用于一些用例。**JSF** 在 **JSP** 之后开始获得关注，但很快停止了流行，现在几乎完全被遗弃，基本上只用于遗留应用程序。基于框架（如
    React）的 SPAs（单页应用程序）随后出现，现在非常流行且广泛使用。
- en: With this section, we have completed our overview of web frameworks. In the
    next section, we are going to take a look at mobile application development.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节，我们完成了对网络框架的概述。在下一节中，我们将探讨移动应用程序开发。
- en: Learning about mobile application development
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解移动应用程序开发
- en: Mobile application development shares a lot of concepts (and challenges) with
    web application development. However, there are also some core differences. In
    this section, we are going to analyze some core concepts to keep in mind when
    designing the architecture of a mobile application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序开发与网络应用程序开发共享许多概念（和挑战）。然而，也存在一些核心差异。在本节中，我们将分析一些在设计移动应用程序架构时需要记住的核心概念。
- en: In this context, we are mostly referring to mobile applications as a further
    channel to access the functionalities offered by a more complex ecosystem that
    is also accessible in other ways (via a web frontend, at least). Also, most of
    the considerations made in this section should be seen from an enterprise perspective.
    So, of course, if you are working in a different environment (such as in a start-up),
    your mileage may vary. First of all, let's start by looking at why we should consider
    developing a mobile application as a way to enable interaction with our features
    and functionalities.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们主要是指移动应用程序作为进一步访问由更复杂的生态系统提供的功能的渠道，这个生态系统也可以通过其他方式（至少是通过Web前端）访问。此外，本节中提出的许多考虑因素应从企业角度来考虑。因此，当然，如果你在另一个环境中工作（如初创公司），你的体验可能会有所不同。首先，让我们先看看为什么我们应该考虑开发移动应用程序作为实现与我们的功能和功能交互的一种方式。
- en: The importance of mobile applications
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动应用程序的重要性
- en: In today's world, it's trivial to point out that a mobile application is often
    our first point of contact with many services, such as banking, shopping, and
    entertainment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，指出移动应用程序往往是我们的第一个接触点，例如银行、购物和娱乐等服务，是一件轻而易举的事情。
- en: There are around 7 billion mobile users in the world, and it's more and more
    common for people to possess one or more mobile devices (smartphones and tablets)
    rather than a laptop or desktop PC.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上大约有70亿移动用户，越来越多的人拥有一个或多个移动设备（智能手机和平板电脑），而不是笔记本电脑或台式PC。
- en: Mobile devices offer a regulated environment through application permission
    settings and app stores that, while being a bit more restrictive, highly improve
    stability and performance standards. That's often a key reason for choosing app
    interaction over web interaction – it often offers a more standardized user experience
    and simpler access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备通过应用程序权限设置和应用程序商店提供了一个受控的环境，虽然稍微有些限制，但大大提高了稳定性和性能标准。这通常是选择应用程序交互而不是Web交互的关键原因——它通常提供更标准化的用户体验和更简单的访问。
- en: Then, of course, there is convenience – it's way easier to complete a task,
    whether it's purchasing something or just accessing some information, using a
    device that you have in your pocket compared to having to use a laptop or desktop
    PC.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，还有便利性——使用你口袋里的设备完成任务，无论是购买东西还是获取一些信息，都比使用笔记本电脑或台式PC要容易得多。
- en: Last but not least, mobile devices are equipped with sensors and functionalities
    that are key for offering an integrated experience. I can search for a restaurant
    and immediately call them to book a table or ask for directions while driving
    there.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，移动设备配备了传感器和功能，这对于提供集成体验至关重要。我可以在搜索餐厅的同时立即给他们打电话预订桌子或询问路线，在开车去那里的过程中。
- en: Given all that, it's nowadays the default position to think about a *mobile-first*
    user experience when developing user interactions. But there are a number of challenges
    to think about.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，如今在开发用户交互时考虑*以移动为先*的用户体验是默认的立场。但有许多挑战需要考虑。
- en: The challenges of mobile application development
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动应用程序开发的挑战
- en: When it comes to the development of mobile applications, the first issue that
    comes to mind is **fragmentation**. In web applications, modern browsers have
    almost eliminated incompatibilities between devices, and indeed today you will
    get the same user experience whether you are using Firefox, Chrome, or Edge on
    a Macintosh, Windows, or Linux machine. And modern frameworks (such as React,
    which we saw earlier) make it almost effortless to create such a unified experience.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到移动应用程序的开发时，首先想到的问题就是**碎片化**。在Web应用程序中，现代浏览器几乎消除了设备之间的不兼容性，确实，今天无论你是在Macintosh、Windows还是Linux机器上使用Firefox、Chrome还是Edge，你都会获得相同的用户体验。而且现代框架（如我们之前看到的React）几乎可以毫不费力地创建这样的统一体验。
- en: 'This is unfortunately not true for mobile devices:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，这一点并不适用于移动设备：
- en: First of all, you have the form factor to consider. Different models of smartphones
    have different screen sizes and ratios. They can be used in landscape or portrait
    mode. Tablet devices add even more variants to the mix.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要考虑的是设备形态。不同型号的智能手机有不同的屏幕尺寸和比例。它们可以用于横屏或竖屏模式。平板电脑设备更是增加了更多的变体。
- en: The hardware resources may be limited. The rendering of complex animations or
    heavily interactive features may slow down some low-end devices.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件资源可能有限。复杂动画或高度交互式功能的渲染可能会降低低端设备的速度。
- en: Connectivity can be unstable. You have to manage what happens to your application
    when the bandwidth is low or there is a network interruption.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接性可能不稳定。你必须管理当带宽低或出现网络中断时你的应用会发生什么。
- en: Devices often offer additional hardware, such as sensors, cameras, and GPS.
    However, you have to manage what happens when you have permissions to access such
    devices and what happens when they are denied.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备通常提供额外的硬件，例如传感器、摄像头和GPS。然而，你必须管理当你有权限访问这些设备时会发生什么，以及当它们被拒绝时会发生什么。
- en: Last but not least, there are, at the time of writing, at least two ecosystems
    to consider, Google and Apple, which have different distribution channels, different
    supporting services (such as notifications and updates), and different programming
    languages and frameworks. This last point we are going to discuss in more detail
    in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在撰写本文时，至少有两个生态系统需要考虑，即谷歌和苹果，它们拥有不同的分发渠道、不同的支持服务（例如通知和更新），以及不同的编程语言和框架。这一点我们将在下一节中更详细地讨论。
- en: Mobile application development options
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动应用程序开发选项
- en: Since the inception of mobile application development, a common topic has been
    how to manage different platforms (or, at least, Google and Apple) and whether
    there is a way to partially reuse the effort spent on development for other platforms
    (such as the web).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 自从移动应用程序开发开始以来，一个常见的话题是如何管理不同的平台（至少是谷歌和苹果），以及是否有一种方法可以部分重用为其他平台（如网络）开发所付出的努力。
- en: The first viable option for reducing fragmentation and leveraging web development
    efforts is to completely ditch mobile application development and instead go for
    mobile-optimized web applications. This is a smart option, as with modern web
    development frameworks and languages (such as HTML5 and CSS3), it's easy to target
    mobile devices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 减少碎片化并利用网络开发努力的第一个可行选项是完全放弃移动应用程序开发，转而开发针对移动设备的优化网页应用。这是一个明智的选择，因为随着现代网络开发框架和语言（如HTML5和CSS3）的出现，针对移动设备的目标变得容易实现。
- en: These technologies, other than making it easy to create responsive designs that
    fit nicely in a mobile-optimized layout, create a standard for accessing the most
    common mobile features, such as position tracking (via GPS), cameras, and microphones.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术除了使创建适合移动优化布局的响应式设计变得容易之外，还建立了一个标准，用于访问最常见的移动功能，例如位置跟踪（通过GPS）、摄像头和麦克风。
- en: The most important benefit of this approach is that we can manage a single code
    base. Even if we want to differentiate between the mobile and web versions of
    our user interface (it's our choice – we could even just have one single version),
    at least we can have a single version across all mobile devices, regardless of
    the underlying technology. The second benefit is that we can keep our publishing
    process outside app stores, so we are not subject to the timing and regulations
    that are typically enforced by such distribution channels.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最重要的好处是我们可以管理单一的代码库。即使我们想要区分移动和网页版本的用户界面（这是我们的选择——我们甚至可以只有一个版本），至少我们可以在所有移动设备上拥有一个单一版本，无论其底层技术如何。第二个好处是我们可以将发布过程保持在应用商店之外，因此我们不受通常由这些分发渠道实施的时机和规定的约束。
- en: However, there are of course some limitations, with the most significant one
    being performance. Mobile web applications generally perform worse than their
    native counterparts. That is particularly true for heavily interactive experiences,
    such as games or very visual user interfaces. Moreover, mobile web applications
    have more limited options (if any) to run in an offline or limited-connectivity
    scenario.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当然也有一些局限性，其中最显著的是性能。移动网页应用通常比其本地版本表现更差。这对于高度交互式的体验尤其如此，例如游戏或非常视觉化的用户界面。此外，移动网页应用在离线或有限连接场景下的运行选项更有限（如果有的话）。
- en: Moreover, mobile web applications are usually less *ergonomic* to access, meaning
    that the user needs to access the browser and load the application. Even if it's
    possible to use shortcuts, it's still a more uncomfortable experience than directly
    finding an app icon in an application list (which is also better from a branding
    perspective). Last but not least, mobile web applications do not benefit from
    the visibility that can come from app stores.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，移动网页应用通常不太**符合人体工程学**，这意味着用户需要访问浏览器并加载应用。即使可以使用快捷方式，这仍然比直接在应用列表中找到应用图标（这也从品牌的角度来看更好）更不舒服。最后但同样重要的是，移动网页应用无法从应用商店带来的可见性中受益。
- en: A possible alternative to mobile web applications is hybrid applications. In
    this approach, a mobile web application is enclosed into a native *shell*, which
    basically is just a slimmed-down, full-screen browser used to act as a bridge
    between a mobile web application and a device. In such a setup, our application
    can be published to app stores and can access more native features of the host
    device. Moreover, it is possible to implement unique code bases, or at least that's
    the case with the two main technologies of Apple and Google. The downside is that
    performance and access to native hardware devices will still be limited compared
    to a fully native application. A notable framework to develop hybrid apps is React
    Native, which we mentioned previously.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 移动网页应用程序的一个可能的替代方案是混合应用程序。在这种方法中，移动网页应用程序被封装在一个本地的*外壳*中，这基本上是一个精简的、全屏的浏览器，用于作为移动网页应用程序和设备之间的桥梁。在这种配置中，我们的应用程序可以发布到应用商店，并访问主机设备的更多原生功能。此外，实现独特的代码库是可能的，至少苹果和谷歌的两种主要技术是这样的。缺点是，与完全本地的应用程序相比，性能和对原生硬件设备的访问仍然有限。一个值得注意的用于开发混合应用程序的框架是React
    Native，我们之前提到过。
- en: The last option is, obviously, to develop a fully native application. To do
    that, you will have to use the languages and tools provided for your specific
    target platform.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项显然是开发一个完全本地的应用程序。为此，您将不得不使用为您的特定目标平台提供的语言和工具。
- en: Such languages are commonly Swift or Objective-C for Apple devices, and Java
    or Kotlin for Android ones. The vendors also distribute development environments
    and tools for building and distributing the applications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言通常是用于苹果设备的Swift或Objective-C，以及用于安卓设备的Java或Kotlin。供应商还提供用于构建和分发应用程序的开发环境和工具。
- en: In this way, you will have full control over the device's capabilities and can
    exploit all the available resources, which can be crucial for some applications.
    The obvious downside is that you will have to manage two completely different
    development lines, which means having different skills on the team, dedicated
    build pipelines, and in general, a duplicated effort.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您将完全控制设备的性能，并可以利用所有可用资源，这对于某些应用程序来说可能是至关重要的。明显的缺点是，您将不得不管理两条完全不同的开发线，这意味着团队中需要不同的技能，专门的构建管道，总的来说，是重复的工作。
- en: Regardless of your development choice, you will still have to face a challenge
    in testing, as checking the application's behavior for all the available platforms
    properly can be very expensive. In order to partially solve this challenge, it
    is possible to rely on simulators, which emulate the major mobile devices for
    testing purposes. Another viable alternative is to use specialized services. There
    are a number of companies offering a range of mobile devices for testing purposes,
    which can be rented (as cloud resources) and remotely controlled in order to execute
    test suites.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的开发选择如何，您仍然将不得不面对测试的挑战，因为正确检查应用程序在所有可用平台上的行为可能非常昂贵。为了部分解决这个挑战，可以依靠模拟器，这些模拟器用于测试目的，模拟主要的移动设备。另一个可行的替代方案是使用专业服务。有许多公司提供各种移动设备用于测试目的，这些设备可以作为云资源租用，并远程控制以执行测试套件。
- en: In this section, we have looked at web and mobile applications, which are the
    two most common channels for enterprise services nowadays. But there are some
    other options that are being used more and more. We are going to learn about them
    in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了网页和移动应用程序，这是当今企业服务中最常见的两个渠道。但还有一些其他选项正在越来越多地被使用。我们将在下一节中了解它们。
- en: Exploring IVR, chatbots, and voice assistants
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索IVR、聊天机器人和语音助手
- en: Providing more channels for customer interaction is often a very smart investment.
    It means reaching more people, having a high customer satisfaction rate, and a
    reduced need for manual interaction (such as assistance provided by a human operator),
    which can be expensive and also less effective. These goals are important to achieve,
    and in this section, we'll look at some ways to do so.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 提供更多客户互动渠道通常是一个非常明智的投资。这意味着触及更多的人，拥有高客户满意度，以及减少对人工交互（如由人工操作员提供的帮助）的需求，这可能既昂贵又不太有效。这些目标非常重要，在本节中，我们将探讨实现这些目标的一些方法。
- en: Interactive voice response
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式语音响应
- en: '**Interactive Voice Response** (**IVR**) is one kind of technology that helps
    us achieve the aforementioned goals. It provides a way for a human user to interact
    with services over a phone call. I think that pretty much every one of us has
    first-hand experience of interacting with an IVR system, as they are pretty common
    in helpdesk hotlines. The system offers a number of options to choose from. The
    user can then choose one of the options using a **Dual-Tone Multi-Frequency**
    (**DTMF**) tone (a tone generated by pressing a button on the phone''s number
    pad) or via voice recognition (which can be harder and more expensive to implement
    than the DTMF method, as it requires speech-to-text capabilities).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式语音响应**（**IVR**）是我们实现上述目标的一种技术。它为人类用户提供了一种通过电话与服务互动的方式。我认为我们中的每一个人都有过与IVR系统互动的第一手经验，因为它们在帮助台热线中相当常见。系统提供了一系列可供选择的项目。然后，用户可以使用**双音多频**（**DTMF**）音调（通过按手机数字键盘上的按钮产生的音调）或通过语音识别（与DTMF方法相比，语音识别可能更难且成本更高，因为它需要语音到文本的能力）来选择其中一个选项。'
- en: Every option can lead to another set of options. At some point, the customer
    gets to the desired information, provided by text-to-speech or a recorded message.
    Another option is to have the call ultimately dispatched to a human operator.
    While still requiring a human, the presence of the IVR system will most likely
    filter the most common requests, reducing the number of human operators required,
    and can provide the operator with data collected from the automatic interactions,
    such as the user's identity or the problem to resolve.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都可以引导到另一组选项。在某个时刻，客户可以通过文本到语音或录音消息获得所需的信息。另一个选项是将电话最终转接到人工操作员那里。虽然仍然需要人工操作员，但IVR系统的存在很可能会过滤掉最常见的请求，从而减少所需的人工操作员数量，并且可以为操作员提供从自动交互中收集的数据，例如用户的身份或需要解决的问题。
- en: Algorithmically, an IVR system basically involves *tree traversing*. The customer
    starts at the root node. At each interaction, the customer is provided with a
    set of options (the child nodes). The customer can then pick one of the nodes
    or step back a level (but no further than the root node, of course). At some point,
    the customer will reach a leaf (the desired information or a human operator).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从算法的角度来看，IVR系统基本上涉及**树遍历**。客户从根节点开始。在每次交互中，客户都会得到一组选项（子节点）。客户可以选择其中一个节点或退回一个级别（但当然不能超过根节点）。在某个时刻，客户将达到一个叶节点（所需的信息或人工操作员）。
- en: IVR systems, as we have seen, involve a lot of different technologies, starting
    with integrating phone calls (both inbound and outbound) and spanning media handling
    (recorded voice playback), speech-to-text, and text-to-speech. In other words,
    they are rarely implemented from scratch. In almost every case, in order to implement
    an IVR system, it is common to rely on packaged solutions. Asterisk, which is
    a piece of open source PBX software, is used as a common choice for implementing
    these kinds of systems. Nowadays, however, SaaS solutions are commonly used, requiring
    just configuration tweaks in order to implement the desired behavior. And since
    the interaction is so standardized with packaged solutions, and in terms of branding
    you're limited to the provided recorded voices, a custom IVR implementation is
    not worth the effort.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，IVR系统涉及许多不同的技术，从集成电话呼叫（包括入站和出站）到涵盖媒体处理（录音语音播放）、语音到文本和文本到语音。换句话说，它们很少从头开始实现。在几乎所有情况下，为了实现IVR系统，通常依赖于打包解决方案。Asterisk，这是一款开源的PBX软件，常被用作实现这类系统的常见选择。然而，如今，SaaS解决方案被广泛使用，只需要进行配置调整即可实现所需的行为。由于与打包解决方案的交互非常标准化，并且在品牌方面你仅限于提供的录音语音，因此定制的IVR实现不值得付出努力。
- en: Chatbots
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天机器人
- en: '**Chatbots** are basically the same concept transposed to text chats. They
    achieve the same goal (providing a customized user experience while reducing pressure
    on human operators), but they don''t require text-to-speech, speech-to-text, or
    recorded voice messages.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天机器人**基本上是将相同的概念应用到文本聊天中。它们达到相同的目标（在减少对人工操作员压力的同时提供定制化用户体验），但它们不需要文本到语音、语音到文本或录音语音消息。'
- en: The interaction can still be modeled as a tree by providing multiple options
    to the customer. However, it is common for most chatbot platforms to provide freeform
    input to customers and try to interpret what the customer is looking for, by parsing
    the messages and doing what is called **Natural Language Processing** (**NLP**).
    This process can be complex, involving looking for keywords to analyze the customer's
    request or even decoding the meaning of the customer's entire message.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向客户提供多个选项，交互仍然可以被视为一棵树。然而，在大多数聊天机器人平台上，通常向客户提供自由形式的输入，并尝试通过解析消息和执行所谓的**自然语言处理**（**NLP**）来解释客户正在寻找的内容。这个过程可能很复杂，包括寻找关键词来分析客户的请求，甚至解码客户整个消息的含义。
- en: Chatbots are less *invasive* than IVR, as they don't require integration with
    phone infrastructures. There are a number of frameworks available for implementing
    such solutions, and they are often identified as a perfect use case for the serverless
    deployment model (see [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*). However, as with IVR technology, it is
    unusual to implement such solutions from scratch nowadays, and it's more common
    to rely on packaged applications or SaaS solutions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与IVR相比，聊天机器人不那么**侵入性**，因为它们不需要与电话基础设施集成。有多个框架可用于实现此类解决方案，并且它们通常被识别为无服务器部署模型的完美用例（见[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*）。然而，与IVR技术一样，现在从头开始实现此类解决方案并不常见，更常见的是依赖于打包的应用程序或SaaS解决方案。
- en: Voice assistants
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音助手
- en: '**Voice assistants** are one of the most modern takes on the same issue. Conceptually,
    voice assistants are kind of a mix between the user experience provided by an
    IVR system and the one provided by a chatbot. From a user''s perspective, voice
    assistants are consumed from a proprietary hardware and software stack, implemented
    by what is commonly called a *smart speaker*. The most widespread implementations
    at the time of writing are Google Home and Amazon Alexa.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**语音助手**是对同一问题的最现代的解决方案之一。从概念上讲，语音助手是IVR系统提供的用户体验和聊天机器人提供的用户体验的一种混合。从用户的角度来看，语音助手是通过通常称为*智能扬声器*的专有硬件和软件堆栈消费的。在撰写本文时，最广泛的应用是Google
    Home和Amazon Alexa。'
- en: This topic is particularly hot, as currently voice assistant applications are
    still in their infancy, and implementing one is a really unique feature. However,
    to do so, you will require specific skills, and each vendor relies on proprietary
    SDKs to build their platforms, which are usually hosted and powered by the cloud
    provider behind them (AWS and Google Cloud Platform).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题特别热门，因为目前语音助手应用仍处于起步阶段，实现它是一项真正独特的功能。然而，要实现这一点，你需要特定的技能，并且每个供应商都依赖于他们自己的SDK来构建他们的平台，这些平台通常由背后的云服务提供商（如AWS和Google
    Cloud Platform）托管和供电。
- en: Omnichannel strategy in enterprise applications
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业应用中的全渠道策略
- en: In this chapter, we explored a number of different options for user interaction,
    from web applications (which are the most common channel for user interaction),
    through mobile applications, to some alternative channels, such as IVR, chatbots,
    and voice assistants.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了用户交互的多种不同选项，从最常用的用户交互渠道——Web应用，到移动应用，再到一些替代渠道，如IVR、聊天机器人和语音助手。
- en: This opens up a big consideration as to which is the best strategy to go for.
    Indeed, it is pretty common for enterprise applications to provide many, if not
    all, of these channels at once. And as a user, we want to interact with applications
    and get the same information and the same user experience regardless of the channel
    used.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个重大考虑，即选择哪种策略是最好的。确实，企业应用通常一次提供许多，如果不是所有这些渠道。作为用户，我们希望无论使用哪种渠道都能与应用程序互动并获得相同的信息和用户体验。
- en: This poses some serious challenges, from user identity to state management.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一些严重的挑战，从用户身份到状态管理。
- en: There are a number of ways to face such challenges.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以应对这些挑战。
- en: The most important thing is to provide a unified backend for all channels. To
    do so, it is common to use the same services (for example, for identifying a user
    or searching for saved information) and wrap things using a mediation layer (also
    known as a *backend for frontend*) in order to optimize the inputs and outputs
    for a specific device (such as a phone call, a mobile application, or a web user
    interface). In this way, we can make sure that we provide the same results regardless
    of what channel is used for interaction.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是为所有渠道提供一个统一的后端。为了做到这一点，通常使用相同的服务（例如，用于识别用户或搜索保存的信息），并使用中介层（也称为*前端后端*）来包装这些服务，以优化特定设备（如电话通话、移动应用程序或Web用户界面）的输入和输出。这样，我们可以确保无论使用什么渠道进行交互，都能提供相同的结果。
- en: In doing so, we will provide what is called **multichannel** functionality –
    the same features are available on different channels and devices (of course,
    with minor modifications due to the limitations of each device). But there is
    a further step that can be taken for a more complete user experience, and this
    is called **omnichannel** functionality. With an omnichannel experience, the user
    can switch channels during a complex transaction and continue an operation started
    on a different kind of device with limited or no impact on the user experience
    and the final result.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，我们将提供所谓的**多渠道**功能——相同的特性在不同的渠道和设备上都是可用的（当然，由于每个设备的限制，可能会有一些小的修改）。但还可以采取进一步的步骤以提供更完整的用户体验，这被称为**全渠道**功能。在全渠道体验中，用户可以在复杂交易过程中切换渠道，并且可以在不同类型的设备上继续之前开始的操作，而对用户体验和最终结果的影响最小或没有影响。
- en: The classical example is a mortgage application. A user can call an IVR system
    asking for information to start a mortgage application. This mortgage application
    can then be continued using a web application, where the customer can more comfortably
    provide personal information. After an asynchronous approval process, the customer
    can then be notified on a mobile app of the mortgage application outcome and complete
    the process in the mobile app itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的例子是抵押贷款申请。用户可以拨打IVR系统请求信息以开始抵押贷款申请。然后，该抵押贷款申请可以使用Web应用程序继续，客户可以在Web应用程序中更舒适地提供个人信息。在异步审批过程之后，客户可以在移动应用程序上收到抵押贷款申请结果的通知，并在移动应用程序中完成整个过程。
- en: In order to implement an omnichannel approach, our enterprise application must
    be capable of storing the state and details of multi-step transactions (such as
    the mortgage application in our example) in a so-called *state machine*, commonly
    implemented as a business workflow (as seen in [*Chapter 8*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200),
    *Designing Application Integration and Business Automation*). It will then be
    necessary to implement some services to interact with the workflow from the desired
    channel (as previously mentioned, using a mediator or backend-for-frontend pattern).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现全渠道方法，我们的企业应用程序必须能够将多步交易的**状态和细节**（例如，我们示例中的抵押贷款申请）存储在所谓的**状态机**中，通常作为业务流程（如[第8章](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200)，*设计应用程序集成和业务自动化*）实现。然后，将需要实现一些服务以从期望的渠道（如之前提到的，使用中介或前端后端模式）与工作流程进行交互。
- en: A common strategy is also to *codify* some checks (possibly by using a business
    rule) in order to identify which step can be implemented by which specific channel
    (and device), as due to the specificity of each channel, it may be impossible
    (or at least not advisable) to perform certain steps on certain devices. A typical
    example is IVR. It is usually difficult to properly identify a customer over a
    phone call. It is possible to check the phone number and to ask for a PIN, but
    this may be not enough for some operations that are better suited to a mobile
    device (where we can ask for biometric authentication) or a web application (where
    we can enforce **Two-Factor Authentication** (**2FA**)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的策略是将一些检查（可能通过使用业务规则）**编码化**，以确定哪些步骤可以由哪个特定的渠道（和设备）实现，因为由于每个渠道的特定性，可能在某些设备上执行某些步骤是不可能的（或者至少是不建议的）。一个典型的例子是IVR。通常很难在电话通话中正确识别客户。可以检查电话号码并要求输入PIN码，但这可能不足以进行某些更适合移动设备（我们可以要求生物识别认证）或Web应用程序（我们可以强制执行**双因素认证**（**2FA**））的操作。
- en: With this section, we have completed our overview of the most common interaction
    channels for our users.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经完成了对我们用户最常见交互渠道的概述。
- en: Let's summarize what we have learned in this chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the core server-side web technologies provided
    by the JEE platform (JSP and JSF). We explored the pros and cons of these technologies
    and the main ideas behind them, including interaction with other JEE technologies
    and standards.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了JEE平台（JSP和JSF）提供的核心服务器端Web技术。我们探讨了这些技术的优缺点以及它们背后的主要思想，包括与其他JEE技术和标准交互。
- en: We then moved on to client-side frameworks for building SPAs. We saw how simple
    and powerful the React framework is and how it can be used to implement componentized
    interfaces.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向构建单页应用（SPA）的客户端框架。我们看到了React框架的简单和强大，以及它是如何被用来实现组件化界面的。
- en: We also studied the basics of mobile application development, which is now essential
    to provide a complete customer experience and can leverage some of the concepts
    of web application development.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了移动应用开发的基础，这对于提供完整的客户体验现在变得至关重要，并且可以利用一些网络应用开发的概念。
- en: Moreover, we had a look at other interaction channels, such as phone calls (using
    IVR systems), text chats (using chatbots), and voice assistants. Lastly, we looked
    at some considerations on how to harmonize all those technologies into a multichannel
    and omnichannel user experience.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还考察了其他交互渠道，例如电话（使用IVR系统）、文本聊天（使用聊天机器人）和语音助手。最后，我们探讨了如何将这些技术和谐地整合到多渠道和全渠道用户体验中。
- en: In the next chapter, we are going to focus on the data layer. This will include
    coverage of relational databases as well as alternatives, such as key-value stores
    and NoSQL. This will represent another fundamental layer of application architecture.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注数据层。这包括关系型数据库以及替代方案，如键值存储和NoSQL。这将代表应用架构的另一个基本层。
- en: Further reading
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Eclipse Foundation – the JSP specification([https://projects.eclipse.org/projects/ee4j.jsp](https://projects.eclipse.org/projects/ee4j.jsp))
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse基金会 – JSP规范([https://projects.eclipse.org/projects/ee4j.jsp](https://projects.eclipse.org/projects/ee4j.jsp))
- en: '*The Problems with JSP*, *Jason Hunter* ([http://servlets.com/soapbox/problems-jsp.html](http://servlets.com/soapbox/problems-jsp.html))'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSP的问题*，*贾森·亨特* ([http://servlets.com/soapbox/problems-jsp.html](http://servlets.com/soapbox/problems-jsp.html))'
- en: Jakarta EE – the JSF specification ([https://jakarta.ee/specifications/faces/](https://jakarta.ee/specifications/faces/))
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta EE – JSF规范 ([https://jakarta.ee/specifications/faces/](https://jakarta.ee/specifications/faces/))
- en: '*Why You Should Avoid JSF*, *Jens Schauder* ([https://dzone.com/articles/why-you-should-avoid-jsf](https://dzone.com/articles/why-you-should-avoid-jsf))'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么你应该避免使用JSF*，*延斯·绍德* ([https://dzone.com/articles/why-you-should-avoid-jsf](https://dzone.com/articles/why-you-should-avoid-jsf))'
- en: Meta Platforms, Inc. – the official React website ([https://reactjs.org/](https://reactjs.org/))
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meta Platforms, Inc. – 官方React网站 ([https://reactjs.org/](https://reactjs.org/))
- en: W3Schools – *React Tutorial* ([https://www.w3schools.com/react/](https://www.w3schools.com/react/))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3Schools – *React教程* ([https://www.w3schools.com/react/](https://www.w3schools.com/react/))
