- en: Using MicroProfile in Multi-Cloud Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多云环境中使用MicroProfile
- en: Microservices and microservices architectures are ideal development approaches
    for cloud and multi-cloud environments, including hybrid cloud deployments, where
    your application comprises on-premise logic as well as logic that runs in the
    cloud. Eclipse MicroProfile is a specification that optimizes Java for microservices
    architecture and thus provides constructs so that you can implement microservices
    in Java and the cloud. These topics will help you to understand why Eclipse MicroProfile
    is ideal for developing applications in hybrid and multi-cloud environments, and
    what you must take into consideration when using it in these types of deployments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和微服务架构是云和多云环境的理想开发方法，包括混合云部署，您的应用程序包括本地逻辑以及运行在云中的逻辑。Eclipse MicroProfile是一个优化Java适用于微服务架构的规范，因此提供了构造，使您可以使用Java和云实现微服务。这些主题将帮助您了解为什么Eclipse
    MicroProfile适用于开发混合和多云环境中的应用程序，以及在这些类型的部署中使用它时必须考虑的因素。
- en: In this chapter, we will discuss the following ...
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容...
- en: Using Eclipse MicroProfile for cloud-native application development
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eclipse MicroProfile进行云原生应用开发
- en: 'What is a cloud-native application? Typically, a definition for **cloud-native**
    entails the following characteristics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是云原生应用？通常，对于**云原生**的定义包括以下特征：
- en: Designed as loosely coupled services, such as microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计为松耦合服务，如微服务
- en: Loosely coupled services that interact via language-independent communication
    protocols, which allow microservices to be implemented in different programming
    languages and frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合的服务，通过语言无关的通信协议进行交互，这使得微服务可以采用不同的编程语言和框架实现
- en: Lightweight containers that can scale up and down on-demand or via resource
    utilization metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按需或通过资源利用率指标进行扩展轻量级容器
- en: Managed through Agile DevOps processes, with each microservice of a cloud-native
    application going through an independent life cycle that's managed through an
    Agile process using **continuous integration/continuous delivery** (**CI/CD**)
    pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过敏捷DevOps流程管理，每个云原生应用程序的微服务都经历一个独立的生命周期，该生命周期通过使用**持续集成/持续交付**（**CI/CD**）管道进行敏捷管理
- en: However, Eclipse MicroProfile's goal is to optimize Java for microservice architectures,
    so does it make it suitable for cloud-native application development? What about
    container-native development? What is the relationship between microservices,
    cloud-native development, and container-native development? How do these differ
    or compare? Let's find out!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Eclipse MicroProfile的目标是优化Java适用于微服务架构，那么它是否适合云原生应用开发呢？容器原生开发又如何？微服务、云原生开发和容器原生开发之间的关系是什么？它们之间有什么区别或比较？让我们来找出答案！
- en: Microservices versus cloud native versus container native
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与云原生与容器原生
- en: 'First, let''s draw the differences between these three terms with respect to
    how an application is developed. As we discussed in [Chapter 1](96308ec7-7393-41b7-a17c-43c15d409f40.xhtml),
    *Introduction to Eclipse MicroProfile*, an Enterprise Java microservice has the
    following features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们绘制这三个术语在应用程序开发方面的区别。正如我们在[第1章](96308ec7-7393-41b7-a17c-43c15d409f40.xhtml)中讨论的，*Eclipse
    MicroProfile简介*，企业Java微服务具有以下特征：
- en: It is a microservice written using the Java language.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个使用Java语言编写的微服务。
- en: It can use any Java framework.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用任何Java框架。
- en: It can use any Java API.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用任何Java API。
- en: It must be enterprise grade, which means it must have high reliability, availability,
    scalability, security, robustness, and performance.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是企业级的，这意味着它必须具有高可靠性、可用性、可扩展性、安全性、健壮性和性能。
- en: It must fulfill the characteristics of a microservice, all of which are listed
    at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须满足微服务的所有特征，这些特征列在[https://martinfowler.com/microservices/](https://martinfowler.com/microservices/)上。
- en: By its definition, a microservice does not prescribe specific details of the
    underlying ...
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其定义，微服务不规定底层的具体细节...
- en: What about 12-factor applications?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那12因子应用又如何呢？
- en: 'Just like the microservices and microservices architecture definitions, a 12-factor
    app does not prescribe the underlying technologies, for example, the programming
    language, database, caches, and so on, or frameworks that should be used to implement
    them. The 12-factor app is a methodology that''s used for implementing applications.
    These twelve factors are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像微服务和微服务架构的定义一样，12因子应用不会规定底层技术，例如编程语言、数据库、缓存等，或应使用它们实现的框架。12因子应用是一种用于实施应用程序的方法。这十二个因素如下：
- en: One codebase tracked in revision control, many deploys
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码库在版本控制中跟踪，多个部署
- en: Explicitly declare and isolate dependencies
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确声明和隔离依赖项
- en: Store config in the environment
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境中存储配置
- en: Treat backing services as attached resources
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将后端服务视为附加资源
- en: Strictly separate build and run stages
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格区分构建和运行阶段
- en: Execute the app as one or more stateless processes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序作为无状态进程之一或多个执行
- en: Export services via port binding
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过端口绑定导出服务
- en: Scale out via the process model
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过进程模型进行扩展
- en: Maximize robustness with fast startup and graceful shutdown
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快速启动和优雅关机最大化健壮性
- en: Keep development, staging, and production as similar as possible
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持开发、暂存和生产环境相似
- en: Treat logs as event streams
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志视为事件流
- en: Run admin/management tasks as one-off processes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将管理任务作为一次性流程运行
- en: 'Implementing an application using this methodology helps us do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法实施应用程序可以帮助我们做到以下几点：
- en: Minimize time and cost for new developers joining the project
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化新开发者加入项目的时间和成本
- en: Offer portability between execution environments
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在执行环境之间可移植性
- en: Easily deploy the application to cloud platforms
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松将应用程序部署到云平台
- en: Minimize the differences between development and production
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化开发和生产之间的差异
- en: Scale it up without changes
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需更改即可扩展
- en: You can read all about the 12 factors at [https://12factor.net](https://12factor.net).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://12factor.net](https://12factor.net)上阅读到关于12个因素的全部内容。
- en: The 12-factor app is a methodology that a developer can follow while designing
    and implementing microservices and applications, independent of the programming
    language or framework that's being used to implement them. The framework that
    a developer can use to implement microservices using the 12-factor app is Eclipse
    MicroProfile. The 12-factor app and Eclipse MicroProfile are not mutually exclusive
    but really complement each other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 12因子应用是一种开发者可以在设计和实现微服务和应用程序时遵循的方法，与实现它们的编程语言或框架无关。开发者可以使用12因子应用框架实现微服务，这个框架是Eclipse
    MicroProfile。12因子应用和Eclipse MicroProfile并不是相互排斥的，而是相辅相成的。
- en: But what about a methodology for designing and implementing applications that's
    not the 12-factor app? What about serverless and **Function-as-a-Service** (**FaaS**)
    technologies? How does Eclipse MicroProfile fit into these newer cloud-native
    technologies?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了12因子应用之外，还有没有其他设计和实现应用程序的方法呢？无服务器和**功能即服务**（**FaaS**）技术又如何呢？Eclipse MicroProfile在这些更新的云原生技术中如何定位？
- en: What about serverless and FaaS?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么无服务器和FaaS呢？
- en: Serverless and FaaS cloud-native technologies have been experiencing steady
    interest and growth in the market, as evidenced by offerings from all the major
    cloud providers, that is, AWS Lambda, Azure Functions, Oracle Functions, and Google
    Cloud Functions. In an era where organizations are increasingly using the cloud
    for development and production workloads, and compute and memory costs are operational
    expenses that need to be tracked and monitored, FaaS is attractive because it
    abstracts compute and memory management away from the user, who is then able to
    focus on developing business logic, thereby becoming a lot more productive than
    ever before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器和FaaS作为云原生技术，在市场上一直保持着稳定的兴趣和增长，这一点从所有主要云服务提供商的产品中可以看出，即AWS Lambda、Azure
    Functions、Oracle Functions和Google Cloud Functions。在组织越来越多地使用云进行开发和生产负载的时代，计算和内存成本是必须跟踪和监控的操作费用，FaaS之所以吸引人，是因为它将计算和内存管理从用户手中抽象出来，使用户能够专注于开发业务逻辑，从而比以往任何时候都更加高效。
- en: With FaaS, developers don't need to set up VMs and memory, ...
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FaaS，开发人员无需设置虚拟机和内存，...
- en: Cloud-native application development
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用开发
- en: 'There are two complementary aspects or components to cloud-native application
    development: application services and infrastructure services. Application services
    speed up the development of the business logic of a cloud-native application,
    and infrastructure services speed up its delivery and deployment. These two aspects
    are complementary and integral to cloud-native application development. You cannot
    have one without the other. They are essentially the yin and the yang of cloud-native application
    development, as depicted by the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用开发有两个互补的方面或组件：应用服务和基础设施服务。应用服务加快了云原生应用的业务逻辑开发，而基础设施服务则加快了其交付和部署。这两个方面是互补的，并构成了云原生应用开发的一部分。没有另一个，你无法拥有。它们本质上是云原生应用开发的阴阳两面，如下面的图表所示：
- en: '![](img/5396deb8-7e59-4be5-9b20-a31287abeed3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5396deb8-7e59-4be5-9b20-a31287abeed3.png)'
- en: 'As we mentioned earlier in this chapter, cloud-native application development
    is an approach to building and running applications that takes full advantage
    of the cloud computing model, which is based on four key tenets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这章节前面提到的，云原生应用开发是一种构建和运行应用程序的方法，它充分利用了云计算模型，该模型基于四个核心原则：
- en: A service-based architecture (miniservices, microservices, SOA services, and
    so on)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于服务架构（微服务、微服务、SOA 服务等）
- en: An API-driven approach for inter-service communication
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务间通信的 API 驱动方法
- en: An underlying infrastructure that's based on containers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于容器的底层基础设施
- en: DevOps processes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps 流程
- en: 'The following diagram depicts the four key tenets of cloud-native application
    development:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了云原生应用开发的四个核心原则：
- en: '![](img/5994cf8f-77e2-4906-b576-0a8742fe81b5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5994cf8f-77e2-4906-b576-0a8742fe81b5.png)'
- en: As shown in the previous diagram, the architecture and communication aspects
    are related to the development concerns of cloud-native applications, and the
    infrastructure and the process aspects are related to their delivery/deployment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，前一个图表中，架构和通信方面与云原生应用的开发关注点相关，而基础设施和流程方面则与它们的交付/部署相关。
- en: Organizations who are on their journey to adopting cloud-native application
    development can benefit from eight steps, as described by the e-Book titled *The
    path to cloud-native applications: **8 steps to guide your journey*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '正在采用云原生应用开发的组织可以从八个步骤中受益，这些步骤在电子书中有所描述，书名为 *The path to cloud-native applications:
    **8 steps to guide your journey*.'
- en: To obtain the e-Book *The path to cloud-native applications: **8 steps to guide
    your journey*, please refer to [https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook](https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取电子书 *The path to cloud-native applications: **8 steps to guide your journey*,
    请参考 [https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook](https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook).'
- en: 'Let''s discuss how Eclipse MicroProfile can play a role in these eight steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下 Eclipse MicroProfile 在这八个步骤中可以发挥什么作用：
- en: '**Evolve the DevOps culture and practices**: "*Take advantage of new technology,
    faster approaches, **and tighter collaboration by embracing the principles and
    cultural values of DevOps and organizing your organization around those values.*"
    Although this is an organizational and process-related step, Eclipse MicroProfile,
    as a specification for microservices, can be a good fit for this adaptation of
    culture and process because microservices, due to their characteristics, closely
    support DevOps processes.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发展和实践 DevOps 文化**：“*利用新技术、更快的方法以及更紧密的协作，通过采纳 DevOps 的原则和文化价值观，围绕这些价值观组织你的组织.*”
    尽管这是一个与组织和工作流程相关的步骤，但作为微服务规范的 Eclipse MicroProfile 可以很好地适应这种文化和流程的改变，因为微服务由于其特性，紧密支持
    DevOps 流程。'
- en: '**Speed up existing applications using fast monoliths**: "*Accelerate existing
    applications by migrating to a modern, container-based platform – and break up
    monolithic applications into microservices or miniservices for additional efficiency
    gains.*" Eclipse MicroProfile can be of great help when breaking up your monolith
    into microservices. As you identify bounded contexts in your monolith, consider
    using Eclipse MicroProfile to implement each of the microservices that implement
    the logic of each bounded context.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用快速单体加速现有应用**：“*通过迁移到现代、基于容器的平台来加速现有应用——并将单体应用分解为微服务或小型服务，以获得额外的效率提升。*”
    在将单体应用分解为微服务时，Eclipse MicroProfile可以提供很大帮助。 当你在单体应用中识别出边界上下文时，可以考虑使用Eclipse MicroProfile来实现每个微服务，这些微服务实现每个边界上下文的逻辑。'
- en: '**Use application services to speed up development**: "*Speed up software development
    with reusability. Cloud-native application services are ready-to-use developer
    tools. However, these reusable components must be optimized and integrated into
    the underlying cloud-native infrastructure to maximize their benefits.*" An **In-Memory
    Data Grid** (**IMDG**) and Messaging Brokers are application services that help
    speed up the development of business logic. A microservice, developed using Eclipse
    MicroProfile, can leverage these application services by invoking them from within
    its method bodies. Eclipse MicroProfile does not impose any kind of restriction
    when integrating to application services, such as an IMDG or a Messaging Broker.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用应用服务加快开发速度**：“*通过可重用性加快软件开发。云原生应用服务是即用的开发者工具。然而，这些可重用组件必须优化并集成到云原生基础架构中，以最大化其效益。*”**内存数据网格**（**IMDG**）和消息代理是应用服务，它们有助于加快业务逻辑的开发。使用Eclipse
    MicroProfile开发的微服务，可以通过其方法体内部调用这些应用服务。Eclipse MicroProfile在集成应用服务，如IMDG或消息代理时，不会施加任何限制。'
- en: '**Choose the right tool for the right task**: "*Use a container-based application
    platform that supports the right mix of frameworks, languages, and architectures
    – and can be tailored to your specific business application need.*" Eclipse MicroProfile
    is one of the tools that a developer can use when choosing the right tool for
    the right task. For example, Red Hat Application Runtimes is a collection of runtimes
    and tools, which includes Eclipse MicroProfile, Node.js, Spring Boot, and Vertex.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为每项任务选择合适的工具**：“*使用基于容器的应用平台，支持正确的框架、语言和架构的混合——并可根据您的特定业务应用需求进行定制。*” 当选择合适的工具来完成任务时，开发者可以使用Eclipse
    MicroProfile这样的工具。例如，Red Hat Application Runtimes是一组运行时和工具的集合，其中包括Eclipse MicroProfile、Node.js、Spring
    Boot和Vertex。'
- en: '**Provide developers with a self-service, on-demand infrastructure**: "*Use
    containers and container orchestration technologies to simplify access to the
    underlying infrastructure, give control and visibility to IT operations teams,
    and provide robust application life cycle management across various infrastructure
    environments, such as data centers, private clouds, and public clouds.*" The microservices
    you develop with Eclipse MicroProfile can be deployed to one or more containers.
    By easily managing these containers and your microservices architecture, which
    is running on them, you can accelerate your development cycles to deliver value
    to the business faster.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为开发者提供自助、按需的基础设施**：“*使用容器和容器编排技术简化对底层基础设施的访问，赋予IT运营团队控制和可见性，并在各种基础设施环境中，如数据中心、私有云和公有云，提供健壮的应用生命周期管理。*”
    使用Eclipse MicroProfile开发的微服务可以部署到一个或多个容器中。 通过轻松管理这些容器以及在其上运行的微服务架构，您可以加快开发周期，更快地向业务交付价值。'
- en: '**Automate IT to accelerate application delivery**: "*Create a**utomation sandboxes
    in order to lea**rn about the automation language and process, establish collaborative
    dialog across organizations for defining service requirements, create self-service
    catalogs that empower users and speed delivery, and use metering, monitoring,
    and chargeback policies and processes.*" Eclipse MicroProfile provides capabilities
    for metrics, fault tolerance, and health checks, all of which can be used as input
    to the IT automation processes.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动化IT以加速应用交付**：“*创建自动化沙盒，以学习自动化语言和流程，跨组织建立协作对话以定义服务需求，创建自助服务目录以赋予用户权力并加快交付，以及使用度量、监控和计费回策略和流程。*”
    Eclipse MicroProfile提供了度量、容错和健康检查等功能，这些都可以作为IT自动化过程的输入。'
- en: '**Implement continuous delivery and advanced deployment techniques**: "*Accelerate
    the delivery of your cloud-native applications with automated delivery, CI/CD
    pipelines, rolling blue/green and canary deployments, and A/B testing.*" The use
    of microservices in combination with CI/CD can facilitate advanced deployment
    techniques. For example, you can introduce a MicroProfile-based microservice with
    new functionality as part of a blue/green or canary deployment into production
    and switch all of the traffic to it once you have proven that the new functionality
    works as expected.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实施持续交付和高级部署技术**："*使用自动化交付、CI/CD管道、滚动蓝/绿和金丝雀部署以及A/B测试，加速你的云原生应用程序的交付。*" 微服务与CI/CD的结合可以促进高级部署技术。例如，你可以作为一个蓝/绿或金丝雀部署的一部分，将具有新功能的MicroProfile基础微服务引入生产中，一旦你证明了新的功能如预期般工作，就可以将所有流量切换到它。'
- en: '**Evolve a more modular architecture**: "*Choose a modular design that makes
    sense for your specific needs, using microservices, a monolith-first approach,
    or miniservices – or a combination.*" For this step, you can use Eclipse MicroProfile
    to develop microservices for new applications or as you break specific bounded
    contexts of your monolith into microservices.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进化成更模块化的架构**： "*选择一种适合你特定需求的模块化设计，使用微服务、单体优先方法或迷你服务——或它们的组合。*" 在这一步，你可以使用Eclipse
    MicroProfile来为新的应用程序开发微服务，或者在你将单体的特定有限上下文拆分为微服务时使用。'
- en: Now that we have discussed how Eclipse MicroProfile facilitates cloud-native
    application development and how it can help in each of the eight steps to guide
    you in your journey to cloud-native applications, let's turn to the topic of running
    MicroProfile-based applications across clouds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了Eclipse MicroProfile如何促进云原生应用程序的开发，以及它如何在八个步骤中帮助引导你走向云原生应用程序，现在让我们转向在云之间运行基于MicroProfile的应用程序的主题。
- en: Developing and running MicroProfile applications across clouds
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云之间开发和运行MicroProfile应用程序
- en: What features does MicroProfile provide to support development across clouds?
    Microservices and support for language-agnostic communication based on HTTP REST
    API are two of the main features that are supported. In addition, MicroProfile
    Config supports the integration of cloud environment variables that define integration
    with the cloud environment. MicroProfile Health Check supports integration with
    the cloud environment health checks. MicroProfile Metrics and MicroProfile OpenTracing support
    integration with the DevOps monitoring tasks. Finally, MicroProfile fault tolerance
    supports fallback and recovery behaviors between the independent microservices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile提供了哪些特性来支持在云之间开发？微服务和基于HTTP REST API的语言无关通信是支持的两个主要特性。此外，MicroProfile
    Config支持将云环境变量集成到定义与云环境集成的集成中。MicroProfile Health Check支持与云环境健康检查的集成。MicroProfile
    Metrics和MicroProfile OpenTracing支持与DevOps监控任务的集成。最后，MicroProfile容错支持独立微服务之间的回退和恢复行为。
- en: Eclipse MicroProfile ...
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile ...
- en: Bare-metal machines versus VMs versus containers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裸机机器与虚拟机与容器
- en: The decision of whether to run a MicroProfile-based microservice or application
    on bare-metal machines, VMs, or containers depends on the specific requirements
    of your application. In fact, the determination of what type of underlying cloud
    compute resource rests squarely on your application needs and not the framework
    being used for its development, that is, Eclipse MicroProfile. For example, if
    your application or microservice requires real or near-real-time response times,
    then you'd most likely favor a bare-metal or container (running on bare-metal)
    deployment. This decision would be made independent of the framework you are using
    to write your business logic, whether that be Eclipse MicroProfile or another
    one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是否在裸机机器、虚拟机或容器上运行基于MicroProfile的微服务或应用程序取决于你的应用程序的具体要求。实际上，确定哪种底层云计算资源完全取决于你的应用程序需求，而不是用于其开发的框架，即Eclipse
    MicroProfile。例如，如果你的应用程序或微服务需要实时或接近实时的响应时间，那么你很可能会偏好裸机或容器（运行在裸机上）部署。这个决定与你正在使用来编写业务逻辑的框架无关，无论是Eclipse
    MicroProfile还是其他框架。
- en: Since Eclipse MicroProfile supports microservices and language-agnostic communication
    based on HTTP REST, your inter-microservice communication is unaffected by the
    type of underlying compute on which your microservices are running; for example,
    you could have a microservice running on a VM communicating via REST with another
    microservice running on a bare-metal machine. But what if your application consists
    of microservices running on-premises and another running on the cloud, also known
    as a hybrid cloud application? What considerations do you need to have in mind?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Eclipse MicroProfile 支持微服务和基于 HTTP REST 的语言无关通信，你的微服务之间的通信不受运行微服务的底层计算类型的影响；例如，你可以有一个运行在
    VM 上的微服务通过 REST 与另一个运行在裸机上的微服务进行通信。但是，如果你的应用程序由在本地运行的微服务和在云上运行的另一个微服务组成，也称为混合云应用程序，你需要考虑什么？
- en: Considerations when using MicroProfile in a hybrid cloud deployment
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在混合云部署中使用 MicroProfile 时的考虑
- en: 'A hybrid cloud application comprises on-premises logic as well as on-cloud
    logic. In other words, if part of your application logic runs on-premises and
    part of it runs in the cloud, you effectively have a hybrid cloud application.
    When using Eclipse MicroProfile in this type of deployment, here are the things
    you need to consider:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 混合云应用程序包括本地逻辑以及云逻辑。换句话说，如果你的应用程序逻辑的一部分在本地运行，另一部分在云中运行，你实际上拥有一个混合云应用程序。当在这个类型的部署中使用
    Eclipse MicroProfile 时，以下是你需要考虑的事情：
- en: Configuration of communication routes between the cloud environment and the
    on-premises environment needs to be done using whatever DNS support the cloud
    environment supports
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置云环境与本地环境之间的通信路由需要使用云环境支持的所有 DNS 支持
- en: Configuration of MicroProfile OpenTracing to enable the capture of tracing across
    cloud environments
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 MicroProfile OpenTracing 以在云环境之间捕获跟踪
- en: Monitoring of the split MicroProfile Metrics information across cloud ...
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云环境和本地环境之间分割 MicroProfile Metrics 信息进行监控...
- en: Challenges when using MicroProfile OpenTracing in a multi-cloud deployment
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多云部署中使用 MicroProfile OpenTracing 时的挑战
- en: Distributed tracing in a multi-cloud environment can be challenging. We want
    to fulfill the same objective that we would with a single cloud environment, that
    is, to visualize the single end-to-end trace associated with a request as it passes
    through services within and across each cloud, but may face complications when
    dealing with different context propagation formats and storage of the tracing
    data in different formats per cloud.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在多云环境中进行分布式跟踪可能会很有挑战性。我们希望能够实现与单一云环境相同的目标，即可视化与请求相关联的单个端到端跟踪，以及它穿过每个云中的服务，但在处理不同的上下文传播格式和每个云存储跟踪数据的不同格式时可能会遇到复杂问题。
- en: The first challenge is to ensure that a trace continues across different cloud
    environments. This is a problem because, at the time of writing this book, there
    is not a widely adopted or standardized trace context format. Usually, each tracing
    system uses different headers and formats to propagate the tracing context. For
    instance, Zipkin uses B3 propagation, Jaeger uses a `ber-trace-id` header, Amazon
    X-Ray uses `X-Amzn-Trace-Id`, and Google uses `X-Cloud-Trace-Context`. Therefore,
    if a request has to be traced across heterogenous tracing systems, each time it
    leaves or enters a different environment, the trace context has to be converted.
    This can usually be done by configuring a tracer with a custom injector or extractor
    implementation. However, this is currently beyond the scope of the MicroProfile
    OpenTracing project. In the future, the trace context format might be standardized
    under the W3C Trace Context project ([https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是要确保跟踪可以在不同的云环境中持续进行。这是一个问题，因为截至撰写本书时，还没有被广泛采用或标准化的跟踪上下文格式。通常，每个跟踪系统都使用不同的头文件和格式来传播跟踪上下文。例如，Zipkin
    使用 B3 传播，Jaeger 使用 `ber-trace-id` 头文件，Amazon X-Ray 使用 `X-Amzn-Trace-Id`，Google
    使用 `X-Cloud-Trace-Context`。因此，如果一个请求需要在不同的跟踪系统之间进行跟踪，每次它离开或进入不同的环境时，都需要转换跟踪上下文。这通常可以通过配置带有自定义注入器或提取器实现的跟踪器来完成。然而，这目前超出了
    MicroProfile OpenTracing 项目的范围。将来，跟踪上下文格式可能会在 W3C 跟踪上下文项目下得到标准化([https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/)).
- en: The second challenge, even in a homogenous tracing environment, is to visualize
    tracing data from multi-cloud environments. This can be problematic because tracing
    data in each cloud might be stored in different databases or in different formats.
    This can be overcome by replicating the data to a single unified storage or sending
    missing tracing data between systems on-demand with the appropriate data format
    adjustments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个挑战，即使在同质追踪环境中，也是可视化多云环境中的追踪数据。这可能很成问题，因为每个云中的追踪数据可能存储在不同的数据库或不同的格式中。这可以通过将数据复制到单一统一存储，或者使用适当的数据格式调整，在系统之间按需发送缺失的追踪数据来克服。
- en: Next, we will discuss the challenges of using Eclipse MicroProfile in a service
    mesh, such as Istio.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在像Istio这样的服务网格中使用Eclipse MicroProfile遇到的挑战。
- en: Considerations when using Eclipse MicroProfile in a service mesh
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务网格中使用Eclipse MicroProfile的考虑
- en: Service meshes such as Istio or LinkerD offer services at the platform level
    on top of Kubernetes in the areas of discovery, routing, and fault tolerance. Some
    of those services can also be found in MicroProfile. When you deploy a MicroProfile
    application into such a service mesh, you need to consider whether you want to
    use the version from MicroProfile or the one from the mesh.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 像Istio或LinkerD这样的服务网格在Kubernetes之上的平台级别提供服务，涵盖发现、路由和故障容限等领域。其中一些服务也可以在MicroProfile中找到。当你将MicroProfile应用程序部署在这样的服务网格中时，你需要考虑是否想使用MicroProfile版本或网格中的版本。
- en: The MicroProfile feature that is most likely affected here is fault tolerance,
    especially the retry logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 受影响的MicroProfile特性最可能是故障容限，尤其是重试逻辑。
- en: Retry
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试
- en: 'Retry in fault tolerance lets you retry a request to another service in case
    the first request fails (see [Chapter 3](73f2287d-1676-47c9-9887-cf74aa0aa6f0.xhtml), *MicroProfile
    Config and Fault Tolerance*, for more information). Now, consider that you have
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障容限中的重试允许在第一个请求失败时重试对另一个服务的请求（更多信息请参见[第3章](73f2287d-1676-47c9-9887-cf74aa0aa6f0.xhtml)，*MicroProfile
    Config和Fault Tolerance*）。现在，考虑你有以下代码：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this tells Istio to retry 5 times, you may end up with 15 retries (Istio
    will retry 5 times for each of the 3 retries in your code before it returns an
    error) before `aMethod` finally ends with an error. You may consider turning off
    the retries in code, as changes to the number of retries in Istio can be made
    on the fly without the need to restart a pod.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这告诉Istio重试5次，但最终可能导致`aMethod`以错误结束，共进行15次重试（Istio会在返回错误之前为您的代码中的3次重试各重试5次）。你可能考虑关闭代码中的重试，因为可以通过不需要重启pod的方式，随时在Istio中更改重试次数。
- en: Fallback
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回退
- en: 'On the other hand, Istio does not have a fallback policy for when all the retries
    fail – it is not possible to have Istio call another version of your workload. When
    you annotate the preceding code with the `@Fallback` annotation, it is possible
    to execute another action in case the original call fails:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Istio没有在所有重试失败时调用回退策略——不可能让Istio调用您工作负载的另一个版本。当你在前面的代码上添加`@Fallback`注解时，在原始调用失败的情况下可以执行另一个动作：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the `fallbackForA` fallback method will be called once all the
    retries from Istio, times those from MicroProfile, have been exhausted. If you
    remove the `@Retry` annotation from the preceding example, the fallback method
    is called when the Istio retries have been exhausted. ...
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一旦Istio和MicroProfile的所有重试都耗尽，将会调用`fallbackForA`回退方法。如果你从前面示例中移除了`@Retry`注解，当Istio的重试耗尽时会调用回退方法...
- en: Fault injection in the service mesh
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格中的故障注入
- en: 'Istio lets you inject faults into the results pretty easily. This sounds counterproductive
    at the start, but can be a very nice way of testing that you get the fault tolerance
    handling right. The following `VirtualService` for Istio defines such fault injection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Istio可以很容易地在结果中注入故障。这听起来开始时有些适得其反，但这是一个非常好的测试您是否正确处理了故障容限的方式。以下是为Istio定义故障注入的`VirtualService`：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Istio will hear for calls to the destination host, `myTarget`, and send a 404
    response for 20% of the calls instead of the real response code. On top of this,
    it will delay every other response by 200 milliseconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Istio将监听对目标主机`myTarget`的调用，并对20%的调用发送404响应，而不是真实的响应代码。此外，它还会将其他每个响应延迟200毫秒。
- en: Conclusion
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: MicroProfile defines primitives in the area of fault tolerance that can also
    be provided by other means, such as in a service mesh. If this is the case for
    you, you have to consider which one to activate. Activating both may result in
    unexpected behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile在容错领域定义了原语，这些原语也可以通过其他方式提供，例如在服务网格中。如果这是你的情况，你必须考虑激活哪一个。同时激活两个可能会导致意外行为。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how Eclipse MicroProfile facilitates cloud-native
    application development, regardless of whether it is a hybrid cloud or multi-cloud
    application. We also discussed the relationship between microservices, cloud-native
    development, and container-native development, and how microservices running on
    containers are an ideal option for cloud-native development. You also learned
    how Eclipse MicroProfile relates to the 12-factor app, as well as serverless and
    FaaS environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了Eclipse MicroProfile如何促进云原生应用程序开发，无论是混合云还是多云应用程序。我们还讨论了微服务、云原生开发和容器原生开发之间的关系，以及运行在容器上的微服务是云原生开发的理想选择。你也学习了Eclipse
    MicroProfile与12因子应用程序以及无服务器和函数即服务环境的关系。
- en: We covered the eight steps to guide your journey into cloud-native applications
    and how Eclipse MicroProfile can help at each step. In addition, we discussed
    what you need to consider when using Eclipse MicroProfile for applications that
    span across clouds, when to run Eclipse MicroProfile on bare-metal machines versus
    VMs versus containers, what to consider when running Eclipse MicroProfile microservices
    in hybrid cloud applications, the challenges to be aware of when running Eclipse
    MicroProfile OpenTracing in a multi-cloud deployment, and finally what to consider
    when using Eclipse MicroProfile in a service mesh.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了八个步骤，指导你进入云原生应用程序的旅程，以及Eclipse MicroProfile如何在每一步帮助。此外，我们还讨论了在使用Eclipse
    MicroProfile跨云应用程序时需要考虑的内容，何时在裸机机器上运行Eclipse MicroProfile与在虚拟机上运行Eclipse MicroProfile与在容器上运行Eclipse
    MicroProfile，以及在运行Eclipse MicroProfile微服务时需要考虑的内容在混合云应用程序中，在运行Eclipse MicroProfile
    OpenTracing时需要意识到的多云部署挑战，以及最后在使用Eclipse MicroProfile时需要考虑的内容在服务网格中。
- en: Throughout this book, we've covered the origins of MicroProfile, a specification
    for Java microservices, and the history behind how it came into being. We introduced
    the open source project, its mission, governance, benefits, how to contribute
    to it, and the life cycle of its sub-projects. We then delved into each of the
    MicroProfile APIs/sub-projects that make up the umbrella/platform release, as
    well as the sub-projects outside the umbrella release.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经介绍了MicroProfile的起源，这是一个针对Java微服务的规范，以及它背后的历史。我们介绍了开源项目，它的使命、治理、好处、如何为其做出贡献以及其子项目的生命周期。然后我们深入探讨了构成伞式/平台发布的每个MicroProfile
    API/子项目，以及不在伞式发布的子项目。
- en: We also covered the current implementations of MicroProfile in the market, including
    Quarkus, and showed you how to "quark" a generated MicroProfile project by the
    MicroProfile Starter. We discussed the Conference Application, a community sample
    project that demonstrates the interoperability of MicroProfile across different
    vendor implementations. We also provided code examples throughout for reference
    and discussion purposes, and also provided a fully working project with source
    code that implemented all the MicroProfile APIs that you can freely access, download,
    compile, and reuse in your development efforts and to get jump-started with MicroProfile.
    Later, we discussed the reactive functionality offered by MicroProfile and its
    future developments, such as sub-projects in the pipeline and in the MicroProfile
    sandbox, as well as its likely future relationship with Jakarta EE.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样覆盖了市场上当前的MicroProfile实现，包括Quarkus，并展示了如何使用MicroProfile Starter生成的MicroProfile项目来“quark”项目。我们讨论了会议应用程序，这是一个社区样本项目，展示了MicroProfile在不同供应商实现之间的互操作性。我们还在整个文档中提供了代码示例，以便参考和讨论，并且还提供了一个带有源代码的完整可工作项目，实现了所有MicroProfile
    API，您可以自由访问、下载、编译并在您的开发努力中重用，以及开始使用MicroProfile。后来，我们讨论了MicroProfile提供的响应式功能及其未来发展，例如管道中的子项目和对MicroProfile沙盒的子项目，以及它可能与Jakarta
    EE的未来关系。
- en: Lastly, we went over how MicroProfile-based applications and microservices are
    a good fit for implementing solutions in containers, the cloud, and serverless/FaaS
    deployments. Whether you are new to Java microservices or an experienced Java
    developer, you can use all the knowledge you have gained from this book to start
    developing microservices that are based on this new and innovative community-driven
    specification for the creation of observable, scalable, secure, and highly available
    hybrid and multi-cloud applications so that you can deliver value to your business
    faster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了基于**MicroProfile**的应用程序和微服务如何适合在容器、云以及无服务器/FaaS部署中实现解决方案。无论您是Java微服务的新手还是有经验的Java开发者，您都可以利用本书中获得的所有知识来开始开发基于这一新型的、创新的社区驱动规范的微服务，以创建可观察、可扩展、安全和高可用的混合和多云应用，从而您可以更快地为您的企业提供价值。
- en: Questions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does Eclipse MicroProfile facilitate cloud-native application development?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile**如何促进云原生应用开发？'
- en: What are the two complementary concerns of cloud-native application development?
    How does Eclipse MicroProfile fit into these concerns?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云原生应用开发的两个互补关注点是什么？**Eclipse MicroProfile**如何融入这些关注点？
- en: What are the four key tenets of cloud-native application development? How does
    Eclipse MicroProfile relate to these?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云原生应用开发的四个关键原则是什么？**Eclipse MicroProfile**与这些原则有何关联？
- en: How does Eclipse MicroProfile contribute to each of the eight steps to guide
    your journey through cloud-native applications?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile**如何为引导您通过云原生应用开发的八个步骤做出贡献？'
- en: How does Eclipse MicroProfile relate to the 12-factor app?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile**与12因子应用有何关联？'
- en: How can Eclipse MicroProfile facilitate serverless and FaaS environments?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile**如何促进无服务器和FaaS环境？'
- en: What should you consider when implementing and running Eclipse MicroProfile
    across clouds?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在跨云实施和运行**Eclipse MicroProfile**时，您应该考虑哪些问题？
- en: What are the challenges when using Eclipse MicroProfile ...
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Eclipse MicroProfile**时会遇到哪些挑战...
