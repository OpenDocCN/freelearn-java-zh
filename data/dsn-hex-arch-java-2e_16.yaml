- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Using SOLID Principles with Hexagonal Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SOLID 原则与六边形架构
- en: The idea of having a set of principles to help us develop better software amuses
    me. Over the years, programmers have faced many problems; some happened so often
    that patterns to solve such issues emerged, giving rise to the so-called **design
    patterns**. These patterns have been employed to solve specific software development
    problems. Complementing design patterns that act more on recurrent and specific
    coding problems, ideas have emerged on tackling maintainability problems in software
    projects. A remarkable and influential set of those ideas has been synthesized
    into what is known as **SOLID principles**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一套原则来帮助我们开发更好的软件的想法让我感到有趣。多年来，程序员们面临了许多问题；有些问题发生得如此频繁，以至于出现了解决这类问题的模式，从而产生了所谓的**设计模式**。这些模式被用来解决特定的软件开发问题。为了补充那些主要针对重复和特定编码问题的设计模式，人们还提出了解决软件项目中可维护性问题的新思路。其中一套引人注目且具有影响力的思想被综合为众所周知的**SOLID原则**。
- en: This chapter will explore SOLID principles and how we can tap into them while
    using hexagonal architecture. We will start by reviewing each principle, and then
    we will proceed to see how they can be applied in the context of a hexagonal system.
    Finally, we will discuss how design patterns, such as builder and abstract factory,
    can be used with hexagonal architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 SOLID 原则以及我们如何在使用六边形架构时利用它们。我们将首先回顾每个原则，然后我们将继续探讨它们如何在六边形系统的背景下应用。最后，我们将讨论如何将建造者和抽象工厂等设计模式与六边形架构结合使用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding SOLID principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SOLID 原则
- en: Applying SOLID on a hexagonal architecture system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在六边形架构系统中应用 SOLID
- en: Exploring other design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他设计模式
- en: After completing this chapter, you will be able to employ SOLID principles in
    conjunction with hexagonal architecture techniques. Also, you will know how to
    use design patterns, such as chain of responsibility, decorator, builder, and
    singleton, while developing a hexagonal system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章学习后，您将能够结合六边形架构技术使用 SOLID 原则。同时，您还将了解如何在开发六边形系统时使用设计模式，例如责任链模式、装饰者模式、建造者模式和单例模式。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, MacOS, and Windows operating systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，您需要在您的计算机上安装最新的**Java SE 开发工具包**和**Maven 3.8**。它们适用于 Linux、MacOS
    和 Windows 操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16)。
- en: Understanding SOLID principles
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SOLID 原则
- en: Since the advent of programming, developers have discussed ideas and captured
    principles to help develop better software. These principles arose as a response
    to help handle highly complex code. After suffering multiple times from the same
    recurrent problems, developers started recognizing those problems’ patterns and
    devised techniques to prevent such issues. A notable example is the **Gang of
    Four** (**GoF**) book on design patterns, which caused a tremendous impact in
    the object-oriented world and continues to influence generations of developers
    to this day. Another remarkable and influential example is the ideas formulated
    by Robert Martin that led to SOLID principles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从编程诞生以来，开发者们一直在讨论想法并捕捉原则，以帮助开发更好的软件。这些原则的出现是为了应对处理高度复杂代码的需求。在多次遭受相同重复问题后，开发者开始认识到这些问题的模式，并设计了防止此类问题的技术。一个显著的例子是关于设计模式的**四人帮**（**GoF**）书籍，它在面向对象的世界中产生了巨大影响，并继续影响着一代又一代的开发者。另一个引人注目且具有影响力的例子是罗伯特·马丁提出的思想，这些思想导致了
    SOLID 原则的形成。
- en: 'SOLID stands for the following principles:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 代表以下原则：
- en: '**Single Responsibility** **Principle** (**SRP**)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）'
- en: '**Open Closed** **Principle** (**OCP**)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）'
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）'
- en: '**Interface Segregation** **Principle** (**ISP**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）'
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置** **原则** （**DIP**）'
- en: These principles aim to help developers create robust and easy-to-change software
    through code, based on a set of rules defined by those principles. I believe that
    using these principles does not fully guarantee that software is free of maintainability
    problems. However, such principles can significantly improve overall code quality.
    In essence, it’s all about employing techniques that allow the introduction of
    changes to a code base in a sustainable way. I mean, the software will grow, but
    its complexity will be kept under control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则旨在通过代码帮助开发者创建健壮且易于更改的软件，基于这些原则定义的一系列规则。我相信使用这些原则并不能完全保证软件没有可维护性问题。然而，这些原则可以显著提高整体代码质量。本质上，这全部关于采用允许以可持续的方式向代码库引入更改的技术。我的意思是，软件会增长，但它的复杂性将得到控制。
- en: SOLID principles work in a similar way to hexagonal architecture because both
    aim to provide techniques to develop more maintainable, change-tolerant software.
    Therefore, it makes sense to explore how those principles can be applied in the
    context of a hexagonal application. Let’s start our exploration by reviewing each
    one of the SOLID principles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则与六边形架构以类似的方式工作，因为两者都旨在提供技术来开发更易于维护、更易于更改的软件。因此，探索这些原则如何在六边形应用程序的背景下应用是有意义的。让我们从回顾SOLID原则的每一个开始我们的探索。
- en: Single Responsibility Principle (SRP)
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: It’s not hard for me to remember a situation where I would witness or be the
    author of a code change that caused side effects, discovered only after an application
    was deployed to a staging or, even worse, production environment. A stakeholder
    would report problems in the application that started to occur right after the
    change that caused the side effect was deployed. So, although the change solved
    the problem for one stakeholder, it created a problem for another. Why? Because
    the change responsible for the problem has violated the SRP. The violation occurred
    because the same system logic served two different stakeholders. The change solved
    the problem for one stakeholder but created a side effect that caused trouble
    for the other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得一个情况，我会目睹或成为导致副作用代码更改的作者，这种副作用只有在应用程序部署到预发布环境或更糟糕的生产环境后才会被发现。一个利益相关者会报告应用程序在导致副作用的更改部署后开始出现的问题。所以，尽管这个更改解决了某个利益相关者的问题，但它为另一个利益相关者创造了问题。为什么？因为导致问题的更改违反了SRP。违反发生是因为相同的系统逻辑为两个不同的利益相关者服务。这个更改解决了某个利益相关者的问题，但为另一个利益相关者创造了副作用，导致了问题。
- en: An SRP violation can also occur when we define abstractions too early. Suppose
    we define an abstract class with certain data and behaviors we believe will be
    common to all future implementations of that abstract class. Then, later on, we
    discover, through an unfortunate incident report, that some data or behavior from
    that abstract class causes unexpected outcomes in a recent implementation provided
    by another developer, who assumed the behaviors and data provided by that abstraction
    would work in the implementation that causes the trouble.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们过早地定义抽象时，也可能违反SRP。假设我们定义了一个抽象类，其中包含我们认为将适用于该抽象类所有未来实现的一些数据和行为。然后，后来通过一个不幸的事故报告，我们发现该抽象类中的一些数据或行为在另一位开发者的最近实现中导致了意外的结果，这位开发者假设由该抽象提供的行为和数据将在导致问题的实现中工作。
- en: The SRP ensures a method or function is changed based on requests from only
    one type of stakeholder or actor, usually a department or a line of business in
    an organization. It is important to ensure the logic from department A, for example,
    does not mess up the logic from department B, which can be accomplished by arranging
    the code in a way that the logic to serve different stakeholders is adequately
    separated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SRP确保一个方法或函数的更改仅基于一种利益相关者或行为者的请求，通常是一个组织的部门或一条业务线。确保部门A的逻辑，例如，不会干扰部门B的逻辑是很重要的，这可以通过以某种方式安排代码来实现，即服务于不同利益相关者的逻辑得到适当的分离。
- en: Open-Closed Principle (OCP)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放-封闭原则（OCP）
- en: The idea behind this principle lies in increasing what software can do without
    changing the existing things in it. In order to do this, a software component
    or module should be open for extension but closed for modification. I can recall
    an experience where I was implementing a reporting feature. Instead of having
    one class to deal with all kinds of reports, I created a base abstract class with
    basic attributes common to reports. Every time a new type of report had to be
    implemented, a new concrete class would be created by implementing the base abstract
    class. Additional attributes and functions would be appended to the basic attributes
    of the base abstract class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则背后的想法在于在不改变现有事物的情况下增加软件的功能。为了做到这一点，一个软件组件或模块应该是可扩展的，但不可修改的。我可以回忆起一个经历，当时我在实现报告功能。我没有使用一个类来处理所有类型的报告，而是创建了一个具有报告的基本属性的基础抽象类。每次需要实现新的报告类型时，就会通过实现基础抽象类创建一个新的具体类。额外的属性和功能会被附加到基础抽象类的基本属性上。
- en: We use the OCP to avoid those situations where we want to add a new feature,
    and to do so, we also need to change some piece of logic already supporting an
    existing feature. By doing that, we violate the OCP. Instead, we need to arrange
    code so that we can add new features without modifying the code already serving
    existing features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 OCP 来避免那些我们想要添加新功能，并且为了实现这个功能，我们也需要更改已经支持现有功能的一些逻辑的情况。通过这样做，我们违反了 OCP。相反，我们需要安排代码，以便我们可以在不修改现有代码的情况下添加新功能。
- en: Liskov Substitution Principle (LSP)
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则（LSP）
- en: Based on the reporting example I gave in the OCP description, let’s suppose
    we have a `Report` class containing the `print` method declaration. According
    to a given problem domain, the `print` method is a behavior supported by any report.
    In addition to the `Report` class, imagine we have the `WorkdayReport` and `WeekendReport`
    classes extending it. The LSP prescribes that if we pass objects of type `WorkdayReport`
    or `WeekendReport` to a method expecting a `Report` type, that method will be
    able to trigger the behaviors inherent to all kinds of reports – in this case,
    the `print` method. The bottom line is that the `Report` type should be designed
    so that its declared methods, when overridden for sub-types, should be coherent
    with the subtype’s purpose.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我在 OCP 描述中给出的报告示例，让我们假设我们有一个包含 `print` 方法声明的 `Report` 类。根据给定的问题域，`print` 方法是任何报告支持的行为。除了
    `Report` 类之外，假设我们还有扩展它的 `WorkdayReport` 和 `WeekendReport` 类。LSP 规定，如果我们向期望 `Report`
    类型的方法传递 `WorkdayReport` 或 `WeekendReport` 类型的对象，该方法将能够触发所有报告类型固有的行为——在这种情况下，就是
    `print` 方法。总之，`Report` 类型应该被设计得使其声明的、在子类型中重写的方法与子类型的目的保持一致。
- en: Interface Segregation Principle (ISP)
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: The ISP is helpful whenever we want to provide clients with an interface containing
    only the method declarations they need. This principle is usually employed when
    we have a single interface with many method declarations, and a given client only
    implements some methods and provides dummy implementations for those they don’t
    need. By employing the ISP, we break that single interface with multiple interfaces
    tailored for specific client needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为客户提供只包含他们需要的声明的方法的接口时，ISP 是有帮助的。这个原则通常在我们有一个包含许多方法声明的单一接口，并且一个特定的客户端只实现一些方法并为不需要的方法提供占位实现时被使用。通过应用
    ISP，我们打破了那个包含多个接口的单个接口，这些接口针对特定的客户端需求进行了定制。
- en: Dependency Inversion Principle (DIP)
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）
- en: Stable and unstable software components have distinct concepts. *Stable* means
    those components that don’t change too often, while *unstable* is the opposite.
    Having a client component depending directly on an unstable component may be risky
    because changes in unstable code can trigger changes in the client. Most of the
    time, the unstable component is a concrete class with implementation details that
    don’t need to be exposed to its clients.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定和不稳定的软件组件有截然不同的概念。*稳定*意味着那些不太经常变化的组件，而*不稳定*则相反。一个客户端组件直接依赖于一个不稳定的组件可能是危险的，因为不稳定代码的变化可能会触发客户端的变化。大多数情况下，不稳定组件是一个具有不需要暴露给其客户端的实现细节的具体类。
- en: To avoid exposing such implementation details and protect the client from dependency
    changes, DIP prescribes that clients should always depend on abstractions rather
    than concretions. The unstable component – a concrete class with implementation
    details – should derive from an abstraction by implementing an interface, for
    example. Then, the client should rely on a stable component, an interface implemented
    by the unstable component (a concrete class). We call an interface a stable component
    because it acts as a contract, and contracts are less susceptible to change.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免暴露此类实现细节并保护客户端免受依赖变更的影响，DIP 规定客户端应始终依赖于抽象而非具体实现。不稳定的组件——一个具有实现细节的具体类——应通过实现一个接口（例如）从抽象中派生出来。然后，客户端应依赖于一个稳定的组件，即不稳定组件（具体类）实现的接口。我们称接口为稳定组件，因为它充当合同，而合同更不易发生变化。
- en: Let’s see in the next section how we can apply SOLID principles to an application
    developed using hexagonal architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看如何将 SOLID 原则应用于使用六边形架构开发的应用程序。
- en: Applying SOLID on a hexagonal architecture system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在六边形架构系统中应用 SOLID 原则
- en: To see how each SOLID principle is applied, we will go back to the topology
    and inventory system we have developed throughout the book. Let’s start by seeing
    how the SRP can be applied in the topology and inventory system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解每个 SOLID 原则是如何应用的，我们将回到本书中开发的全局拓扑和库存系统。让我们首先看看 SRP 在拓扑和库存系统中是如何应用的。
- en: Applying the SRP
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 SRP
- en: Just to recap, the topology and inventory system manages network resources such
    as routers and switches. Such a system is suited for telecommunication or **Internet
    Service Provider** (**ISP**) companies that want to keep an inventory of the network
    resources they use to serve their customers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了回顾，拓扑和库存系统管理网络资源，如路由器和交换机。这样的系统适合电信或**互联网服务提供商**（**ISP**）公司，他们希望对其为服务客户所使用的网络资源进行库存管理。
- en: In the topology and inventory system, we have core and edge routers. Core routers
    handle high-load network traffic from one or more edge routers. Edge routers are
    used to handle traffic from end users. Edge routers connect to network switches.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在拓扑和库存系统中，我们有核心路由器和边缘路由器。核心路由器处理来自一个或多个边缘路由器的高负载网络流量。边缘路由器用于处理来自最终用户的流量。边缘路由器连接到网络交换机。
- en: Consider a scenario where core and edge routers change locations. For example,
    a core router that is now localized in France needs, for some reason, to be re-provisioned
    in Italy, and an edge router that is in Frankfurt needs to be re-provisioned in
    Berlin. Consider also that network changes across countries are handled by actor
    A, and network changes across cities are handled by actor B.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，核心路由器和边缘路由器更改位置。例如，现在位于法国的核心路由器由于某些原因需要重新配置到意大利，而位于法兰克福的边缘路由器需要重新配置到柏林。还要考虑网络跨国家变化由演员
    A 处理，而网络跨城市变化由演员 B 处理。
- en: 'Let’s change the topology and inventory application to fulfill the described
    requirement. The changes described as follows are made in the Domain hexagon:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将拓扑和库存应用程序更改为满足描述的要求。以下描述的更改是在域六边形中进行的：
- en: 'Create the `AllowedCountrySpec` specification class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `AllowedCountrySpec` 规范类：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This specification limits which countries can be chosen through the `allowedCountries`
    attribute. That’s not how you should represent it in a real application, but it
    is enough to illustrate the SRP idea.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此规范限制了可以通过 `allowedCountries` 属性选择的哪些国家。这并不是在真实应用程序中应该如何表示它，但它足以说明 SRP 的概念。
- en: 'Now, create the `AllowedCitySpec` specification class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建 `AllowedCitySpec` 规范类：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Following the same idea from the previous specification, here we limit which
    cities are allowed through the `allowedCities` attribute.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 沿用之前规范中的相同思路，我们在这里通过 `allowedCities` 属性限制允许的城市。
- en: 'Declare the `changeLocation` method in the `Router` abstract class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Router` 抽象类中声明 `changeLocation` 方法：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that `Router` is an abstract sealed class, allowing only the `CoreRouter`
    and `EdgeRouter` classes to implement it.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Router` 是一个抽象密封类，只允许 `CoreRouter` 和 `EdgeRouter` 类实现它。
- en: 'Provide an implementation for `CoreRouter`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `CoreRouter` 提供实现：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `AllowedCountrySpec` to check whether the new router `Location` is
    allowed. If a non-allowed country is provided, an exception is thrown. Otherwise,
    the new location is assigned to the `location` variable from the `Router` object.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `AllowedCountrySpec` 来检查新路由器 `Location` 是否被允许。如果提供了不允许的国家，将抛出异常。否则，将新位置分配给
    `Router` 对象的 `location` 变量。
- en: 'Provide an implementation for `EdgeRouter`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `EdgeRouter` 提供实现：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `EdgeRouter` implementation is slightly different. In addition to `AllowedCountrySpec`,
    we also have `AllowedCitySpec`. A new `Location` will be assigned to the `Router`
    object only after fulfilling these two specifications.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EdgeRouter` 的实现略有不同。除了 `AllowedCountrySpec`，我们还有 `AllowedCitySpec`。只有在这两个规范满足之后，才会为
    `Router` 对象分配一个新的 `Location`。'
- en: Let’s review what we have done here. We started by creating the `AllowedCountrySpec`
    and `AllowedCitySpec` specifications; then, we declared the `changeLocation` method
    on the `Router` abstract class. As both `CoreRouter` and `EdgeRouter` implement
    this class, we had to override the `changeLocation` method to serve the needs
    of actor A and actor B. Actor A is responsible for handling location changes across
    countries – in this case, `CoreRouter`. Actor B is in charge of handling location
    changes across cities, which is the responsibility of `EdgeRouter`’.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里做了什么。我们首先创建了 `AllowedCountrySpec` 和 `AllowedCitySpec` 规范；然后，我们在
    `Router` 抽象类上声明了 `changeLocation` 方法。由于 `CoreRouter` 和 `EdgeRouter` 都实现了这个类，我们必须重写
    `changeLocation` 方法来满足角色 A 和角色 B 的需求。角色 A 负责处理跨国家的位置更改——在这种情况下，是 `CoreRouter`。角色
    B 负责处理跨城市的位置更改，这是 `EdgeRouter` 的责任。
- en: Suppose that instead of declaring `changeLocation` as abstract, we provided
    a concrete implementation shared by both the `CoreRouter` and `EdgeRouter` classes.
    That would violate the SRP because the `changeLocation` logic would serve different
    actors.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们不是将 `changeLocation` 声明为抽象的，而是提供了一个由 `CoreRouter` 和 `EdgeRouter` 类共享的具体实现。这将违反
    SRP，因为 `changeLocation` 逻辑将服务于不同的角色。
- en: Applying the OCP
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 OCP
- en: 'We have not stated it yet, but the arrangement between the `Router`, `CoreRouter`,
    and `EdgeRouter` classes represents an application of the OCP. Observe the following
    Unified Modeling Language (UML) diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未声明，但 `Router`、`CoreRouter` 和 `EdgeRouter` 类之间的安排代表了 OCP 的应用。观察以下统一建模语言（UML）图：
- en: '![Figure 16.1 – Applying the OCP](img/B19777_16_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – 应用 OCP](img/B19777_16_01.jpg)'
- en: Figure 16.1 – Applying the OCP
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 应用 OCP
- en: The OCP ensures that a module or component is closed for change but open for
    extension. Instead of providing a class design where one single class would contain
    the logic to handle both core and edge routers, we leverage the inheritance capability
    from Java to extend the possibilities of the `Router` abstract class, without
    changing its attributes and behaviors. Such extensions are possible through the
    `CoreRouter` and `EdgeRouter` concrete class implementations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OCP 确保模块或组件对更改是封闭的，但对扩展是开放的。我们不是提供一个包含处理核心和边缘路由器逻辑的单个类的类设计，而是利用 Java 的继承能力来扩展
    `Router` 抽象类的可能性，而不改变其属性和行为。这种扩展通过 `CoreRouter` 和 `EdgeRouter` 具体类实现是可能的。
- en: Applying the LSP
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 LSP
- en: 'To demonstrate the application of the LSP, we need to make more changes in
    the topology and inventory system. While applying the SRP and OCP, we changed
    the Domain hexagon. Now, we will make changes in the Application hexagon:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 LSP 的应用，我们需要在拓扑和库存系统中进行更多更改。在应用 SRP 和 OCP 的同时，我们改变了域六边形。现在，我们将对应用程序六边形进行更改：
- en: 'Declare the `changeLocation` method in the `RouterManagementUseCase` interface:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RouterManagementUseCase` 接口中声明 `changeLocation` 方法：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Changing a router’s location is a new use case that we add to the topology and
    inventory system, so we add the `changeLocation` method declaration to express
    that use case.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改路由器的位置是我们添加到拓扑和库存系统中的新用例，因此我们添加了 `changeLocation` 方法声明来表达该用例。
- en: 'Implement the `changeLocation` method in `RouterManagementInputPort`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RouterManagementInputPort` 中实现 `changeLocation` 方法：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `changeLocation` method from `RouterManagementInputPort` calls `changeLocation`
    from `Router` by passing a `Location` object. `changeLocation` from `Router` has
    a logic that checks whether the provided `Location` is allowed. If everything
    is fine, we call `persitRouter` to persist `Router` with its new `Location`.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RouterManagementInputPort` 中的 `changeLocation` 方法通过传递一个 `Location` 对象来调用 `Router`
    中的 `changeLocation`。`Router` 中的 `changeLocation` 具有检查提供的 `Location` 是否被允许的逻辑。如果一切正常，我们调用
    `persitRouter` 来持久化带有其新 `Location` 的 `Router`。'
- en: 'The LSP application can be observed when we implement the `changeLocation`
    method in `RouterManagementInputPort`. Note that `changeLocation` expects a `Router`
    type:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在 `RouterManagementInputPort` 中实现 `changeLocation` 方法时，我们可以观察到 LSP 的应用。注意
    `changeLocation` 期望一个 `Router` 类型：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It means we can pass here either a `CoreRouter` or an `EdgeRouter` object because
    both extend `Router`, and both provide an implementation of `changeLocation`,
    a behavior inherent to all routers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以传递一个`CoreRouter`或一个`EdgeRouter`对象，因为它们都扩展了`Router`，并且它们都提供了`changeLocation`的实现，这是所有路由器固有的行为。
- en: Applying the ISP
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用ISP（接口隔离原则）
- en: 'While applying the LSP, we created `RouterManagementUseCase` and `RouterManagementInputPort`
    in the Application hexagon. Let’s finish our implementation by providing an input
    adapter in the Framework hexagon to connect the input adapter to the input port:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用LSP（Liskov替换原则）时，我们在应用程序六边形中创建了`RouterManagementUseCase`和`RouterManagementInputPort`。让我们通过在框架六边形中提供一个输入适配器来完成我们的实现，以将输入适配器连接到输入端口：
- en: 'Implement the `changeLocation` method in the `RouterManagementAdapter` class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RouterManagementAdapter`类中实现`changeLocation`方法：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `POST` and `PATH` annotations, we turn this method into a `REST` endpoint
    to receive requests sent to the `/router/changeLocation/{routerId}` URI. The router
    part of the URI comes from the top-level definition of the `PATH` annotation of
    the `RouterManagementAdapter` class.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用`POST`和`PATH`注解，我们将此方法转换为`REST`端点，以接收发送到`/router/changeLocation/{routerId}`
    URI的请求。URI中的路由部分来自`RouterManagementAdapter`类`PATH`注解的最高级定义。
- en: This input adapter gets `Router` using the `retrieveRouter` method from `RouterManagementUseCase`.
    Then, it converts the `LocationRequest` object into a `Location` domain object.
    Finally, it passes `Router` and `Location` to the `changeLocation` method from
    `RouterManagementUseCase`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此输入适配器使用`RouterManagementUseCase`中的`retrieveRouter`方法获取`Router`。然后，它将`LocationRequest`对象转换为`Location`域对象。最后，它将`Router`和`Location`传递给`RouterManagementUseCase`中的`changeLocation`方法。
- en: To confirm that our implementation works, let’s implement a test to check the
    entire flow.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确认我们的实现是有效的，让我们实现一个测试来检查整个流程。
- en: 'Implement the following test in the `RouterManagementAdapterTest` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RouterManagementAdapterTest`类中实现以下测试：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test changes the location of the Router, which is a core router located
    in the United States. After sending a `POST` request containing a `Location` object
    with `Germany` as the country and `Berlin` as the city, we run an assertion to
    ensure that the returned `Router` object has the changed location – Germany instead
    of the United States.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此测试更改了路由器的位置，这是一个位于美国的核心路由器。在发送包含国家为“德国”和城市为“柏林”的`Location`对象的`POST`请求后，我们运行一个断言以确保返回的`Router`对象具有更改后的位置——德国而不是美国。
- en: The ISP can be observed in making use-case operations available to the input
    adapter. We have the `RouterManagementInputPort` class implementing the `RouterManagementUseCase`
    interface. The ISP is employed because all method declarations from the `RouterManagementUseCase`
    interface are relevant and implemented by `RouterManagementInputPort`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ISP可以通过使用例操作对输入适配器可用来观察到。我们有`RouterManagementInputPort`类实现了`RouterManagementUseCase`接口。ISP被采用，因为`RouterManagementUseCase`接口的所有方法声明都由`RouterManagementInputPort`实现，并且都是相关的。
- en: Applying the DIP
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用DIP（依赖倒置原则）
- en: 'We discussed dependency inversion in [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192),
    *Applying Dependency Inversion with Java Modules*, where we used the **Java Platform
    Module System** (**JPMS**) to apply dependency inversion. To recap, let’s review
    the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第9章*](B19777_09.xhtml#_idTextAnchor192)，“使用Java模块应用依赖倒置”中讨论了依赖倒置，其中我们使用了**Java平台模块系统**（**JPMS**）来应用依赖倒置。为了回顾，让我们查看以下图表：
- en: '![Figure 16.2 – Reviewing dependency inversion](img/B19777_16_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 依赖倒置的回顾](img/B19777_16_02.jpg)'
- en: Figure 16.2 – Reviewing dependency inversion
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 依赖倒置的回顾
- en: 'The DIP states that clients should always depend on abstractions rather than
    concretions. That is precisely what we are doing by making `RouterManagementAdapter`
    depend on the `RouterManagementUseCase` interface, rather than the `RouterManagementInputPort`
    concrete class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DIP指出，客户端应该始终依赖于抽象而不是具体实现。这正是我们通过使`RouterManagementAdapter`依赖于`RouterManagementUseCase`接口，而不是`RouterManagementInputPort`具体类所做的事情：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion
    with Java Modules*, the `RouterManagementUseCase` interface implementation – a
    `RouterManagementInputPort` object – is provided by the JPMS. In the current implementation,
    we use Quarkus with the `@Inject` annotation to provide `RouterManagementInputPort`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19777_09.xhtml#_idTextAnchor192)，“使用Java模块应用依赖倒置”中，`RouterManagementUseCase`接口的实现——一个`RouterManagementInputPort`对象——由JPMS提供。在当前实现中，我们使用Quarkus和`@Inject`注解来提供`RouterManagementInputPort`。
- en: Exploring other design patterns
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他设计模式
- en: In previous chapters, we applied some design patterns while developing the topology
    and inventory system. These patterns helped us arrange code to support application
    needs better. So, in this section, we will review the design patterns we applied
    while implementing hexagonal architecture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在开发拓扑和库存系统时应用了一些设计模式。这些模式帮助我们更好地组织代码以支持应用需求。因此，在本节中，我们将回顾我们在实现六边形架构时应用的设计模式。
- en: Singleton
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: Before introducing Quarkus to our topology and inventory system, we had to provide
    our own mechanism to create a single database connection object. When handling
    database-based connections, it’s common to have just one instance that connects
    to a database and shares that connection with other objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍Quarkus到我们的拓扑和库存系统之前，我们必须提供自己的机制来创建一个单独的数据库连接对象。在处理基于数据库的连接时，通常只有一个实例连接到数据库，并将该连接与其他对象共享。
- en: 'Singleton is the pattern we used to create a single database connection instance,
    as shown in the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是我们用来创建单个数据库连接实例的模式，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To ensure only an object is created, we create a private constructor to prevent
    clients from creating additional instances. The object creation is handled by
    the `getInstance` method, which checks whether the instance attribute is `null.`
    If it is `null`, then it creates a new `RouterNetworkH2Adapter` and assigns it
    to the `instance` variable. The private constructor then creates a database connection
    using `EntityManagerFactory`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保只创建一个对象，我们创建一个私有的构造函数以防止客户端创建额外的实例。对象创建由`getInstance`方法处理，该方法检查实例属性是否为`null`。如果是`null`，则创建一个新的`RouterNetworkH2Adapter`并将其分配给`instance`变量。然后私有的构造函数使用`EntityManagerFactory`创建数据库连接。
- en: When executing `getInstance` for a second time, instead of creating a new `RouterNetworkH2Adapter`,
    we return the existing instance created previously.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二次执行`getInstance`方法时，我们不是创建一个新的`RouterNetworkH2Adapter`实例，而是返回之前创建的现有实例。
- en: Builder
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器
- en: Builder is a design pattern that helps us expressively create complex objects.
    It’s intended for scenarios with constructors with many parameters and different
    ways to make the same object. We have used that design pattern to create `CoreRouter`
    and `EdgeRouter` objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器是一种设计模式，它帮助我们以表达性的方式创建复杂的对象。它适用于具有许多参数和不同方式创建相同对象的场景。我们已使用该设计模式创建了`CoreRouter`和`EdgeRouter`对象。
- en: 'Consider the following example, where we create an instance of `CoreRouter`
    using its constructor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中我们使用其构造函数创建`CoreRouter`的一个实例：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One of the drawbacks of using the constructor directly is that we need to know
    how to pass the parameters in the correct order. In the previous example, we must
    pass first `id`, then `parentRouterId`, and so on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用构造函数的一个缺点是我们需要知道如何以正确的顺序传递参数。在先前的示例中，我们必须首先传递`id`，然后是`parentRouterId`，依此类推。
- en: 'Now, let’s see the object creation using builder:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用构建器进行对象创建：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other than skipping some parameters such as `parentRouterId`, we pass the parameters
    in any order through builder methods such as `vendor` or `model`. Once we are
    done, we call the `build` method to return the `CoreRouter` instance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跳过一些参数，如`parentRouterId`之外，我们通过`vendor`或`model`等构建器方法以任何顺序传递参数。一旦完成，我们调用`build`方法来返回`CoreRouter`实例。
- en: 'Throughout the book, we have not provided a custom builder implementation.
    Instead, we relied on the helpful Lombok libraries to create builders by simply
    adding the `Builder` annotation to the class’s constructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们没有提供自定义构建器的实现。相反，我们依靠有用的Lombok库，通过简单地在类的构造函数上添加`Builder`注解来创建构建器：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lombok is probably enough for you if you don’t have special requirements for
    how your objects should be created. Otherwise, you can implement your own builder
    mechanism. That is usually done when you want to define mandatory or optional
    parameters and other rules for object creation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有对你对象创建的特殊要求，Lombok可能就足够了。否则，你可以实现自己的构建器机制。这通常发生在你想要定义对象创建的强制或可选参数以及其他规则时。
- en: Abstract factory
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: 'We discussed in the previous section how applying the LSP enables us to pass
    a `CoreRouter` or `EdgeRouter` object to a method expecting a `Router` type, and
    then we can use that object without any issues. The abstract factory pattern comes
    into play whenever we need to create `CoreRouter` or `EdgeRouter` objects. We
    did so when we implemented the `RouterFactory` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何应用LSP使我们能够传递一个`CoreRouter`或`EdgeRouter`对象给期望`Router`类型的函数，然后我们可以使用该对象而没有任何问题。当我们实现`RouterFactory`类时，抽象工厂模式就派上用场了：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `RouterFactory` class contains only the `getRouter` method, which receives
    some parameters required to create code and edge routers and returns an object
    of type `Router`. Note that we pass a `RouterType` parameter used in the `switch`
    statement to identify which kind of router needs to be created, either `CoreRouter`
    or `EdgeRouter`. Regardless of the specific router subtype, we always return it
    as the `Router` supertype for use, for example, in scenarios where the LSP can
    be applied.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterFactory`类只包含`getRouter`方法，该方法接收创建代码和边缘路由器所需的参数，并返回一个类型为`Router`的对象。请注意，我们传递了一个用于`switch`语句的`RouterType`参数，用于识别需要创建哪种类型的路由器，即`CoreRouter`或`EdgeRouter`。无论具体的路由器子类型如何，我们总是将其作为`Router`超类型返回以供使用，例如，在可以应用LSP的场景中。'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter allowed us to explore how SOLID principles can be employed together
    with hexagonal architecture. We also reviewed our design patterns while implementing
    the topology and inventory system. We started by briefly discussing SOLID principles.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让我们探索了如何将SOLID原则与六边形架构一起使用。我们在实现拓扑和库存系统时也回顾了我们的设计模式。我们首先简要地讨论了SOLID原则。
- en: After getting a basic understanding of the principles, we moved on to see how
    they can be applied in the context of a hexagonal application. We then implemented
    the change router location feature to the topology and inventory system. Finally,
    we reviewed how design patterns such as builder, singleton, and abstract factory
    are employed while designing the hexagonal system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在对原则有了基本了解之后，我们继续探讨它们如何在六边形应用程序的上下文中应用。然后，我们将更改路由位置功能实现到拓扑和库存系统中。最后，我们回顾了在设计六边形系统时如何使用如建造者、单例和抽象工厂等设计模式。
- en: The next and final chapter will explore further design practices to help us
    build better software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章和最后一章将进一步探讨设计实践，以帮助我们构建更好的软件。
- en: Questions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does OCP stand for, and what is its purpose?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OCP代表什么，它的目的是什么？
- en: What is the goal of the DIP?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DIP的目标是什么？
- en: Which design pattern can support the LSP?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种设计模式可以支持LSP？
- en: Answers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: It stands for the **Open-Closed Principle**. Its purpose is to ensure a software
    component or module is closed for modification but open for extension.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它代表的是**开放封闭原则**。其目的是确保软件组件或模块对修改是封闭的，但对扩展是开放的。
- en: The DIP prescribes that clients should always depend on abstractions rather
    than concretions. By doing that, we protect clients from changes in the concretions
    that may require changes in the client code.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DIP规定客户端应始终依赖于抽象而不是具体实现。通过这样做，我们保护客户端免受具体实现变化的影响，这些变化可能需要修改客户端代码。
- en: The abstract factory pattern provides objects based on their supertype, which
    can be used in LSP, where supertypes are replaced with subtypes while retaining
    the object’s behavior consistency.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象工厂模式根据其超类型提供对象，这可以在LSP中使用，其中超类型被子类型替换，同时保持对象行为的一致性。
