- en: Chapter 8. More About Search – Search Trees and Hash Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 更多关于搜索 – 搜索树和哈希表
- en: In the previous chapters, we had a look at both binary search and trees. In
    this chapter, we will see how they are related and how this helps us create some
    more flexible, searchable data structures. We will also look at a different kind
    of searchable structure called a hash table. The reason for using these structures
    is that they allow mutation and still remain searchable. Basically, we need to
    be able to insert and delete elements from the data structures with ease while
    still being able to conduct a search efficiently. These structures are relatively
    complicated, so we need to take a step-by-step approach toward understanding it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了二分查找和树。在本章中，我们将了解它们之间的关系以及这种关系如何帮助我们创建更灵活、可搜索的数据结构。我们还将探讨一种称为哈希表的不同类型的可搜索结构。使用这些结构的原因是它们允许数据结构发生变异，同时仍然可搜索。基本上，我们需要能够轻松地从数据结构中插入和删除元素，同时仍然能够高效地进行搜索。这些结构相对复杂，因此我们需要逐步理解它们。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Binary search trees
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: Balanced binary search trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡二叉搜索树
- en: Hash tables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Binary search tree
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'You already know what binary search is. Let''s go back to the sorted array
    from an earlier chapter and study it again. If you think about binary search,
    you know you need to start from the middle of the sorted array. Depending on the
    value to be searched, either we return if the middle element is the search item,
    or move to the left or right based on whether the search value is greater than
    or less than the middle value. After this, we continue the same process recursively.
    This means the landing points in each step are quite fixed; they are the middle
    values. We can draw all the search paths as in the next figure. In each step,
    the arrows connect to the mid points of both the right half and left half, considering
    the current position. In the bottom part, we disassemble the array and spread
    out the elements while keeping the sources and targets of the arrows similar.
    As one can see, this gives us a binary tree. Since each edge in this tree moves
    from the midpoint of one step to the midpoint of the next step in the binary search,
    the same search can be performed in the tree by simply following its edges. This
    tree is quite appropriately called a binary search tree. Each level of this tree
    represents a step in binary search:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道什么是二分查找。让我们回到之前章节中的排序数组，再次研究它。如果你考虑二分查找，你知道你需要从排序数组的中间开始。根据要搜索的值，要么如果中间元素是搜索项，就返回，要么根据搜索值是大于还是小于中间值，向左或向右移动。之后，我们继续以相同的方式进行递归。这意味着每一步的着陆点相当固定；它们是中间值。我们可以像在下一张图中那样绘制所有搜索路径。在每一步中，箭头连接到右半部和左半部的中间点，考虑到当前位置。在底部部分，我们分解数组并展开元素，同时保持箭头的源和目标相似。正如人们可以看到的，这给了我们一个二叉树。由于这个树中的每条边都是从二分查找中一步的中间点到下一步的中间点的移动，因此可以通过简单地跟随其边缘在树中执行相同的搜索。这个树非常恰当地被称为二叉搜索树。这个树的每一层代表二分查找中的一步：
- en: '![Binary search tree](img/00046.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![二叉搜索树](img/00046.jpeg)'
- en: Binary search tree
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'Say we want to search for item number **23**. We start from the original midpoint,
    which is the root of the tree. The root has the value **50**. **23** is less than
    **50**, so we must check the left-hand side; in the case of our tree, follow the
    left edge. We arrive at the value **17**. **23** is greater than **17**, so we
    must follow the right edge and arrive at the value **23**. We just found the element
    we have been searching for. This algorithm can be summarized as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要搜索编号为**23**的项目。我们从树的原始中点开始，即树的根。根的值是**50**。**23**小于**50**，所以我们必须检查左侧；在我们的树中，跟随左侧边缘。我们到达值**17**。**23**大于**17**，所以我们必须跟随右侧边缘，到达值**23**。我们刚刚找到了我们一直在寻找的元素。这个算法可以总结如下：
- en: Start at the root.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根开始。
- en: If the current element is equal to the search element, we are done.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前元素等于搜索元素，我们就完成了。
- en: If the search element is less than the current element, we follow the left edge
    and start again from 2.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索元素小于当前元素，我们跟随左侧边缘并从2开始再次进行。
- en: If the search element is greater than the current element, we follow the right
    edge and start again from 2.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索元素大于当前元素，我们跟随右侧边缘并从2开始再次进行。
- en: 'To code this algorithm, we must first create a binary search tree. Create a
    `BinarySearchTree` class extending the `BinaryTree` class and then put your algorithm
    inside it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写此算法，我们首先必须创建一个二叉搜索树。创建一个扩展`BinaryTree`类的`BinarySearchTree`类，然后将你的算法放入其中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now wrap the method so that you don''t need to pass the root. This method also
    checks whether the tree is an empty tree and fails the search if that is the case:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将方法封装起来，这样你就不需要传递根节点。此方法还检查树是否为空树，如果是，则搜索失败：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So what exactly is the point of modifying an array in a binary tree? After all,
    are we not doing the same exact search still? Well, the point is that when we
    have this in a tree form, we can easily insert new values in the tree or delete
    some values. In the case of an array, insertion and deletion have linear time
    complexity and cannot go beyond the preallocated array size.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，修改二叉树中的数组究竟有什么意义呢？毕竟，我们不是还在做完全相同的搜索吗？嗯，关键是当我们以树的形式拥有它时，我们可以轻松地在树中插入新值或删除一些值。在数组的情况下，插入和删除的时间复杂度是线性的，并且不能超过预分配的数组大小。
- en: Insertion in a binary search tree
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在二叉搜索树中插入
- en: 'Insertion in a binary search tree is done by first searching for the value
    to be inserted. This either finds the element or ends the search unsuccessfully,
    where the new value is supposed to be if it were in that position. Once we reach
    this position, we can simply add the element to the tree. In the following code,
    we rewrite the search again because we need access to the parent node once we
    find the empty spot to insert our element:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树中插入是通过首先搜索要插入的值来完成的。这要么找到元素，要么在新的值应该所在的位置上搜索失败。一旦我们到达这个位置，我们就可以简单地在该位置添加元素。在下面的代码中，我们再次重写搜索，因为我们找到空位插入元素后需要访问父节点：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can wrap this up into a method that does not need a starting node. It also
    makes sure that when we insert into an empty tree, we just add a root:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方法封装起来，使其不需要起始节点。这也确保了当我们向空树插入时，我们只需添加一个根节点：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Suppose in our earlier tree, we want to insert the value **21**. The following
    figure shows the search path using arrows and how the new value is inserted:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们之前的树中，我们想要插入值**21**。以下图显示了使用箭头的搜索路径以及新值是如何插入的：
- en: '![Insertion in a binary search tree](img/00047.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![在二叉搜索树中插入](img/00047.jpeg)'
- en: Insertion of a new value into a binary tree
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树中插入新值
- en: 'Now that we have the means to insert elements in the tree, we can build the
    tree simply by a successive insertion. The following code creates a random tree
    with 20 elements and then does an in-order traversal of it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了在树中插入元素的手段，我们可以通过连续插入来简单地构建树。以下代码创建了一个包含20个元素的随机树，然后对其进行中序遍历：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run the preceding code, you will always find that the elements are sorted.
    Why is this the case? We will see this in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你总会发现元素是排序的。为什么是这样呢？我们将在下一节中看到这一点。
- en: What to do if the element inserted is the same as the element already present
    in the search tree? It depends on that particular application. Generally, since
    we search by value, we don't want duplicate copies of the same value. For simplicity,
    we will not insert a value if it is already there.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入的元素与搜索树中已存在的元素相同，应该怎么办？这取决于特定的应用。通常，由于我们是按值搜索，我们不希望有相同值的重复副本。为了简单起见，如果值已经存在，我们将不会插入该值。
- en: Invariant of a binary search tree
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树的不变量
- en: 'An invariant is a property that stays the same irrespective of the modifications
    made in the structure it is related to. An in-order traversal of a binary search
    tree will always result in the traversal of the elements in a sorted order. To
    understand why this happens, let''s consider another invariant of a binary tree:
    all descendants of the left child of a node have a value less than or equal to
    the value of the node, and all descendants of the right child of a node have a
    value greater than the value of the node. It is understandable why this is true
    if you think about how we formed the binary search tree using the binary search
    algorithm. This is why when we see an element bigger than our search value, we
    always move to the left child. This is because all the values that are descendants
    of the right child are bigger than the left child so there is no point investing
    time in checking them. We will use this to establish that an in-order traversal
    of a binary search tree will traverse elements in a sorted order of the values
    in the nodes.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是无论与其相关的结构如何修改，其属性都保持不变的性质。二叉搜索树的顺序遍历将始终以排序顺序遍历元素。为了理解为什么会这样，让我们考虑二叉树的另一个不变量：一个节点的左子树的所有后代都具有小于或等于该节点值的值，而一个节点的右子树的所有后代都具有大于该节点值的值。如果你考虑我们如何使用二分搜索算法形成二叉搜索树，这就可以理解为什么这是正确的。这就是为什么当我们看到比我们的搜索值大的元素时，我们总是移动到左子树。这是因为所有右子树的后代值都大于左子树，所以没有必要浪费时间检查它们。我们将利用这一点来证明二叉搜索树的顺序遍历将以节点值的排序顺序遍历元素。
- en: 'We will use induction to argue for this. Suppose we have a tree with only one
    node. In this case, any traversal could be easily sorted. Now let''s consider
    a tree with only three elements, as shown in the following figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用归纳法来论证这一点。假设我们有一个只有一个节点的树。在这种情况下，任何遍历都可以很容易地排序。现在让我们考虑一个只有三个元素的树，如图所示：
- en: '![Invariant of a binary search tree](img/00048.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![二叉搜索树的不变量](img/00048.jpeg)'
- en: A binary search tree with three nodes
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 具有三个节点的二叉搜索树
- en: An in-order traversal of this tree will first process the left child, then the
    parent, and finally, the right child. Since the search tree guarantees that the
    left child has a value that is less than or equal to the parent and the right
    child has a value greater than or equal to the value of the parent, the traversal
    is sorted.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对此树的顺序遍历将首先处理左子树，然后是父节点，最后是右子树。由于搜索树保证了左子树具有小于或等于父节点的值，而右子树具有大于或等于父节点值的值，因此遍历是排序的。
- en: 'Now let''s consider our general case. Suppose this invariant we discussed is
    true for trees with maximum *h-levels*. We will prove that, in such a case, it
    is also true for trees with maximum *h+1* levels. We will consider a general search
    tree, as shown in the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑我们的通用情况。假设我们讨论的这个不变量对于具有最大*h*层级的树是正确的。我们将证明，在这种情况下，对于具有最大*h+1*层级的树也是正确的。我们将考虑一个通用的搜索树，如图所示：
- en: '![Invariant of a binary search tree](img/00049.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![二叉搜索树的不变量](img/00049.jpeg)'
- en: A general binary search tree
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通用二叉搜索树
- en: The triangles represent subtrees with maximum *n* levels. We assume that the
    invariant holds true for subtrees. Now, an in-order traversal would first traverse
    the left subtree in sorted order, then the parent, and finally, the right subtree
    in the same order. The sorted order traversal of the subtrees is implied by the
    assumption that the invariant holds true for these subtrees. This will result
    in the order *[traversal of left descendants in sorted order][traversal of parents][traversal
    of right descendants in sorted order]*. Since the left descendants are all less
    than or equal to the parent and right descendants are all greater than or equal
    to the parent, the order mentioned is actually a sorted order. So a tree of the
    maximum level *h+1* can be drawn, as shown in the preceding figure, with each
    sub-tree having *n* levels maximum. If this the case and the invariant is true
    for all trees with level *h*, it must also be true for trees with level *h+1*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形代表具有最大 *n* 层的子树。我们假设对于子树，这个不变量是成立的。现在，中序遍历会首先以排序顺序遍历左子树，然后是父节点，最后是同样顺序的右子树。子树的排序顺序遍历是由假设这些子树的不变量成立所隐含的。这将导致顺序
    *[按排序顺序遍历左子代][遍历父节点][按排序顺序遍历右子代]*。由于左子代都小于或等于父节点，而右子代都大于或等于父节点，所以提到的顺序实际上是一个排序顺序。因此，可以绘制一个最大层
    *h+1* 的树，如图所示，每个子树的最大层为 *n*。如果这种情况成立，并且对于所有层 *h* 的树，这个不变量都是成立的，那么对于层 *h+1* 的树也必须成立。
- en: We already know that the invariant is true for trees with maximum level 1 and
    2\. However, it must be true for trees with maximum level 3 as well. This implies
    it must be true for trees with maximum level 4 and so on up to infinity. This
    proves that the invariant is true for all *h* and is universally true.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，对于最大层为 1 和 2 的树，这个不变量是成立的。然而，对于最大层为 3 的树也必须成立。这暗示它对于最大层为 4 的树也必须成立，以此类推，直到无穷大。这证明了对于所有
    *h*，这个不变量是成立的，并且是普遍成立的。
- en: Deletion of an element from a binary search tree
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从二叉搜索树中删除一个元素
- en: 'We are interested in all the modifications of a binary search tree where the
    resultant tree will remain a valid binary search tree. Other than insertion, we
    need to be able to carry out deletion as well. That is to say, we need to be able
    to remove an existing value from the tree:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对二叉搜索树的所有修改都感兴趣，其中结果树仍然是一个有效的二叉搜索树。除了插入之外，我们还需要能够执行删除操作。也就是说，我们需要能够从树中删除一个现有的值：
- en: '![Deletion of an element from a binary search tree](img/00050.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![从二叉搜索树中删除一个元素](img/00050.jpeg)'
- en: Three simple cases of deletion of nodes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 节点删除的三个简单情况
- en: 'The main concern is to know what to do with the children of the deleted node.
    We don''t want to lose those values from the tree, and we still want to make sure
    the tree remains a search tree. There are four different cases we need to consider.
    The relatively easier three cases are shown in the preceding figure. Here''s a
    brief description of these cases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 主要关注的是知道如何处理被删除节点的子节点。我们不希望从树中丢失这些值，同时我们还想确保树仍然是一个搜索树。我们需要考虑四种不同的情况。相对容易的三个情况已在前面图中展示。以下是这些情况的简要描述：
- en: The first case is where there is no child. This is the easiest case; we just
    delete the node.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是没有子节点的情况。这是最简单的情况；我们只需删除该节点。
- en: The second case is where there is only a right subtree. In this case, the subtree
    can take the place of the deleted node.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是只有一个右子树的情况。在这种情况下，子树可以取代被删除的节点。
- en: The third case is very similar to the second case, except it is about the left
    subtree.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况与第二种情况非常相似，只是它关于左子树。
- en: The fourth case is, of course, when both the children are present for the node
    to be deleted. In this case, none of the children can take the place of the node
    that is to be deleted as the other one would also need to be attached somewhere.
    We resolve this by replacing the node that needs to be deleted by another node
    that can be a valid parent of both the children. This node is the least node of
    the right subtree. Why is this the case? It is because if we delete this node
    from the right subtree, the remaining nodes of the right subtree would be greater
    than or equal to this node. And this node is also, of course, greater than all
    the nodes of the left subtree. This makes this node a valid parent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种情况当然是当要删除的节点有两个子节点时。在这种情况下，没有一个子节点可以取代要删除的节点，因为另一个子节点也需要被附加到某个地方。我们通过用另一个节点替换需要删除的节点来解决这个问题，这个节点可以是两个子节点的有效父节点。这个节点是右子树的最小节点。为什么是这样呢？这是因为如果我们从这个右子树中删除这个节点，右子树的剩余节点将大于或等于这个节点。当然，这个节点也大于左子树中的所有节点。这使得这个节点成为一个有效的父节点。
- en: 'The next question is this: what is the least node in the right subtree? Remember
    that when we move to the left child of a node, we always get a value that is less
    than or equal to the current node. Hence, we must keep traversing left until we
    find no more left child. If we do this, we will reach the least node eventually.
    The least node of any subtree cannot have any left child, so it can be deleted
    using the first case or the second case of deletion. The delete operation of the
    fourth case is thus used to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要问的问题是：右子树中的最小节点是什么？记住，当我们移动到一个节点的左子节点时，我们总是得到一个小于或等于当前节点的值。因此，我们必须继续向左遍历，直到没有更多的左子节点。如果我们这样做，我们最终会到达最小节点。任何子树的最小节点不能有任何左子节点，因此可以使用删除的第一个或第二个情况来删除它。因此，第四种情况的删除操作用于：
- en: Copy the value of the least node in the right subtree to the node to be deleted
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将右子树中最小节点的值复制到要删除的节点
- en: Delete the least node in the right subtree
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除右子树中的最小节点
- en: 'To write the deletion code, we need to first add a few methods to our `BinaryTree`
    class, which is meant for deleting nodes and rewriting node values. The method
    `deleteNodeWithSubtree` simply deletes a node along with all its descendants.
    It simply forgets about all the descendants. It also has certain checks to confirm
    the validity of the input. Deletion of a root, as usual, must be handled separately:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写删除代码，我们首先需要向我们的 `BinaryTree` 类添加几个方法，这个类是用来删除节点和重写节点值的。`deleteNodeWithSubtree`
    方法简单地删除一个节点及其所有后代。它简单地忘记了所有后代。它也有一定的检查来确认输入的有效性。通常，根的删除必须单独处理：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we add another method to the `BinaryTree` class for rewriting the value
    in a node. We don''t allow this class to use public methods in the `node` class
    to maintain encapsulation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们向 `BinaryTree` 类添加另一个方法来重写节点中的值。我们不允许这个类使用 `node` 类的公共方法来保持封装：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code is self-explanatory. Finally, we write a method to replace
    a node''s child with another node from the same tree. This is useful for cases
    2 and 3:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是自我解释的。最后，我们编写一个方法来用一个来自同一棵树的另一个节点替换节点的子节点。这在情况 2 和 3 中很有用：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we add a method to `BinarySearchTree` to find the least node in the
    subtree. We walk keeping to the left until there is no more child on the left-hand
    side:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `BinarySearchTree` 中添加一个方法来找到子树中的最小节点。我们继续向左走，直到没有更多的左子节点：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can implement our deletion algorithm. First, we create a `deleteNode`
    method that deletes a node. We can then use this method to delete a value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现我们的删除算法。首先，我们创建一个 `deleteNode` 方法来删除一个节点。然后我们可以使用这个方法来删除一个值：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Case 1**: There are no children. In this case, we can simply delete the node:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况 1**：没有子节点。在这种情况下，我们可以简单地删除节点：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Case 2**: There is only a right child. The right child can take the place
    of the deleted node:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况 2**：只有一个右子节点。右子节点可以取代被删除的节点：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Case 3**: There is only a left child. The left child can take the place of
    the deleted node:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况 3**：只有一个左子节点。左子节点可以取代被删除的节点：'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Case 4**: Both left child and right child are present. In this case, first
    we copy the value of the leftmost child in the right subtree (or the successor)
    to the node that needs to be deleted. Once we do this, we delete the leftmost
    child in the right subtree:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况 4**：左子节点和右子节点都存在。在这种情况下，首先我们将右子树中最左边的子节点的值（或后继）复制到要删除的节点。一旦这样做，我们就删除右子树中最左边的子节点：'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The process of deleting a node turned out to be a little more complicated, but
    it is not difficult. In the next section, we will discuss the complexity of the
    operations of a binary search tree.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个节点的过程证明要复杂一些，但并不困难。在下一节中，我们将讨论二叉搜索树操作的复杂度。
- en: Complexity of the binary search tree operations
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树操作的复杂度
- en: The first operation we will consider is the search operation. It starts at the
    root and moves down one level every time we move from one node to either of its
    children. The maximum number of edges we have to traverse during the search operation
    must be equivalent to the maximum height of the tree—that is, the maximum distance
    between any node and root. If the height of the tree is *h*, then the complexity
    of search is *O(h)*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑的操作是搜索操作。它从根开始，每次从一个节点移动到其子节点之一时，就向下移动一个级别。在搜索操作期间必须遍历的最大边数必须等同于树的最大高度——即任何节点与根之间的最大距离。如果树的高度是
    *h*，那么搜索的复杂度是 *O(h)*。
- en: Now what is the relation between the number of nodes *n* of a tree and the height
    *h* of a tree? It really depends on how the tree is built. Any level would require
    at least one node in it, so in the worst case scenario, *h = n* and the search
    complexity is *O(n)*. What is our best case? Or rather, what do we want *h* to
    be in relation to *n*? In other words, what is the minimum *h*, given a particular
    *n*. To answer this, we first ask, what is the maximum *n* we can fit in a tree
    with height *h*?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在树中节点数 *n* 和树的高度 *h* 之间有什么关系？这实际上取决于树是如何构建的。任何级别至少需要有一个节点，所以在最坏的情况下，*h = n*，搜索复杂度为
    *O(n)*。我们的最佳情况是什么？或者更确切地说，我们希望 *h* 与 *n* 之间保持什么关系？换句话说，给定一个特定的 *n*，最小 *h* 是多少。为了回答这个问题，我们首先问，在高度
    *h* 的树中我们可以容纳的最大 *n* 是多少？
- en: 'The root is just a single element. The children of the root make a complete
    level adding two more nodes for a tree of height 2\. In the next level, we will
    have two children for any node in this level. So the next level or level three
    has a total of *2X2=4* nodes. It can be easily seen that the level *h* of the
    tree has a total of *2^((h-1))* nodes. The total number of nodes that a tree of
    height *h* can then have is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根只是一个单一元素。根的子节点构成一个完整的级别，为高度为 2 的树添加两个节点。在下一级，我们将为这一级中的任何节点有两个子节点。所以下一级或第三级总共有
    *2X2=4* 个节点。可以很容易地看出，树的级别 *h* 总共有 *2^((h-1))* 个节点。高度为 *h* 的树可以拥有的节点总数如下：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is our ideal case where the complexity of the search is *O(lg n)*. This
    kind of a tree where all the levels are full is called a balanced binary tree.
    Our aim is to maintain the balanced nature of the tree even when insertion or
    deletion is carried out. However, in general, the tree would not remain balanced
    in the case of an arbitrary order of insertion of elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的理想情况，其中搜索的复杂度是 *O(lg n)*。所有级别都满的二叉树称为平衡二叉树。我们的目标是即使在插入或删除操作时也要保持树的平衡性质。然而，在一般情况下，如果元素插入的顺序是任意的，树就不会保持平衡。
- en: Insertion simply requires searching the element; once this is done, adding a
    new node is just a constant time operation. Therefore, it has the same complexity
    as that of a search. Deletion actually requires a maximum of two searches (in
    the fourth case), so it also has the same complexity as that of a search.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 插入只需要搜索元素；一旦完成，添加一个新节点就是一个常数时间操作。因此，它的复杂度与搜索相同。删除实际上最多需要两次搜索（在第四种情况下），因此它的复杂度也与搜索相同。
- en: Self-balancing binary search tree
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自平衡二叉搜索树
- en: 'A binary search tree that remains balanced to some extent when insertion and
    deletion is carried out is called a self-balancing binary search tree. To create
    a balanced version of an unbalanced tree, we use a peculiar operation called **rotation**.
    We will discuss rotation in the following section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行插入和删除操作时，在一定程度上保持平衡的二叉搜索树被称为自平衡二叉搜索树。为了创建一个平衡的不平衡树的版本，我们使用一种称为**旋转**的特殊操作。我们将在下一节中讨论旋转：
- en: '![Self-balancing binary search tree](img/00051.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![自平衡二叉搜索树](img/00051.jpeg)'
- en: Rotation of a binary search tree
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的旋转
- en: This figure shows the rotation operation on nodes **A** and **B**. Left rotation
    on **A** creates the right image, and right rotation on **B** creates the left
    image. To visualize a rotation, first think about pulling out the subtree **D**.
    This subtree is somewhere in the middle. Now the nodes are rotated in either the
    left or right direction. In the case of the left rotation, the right child becomes
    the parent and the parent becomes the left child of the original child. Once this
    rotation is done, the **D** subtree is added to the right child's position of
    the original parent. The right rotation is exactly the same but in the opposite
    direction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了节点 **A** 和 **B** 上的旋转操作。对 **A** 进行左旋转会生成右侧的图像，而对 **B** 进行右旋转会生成左侧的图像。为了可视化旋转，首先考虑将子树
    **D** 拔出。这个子树位于中间某个位置。现在节点向左或向右旋转。在左旋转的情况下，右子节点变为父节点，而父节点变为原始子节点的左子节点。一旦完成这个旋转，**D**
    子树就被添加到原始父节点的右子节点位置。右旋转与左旋转完全相同，但方向相反。
- en: How does it help balance a tree? Notice the left-hand side of the diagram. You'll
    realize that the right side looks heavier, however, once you perform left rotation,
    the left-hand side will appear heavier. Actually, a left rotation decreases the
    depth of the right subtree by one and increases that of the left subtree by one.
    Even if, originally, the right-hand side had a depth of 2 when compared to the
    left-hand side, you could fix it using left rotation. The only exception is the
    subtree **D** since the root of **D** remains at the same level; its maximum depth
    does not change. A similar argument will hold true for the right rotation as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何帮助平衡一棵树？注意图中的左侧。你会意识到右侧看起来更重，然而，一旦你执行左旋转，左侧看起来会更重。实际上，左旋转将右子树的深度减少一个，并将左子树的深度增加一个。即使最初，与左侧相比，右侧的深度为2，你也可以通过左旋转来修复它。唯一的例外是子树
    **D**，因为 **D** 的根保持在同一级别；其最大深度没有变化。对于右旋转，类似的论点同样成立。
- en: 'Rotation keeps the search-tree property of the tree unchanged. This is very
    important if we are going to use it to balance search trees. Let''s consider the
    left rotation. From the positions, we can conclude the following inequalities:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转保持树的搜索树属性不变。如果我们打算用它来平衡搜索树，这一点非常重要。让我们考虑左旋转。从位置上，我们可以得出以下不等式：
- en: Each node in **C** ≤ **A**
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C** 中的每个节点 ≤ **A**'
- en: A ≤ B
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A ≤ B
- en: '**A** ≤ Each node in **D** ≤ **B**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** ≤ **D** 中的每个节点 ≤ **B**'
- en: '**B** ≤ Each node in **E**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B** ≤ **E** 中的每个节点'
- en: 'After we perform the rotation, we check the inequalities the same way and we
    find they are exactly the same. This proves the fact that rotation keeps the search-tree
    property unchanged. A very similar argument can be made for the right rotation
    as well. The idea of the algorithm of a rotation is simple: first take the middle
    subtree out, do the rotation, and reattach the middle subtree. The following is
    the implementation in our `BinaryTree` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行旋转后，我们以相同的方式检查不等式，发现它们完全相同。这证明了旋转保持搜索树属性不变的事实。旋转算法的想法很简单：首先取出中间子树，进行旋转，然后重新连接中间子树。以下是在我们的
    `BinaryTree` 类中的实现：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, let''s do some parameter value checks:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们做一些参数值检查：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The child and grandchild we want to move depend on the direction of the rotation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要移动的子节点和孙节点取决于旋转的方向：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The root node needs to be treated differently as usual:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点需要像往常一样进行特殊处理：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now can look at our first self-balancing binary tree called the AVL tree.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们的第一个自平衡二叉树，称为AVL树。
- en: AVL tree
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AVL树
- en: 'AVL tree is our first self-binary search tree. The idea is simple: keep every
    subtree as balanced as possible. An ideal scenario would be for both the left
    and right subtrees, starting from every node, to have exactly the same height.
    However, since the number of nodes are not in the form of *2^p* *-1*, where *p*
    is a positive integer, we cannot always achieve this. Instead, we allow a little
    bit of wiggle room. It''s important that the difference between the height of
    the left subtree and the right subtree must not be greater than one. If, during
    any insert or delete operation, we happen to break this condition, we will apply
    rotations to fix this. We only have to worry about a difference of two between
    the heights as we are only thinking of insertion and deletion of one element at
    a time, and inserting one element or deleting it cannot change the height by more
    than one. Therefore, our worst case is that there was already a difference of
    one and the new addition or deletion created one more difference requiring a rotation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是我们第一个自平衡二叉搜索树。想法很简单：尽可能保持每个子树平衡。理想的情况是，从每个节点开始，左右子树的高度完全相同。然而，由于节点数量不是*2^p*
    *-1*的形式，其中*p*是正整数，我们无法总是实现这一点。相反，我们允许有一点灵活性。重要的是，左子树和右子树的高度差不能超过一。如果在任何插入或删除操作中意外破坏了这个条件，我们将应用旋转来修复它。我们只需要担心高度差为两个，因为我们一次只考虑一个元素的插入和删除，插入一个元素或删除它不能使高度变化超过一个。因此，我们的最坏情况是已经有一个差异，新的添加或删除又产生了一个差异，需要旋转来修复。
- en: 'The simplest kind of rotation is shown in the following figure. The triangles
    represent subtrees of equal heights. Notice that the height of the left subtree
    is two less than the height of the right subtree:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的旋转类型在以下图中展示。三角形代表等高的子树。请注意，左子树的高度比右子树的高度少两个：
- en: '![AVL tree](img/00052.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![AVL树](img/00052.jpeg)'
- en: AVL tree – simple rotation
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树 – 简单旋转
- en: So we do a left rotation to generate the subtree of the structure, as shown
    in the preceding diagram. You can see that the heights of the subtrees follow
    our condition. The simple right rotation case is exactly the same, just in the
    opposite direction. We must do this for all the ancestors of the node that were
    either inserted or deleted as the heights of subtrees rooted by these nodes were
    the only ones affected by it. Since rotations also cause heights to change, we
    must start from the bottom and walk our way up to the root while doing rotations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们进行左旋转以生成结构子树，如图所示。您可以看到子树的高度符合我们的条件。简单的右旋转情况完全相同，只是方向相反。我们必须对所有节点的前辈进行此操作，这些节点要么被插入，要么被删除，因为只有这些节点的子树高度受到影响。由于旋转也会导致高度变化，我们必须从底部开始，在旋转的同时向上走到根节点。
- en: 'There is one more kind of case called a double rotation. Notice that the height
    of the subtree rooted by the middle grandchild does not change due to the rotation.
    So, if this is the reason for the imbalance, a simple rotation will not fix it.
    It is shown in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为双重旋转的情况。请注意，由于旋转，中间孙子的根的子树的高度没有改变。因此，如果这是不平衡的原因，简单的旋转无法解决这个问题。这也在以下图中展示：
- en: '![AVL tree](img/00053.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![AVL树](img/00053.jpeg)'
- en: Simple rotation does not fix this kind of imbalance
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单旋转无法修复这种不平衡
- en: Here, the subtree that received an insertion is rooted by **D** or a node is
    deleted from the subtree **C**. In the case of an insertion, notice that there
    would be no rotation on **B** as the left subtree of **B** has a height of only
    one more than that of its right subtree. **A** is however unbalanced. The height
    of the left subtree of **A** is two less than that of its right subtree. However,
    if we do a rotation on **A**, as shown in the preceding figure, it does not fix
    the problem; only the left-heavy condition is transformed into a right-heavy condition.
    To resolve this, we need a double rotation, as shown in the next figure. First,
    we do an opposite direction rotation of the middle grandchild so that it is not
    unbalanced in the opposite direction. A simple rotation after this will fix the
    imbalance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，接收插入的子树以**D**为根，或者从子树**C**中删除了一个节点。在插入的情况下，请注意，由于**B**的左子树的高度只比其右子树高一个，所以**B**上不会进行旋转。然而，**A**是不平衡的。**A**的左子树的高度比其右子树低两个。但是，如果我们对**A**进行旋转，如前图所示，这并不能解决问题；只是将左重条件转换成了右重条件。为了解决这个问题，我们需要进行双重旋转，如下一图所示。首先，我们对中间的孙子节点进行相反方向的旋转，使其在相反方向上不会失衡。之后的简单旋转将修复不平衡。
- en: '![AVL tree](img/00054.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![AVL树](img/00054.jpeg)'
- en: AVL tree double rotation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树双重旋转
- en: 'So we create an AVL tree class, and we add an extra field to the `Node` class
    to store the height of the subtree rooted by it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个AVL树类，并在`Node`类中添加了一个额外的字段来存储其根的子树的高度：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We must override the `newNode` method to return our extended node:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写`newNode`方法以返回我们的扩展节点：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use a utility method to retrieve the height of a subtree with a null check.
    The height of a null subtree is zero:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个实用方法来检索子树的高度，并进行空检查。空子树的高度为零：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we include a method to compute and update the height of the subtree
    rooted by a node. The height is one more than that of the maximum height of its
    children:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包括一个方法来计算和更新节点根的子树的高度。高度是其孩子最大高度加一：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also override the `rotate` method in `BinaryTree` to update the height of
    the subtrees after the rotation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`BinaryTree`中重写了`rotate`方法，以便在旋转后更新子树的高度：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the help of these methods, we implement the rebalancing of a node all
    the way up to the root, as described in the preceding code. The rebalancing bit
    is done by checking the difference in the height of the left and right subtrees.
    If the difference is 0, 1, or -1, nothing needs to be done. We simply move up
    the tree recursively. When the height difference is 2 or -2, this is when we need
    to rebalance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方法，我们实现了从节点到根节点的整个平衡过程，如前述代码所示。平衡位是通过检查左右子树高度差来完成的。如果差值为0、1或-1，则不需要做任何事情。我们只需递归地向上移动树。当高度差为2或-2时，这就是我们需要进行平衡的时候：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the rotation is implemented, implementing the insert and delete operations
    is very simple. We first do a regular insertion or deletion, followed by rebalancing.
    A simple insertion operation is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦旋转实现，实现插入和删除操作就非常简单。我们首先进行常规的插入或删除，然后进行平衡。一个简单的插入操作如下：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The delete operation is also very similar. It only requires an additional check
    confirming that the node is actually found and deleted:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作也非常相似。它只需要一个额外的检查来确认节点确实被找到并删除：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Complexity of search, insert, and delete in an AVL tree
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AVL树中搜索、插入和删除的复杂度
- en: 'The worst case of an AVL tree is when it has maximum imbalance. In other words,
    the tree is worst when it reaches its maximum height for a given number of nodes.
    To find out how much that is, we need to ask the question differently, given a
    height h: what is the minimum number of nodes (n) that can achieve this? Let the
    minimum number of nodes required to achieve this be *f(h)*. A tree of height *h*
    will have two subtrees, and without any loss of generality, we can assume that
    the left subtree is higher than the right subtree. We would like both these subtrees
    to also have a minimum number of nodes. So the height of the left subtree would
    be *f(h-1)*. We want the height of the right subtree to be minimum, as this would
    not affect the height of the entire tree. However, in an AVL tree, the difference
    between the heights of two subtrees at the same level can differ by a maximum
    of one. The height of this subtree is *h-2*. So the number of nodes in the right
    subtree is *f(h-2)*. The entire tree must also have a root, hence the total number
    of nodes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树的最坏情况是它具有最大不平衡。换句话说，当给定节点数达到最大高度时，树是最差的。为了找出这是多少，我们需要以不同的方式提出问题，给定高度h：能够实现这一点的最小节点数（n）是多少？设实现这一点的最小节点数为*f(h)*。高度为*h*的树将有两个子树，并且不失一般性，我们可以假设左子树比右子树高。我们希望这两个子树也具有最小节点数。因此，左子树的高度将是*f(h-1)*。我们希望右子树的高度最小，因为这不会影响整个树的高度。然而，在AVL树中，同一级别的两个子树的高度差最大为1。这个子树的高度是*h-2*。因此，右子树的节点数是*f(h-2)*。整个树也必须有一个根节点，因此总节点数：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It almost looks like the formula of the Fibonacci sequence, except for the
    *+1* part. Our starting values are 1 and 2 because *f(1) = 1* (only the root)
    and *f(2) = 2* (just one child). This is greater than the starting values of the
    Fibonacci sequence, which are 1 and 1\. One thing is of course clear that the
    number of nodes would be greater than the corresponding Fibonacci number. So,
    the following is the case:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它几乎看起来像是斐波那契数列的公式，除了*+1*部分。我们的起始值是1和2，因为*f(1) = 1*（只有根节点）和*f(2) = 2*（只有一个孩子）。这大于斐波那契数列的起始值，斐波那契数列的起始值是1和1。当然，节点数将大于相应的斐波那契数。所以，以下就是情况：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We know that for a large enough *h*, *F* [h] *≈ φF* [h-1] holds true; here
    *φ* is the golden ratio *(1 + √5)/2*. This means *F* [h] *= C φ* ^h, where C is
    some constant. So, we have the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道对于足够大的*h*，*F*h* ≈ φ*F*h-1*成立；这里*φ*是黄金比例*(1 + √5)/2*。这意味着*F*h* = C φ*h，其中C是某个常数。所以，我们得到以下：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means even the worst height of an AVL tree is logarithmic, which is what
    we wanted. Since an insertion processes one node in each level until it reaches
    the insertion site, the complexity of an insertion is *O(lg n)*; it is the same
    for performing search and delete operations, and it holds true for the same reason.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使是AVL树的最坏高度也是对数级的，这正是我们想要的。由于插入过程在每个级别处理一个节点，直到达到插入位置，因此插入的复杂度是*O(lg n)*；执行搜索和删除操作也是一样，原因相同。
- en: Red-black tree
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'An AVL tree guarantees logarithmic insertion, deletion, and search. But it
    makes a lot of rotations. In most applications, insertions are randomly ordered
    and so are deletions. So, the trees would sort of balance out eventually. However,
    since the AVL tree is too quick to rotate, it may make very frequent rotations
    in opposite directions even when it would be unnecessary, had it been waiting
    for the future values to be inserted. This can be avoided using a different approach:
    knowing when to rotate a subtree. This approach is called a red-black tree.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树保证了对数级的插入、删除和搜索。但它会进行很多旋转。在大多数应用中，插入和删除都是随机排序的。因此，这些树最终会平衡。然而，由于AVL树旋转得太快，它可能会在不需要的情况下频繁地在相反方向上进行旋转。这可以通过不同的方法来避免：知道何时旋转子树。这种方法被称为红黑树。
- en: 'In a red-black tree, the nodes have a color, either black or red. The colors
    can be switched during the operations on the node, but they have to follow these
    conditions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在红黑树中，节点有一个颜色，要么是黑色，要么是红色。在节点操作期间可以切换颜色，但它们必须遵循以下条件：
- en: The root has to be black
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点必须是黑色的
- en: A red node cannot have a black child
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色节点不能有黑色子节点
- en: The black height of any subtree rooted by any node is equal to the black height
    of the subtree rooted by the sibling node
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以任何节点为根的子树的黑色高度等于以兄弟节点为根的子树的黑色高度
- en: 'Now what is the black height of a subtree? It is the number of black nodes
    found from the root to the leaf. When we say *leaf*, we really mean null children,
    which are considered black and allow a parent to be red without violating rule
    2\. This is the same no matter which path we take. This is because of the third
    condition. So the third condition can also be restated as this: the number of
    black nodes in the path from the root of any subtree to any of its leaves is the
    same, irrespective of which leave we choose.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在什么是子树的黑高？它是从根到叶子的黑色节点的数量。当我们说*叶*时，我们实际上是指空孩子，它们被认为是黑色的，并且允许父节点为红色而不违反规则2。这无论我们走哪条路径都是一样的。这是因为第三个条件。所以第三个条件也可以重新表述为：从任何子树的根到其任何叶子节点的路径上的黑色节点数量是相同的，无论我们选择哪个叶子。
- en: 'For ease of manipulation, the null children of the leaves are also considered
    sort of half nodes; null children are always considered black and are the only
    ones really considered as leaves as well. So leaves don''t contain any value.
    But they are different from the conventional leaves in other red-black trees.
    New nodes can be added to the leaves but not in a red-black tree; this is because
    the leaves here are null nodes. So we will not draw them out explicitly or put
    them in the code. They are only helpful to compute and match black heights:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于操作，叶子的空孩子也被视为某种半节点；空孩子总是被认为是黑色的，并且是唯一真正被视为叶子的节点。所以叶子不包含任何值。但它们与其他红黑树中的传统叶子不同。新节点可以添加到叶子，但不能添加到红黑树中；这是因为这里的叶子是空节点。因此，我们不会明确地绘制它们或把它们放入代码中。它们只对计算和匹配黑高有帮助：
- en: '![Red-black tree](img/00055.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![红黑树](img/00055.jpeg)'
- en: An example of a red-black tree
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树的例子
- en: In our example of the red-black tree of height 4, the null nodes are black,
    which are not shown (in print copy, the light-colored or gray nodes are red nodes
    and dark-colored nodes are black nodes).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们高度为4的红黑树例子中，空节点是黑色的，这些节点没有显示（在打印副本中，浅色或灰色节点是红色节点，深色节点是黑色节点）。
- en: Both insertion and deletion are more complicated than the AVL tree, as there
    are more cases that we need to handle. We will discuss this in the following sections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和删除都比AVL树复杂，因为我们需要处理更多的情况。我们将在以下章节中讨论这个问题。
- en: Insertion
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: 'Insertion is done in the same way we do it with BST. After an insertion is
    complete, the new node is colored red. This preserves the black height, but it
    can result in a red node being a child of another red node, which would violate
    condition 2\. So we do some manipulation to fix this. The following two figures
    show four cases of insertions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 插入是以我们处理BST（二叉搜索树）相同的方式进行。插入完成后，新节点被着色为红色。这保留了黑高，但它可能导致一个红色节点成为另一个红色节点的子节点，这将违反条件2。因此，我们需要进行一些操作来修复这个问题。以下两个图显示了四种插入情况：
- en: '![Insertion](img/00056.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![插入](img/00056.jpeg)'
- en: Case 1 and 2 of red-black tree insertion
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树插入的1和2情况
- en: '![Insertion](img/00057.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![插入](img/00057.jpeg)'
- en: Case 3 and 4 of red-black tree insertion
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树插入的3和4情况
- en: 'Let''s discuss the insertions case by case. Notice that the trees in the diagram
    look black and unbalanced. But this is only because we have not drawn the entire
    tree; it''s just a part of the tree we are interested in. The important point
    is that the black height of none of the nodes change because of whatever we do.
    If the black height must be increased to fit the new node, it must be at the top
    level; so we simply move it up to the parent. The four cases are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个讨论插入的情况。注意，图中的树看起来是黑色和不平衡的。但这仅仅是因为我们没有绘制整个树；这只是我们感兴趣的树的一部分。重要的是，无论我们做什么，任何节点的黑高都不会改变。如果必须增加黑高以适应新节点，它必须在顶层；所以我们只需将其移动到父节点。以下四种情况如下：
- en: The parent is black. In this case, nothing needs to be done as it does not violate
    any of the constraints.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父节点是黑色的。在这种情况下，不需要做任何事情，因为它没有违反任何约束。
- en: Both parent and uncle are red. In this case, we repaint parent, uncle, and grandparent
    and the black heights are still unchanged. Notice now that no constraints are
    violated. If, however, the grandparent is the root, keep it black. This way, the
    entire tree's black height is increased by 1.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父节点和叔叔节点都是红色的。在这种情况下，我们需要重新着色父节点、叔叔节点和祖父节点，并且黑高保持不变。注意现在没有违反任何约束。然而，如果祖父节点是根节点，则保持它为黑色。这样，整个树的黑高就增加了1。
- en: The parent is red and uncle is black. The newly added node is on the same side
    of the parent as the parent is of the grandparent. In this case, we make a rotation
    and repaint. We first repaint the parent and grandparent and then rotate the grandparent.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父节点是红色，叔叔节点是黑色。新添加的节点位于父节点与祖父节点相同的侧。在这种情况下，我们进行旋转并重新着色。我们首先重新着色父节点和祖父节点，然后旋转祖父节点。
- en: This is the case that is similar to case 3, except the newly added node is on
    the opposite side of the parent as the parent is of the grandparent. Case 3 cannot
    be applied here because doing so will change the black height of the newly added
    node. In this case, we rotate the parent to make it the same as case 3.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与情况3类似，但新添加的节点位于父节点与祖父节点相反的一侧。由于这样做会改变新添加节点的黑色高度，所以不能应用情况3。在这种情况下，我们旋转父节点，使其与情况3相同。
- en: Note that all the cases can happen in the opposite direction, that is, in mirror
    image. We will handle both the cases the same way.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，所有这些情况都可以以相反的方向发生，即镜像。我们将以相同的方式处理这两种情况。
- en: 'Let''s create our `RedBlackTree` class extending the `BinarySearchTree` class.
    We have to again extend the `Node` class and include a flag to know whether the
    node is black:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个扩展`BinarySearchTree`类的`RedBlackTree`类。我们必须再次扩展`Node`类，并包括一个标志以知道节点是否为黑色：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We now add a utility method that returns whether a node is black. As explained
    earlier, a null node is considered black:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加一个实用方法，该方法返回一个节点是否为黑色。如前所述，空节点被认为是黑色：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we''re ready to define the method of rebalancing after we do an insertion.
    This method works as described in the four cases earlier. We maintain a `nodeLeftGrandChild`
    flag that stores whether the parent is the left child of the grand parent or its
    right child. This helps us find the uncle and also rotate in the correct direction:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在插入后定义重新平衡的方法。这种方法与前面描述的四个情况相同。我们维护一个`nodeLeftGrandChild`标志，用于存储父节点是否是祖父节点的左子节点或其右子节点。这有助于我们找到叔叔节点，并在正确的方向上进行旋转：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The insertion is now done as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 插入现在是按照以下方式进行的：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Deletion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: 'Deletion starts with a normal binary search tree deletion. If you remember,
    this always involves deletion of a node with at most one child. Deletion of an
    internal node is done by first copying the value of the leftmost node of the right
    subtree and deleting it. So we will consider only this case:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作从正常的二叉搜索树删除操作开始。如果你还记得，这通常涉及删除最多只有一个子节点的节点。删除内部节点是通过首先复制右子树最左节点的值然后删除它来完成的。因此，我们只考虑这种情况：
- en: '![Deletion](img/00058.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![删除](img/00058.jpeg)'
- en: Case 1, 2, and 3 of deletion in a red-black tree
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树删除操作的1、2和3种情况
- en: After the deletion is done, the parent of the deleted node either has no child
    or has one child, which was originally its grandchild. During the insertion, the
    problem we needed to solve was a red child of a red parent. In a deletion process,
    this cannot happen. But it can cause the black height to change.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 删除完成后，被删除节点的父节点要么没有子节点，要么有一个子节点，这个子节点原本是其祖父节点。在插入过程中，我们需要解决的问题是一个红色父节点的红色子节点。在删除过程中，这种情况不会发生。但它可以导致黑色高度发生变化。
- en: One simple case is that if we delete a red node, the black height does not change
    anything, so we don't have to do anything. Another simple case is that if the
    deleted node were black and the child red, we can simply repaint the child black
    in order to restore the black height.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的情况是，如果我们删除一个红色节点，黑色高度不会发生变化，所以我们不需要做任何事情。另一个简单的情况是，如果被删除的节点是黑色且子节点是红色，我们可以简单地重新着色子节点为黑色，以恢复黑色高度。
- en: 'A black child cannot really happen because that would mean the original tree
    was black and unbalanced, as the deleted node had a single black child. But since
    recursion is involved, a black child can actually arise while moving up the path
    with recursive rebalancing. In the following discussion, we only look at cases
    where the deleted node was black and the child was also black (or null child,
    which is considered black). Deletion is done as per the following cases, as shown
    in the figures *Case 1 and 2 and 3 of deletion in a red-black tree* and *Case
    4, 5 and 6 of deletion from a red-black tree*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色子节点实际上是不可能发生的，因为这意味着原始树是黑色且不平衡的，因为被删除的节点有一个单独的黑色子节点。但由于递归的存在，在递归重新平衡的过程中向上移动路径时，实际上可以出现黑色子节点。在以下讨论中，我们只考虑被删除的节点是黑色且子节点也是黑色（或空子节点，被认为是黑色）的情况。删除操作按照以下情况执行，如图所示*红黑树删除操作的1、2和3种情况*和*从红黑树删除的4、5和6种情况*：
- en: The first case we have is when the parent, sibling, and both the nephews are
    black. In this case, we can simply repaint the sibling to red, which will make
    the parent black and balanced. However, the black height of the whole subtree
    will reduce by one; hence, we must continue rebalancing from the parent.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遇到的第一种情况是父节点、兄弟节点以及两个侄子节点都是黑色。在这种情况下，我们可以简单地重新绘制兄弟节点为红色，这将使父节点变为黑色并保持平衡。然而，整个子树的黑色高度将减少一个；因此，我们必须从父节点开始继续重新平衡。
- en: This is the case when the parent and sibling are black, but the away nephew
    is red. In this case, we cannot repaint the sibling as this would cause the red
    sibling to have a red child, violating constraint 2\. So we first repaint the
    red nephew to black and then rotate to fix the black height of the nephew while
    fixing the black height of the child.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是父节点和兄弟节点为黑色，但远侄子节点为红色的情况。在这种情况下，我们不能重新绘制兄弟节点，因为这会使红色兄弟节点有一个红色子节点，违反了约束2。因此，我们首先将红色侄子节点重新着色为黑色，然后旋转以修复侄子节点的黑色高度，同时修复子节点的黑色高度。
- en: When the near nephew is red instead of the away nephew, the rotation does not
    restore the black height of the near nephew that has been repainted. So, we repaint
    NN but do a double rotation instead.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当近侄子节点为红色而不是远侄子节点时，旋转不会恢复被重新着色的近侄子节点的黑色高度。因此，我们重新着色NN，但进行双重旋转。
- en: Now consider what happens when the sibling is red. We first repaint the parent
    and sibling using opposite colors and rotating P. But this does not change the
    black height of any node; it reduces the case to case 5 or 6, which we will discuss
    now. So we simply call the rebalancing code again recursively.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在考虑当兄弟节点为红色时会发生什么。我们首先使用相反的颜色重新绘制父节点和兄弟节点，并旋转P。但这并不会改变任何节点的黑色高度；它将情况简化为5或6，我们将在下面讨论。因此，我们只需再次递归地调用重新平衡代码。
- en: We are now done with all the cases where the parent was black. This is a case
    where the parent is red. In this case, we consider the near nephew to be black.
    Simply rotating the parent fixes the black height.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在完成了所有父节点为黑色的情况。这是一个父节点为红色的情况。在这种情况下，我们将近侄子节点视为黑色。简单地旋转父节点就可以修复黑色高度。
- en: Our final case is when the parent is red and the near nephew is red. In this
    case, we recolor the parent and do a double rotation. Notice that the top node
    remains red. This is not a problem because the original top node, which is the
    parent node, was also red and hence its parent must be black.![Deletion](img/00059.jpeg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后的案例是当父节点为红色且近侄子节点为红色时。在这种情况下，我们重新着色父节点并进行双重旋转。注意，顶部节点仍然为红色。这不是问题，因为原始的顶部节点，即父节点，也是红色，因此它的父节点必须是黑色。![删除](img/00059.jpeg)
- en: Case 4, 5, and 6 of deletion from a red-black tree
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从红黑树中删除的4、5和6种情况
- en: 'Now we can define the `rebalanceForDelete` method coding all the preceding
    cases:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义`rebalanceForDelete`方法，编码所有前面的情况：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we override the `deleteValue` method to invoke rebalancing after the deletion.
    We only need to rebalance if the deleted node was black. We first check that.
    Then, we need to figure out whether the deleted child was a left child of the
    parent or the right child. After that, we can invoke the `rebalanceForDelete`
    method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们覆盖了`deleteValue`方法，在删除后调用重新平衡。我们只需要在删除的节点是黑色时进行重新平衡。我们首先检查这一点。然后，我们需要确定被删除的子节点是父节点的左子节点还是右子节点。之后，我们可以调用`rebalanceForDelete`方法：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The worst case of a red-black tree
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红黑树的最坏情况
- en: 'What is the worst possible red-black tree? We try to find out the same way
    we did in the case of the AVL tree. This one is a little more complicated, though.
    To understand the worst tree, we must take into account the black height. To fit
    the minimum number of nodes n into height h, we need to first choose a black height.
    Now it is desirable to have as few black nodes as possible so that we don''t have
    to include black nodes for balancing the black height in the siblings of the nodes
    we are trying to stretch the height with. Since a red node cannot be the parent
    of another, we must have alternate black nodes. We consider height *h* and an
    even number so that the black height is *h/2 = l*. For simplicity, we don''t count
    the black null nodes for either the height or the black height. The next figure
    shows some examples of the worst trees:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏可能的红黑树是什么？我们试图以与AVL树案例相同的方式找出答案。虽然这个案例稍微复杂一些。要使最小节点数 n 适应高度 h，我们首先需要选择一个黑高。现在我们希望尽可能少地有黑节点，这样我们就不必在试图拉伸高度的节点兄弟中包含黑节点来平衡黑高。由于红节点不能成为另一个节点的父节点，我们必须有交替的黑节点。我们考虑高度
    *h* 和一个偶数，这样黑高就是 *h/2 = l*。为了简单起见，我们既不计算高度也不计算黑高的黑空节点。下一个图显示了最坏树的一些示例：
- en: '![The worst case of a red-black tree](img/00060.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![红黑树的最坏情况](img/00060.jpeg)'
- en: Worst red-black trees
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的红黑树
- en: The general idea is, of course, to have one path with the maximum possible height.
    This path should be stuffed with the maximum number of red nodes and the other
    paths filled with the least number of nodes, that is, with only black nodes. The
    general idea is shown in the next figure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一般想法是，有一条路径具有最大可能的高度。这条路径应该填充尽可能多的红节点，而其他路径则填充尽可能少的节点，即只填充黑节点。一般想法在下一个图中显示。
- en: 'The number of nodes in a full black tree of height *l-1* is of course *2* ^(l-1)
    *– 1*. So, if the number of nodes for height *h = 2l* is *f(l)*, then we have
    the recursive formula:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 高度为 *l-1* 的满黑树中的节点数当然是 *2* ^(*l-1*) *– 1*。所以，如果高度为 *h = 2l* 的节点数为 *f(l)*，那么我们就有递归公式：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, from the preceding figure, we can already see that *f(1) = 2*, *f(2) =
    6*, and *f(3) = 14*. It looks like the formula should be *f(l) = 2* ^(l-1) *-2*.
    We already have the base cases. If we can prove that if the formula is true for
    l, then it is also true for *l+1*, we would be able to prove the formula for all
    *l* by induction. This is what we will try to do:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从前面的图中，我们还可以看到 *f(1) = 2*，*f(2) = 6*，和 *f(3) = 14*。看起来公式应该是 *f(l) = 2* ^(*l-1*)
    *-2*。我们已经有了基本案例。如果我们能证明如果公式对 l 成立，那么它对 *l+1* 也成立，我们就能通过归纳法证明所有 *l* 的公式。这正是我们将要尝试做的：
- en: '![The worst case of a red-black tree](img/00061.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![红黑树的最坏情况](img/00061.jpeg)'
- en: General idea of the worst red-black tree
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏红黑树的一般想法
- en: 'We already have *f(l+1) = f(l) + 2l+1* and we also assume *f(l) = 2l+1-2*.
    So this is the case: *f(l+1) = 2l+1-2 + 2l+1 = 2l+2-2*. Hence, if the formula
    holds true for *l*, it also holds true for *l+1*; therefore, it is proved by induction.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 *f(l+1) = f(l) + 2l+1*，并且我们也假设 *f(l) = 2l+1-2*。所以这是这种情况：*f(l+1) = 2l+1-2
    + 2l+1 = 2l+2-2*。因此，如果公式对 *l* 成立，它对 *l+1* 也成立；因此，通过归纳法证明了这一点。
- en: 'So the minimum number of nodes is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，最小节点数如下：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Therefore, a red-black tree has a guaranteed logarithmic height; from this,
    it is not hard to derive that the search, insertion, and deletion operations are
    all logarithmic.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，红黑树有一个保证的对数高度；从这个事实可以推导出，搜索、插入和删除操作都是对数的。
- en: Hash tables
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'A hash table is a completely different kind of searchable structure. The idea
    starts from what is called a hash function. It is a function that gives an integer
    for any value of the desired type. For example, the hash function for strings
    must return an integer for every string. Java requires every class to have a `hashcode()`
    method. The object class has one method implemented by default, but we must override
    the default implementation whenever we override the `equals` method. The hash
    function holds the following properties:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一种完全不同的可搜索结构。这个想法始于所谓的哈希函数。这是一个函数，为任何所需类型的值提供一个整数。例如，字符串的哈希函数必须为每个字符串返回一个整数。Java要求每个类都必须有一个
    `hashcode()` 方法。对象类默认实现了一个方法，但每当我们要重写 `equals` 方法时，我们必须重写默认实现。哈希函数具有以下属性：
- en: Same values must always return the same hash value. This is called consistency
    of the hash. In Java, this means if `x` and `y` are two objects and `x.equals(y)`
    is `true`, then `x.hashcode() == y.hashcode()`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的值必须始终返回相同的哈希值。这被称为哈希的一致性。在Java中，这意味着如果`x`和`y`是两个对象，并且`x.equals(y)`为`true`，那么`x.hashcode()
    == y.hashcode()`。
- en: Different values may return the same hash, but it is preferred that they don't.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的值可能返回相同的哈希值，但最好是它们不返回相同的值。
- en: The hash function is computable in constant time.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数可以在常数时间内计算。
- en: 'A perfect hash function will always provide a different hash value for different
    values. However, such a hash function cannot be computed in constant time in general.
    So, we normally resort to generating hash values that look seemingly random but
    are really complicated functions of the value itself. For example, `hashcode`
    of the `String` class looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的哈希函数将为不同的值提供不同的哈希值。然而，通常这种哈希函数不能在常数时间内计算。因此，我们通常求助于生成看似随机但实际上是值的复杂函数的哈希值。例如，`String`类的`hashcode`看起来像这样：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that it is a complicated function that is computed from constituent characters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个由构成字符计算出的复杂函数。
- en: A hash table keeps an array of buckets indexed by the hash code. The bucket
    can have many kinds of data structures, but here, we will use a linked list. This
    makes it possible to jump to a certain bucket in constant time and then the bucket
    is kept small enough so that the search within the bucket, even a linear search,
    will not cost that much.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表保持一个由哈希码索引的桶数组。桶可以有多种数据结构，但在这里，我们将使用链表。这使得能够在常数时间内跳转到某个桶，并且桶保持足够小，以至于桶内的搜索，即使是线性搜索，也不会花费太多。
- en: 'Let''s create a skeleton class for our hash table:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的哈希表创建一个骨架类：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We accept two parameters. `InitialSize` is the initial number of buckets we
    want to start with, and our second parameter is the maximum load factor.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受两个参数。`InitialSize`是我们想要开始的初始桶数量，我们的第二个参数是最大负载因子。
- en: What is load factor? Load factor is the average number of values per bucket.
    If the number of buckets is *k* and the total number of values in it is *n*, then
    load factor is *n/k*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是负载因子？负载因子是每个桶的平均值。如果桶的数量是*k*，并且其中的总值为*n*，那么负载因子是*n/k*。
- en: Insertion
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: Insertion is done by first computing the hash and picking up the bucket in that
    index. Now firstly, the bucket is searched linearly for the value. If the value
    is found, insertion is not carried out; otherwise, the new value is added to the
    end of the bucket.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 插入操作首先计算哈希值，然后选择该索引处的桶。现在首先，线性搜索该桶以查找值。如果找到值，则不执行插入；否则，将新值添加到桶的末尾。
- en: 'First we create a function for inserting in a given array of buckets and then
    using it to perform the insertion. This would be useful when you are dynamically
    growing your hash table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个用于在给定的桶数组中插入的函数，然后使用它来执行插入操作。这在您动态扩展哈希表时非常有用：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that effective hash code is computed by taking the remainder of the actual
    hash code divided by the number of buckets. This is done to limit the number of
    hash code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有效的哈希码是通过将实际哈希码除以桶的数量得到的余数来计算的。这样做是为了限制哈希码的数量。
- en: 'There is one more thing to be done here and that is rehashing. Rehashing is
    the process of dynamically growing the hash table as soon as it exceeds a predefined
    load factor (or in some cases due to other conditions, but we will use load factor
    in this text). Rehashing is done by creating a second array of buckets of a bigger
    size and copying each element to the new set of buckets. Now the old array of
    buckets is discarded. We create this function as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一件事要做，那就是重新哈希。重新哈希是在哈希表超过预定义的负载因子（或在某些情况下由于其他条件，但我们将使用负载因子）时动态扩展哈希表的过程。重新哈希是通过创建一个更大的桶数组的第二个桶数组并复制每个元素到新的桶集合中完成的。现在，旧的桶数组被丢弃。我们创建此函数如下：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can have our completed `insert` function for a value:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以有一个为值完成的`insert`函数：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The complexity of insertion
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入的复杂度
- en: 'It is easy to see that the insert operation is almost constant time unless
    we have to rehash it; in this case, it is *O(n)*. So how many times do we have
    to rehash it? Suppose the load factor is *l* and the number of buckets is *b*.
    Say we start from an `initialSize` *B*. Since we are doubling every time we rehash,
    the number of buckets will be *b = B.2* ^R; here *R* is the number of times we
    rehashed. Hence, the total number of elements can be represented as this: *n =
    bl = Bl. 2* *R*. Check this out:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，除非我们不得不重新散列，否则插入操作几乎是常数时间；在这种情况下，它是 *O(n)*。那么我们得重新散列多少次？假设负载因子为 *l*，桶的数量为
    *b*。假设我们从 `initialSize` *B* 开始。由于我们每次重新散列时都会加倍，所以桶的数量将是 *b = B.2* ^R；这里 *R* 是我们重新散列的次数。因此，元素的总数可以表示为：*n
    = bl = Bl. 2* *R*。看看这个：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There must be about `lg n` number of rehashing operations, each with complexity
    of `O(n)`. So the average complexity for inserting `n` elements is `O(n lg n)`.
    Hence, the average complexity for inserting each element is `O(lg n)`. This, of
    course, would not work if the values are all clustered together in a single bucket
    that we are inserting into. Then, each insert would be `O(n)`, which is the worst
    case complexity of an insertion.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大约有 `lg n` 次重新散列操作，每次操作的复杂度为 `O(n)`。因此，插入 `n` 个元素的平均复杂度为 `O(n lg n)`。因此，插入每个元素的平均复杂度为
    `O(lg n)`。当然，如果所有值都聚集在我们插入的单个桶中，这就不适用了。那么，每次插入的复杂度将是 `O(n)`，这是插入操作的最坏情况复杂度。
- en: Deletion is very similar to insertion; it involves deletion of elements from
    the buckets after they are searched.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 删除与插入非常相似；它涉及在搜索后从桶中删除元素。
- en: Search
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Search is simple. We compute the hash code, go to the appropriate bucket, and
    do a linear search in the bucket:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索很简单。我们计算哈希码，转到适当的桶，并在桶中进行线性搜索：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Complexity of the search
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索的复杂度
- en: The complexity of the search operation is constant time if the values are evenly
    distributed. This is because in this case, the number of elements per bucket would
    be less than or equal to the load factor. However, if all the values are in the
    same bucket, search is reduced to a linear search and it is *O(n)*. So the worst
    case is linear. The average case of search is constant time in most cases, which
    is better than that of binary search trees.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值分布均匀，搜索操作的复杂度是常数时间。这是因为在这种情况下，每个桶中的元素数量将小于或等于负载因子。然而，如果所有值都在同一个桶中，搜索将简化为线性搜索，其复杂度为
    *O(n)*。所以最坏情况是线性的。在大多数情况下，搜索的平均复杂度是常数时间，这比二叉搜索树的复杂度要好。
- en: Choice of load factor
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载因子选择
- en: If the load factor is too big, each bucket would hold a lot of values that would
    output a bad linear search. But if the load factor is too small, there would be
    a huge number of unused buckets causing wastage of space. It is really a compromise
    between search time and space. It can be shown that for a uniformly distributed
    hash code, the fraction of buckets that are empty can be approximately expressed
    as e^(-l), where l is the load factor and e is the base of a natural logarithm.
    If we use a load factor of say 3, then the fraction of empty buckets would be
    approximately e^(-3) = 0.0497 or 5 percent, which is not bad. In the case of a
    non-uniformly distributed hash code (that is, with unequal probabilities for different
    ranges of values of the same width), the fraction of empty buckets would always
    be greater. Empty buckets take up space in the array, but they do not improve
    the search time. Therefore, they are undesirable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负载因子太大，每个桶将包含大量值，这将导致线性搜索性能不佳。但如果负载因子太小，将会有大量的未使用桶，导致空间浪费。这实际上是在搜索时间和空间之间的一种折衷。可以证明，对于均匀分布的哈希码，空桶的分数可以近似表示为
    e^(-l)，其中 l 是负载因子，e 是自然对数的底数。如果我们使用负载因子为 3，那么空桶的分数将大约是 e^(-3) = 0.0497 或 5%，这并不坏。在非均匀分布的哈希码（即，具有不同宽度的值的不同范围的概率不等）的情况下，空桶的分数总是更大的。空桶占用数组空间，但它们不会提高搜索时间。因此，它们是不受欢迎的。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw a collection of searchable and modifiable data structures.
    All of these allowed you to insert new elements or delete elements while still
    remaining searchable and that too quite optimally. We saw binary search trees
    in which a search follows the paths of the tree from the root. Binary search trees
    can be modified optimally while still remaining searchable if they are of the
    self-balancing type. We studied two different kinds of self-balancing trees: AVL
    trees and red-black trees. Red-black trees are less balanced than AVL trees, but
    they involve a fewer number of rotations than AVL trees. In the end, we went through
    the hash table, which is a different kind of searchable structure. Although the
    worst case complexity of search or insertion is *O(n)*, hash tables provide constant
    time search and average time insertion (*O(lg n)*) in most cases. If a hash table
    does not keep growing, the average insertion and deletion operations will also
    be constant time.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了一系列可搜索和可修改的数据结构。所有这些结构都允许你在插入新元素或删除元素的同时保持可搜索性，而且这种可搜索性还相当优化。我们看到了二叉搜索树，其中搜索遵循从根到树的路径。如果这些二叉搜索树是自平衡类型，那么它们在保持可搜索性的同时可以进行最优化的修改。我们研究了两种不同的自平衡树：AVL树和红黑树。红黑树比AVL树平衡性较差，但它们所需的旋转次数比AVL树少。最后，我们探讨了哈希表，这是一种不同类型的可搜索结构。尽管在最坏情况下的搜索或插入复杂度为*O(n)*，但在大多数情况下，哈希表提供常数时间的搜索和平均时间的插入（*O(lg
    n)*)。如果一个哈希表不持续增长，那么平均插入和删除操作也将是常数时间。
- en: In the next chapter, we will see some more important general purpose data structures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一些更重要的通用数据结构。
