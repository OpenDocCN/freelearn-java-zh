- en: Basic Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本操作符
- en: In the previous chapter, you learned a lot about the `Observable` and `Observer`.
    We also covered a small number of operators, particularly `map()` and `filter()`,
    to understand the role of operators as well. But there are hundreds of RxJava
    operators we can leverage to express business logic and behaviors. We will cover
    operators comprehensively throughout much of this book, so you know which ones
    to use and when. Being aware of the operators available and combining them is
    critical to being successful using ReactiveX. You should strive to use operators
    to express business logic so your code stays as reactive as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学到了很多关于 `Observable` 和 `Observer` 的知识。我们还介绍了一些操作符，特别是 `map()` 和 `filter()`，以了解操作符的作用。但我们可以利用数百个
    RxJava 操作符来表达业务逻辑和行为。我们将在这本书的大部分内容中全面介绍操作符，这样你知道何时使用哪些操作符。了解可用的操作符并将它们组合起来对于成功使用
    ReactiveX 至关重要。你应该努力使用操作符来表达业务逻辑，以便你的代码尽可能保持反应式。
- en: It should be noted that operators themselves are Observers to the `Observable`
    they are called on. If you call `map()` on an `Observable`, the returned `Observable`
    will subscribe to it. It will then transform each emission and in turn be a producer
    for Observers downstream, including other operators and the terminal `Observer`
    itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，操作符本身是它们所调用的 `Observable` 的观察者。如果你在 `Observable` 上调用 `map()`，返回的 `Observable`
    将订阅它。然后它将转换每个输出，并依次成为下游观察者（包括其他操作符和终端 `Observer`）的生产者。
- en: You should strive to execute as much logic as possible using RxJava operators,
    and you should use an `Observer` to receive the end product emissions that are
    ready to be consumed. Try not to cheat or get creative by extracting values out
    of the `Observable` chain, or resort to blocking processes or imperative programming
    tactics. When you keep algorithms and processes reactive, you can easily leverage
    the benefits of reactive programming such as lower memory usage, flexible concurrency,
    and disposability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该努力使用 RxJava 操作符执行尽可能多的逻辑，并使用 `Observer` 来接收准备消费的最终产品输出。尽量别从 `Observable`
    链中提取值，或者求助于阻塞过程或命令式编程策略。当你保持算法和过程反应式时，你可以轻松利用反应式编程的好处，如降低内存使用、灵活的并发性和可丢弃性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Suppressing operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抑制操作符
- en: Transforming operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换操作符
- en: Reducing operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法操作符
- en: Error-recovery operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误恢复操作符
- en: Action operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作操作符
- en: Suppressing operators
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抑制操作符
- en: There are a number of operators that will suppress emissions that fail to meet
    a specified criterion. These operators work by simply not calling the `onNext()`
    function downstream for a disqualified emission, and therefore does not go down
    the chain to `Observer`. We have already seen the `filter()` operator, which is
    probably the most common suppressing operator. We will start with this one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多操作符可以抑制不符合特定标准的输出。这些操作符通过简单地不对不合格的输出调用下游的 `onNext()` 函数来实现，因此不会向下传递到 `Observer`。我们已经看到了
    `filter()` 操作符，这可能是最常见的抑制操作符。我们将从这个开始。
- en: filter()
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: filter()
- en: The  `filter()` operator accepts `Predicate<T>` for a given `Observable<T>`.
    This means that you provide it a lambda that qualifies each emission by mapping
    it to a Boolean value, and emissions with false will not go forward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 操作符接受 `Predicate<T>` 用于给定的 `Observable<T>`。这意味着你提供一个 lambda 表达式，通过映射每个输出到布尔值来验证每个输出，带有
    false 的输出将不会继续。'
- en: 'For instance,  you can use `filter()` to only allow string emissions that are
    not five characters in length:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `filter()` 来只允许长度不是五个字符的字符串输出：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `filter()` function is probably the most commonly used operator to suppress
    emissions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数可能是最常用的用于抑制输出的操作符。'
- en: Note that if all emissions fail to meet your criteria, the returned `Observable`
    will be empty, with no emissions occurring before `onComplete()` is called.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果所有输出都无法满足你的标准，返回的 `Observable` 将为空，且在调用 `onComplete()` 之前不会发生任何输出。
- en: take()
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: take()
- en: 'The `take()` operator has two overloads. One will take a specified number of
    emissions and then call  `onComplete()` after it captures all of them. It will
    also dispose of the entire subscription so that no more emissions will occur.
    For instance, `take(3)` will emit the first three emissions and then call the `onComplete()`
    event:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`take()`操作符有两个重载版本。其中一个将获取指定数量的发射，并在捕获所有这些发射后调用`onComplete()`。它还将销毁整个订阅，以便不再发生更多发射。例如，`take(3)`将发射前三个发射，然后调用`onComplete()`事件：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码片段的输出如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that if you receive fewer emissions than you specify in your `take()` function,
    it will simply emit what it does get and then call the `onComplete()` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在`take()`函数中指定的发射少于你得到的，它将简单地发射它所得到的，然后调用`onComplete()`函数。
- en: 'The other overload will take emissions within a specific time duration and
    then call  `onComplete()`. Of course, our cold `Observable` here will emit so
    quickly that it would serve as a bad example for this case. Maybe a better example
    would be to use an `Observable.interval()` function. Let''s emit every `300` milliseconds,
    but `take()`emissions for only `2` seconds in the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重载版本将获取特定时间持续时间内的发射，然后调用`onComplete()`。当然，我们这里的冷`Observable`会非常快地发射，这会是一个不好的例子。也许使用`Observable.interval()`函数会更好。让我们以每`300`毫秒发射一次，但在以下代码片段中只对`2`秒内的发射进行`take()`操作：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码片段的输出如下：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will likely get the output that's shown here (each print happening every
    `300` milliseconds). You can only get six emissions in `2` seconds if they are
    spaced out by `300` milliseconds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到这里显示的输出（每个打印每`300`毫秒发生一次）。如果它们以`300`毫秒的间隔分散，那么在`2`秒内你只能得到六个发射。
- en: Note that there is also a `takeLast()` operator, which will take the last specified
    number of emissions (or time duration) before the `onComplete()`  function is
    called. Just keep in mind that it will internally queue emissions until its `onComplete()`
    function is called, and then it can logically identify and emit the last emissions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个`takeLast()`操作符，它将在调用`onComplete()`函数之前获取指定数量的最后发射（或时间持续时间）。只需记住，它将内部排队发射，直到其`onComplete()`函数被调用，然后它可以逻辑上识别并发射最后的发射。
- en: skip()
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`skip()`'
- en: 'The `skip()` operator does the opposite of the `take()` operator. It will ignore
    the specified number of emissions and then emit the ones that follow.  If I wanted
    to skip the first `90` emissions of an `Observable`, I could use this operator,
    as shown in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip()`操作符与`take()`操作符相反。它将忽略指定数量的发射，然后发射后续的发射。如果我想跳过一个`Observable`的前`90`个发射，我可以使用这个操作符，如下所示：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the following code snippet is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like the `take()` operator, there is also an overload accepting a time
    duration. There is also a `skipLast()` operator, which will skip the last specified
    number of items (or time duration) before the `onComplete()` event is called.
    Just keep in mind that the `skipLast()` operator will queue and delay emissions
    until it confirms the last emissions in that scope.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`take()`操作符一样，还有一个接受时间持续的重载。还有一个`skipLast()`操作符，它将在调用`onComplete()`事件之前跳过指定数量的项目（或时间持续时间）。只需记住，`skipLast()`操作符将排队并延迟发射，直到它确认该范围内的最后发射。
- en: takeWhile() and skipWhile()
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`takeWhile()` 和 `skipWhile()`'
- en: 'Another variant of the `take()` operator is the `takeWhile()` operator, which
    takes emissions while a condition derived from each emission is true. The following
    example will keep taking emissions while emissions are less than `5`. The moment
    it encounters one that is not, it will call the `onComplete()` function and dispose
    of this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`take()`操作符的另一个变体是`takeWhile()`操作符，它将在从每个发射推导出的条件为真时获取发射。以下示例将在发射小于`5`时持续获取发射。一旦遇到一个不满足条件的发射，它将调用`onComplete()`函数并销毁它：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码片段的输出如下：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just like the `takeWhile()` function, there is a `skipWhile()` function. It
    will keep skipping emissions while they qualify with a condition. The moment that
    condition no longer qualifies, the emissions will start going through. In the
    following code, we skip emissions as long as they are less than or equal to `95`.
    The moment an emission is encountered that does not meet this condition, it will
    allow all subsequent emissions going forward:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`takeWhile()`函数一样，还有一个`skipWhile()`函数。它将一直跳过满足条件的排放项。一旦条件不再满足，排放项将开始通过。在下面的代码中，只要排放项小于或等于`95`，就跳过排放项。一旦遇到不满足此条件的排放项，它将允许所有后续的排放项向前传递：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `takeUntil()` operator is similar to `takeWhile()`, but it accepts another `Observable`
    as a parameter. It will keep taking emissions until that other `Observable` pushes
    an emission. The `skipUntil()` operator has similar behavior. It also accepts
    another `Observable` as an argument but it will keep skipping until the other `Observable`
    emits something.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeUntil()`操作符与`takeWhile()`类似，但它接受另一个`Observable`作为参数。它将一直接收排放项，直到那个其他`Observable`推送一个排放项。`skipUntil()`操作符具有类似的行为。它也接受另一个`Observable`作为参数，但它将一直跳过，直到其他`Observable`发出一些内容。'
- en: distinct()
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: distinct()
- en: 'The `distinct()` operator will emit each unique emission, but it will suppress
    any duplicates that follow. Equality is based on `hashCode()/equals()` implementation
    of the emitted objects. If we wanted to emit the distinct lengths of a string
    sequence, it could be done as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct()`操作符会排放每个唯一的排放项，但它会抑制随后出现的任何重复项。等价性基于排放对象的`hashCode()/equals()`实现。如果我们想排放字符串序列的唯一长度，可以这样做：'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Keep in mind that if you have a wide, diverse spectrum of unique values, `distinct()`
    can use a bit of memory. Imagine that each subscription results in a `HashSet`
    that tracks previously captured unique values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您有一系列广泛的、独特的值，`distinct()`可能会使用一些内存。想象一下，每个订阅都会产生一个`HashSet`，用于跟踪之前捕获的唯一值。
- en: 'You can also add a lambda argument that maps each emission to a key used for
    equality logic. This allows the emissions, but not the key, to go forward while
    using the key for distinct logic. For instance, we can key off each string''s
    length and use it for uniqueness, but emit the strings rather than their lengths:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加一个lambda参数，将每个排放项映射到一个用于等价逻辑的键。这允许排放项（而不是键）向前传递，同时使用键进行不同的逻辑。例如，我们可以根据每个字符串的长度进行键控，并使用它来保证唯一性，但排放字符串而不是它们的长度：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Alpha` is five characters, and `Beta` is four. `Gamma` and `Delta` were ignored
    because `Alpha` was already emitted and is 5 characters. `Epsilon` is seven characters,
    and because no seven-character string was emitted yet, it was emitted forward.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alpha`是五个字符，`Beta`是四个。`Gamma`和`Delta`被忽略，因为`Alpha`已经被排放，并且是5个字符。`Epsilon`是七个字符，因为还没有排放过七个字符的字符串，所以它被向前排放。'
- en: distinctUntilChanged()
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: distinctUntilChanged()
- en: 'The `distinctUntilChanged()` function will ignore duplicate consecutive emissions.
    It is a helpful way to ignore repetitions until they change. If the same value
    is being emitted repeatedly, all the duplicates will be ignored until a new value
    is emitted. Duplicates of the next value will be ignored until it changes again,
    and so on. Observe the output for the following code to see this behavior in action:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged()`函数会忽略连续的重复排放项。这是一种忽略重复直到它们改变的有用方法。如果正在重复排放相同的值，所有重复项都将被忽略，直到发射一个新的值。下一个值的重复项将被忽略，直到它再次改变，依此类推。观察以下代码的输出，以查看此行为：'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We first receive an emission of `1`, which is allowed forward. But the next
    two `1` are ignored because they are consecutive duplicates. When it switches
    to `2`, that initial 2 is emitted, but the following duplicate is ignored. A `3`
    is emitted and its following duplicate is ignored as well. Finally, we switch
    back to a `2` that emits and then a `1` whose duplicate is ignored.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先接收一个`1`的排放，这是允许的。但接下来的两个`1`被忽略，因为它们是连续的重复项。当它切换到`2`时，那个初始的`2`被排放，但随后的重复项被忽略。排放一个`3`，其随后的重复项也被忽略。最后，我们切换回一个排放的`2`，然后是一个重复项被忽略的`1`。
- en: 'Just like `distinct()`, you can provide an optional argument for a key through
    a lambda mapping. In the following code snippet, we execute the `distinctUntilChanged()`
    operation with strings keyed on their lengths:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`distinct()`一样，你可以通过一个lambda映射提供一个可选的键参数。在以下代码片段中，我们使用基于字符串长度的键执行`distinctUntilChanged()`操作：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `Zeta` was skipped because it comes right after `Beta`, which also
    is four characters. `Delta` is ignored as well because it follows `Gamma`, which
    is five characters as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`Zeta`紧随`Beta`之后，而`Beta`也是四个字符，因此跳过了`Zeta`。同样，由于`Delta`紧随`Gamma`之后，而`Gamma`也是五个字符，因此也忽略了`Delta`。
- en: elementAt()
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: elementAt()
- en: You can get a specific emission by its index specified by a Long, starting at
    `0`. After that item is found and emitted, `onComplete()` will be called and the
    subscription will be disposed of.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定一个Long类型的索引来获取特定的发射项，索引从`0`开始。找到并发出该项目后，将调用`onComplete()`，并取消订阅。
- en: 'If you want to get the fourth emission coming from an `Observable`, you can
    do it as shown in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从`Observable`中获取第四个发射项，你可以按照以下代码片段所示进行操作：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the following code snippet is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may not have noticed, but `elementAt()` returns `Maybe<T>` instead of `Observable<T>`.
    This is because it will yield one emission, but if there are fewer emissions than
    the sought index, it will be empty.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，`elementAt()`返回`Maybe<T>`而不是`Observable<T>`。这是因为它将产生一个发射项，但如果发射项少于所求索引，它将是空的。
- en: There are other flavors of `elementAt()`, such as `elementAtOrError()`, which
    return a `Single` and will emit an error if an element at that index is not found.
    `singleElement()` will turn an `Observable` into a `Maybe`, but will produce an
    error if there is anything beyond one element. Finally, `firstElement()` and `lastElement()`
    will yield, maybe emitting the first or last emission, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementAt()`还有其他变体，例如`elementAtOrError()`，它返回一个`Single`，如果在该索引处找不到元素，则会发出错误。`singleElement()`将`Observable`转换为`Maybe`，但如果存在超过一个元素，则会产生错误。最后，`firstElement()`和`lastElement()`将分别产生第一个或最后一个发射项。'
- en: Transforming operators
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换操作符
- en: Next, we will cover various common operators that transform emissions. A series
    of operators in an `Observable` chain is a stream of transformations. You have
    already seen `map()`, which is the most obvious operator in this category. We
    will start with that one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍各种常见的转换发射项的操作符。在`Observable`链中的操作符系列是一系列转换。你已经看到了`map()`，这是这一类别中最明显的操作符。我们将从这个开始。
- en: map()
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map()
- en: 'For a given `Observable<T>`, the `map()` operator will transform a `T` emission
    into an `R` emission using the provided `Function<T,R>` lambda. We have already
    used this operator many times, turning strings into lengths. Here is a new example:
    we can take raw date strings and use the `map()` operator to turn each one into
    a `LocalDate` emission, as shown in the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的`Observable<T>`，`map()`操作符将使用提供的`Function<T,R>` lambda将`T`发射项转换为`R`发射项。我们已经多次使用此操作符，将字符串转换为长度。以下是一个新示例：我们可以将原始日期字符串作为输入，并使用`map()`操作符将每个字符串转换为`LocalDate`发射项，如下所示：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We passed a lambda that turns each string into a `LocalDate` object. We created
    a `DateTimeFormatter` in advance in order to assist with the `LocalDate.parse()`
    operation, which returns a `LocalDate`. In turn, we pushed each `LocalDate` emission
    to our `Observer` to be printed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了一个将每个字符串转换为`LocalDate`对象的lambda表达式。我们提前创建了一个`DateTimeFormatter`，以便协助进行`LocalDate.parse()`操作，该操作返回一个`LocalDate`。然后，我们将每个`LocalDate`发射项推送到我们的`Observer`以进行打印。
- en: The `map()` operator does a one-to-one conversion for each emission. If you
    need to do a one-to-many conversion (turn one emission into several emissions),
    you will likely want to use `flatMap()` or `concatMap()`, which we will cover
    in the next chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`操作符对每个发射项进行一对一的转换。如果你需要执行一对一转换（将一个发射项转换为多个发射项），你可能希望使用`flatMap()`或`concatMap()`，我们将在下一章中介绍。'
- en: cast()
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cast()
- en: 'A simple, map-like operator to cast each emission to a different type is `cast()`.
    If we want to take `Observable<String>` and cast each emission to an object (and
    return an `Observable<Object>`), we could use the `map()` operator like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的、类似映射的操作符，用于将每个发射项转换为不同类型的是`cast()`。如果我们想将`Observable<String>`转换为对象（并返回一个`Observable<Object>`），我们可以使用`map()`操作符，如下所示：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But a shorthand we can use instead is `cast()`, and we can simply pass the
    class type we want to cast to, as shown in the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用的一个简写是`cast()`，我们可以简单地传递我们想要转换到的类类型，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you find that you are having typing issues due to inherited or polymorphic
    types being mixed, this is an effective brute-force way to cast everything down
    to a common base type. But strive to properly use generics and type wildcards
    appropriately first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现由于继承或多态类型混合而出现打字问题，这是一个将所有内容强制转换为公共基类型的有效暴力方法。但首先努力正确使用泛型和适当使用类型通配符。
- en: startWith()
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`startWith()`'
- en: 'For a given `Observable<T>`, the `startWith()` operator allows you to insert
    a `T` emission that precedes all the other emissions. For instance, if we have
    an `Observable<String>`that emits items on a menu we want to print, we can use
    `startWith()` to append a title header first:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的`Observable<T>`，`startWith()`操作符允许你插入一个在所有其他发射之前发生的`T`发射。例如，如果我们有一个`Observable<String>`，它发射我们想要打印的菜单项，我们可以使用`startWith()`来首先添加一个标题头：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to start with more than one emission, use `startWithArray()` to
    accept `varargs` parameters. If we want to add a divider between our header and
    menu items, we can start with both the header and divider as emissions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要开始于多个发射，请使用`startWithArray()`来接受`varargs`参数。如果我们想在标题和菜单项之间添加分隔符，我们可以开始于标题和分隔符作为发射：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `startWith()` operator is helpful for cases like this, where we want to
    seed an initial value or precede our emissions with one or more emissions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWith()`操作符在这种情况下很有用，当我们想要提供一个初始值或在我们自己的发射之前添加一个或多个发射。'
- en: If you want an entire emissions of `Observable` to precede emissions of another `Observable`,
    you will want to use `Observable.concat()` or `concatWith()`, which we will cover
    in the next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个完整的`Observable`发射先于另一个`Observable`的发射，你将想要使用`Observable.concat()`或`concatWith()`，我们将在下一章中介绍。
- en: defaultIfEmpty()
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty()`'
- en: If we want to resort to a single emission if a given `Observable` comes out
    empty, we can use `defaultIfEmpty()`. For a given `Observable<T>`, we can specify
    a default `T` emission if no emissions occur when `onComplete()` is called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在给定的`Observable`为空时仅使用单个发射，我们可以使用`defaultIfEmpty()`。对于给定的`Observable<T>`，我们可以在调用`onComplete()`时没有发射发生的情况下指定一个默认的`T`发射。
- en: 'If we have an `Observable<String>` and filter for items that start with `Z` but
    no items meet this criteria, we can resort to emitting `None`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`Observable<String>`并过滤以查找以`Z`开头的项，但没有项符合此标准，我们可以求助于发射`None`：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, if emissions were to occur, we would never see `None` emitted. It
    will only happen if the preceding `Observable` is empty.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果发生发射，我们永远不会看到`None`被发射。这只会在前面的`Observable`为空时发生。
- en: switchIfEmpty()
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switchIfEmpty()`'
- en: Similar to `defaultIfEmpty()`, `switchIfEmpty()` specifies a different `Observable`
    to emit values from if the source `Observable` is empty. This allows you specify
    a different sequence of emissions in the event that the source is empty rather
    than emitting just one value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`defaultIfEmpty()`类似，`switchIfEmpty()`在源`Observable`为空时指定一个不同的`Observable`来发射值。这允许我们在源为空的情况下指定不同的发射序列，而不是只发射一个值。
- en: 'We could choose to emit three additional strings, for example, if the preceding
    `Observable` came out empty due to a `filter()` operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择发射三个额外的字符串，例如，如果前面的`Observable`由于`filter()`操作为空：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, if the preceding `Observable` is not empty, then `switchIfEmpty()`
    will have no effect and not use that specified `Observable`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果前面的`Observable`不为空，那么`switchIfEmpty()`将没有效果，不会使用指定的`Observable`。
- en: sorted()
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sorted()`'
- en: 'If you have a finite `Observable<T>` emitting items that implement `Comparable<T>`,
    you can use `sorted()` to sort the emissions. Internally, it will collect all
    the emissions and then re-emit them in their sorted order. In the following code
    snippet, we sort emissions from `Observable<Integer>`so that they are emitted
    in their natural order:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个有限制的`Observable<T>`，它发射实现`Comparable<T>`的项，你可以使用`sorted()`来对发射进行排序。内部，它将收集所有发射，然后按排序顺序重新发射它们。在以下代码片段中，我们按自然顺序对`Observable<Integer>`的发射进行排序：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Of course, this can have some performance implications as it will collect all
    emissions in memory before emitting them again. If you use this against an infinite
    `Observable`, you may get an `OutOfMemory` error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可能会对性能产生一些影响，因为它将在再次发射之前在内存中收集所有排放。如果你使用它来对抗无限的`Observable`，可能会得到`OutOfMemory`错误。
- en: 'You can also provide `Comparator` as an argument to specify an explicit sorting
    criterion. We can provide `Comparator` to reverse the sorting order, such as the
    one shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供`Comparator`作为参数来指定一个显式的排序标准。我们可以提供`Comparator`来反转排序顺序，如下所示：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since `Comparator` is a single-abstract-method interface, you can implement
    it quickly with a lambda. Specify the two parameters representing two emissions,
    and then map them to their comparison operation. We can use this to sort string
    emissions by their lengths, for instance. This also allows us to sort items that
    do not implement Comparable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Comparator`是一个单抽象方法接口，你可以通过lambda表达式快速实现它。指定代表两个排放的两个参数，然后将它们映射到它们的比较操作。我们可以用这个来按长度排序字符串排放，例如。这也允许我们排序不实现`Comparable`接口的项目：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: delay()
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: delay()
- en: 'We can postpone emissions using the `delay()` operator. It will hold any received
    emissions and delay each one for the specified time period. If we wanted to delay
    emissions by three seconds, we could do it like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`delay()`运算符来推迟排放。它将保留任何接收到的排放，并将每个排放推迟指定的时长。如果我们想将排放推迟三秒，可以这样做：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because `delay()` operates on a different scheduler (such as `Observable.interval()`),
    we need to leverage a `sleep()` method to keep the application alive long enough
    to see this happen. Each emission will be delayed by three seconds. You can pass
    an optional third Boolean argument indicating whether you want to delay error
    notifications as well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`delay()`在另一个调度器（如`Observable.interval()`）上操作，我们需要利用`sleep()`方法来保持应用程序足够长时间，以便看到这个效果。每个排放将被推迟三秒。你可以传递一个可选的第三个布尔参数，表示你是否想推迟错误通知。
- en: For more advanced cases, you can pass another `Observable` as your `delay()`
    argument, and this will delay emissions until that other `Observable` emits something.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的情况，你可以将另一个`Observable`作为你的`delay()`参数传递，这将推迟排放，直到那个其他`Observable`发射一些内容。
- en: Note that there is a `delaySubscription()` operator, which will delay subscribing
    to the `Observable` preceding it rather than delaying each individual emission.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个`delaySubscription()`运算符，它将延迟订阅它前面的`Observable`，而不是延迟每个单独的排放。
- en: repeat()
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: repeat()
- en: The `repeat()` operator will repeat subscription upstream after `onComplete()`
    a specified number of times.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`运算符将在`onComplete()`之后重复上游订阅指定次数。'
- en: 'For instance, we can repeat the emissions twice for a given `Observable` by
    passing a long `2` as an argument for `repeat()`, as shown in the following code
    snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过将`2`作为`repeat()`的参数传递给给定的`Observable`来重复排放两次，如下面的代码片段所示：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you do not specify a number, it will repeat infinitely, forever re-subscribing
    after every `onComplete()`. There is also a `repeatUntil()` operator that accepts
    a Boolean Supplier lambda argument and will continue repeating until it yields
    `true`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定数字，它将无限重复，在每次`onComplete()`之后重新订阅。还有一个`repeatUntil()`运算符，它接受一个布尔供应商lambda参数，并将继续重复，直到它产生`true`。
- en: scan()
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scan()
- en: The `scan()` method is a rolling aggregator. For every emission, you add it
    to an accumulation. Then, it will emit each incremental accumulation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan()`方法是一个滚动聚合器。对于每个排放，你将其添加到一个累积中。然后，它将发出每个增量累积。'
- en: 'For instance, you can emit the rolling sum for each emission by passing a lambda
    to the`scan()` method that adds each `next` emission to the `accumulator`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过将一个lambda表达式传递给`scan()`方法来发射每个排放的滚动总和，该lambda表达式将每个`next`排放添加到`accumulator`中：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It emitted the initial value of `5`, which was the first emission it received.
    Then, it received `3` and added it to `5`, emitting `8`. After that, `7` was received,
    which was added to `8`, emitting `15`, and so on. This does not have to be used
    just for rolling sums. You can create many kinds of accumulations (even non-math
    ones such as string concatenations or Boolean reductions).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它发出了初始值`5`，这是它接收到的第一个值。然后，它接收到了`3`，并将其加到`5`上，发出了`8`。之后，接收到了`7`，将其加到`8`上，发出了`15`，以此类推。这不仅仅可以用于滚动求和。你可以创建许多种类的累积（甚至是非数学的，如字符串连接或布尔缩减）。
- en: Note that `scan()` is very similar to `reduce()`, which we will learn about
    shortly. Be careful to not confuse the two. The `scan()`  method emits the rolling
    accumulation for each emission, whereas `reduce()` yields a single emission reflecting
    the final accumulation once `onComplete()` is called. `scan()`can be used on infinite
    Observables safely since it does not require an `onComplete()` call.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`scan()`与`reduce()`非常相似，我们将在稍后了解。小心不要混淆这两个。`scan()`方法为每个发射发出滚动累积，而`reduce()`在调用`onComplete()`后产生一个单一的发射，反映最终的累积。`scan()`可以在无限`Observable`上安全使用，因为它不需要调用`onComplete()`。
- en: 'You can also provide an initial value for the first argument and aggregate
    into a different type than what is being emitted. If we wanted to emit the rolling
    count of emissions, we can provide an initial value of `0` and just add `1` to
    it for every emission. Keep in mind that the initial value will be emitted first,
    so use `skip(1)` after `scan()` if you do not want that initial emission:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为第一个参数提供一个初始值，并将聚合到与发射不同的类型中。如果我们想发出发射的滚动计数，我们可以提供一个初始值`0`，并为每个发射加`1`。请注意，初始值将首先发出，所以如果你不想有初始发射，请在`scan()`之后使用`skip(1)`：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Reducing operators
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩减操作符
- en: You will likely have moments where you want to take a series of emissions and
    consolidate them into a single emission (usually emitted through a `Single`).
    We will cover a few operators that accomplish this. Note that nearly all of these
    operators only work on a finite `Observable` that calls `onComplete()` because
    typically, we can consolidate only finite datasets. We will explore this behavior
    as we cover these operators.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到想要将一系列发射合并成一个发射（通常通过`Single`发出）的时刻。我们将介绍一些完成此任务的运算符。请注意，几乎所有这些运算符都只适用于有限`Observable`，因为通常我们只能合并有限的数据集。我们将随着介绍这些运算符来探索这种行为。
- en: count()
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: count()
- en: 'The simplest operator to consolidate emissions into a single one is `count()`.
    It will count the number of emissions and emit through a Single once `onComplete()`
    is called, shown as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将发射合并成一个的最简单操作符是`count()`。它将计算发射的数量，并在调用`onComplete()`后通过`Single`发出，如下所示：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Like most reduction operators, this should not be used on an infinite `Observable`.
    It will hang up and work infinitely, never emitting a count or calling `onComplete()`.
    You should consider using `scan()` to emit a rolling count instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数缩减操作符一样，这个操作符不应该用在无限`Observable`上。它将挂起并无限期地工作，永远不会发出计数或调用`onComplete()`。你应该考虑使用`scan()`来发出滚动计数。
- en: reduce()
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reduce()
- en: 'The `reduce()` operator is syntactically identical to `scan()`, but it only
    emits the final accumulation when the source calls `onComplete()`. Depending on
    which overload you use, it can yield `Single` or `Maybe`. If you want to emit
    the sum of all integer emissions, you can take each one and add it to the rolling
    total. But it will only emit once it is finalized:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`操作符在语法上与`scan()`相同，但它只在源调用`onComplete()`时才发出最终的累积。根据你使用的重载，它可以产生`Single`或`Maybe`。如果你想发出所有整数发射的总和，你可以将每个值加到滚动总和中。但只有在最终确定后才会发出：'
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Similar to `scan()`, there is a seed argument that you can provide that will
    serve as the initial value to accumulate on. If we wanted to turn our emissions
    into a single comma-separated value string, we could use `reduce()` like this,
    shown as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与`scan()`类似，你可以提供一个种子参数，它将作为累积的初始值。如果我们想将我们的发射转换为单个逗号分隔的值字符串，我们可以像下面这样使用`reduce()`：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We provided an empty string as our seed value, and we maintain a rolling concatenation
    total and keep adding to it. We prevent a preceding comma using a ternary operator
    to check whether the `total` is the seed value and returning an empty string instead
    of a comma if it is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个空字符串作为我们的种子值，并保持一个滚动连接总和，并继续添加到它。我们使用三元运算符来防止前面的逗号，检查`total`是否是种子值，如果是，则返回一个空字符串而不是逗号。
- en: Your seed value should be immutable, such as an integer or string. Bad side-effects
    can happen if it is mutable, and you should use `collect()` (or `seedWith()`)
    for these cases, which we will cover in a moment. For instance, if you want to
    reduce `T` emissions into a collection, such as `List<T>`, use `collect()` instead
    of `reduce()`. Using `reduce()` will have an undesired side-effect of using the
    same list for each subscription, rather than creating a fresh, empty one each
    time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您的种子值应该是不可变的，例如整数或字符串。如果它是可变的，可能会发生不良副作用，您应该使用`collect()`（或`seedWith()`）来处理这些情况，我们将在稍后介绍。例如，如果您想将`T`发射减少到一个集合中，例如`List<T>`，请使用`collect()`而不是`reduce()`。使用`reduce()`将产生一个不期望的副作用，即每次订阅都使用相同的列表，而不是每次都创建一个新的、空的列表。
- en: all()
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: all()
- en: 'The `all()` operator verifies that each emission qualifies with a specified
    condition and return a `Single<Boolean>`. If they all pass, it will emit `True`.
    If it encounters one that fails, it will immediately emit `False`. In the following
    code snippet, we emit a test against six integers, verifying that they all are
    less than `10`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`运算符验证每个发射是否符合指定的条件，并返回一个`Single<Boolean>`。如果它们都通过，它将发出`True`。如果它遇到一个失败的，它将立即发出`False`。在以下代码片段中，我们发出对六个整数的测试，验证它们是否都小于`10`：'
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When the `all()` operator encountered `11`, it immediately emitted `False` and
    called `onComplete()`. It did not even get to `2` or `14` because that would be
    unnecessary work. It already found an element that fails the entire test.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到`all()`运算符的`11`时，它立即发出`False`并调用`onComplete()`。它甚至没有到达`2`或`14`，因为这将是多余的工作。它已经找到了一个不符合整个测试条件的元素。
- en: If you call `all()` on an empty `Observable`, it will emit true due to the principle
    of vacuous truth. You can read more about vacuous truth on Wikipedia at [https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个空的`Observable`上调用`all()`，它将由于空值真原则而发出`true`。您可以在维基百科上了解更多关于空值真的信息：[https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth)。
- en: any()
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: any()
- en: The `any()` method will check whether at least one emission meets a specific
    criterion and return a `Single<Boolean>`. The moment it finds an emission that
    qualifies, it will emit true and then call `onComplete()`. If it processes all
    emissions and finds that they all are false, it will emit false and call `onComplete()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()`方法将检查至少有一个发射满足特定标准，并返回一个`Single<Boolean>`。一旦它找到一个符合条件的发射，它将发出`true`然后调用`onComplete()`。如果它处理了所有发射并发现它们都是`false`，它将发出`false`并调用`onComplete()`。'
- en: 'In the following code snippet, we emit four date strings, convert them into
    `LocalDate` emissions, and test for any that are in the month of June or later:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们发出四个日期字符串，将它们转换为`LocalDate`发射，并测试其中是否有在六月或之后的月份：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When it encountered the `2016-09-12` date, it immediately emitted true and called
    `onComplete()`. It did not proceed to process `2016-04-03`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当它遇到日期`2016-09-12`时，它立即发出`true`并调用`onComplete()`。它没有继续处理`2016-04-03`。
- en: If you call `any()` on an empty `Observable`, it will emit false due to the
    principle of vacuous truth. You can read more about vacuous truth on Wikipedia
    at [https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个空的`Observable`上调用`any()`，它将由于空值真原则而发出`false`。您可以在维基百科上了解更多关于空值真的信息：[https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth)。
- en: contains()
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: contains()
- en: The `contains()` operator will check whether a specific element (based on the
    `hashCode()/equals()` implementation) ever emits from an `Observable`. It will
    return a `Single<Boolean>` that will emit true if it is found and false if it
    is not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains()`运算符将检查一个特定的元素（基于`hashCode()/equals()`实现）是否曾从`Observable`中发出。它将返回一个`Single<Boolean>`，如果找到则发出`true`，如果没有找到则发出`false`。'
- en: 'In the following code snippet, we emit the integers `1` through `10000`, and
    we check whether the number `9563` is emitted from it using `contains()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们发出整数`1`到`10000`，并使用`contains()`检查是否从中发出了数字`9563`：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can probably guess, the moment the element is found, it will emit true
    and call `onComplete()` and dispose of the operation. If the source calls `onComplete()`
    and the element was not found, it will emit `false`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许能猜到的，一旦找到元素，它将发出 true 并调用 `onComplete()` 以及处置操作。如果源调用 `onComplete()` 但元素未找到，它将发出
    `false`。
- en: Collection operators
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合操作符
- en: Collection operators will accumulate all emissions into a collection such as
    a list or map and then emit that entire collection as a single emission. Collection
    operators are another form of reducing operators since they consolidate emissions
    into a single one. We will cover them separately since they are a significant
    category on their own, though.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作符会将所有发射累积到一个集合，如列表或映射中，然后作为单个发射发出整个集合。集合操作符是减少操作符的另一种形式，因为它们将发射合并成一个。我们将单独介绍它们，因为它们是一个重要的类别。
- en: Note that you should avoid reducing emissions into collections for the sake
    of it. It can undermine the benefits of reactive programming where items are processed
    in a beginning-to-end, one-at-a-time sequence. You only want to consolidate emissions
    into collections when you are logically grouping them in some way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该避免仅仅为了将发射减少到集合中。这可能会削弱反应式编程的好处，在反应式编程中，项目是按顺序、逐个处理的。你只应该在逻辑上将发射以某种方式分组时才将发射合并到集合中。
- en: toList()
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`toList()`'
- en: 'A common collection operator is `toList()`. For a given `Observable<T>`, it
    will collect incoming emissions into a `List<T>` and then push that entire `List<T>` as
    a single emission (through `Single<List<T>>`). In the following code snippet,
    we collect string emissions into a `List<String>`. After the preceding `Observable` signals
    `onComplete()`, that list is pushed forward to the `observer` to be printed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的集合操作符是 `toList()`。对于一个给定的 `Observable<T>`，它将收集传入的发射到 `List<T>` 中，然后将整个
    `List<T>` 作为单个发射（通过 `Single<List<T>>`）推送出去。在下面的代码片段中，我们将字符串发射收集到 `List<String>`
    中。在先前的 `Observable` 发出 `onComplete()` 之后，该列表被推送到 `observer` 以供打印：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'By default, `toList()` will use a standard `ArrayList` implementation. You
    can optionally specify an integer argument to serve as the `capacityHint`, and
    that will optimize the initialization of ArrayList to expect roughly that number
    of items:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`toList()` 将使用标准的 `ArrayList` 实现。你可以选择指定一个整数参数作为 `capacityHint`，这将优化 ArrayList
    的初始化，以期望大约有那么多项：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you want to specify a different list implementation besides `ArrayList`,
    you can provide a `Callable` lambda as an argument to construct one. In the following
    code snippet, I provide a `CopyOnWriteArrayList` instance to serve as my list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要指定除了 `ArrayList` 之外的不同列表实现，你可以提供一个 `Callable` lambda 作为参数来构建一个。在下面的代码片段中，我提供了一个
    `CopyOnWriteArrayList` 实例作为我的列表：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you want to use Google Guava's immutable list, this is a little trickier
    since it is immutable and uses a builder. We will show you how to do this with `collect()`
    later in this section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 Google Guava 的不可变列表，这会稍微复杂一些，因为它是不可变的并且使用构建器。我们将在本节稍后通过 `collect()`
    展示如何做到这一点。
- en: toSortedList()
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`toSortedList()`'
- en: 'A different flavor of `toList()` is `toSortedList()`. This will collect the
    emissions into a list that sorts the items naturally based on their `Comparator`
    implementation. Then, it will emit that sorted `List<T>` forward to the `Observer`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`toList()` 的另一种风味是 `toSortedList()`。这将收集发射到根据其 `Comparator` 实现自然排序的列表中。然后，它将排序后的
    `List<T>` 推送到 `Observer`：'
- en: '[PRE64]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Like `sorted()`, you can provide a `Comparator` as an argument to apply a different
    sorting logic. You can also specify an initial capacity for the backing `ArrayList`
    just like `toList()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sorted()` 一样，你可以提供一个 `Comparator` 作为参数来应用不同的排序逻辑。你还可以指定与 `toList()` 一样的基础
    `ArrayList` 的初始容量。
- en: toMap() and toMultiMap()
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`toMap()` 和 `toMultiMap()`'
- en: For a given `Observable<T>`, the `toMap()` operator will collect emissions into
    `Map<K,T>`, where `K` is the key type derived off a lambda `Function<T,K>` argument
    producing the key for each emission.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个给定的 `Observable<T>`，`toMap()` 操作符将收集发射到 `Map<K,T>` 中，其中 `K` 是从 lambda `Function<T,K>`
    参数派生的键类型，为每个发射生成键。
- en: 'If we want to collect strings into `Map<Char,String>`, where each string is
    keyed off their first character, we can do it like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将字符串收集到 `Map<Char,String>` 中，其中每个字符串都根据其第一个字符作为键，我们可以这样做：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `s -> s.charAt(0)` lambda argument takes each string and derives the key
    to pair it with. In this case, we are making the first character of that string
    the key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`s -> s.charAt(0)` lambda 参数将每个字符串取出来，并从中导出键以与之配对。在这种情况下，我们正在将字符串的第一个字符作为键。'
- en: 'If we wanted to yield a different value other than the emission to associate
    with the key, we can provide a second lambda argument that maps each emission
    to a different value. We can, for instance, map each first letter key with the
    length of that string:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要产生与键关联的不同值，而不是发射值，我们可以提供一个第二个 lambda 参数，该参数将每个发射映射到不同的值。例如，我们可以将每个首字母键映射到该字符串的长度：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By default, `toMap()` will use `HashMap`. You can also provide a third lambda
    argument that provides a different map implementation. For instance, I can provide
    `ConcurrentHashMap` instead of `HashMap` :'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`toMap()` 将使用 `HashMap`。您也可以提供一个第三个 lambda 参数，以提供不同的映射实现。例如，我可以提供 `ConcurrentHashMap`
    而不是 `HashMap`：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that if I have a key that maps to multiple emissions, the last emission
    for that key is going to replace subsequent ones. If I make the string length
    the key for each emission, `Alpha` is going to be replaced by `Gamma`, which is
    going to be replaced by `Delta`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我有多个发射映射到键，则该键的最后发射将替换后续的发射。如果我将字符串长度作为每个发射的键，则 `Alpha` 将被 `Gamma` 替换，而
    `Gamma` 将被 `Delta` 替换：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you want a given key to map to multiple emissions, you can use `toMultiMap()`
    instead, which will maintain a list of corresponding values for each key. `Alpha`,
    `Gamma`, and `Delta` will then all be put in a list that is keyed off the length
    five:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望给定的键映射到多个发射，则可以使用 `toMultiMap()`，它将为每个键维护一个相应的值列表。`Alpha`、`Gamma` 和 `Delta`
    将被放入一个以长度五为键的列表中：
- en: '[PRE73]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: collect()
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: collect()
- en: 'When none of the collection operators have what you need, you can always use
    the `collect()` operator to specify a different type to collect items into. For
    instance, there is no `toSet()` operator to collect emissions into a `Set<T>`,
    but you can quickly use `collect()` to effectively do this. You will need to specify
    two arguments that are built with lambda expressions: `initialValueSupplier`,
    which will provide a new `HashSet`for a new `Observer`, and `collector`, which
    specifies how each emission is added to that `HashSet`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有收集操作符满足您的需求时，您始终可以使用 `collect()` 操作符来指定一个不同的类型以收集项目。例如，没有 `toSet()` 操作符来收集到
    `Set<T>` 中的排放物，但您可以使用 `collect()` 快速有效地完成此操作。您需要指定两个由 lambda 表达式构建的参数：`initialValueSupplier`，它将为新的
    `Observer` 提供一个新的 `HashSet`，以及 `collector`，它指定了如何将每个发射添加到该 `HashSet` 中：
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now our `collect()` operator will emit a single `HashSet<String>` containing
    all the emitted values.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `collect()` 操作符将发出一个包含所有发出值的单个 `HashSet<String>`。
- en: Use `collect()` instead of `reduce()` when you are putting emissions into a
    mutable object, and you need a new mutable object seed each time. We can also
    use `collect()` for trickier cases that are not straightforward collection implementations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要将排放物放入可变对象中，并且每次都需要一个新的可变对象种子时，请使用 `collect()` 而不是 `reduce()`。我们还可以使用 `collect()`
    处理更复杂的情况，这些情况不是简单的集合实现。
- en: Say you added Google Guava as a dependency ([https://github.com/google/guava](https://github.com/google/guava))
    and you want to collect emissions into an `ImmutableList`. To create an `ImmutableList` ,
    you have to call its `builder()` factory to yield an `ImmutableList.Builder<T>`**.**
    You then call its `add()` method to put items in the builder, followed by a call
    to `build()`, which returns a sealed, final `ImmutableList<T>` that cannot be
    modified.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已将 Google Guava 作为依赖项添加 ([https://github.com/google/guava](https://github.com/google/guava))，并且您想要将排放物收集到一个
    `ImmutableList` 中。要创建一个 `ImmutableList`，您必须调用其 `builder()` 工厂方法以产生一个 `ImmutableList.Builder<T>`**。**
    然后，您调用其 `add()` 方法将项目放入构建器中，接着调用 `build()`，它返回一个密封的、最终的 `ImmutableList<T>`，该列表不能被修改。
- en: 'To collect emissions into `ImmutableList`, you can supply an `ImmutableList.Builder<T>`
    for your first lambda argument and then add each element through its `add()` method
    in the second argument. This will emit `ImmutableList.Builder<T>` once it is fully
    populated, and you can `map()` it to its `build()` call in order to emit an `ImmutableList<T>`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要将发射收集到 `ImmutableList` 中，你可以为第一个 lambda 参数提供一个 `ImmutableList.Builder<T>`，然后在第二个参数中通过其
    `add()` 方法添加每个元素。这将在其完全填充后发出 `ImmutableList.Builder<T>`，然后你可以将其 `map()` 到其 `build()`
    调用，以发出 `ImmutableList<T>`：
- en: '[PRE77]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE78]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Again, the `collect()` operator is helpful to collect emissions into any arbitrary
    type that RxJava does not provide out of the box.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`collect()` 操作符对于将发射收集到任何 RxJava 不直接提供的任意类型非常有用。
- en: Error recovery operators
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误恢复操作符
- en: Exceptions can occur in your `Observable` chain across many operators depending
    on what you are doing. We already know about the `onError()` event that is communicated
    down the `Observable` chain to the `Observer`. After that, the subscription terminates
    and no more emissions will occur. But sometimes, we want to intercept exceptions
    before they get to the `Observer` and attempt some form of recovery. We cannot
    necessarily pretend that the error never happened and expect emissions to resume,
    but we can attempt re-subscribing or switch to an alternate source `Observable`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `Observable` 链中，可能会因为你的操作而出现异常。我们已经知道 `onError()` 事件是沿着 `Observable` 链向下传递到
    `Observer` 的。在那之后，订阅终止，不会再有更多的发射发生。但有时，我们想在异常到达 `Observer` 之前拦截它们，并尝试某种形式的恢复。我们不一定假装错误从未发生并期望发射继续，但我们可以尝试重新订阅或切换到另一个来源的
    `Observable`。
- en: We can still do the former, just not with RxJava operators, which we will see
    shortly. If you find that the error recovery operators do not meet your needs,
    chances are you can compose them creatively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以这样做，只是不是使用 RxJava 操作符，我们很快就会看到。如果你发现错误恢复操作符不符合你的需求，那么很可能会以创造性的方式组合它们。
- en: 'For these examples, let''s divide each integer emission by 10, where one of
    the emissions is `0`. This will result in a "`/ by zero`" exception being emitted
    to the `Observer`, as shown in the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，让我们将每个整数发射量除以 10，其中一个发射量是 `0`。这将导致向 `Observer` 发射一个 "`/ by zero`" 异常，如下面的代码片段所示：
- en: '[PRE79]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: onErrorReturn() and onErrorReturnItem()
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onErrorReturn()` 和 `onErrorReturnItem()`'
- en: 'When you want to resort to a default value when an exception occurs, you can
    use `onErrorReturnItem()`. If we want to emit `-1` when an exception occurs, we
    can do it like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在发生异常时回退到默认值时，你可以使用 `onErrorReturnItem()`。如果我们想在发生异常时发出 `-1`，我们可以这样做：
- en: '[PRE81]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE82]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can also supply `Function<Throwable,T>` to dynamically produce the value
    using a lambda. This gives you access to `Throwable` , which you can use to determine
    the returned value as shown in the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供一个 `Function<Throwable,T>` 来动态地使用 lambda 生成值。这让你可以访问 `Throwable`，你可以用它来确定返回的值，如下面的代码片段所示：
- en: '[PRE83]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The placement of `onErrorReturn()` matters. If we put it before the `map()`
    operator, the error would not be caught because it happened after `onErrorReturn()`.
    To intercept the emitted error, it must be downstream from where the error occurred.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorReturn()` 的放置很重要。如果我们把它放在 `map()` 操作符之前，错误就不会被捕获，因为错误发生在 `onErrorReturn()`
    之后。为了拦截发出的错误，它必须在错误发生的地方下游。'
- en: 'Note that even though we emitted `-1` to handle the error, the sequence still
    terminated after that. We did not get the `3`, `2`, or `8` that was supposed to
    follow. If you want to resume emissions, you will just want to handle the error
    within the `map()` operator where the error can occur. You would do this in lieu
    of `onErrorReturn()` or `onErrorReturnItem()`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们发出了 `-1` 来处理错误，但序列在那之后仍然终止了。我们没有得到应该跟随的 `3`、`2` 或 `8`。如果你想恢复发射，你只需要在错误可能发生的
    `map()` 操作符内处理错误。你会这样做，而不是使用 `onErrorReturn()` 或 `onErrorReturnItem()`：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出如下：
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: onErrorResumeNext()
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onErrorResumeNext()`'
- en: Similar to `onErrorReturn()` and `onErrorReturnItem()`, `onErrorResumeNext()`
    is very similar. The only difference is that it accepts another `Observable` as
    a parameter to emit potentially multiple values, not a single value, in the event
    of an exception.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `onErrorReturn()` 和 `onErrorReturnItem()` 类似，`onErrorResumeNext()` 非常相似。唯一的区别是它接受另一个
    `Observable` 作为参数，在异常发生时发出可能多个值，而不是单个值。
- en: 'This is somewhat contrived and likely has no business use case, but we can
    emit three `-1` emissions in the event of an error:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点牵强，可能没有实际的应用场景，但我们可以错误发生时发出三个 `-1` 的发射项：
- en: '[PRE86]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段的输出如下：
- en: '[PRE87]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can also pass it `Observable.empty()` to quietly stop emissions in the event
    that there is an error and gracefully call the `onComplete()` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递它 `Observable.empty()` 来在发生错误时安静地停止发射，并优雅地调用 `onComplete()` 函数：
- en: '[PRE88]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段的输出如下：
- en: '[PRE89]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Similar to `onErrorReturn()`, you can provide a `Function<Throwable,Observable<T>>`
    lambda to produce an `Observable` dynamically from the emitted `Throwable`, as
    shown in the code snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `onErrorReturn()` 类似，你可以提供一个 `Function<Throwable,Observable<T>>` lambda 来从发出的
    `Throwable` 动态生成一个 `Observable`，如下面的代码片段所示：
- en: '[PRE90]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE91]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: retry()
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: retry()
- en: Another way to attempt recovery is to use the `retry()` operator, which has
    several parameter overloads. It will re-subscribe to the preceding `Observable`
    and, hopefully, not have the error again.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试恢复的另一种方法是使用 `retry()` 算子，它有几个参数重载。它将重新订阅前面的 `Observable`，并希望不再出现错误。
- en: 'If you call `retry()` with no arguments, it will resubscribe an infinite number
    of times for each error. You need to be careful with `retry()` as it can have
    chaotic effects. Using it with our example will cause it to emit these integers
    infinitely and repeatedly:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不带参数调用 `retry()`，它将为每个错误无限次地重新订阅。你需要小心使用 `retry()`，因为它可能会产生混乱的效果。使用我们的示例将导致它无限次地重复发射这些整数：
- en: '[PRE92]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段的输出如下：
- en: '[PRE93]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'It might be safer to specify a fixed number of times to `retry()` before it
    gives up and just emits the error to the `Observer`. In the following code snippet,
    we will only retry two times:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在放弃并仅向 `Observer` 发出错误之前指定一个固定的重试次数可能更安全。在下面的代码片段中，我们只会重试两次：
- en: '[PRE94]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段的输出如下：
- en: '[PRE95]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You can also provide `Predicate<Throwable>` or `BiPredicate<Integer,Throwable>`
    to conditionally control when `retry()` is attempted. The `retryUntil()` operator
    will allow retries while a given `BooleanSupplier` lambda is false. There is also
    an advanced `retryWhen()` operator that supports advanced composition for tasks
    such as delaying retries.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供 `Predicate<Throwable>` 或 `BiPredicate<Integer,Throwable>` 来有条件地控制何时尝试
    `retry()`。`retryUntil()` 算子将允许在给定的 `BooleanSupplier` lambda 为 `false` 时进行重试。还有一个高级的
    `retryWhen()` 算子，它支持高级的任务组合，例如延迟重试。
- en: Action operators
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动算子
- en: To close this chapter, we will cover some helpful operators that can assist
    in debugging as well as getting visibility into an `Observable` chain. These are
    the action or `doOn` operators.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们将介绍一些有助于调试以及了解 `Observable` 链的辅助算子。这些是动作或 `doOn` 算子。
- en: doOnNext(), doOnComplete(), and doOnError()
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doOnNext(), doOnComplete(), 和 doOnError()
- en: These three operators: `doOnNext()`, `doOnComplete()`, and `doOnError()` are
    like putting a mini `Observer` right in the middle of the `Observable` chain.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个算子：`doOnNext()`、`doOnComplete()` 和 `doOnError()` 就像在 `Observable` 链的中间放置了一个迷你
    `Observer`。
- en: 'The `doOnNext()` operator allows you to peek at each emission coming out of
    an operator and going into the next. This operator does not affect the operation
    or transform the emissions in any way. We just create a side-effect for each event
    that occurs at that point in the chain. For instance, we can perform an action
    with each string before it is mapped to its length. In this case, we will just
    print them by providing a `Consumer<T>` lambda:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`doOnNext()` 算子允许你查看从算子中发出并进入下一个算子的每个发射项。此算子不会以任何方式影响操作或转换发射项。我们只为链中该点的每个事件创建副作用。例如，我们可以在将字符串映射到其长度之前对每个字符串执行操作。在这种情况下，我们只需通过提供一个
    `Consumer<T>` lambda 来打印它们：'
- en: '[PRE96]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE97]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can also leverage `doAfterNext()`, which performs the action after the emission
    is passed downstream rather than before.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用 `doAfterNext()`，它在发射传递到下游之后执行操作，而不是在之前。
- en: The `onComplete()` operator allows you to fire off an action when `onComplete()`
    is called at the point in the `Observable` chain. This can be helpful in seeing
    which points of the `Observable` chain have completed, as shown in the following
    code snippet**:**
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`onComplete()` 操作符允许你在 `Observable` 链中的该点调用 `onComplete()` 时触发一个操作。这有助于查看 `Observable`
    链的哪些点已经完成，如下面的代码片段所示：**'
- en: '[PRE98]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE99]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And, of course, `onError()` will peek at the error being emitted up the chain,
    and you can perform an action with it. This can be helpful to put between operators
    to see which one is to blame for an error:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`onError()` 会查看正在向上传递的错误，并且你可以用它执行一个操作。这有助于在操作符之间放置，以查看哪个操作符导致了错误：
- en: '[PRE100]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE101]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We used `doOnError()` in two places to see where the error first appeared. Since
    we did not see `Source failed!` printed but we saw `Division failed!`, we can
    deduct that the error occurred in the `map()` operator.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个地方使用了 `doOnError()` 来查看错误首次出现的位置。由于我们没有看到打印出 `Source failed!`，而是看到了 `Division
    failed!`，我们可以推断错误发生在 `map()` 操作符中。
- en: Use these three operators together to get an insight into what your `Observable`
    operation is doing or to quickly create side-effects.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个操作符一起，可以深入了解你的 `Observable` 操作正在做什么，或者快速创建副作用。
- en: You can specify all three actions for `onNext()`, `onComplete()`, and `onError()`
    using `doOnEach()` as well. The `subscribe()` method accepts these three actions
    as lambda arguments or an entire `Observer<T>`. It is like putting `subscribe()`
    right in the middle of your Observable chain! There is also a `doOnTerminate()`
    operator, which fires for an `onComplete()` or `onError()` event.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `doOnEach()` 来指定 `onNext()`、`onComplete()` 和 `onError()` 的所有三个操作。`subscribe()`
    方法接受这三个操作作为 lambda 参数或整个 `Observer<T>`。这就像在 `Observable` 链的中间放置了 `subscribe()`！还有一个
    `doOnTerminate()` 操作符，它在 `onComplete()` 或 `onError()` 事件发生或被下游销毁时触发。
- en: doOnSubscribe() and doOnDispose()
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doOnSubscribe() 和 doOnDispose()
- en: Two other helpful action operators are `doOnSubscribe()` and `doOnDispose()`.
    The `doOnSubscribe()` fires a specific `Consumer<Disposable>` the moment subscription
    occurs at that point in the `Observable` chain. It provides access to the Disposable
    in case you want to call `dispose()` in that action. The `doOnDispose()` operator
    will perform a specific action when disposal is executed at that point in the
    `Observable` chain.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的操作符是 `doOnSubscribe()` 和 `doOnDispose()`。`doOnSubscribe()` 在 `Observable`
    链中的订阅发生时立即触发一个特定的 `Consumer<Disposable>`。它提供了对 Disposable 的访问，以便你在该操作中调用 `dispose()`。`doOnDispose()`
    操作符将在 `Observable` 链中的该点执行销毁时执行特定操作。
- en: 'We use both operators to print when subscription and disposal occur, as shown
    in the following code snippet. As you can predict, we see the subscribe event
    fire off first. Then, the emissions go through, and then disposal is finally fired:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这两个操作符来打印订阅和销毁发生的时间，如下面的代码片段所示。正如你所预测的，我们首先看到订阅事件被触发。然后，发射通过，最后销毁事件被触发：
- en: '[PRE102]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE103]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that `doOnDispose()` can fire multiple times for redundant disposal requests
    or not at all if it is not disposed of in some form or another. Another option
    is to use the `doFinally()` operator, which will fire after either `onComplete()`
    or `onError()` is called or disposed of by the downstream.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`doOnDispose()` 可能会因为冗余的销毁请求而多次触发，或者如果没有以某种形式销毁，则根本不会触发。另一个选择是使用 `doFinally()`
    操作符，它将在 `onComplete()` 或 `onError()` 被调用或由下游销毁后触发。
- en: doOnSuccess()
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doOnSuccess()
- en: 'Remember that `Maybe` and `Single` types do not have an `onNext()` event but
    rather an `onSuccess()` operator to pass a single emission. Therefore, there is
    no `doOnNext()` operator on either of these types, as observed in the following
    code snippet, but rather a `doOnSuccess()` operator. Its usage should effectively
    feel like `doOnNext()`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Maybe` 和 `Single` 类型没有 `onNext()` 事件，而是有一个 `onSuccess()` 操作符来传递单个发射。因此，这两种类型都没有
    `doOnNext()` 操作符，如下面的代码片段所示，而是有一个 `doOnSuccess()` 操作符。它的使用应该感觉就像 `doOnNext()`：
- en: '[PRE104]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE105]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of ground in this chapter, and hopefully by now, you are starting
    to see that RxJava has a lot of practical use. We covered various operators that
    suppress and transform emissions as well as reduce them to a single emission in
    some form. You learned how RxJava provides robust ways to recover from errors
    as well as get visibility into what `Observable` chains are doing with action
    operators.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，并且希望到现在为止，你已经开始看到RxJava有很多实际的应用。我们介绍了各种抑制和转换发射以及将它们以某种形式减少到单个发射的操作符。你学习了RxJava如何通过操作符提供强大的错误恢复方式以及了解`Observable`链如何操作。
- en: If you want to learn more about RxJava operators, there are many resources online.
    Marble diagrams are a popular form of Rx documentation, visually showing how each
    operator works. The *rxmarbles.com* ([http://rxmarbles.com](http://rxmarbles.com))
    site is a popular, interactive web app that allows you to drag marble emissions
    and see the affected behavior with each operator. There is also an *RxMarbles*
    Android App ([https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles](https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles))
    that you can use on your Android device. Of course, you can also see a comprehensive
    list of operators on the ReactiveX website ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于RxJava操作符的信息，网上有很多资源。Marble图是Rx文档的一种流行形式，可以直观地展示每个操作符的工作方式。*rxmarbles.com*（[http://rxmarbles.com](http://rxmarbles.com)）是一个流行的、交互式的网络应用，允许你拖动Marble发射并查看每个操作符影响的行为。还有一个*RxMarbles*安卓应用（[https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles](https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles)），你可以在你的安卓设备上使用。当然，你还可以在ReactiveX网站上看到操作符的完整列表（[http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)）。
- en: Believe it or not, we have barely gotten started. This chapter only covered
    the basic operators. In the coming chapters, we will cover operators that perform
    powerful behaviors, such as concurrency and multicasting. But before we do that,
    let's move on to operators that combine Observables.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们才刚刚开始。本章只涵盖了基本操作符。在接下来的章节中，我们将介绍执行强大行为的操作符，例如并发和多播。但在我们这样做之前，让我们继续介绍那些组合Observables的操作符。
