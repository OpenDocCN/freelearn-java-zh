- en: Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.现代应用程序的基本属性 - 异步和并发
- en: 'Availability and performance are two words that often characterize the requirements
    found behind most commercial software. As the volume of processed information
    continues to grow together with the rise of social networks and added complexity
    of online services, web servers are now increasingly confronted with heavy loads
    and higher numbers of concurrent requests. In this chapter, we will explore different
    ways to deal with better performance and scalability by covering the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性和性能是两个经常用来描述大多数商业软件背后需求的词汇。随着处理的信息量随着社交网络的兴起和在线服务的复杂性增加而不断增长，Web服务器现在越来越多地面临沉重的负载和更高的并发请求数量。在本章中，我们将通过涵盖以下主题来探讨不同的方法，以实现更好的性能和可伸缩性：
- en: The Async library, a new way to simplify asynchronous code, including examples
    of web services composition
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async库，一种简化异步代码的新方法，包括Web服务组合的示例
- en: Akka, a toolkit and runtime that simplifies the building of concurrent, distributed,
    and fault-tolerant applications based on the actor paradigm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka，一个基于actor范例简化构建并发、分布式和容错应用的工具包和运行时环境
- en: The pillars of Concurrency
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发的支柱
- en: Concurrency and asynchrony are the techniques that most programming languages
    use to enhance response time and scalability, and Java is no exception. Asynchronous
    method calls is a technique by which the caller of a potentially time-consuming
    computation does not wait for a response, but rather continues to proceed with
    other code while the computation is ongoing. The caller will be notified once
    running has completed, receiving notification of either a successful result or
    a failure message.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和异步是大多数编程语言用来增强响应时间和可伸缩性的技术，Java也不例外。异步方法调用是一种技术，调用者对可能耗时的计算不需要等待响应，而是在计算进行的同时继续执行其他代码。一旦运行完成，调用者将被通知，无论是成功的结果还是失败的消息。
- en: The traditional way to deal with asynchronous code in Java has mostly been through
    the registration of callbacks, that is, placeholders that are called upon completion.
    Complexity tends to increase when working with asynchronous code as the sequence
    of execution is not deterministic, that is, the order of execution is not guaranteed.
    Executing code concurrently is, therefore, more difficult to test since it may
    not produce the same result on successive invocations. Furthermore, as callbacks
    are not composable (which means that they can't be chained and combined in a flexible
    way), it can be cumbersome to mix several asynchronous computations together to
    achieve more advanced scenarios, resulting in the well-known problem of callback
    hell when such projects increase in size (cases where the complexity is at such
    a high level that it is difficult to maintain and guarantee the proper execution
    of a piece of code).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中处理异步代码的传统方式主要是通过注册回调函数，即当任务完成时被调用的占位符。当处理异步代码时，由于执行顺序不是确定的，即执行顺序没有保证，因此复杂性往往会增加。因此，并发执行代码更难测试，因为连续调用可能不会产生相同的结果。此外，由于回调函数不可组合（这意味着它们不能以灵活的方式链式组合），将多个异步计算混合在一起以实现更高级的场景可能会变得很繁琐，从而导致在项目规模增加时出现的“回调地狱”问题（复杂性如此之高，以至于难以维护和保证代码的正确执行）。
- en: Concurrency is also encountered when code is executed on multiple cores. Recent
    hardware architectures are now embedding several cores into the same machine as
    a way to continue achieving better performance when the minimal physical size
    of transistors has been reached.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码在多个核心上执行时，也会遇到并发问题。最近的硬件架构现在将多个核心嵌入到同一台机器中，作为在晶体管的最小物理尺寸达到极限时继续实现更好性能的一种方式。
- en: Another consequence of dealing with concurrent code is that multiple threads
    of execution can get into conflicts when trying to access the same resources.
    Mutable state in a program, which is not protected against shared access, has
    a higher risk of being incorrect. Making sure that the concurrent code executes
    correctly often comes at the cost of increased complexity. Java thread synchronization
    mechanisms, for example, using locks, have led to solutions that are difficult
    to understand and maintain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 处理并发代码的另一个后果是，当尝试访问相同资源时，多个执行线程可能会发生冲突。程序中的可变状态，如果没有保护共享访问，有更高的风险出现错误。确保并发代码正确执行通常需要付出增加复杂性的代价。例如，Java线程同步机制，如使用锁，导致了难以理解和维护的解决方案。
- en: The functional approach of Scala striving for immutability is a first step towards
    easier concurrency. **Scala Improvement** **Process** (**SIP**), which can be
    seen as the equivalent to the Java JSR process in Scala, has proposed an SIP concerning
    *SIP-14-Futures and Promises*. These notions are not new as they have already
    been used in many other languages when writing concurrent code, but the new proposal
    tries to merge the various Scala implementations of Futures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Scala追求不可变性的函数式方法是迈向更易并发处理的第一步。**Scala改进流程**（**SIP**），在Scala中可以看作是Java JSR流程的等价物，已经提出了一项关于
    *SIP-14-Futures and Promises* 的提案。这些概念并不新颖，因为它们在编写并发代码时已经被许多其他语言使用过，但新的提案试图合并Scala中Futures的各种实现。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Futures and Promises are objects through which you can later retrieve the result
    of some asynchronous execution after it finishes. To learn more, visit [http://en.wikipedia.org/wiki/Futures_and_promises](http://en.wikipedia.org/wiki/Futures_and_promises).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Futures和Promises是通过它们可以检索异步执行结果的某些对象。要了解更多信息，请访问[http://en.wikipedia.org/wiki/Futures_and_promises](http://en.wikipedia.org/wiki/Futures_and_promises)。
- en: 'As stated in *SIP-14-Futures and Promises*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *SIP-14-Futures and Promises* 所述：
- en: Futures provide a nice way to reason about performing many operations in parallel—in
    an efficient and non-blocking way.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Futures提供了一种很好的方式来推理并行执行多个操作——以高效和非阻塞的方式进行。
- en: From this proposal, an implementation has been created, which is now the basis
    of many Scala libraries that deal with concurrent and asynchronous code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个提案中，创建了一个实现，现在它是许多处理并发和异步代码的Scala库的基础。
- en: The Async library – SIP-22-Async
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async库 – SIP-22-Async
- en: 'In [Chapter 7](ch07.html "Chapter 7. Working with Integration and Web Services"),
    *Working with Integration and Web Services*, we have briefly seen how to call
    asynchronous web services that return a `Future` object. The aim of Async is to
    simplify asynchronous code by providing a couple of powerful constructs to deal
    with asynchronous code blocks and, in particular, combining several such blocks.
    It consists of only two constructs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。使用集成和Web服务") *使用集成和Web服务* 中，我们简要地看到了如何调用返回`Future`对象的异步Web服务。Async的目标是通过提供一些强大的结构来简化异步代码，特别是处理多个异步代码块，特别是组合多个这样的块。它只包含两个结构：
- en: '`async { <expression> }`: In this construct, `<expression>` is the code to
    be executed asynchronously.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async { <expression> }`：在这个结构中，`<expression>`是异步执行的代码。'
- en: '`await { <expression returning a Future> }`: This construct is included in
    an `async` block. It suspends the execution of the enclosing `async` block until
    the argument `Future` is completed.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await { <expression returning a Future> }`：这个结构包含在一个`async`块中。它暂停包含的`async`块的执行，直到参数`Future`完成。'
- en: 'An interesting characteristic of the whole `async`/`await` mechanism is that
    it is totally nonblocking. Although it is not really required to understand how
    `async`/`await` works, the exact signature of the two methods `async[]` and `await[]`
    are given for reference, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await`机制的一个有趣特点是它是完全非阻塞的。尽管理解`async`/`await`的工作原理并非必需，但两个方法`async[]`和`await[]`的确切签名如下供参考：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`T` refers to arbitrary types (such as `Int` or `String`) or container types
    (such as `List` or `Map`), which is how we describe generic types in Scala. Although
    we will not cover too much programming with generic types, which has already been
    extensively described in other books such as *Programming in Scala,* *Artima*
    by *Martin Odersky*, *Lex Spoon* and *Bill Venners*, it is important to understand
    that they exist and they form part of the core of the Scala language.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`代表任意类型（如`Int`或`String`）或容器类型（如`List`或`Map`），这是我们描述Scala中泛型类型的方式。尽管我们不会过多地介绍泛型编程，这在其他书籍如*Programming
    in Scala*、*Artima*由*Martin Odersky*、*Lex Spoon*和*Bill Venners*中已经广泛描述，但了解它们存在并且是Scala语言核心部分是很重要的。'
- en: 'To better understand what Async is all about, we will use the examples that
    we can run in the REPL. Create a new `Play` project by running the command `>
    play new ch8samples` and choose, of course, Scala as the language used for the
    project. Once the project is created, add the Async library as a dependency by
    adding one line inside the `build.sbt` file, which now looks like the following
    lines:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Async是什么，我们将使用REPL中可以运行的示例。通过运行命令`> play new ch8samples`创建一个新的`Play`项目，并当然选择Scala作为项目使用的语言。一旦项目创建完成，通过在`build.sbt`文件中添加一行来将Async库作为依赖项添加，现在文件看起来如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can run the REPL console, as usual, in a terminal window by entering the
    following command from the root directory of the project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在终端窗口中运行REPL控制台，就像往常一样，通过在项目的根目录中输入以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, we need to perform some imports, which are as shown in the following
    command lines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要执行一些导入，如下面的命令行所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, for a thread pool, an execution context is needed to handle how and
    when the asynchronous computation should be executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于线程池，需要一个执行上下文来处理异步计算应该如何以及何时执行。
- en: 'Second, we can specify an asynchronous computation by enclosing the computation
    into an `async` block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们可以通过将计算封装在一个`async`块中来指定异步计算：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see that the type of the result is `Option[scala.util.Try[Int]]`,
    recollect the brief discussion on the `Try` class in [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*. We learned that it builds upon an `Either`
    class that can take the value `Success` or `Failure` that corresponds respectively
    to the `Left` and `Right` values of the `Either` class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果类型是`Option[scala.util.Try[Int]]`，回顾一下[第2章](ch02.html "第2章. 代码集成")中关于`Try`类的简要讨论，*代码集成*。我们了解到它基于一个可以取`Success`或`Failure`值的`Either`类，分别对应于`Either`类的`Left`和`Right`值。
- en: In our case, the computation was quite immediate and resulted in the success
    value of `6`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，计算非常迅速，并得到了成功值`6`。
- en: 'Let us make the computation that takes a longer time (for example, 10 seconds),
    as shown in the following command lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个耗时较长的计算（例如，10秒钟），如下面的命令行所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, during those 10 seconds, we access its result value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这10秒钟内，我们访问其结果值：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will get the answer `None`, which is what we expect, as the computation is
    not completed yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到`None`的答案，这正是我们预期的，因为计算尚未完成。
- en: 'If we wait for 10 seconds and perform the same query again, we''ll get our
    result:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待10秒钟并再次执行相同的查询，我们将得到我们的结果：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that once a Future is completed and given a value, it cannot be modified.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦Future完成并赋予了一个值，它就不能被修改。
- en: 'An alternative to polling for the result is to be informed or execute some
    code when the Future is completed. We can do that by invoking the `onComplete`
    method, immediately after rerunning our computation, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取结果的方法是在Future完成时得到通知或执行一些代码。我们可以在重新运行我们的计算后立即调用`onComplete`方法，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In other words, while the computation is not finished, we can proceed executing
    other statements:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在计算未完成时，我们可以继续执行其他语句：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Eventually, we will see the value `6` on the screen, once the time of 10 seconds
    elapses:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当10秒钟的时间过去后，我们将在屏幕上看到值`6`：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So far, we've seen that the `async` method performs the same way as the `future`
    method, which is part of the `scala.concurrent` package; for this reason, we could
    just replace `async` with `future`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到`async`方法与`future`方法的表现相同，后者是`scala.concurrent`包的一部分；因此，我们可以直接用`future`替换`async`。
- en: The preferred way is to use `async` in conjunction with `await`. The `await`
    method is taking a `Future` object as an input argument. It wraps the rest of
    the `async,` blocks in a closure and passes it as a callback on completion of
    the `Future` object we're waiting on (the one we passed as argument). Although
    `await` will wait for the invoked `Future` object until it is completed, the whole
    `async`/`await` execution is nonblocking, which means we can compose the `Future`
    objects in a totally nonblocking way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 优先选择的方式是结合使用`async`和`await`。`await`方法接受一个`Future`对象作为输入参数。它将`async`块剩余部分包装在一个闭包中，并在等待的`Future`对象（我们作为参数传递的那个）完成时将其作为回调传递。尽管`await`会等待被调用的`Future`对象直到其完成，但整个`async`/`await`执行是非阻塞的，这意味着我们可以以完全非阻塞的方式组合`Future`对象。
- en: 'Let''s illustrate composing two computations where the input of one depends
    on the output of the other. A typical example is the invocation of two web services
    to query a weather forecast service: one that returns our current geo location
    and the other that needs our position (coordinates or the city name). The following
    lines of command explain the invocation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过组合两个计算来举例说明，其中一个的计算输入依赖于另一个的计算输出。一个典型的例子是调用两个网络服务来查询天气预报服务：一个返回我们的当前地理位置，另一个需要我们的位置（坐标或城市名称）。以下命令行解释了调用过程：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait for a couple of seconds to make sure that the web service `Future` gets
    completed, then press *Enter*; you''ll see the following result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟以确保网络服务`Future`完成，然后按*Enter*；你会看到以下结果：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first service returns the XML text where we extracted only the `City` element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个服务返回我们提取的仅包含`City`元素的XML文本。
- en: 'Now, let''s try a second service from the [http://openweathermap.org](http://openweathermap.org)
    website, a useful resource for testing web service code in general. The following
    web service call returns the weather as a JSON message, given a particular location
    (we will use a hardcoded `Paris` city here to first experiment with this service
    alone without composing the two services):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试从[http://openweathermap.org](http://openweathermap.org)网站获取第二个服务，这是一个用于测试通用网络服务代码的有用资源。以下网络服务调用返回特定位置的天气作为JSON消息（我们将在这里使用硬编码的`Paris`城市来单独实验这个服务，而不组合两个服务）：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait for a couple of seconds to make sure that the web service `Future` gets
    completed, then enter the following statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟以确保网络服务`Future`完成，然后输入以下语句：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Combining web services
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合网络服务
- en: We are now ready to combine two services using `async`/`await`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`async`/`await`组合两个服务。
- en: 'Let''s copy and paste the following lines at once in the REPL. To do this,
    we can use the convenient `:paste` command of the REPL, as shown in the following
    command lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次性在REPL中复制粘贴以下行。为此，我们可以使用REPL的方便的`:paste`命令，如下所示：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What happens in this code is that the `await` construct ensures that the location
    city will be available to the weather service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中发生的情况是，`await`构造确保了位置城市对天气服务可用。
- en: Combining services without await
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用`await`组合服务
- en: 'If we do not put an `await` method around the `futureLocation` web service
    call while defining the `futureWeather2` variable, we get a different answer.
    This is because, in such a case, the `Future` object that contains the location
    service answer is not yet populated when querying for the weather service. You
    can verify this behavior by copying and pasting the three following statements
    at once into the REPL (assuming the `locationURL` variable is still valid, it
    was created earlier while introducing the location service):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在定义`futureWeather2`变量时没有在`futureLocation`网络服务调用周围放置`await`方法，我们会得到不同的答案。这是因为在这种情况下，包含位置服务答案的`Future`对象在查询天气服务时还没有填充。你可以通过一次性复制粘贴以下三个语句来验证这种行为（假设`locationURL`变量仍然有效，它是在介绍位置服务时创建的）：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the output shows that the city was not entered correctly into the
    weather service.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出显示城市没有正确输入到天气服务中。
- en: Getting started with Akka
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Akka
- en: '**Akka** is a toolkit to simplify writing concurrent and distributed applications,
    tasks that can be complex to achieve, as we described at the beginning of this
    chapter. As Akka is largely documented both by a number of books as well as extensive
    online documentation, our goal here is mostly to experiment with the technology.
    We will see how to elegantly write Scala code to solve problems that might otherwise
    be error-prone and hard to understand if written in more conventional ways such
    as thread synchronization and other languages such as Java. Akka is written in
    Scala, but provides to both Java and Scala APIs.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Akka**是一个工具包，用于简化编写并发和分布式应用程序，这些任务可能非常复杂，正如我们在本章开头所描述的。由于Akka既有大量书籍的详细文档，也有广泛的在线文档，我们的目标主要是进行技术实验。我们将看到如何优雅地编写Scala代码来解决那些如果以更传统的线程同步或其他语言（如Java）编写可能会出错且难以理解的问题。Akka是用Scala编写的，但同时也提供了Java和Scala的API。'
- en: Understanding the Actor model
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Actor模型
- en: Akka relies on the Actor paradigm to create concurrent applications. The Actor
    model has already been introduced decades ago in the original paper of Carl Hewitt,
    Peter Bishop, and Richard Steiger entitled *A Universal Modular Actor Formalism
    for Artificial Intelligence*, *1973*, *IJCAI*. Erlang is an example of language
    that has been made famous using this model of computation and achieved very good
    scalability and reliability figures (the well-known nine nines of availability).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Akka依赖于Actor范式来创建并发应用程序。Actor模型早在卡尔·休伊特（Carl Hewitt）、彼得·毕晓普（Peter Bishop）和理查德·斯蒂格（Richard
    Steiger）撰写的原始论文《为人工智能提供一个通用的模块化Actor形式主义》（*A Universal Modular Actor Formalism
    for Artificial Intelligence*），发表于1973年的IJCAI会议上就已经被介绍。Erlang是使用这种计算模型而闻名的一种语言，并且实现了非常好的可扩展性和可靠性指标（著名的九九可用性）。
- en: Without going too much into details, we can say that the Actor model is a model
    based on message passing rather than method calls. Each unit of computation, called
    **actor**, encapsulates its own behavior and communicates with other actors through
    asynchronous immutable messages. It is quite straightforward to reason about actor
    systems since they mimic the way humans communicate, exchanging immutable messages
    between each other. Since the footprint of actors is very minimal compared to
    threads, and state is not shared, they are very suited to writing concurrent and
    distributed applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，我们可以这样说，Actor模型是一个基于消息传递而不是方法调用的模型。每个计算单元，称为**actor**，封装了自己的行为，并通过异步不可变消息与其他actor进行通信。由于actor的足迹与线程相比非常小，并且状态不共享，因此非常适合编写并发和分布式应用程序。
- en: In the gold mine of Typesafe activator templates, a number of projects concerning
    Akka are available. Let's dig into a couple of them to better understand how to
    make programs using Akka actors. First, we can take a look at the `hello-akka`
    project to get an idea on how to run a simple actor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Typesafe activator模板的宝库中，有许多与Akka相关的项目可供选择。让我们深入探讨其中几个，以更好地理解如何使用Akka actors编写程序。首先，我们可以查看`hello-akka`项目，以了解如何运行一个简单的actor。
- en: If you haven't got the Typesafe activator in place, follow the instructions
    from [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*, to create the sample project associated with the `hello-akka`
    template. Once imported into Eclipse, we may start looking at the main class `HelloAkkaScala.scala`
    in the default package of the `Scala src` directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Typesafe activator，请按照[第3章](ch03.html "第3章。理解Scala生态系统")中的说明，即《理解Scala生态系统》，来创建与`hello-akka`模板相关的示例项目。一旦导入到Eclipse中，我们就可以开始查看`Scala
    src`目录默认包中的主类`HelloAkkaScala.scala`。
- en: 'It starts with the following lines (skipping the imports):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它从以下几行开始（省略了导入部分）：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you see, defining an actor consists of extending an `Actor` trait and requires
    only implementing the abstract `receive` method. This method represents the actor's
    behavior when it receives a message. It does not need to handle all types of messages,
    which is why it is a partial function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义一个actor包括扩展`Actor`特质，并且只需要实现抽象的`receive`方法。这个方法代表了actor在接收到消息时的行为。它不需要处理所有类型的消息，这就是为什么它是一个部分函数。
- en: The declared mutable variable, `greeting`, shows that you can safely add some
    mutable state to your actor since the processing of the `receive` method is single
    threaded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的可变变量`greeting`表明你可以在actor中安全地添加一些可变状态，因为`receive`方法的处理是单线程的。
- en: It is convenient to model the immutable messages sent between actors as case
    classes, and the `Greeter` actor uses the two messages, `Greet` and `WhoToGreet(who:String)`.
    Whenever the `Greeter` actor receives a `WhoToGreet(who)` message, it simply updates
    its state but does not reply anything. In contrast, when this same actor receives
    a `Greet` message, it uses the saved state to answer the actor that sent the message.
    The `!` method is also called `tell` (which, by the way, is the name used in the
    Akka Java API) and represents the sending of a message to an actor, with the signature
    `actor ! message`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将演员之间发送的不可变消息建模为案例类很方便，`Greeter`演员使用两个消息，`Greet`和`WhoToGreet(who:String)`。每当`Greeter`演员收到`WhoToGreet(who)`消息时，它只是更新其状态但不回复任何内容。相比之下，当这个相同的演员收到`Greet`消息时，它使用保存的状态来回答发送消息的演员。`!`方法也称为`tell`（顺便说一下，这是Akka
    Java API中使用的名称）并代表向演员发送消息，其签名是`actor ! message`。
- en: 'Also, note the presence of the `sender` variable that is made implicitly available
    as part of the `Actor` trait, since it is a common pattern that an actor replies
    to the sender. However, we could have added an `ActorRef` argument to the `Greet`
    message containing the address of the receiver instead, that is, declared a `case
    Greet(someone:ActorRef)` class and implemented the processing of `Greet`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`sender`变量的存在，它是作为`Actor`特质的一部分隐式提供的，因为演员回复发送者的模式很常见。然而，我们也可以在包含接收者地址的`Greet`消息中添加一个`ActorRef`参数，即声明一个`case
    Greet(someone:ActorRef)`类并实现`Greet`的处理，如下所示：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `HelloAkkaScala` object defines the main routine, as shown in the following
    code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloAkkaScala`对象定义了主程序，如下面的代码片段所示：'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A system running actors needs a runtime environment; this is what the `system`
    variable declares. Creating an actor consists of invoking the `system.actorOf`
    method with a configuration argument as well as an optional name. This method
    gives you back an `ActorRef` (actor reference) object, which is the actor address,
    that is, where messages can be sent. An `ActorRef` object is an immutable and
    serializable handle to an actor, which may or may not reside on the local host
    or within the same `ActorSystem` object. As actors only communicate through messages
    in an asynchronous fashion, each actor has a mailbox where messages can be enqueued
    if the actor cannot handle them as quickly as they arrive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行演员的系统需要一个运行时环境；这就是`system`变量所声明的。创建一个演员包括使用配置参数以及可选名称调用`system.actorOf`方法。此方法返回一个`ActorRef`（演员引用）对象，即演员地址，即消息可以发送的地方。`ActorRef`对象是对演员的不可变和可序列化句柄，它可能位于本地主机上或同一`ActorSystem`对象内。由于演员只能以异步方式通过消息进行通信，每个演员都有一个邮箱，如果演员不能像消息到达那样快速处理它们，消息可以排队。
- en: The remaining part of the main routine essentially sends orders in the form
    of `Greet` or `WhoToGreet` messages to the `Greeter` actor. These messages are
    sent from an `Inbox` object that also expects answers. This `Inbox` object, also
    referred to as "actor-in-a-box", is a convenient way to write code outside actors
    that will communicate with actors. Finally, the last actor, `greetPrinter`, sends
    `Greet` messages (that are scheduled by the environment) to the `Greeter` actor
    repetitively every second.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序剩余部分基本上以`Greet`或`WhoToGreet`消息的形式向`Greeter`演员发送订单。这些消息从一个也期望得到回答的`Inbox`对象发送。这个`Inbox`对象也被称为“actor-in-a-box”，是编写将与其他演员通信的代码的便捷方式。最后，最后一个演员`greetPrinter`每秒重复向`Greeter`演员发送`Greet`消息（由环境安排）。
- en: 'You can execute the example code within the project by running the command
    `> ./activator run` and choosing the `[2] HelloAkkaScala` program. You should
    see something as is shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行命令`> ./activator run`并在选择`[2] HelloAkkaScala`程序来在项目中执行示例代码。您应该看到如下代码所示的内容：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Switching behavior
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为切换
- en: 'Actors have the ability to switch their behavior before handling the next message.
    To illustrate this, let''s consider an example of a travel agent actor that needs
    to reserve both a seat in a flight and a hotel room for its customer. The travel
    agent is responsible for making sure the booking is transactional, that is, it
    is only successful if both transport and accommodation are booked, which is illustrated
    in the following figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 演员在处理下一个消息之前可以切换其行为。为了说明这一点，让我们考虑一个需要为顾客预订航班座位和酒店房间的旅行代理演员的例子。旅行代理负责确保预订是事务性的，也就是说，只有当交通和住宿都预订成功时，它才是成功的，这如下面的图所示：
- en: '![Switching behavior](img/3637OS_08_01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![切换行为](img/3637OS_08_01.jpg)'
- en: 'As it is a recognized best practice to declare the messages concerning an actor
    into its companion object, we will express a `Flight` actor in the following way:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将关于演员的消息声明在其伴随对象中是一种公认的最佳实践，因此我们将以下方式表达`Flight`演员：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the `require` assertion found in the `BookSeat` message declaration.
    This method is part of `Predef`, a global object that includes many useful functionalities
    imported by default. It enables to do some *design-by-contract* style specification
    by checking pre- and post-conditions on methods. The `receive` method of the `Flight`
    actor is handling one type of message only, `BookSeat(n:Int)`, which means reserving
    *n* seats as long as there are enough seats left for the flight. The `Flight`
    actor updates its state and replies with a `Done` message to the sender if there
    are enough seats left; it replies `Failed` otherwise.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`BookSeat`消息声明中找到的`require`断言。这个方法属于`Predef`，这是一个包含许多默认导入的有用功能的全局对象。它通过检查方法的前置和后置条件来实现一些*基于契约的设计*风格的规范。`Flight`演员的`receive`方法只处理一种类型的消息，即`BookSeat(n:Int)`，这意味着只要航班还有足够的座位，就可以预订*n*个座位。如果还有足够的座位，`Flight`演员将更新其状态，并回复一个`Done`消息给发送者；否则回复`Failed`。
- en: Notice the `LoggingReceive` class that surrounds the block handling the actor
    messages. It is part of the `akka.event` package and is a convenient way of logging
    information that reaches this block. We will see later on, while executing the
    sample code, what these messages look like.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意围绕处理演员消息的代码块的`LoggingReceive`类。它是`akka.event`包的一部分，是一种方便记录到达此块的信息的方式。我们将在稍后执行示例代码时看到这些消息的样子。
- en: 'In a similar manner, a `Hotel` actor that takes care of reserving a room for
    *n* persons can be written as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，可以编写一个负责为*n*人预订房间的`Hotel`演员，如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The travel agent actor is the one that is going to switch its behavior. Once
    it has sent orders to book plane seats and hotel rooms for a number of people,
    it will successively change state while expecting answers. Since the messages
    sent to both `Flight` and `Hotel` are asynchronous, that is, nonblocking, we do
    not know which answer will come back first. Furthermore, answers might not come
    back at all as there is no guarantee at this point that the messages have been
    delivered or correctly handled. The code for the `TravelAgent` actor is given
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行代理演员是即将切换其行为的演员。一旦它向预订飞机座位和酒店房间的人数发送了订单，它将依次改变状态，并期待回答。由于发送给`Flight`和`Hotel`的消息是异步的，即非阻塞的，所以我们不知道哪个回答会先回来。此外，回答可能根本不会回来，因为此时没有保证消息已经送达或正确处理。`TravelAgent`演员的代码如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The invocation `context.become(<new behavior method>)` switches the behavior
    of the actor. In the case of this simple travel agent, the behavior will be switched
    to the expected messages that can be received in any order from the `Flight` and
    `Hotel` actors, respectively. If a successful answer is received from either the
    `Flight` or `Hotel` actors, the `TravelAgent` actor will switch its behavior to
    expect only the remaining answer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`context.become(<new behavior method>)`切换演员的行为。在这个简单的旅行代理案例中，行为将切换到可以分别从`Flight`和`Hotel`演员接收到的预期消息，顺序不限。如果从`Flight`或`Hotel`演员那里收到成功的回答，`TravelAgent`演员将切换其行为，只期待剩余的回答。
- en: 'Now, we only need a main routine to create our initial actors and initiate
    communication with the `TravelAgent` actor, as exhibited in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一个主程序来创建我们的初始演员，并与`TravelAgent`演员进行通信，如下所示：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the four actor classes involved in the use case have been written in Eclipse,
    running the program can be done by running an Eclipse configuration. Navigate
    to **Run** | **Run Configuration…** and edit a new **Java Application configuration**
    window knowing that the main class to run is the `akka.Main` class of the Akka
    runtime, as specified in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在Eclipse中编写了涉及用例的四个演员类，可以通过运行Eclipse配置来运行程序。导航到**运行** | **运行配置…**并编辑一个新的**Java应用程序配置**窗口，知道要运行的主类是Akka运行时的`akka.Main`类，如图下所示：
- en: '![Switching behavior](img/3637OS_08_02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![切换行为](img/3637OS_08_02.jpg)'
- en: 'The actual main routine we want to run is passed as an argument. To do that,
    edit the **Arguments** tab of the same window, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要运行的实际主程序作为参数传递。为此，编辑同一窗口的**参数**选项卡，如图下所示：
- en: '![Switching behavior](img/3637OS_08_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![切换行为](img/3637OS_08_03.jpg)'
- en: 'For the debug messages produced by the `LoggingReceive` object to be active,
    you need to add the VM arguments as specified in the previous screenshot. Clicking
    on the **Run** button will execute the `BookingMain` class within the Akka runtime
    environment and display the following flow of messages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `LoggingReceive` 对象产生的调试消息生效，你需要添加之前截图中所指定的 VM 参数。点击 **运行** 按钮将在 Akka 运行时环境中执行
    `BookingMain` 类，并显示以下消息流：
- en: '![Switching behavior](img/3637OS_08_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![切换行为](img/3637OS_08_05.jpg)'
- en: If you want to test an alternative scenario, for example, to see the booking
    failed while reserving the hotel, just put a higher number of persons, that is,
    `20` in `travelAgent ! TravelAgent.BookTrip(flight,hotel,20)`, instead of `10`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试一个替代场景，例如，在预订酒店时看到预订失败，只需在 `travelAgent ! TravelAgent.BookTrip(flight,hotel,20)`
    中输入更多的人数，即 `20`，而不是 `10`。
- en: Supervising actors to handle failure
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监督角色以处理失败
- en: In applications that are running actors concurrently, there might sometimes
    be exceptions that are thrown and those make an actor die eventually. As other
    actors are still running, it might be difficult to notice partial failures. In
    traditional architectures, where an object calls methods on other objects, the
    caller is the one receiving the exception. Since it usually blocks waiting for
    a response, it is also the one responsible to handle the failure. With actors,
    as all messages are being handled asynchronously without knowing the time it will
    take before receiving an answer (if any), the context in regards to the sent messages
    is usually not around anymore to handle the failure; so, it might be more difficult
    to react on an exception. In any case, something must be done about the failing
    actor for the application to function properly as its whole.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发运行角色的应用程序中，有时可能会抛出异常，这些异常最终会导致角色死亡。由于其他角色仍在运行，可能很难注意到部分失败。在传统的架构中，其中对象在其它对象上调用方法，调用者是接收异常的一方。由于它通常在等待响应时阻塞，因此它也是负责处理失败的一方。与角色不同，由于所有消息都是异步处理的，不知道在收到答案之前需要多长时间（如果有的话），因此关于发送消息的上下文通常不再存在以处理失败；因此，对异常的反应可能更困难。无论如何，必须对失败的角色采取一些措施，以便应用程序能够正常工作。
- en: This is why Akka embraces the "let it crash" philosophy by providing support
    to monitor and eventually restart an actor or a group of dependent actors. As
    actors are normally created by other actors, they can be organized as hierarchies
    where an actor's parent is also its supervisor. Handling partial failure, therefore,
    consists of defining some strategies to restart part of the actor hierarchy simultaneously,
    depending on the situation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 Akka 通过提供支持来监控并最终重启一个或一组依赖角色，而拥抱“让它崩溃”的哲学。由于角色通常由其他角色创建，它们可以被组织成层次结构，其中角色的父级也是其管理者。因此，处理部分失败包括定义一些策略，根据情况同时重启部分角色层次结构。
- en: 'If we go back to our small travel booking application, we can refactor the
    `TravelAgent` actor to be the supervisor of the `Flight` and `Hotel` booking actors.
    Therefore, we can declare the following supervisor strategy within the `TravelAgent`
    class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的小型旅行预订应用程序，我们可以重构 `TravelAgent` 角色使其成为 `Flight` 和 `Hotel` 预订角色的管理者。因此，我们可以在
    `TravelAgent` 类中声明以下管理者策略：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two possible strategies are `OneForOneStrategy` and `AllForOneStrategy`.
    In the first case, each child of the supervisor will be handled separately, whereas
    in the second case, all children of the given supervisor will be handled simultaneously.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两种可能的策略是 `OneForOneStrategy` 和 `AllForOneStrategy`。在前一种情况下，管理者的每个子角色将分别处理，而在第二种情况下，给定管理者的所有子角色将同时处理。
- en: 'The `Flight` companion object now contains an additional message that reflects
    the failure, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flight` 伴生对象现在包含了一个反映失败情况的消息，如下面的代码所示：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To simulate the fact that booking the seats on a flight might fail at times,
    we can introduce the following method call when handling the `receive` method
    of the `Flight` actor, as shown in the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟在预订航班座位时可能会失败的情况，我们可以在处理 `Flight` 角色的 `receive` 方法时引入以下方法调用，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Relaunching the booking scenario with the `Run` configuration will display
    (since the failure happens only 25 percent of the time) the failing message at
    times, as shown in the following lines:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Run`配置重新启动预订场景将在某些时候显示失败消息，如下所示：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For interested readers who want to elaborate more on the topic of supervision,
    there is a complete and consistent sample called `akka-supervision` that is part
    of the activator templates. It demonstrates the computation of arithmetic expressions,
    so that nodes that represent subparts of the total computation may fail and be
    restarted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要更深入探讨监督主题的读者，有一个完整且一致的示例，称为`akka-supervision`，它是激活器模板的一部分。它演示了算术表达式的计算，以便表示总计算子部分的节点可能会失败并重新启动。
- en: Testing actor systems
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试演员系统
- en: Because of their nondeterministic nature, concurrent systems require some special
    care when testing them in contrast to traditional single-threaded architectures.
    Actor systems are no exceptions; the messages being sent and received asynchronously,
    there are multiple paths a program flow can follow. Fortunately, Akka provides
    a lot of support defined in the `akka-testkit` module for dealing with tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的非确定性本质，与传统的单线程架构相比，在测试并发系统时需要特别注意。演员系统也不例外；消息的发送和接收是异步的，程序流程可以遵循多条路径。幸运的是，Akka在`akka-testkit`模块中提供了大量的支持，用于处理测试。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Testing Tools"), *Testing Tools*, we have
    already covered a number of examples involving the `scalatest` framework by looking
    at the `test-patterns-scala` activator template project. It contains a basic use
    case regarding the testing of Akka actors through the `testkit` module. You can
    reimport this template project into Eclipse or just open it if it is still in
    the IDE. The `Test09.scala` file exhibits the usage of a testing actor by providing
    an `ImplicitSender` trait that fakes the sending of messages to two actors under
    test. The first actor under test is a simple echo actor, whereas the second is
    calling a location service asynchronously that calculates the latitude and longitude
    of a given address. The syntax of the `GeoActor` object, given in the following
    test, should look familiar since it uses the dispatch libraries in the same way
    as we have seen in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。测试工具")*测试工具*中，我们已经通过查看`test-patterns-scala`激活器模板项目，涉及了`scalatest`框架的许多示例。它包含了一个关于通过`testkit`模块测试Akka演员的基本用例。您可以重新导入此模板项目到Eclipse中，或者如果它仍在IDE中，也可以直接打开它。以下测试中的`GeoActor`对象的语法应该看起来很熟悉，因为它使用与我们在[第3章](ch03.html
    "第3章。理解Scala生态系统")*理解Scala生态系统*中看到的方式相同的调度库：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the main routine of the test case, we mix in the `ImplicitSender` trait
    and then invoke the `expectMsg` method :'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例的主流程中，我们混合了`ImplicitSender`特质，然后调用`expectMsg`方法：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `expectMsg()` method has the role of an assertion that takes duration as
    a parameter, so that it does not wait forever for the reply to come back. Instead,
    it will throw an exception if the specified time has passed and it has not yet
    received the answer it was waiting for.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`expectMsg()`方法的作用是一个带有持续时间参数的断言，因此它不会永远等待回复。相反，如果指定的时间已经过去，它还没有收到它等待的答案，它将抛出一个异常。'
- en: Exploring further with Akka
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步探索Akka
- en: 'In addition to the useful functionalities of actor messaging and supervision,
    Akka includes support for many other, more advanced features. Among them are the
    following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了演员消息和监督的有用功能外，Akka还包括对许多其他更高级功能的支持。其中以下是一些：
- en: It monitors the lifecycle of actors through the `DeathWatch` API.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过`DeathWatch` API监控演员的生命周期。
- en: It persists actor state for recovery after failure.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在失败后持久化演员状态以进行恢复。
- en: It remotes with actors, that is, communicates with actors in a distributed environment
    and in a transparent way.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与演员进行远程通信，即在分布式环境中以透明的方式与演员通信。
- en: It clusters to handle failure in a distributed environment. A sample of the
    clustering features is also available as the `akka-clustering` activator template.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在分布式环境中进行集群处理以处理失败。集群功能的示例也作为`akka-clustering`激活器模板提供。
- en: These features are out of the scope of this book, but they are extensively documented
    on the Akka site and available at [http://akka.io/docs/](http://akka.io/docs/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性超出了本书的范围，但在 Akka 网站上进行了广泛记录，并可在 [http://akka.io/docs/](http://akka.io/docs/)
    获取。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have first studied how to deal with asynchronous Scala code
    using the Async toolkit, which simplifies writing nonblocking code using Futures
    and Promises. We then moved to the concurrency topic by introducing the Akka framework
    based on the actor paradigm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何使用 Async 工具包处理异步 Scala 代码，该工具包简化了使用 Futures 和 Promises 编写非阻塞代码。然后，我们通过介绍基于演员范式的
    Akka 框架转向了并发主题。
- en: Concurrent and distributed systems is such a large topic that we have only introduced
    some basic usage scenarios of actor systems. We have learned that since the behavior
    and state of actors are encapsulated, actor systems are easy to reason about.
    Moreover, the supervision and clustering support in Akka makes the handling of
    failure and distribution very robust. The material covered in this chapter is
    just a glimpse of what the toolkit can achieve; the very extended and well-written
    documentation of the Akka project will guide you through creating scalable and
    distributed applications. Programming asynchronous, concurrent, and distributed
    systems is often a complex task, and the actor model makes it more manageable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和分布式系统是一个如此庞大的主题，我们只介绍了演员系统的一些基本使用场景。我们了解到，由于演员的行为和状态被封装，演员系统易于推理。此外，Akka
    中的监督和集群支持使得处理故障和分布非常稳健。本章涵盖的材料只是 Akka 工具箱所能实现的一瞥；Akka 项目的非常详尽和精心编写的文档将指导你创建可扩展和分布式应用。编程异步、并发和分布式系统通常是一项复杂的任务，而演员模型使其更加易于管理。
- en: Since Akka is also the foundation of the `Play` Framework, we will continue
    to use it through the next chapter. We will build reactive web applications in
    `Play` to illustrate how to create modern applications that need to handle streams
    of data and push information into the browser.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Akka 也是 `Play` 框架的基础，我们将在下一章继续使用它。我们将使用 `Play` 构建响应式网络应用，以展示如何创建需要处理数据流并将信息推送到浏览器的现代应用。
