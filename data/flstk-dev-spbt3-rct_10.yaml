- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Getting Started with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 入门
- en: This chapter describes the basics of React programming. We will cover the skills
    that are required to create basic functionalities for our React frontend. In JavaScript,
    ­we use the **ECMAScript 2015** (**ES6**) syntax because it provides many features
    that make coding cleaner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 React 编程的基础。我们将涵盖创建 React 前端基本功能所需的技术。在 JavaScript 中，我们使用 **ECMAScript
    2015**（**ES6**）语法，因为它提供了许多使编码更简洁的功能。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Creating React components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 React 组件
- en: Useful ES6 features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的 ES6 功能
- en: JSX and styling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 和样式
- en: Props and state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props 和状态
- en: Conditional rendering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件渲染
- en: React hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 钩子
- en: The Context API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文 API
- en: Handling lists, events, and forms with React
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 处理列表、事件和表单
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For our work, React version 18 or higher will be required. We set up our environment
    correctly in *Chapter 7*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的工作，需要使用 React 版本 18 或更高版本。我们在*第 7 章*中正确设置了我们的环境。
- en: 'You can find more resources at the GitHub link for this chapter: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的 GitHub 链接中找到更多资源：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08)。
- en: Creating React components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 React 组件
- en: React is a JavaScript library for **user interfaces** (**UIs**). Since version
    15, React has been developed under the MIT license. React is component-based,
    and the components are independent and reusable. Components are the basic building
    blocks of React. When you start to develop a UI with React, it is good to start
    by creating **mock interfaces**. That way, it will be easy to identify what kinds
    of components you have to create and how they interact.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于**用户界面**（**UI**）的 JavaScript 库。自 15 版本以来，React 一直在 MIT 许可下开发。React
    是基于组件的，组件是独立且可重用的。组件是 React 的基本构建块。当你开始使用 React 开发 UI 时，最好先创建**模拟界面**。这样，将很容易确定你需要创建哪些类型的组件以及它们如何交互。
- en: 'From the following mock UI, we can see how the UI can be split into components.
    In this case, there will be an application root component, a search bar component,
    a table component, and a table row component:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下模拟用户界面中，我们可以看到 UI 可以如何拆分为组件。在这种情况下，将有一个应用程序根组件、一个搜索栏组件、一个表格组件和一个表格行组件：
- en: '![](img/B19818_08_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_01.png)'
- en: 'Figure 8.1: React components'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：React 组件
- en: 'The components can then be arranged in a **tree hierarchy**, as shown in the
    following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以按照以下截图所示的**树形层次结构**进行排列：
- en: '![Figure 7.2 – Component tree ](img/B19818_08_02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 组件树](img/B19818_08_02.png)'
- en: 'Figure 8.2: Component tree'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：组件树
- en: 'The **root component** has two **child components**: the search component and
    the table component. The table component has one child component: the table row
    component. The important thing to understand with React is that the data flow
    goes from a parent component to a child component. We will learn later how data
    can be passed from a parent component to a child component using props.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**根组件**有两个**子组件**：搜索组件和表格组件。表格组件有一个子组件：表格行组件。在 React 中需要理解的重要一点是数据流是从父组件流向子组件。我们将在稍后学习如何使用
    props 从父组件传递数据到子组件。'
- en: React uses the **virtual document object model** (**VDOM**) for selective re-rendering
    of the UI, which makes it more cost-effective. The **document object model** (**DOM**)
    is a programming interface for web documents that represents the web page as a
    structured tree of objects. Each object in a tree corresponds to a part of the
    document. Using the DOM, programmers can create documents, navigate their structure,
    and add, modify, or delete elements and content. The VDOM is a lightweight copy
    of the DOM, and manipulation of the VDOM is much faster than it is with the real
    DOM. After the VDOM is updated, React compares it to a snapshot that was taken
    of the VDOM before updates were run. After the comparison, React will know which
    parts have been changed, and only these parts will be updated to the real DOM.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用 **虚拟文档对象模型**（**VDOM**）进行 UI 的选择性重新渲染，这使得它更加高效。**文档对象模型**（**DOM**）是用于表示网页为结构化对象树的编程接口。树中的每个对象都对应文档的一部分。使用
    DOM，程序员可以创建文档、导航其结构，并添加、修改或删除元素和内容。VDOM 是 DOM 的轻量级副本，对 VDOM 的操作比在真实 DOM 中要快得多。在更新
    VDOM 之后，React 会将其与在更新之前拍摄的 VDOM 快照进行比较。比较之后，React 将知道哪些部分已经更改，并且只有这些部分会被更新到真实
    DOM。
- en: A React component can be defined either by using a JavaScript function – a **functional
    component** – or the ES6 JavaScript class – a **class component**. We will go
    more deeply into ES6 in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 React 组件可以通过使用 JavaScript 函数——一个 **函数组件**——或者 ES6 JavaScript 类——一个 **类组件**来定义。我们将在下一节更深入地了解
    ES6。
- en: 'Here is some simple component source code that renders the `Hello World` text.
    This first code block uses a JavaScript function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的组件源代码，用于渲染 `Hello World` 文本。第一个代码块使用 JavaScript 函数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mandatory `return` statement in the React function component defines what
    the component looks like.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React 函数组件中必须的 `return` 语句定义了组件的外观。
- en: 'Alternatively, the following code uses the ES6 class to create a component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下代码使用 ES6 类来创建一个组件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class component contains the required `render()` method, which shows and
    updates the rendered output of the component. If you compare the functional and
    class `App` components, you can see that the `render()` method is not needed in
    the functional component. Before React version 16.8, you had to use class components
    to be able to use states. Now, you can use hooks to create states with functional
    components as well. We will learn about states and hooks later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件包含必要的 `render()` 方法，该方法显示并更新组件的渲染输出。如果您比较函数和类 `App` 组件，您会看到在函数组件中不需要 `render()`
    方法。在 React 版本 16.8 之前，您必须使用类组件才能使用状态。现在，您也可以使用 hooks 在函数组件中创建状态。我们将在本章后面学习状态和
    hooks。
- en: In this book, we will create components using functions, which means we have
    to write less code. Functional components are a modern way to write React components,
    and we recommend avoiding using classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用函数创建组件，这意味着我们需要编写更少的代码。函数组件是编写 React 组件的现代方式，我们建议避免使用类。
- en: The name of the React component should start with a capital letter. It is also
    recommended to use the PascalCase naming convention, whereby each word starts
    with a capital letter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件的名称应该以大写字母开头。还建议使用 PascalCase 命名约定，即每个单词都以大写字母开头。
- en: 'Imagine we are making changes to our example component’s `return` statement
    and adding a new `<h2>` element to it, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在修改示例组件的 `return` 语句，并向其中添加一个新的 `<h2>` 元素，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if the app is run, we will see an **Adjacent JSX elements must be wrapped
    in an enclosing tag** error, as indicated in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果运行应用程序，我们将看到一个 **相邻 JSX 元素必须包裹在封装标签中**的错误，如下面的屏幕截图所示：
- en: '![](img/B19818_08_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_08_03.png)'
- en: 'Figure 8.3: Adjacent JSX elements error'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：相邻 JSX 元素错误
- en: 'If your component returns multiple elements, you have to wrap these inside
    one parent element. To fix this error, we have to wrap the header elements in
    one element, such as a `div`, as illustrated in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组件返回多个元素，您必须将这些元素包裹在一个父元素内部。为了修复这个错误，我们必须将标题元素包裹在一个元素中，例如一个 `div`，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also use a React **fragment**, as shown in the following code snippet.
    Fragments don’t add any extra nodes to the DOM tree:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 React **片段**，如下面的代码片段所示。片段不会向 DOM 树添加任何额外的节点：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is also shorter syntax for fragments, which looks like empty JSX tags.
    This is shown in the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于片段，也有更短的语法，它看起来像空的 JSX 标签。这在上面的代码片段中显示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Examining our first React app
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查我们的第一个 React 应用
- en: Let’s look more carefully at the first React app we created in *Chapter 7*,
    *Setting Up the Environment and Tools – Frontend*, using Vite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们在 *第 7 章* 中使用 Vite 创建的第一个 React 应用，*设置环境和工具 – 前端*。
- en: 'The source code of the `main.jsx` file in the root folder looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件夹中的 `main.jsx` 文件的源代码如下：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the beginning of the file, there are `import` statements that load components
    and assets to our file. For example, the second line imports the `react-dom` package
    from the `node_modules` folder, and the third line imports the `App` component
    (the `App.jsx` file in the `src` folder). The fourth line imports the `index.css`
    style sheet that is in the same folder as the `main.jsx` file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的开头有一些 `import` 语句，它们将组件和资产加载到我们的文件中。例如，第二行从 `node_modules` 文件夹中导入 `react-dom`
    包，第三行导入 `App` 组件（位于 `src` 文件夹中的 `App.jsx` 文件），第四行导入与 `main.jsx` 文件相同的文件夹中的 `index.css`
    样式表。
- en: The `react-dom` package provides DOM-specific methods for us. To render the
    React component to the DOM, we can use the `render` method from the `react-dom`
    package. `React.StrictMode` is used to find potential problems in your React app
    and these are printed in the browser console. Strict Mode only runs in development
    mode and renders your components extra time, so it has time to find bugs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-dom` 包为我们提供了特定的 DOM 方法。要将 React 组件渲染到 DOM 中，我们可以使用来自 `react-dom` 包的
    `render` 方法。`React.StrictMode` 用于在您的 React 应用中查找潜在问题，这些问题会在浏览器控制台中打印出来。严格模式仅在开发模式下运行，并且会额外渲染您的组件，因此它有足够的时间来查找错误。'
- en: 'The **root API** is used to render React components inside a browser DOM node.
    In the following example, we first create a root by passing the DOM element to
    the `createRoot` method. The root calls the `render` method to render an element
    to the root:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**root API** 用于在浏览器 DOM 节点内渲染 React 组件。在以下示例中，我们首先通过将 DOM 元素传递给 `createRoot`
    方法来创建一个根。根调用 `render` 方法将一个元素渲染到根：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `container` in the root API is the `<div id="root"></div>` element, which
    can be found in the `index.html` file inside the project root folder. Look at
    the following `index.html` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根 API 中的 `container` 是 `<div id="root"></div>` 元素，它位于项目根文件夹内的 `index.html` 文件中。查看以下
    `index.html` 文件：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following source code shows the `App.jsx` component from our first React
    app. You can see that `import` also applies to assets, such as images and style
    sheets. At the end of the source code, there is an `export default` statement
    that exports the component, and it can be made available to other components by
    using the `import` statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码显示了我们的第一个 React 应用中的 `App.jsx` 组件。您可以看到 `import` 也适用于资产，如图片和样式表。在源代码的末尾有一个
    `export default` 语句，它导出组件，并且可以通过使用 `import` 语句使其对其他组件可用：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that in the `App` component that Vite has created, we don’t have
    semicolons at the end of statements. It is optional in JavaScript but, in this
    book, we will use semicolons to terminate statements when we start to create our
    own React components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在 Vite 创建的 `App` 组件中，我们没有在语句末尾使用分号。在 JavaScript 中这是可选的，但在这本书中，当我们开始创建自己的
    React 组件时，我们将使用分号来终止语句。
- en: There can only be one `export default` statement per file, but there can be
    multiple named `export` statements. Default exports are commonly used to export
    React components. Named exports are commonly used to export specific functions
    or objects from a module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件只能有一个 `export default` 语句，但可以有多个命名的 `export` 语句。默认导出通常用于导出 React 组件。命名导出通常用于从模块中导出特定的函数或对象。
- en: 'The following example shows how to import default and named exports:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何导入默认和命名的导出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The exports look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 导出看起来是这样的：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have covered the basics of React components, let’s take a look at
    the basic features of ES6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 React 组件的基础知识，让我们来看看 ES6 的基本特性。
- en: Useful ES6 features
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的 ES6 特性
- en: '**ES6** was released in 2015, and it introduced a lot of new features. ECMAScript
    is a standardized scripting language, and JavaScript is one implementation of
    it. In this section, we will go through the most important features released in
    ES6 that we will be using in the following sections.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES6** 于 2015 年发布，并引入了许多新特性。ECMAScript 是一种标准化的脚本语言，而 JavaScript 是其一种实现。在本节中，我们将介绍
    ES6 中发布的最重要特性，这些特性将在接下来的章节中使用。'
- en: Constants and variables
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量和变量
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you will get an error if you try to reassign the `PI` value, as indicated
    in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试重新分配 `PI` 值，将会得到错误，如下面的截图所示：
- en: '![Figure 7.4 – Assignment to constant variable ](img/B19818_08_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 向常量变量赋值](img/B19818_08_04.png)'
- en: 'Figure 8.4: Assignment to constant variable'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：向常量变量赋值
- en: 'The `const` is block-scoped. This means that the `const` variable can only
    be used inside the block in which it is defined. In practice, the block is the
    area between curly brackets `{}`. If `const` is defined outside of any function
    or block, it becomes a global variable, and you should try to avoid this situation.
    Global variables make code harder to understand, maintain, and debug. The following
    sample code shows how the scope works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 是块级作用域的。这意味着 `const` 变量只能在其定义的块内部使用。在实践中，块是花括号 `{}` 之间的区域。如果 `const`
    在任何函数或块外部定义，它就变成了全局变量，您应尽量避免这种情况。全局变量会使代码更难以理解、维护和调试。以下示例代码展示了作用域是如何工作的：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second `console.log` statement gives an error because we are trying to use
    the `total` variable outside its scope.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `console.log` 语句会报错，因为我们试图在作用域之外使用 `total` 变量。
- en: 'The following example demonstrates what happens when `const` is an object or
    array:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了当 `const` 是对象或数组时会发生什么：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When `const` is an object or array, its properties or elements can be updated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `const` 是对象或数组时，其属性或元素可以被更新。
- en: The `let` keyword allows you to declare *mutable* block-scoped variables. The
    variable declared using `let` can be used inside the block in which it is declared
    (it can also be used inside sub-blocks).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字允许您声明可变块级作用域变量。使用 `let` 声明的变量可以在其声明的块内部使用（也可以在子块内部使用）。'
- en: Arrow functions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'The traditional way of defining a function in JavaScript is by using a `function`
    keyword. The following function takes one argument and returns the argument value
    multiplied by `2`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中定义函数的传统方式是使用 `function` 关键字。以下函数接受一个参数，并返回该参数值乘以 `2`：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we use the ES6 arrow function, the function looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 ES6 箭头函数时，函数看起来是这样的：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see, by using the arrow function, we have made the declaration of
    the same function more compact. The function is a so-called **anonymous function**,
    and we can’t call it. Anonymous functions are often used as an argument for other
    functions. In JavaScript, functions are *first-class citizens* and you can store
    functions in variables, as illustrated here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用箭头函数，我们使相同函数的声明更加紧凑。该函数是一个所谓的**匿名函数**，我们无法调用它。匿名函数通常用作其他函数的参数。在 JavaScript
    中，函数是**一等公民**，您可以将函数存储在变量中，如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you can use the variable name to call the function, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用变量名来调用函数，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you have more than one argument, you have to wrap the arguments in parentheses
    and separate the arguments with a comma to use the arrow function effectively.
    For example, the following function takes two parameters and returns their sum:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个参数时，您必须将参数包裹在括号中，并用逗号分隔参数，以有效地使用箭头函数。例如，以下函数接受两个参数，并返回它们的和：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the function body is an expression, then you don’t need to use the `return`
    keyword. The expression is always implicitly returned from the function. When
    you have multiple lines in the function body, you have to use curly brackets and
    a `return` statement, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数体是一个表达式，那么您不需要使用 `return` 关键字。表达式总是隐式地从函数中返回。当函数体有多行时，您必须使用花括号和一个 `return`
    语句，如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the function doesn’t have any arguments, then you should use empty parentheses,
    like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数没有参数，那么您应该使用空括号，如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are going to use lots of arrow functions later in our frontend implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的前端实现中大量使用箭头函数。
- en: Template literals
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: 'Template literals can be used to concatenate strings. The traditional way to
    concatenate strings is to use the `+` operator, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串可以用于连接字符串。连接字符串的传统方式是使用 `+` 运算符，如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With template literals, the syntax looks like this. You have to use backticks
    ([PRE24]) instead of single or double quotes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串时，语法如下。您必须使用反引号（`）而不是单引号或双引号：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we will learn how to use object destructuring.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用对象解构。
- en: Object destructuring
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象解构
- en: 'The object destructuring feature allows you to extract values from an object
    and assign them to a variable. You can use a single statement to assign multiple
    properties of an object to individual variables. For example, if you have this
    object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构功能允许你从对象中提取值并将它们分配给变量。你可以使用单个语句将对象的多个属性分配给单个变量。例如，如果你有这个对象：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can destructure it using the following statement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语句对其进行解构：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It creates three variables, `firstName`, `lastName`, and `email`, which get
    their values from the `person` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了三个变量，`firstName`、`lastName` 和 `email`，它们从 `person` 对象中获取它们的值。
- en: 'Without object destructuring, you have to access each property individually,
    as shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对象解构的情况下，你必须单独访问每个属性，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we will learn how to create classes using JavaScript ES6 syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用 JavaScript ES6 语法创建类。
- en: Classes and inheritance
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和继承
- en: Class definition in ES6 is similar to other object-oriented languages such as
    Java or C#. We saw an ES6 class when we looked at how to create React class components
    earlier. But, as we said earlier, classes are no longer recommended for creating
    React components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中的类定义与其他面向对象的语言（如 Java 或 C#）类似。我们在之前查看如何创建 React 类组件时已经看到了 ES6 类。但是，正如我们之前所说的，类不再推荐用于创建
    React 组件。
- en: 'The keyword for defining classes is `class`. A class can have fields, constructors,
    and class methods. The following sample code shows an ES6 class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的关键字是 `class`。一个类可以有字段、构造函数和类方法。以下示例代码展示了 ES6 类：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inheritance is performed with an `extends` keyword. The following sample code
    shows an `Employee` class that inherits a `Person` class. This means that it inherits
    all fields from the parent class and can have its own fields that are specific
    to `Employee`. In the constructor, we first call the parent class constructor
    by using the `super` keyword. That call is required by the rest of the code, and
    you will get an error if it is missing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是通过 `extends` 关键字实现的。以下示例代码展示了继承自 `Person` 类的 `Employee` 类。这意味着它继承了父类的所有字段，并且可以有自己的特定于
    `Employee` 的字段。在构造函数中，我们首先使用 `super` 关键字调用父类构造函数。这个调用对于其余的代码是必需的，如果它缺失，你会得到一个错误：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Although ES6 is already quite old, some of its features are still only partially
    supported by modern web browsers. **Babel** is a JavaScript compiler that is used
    to compile ES6 (or newer versions) to an older version that is compatible with
    all browsers. You can test the compiler on the Babel website ([https://babeljs.io](https://babeljs.io)).
    The following screenshot shows the arrow function compiling back to the older
    JavaScript syntax:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 ES6 已经相当老了，但其中一些功能在现代网络浏览器中仍然只部分受支持。**Babel** 是一个 JavaScript 编译器，用于将 ES6（或更新的版本）编译成与所有浏览器兼容的旧版本。你可以在
    Babel 网站上测试编译器（[https://babeljs.io](https://babeljs.io)）。以下截图显示了箭头函数编译回旧版 JavaScript
    语法：
- en: '![Figure 7.5 – Babel ](img/B19818_08_05.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – Babel](img/B19818_08_05.png)'
- en: 'Figure 8.5: Babel'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：Babel
- en: Now that we have learned about the basics of ES6, let’s take a look at what
    JSX and styling are all about.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 ES6 的基础知识，让我们来看看 JSX 和样式都是些什么。
- en: JSX and styling
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 和样式
- en: '**JavaScript XML** (**JSX**) is the syntax extension for JavaScript. It is
    not mandatory to use JSX with React, but there are some benefits that make development
    easier. For example, JSX prevents injection attacks because all values are escaped
    in JSX before they are rendered. The most useful feature is that you can embed
    JavaScript expressions in JSX by wrapping them with curly brackets; this technique
    will be used a lot in the following chapters. JSX is compiled into regular JavaScript
    by Babel.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript XML**（**JSX**）是 JavaScript 的语法扩展。使用 JSX 与 React 不是强制性的，但有一些使开发更简单的优点。例如，JSX
    防止注入攻击，因为所有值在 JSX 渲染之前都会被转义。最有用的功能是，你可以通过用花括号包裹它们来在 JSX 中嵌入 JavaScript 表达式；这种技术将在接下来的章节中大量使用。JSX
    由 Babel 编译成常规 JavaScript。'
- en: 'In the following example, we can access a component’s props when using JSX:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以在使用 JSX 时访问组件的 props：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Component props are covered in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 组件 props 将在下一节中介绍。
- en: 'You can also pass a JavaScript expression as props, as shown in the following
    code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像以下代码片段所示那样将 JavaScript 表达式作为 props 传递：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can use both inline and external styling with React JSX elements. Here
    are two examples of inline styling. This first one defines the style inside the
    `div` element:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内联和外部样式与 React JSX 元素一起使用。以下有两个内联样式的示例。第一个在 `div` 元素内部定义了样式：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second example creates a style object first, which is then used in the
    `div` element. The object name should use the *camelCase* naming convention:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例首先创建一个样式对象，然后在该 `div` 元素中使用。对象名称应使用 *camelCase* 命名约定：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As shown in a previous section, you can import a style sheet into a React component.
    To reference classes from an external **CSS** file, you should use a `className`
    attribute, as shown in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个部分所示，你可以将样式表导入到 React 组件中。要引用外部 **CSS** 文件中的类，你应该使用 `className` 属性，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we will learn about React props and state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于 React props 和 state 的内容。
- en: Props and state
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props 和 state
- en: '**Props** and **state** are the input data for rendering a component. The component
    is re-rendered when the props or state change.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Props** 和 **state** 是渲染组件的输入数据。当 props 或 state 发生变化时，组件会重新渲染。'
- en: Props
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Props
- en: '**Props** are inputs to components, and they are a mechanism to pass data from
    a parent component to its child component. Props are JavaScript objects, so they
    can contain multiple key-value pairs.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Props** 是组件的输入，它们是传递数据从父组件到子组件的机制。Props 是 JavaScript 对象，因此它们可以包含多个键值对。'
- en: 'Props are immutable, so a component cannot change its props. Props are received
    from the parent component. A component can access props through the `props` object
    that is passed to the function component as a parameter. For example, let’s take
    a look at the following component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Props 是不可变的，因此组件不能改变其 props。Props 是从父组件接收的。组件可以通过作为参数传递给函数组件的 `props` 对象来访问
    props。例如，让我们看一下以下组件：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The component just renders a static message, and it is not reusable. Instead
    of using a hardcoded name, we can pass a name to the `Hello` component by using
    props, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组件仅渲染一个静态消息，并且不可复用。我们可以通过使用 props 将一个名字传递给 `Hello` 组件，而不是使用硬编码的名字，如下所示：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The parent component can send props to the `Hello` component in the following
    way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件可以通过以下方式将 props 发送到 `Hello` 组件：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, when the `Hello` component is rendered, it shows the `Hello John` text.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `Hello` 组件被渲染时，它显示 `Hello John` 文本。
- en: 'You can also pass multiple props to a component, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向组件传递多个 props，如下所示：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, you can access both props in the component using the `props` object, as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `props` 对象访问组件中的这两个 props，如下所示：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the component output is `Hello John Johnson`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件输出为 `Hello John Johnson`。
- en: 'You can also use object destructuring to destructure a `props` object in the
    following way:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用对象解构以以下方式解构 `props` 对象：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: State
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: State
- en: In React, the component **state** is an internal data store that holds information
    that can change over time. The state also affects the rendering of the component.
    When the state is updated, React schedules a re-render of the component. When
    the component re-renders, the state retains its latest values. State allows components
    to be dynamic and responsive to user interactions or other events.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，组件 **state** 是一个内部数据存储，它持有随时间变化的信息。状态还影响组件的渲染。当状态更新时，React 会安排组件的重新渲染。当组件重新渲染时，状态保留其最新的值。状态允许组件动态且对用户交互或其他事件做出响应。
- en: It’s generally a good practice to avoid introducing unnecessary states in your
    React components. Unnecessary states increase the complexity of your components
    and can cause unwanted side effects. Sometimes, a local variable can be a better
    option. But you have to understand that *changes to local variables won’t trigger
    re-rendering*. Each time a component re-renders, local variables are reinitialized,
    and their values don’t persist between renders.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，避免在 React 组件中引入不必要的状态是一个好的实践。不必要的状态会增加组件的复杂性，并可能导致不期望的副作用。有时，局部变量可能是一个更好的选择。但你要明白，*局部变量的更改不会触发重新渲染*。每次组件重新渲染时，局部变量都会被重新初始化，它们的值在渲染之间不会持久化。
- en: 'The state is created using the `useState` hook function. It takes one argument,
    which is the initial value of the state, and returns an array of two elements.
    The first element is the name of the state, and the second element is a function
    that is used to update the state value. The syntax of the `useState` function
    is shown in the following code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useState` 钩子函数创建状态。它接受一个参数，即状态的初始值，并返回一个包含两个元素的数组。第一个元素是状态的名字，第二个元素是一个用于更新状态值的函数。`useState`
    函数的语法在下面的代码片段中展示：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next code example creates a state variable called `name`, and the initial
    value is `Jim`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例创建了一个名为 `name` 的状态变量，其初始值为 `Jim`：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also import the `useState` function from React, like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像这样从React导入`useState`函数：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, you don’t need to type the `React` keyword, as indicated here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您不需要像这里所示的那样键入`React`关键字：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The value of the state can now be updated by using the `setName` function,
    as illustrated in the following code snippet. This is the only way to modify the
    state value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`setName`函数来更新状态值，如下面的代码片段所示。这是修改状态值的唯一方法：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should never update the state value directly using the `=` operator. If
    you update the state directly, as shown next, React won’t re-render the component
    and you will also get an error because you cannot reassign the `const` variable:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您绝对不应该直接使用`=`运算符来更新状态值。如果您直接更新状态，如以下所示，React将不会重新渲染组件，您也会得到一个错误，因为您不能重新分配`const`变量：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you have multiple states, you can call the `useState` function multiple
    times, as shown in the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个状态，您可以多次调用`useState`函数，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, you can update states using the `setFirstName` and `setLastName` functions,
    as shown in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`setFirstName`和`setLastName`函数来更新状态，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also define state using an object, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用对象来定义状态，如下所示：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, you can update both the `firstName` and `lastName` state object parameters
    using the `setName` function, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`setName`函数更新`firstName`和`lastName`状态对象参数，如下所示：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you want to do a partial update of the object, you can use the **spread
    operator**. In the following example, we use the object spread syntax (`...`)
    that was introduced in ES2018\. It clones the `name` state object and updates
    the `firstName` value to be `Jim`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对对象进行部分更新，可以使用**展开运算符**。在下面的示例中，我们使用了在ES2018中引入的对象展开语法（`...`），它克隆了`name`状态对象并将`firstName`的值更新为`Jim`：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A state can be accessed by using the state name, as shown in the next example.
    The scope of the state is the component, so it cannot be used outside the component
    in which it is defined:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用状态名称来访问状态，如下一个示例所示。状态的范围是组件，因此它不能在定义它的组件外部使用：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If your state is an object, then you can access it in the following way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的状态是一个对象，那么您可以按以下方式访问它：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have now learned the basics of state and props, and we will learn more about
    states later in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了状态和属性的基础知识，我们将在本章的后面部分学习更多关于状态的内容。
- en: Stateless components
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态组件
- en: 'The React **stateless component** is just a pure JavaScript function that takes
    props as an argument and returns a React element. Here’s an example of a stateless
    component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: React的**无状态组件**只是一个接受props作为参数并返回React元素的纯JavaScript函数。以下是一个无状态组件的示例：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, the component is rendered and **memoized**. In the next render, React renders
    a memoized result if the props are not changed. The `React.memo()` phrase also
    has a second argument, `arePropsEqual()`, which you can use to customize rendering
    conditions, but we will not cover that here. The one benefit of using functional
    components is unit testing, which is straightforward because their return values
    are always the same for the same input values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件已被渲染并**缓存**。在下一次渲染中，如果属性没有改变，React将渲染缓存的结果。`React.memo()`短语还有一个第二个参数`arePropsEqual()`，您可以使用它来自定义渲染条件，但这里我们不会涉及。使用函数组件的一个好处是单元测试，因为它们的返回值对于相同的输入值始终相同。
- en: Conditional rendering
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件渲染
- en: You can use a conditional statement to render different UIs if a condition is
    `true` or `false`. This feature can be used, for example, to show or hide some
    elements, handle authentication, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为`true`或`false`，您可以使用条件语句来渲染不同的UI。这个特性可以用来显示或隐藏某些元素，处理身份验证等等。
- en: 'In the following example, we will check if `props.isLoggedin` is `true`. If
    so, we will render the `<Logout />` component; otherwise, we render the `<Login
    />` component. This is now implemented using two separate `return` statements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将检查`props.isLoggedin`是否为`true`。如果是这样，我们将渲染`<Logout />`组件；否则，我们将渲染`<Login
    />`组件。现在这是通过两个单独的`return`语句实现的：
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can also implement this by using `condition ? true : false` logical operators,
    and then you need only one `return` statement, as illustrated here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '您也可以通过使用`condition ? true : false`逻辑运算符来实现这一点，然后您只需要一个`return`语句，如下所示：'
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: React hooks
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React hooks
- en: '**Hooks** were introduced in React version 16.8\. Hooks allow you to use state
    and some other React features in functional components. Before hooks, you had
    to write class components if states or complex component logic were needed.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**钩子**是在React 16.8版本中引入的。钩子允许你在函数组件中使用状态和一些其他React特性。在钩子出现之前，如果需要状态或复杂的组件逻辑，你必须编写类组件。'
- en: There are certain important rules for using hooks in React. You should always
    call hooks at the top level in your React function component. You shouldn’t call
    hooks inside loops, conditional statements, or nested functions. Hook names begin
    with the word `use`, followed by the purpose they serve.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中使用钩子有一些重要的规则。你应该始终在React函数组件的顶层调用钩子。你不应该在循环、条件语句或嵌套函数中调用钩子。钩子名称以单词`use`开头，后跟它们所服务的目的。
- en: useState
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useState
- en: 'We are already familiar with the `useState` hook function that is used to declare
    states. Let’s look at one more example of using the `useState` hook. We will create
    an example counter that contains a button, and when it is pressed, the counter
    is increased by `1`, as illustrated in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了用于声明状态的`useState`钩子函数。让我们看看使用`useState`钩子的另一个示例。我们将创建一个包含按钮的示例计数器，当按下按钮时，计数器增加`1`，如下截图所示：
- en: '![](img/B19818_08_06.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_08_06.png)'
- en: 'Figure 8.6: Counter component'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：计数器组件
- en: 'First, we create a `Counter` component and declare a state called `count` with
    the initial value `0`. The value of the counter state can be updated using the
    `setCount` function. The code is illustrated in the following snippet:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`Counter`组件，并声明一个名为`count`的状态，其初始值为`0`。可以使用`setCount`函数更新计数器状态的值。以下代码片段展示了这一过程：
- en: '[PRE59]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we render a button element that increments the state by `1`. We use the
    `onClick` event attribute to call the `setCount` function, and the new value is
    the current value plus `1`. We will also render the counter state value. The code
    is illustrated in the following snippet:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们渲染一个按钮元素，每次按下按钮时将状态增加`1`。我们使用`onClick`事件属性来调用`setCount`函数，新值是当前值加`1`。我们还将渲染计数器状态值。以下代码片段展示了这一过程：
- en: '[PRE60]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, our `Counter` component is ready, and the counter is incremented by `1`
    each time the button is pressed. When the state is updated, React re-renders the
    component and we can see the new `count` value.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的`Counter`组件已经准备好，每次按下按钮时计数器都会增加`1`。当状态更新时，React会重新渲染组件，我们可以看到新的`count`值。
- en: In React, events are named using camelCase, for example, **onClick**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，事件名称使用驼峰式命名法，例如，**onClick**。
- en: 'Note that the function must be *passed* to an event handler, and then React
    will call the function only when the user clicks the button. We use an arrow function
    in the following example because it is more compact to write and improves code
    readability. If you call the function *in* the event handler, then the function
    is called when the component is rendered, which can cause an infinite loop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须将函数传递给事件处理器，然后React仅在用户点击按钮时调用该函数。以下示例中我们使用箭头函数，因为它更简洁，并且可以提高代码的可读性。如果你在事件处理器中调用该函数，那么该函数将在组件渲染时被调用，这可能导致无限循环：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'State updates are asynchronous, so you have to be careful when a new state
    value depends on the current state value. To be sure that the latest value is
    used, you can pass a function to the update function. You can see an example of
    this here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新是异步的，因此当新的状态值依赖于当前状态值时，你必须小心。为了确保使用最新的值，你可以将一个函数传递给更新函数。你可以在以下示例中看到这一点：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, the previous value is passed to the function, and the updated value is
    returned and saved to the `count` state.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将前一个值传递给函数，然后返回并保存到`count`状态中的更新值。
- en: There is also a hook function called `useReducer` that is recommended when you
    have a complex state, but we won’t cover that in this book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`useReducer`的钩子函数，当你有复杂的状态时推荐使用，但在此书中我们不会涉及这一点。
- en: Batching
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理
- en: 'React uses **batching** in state updates to reduce re-renders. Before React
    version 18, batching only worked in states updated during browser events – for
    example, a button click. The following example demonstrates the idea of batch
    updates:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: React使用**批处理**来更新状态以减少重新渲染。在React 18版本之前，批处理仅在浏览器事件期间更新的状态中起作用——例如，按钮点击。以下示例演示了批处理更新的概念：
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: From React version 18 onward, all state updates will be batched. If you don’t
    want to use batch updates in some cases, you can use the `react-dom` library’s
    `flushSync` API to avoid batching. For example, you might have a case where you
    want to update some state before updating the next one. It can be useful when
    incorporating third-party code, such as browser APIs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从 React 版本 18 开始，所有状态更新都将被批处理。如果你在某些情况下不想使用批处理更新，你可以使用 `react-dom` 库的 `flushSync`
    API 来避免批处理。例如，你可能有一个在更新下一个状态之前更新一些状态的情况。当整合第三方代码，如浏览器 API 时，这可能很有用。
- en: 'Here’s the code you’d need to do this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要执行的代码：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You should use `flushSync` only if it is needed, because it can affect the performance
    of your React app.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在需要时使用 `flushSync`，因为它可能会影响你的 React 应用的性能。
- en: useEffect
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect
- en: 'The `useEffect` hook function can be used to perform side effects in the React
    function component. The side effect can be, for example, a `fetch` request. The
    `useEffect` hook takes two arguments, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子函数可以用来在 React 函数组件中执行副作用。副作用可以是，例如，一个 `fetch` 请求。`useEffect`
    钩子接受两个参数，如以下所示：'
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `callback` function contains side-effect logic, and `[dependencies]` is
    an optional array of dependencies.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback` 函数包含副作用逻辑，`[dependencies]` 是一个可选的依赖数组。'
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the following screenshot, we can see what the console now looks like, and
    we can see that the `useEffect` callback is invoked after each render. The first
    log row is printed after the initial render, and the rest are printed after the
    button is pressed two times and the component is re-rendered due to state updates:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到控制台现在的样子，并且我们可以看到 `useEffect` 回调在每个渲染后都会被调用。第一条日志行是在初始渲染后打印的，其余的都是在按钮被按下两次并且组件由于状态更新而重新渲染后打印的：
- en: '![](img/B19818_08_07.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_07.png)'
- en: 'Figure 8.7: useEffect'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：useEffect
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you pass an empty array as the second argument, the `useEffect` callback
    function runs only after the first render, as shown in the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将空数组作为第二个参数传递，`useEffect` 回调函数只会在第一次渲染后运行，如下面的代码片段所示：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, you can see that **Hello from useEffect** is printed only once after the
    initial render, and if you press the button, the text is not printed. The message
    is printed twice after the first render due to React Strict Mode. Strict Mode
    renders your component twice in development mode to find bugs and does not impact
    the production build:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到在初始渲染后，**来自 useEffect 的问候** 只打印了一次，如果你按下按钮，文本就不会打印。由于 React Strict Mode，消息在第一次渲染后打印了两次。Strict
    Mode 在开发模式下渲染你的组件两次以查找错误，并且不会影响生产构建：
- en: '![](img/B19818_08_08.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_08.png)'
- en: 'Figure 8.8: useEffect with an empty array'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：带有空数组的 useEffect
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you run the counter app with these changes, you can see what happens in
    the console, as shown in the following screenshot. The component is rendered twice
    at the beginning due to Strict Mode. After the initial render, the component is
    unmounted (removed from the DOM), and therefore, the cleanup function is called:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这些更改运行计数器应用，你可以在控制台中看到发生的情况，如下面的屏幕截图所示。由于 Strict Mode，组件最初渲染了两次。在初始渲染后，组件被卸载（从
    DOM 中移除），因此会调用清理函数：
- en: '![](img/B19818_08_09.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_09.png)'
- en: 'Figure 8.9: Cleanup function'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：清理函数
- en: useRef
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useRef
- en: 'The `useRef` hook returns a mutable `ref` object that can be used, for example,
    to access DOM nodes. You can see it in action here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子返回一个可变的 `ref` 对象，可以用来访问 DOM 节点。你可以在以下操作中看到它：'
- en: '[PRE73]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `ref` object returned has a `current` property that is initialized with
    the argument passed (`initialValue`). In the next example, we create a `ref` object
    called `inputRef` and initialize it to `null`. Then, we use the JSX element’s
    `ref` property and pass our `ref` object to it. Now, it contains our `input` element,
    and we can use the `current` property to execute the `input` element’s `focus`
    function. Now, when the button is pressed, the input element is focused:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `ref` 对象具有一个 `current` 属性，该属性使用传递的参数初始化（`initialValue`）。在下一个示例中，我们创建了一个名为
    `inputRef` 的 `ref` 对象并将其初始化为 `null`。然后，我们使用 JSX 元素的 `ref` 属性并将我们的 `ref` 对象传递给它。现在，它包含我们的
    `input` 元素，我们可以使用 `current` 属性来执行 `input` 元素的 `focus` 函数。现在，当按钮被按下时，输入元素将被聚焦：
- en: '[PRE74]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this section, we have learned the basics of React hooks, and we will use
    them in practice when we start to implement our frontend. There are other useful
    hook functions available in React, and next you will learn how to create your
    own hooks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 React 钩子的基础知识，当我们开始实现前端时，我们将实际使用它们。React 中还有其他有用的钩子函数可用，接下来你将学习如何创建你自己的钩子。
- en: Custom hooks
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义钩子
- en: You can build your own hooks in React. As we have seen already, hooks’ names
    should start with the `use` word, and they are JavaScript functions. Custom hooks
    can also call other hooks. With custom hooks, you can reduce your component code
    complexity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 React 中构建自己的钩子。正如我们已经看到的，钩子的名称应该以 `use` 字符开头，并且它们是 JavaScript 函数。自定义钩子也可以调用其他钩子。使用自定义钩子，你可以减少组件代码的复杂性。
- en: 'Let’s go through a simple example of creating a custom hook:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来创建一个自定义钩子：
- en: 'We will create a `useTitle` hook that can be used to update a document title.
    We will define it in its own file called `useTitle.js`. First, we define a function,
    and it gets one argument named `title`. The code is illustrated in the following
    snippet:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 `useTitle` 钩子，它可以用来更新文档标题。我们将在名为 `useTitle.js` 的文件中定义它。首先，我们定义一个函数，它接受一个名为
    `title` 的参数。代码如下所示：
- en: '[PRE75]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we will use a `useEffect` hook to update the document title each time
    the `title` argument is changed, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `useEffect` 钩子来更新文档标题，每次 `title` 参数改变时，如下所示：
- en: '[PRE76]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we can start to use our custom hook. Let’s use it in our counter example
    and print the current counter value into the document title. First, we have to
    import the `useTitle` hook into our `Counter` component, like this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用我们的自定义钩子了。让我们在计数器示例中使用它，并将当前计数器的值打印到文档标题中。首先，我们必须将 `useTitle` 钩子导入到我们的
    `Counter` 组件中，如下所示：
- en: '[PRE77]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we will use the `useTitle` hook to print the `count` state value into
    the document title. We can call our hook function in the top level of the `Counter`
    component function, and every time the component is rendered, the `useTitle` hook
    function is called and we can see the current count value in the document title.
    The code is illustrated in the following snippet:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `useTitle` 钩子将 `count` 状态值打印到文档标题中。我们可以在 `Counter` 组件函数的最高级别调用我们的钩子函数，每次组件渲染时，`useTitle`
    钩子函数都会被调用，我们可以在文档标题中看到当前的计数器值。代码如下所示：
- en: '[PRE78]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, if you click the button, the `count` state value is also shown in the
    document title using our custom hook, as illustrated in the following screenshot:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击按钮，`count` 状态值也会通过我们的自定义钩子显示在文档标题中，如下面的截图所示：
- en: '![](img/B19818_08_10.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_08_10.png)'
- en: 'Figure 8.10: Custom hook'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：自定义钩子
- en: You now have basic knowledge of React hooks and how you can create your own
    custom hooks.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经掌握了 React 钩子（hooks）的基本知识以及如何创建你自己的自定义钩子。
- en: The Context API
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文 API
- en: Passing data using props can be cumbersome if your component tree is deep and
    complex. You have to pass data through all components down the component tree.
    **The Context API** solves this problem, and it is recommended for use with *global*
    data that you might need in multiple components throughout your component tree
    – for example, a theme or authenticated user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组件树很深且复杂，使用属性传递数据可能会很麻烦。你必须通过组件树中的所有组件传递数据。**上下文 API** 解决了这个问题，并且建议用于需要在整个组件树中的多个组件中使用
    *全局* 数据——例如，主题或认证用户。
- en: '**Context** is created using the `createContext` method, which takes an argument
    that defines the default value. You can create your own file for the context,
    and the code looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**是通过 `createContext` 方法创建的，该方法接受一个参数来定义默认值。你可以为上下文创建自己的文件，代码如下：'
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we will use a context provider component, which makes our context available
    for other components. The context provider component has a `value` prop that will
    be passed to consuming components. In the following example, we have wrapped `<MyComponent
    />` using the context provider component, so the `userName` value is available
    in our component tree under `<MyComponent />`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用上下文提供者组件，它使我们的上下文对其他组件可用。上下文提供者组件有一个 `value` 属性，它将被传递给消费组件。在以下示例中，我们使用上下文提供者组件包裹了
    `<MyComponent />`，因此 `userName` 值在我们的组件树中的 `<MyComponent />` 下可用：
- en: '[PRE80]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we can access the value provided in any component in the component tree
    by using the `useContext()` hook, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用 `useContext()` 钩子在任何组件树中的组件中访问提供的值，如下所示：
- en: '[PRE81]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The component now renders the `Welcome` `john` text.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 组件现在渲染了 `Welcome` `john` 文本。
- en: Handling lists with React
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 处理列表
- en: 'For list handling, we will learn about the JavaScript `map()` method, which
    is useful when you have to manipulate a list. The `map()` method creates a new
    array containing the results of calling a function on each element in the original
    array. In the following example, each array element is multiplied by `2`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表处理，我们将学习JavaScript的`map()`方法，这在您必须操作列表时非常有用。`map()`方法创建一个新的数组，该数组包含对原始数组中每个元素调用函数的结果。在下面的示例中，每个数组元素都乘以`2`：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following example code demonstrates a component that transforms an array
    of integers into an array of list items and renders these inside the `ul` element:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码演示了一个组件，该组件将整数数组转换为列表项数组，并在`ul`元素内渲染这些项：
- en: '[PRE83]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following screenshot shows what the component looks like when it is rendered.
    If you open the console, you can see a warning (**Each child in a list should
    have a unique** **"****key****"** **prop**):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了组件渲染后的样子。如果您打开控制台，您可以看到一个警告（**列表中的每个子项都应该有一个唯一的** **"****key****"** **属性**）：
- en: '![](img/B19818_08_11.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_08_11.png)'
- en: 'Figure 8.11: React list component'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：React列表组件
- en: 'List items in React need a **unique key** that is used to detect rows that
    have been updated, added, or deleted. The `map()` method also has `index` as a
    second argument, which we use to handle the warning:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: React中的列表项需要一个**唯一键**，该键用于检测已更新、添加或删除的行。`map()`方法也有`index`作为第二个参数，我们用它来处理警告：
- en: '[PRE84]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, after adding the key, there is no warning in the console.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加了键之后，控制台中没有警告。
- en: The usage of `index` is not recommended because it can cause bugs if the list
    is reordered or if you add or delete list items. Instead of that, you should use
    a unique key from the data if that exists. There are also libraries available
    that you can use to generate unique IDs, like **uuid** ([https://github.com/uuidjs/uuid](https://github.com/uuidjs/uuid)).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用`index`，因为如果列表被重新排序或添加或删除列表项，它可能会导致错误。相反，如果存在，您应该使用数据中的唯一键。还有一些库可供您使用，例如**uuid**([https://github.com/uuidjs/uuid](https://github.com/uuidjs/uuid))来生成唯一ID。
- en: 'If the data is an array of objects, it would be nicer to present it in table
    format. We do this in roughly the same way as we did with the list, but now we
    just map the array to table rows (`tr` elements) and render these inside the `table`
    element, as shown in the following component code. Now we have a unique ID in
    the data so we can use it as a key:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是对象数组，以表格格式呈现会更好。我们以与列表相同的方式执行此操作，但现在我们只是将数组映射到表格行（`tr`元素）并在`table`元素内渲染这些行，如下面的组件代码所示。现在数据中有一个唯一的ID，因此我们可以将其用作键：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following screenshot shows what the component looks like when it is rendered.
    You should see the data in the HTML table:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了组件渲染后的样子。您应该在HTML表格中看到数据：
- en: '![](img/B19818_08_12.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_08_12.png)'
- en: 'Figure 8.12: React table'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：React表格
- en: Now, we have learned how to handle list data using the `map()` method and how
    to render it using, for example, an HTML `table` element.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学习了如何使用`map()`方法处理列表数据，以及如何使用例如HTML `table`元素来渲染它。
- en: Handling events with React
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React处理事件
- en: 'Event handling in React is similar to handling DOM element events. The difference
    compared to HTML event handling is that event naming uses *camelCase* in React.
    The following sample component code adds an event listener to a button and shows
    an alert message when the button is pressed:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: React中的事件处理类似于处理DOM元素事件。与HTML事件处理相比，区别在于React中事件命名使用*camelCase*。以下示例组件代码向按钮添加事件监听器，并在按钮被按下时显示警告消息：
- en: '[PRE86]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'As we learned earlier in the counter example, you have to pass a function to
    the event handler instead of calling it. Now, the `handleClick` function is defined
    outside the `return` statement, and we can refer to it using the function name:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的计数器示例中学到的那样，您必须将函数传递给事件处理器而不是调用它。现在，`handleClick`函数在`return`语句外部定义，我们可以通过函数名来引用它：
- en: '[PRE87]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In React, you cannot return `false` from the event handler to prevent the default
    behavior. Instead, you should call the event object’s `preventDefault()` method.
    In the following example, we are using a `form` element, and we want to prevent
    form submission:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，您不能从事件处理器返回`false`以防止默认行为。相反，您应该调用事件对象的`preventDefault()`方法。在以下示例中，我们使用一个`form`元素，我们想要防止表单提交：
- en: '[PRE88]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, when you press the **Submit** button, you can see the alert and the form
    will not be submitted.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您按下**提交**按钮时，您可以看到警告，并且表单将不会提交。
- en: Handling forms with React
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React处理表单
- en: Form handling is a little bit different with React. An HTML `form` will navigate
    to the next page when it is submitted. In React, often, we want to invoke a JavaScript
    function that has access to form data after submission, and avoid navigating to
    the next page. We already covered how to avoid submission in the previous section
    using `preventDefault()`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中处理表单略有不同。一个HTML `form`在提交时会导航到下一页。在React中，我们通常希望在提交后调用一个可以访问表单数据的JavaScript函数，并避免导航到下一页。我们已经在上一节中介绍了如何使用`preventDefault()`来避免提交。
- en: Let’s first create a minimalistic form with one input field and a **Submit**
    button. In order to get the value of the input field, we use the `onChange` event
    handler. We use the `useState` hook to create a state variable called `text`.
    When the value of the input field is changed, the new value will be saved to the
    state. This component is called a **controlled component** because form data is
    handled by React. In an uncontrolled component, the form data is handled only
    by the DOM.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个包含一个输入字段和一个**提交**按钮的最简表单。为了获取输入字段的值，我们使用`onChange`事件处理程序。我们使用`useState`钩子创建一个名为`text`的状态变量。当输入字段的值发生变化时，新值将被保存到状态中。这个组件被称为**受控组件**，因为表单数据由React处理。在非受控组件中，表单数据仅由DOM处理。
- en: 'The `setText(event.target.value)` statement gets the value from the `input`
    field and saves it to the state. Finally, we will show the typed value when a
    user presses the **Submit** button. Here is the source code for our first form:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`setText(event.target.value)`语句从`input`字段获取值并将其保存到状态中。最后，当用户按下**提交**按钮时，我们将显示输入的值。以下是我们的第一个表单的源代码：'
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is a screenshot of our form component after the **Submit** button has
    been pressed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下**提交**按钮后，这是我们的表单组件的截图：
- en: '![](img/B19818_08_13.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_13.png)'
- en: 'Figure 8.13: Form component'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：表单组件
- en: 'You can also write an inline `onChange` handler function using JSX, as shown
    in the following example. This is quite common practice if you have a simple event
    handler function, and it makes your code more readable:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用JSX编写内联`onChange`处理程序函数，如下例所示。如果你有一个简单的处理程序函数，这是一种相当常见的做法，它可以使你的代码更易于阅读：
- en: '[PRE90]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now is a good time to look at React Developer Tools, which are useful for debugging
    React apps.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是查看React开发者工具的好时机，这对于调试React应用非常有用。
- en: If you haven’t installed React Developer Tools yet, you can find the instructions
    in *Chapter 7*, *Setting Up the Environment and Tools – Frontend*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装React开发者工具，你可以在*第7章*中找到说明，*设置环境和工具 – 前端*。
- en: If we open the React Developer Tools **Components** tab with our React form
    app and type something into the input field, we can see how the value of the state
    changes, and we can inspect the current value of both the props and the state.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用我们的React表单应用打开React开发者工具的**组件**标签，并在输入字段中输入一些内容，我们可以看到状态值是如何变化的，并且我们可以检查props和状态当前的值。
- en: 'The following screenshot shows how the state changes when we type something
    into the input field:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们在输入字段中输入内容时状态是如何变化的：
- en: '![](img/B19818_08_14.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_14.png)'
- en: 'Figure 8.14: React Developer Tools'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：React开发者工具
- en: '[PRE91]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'One way to handle multiple input fields is to add as many change handlers as
    we have input fields, but this creates a lot of boilerplate code, which we want
    to avoid. Therefore, we add `name` attributes to our input fields. We can utilize
    these in the change handler to identify which input field triggers the change
    handler. The `name` attribute value of the `input` element must be the same as
    the name of the state object property in which we want to save the value, and
    the value attribute should be `object.property`, for example, in the last name
    input element. The code is illustrated here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个输入字段的一种方法是为每个输入字段添加尽可能多的更改处理程序，但这会创建大量的样板代码，我们希望避免。因此，我们在输入字段中添加`name`属性。我们可以在更改处理程序中使用这些属性来识别哪个输入字段触发了更改处理程序。`input`元素的`name`属性值必须与我们想要保存值的state对象属性的名称相同，值属性应该是`object.property`，例如，在姓氏输入元素中。代码如下所示：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, if the input field that triggers the handler is the last name field, then
    `event.target.name` is `lastName`, and the typed value will be saved to the state
    object’s `lastName` field. Here, we will also use the object spread notation that
    was introduced in the *Props and state* section. In this way, we can handle all
    input fields with the one change handler:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果触发处理器的输入字段是姓氏字段，那么 `event.target.name` 就是 `lastName`，并且输入的值将被保存到状态对象的 `lastName`
    字段。在这里，我们还将使用在 *Props 和状态* 部分中引入的对象展开运算符。这样，我们可以使用一个更改处理器来处理所有输入字段：
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here is the full source code for the component:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组件的完整源代码：
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here is a screenshot of our form component after the **Submit** button has
    been pressed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提交按钮被按下后我们的表单组件的截图：
- en: '![](img/B19818_08_15.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_08_15.png)'
- en: 'Figure 8.15: React form component'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15：React 表单组件
- en: '[PRE96]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We now know how to handle forms with React, and we will use these skills later
    when we implement our frontend.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何使用 React 处理表单，我们将在实现前端时使用这些技能。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to learn about React, which we will be using to
    build our frontend. In our frontend development, we will use ES6, which makes
    our code cleaner, as we saw in the chapter. Before starting to develop with React,
    we covered the basics, such as the React component, JSX, props, state, and hooks.
    We then went through the features we need for further development. We learned
    about conditional rendering and context, as well as how to handle lists, forms,
    and events with React.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习 React，我们将使用它来构建我们的前端。在我们的前端开发中，我们将使用 ES6，这使得我们的代码更简洁，正如我们在本章中看到的。在开始使用
    React 进行开发之前，我们涵盖了基础知识，例如 React 组件、JSX、props、state 和 hooks。然后我们探讨了进一步开发所需的功能。我们学习了条件渲染和上下文，以及如何使用
    React 处理列表、表单和事件。
- en: In the next chapter, we will focus on TypeScript with React. We will learn the
    basics of TypeScript and how to use it in our React projects.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于 TypeScript 与 React。我们将学习 TypeScript 的基础知识以及如何在我们的 React 项目中使用它。
- en: Questions
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a React component?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 React 组件？
- en: What are states and props?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态和 props 是什么？
- en: How does data flow in a React app?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 应用程序中的数据是如何流动的？
- en: What is the difference between stateless and stateful components?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无状态组件和有状态组件有什么区别？
- en: What is JSX?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSX 是什么？
- en: How are React hooks named?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 钩子是如何命名的？
- en: How does context work?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文是如何工作的？
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some other good resources for learning about React:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他关于学习 React 的好资源：
- en: '*React – The Complete Guide*, by Maximilian Schwarzmüller ([https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603](https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603))'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《React 完全指南》*，作者 Maximilian Schwarzmüller ([https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603](https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603))'
- en: '*The Ultimate React Course 2023*, by Jonas Schmedtmann ([https://www.udemy.com/course/the-ultimate-react-course/](https://www.udemy.com/course/the-ultimate-react-course/))'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《2023 年终极 React 课程》*，作者 Jonas Schmedtmann ([https://www.udemy.com/course/the-ultimate-react-course/](https://www.udemy.com/course/the-ultimate-react-course/))'
- en: Learn more on Discord
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里你可以分享反馈、向作者提问，并了解新发布的内容——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10796108009382640.png)'
