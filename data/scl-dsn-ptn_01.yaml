- en: The Design Patterns Out There and Setting Up Your Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有的设计模式和设置您的环境
- en: In the world of computer programming, there are multiple ways to create a solution
    to a given problem. However, some might wonder whether there is a correct way
    of achieving a specific task. The answer is yes; there is always a right way,
    but in software development, there are usually multiple right ways to achieve
    a task. Some factors exist that guide the programmer to the right solution and,
    depending on them, people tend to get the expected result. These factors could
    define many things—the actual language being used, the algorithm, the type of
    executable produced, the output format, and the code structure. In this book,
    the language is already chosen for us—Scala. There are, however, a number of ways
    to use Scala, and we will be focusing on them—the design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的世界里，有多种方式来解决给定的问题。然而，有些人可能会想知道是否有一种正确的方法来实现特定的任务。答案是肯定的；总有一种正确的方法，但在软件开发中，通常有多种正确的方法来实现任务。存在一些因素可以指导程序员找到正确的解决方案，并且根据这些因素，人们往往能够得到预期的结果。这些因素可以定义许多事情——实际使用的语言、算法、生成的可执行文件类型、输出格式以及代码结构。在这本书中，语言已经为我们选择了——Scala。然而，使用Scala的方法有很多，我们将重点关注它们——设计模式。
- en: 'In this chapter, we will explain what design patterns are and why they exist.
    We will go through the different types of design patterns that are out there.
    This book aims to provide useful examples to aid you in the learning process,
    and being able to run them easily is key. Hence, some points on how to set up
    a development environment properly will be given here. The top-level topics we
    will go through are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释什么是设计模式以及它们为什么存在。我们将介绍现有的不同类型的设计模式。本书旨在提供有用的示例，以帮助您在学习过程中，能够轻松运行它们是关键。因此，这里将给出一些关于如何正确设置开发环境的要点。我们将讨论的顶级主题如下：
- en: What is a design pattern and why do they exist?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式以及它们为什么存在？
- en: The main types of design patterns and their features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的主要类型及其特点
- en: Choosing the right design pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的设计模式
- en: Setting up a development environment in real life
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实生活中设置开发环境
- en: The last point doesn't have much to do with design patterns. However, it is
    always a good idea to build projects properly, as this makes it much easier to
    work in the future.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点与设计模式关系不大。然而，始终正确地构建项目是一个好主意，因为这会使未来的工作变得容易得多。
- en: Design patterns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Before delving into the Scala design patterns, we have to explain what they
    actually are, why they exist, and why it is worth being familiar with them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Scala设计模式之前，我们必须解释它们实际上是什么，为什么它们存在，以及为什么熟悉它们是值得的。
- en: Software is a broad subject, and there are innumerable examples of things people
    can do with it. At first glance, most of these things are completely different—games,
    websites, mobile phone applications, and specialized systems for different industries.
    There are, however, many similarities in how software is built. Many times, people
    have to deal with similar issues, no matter the type of software they create.
    For example, computer games, as well as websites, might need to access a database.
    And throughout time, by experience, developers learn how structuring their code
    differs for the various tasks that they perform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是一个广泛的领域，人们可以用它做无数的事情。乍一看，这些事情大多数都是完全不同的——游戏、网站、手机应用程序以及为不同行业定制的系统。然而，在软件构建方面有许多相似之处。很多时候，无论他们创建的软件类型如何，人们都必须处理类似的问题。例如，计算机游戏和网站可能需要访问数据库。随着时间的推移，通过经验，开发者了解到他们如何根据他们执行的各种任务来结构化他们的代码。
- en: The formal definition for design patterns
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的正式定义
- en: A design pattern is a reusable solution to a recurring problem in software design.
    It is not a finished piece of code but a template that helps to solve a particular
    problem or family of problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是对软件设计中反复出现的问题的可重用解决方案。它不是一个完整的代码片段，而是一个模板，有助于解决特定问题或一系列问题。
- en: Design patterns are best practices at which the software community has arrived
    over a period of time. They are supposed to help you write efficient, readable,
    testable, and easily extendable code. In some cases, they can be the result of
    a programming language not being expressive enough to elegantly achieve a goal.
    This means that more feature-rich languages might not even need a design pattern,
    while others still do. Scala is one of those rich languages, and in some cases,
    it makes the use of some design patterns obsolete or simpler. We will see how
    exactly it does that in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件社区经过一段时间积累的最佳实践。它们旨在帮助你编写高效、可读、可测试且易于扩展的代码。在某些情况下，它们可能是由于编程语言表达能力不足而无法优雅地实现目标的结果。这意味着功能更丰富的语言可能甚至不需要设计模式，而其他语言仍然需要。Scala
    就是这些丰富语言之一，在某些情况下，它使得某些设计模式变得过时或更简单。我们将在本书中看到它是如何做到这一点的。
- en: The lack or existence of a certain functionality within a programming language
    also makes it able to implement additional design patterns that others cannot.
    The opposite is also valid—it might not be able to implement things that others
    can.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中是否存在某种功能，也使得它能够实现其他语言无法实现的设计模式。反之亦然——它可能无法实现其他语言可以实现的事情。
- en: Scala and design patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 和设计模式
- en: Scala is a hybrid language that combines features from object-oriented and functional
    languages. This not only allows it to keep some of the well-known object-oriented
    design patterns relevant, but also provides various other ways of exploiting its
    features to write code that is clean, efficient, testable, and extendable all
    at the same time. The hybrid nature of the language also makes some of the traditional
    object-oriented design patterns obsolete, or possible, using other cleaner techniques.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种混合语言，它结合了面向对象和函数式语言的特点。这不仅使它能够保持一些已知的面向对象设计模式的相关性，而且还提供了各种其他方式来利用其特性，以编写既干净、高效、可测试又可扩展的代码。语言的混合特性也使得一些传统的面向对象设计模式变得过时，或者可以通过其他更干净的技术来实现。
- en: The need for design patterns and their benefits
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要设计模式和它们的益处
- en: Writing code without the conscious use of a design pattern is something many
    software engineers do. In the end, however, they either end up using one without
    realizing it, or they end up with code that can be improved in some way. As we
    mentioned earlier, design patterns help to write efficient, readable, extendable,
    and testable code. All these features are really important to companies in the
    industry.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有有意识地使用设计模式的情况下编写代码是许多软件工程师的做法。然而，最终，他们要么在不经意间使用了某个模式，要么得到的代码在某些方面可以改进。正如我们之前提到的，设计模式有助于编写高效、可读、可扩展和可测试的代码。所有这些特性对于行业中的公司来说都非常重要。
- en: Even though in some cases it is preferable to quickly write a prototype and
    get it out, it is more usually the case that a piece of software is supposed to
    evolve. Maybe you will have experience of extending some badly written code, but
    regardless, it is a challenging task and takes a really long time, and sometimes
    it feels that rewriting it would be easier. Moreover, this makes introducing bugs
    into the system much more likely.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些情况下，快速编写原型并尽快推出可能更可取，但通常情况下，软件应该会演变。也许你会有扩展一些编写糟糕的代码的经验，但无论如何，这都是一项具有挑战性的任务，需要花费很长时间，有时甚至觉得重写它会更简单。此外，这也使得向系统中引入错误的可能性大大增加。
- en: Code readability is also something that should be appreciated. Of course, one
    could use a design pattern and still have their code hard to read, but generally,
    design patterns help. Big systems are usually worked on by many people, and everyone
    should be able to understand what exactly is going on. Also, people who join a
    team are able to integrate much more easily and quickly if they are working on
    a well-written piece of software.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可读性也是应该被重视的一点。当然，即使使用设计模式，代码也可能难以阅读，但通常来说，设计模式是有帮助的。大型系统通常由许多人共同开发，每个人都应该能够理解正在发生的事情。此外，如果团队成员在编写一个编写良好的软件项目，他们能够更容易、更快地融入团队。
- en: Testability is something that prevents developers from introducing bugs when
    writing or extending code. In some cases, code could be created so badly that
    it is not even testable. Design patterns are supposed to eliminate these problems
    as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性是防止开发者在编写或扩展代码时引入错误的一个因素。在某些情况下，代码可能编写得如此糟糕，以至于根本无法进行测试。设计模式旨在消除这些问题。
- en: While efficiency is often connected with algorithms, design patterns could also
    affect it. A simple example could be an object that takes a long time to instantiate,
    and instances are used in many places in an application, but could be made a singleton
    instead. You will see more concrete examples in the later chapters of this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然效率通常与算法相关联，但设计模式也可能影响效率。一个简单的例子是一个需要很长时间才能实例化的对象，在应用程序的许多地方使用实例，但可以将其改为单例。你将在本书的后续章节中看到更多具体的例子。
- en: Design pattern categories
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式类别
- en: The fact that software development is an extremely broad topic leads to a number
    of things that can be done with programming. Requirements can vary greatly between
    different industries and engineering teams. These facts have caused many different
    design patterns to be invented. This is further contributed to by the existence
    of various programming languages with different features and levels of expressiveness.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发是一个极其广泛的话题，这导致了许多可以用编程来完成的事情。不同行业和工程团队的需求可能会有很大差异。这些事实导致了众多不同设计模式的发明。此外，存在各种具有不同特性和表达能力的编程语言也进一步促进了这一点。
- en: This book focuses on the design patterns from the point of view of Scala. As
    we mentioned previously, Scala is a hybrid language. This leads us to a few famous
    design patterns that are not needed anymore—one example is the null object design
    pattern, which can simply be replaced by Scala's `Option`. Other design patterns
    become possible using different approaches—the decorator design pattern can be
    implemented using stackable traits. Finally, some new design patterns become available
    that are applicable specifically to the Scala programming language—the cake design
    pattern, pimp my library, and so on. We will focus on all of these and make it
    clear where the richness of Scala helps us to make our code even cleaner and simpler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从Scala的角度关注设计模式。正如我们之前提到的，Scala是一种混合语言。这导致了一些著名的设计模式不再需要——一个例子是null对象设计模式，它可以简单地用Scala的`Option`替换。其他设计模式可以通过不同的方法实现——装饰者设计模式可以使用可堆叠特质实现。最后，一些新的设计模式变得可用，这些模式专门适用于Scala编程语言——如蛋糕设计模式、pimp
    my library等。我们将关注所有这些，并清楚地说明Scala的丰富性如何帮助我们使代码更加简洁和简单。
- en: 'Even if there are many different design patterns, they can all be grouped in
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有众多不同的设计模式，它们都可以归纳为以下几类：
- en: Creational
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型
- en: Structural
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构型
- en: Behavioral
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为型
- en: Functional
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式
- en: Scala-specific design patterns
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala特定设计模式
- en: Some of the design patterns that are specific to Scala can be assigned to the
    previous groups. They can either be additions or replacements of the already existing
    ones. They are typical to Scala and take advantage of some advanced language features
    or simply features not available in other languages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特定于Scala的设计模式可以被分配到之前的组中。它们可以是现有模式的补充或替代。它们是Scala的典型代表，利用了一些高级语言特性或仅在其他语言中不可用的特性。
- en: The first three groups contain the famous *Gang of Four* design patterns. Every
    design pattern book covers them and so will we. The rest, even if they can be
    assigned to one of the first three groups, will be specific to Scala and functional
    programming languages. In the next few subsections, we will explain the main characteristics
    of the listed groups and briefly present the actual design patterns that fall
    under them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个组包含著名的*四人帮*设计模式。每本设计模式书籍都会涵盖它们，我们也不例外。其余的，即使它们可以被分配到前三个组中，也将是Scala和函数式编程语言的特定模式。在接下来的几个小节中，我们将解释所列组的特征，并简要介绍属于它们的设计模式。
- en: Creational design patterns
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'The creational design patterns deal with object creation mechanisms. Their
    purpose is to create objects in a way that is suitable to the current situation,
    which could lead to unnecessary complexity and the need for extra knowledge if
    they were not there. The main ideas behind the creational design patterns are
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式处理对象创建机制。它们的目的是以适合当前情况的方式创建对象，如果没有这些模式，可能会导致不必要的复杂性和额外知识的需求。创建型设计模式背后的主要思想如下：
- en: Knowledge encapsulation about the concrete classes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于具体类的知识封装
- en: Hiding details about the actual creation and how objects are combined
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏实际创建和对象组合的细节
- en: 'We will be focusing on the following creational design patterns in this book:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点关注以下创建型设计模式：
- en: The abstract factory design pattern
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: The factory method design pattern
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法设计模式
- en: The lazy initialization design pattern
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载初始化设计模式
- en: The singleton design pattern
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: The object pool design pattern
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池设计模式
- en: The builder design pattern
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者设计模式
- en: The prototype design pattern
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型设计模式
- en: The following few sections give a brief definition of what these patterns are.
    They will be looked at in depth individually later in this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节简要定义了这些模式是什么。它们将在本书稍后的部分进行深入探讨。
- en: The abstract factory design pattern
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: This is used to encapsulate a group of individual factories that have a common
    theme. When used, the developer creates a specific implementation of the abstract
    factory and uses its methods in the same way as in the factory design pattern
    to create objects. It can be thought of as another layer of abstraction that helps
    to instantiate classes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于封装具有共同主题的一组单独的工厂。当使用时，开发者创建抽象工厂的具体实现，并像在工厂设计模式中一样使用其方法来创建对象。它可以被视为另一层抽象，有助于实例化类。
- en: The factory method design pattern
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法设计模式
- en: This design pattern deals with the creation of objects without explicitly specifying
    the actual class that the instance will have—it could be something that is decided
    at runtime based on many factors. Some of these factors can include operating
    systems, different data types, or input parameters. It gives developers the peace
    of mind of just calling a method rather than invoking a concrete constructor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式处理对象的创建，而不需要显式指定实例将具有的实际类——它可能是基于许多因素在运行时决定的某物。这些因素可能包括操作系统、不同的数据类型或输入参数。它给开发者带来了只需调用方法而不是调用具体构造函数的安心。
- en: The lazy initialization design pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载初始化设计模式
- en: This design pattern is an approach to delay the creation of an object or the
    evaluation of a value until the first time it is needed. It is much more simplified
    in Scala than it is in an object-oriented language such as Java.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式是一种延迟创建对象或评估值的方法，直到第一次需要时。在Scala中，它比在Java这样的面向对象语言中要简单得多。
- en: The singleton design pattern
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: This design pattern restricts the creation of a specific class to just one object.
    If more than one class in the application tries to use such an instance, then
    this same instance is returned for everyone. This is another design pattern that
    can be easily achieved with the use of basic Scala features.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式将特定类的创建限制为仅一个对象。如果应用程序中的多个类试图使用此类实例，则返回相同的实例给所有人。这是另一种可以通过使用基本Scala特性轻松实现的设计模式。
- en: The object pool design pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池设计模式
- en: This design pattern uses a pool of objects that are already instantiated and
    ready for use. Whenever someone requires an object from the pool, it is returned,
    and after the user is finished with it, it puts it back into the pool manually
    or automatically. A common use for pools are database connections, which generally
    are expensive to create; hence, they are created once and then served to the application
    on request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式使用一个已经实例化并准备好使用的对象池。每当有人需要池中的对象时，它就会被返回，用户使用完毕后，它会手动或自动将其放回池中。池的常见用途是数据库连接，通常创建成本高昂；因此，它们一旦创建，就会在请求时提供给应用程序。
- en: The builder design pattern
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建者设计模式
- en: The builder design pattern is extremely useful for objects with many possible
    constructor parameters that would otherwise require developers to create many
    overrides for the different scenarios an object could be created in. This is different
    to the factory design pattern, which aims to enable polymorphism. Many of the
    modern libraries today employ this design pattern. As we will see later, Scala
    can achieve this pattern really easily.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者设计模式对于具有许多可能构造参数的对象来说极其有用，否则开发者需要为对象可能创建的不同场景创建许多重写。这与工厂设计模式不同，工厂设计模式旨在实现多态。许多现代库今天都采用这种设计模式。正如我们稍后将会看到的，Scala可以非常容易地实现这种模式。
- en: The prototype design pattern
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式
- en: This design pattern allows object creation using a `clone()` method from an
    already created instance. It can be used in cases when a specific resource is
    expensive to create or when the abstract factory pattern is not desired.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式允许使用已创建实例的`clone()`方法进行对象创建。在创建特定资源成本高昂或不需要抽象工厂模式的情况下，可以使用它。
- en: Structural design patterns
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化设计模式
- en: 'Structural design patterns exist in order to help establish the relationships
    between different entities in order to form larger structures. They define how
    each component should be structured so that it has very flexible interconnecting
    modules that can work together in a larger system. The main features of structural
    design patterns include the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式的存在是为了帮助建立不同实体之间的关系，以便形成更大的结构。它们定义了每个组件应该如何构建，以便它具有非常灵活的互联模块，可以在更大的系统中协同工作。结构设计模式的主要特点包括以下内容：
- en: The use of composition to combine the implementations of multiple objects
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合来组合多个对象的实现
- en: Help build a large system made of various components by maintaining a high level
    of flexibility
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过保持高度的灵活性，帮助构建由各种组件组成的大型系统
- en: 'In this book, we will focus on the following structural design patterns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注以下结构设计模式：
- en: The adapter design pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: The decorator design pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: The bridge design pattern
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接设计模式
- en: The composite design pattern
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: The facade design pattern
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面设计模式
- en: The flyweight design pattern
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元设计模式
- en: The proxy design pattern
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: The next subsections will put some light on what these patterns are about before
    we delve into them later in this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在这本书的后续部分深入探讨这些模式之前，下一小节将简要介绍这些模式的内容。
- en: The adapter design pattern
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: The adapter design pattern allows the interface of an existing class to be used
    from another interface. Imagine that there is a client who expects your class
    to expose a `doWork()` method. You might have the implementation ready in another
    class, but the method is called differently and is incompatible. It might require
    extra parameters too. This could also be a library that the developer doesn't
    have access to for modifications. This is where the adapter can help by wrapping
    the functionality and exposing the required methods. The adapter is useful for
    integrating the existing components. In Scala, the adapter design pattern can
    be easily achieved using implicit classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式允许使用另一个接口使用现有类的接口。想象一下，有一个客户端期望你的类公开一个`doWork()`方法。你可能已经在另一个类中准备好了实现，但方法的调用方式不同且不兼容。可能还需要额外的参数。这也可能是一个开发者无法修改的库。这就是适配器通过包装功能并公开所需方法来帮助的地方。适配器对于集成现有组件非常有用。在Scala中，可以使用隐式类轻松实现适配器设计模式。
- en: The decorator design pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: Decorators are a flexible alternative to sub classing. They allow developers
    to extend the functionality of an object without affecting other instances of
    the same class. This is achieved by wrapping an object of the extended class into
    one that extends the same class and overrides the methods whose functionality
    is supposed to be changed. Decorators in Scala can be built much more easily using
    another design pattern called **stackable traits**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是子类化的灵活替代方案。它们允许开发者在不影响同一类其他实例的情况下扩展对象的功能。这是通过将扩展类的对象包装在一个扩展相同类并覆盖那些需要改变功能的方法的对象中实现的。在Scala中，可以使用另一个称为**可堆叠特质**的设计模式来更轻松地构建装饰器。
- en: The bridge design pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式
- en: The purpose of the bridge design pattern is to decouple an abstraction from
    its implementation so that the two can vary independently. It is useful when the
    class and its functionality vary a lot. The bridge reminds us of the adapter pattern,
    but the difference is that the adapter pattern is used when something is already
    there and you cannot change it, while the bridge design pattern is used when things
    are being built. It helps us to avoid ending up with multiple concrete classes
    that will be exposed to the client. You will get a clearer understanding when
    we delve deeper in the topic, but for now, let's imagine that we want to have
    a `FileReader` class that supports multiple different platforms. The bridge will
    help us end up with `FileReader`, which will use a different implementation, depending
    on the platform. In Scala, we can use self-types in order to implement a bridge
    design pattern.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式的目的在于将抽象与其实现解耦，以便两者可以独立变化。当类及其功能变化很大时，它很有用。桥接模式让我们想起了适配器模式，但不同之处在于适配器模式用于当某物已经存在且无法更改时，而桥接设计模式用于构建事物时。它帮助我们避免最终产生多个将暴露给客户端的具体类。当我们更深入地探讨这个主题时，你会得到更清晰的理解，但到目前为止，让我们想象我们想要有一个支持多个不同平台的`FileReader`类。桥接模式将帮助我们得到`FileReader`，它将根据平台使用不同的实现。在Scala中，我们可以使用自类型来实现桥接设计模式。
- en: The composite design pattern
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: The composite is a partitioning design pattern that represents a group of objects
    that are to be treated as only one object. It allows developers to treat individual
    objects and compositions uniformly and to build complex hierarchies without complicating
    the source code. An example of composite could be a tree structure where a node
    can contain other nodes, and so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种分区设计模式，它表示一组将被视为单个对象的对象。它允许开发者以统一的方式处理单个对象和组合，并在不复杂化源代码的情况下构建复杂的层次结构。组合的一个例子可以是树结构，其中节点可以包含其他节点，依此类推。
- en: The facade design pattern
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门面设计模式
- en: The purpose of the facade design pattern is to hide the complexity of a system
    and its implementation details by providing the client with a simpler interface
    to use. This also helps to make the code more readable and to reduce the dependencies
    of the outside code. It works as a wrapper around the system that is being simplified
    and, of course, it can be used in conjunction with some of the other design patterns
    mentioned previously.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 门面设计模式的目的在于通过向客户端提供一个更简单的接口来使用，从而隐藏系统的复杂性和其实施细节。这也帮助代码更易于阅读，并减少外部代码的依赖。它作为简化系统的包装器，当然，它可以与其他之前提到的设计模式一起使用。
- en: The flyweight design pattern
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元设计模式
- en: The flyweight design pattern provides an object that is used to minimize memory
    usage by sharing it throughout the application. This object should contain as
    much data as possible. A common example given is a word processor, where each
    character's graphical representation is shared with the other same characters.
    The local information then is only the position of the character, which is stored
    internally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 享元设计模式提供了一个对象，该对象通过在整个应用程序中共享来最小化内存使用。这个对象应该包含尽可能多的数据。一个常见的例子是文字处理器，其中每个字符的图形表示都与其他相同的字符共享。局部信息只是字符的位置，该位置在内部存储。
- en: The proxy design pattern
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: The proxy design pattern allows developers to provide an interface to other
    objects by wrapping them. They can also provide additional functionality, for
    example, security or thread-safety. Proxies can be used together with the flyweight
    pattern, where the references to shared objects are wrapped inside proxy objects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式允许开发者通过包装其他对象来为它们提供接口。他们还可以提供额外的功能，例如安全性或线程安全性。代理可以与享元模式一起使用，其中对共享对象的引用被包装在代理对象内部。
- en: Behavioral design patterns
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Behavioral design patterns increase communication flexibility between objects
    based on the specific ways they interact with each other. Here, creational patterns
    mostly describe a moment in time during creation, structural patterns describe
    a more or less static structure, and behavioral patterns describe a process or
    flow. They simplify this flow and make it more understandable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式通过基于对象之间相互交互的具体方式来增加对象之间的通信灵活性。在这里，创建型模式主要描述创建过程中的一个时刻，结构型模式描述一个更多或更少的静态结构，而行为模式描述一个过程或流程。它们简化了这个流程，使其更容易理解。
- en: 'The main features of behavioral design patterns are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式的主要特点如下：
- en: What is being described is a process or flow
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所描述的是一种过程或流程
- en: The flows are simplified and made understandable
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程被简化并变得易于理解
- en: They accomplish tasks that would be difficult or impossible to achieve with
    objects
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们完成那些用对象难以或无法实现的任务
- en: 'In this book, we will focus our attention on the following behavioral design
    patterns:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将关注以下行为设计模式：
- en: The value object design pattern
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象设计模式
- en: The null object design pattern
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空对象设计模式
- en: The strategy design pattern
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The command design pattern
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: The chain of responsibility design pattern
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: The interpreter design pattern
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器设计模式
- en: The iterator design pattern
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器设计模式
- en: The mediator design pattern
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者设计模式
- en: The memento design pattern
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录设计模式
- en: The observer design pattern
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: The state design pattern
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: The template method design pattern
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法设计模式
- en: The visitor design pattern
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: The following subsections will give brief definitions of the aforementioned
    behavioral design patterns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将简要定义上述行为设计模式。
- en: The value object design pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象设计模式
- en: Value objects are immutable and their equality is based not on their identity,
    but on their fields being equal. They can be used as data transfer objects, and
    they can represent dates, colors, money amounts, numbers, and more. Their immutability
    makes them really useful in multithreaded programming. The Scala programming language
    promotes immutability, and value objects are something that naturally occur there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是不可变的，它们的相等性不是基于它们的身份，而是基于它们的字段相等。它们可以用作数据传输对象，并且可以代表日期、颜色、金额、数字等。它们的不可变性使它们在多线程编程中非常有用。Scala编程语言推崇不可变性，值对象是那里自然发生的事物。
- en: The null object design pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象设计模式
- en: Null objects represent the absence of a value and they define a neutral behavior.
    This approach removes the need to check for `null` references and makes the code
    much more concise. Scala adds the concept of optional values, which can replace
    this pattern completely.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象代表值的缺失，并且它们定义了一种中立的行为。这种方法消除了检查`null`引用的需要，并使代码更加简洁。Scala添加了可选值的概念，这可以完全替代此模式。
- en: The strategy design pattern
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The strategy design pattern allows algorithms to be selected at runtime. It
    defines a family of interchangeable encapsulated algorithms and exposes a common
    interface to the client. Which algorithm is chosen could depend on various factors
    that are determined while the application runs. In Scala, we can simply pass a
    function as a parameter to a method, and depending on the function, a different
    action will be performed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式允许在运行时选择算法。它定义了一组可互换的封装算法，并向客户端提供了一个公共接口。所选择的算法可能取决于在应用程序运行时确定的多种因素。在Scala中，我们可以简单地将一个函数作为参数传递给一个方法，根据函数的不同，将执行不同的操作。
- en: The command design pattern
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: 'This design pattern represents an object that is used to store information
    about an action that needs to be triggered at a later time. The information includes
    the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计模式代表一个用于存储有关需要在以后某个时间触发的动作信息的对象。信息包括以下内容：
- en: The method name
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称
- en: The owner of the method
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的所有者
- en: Parameter values
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数值
- en: The client then decides which commands need to be executed and when by the invoker.
    This design pattern can easily be implemented in Scala using the by-name parameters
    feature of the language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端随后决定由调用者执行哪些命令以及何时执行。这种设计模式可以很容易地使用Scala语言中按名称传递参数的功能实现。
- en: The chain of responsibility design pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: The chain of responsibility is a design pattern where the sender of a request
    is decoupled from its receiver. This way, it makes it possible for multiple objects
    to handle the request and to keep logic nicely separated. The receivers form a
    chain where they pass the request and, if possible, they process it, and if not,
    they pass it to the next receiver. There are variations where a handler might
    dispatch the request to multiple other handlers at the same time. This somehow
    reminds us of function composition, which in Scala can be achieved using the stackable
    traits design pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 职责链模式是一种设计模式，其中请求的发送者与其接收者解耦。这样，它使得多个对象能够处理请求，并保持逻辑的清晰分离。接收者形成一个链，它们传递请求，如果可能的话，处理它，如果不可以，则将其传递给下一个接收者。在某些变体中，处理程序可能会同时将请求分发给多个其他处理程序。这多少让我们想起了函数组合，在Scala中可以通过可堆叠特性设计模式来实现。
- en: The interpreter design pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器设计模式
- en: The interpreter design pattern is based on the ability to characterize a well-known
    domain with a language with a strict grammar. It defines classes for each grammar
    rule in order to interpret sentences in the given language. These classes are
    likely to represent hierarchies as grammar is usually hierarchical as well. Interpreters
    can be used in different parsers, for example, SQL or other languages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式基于使用具有严格语法的语言来表征已知领域的能力。它为每个语法规则定义类，以便解释给定语言中的句子。这些类很可能会表示层次结构，因为语法通常是分层的。解释器可以用于不同的解析器，例如SQL或其他语言。
- en: The iterator design pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器设计模式
- en: The iterator design pattern is when an iterator is used to traverse a container
    and access its elements. It helps to decouple containers from the algorithms performed
    on them. What an iterator should provide is sequential access to the elements
    of an aggregate object without exposing the internal representation of the iterated
    collection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式是指使用迭代器遍历容器并访问其元素的情况。它有助于将容器与其上执行的操作解耦。迭代器应提供对聚合对象元素的顺序访问，而不暴露迭代集合的内部表示。
- en: The mediator design pattern
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者设计模式
- en: This pattern encapsulates the communication between different classes in an
    application. Instead of interacting directly with each other, objects communicate
    through the mediator, which reduces the dependencies between them, lowers the
    coupling, and makes the overall application easier to read and maintain.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式封装了应用程序中不同类之间的通信。不是直接相互交互，对象通过中介进行通信，这减少了它们之间的依赖性，降低了耦合度，并使得整个应用程序更容易阅读和维护。
- en: The memento design pattern
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录设计模式
- en: This pattern provides the ability to roll back an object to its previous state.
    It is implemented with three objects—**originator**, **caretaker**, and **memento**.
    The originator is the object with the internal state; the caretaker will modify
    the originator, and a memento is an object that contains the state that the originator
    returns. The originator knows how to handle a memento in order to restore its
    previous state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式提供了将对象回滚到其先前状态的能力。它通过三个对象实现——**发起者**、**保管者**和**备忘录**。发起者是具有内部状态的对象；保管者将修改发起者，而备忘录是一个包含发起者返回的状态的对象。发起者知道如何处理备忘录以恢复其先前状态。
- en: The observer design pattern
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: This design pattern allows the creation of publish/subscribe systems. There
    is a special object called subject that automatically notifies all the observers
    when there are any changes in the state. This design pattern is popular in various
    GUI toolkits and generally where event handling is needed. It is also related
    to reactive programming, which is enabled by libraries such as Akka. We will see
    an example of this towards the end of this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计模式允许创建发布/订阅系统。有一个特殊对象称为主题，当状态有任何变化时，它会自动通知所有观察者。这种设计模式在各种GUI工具包中很受欢迎，通常在需要事件处理的地方。它也与响应式编程相关，响应式编程由如Akka之类的库启用。我们将在本书的末尾看到一个例子。
- en: The state design pattern
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: This design pattern is similar to the strategy design pattern, and it uses a
    state object to encapsulate different behavior for the same object. It improves
    the code's readability and maintainability by avoiding the use of large conditional
    statements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式类似于策略设计模式，它使用一个状态对象来封装同一对象的不同的行为。通过避免使用大型条件语句，它提高了代码的可读性和可维护性。
- en: The template method design pattern
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法设计模式
- en: This design pattern defines the skeleton of an algorithm in a method and then
    passes some of the actual steps to the subclasses. It allows developers to alter
    some of the steps of an algorithm without having to modify its structure. An example
    of this could be a method in an abstract class that calls other abstract methods,
    which will be defined in the children.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计模式在方法中定义算法的框架，然后将一些实际步骤传递给子类。它允许开发者在不修改其结构的情况下更改算法的一些步骤。一个例子可能是抽象类中的方法调用其他抽象方法，这些方法将在子类中定义。
- en: The visitor design pattern
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: The visitor design pattern represents an operation to be performed on the elements
    of an object structure. It allows developers to define a new operation without
    changing the original classes. Scala can minimize the verbosity of this pattern
    compared to the pure object-oriented way of implementing it by passing functions
    to methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者设计模式表示对对象结构中的元素执行的操作。它允许开发者定义一个新操作，而无需更改原始类。Scala 通过将函数传递给方法，可以比纯面向对象方式实现此模式时最小化其冗长性。
- en: Functional design patterns
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: 'We will be looking into all of the preceding design patterns from the point
    of view of Scala. This means that they will look different than in other languages,
    but they still haven''t been designed specifically for functional programming.
    Functional programming is much more expressive than object-oriented programming.
    It has its own design patterns that help to make the life of a programmer easier.
    We will focus on:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Scala 的角度审视所有前面的设计模式。这意味着它们在其他语言中看起来会不同，但它们还没有被专门设计用于函数式编程。函数式编程比面向对象编程更具表现力。它有自己的设计模式，有助于使程序员的编程生活更轻松。我们将重点关注：
- en: Monoids
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: Monads
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: Functors
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: After we've looked at some Scala functional programming concepts, and we've
    been through these, we will mention some interesting design patterns from the
    Scala world.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们审视了一些 Scala 函数式编程概念，并且已经了解了这些概念之后，我们将提到一些来自 Scala 世界中的有趣设计模式。
- en: A brief explanation of the preceding listed patterns will follow in the next
    few subsections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，将对前面列出的模式进行简要说明。
- en: Monoids
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: 'Monoid is a concept that comes from mathematics. We will take a look at it
    in more detail with all the theory needed to understand it later in this book.
    For now, it will be enough to remember that a monoid is an algebraic structure
    with a single associative binary operation and an identity element. Here are the
    keywords that you should remember:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 摩纳哥是一个来自数学的概念。我们将在本书后面部分详细探讨它，包括理解它所需的所有理论。现在，只需记住，摩纳哥是一个具有单个关联二进制运算和单位元素的代数结构。以下是你应该记住的关键词：
- en: The associative binary operation. This means `(a+b)+c = a+(b+c)`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合二进制运算。这意味着 `(a+b)+c = a+(b+c)`。
- en: The identity element. This means `a+i = i+a = a`. Here, the identity is `i`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位元素。这意味着 `a+i = i+a = a`。在这里，单位是 `i`。
- en: What is important about monoids is that they give us the possibility to work
    with many different types of values in a common way. They allow us to convert
    pairwise operations to work with sequences; the associativity gives us the possibility
    for parallelization, and the identity element allows us to know what to do with
    empty lists. Monoids are great to easily describe and implement aggregations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 摩纳哥的重要之处在于它们为我们提供了以相同方式处理许多不同类型值的可能性。它们允许我们将成对操作转换为与序列一起工作；结合性为我们提供了并行化的可能性，而单位元素允许我们知道如何处理空列表。摩纳哥非常适合轻松描述和实现聚合。
- en: Monads
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: In functional programming, monads are structures that represent computations
    as sequences of steps. Monads are useful for building pipelines, adding operations
    with side effects cleanly to a language where everything is immutable, and implementing
    compositions. This definition might sound vague and unclear, but explaining monads
    in a few sentences seems to be something hard to achieve. Later in this book,
    we will focus on them and try and clear things up without the use of a complex
    mathematical theory. We will try to show why monads are useful and what they can
    help with, as long as developers understand them well.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，摩纳哥是表示计算为一系列步骤的结构。摩纳哥对于构建管道、干净地添加副作用操作到一切都是不可变的语言中非常有用，并且用于实现组合。这个定义可能听起来模糊不清，但用几句话解释摩纳哥似乎是一项艰巨的任务。在本书的后面部分，我们将专注于它们，并尝试在不使用复杂数学理论的情况下澄清问题。我们将尝试展示摩纳哥为什么有用以及它们能帮助开发者做什么，只要开发者对它们有很好的理解。
- en: Functors
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: Functors come from category theory, and as for monads, it takes time to explain
    them properly. We will look at functors later in this book. For now, you could
    remember that functors are things that can allow us to lift a function of the
    type `A => B` to a function of the type `F[A] => F[B]`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 拟人来自范畴论，至于单子，解释它们需要时间。我们将在本书的后面部分查看拟人。现在，你可以记住，拟人是一些可以让我们将类型`A => B`的函数提升到类型`F[A]
    => F[B]`的函数的东西。
- en: Scala-specific design patterns
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala特定的设计模式
- en: The design patterns in this group could be assigned to some of the previous
    groups. However, they are specific to Scala and exploit some of the language features
    that we will focus on in this book, and so we've decided to place them in their
    own group.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组中的设计模式可以被分配到一些之前的组中。然而，它们是特定于Scala的，并利用了我们在本书中将要关注的某些语言特性，因此我们决定将它们放在自己的组中。
- en: 'We will focus our attention on the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注以下内容：
- en: The lens design pattern
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头设计模式
- en: The cake design pattern
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕设计模式
- en: Pimp my library
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化我的库
- en: Stackable traits
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可堆叠特性
- en: The type class design pattern
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类设计模式
- en: Lazy evaluation
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟评估
- en: Partial functions
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分函数
- en: Implicit injection
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式注入
- en: Duck typing
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭式编程
- en: Memoization
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: The next subsections will give you some brief information about these patterns
    before we properly study them later in this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们稍后在本书中详细研究这些模式之前，以下小节将为您提供一些关于这些模式的简要信息。
- en: The lens design pattern
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜头设计模式
- en: The Scala programming language promotes immutability. Having objects immutable
    makes it harder to make mistakes. However, sometimes mutability is required and
    the lens design pattern helps us to achieve this nicely.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编程语言提倡不可变性。使对象不可变使得犯错误更难。然而，有时需要可变性，而镜头设计模式帮助我们很好地实现这一点。
- en: The cake design pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛋糕设计模式
- en: The cake design pattern is the Scala way to implement dependency injection.
    It is something that is used quite a lot in real-life applications, and there
    are numerous libraries that help developers achieve it. Scala has a way of doing
    this using language features, and this is what the cake design pattern is all
    about.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕设计模式是Scala实现依赖注入的方式。这在现实生活中的应用中相当常见，有许多库帮助开发者实现它。Scala有一种使用语言特性来实现它的方法，这就是蛋糕设计模式的主要内容。
- en: Pimp my library
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我的库
- en: Many times, engineers need to work with libraries, which are made to be as generic
    as possible. Sometimes, we need to do something more specific to our use case,
    though. The pimp my library design pattern provides a way to write extension methods
    for libraries, which we cannot modify. We can also use it for our own libraries
    as well. This design pattern also helps to achieve better code readability.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，工程师需要与库一起工作，这些库被设计得尽可能通用。有时，我们需要对我们自己的用例做更多具体的事情。优化我的库设计模式提供了一种为无法修改的库编写扩展方法的方式。我们也可以用它来为我们自己的库编写。这种设计模式还有助于提高代码的可读性。
- en: Stackable traits
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可堆叠特性
- en: Stackable traits is the Scala way to implement the decorator design pattern.
    It can also be used to compose functions, and it's based on a few advanced Scala
    features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可堆叠特性是Scala实现装饰器设计模式的方式。它也可以用来组合函数，并且它基于一些高级的Scala特性。
- en: The type class design pattern
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类设计模式
- en: This design pattern allows us to write generic code by defining a behavior that
    must be supported by all members of a specific type class. For example, all numbers
    must support the addition and subtraction operations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式允许我们通过定义必须由特定类型类的所有成员支持的行为来编写通用代码。例如，所有数字都必须支持加法和减法操作。
- en: Lazy evaluation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟评估
- en: Often, engineers have to deal with operations that are slow and/or expensive.
    Sometimes, the result of these operations might not even be needed. Lazy evaluation
    is a technique that postpones the operation execution until it is actually needed.
    It could be used for application optimization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，工程师必须处理一些慢速和/或昂贵的操作。有时，这些操作的结果甚至可能不需要。延迟评估是一种将操作执行推迟到实际需要的技术的技术。它可以用于应用程序优化。
- en: Partial functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: Mathematics and functional programming are really close together. As a consequence,
    some functions exist that are only defined for a subset of all the possible input
    values they can get. A popular example is the square root function, which only
    works for non-negative numbers. In Scala, such functions can be used to efficiently
    perform multiple operations at the same time or to compose functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数学与函数式编程非常接近。因此，一些函数只为所有可能输入值的一个子集定义。一个流行的例子是平方根函数，它只对非负数有效。在Scala中，这样的函数可以用来高效地同时执行多个操作或组合函数。
- en: Implicit injection
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式注入
- en: Implicit injection is based on the implicit functionality of the Scala programming
    language. It automatically injects objects whenever they are needed, as long as
    they exist in a specific scope. It can be used for many things, including dependency
    injection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式注入基于Scala编程语言的隐式功能。只要对象存在于特定的作用域中，它们就会在需要时自动注入。它可以用于许多事情，包括依赖注入。
- en: Duck typing
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸭式类型
- en: This is a feature that is available in Scala and is similar to what some dynamic
    languages provide. It allows developers to write code that requires the callers
    to have some specific methods (but not implement an interface). When someone uses
    a method with a duck type, it is actually checked during compile time whether
    the parameters are valid.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在Scala中可用且与某些动态语言提供的类似的功能。它允许开发者编写需要调用者具有某些特定方法（但不需要实现接口）的代码。当有人使用鸭式类型的函数时，实际上在编译时会检查参数是否有效。
- en: Memoization
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: This design pattern helps with optimization by remembering function results,
    based on the inputs. This means that as long as the function is stable and will
    return the same result when the same parameters are passed, one can remember its
    results and simply return them for every consecutive identical call.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式通过记住基于输入的函数结果来帮助优化。这意味着只要函数是稳定的，并且在传递相同的参数时返回相同的结果，就可以记住其结果，并在每次连续相同的调用中简单地返回它们。
- en: Choosing a design pattern
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择设计模式
- en: 'As we already saw, there are a huge number of design patterns. In many cases,
    they are suitable to be used in combinations as well. Unfortunately, there is
    no definite answer regarding how to choose the concept of designing our code.
    There are many factors that could affect the final decision, and you should ask
    yourselves the following questions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，有大量的设计模式。在许多情况下，它们可以组合使用。不幸的是，关于如何选择设计代码的概念，并没有一个确定的答案。有许多因素可能会影响最终的决定，你应该问自己以下问题：
- en: Is this piece of code going to be fairly static or will it change in the future?
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码将会相对静态，还是将来会发生变化？
- en: Do we have to dynamically decide what algorithms to use?
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要动态决定使用哪些算法吗？
- en: Is our code going to be used by others?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码会被其他人使用吗？
- en: Do we have an agreed interface?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个共同同意的接口吗？
- en: What libraries are we planning to use, if any?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，我们计划使用哪些库？
- en: Are there any special performance requirements or limitations?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何特殊的性能要求或限制？
- en: This is by no means an exhaustive list of questions. There is a huge amount
    of factors that could dictate our decision in how we build our systems. It is,
    however, really important to have a clear *specification*, and if something seems
    missing, it should always be checked first.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是问题的完整列表。有大量的因素可能会决定我们构建系统的方式。然而，有一个清晰的*规范*是非常重要的，如果似乎有什么缺失，应该首先检查。
- en: In the rest of the chapters, we will try to give specific recommendations about
    when a design pattern should and should not be used. They should help you ask
    the right questions and take the right decision before going on and writing code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将尝试给出具体建议，关于何时应该和不应该使用设计模式。它们应该帮助你提出正确的问题，并在编写代码之前做出正确的决定。
- en: Setting up the development environment
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: This book will aim to give real code examples for you to run and experiment
    with. As well as showing the most important code snippets in the pages of the
    book, you will have access to the code both from Packt Publishing as well as through
    GitHub for your convenience. The repository can be found at [https://github.com/nikolovivan/scala-design-patterns-v2](https://github.com/nikolovivan/scala-design-patterns-v2).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为您提供可运行的代码示例，以便您进行实验。除了在本书的页面中展示最重要的代码片段外，您还可以通过 Packt Publishing 以及 GitHub
    获取代码，以便您方便使用。仓库可以在 [https://github.com/nikolovivan/scala-design-patterns-v2](https://github.com/nikolovivan/scala-design-patterns-v2)
    找到。
- en: Having code examples means that it is important to be able to easily run any
    examples we have provided here and not to fight with the code. We will do our
    best to have the code tested and properly packaged, but you should also make sure
    that you have everything needed to run the examples.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有代码示例意味着能够轻松运行我们提供的任何示例非常重要，并且不要与代码发生冲突。我们将尽力确保代码经过测试并正确打包，但您也应该确保您拥有运行示例所需的一切。
- en: Installing Scala
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Scala
- en: Of course, you will need the Scala programming language. It does require Java
    to be installed, it evolves quickly, and the newest version can be found at [https://www.scala-lang.org/download/](https://www.scala-lang.org/download/).
    There are different ways of installing the language and you can choose whichever
    is the most comfortable for you. There are a few tips about how to install the
    language in your operating system at [https://www.scala-lang.org/download/install.html](https://www.scala-lang.org/download/install.html).
    As the official Scala website suggests, the easiest way to get started is to download
    an IDE (IntelliJ, for example), get the Scala plugin, and it will set things up
    for you. I will provide a couple of tips that have proven useful in my career
    that have enabled me to be very flexible while experimenting and learning.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要 Scala 编程语言。它需要安装 Java，发展迅速，最新版本可以在 [https://www.scala-lang.org/download/](https://www.scala-lang.org/download/)
    找到。安装语言有多种方式，您可以选择最适合您的方式。有关如何在您的操作系统上安装语言的几个提示可以在 [https://www.scala-lang.org/download/install.html](https://www.scala-lang.org/download/install.html)
    找到。正如官方 Scala 网站所建议的，最简单的方法是下载一个 IDE（例如 IntelliJ），安装 Scala 插件，它将为您设置一切。我将提供一些在我的职业生涯中证明有用的提示，这些提示使我能够在实验和学习时非常灵活。
- en: Tips for installing Scala manually
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动安装 Scala 的提示
- en: 'You can always download multiple versions of Scala and experiment with them.
    I use Linux and my tips will be applicable to Mac OS users, too. Windows users
    can also do a similar setup. Here are the steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以下载多个 Scala 版本并对其进行实验。我使用 Linux，我的提示也适用于 Mac OS 用户。Windows 用户也可以进行类似的设置。以下是步骤：
- en: Install Scala under `/opt/scala-{version}/` or any other path you prefer.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/opt/scala-{version}/` 或您喜欢的任何路径下安装 Scala。
- en: 'Create a symlink using this command: `sudo ln -s /opt/scala-{version} scala-current`.
    This can make switching versions much easier, if you decide to experiment.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令创建一个符号链接：`sudo ln -s /opt/scala-{version} scala-current`。如果您决定进行实验，这可以使版本切换变得容易得多。
- en: 'Add the path to the Scala `bin` folder to your `.bashrc` (or equivalent) file
    using the following lines:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将 Scala 的 `bin` 文件夹路径添加到您的 `.bashrc`（或等效）文件中：
- en: '`export SCALA_HOME=/opt/scala-current`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export SCALA_HOME=/opt/scala-current`'
- en: '`export PATH=$PATH:$SCALA_HOME/bin`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export PATH=$PATH:$SCALA_HOME/bin`'
- en: Now if you had defined a symlink and you decide to install another version of
    Scala, you could simply redefine the existing symlink and you can go on with your
    real work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您已经定义了一个符号链接，并且您决定安装另一个 Scala 版本，您可以简单地重新定义现有的符号链接，然后继续您的工作。
- en: If you don't want to go through the hassle of installing Scala manually or you
    find that you often switch to different versions of the language, SBT might be
    a more comfortable option.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想手动安装 Scala 或者您发现您经常切换到不同版本的编程语言，SBT 可能是一个更舒适的选择。
- en: Tips for installing Scala using SBT
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SBT 安装 Scala 的提示
- en: 'You can also experiment with any Scala version using SBT. To do this, you should:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 SBT 尝试任何 Scala 版本。为此，您应该：
- en: 'Download and install SBT: [https://www.scala-sbt.org/download.html](https://www.scala-sbt.org/download.html).'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 SBT：[https://www.scala-sbt.org/download.html](https://www.scala-sbt.org/download.html)。
- en: Open a Terminal and run `sbt`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `sbt`。
- en: In the SBT shell, type `++ 2.12.4` or any version you want to try. Please note
    that if the currently used Scala version is not binary compatible with the one
    you want to use, you will have to modify the command to the following—`++ 2.12.4!`.
    Binary compatibility is very important in Scala and you should try and make sure
    they use libraries written in the same version of Scala as they use. Otherwise,
    you might get into trouble.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SBT壳中，输入`++ 2.12.4`或你想要尝试的任何版本。请注意，如果当前使用的Scala版本与你要使用的版本不兼容，你必须修改命令为以下形式——`++
    2.12.4!`。二进制兼容性在Scala中非常重要，你应该确保它们使用与它们相同的Scala版本编写的库。否则，你可能会遇到麻烦。
- en: Issue the `console` command and you will be in a Scala shell running the version
    of your choice.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`console`命令，你将进入一个运行你选择的版本的Scala壳。
- en: All the examples in this book use SBT or Maven (depending on your preferences).
    They are build and dependency management tools, which means that you might not
    even need to do anything extra to install Scala. You can just import an example
    project and everything will be taken care of automatically.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都使用SBT或Maven（根据你的偏好）。它们是构建和依赖管理工具，这意味着你可能甚至不需要做任何额外的事情来安装Scala。你只需导入一个示例项目，所有的事情都会自动处理。
- en: Scala IDEs
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala集成开发环境（IDE）
- en: 'There are multiple IDEs out there that support development in Scala. There
    is absolutely no preference about which one to use to work with the code. Some
    of the most popular ones are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有多个IDE支持Scala的开发。在用于与代码一起工作的IDE方面，没有任何偏好。以下是一些最受欢迎的IDE：
- en: IntelliJ
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ
- en: Eclipse
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: NetBeans
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans
- en: IntelliJ is currently the one recommended on the Scala website and probably
    the most used one at the time of writing. All of those IDEs use plugins to work
    with Scala, and downloading and using them should be straightforward.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ目前是Scala网站上推荐的，也可能是写作时最常用的IDE。所有这些IDE都使用插件来与Scala一起工作，下载和使用它们应该是直接的。
- en: Dependency management
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Running most of the examples in this book will not require any additional dependencies
    in terms of special libraries. In some cases, though, we might need to show how
    a Scala code is unit tested, which will require us to use a testing framework.
    Also, we will later present some real-life use cases in which an additional library
    is used. Dealing with dependencies nowadays is done using specialized tools. They
    usually are interchangeable, and which one to use is a personal choice. The most
    popular tool used with Scala projects is SBT, but Maven is also an option, and
    there are many others out there as well. The former is normally used when a project
    is started from scratch and Scala is the main programming language. The latter
    could be useful in cases when the main language used is Java, for example, and
    we want to add modules written in Scala.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中运行大多数示例不需要任何特殊库的额外依赖。然而，在某些情况下，我们可能需要展示如何对Scala代码进行单元测试，这需要我们使用测试框架。此外，我们还将展示一些实际使用案例，其中使用了额外的库。如今，处理依赖通常使用专门的工具。它们通常是可互换的，使用哪个工具是个人选择。与Scala项目一起使用最流行的工具是SBT，但Maven也是一个选择，还有许多其他工具。前者通常在项目从头开始且Scala是主要编程语言时使用。后者在主要使用的语言是Java，例如，并且我们想要添加用Scala编写的模块时可能很有用。
- en: Modern IDEs provide the functionality to generate the required build configuration
    files, but we will give some generic examples that could be useful not only here,
    but in future projects. Depending on the IDE you prefer, you might need to install
    some extra plugins to have things up and running, and a quick Google search should
    help.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现代IDE提供了生成所需构建配置文件的功能，但我们将提供一些通用的示例，这些示例不仅在这里有用，而且在未来的项目中也可能有用。根据你偏好的IDE，你可能需要安装一些额外的插件才能使一切正常运行，快速进行Google搜索应该会有所帮助。
- en: SBT
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT
- en: '**SBT** stands for **Simple Build Tool** and it uses the Scala syntax to define
    how a project is built, managing dependencies, and so on. It uses `.sbt` files
    for this purpose. It also supports a setup based on Scala code in `.scala` files,
    as well as a mix of both.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**SBT**代表**简单构建工具**，它使用Scala语法来定义项目如何构建、管理依赖等。它使用`.sbt`文件来完成这个目的。它还支持基于`.scala`文件的Scala代码的设置，以及两者的混合使用。'
- en: To download SBT, go to [http://www.scala-sbt.org/1.0/docs/Setup.html](http://www.scala-sbt.org/1.0/docs/Setup.html)
    and follow the instructions. If you wish to obtain the newest version, then simply
    Google it and use the result you get back.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 SBT，请访问 [http://www.scala-sbt.org/1.0/docs/Setup.html](http://www.scala-sbt.org/1.0/docs/Setup.html)
    并按照说明操作。如果您希望获取最新版本，只需在 Google 上搜索并使用返回的结果即可。
- en: 'The following screenshot shows the structure of a skeleton SBT project:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了骨架 SBT 项目的结构：
- en: '![](img/956023d8-04b8-4503-90b9-864a4408bd42.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/956023d8-04b8-4503-90b9-864a4408bd42.png)'
- en: It is important to show the contents of the main `.sbt` files.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 显示主 `.sbt` 文件的内容是很重要的。
- en: 'The `version.sbt` file looks as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`version.sbt` 文件如下所示：'
- en: '[PRE0]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It contains the current version that is automatically incremented if a release
    is made.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含当前版本，如果发布新版本，则该版本会自动递增。
- en: 'The `assembly.sbt` file has the following content:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`assembly.sbt` 文件的内容如下：'
- en: '[PRE1]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It contains information about how to build the assembly JAR—a merge strategy,
    final JAR name, and so on. It uses a plugin called `sbtassembly` ([https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含有关如何构建汇编 JAR 的信息——合并策略、最终 JAR 名称等。它使用一个名为 `sbtassembly` 的插件（[https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly)）。
- en: 'The `build.sbt` file is the file that contains the dependencies of the project,
    some extra information about the compiler, and metadata. The skeleton file looks
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sbt` 文件是包含项目依赖、一些关于编译器的额外信息和元数据的文件。骨架文件如下所示：'
- en: '[PRE2]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, here we define the Java version against which we compile some
    manifest information and the library dependencies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里我们定义了编译某些清单信息和库依赖项所针对的 Java 版本。
- en: 'The dependencies for our project are defined in the `libraryDependencies` section
    of our SBT file. They have the following format:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的依赖项定义在我们 SBT 文件的 `libraryDependencies` 部分中。它们具有以下格式：
- en: '[PRE3]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we decide to separate `groupId` and `artifactId` with `%%` instead of `%`,
    SBT will automatically use `scalaVersion` and append `_2.12` (for Scala 2.12.*)
    to `artifactId`. This syntax is usually used when we include dependencies written
    in Scala, as the convention there requires us to have the Scala version added
    as part of `artifactId`. We can, of course, manually append the Scala version
    to `artifactId` and use `%`. This is also done in cases when we import libraries
    written in a different major version of Scala. In the latter case, however, we
    need to be careful with binary compatibility. Of course, not all libraries will
    be written in the version we use, so we either have to thoroughly test them and
    make sure they won't break our application, change our Scala version, or look
    for alternatives.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定用 `%%` 而不是 `%` 将 `groupId` 和 `artifactId` 分隔开，SBT 将自动使用 `scalaVersion`
    并将 `_2.12`（对于 Scala 2.12.*）附加到 `artifactId` 上。这种语法通常用于包含用 Scala 编写的依赖项，因为那里的惯例要求我们将
    Scala 版本作为 `artifactId` 的一部分。我们当然可以手动将 Scala 版本附加到 `artifactId` 并使用 `%`。这也适用于导入用不同主要版本的
    Scala 编写的库的情况。在后一种情况下，我们需要注意二进制兼容性。当然，并非所有库都会用我们使用的版本编写，因此我们要么彻底测试它们并确保它们不会破坏我们的应用程序，要么更改我们的
    Scala 版本，或者寻找替代方案。
- en: The dependencies shown will not be needed at any point in this book (the one
    for Spark and the Datastax one). They are here just for illustration purposes,
    and you can safely remove them if not needed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的依赖项在任何本书的任何地方都不需要（Spark 和 Datastax 的那个）。它们只是用于说明目的，如果不需要，您可以安全地删除它们。
- en: SBT requires each statement to be on a new line and to be separated with a blank
    line from the previous one if we work with `.sbt` files. When using `.scala` files,
    we just write code in Scala.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SBT 要求每个语句都在新的一行上，并且如果我们在 `.sbt` 文件中工作，则每个语句与前一个语句之间需要用空白行隔开。当使用 `.scala` 文件时，我们只需用
    Scala 编写代码。
- en: The `%%` syntax in the dependencies is a syntactic sugar, which, using `scalaVersion`,
    will replace the name of the library, for example, `scalatest` will become `scalatest_2.12`
    in our case.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项中的 `%%` 语法是一种语法糖，它使用 `scalaVersion` 将库的名称替换掉，例如，在我们的例子中，`scalatest` 将变成 `scalatest_2.12`。
- en: SBT allows the engineer to express the same things differently. One example
    is the preceding dependencies—instead of adding a sequence of dependencies, we
    can add them one by one. The final result will be the same. There is also a lot
    of flexibility with other parts of SBT. For more information on SBT, refer to
    the documentation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: SBT 允许工程师用不同的方式表达相同的内容。一个例子是前面的依赖项——我们不是添加一系列依赖项，而是可以逐个添加。最终的结果将是相同的。SBT 的其他部分也有很多灵活性。有关
    SBT 的更多信息，请参阅文档。
- en: 'The `project/build.properties` defines the `sbt` version to be used when building
    and interacting with the application under `sbt`. It is as simple as the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`project/build.properties` 文件定义了在 `sbt` 下构建和与应用程序交互时要使用的 `sbt` 版本。它就像以下这样简单：'
- en: '[PRE4]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, there is the `project/plugins.sbt` file that defines different plugins
    used to get things up and running. We already mentioned `sbtassembly`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个 `project/plugins.sbt` 文件，它定义了用于使项目启动运行的不同插件。我们之前提到了 `sbtassembly`：
- en: '[PRE5]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are different plugins online that provide useful functionalities. Here
    are some common `sbt` commands that can be run from the root folder in the Terminal
    of this skeleton project:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有不同插件提供有用的功能。以下是一些常见的可以在该骨架项目的终端中运行的 `sbt` 命令：
- en: '`sbt`: This opens the sbt console for the current project. All of the commands
    that will follow can be issued from here by omitting the `sbt` keyword.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt`: 这将打开当前项目的 sbt 控制台。所有后续的命令都可以在这里发出，无需使用 `sbt` 关键字。'
- en: '`sbt test`: This runs the application unit tests.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt test`: 这将运行应用程序单元测试。'
- en: '`sbt compile`: This compiles the application.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt compile`: 这将编译应用程序。'
- en: '`sbt assembly`: This creates an assembly of the application (a fat JAR) that
    can be used to run as any other Java JAR.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt assembly`: 这将创建应用程序的汇编（一个胖 JAR），可以像其他任何 Java JAR 一样运行。'
- en: Maven
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven
- en: Maven holds its configuration in files named `pom.xml`. It supports multimodule
    projects easily, while for `sbt`, there needs to be some extra work done. In Maven,
    each module simply has its own child `pom.xml` file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 在名为 `pom.xml` 的文件中保存其配置。它易于支持多模块项目，而对于 `sbt`，则需要做一些额外的工作。在 Maven 中，每个模块都有自己的子
    `pom.xml` 文件。
- en: To download Maven, go to [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 Maven，请访问 [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)。
- en: 'The following screenshot shows the structure of a skeleton Maven project:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了骨架 Maven 项目的结构：
- en: '![](img/829bcce5-0db0-49fc-b76f-e4a1a6ab855f.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/829bcce5-0db0-49fc-b76f-e4a1a6ab855f.png)'
- en: The main `pom.xml` file is much longer than the preceding SBT solution. Let's
    have a look at its parts separately.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 `pom.xml` 文件比之前的 SBT 解决方案要长得多。让我们分别看看它的各个部分。
- en: 'There is usually some metadata about the project and different properties that
    can be used in the POM files in the beginning:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 POM 文件的开头有一些关于项目和不同属性的信息：
- en: '[PRE6]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, there are the dependencies:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是依赖项：
- en: '[PRE7]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, there are the build definitions. Here, we can use various plugins to
    do different things with our project and give hints to the compiler. The build
    definitions are enclosed in the `<build>` tags.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是构建定义。在这里，我们可以使用各种插件对我们的项目进行不同的操作，并向编译器提供提示。构建定义被 `<build>` 标签包围。
- en: 'First, we specify some resources:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定一些资源：
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first plugin we have used is `scala-maven-plugin`, which is used when working
    with Scala and Maven:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第一个插件是 `scala-maven-plugin`，当与 Scala 和 Maven 一起工作时使用：
- en: '[PRE9]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another plugin we use is `maven-assembly-plugin`, which is used for building
    the fat JAR of the application:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另一个插件是 `maven-assembly-plugin`，用于构建应用程序的胖 JAR：
- en: '[PRE10]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete `pom.xml` file is equivalent to the preceding `sbt` files that
    we presented.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `pom.xml` 文件等同于我们之前提供的 `sbt` 文件。
- en: As before, the Spark and Datastax dependencies are here just for illustration
    purposes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spark 和 Datastax 依赖项仅用于说明目的。
- en: The use of JUnit to run unit tests in Scala 2.12
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 2.12 中使用 JUnit 运行单元测试
- en: If you look into the dependencies in more depth, you will see that we have imported
    `junit`, which is a Java testing framework. At first glance, someone might think
    that we don't actually need it. However, there is a catch. A quick Google search
    about how to run Scalatest unit tests with Maven would point to resources recommending
    the use of `scalatest-maven-plugin`. If we followed those instructions and tried
    running some tests from the command line, we would get a strange error. This is
    due to the fact that we used Scala 2.12 and the `scalatest-maven-plugin` at its
    current version is not binary compatible with this version of the language.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入研究依赖项，你会看到我们导入了 `junit`，这是一个 Java 测试框架。乍一看，有人可能会认为我们实际上并不需要它。然而，有一个陷阱。快速
    Google 搜索如何使用 Maven 运行 Scalatest 单元测试会指向推荐使用 `scalatest-maven-plugin` 的资源。如果我们遵循那些说明并尝试从命令行运行一些测试，我们会得到一个奇怪的错误。这是由于我们使用了
    Scala 2.12，而当前的 `scalatest-maven-plugin` 版本与该语言的这个版本不兼容。
- en: 'Like many things in software engineering, we have to find workarounds. Here,
    we could do two things:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件工程中的许多事情一样，我们必须找到解决方案。在这里，我们可以做两件事：
- en: Use an older version of Scala.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用较旧的Scala版本。
- en: Force Maven to run our tests.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制Maven运行我们的测试。
- en: Of course, the second option is the more desirable. This means that the only
    thing we need to do in each Scalatest we write is to add the following annotation
    to each test class: `@RunWith(classOf[JUnitRunner])` and make sure our test classes
    contain the word `Test` in their name.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，第二个选项更可取。这意味着我们只需要在每个Scalatest中做一件事，那就是在每个测试类中添加以下注解：`@RunWith(classOf[JUnitRunner])`，并确保我们的测试类名称中包含单词`Test`。
- en: Similarly to SBT, you can use Maven from the command line. Some of the commands
    you might find most useful with the example projects in this book are shown in
    the next tip.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于SBT，您可以从命令行使用Maven。本书示例项目中您可能发现最有用的命令将在下一个提示中展示。
- en: 'Useful Maven commands:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的Maven命令：
- en: '`mvn clean test`: This runs the application unit tests'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvn clean test`：这会运行应用程序单元测试'
- en: '`mvn clean compile`: This compiles the application'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvn clean compile`：这会编译应用程序'
- en: '`mvn clean package`: This creates an assembly of the application (a fat JAR)
    that can be used to run as any other Java JAR'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvn clean package`：这会创建一个应用程序的集合（一个胖JAR），可以像其他Java JAR一样运行'
- en: SBT versus Maven
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT与Maven的比较
- en: In this book, we will be using both SBT and Maven for dependency management
    and creating our projects. They are interchangeable, and our source code will
    not depend on which build system we choose. You can easily translate the `.pom`
    files to `.sbt` files using the skeleton that we've provided. The only difference
    will really be the dependencies and how they are expressed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用SBT和Maven进行依赖管理并创建我们的项目。它们可以互换使用，我们的源代码将不依赖于我们选择的构建系统。您可以使用我们提供的框架轻松地将`.pom`文件转换为`.sbt`文件。真正不同的将是依赖项以及它们是如何表达的。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, we have a fair idea about what a design pattern means and how it can
    affect the way we write our code. We've iterated through the most famous design
    patterns out there, and we have outlined the main differences between them. We
    saw that in many cases, we could use Scala's features in order to make a pattern
    obsolete, simpler, or different to implement compared to the classical case for
    pure object-oriented languages. This book will show you how Scala makes it easier
    to write high-quality code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一个关于设计模式意味着什么以及它如何影响我们编写代码方式的大致了解。我们回顾了最著名的设计模式，并概述了它们之间的主要区别。我们看到了在许多情况下，我们可以使用Scala的特性来使一个模式变得过时、更简单或与纯面向对象语言的经典案例相比具有不同的实现方式。本书将向您展示Scala如何使编写高质量代码变得更加容易。
- en: Knowing what to look for when picking a design pattern is important, and you
    should already know what specific details to watch out for and how important specifications
    are.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在挑选设计模式时应该寻找什么很重要，您应该已经知道应该注意哪些具体细节以及规范的重要性。
- en: Last but not least, we advise you to run the examples in this book, and we have
    provided some pointers that should make this really easy. In some cases, creating
    a complete solution using SBT or Maven might be too much hassle and somewhat unnecessary,
    but we believe it is a good practice to follow. Additionally, the approaches we
    explained are used throughout the industry and will be beneficial outside the
    scope of this book.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们建议您运行本书中的示例，并且我们已经提供了一些应该会使这变得非常简单的提示。在某些情况下，使用SBT或Maven创建一个完整的解决方案可能过于繁琐且有些不必要，但我们相信这是一个好的实践。此外，我们解释的方法在整个行业中都有应用，并且将超出本书的范围带来益处。
- en: In the next chapter, we will get straight to the practical part of this book,
    where we will look at traits and mixing compositions, what they are useful for,
    and how and when to use them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将直接进入本书的实践部分，我们将探讨特性和混合组合，它们有什么用途，以及何时何地使用它们。
