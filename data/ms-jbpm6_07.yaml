- en: Chapter 7. Customizing and Extending jBPM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。定制和扩展jBPM
- en: This chapter details the extension points of jBPM. Not every user of jBPM uses
    the entire tool stack. Users will need to customize/extend jBPM to fit it into
    their solution architecture. This chapter will show you how jBPM's features can
    be customized and extended.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了jBPM的扩展点。并非每个jBPM用户都使用整个工具栈。用户将需要定制/扩展jBPM以适应其解决方案架构。本章将向您展示如何定制和扩展jBPM的功能。
- en: 'The list of topics that will be covered in the chapter is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题列表如下：
- en: Domain-specific processes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定流程
- en: Writing your custom workitem handlers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的自定义工作项处理程序
- en: Customizing the process designer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制流程设计器
- en: Extending variable persistence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展变量持久性
- en: Extending user management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展用户管理
- en: Custom process nodes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义流程节点
- en: 'In [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*,
    we introduced the jBPM feature that lets you bind specific Java class implementations
    to the execution of a specific process task node type: send/receive tasks, service
    tasks, and ad hoc tasks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。BPMN结构")中，我们介绍了jBPM的一个功能，该功能允许您将特定的Java类实现绑定到特定流程任务节点类型的执行：发送/接收任务、服务任务和临时任务。
- en: These kinds of *extensible* task nodes are often called **custom workitems**,
    and the implementing classes that perform the horse work behind the process curtains
    are called **workitem handlers**. This architecture makes jBPM more flexible when
    it comes to adapting the engine to a particular domain, both in terms of features
    and tools UI. Let's start by reviewing the basics of the jBPM workitem and handlers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这类**可扩展**的任务节点通常被称为**自定义工作项**，在流程幕后执行实际工作的实现类被称为**工作项处理程序**。这种架构使得jBPM在适应特定领域时更加灵活，无论是从功能还是工具UI方面。让我们首先回顾jBPM工作项和处理程序的基本知识。
- en: Workitem and handlers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作项和处理程序
- en: 'jBPM defines a work item as a unit of work that is defined inside the scope
    of a process but can be executed outside the engine; in particular:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM将工作项定义为在流程范围内定义但可以在引擎外部执行的工作单元；特别是：
- en: It accepts a set of parameters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一组参数
- en: It performs some action
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行某些操作
- en: It optionally returns a result
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以可选地返回一个结果
- en: 'The workitem is just an abstract definition of a work unit and has several
    concrete, practical implementations in jBPM: human tasks, sendMessage tasks, and
    so on. The engine imposes no limitations to the workitem handler apart from enforcing
    the implementation of the `org.kie.api.runtime.process.WorkItemHandler` interface.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 工作项只是工作单元的抽象定义，在jBPM中有几种具体的、实用的实现，例如：人工任务、sendMessage任务等。除了强制实现`org.kie.api.runtime.process.WorkItemHandler`接口外，引擎对工作项处理程序没有限制。
- en: The engine runtime is instructed to bind a new handler implementation through
    the `WorkItemManager.registerWorkItemHandler(String workItemName, WorkItemHandler
    handler)` method, where the `workItemName` parameter must match a custom node
    name since it serves as the handler key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎运行时通过`WorkItemManager.registerWorkItemHandler(String workItemName, WorkItemHandler
    handler)`方法指示绑定新的处理程序实现，其中`workItemName`参数必须匹配自定义节点名称，因为它作为处理程序键。
- en: jBPM itself extensively uses WorkItemHandler such as `LocalHTWorkItemHandler`
    (workitem name `Human Task`), `WebServiceWorkItemHandler` (workitem name `WebService`),
    or `RESTWorkItemHandler` (name `Rest`). This feature effectively streamlines the
    engine customization process, letting the user enhane (or replace) jBPM functionalities.
    You can find several jBPM workitem handler classes in the `jpbm-workitems-6.2.0.Final.jar`
    library (see package details in the following class diagram).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM本身广泛使用处理程序，如`LocalHTWorkItemHandler`（工作项名称`Human Task`）、`WebServiceWorkItemHandler`（工作项名称`WebService`）或`RESTWorkItemHandler`（名称`Rest`）。此功能有效地简化了引擎定制过程，使用户能够增强（或替换）jBPM功能。您可以在`jpbm-workitems-6.2.0.Final.jar`库中找到几个jBPM工作项处理程序类（有关类图中的包详细信息，请参阅以下内容）。
- en: '![Workitem and handlers](img/9578OS_07_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![工作项和处理程序](img/9578OS_07_03.jpg)'
- en: '`AsyncWorkItemHandler` (we discussed it in the *Async task* section in [Chapter
    5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*) can be found in
    the `jpbm-executor-6.2.0.Final.jar` library.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncWorkItemHandler`（我们在[第5章](ch05.html "第5章。BPMN结构")的*异步任务*部分讨论过）可以在`jpbm-executor-6.2.0.Final.jar`库中找到。'
- en: Life cycle
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'The workitem state transitions are as follows: `ACTIVE`, `PENDING`, `COMPLETED`,
    and `ABORTED`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 工作项状态转换如下：`ACTIVE`、`PENDING`、`COMPLETED`和`ABORTED`。
- en: 'The WorkItemHandler call sequence is quite simple (see the following interaction
    diagrams), and when the handler calls complete or abort, the engine takes the
    control again and the process execution continues. The handler must implement
    two methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: WorkItemHandler调用序列相当简单（见以下交互图），当处理程序调用完成或中止时，引擎再次接管控制，流程执行继续。处理程序必须实现两个方法：
- en: '`executeWorkItem`: The workitem manager invokes the `executeMethod` handler
    and, upon completion (at the end of `executeMethod`), the handler must invoke
    the callback method called `completeWorkItem` on the manager itself (optionally
    passing the output parameters):![Life cycle](img/9578OS_07_01.jpg)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executeWorkItem`: 工作项管理器调用`executeMethod`处理程序，并在`executeMethod`结束时，处理程序必须调用管理器上的回调方法`completeWorkItem`（可选地传递输出参数）：![生命周期](img/9578OS_07_01.jpg)'
- en: '`abortWorkItem`: This method gets called as a consequence of a cancel or error
    event. The handler must perform clean-up operations (when needed) and call the
    manager back by the `abortWorkItem` method, which instructs the manager to set
    the workitem in the **ABORTED** state:![Life cycle](img/9578OS_07_02.jpg)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abortWorkItem`: 此方法在取消或错误事件发生后被调用。处理程序必须执行清理操作（如有必要）并通过`abortWorkItem`方法调用管理器，该方法指示管理器将工作项设置为**已中止**状态：![生命周期](img/9578OS_07_02.jpg)'
- en: Cacheable and closeable interfaces
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可缓存和可关闭接口
- en: 'jBPM 6.2 introduces a new feature that lets the user hook into the workitem
    handler life cycle by implementing the following interface methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM 6.2引入了一个新功能，允许用户通过实现以下接口方法钩入工作项处理程序的生命周期：
- en: '`org.kie.internal.runtime.Closeable.close()`: Called on WorkItemManager (and
    Session) disposal. Here, you can perform the typical housekeeping duties (freeing
    resources, close connections, and so on).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.kie.internal.runtime.Closeable.close()`: 在WorkItemManager（和会话）释放时调用。在这里，您可以执行典型的维护工作（释放资源、关闭连接等）。'
- en: '`org.kie.internal.runtime.Cacheable.close()`: Called when the jBPM internal
    cache manager is closed/disposed. By implementing the `Cacheable` interface, we
    enable our Workitem handler definition to be cached by jBPM.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.kie.internal.runtime.Cacheable.close()`: 当jBPM内部缓存管理器关闭/释放时调用。通过实现`Cacheable`接口，我们使我们的Workitem处理程序定义能够被jBPM缓存。'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The RuntimeManager internally caches several configured object class definitions
    to optimize the initialization and startup times: event listeners, globals, marshalling
    strategies, Workitem handlers, and so on.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RuntimeManager内部缓存了多个配置的对象类定义以优化初始化和启动时间：事件监听器、全局变量、序列化策略、Workitem处理程序等。
- en: For a `Closeable` interface example, please have a look at the PizzaTweet handler
    implementation discussed in the following paragraphs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Closeable`接口的示例，请参阅以下段落中讨论的PizzaTweet处理程序实现。
- en: Handlers in action
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理程序在行动
- en: 'The workitem customization can be seen as a two-step process:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 工作项定制可以看作是一个两步过程：
- en: '**Code implementation and runtime registration**: Make the handler implementation
    available to the runtime engine in order to trigger the handler execution when
    the engine reaches the custom node type'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码实现和运行时注册**：使处理程序实现可供运行时引擎使用，以便在引擎达到自定义节点类型时触发处理程序执行'
- en: '**Designer customization**: Enable the usage of the custom node from the UI
    interface (process designer)'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计器定制**：启用从UI界面（流程设计器）使用自定义节点的功能'
- en: 'Before diving into a detailed example (the `pizzatweet` project), let us look
    at the basics of the workitem architecture and review the three different ways
    in which we can register a handler: by direct registration with the API, by setting
    the `kmodule.xml` file, and by adding a handler configuration file.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入一个详细示例（`pizzatweet`项目）之前，让我们看看工作项架构的基本知识，并回顾我们可以注册处理程序的三种不同方式：通过直接使用API注册、通过设置`kmodule.xml`文件以及通过添加处理程序配置文件。
- en: Direct handler registration
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接处理程序注册
- en: 'The shortest, naïve way of registering a handler implementation with your engine
    session is to make a direct invocation to the Kie session''s WorkItemManager:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将处理程序实现注册到您的引擎会话中最简单、最直接的方法是直接调用Kie会话的WorkItemManager：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives you a lot of flexibility; you do not need to define extra configuration
    files or properties (more on these in the upcoming section), and you are free
    to initialize your handler with everything you need during the execution. This
    is the preferred way to go when unit testing, particularly when replacing or defining
    a system workitem handler (`human task`, `service`, or `task`) since you do not
    have to tweak the Kie console to add the new node type to the **Service Task**
    menu, which would be mandatory to properly design the process definition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了很大的灵活性；你不需要定义额外的配置文件或属性（更多内容将在下一节中介绍），并且你可以在执行过程中自由地初始化你的处理程序所需的一切。这是单元测试时的首选方式，尤其是在替换或定义系统工作项处理程序（`human
    task`、`service` 或 `task`）时，因为你不需要调整 Kie 控制台以将新节点类型添加到 **服务任务** 菜单，这对于正确设计流程定义是强制性的。
- en: Declarative kmodule.xml handler configuration
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性 kmodule.xml 处理程序配置
- en: 'In case your project is a Kie module and you need a declarative, a less hardwired
    way to define the handlers is to add the `<workItemHandlers>` element to the `kmodule.xml`
    file as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目是 Kie 模块，并且你需要一种声明性、非硬编码的方式来定义处理程序，可以将 `<workItemHandlers>` 元素添加到 `kmodule.xml`
    文件中，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Handler configuration file
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理程序配置文件
- en: 'When you need to add new custom node types, the preferred, standard way to
    register your handler implementation is to have it listed in the standard handler
    configuration file: the `CustomWorkItemHandlers.conf` file.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要添加新的自定义节点类型时，将你的处理程序实现列出在标准处理程序配置文件中是首选和标准的方式：`CustomWorkItemHandlers.conf`
    文件。
- en: 'This file must contain the handler implementation class constructors and the
    work item name that will be used to register them; here you have, as an example,
    the default configuration file shipped with jBPM 6.2:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件必须包含处理程序实现类的构造函数以及将用于注册的工作项名称；以下是一个示例，即 jBPM 6.2 伴随的默认配置文件：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This file is written with the MVEL expression language and is loaded by the
    jBPM console runtime from the `jbpm-console.war\WEB-INF\classes\META-INF` folder;
    note that the filename is added to the sibling file called `drools.session.conf`
    whose content is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用 MVEL 表达式语言编写，并由 jBPM 控制台运行时从 `jbpm-console.war\WEB-INF\classes\META-INF`
    文件夹加载；请注意，文件名被添加到名为 `drools.session.conf` 的同级文件中，其内容如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that from the system default handler definitions (`Web Service` and `Service
    Task`), by defining a constructor that accepts the `ksession` parameter, the KieSession
    will be automatically injected at runtime in your handler instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过定义一个接受 `ksession` 参数的构造函数，从系统默认处理程序定义（`Web Service` 和 `Service Task`）中，KieSession
    将在运行时自动注入到你的处理程序实例中。
- en: 'The very same property called `drools.workItemHandlers` is used to load the
    handler configuration file(s), for instance, during Kie Session initialization
    with `KieSessionConfiguration`. For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的属性 `drools.workItemHandlers` 用于加载处理程序配置文件，例如，在 `KieSessionConfiguration`
    初始化期间，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, with the runtime builder classes (see [Chapter 6](ch06.html
    "Chapter 6. Core Architecture"), *Core Architecture*, for details about runtime
    classes), you can have the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用运行时构建类（有关运行时类的详细信息，请参阅第 6 章 [Chapter 6. Core Architecture]，*核心架构*），你可以有如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `.conf` file is searched in the `META-INF/` classpath or in the `user.home`
    system folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`.conf` 文件在 `META-INF/` 类路径或 `user.home` 系统文件夹中搜索。'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The property supports multiple space-separated entries such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性支持多个用空格分隔的条目，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Handler definition file
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理程序定义文件
- en: The file that defines the WorkItemHandler process definition node properties
    is the workitem definition file (having the `.WID` extension), and it is written
    using the MVEL expression language.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 WorkItemHandler 流程定义节点属性的文件是工作项定义文件（具有 `.WID` 扩展名），它使用 MVEL 表达式语言编写。
- en: When in the **Project Authoring** mode, the KIE console creates a default `WorkDefinitions.wid`
    file in your project `resources` folder that defines the `email`, `log`, `webservice`,
    and `rest` handlers whose custom nodes can be found under the Service Task menu
    of the process designer palette. Additional resources (custom node icons) are
    created in the `global` folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于 **项目创作** 模式时，KIE 控制台会在你的项目 `resources` 文件夹中创建一个默认的 `WorkDefinitions.wid`
    文件，该文件定义了 `email`、`log`、`webservice` 和 `rest` 处理程序，其自定义节点可以在流程设计器调色板的服务任务菜单下找到。额外的资源（自定义节点图标）在
    `global` 文件夹中创建。
- en: 'Here, you define your custom node properties and the workitem abstract definitions:
    `name` (used as the key for the handler), its parameters (input), result parameters
    (output), `displayName` (the label used for the node), and node icon resource.
    Let us have a look at our `PizzaTweet` custom node (we will talk about this in
    the example section):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义自定义节点属性和工作项抽象定义：`name`（用作处理程序的关键字），其参数（输入），结果参数（输出），`displayName`（用于节点的标签），以及节点图标资源。让我们看看我们的`PizzaTweet`自定义节点（我们将在示例部分讨论这个话题）：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `"parameters"` and `"results"` attributes are maps of typed parameters (name-type
    pairs).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`"参数"`和`"结果"`属性是类型化参数（名称-类型对）的映射。'
- en: '`parameters`: Defines the set of input parameters of the workitem'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`：定义工作项的输入参数集'
- en: '`results`: Defines the set of output parameters'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`results`：定义输出参数集'
- en: 'The types allowed for the parameters are the ones supported by the Drool core
    type classes: `StringDataType`, `IntegerDataType`, `FloatDataType`, `BooleanDataType`,
    `EnumDataType`, `ObjectDataType`, `ListDataType`, and `UndefinedDataType.ObjectDataType`
    wraps a type, while `ListDataType` wraps `java.util.List`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 允许参数的类型是Drool核心类型类所支持的类型：`StringDataType`、`IntegerDataType`、`FloatDataType`、`BooleanDataType`、`EnumDataType`、`ObjectDataType`、`ListDataType`和`UndefinedDataType`。`ObjectDataType`封装一个类型，而`ListDataType`封装`java.util.List`。
- en: Workitem handler implementation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作项处理程序实现
- en: Your handler must implement the `org.kie.api.runtime.process.WorkItemHandler`
    interface or extend the `AbstractWorkItemHandler` abstract class. This class gives
    you a set of useful helper methods in case your handler needs to get runtime information
    from the process or its nodes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您的处理程序必须实现`org.kie.api.runtime.process.WorkItemHandler`接口或扩展`AbstractWorkItemHandler`抽象类。这个类在您的处理程序需要从流程或其节点获取运行时信息时提供了一组有用的辅助方法。
- en: Handling input parameters
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理输入参数
- en: The handler can read the input parameters with the `WorkItem.getParameter (String
    name)` method. The input parameters are passed by the engine runtime, upon evaluation
    of your node data input set mappings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序可以使用`WorkItem.getParameter(String name)`方法读取输入参数。输入参数由引擎运行时在评估您的节点数据输入集映射时传递。
- en: Returning results to the process
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将结果返回给流程
- en: 'The handler return object (`"results"`) is defined as a collection of parameters.
    Each attribute name must match a data output parameter in the `DataOutputSet`
    node settings (`"details"` and `"tweetOK"`), for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序返回对象（`"results"”）定义为参数集合。每个属性名称必须与`DataOutputSet`节点设置中的数据输出参数匹配（例如："details"和"tweetOK"），例如：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `details` and `tweetOk` keys must match both node data output parameter
    names (see the screenshot in the *Process and task parameter mappings* section)
    and the workitem handler `"results"` properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`details`和`tweetOk`键必须与节点数据输出参数名称（参见*流程和任务参数映射*部分的截图）以及工作项处理程序的`"results"`属性相匹配：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The PizzaTweet example
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PizzaTweet示例
- en: The example guides you through the definition and the installation of a full
    working example project, which features a custom workitem that sends messages
    to Twitter (Twitter API integration not implemented for clarity).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例引导您通过定义和安装一个完整的可工作示例项目，该项目包含一个自定义的工作项，该工作项向Twitter发送消息（为了清晰，未实现Twitter API集成）。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a Twitter handler implementation in the Red Hat jBPM service repository:
    [http://people.redhat.com/kverlaen/repository/Twitter/](http://people.redhat.com/kverlaen/repository/Twitter/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Red Hat jBPM服务仓库中找到一个Twitter处理程序实现：[http://people.redhat.com/kverlaen/repository/Twitter/](http://people.redhat.com/kverlaen/repository/Twitter/)。
- en: The main project (the `pizzatweet` KIE module) contains the process definition
    and the WID file, and it depends on custom types that are defined in the `pizzamodel`
    project (a plain utility JAR). These types are also used as parameter types by
    the `PizzaTweetHandler` handler (defined in the `pizzahandlers` project, another
    plain JAR).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 主要项目（`pizzatweet` KIE模块）包含流程定义和WID文件，并且它依赖于在`pizzamodel`项目中定义的自定义类型（一个普通的实用JAR）。这些类型也被`PizzaTweetHandler`处理程序（在`pizzahandlers`项目中定义，另一个普通JAR）用作参数类型。
- en: The main project (the KIE module)
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要项目（KIE模块）
- en: 'The main project depends on the two supplier projects: `pizzamodel` and `pizzahandlers`.
    Since these two projects are not KIE modules and do not need additional processing
    by the KIE runtime (they do not contain jBPM resources), we have set their Maven
    dependency scope to `provided` (see the `pom.xml` PizzaTweet project file). This
    speeds up the Maven build of our main KIE module; `kie-mave-plugin` in fact searches
    for KIE module dependencies only when their Maven scope is `runtime` or `compile`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 主要项目依赖于两个供应商项目：`pizzamodel`和`pizzahandlers`。由于这两个项目不是KIE模块，并且不需要KIE运行时进行额外处理（它们不包含jBPM资源），我们已经将它们的Maven依赖范围设置为`provided`（参见`pom.xml`
    PizzaTweet项目文件）。这加快了我们的主要KIE模块的Maven构建；实际上，`kie-mave-plugin`仅在它们的Maven范围是`runtime`或`compile`时搜索KIE模块依赖项。
- en: 'The KIE plugin for Maven (`kie-maven-plugin`) is the preferred way to build
    a KIE module. It ensures that all module business resources are valid at compile
    time and that the module can be successfully loaded at runtime. Make sure that
    you always have the `kie-maven-plugin` set in the `pom.xml` file of your KIE module
    (see the following `PizzaTweet` `pom.xml` excerpt):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Maven的KIE插件（`kie-maven-plugin`）是构建KIE模块的首选方式。它确保所有模块业务资源在编译时有效，并且模块可以在运行时成功加载。请确保您始终在KIE模块的`pom.xml`文件中设置了`kie-maven-plugin`（参见以下`PizzaTweet`
    `pom.xml`摘录）：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Process and task parameter mappings
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流程和任务参数映射
- en: 'After having introduced the `pizzatweet` custom task definition in the previous
    section (the handler definition file), let us now look at how it fits into the
    process definition. The process definition is easy to understand; it has the custom
    tweet task and a script task that acts as a debugging step. The process variables
    (`msg`, `order`, and `tags`) are mapped to the custom task input parameters, while
    the resulting parameters (`tweetOK`, `details`) are mapped back to process variables
    (`success` and `results`). The following screenshot shows the **Assignments**
    properties panel for the `Pizza Tweet` custom node (see the `PizzaTweet` process
    definition):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节（处理器定义文件）介绍了`pizzatweet`自定义任务定义之后，现在让我们看看它如何与流程定义相匹配。流程定义很容易理解；它包含自定义推文任务和一个作为调试步骤的脚本任务。流程变量（`msg`、`order`和`tags`）映射到自定义任务输入参数，而结果参数（`tweetOK`、`details`）映射回流程变量（`success`和`results`）。以下截图显示了`Pizza
    Tweet`自定义节点（参见`PizzaTweet`流程定义）的**分配**属性面板：
- en: '![Process and task parameter mappings](img/9578OS_07_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![流程和任务参数映射](img/9578OS_07_04.jpg)'
- en: After the tweet task completes, the script task is executed. As mentioned earlier,
    it simply dumps the updated process variables to the console for you to see. We
    are now going to look at the two dependent projects (handlers and models).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 推文任务完成后，执行脚本任务。如前所述，它只是将更新的流程变量输出到控制台供您查看。现在我们将查看两个依赖项目（处理器和模型）。
- en: Handler project (pizzahandlers)
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器项目（pizzahandlers）
- en: This project contains the handler implementation (the `PizzaTweetHandler` class)
    only, the one responsible for sending the tweet. In order to deploy the dependent
    `pizzahandlers` handler project, we have to perform a Maven "clean build install."
    The JAR file will then be installed in your system's Maven repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目仅包含处理器实现（`PizzaTweetHandler`类），负责发送推文。为了部署依赖的`pizzahandlers`处理器项目，我们必须执行Maven的“clean
    build install”。然后，JAR文件将被安装到您的系统Maven仓库中。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that all the implementation classes and required dependencies are
    also available on the classpath of the application war (in this case, the war
    is our KIE console war), for example, by copying the required JAR files in the
    `/lib` folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有实现类和所需依赖项也存在于应用程序war（在这种情况下，war是我们的KIE控制台war）的类路径上，例如，通过将所需的JAR文件复制到`/lib`文件夹中。
- en: Model project (pizzamodel)
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型项目（pizzamodel）
- en: The model project defines Java types for the process definition variables and
    the handler project parameters. In order to deploy the dependent `pizzamodel`
    project, we have to execute a Maven "clean build install." Thus, the JAR file
    is installed in your system's Maven repository so as to make it available to runtime
    dependency resolving.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模型项目定义了流程定义变量和处理项目参数的Java类型。为了部署依赖的`pizzamodel`项目，我们必须执行Maven的“clean build install”。因此，JAR文件被安装到您的系统Maven仓库中，以便在运行时依赖项解析时可用。
- en: IDE customization
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDE自定义
- en: 'In order to configure the KIE workbench (business process editor) tools and
    being able to use our custom node in the process editor, we have to create a workitem
    handler file. We create the `WEB-INF\classes\META-INF\PACKTworkItemHandlers.conf`
    file (in the `jbpm-console deployment` folder) and add the following content:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置 KIE 工作台（业务流程编辑器）工具并能够在流程编辑器中使用我们的自定义节点，我们必须创建一个工作项处理程序文件。我们在 `WEB-INF\classes\META-INF\PACKTworkItemHandlers.conf`
    文件（在 `jbpm-console deployment` 文件夹中）中添加以下内容：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we edit the `WEB-INF\classes\META-INF\drools.session.conf` file by adding
    our custom handler `.conf` filename to the `drools.workItemHandlers` property.
    Thus, the handler definitions from both the files are loaded. Please note that
    the handler configuration file names must be separated by a space:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将我们的自定义处理程序 `.conf` 文件名添加到 `drools.workItemHandlers` 属性中，编辑 `WEB-INF\classes\META-INF\drools.session.conf`
    文件。这样，两个文件中的处理程序定义都被加载。请注意，处理程序配置文件名必须由空格分隔：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `drools.session.conf` file is picked up by the KIE console and read during
    KIE session initialization; see the *Handler configuration file* section for further
    details.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`drools.session.conf` 文件在 KIE 控制台初始化期间被选中并读取；有关更多详细信息，请参阅 *处理程序配置文件* 部分。'
- en: 'Copy the installed `pizzahandlers-1.0.0-SNAPSHOT.jar` and `pizzamodel-1.0.0-SNAPSHOT.jar`
    files to the jBPM console''s `WEB-INF\lib` folder (for example, `wildfly-8.1.0.Final\standalone\deployments\jbpm-console.war\WEB-INF\lib`).
    This makes both the custom java types and the handler class available to the Kie
    console (a jBoss restart is required). Note that the Pizza Tweet (`name: pizzatweet`)
    custom task node is now displayed in the **Service Tasks** section of the object
    library:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将安装的 `pizzahandlers-1.0.0-SNAPSHOT.jar` 和 `pizzamodel-1.0.0-SNAPSHOT.jar` 文件复制到
    jBPM 控制台的 `WEB-INF\lib` 文件夹中（例如，`wildfly-8.1.0.Final\standalone\deployments\jbpm-console.war\WEB-INF\lib`）。这使得自定义
    Java 类型和处理程序类对 Kie 控制台可用（需要重启 jBoss）。请注意，Pizza Tweet（名称：pizzatweet）自定义任务节点现在显示在对象库的
    **服务任务** 部分中：
- en: '![IDE customization](img/9578OS_07_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![IDE 自定义](img/9578OS_07_05.jpg)'
- en: Console test run
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台测试运行
- en: As of jBPM 6.2.0 release, the KIE console is not much of a help in letting us
    test our process, since the generated task forms do not support complex type parameters
    automatically (our process takes an input parameter of the `Order` type); we cannot
    easily create our new process instances from here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 jBPM 6.2.0 版本发布，KIE 控制台在让我们测试我们的流程方面帮助不大，因为生成的任务表单不支持自动处理复杂类型参数（我们的流程接受 `Order`
    类型的输入参数）；我们无法轻松从这里创建新的流程实例。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The jBPM user guide (*Chapter 13*, *Forms*) explains the features shipped with
    the KIE console Form Modeler ([http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html](http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html))
    and gives useful instructions on how to create customized human task forms and
    start process forms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM 用户指南（第 13 章，表单）解释了与 KIE 控制台表单模型器一起提供的功能（[http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html](http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html)），并提供了有关如何创建自定义人类任务表单和启动流程表单的有用说明。
- en: However, before leaving the console, let's check whether the process can successfully
    deploy without issues. Go to the `pizzatweet` project from the **Tools**/**Project
    Details** view and issue **build & deploy**. The process definition is registered
    with the runtime, and we should see it from the **Process Management/Process Definitions**
    tab.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在离开控制台之前，让我们检查流程是否可以成功部署而不会出现任何问题。从 **工具**/**项目详情** 视图中转到 `pizzatweet` 项目，并执行
    **构建 & 部署**。流程定义已注册到运行时，我们应该能在 **流程管理/流程定义** 选项卡中看到它。
- en: '![Console test run](img/9578OS_07_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![控制台测试运行](img/9578OS_07_06.jpg)'
- en: Standalone test run
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立测试运行
- en: 'Get the PizzaTweetTest test class from the `PizzaTwitter` project and run (jUnit)
    the `newTweet` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `PizzaTwitter` 项目获取 `PizzaTweetTest` 测试类并运行（JUnit）的 `newTweet` 方法：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The console prints the following text; first, we have the following handler
    log traces:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台打印以下文本；首先，我们有以下处理程序日志跟踪：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we have the script task log traces, showing the following handler results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有脚本任务日志跟踪，显示以下处理程序结果：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the handler has been locally tested, we can move on and share it with
    the development team; this is where the service repository comes to the rescue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序本地测试完成后，我们可以继续前进并与开发团队共享；这就是服务仓库发挥作用的地方。
- en: Service repository
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务仓库
- en: jBPM gives us the ability to add any handler to a public service repository;
    these are a collection of handler definitions that can be accessed both via HTTP
    or locally (the FILE protocol) so that handlers can be shared with the other developers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM赋予我们向公共服务仓库添加任何处理器的功能；这些是一组处理器定义，可以通过HTTP或本地（文件协议）访问，以便与其他开发者共享处理器。
- en: 'At the time of writing this book, the KIE workbench supported two repositories:
    [http://people.redhat.com/kverlaen/repository](http://people.redhat.com/kverlaen/repository)
    and [http://people.redhat.com/tsurdilo/repository](http://people.redhat.com/tsurdilo/repository).
    Another repository service is available at [http://docs.jboss.org/jbpm/v6.2/repository/](http://docs.jboss.org/jbpm/v6.2/repository/).
    These repositories host several handler definitions; some of them are externally
    defined handlers (which means that the implementing JAR file is physically hosted
    in the repository), while other handlers are already defined in the jBPM runtime
    (for example, Java, REST, and transform handlers), and the repository just publishes
    the extended handler definition (`.WID`) file. The service repository is accessible
    through the **Connect to a service repository** button in the business process
    editor. Here, you have an example repository content dialog window:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，KIE工作台支持两个仓库：[http://people.redhat.com/kverlaen/repository](http://people.redhat.com/kverlaen/repository)
    和 [http://people.redhat.com/tsurdilo/repository](http://people.redhat.com/tsurdilo/repository)。另一个仓库服务可在
    [http://docs.jboss.org/jbpm/v6.2/repository/](http://docs.jboss.org/jbpm/v6.2/repository/)
    找到。这些仓库托管了多个处理器定义；其中一些是外部定义的处理器（这意味着实现JAR文件物理上托管在仓库中），而其他处理器已在jBPM运行时中定义（例如，Java、REST和转换处理器），仓库仅发布扩展处理器定义（`.WID`）文件。服务仓库可通过业务流程编辑器中的**连接到服务仓库**按钮访问。在这里，您可以看到一个示例仓库内容对话框窗口：
- en: '![Service repository](img/9578OS_07_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![服务仓库](img/9578OS_07_08.jpg)'
- en: We are going to see how to set up an additional custom local service repository.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何设置一个额外的自定义本地服务仓库。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For additional details about the service repository, please refer to *Chapter
    21, Domain-specific Processes* of the jBPM 6.2 user guide (*Service Repository*
    paragraph).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于服务仓库的更多详细信息，请参阅jBPM 6.2用户指南的第21章“特定领域流程”（服务仓库部分）。
- en: Custom service repository
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义服务仓库
- en: A service repository is basically a folder structure containing handlers. The
    folder structure and the content to load are specified by a set of `index.conf`
    files. See the `repo.rar` example included with the book's source code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务仓库基本上是一个包含处理器的文件夹结构。文件夹结构和要加载的内容由一组`index.conf`文件指定。请参阅书中源代码中包含的`repo.rar`示例。
- en: 'Create a folder structure for our repository in a local folder (for example,
    `c:/temp/packtservicerepo`) containing the `pizzatweet` handler folder; inside
    the handler folder, we add the enhanced `pizzatweet.wid` file, which is basically
    a standard WID file with the following additional entries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地文件夹（例如，`c:/temp/packtservicerepo`）中为我们的仓库创建一个文件夹结构，包含`pizzatweet`处理器文件夹；在处理器文件夹内，我们添加增强的`pizzatweet.wid`文件，这基本上是一个标准的WID文件，具有以下附加条目：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The dependencies path is relative to the handler folder (`/lib`), and there
    we copy the two JAR files: the JAR file containing the handler definition and
    the JAR file defining the Java models.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖路径相对于处理器文件夹（`/lib`），在那里我们复制两个JAR文件：包含处理器定义的JAR文件和定义Java模型的JAR文件。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the details about the pizza handler and model projects in the `PizzaTweet`
    example paragraph.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`PizzaTweet`示例段落中关于披萨处理器和模型项目的详细信息。
- en: 'It''s worth mentioning that the WID file must have the handler folder name.
    After creating the files, we can open the service repository from the KIE workbench,
    giving the following local filesystem path: `file:///c:/temp/packtservicerepo`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，WID文件必须具有处理器文件夹名称。在创建文件后，我们可以从KIE工作台打开服务仓库，给出以下本地文件系统路径：`file:///c:/temp/packtservicerepo`。
- en: '![Custom service repository](img/9578OS_07_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![自定义服务仓库](img/9578OS_07_09.jpg)'
- en: Now, we can use **Install selected item** `:`. This makes the KIE workbench
    copy the assets to the internal KIE repository so that the handler becomes available.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用**安装选定项** `:`。这会使KIE工作台将资产复制到内部KIE仓库，从而使处理器可用。
- en: jBPM identity management
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jBPM身份管理
- en: In [Chapter 4](ch04.html "Chapter 4. Operation Management"), *Operation Management*,
    we saw how the KIE workbench features JAAS-based user authentication and RBAC
    for the UI functionalities by means of the `user.properties` and `roles.properties`
    files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 运营管理")中，*运营管理*，我们看到了KIE工作台如何通过`user.properties`和`roles.properties`文件使用基于JAAS的用户身份验证和RBAC来为UI功能提供功能。
- en: The jBPM engine does not have built-in authentication or fine-grained authorization
    functionalities on process creation or task operations. TaskService and the human
    task management of users and groups with respect to task operations are delegated
    to a custom implementation of the `UserGroupCallback` interface. Here, the developer
    is able to implement his/her own task authorization mechanism by hooking into
    a custom identity management system or an ad hoc implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM引擎在创建流程或任务操作时没有内置的身份验证或细粒度授权功能。TaskService以及用户和组在任务操作方面的任务管理委托给`UserGroupCallback`接口的定制实现。在这里，开发者能够通过挂钩到自定义的身份管理系统或临时实现来实现自己的任务授权机制。
- en: 'jBPM provides a set of ready-to-use, configurable `UserGroupCallback` implementations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM提供了一套现成的、可配置的`UserGroupCallback`实现：
- en: '`DBUserGroupCallbackImpl`: Implementation that uses SQL queries to get user
    and group data from a database'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBUserGroupCallbackImpl`：使用SQL查询从数据库获取用户和组数据的实现'
- en: '`LDAPUserGroupCallbackImpl`: LDAP system integration'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDAPUserGroupCallbackImpl`：LDAP系统集成'
- en: '`MvelUserGroupCallbackImpl`: Default jBPM implementation when no callback is
    specified; the `UserGroupsAssignmentsOne.mvel` file is read and evaluated'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MvelUserGroupCallbackImpl`：当未指定回调时，默认的jBPM实现；读取并评估`UserGroupsAssignmentsOne.mvel`文件'
- en: '`JAASUserGroupCallbackImpl`: JAAS-based implementation to be used in a container
    (JBoss AS and Tomcat):![jBPM identity management](img/9578OS_07_11.jpg)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAASUserGroupCallbackImpl`：用于容器的基于JAAS的实现：![jBPM身份管理](img/9578OS_07_11.jpg)'
- en: User callback configuration
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户回调配置
- en: 'The `UserGroupCallback` implementation is a singleton and can be set on the
    environment used to create `RuntimeEngine`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserGroupCallback`实现是一个单例，可以设置在创建`RuntimeEngine`时使用的环境中：'
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'All of the book''s source code examples use a default custom callback class
    (`MyUserCallback`: you can find it in the `test-common` project). The callback
    is set by the `PacktJUnitBaseTestCase` class from which every test case borrows
    the runtime engine, the session, and so on.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有源代码示例都使用默认的定制回调类（`MyUserCallback`：您可以在`test-common`项目中找到它）。回调由`PacktJUnitBaseTestCase`类设置，每个测试用例都从该类借用运行时引擎、会话等。
- en: The jBPM UserGroupCallback implementations rely on the `jbpm.usergroup.callback.properties`
    system property for the property filename or, alternatively, on the `jbpm.usergroup.callback.properties`
    property file for automatic configuration. The callback class can have a defined
    set of properties; let's review some of them for the classes shipped with jBPM.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM UserGroupCallback实现依赖于`jbpm.usergroup.callback.properties`系统属性用于属性文件名，或者，作为替代，依赖于`jbpm.usergroup.callback.properties`属性文件进行自动配置。回调类可以定义一组属性；让我们回顾一下jBPM附带的一些类。
- en: The DBUserGroupCallbackImpl class
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBUserGroupCallbackImpl类
- en: 'This callback has the following four properties (let `users` and `groups` be
    the tables defining our users and groups data):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调具有以下四个属性（假设`users`和`groups`是定义我们的用户和组数据的表）：
- en: '`db.ds.jndi.name`: JNDI name of the data source to be used, for example, `jdbc/jbpm-ds`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.ds.jndi.name`：要使用的数据源JNDI名称，例如，`jdbc/jbpm-ds`。'
- en: '`db.user.query`: Query used to verify existence of the user (case-sensitive,
    expects a single parameter on position 1), for example:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.user.query`：用于验证用户存在的查询（区分大小写，期望在位置1上有一个参数），例如：'
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`db.roles.query`: Query user to check group existence (case-sensitive, expects
    single parameter on position 1), for example:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.roles.query`：查询以检查组的存在（区分大小写，期望在位置1上有一个参数），例如：'
- en: '[PRE19]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`db.user.roles.query`: Query used to get groups for a given user (case-sensitive,
    expects single parameter on position 1), for example:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.user.roles.query`：用于获取给定用户的组（区分大小写，期望在位置1上有一个参数），例如：'
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The LDAPUserGroupCallbackImpl class
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDAPUserGroupCallbackImpl类
- en: 'This callback relies on several properties (parameter descriptions):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调依赖于几个属性（参数描述）：
- en: '`ldap.bind.user` (optional if the LDAP server accepts anonymous access)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.bind.user`（如果LDAP服务器接受匿名访问则为可选）'
- en: '`ldap.bind.pwd` (optional if the LDAP server accepts anonymous access)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.bind.pwd`（如果LDAP服务器接受匿名访问则为可选）'
- en: '`ldap.user.ctx` (mandatory), for example, `ou\=Staff,dc\=packt,dc\=com`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.ctx` (必需)，例如，`ou=Staff,dc=packt,dc=com`'
- en: '`ldap.role.ctx` (mandatory), for example, `ou\=Roles,dc\=packt,dc\=com`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.role.ctx` (必需)，例如，`ou=Roles,dc=packt,dc=com`'
- en: '`ldap.user.roles.ctx` (optional; if not given, `ldap.role.ctx` will be used)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.roles.ctx` (可选；如果没有提供，将使用 `ldap.role.ctx`)'
- en: '`ldap.user.filter` (mandatory), for example, `=(uid\={0})`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.filter` (必需)，例如，`=(uid={0})`'
- en: '`ldap.role.filter` (mandatory), for example, `(cn\={0})`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.role.filter` (必需)，例如，`(cn={0})`'
- en: '`ldap.user.roles.filter` (mandatory), for example, `(member\={0})`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.roles.filter` (必需)，例如，`(member={0})`'
- en: '`ldap.user.attr.id` (optional; if not given, `uid` will be used)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.attr.id` (可选；如果没有提供，将使用 `uid`)'
- en: '`ldap.roles.attr.id` (optional; if not given, `cn` will be used)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.roles.attr.id` (可选；如果没有提供，将使用 `cn`)'
- en: '`ldap.user.id.dn` (optional; is user id a `DN`?; instructs the callback to
    query for a user `DN` before searching for roles; default false)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.user.id.dn` (可选；用户 ID 是否为 `DN`？；指示回调在搜索角色之前查询用户 `DN`；默认为 false)'
- en: '`ldap.search.scope` (optional; if not given, `OBJECT_SCOPE` will be used);
    the possible values are as follows: `OBJECT_SCOPE`, `ONELEVEL_SCOPE`, and `SUBTREE_SCOPE`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap.search.scope` (可选；如果没有提供，将使用 `OBJECT_SCOPE`); 可能的值如下：`OBJECT_SCOPE`、`ONELEVEL_SCOPE`
    和 `SUBTREE_SCOPE`'
- en: '`java.naming.factory.initial`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.naming.factory.initial`'
- en: '`java.naming.security.authentication`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.naming.security.authentication`'
- en: '`java.naming.security.protocol`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.naming.security.protocol`'
- en: '`java.naming.provider.url`, for example, `ldap://localhost:10389`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.naming.provider.url`，例如，`ldap://localhost:10389`'
- en: jBPM serialization
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jBPM 序列化
- en: We have seen that the engine features, with enabled persistence, state saving
    of session, process, task, and variable data to the database, and contextually,
    relevant object state data are marshalled and then, persisted on entity saving
    and unmarshaled on entity loading so as to make possible the preservation of the
    engine execution state in the long term, across system restarts. Here, the term
    **marshalling** is used because the jBPM serialization layer utilizes the Google
    Protobuf framework, a protocol, which, in the first instance, was used for RPC.
    Let us have a look at how the default jBPM serialization works and, later on,
    how we can manage to hook our serialization mechanism into jBPM.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在启用持久化的情况下，引擎具有以下功能：将会话、流程、任务和变量数据保存到数据库，并且上下文中相关的对象状态数据在实体保存时进行序列化，然后在实体加载时反序列化，以便在长期内、跨系统重启的情况下保存引擎执行状态。在这里，术语
    **序列化** 是因为 jBPM 序列化层使用了 Google Protobuf 框架，该框架最初用于 RPC。让我们看看默认的 jBPM 序列化是如何工作的，以及我们如何能够将我们的序列化机制钩入
    jBPM。
- en: Marshalling
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: '`CommandService` ([Chapter 6](ch06.html "Chapter 6. Core Architecture"), *Core
    Architecture*) and the related interceptors are invoked to persist entities in
    a transactional way; the internal object marshalling phase takes place inside
    the transaction.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandService` ([第6章](ch06.html "第6章。核心架构"), *核心架构*) 和相关的拦截器被调用以以事务方式持久化实体；内部对象序列化阶段发生在事务内部。'
- en: During the saving (or update) of the session, for example, its instance gets
    marshalled into its `RULEBYTESARRAY` column (`SessionInfo` table) so that the
    `Knowledge Session` instance can be loaded after a restart. The same happens for
    a process instance; its instance (with variables, node definitions, swimlanes,
    and so on.) is marshalled into `PROCESSINSTANCEBYTEARRAY` (the `ProcessInstanceInfo`
    table). The task data is marshalled into the `WORKITEMBYTEARRAY` (`WorkItemInfo`
    table).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话的保存（或更新）过程中，例如，其实例被序列化到其 `RULEBYTESARRAY` 列（`SessionInfo` 表）中，以便在重启后可以加载
    `Knowledge Session` 实例。对于流程实例也是如此；其实例（包括变量、节点定义、泳道等）被序列化到 `PROCESSINSTANCEBYTEARRAY`（`ProcessInstanceInfo`
    表）。任务数据被序列化到 `WORKITEMBYTEARRAY`（`WorkItemInfo` 表）。
- en: The engine classes, which actually perform the marshalling job, are respectively
    `SessionMarshallingHelper` and `ProtobufProcessMarshaller`; these classes are
    internally baked by the `ProtobufMarshaller` class, which manages operations through
    a write handler (`ProtobufOutputMarshaller`) and an input handler (`ProtobufInputMarshaller`).
    The class diagram shown later demonstrates these classes and also how `KieMarshallers`
    (we introduced this in [Chapter 6](ch06.html "Chapter 6. Core Architecture"),
    *Core Architecture*) fits into the picture. It is simply a factory default for
    marshaller and strategy instances. `Strategies` are classes that control the marshalling
    process of variables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际执行序列化任务的引擎类分别是`SessionMarshallingHelper`和`ProtobufProcessMarshaller`；这些类由`ProtobufMarshaller`类内部封装，该类通过写入处理程序（`ProtobufOutputMarshaller`）和输入处理程序（`ProtobufInputMarshaller`）管理操作。稍后显示的类图展示了这些类以及`KieMarshallers`（我们在[第6章](ch06.html
    "第6章。核心架构")中介绍了它，*核心架构*）如何融入画面。它只是一个默认的marshaller和策略实例的工厂。`策略`是控制变量序列化过程的类。
- en: Persisting variables
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量持久化
- en: jBPM does not feature off-the-shelf processes and task variable persistence
    toward an ER model, mainly because of performance reasons. The main drawback is
    that you cannot search process instances by the value of a process variable. In
    order to add this kind of feature, you have to provide an implementation for the
    `JPAPlaceholderResolverStrategy` strategy (we are going to discuss it in a moment).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM没有提供现成的流程和任务变量持久化到ER模型的功能，这主要是出于性能原因。主要缺点是您不能通过流程变量的值来搜索流程实例。为了添加此类功能，您必须为`JPAPlaceholderResolverStrategy`策略提供实现（我们将在稍后讨论它）。
- en: Strategies
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略
- en: As we have just seen, the default jBPM marshalling process results into bytes
    written in the database. This could be of limited interest to our application,
    but luckily, jBPM gives us the tools to hook into this mechanism by controlling
    the way variable (at least) marshaling works, by using or adding the so-called
    strategies.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，默认的jBPM序列化过程将结果写入数据库的字节。这可能对我们应用程序的兴趣有限，但幸运的是，jBPM提供了工具，通过控制变量（至少）序列化的方式来挂钩此机制，通过使用或添加所谓的策略。
- en: 'During marshalling, in fact, jBPM delegates the serialization of process and
    task variables to strategy classes; jBPM ships with some ready-to-use strategies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化过程中，实际上，jBPM将流程和任务变量的序列化委托给策略类；jBPM附带了一些现成的策略：
- en: '`org.drools.core.marshalling.impl.SerializablePlaceholderResolverStrategy`:
    Features default Java serialization on objects implementing the `Serializable`
    interface. jBPM adds this strategy by default to the list of enabled strategies.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.drools.core.marshalling.impl.SerializablePlaceholderResolverStrategy`：在实现`Serializable`接口的对象上提供默认的Java序列化。jBPM默认将此策略添加到启用策略列表中。'
- en: '`org.drools.persistence.jpa.marshaller.JPAPlaceholderResolverStrategy`: A strategy
    that manages variables as entities to and from a JPA-persistent store.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.drools.persistence.jpa.marshaller.JPAPlaceholderResolverStrategy`：一种将变量作为实体在JPA持久化存储之间进行管理的策略。'
- en: '`org.jbpm.document.marshalling.DocumentMarshallingStrategy`: This strategy
    manages marshalling for parameters of the `org.jbpm.document.Document` type. The
    document parameter type is used as the upload file parameter in the KIE Form modeler.
    These features are available with `jbpm-document-6-2-0.Final.jar`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jbpm.document.marshalling.DocumentMarshallingStrategy`：此策略管理`org.jbpm.document.Document`类型参数的序列化。文档参数类型在KIE表单模型器中用作上传文件参数。这些功能在`jbpm-document-6-2-0.Final.jar`中可用。'
- en: jBPM supports multiple strategies at once; it invokes them sequentially (a chain
    of responsibility patterns) following the order in which they are given when configuring
    the session (more on this in the following section). Each strategy (`ObjectMarshallingStrategy`)
    must specify the objects that it handles (the `accept` method) and provide the
    `marshal` and `unmarshal` methods (see the class diagram ahead).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM同时支持多个策略；它按照配置会话时给出的顺序（责任链模式）依次调用它们（更多内容将在下一节中介绍）。每个策略（`ObjectMarshallingStrategy`）必须指定它处理的对象（`accept`方法）并提供`marshal`和`unmarshal`方法（请参阅前面的类图）。
- en: Let us now look at how strategies can be configured using a working example
    which uses the jBPM `JPAPlaceholderResolverStrategy` in order to persist our process
    and task variables to our domain database table. Please refer to the `jbpm-marshalling`
    example project for a working marshalling example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过一个使用 jBPM `JPAPlaceholderResolverStrategy` 的实际示例来查看如何配置策略，以便将我们的流程和任务变量持久化到我们的领域数据库表中。请参阅
    `jbpm-marshalling` 示例项目以获取一个有效的 marshalling 示例。
- en: Configuring a marshalling strategy
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 marshalling 策略
- en: 'The `jbpm-marshalling` example features a process definition (`rule_marshall.bpmn`),
    which uses an entity class as both the process variable and the task parameter.
    We want the engine to transparently persist our domain variable (the `OrderEntity`
    class) into a new domain database table (the `ORDERENTITY` table). The OrderEntity
    entity class must be added to our persistence unit (check the `persistence.xml`
    project), for example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`jbpm-marshalling` 示例包含一个流程定义（`rule_marshall.bpmn`），它使用实体类作为流程变量和任务参数。我们希望引擎透明地将我们的领域变量（`OrderEntity`
    类）持久化到一个新的领域数据库表（`ORDERENTITY` 表）中。必须将 OrderEntity 实体类添加到我们的持久化单元中（检查 `persistence.xml`
    项目），例如：'
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We set the marshalling strategies by passing an array of `ObjectMarshallingStrategy`
    to the environment that is used to create KieSession; in the following example
    (the `MarshallTest` example class), we configure the `JPAPlaceholderResolverStrategy`
    and the `SerializablePlaceholderResolverStrategy` strategies (please refer to
    the *RuntimeManager and the engine* section in [Chapter 6](ch06.html "Chapter 6. Core
    Architecture"), *Core Architecture*, for details).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向用于创建 KieSession 的环境中传递一个 `ObjectMarshallingStrategy` 数组来设置 marshalling
    策略；在下面的示例（`MarshallTest` 示例类）中，我们配置了 `JPAPlaceholderResolverStrategy` 和 `SerializablePlaceholderResolverStrategy`
    策略（有关详细信息，请参阅[第 6 章](ch06.html "第 6 章。核心架构")中的*RuntimeManager 和引擎*部分，*核心架构*）。
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we provided an extended `CustomJPAPlaceholderResolverStrategy`; this
    class extends and delegates all functionalities to the default `JPAPlaceholderResolverStrategy`
    and adds some logging features by sending the relevant information to the console
    during the marshalling process. Its constructor is given `EntityManagerFactory`,
    which has been created from the same persistence unit that the engine is using.
    This means that our entity table will be in the same engine database schema. The
    `ClassObjectMarshallingStrategyAcceptor` instance (used for `SerializablePlaceholderResolverStrategy`)
    performs the logic of accepting (filtering) object instances. Remember to always
    add the `SerializablePlaceholderResolverStrategy` strategy as the last strategy,
    since it's the one used by the engine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提供了一个扩展的 `CustomJPAPlaceholderResolverStrategy`；这个类扩展并委托所有功能到默认的 `JPAPlaceholderResolverStrategy`，并在
    marshalling 过程中通过向控制台发送相关信息添加了一些日志功能。其构造函数接受 `EntityManagerFactory`，它是由与引擎使用相同的持久化单元创建的。这意味着我们的实体表将位于同一个引擎数据库模式中。`ClassObjectMarshallingStrategyAcceptor`
    实例（用于 `SerializablePlaceholderResolverStrategy`）执行接受（过滤）对象实例的逻辑。请记住，始终将 `SerializablePlaceholderResolverStrategy`
    策略作为最后一个策略添加，因为它是由引擎使用的。
- en: '![Configuring a marshalling strategy](img/9578OS_07_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![配置 marshalling 策略](img/9578OS_07_07.jpg)'
- en: Persisting variables
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化变量
- en: The `MarshallTest` class is derived from `RuleTaskTest` (see the *Rule start
    event* section in [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*);
    it sets a global session variable and then, creates the process for passing two
    parameters, namely a plain `Order` instance and an `OrderEntity` instance, which
    are then passed to the user task. Upon the completion of the user task, the business
    rule is triggered and the global session variable is evaluated.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarshallTest` 类继承自 `RuleTaskTest`（请参阅[第 5 章](ch05.html "第 5 章。BPMN 构造")中的*规则开始事件*部分，*BPMN
    构造*）；它设置一个全局会话变量，然后创建一个流程，传递两个参数，即一个普通的 `Order` 实例和一个 `OrderEntity` 实例，这些实例随后被传递给用户任务。在用户任务完成之后，业务规则被触发，并评估全局会话变量。'
- en: 'If we run the example jUnit test, we can see how the `marshall` method for
    our strategy class gets called several times before the human task is triggered:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行示例 jUnit 测试，我们可以看到在触发人工任务之前，我们的策略类的 `marshall` 方法被调用多次：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The order entity is first inserted and then, updated several times; in the database
    table, we can see our record.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 订单实体首先被插入，然后更新了多次；在数据库表中，我们可以看到我们的记录。
- en: '![Persisting variables](img/9578OS_07_10.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![持久化变量](img/9578OS_07_10.jpg)'
- en: 'It is the strategy''s responsibility to maintain the entity state consistent
    between these calls. After the task completion, the `unmarshall` method gets called
    twice: first when the workitem is loaded from the database before its completion,
    and second when the process instance is loaded from the session:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 维护实体状态在这些调用之间的一致性是策略的责任。在任务完成后，`unmarshall` 方法被调用两次：第一次是在工作项在完成前从数据库中加载时，第二次是在从会话中加载流程实例时：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'jBPM is open and configurable software. In this chapter, we reviewed three
    core features of the platform, which are commonly extended when tailoring jBPM
    systems to meet specific application requirements: domain processes and custom
    BPMN nodes, custom persistence for process and task variables, and human authorization
    based on custom implementation or legacy systems. The next chapter will provide
    the user with real-world jBPM solutions.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM 是一款开放且可配置的软件。在本章中，我们回顾了平台的核心特性，这些特性在定制 jBPM 系统以满足特定应用需求时通常会被扩展：领域流程和自定义
    BPMN 节点、流程和任务变量的自定义持久化，以及基于自定义实现或遗留系统的人事授权。下一章将为用户提供实际的 jBPM 解决方案。
