- en: '*Chapter 7*: GraalVM Polyglot – JavaScript and Node.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：GraalVM 多语言 – JavaScript 和 Node.js'
- en: In the previous chapter, we looked at how Truffle provides a layer to integrate
    other language programs to run on GraalVM. In this chapter, we will focus on JavaScript
    and Node.js interpreters, and in the next chapter, we will cover other runtimes,
    such as Java/Truffle, Python, R, and WebAssembly. We will be covering aspects
    of the polyglot interoperability features of Truffle and exploring the JavaScript
    interpreter. We will be exploring these features hands-on by writing code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Truffle 如何提供一层来集成其他语言程序以便在 GraalVM 上运行。在本章中，我们将重点关注 JavaScript 和
    Node.js 解释器，在下一章中，我们将介绍其他运行时，例如 Java/Truffle、Python、R 和 WebAssembly。我们将探讨 Truffle
    的多语言互操作性功能，并探索 JavaScript 解释器。我们将通过编写代码来亲身体验这些功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding how to run non-JVM language applications on Graal, specifically
    JavaScript and Node
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在 Graal 上运行非 JVM 语言应用程序，特别是 JavaScript 和 Node
- en: Learning how to pass objects/values between applications written in different
    languages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在用不同语言编写的应用程序之间传递对象/值
- en: Understanding how to use optimization techniques to fine-tune the code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用优化技术来微调代码
- en: By the end of this chapter, you will have a very clear understanding of how
    to build a polyglot application on GraalVM.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将非常清楚地了解如何在 GraalVM 上构建多语言应用程序。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be doing a lot of hands-on coding, to explore the
    various guest languages that GraalVM supports. To try the code, you will need
    the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行大量的动手编码，以探索 GraalVM 支持的各种客语言。要尝试代码，您需要以下内容：
- en: 'Various language Graal runtimes: We will cover in the chapter how to install
    and run these runtimes.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种语言的 Graal 运行时：我们将在本章中介绍如何安装和运行这些运行时。
- en: 'Access to GitHub: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from the following link. You will
    find the chapter-specific code under the `chapter7` directory: [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 GitHub：有一些示例代码片段，这些代码片段存储在 Git 仓库中。您可以从以下链接下载代码：[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js)。您将在`chapter7`目录下找到特定章节的代码。
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3yqu4ui](https://bit.ly/3yqu4ui).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在[https://bit.ly/3yqu4ui](https://bit.ly/3yqu4ui)找到。
- en: Understanding the JavaScript (including Node.js) Truffle interpreter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JavaScript（包括 Node.js）Truffle 解释器
- en: The GraalVM version of JavaScript is an ECMAScript-compliant runtime for both
    JavaScript, `js`, and Node.js, `node`. It supports all the features of ECMAScript
    2021, at the time of writing this book. It is also Nashorn- and Rhino-compatible
    and provides complete support for Node.js.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 的 JavaScript 版本是一个符合 ECMAScript 标准的运行时，适用于 JavaScript (`js`) 和 Node.js
    (`node`)。它支持截至本书编写时的 ECMAScript 2021 的所有功能。它还与 Nashorn 和 Rhino 兼容，并提供对 Node.js
    的完全支持。
- en: GraalVM Node.js uses the original Node.js source code and replaces the V8 JavaScript
    engine with the GraalVM JavaScript engine. The replacement is seamless, and the
    application developers don't have to modify any significant amount of code or
    configuration to run existing Node.js applications with GraalVM Node.js. GraalVM
    Node.js provides more features for embedding code from other languages, and accessing
    data and code, and interoperating code in other language. `npm`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM Node.js 使用原始的 Node.js 源代码，并用 GraalVM JavaScript 引擎替换了 V8 JavaScript
    引擎。这种替换是无缝的，应用程序开发者不需要修改大量代码或配置，就可以使用 GraalVM Node.js 运行现有的 Node.js 应用程序。GraalVM
    Node.js 为嵌入来自其他语言的代码、访问数据和代码以及与其他语言代码的互操作提供了更多功能。`npm`。
- en: In this section, apart from using JavaScript and Node as an alternate runtime
    for running applications, we will also explore their polyglot interoperability
    features. We will be walking through a lot of JavaScript and Node.js sample code
    to explore the polyglot capabilities of the GraalVM JavaScript runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，除了将 JavaScript 和 Node 作为运行应用程序的替代运行时之外，我们还将探索它们的互操作性功能。我们将通过大量的 JavaScript
    和 Node.js 示例代码来探索 GraalVM JavaScript 运行时的多语言能力。
- en: Verifying JavaScript, Node, and npm installation and versions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 JavaScript、Node 和 npm 的安装和版本
- en: JavaScript and Node.js come along with the GraalVM installation; you will find
    them in the `<GraalHome>/bin` directory. We can check if the JavaScript runtime
    is properly configured by checking the version number.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 和 Node.js 随 GraalVM 安装一起提供；你可以在 `<GraalHome>/bin` 目录中找到它们。我们可以通过检查版本号来验证
    JavaScript 运行时是否配置正确。
- en: 'To check the version, execute the `js --version` command. At the time of writing
    this book, GraalVM JavaScript 21.0.0.2 was the latest. The following is the output
    (note that it is GraalVM JavaScript):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查版本，请执行 `js --version` 命令。在撰写本书时，GraalVM JavaScript 21.0.0.2 是最新的。以下是输出（注意，这是
    GraalVM JavaScript）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also ensure that we are running the right version of Node.js by calling
    a specific node.js version by executing the `node --version` command. In the following
    command, we are explicitly calling the right version. Note that the GraalVM home
    location might be different for you:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过执行 `node --version` 命令来确保我们正在运行正确的 Node.js 版本。在以下命令中，我们明确调用正确的版本。请注意，对于您来说，GraalVM
    主目录可能不同：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s also make sure NPM is working by executing the `npm --version` command.
    The following is the command and output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也通过执行 `npm --version` 命令来确保 NPM 正在运行。以下是命令和输出：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have verified the JavaScript, Node.js, and npm installations, let's
    create a simple Node.js application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经验证了 JavaScript、Node.js 和 npm 的安装，让我们创建一个简单的 Node.js 应用程序。
- en: 'Go to an application folder, and execute `npm init`. This will set up the boilerplate
    configuration for the Node.js application. We will name the application `graal-node-app`.
    The following shows the console output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 进入应用程序文件夹，并执行 `npm init`。这将设置 Node.js 应用程序的样板配置。我们将应用程序命名为 `graal-node-app`。以下显示的是控制台输出：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This creates a Node.js application and a `package.json` file with a boilerplate
    configuration, based on the options we selected. Let''s install the `express`
    package by executing `npm install --save express`. This installs the `express`
    package in the application folder and also updates the `package.json` file (because
    of the `--save` argument). Here is the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个基于我们选择的选项的 Node.js 应用程序和 `package.json` 文件，其中包含样板配置。让我们通过执行 `npm install
    --save express` 来安装 `express` 包。这将把 `express` 包安装到应用程序文件夹中，并更新 `package.json`
    文件（因为使用了 `--save` 参数）。以下是输出：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will find the `node_modules` directory, which contains all the packages
    that are required to run our application. Let''s create an `index.js` file with
    the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到包含运行我们的应用程序所需的所有包的 `node_modules` 目录。让我们创建一个 `index.js` 文件，并使用以下代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, it's a very simple application, which responds with an HTML
    `Hello Graal Node` as a header 1, when invoked at the root. The application will
    listen at port number `8080`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的应用程序，当在根目录下调用时，会以 HTML `Hello Graal Node` 作为标题 1 响应。应用程序将在端口号
    `8080` 上监听。
- en: 'Let''s run this application with the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此应用程序：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we can see the output, we know that the application is listening at
    `8080`. Let''s try to call this from the web browser at http://localhost:8080/.
    The following is the screenshot of the application response on the web browser:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以看到输出，我们知道应用程序正在监听 `8080`。让我们尝试从 Web 浏览器在 http://localhost:8080/ 上调用它。以下是应用程序在
    Web 浏览器上响应的截图：
- en: '![Figure 7.1 – Hello Graal Node screenshot'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – Hello Graal Node 截图'
- en: '](img/B16878_Figure_7.1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – Hello Graal Node 截图](img/B16878_Figure_7.1.jpg)'
- en: Figure 7.1 – Hello Graal Node screenshot
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Hello Graal Node 截图
- en: Now that we know that the Node.js on GraalVM is working fine, let's understand
    the polyglot interoperability.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道 GraalVM 上的 Node.js 运行正常，让我们了解多语言互操作性。
- en: JavaScript interoperability
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 互操作性
- en: In [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle –
    An Overview*, we went into a lot of details about how Truffle enables polyglot
    support and provides an infrastructure for polyglot interoperability and polyglot
    embedding. In this section, we will explore these features with sample code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)，“Truffle – 概述”中，我们详细介绍了
    Truffle 如何启用多语言支持，并提供多语言互操作性和嵌入的基础设施。在本节中，我们将通过示例代码探索这些功能。
- en: Let's take the Node.js application that we created in the previous section,
    and add an endpoint, `/poly`, in our `index.js` file. Let's create a simple Python
    array object, and store some numbers in the object. We will then iterate through
    this Python object in Node.js, to list these numbers. This shows how we can embed
    Python code snippets within JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取用上一节中创建的Node.js应用程序，并在我们的`index.js`文件中添加一个端点`/poly`。让我们创建一个简单的Python数组对象，并在对象中存储一些数字。然后我们将遍历这个Python对象在Node.js中，列出这些数字。这展示了我们如何在JavaScript中嵌入Python代码片段。
- en: 'The following source code shows this new endpoint, `/poly`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码显示了这个新的端点`/poly`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s have the code to listen at port `8080` and call the preceding function
    when we receive a request:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码来监听`8080`端口，并在收到请求时调用前面的函数：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the code, we are using the `Polyglot.eval()` method to run
    Python code. To let the polyglot object know that it''s Python code, we are passing
    `python` as a parameter, and passing the Python representation of the array. Let''s
    now run this code with `node`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所见，我们正在使用`Polyglot.eval()`方法来运行Python代码。为了让polyglot对象知道它是Python代码，我们传递了`python`作为参数，并传递了数组的Python表示。现在让我们用`node`运行此代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we have to pass `--jvm` and `--polyglot` arguments to node. It's very
    important to pass these parameters. `--jvm` tells node to run on `--polyglot`,
    as the name suggests, tells node to support `polyglot`. Since Truffle and Graal
    run on JVM, it's important to use the `jvm` argument, even though we may not be
    directly using Java in our code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须向node传递`--jvm`和`--polyglot`参数。传递这些参数非常重要。`--jvm`告诉node在`--polyglot`上运行，正如其名称所暗示的，告诉node支持`polyglot`。由于Truffle和Graal在JVM上运行，因此使用`jvm`参数很重要，即使我们可能没有在我们的代码中直接使用Java。
- en: 'Let''s now access this new endpoint from the browser. The following screenshot
    shows the output as expected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从浏览器中访问这个新的端点。以下截图显示了预期的输出：
- en: '![Figure 7.2 – /poly endpoint result screenshot'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – `/poly`端点结果截图'
- en: '](img/B16878_Figure_7.2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16878_Figure_7.2.jpg](img/B16878_Figure_7.2.jpg)'
- en: Figure 7.2 – /poly endpoint result screenshot
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – `/poly`端点结果截图
- en: 'As you might have noticed, the first time we called, it took time to load the
    page, but the subsequent calls are instantaneous. Let''s just time that with curl
    (curl is a command-line utility to call any URLs. Please refer to [https://curl.se/](https://curl.se/)
    for more details on curl and how to install curl on your machine). The following
    is a screenshot of a sequence of curl commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，我们第一次调用时页面加载需要时间，但随后的调用都是瞬间的。让我们用curl来计时（curl是一个用于调用任何URL的命令行工具。有关curl的更多详细信息以及如何在您的机器上安装curl，请参阅[https://curl.se/](https://curl.se/)）。以下是一系列curl命令的截图：
- en: '![Figure 7.3 – Performance of Node.js after subsequent calls'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – 随后调用后Node.js的性能'
- en: '](img/B16878_Figure_7.3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16878_Figure_7.3.jpg](img/B16878_Figure_7.3.jpg)'
- en: Figure 7.3 – Performance of Node.js after subsequent calls
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 随后调用后Node.js的性能
- en: We can see the initial load on the CPU, but subsequent calls are quick with
    no additional load on the CPU.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到CPU的初始负载，但随后的调用快速进行，没有额外的CPU负载。
- en: Let's now explore more advanced features of polyglot interoperability. JavaScript
    and Java interoperability is very sophisticated. Let's explore the concepts with
    more complex implementations than lists.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索polyglot互操作性的更多高级功能。JavaScript和Java互操作性非常复杂。让我们通过比列表更复杂的实现来探索这些概念。
- en: JavaScript embedded code in Java
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的JavaScript嵌入代码
- en: Let's recall the `FibonaaciCalculator.java` file that we used in previous chapters.
    Let's modify that `FibonacciCalculator.java` to use a JavaScript snippet and execute
    that JavaScript snippet within Java.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在前面章节中使用的`FibonaaciCalculator.java`文件。让我们将`FibonacciCalculator.java`修改为使用JavaScript片段并在Java中执行该JavaScript片段。
- en: 'Here is the modified version of the `FibonacciCalculator` with an embedded
    JavaScript snippet. The Java file is called `FibonacciCalculatorPolyglot.java`.
    You can find the full code in the Git repository:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有嵌入JavaScript片段的修改后的`FibonacciCalculator`版本。Java文件名为`FibonacciCalculatorPolyglot.java`。您可以在Git仓库中找到完整的代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to import the `polyglot` classes. This implements the Truffle interoperability:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须导入`polyglot`类。这实现了Truffle互操作性：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s define the `main()` function, which will invoke `findFibonacci()`
    several times to reach the compiler threshold:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`main()`函数，它将多次调用`findFibonacci()`以达到编译器阈值：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explore this code. We have defined a static `String` variable that holds
    the JavaScript snippet, shown next:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这段代码。我们定义了一个静态`String`变量，它包含下一个显示的JavaScript代码片段：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have defined a static `String` with a simple JavaScript function that prints
    whatever is the parameter that is passed to it. To invoke this JavaScript code
    within Java, we need to first import the `Polyglot` libraries by importing the
    following packages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个静态`String`，其中包含一个简单的JavaScript函数，该函数打印传递给它的任何参数。要在Java中调用此JavaScript代码，我们需要首先通过导入以下包来导入`Polyglot`库：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To invoke the JavaScript code, we first need to create an instance of the `org.graalvm.polyglot.Context`
    class. The `Context` object provides the polyglot context to allow the guest language
    code to run in the host language. A polyglot context represents the global runtime
    state of all installed and permitted languages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用JavaScript代码，我们首先需要创建`org.graalvm.polyglot.Context`类的实例。`Context`对象提供了多语言上下文，允许客语言代码在宿主语言中运行。多语言上下文表示所有已安装和允许的语言的全局运行时状态。
- en: 'The simplest way to use the `Context` object is to create the `Context` object
    and use the `eval()` function in the `Context` object, to execute other language
    code. The following is a code snippet where we are executing a JavaScript code
    snippet within Java. In this case, the guest language is JavaScript, which is
    passed as a parameter, `"js"`, in the `eval` method in the host language, Java:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Context`对象的最简单方法是创建`Context`对象，并在`Context`对象中使用`eval()`函数执行其他语言代码。以下是一个代码片段，其中我们在Java中执行JavaScript代码片段。在这种情况下，客语言是JavaScript，它作为参数`"js"`传递到宿主语言Java的`eval`方法中：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s execute this code. Following is the screenshot of the output, after
    execution:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行此代码。以下是执行后的输出截图：
- en: '![Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript
    outputs'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – FibonacciCalculatorPolyglot的输出，显示Java和JavaScript的输出'
- en: '](img/B16878_Figure_7.4.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_7.4.jpg)'
- en: Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript
    outputs
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – FibonacciCalculatorPolyglot的输出，显示Java和JavaScript的输出
- en: As you can see in the output, we have two totals printed, one is printed with
    Java code and the other one is printed from the JavaScript code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，我们打印了两个总数，一个是用Java代码打印的，另一个是从JavaScript代码打印的。
- en: This opens up a lot of possibilities – imagine running machine learning code
    written in Python or R in Node.js web applications. We are bringing the best features
    of individual languages together in one VM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了许多可能性——想象一下在Node.js网络应用程序中运行用Python或R编写的机器学习代码。我们正在将单个语言的最佳特性结合在一个虚拟机中。
- en: 'The `Context` object has `ContextBuilder`, which can be used to set specific
    environment properties. The following are some of the properties that it can set,
    and the relevant `Context` creates code. This can be used to control the access
    the guest language has to the host. The code to control the access is `Context.newBuilder().allowXXX().build()`.
    The following are various `allowXXX` methods that can be used for finer access
    control:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`对象有`ContextBuilder`，可以用来设置特定的环境属性。以下是可以设置的属性之一，以及相关的`Context`创建代码。这可以用来控制客语言对宿主的访问。控制访问的代码是`Context.newBuilder().allowXXX().build()`。以下是可以用于更精细访问控制的`allowXXX`方法的各个版本：'
- en: '`allowAllAccess(boolean)`: This is the default. It provides all access to the
    guest language.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowAllAccess(boolean)`: 这是默认设置。它为客语言提供所有访问权限。'
- en: '`allowCreateProcess(boolean)`: Provides control access for the guest language
    to create a new process.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowCreateProcess(boolean)`: 为客语言创建新进程提供控制访问。'
- en: '`allowCreateThread(boolean)`: Provides control access for the guest language
    to create a new thread.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowCreateThread(boolean)`: 为客语言创建新线程提供控制访问。'
- en: '`allowEnvironmentAccess(EnvironmentAccess)`: Allows control access to the environment
    using the provided policy.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowEnvironmentAccess(EnvironmentAccess)`: 允许使用提供的策略控制访问环境。'
- en: '`allowHostClassLoading(boolean)`: This allows the guest languages to load new
    host classes via a JAR or a class file.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowHostClassLoading(boolean)`: 这允许客语言通过JAR文件或类文件加载新的宿主类。'
- en: '`allowIO(boolean)`: Controls access to perform I/O operations. If true, the
    guest language can perform unrestricted I/O operations on the host system.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowIO(boolean)`: 控制执行I/O操作的访问。如果为true，客语言可以在宿主系统上执行不受限制的I/O操作。'
- en: '`allowNativeAccess(boolean)`: Controls guest languages to access the native
    interface.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowNativeAccess(boolean)`: 控制客语言访问本地接口。'
- en: '`allowPolyglotAccess(PolyglotAccess)`: Controls polyglot access using the provided
    policy. `PolyglotAccess` can be used to define custom polyglot access policies
    on how the data, bindings, and code execution can be the controlled at a finer
    level. This is a custom implementation, which the guest languages can build using
    the `PolyglotAccess` builder.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowPolyglotAccess(PolyglotAccess)`: 使用提供的策略控制多语言访问。`PolyglotAccess` 可以用来定义自定义的多语言访问策略，以更细粒度地控制数据、绑定和代码执行。这是一个自定义实现，访客语言可以使用
    `PolyglotAccess` 构建器来构建。'
- en: Refer to the Javadoc ([https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html](https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html))
    for more details about other methods. It is risky to give the guest language all
    the access; it's always better to provide fine and specific access based on the
    requirement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Javadoc ([https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html](https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html))
    以获取有关其他方法的更多详细信息。给访客语言所有访问权限是有风险的；根据需求提供精细和具体的访问总是更好的。
- en: 'Here is an example of how we can build a `Context` object with specific access:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用特定访问构建 `Context` 对象的示例：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also load an external file using the following code snippet, which is
    a recommended way of embedding code. It is not a good practice to copy-paste the
    other language code as a string into the host language. It's a configuration management
    nightmare to keep the code up to date and bug-free, as the code in other languages
    might be developed by different developers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下代码片段加载外部文件，这是嵌入代码的推荐方式。将其他语言的代码作为字符串复制粘贴到宿主语言中并不是一个好的做法。保持代码更新且无错误是一项配置管理噩梦，因为其他语言的代码可能由不同的开发者开发。
- en: 'Following is a code snippet that shows how to load the source code as a file,
    rather than embedding the guest language code in the host source code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段，展示了如何将源代码作为文件加载，而不是将访客语言代码嵌入到宿主源代码中：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this section, we saw how we can invoke JavaScript code from Java. Now let's
    try to call a Java class from JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何从 Java 中调用 JavaScript 代码。现在让我们尝试从 JavaScript 中调用一个 Java 类。
- en: Calling a Java class from JavaScript/Node.js
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 JavaScript/Node.js 调用 Java 类
- en: 'Now that we have seen how Java code can run JavaScript code, let''s try to
    call Java code from JavaScript. Here is a very simple Java application, which
    prints the argument that is passed to it on a console. The name of the Java file
    is `HelloGraalPolyglot.java`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Java 代码如何运行 JavaScript 代码，让我们尝试从 JavaScript 中调用 Java 代码。以下是一个非常简单的
    Java 应用程序，它在控制台上打印传递给它的参数。Java 文件的名称是 `HelloGraalPolyglot.java`：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's compile this application with `javac HelloGraalPolyglot.java`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `javac HelloGraalPolyglot.java` 编译此应用程序。
- en: 'Now let''s try to call this application from the JavaScript. The following
    is the JavaScript code `hellograalpolyglot.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试从 JavaScript 中调用此应用程序。以下是在 JavaScript 中的代码 `hellograalpolyglot.js`：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is very simple JavaScript code. We are loading the Java class using the `Java.type()`
    method in JavaScript, and calling the `main()` method with a `String` parameter,
    and passing the string `"Hello from JavaScript"`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常简单的 JavaScript 代码。我们使用 JavaScript 中的 `Java.type()` 方法加载 Java 类，并使用 `String`
    参数调用 `main()` 方法，并传递字符串 `"Hello from JavaScript"`。
- en: 'To execute this JavaScript, we will have to pass the `--jvm` argument and `--vm.cp`
    to set the classpath. Here is the command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此 JavaScript，我们必须传递 `--jvm` 参数和 `--vm.cp` 来设置类路径。以下是命令：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following shows the output of executing this command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了执行此命令的输出：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This was a very simple example. To understand how parameters are passed and
    how the method return data is captured and used in JavaScript, let's try to call
    the `findFibonacci()` method defined in the `FibonacciCalculator.java` code, from
    a Node.js application. We will pass a parameter and get an array out of the method,
    which we will render as a web page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子。为了理解参数是如何传递的，以及方法返回的数据是如何在 JavaScript 中捕获和使用，让我们尝试从 Node.js 应用程序中调用定义在
    `FibonacciCalculator.java` 代码中的 `findFibonacci()` 方法。我们将传递一个参数，并从方法中获取一个数组，我们将将其渲染为网页。
- en: 'Let''s modify `index.js` and add another endpoint, `/fibonacci`. Here is the
    complete source code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `index.js` 并添加另一个端点 `/fibonacci`。以下是完整的源代码：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this `node.js` code, we are first loading the Java class `FibonacciCalculatorPolyglot`
    using the `Java.Type()` method. Then we are creating an instance of this class
    and calling the method directly. The output, we know, is an array. We are iterating
    through the array and printing the result as an HTML list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`node.js`代码中，我们首先使用`Java.Type()`方法加载Java类`FibonacciCalculatorPolyglot`。然后我们创建这个类的实例并直接调用方法。我们知道输出是一个数组。我们正在遍历数组并将结果打印为HTML列表。
- en: 'Let''s run this code with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行此代码：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s go to http://localhost:8080/fibonacci. Here is the screenshot of
    the output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到http://localhost:8080/fibonacci。以下是输出截图：
- en: '![Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator
    method screenshot'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 调用FibonacciCalculator方法的Node.js应用程序输出截图'
- en: '](img/B16878_Figure_7.5.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_7.5.jpg)'
- en: Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator
    method screenshot
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 调用FibonacciCalculator方法的Node.js应用程序输出截图
- en: The preceding screenshot shows the Node.js/Fibonacci endpoint working, where
    it is listing the first 10 Fibonacci numbers as an HTML list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了Node.js/Fibonacci端点正在工作，其中它以HTML列表的形式列出前10个斐波那契数。
- en: 'In this section, we looked at how to run a JavaScript snippet within Java,
    invoke Java from JavaScript and invoke a Java method, pass parameters, and get
    results from a Java method from a Node.js application. Let''s very quickly summarize
    the various JavaScript interoperability features:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何在Java中运行JavaScript代码片段，从JavaScript调用Java，调用Java方法，传递参数，以及从Node.js应用程序中获取Java方法的返回结果。让我们快速总结一下各种JavaScript互操作性功能：
- en: When we want to call Java code from JavaScript, we pass the `--jvm` argument
    and set `CLASSPATH` to load the right class using `--vm.cp`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想从JavaScript调用Java代码时，我们需要传递`--jvm`参数，并使用`--vm.cp`设置`CLASSPATH`来加载正确的类。
- en: We use the polyglot `Context` object in Java to run other language code. There
    is a special `ScriptEngine` object for running JavaScript in Java. The `Context`
    object wraps this and is the recommended way to run.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在Java中使用多语言`Context`对象来运行其他语言代码。有一个特殊的`ScriptEngine`对象用于在Java中运行JavaScript。`Context`对象封装了这个对象，并且是推荐的运行方式。
- en: We use `Java.type()` to load a Java class from JavaScript/Node.js.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Java.type()`从JavaScript/Node.js加载Java类。
- en: We can use `new` to create the instances of the class.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`new`关键字来创建类的实例。
- en: Type conversion is taken care of by GraalVM between Java and JavaScript. In
    cases where there could be a loss of data (for example, converting from `long`
    to `int`) a `TypeError` is thrown.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换由GraalVM在Java和JavaScript之间处理。在可能丢失数据的情况下（例如，从`long`转换为`int`），会抛出`TypeError`。
- en: Java package resolution can be done by providing the full package path while
    calling `Java.type()`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`Java.type()`时，可以通过提供完整的包路径来完成Java包的解析。
- en: Exception handling can be done naturally using `try{}catch` blocks both in Java
    and JavaScript. GraalVM takes care of converting the exception.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理可以通过在Java和JavaScript中使用`try{}catch`块来实现。GraalVM负责转换异常。
- en: In the preceding example, we looked at how Java arrays can be iterated by JavaScript.
    Similarly, `Hashmap` can also be used natively using the `put()` and `get()` methods.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们探讨了Java数组如何被JavaScript迭代。同样，`Hashmap`也可以使用`put()`和`get()`方法原生地使用。
- en: JavaScript objects can be accessed by Java code as instances of the `com.oracle.truffle.api.interop.java.TruffleMap`
    class.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript对象可以通过Java代码作为`com.oracle.truffle.api.interop.java.TruffleMap`类的实例来访问。
- en: In this section, we looked at how we can interoperate between Java and JavaScript.
    Let's now explore how to build polyglot native images.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何在Java和JavaScript之间进行互操作。现在，让我们探索如何构建多语言原生镜像。
- en: Polyglot native images
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多语言原生镜像
- en: 'Graal also supports creating native images of polyglot applications. To create
    a native image of this Java class, we have to use the `--language` argument to
    build the native image. The following are the various language flags we can pass
    to `native-image` (the Native Image builder). In [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Graal Ahead-of-Time Compiler and Native Image*, we covered the Native Image builder
    in detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Graal还支持创建多语言应用程序的原生镜像。要创建这个Java类原生镜像，我们必须使用`--language`参数来构建原生镜像。以下是可以传递给`native-image`（原生镜像构建器）的各种语言标志。在[*第5章*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097)中，*Graal即时编译器和原生镜像*，我们详细介绍了原生镜像构建器：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our example, we have to pass `--language:js` to let the Native Image builder
    know that we are using JavaScript within our Java code. So, we need to execute
    the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们必须传递 `--language:js` 以让 Native Image 构建器知道我们在 Java 代码中使用 JavaScript。因此，我们需要执行以下命令：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Following is the screenshot of the output after executing the command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行命令后的输出截图：
- en: '![Figure 7.6 – Polyglot Native Image build output screenshot'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 多语言原生图像构建输出截图'
- en: '](img/B16878_Figure_7.6.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_7.6.jpg)'
- en: Figure 7.6 – Polyglot Native Image build output screenshot
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 多语言原生图像构建输出截图
- en: 'The Native Image builder performs a static code analysis and builds the optimum
    image of our polyglot application. We should be able to find the executable `fibonaccicalculatorpolyglot`
    file in the directory. Let''s execute the native image with the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Native Image 构建器执行静态代码分析并构建我们多语言应用程序的最佳图像。我们应该能够在目录中找到可执行的 `fibonaccicalculatorpolyglot`
    文件。让我们使用以下命令执行原生图像：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following figure shows the screenshot of the output when we run the native
    image:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了运行原生图像时的输出截图：
- en: '![Figure 7.7 – Polyglot Native Image execution results screenshot'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 多语言原生图像执行结果截图'
- en: '](img/B16878_Figure_7.7.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_7.7.jpg)'
- en: Figure 7.7 – Polyglot Native Image execution results screenshot
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 多语言原生图像执行结果截图
- en: (In this example, you might find the code is performing more slowly than in
    JIT mode. Please refer to [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*, for more details on why this is happening.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: （在这个例子中，你可能会发现代码在 JIT 模式下运行得更慢。请参阅 [*第 4 章*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)，*Graal
    即时编译器*，了解更多关于为什么会出现这种情况的详细信息。）
- en: Bindings
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'The binding object acts as an intermediate layer between Java and JavaScript
    to access methods, variables, and objects between the languages. To understand
    how bindings work, let''s write a very simple JavaScript file that has three methods
    – `add()`, `subtract()`, and `multiply()`. All three methods access two numbers
    and return a number. We also have a variable that holds a simple string. Here
    is the JavaScript code, `Math.js`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定对象在 Java 和 JavaScript 之间充当中间层，以访问两种语言之间的方法、变量和对象。为了了解绑定是如何工作的，让我们编写一个非常简单的
    JavaScript 文件，该文件有三个方法 – `add()`、`subtract()` 和 `multiply()`。所有三个方法都访问两个数字并返回一个数字。我们还有一个包含简单字符串的变量。以下是
    JavaScript 代码，`Math.js`：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This JavaScript code is very simple and straightforward.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 JavaScript 代码非常简单且直接。
- en: Let's now write a simple Java class that loads this JavaScript file and calls
    the methods by passing integer parameters, and prints the result returned by JavaScript
    methods. This class also accesses the variable `helloMathMessage` and prints it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一个简单的 Java 类，该类加载此 JavaScript 文件，通过传递整数参数调用方法，并打印 JavaScript 方法返回的结果。此类还可以访问变量
    `helloMathMessage` 并打印它。
- en: 'Let''s walk through the code to understand how this works. Here is the code,
    `MathJSCaller.java`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析代码以了解其工作原理。以下是代码，`MathJSCaller.java`：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are importing all the polyglot classes that implement the Truffle interoperability:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入所有实现 Truffle 互操作性的多语言类：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we are creating the `Context` object and loading the
    JavaScript file and building it. Once the JavaScript is loaded, then to access
    the method members and variable member from the JavaScript file, we are using
    `Context.getBindings()`. Bindings provide a layer that allows polyglot languages
    to access the data and method members:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建 `Context` 对象，加载 JavaScript 文件并构建它。一旦 JavaScript 被加载，为了从 JavaScript
    文件中访问方法成员和变量成员，我们使用 `Context.getBindings()`。绑定提供了一层，允许多语言访问数据和成员方法：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are just printing the binding keys to see what all members are exposed to.
    Now, let''s access the members, by calling the methods and accessing the variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是打印绑定键以查看所有公开的成员。现在，让我们通过调用方法和访问变量来访问成员：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we are printing all the results. The complete source code is available
    at the Git repository link provided in the *Technical requirements* section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出所有结果。完整的源代码可在 *技术要求* 部分的 Git 仓库链接中找到。
- en: 'Now, let''s run this application. The following screenshot shows the output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个应用程序。以下截图显示了输出：
- en: '![Figure 7.8 MathJSCaller execution results'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 MathJSCaller 执行结果'
- en: '](img/B16878_Figure_7.8.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_7.8.jpg)'
- en: Figure 7.8 MathJSCaller execution results
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 MathJSCaller 执行结果
- en: We can see that our program is working. It can load the JavaScript `math.js`
    file and call all the methods. We also see the list of binding keys, which we
    printed by calling `System.out.println("Binding Keys :" + ctx.getBindings("js").getMemberKeys());`.
    We can see the list has four keys, and they match what we have in the `math.js`
    file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的程序正在运行。它可以加载JavaScript的`math.js`文件并调用所有方法。我们还看到了绑定键的列表，这是通过调用`System.out.println("Binding
    Keys :" + ctx.getBindings("js").getMemberKeys());`打印出来的。我们可以看到列表有四个键，它们与`math.js`文件中的内容相匹配。
- en: In this example, we saw how a binding object acts as an interface to access
    JavaScript members from Java.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了绑定对象如何作为接口从Java访问JavaScript成员。
- en: Multithreading
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: JavaScript on GraalVM supports multithreading. In this section, we will explore
    various patterns that are supported in the context of polyglot between Java and
    JavaScript.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM上的JavaScript支持多线程。在本节中，我们将探讨在多语言环境中Java和JavaScript之间支持的多种模式。
- en: A JavaScript object that is created in a thread can only be used within that
    thread, it cannot be accessed from another thread. For example, in our example,
    `Value` objects such as `addFunction`, `subtractFunction`, and so on can only
    be used with that thread.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程中创建的JavaScript对象只能在该线程中使用，不能从另一个线程访问。例如，在我们的例子中，`Value`对象如`addFunction`、`subtractFunction`等只能与该线程一起使用。
- en: 'Let''s modify our `MathJSCaller` class'' `runMathJS()` method to run a thread
    indefinitely, to simulate a concurrent access situation. Let''s modify the preceding
    code and call the member functions in a separate thread. Here is the code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`MathJSCaller`类的`runMathJS()`方法，使其无限期地运行，以模拟并发访问情况。让我们修改前面的代码，并在单独的线程中调用成员函数。以下是代码片段：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We copied the accessing of the member methods in a separate thread. Now let''s
    call this in a loop, to simulate concurrent access, using the same `Context` object
    within the threads and outside the thread. The following code snippet shows calls
    outside the thread using the same `Context` object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在单独的线程中复制了成员方法的访问。现在让我们在循环中调用它，以模拟并发访问，使用线程内部的相同`Context`对象和线程外部的对象。以下代码片段显示了使用相同`Context`对象在线程外部的调用：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run this code, at some point, when the objects are simultaneously accessed
    by the two threads, we should get the following exception:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，在某个时刻，当两个线程同时访问对象时，我们应该得到以下异常：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To overcome this issue, it is recommended to use isolated runtimes. We can
    create separate `Context` objects per thread and create new instances of these
    objects and use them in that thread. Here is the fixed code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，建议使用隔离的运行时。我们可以为每个线程创建单独的`Context`对象，并创建这些对象的新实例，并在该线程中使用它们。以下是修复后的代码：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, within the thread, we are creating a separate `Context` object. The following
    code snippet shows the updated code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在线程内部，我们创建了一个单独的`Context`对象。以下代码片段显示了更新的代码：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see, in this code, we are creating a separate `context` object within
    the thread, which is local to the thread. This does not create an exception.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这段代码中，我们在线程内部创建了一个单独的`context`对象，它是线程本地的。这不会创建异常。
- en: 'The other solution to this is to access the `context` object in proper `synchronized`
    blocks or methods, so that the runtimes are not accessed at the same time. Here
    is the updated code, with a `synchronized` block:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一个方法是，在适当的`synchronized`块或方法中访问`context`对象，这样就不会同时访问运行时。以下是带有`synchronized`块的更新代码：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also include the whole block as a synchronized block, still using the
    same `Context` object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将整个块作为一个`synchronized`块包含在内，仍然使用相同的`Context`对象：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will also run fine but might run slower than the previous solution, as
    there could be a lot of locks on the `Context` object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将正常运行，但可能比之前的解决方案慢，因为可能会有很多锁在`Context`对象上。
- en: Java objects are thread-safe, so Java objects can be accessed between JavaScript
    runtimes running different threads.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java对象是线程安全的，因此Java对象可以在运行在不同线程的JavaScript运行时之间访问。
- en: Asynchronous programming – Promise and await
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程 - Promise和await
- en: 'Asynchronous programming is very prominent in modern distributed applications.
    JavaScript uses `Promise`. The `Promise` object represents the completion of an
    asynchronous activity, along with the final value. The `Promise` object has three
    states:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程在现代分布式应用中非常突出。JavaScript使用`Promise`。`Promise`对象表示异步活动的完成，以及最终值。`Promise`对象有三个状态：
- en: '**Pending**: This state is the initial state.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待定**：此状态是初始状态。'
- en: '**Fulfilled**: This state indicates that the operation successfully executed.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**履行**：此状态表示操作成功执行。'
- en: '**Rejected**: This state indicates that the operation failed.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：此状态表示操作失败。'
- en: Sometimes, we may have to have JavaScript creating a promise and the logic might
    be running in Java code, and when the Java code is done, it may have to fulfill
    or reject the promise. To handle that, Graal provides a `PromiseExecuter` interface.
    A Java class has to implement this interface method, `void onPromiseCreation(Value
    onResolve, Value onReject);`. A Java class that implements this interface can
    be used by JavaScript to create a `Promise` object. JavaScript can call `await`
    on a Java object that implements void then `(Value onResolve`, `Value onReject);`
    to implement asynchronous programming between JavaScript and Java.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要JavaScript创建一个承诺，逻辑可能运行在Java代码中，当Java代码完成时，可能需要履行或拒绝这个承诺。为了处理这种情况，Graal提供了一个`PromiseExecuter`接口。一个Java类必须实现这个接口方法，`void
    onPromiseCreation(Value onResolve, Value onReject);`。实现这个接口的Java类可以被JavaScript用来创建一个`Promise`对象。JavaScript可以在实现void
    then `(Value onResolve`, `Value onReject);`的Java对象上调用`await`，以实现JavaScript和Java之间的异步编程。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the various polyglot interoperability and embedding
    features of GraalVM/Truffle for JavaScript and Node.js in detail. We explored
    all the key concepts with some real code examples, to gain a clear understanding
    of how JavaScript and Node.js can call, pass data, and interoperate with other
    language code. This is one of the salient features of GraalVM.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了GraalVM/Truffle为JavaScript和Node.js提供的各种多语言互操作和嵌入功能。我们通过一些实际的代码示例探讨了所有关键概念，以获得对JavaScript和Node.js如何调用、传递数据以及与其他语言代码互操作的清晰理解。这是GraalVM的一个显著特性。
- en: The examples given in this chapter will help you to build and run polyglot applications
    that are written using the Java and JavaScript languages on the same runtime.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章给出的示例将帮助您构建和运行使用Java和JavaScript语言在同一运行时编写的多语言应用。
- en: In the next chapter, we will continue to explore R, Python, and the latest Java
    on Truffle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索R、Python和最新的Java在Truffle上的应用。
- en: Questions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What JavaScript object and method is used to run other language code?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于运行其他语言代码的JavaScript对象和方法是什么？
- en: What is the `Context` object in Java?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java中的`Context`对象是什么？
- en: How do you control the access a guest language gets to the host?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何控制客户端语言对宿主机的访问？
- en: How do you build a native image of a polyglot application?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何构建多语言应用的原生镜像？
- en: What is a binding?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定是什么？
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: GraalVM Enterprise Edition ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM企业版([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
- en: JavaScript and Node.js reference ([https://www.graalvm.org/reference-manual/js/](https://www.graalvm.org/reference-manual/js/))
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和Node.js参考([https://www.graalvm.org/reference-manual/js/](https://www.graalvm.org/reference-manual/js/))
- en: '*Truffle: A Self-Optimizing Runtime System* ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Truffle：一个自优化的运行时系统* ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))'
- en: '*An Object Storage Model for the Truffle Language Implementation Framework*
    ([https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf](https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf))'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Truffle语言实现框架的对象存储模型* ([https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf](https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf))'
