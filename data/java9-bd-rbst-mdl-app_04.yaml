- en: Java 9 Language Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9语言增强
- en: In the previous chapter, we gained insight into some exciting new features contained
    in Java 9\. Our focus was on javac, the JDK libraries, and test suites. We learned
    about memory management improvements including memory allocation, heap optimizations,
    and enhanced garbage collection. We also covered changes to the compilation process,
    type testing, annotations, and runtime compiler tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Java 9中包含的一些令人兴奋的新特性。我们的重点是javac、JDK库和测试套件。我们学习了内存管理改进，包括内存分配、堆优化和增强的垃圾回收。我们还涵盖了编译过程、类型测试、注解和运行时编译器测试的更改。
- en: This chapter covers some changes in Java 9 that impact variable handlers, depreciation
    warnings, improvements on Project Coin changes implemented in Java 7, and import
    statement processing. These represent changes to the Java language itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Java 9中的一些变化，这些变化影响了变量处理器、弃用警告、在Java 7中实施的Project Coin更改的改进以及导入语句处理。这些代表了Java语言本身的变更。
- en: 'The topics we will cover here are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论的主题包括：
- en: Variable handlers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量处理器
- en: Import statement depreciation warnings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句弃用警告
- en: Project Coin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Coin
- en: Import statement processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句处理
- en: Working with variable handlers [JEP 193]
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与变量处理器协同工作 [JEP 193]
- en: 'Variable handlers are typed references to variables and are governed by the
    `java.lang.invoke.VarHandle` abstract class. The `VarHandle` method''s signature
    is polymorphic. This provides for great variability in both method signatures
    and return types. Here is a code sample demonstrating how a `VarHandle` might
    be used:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量处理器是对变量的类型引用，并由`java.lang.invoke.VarHandle`抽象类管理。`VarHandle`方法的签名是多态的。这为方法签名和返回类型提供了极大的可变性。以下是一个代码示例，展示了如何使用`VarHandle`：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The aim of this JEP was to standardize the way in which methods of the following
    classes are invoked:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JEP的目的是标准化以下类的方法调用方式：
- en: '`java.util.concurrent.atomic`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`'
- en: '`sun.misc.Unsafe`</li>'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`'
- en: 'Specifically, methods that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是以下方法：
- en: accessed/mutated object fields
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问/修改对象字段
- en: accessed/mutated elements of an array
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问/修改数组元素
- en: 'In addition, this JEP resulted in two fence operations for memory ordering
    and object reachability. In the spirit of due diligence, special attention was
    given to ensure the JVM''s safety. It was important to ensure that memory errors
    did not result from these changes. Data integrity, usability, and, of course,
    performance were key components of the aforementioned due diligence and are explained
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个JEP导致了两个用于内存排序和对象可达性的栅栏操作。本着尽职尽责的精神，特别关注确保JVM的安全性。重要的是要确保这些更改不会导致内存错误。数据完整性、可用性和当然，性能是上述尽职尽责的关键组成部分，以下将进行解释：
- en: '**Safety**: Corrupt memory states must not be possible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：必须不可能出现损坏的内存状态。'
- en: '**Data integrity**: Ensure access to an object''s field uses identical rules
    used by:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性**：确保访问对象字段使用与以下相同的规则：'
- en: '`getfield` byte code'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getfield`字节码'
- en: '`putfield` byte code'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putfield`字节码'
- en: '**Usability**: The benchmark for usability was the `sun.misc.Unsafe` API. The
    goal was to make the new API easier to use than the benchmark.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：可用性的基准是`sun.misc.Unsafe` API。目标是使新的API比基准更容易使用。'
- en: '**Performance**: There could be no degradation of performance compared to the
    use of the `sun.misc.Unsafe` API. The goal was to outperform that API.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：与使用`sun.misc.Unsafe` API相比，性能可能不会下降。目标是超越该API。'
- en: In Java, a fence operation is what javac does to force a constraint on memory
    in the form of a barrier instruction. These operations occur before and after
    the barrier instruction, essentially fencing them in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，栅栏操作是javac强制对内存施加约束的形式，这种约束以屏障指令的形式出现。这些操作发生在屏障指令之前和之后，实际上是将它们围起来。
- en: Working with the AtoMiC Toolkit
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AtoMiC工具包协同工作
- en: The `java.util.concurrent.atomic` package is a collection of 12 sub-classes
    that support operations on single variables that are thread-safe and lock-free.
    In this context, thread-safe refers to code that accesses or mutates a shared
    single variable without impeding on other threads executing on the variable at
    the same time. This superclass was introduced in Java 7.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`包是一组12个子类，支持对线程安全和无锁的单个变量的操作。在这种情况下，线程安全指的是访问或修改共享单个变量的代码，而不会妨碍同时在该变量上执行的其它线程。这个超类是在Java
    7中引入的。'
- en: 'Here is a list of the 12 sub-classes in the AtoMiC Toolkit. The class names,
    as you would expect, are self-descriptive:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 AtoMiC 工具包中的 12 个子类的列表。正如你所期望的，类名是自我描述的：
- en: '| **Atomic subclass** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **原子子类** |'
- en: '| `java.util.concurrent.atomic.AtomicBoolean` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicBoolean` |'
- en: '| `java.util.concurrent.atomic.AtomicInteger` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicInteger` |'
- en: '| `java.util.concurrent.atomic.AtomicIntegerArray` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicIntegerArray` |'
- en: '| `java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>` |'
- en: '| `java.util.concurrent.atomic.AtomicLong` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLong` |'
- en: '| `java.util.concurrent.atomic.AtomicLongArray` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLongArray` |'
- en: '| `java.util.concurrent.atomic.AtomicLongFieldUpdater<T>` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLongFieldUpdater<T>` |'
- en: '| `java.util.concurrent.atomic.AtomicMarkableReference<V>` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicMarkableReference<V>` |'
- en: '| `java.util.concurrent.atomic.AtomicReference<V>` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReference<V>` |'
- en: '| `java.util.concurrent.atomic.AtomicReferenceArray<E>` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReferenceArray<E>` |'
- en: '| `java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T,V>` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T,V>` |'
- en: '| `java.util.concurrent.atomic.AtomicStampedReference<V>` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicStampedReference<V>` |'
- en: Volatile variables, fields, and array elements can be asynchronously modified
    by concurrent threads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量、字段和数组元素可以被并发线程异步修改。
- en: In Java, the `volatile` keyword is used to inform the javac utility to read
    the value, field, or array element from the main memory and not to cache them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，`volatile` 关键字用于通知 javac 工具从主内存中读取值、字段或数组元素，而不是将其缓存。
- en: 'Here is a code snippet that demonstrates the use of the volatile keyword for
    an instance variable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，演示了如何使用 `volatile` 关键字来对一个实例变量进行操作：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the sun.misc.Unsafe class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sun.misc.Unsafe 类
- en: The `sun.misc.Unsafe` class, like other `sun` classes, is not officially documented
    or supported. It has been used to circumvent some of Java's built-in memory management
    safety features. While this can be viewed as a window to greater control and flexibility
    in our code, it is a terrible programming practice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe` 类，像其他 `sun` 类一样，没有官方文档或支持。它被用来绕过 Java 内置的某些内存管理安全特性。虽然这可以被视为对我们代码中更大控制和灵活性的窗口，但它是一种糟糕的编程实践。'
- en: 'The class had a single private constructor, so an instance of the class could
    not easily be instantiated. So, if we tried to instantiate an instance with `myUnsafe
    = new Unsafe()`, a `SecurityException` would be thrown in most circumstances.
    This somewhat unreachable class has over 100 methods that permitted operations
    on arrays, classes, and objects. Here is a brief sampling of those methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一个单独的私有构造函数，因此无法轻松实例化该类的实例。因此，如果我们尝试使用 `myUnsafe = new Unsafe()` 实例化一个实例，在大多数情况下会抛出
    `SecurityException`。这个相对难以触及的类有超过 100 个方法，允许对数组、类和对象进行操作。以下是这些方法的简要示例：
- en: '| **Arrays** | **Classes** | **Objects** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **数组** | **类** | **对象** |'
- en: '| `arrayBaseOffset` | `defineAnonymousClass` | `allocateInstance` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `arrayBaseOffset` | `defineAnonymousClass` | `allocateInstance` |'
- en: '| `arrayIndexScale` | `defineClass` | `objectFieldOffset` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `arrayIndexScale` | `defineClass` | `objectFieldOffset` |'
- en: '|  | `ensureClassInitialized` |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  | `ensureClassInitialized` |  |'
- en: '|  | `staticFieldOffset` |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  | `staticFieldOffset` |  |'
- en: 'Here is a secondary grouping of the `sun.misc.Unsafe` class method for information,
    memory, and synchronization:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `sun.misc.Unsafe` 类方法的次要分组，按信息、内存和同步进行分组：
- en: '| **Information** | **Memory** | **Synchronization** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | **内存** | **同步** |'
- en: '| `addressSize` | `allocateMemory` | `compareAndSwapInt` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `addressSize` | `allocateMemory` | `compareAndSwapInt` |'
- en: '| `pageSize` | `copyMemory` | `monitorEnter` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `pageSize` | `copyMemory` | `monitorEnter` |'
- en: '|  | `freeMemory` | `monitorExit` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  | `freeMemory` | `monitorExit` |'
- en: '|  | `getAddress` | `putOrderedEdit` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | `getAddress` | `putOrderedEdit` |'
- en: '|  | `getInt` | `tryMonitorEnter` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | `getInt` | `tryMonitorEnter` |'
- en: '|  | `putInt` |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | `putInt` |  |'
- en: The `sun.misc.Unsafe` class was earmarked for removal in Java 9\. There was
    actually some opposition to this decision in the programming industry. To put
    their concerns to rest, the class has been depreciated, but will not be completely
    removed. A special flag can be sent to the JVM to utilize the original API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe` 类在 Java 9 中被标记为移除。实际上，在编程行业中对此决定有一些反对意见。为了平息他们的担忧，该类已被弃用，但不会完全移除。可以向
    JVM 发送一个特殊标志来利用原始 API。'
- en: Eliding depreciation warnings on import statements [JEP 211]
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在导入语句中省略弃用警告 [JEP 211]
- en: This is one of the more simplistic JEPs for Java 9\. Quite often, when we compile
    our programs, we receive many warnings and errors. The compiler errors must be
    fixed as they are typically syntactical in nature. The warnings, on the other
    hand, should be reviewed and appropriately addressed. Some of the warning messages
    are ignored by developers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些更简单的 Java 9 JEP 之一。在编译我们的程序时，我们经常会收到许多警告和错误。编译器错误必须修复，因为它们通常是语法性的。另一方面，警告应该被审查并适当处理。一些警告消息被开发者忽略。
- en: 'This JEP provides slight relief in the number of warnings we receive. Specifically,
    depreciation warnings caused by import statements are no longer generated. Prior
    to Java 9, we could suppress deprecated warning messages with the following annotation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此 JEP 在我们收到的警告数量上提供了一些缓解。具体来说，由导入语句引起的过时警告不再生成。在 Java 9 之前，我们可以使用以下注解来抑制过时警告消息：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, with Java 9, the compiler will suppress depreciated warnings if one or
    more of the following cases is true:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 Java 9 的推出，编译器将在以下情况之一为真时抑制已过时的警告：
- en: If the `@Deprecated` annotation is used
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `@Deprecated` 注解
- en: If the `@SuppressWarnings` annotation is used
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `@SuppressWarnings` 注解
- en: If the use of the warning-generating code and the declaration are within the
    ancestor class
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成警告的代码和声明在祖先类中
- en: If the use of the warning-generating code is within an import statement
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成警告的代码在导入语句中使用
- en: The fourth condition listed was an addition in Java 9.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第四个条件是在 Java 9 中添加的。
- en: Milling Project Coin [JEP 213]
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Milling Project Coin [JEP 213]
- en: 'Project Coin was a feature set of minor changes introduced in Java 7\. These
    changes are listed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Project Coin 是在 Java 7 中引入的微小更改的功能集。以下列出了这些更改：
- en: Strings in `switch` statements
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句中的字符串'
- en: Binary integral literals
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制整数字面量
- en: Using underscores in numeric literals
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字字面量中使用下划线
- en: Implementing multi-catch
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多捕获
- en: Allowing for more precise re-throwing of exceptions
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更精确地重新抛出异常
- en: Generic instance creation improvements
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型实例创建改进
- en: Addition of the `try-with-resources` statement
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `try-with-resources` 语句
- en: Improvements to invoking `varargs` methods
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `varargs` 方法的改进
- en: 'Detailed information can be found in the following Oracle presentation: [http://www.oracle.com/us/technologies/java/project-coin-428201.pdf](http://www.oracle.com/us/technologies/java/project-coin-428201.pdf).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息可以在以下 Oracle 演示文稿中找到：[http://www.oracle.com/us/technologies/java/project-coin-428201.pdf](http://www.oracle.com/us/technologies/java/project-coin-428201.pdf)。
- en: JEP 213 focused on improvements to Project Coin's enhancements. There were five
    such enhancements, each detailed as follows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 213 专注于 Project Coin 的改进。共有五个这样的改进，如下详细说明。
- en: Using the @SafeVarargs annotation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `@SafeVarargs` 注解
- en: In Java 9, we can use the `@SafeVarargs` annotation with private instance methods.
    When we use this annotation, we are asserting that the method does not contain
    any harmful operations on the `varargs` passed as parameters to the method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，我们可以使用 `@SafeVarargs` 注解与私有实例方法。当我们使用此注解时，我们断言该方法不包含对作为方法参数传递的 `varargs`
    执行任何有害操作。
- en: 'The syntax for usage is:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法为：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use of the `@SafeVarargs` annotation is restricted to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SafeVarargs` 注解的使用限制为：'
- en: Static methods
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Final instance methods
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终实例方法
- en: Private instance methods
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有实例方法
- en: The try-with-resource statement
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`try-with-resource` 语句'
- en: 'The `try-with-resource` statement previously required a new variable to be
    declared for each resource in the statement when a final variable was used. Here
    is the syntax for the `try-with-resource` statement prior to Java 9 (in Java 7
    or 8):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，`try-with-resource` 语句在每次使用最终变量时，需要为语句中的每个资源声明一个新变量。以下是 Java 9（Java
    7 或 8）之前 `try-with-resource` 语句的语法：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is a code snippet using the preceding syntax:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用上述语法的代码片段：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, with Java 9, the `try-with-resource` statement can manage final variables
    without requiring a new variable declaration. So, we can now rewrite the earlier
    code, as shown here in Java 9:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 Java 9 的推出，`try-with-resource` 语句可以管理最终变量，而无需声明新变量。因此，我们现在可以像下面这样重写之前的代码，这是在
    Java 9 中的示例：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `xmlScanner` object reference is contained inside the `try-with-resource`
    statement block, which provides for automatic resource management. The resource
    will automatically be closed as soon as the `try-with-resource` statement block
    is exited.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`xmlScanner` 对象引用包含在 `try-with-resource` 语句块中，这提供了自动资源管理。资源将在退出 `try-with-resource`
    语句块后自动关闭。
- en: You can also use a `finally` block as part of the `try-with-resource` statement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`finally`块作为`try-with-resource`语句的一部分使用。
- en: Using the diamond operator
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用菱形运算符
- en: Introduced in Java 9, the diamond operator can be used with anonymous classes
    if the inferred data type is denotable. When a data type is inferred, it suggests
    that the Java Compiler can determine the data types in a method's invocation.
    This includes the declaration and any included arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中引入的菱形运算符，如果推断的数据类型是可表示的，可以与匿名类一起使用。当推断数据类型时，它表明Java编译器可以确定方法调用中的数据类型。这包括声明和任何包含的参数。
- en: The diamond operator is the less-than and greater-than symbol pair (`<>` ).
    It is not new to Java 9; rather, the specific use with anonymous classes is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 菱形运算符是小于和大于符号对（`<>`）。它对Java 9来说并不新鲜；相反，它与匿名类的特定使用才是。
- en: 'The diamond operator was introduced in Java 7 and made instantiating generic
    classes simpler. Here is a pre-Java 7 example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 菱形运算符是在Java 7中引入的，它使泛型类的实例化变得更加简单。以下是一个Java 7之前的示例：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in Java 7, we could rewrite it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Java 7中，我们可以这样重写它：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The problem was that this method could not be used for anonymous classes. Here
    is an example in Java 8 that works fine:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个方法不能用于匿名类。以下是一个Java 8中的示例，它运行良好：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the preceding code works fine, when we change it to use the diamond operator,
    as shown here, a compiler error will occur:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的代码运行良好，但当我们将其更改为使用菱形运算符，如这里所示时，将发生编译器错误：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The error results from using the diamond operator with anonymous inner classes.
    Java 9 to the rescue. While the preceding code results in a compile time error
    in Java 8, it works fine in Java 9.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是由于使用菱形运算符与匿名内部类引起的。Java 9拯救了这个问题。虽然前面的代码在Java 8中会导致编译时错误，但在Java 9中它运行良好。
- en: Discontinuing use of the underscore
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止使用下划线
- en: 'The underscore character ( `_` ) can no longer be used as a legal identifier
    name. Earlier attempts to remove the underscore in an identifier name were incomplete.
    The use of such would generate a combination of errors and warnings. With Java
    9, the warnings are now errors. Consider the following sample code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线字符（`_`）不能再用作合法的标识符名称。之前尝试从标识符名称中删除下划线的尝试是不完整的。这样的使用会产生错误和警告的组合。在Java 9中，这些警告现在是错误。考虑以下示例代码：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code, in Java 8, will result in compiler warnings for `int _ =
    319;` and `if ( _ > 300 )` statements. The warning is *as of release 9, '_' is
    a keyword, and may not be used as an identifier*. So, in Java 9, you will not
    be able to use the underscore by itself as a legal identifier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，前面的代码会导致`int _ = 319;`和`if (_ > 300)`语句的编译器警告。警告是：从版本9开始，`_`是一个关键字，不能用作标识符。因此，在Java
    9中，您将无法单独使用下划线作为合法的标识符。
- en: It is considered bad programming practice to use identifier names that are not
    self-descriptive. So, the use of the underscore character by itself as an identifier
    name should not be a problematic change.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是不良的编程实践使用非自我描述的标识符名称。因此，将下划线字符单独用作标识符名称不应是一个有问题的变化。
- en: Making use of private interface methods
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有接口方法
- en: Lambda expressions were a big part of the Java 8 release. As a follow-up to
    that improvement, private methods in interfaces are now feasible. Previously,
    we could not share data between non-abstract methods of an interface. With Java
    9, this data sharing is possible. Interface methods can now be private. Let's
    look at some sample code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是Java 8发布的一个重要部分。作为对该改进的后续，接口中的私有方法现在变得可行。之前，我们无法在接口的非抽象方法之间共享数据。在Java
    9中，这种数据共享成为可能。接口方法现在可以是私有的。让我们看看一些示例代码。
- en: 'This first code snippet is how we might code an interface in Java 8:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个代码片段是我们在Java 8中编写接口的方式：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in Java 9, we can rewrite this code. As you can see next, the redundant
    code has been moved into a single private method called `characterTravel`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java 9中，我们可以重写这段代码。正如您接下来可以看到的，冗余的代码已经被移动到一个名为`characterTravel`的单独私有方法中：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Processing import statements correctly [JEP 216]
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确处理导入语句 [JEP 216]
- en: JEP 216 was issued as a fix to javac in regards to how import statements are
    processed. Prior to Java 9, there were instances where the order of import statements
    would impact if the source code was accepted or not.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 216是为了修复javac在处理导入语句方面的缺陷而发布的。在Java 9之前，存在一些情况下导入语句的顺序会影响源代码是否被接受。
- en: When we develop applications in Java, we typically add import statements as
    we need them, resulting in an unordered list of import statements. IDEs do a great
    job of color-coding import statements that are not used, as well as informing
    us of import statements we need but that have not been included. It should not
    matter what order the import statements are in; there is no applicable hierarchy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Java 中开发应用程序时，我们通常会根据需要添加导入语句，从而产生一个无序的导入语句列表。IDEs 在对未使用的导入语句进行着色编码方面做得很好，同时也通知我们那些需要但尚未包含的导入语句。导入语句的顺序无关紧要；没有适用的层次结构。
- en: javac compiles classes in two primary steps. Specific to handling import statements,
    these steps are type resolution and member resolution. The type resolution consists
    of a review of the abstract syntax tree to identify declarations of classes and
    interfaces. The member resolution includes determining the class hierarchy and
    individual class variables and members.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: javac 以两个主要步骤编译类。针对处理导入语句，这些步骤是类型解析和成员解析。类型解析包括对抽象语法树的审查，以识别类和接口的声明。成员解析包括确定类层次结构和单个类变量和成员。
- en: 'With Java 9, the order we list import statements in our classes and files will
    no longer impact the compilation process. Let''s look at an example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，我们在类和文件中列出导入语句的顺序将不再影响编译过程。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding example, type resolution occurs and results in the following
    realizations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类型解析发生并导致以下认识：
- en: '`SamplePackage.OuterPackage` exists'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage` 存在'
- en: '`SamplePackage.OuterPackage.Nested` exists'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage.Nested` 存在'
- en: '`SamplePackage.Thing.Innner` exists'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Thing.Innner` 存在'
- en: 'The next step is member resolution, and this is where the problem existed prior
    to Java 9\. Here is an overview of the sequential steps javac would use to conduct
    the member resolution for our sample code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是成员解析，这正是 Java 9 之前存在的问题所在。以下是 javac 为我们的示例代码执行成员解析的顺序步骤概述：
- en: Resolution of `SamplePackage.OuterPackage` begins.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage` 的解析开始。'
- en: The `SamplePackage.OuterPackage.Nested` import is processed.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理 `SamplePackage.OuterPackage.Nested` 的导入。
- en: Resolution of the `SamplePackage.Outer.Nested` class begins.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Outer.Nested` 类的解析开始。'
- en: The inner interface is type checked, although, because it is not in scope at
    this point, inner cannot be resolved.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部接口进行了类型检查，尽管由于它目前不在作用域内，内部无法解析。
- en: Resolution of `SamplePackage.Thing` begins. This step includes importing all
    member types of `SamplePackage.Thing` into scope.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Thing` 的解析开始。这一步骤包括将 `SamplePackage.Thing` 的所有成员类型导入作用域。'
- en: So the error occurs, in our example, because `Inner` is out of scope when resolution
    is attempted. If steps 4 and 5 were swapped, it would not have been a problem.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，错误发生是因为在尝试解析时 `Inner` 超出了作用域。如果步骤 4 和 5 互换，就不会有问题。
- en: 'The solution to the problem, implemented in Java 9, was to break the member
    resolution steps into additional sub-steps. Here are those steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中实现的问题解决方案是将成员解析步骤分解为额外的子步骤。以下是这些步骤：
- en: Analyze the import statements.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析导入语句。
- en: Create the hierarchy (class and interfaces).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建层次结构（类和接口）。
- en: Analyze class headers and type parameters.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析类头和类型参数。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered changes in Java 9 with regards to variable handlers
    and how they relate to the Atomic Toolkit. We also covered depreciation warnings
    and why they are now suppressed under specific circumstances. Five enhancements
    to changes introduced with Java 7 as part of Project Coin were also reviewed.
    Finally, we explored the improvements to import statement processing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java 9 中关于变量处理器及其与 Atomic Toolkit 相关性的变化。我们还介绍了弃用警告及其为何在特定情况下被抑制的原因。还回顾了
    Java 7 作为 Project Coin 部分引入的五个变化增强。最后，我们探讨了导入语句处理的改进。
- en: In the next chapter, we will examine the structure of a Java module as specified
    by Project Jigsaw. We will take a deep dive into how Project Jigsaw is implemented
    as part of the Java platform. Code snippets from a sample e-commerce application
    are used throughout the chapter to demonstrate Java 9's modular system. Internal
    changes to the Java platform, in regards to the modular system, are also discussed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将检查由 Project Jigsaw 指定的 Java 模块结构。我们将深入探讨 Project Jigsaw 作为 Java 平台一部分的实现方式。本章中使用了来自一个示例电子商务应用程序的代码片段，以展示
    Java 9 的模块化系统。还讨论了 Java 平台在模块化系统方面的内部变化。
