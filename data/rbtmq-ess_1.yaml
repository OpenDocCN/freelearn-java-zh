- en: A Rabbit Springs to Life
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 一只兔子跃然纸上
- en: '**Messaging** or **message queuing** is a method of communication between applications
    or components. Thanks to message queues, these applications can remain completely
    separate as they process their individual tasks. Messages are typically small
    requests, replies, status updates, or even just information. A message queue provides
    a temporary place for these messages to stay, allowing applications to send and
    receive them as necessary.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递**或**消息队列**是应用程序或组件之间的一种通信方式。得益于消息队列，这些应用程序可以在处理各自任务时保持完全独立。消息通常是小型请求、回复、状态更新，甚至是仅仅信息。消息队列提供了一个临时的地方让这些消息停留，允许应用程序根据需要发送和接收它们。'
- en: RabbitMQ is an open source message broker that acts as the intermediary or middleman
    for independent applications, giving them a common platform to communicate. RabbitMQ
    mainly uses an Erlang-based implementation of the **Advanced Message Queuing Protocol **(**AMQP**),
    which supports advanced features such as clustering and the complex routing of
    messages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一个开源的消息代理，作为独立应用程序的中介或中间人，为它们提供了一个共同的平台来通信。RabbitMQ 主要使用基于 Erlang
    的 **高级消息队列协议**（**AMQP**）的实现，它支持诸如集群和消息的复杂路由等高级功能。
- en: This chapter includes information about how to get started with RabbitMQ, and
    why it would benefit an architecture. This book follows a fictitious taxi agency,
    **Complete Car** (**CC**), to demonstrate how they have implemented RabbitMQ into
    the architecture. This chapter shows how to install and configure RabbitMQ so
    that it's easy to get everything up and running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括有关如何开始使用 RabbitMQ 以及它为何会惠及架构的信息。本书通过一个虚构的出租车公司，**完整汽车**（**CC**），来展示他们如何将
    RabbitMQ 集成到架构中。本章展示了如何安装和配置 RabbitMQ，使其易于启动和运行。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Explaining message queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释消息队列
- en: Discovering AMQP and RabbitMQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 AMQP 和 RabbitMQ
- en: Using RabbitMQ in real life
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实生活中使用 RabbitMQ
- en: Exploring the benefits of message queuing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索消息队列的好处
- en: A RabbitMQ scenario
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ 场景
- en: Getting ready for RabbitMQ
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备使用 RabbitMQ
- en: Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [h ttps://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01)。
- en: Explaining message queues
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释消息队列
- en: 'Smoke signals, couriers, carrier pigeons, and semaphores: if this was a riddle,
    the word **messages **would immediately spring to mind. Humanity has always had
    the need to connect, finding new ways to defy challenges posed by the distance
    between the different groups of people needing to communicate. Humankind has come
    a long way with modern technologies, but essentially, the basics remain. Senders,
    recipients, and messages are at the core of all our communication infrastructures.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾信号、信使、信鸽和信号旗：如果这是一个谜语，那么“**信息**”这个词会立刻浮现在脑海中。人类始终有连接的需求，寻找新的方法来克服不同需要沟通的人群之间的距离带来的挑战。人类在现代技术的帮助下已经走了很长的路，但本质上，基础仍然如此。发送者、接收者和信息是所有通信基础设施的核心。
- en: Software applications have the same needs; systems need to communicate and send
    messages between each other. They sometimes need to be sure that the message that's
    been sent has reached its destination, and sometimes they need to receive an immediate
    response. In some cases, they may even need to receive more than one response.
    Based on these different needs, different styles of communication between systems
    have emerged.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用也有同样的需求；系统需要相互通信和发送信息。它们有时需要确保发送的信息已经到达目的地，有时它们需要立即收到回应。在某些情况下，它们甚至可能需要收到多个回应。基于这些不同的需求，系统之间出现了不同的通信风格。
- en: AMQP, RabbitMQ's default protocol, is explained in the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP，RabbitMQ 的默认协议，将在下一节中解释。
- en: Discovering AMQP and RabbitMQ
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现 AMQP 和 RabbitMQ
- en: Message queuing is a one-way communication style that provides asynchronous
    interaction between systems. As this chapter continues to describe how message
    queues work, the benefits will become clear. Some background on the request-response
    message exchange pattern will shed light on how RabbitMQ works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是一种单向通信风格，它为系统之间提供异步交互。随着本章继续描述消息队列的工作方式，其优势将变得明显。关于请求-响应消息交换模式的背景信息将阐明RabbitMQ的工作原理。
- en: The request-response message exchange pattern
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求-响应消息交换模式
- en: 'There are many types of message exchange patterns, but the request-response
    style is the most common. A system, acting as a client, interacts with another
    remote system, which is acting as a server. The client sends a request for data,
    and the server responds to the request, as shown in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多种消息交换模式，但请求-响应式是最常见的。一个系统作为客户端，与另一个远程系统交互，该系统作为服务器。客户端发送数据请求，服务器响应请求，如下面的图所示：
- en: '![](img/55761e1c-afc1-4fe2-8ffa-338ca2cfc21b.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55761e1c-afc1-4fe2-8ffa-338ca2cfc21b.png)'
- en: 'Fig 1.1: The request-response interaction between the client and the server'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：客户端与服务器之间的请求-响应交互
- en: 'The request-response style is used when the client must have an immediate response
    or wants the service to complete a task without delay, such as being placed on
    hold when calling a restaurant to reserve a table:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端必须立即得到响应或希望服务立即完成任务时，例如在打电话给餐厅预订桌子时，会使用请求-响应式：
- en: '![](img/71dd3f7d-9555-4fe8-a6fd-a21aca382a9d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71dd3f7d-9555-4fe8-a6fd-a21aca382a9d.png)'
- en: 'Fig 1.2: Request-response between a client and a restaurant'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：客户端与餐厅之间的请求-响应
- en: 'Whether it takes the form of a remote procedure call, a web service invocation,
    or consumption of a resource, the model is the same: one system sends a message
    to another and waits for the remote party to respond. Systems communicate with
    each other in a point-to-point manner, where events and processes occur simultaneously
    or have dependencies or events related to time; the interaction between the client
    and server is **synchronous**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论其形式是远程过程调用、Web服务调用还是资源消费，模型都是相同的：一个系统向另一个系统发送消息并等待远程方的响应。系统以点对点的方式相互通信，其中事件和进程同时发生或具有依赖性或与时间相关的事件；客户端与服务器之间的交互是**同步**的。
- en: One on hand, this request-response style gives developers a simple programming
    model as everything happens procedurally. On the other hand, the tight coupling
    between both parties has a deep impact on the architecture of the whole system
    as it is hard to evolve, hard to scale, and hard to ship in independent releases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，这种请求-响应式风格为开发者提供了一个简单的编程模型，因为所有事情都是按程序发生的。另一方面，双方之间的紧密耦合对整个系统的架构产生了深远的影响，因为它难以演进，难以扩展，也难以独立发布。
- en: Message queuing exchange pattern
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列交换模式
- en: Message queuing is a one-way style of interaction where one system asynchronously
    interacts with another system via messages, generally through a message broker. A
    requesting system in asynchronous communication mode does not wait for an answer
    or require return information; it continues processing no matter what. The most
    common example of such an interaction is an email. The point is, asynchronous
    communication does not involve waiting for a response in order to continue processing.
    In fact, there may be no response or it may take some time for a response to be
    sent. Whatever the case, the system does not rely on a response to continue the
    process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是一种单向交互风格，其中一个系统通过消息异步地与另一个系统交互，通常通过消息代理。在异步通信模式下，请求系统不需要等待答案或要求返回信息；无论发生什么情况，它都会继续处理。这种交互的最常见例子是电子邮件。关键是，异步通信不涉及等待响应以继续处理。事实上，可能没有响应，或者发送响应可能需要一些时间。无论哪种情况，系统都不会依赖于响应来继续进程。
- en: 'Messages flow in one direction, from the publisher to the broker and finally
    to the consumer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 消息单向流动，从发布者到代理，最后到消费者：
- en: '![](img/e10308b6-e487-4927-8405-bcfbf5587839.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e10308b6-e487-4927-8405-bcfbf5587839.png)'
- en: 'Fig 1.3: Basic components of a one-way interaction with message queuing'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：基于消息队列的单向交互的基本组件
- en: Systems and applications play both the role of message publishers (producers)
    and message consumers (subscribers). A publisher publishes a message to a broker
    that they rely on to deliver the data to the intended consumer. If a response
    is required, it will arrive at some point in time through the same mechanism,
    but reversed (the consumer and producer roles will be swapped).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系统和应用程序同时扮演消息发布者（生产者）和消息消费者（订阅者）的角色。发布者将消息发布给一个代理，他们依赖这个代理将数据传递给目标消费者。如果需要响应，它将通过相同的机制在某个时间点到达，但方向相反（消费者和生产者的角色将互换）。
- en: A loosely coupled architecture
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松散耦合架构
- en: One big advantage of the messaging queuing approach is that systems become loosely
    coupled with each other. They do not need to know the location of other nodes
    on the network; a mere name is enough to reach them. Systems can, therefore, be
    evolved in an independent manner with no impact on each other as the reliability
    of message delivery is entrusted to a broker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列方法的一个大优点是系统之间变得松散耦合。它们不需要知道网络上其他节点的位置；仅仅一个名字就足够了。因此，系统可以独立地发展，不会相互影响，因为消息传递的可靠性委托给了代理。
- en: 'The following diagram illustrates a loose coupling between the publisher and
    the consumer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了发布者和消费者之间的松散耦合：
- en: '![](img/09a9fe21-6b50-4db2-8496-81930a935750.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09a9fe21-6b50-4db2-8496-81930a935750.png)'
- en: 'Fig 1.4: Message queuing enabling a loosely coupled architecture'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：消息队列实现松散耦合架构
- en: If one system is down for any reason, the other part of the system can still
    operate, and messages that are supposed to be sent between them wait in the queue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统因任何原因关闭，系统的另一部分仍然可以运行，它们之间应该发送的消息将等待在队列中。
- en: 'The architecture represented via message queuing allows for the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息队列表示的架构允许以下功能：
- en: The publishers or consumers can be updated one by one, without them impacting
    each other.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者或消费者可以逐个更新，而不会相互影响。
- en: The performance of each side leaves the other side unaffected.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一方的性能都不会影响另一方。
- en: The publishers or consumers are allowed to fail without impacting each other.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者或消费者允许失败而不会相互影响。
- en: The number of instances of publishers and consumers to scale and to accommodate
    their workload in complete independence.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者和消费者实例的数量可以根据需要扩展，以独立地适应它们的工作负载。
- en: Technology mixing between consumer and publishers.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者和发布者之间的技术混合。
- en: The main downside of this approach is that programmers cannot rely on the mental
    model of procedural programming where events occur one after another. In messaging,
    things happen over time. Systems must be programmed to deal with this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是程序员不能依赖于程序性编程的心理模型，其中事件一个接一个地发生。在消息传递中，事情是随着时间的推移发生的。系统必须被编程来处理这种情况。
- en: If all this is a little blurry, use the example of a well-known protocol, **Simple
    Mail Transfer Protocol** (**SMTP**). In this protocol, emails are published (sent)
    to an SMTP server. This initial server then stores and forwards the email to the
    next SMTP server, and so on until the recipient email server is reached. At this
    point, the message is queued in an inbox, waiting to be picked up by the consumer
    (typically, via POP3 or IMAP). With SMTP, the publisher has no idea when the email
    will be delivered or whether it will eventually be delivered at all. In the case
    of a delivery failure, the publisher is notified of issues later down the line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切有点模糊不清，可以参考一个众所周知的协议，**简单邮件传输协议**（**SMTP**）。在这个协议中，电子邮件被发布（发送）到SMTP服务器。这个初始服务器随后存储并转发电子邮件到下一个SMTP服务器，依此类推，直到到达收件人的电子邮件服务器。此时，消息将在收件箱中排队，等待消费者取走（通常是通过POP3或IMAP）。在SMTP中，发布者不知道电子邮件何时会被投递，或者是否最终会被投递。在投递失败的情况下，发布者会在稍后得知问题。
- en: 'The only sure fact is that the broker has successfully accepted the message
    that was initially sent. This entire process can be seen in the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一确定的事实是，代理已经成功接收了最初发送的消息。整个过程可以在以下图表中看到：
- en: '![](img/3bd7cc21-3873-4dd2-9881-85803726d75f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bd7cc21-3873-4dd2-9881-85803726d75f.png)'
- en: 'Fig 1.5: The email infrastructure as an analogy for message queuing'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：将电子邮件基础设施作为消息队列的类比
- en: Furthermore, if a response is needed, it will arrive asynchronously using the
    same delivery mechanism but with the publisher and consumer roles reversed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要响应，它将使用相同的交付机制异步到达，但发布者和消费者的角色相反。
- en: With these fundamental notions established, it is the perfect time to delve
    into the messaging protocol that will be used in this book, which is AMQP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了这些基本概念之后，现在是深入探讨本书将使用的消息协议——AMQP的最佳时机。
- en: Meet AMQP
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解AMQP
- en: '**AMQP** is an open standard protocol that defines how a system can exchange
    messages. The protocol defines a set of rules that needs to be followed by the
    systems that are going to communicate with each other. In addition to defining
    the interaction that happens between a consumer/producer and a broker, it also
    defines the representation of the messages and commands being exchanged. AMQP
    is truly interoperable as it specifies the wire format for messages, leaving nothing
    open to interpretation by a particular vendor or hosting platform. Since it is
    open source, the AMQP community is prolific and has broker and client implementations
    in a wide range of languages.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**AMQP**是一个开放标准协议，它定义了系统如何交换消息。该协议定义了一套规则，这些规则需要由将要相互通信的系统遵循。除了定义消费者/生产者和代理之间的交互外，它还定义了交换的消息和命令的表示。AMQP真正实现了互操作性，因为它指定了消息的线格式，没有留给特定供应商或托管平台任何解释的空间。由于它是开源的，AMQP社区非常活跃，并在多种语言中实现了代理和客户端实现。'
- en: RabbitMQ is built upon the AMQP 0-9-1 specification, but plugins are available
    that support AMQP 1.0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ基于AMQP 0-9-1规范构建，但提供了支持AMQP 1.0的插件。
- en: The AMQP 0-9-1 specification can be downloaded at [http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf](http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf](http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf)下载AMQP
    0-9-1规范。
- en: 'The following is a list of the core concepts of AMQP, which will be explained
    in detail in upcoming chapters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了AMQP的核心概念，这些概念将在后续章节中详细解释：
- en: '**Broker or message broker**: A broker is a piece of software that receives
    messages from one application or service, and delivers them to another application,
    service, or broker.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理或消息代理**：代理是一段软件，它从应用程序或服务接收消息，并将它们传递给另一个应用程序、服务或代理。'
- en: '**Virtual host, vhost**: A vhost exists within the broker. It''s a way to separate
    applications that are using the same RabbitMQ instance, similar to a logical container
    inside a broker; for example, separating working environments into development
    on one vhost and staging on another, keeping them within the same broker instead
    of setting up multiple brokers. Users, exchanges, queues, and so on are isolated
    on one specific vhost. A user connected to a particular vhost cannot access any
    resources (queue, exchange, and so on) from another vhost. Users can have different
    access privileges to different vhosts.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟主机，vhost**：虚拟主机存在于代理中。它是将使用相同RabbitMQ实例的应用程序分离的一种方式，类似于代理内部的一个逻辑容器；例如，将工作环境分离到开发在一个vhost上和预发布在另一个vhost上，而不是设置多个代理。用户、交换、队列等都在一个特定的vhost上隔离。连接到特定vhost的用户无法访问另一个vhost上的任何资源（队列、交换等）。用户可以对不同的vhost有不同的访问权限。'
- en: '**Connection**: Physical network (TCP) connection between the application (publisher/consumer)
    and a broker. When the client disconnects or a system failure occurs, the connection
    is closed.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：应用程序（发布者/消费者）和代理之间的物理网络（TCP）连接。当客户端断开连接或发生系统故障时，连接将被关闭。'
- en: '**Channel**: A channel is a **virtual connection** inside a **connection***.* It
    reuses a connection, forgoing the need to reauthorize and open a new TCP stream.
    When messages are published or consumed, it is done over a channel. Many channels
    can be established within a single connection.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：通道是连接中的一个**虚拟连接**。它重用连接，无需重新授权和打开新的TCP流。当发布或消费消息时，是在通道上完成的。可以在单个连接中建立多个通道。'
- en: '**Exchange**: The exchange entity is in charge of applying routing rules for
    messages, making sure that messages are reaching their final destination. In other
    words, the exchange ensures that the received message ends up in the correct queues.
    Which queue the message ends up in depends on the rules defined by the exchange
    type. A queue needs to be bound to at least one exchange to be able to receive
    messages. Routing rules include direct (point-to-point), topic (publish-subscribe),
    fanout (multicast), and header exchanges.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换**：交换实体负责应用消息的路由规则，确保消息达到最终目的地。换句话说，交换确保接收到的消息最终进入正确的队列。消息最终进入哪个队列取决于交换类型定义的规则。一个队列至少需要绑定到一个交换，才能接收消息。路由规则包括直接（点对点）、主题（发布订阅）、广播（多播）和头部交换。'
- en: '**Queue**: A queue is a sequence of items; in this case, messages. The queue
    exists within the broker.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：队列是一系列项目；在这种情况下，是消息。队列存在于代理中。'
- en: '**Binding**: A binding is a virtual link between an exchange and a queue within
    the broker. It enables messages to flow from an exchange to a queue.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定**：绑定是代理中交换机和队列之间的虚拟链接。它使得消息可以从交换流向队列。'
- en: 'The following diagram illustrates an overview of some of the concepts in AMQP:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了AMQP中一些概念的整体概述：
- en: '![](img/eb85d456-ba34-460a-ba06-4a916b6296f3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb85d456-ba34-460a-ba06-4a916b6296f3.png)'
- en: 'Fig 1.6: Overview of some of the concepts defined by the AMQP specification'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/eb85d456-ba34-460a-ba06-4a916b6296f3.png)'
- en: The open source broker shown in detailin this book has been built from the ground
    up to support AMQP, but many other protocols are also supported by RabbitMQ, such
    as MQTT, HTTP, and STOMP.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本书详细展示的开源代理是从头开始构建以支持AMQP的，但RabbitMQ也支持许多其他协议，例如MQTT、HTTP和STOMP。
- en: Now, it's time to turn the focus to RabbitMQ.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将焦点转向RabbitMQ了。
- en: The RabbitMQ broker
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ代理
- en: RabbitMQ is an Erlang implementation of an AMQP broker. It implements Version
    0-9-1 of AMQP with custom extensions, as allowed by the protocol. Erlang has been
    chosen because of its intrinsic support for building highly reliable and distributed
    applications. Indeed, Erlang is used to run telecommunication switches in several
    large telecommunication systems, and a total system's availability of nine nines
    has been reported (that's only 32 milliseconds of downtime per year). Erlang is
    able to run on any operating system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ是AMQP代理的Erlang实现。它实现了AMQP的0-9-1版本，并添加了协议允许的自定义扩展。选择Erlang是因为它内在的支持构建高度可靠和分布式应用的能力。实际上，Erlang被用于运行几个大型电信系统中的电信交换机，并报告了整个系统的九个九的可用性（这意味着每年只有32毫秒的停机时间）。Erlang能够在任何操作系统上运行。
- en: For data persistence, RabbitMQ relies on Mnesia, the in-memory/file-persisted
    embedded database of Erlang. Mnesia stores information about users, exchanges,
    queues, bindings, and so on. The queue index stores message positions and information
    on whether a message has been delivered or not. Messages are stored either in
    the queue index or in the message store, a key-value store shared among all queues.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据持久性，RabbitMQ依赖于Erlang的内存/文件持久化嵌入式数据库Mnesia。Mnesia存储有关用户、交换、队列、绑定等信息。队列索引存储消息位置以及消息是否已投递的信息。消息存储在队列索引或消息存储中，这是一个在所有队列之间共享的键值存储。
- en: For clustering, it mainly relies on Erlang's ingrained clustering abilities.
    RabbitMQ can easily be extended with the addition of plugins. For example, a web-based
    administration console can be deployed on RabbitMQ thanks to this mechanism.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群，它主要依赖于Erlang固有的集群能力。RabbitMQ可以通过添加插件轻松扩展。例如，可以通过这种机制在RabbitMQ上部署基于Web的管理控制台。
- en: Plugins can be used to extend the core broker functionality. There are many
    plugins available for RabbitMQ, and it's also possible to develop plugins, if
    needed: [https://www.rabbitmq.com/plugins.html](https://www.rabbitmq.com/plugins.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用插件来扩展核心代理功能。RabbitMQ有许多可用的插件，如果需要，也可以开发插件：[https://www.rabbitmq.com/plugins.html](https://www.rabbitmq.com/plugins.html)。
- en: 'RabbitMQ can be set up on a single, standalone instance, or as a cluster on
    multiple servers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ可以设置在单个独立实例上，或者作为多个服务器上的集群：
- en: '![](img/af1f86a8-0764-4632-afdd-1b618669a3e2.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af1f86a8-0764-4632-afdd-1b618669a3e2.png)'
- en: 'Fig 1.7: Standalone instance, or as a cluster on multiple servers'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：独立实例，或作为多个服务器上的集群
- en: RabbitMQ brokers can be connected together using different techniques, such
    as federation and shovels, in order to form messaging topologies with smart message
    routing across brokers and the capacity to span multiple data centers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ代理可以使用不同的技术，如联邦和铲子，连接在一起，以形成跨代理的智能消息路由的消息拓扑，并具有跨越多个数据中心的容量。
- en: 'The following screenshot shows federation between RabbitMQ brokers located
    in different places around the world:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了位于世界各地不同位置的RabbitMQ代理之间的联邦：
- en: '![](img/d81c5d31-c38f-43fd-884c-797e97efe07e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d81c5d31-c38f-43fd-884c-797e97efe07e.png)'
- en: 'Fig 1.8: The RabbitMQ broker engaging in various topologies'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：参与各种拓扑的RabbitMQ代理
- en: '**RabbitMQ supports AMQP 1.0 through plugins.**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**RabbitMQ通过插件支持AMQP 1.0**。'
- en: AMQP 1.0 was published at the end of 2011 after the development and maintenance
    of AMQP was transferred to OASIS. AMQP has been drastically revised between 0-9-1
    and 1.0\. This was so drastic that some core concepts, such as the exchange, no
    longer exist. Thus, AMQP 1.0 is a different protocol than 0-9-1, but there is
    no truly compelling reason to adopt it. It is not more capable than 0-9-1, and
    some would also argue that it has lost some of the key aspects that made it attractive
    in the first place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP 1.0于2011年底发布，在AMQP的开发和维护转移到OASIS之后。AMQP在0-9-1和1.0之间经历了大幅修订。这次修订如此剧烈，以至于一些核心概念，如交换，不再存在。因此，AMQP
    1.0是一个与0-9-1不同的协议，但没有真正令人信服的理由去采用它。它并不比0-9-1更强大，有些人也会争论说，它失去了最初使其具有吸引力的关键方面。
- en: So, when or where is RabbitMQ used? The next section describes some common use
    cases for RabbitMQ.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RabbitMQ在何时何地被使用？下一节将描述一些常见的RabbitMQ使用案例。
- en: Using RabbitMQ in real life
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现实生活中使用RabbitMQ
- en: The most common use case for RabbitMQ is a single producer, single consumer
    queue. Think of it as a pipe where one application puts messages into one end
    of the pipe and another application reads the messages that come out the other
    end. Messages are delivered in first in, first out order. These messages may be
    commands or contain important data. This sounds easy, but where could this type
    of architecture be applied? It's time to understand when and why message queuing
    shines!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ最常见的使用案例是单生产者、单消费者队列。想象它就像一个管道，一个应用程序将消息放入管道的一端，另一个应用程序读取从另一端出来的消息。消息按照先入先出的顺序交付。这些消息可能是命令或包含重要数据。这听起来很简单，但这种类型的架构可以应用在哪里？现在是时候了解何时以及为什么消息队列会发光了！
- en: Message queues between microservices
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务之间的消息队列
- en: Message queues are often used in between microservices, but what does that mean?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列通常用于微服务之间，但这意味着什么？
- en: Microservice architectural style divides the application into small services,
    with the finished application being the sum of its microservices. The services
    are not strictly connected to each other. Instead, they use, for example, message
    queues to keep in touch. One service asynchronously pushes messages to a queue
    and those messages are delivered to the correct destination when the consumer
    is ready.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格将应用程序划分为小的服务，完成的应用程序是其微服务的总和。服务之间并不严格连接。相反，它们使用，例如，消息队列来保持联系。一个服务异步地将消息推送到队列，当消费者准备好时，这些消息被发送到正确的目的地。
- en: The microservice architecture is often compared and contrasted with the monolith
    architecture, where the entire system is bundled together into one piece of software.
    One application is not only responsible for a particular task; it actually performs
    every step needed to complete a particular function. Monoliths communicate within
    the system since all the parts are running in the same process. This system is
    highly coupled since every function is reliant on the others.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通常与单体架构进行比较和对比，在单体架构中，整个系统被捆绑在一起成为一块软件。一个应用程序不仅负责特定的任务；它实际上执行完成特定功能所需的每一步。单体在系统中进行通信，因为所有部分都在同一个进程中运行。这个系统高度耦合，因为每个功能都依赖于其他功能。
- en: 'In an example of a webshop built on a monolith architecture style, one system
    handles all of the functions, including inventory, payments, reviews, and ratings
    and so on, as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个基于单体架构风格构建的网店示例中，一个系统处理所有功能，包括库存、支付、评论和评分等，如下所示：
- en: '![](img/2b1c0208-cfbf-47aa-ae97-71be171caf27.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b1c0208-cfbf-47aa-ae97-71be171caf27.png)'
- en: 'Fig 1.9: A webshop built in a monolith architecture style'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：采用单体架构风格构建的网店
- en: 'A webshop built on the microservice architecture, on the other hand, means
    that each part of the system is an individual activity. One microservice handles
    reviews and ratings. Then, there''s another inventory, and then yet another for
    payments, and so on, as shown in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在微服务架构之上的在线商店，另一方面意味着系统的每个部分都是一个独立的活动。一个微服务处理评论和评分。然后是库存，然后是支付，等等，如下面的图所示：
- en: '![](img/f23a3835-2ccf-4bfe-836a-69137a57861f.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f23a3835-2ccf-4bfe-836a-69137a57861f.png)'
- en: 'Fig 1.10: A microservice architecture style where each part is focused on a
    single business capability'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：一种微服务架构风格，其中每个部分都专注于单一的业务能力
- en: Each pair of requests and responses communicates independently. This is known
    as stateless communication. While many microservices are involved, they are not
    directly dependent on each other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应的每一对都是独立通信的。这被称为无状态通信。虽然涉及许多微服务，但它们并不直接相互依赖。
- en: Another typical use case for RabbitMQ is as a task queue, which we'll cover
    in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 的另一个典型用例是作为任务队列，我们将在下一节中介绍。
- en: Event and tasks
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件和任务
- en: Events are notifications that tell applications when something has happened.
    One application can subscribe to events from another application and respond by
    creating and handling tasks for themselves. A typical use case is when RabbitMQ
    acts as a task queue that handles **slow** operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是通知，告诉应用程序何时发生了某事。一个应用程序可以订阅来自另一个应用程序的事件，并通过为自己创建和处理任务来响应。一个典型的用例是当 RabbitMQ
    作为处理 **慢** 操作的任务队列时。
- en: 'Let''s take a look at two examples of this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个这样的例子：
- en: Imagine a social media application such as Instagram. Every time someone publishes
    a new post, the network (followers) needs to be informed about the new post. This
    could be a very time-consuming operation. Millions of people could be trying to
    perform the same task at the same time. The application can, with the use of message
    queues, enqueue a task onto the queue for each post as it arrives. When the worker
    receives the request, it retrieves a list of followers for the sender, and updates
    each of them.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一个社交媒体应用程序，例如 Instagram。每次有人发布一条新帖子时，网络（关注者）都需要了解新的帖子。这可能是一个非常耗时的操作。数百万的人可能同时尝试执行相同的任务。应用程序可以使用消息队列，在每条帖子到达时将其任务排队。当工作者收到请求时，它会检索发送者的关注者列表，并更新他们。
- en: As another example, think of an email newsletter campaign tool that is sending
    out thousands of emails to thousands of users. With a possible scenario where
    many users trigger bulk messages at the same time. The email newsletter campaign
    tool needs to be able to handle this volume of messages. All these emails can
    be added to a push queue with instructions to the worker regarding what to send
    and to whom. Every single email is handled, one by one, until all the emails have
    been sent.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑一个发送数千封电子邮件给数千用户的电子邮件新闻通讯工具。在一个可能的场景中，许多用户同时触发大量消息。电子邮件新闻通讯工具需要能够处理这种消息量。所有这些电子邮件都可以添加到一个推送队列中，并给工作者提供发送给谁以及发送什么的指令。每封电子邮件都会逐个处理，直到所有电子邮件都发送完毕。
- en: 'The following diagram shows a task queue, where messages are first entering
    the queue, and then handled. New tasks are then added to another queue:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了任务队列，其中消息首先进入队列，然后被处理。然后，新任务被添加到另一个队列中：
- en: '![](img/768cecf3-08a9-46c0-a5b5-d41491b3b207.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/768cecf3-08a9-46c0-a5b5-d41491b3b207.png)'
- en: 'Fig 1.11: Event and task queue'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：事件和任务队列
- en: With that, we've looked at and reviewed two typical use cases. The benefits
    of RabbitMQ have been apparent in each. We'll make this even more evident by exploring
    the benefits of message queuing in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经查看并回顾了两个典型用例。在每一个用例中，RabbitMQ 的优势都显而易见。我们将在下一节中通过探索消息队列的优势使其更加明显。
- en: Exploring the benefits of message queuing
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索消息队列的优势
- en: 'Communication between various applications plays an important role in distributed
    systems. There are many examples of when a message queue can be used, so let''s
    highlight some features and benefits of message queuing in microservice architectures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，各种应用程序之间的通信起着重要作用。有许多可以使用消息队列的例子，所以让我们突出消息队列在微服务架构中的某些特性和优势：
- en: '**Development and maintenance made easier**: Dividing an application across
    multiple services allows separate responsibilities and gives developers the freedom
    to write code for a specific service in any chosen language. It will be easier
    to maintain written code and make changes to the system; when updating a single
    authentication scheme, only the authentication module must have code added for
    testing, without it disrupting any other functions.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和维护变得简单**：将应用程序分割成多个服务允许分离责任，并给开发者提供了在任意选择的任何语言中为特定服务编写代码的自由。这将更容易维护编写的代码并对系统进行更改；当更新单个认证方案时，只需为测试添加认证模块的代码，而不会干扰任何其他功能。'
- en: '**Fault isolation**: A fault can be isolated to a single module and will thereby
    not affect other services. For example, an application with a reporting service
    temporarily out of function will not affect the authenticate or payment services.
    As another example, making changes to the reporting service still allows customers
    to perform essential transactions, even when they aren''t able to view reports.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障隔离**：故障可以隔离到单个模块，因此不会影响其他服务。例如，一个报告服务暂时无法使用的应用程序不会影响认证或支付服务。作为另一个例子，对报告服务进行更改仍然允许客户执行基本交易，即使他们无法查看报告。'
- en: '**Enhanced levels of speed and productivity**:Different developers are able
    to work on different modules at the same time. In addition to speeding up the
    development cycle, the testing phase is also impacted by the use of microservices
    and message queues. This is because each service can be tested on its own to determine
    the readiness of the overall system.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高速度和生产力**：不同的开发者可以同时在不同的模块上工作。除了加快开发周期外，微服务和消息队列的使用也对测试阶段产生了影响。这是因为每个服务都可以单独测试，以确定整个系统的就绪状态。'
- en: '**Improved scalability**: Microservices also allow for effortless scale-out
    at will. It''s possible to add more consumers if the message queue is growing.
    Adding new components to just one service is easy to do without changing any other
    service.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可扩展性**：微服务还允许随意轻松地进行扩展。如果消息队列在增长，可以添加更多消费者。只需向一个服务添加新组件，而无需更改任何其他服务，这很容易做到。'
- en: '**Easy to understand**: Since each module in a microservice architecture represents
    a single functionality, getting to know the relevant details for a task is easy.
    For example, hiring a consultant for a single service does not require them to
    understand the entire system.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**：由于微服务架构中的每个模块都代表一个单一的功能，因此了解任务的相关细节很容易。例如，为单个服务聘请顾问不需要他们了解整个系统。'
- en: Now that is enough knowledge to be dangerous, so it is a good time to dive into
    the RabbitMQ scenario company that sets the scene for the rest of this book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经拥有了足够的知识去冒险，所以现在是深入到为本书其余部分设定场景的RabbitMQ场景公司的最佳时机。
- en: A RabbitMQ scenario
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个RabbitMQ场景
- en: CC is a new taxi agency with huge potential. Today, the company has just two
    taxi drivers and two developers, but they want to expand a lot in the upcoming
    year. CC has already built a website in Ruby and started out with a backend, also
    written in Ruby, that stores CC trips in a database. CC also has some scripts,
    written in Python, that generate route reports.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CC是一家具有巨大潜力的新出租车公司。今天，公司只有两名出租车司机和两名开发者，但他们希望在即将到来的这一年里大幅扩张。CC已经用Ruby构建了一个网站，并从后端开始，也是用Ruby编写的，用于在数据库中存储CC的行程。CC还有一些用Python编写的脚本，用于生成路线报告。
- en: 'So far, CC''s system runs as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，CC的系统运行如下：
- en: The company's website and blog runs on Ruby.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司的网站和博客运行在Ruby上。
- en: The Rich Internet Application that stores route data, such as the starting point
    and the endpoint of the trip, is written in Ruby.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储路线数据（如行程的起点和终点）的富互联网应用程序是用Ruby编写的。
- en: There's a back-office that sends route updates to drivers and is written in
    Ruby.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个后台办公室向司机发送路线更新，是用Ruby编写的。
- en: Multiple ad hoc Python scripts are used to extract and message data to generate
    route reports.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个临时的Python脚本提取和发送数据以生成路线报告。
- en: Taxi applications are written in Python.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出租车应用程序是用Python编写的。
- en: 'The old architecture is illustrated as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对旧架构的说明：
- en: '![](img/31b397de-241d-45ae-af51-4b191c803e71.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31b397de-241d-45ae-af51-4b191c803e71.png)'
- en: 'Fig 1.12: CC software landscape'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：CC软件架构
- en: Why is CC looking at adding RabbitMQ to an already busy environment? The main
    reason is because of a new feature CC wants to offer to their customers – they
    want to build a taxi application that handles reservations on the go. CC also
    wants to be able to scale painlessly. The plan is to build an app where users
    can book a car via a smartphone, receive booking confirmation, and view the car
    approaching the starting point of the trip.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么CC在已经繁忙的环境中考虑添加RabbitMQ？主要原因是CC希望向客户提供一项新功能——他们想构建一个处理即时预订的出租车应用程序。CC还希望能够轻松扩展。计划是构建一个应用程序，用户可以通过智能手机预订汽车，接收预订确认，并查看汽车接近行程的起点。
- en: Since CC already has some services in different languages, and since CC wants
    to be able to scale easily, they decided to use a ready-made message-oriented
    middleware such as RabbitMQ for asynchronous communication between the app, the
    client, and the backend.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CC已经在不同的语言中拥有一些服务，并且由于CC希望能够轻松扩展，他们决定使用现成的面向消息的中间件，如RabbitMQ，以实现应用程序、客户端和后端之间的异步通信。
- en: As CC's knowledge and usage of RabbitMQ increases, they will discover new opportunities
    to leverage it in the environment. For now, let's follow CC as it gets started
    with its very first step into working with RabbitMQ.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CC对RabbitMQ的知识和使用的增加，他们将在环境中发现新的机会来利用它。现在，让我们跟随CC，看看它在与RabbitMQ合作的第一步。
- en: Getting ready for RabbitMQ
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备安装RabbitMQ
- en: 'To get started, the following three installation and configuration steps need
    to be completed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，需要完成以下三个安装和配置步骤：
- en: Installing the RabbitMQ broker
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装RabbitMQ代理
- en: Installing the management plugin (Web UI)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装管理插件（Web UI）
- en: Configuring the vhost and user
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置vhost和用户
- en: Let's start by installing the broker!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装代理程序开始！
- en: Installing the broker
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装代理程序
- en: CC runs its production servers on Ubuntu Linux. One developer has macOS and
    Linux, while the other one is all Windows. This heterogeneity is not a concern
    for RabbitMQ, which can run natively on all these operating systems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CC在其生产服务器上运行Ubuntu Linux。一位开发者有macOS和Linux，而另一位则是全部Windows。这种异构性对RabbitMQ来说不是问题，因为它可以在所有这些操作系统上本地运行。
- en: 'RabbitMQ provides complete online installation guides for all the supported
    operating systems, and they can be found here: [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).
    This book contains instructions for Debian/Ubuntu, where RabbitMQ is installed
    from the `apt` repository. It also contains instructions for Docker further down
    in this chapter.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ为所有支持的操作系统提供完整的在线安装指南，可以在以下位置找到：[http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html)。本书包含Debian/Ubuntu的安装说明，其中RabbitMQ是从`apt`仓库安装的。它还包含本章后面的Docker安装说明。
- en: RabbitMQ installation on Ubuntu
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ubuntu上的RabbitMQ安装
- en: 'There are relatively few steps required to install RabbitMQ. They are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装RabbitMQ所需的步骤相对较少。它们如下：
- en: Update Ubuntu.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Ubuntu。
- en: Download and install the repository key.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装仓库密钥。
- en: Ensure the key is in the repository.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保密钥在仓库中。
- en: Install RabbitMQ from the package repository.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从软件仓库安装RabbitMQ。
- en: Ensure that Ubuntu is up to date before starting the download process. Make
    sure that the operating system is using the latest versions of all software since
    outdated dependencies create security vulnerabilities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下载过程之前，请确保Ubuntu是最新的。请确保操作系统正在使用所有软件的最新版本，因为过时的依赖项会创建安全漏洞。
- en: 'Run the `apt update` command to download the latest releases of the installed
    software:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`apt update`命令以下载已安装软件的最新版本：
- en: '[PRE0]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'RabbitMQ requires several software packages. Verify that `curl`, `apt-transport-https`,
    and `GnuPG` are on the system by running the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ需要几个软件包。通过运行以下命令来验证系统上是否有`curl`、`apt-transport-https`和`GnuPG`：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `-y` option accepts any licenses for these dependencies. Ubuntu installs
    all required sub-packages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y`选项接受这些依赖项的任何许可证。Ubuntu会安装所有必需的子包。'
- en: 'Discover the name of the operating system by running any of the following commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下任何命令来发现操作系统的名称：
- en: '`cat /etc/os-release`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat /etc/os-release`'
- en: '`lsb_release -a`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsb_release -a`'
- en: '`hostnamectl`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostnamectl`'
- en: 'The release name is non-technical. Previous names include `focal` and `bionic`.
    Ubuntu does not include RabbitMQ by default, so it must be added to the repository
    key before you proceed. Execute the following set of commands in a Terminal:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 版本名称是非技术性的。之前的名称包括`focal`和`bionic`。Ubuntu默认不包含RabbitMQ，因此在继续之前必须将其添加到仓库密钥中。在终端中执行以下命令集：
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These commands download the key and add it to the repository list before adding
    the appropriate operating system packages for the broker and Erlang.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在添加代理和 Erlang 的适当操作系统包之前，会下载密钥并将其添加到存储库列表中。
- en: RabbitMQ is written in Erlang, a functional language that has robust built-in
    support for creating distributed networks. The developers maintain a list of minimum
    versions ([https://www.rabbitmq.com/which-erlang.html](https://www.rabbitmq.com/which-erlang.html))
    of the language for the latest supported releases of the broker. At the time of
    writing, RabbitMQ 3.8 supports Erlang 21.3 through 23.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是用 Erlang 编写的，这是一种功能语言，它为创建分布式网络提供了强大的内置支持。开发者维护了一个列表，列出了语言的最小版本，这些版本适用于代理的最新支持版本。在撰写本文时，RabbitMQ
    3.8 支持 Erlang 21.3 到 23。
- en: RabbitMQ can now be installed correctly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，RabbitMQ 可以正确安装了。
- en: Though not absolutely required for using RabbitMQ, it is encouraged to discover
    this powerful language and platform. You can learn more about Erlang at [http://www.erlang.org/](http://www.erlang.org/).
    Alternatively, you can consider Elixir as an optional language for the Erlang
    **virtual machine** (**VM**). You can find out more about this at [http://elixir-lang.org](http://elixir-lang.org).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 RabbitMQ 并非绝对必要，但鼓励探索这种强大的语言和平台。您可以在 [http://www.erlang.org/](http://www.erlang.org/)
    上了解更多关于 Erlang 的信息。或者，您可以考虑将 Elixir 作为 Erlang **虚拟机**（**VM**）的可选语言。您可以在 [http://elixir-lang.org](http://elixir-lang.org)
    上了解更多信息。
- en: 'Run the following commands to install RabbitMQ:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 RabbitMQ：
- en: '[PRE3]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `librabbitmq-dev` library includes a client for interacting with the broker.
    However, the server may be the only requirement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`librabbitmq-dev` 库包括一个用于与代理交互的客户端。然而，服务器可能只是唯一的要求。'
- en: RabbitMQ installation on Docker
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RabbitMQ 在 Docker 上的安装
- en: 'Docker containers allow the separation and control of resources without risking
    corrupting the operating system. Instructions for installing Docker are available
    from the official website: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    With Docker installed, pull the RabbitMQ image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器允许分离和控制资源，而不会风险损坏操作系统。有关安装 Docker 的说明，请参阅官方网站：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。安装
    Docker 后，拉取 RabbitMQ 镜像：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the broker with reasonable defaults:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合理的默认值运行代理：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A Docker container needs to be created so that it's accessible from the `localhost`
    with the management console enabled. This will be discovered shortly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个 Docker 容器，以便可以从 `localhost` 访问它，并启用管理控制台。这将在稍后被发现。
- en: Starting RabbitMQ
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 RabbitMQ
- en: 'Installing the RabbitMQ server from the repository also installs a suite of
    command-line tools used to start the server for the first time. This is done by
    executing the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储库安装 RabbitMQ 服务器也会安装一套用于首次启动服务器的命令行工具。这是通过执行以下命令完成的：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The server starts in the foreground. To run the broker as a service, use the
    following commands:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在前台启动。要将代理作为服务运行，请使用以下命令：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `systemctl` command can also be used to manage services in Ubuntu. The output
    of the final command should show that the broker is running. Consult the RabbitMQ
    documentation ([https://www.rabbitmq.com/troubleshooting.html](https://www.rabbitmq.com/troubleshooting.html))
    if not.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl` 命令也可以用于管理 Ubuntu 中的服务。最终命令的输出应显示代理正在运行。如果未显示，请参阅 RabbitMQ 文档 ([https://www.rabbitmq.com/troubleshooting.html](https://www.rabbitmq.com/troubleshooting.html))。'
- en: Downloading the example code
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: Download all the example code files for this book. They can be purchased from [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed to you directly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下载本书的所有示例代码文件。它们可以从 [http://www.packtpub.com](http://www.packtpub.com) 购买。如果您在其他地方购买了此书，请访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，以便将文件直接通过电子邮件发送给您。
- en: Verifying that the RabbitMQ broker is running
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证 RabbitMQ 代理是否正在运行
- en: Now, verify that the RabbitMQ broker is actually working by using the `status
    service` command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用 `status service` 命令来验证 RabbitMQ 代理实际上是否正在运行。
- en: 'Write the following line in the Terminal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中写下以下行：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The default folders where the package has installed files are `/etc/rabbitmq`
    for configuration files, `/usr/lib/rabbitmq` for application files, and `/var/lib/rabbitmq`
    for data files (`mnesia`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 包安装文件的默认文件夹是 `/etc/rabbitmq` 用于配置文件，`/usr/lib/rabbitmq` 用于应用程序文件，`/var/lib/rabbitmq`
    用于数据文件 (`mnesia`)。
- en: 'Look at the running processes for RabbitMQ and find both the service wrapper
    and the Erlang VM (also known as BEAM) that''s running, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 查看RabbitMQ的运行进程，找到正在运行的服务包装器和Erlang VM（也称为BEAM），如下所示：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is possible that, when RabbitMQ runs, a process named `epmd` is also running.
    This is the Erlang port mapper daemon, which is in charge of coordinating Erlang
    nodes in a cluster. It is expected to start even if the clustered RabbitMQ application
    is not running.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能，当RabbitMQ运行时，一个名为`epmd`的进程也在运行。这是Erlang端口映射器守护进程，负责协调集群中的Erlang节点。即使集群中的RabbitMQ应用程序没有运行，它也会启动。
- en: Note that by default, the broker service is configured to auto-start when the
    Linux host starts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，代理服务配置为在Linux主机启动时自动启动。
- en: Skip the hassle of the installation and configuration of RabbitMQ and use a
    hosted RabbitMQ solution. CloudAMQP is the largest provider of hosted RabbitMQ
    clusters: [www.cloudamqp.com](https://www.cloudamqp.com/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过安装和配置RabbitMQ的麻烦，并使用托管RabbitMQ解决方案。CloudAMQP是托管RabbitMQ集群的最大提供商：[www.cloudamqp.com](https://www.cloudamqp.com/)。
- en: Installing the management plugin (Web UI)
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装管理插件（Web UI）
- en: RabbitMQ does not install a management console by default, but the optional
    web-based plugin used in this example makes it easy to peek into a running RabbitMQ
    instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ默认不安装管理控制台，但本例中使用的可选基于Web的插件使得查看正在运行的RabbitMQ实例变得容易。
- en: 'The Debian package installs several scripts. One of them is `rabbitmq-plugins`.
    Its purpose is to allow us to install and remove plugins. Use it to install the
    management plugin, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Debian软件包安装了几个脚本。其中之一是`rabbitmq-plugins`。它的目的是允许我们安装和删除插件。使用它来安装管理插件，如下所示：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Yes, it is that easy!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就这么简单！
- en: 'Use a web browser to reach the home page of the management console by navigating
    to `http://<hostname>:15672`, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web浏览器通过导航到`http://<hostname>:15672`来访问管理控制台的主页，如下面的截图所示：
- en: '![](img/280d4407-ed0a-4bf6-9167-f1215438efe7.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/280d4407-ed0a-4bf6-9167-f1215438efe7.png)'
- en: 'Fig 1.13: The login screen of the management console'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：管理控制台的登录屏幕
- en: Stay tuned for the next episode – creating and configuring users!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续关注下一集——创建和配置用户！
- en: Configuring users
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置用户
- en: 'One of the scripts that''s installed by the Debian package is `rabbitmqctl`,
    which is a tool for managing RabbitMQ nodes and used to configure all aspects
    of the broker. Use it to configure an administration user in the broker, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Debian软件包安装的脚本之一是`rabbitmqctl`，这是一个用于管理RabbitMQ节点并用于配置代理所有方面的工具。使用它来配置代理中的管理员用户，如下所示：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, RabbitMQ comes with a guest user that''s authenticated with the
    guest password. Change this password to something else, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RabbitMQ附带一个使用guest密码认证的guest用户。将其密码更改为其他密码，如下所示：
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Navigating back to the management console login screen allows us to log in with
    the username `cc-admin` and the password `taxi123`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回管理控制台登录屏幕，我们可以使用用户名`cc-admin`和密码`taxi123`登录。
- en: 'The welcome screen provides an overview of the broker''s internals, as shown
    in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎屏幕提供了对代理内部结构的概述，如下面的截图所示：
- en: '![](img/ee346036-1498-4c86-83e8-dbb9b3627f28.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee346036-1498-4c86-83e8-dbb9b3627f28.png)'
- en: 'Fig 1.14: The main dashboard of the management console'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：管理控制台的主仪表板
- en: Note that at this point, the `cc-admin` user is not able to examine any exchange
    or queue in any vhost. For now, another user must be created for development purposes
    so that applications can connect to RabbitMQ.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在此阶段，`cc-admin`用户无法在任何vhost中检查任何交换机或队列。目前，必须创建另一个用户用于开发目的，以便应用程序可以连接到RabbitMQ。
- en: 'Create the `cc-dev` user, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为`cc-dev`的用户，如下所示：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As discussed earlier in this chapter, RabbitMQ supports the notion of vhosts,
    which is where different users can have different access privileges. The CC development
    environment will have a vhost, also known as vhost. Anything that happens in the
    vhost happens in isolation from any other environment created in the future (such
    as a QA environment). It is possible to set per-vhost limits on a number of queues
    and concurrent client connections in later versions of RabbitMQ (3.7+).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，RabbitMQ支持vhosts的概念，这是不同用户可以有不同的访问权限的地方。CC开发环境将有一个vhost，也称为vhost。在未来的任何其他环境中（如QA环境）创建的任何内容都将与vhost中的内容隔离。在RabbitMQ的后续版本（3.7+）中，可以对每个vhost的队列数量和并发客户端连接数设置限制。
- en: 'Create a vhost called `cc-dev-vhost`, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`cc-dev-vhost`的vhost，如下所示：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a user and a vhost for development.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个用户和一个用于开发的虚拟主机。
- en: Configuring dedicated vhosts
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置专用虚拟主机
- en: RabbitMQ comes with a default vhost called `/` that the guest user has full
    permissions for. Though this is convenient for quick tests, it is recommended
    that a dedicated vhost is created to keep concerns separated so that it is possible
    to completely drop a vhost and restart from scratch without unexpected impacts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ自带一个默认的虚拟主机`/`，访客用户对其拥有完全权限。虽然这对于快速测试来说很方便，但建议创建一个专门的虚拟主机来保持关注点的分离，这样就可以完全删除虚拟主机并从头开始，而不会产生意外的后果。
- en: 'As it stands, neither the `cc-admin` nor `cc-dev` users have permission to
    do anything on `cc-dev-vhost`. You can fix this by giving the vhost full rights,
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`cc-admin`和`cc-dev`用户都没有在`cc-dev-vhost`上执行任何操作的权限。你可以通过授予虚拟主机完全权限来修复这个问题，如下所示：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To recap what was just done, most of the command is straightforward but the
    `".*" ".*" ".*"` part looks a tad mysterious, so let's analyze it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾刚才所做的工作，大部分命令都很直接，但`".*" ".*" ".*"`部分看起来有点神秘，所以让我们来分析一下。
- en: It is a triplet of permissions for the considered vhost, which grants **configure**,
    **write**, and **read** permissions on the designated resources for the considered
    user and vhost. Resources, which consist of exchanges and queues, are designated
    by regular expressions that match their names. In this case, any resource that's
    requested via the `.*` regular expression is allowed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对考虑的虚拟主机的三个权限组合，它为考虑的用户和虚拟主机在指定的资源上授予了**配置**、**写入**和**读取**权限。资源包括交换和队列，由匹配其名称的正则表达式指定。在这种情况下，通过`.*`正则表达式请求的任何资源都是允许的。
- en: The actual commands that are granted depend on the resource type and the granted
    permissions. For a complete list of the access control policies supported by RabbitMQ,
    see [http://www.rabbitmq.com/access-control.html](http://www.rabbitmq.com/access-control.html).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 授予的实际命令取决于资源类型和授予的权限。有关RabbitMQ支持的完整访问控制策略列表，请参阅[http://www.rabbitmq.com/access-control.html](http://www.rabbitmq.com/access-control.html)。
- en: 'As an alternative to all command lines, turn to the user management features
    of the management console. Click on the Admin tab of the console and then on the
    `cc-dev` user listed in the Users tab to view information similar to what''s shown
    in the following screenshot. The entire user configuration that was set from the
    command line is visible and can be edited in the management console:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为所有命令行的替代方案，转向管理控制台的用户管理功能。点击控制台的“管理员”标签，然后在“用户”标签中点击“cc-dev”用户，查看以下截图所示的信息。从命令行设置的整个用户配置在管理控制台中可见，并可进行编辑：
- en: '![](img/d898f837-ce12-420c-9644-f4af2a4d27e7.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d898f837-ce12-420c-9644-f4af2a4d27e7.png)'
- en: 'Fig 1.15: User management from the RabbitMQ management console'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：从RabbitMQ管理控制台进行用户管理
- en: 'The details of an individual user can be found by clicking on a given user''s
    name in the management console:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在管理控制台中点击特定用户的名称，可以找到单个用户的详细信息：
- en: '![](img/75629c10-48d3-4fc3-b069-7cabe27614fa.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75629c10-48d3-4fc3-b069-7cabe27614fa.png)'
- en: 'Fig 1.16: Details of an individual user in the management console'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：管理控制台中单个用户的详细信息
- en: The RabbitMQ broker and the management plugin (Web UI) have been installed and
    the vhost and the users have been configured.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ代理和管理插件（Web UI）已安装，并已配置虚拟主机和用户。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the architectural and design promises of messaging, including
    how AMQP and RabbitMQ deliver on these promises. In addition, the reason why the
    taxi agency Complete Car decided to introduce RabbitMQ in its software landscape
    was discovered. Finally, a RabbitMQ broker was installed and a user and various
    vhosts were configured for it. Armed with a basic understanding of message queues
    and RabbitMQ, the next chapter builds on these concepts and explores the architecture
    behind the Complete Car taxi application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了消息传递的架构和设计承诺，包括AMQP和RabbitMQ如何实现这些承诺。此外，还发现了出租车代理机构Complete Car决定在其软件环境中引入RabbitMQ的原因。最后，安装了一个RabbitMQ代理，并为它配置了用户和多个虚拟主机。在掌握了消息队列和RabbitMQ的基本理解之后，下一章将在此基础上构建，并探讨Complete
    Car出租车应用程序背后的架构。
- en: It's time to hit the ground running and write some code. Turn to the next chapter
    to start building a RabbitMQ-powered application!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手编写代码了。转向下一章，开始构建一个由RabbitMQ驱动的应用程序！
