- en: '*Chapter 3*: Java Fundamentals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：Java 基础知识'
- en: This chapter presents to you a more detailed view of Java as a language. It
    starts with code organization in packages and a description of accessibility levels
    of classes (interfaces) and their methods and properties (fields). Reference types,
    as the main types of a Java object-oriented nature, are also presented in detail,
    followed by a list of reserved and restricted keywords and a discussion of their
    usage. The chapter ends with the methods of conversion between different primitive
    types and from a primitive type to a corresponding reference type and back.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了 Java 作为语言的更详细视图。它从包中的代码组织以及类（接口）及其方法、属性（字段）的可访问性级别描述开始。作为 Java 面向对象性质的主要类型，引用类型也进行了详细说明，随后列出了保留和受限关键字及其用法讨论。本章最后介绍了不同原始类型之间的转换方法，以及从原始类型到相应引用类型及其反向转换的方法。
- en: These are the fundamental terms and features of the Java language. The importance
    of understanding them cannot be overstated. Without them, you cannot write any
    Java program. So, try not to rush through this chapter and make sure you understand
    everything presented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Java 语言的基本术语和功能。理解它们的重要性不容忽视。没有它们，您无法编写任何 Java 程序。因此，请尽量不要急于翻阅本章，并确保您理解了所展示的所有内容。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Packages, importing, and access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包、导入和访问
- en: Java reference types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 引用类型
- en: Reserved and restricted keywords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留和受限关键字
- en: Usage of the `this` and `super` keywords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this` 和 `super` 关键字的用法'
- en: Converting between primitive types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始类型之间进行转换
- en: Converting between primitive and reference types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始类型和引用类型之间进行转换
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章提供的代码示例，您需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台装有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: An IDE or a code editor you prefer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您偏好的 IDE 或代码编辑器
- en: The instructions for how to set up a Java SE and an IntelliJ IDEA editor were
    provided in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Java 17*, of this book. The files with the code examples for this chapter
    are available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch03_fundamentals` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)“Java 17 入门”中提供了如何设置 Java SE
    和 IntelliJ IDEA 编辑器的说明。本章的代码示例文件可在 GitHub 仓库的 `examples/src/main/java/com/packt/learnjava/ch03_fundamentals`
    文件夹中找到，网址为 [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)。
- en: Packages, importing, and access
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包、导入和访问
- en: As you already know, a package name reflects a directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the top-level class declared in it (this
    class can contain other classes). The first line of the `.java` file is the package
    statement that starts with the `package` keyword, followed by the actual package
    name – the directory path to this file in which slashes are replaced with dots.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，包名反映了目录结构，从包含 `.java` 文件的项目目录开始。每个 `.java` 文件的名字必须与其中声明的顶层类名相同（此类可以包含其他类）。`.java`
    文件的第一行是包声明，以 `package` 关键字开始，后跟实际的包名——该文件在目录路径中的斜杠被点号替换。
- en: A package name and the class name together compose a **fully qualified class
    name**. It uniquely identifies the class but tends to be too long and inconvenient
    to use. This is when **importing** comes to the rescue by allowing specification
    of the fully qualified name only once, and then referring to the class only by
    the class name.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包名和类名一起组成**完全限定类名**。它唯一地标识了该类，但通常太长且不便使用。这时，**导入**就派上用场，允许只指定一次完全限定名，然后只通过类名来引用该类。
- en: Invoking a method of a class from the method of another class is possible only
    if a caller has access to that class and its methods. The `public`, `protected`,
    and `private` access modifiers define the level of accessibility and allow (or
    disallow) some methods, properties, or even the class itself to be visible to
    other classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个类的类方法中调用一个类的方法只有在调用者可以访问该类及其方法时才可能。`public`、`protected`和`private`访问修饰符定义了可访问性级别，并允许（或不允许）某些方法、属性，甚至类本身对其他类可见。
- en: All these aspects will be discussed in detail in the current section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当前节将详细讨论所有这些方面。
- en: Packages
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: 'Let’s look at the class we called `Packages`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们称之为`Packages`的类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line in the `Packages` class is a package declaration that identifies
    the class location on the source tree or, in other words, the `.java` file location
    in a filesystem. When the class is compiled and its `.class` file with bytecode
    is generated, the package name also reflects the `.class` file location in the
    filesystem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Packages`类的第一行是一个包声明，它标识了类在源树中的位置，换句话说，在文件系统中的`.java`文件位置。当类被编译并生成包含字节码的`.class`文件时，包名也反映了文件系统中的`.class`文件位置。'
- en: Importing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: 'After the package declaration, the `import` statements follow. As you can see
    from the previous example, they allow you to avoid using the fully qualified class
    (or interface) name anywhere else in the current class (or interface). When many
    classes (or interfaces) from the same package are imported, it is possible to
    import all classes and interfaces from the same package as a group, using the
    `*` symbol. In our example, it would look as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在包声明之后，跟随的是`import`语句。正如你从前面的例子中看到的，它们允许你在当前类（或接口）的任何地方避免使用完全限定的类（或接口）名称。当从同一个包中导入许多类（或接口）时，可以使用`*`符号将同一包中的所有类和接口作为一组导入。在我们的例子中，它看起来如下所示：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But that is not a recommended practice as it hides away the imported class
    (or interface) location when several packages are imported as a group. For example,
    look at this code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是一个推荐的做法，因为它在作为一组导入多个包时隐藏了导入的类（或接口）的位置。例如，看看这个代码片段：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, can you guess the package to which class `C` or class
    `D` belongs? Also, it is possible that two classes in different packages have
    the same name. If that is the case, group importing can create a degree of confusion
    or even a problem that’s difficult to nail down.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你能猜出类`C`或类`D`属于哪个包吗？还有可能两个不同包中的类有相同的名称。如果是这样，分组导入可能会造成一定程度的混淆，甚至可能是一个难以确定的问题。
- en: 'It is also possible to import an individual static class (or interface) members.
    For example, if `SomeInterface` has a `NAME` property (as a reminder, interface
    properties are public and static by default), you can typically refer to it as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以导入单个静态类（或接口）成员。例如，如果`SomeInterface`有一个`NAME`属性（作为一个提醒，接口属性默认是公共和静态的），你通常可以这样引用它：
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To avoid using even the interface name, you can use a static import:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用甚至接口名称，你可以使用静态导入：
- en: '[PRE26]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, if `SomeClass` has a public static property, `someProperty`, and
    a public static method, `someMethod()`, it is possible to import them statically
    too:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果`SomeClass`有一个公共静态属性`someProperty`和一个公共静态方法`someMethod()`，你也可以将它们静态导入：
- en: '[PRE33]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: But this technique should be used wisely, since it may create the impression
    that a statically imported method or property belongs to the current class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种技术应该明智地使用，因为它可能会给人留下这样的印象：静态导入的方法或属性属于当前类。
- en: Access modifiers
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: We have already used in our examples the three access modifiers –`public`, `protected`,
    and `private` – which regulate access to the classes, interfaces, and their members
    from outside – from other classes or interfaces. There is also a fourth implicit
    one (also called the **default modifier package-private**) that is applied when
    none of the three explicit access modifiers is specified.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的例子中使用了三种访问修饰符——`public`、`protected`和`private`——它们从外部（来自其它类或接口）调节对类、接口及其成员的访问。还有一个第四个隐含的（也称为**默认修饰符包私有**）修饰符，当没有指定这三个显式访问修饰符时应用。
- en: 'The effect of their usage is pretty straightforward:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的使用效果相当直接：
- en: '`public`: Accessible to other classes and interfaces of the current and other
    packages'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：可被当前和其它包中的其它类和接口访问'
- en: '`protected`: Accessible only to other members of the same package and children
    of the class'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：只能被同一包中的其它成员和类的子类访问'
- en: 'no access modifier: Accessible only to other members of the same package'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有访问修饰符：仅对同一包的其他成员可访问
- en: '`private`: Accessible only to members of the same class'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：仅对同一类的成员可访问'
- en: From inside the class or an interface, all the class or interface members are
    always accessible. Besides, as we have stated several times already, all interface
    members are public by default, unless declared as `private`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从类或接口内部，所有类或接口成员总是可访问的。此外，正如我们已多次声明，所有接口成员默认是公共的，除非声明为`private`。
- en: Also, please note that class accessibility supersedes the class members’ accessibility
    because, if the class itself is not accessible from somewhere, no change in the
    accessibility of its methods or properties can make them accessible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，类的可访问性高于类成员的可访问性，因为如果类本身在某处不可访问，其方法或属性的访问性变化也无法使其变得可访问。
- en: When people talk about access modifiers for classes and interfaces, they mean
    the classes and interfaces that are declared inside other classes or interfaces.
    The encompassing class or interface is called a top-level class or interface,
    while those inside them are called inner classes or interfaces. The static inner
    classes are also called static nested classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们谈论类和接口的访问修饰符时，他们指的是在其它类或接口内部声明的类和接口。包含它们的类或接口被称为顶层类或接口，而它们内部的是内部类或接口。静态内部类也被称为静态嵌套类。
- en: It does not make sense to declare a top-level class or interface `private` because
    it will not be accessible from anywhere. And the Java authors decided against
    allowing the top-level class or interface to be declared `protected` too. It is
    possible, though, to have a class without an explicit access modifier, thus making
    it accessible only to members of the same package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 声明顶层类或接口为`private`是没有意义的，因为它将无法从任何地方访问。而且，Java的作者决定不允许顶层类或接口被声明为`protected`。尽管如此，可以有一个没有显式访问修饰符的类，这样它就只能被同一包的成员访问。
- en: 'Here is an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE50]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Please note that static nested classes do not have access to other members of
    the top-level class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，静态嵌套类无法访问顶层类的其他成员。
- en: 'Another particular feature of an inner class is that it has access to all,
    even private members, of the top-level class, and vice versa. To demonstrate this
    feature, let’s create the following private properties and methods in the top-level
    class and in a `private` inner class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类的另一个特别之处在于，它可以访问顶层类的所有成员，包括私有成员，反之亦然。为了演示这一特性，让我们在顶层类和一个`private`内部类中创建以下私有属性和方法：
- en: '[PRE68]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As you can see, all the methods and properties in the previous classes are private,
    which means that normally, they are not accessible from outside the class. And
    that is true for the `AccessModifiers` class – its private methods and properties
    are not accessible for other classes that are declared outside of it. But the
    `InnerClass` class can access the private members of the top-level class, while
    the top-level class can access the private members of its inner classes. The only
    limitation is that a non-static inner class cannot have static members. By contrast,
    a static nested class can have both static and non-static members, which makes
    a static nested class much more usable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前述类中的所有方法和属性都是私有的，这意味着通常它们不能从类外部访问。这对于`AccessModifiers`类也是如此——它的私有方法和属性对声明在其外部的其他类不可访问。但是`InnerClass`类可以访问顶层类的私有成员，而顶层类可以访问其内部类的私有成员。唯一的限制是非静态内部类不能有静态成员。相比之下，静态嵌套类可以既有静态成员也有非静态成员，这使得静态嵌套类更加实用。
- en: 'To demonstrate all the possibilities described, we will add the following `main()`
    method to the `AccessModifiers` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示所有描述的可能性，我们将在`AccessModifiers`类中添加以下`main()`方法：
- en: '[PRE94]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Naturally, a non-static inner class cannot be accessed from a static context
    of the top-level class, hence the `compiler error` comment in the preceding code.
    If we run it, the result will be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，非静态内部类不能从顶层类的静态上下文中访问，因此前述代码中的`编译器错误`注释。如果我们运行它，结果将如下所示：
- en: '![](img/B18388_Figure_3.1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_3.1.jpg)'
- en: The first two lines of the output come from `topLevelPrivateMethod()`, and the
    rest from the `main()` method. As you can see, an inner- and a top-level class
    can access each other’s private state, inaccessible from outside.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前两行来自`topLevelPrivateMethod()`，其余来自`main()`方法。正如你所见，内部类和顶层类可以相互访问对方的私有状态，这些状态从外部是无法访问的。
- en: Java reference types
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java引用类型
- en: A `new` operator creates an object of a class and returns the reference to the
    memory where the object resides. From a practical standpoint, the variable that
    holds this reference is treated in the code as if it is the object itself. Such
    a variable can be a class, an interface, an array, or a `null` literal that indicates
    that no memory reference is assigned to the variable. If the type of reference
    is an interface, it can be assigned either `null` or a reference to the object
    of the class that implements this interface because the interface itself cannot
    be instantiated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符创建一个类的对象，并返回对象所在内存位置的引用。从实际的角度来看，持有这个引用的变量在代码中被当作对象本身来处理。这样的变量可以是类、接口、数组或表示没有分配内存引用的`null`字面量。如果引用的类型是接口，它可以被赋值为`null`或实现此接口的类的对象引用，因为接口本身不能被实例化。'
- en: A JVM watches for all the created objects and checks whether there are references
    to each of them in the currently executed code. If there is an object without
    any reference to it, JVM removes it from the memory in a process called **garbage
    collection**. We will describe this process in [*Chapter 9*](B18388_09_ePub.xhtml#_idTextAnchor205),
    *JVM Structure and Garbage Collection*. For example, an object was created during
    a method execution and was referred to by the local variable. This reference will
    disappear as soon as the method finishes its execution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JVM会监视所有创建的对象，并检查当前执行代码中是否有对每个对象的引用。如果一个对象没有任何引用，JVM会在一个称为**垃圾回收**的过程中将其从内存中移除。我们将在[*第9章*](B18388_09_ePub.xhtml#_idTextAnchor205)，*JVM结构和垃圾回收*中描述这个过程。例如，一个对象在方法执行期间被创建，并被局部变量引用。这个引用将在方法执行完毕后消失。
- en: You have seen the examples of custom classes and interfaces, and we have talked
    about the `String` class already (see [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*). In this section, we will also describe two other
    Java reference types – array and enum – and demonstrate how to use them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了自定义类和接口的示例，我们之前也已经讨论了`String`类（见[*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java
    17入门*）。在本节中，我们还将描述两种其他的Java引用类型——数组和枚举——并演示如何使用它们。
- en: Class and interface
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和接口
- en: 'A variable of a class type is declared using the corresponding class name:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的类名声明一个类类型的变量：
- en: '[PRE103]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The value that can be assigned to such a variable can be one of the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以赋值给此类变量的值可以是以下之一：
- en: A `null` literal reference type (which means the variable can be used but does
    not refer to any object)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`字面量引用类型（这意味着变量可以被使用，但不指向任何对象）'
- en: A reference to an object of the same class or any of its descendants (because
    a descendant inherits the types of all of its ancestors)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对同一类或其任何子类的对象的引用（因为子类继承了所有祖先的类型）
- en: 'This last type of assignment is called a `java.lang.Object`, the following
    assignment can be done for any class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后的赋值类型称为`java.lang.Object`，以下赋值可以对任何类进行：
- en: '[PRE104]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Such an assignment is also called an **upcasting** because it moves the type
    of the variable up on the line of inheritance (which, like any family tree, is
    usually presented with the oldest ancestor at the top).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种赋值也称为**向上转型**，因为它将变量的类型向上移动到继承线上（这就像任何家谱一样，通常将最古老的祖先放在顶部）。
- en: 'After such an upcasting, it is possible to make a narrowing assignment using
    a `(type)` cast operator:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的向上转型之后，可以使用`(type)`类型转换运算符进行缩窄赋值：
- en: '[PRE105]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Such an assignment is also called `instanceof` operator (see [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*) to check the reference type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种赋值也称为`instanceof`运算符（见[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*）来检查引用类型。
- en: 'Similarly, if a class implements a certain interface, its object reference
    can be assigned to this interface or any ancestor of the interface:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个类实现了某个接口，其对象引用可以被赋值给这个接口或接口的任何祖先：
- en: '[PRE106]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As you can see, as in the case with class reference upcasting and downcasting,
    it is possible to recover the original type of the object after its reference
    was assigned to a variable of one of the implemented interface types.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与类引用的向上转型和向下转型一样，在将对象的引用赋给实现了接口类型之一的变量之后，可以恢复对象的原始类型。
- en: The material of this section can also be viewed as another demonstration of
    Java polymorphism in action.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的内容也可以被视为Java多态性在行动中的另一个演示。
- en: Array
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An `java.lang.Object` class too. The array elements have the same type as the
    declared array type. The number of elements may be zero, in which case the array
    is said to be an empty array. Each element can be accessed by an index, which
    is a positive integer or zero. The first element has an index of zero. The number
    of elements is called an array length. Once an array is created, its length never
    changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样也是一个`java.lang.Object`类。数组元素与声明的数组类型相同。元素的数量可能为零，在这种情况下，数组被称为空数组。每个元素可以通过索引访问，索引是一个正整数或零。第一个元素的索引为零。元素的数量称为数组长度。一旦创建了数组，其长度就不会改变。
- en: 'The following are examples of an array declaration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些数组声明的示例：
- en: '[PRE113]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Each bracket pair indicates another dimension. The number of bracket pairs
    is the nesting depth of the array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对括号表示另一个维度。括号对的数量是数组的嵌套深度：
- en: '[PRE117]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `new` operator allocates memory for each element that can be assigned (filled
    with) a value later. But in my case, the elements of an array are initialized
    to the default values at creation time, as the following example demonstrates:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符为可以分配（填充）值的每个元素分配内存。但在我这个例子中，数组的元素在创建时被初始化为默认值，如下例所示：'
- en: '[PRE121]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Another way to create an array is to use an array initializer – a comma-separated
    list of values enclosed in braces for each dimension, such as the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的另一种方法是使用数组初始化器——每个维度中用大括号括起来的逗号分隔的值列表，如下所示：
- en: '[PRE124]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'A multidimensional array can be created without declaring the length of each
    dimension. Only the first dimension has to have the length specified:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以不声明每个维度的长度来创建多维数组。只需指定第一个维度的长度：
- en: '[PRE130]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The missing length of other dimensions can be specified later:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其他维度的长度可以稍后指定：
- en: '[PRE137]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This way, it is possible to assign a different length to different dimensions.
    Using the array initializer, it is also possible to create dimensions of different
    lengths:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以为不同的维度分配不同的长度。使用数组初始化器，也可以创建不同长度的维度：
- en: '[PRE142]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The only requirement is that a dimension has to be initialized before it can
    be used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求是，在可以使用之前，必须初始化维度。
- en: Enum
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Enum
- en: 'The `java.lang.Enum` class, which, in turn, extends `java.lang.Object`. It
    allows the specification of a limited set of constants, each of them an instance
    of the same type. The declaration of such a set starts with the `enum` keyword.
    Here is an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Enum`类，它反过来扩展了`java.lang.Object`。它允许指定一组有限的常量，每个常量都是同一类型的实例。此类集合的声明以`enum`关键字开始。以下是一个示例：'
- en: '[PRE143]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Each of the listed items – `SPRING`, `SUMMER`, `AUTUMN`, and `WINTER` – is an
    instance of a `Season` type. They are the only four instances the `Season` class
    can have. They are created in advance and can be used everywhere as a value of
    a `Season` type. No other instance of the `Season` class can be created, and that
    is the reason for the creation of the `enum` type – it can be used for cases when
    the list of instances of a class has to be limited to the fixed set.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的每个项目——`SPRING`、`SUMMER`、`AUTUMN`和`WINTER`——都是`Season`类型的实例。它们是`Season`类可以拥有的唯一四个实例。它们是预先创建的，可以在任何地方用作`Season`类型的值。不能创建`Season`类的其他实例，这就是创建`enum`类型的原因——它可以在需要将类的实例列表限制为固定集合的情况下使用。
- en: 'The `enum` declaration can also be written in title case:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`声明也可以写成标题大小写：'
- en: '[PRE144]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: However, the all-capitals style is used more often because, as we mentioned
    earlier, there is a convention to express the static final constant’s identifier
    in a capital case. It helps to distinguish constants from variables. The `enum`
    constants are implicitly static and final.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，全大写风格的使用更为常见，因为我们之前提到，有一个约定，即用大写字母表示静态最终常量的标识符。这有助于区分常量和变量。`enum`常量隐式地是静态和最终的。
- en: 'Because the `enum` values are constants, they exist uniquely in a JVM and can
    be compared by reference:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`enum`值是常量，它们在JVM中唯一存在，可以通过引用进行比较：
- en: '[PRE145]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The following are the most frequently used methods of the `java.lang.Enum`
    class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的`java.lang.Enum`类的方法：
- en: '`name()`: Returns the `enum` constant’s identifier as it is spelled when declared
    (`WINTER`, for example).'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`: 返回`enum`常量的标识符，正如它在声明时拼写的那样（例如`WINTER`）。'
- en: '`toString()`: Returns the same value as the `name()` method by default but
    can be overridden to return any other `String` value.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`: 默认情况下返回与`name()`方法相同的值，但可以重写以返回任何其他`String`值。'
- en: '`ordinal()`: Returns the position of the `enum` constant when declared (the
    first in the list has a `0` ordinal value).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordinal()`: 返回`enum`常量在声明时的位置（列表中的第一个具有`0`序数值）。'
- en: '`valueOf(Class enumType, String name)`: Returns the `enum` constant object
    by its name, expressed as a `String` literal.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valueOf(Class enumType, String name)`: 通过其名称（以字符串字面量表示）返回`enum`常量对象。'
- en: '`values()`: A static method, described in the documentation of the `valueOff()`
    method as follows: “All the constants of an `enum` class can be obtained by calling
    the implicit `public static T[] values()` method of that class.”'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 这是一个静态方法，在`valueOff()`方法的文档中描述如下：“可以通过调用该类的隐式`public static T[]
    values()`方法来获取一个`enum`类的所有常量。”'
- en: 'To demonstrate the preceding methods, we are going to use the already familiar
    `enum`, `Season`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前面的方法，我们将使用已经熟悉的`enum`，`Season`：
- en: '[PRE148]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'And here is the demo code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示代码：
- en: '[PRE149]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'To override the `toString()` method, let’s create the `Season1` `enum`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重写`toString()`方法，让我们创建`Season1` `enum`：
- en: '[PRE158]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Here is how it works:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何工作的示例：
- en: '[PRE165]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'It is possible to add any other property to each `enum` constant. For example,
    let’s add an average temperature value to each `enum` instance:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向每个`enum`常量添加任何其他属性。例如，让我们给每个`enum`实例添加一个平均温度值：
- en: '[PRE169]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'If we iterate over values of the `Season2` `enum`, the result will be as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遍历`Season2` `enum`的值，结果将如下所示：
- en: '[PRE184]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In the standard Java libraries, there are several `enum` classes – for example,
    `java.time.Month`, `java.time.DayOfWeek`, and `java.util.concurrent.TimeUnit`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的Java库中，有几个`enum`类——例如，`java.time.Month`、`java.time.DayOfWeek`和`java.util.concurrent.TimeUnit`。
- en: Default values and literals
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值和字面量
- en: As we have already seen, the default value of a reference type is `null`. Some
    sources call it a `null`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，引用类型的默认值是`null`。一些资料称之为`null`。
- en: The only reference type that has a literal other than the `null` literal is
    the `String` class. We discussed strings in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一具有除`null`字面量之外字面量的引用类型是`String`类。我们已经在[*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java
    17入门*中讨论了字符串。
- en: A reference type as a method parameter
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引用类型作为方法参数
- en: 'When a primitive type value is passed into a method, we use it. If we do not
    like the value passed into the method, we change it as we see fit and do not think
    twice about it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个原始类型值传递到方法中时，我们使用它。如果我们不喜欢传递到方法中的值，我们可以随意更改它，并且不会对此多加思考：
- en: '[PRE188]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'We have no concerns that the variable value outside the method may change:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对外部方法之外的变量值可能发生变化没有顾虑：
- en: '[PRE191]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: It is not possible to change the parameter value of a primitive type outside
    the method because a primitive type parameter is passed into the method by value.
    This means that the copy of the value is passed into the method, so even if the
    code inside the method assigns a different value to it, the original value is
    not affected.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原始类型参数是通过值传递到方法中的，因此不可能在方法外部更改原始类型的参数值。这意味着值的副本被传递到方法中，因此即使方法内部的代码将其赋值为不同的值，原始值也不会受到影响。
- en: 'Another issue with a reference type is that even though the reference itself
    is passed by value, it still points to the same original object in the memory,
    so the code inside the method can access the object and modify it. To demonstrate
    it, let’s create a `DemoClass` and the method that uses it:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 参考类型的一个问题是，尽管引用本身是通过值传递的，但它仍然指向内存中的同一个原始对象，因此方法内部的代码可以访问并修改该对象。为了演示这一点，让我们创建一个`DemoClass`及其使用方法：
- en: '[PRE194]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'If we use the preceding method, the result will be as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的方法，结果将如下所示：
- en: '[PRE203]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: That’s a big difference, isn’t it? So, you have to be careful not to modify
    the passed-in object in order to avoid an undesirable effect. However, this effect
    is occasionally used to return the result. But it does not belong to the list
    of best practices because it makes code less readable. Changing the passed-in
    object is like using a secret tunnel that is difficult to notice. So, use it only
    when you have to.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个很大的区别，不是吗？因此，你必须小心不要修改传入的对象，以避免产生不希望的效果。然而，这种效果偶尔被用来返回结果。但这并不属于最佳实践列表，因为它会使代码的可读性降低。修改传入的对象就像使用一个难以察觉的秘密通道。所以，只有在必要时才使用它。
- en: 'Even if the passed-in object is a class that wraps a primitive value, this
    effect still holds (we will talk about the primitive values wrapping type in the
    *Converting between primitive and reference types* section). Here is `DemoClass1`
    and an overloaded version of the `modifyParameter()` method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 即使传入的对象是一个包装原始值的类，这种效果仍然存在（我们将在 *“在 *转换原始类型和引用类型之间*”部分讨论原始值包装类型）。以下是 `DemoClass1`
    和 `modifyParameter()` 方法的重载版本：
- en: '[PRE207]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'If we use the preceding method, the result will be as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的方法，结果将如下所示：
- en: '[PRE216]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The only exception to this behavior of reference types is an object of the
    `String` class. Here is another overloaded version of the `modifyParameter()`
    method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型这种行为的唯一例外是 `String` 类的对象。以下是 `modifyParameter()` 方法的另一个重载版本：
- en: '[PRE219]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'If we use the preceding method, the result will be as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的方法，结果将如下所示：
- en: '[PRE222]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: As you can see, whether we use a literal or a new `String` object, the result
    remains the same – the original `String` value is not changed after the method
    that assigns another value to it. That is exactly the purpose of the `String`
    value immutability feature we discussed in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论我们使用字面量还是一个新的 `String` 对象，结果都相同——在将另一个值赋给它的方法之后，原始的 `String` 值并未改变。这正是我们在
    [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*《Java 17 入门》中讨论的 `String` 值不可变特性的目的。
- en: equals() method
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`equals()` 方法'
- en: The equality operator (`==`), when applied to the variables of reference types,
    compares the references themselves, not the content (the state) of the objects.
    But two objects always have different memory references even if they have identical
    content. Even when used for `String` objects, the operator (`==`) returns `false`
    if at least one of them is created using a `new` operator (see the discussion
    about `String` value immutability in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 等号运算符（`==`），当应用于引用类型的变量时，比较的是引用本身，而不是对象的内容（状态）。但是，即使它们具有相同的内容，两个对象也总是有不同的内存引用。即使用于
    `String` 对象，如果至少有一个是通过 `new` 运算符创建的，运算符（`==`）也会返回 `false`（参见 [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*《Java
    17 入门》中关于 `String` 值不可变的讨论）。
- en: To compare content, you can use the `equals()` method. Its implementation in
    the `String` class and numerical type wrapper classes (`Integer`, `Float`, and
    so on) does exactly that – compare the content of the objects.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较内容，可以使用 `equals()` 方法。在 `String` 类和数值类型包装类（`Integer`、`Float` 等）中的实现正是这样——比较对象的内容。
- en: 'However, the `equals()` method implementation in the `java.lang.Object` class
    compares only references, which is understandable because the variety of possible
    content the descendants can have is huge, and the implementation of the generic
    content comparison is just not feasible. This means that every Java object that
    needs to have the `equals()` method comparing the object’s content – not just
    references – has to re-implement the `equals()` method and, thus, override its
    implementation in the `java.lang.Object` class, which appears as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`java.lang.Object` 类中的 `equals()` 方法仅比较引用，这是可以理解的，因为后代可能具有的可能内容种类繁多，而通用内容比较的实现根本不可行。这意味着每个需要
    `equals()` 方法比较对象内容的 Java 对象——不仅仅是引用——都必须重新实现 `equals()` 方法，并因此覆盖 `java.lang.Object`
    类中的实现，如下所示：
- en: '[PRE228]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'By contrast, look at how the same method is implemented in the `Integer` class:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，看看同样的方法在 `Integer` 类中的实现：
- en: '[PRE231]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: As you can see, it extracts the primitive `int` value from the input object
    and compares it to the primitive value of the current object. It does not compare
    object references at all.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它从输入对象中提取原始 `int` 值，并将其与当前对象的原始值进行比较。它根本不比较对象引用。
- en: 'The `String` class, on the other hand, compares the references first and, if
    the references are not the same value, compares the content of the objects:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`String` 类首先比较引用，如果引用不相同，则比较对象的内容：
- en: '[PRE238]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The `StringLatin1.equals()` and `StringUTF16.equals()` methods compare the values
    character by character, not just references.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringLatin1.equals()` 和 `StringUTF16.equals()` 方法逐字符比较值，而不仅仅是引用。'
- en: 'Similarly, if the application code needs to compare two objects by their content,
    the `equals()` method in the corresponding class has to be overridden. For example,
    let’s look at the familiar `DemoClass` class:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果应用程序代码需要通过内容比较两个对象，相应类中的 `equals()` 方法必须被重写。例如，让我们看看熟悉的 `DemoClass` 类：
- en: '[PRE254]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'We can add to it the `equals()` method manually, but the IDE can help us to
    do this, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动添加 `equals()` 方法，但 IDE 可以帮助我们完成这项工作，如下所示：
- en: Right-click inside the class just before the closing brace (`}`).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中右键单击关闭括号 `}` 之前的位置。
- en: Select **Generate** and then follow the prompts.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **生成** 然后按照提示操作。
- en: 'Eventually, two methods will be generated and added to the class:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，将生成并添加到类中的两个方法：
- en: '[PRE260]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Looking at the generated code, focus your attention on the following points:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的代码时，请注意以下要点：
- en: The usage of the `@Override` annotation – this ensures that the method does
    override a method (with the same signature) in one of the ancestors. With this
    annotation in place, if you modify the method and change the signature (by mistake
    or intentionally), the compiler (and your IDE) will immediately raise an error,
    telling you that there is no method with such a signature in any of the ancestor
    classes. So, it helps to detect an error early.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Override` 注解的使用——这确保了方法确实覆盖了祖先中的一个方法（具有相同的签名）。有了这个注解，如果您修改了方法并更改了签名（无意或有意），编译器（和您的
    IDE）将立即抛出一个错误，告诉您在祖先类中没有这样的签名的方法。因此，它有助于早期发现错误。'
- en: 'The usage of the `java.util.Objects` class – this has quite a few very helpful
    methods, including the `equals()` static method that not only compares references
    but also uses the `equals()` method:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Objects` 类的使用——它包含许多非常有用的方法，包括 `equals()` 静态方法，它不仅比较引用，还使用 `equals()`
    方法：'
- en: '[PRE271]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: As we have demonstrated earlier, the `equals()` method, implemented in the `String`
    class, compares strings by their content and serves this purpose because the `getProp()`
    method of `DemoClass` returns a string.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所展示的，`String` 类中实现的 `equals()` 方法通过内容比较字符串，并因此服务于这个目的，因为 `DemoClass` 的
    `getProp()` 方法返回一个字符串。
- en: The `hashCode()` method – the integer returned by this method uniquely identifies
    this particular object (but please do not expect it to be the same between different
    runs of the application). It is not necessary to have this method implemented
    if the only method needed is `equals()`. Nevertheless, it is recommended to have
    it just in case the object of this class is going to be collected in `Set` or
    another collection based on a hash code (we are going to talk about Java collections
    in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode()` 方法——此方法返回的整数唯一地标识了该特定对象（但请不要期望它在应用程序的不同运行之间是相同的）。如果只需要 `equals()`
    方法，则不需要实现此方法。尽管如此，出于以防万一，如果此类对象将被收集到 `Set` 或基于哈希码的其他集合中，建议实现它（我们将在 [*第 6 章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*）中讨论
    Java 集合）。'
- en: Both these methods are implemented in `Object` because many algorithms use the
    `equals()` and `hashCode()` methods, and your application may not work without
    these methods implemented. Meanwhile, your objects may not need them in your application.
    However, once you decide to implement the `equals()` method, it is a good idea
    to implement the `hasCode()` method too. Besides, as you have seen, an IDE can
    do this without any overhead.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都在 `Object` 中实现，因为许多算法使用 `equals()` 和 `hashCode()` 方法，并且如果您的应用程序没有实现这些方法，则可能无法正常工作。同时，您的对象可能不需要它们在您的应用程序中。然而，一旦您决定实现
    `equals()` 方法，实现 `hashCode()` 方法也是一个好主意。此外，如您所见，IDE 可以在不产生任何开销的情况下完成这项工作。
- en: Reserved and restricted keywords
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留和限制关键字
- en: The **keywords** are the words that have particular meaning for a compiler and
    cannot be used as identifiers. As of Java 17, there are 52 reserved keywords,
    5 reserved identifiers, 3 reserved words, and 10 restricted keywords. The reserved
    keywords cannot be used as identifiers anywhere in the Java code, while the restricted
    keywords cannot be used as identifiers only in the context of a module declaration.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键字**是对于编译器有特定意义的单词，不能用作标识符。截至 Java 17，有 52 个保留关键字、5 个保留标识符、3 个保留词和 10 个限制性关键字。保留关键字不能在任何
    Java 代码中使用作标识符，而限制性关键字只能在模块声明上下文中用作标识符。'
- en: Reserved keywords
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留关键字
- en: 'The following is a list of all Java-reserved keywords:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份所有 Java 保留关键字的列表：
- en: '![](img/B18388_Table_3.1.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Table_3.1.jpg)'
- en: 'By now, you should feel at home with most of the preceding keywords. By way
    of an exercise, you can go through the list and check how many of them you remember.
    Up until now, we have not discussed the following eight keywords:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对前面的大部分关键字都很熟悉。作为一个练习，你可以通过列表检查你记得多少。到目前为止，我们还没有讨论以下八个关键字：
- en: '`const` and `goto` are reserved but not used, so far.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`和`goto`是保留的，但尚未使用。'
- en: The `assert` keyword is used in an `assert` statement (we will talk about this
    in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception Handling*).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`关键字用于`assert`语句中（我们将在[*第4章*](B18388_04_ePub.xhtml#_idTextAnchor110)，*异常处理*）中使用。'
- en: The `synchronized` keyword is used in concurrent programming (we will talk about
    this in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187), *Multithreading
    and Concurrent Processing*).
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`关键字用于并发编程（我们将在[*第8章*](B18388_08_ePub.xhtml#_idTextAnchor187)，*多线程与并发处理*）中使用。'
- en: The `volatile` keyword makes the value of a variable uncacheable.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile`关键字使得变量的值不可缓存。'
- en: The `transient` keyword makes the value of a variable not serializable.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transient`关键字使得变量的值不可序列化。'
- en: The `strictfp` keyword restricts floating-point calculations, making it the
    same result on every platform while performing operations in the floating-point
    variable.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictfp`关键字限制了浮点数计算，使得在执行浮点变量操作时，每个平台上的结果都相同。'
- en: The `native` keyword declares a method implemented in platform-dependent code,
    such as C or C++.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native`关键字声明了一个在平台相关代码（如C或C++）中实现的方法。'
- en: Reserved identifiers
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留标识符
- en: 'The five reserved identifiers in Java are as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的五个保留标识符如下：
- en: '`permits`'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permits`'
- en: '`record`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record`'
- en: '`sealed`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sealed`'
- en: '`var`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`'
- en: '`yield`'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`'
- en: Reserved words for literal values
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字值的保留字
- en: 'The three reserved words in Java are as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的三个保留字如下：
- en: '`true`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`false`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`null`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: Restricted keywords
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受限关键字
- en: 'The 10 restricted keywords in Java are as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的10个受限关键字如下：
- en: '`open`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`'
- en: '`module`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`'
- en: '`requires`'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`'
- en: '`transitive`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transitive`'
- en: '`exports`'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`'
- en: '`opens`'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opens`'
- en: '`to`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`'
- en: '`uses`'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uses`'
- en: '`provides`'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provides`'
- en: '`with`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`'
- en: 'They are called *restricted* because they cannot be identifiers in the context
    of a module declaration, which we will not discuss in this book. In all other
    places, it is possible to use them as identifiers, such as the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被称为*受限*，因为它们不能在模块声明上下文中作为标识符，我们将在本书中不讨论这一点。在其他所有地方，它们都可以用作标识符，例如以下内容：
- en: '[PRE272]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Although you can, it is a good practice not to use them as identifiers, even
    outside module declaration.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以这样做，但即使在不进行模块声明的情况下，不将它们用作标识符也是一个好习惯。
- en: Usage of the this and super keywords
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`this`和`super`关键字的用法'
- en: The `this` keyword provides a reference to the current object. The `super` keyword
    refers to the parent class object. These keywords allow us to refer to a variable
    or method that has the same name in the current context and the parent object.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字提供了一个对当前对象的引用。`super`关键字指向父类对象。这些关键字允许我们引用在当前上下文和父对象中具有相同名称的变量或方法。'
- en: Usage of the this keyword
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`this`关键字的用法'
- en: 'Here is the most popular example:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最受欢迎的例子：
- en: '[PRE274]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'The first line looks ambiguous, but, in fact, it is not – the local variable,
    `int count`, hides the `int count` private property instance. We can demonstrate
    this by running the following code:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行看起来有些模糊，但实际上并非如此——局部变量`int count`隐藏了`int count`私有属性实例。我们可以通过运行以下代码来证明这一点：
- en: '[PRE283]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'Using the `this` keyword fixes the problem:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`this`关键字可以解决问题：
- en: '[PRE286]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Adding `this` to line `1` allows the value to be assigned the instance property.
    Adding `this` to line `2` does not make a difference, but it is good practice
    to use the `this` keyword every time with the `instance` property. It makes the
    code more readable and helps avoid difficult-to-trace errors, such as the one
    we have just demonstrated.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`1`行添加`this`允许将值分配给实例属性。在第`2`行添加`this`没有区别，但每次使用`instance`属性时都使用`this`关键字是一个好习惯。这使得代码更易读，并有助于避免难以追踪的错误，例如我们刚才演示的那个。
- en: 'We have also seen the `this` keyword usage in the `equals()` method:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了`this`关键字在`equals()`方法中的使用：
- en: '[PRE295]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'And, just to remind you, here are the examples of a constructor that we presented
    in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，为了提醒你，以下是我们曾在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中展示的构造函数的例子：
- en: '[PRE302]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: In the preceding code, you can see not only the `this` keyword but also the
    usage of the `super` keyword, which we are going to discuss next.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到不仅有关键字 `this`，还有 `super` 关键字的使用，我们将在下一节讨论它的用法。在构造函数中，`super` 关键字已经展示了它的用法，它必须仅在第一行使用，因为父类对象必须在当前对象创建之前创建。如果构造函数的第一行不是
    `super()`，这意味着父类有一个不带参数的构造函数。
- en: Usage of the super keyword
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超级关键字的使用
- en: The `super` keyword refers to the parent object. We saw its usage in the *Usage
    of the this keyword* section in a constructor already, where it has to be used
    only in the first line because the parent class object has to be created before
    the current object can be created. If the first line of the constructor is not
    `super()`, this means the parent class has a constructor without parameters.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`super` 关键字指的是父对象。我们在构造函数中已经看到了它的用法，在 *超级关键字的使用* 部分，它必须仅在第一行使用，因为父类对象必须在当前对象创建之前创建。如果构造函数的第一行不是
    `super()`，这意味着父类有一个不带参数的构造函数。'
- en: 'The `super` keyword is especially helpful when a method is overridden and the
    method of the parent class has to be called:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被重写，并且需要调用父类的方法时，`super` 关键字特别有用：
- en: '[PRE316]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: As we progress through this book, we will see more examples of using the `this`
    and `super` keywords.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在这本书中的进展，我们将看到更多使用 `this` 和 `super` 关键字的例子。
- en: Converting between primitive types
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型之间的转换
- en: 'The maximum numeric value that a numeric type can hold depends on the number
    of bits allocated to it. The following are the number of bits for each numeric
    type of representation:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数值类型可以持有的最大数值取决于为其分配的位数。以下是对每种数值类型表示的位数：
- en: '`byte`: 8 bits'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：8位'
- en: '`char`: 16 bits'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：16位'
- en: '`short`: 16 bits'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：16位'
- en: '`int`: 32 bits'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：32位'
- en: '`long`: 64 bits'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：64位'
- en: '`float`: 32 bits'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：32位'
- en: '`double`: 64 bits'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：64位'
- en: When a value of one numeric type is assigned to a variable of another numeric
    type and the new type can hold a bigger number, such a conversion is called a
    `cast` operator.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数值类型的值赋给另一个数值类型的变量，并且新类型可以容纳更大的数字时，这种转换称为 `cast` 操作符。
- en: Widening conversion
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宽泛转换
- en: 'According to the Java Language Specification, there are 19 widening primitive
    type conversions:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Java语言规范，共有19种宽泛的原始类型转换：
- en: '`byte` to `short`, `int`, `long`, `float`, or `double`'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 到 `short`、`int`、`long`、`float` 或 `double`'
- en: '`short` to `int`, `long`, `float`, or `double`'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 到 `int`、`long`、`float` 或 `double`'
- en: '`char` to `int`, `long`, `float`, or `double`'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 到 `int`、`long`、`float` 或 `double`'
- en: '`int` to `long`, `float`, or `double`'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 到 `long`、`float` 或 `double`'
- en: '`long` to `float` or `double`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 到 `float` 或 `double`'
- en: '`float` to `double`'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 到 `double`'
- en: 'During widening conversion between integral types, and from some integral types
    to a floating-point type, the resulting value matches the original one exactly.
    However, conversion from `int` to `float`, from `long` to `float`, or from `long`
    to `double` may result in a loss of precision. The resulting floating-point value
    may be correctly rounded using `IEEE 754 round-to-nearest mode`, according to
    the Java Language Specification. Here are a few examples that demonstrate the
    loss of precision:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数类型之间的宽泛转换，以及某些整数类型到浮点类型的转换中，结果值与原始值完全匹配。然而，从 `int` 到 `float`、从 `long` 到 `float`
    或从 `long` 到 `double` 的转换可能会导致精度损失。根据Java语言规范，结果浮点值可以使用 `IEEE 754 四舍五入到最接近的模式`
    正确舍入。以下是一些演示精度损失的例子：
- en: '[PRE330]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: As you can see, conversion from `int` to `double` preserves the value, but `long`
    to `float`, or `long` to `double`, may lose precision. It depends on how big the
    value is. So, be aware and allow for some loss of precision if it is important
    for your calculations.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 `int` 到 `double` 的转换会保留值，但 `long` 到 `float` 或 `long` 到 `double` 可能会丢失精度。这取决于值的大小。所以，如果你在计算中需要精确度，请注意并允许一些精度损失。
- en: Narrowing conversion
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 狭义转换
- en: 'The Java Language Specification identifies 22 narrowing primitive conversions:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言规范确定了22种狭义原始类型转换：
- en: '`short` to `byte` or `char`'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 到 `byte` 或 `char`'
- en: '`char` to `byte` or `short`'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 到 `byte` 或 `short`'
- en: '`int` to `byte`, `short`, or `char`'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 到 `byte`、`short` 或 `char`'
- en: '`long` to `byte`, `short`, `char`, or `int`'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 到 `byte`、`short`、`char` 或 `int`'
- en: '`float` to `byte`, `short`, `char`, `int`, or `long`'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 到 `byte`、`short`、`char`、`int` 或 `long`'
- en: '`double` to `byte`, `short`, `char`, `int`, `long`, or `float`'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 到 `byte`、`short`、`char`、`int`、`long` 或 `float`'
- en: 'Similar to the widening conversion, a narrowing conversion may result in a
    loss of precision, or even in a loss of the value magnitude. The narrowing conversion
    is more complicated than a widening one, and we are not going to discuss it in
    this book. It is important to remember that before performing a narrowing, you
    must make sure that the original value is smaller than the maximum value of the
    target type. Otherwise, you can get a completely different value (with lost magnitude).
    Look at the following example:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 与拓宽转换类似，缩窄转换可能会导致精度丢失，甚至可能丢失值的大小。缩窄转换比拓宽转换更复杂，我们不会在本书中讨论它。重要的是要记住，在执行缩窄之前，必须确保原始值小于目标类型的最大值。否则，您可能会得到一个完全不同的值（丢失了大小）。请看以下示例：
- en: '[PRE345]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: As you can see from the examples, without checking first whether the target
    type can accommodate the value, you can get the result just equal to the maximum
    value of the target type. The rest will be just lost, no matter how big the difference
    is.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中可以看出，如果不首先检查目标类型是否可以容纳该值，那么得到的结果将正好等于目标类型的最大值。其余的都将丢失，无论差异有多大。
- en: Important Note
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before performing a narrowing conversion, check whether the maximum value of
    the target type can hold the original value.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行缩窄转换之前，检查目标类型的最大值是否可以容纳原始值。
- en: Please note that the conversion between the `char` type and the `byte` or `short`
    types is an even more complicated procedure because the `char` type is an unsigned
    numeric type, while the `byte` and `short` types are signed numeric types, so
    some loss of information is possible even when a value may look as though it fits
    in the target type.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`char`类型与`byte`或`short`类型之间的转换是一个更为复杂的程序，因为`char`类型是一个无符号数值类型，而`byte`和`short`类型是有符号数值类型，所以即使一个值看起来似乎可以适应目标类型，也可能发生信息丢失。
- en: Methods of conversion
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换方法
- en: 'In addition to the casting, each primitive type has a corresponding reference
    type (called a `boolean` and `char`. All the wrapper classes belong to the `java.lang`
    package:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型转换之外，每种原始类型都有一个相应的引用类型（称为`boolean`和`char`。所有的包装类都属于`java.lang`包）：
- en: '`java.lang.Boolean`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Boolean`'
- en: '`java.lang.Byte`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Byte`'
- en: '`java.lang.Character`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character`'
- en: '`java.lang.Short`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Short`'
- en: '`java.lang.Integer`'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Integer`'
- en: '`java.lang.Long`'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Long`'
- en: '`java.lang.Float`'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Float`'
- en: '`java.lang.Double`'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Double`'
- en: 'Each of them – except the `Boolean` and `Character` classes – extends the `java.lang.Number`
    abstract class, which has the following abstract methods:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 其中除了`Boolean`和`Character`类之外，它们都扩展了`java.lang.Number`抽象类，该抽象类有以下抽象方法：
- en: '`byteValue()`'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byteValue()`'
- en: '`shortValue()`'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shortValue()`'
- en: '`intValue()`'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intValue()`'
- en: '`longValue()`'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longValue()`'
- en: '`floatValue()`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floatValue()`'
- en: '`doubleValue()`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doubleValue()`'
- en: 'Such design forces the descendants of the `Number` class to implement all of
    them. The results they produce are the same as the `cast` operator in the previous
    examples:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计迫使`Number`类的后代实现所有这些方法。它们产生的结果与前面示例中的`cast`运算符相同：
- en: '[PRE350]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'In addition, each of the wrapper classes has methods that allow the conversion
    of the `String` representation of a numeric value to the corresponding primitive
    numeric type or reference type, such as the following:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个包装类都有方法，允许将数值的`String`表示形式转换为相应的原始数值类型或引用类型，如下所示：
- en: '[PRE371]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: In the examples, please note the two methods that accept the `property` parameter.
    These two and similar methods of other wrapper classes convert a system property
    (if one exists) to the corresponding primitive type.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，请注意接受`property`参数的两个方法。这两个方法以及其他包装类的类似方法将系统属性（如果存在）转换为相应的原始类型。
- en: 'Each of the wrapper classes has the `toString(primitive value)` static method
    to convert the primitive type value to its `String` representation, such as the
    following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包装类都有一个`toString(primitive value)`静态方法，用于将原始类型值转换为它的`String`表示形式，如下所示：
- en: '[PRE387]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: The wrapper classes have many other useful methods of conversion from one primitive
    type to another and to different formats. So, if you need to do something such
    as that, look into the corresponding wrapper class first.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类有许多其他有用的转换方法，可以从一种原始类型转换为另一种原始类型，以及转换为不同的格式。因此，如果您需要做类似的事情，首先查看相应的包装类。
- en: Converting between primitive and reference types
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型与引用类型之间的转换
- en: The conversion of a primitive type value to an object of the corresponding wrapper
    class is called **boxing**. Also, the conversion from an object of a wrapper class
    to the corresponding primitive type value is called **unboxing**.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始类型值转换为相应包装类的对象称为**装箱**。同样，将包装类的对象转换为相应原始类型值称为**拆箱**。
- en: Boxing
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装箱
- en: 'The boxing of a primitive type can be done either automatically (called `valueOf()`
    method available in each wrapper type:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的装箱可以自动完成（每个包装类型都提供了名为`valueOf()`的方法）：
- en: '[PRE391]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: Note that autoboxing is only possible in relation to a corresponding wrapper
    type. Otherwise, the compiler generates an error.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，自动装箱仅在相关包装类型之间才可能。否则，编译器会生成错误。
- en: The input value of the `valueOf()` method of the `Byte` and `Short` wrappers
    required casting because it was a narrowing of a primitive type we discussed in
    the previous section.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`Byte`和`Short`包装类的`valueOf()`方法的输入值需要强制类型转换，因为它是我们之前章节中讨论的原始类型缩窄。'
- en: Unboxing
  id: totrans-651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆箱
- en: 'Unboxing can be accomplished using methods of the `Number` class implemented
    in each wrapper class:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用每个包装类中实现的`Number`类的方法来完成拆箱：
- en: '[PRE407]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: As you can see from the comment in the example, the conversion from a wrapper
    type to the corresponding primitive type is not called **auto-unboxing**; it is
    called **implicit unboxing** instead. In contrast to autoboxing, it is possible
    to use implicit unboxing even between wrapping and primitive types that do not
    match.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从示例中的注释中可以看到，从包装类型到相应原始类型的转换不被称为**自动拆箱**；而是称为**隐式拆箱**。与自动装箱不同，即使在包装类型和与之不匹配的原始类型之间，也可以使用隐式拆箱。
- en: Summary
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what Java packages are and the role they play in
    organizing code and class accessibility, including the `import` statement and
    access modifiers. You also became familiar with reference types – classes, interfaces,
    arrays, and enums. The default value of any reference type is `null`, including
    the `String` type.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Java包是什么以及它们在组织代码和类可访问性方面所起的作用，包括`import`语句和访问修饰符。您还熟悉了引用类型——类、接口、数组和枚举。任何引用类型的默认值都是`null`，包括`String`类型。
- en: You should now understand that the reference type is passed into a method by
    reference and how the `equals()` method is used and can be overridden. You also
    had an opportunity to study the full list of reserved and restricted keywords
    and learned the meaning and usage of the `this` and `super` keywords.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该理解了引用类型是如何通过引用传递给方法的，以及`equals()`方法的使用和重写方式。您还有机会研究完整的保留和限制关键字列表，并学习了`this`和`super`关键字的意义和用法。
- en: The chapter concluded by describing the process and methods of conversion between
    primitive types, wrapping types, and `String` literals.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过描述原始类型、包装类型和`String`字面量之间的转换过程和方法来结束。
- en: In the next chapter, we will talk about the Java exceptions framework, checked
    and unchecked (runtime) exceptions, `try-catch-finally` blocks, `throws` and `throw`
    statements, and the best practices of exception handling.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Java异常框架，检查和未检查（运行时）异常，`try-catch-finally`块，`throws`和`throw`语句，以及异常处理的最佳实践。
- en: Quiz
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Select all the statements that are correct:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: The `Package` statement describes the class or interface location.
  id: totrans-683
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Package`语句描述了类或接口的位置。'
- en: The `Package` statement describes the class or interface name.
  id: totrans-684
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Package`语句描述了类或接口的名称。'
- en: '`Package` is a fully qualified name.'
  id: totrans-685
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Package`是一个完全限定名。'
- en: The `Package` name and class name compose a fully qualified name of the class.
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Package`名称和类名组成类的完全限定名。'
- en: 'Select all the statements that are correct:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: The `Import` statement allows the use of the fully qualified name.
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import`语句允许使用完全限定名。'
- en: The `Import` statement has to be the first in the `.java` file.
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import`语句必须在`.java`文件的第一行。'
- en: The `Group import` statement brings in the classes (and interfaces) of one package
    only.
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Group import`语句仅引入一个包中的类（和接口）。'
- en: The `Import statement` allows the use of the fully qualified name to be avoided.
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import statement`允许避免使用完全限定名。'
- en: 'Select all the statements that are correct:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: Without an access modifier, the class is accessible only by other classes and
    interfaces of the same package.
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有访问修饰符，类只能被同一包中的其他类和接口访问。
- en: The private method of a private class is accessible to other classes declared
    in the same `.java` file.
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有类的私有方法可以被同一 `.java` 文件中声明的其他类访问。
- en: The public method of a private class is accessible to other classes not declared
    in the same `.java` file but from the same package.
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有类的公共方法可以被同一包中但不在同一 `.java` 文件中声明的其他类访问。
- en: The protected method is accessible only to the descendants of the class.
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护的（protected）方法只能被类的后代访问。
- en: 'Select all the statements that are correct:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Private methods can be overloaded but not overridden.
  id: totrans-698
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有方法可以被重载但不能被覆盖。
- en: Protected methods can be overridden but not overloaded.
  id: totrans-699
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护的（protected）方法可以被覆盖但不能被重载。
- en: Methods without an access modifier can be both overridden and overloaded.
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有访问修饰符的方法既可以被重载也可以被覆盖。
- en: Private methods can access private properties of the same class.
  id: totrans-701
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有方法可以访问同一类的私有属性。
- en: 'Select all the statements that are correct:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Narrowing and downcasting are synonyms.
  id: totrans-703
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狭义和向下转型是同义词。
- en: Widening and downcasting are synonyms.
  id: totrans-704
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展和向下转型是同义词。
- en: Widening and upcasting are synonyms.
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展和向上转型是同义词。
- en: Widening and narrowing have nothing in common with upcasting and downcasting.
  id: totrans-706
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展和狭义与向上转型和向下转型没有共同之处。
- en: 'Select all the statements that are correct:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: '`Array` is an object.'
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Array` 是一个对象。'
- en: '`Array` has a length that is a number of the elements it can hold.'
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Array` 有一个表示它能容纳的元素数量的长度。'
- en: The first element of an array has the index 1.
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组的第一个元素具有索引 1。
- en: The second element of an array has the index 1.
  id: totrans-711
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组的第二个元素具有索引 1。
- en: 'Select all the statements that are correct:'
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: '`Enum` contains constants.'
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Enum` 包含常量。'
- en: '`Enum` always has a constructor, either default or explicit.'
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Enum` 总是有一个构造函数，无论是默认的还是显式的。'
- en: An `enum` constant can have properties.
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举（enum）常量可以有属性。
- en: '`Enum` can have constants of any reference type.'
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Enum` 可以有任何引用类型的常量。'
- en: 'Select all the statements that are correct:'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Any reference type passed in as a parameter can be modified.
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何作为参数传入的引用类型都可以被修改。
- en: A `new String()` object passed in as a parameter can be modified.
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为参数传入的 `new String()` 对象可以被修改。
- en: An object reference value passed in as a parameter cannot be modified.
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为参数传入的对象引用值不能被修改。
- en: An array passed in as a parameter can have elements assigned to different values.
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为参数传入的数组可以有不同的值分配给其元素。
- en: 'Select all the statements that are correct:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Reserved keywords cannot be used.
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留关键字不能使用。
- en: Restricted keywords cannot be used as identifiers.
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制关键字不能用作标识符。
- en: A reserved `identifier` keyword cannot be used as an identifier.
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留的 `identifier` 关键字不能用作标识符。
- en: A reserved keyword cannot be used as an identifier.
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留关键字不能用作标识符。
- en: 'Select all the statements that are correct:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The `this` keyword refers to the `current` class.
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`this` 关键字指的是当前类。'
- en: The `super` keyword refers to the `super` class.
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`super` 关键字指的是超类。'
- en: The `this` and `super` keywords refer to objects.
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`this` 和 `super` 关键字指的是对象。'
- en: The `this` and `super` keywords refer to methods.
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`this` 和 `super` 关键字指的是方法。'
- en: 'Select all the statements that are correct:'
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The widening of a primitive type makes the value bigger.
  id: totrans-733
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始类型的扩展会使值变大。
- en: The narrowing of a primitive type always changes the type of the value.
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始类型的狭义总是改变值的类型。
- en: The widening of a primitive type can be done only after narrowing a conversion.
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始类型的扩展只能在转换狭义之后进行。
- en: Narrowing makes the value smaller.
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狭义会使值变小。
- en: 'Select all the statements that are correct:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Boxing puts a limit on the value.
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装箱（Boxing）对值有限制。
- en: Unboxing creates a new value.
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解箱（Unboxing）创建了一个新值。
- en: Boxing creates a reference-type object.
  id: totrans-740
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装箱（Boxing）创建了一个引用类型对象。
- en: Unboxing deletes a reference-type object.
  id: totrans-741
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解箱（Unboxing）删除了一个引用类型对象。
