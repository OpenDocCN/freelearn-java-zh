- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Spring Reactive and Spring Cloud Stream
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Reactive 和 Spring Cloud Stream
- en: A different approach to applications may be necessary in high concurrency scenarios,
    with resource-intensive operations such as **Input/Output** (**I/O**)-bounded
    tasks that require low latency and responsiveness. In this chapter, we’ll learn
    about two Spring Boot projects that address such a scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在高并发场景中，可能需要不同的应用程序方法，例如需要低延迟和响应性的资源密集型操作，如 **输入/输出** (**I/O**) 限定的任务。在本章中，我们将了解两个解决此类场景的
    Spring Boot 项目。
- en: '**Spring Reactive** is Spring’s response to reactive processing scenarios.
    Reactive processing is a paradigm that allows developers to build **non-blocking**,
    asynchronous applications that can handle **backpressure**. Non-blocking means
    that when an application waits for an external resource to respond, for instance,
    when calling an external web service or database, the application doesn’t block
    the processing thread. Instead, it reuses the processing threads to handle new
    requests. Backpressure is a mechanism for handling situations where a downstream
    component cannot keep up with the rate of data production from an upstream component.
    For these mechanisms, Spring Reactive can be used in high-concurrency scenarios
    with resource-intensive operations.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Reactive** 是 Spring 对反应式处理场景的响应。反应式处理是一种范式，允许开发者构建 **非阻塞**、异步的应用程序，可以处理
    **背压**。非阻塞意味着当应用程序等待外部资源响应时，例如调用外部 Web 服务或数据库时，应用程序不会阻塞处理线程。相反，它重用处理线程来处理新的请求。背压是一种处理下游组件无法跟上上游组件数据生产速率的情况的机制。对于这些机制，Spring
    Reactive 可以在高并发场景和资源密集型操作中使用。'
- en: '**Spring WebFlux** is the reactive web framework equivalent to the Spring **model-view-controller**
    (**MVC**) we used in the previous chapters. To facilitate the transition between
    web frameworks, Spring WebFlux mirrors the names and annotations from the Spring
    MVC.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring WebFlux** 是与我们在前几章中使用的 Spring **模型-视图-控制器** (**MVC**) 相当的反应式 Web 框架。为了促进不同
    Web 框架之间的过渡，Spring WebFlux 反映了 Spring MVC 中的名称和注解。'
- en: Spring Data **Reactive Relational Database Connectivity** (**R2DBC**) is the
    specification for integrating relational databases using reactive drivers. Compared
    to traditional blocking drivers, it also applies familiar abstractions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data **Reactive Relational Database Connectivity** (**R2DBC**) 是使用反应式驱动程序集成关系型数据库的规范。与传统阻塞驱动程序相比，它还应用了熟悉的抽象。
- en: '**Spring Cloud Stream** is a framework for building highly scalable event-driven
    distributed applications connected with shared messaging systems. You can use
    reactive programming with Spring Cloud Stream, but the main goal of Spring Cloud
    Stream is to create loosely coupled distributed applications that can scale independently.
    Rather than trying to optimize the runtime execution as reactive does, Spring
    Cloud Stream provides the foundations for creating distributed applications that
    can work with some asynchronous degree. Spring Reactive and Spring Cloud Stream
    can be combined and complementary in high-concurrency scenarios.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Stream** 是一个用于构建高度可扩展的事件驱动分布式应用程序的框架，这些应用程序通过共享消息系统连接。您可以使用反应式编程与
    Spring Cloud Stream 一起使用，但 Spring Cloud Stream 的主要目标是创建松散耦合的分布式应用程序，这些应用程序可以独立扩展。与反应式试图优化运行时执行不同，Spring
    Cloud Stream 为创建可以处理一定程度的异步的分布式应用程序提供了基础。Spring Reactive 和 Spring Cloud Stream
    可以在高并发场景中结合使用，并且是互补的。'
- en: In the first part of this chapter, we’ll explore Spring Reactive by learning
    how to use Spring WebFlux and Spring Data R2DBC with PostgreSQL. In the second
    part, we’ll learn how to use Spring Cloud Stream while using RabbitMQ as the messaging
    service. What you’ll learn can be applied to other messaging services, such as
    Kafka, or other services provided by cloud providers, such as Amazon Kinesis,
    Azure Event Hub, or Google PubSub.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将通过学习如何使用 Spring WebFlux 和 Spring Data R2DBC 与 PostgreSQL 一起使用来探索
    Spring Reactive。在第二部分，我们将学习如何在使用 RabbitMQ 作为消息服务的同时使用 Spring Cloud Stream。你将学到的知识可以应用于其他消息服务，例如
    Kafka，或者云提供商提供的其他服务，例如 Amazon Kinesis、Azure Event Hub 或 Google PubSub。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a reactive RESTful API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个反应式 RESTful API
- en: Using a reactive API client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反应式 API 客户端
- en: Testing reactive applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试反应式应用程序
- en: Connecting to PostgreSQL using Spring Data R2DBC
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data R2DBC 连接到 PostgreSQL
- en: Event-driven applications with Spring Cloud Stream and RabbitMQ
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 和 RabbitMQ 构建事件驱动应用程序
- en: Routing messages with Spring Cloud Stream and RabbitMQ
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 和 RabbitMQ 路由消息
- en: Error handling with Spring Cloud Stream
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 进行错误处理
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we’ll need a PostgreSQL server and a RabbitMQ server. The easiest
    way to run them on your computer is by using Docker. You can get Docker from the
    official site at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
    I will explain how to deploy each tool in its corresponding recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要一个 PostgreSQL 服务器和一个 RabbitMQ 服务器。在您的计算机上运行它们的最简单方法是使用 Docker。您可以从官方站点
    [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    获取 Docker。我将在相应的食谱中解释如何部署每个工具。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将要演示的所有食谱都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8).
- en: Creating a reactive RESTful API
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个反应式 RESTful API
- en: Spring Reactive is the Spring initiative that provides reactive programming
    features and capabilities that can be used in our Spring Boot applications. It
    is designed to support asynchronous and non-blocking programming. But what are
    asynchronous and non-blocking programming? To understand these concepts, it is
    better to start with the traditional model, the non-reactive programming model.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Reactive 是 Spring 的一项倡议，它提供了可以在我们的 Spring Boot 应用程序中使用的反应式编程特性和功能。它旨在支持异步和非阻塞编程。但异步和非阻塞编程是什么？为了理解这些概念，最好从传统的模型开始，即非反应式编程模型。
- en: In a traditional model, when a Spring Boot application receives a request, a
    dedicated thread processes that request. If that request requires communicating
    with another service, such as a database, the processing thread is blocked until
    it receives a response from the other service. The number of available threads
    is limited, so if your application requires high concurrency but mostly waits
    for its dependent services to finish, this synchronous blocking model may have
    limitations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统模型中，当 Spring Boot 应用程序收到一个请求时，一个专用的线程处理该请求。如果该请求需要与另一个服务通信，例如数据库，处理线程将阻塞，直到它从其他服务收到响应。可用的线程数量有限，因此如果您的应用程序需要高并发但主要等待其依赖服务完成，这种同步阻塞模型可能存在限制。
- en: In the reactive model, asynchronous and non-blocking programming reuses the
    threads across the concurrent requests and is not blocked by I/O operations, such
    as network calls or file operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式模型中，异步和非阻塞编程在并发请求之间重用线程，并且不会因 I/O 操作（如网络调用或文件操作）而阻塞。
- en: Reactive programming is particularly well suited for building applications requiring
    high concurrency and scalability, such as web applications that handle many concurrent
    connections or real-time data processing systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程特别适合构建需要高并发和可伸缩性的应用程序，例如处理许多并发连接的 Web 应用程序或实时数据处理系统。
- en: In this recipe, we will use Spring WebFlux to build a RESTful API using reactive
    programming. Spring WebFlux is a module within Spring that enables reactive programming
    for building web applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 Spring WebFlux 通过反应式编程构建一个 RESTful API。Spring WebFlux 是 Spring
    中的一个模块，它使构建 Web 应用程序时能够使用反应式编程。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe doesn’t have additional requirements. We will generate the project
    using the **Spring Initializr** tool and, once downloaded, you can make the changes
    with your favorite **Integrated Development Environment** (**IDE**) or editor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱没有额外的要求。我们将使用 **Spring Initializr** 工具生成项目，一旦下载，您可以使用您喜欢的 **集成开发环境**（**IDE**）或编辑器进行更改。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will create a RESTful API application. This time, we will
    create it using reactive programming, unlike the recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    Follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个 RESTful API 应用程序。这次，我们将使用反应式编程来创建它，而不是像 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020)
    中的食谱那样。按照以下步骤操作：
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), in the *Creating a RESTful
    API* recipe, except changing the following options:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [https://start.spring.io](https://start.spring.io)，并使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020)
    中 *创建 RESTful API* 食谱中相同的参数，除了以下选项需要更改：
- en: For `cards`
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `cards`
- en: For **Dependencies**, select **Spring** **Reactive Web**
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Spring** **Reactive Web**
- en: 'In the `cards` project, add a record named `Card`. Define the record as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cards`项目中，添加一个名为`Card`的记录。定义记录如下：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same folder, add a controller named `CardsController`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中，添加一个名为`CardsController`的控制器：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a method named `getCards` that retrieves all cards:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为`getCards`的方法，用于检索所有卡片：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And add another method to retrieve a card:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后添加另一个方法来检索卡片：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In WebFlux, `Flux<T>` is used to return a stream of objects, while `Mono<T>`
    is used to return a single object. In non-reactive programming, they would be
    the equivalents to returning `List<T>` for `Flux<T>` and `T` for `Mono<T>`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在WebFlux中，`Flux<T>`用于返回对象流，而`Mono<T>`用于返回单个对象。在非反应式编程中，它们将是返回`List<T>`的`Flux<T>`和返回`T`的`Mono<T>`的等价物。
- en: In this controller, `Flux<Card> getCards()` returns multiple objects of the
    `Card` type, and `Mono<Card> getCard` returns just one card.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此控制器中，`Flux<Card> getCards()`返回多个`Card`类型的对象，而`Mono<Card> getCard`仅返回一张卡片。
- en: 'Now, add an exception class named `SampleException`, implementing a new custom
    exception:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`SampleException`的异常类，实现一个新的自定义异常：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, add two more methods to `CardsController` to demonstrate how to implement
    error handling in WebFlux:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向`CardsController`添加两个更多方法，以演示如何在WebFlux中实现错误处理：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `getException` method always throws the exception, and `handleSampleException`
    handles exceptions of the `SampleException` type.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getException`方法总是抛出异常，而`handleSampleException`处理`SampleException`类型的异常。'
- en: 'Now, open a terminal in the root folder of the cards project and execute the
    following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在卡片项目的根目录中打开一个终端，并执行以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have the RESTful API server running.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在有了正在运行的RESTful API服务器。
- en: 'You can test the application by executing a request to `http://locahost:8080/cards`.
    You can use `curl` for this purpose:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过向`http://locahost:8080/cards`发送请求来测试应用程序。您可以使用`curl`来完成此操作：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also test how error handling works by requesting `http://localhost:8080/exception`.
    You will see that it will return an `HTTP` `400` result.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以通过请求`http://localhost:8080/exception`来测试错误处理的工作方式。您将看到它将返回一个`HTTP` `400`结果。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the same annotations as Spring Web to define the controllers in this
    recipe. However, the methods return the `Mono` and `Flux` types instead of traditional
    objects, indicating that the responses will be generated asynchronously. `Mono`
    and `Flux` are the core interfaces of the reactive programming model in WebFlux.
    `Mono` is used for asynchronous operations that produce at most one result, while
    `Flux` is used for asynchronous operations that return zero or more elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本菜谱中使用了与Spring Web相同的注解来定义控制器。然而，方法返回的是`Mono`和`Flux`类型，而不是传统对象，这表明响应将异步生成。`Mono`和`Flux`是WebFlux中反应式编程模型的核心接口。`Mono`用于最多产生一个结果的异步操作，而`Flux`用于返回零个或多个元素的异步操作。
- en: 'Reactive programming is centered around the concept of reactive streams. Reactive
    streams model asynchronous data flows with non-blocking backpressure. I mentioned
    some terms that may sound strange, so let me clarify them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程围绕反应流的概念。反应流使用非阻塞背压模型异步数据流。我提到了一些可能听起来很奇怪的概念，所以让我来澄清它们：
- en: '**Non-blocking**: This refers to operations related to I/O, such as making
    an HTTP request, that avoid blocking threads. This enables the execution of a
    large number of concurrent requests without a dedicated thread per request.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞**：这指的是与I/O相关的操作，例如发送HTTP请求，这些操作避免了线程阻塞。这使您能够在不为每个请求分配专用线程的情况下执行大量并发请求。'
- en: '**Backpressure**: This is a mechanism to ensure that data is only produced
    as fast as it can be consumed, preventing resource exhaustion. For instance, this
    situation may happen when a downstream component cannot keep up with the data
    emitted by an upstream component. WebFlux manages the backpressure automatically.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背压**：这是一种确保数据仅以可以消费的速度产生的机制，以防止资源耗尽。例如，当下游组件无法跟上上游组件发出的数据时，可能会发生这种情况。WebFlux自动管理背压。'
- en: There’s more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to the annotation-based programming model used in this recipe,
    WebFlux also supports the `cards` RESTful API with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本菜谱中使用的基于注解的编程模型之外，WebFlux还支持以下代码的`cards` RESTful API：
- en: 'First, create a class handling the logic:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个处理逻辑的类：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And another one to configure the application:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个用于配置应用程序的：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Annotation-based programming** is more like a traditional non-reactive programming
    model, while functional programming can be more expressive, especially for complex
    routing scenarios. The functional style is better suited for handling high concurrency
    and non-blocking scenarios because it naturally integrates with reactive programming.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于注解的编程**更类似于传统的非响应式编程模型，而函数式编程可以更加表达性，尤其是在复杂的路由场景中。函数式风格更适合处理高并发和非阻塞场景，因为它自然地与响应式编程集成。'
- en: Using annotation-based or functional is a matter of personal preference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于注解或函数式编程是个人偏好的问题。
- en: Using a reactive API client
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式API客户端
- en: We have a RESTful API, now it’s time to use it in a non-blocking fashion. We’ll
    create a reactive RESTful API that calls another RESTful API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个RESTful API，现在是时候以非阻塞的方式使用它了。我们将创建一个调用另一个RESTful API的响应式RESTful API。
- en: In this recipe, we’ll create a reactive application that consumes an API. We’ll
    learn how to use the reactive WebClient to perform requests to the target RESTful
    API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个消费API的响应式应用程序。我们将学习如何使用响应式WebClient对目标RESTful API执行请求。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll consume the application created in the *Creating a reactive
    RESTful API* recipe. If you haven’t completed it yet, I prepared a working version
    that you can use as a starting point for this recipe. You can find it on the book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-2/start` folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将消费在*创建一个响应式RESTful API*食谱中创建的应用程序。如果您还没有完成，我准备了一个可用的版本，您可以用它作为本食谱的起点。您可以在书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)中的`chapter8/recipe8-2/start`文件夹中找到它。
- en: You can run the target project and keep it for the rest of the recipe.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行目标项目，并在整个食谱中保留它。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll create an efficient consumer application for our RESTful API:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的RESTful API创建一个高效的消费者应用程序：
- en: 'First, we’ll create a new application using the Spring Boot Initializr tool.
    You can use the same options as in the *Creating a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), except changing the following options:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用Spring Boot Initializr工具创建一个新的应用程序。您可以使用与[*第1章*](B21646_01.xhtml#_idTextAnchor020)中*创建一个RESTful
    API*食谱中相同的选项，除了更改以下选项：
- en: For `consumer`
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`consumer`
- en: For **Dependencies**, select **Spring** **Reactive Web**
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**Spring Reactive Web**
- en: 'As we run the consumer application alongside the `cards` application, we’ll
    need to change the port where the application listens for requests. We’ll set
    `8090` as the server port. We will also create a configuration for the target
    football service URL. For that, open the `application.yml` file in the `resources`
    folder and set the following content:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在运行消费者应用程序的同时运行`cards`应用程序，我们需要更改应用程序监听请求的端口。我们将设置`8090`作为服务器端口。我们还将为目标足球服务URL创建一个配置。为此，打开`resources`文件夹中的`application.yml`文件，并设置以下内容：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, create a record named `Card` with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`Card`的记录，内容如下：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we’ll create a controller class named `ConsumerController` that will
    consume the target RESTful API. So, this controller will need a WebClient. For
    that, set the `ConsumerController` as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个名为`ConsumerController`的控制器类，该类将消费目标RESTful API。因此，这个控制器需要一个WebClient。为此，将`ConsumerController`设置如下：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The controller now has a WebClient that allows us to perform requests in a non-blocking
    fashion in our client application.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制器现在有一个WebClient，允许我们在客户端应用程序中以非阻塞的方式执行请求。
- en: 'Create a method to consume the operation from the other application that returns
    a stream of `Card` instances. For that, in `ConsumerController`, add the following
    method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来消费来自其他应用程序的操作，该操作返回`Card`实例的流。为此，在`ConsumerController`中添加以下方法：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a method to consume the method returning a single object by adding the
    following method to the `ConsumerController` class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来消费返回单个对象的方法，通过向`ConsumerController`类添加以下方法：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, create a method that manages different response codes from the remote
    server:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个方法来管理来自远程服务器的不同响应代码：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s run the consumer application now. When we perform requests to the client
    application, it will call the server RESTful API server application. Remember
    that we have the server RESTFul API server already running, as explained in the
    *Getting ready* section. Open a terminal in the root folder of the `consumer`
    project and execute the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行消费者应用程序。当我们向客户端应用程序发出请求时，它将调用服务器RESTful API应用程序。记住，我们已经按照“准备就绪”部分中的说明启动了服务器RESTful
    API服务器应用程序。在`consumer`项目的根目录中打开一个终端并执行以下操作：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, test the `consumer` application. Remember that it listens on port `8090`,
    and the server application listens on port `8080`. In the terminal, execute the
    following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试`consumer`应用程序。记住它监听端口`8090`，而服务器应用程序监听端口`8080`。在终端中执行以下命令：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will return `Remote Server return 404`. The `consumer` application tried
    to call a method that does not exist in the server RESTful API server application.
    The consumer application handles the HTTP response codes from the server, in this
    case, `HttpStatus.NOT_FOUND` to return the final response message, which is `Remote
    Server` `return 404`.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将返回`Remote Server return 404`。消费者应用程序尝试调用服务器RESTful API服务器应用程序中不存在的方法。消费者应用程序处理来自服务器的HTTP响应代码，在这种情况下，`HttpStatus.NOT_FOUND`以返回最终响应消息，即`Remote
    Server` `return 404`。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we consumed a RESTful API that is implemented using reactive
    technologies, but from the consumer’s point of view, it doesn’t matter. We can
    consume any RESTful API, regardless of the internal implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们消费了一个使用响应式技术实现的RESTful API，但从消费者的角度来看，这并不重要。我们可以消费任何RESTful API，无论其内部实现如何。
- en: What’s important is that as we take advantage of a non-blocking client, the
    consumer application will benefit if it’s also reactive. When we request against
    the consumer application, it will perform another request to the `cards` application.
    As we use a reactive client in the `consumer` application, it won’t block a thread
    while the `cards` application responds, making that thread available to process
    other requests. This way, the application can manage higher concurrency than traditional
    blocking threads applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当我们利用非阻塞客户端时，如果消费者应用程序也是响应式的，它将从中受益。当我们向消费者应用程序发出请求时，它将对`cards`应用程序发出另一个请求。由于我们在`consumer`应用程序中使用响应式客户端，它不会在`cards`应用程序响应时阻塞线程，从而使该线程可用于处理其他请求。这样，应用程序可以管理比传统阻塞线程应用程序更高的并发性。
- en: Testing reactive applications
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试响应式应用程序
- en: As with non-reactive Spring Boot applications, we want to automate the testing
    of our reactive applications, and Spring Boot provides excellent support for testing
    such scenarios.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与非响应式Spring Boot应用程序一样，我们希望自动化测试我们的响应式应用程序，Spring Boot为这些场景提供了出色的支持。
- en: In this recipe, we’ll learn how to create the tests using the components provided
    by default by Spring Boot when we add the **Spring Reactive** **Web** starter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用Spring Boot在添加**Spring Reactive** **Web**启动器时默认提供的组件来创建测试。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we’ll create the tests for the projects used in the *Using a
    reactive API client* recipe. If you haven’t completed that recipe yet, you can
    use the completed version that I prepared as a starting point for this recipe.
    You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-3/start` folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将为“使用响应式API客户端”配方中使用的项目创建测试。如果你还没有完成那个配方，你可以使用我准备的完成版本作为这个配方的起点。你可以在书的GitHub仓库中找到它，在`chapter8/recipe8-3/start`文件夹中。[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We like robust and reliable applications. We’ll do it with our Reactive applications:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢健壮和可靠的应用程序。我们将使用我们的响应式应用程序来实现这一点：
- en: 'As the applications from the *Using a reactive API client* recipe were created
    with the Spring Boot Initializr tool, just by adding Spring Reactive Web starter
    the testing dependencies are already included. You can check that the `pom.xml`
    file contains the following dependencies:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于从“使用响应式API客户端”配方创建的应用程序使用了Spring Boot Initializr工具，只需添加Spring Reactive Web启动器，测试依赖项就已经包含在内了。你可以检查`pom.xml`文件是否包含以下依赖项：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we’ll start the tests with the `cards` application. Create a new test
    class named `CardsControllerTest`. Remember, it should be created under the `test`
    folder; you can create it in the `src/test/java/com/packt/cards` folder:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`cards`应用程序启动测试。创建一个名为`CardsControllerTest`的新测试类。记住，它应该创建在`test`文件夹下；你可以在`src/test/java/com/packt/cards`文件夹中创建它：
- en: 'The test class should be annotated with `@WebFluxTest`:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类应该使用`@WebFluxTest`注解：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we’ll inject a `WebTestClient` field. For that, annotate the new field
    with `@Autowired`:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将注入一个`WebTestClient`字段。为此，使用`@Autowired`注解新字段：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can use the `webTestClient` field to emulate the calls to the reactive
    RESTful API. For instance, let’s create a test for the `/cards` path that returns
    a list of type `Card`. For that, create a new method annotated with `@Test`:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`webTestClient`字段来模拟对反应式RESTful API的调用。例如，让我们创建一个测试`/cards`路径，它返回一个类型为`Card`的列表。为此，创建一个使用`@Test`注解的新方法：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s test the `/cards/exception` path. For learning purposes, this path always
    returns `a 404 code`, a bad request result; and the body is of type `ProblemDetail`.
    The test method may look as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们测试`/cards/exception`路径。出于学习目的，此路径始终返回`404`代码，一个错误请求结果；并且正文是`ProblemDetail`类型。测试方法可能如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we’ll create the tests for the `consumer` application. As we want to
    test this application independently of the `cards` application, we’ll need to
    mock the `cards` application server. As we learned in the *Mocking a RESTful API*
    recipe, in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), we’ll use the WireMock
    library. For that, open the `pom.xml` file of the project `consumer` and add the
    following dependency:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为`consumer`应用程序创建测试。由于我们想要独立于`cards`应用程序测试此应用程序，我们需要模拟`cards`应用程序服务器。正如我们在[*第1章*](B21646_01.xhtml#_idTextAnchor020)中学习的*模拟RESTful
    API*食谱中，我们将使用WireMock库。为此，打开项目`consumer`的`pom.xml`文件并添加以下依赖项：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have all the dependencies, we’ll create a new test class named
    `ConsumerControllerTest` and prepare it before writing the tests:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了所有依赖项，我们将创建一个新的测试类，命名为`ConsumerControllerTest`，并在编写测试之前对其进行准备：
- en: 'First, annotate the class with `@SpringBootTest` and set a few configuration
    options as follows:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`@SpringBootTest`注解类并设置以下一些配置选项：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we set a new class in the `classes` field that doesn’t exist yet,
    `ConsumerControllerTests.Config`. It’s used to configure the MockServer, as you’ll
    see soon.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在`classes`字段中设置了一个新类，它目前还不存在，`ConsumerControllerTests.Config`。它用于配置MockServer，正如你很快就会看到的。
- en: 'Next, we’ll need to set up the WireMock server. For that, we’ll create a configuration
    subclass class named `Config`; it will define a `WireMockServer` bean:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置WireMock服务器。为此，我们将创建一个名为`Config`的配置子类，它将定义一个`WireMockServer`bean：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we need to configure the URI of the new remote server for the reactive
    WebClient. We need to set the `footballservice.url` application context variable.
    To perform this dynamic configuration, we’ll use the `@DynamicPropertySource`
    annotation. For that, define a static method in the `ConsumerControllerTests`
    class:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要配置用于reactive WebClient的新远程服务器的URI。我们需要设置`footballservice.url`应用程序上下文变量。为了执行此动态配置，我们将使用`@DynamicPropertySource`注解。为此，在`ConsumerControllerTests`类中定义一个静态方法：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To complete the test preparation, we’ll inject `WebTestClient` and `WireMockServer`,
    which we’ll use in the tests. For that, define the fields with the `@``Autowired`
    annotation:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成测试准备，我们将注入`WebTestClient`和`WireMockServer`，我们将在测试中使用。为此，使用`@Autowired`注解定义字段：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can write the tests now. For instance, we’ll create a test to get the cards:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以编写测试了。例如，我们将创建一个获取卡片的测试：
- en: 'We can name it `getCards`:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将其命名为`getCards`：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we’ll arrange what the mocked cards server will return. For that, we’ll
    mock a small set of results for learning purposes:'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将安排模拟卡片服务器将返回的内容。为此，我们将模拟一组小的结果以供学习：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can perform the request using `webTestClient` and validate the results:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`webTestClient`执行请求并验证结果：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can write tests for the rest of the application’s features. I created some
    sample tests, which you can find in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-3/end` folder.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以为应用程序的其余功能编写测试。我创建了一些示例测试，你可以在书的GitHub仓库中找到它们，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在`chapter8/recipe8-3/end`文件夹中。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the `@WebFluxTest` annotation, we can define test classes focusing only
    on WebFlux-related components. This means that it will disable the configuration
    of all components save for those relevant to WebFlux. For instance, it will configure
    the classes annotated with `@Controller` or `@RestController`, but it won’t configure
    classes annotated with `@Service`. With that, Spring Boot can inject `WebTestClient`,
    which we can use to perform requests to our application server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@WebFluxTest`注解，我们可以定义仅关注WebFlux相关组件的测试类。这意味着它将禁用所有组件的配置，除了与WebFlux相关的组件。例如，它将配置带有`@Controller`或`@RestController`注解的类，但不会配置带有`@Service`注解的类。有了这个，Spring
    Boot可以注入`WebTestClient`，我们可以用它来对我们的应用程序服务器执行请求。
- en: In the consumer application, we need to mock the `cards` service. I won’t go
    deeply into the details, as the mechanism is the same as explained in the *Mocking
    a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020). We used
    a configuration subclass annotated with `@TestConfiguration`. This annotation
    allows the configuration of beans that can be used alongside the tests. In our
    case, we just needed `WireMockServer`. Then, we dynamically configured the URI
    of the mocked server using the `@``DynamicPropertySource` annotation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者应用程序中，我们需要模拟`cards`服务。我不会深入细节，因为机制与在[*第一章*](B21646_01.xhtml#_idTextAnchor020)中解释的`Mocking
    a RESTful API`菜谱中相同。我们使用了一个带有`@TestConfiguration`注解的配置子类。这个注解允许配置可以与测试一起使用的bean。在我们的例子中，我们只需要`WireMockServer`。然后，我们使用`@DynamicPropertySource`注解动态配置模拟服务器的URI。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To reference the `Config` class, we used `ConsumerControllerTests.Config` instead
    of just `Config`. The reason for this is that it’s a subclass of the `ConsumerControllerTests`
    class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用`Config`类，我们使用了`ConsumerControllerTests.Config`而不是仅仅`Config`。这样做的原因是它是`ConsumerControllerTests`类的一个子类。
- en: We used the `webEnvironment` field, assigning `SpringBootTest.WebEnvironment.RANDOM_PORT`.
    This means that the test will host the application as a service on a random port.
    We used that to avoid port collisions with the remote server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`webEnvironment`字段，将`SpringBootTest.WebEnvironment.RANDOM_PORT`赋值给它。这意味着测试将以服务的形式在随机端口上托管应用程序。我们使用这个选项是为了避免与远程服务器发生端口冲突。
- en: Connecting to PostgreSQL using Spring Data R2DBC
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data R2DBC连接到PostgreSQL
- en: Using a Reactive database driver makes sense as we need to connect our Reactive
    application to PostgreSQL. This means the application is not blocked when it makes
    requests to the database. There is a Java specification to integrate SQL databases
    using reactive drivers named **R2DBC**. Spring Framework supports R2DBC with Spring
    Data R2DBC, which is part of the larger Spring Data family.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Reactive数据库驱动程序是有意义的，因为我们需要将我们的Reactive应用程序连接到PostgreSQL。这意味着当应用程序向数据库发出请求时，应用程序不会被阻塞。有一个Java规范，名为**R2DBC**，用于使用反应式驱动程序集成SQL数据库。Spring框架通过Spring
    Data R2DBC支持R2DBC，它是更大的Spring Data家族的一部分。
- en: Spring Data R2DBC applies familiar Spring abstractions for R2DBC. You may use
    `R2dbcEntityTemplate`, running statements using the Criteria API and Reactive
    Repositories, among other features.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data R2DBC将R2DBC的熟悉Spring抽象应用于其中。您可以使用`R2dbcEntityTemplate`，使用Criteria
    API和Reactive Repositories运行语句，以及其他功能。
- en: In this recipe, we’ll learn how to connect to PostgreSQL using Reactive Repositories
    and some of the differences between Reactive and non-reactive Repositories. We’ll
    also learn how to configure Flyway for database migrations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Reactive Repositories连接到PostgreSQL，以及Reactive和非Reactive Repositories之间的一些区别。我们还将学习如何配置Flyway进行数据库迁移。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we’ll need a PostgreSQL database. You can use the instructions
    from the *Getting ready* section of the *Connecting your application to PostgreSQL*
    recipe, in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203). Once you have Docker
    installed, as explained in the aforementioned recipe, you can execute the following
    command to run a PostgreSQL server on Docker:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要一个PostgreSQL数据库。您可以使用[*第五章*](B21646_05.xhtml#_idTextAnchor203)中“Connecting
    your application to PostgreSQL”菜谱的“准备工作”部分的说明。一旦您安装了Docker，如上述菜谱中所述，您可以使用以下命令在Docker上运行PostgreSQL服务器：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I also prepared a starting project for this recipe that contains the classes
    that we’ll use as data entities to map with the database tables and the database
    initialization scripts that we’ll use in the *There’s more* section for the Flyway
    migration. You can find the project in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-4/start` folder.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我还为此菜谱准备了一个起始项目，其中包含我们将用作数据实体以映射到数据库表的类，以及我们在 *There’s more* 部分用于 Flyway 迁移的数据库初始化脚本。你可以在本书的
    GitHub 仓库中找到该项目，位于 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在
    `chapter8/recipe8-4/start` 文件夹中。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll configure an application to connect to use PostgreSQL. Let’s go Reactive:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置一个应用程序以连接到 PostgreSQL。让我们变得反应式：
- en: 'First, we’ll ensure we have all the required dependencies. For that, open the
    project’s `pom.xml` file and add the following dependencies:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将确保我们有所有必需的依赖项。为此，打开项目的 `pom.xml` 文件并添加以下依赖项：
- en: '`org.springframework.boot:spring-boot-starter-webflux`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-webflux`'
- en: '`org.springframework.boot:spring-boot-starter-test`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-test`'
- en: '`io.projectreactor:reactor-test`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.projectreactor:reactor-test`'
- en: '`org.springframework.boot:spring-boot-starter-data-r2dbc`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-data-r2dbc`'
- en: '`org.postgresql:r2dbc-postgresql`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.postgresql:r2dbc-postgresql`'
- en: 'Next, we’ll configure the connection to the database using the R2DBC driver.
    For that, open the `application.yml` file and add the following configuration:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 R2DBC 驱动程序配置数据库连接。为此，打开 `application.yml` 文件并添加以下配置：
- en: '[PRE32]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the database URL doesn’t start with `jdbc:` but with `r2dbc:`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，数据库 URL 不以 `jdbc:` 开头，而是以 `r2dbc:` 开头。
- en: 'Then, we’ll configure the entity classes we want to map to the database. These
    classes are in the `repo` folder. To prepare the classes, follow these steps for
    each of them:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将配置我们想要映射到数据库的实体类。这些类位于 `repo` 文件夹中。为了准备这些类，为每个类遵循以下步骤：
- en: Add the `@Table` annotation to the class. You can set the name as it’s defined
    on the database.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@Table` 注解添加到类中。你可以将其名称设置为在数据库中定义的名称。
- en: Add the `@Id` annotation to the identifier field. I named this field `Id` in
    all entity classes.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@Id` 注解添加到标识字段。我在所有实体类中将此字段命名为 `Id`。
- en: 'You can see the `CardEntity` class as an example here:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里将 `CardEntity` 类视为一个例子：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can create the repositories for our entities. For instance, for the `CardEntity`,
    we’ll create the `CardsRepository` as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为我们的实体创建存储库。例如，对于 `CardEntity`，我们将创建 `CardsRepository` 如下：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can do the same for the rest of the entities.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以为其他实体做同样的操作。
- en: 'We’ll add a method to `PlayersRepository` to find a player by their name. For
    that, just add the following method definition to the `PlayersRepository` interface:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `PlayersRepository` 中添加一个方法来通过名称查找玩家。为此，只需将以下方法定义添加到 `PlayersRepository`
    接口：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s create a new service to manage players. You can name it `PlayersService`,
    and as it uses `PlayersRepository`, we’ll add it as a parameter to the constructor,
    and we’ll let Spring Boot do its magic to inject it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的服务来管理玩家。你可以将其命名为 `PlayersService`，因为它使用 `PlayersRepository`，我们将将其作为参数添加到构造函数中，并让
    Spring Boot 做其魔法注入：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we’ll create a couple of methods using the repository. For instance, one
    method to get a player by the ID, and another one to get the player by the name:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用存储库创建几个方法。例如，一个通过 ID 获取玩家的方法，另一个通过名称获取玩家的方法：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that both methods use a class named `PlayerMapper`. I provided this class
    as part of the starting project to create the mappings between the entities and
    the objects returned by the application.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这两种方法都使用了一个名为 `PlayerMapper` 的类。我作为起始项目的一部分提供了这个类，用于在实体和应用程序返回的对象之间创建映射。
- en: Let’s make something more complex now. We’ll retrieve a card and its related
    data, that is, `Album`, if it is already assigned, and `Player` in the card.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来创建一个更复杂的东西。我们将检索一张卡片及其相关数据，即如果已经分配，则包括 `Album`，以及卡片中的 `Player`。
- en: 'Let’s create a new service class named `CardsService`. This service requires
    `CardsRepository`, `PlayersRepository`, and `AlbumsRepository`. We’ll create a
    constructor with an argument of each type:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `CardsService` 的新服务类。这个服务需要 `CardsRepository`、`PlayersRepository`
    和 `AlbumsRepository`。我们将创建一个带有每种类型参数的构造函数：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, add a method to get an item of type `Card`:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个获取类型为 `Card` 的项的方法：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see in the `getCard` method, there is a reference to `retrieveRelations`.
    The `retrieveRelations` method retrieves `Player` from the database and `Album`
    in case it’s defined. Of course, we’ll do all this using a reactive approach:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在`getCard`方法中看到的，有一个对`retrieveRelations`方法的引用。`retrieveRelations`方法从数据库中检索`Player`，如果定义了，还会检索`Album`。当然，我们将使用响应式方法来完成所有这些操作：
- en: '[PRE40]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can implement the Reactive RESTful endpoints to expose this functionality,
    as explained in the *Creating a Reactive RESTful API* recipe in this chapter.
    I prepared some examples that you can find in the book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)
    in the `chapter8/recipe8-4/end` folder. I recommend you check out the *There’s
    more* section, as it includes Flyway to initialize the database and some tests
    using `Testcontainers`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以实现响应式RESTful端点来公开此功能，如本章中*创建响应式RESTful API*配方中所述。我在本书的GitHub存储库中准备了一些示例，您可以在`chapter8/recipe8-4/end`文件夹中找到，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。我建议您查看*还有更多*部分，因为它包括Flyway来初始化数据库和一些使用`Testcontainers`的测试。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Apparently, the Reactive entities and `ReactiveCrudRepository` are very similar
    to their non-reactive counterparts. `ReactiveCrudRepository` provides the same
    base methods with basic functionality such as `findById` and `save`, but there
    are important differences:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，响应式实体和`ReactiveCrudRepository`与它们的非响应式对应物非常相似。`ReactiveCrudRepository`提供了相同的基本方法，例如`findById`和`save`，但存在一些重要差异：
- en: The Reactive repositories don’t manage relations between entities. For that
    reason, we haven’t defined any `@OneToMany` or `@ManyToOne` fields. The relations
    between entities should be managed explicitly in our application, as we did in
    the `getCard` and `retrieveRelations` methods.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式仓库不管理实体之间的关系。因此，我们没有定义任何`@OneToMany`或`@ManyToOne`字段。实体之间的关系应该在我们的应用程序中显式管理，就像我们在`getCard`和`retrieveRelations`方法中所做的那样。
- en: The reactive repositories allow you to define methods following the same naming
    convention as the non-reactive repositories but returning `Mono` for single results
    and `Flux` for multiple results. These methods are transformed into queries in
    the database. You can find more details about the naming convention on the R2DBC
    web page at [https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html](https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式仓库允许您定义遵循与非响应式仓库相同命名约定的方法，但返回`Mono`用于单个结果和`Flux`用于多个结果。这些方法在数据库中转换为查询。您可以在R2DBC网页上找到有关命名约定的更多详细信息，网址为[https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html](https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html)。
- en: We haven’t used it in this recipe, but it’s possible to use the `@Query` annotation
    and provide an SQL query. It is a native query; JPQL is not supported.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这个配方中没有使用它，但可以使用`@Query`注解并提供一个SQL查询。这是一个原生查询；不支持JPQL。
- en: The reactive programming model leverages the request’s asynchronous and non-blocking
    process. Note that in the `getCard` method, the album and the player are retrieved
    asynchronously and simultaneously when the card is found. Parallelism is achieved
    using the `Mono.zip` method, which allows several non-blocking processes to be
    executed simultaneously.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程模型利用请求的异步和非阻塞过程。请注意，在`getCard`方法中，当找到卡片时，专辑和玩家会异步且同时检索。通过使用`Mono.zip`方法实现并行，该方法允许同时执行多个非阻塞过程。
- en: There’s more...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Flyway is not directly supported with R2DBC drivers, but it can be used with
    some adjustments. Let’s see how to do it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway不直接支持R2DBC驱动程序，但可以通过一些调整来使用。让我们看看如何操作：
- en: 'First, you must add the Flyway dependency in your `pom.xml` file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须在您的`pom.xml`文件中添加Flyway依赖项：
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we want to validate the database migration automatically, we’ll also include
    the `Testcontainers` support. For `Testcontainers`, there are no specific reactive
    adjustments to make.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望自动验证数据库迁移，我们还将包括`Testcontainers`支持。对于`Testcontainers`，无需进行任何特定的响应式调整。
- en: '[PRE42]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we’ll need to configure the connection for Flyway explicitly. The reason
    for this is that Flyway only supports the JDBC driver; for that reason, we’ll
    need to specify the `jdbc:` version of the database URL. This configuration can
    be applied in the `application.yml` file. It should look like this:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要明确配置 Flyway 的连接。这样做的原因是 Flyway 只支持 JDBC 驱动程序；因此，我们需要指定数据库 URL 的 `jdbc:`
    版本。这种配置可以在 `application.yml` 文件中应用。它应该看起来像这样：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can set this configuration in a test supporting `Testcontainers`. Let’s
    see what the class to test the `PlayersService` may look like:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在支持 `Testcontainers` 的测试中设置此配置。让我们看看测试 `PlayersService` 的类可能看起来像什么：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the context configuration gets the database configuration from the
    PostgreSQL test container. As `PostgreSQLContainer` only returns the JDBC version
    of the URL, we replaced the `jdbc:` string with `r2dbc:` for the R2DBC driver,
    while keeping the JDBC URL version for Flyway.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上下文配置从 PostgreSQL 测试容器获取数据库配置。由于 `PostgreSQLContainer` 只返回 URL 的 JDBC 版本，我们将
    `jdbc:` 字符串替换为 `r2dbc:` 以用于 R2DBC 驱动程序，同时保留 Flyway 的 JDBC URL 版本。
- en: The rest is just standard Flyway configuration. The sample project provides
    the database initialization scripts in the default folder at `resources/db/migration`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的都是标准的 Flyway 配置。示例项目在 `resources/db/migration` 默认文件夹中提供了数据库初始化脚本。
- en: Event-driven applications with Spring Cloud Stream and RabbitMQ
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 和 RabbitMQ 的事件驱动应用程序
- en: We want to enhance the experience of our football application by using facts
    from a match, such as a goal or a red card. We can use the information to prepare
    a timeline with all events happening during the match or update the match score.
    We foresee that in the future, we can use this information for other features,
    such as preparing player statistics in real time or creating a player’s ranking
    using the statistics.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过使用比赛中的事实（如进球或红牌）来增强我们的足球应用程序的体验。我们可以使用这些信息来准备包含比赛期间发生的所有事件的时序表或更新比赛得分。我们预计将来可以使用这些信息来实现其他功能，例如实时准备球员统计数据或使用统计数据创建球员排名。
- en: 'For this scenario, we can apply an **event-driven architecture** design. This
    type of design consists of detecting, processing, and reacting to real-time events
    as they happen. Usually, there are two types of components: the event producers
    and the event consumers, and they are loosely coupled. Spring Cloud Stream is
    the Spring project that supports event-driven applications that communicate using
    a shared messaging system, such as Kafka or RabbitMQ.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景，我们可以应用一个**事件驱动架构**设计。这种设计包括检测、处理和实时发生的事件的反应。通常有两种类型的组件：事件生产者和事件消费者，它们是松散耦合的。Spring
    Cloud Stream 是支持使用共享消息系统（如 Kafka 或 RabbitMQ）进行通信的事件驱动应用程序的 Spring 项目。
- en: In this recipe, we’ll learn how to use Spring Cloud Stream to create one application
    that emits football match events and one that is subscribed to those events. We’ll
    also learn how to configure the applications to use RabbitMQ as the messaging
    system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 Spring Cloud Stream 创建一个应用程序，该应用程序可以发出足球比赛事件，并创建一个订阅这些事件的另一个应用程序。我们还将学习如何配置应用程序以使用
    RabbitMQ 作为消息系统。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we’ll use RabbitMQ. You can install it on your computer by
    following the instructions of the official website at [https://www.rabbitmq.com/docs/download](https://www.rabbitmq.com/docs/download).
    I recommend running it on Docker locally. With the following command in your terminal,
    you can download and run RabbitMQ on Docker:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 RabbitMQ。您可以通过遵循官方网站 [https://www.rabbitmq.com/docs/download](https://www.rabbitmq.com/docs/download)
    上的说明在您的计算机上安装它。我建议在本地使用 Docker 运行它。在您的终端中输入以下命令，您可以在 Docker 上下载并运行 RabbitMQ：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The image used includes the management portal. You can access it at `http://localhost:15672`
    using `packt` as username and password.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的镜像包括管理门户。您可以使用 `packt` 作为用户名和密码，在 `http://localhost:15672` 访问它。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll create two applications and we’ll connect them using RabbitMQ. We’ll
    use the power of Spring Cloud Stream to make it possible:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个应用程序，并将它们通过 RabbitMQ 连接起来。我们将利用 Spring Cloud Stream 的力量来实现这一点：
- en: 'We’ll start by creating two applications using the Spring Boot Initializr tool:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先使用 Spring Boot Initializr 工具创建两个应用程序：
- en: '`matches`: This application will produce the match events and will publish
    them on RabbitMQ'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matches`：此应用程序将产生比赛事件，并将它们发布到 RabbitMQ'
- en: '`timeline`: This application will process all events published to create a
    match timeline'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeline`：此应用程序将处理发布到所有事件以创建比赛时间线'
- en: 'For that, repeat this step for each application. Open [https://start.spring.io](https://start.spring.io)
    in your browser and use the same options as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    in *Creating a RESTful API*, save for the following options:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了做到这一点，为每个应用程序重复此步骤。在浏览器中打开[https://start.spring.io](https://start.spring.io)，并使用与*第1章*中在*创建RESTful
    API*中相同的选项，除了以下选项：
- en: For `matches` or `timeline`.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`matches`或`timeline`。
- en: For **Dependencies**, don’t select any starter
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，不要选择任何启动器
- en: 'We’ll add the following dependency to the three applications:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将向三个应用程序添加以下依赖项：
- en: '[PRE46]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step will be configuring the `matches` application to emit events:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将是配置`matches`应用程序以发出事件：
- en: 'First, we’ll define a record that will be used to represent the match events:'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个将用于表示比赛事件的记录：
- en: '[PRE47]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can create a nested builder class to facilitate the manipulation. I’m not
    including the builder code in this sample for brevity, but you can find an implementation
    on the book’s GitHub repository.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个嵌套的构建器类来简化操作。为了简洁起见，我没有在这个示例中包含构建器代码，但您可以在书籍的GitHub存储库中找到实现。
- en: 'Next, we’ll define a bean in the `MatchesApplication` class that configures
    `Supplier<Message<MatchEvent>>`:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`MatchesApplication`类中定义一个bean，该bean配置`Supplier<Message<MatchEvent>>`：
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This bean generates the `MatchEvent` messages with a random value assigned to
    the `type` field.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此bean生成带有随机分配给`type`字段的`MatchEvent`消息。
- en: 'Finally, we’ll configure the application to use RabbitMQ. We’ll bind the bean
    we just created to a RabbitMQ exchange named `match-events-topic` and configure
    the binding to map the *routing key* message property to the `eventType` message
    header. For that, open the `application.yml` file and set the following configuration:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将配置应用程序以使用RabbitMQ。我们将把刚刚创建的bean绑定到名为`match-events-topic`的RabbitMQ交换机，并配置绑定以将*路由键*消息属性映射到`eventType`消息头。为此，打开`application.yml`文件并设置以下配置：
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Check that the `spring.rabbitmq` properties are aligned with the parameters
    used to start the RabbitMQ container in the *Getting ready* section. Verify that
    the binding name matches the method that exposes the bean.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在*准备就绪*部分中使用的`spring.rabbitmq`属性与启动RabbitMQ容器的参数一致。验证绑定名称是否与暴露bean的方法匹配。
- en: Now, the `matches` application is ready to start producing events. You can start
    it now.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，`matches`应用程序已准备好开始产生事件。您现在可以启动它。
- en: 'Next, we’ll configure the `timeline` application. This application will consume
    all events produced by the `matches` application. For that, do the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置`timeline`应用程序。该应用程序将消费`matches`应用程序产生的所有事件。为此，请执行以下操作：
- en: 'First, create a `Consumer<MatchEvent>` bean. Open the `TimelineApplication`
    class and add the following code:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`Consumer<MatchEvent>` bean。打开`TimelineApplication`类并添加以下代码：
- en: '[PRE50]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For the sake of clarity, we haven’t created a library with shared code across
    the three applications. Therefore, you will need to define the `MatchEvent` record
    in this project, too.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们没有创建一个包含三个应用程序之间共享代码的库。因此，您还需要在这个项目中定义`MatchEvent`记录。
- en: 'For this project, we only need to configure the RabbitMQ configuration to bind
    an input queue named `timeline` to the `match-events-topic` exchange created in
    *Step 2* and the `processMatchEvent` function to the input queue. That can be
    done by configuring the `application.yml` file as follows:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个项目，我们只需要配置RabbitMQ配置，将名为`timeline`的输入队列绑定到在*步骤2*中创建的`match-events-topic`交换机，并将`processMatchEvent`函数绑定到输入队列。这可以通过以下方式配置`application.yml`文件：
- en: '[PRE51]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The timeline application is now ready to process messages. Just run the application,
    and it will start processing messages. You will see the messages when the events
    are processed in the console.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 时间线应用程序现在已准备好处理消息。只需运行应用程序，它就会开始处理消息。您将在控制台看到事件处理时的消息。
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `spring-cloud-stream-binder-rabbit` dependency includes the Spring Cloud
    Stream starter, with specific bindings for RabbitMQ. The Spring Cloud Stream starter
    provides the necessary abstractions to create event-driven applications with no
    specific references to the underlying messaging technology. In our application,
    we haven’t used any explicit RabbitMQ component in the code. For that reason,
    we could switch to another messaging system, such as Kafka, just by changing the
    dependencies and the configuration, but with no code changes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-cloud-stream-binder-rabbit` 依赖项包括 Spring Cloud Stream 启动器，并为 RabbitMQ
    提供特定的绑定。Spring Cloud Stream 启动器提供了创建无特定底层消息技术引用的事件驱动应用程序所需的抽象。在我们的应用程序中，我们没有在代码中使用任何显式的
    RabbitMQ 组件。因此，我们只需更改依赖项和配置，就可以切换到另一个消息系统，例如 Kafka，而无需更改代码。'
- en: 'Spring Cloud Stream allows binding a `Supplier` function registered as a bean
    to a given destination, in our case, `match-events-topic`. That means that the
    messages produced by the `Supplier` function are sent to that destination. We
    use `spring-cloud-stream-binder-rabbit`, which includes the bindings to RabbitMQ.
    When we start the `matches` application, RabbitMQ creates an **exchange**. An
    exchange is an intermediary component between the producer and the consumer applications.
    Producer applications never send messages directly to consumers. Then, depending
    on the type of exchange, the messages are sent to one or multiple queues or discarded.
    When we started the matches application and the timeline application was not running
    yet, the exchange was created in RabbitMQ, but as there were no subscribers, the
    messages were discarded. In the **RabbitMQ** portal, you would see something like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 允许将注册为 bean 的 `Supplier` 函数绑定到给定的目的地，在我们的例子中是 `match-events-topic`。这意味着
    `Supplier` 函数产生的消息将被发送到该目的地。我们使用 `spring-cloud-stream-binder-rabbit`，它包括绑定到 RabbitMQ
    的绑定。当我们启动 `matches` 应用程序时，RabbitMQ 创建了一个 **交换机**。交换机是生产者和消费者应用程序之间的中介组件。生产者应用程序永远不会直接向消费者发送消息。然后，根据交换机的类型，消息被发送到一个或多个队列或被丢弃。当我们启动
    `matches` 应用程序而 `timeline` 应用程序尚未运行时，交换机在 RabbitMQ 中创建，但由于没有订阅者，消息被丢弃。在 **RabbitMQ**
    门户中，您会看到如下内容：
- en: '![Figure 8.1: match-events-topic in RabbitMQ](img/B21646_08_1.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：RabbitMQ 中的 match-events-topic](img/B21646_08_1.jpg)'
- en: 'Figure 8.1: match-events-topic in RabbitMQ'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：RabbitMQ 中的 match-events-topic
- en: As you can see, the application calls the `Supplier` function once every second,
    which is the default configuration in Spring Cloud Stream. Still, the messages
    are discarded as it’s not defined yet how to route the messages. Indeed, if you
    check the **Queues and Streams** tab, you will see that there are no queues defined.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用程序每秒调用一次 `Supplier` 函数，这是 Spring Cloud Stream 的默认配置。尽管如此，由于尚未定义如何路由消息，因此消息被丢弃。实际上，如果您检查
    **队列和流** 选项卡，您将看到没有定义任何队列。
- en: 'In the `timeline` application, we configured the binding between the `match-event-topic`
    exchange and the destination queue where the messages are forwarded. It’s defined
    in the `spring.cloud.stream.binding.input` properties. We specified `match-events-topic`
    with the `destination` property, and we defined the target queue with the `group`
    property. Then, with the `spring.cloud.stream.function.bindings` properties, we
    defined the link between that queue and the function registered as a bean to process
    the messages. After starting the `timeline` application, you will see that `match-events-topic`
    has a binding that connects the `match-events-topic` exchange to a queue named
    `match-events-topic.timeline`. You can check that in RabbitMQ. It should look
    like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `timeline` 应用程序中，我们配置了 `match-event-topic` 交换机和消息被转发到的目标队列之间的绑定。它定义在 `spring.cloud.stream.binding.input`
    属性中。我们使用 `destination` 属性指定了 `match-events-topic`，并使用 `group` 属性定义了目标队列。然后，通过
    `spring.cloud.stream.function.bindings` 属性，我们定义了该队列与注册为 bean 以处理消息的函数之间的链接。启动
    `timeline` 应用程序后，您将看到 `match-events-topic` 有一个绑定，它将 `match-events-topic` 交换机连接到名为
    `match-events-topic.timeline` 的队列。您可以在 RabbitMQ 中检查这一点。它应该看起来像这样：
- en: '![Figure 8.2: Timeline queue bound to match-events-topic](img/B21646_08_2.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：绑定到 match-events-topic 的 Timeline 队列](img/B21646_08_2.jpg)'
- en: 'Figure 8.2: Timeline queue bound to match-events-topic'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：绑定到 match-events-topic 的 Timeline 队列
- en: As you can see in the RabbitMQ portal, Spring Cloud Stream created the exchange
    and the queue and configured the binding to route all messages to the queue.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 RabbitMQ 门户中看到的那样，Spring Cloud Stream 创建了交换机和队列，并配置了绑定以将所有消息路由到队列。
- en: There’s more...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used the functional approach to send messages, letting the
    Spring Stream Cloud invoke the `Supplier` function to generate messages. In many
    scenarios, we must decide when to send messages more explicitly. For this purpose,
    you can use the `StreamBridge` component. This component lets you send messages
    while only specifying the binding to use.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了函数式方法来发送消息，让 Spring Stream Cloud 调用 `Supplier` 函数来生成消息。在许多场景中，我们必须更明确地决定何时发送消息。为此，你可以使用
    `StreamBridge` 组件。这个组件让你在只指定要使用的绑定的情况下发送消息。
- en: 'Let’s see an example. You can create a service component that receives a `StreamBridge`
    in the constructor, then Spring Boot will inject an instance in runtime:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。你可以创建一个服务组件，它在构造函数中接收一个 `StreamBridge`，然后 Spring Boot 将在运行时注入一个实例：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, you can use `StreamBridge` to send the message:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `StreamBridge` 来发送消息：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'RabbitMQ provides different types of exchanges, depending on how the messages
    are routed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 根据消息的路由方式提供不同类型的交换：
- en: '**Direct**: The messages are forwarded to a queue based on a routing key.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接**: 消息根据路由键被转发到一个队列。'
- en: '**Fanout**: The messages are forwarded to all bounded queues, regardless of
    the routing key.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扇出**: 消息被转发到所有有界队列，无论路由键是什么。'
- en: '**Topic**: The messages are routed to the bounded queues depending on a pattern
    defined in the exchange and the routing keys defined in the queues. This is the
    default type. In the next recipe, we’ll explore this scenario further.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**: 消息根据交换中定义的模式和队列中定义的路由键路由到有界队列。这是默认类型。在下一个食谱中，我们将进一步探讨这个场景。'
- en: '**Headers**: This is similar to the topic exchange, but RabbitMQ routes messages
    using the message headers instead of the routing key.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头信息**: 这与主题交换类似，但 RabbitMQ 使用消息头而不是路由键来路由消息。'
- en: Routing messages with Spring Cloud Stream and RabbitMQ
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 和 RabbitMQ 路由消息
- en: We decided to utilize the match events generated in the previous recipe to update
    the football match score. We’ll create a new application that subscribes to the
    goal events to implement this functionality.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定利用上一个食谱中生成的匹配事件来更新足球比赛的比分。我们将创建一个新的应用程序，订阅进球事件以实现这个功能。
- en: In this recipe, we’ll learn how to configure our Spring Cloud Stream producer
    application to set the routing key based on the message headers. Then, we’ll learn
    how to configure the consumer applications to set up the queue bindings based
    on pattern matches for the routing key.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何配置我们的 Spring Cloud Stream 生产者应用程序，根据消息头设置路由键。然后，我们将学习如何配置消费者应用程序，根据路由键的模式匹配设置队列绑定。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe starts with the outcome of the *Event-driven applications with Spring
    Cloud Stream and RabbitMQ* recipe. I prepared a working version in case you haven’t
    yet completed that recipe. You can find it in the book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-6/start` folder.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱从 *基于 Spring Cloud Stream 和 RabbitMQ 的事件驱动应用程序* 食谱的结果开始。我准备了一个工作版本，以防你还没有完成那个食谱。你可以在书的
    GitHub 仓库中找到它，在 `chapter8/recipe8-6/start` 文件夹中。[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
- en: As in the *Event-driven applications with Spring Cloud Stream and RabbitMQ*
    recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your
    computer, follow the instructions in the *Getting ready* section of that recipe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 *基于 Spring Cloud Stream 和 RabbitMQ 的事件驱动应用程序* 食谱中一样，你需要一个 RabbitMQ 服务器。要在你的计算机上设置
    RabbitMQ 服务，请遵循该食谱中 *准备就绪* 部分的说明。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s make the few necessary adjustments to the producer application, and then
    we’ll use Spring Cloud Stream’s powerful capabilities to set up all RabbitMQ bindings
    for us:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对生产者应用程序进行一些必要的调整，然后我们将使用 Spring Cloud Stream 的强大功能来为我们设置所有 RabbitMQ 绑定：
- en: 'First, we’ll modify the `matches` producer application to include some headers
    in the messages. For that, open the `MatchesApplication` class and modify the
    `matchEvents` method as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改 `matches` 生产者应用程序以在消息中包含一些头信息。为此，打开 `MatchesApplication` 类并按如下方式修改
    `matchEvents` 方法：
- en: Modify the method’s signature; instead of returning `MatchEvent`, we’ll return
    `Message<MatchEvent>`.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改方法的签名；而不是返回 `MatchEvent`，我们将返回 `Message<MatchEvent>`。
- en: We’ll use `MessageBuilder` to create the returning `Message<MatchEvent>`.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `MessageBuilder` 来创建返回的 `Message<MatchEvent>`。
- en: We’ll include a new header named `eventType`. We’ll assume that events with
    the `type` field equal to `2` are goals.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将包括一个名为 `eventType` 的新头信息。我们假设 `type` 字段等于 `2` 的事件是目标。
- en: 'The method should look like this:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法应如下所示：
- en: '[PRE54]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we’ll change the `matches` application’s configuration to assign the
    `eventType` header’s value to the routing key. For that, we’ll configure the rabbit
    producer binding with the `routing-key-expression` property in the `application.yml`
    file. The Spring Cloud configuration should look like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更改 `matches` 应用程序的配置，将 `eventType` 头信息的值分配给路由键。为此，我们将在 `application.yml`
    文件中配置 rabbit 生产者绑定 `routing-key-expression` 属性。Spring Cloud 配置应如下所示：
- en: '[PRE55]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, create a bean that returns `Consumer<MatchEvent>`. You can define it
    in the `ScoreApplication` class. This function will process the events received.
    It could look like this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个返回 `Consumer<MatchEvent>` 的 bean。你可以在 `ScoreApplication` 类中定义它。这个函数将处理接收到的事件。它可能看起来像这样：
- en: '[PRE56]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, configure the bindings to the `match-event-topic` exchange. In this application,
    we’ll set the binding route key using pattern matching. As we defined in *Steps
    1* and *2*, the goals will have the `football.goal` value. So, the configuration
    will look like this:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置绑定到 `match-event-topic` 交换机的绑定。在这个应用程序中，我们将使用模式匹配设置绑定路由键。正如我们在 *步骤 1* 和
    *步骤 2* 中定义的，目标将具有 `football.goal` 的值。因此，配置将如下所示：
- en: '[PRE57]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can run the `score` application. You should check that it only receives
    the goal events. If you run the `timeline` application we created in the *Event-driven
    applications with Spring Cloud Stream and RabbitMQ* recipe, you will see that
    it receives all events, including the goals.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以运行 `score` 应用程序。你应该检查它是否只接收目标事件。如果你运行我们在 *使用 Spring Cloud Stream 和 RabbitMQ
    的驱动应用程序* 菜谱中创建的 `timeline` 应用程序，你会看到它接收所有事件，包括目标。
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that the Spring Cloud Stream doesn’t automatically remove the bindings
    when you stop the application. For that reason, you may need to manually remove
    the bindings, exchanges, or queues of previous executions. You can do that from
    the RabbitMQ portal.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Spring Cloud Stream 不会在停止应用程序时自动删除绑定。因此，你可能需要手动删除先前执行的绑定、交换机或队列。你可以从 RabbitMQ
    门户中这样做。
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key concept in this recipe is the **routing key**, which is an attribute
    added by the producer to the message header. The exchange can then use the routing
    key to decide how to route the message. On the consumer side, it’s possible to
    define a binding to link a queue with an exchange based on the routing keys.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中的关键概念是 **路由键**，这是生产者添加到消息头部的属性。然后交换机可以使用路由键来决定如何路由消息。在消费者端，可以定义一个绑定来根据路由键将队列与交换机链接起来。
- en: In this recipe, we used the `routing-key-expression` to set the routing key
    based on the message’s properties, such as `header` or `payload`. The Spring RabbitMQ
    binder allows the use of **Spring Expression Language** (**SpEL**) to define the
    message’s routing key. The binder evaluates the expression and sets the value
    of the routing key.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 `routing-key-expression` 来根据消息的属性（如 `header` 或 `payload`）设置路由键。Spring
    RabbitMQ binder 允许使用 **Spring 表达式语言**（**SpEL**）来定义消息的路由键。binder 评估表达式并设置路由键的值。
- en: If you look at the messages generated in RabbitMQ, you will see the values of
    **Routing Key** and **headers**.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 RabbitMQ 生成的消息，你会看到 **Routing Key** 和 **headers** 的值。
- en: '![Figure 8.3: Message in RabbitMQ showing the routing key](img/B21646_08_3.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3：RabbitMQ 中的消息显示路由键](img/B21646_08_3.jpg)'
- en: 'Figure 8.3: Message in RabbitMQ showing the routing key'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：RabbitMQ 中的消息显示路由键
- en: On the consumer side, it’s possible to use pattern-matching values when binding
    the queue to the exchange. The messages whose routing key matches the given pattern
    will be forwarded to the corresponding queue. If you look at the bindings of `match-events-topic`
    in the RabbitMQ portal, you will see that two queues are bound, each using a different
    routing key.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端，当将队列绑定到交换机时，可以使用模式匹配值。与给定模式匹配的路由键的消息将被转发到相应的队列。如果你查看 RabbitMQ 门户中的 `match-events-topic`
    的绑定，你会看到绑定了两个队列，每个队列使用不同的路由键。
- en: '![Figure 8.4: Queues bound with different routing keys](img/B21646_08_4.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：使用不同路由键绑定的队列](img/B21646_08_4.jpg)'
- en: 'Figure 8.4: Queues bound with different routing keys'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：使用不同路由键绑定的队列
- en: With this configuration, RabbitMQ will send to the `match-events-topic.score`
    queue only the messages that match the `football.goal.#` routing key. That is,
    all messages whose routing key starts with `football.goal`. It will send to the
    `match-events-topic.timeline` queue all messages, as the `#` symbol acts as a
    wildcard.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，RabbitMQ只会将匹配`football.goal.#`路由键的消息发送到`match-events-topic.score`队列。也就是说，所有路由键以`football.goal`开头的消息。它将所有消息发送到`match-events-topic.timeline`队列，因为`#`符号充当通配符。
- en: See also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: You can find more information about SpEL on the project page at [https://docs.spring.io/spring-framework/reference/core/expressions.html](https://docs.spring.io/spring-framework/reference/core/expressions.html).
    It supports querying and manipulating an object graph at runtime, and all Spring
    projects widely use it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的页面[https://docs.spring.io/spring-framework/reference/core/expressions.html](https://docs.spring.io/spring-framework/reference/core/expressions.html)上找到更多关于SpEL的信息。它支持在运行时查询和操作对象图，并且所有Spring项目都广泛使用它。
- en: Error handling with Spring Cloud Stream
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Stream处理错误
- en: The score application we developed in the previous recipe has become critical
    for football matches as it manages the final match score. For that reason, we
    need to ensure the solution’s robustness.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的菜谱中开发的得分应用程序已经成为足球比赛的关键，因为它管理着最终的比分。因此，我们需要确保解决方案的健壮性。
- en: Spring Cloud Stream can implement highly available, loosely coupled, resilient
    systems. The reason is that the underlying messaging systems, such as RabbitMQ,
    provide different mechanisms to ensure the message is delivered to the intended
    destination. First, the messages can be queued before they are delivered. If,
    for any reason, the consumer application is not ready yet or has a transient failure,
    it will process the queued messages once it’s ready again. You can use the same
    mechanism to increase the number of consumers to increase the throughput of your
    system. You can also configure a retry policy in case of a transient failure in
    your application or forward it to a special queue, which is named a **dead-letter
    queue** (**DLQ**). The DLQ is a common mechanism in messaging systems; the DLQ
    can receive all messages that cannot be processed normally for whatever reason;
    the main purpose is to provide the capability to keep messages that cannot be
    processed, not only due to technical transient errors but those related to software
    issues as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream可以实现高可用性、松耦合、弹性系统。原因是底层消息传递系统，如RabbitMQ，提供了不同的机制来确保消息被发送到预期的目的地。首先，消息可以在交付之前排队。如果由于任何原因，消费者应用程序尚未准备好或发生暂时性故障，它将在准备好后再次处理排队中的消息。您可以使用相同的机制增加消费者数量以提高系统的吞吐量。您还可以在应用程序发生暂时性故障时配置重试策略，或者将其转发到名为**死信队列**（**DLQ**）的特殊队列。DLQ是消息传递系统中的常见机制；DLQ可以接收所有由于任何原因无法正常处理的消息；其主要目的是提供保留无法处理的消息的能力，这不仅限于技术上的暂时性错误，还包括与软件问题相关的错误。
- en: In this recipe, we’ll learn how to configure a DLQ and retry policies for our
    application, and we’ll see how the application behaves in case of errors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何为我们的应用程序配置死信队列（DLQ）和重试策略，并了解在出现错误时应用程序的表现。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the *Routing messages with Spring Cloud Stream and RabbitMQ*
    recipe outcomes as the starting point. If you haven’t completed it yet, you can
    use the version I prepared, which can be found in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-7/start` folder.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用*使用Spring Cloud Stream和RabbitMQ路由消息*菜谱的结果作为起点。如果您尚未完成，可以使用我在书中GitHub仓库中准备的版本，该版本可在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)的`chapter8/recipe8-7/start`文件夹中找到。
- en: As in the *Event-driven applications with Spring Cloud Stream and RabbitMQ*
    recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your
    computer, follow the instructions in the *Getting ready* section of that recipe.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如*使用Spring Cloud Stream和RabbitMQ构建事件驱动应用程序*菜谱中所述，您将需要一个RabbitMQ服务器。要在您的计算机上设置RabbitMQ服务，请遵循该菜谱中*准备就绪*部分的说明。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before we configure the application for error handling, we’ll simulate some
    transient errors in our application:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为应用程序配置错误处理之前，我们将在我们的应用程序中模拟一些暂时性错误：
- en: 'Let’s modify our score application to introduce random errors when message
    processing. We’ll simulate an error happening 80% of the time. For that, open
    the `processGoals` method of the `ScoreApplication` class and replace the code
    with the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的分数应用程序，在消息处理时引入随机错误。我们将模拟80%的时间发生错误。为此，打开`ScoreApplication`类的`processGoals`方法，并用以下代码替换代码：
- en: '[PRE58]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we’ll configure the application to automatically create a DLQ. To do that,
    open the `score` application’s `application.yml` and set the `autoBindDlq` property
    in the `spring.cloud.string.rabbit.bindings.input.consumer` section to `true`.
    It should look like this:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置应用程序以自动创建一个DLQ。为此，打开`score`应用程序的`application.yml`文件，并将`spring.cloud.string.rabbit.bindings.input.consumer`部分中的`autoBindDlq`属性设置为`true`。它应该看起来像这样：
- en: '[PRE59]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![Figure 8.5: DLQ](img/B21646_08_5.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：DLQ](img/B21646_08_5.jpg)'
- en: 'Figure 8.5: DLQ'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：DLQ
- en: Now, we’ll configure the retry policy. For instance, we can configure three
    attempts before a message is routed to the DLQ and one second as the maximum time
    to process a message, which is its `spring.cloud.string.rabbit.bindings.input.consumer.maxAttempts`
    = `3`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置重试策略。例如，我们可以在消息被路由到DLQ之前配置三次尝试，并将处理消息的最大时间设置为1秒，即其`spring.cloud.string.rabbit.bindings.input.consumer.maxAttempts`
    = `3`。
- en: '`spring.cloud.string.rabbit.bindings.input.consumer.ttl` = `1000`. This property
    is expressed in milliseconds.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring.cloud.string.rabbit.bindings.input.consumer.ttl` = `1000`。这个属性以毫秒为单位表示。'
- en: You can run the application now. If you keep it running for a while, you will
    see some errors in the score application, and some messages will reach the DLQ.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序。如果您让它运行一段时间，您将在分数应用程序中看到一些错误，并且一些消息将到达死信队列（DLQ）。
- en: '![Figure 8.6: DLQ messages](img/B21646_08_6.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：DLQ消息](img/B21646_08_6.jpg)'
- en: 'Figure 8.6: DLQ messages'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：DLQ消息
- en: You can also stop and restart the `score` application. In the RabbitMQ portal,
    you can verify that the messages are queued in the `match-events-topic.score`
    queue and that once the application is ready again, it will process all pending
    messages.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以停止并重新启动`score`应用程序。在RabbitMQ门户中，您可以验证消息是否已排队在`match-events-topic.score`队列中，并且一旦应用程序再次准备好，它将处理所有挂起的消息。
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a queue is bound to an exchange, a new message is forwarded to the queue
    every time there’s a new message in the exchange. The message lasts in the queue
    until it’s processed or the TTL expires. The consumer application, in our case,
    the `score` application, tries to read and process; if, for any reason, it fails
    before completing the process, the message returns to the queue. This process
    can be executed with the number of attempts configured, in our case, three attempts.
    Finally, if the message cannot be processed or the TTL expires, then the message
    is forwarded to the DLQ.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个队列绑定到一个交换机时，每当交换机中有新消息时，新消息就会被转发到队列。消息在队列中持续，直到被处理或TTL过期。在我们的案例中，消费者应用程序，即`score`应用程序，会尝试读取和处理；如果由于任何原因在完成处理之前失败，消息将返回到队列。这个过程可以执行配置的尝试次数，在我们的案例中，是三次尝试。最后，如果消息无法处理或TTL过期，则消息将被转发到DLQ。
- en: In our example, we configured an 80% failure rate for demonstration purposes.
    If we reduce the failure rate, fewer messages will reach the DLQ.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们为了演示目的配置了80%的失败率。如果我们降低失败率，到达DLQ的消息会更少。
- en: The solution is more resilient because once the message is queued, we can ensure
    that it will be processed, regardless of the availability of the `score` application.
    The `score` application may be unavailable for a given time for many reasons,
    including a transient error and planned maintenance. For features like these,
    this kind of solution is so popular in microservices architectures and cloud solutions.
    The assumption is that the messaging service is highly available, for instance,
    by deploying a cluster with redundant servers or just by using the **platform
    as a service** (**PaaS**) provided by cloud providers. On the Spring Cloud Stream
    page at [https://spring.io/projects/spring-cloud-stream](https://spring.io/projects/spring-cloud-stream),
    you can find the compatible binders; some are maintained directly by the Spring
    Cloud Team, while partners maintain others.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案更加健壮，因为一旦消息被排队，我们可以确保它将被处理，无论`score`应用程序是否可用。`score`应用程序可能由于许多原因在给定时间内不可用，包括暂时性错误和计划性维护。对于这些功能，这种类型的解决方案在微服务架构和云解决方案中非常流行。假设消息服务具有高可用性，例如，通过部署具有冗余服务器的集群或仅使用云提供商提供的**平台即服务**（**PaaS**）。在Spring
    Cloud Stream页面[https://spring.io/projects/spring-cloud-stream](https://spring.io/projects/spring-cloud-stream)上，您可以找到兼容的绑定器；其中一些由Spring
    Cloud团队直接维护，而其他一些由合作伙伴维护。
- en: See also
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can configure more than one consumer application. If one consumer instance
    cannot process one message, another instance can process it. With this approach,
    scaling out the application by adding more consumers is possible. This design
    is known as **Competing Consumers**. You can find a good description of this scenario
    in the Azure Architecture Center at [https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers).
    The implementation suggests Azure products, but you can apply the same principles
    with other technologies, such as RabbitMQ.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置多个消费者应用程序。如果一个消费者实例无法处理一条消息，另一个实例可以处理它。通过这种方法，通过添加更多消费者来扩展应用程序是可能的。这种设计被称为**竞争消费者**。您可以在Azure架构中心找到关于此场景的良好描述：[https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers)。该实现建议使用Azure产品，但您可以使用其他技术，如RabbitMQ，应用相同的原理。
- en: 'Other design patterns rely on queue systems that are worth having in our toolbox.
    For instance:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 其他设计模式依赖于我们工具箱中值得拥有的队列系统。例如：
- en: '**Asynchronous Request-Reply**: In this pattern, you may need to respond quickly
    to client applications, such as web browsers. However, operations may take much
    longer to respond. To solve this situation, the application saves the request
    in a queue and processes it asynchronously. The application exposes an endpoint
    to get the request status; then, the clients can periodically check the request
    status.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步请求-回复**：在此模式中，您可能需要快速响应用户应用程序，例如网页浏览器。然而，操作可能需要更长的时间才能响应。为了解决这个问题，应用程序将请求保存到队列中，并异步处理它。应用程序公开一个端点以获取请求状态；然后，客户端可以定期检查请求状态。'
- en: '**Queue-Based Load Leveling**. Some applications may rely on a backend with
    limited capacity, but load spikes can occur. In those scenarios with unpredictable
    demand, the queue acts as a buffer, and the consumer application processes the
    requests at a pace that doesn’t overflow the backend.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于队列的负载均衡**。某些应用程序可能依赖于具有有限容量的后端，但可能会出现负载峰值。在这些具有不可预测需求的情况下，队列充当缓冲区，消费者应用程序以不会超出后端容量的速度处理请求。'
- en: 'Part 4: Upgrading to Spring Boot 3 from Previous Versions'
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：从旧版本升级到Spring Boot 3
- en: Most of the time invested in an application over its lifetime is related to
    maintenance. A successful application may last for years or decades. During this
    time, it may require upgrades for its evolution. You probably have an application
    that you want to evolve and take advantage of the Spring Boot 3 features. In this
    part, we’ll learn how to upgrade an existing application from Spring Boot 2 to
    Spring Boot 3.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中，大部分投入的时间都与维护相关。一个成功的应用程序可能持续数年或数十年。在这段时间里，它可能需要升级以实现其进化。您可能有一个希望进化并利用Spring
    Boot 3功能的现有应用程序。在本部分，我们将学习如何将现有应用程序从Spring Boot 2升级到Spring Boot 3。
- en: 'This part has the following chapter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B21646_09.xhtml#_idTextAnchor407)*,* *Upgrading from Spring Boot
    2.x to Spring Boot 3.0*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21646_09.xhtml#_idTextAnchor407)*,* 从Spring Boot 2.x升级到Spring Boot
    3.0*'
