- en: Chapter 7. Working with Integration and Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用集成和Web服务
- en: Because technology stacks evolve continuously, a large area to consider when
    developing commercial software is the integration between systems. The flexibility
    and scalability of the Web have seen the proliferation of services built on top
    of HTTP to integrate systems in a loosely-coupled fashion. Moreover, to be able
    to navigate through secure networks accessible via firewalls and additional security
    mechanisms, the HTTP model has been increasingly popular. In this chapter, we
    are going to cover how to involve Scala when integrating with systems either via
    Web Services or REST Services exchanging messages in formats such as XML and JSON.
    In particular, we will consider running such services through the Play Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术堆栈不断演变，在开发商业软件时需要考虑的一个大领域是系统之间的集成。Web的灵活性和可扩展性使得基于HTTP构建的服务以松散耦合的方式集成系统的数量激增。此外，为了能够通过防火墙和额外的安全机制导航到可通过这些机制访问的安全网络，HTTP模型越来越受欢迎。在本章中，我们将介绍如何在通过Web服务或REST服务交换消息（如XML和JSON格式）时涉及Scala。特别是，我们将考虑通过Play框架运行此类服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Generating data bindings from XML schemas as well as SOAP web service classes
    out of their WSDL description
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从XML模式生成数据绑定，以及从它们的WSDL描述中生成SOAP Web服务类
- en: Manipulating XML and JSON in Scala and in particular in the context of the Play
    Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scala和特别是在Play框架的上下文中操作XML和JSON
- en: Invoking other REST web services from Play, and validating and displaying their
    response
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Play调用其他REST Web服务，并验证和显示其响应
- en: Binding XML data in Scala
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Scala中绑定XML数据
- en: Even if XML has recently stepped down a bit from its ubiquitous position due
    to the increasing popularity of JSON, both formats will continue to be heavily
    used to structure data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使由于JSON日益流行，XML最近从无处不在的位置有所下降，但两种格式都将继续被大量用于结构化数据。
- en: In Java, it is a common practice to use the JAXB libraries to create classes
    that are able to serialize and deserialize XML data and construct XML documents
    through an API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，使用JAXB库创建能够序列化和反序列化XML数据以及通过API构建XML文档的类的做法很常见。
- en: 'In a similar manner, the `scalaxb` library available for Scala can generate
    help classes for working with XML and web services. As an example, let''s consider
    a small XML schema, `Bookstore.xsd,` that defines a set of books as part of a
    book store as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，Scala可用的`scalaxb`库可以生成用于处理XML和Web服务的帮助类。例如，让我们考虑一个小型的XML模式`Bookstore.xsd`，它定义了作为书店一部分的一组书籍，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A typical book is defined by its title, author, date of publication, and ISBN
    number, as shown in the following example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书通常由其标题、作者、出版日期和ISBN号码定义，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are several ways one can run `scalaxb` documented on the [www.scalaxb.org](http://www.scalaxb.org)
    website: either directly as a command line tool, through plugins from SBT or Maven,
    or as a web API hosted on `heroku`. Since we have essentially used SBT so far
    and should be comfortable with it, let''s use the SBT plugin to create the bindings.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以在[www.scalaxb.org](http://www.scalaxb.org)网站上运行`scalaxb`，要么直接作为命令行工具，通过SBT或Maven的插件，或者作为托管在`heroku`上的Web
    API。由于我们到目前为止基本上使用了SBT并且应该对它感到舒适，让我们使用SBT插件来创建绑定。
- en: 'First create a new SBT project entitled `wssample` by running the following
    commands in a new terminal window:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在新终端窗口中运行以下命令创建一个名为`wssample`的新SBT项目：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we need to add the `scalaxb` plugin dependency to a `plugins.sbt` file
    under `project/` (and at the same time we will add the `sbteclipse` plugin that
    enables us to generate an Eclipse project out of the SBT project). The resulting
    `plugins.sbt` file will look similar to the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`project/`目录下的`plugins.sbt`文件中添加`scalaxb`插件依赖（同时我们还将添加`sbteclipse`插件，它使我们能够从SBT项目生成Eclipse项目）。生成的`plugins.sbt`文件将类似于以下代码：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Additionally, we have to slightly modify the `build.sbt` file to notably include
    a command that will generate `scalaxb` XML bindings when compiling with SBT. The
    resulting `build.sbt` file will look similar to the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要稍微修改`build.sbt`文件，以特别包括一个在用SBT编译时将生成`scalaxb` XML绑定的命令。生成的`build.sbt`文件将类似于以下代码：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the `Bookstore.xsd` schema shown previously to a new `src/main/xsd` directory
    created within the project. From now on, each time you invoke the SBT command
    `> compile`, `scalaxb` will generate some Scala classes under the `target/scala-2.10/src_managed`
    directory (in the package given in the `build.sbt` file that is, `se.wssample`),
    unless no changes have been made. For instance, in the case of our small example,
    `scalaxb` generates the following case classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前显示的 `Bookstore.xsd` 架构添加到在项目中创建的新 `src/main/xsd` 目录中。从现在起，每次你调用 SBT 命令 `>
    compile`，`scalaxb` 都将在 `target/scala-2.10/src_managed` 目录下生成一些 Scala 类（在 `build.sbt`
    文件中指定的包中，即 `se.wssample`），除非没有进行更改。例如，在我们的小型示例中，`scalaxb` 生成以下案例类：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the `*` at the end of the first case class declaration, which is used
    to specify varargs (that is, an unspecified number of arguments, so here the `Book_store`
    constructor can take several `Book_type` instances). A possible test class illustrating
    the usage of the generated code to parse an XML document is given in the `BookstoreSpec.scala`
    class as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个案例类声明末尾的 `*`，它用于指定可变参数（即不确定数量的参数，因此这里的 `Book_store` 构造函数可以接受多个 `Book_type`
    实例）。一个展示如何使用生成的代码解析 XML 文档的测试类示例在 `BookstoreSpec.scala` 类中如下所示：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The expected output from this test when invoking the `> sbt test` command is
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `> sbt test` 命令时，此测试的预期输出如下：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running scalaxb from a SOAP web service
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 SOAP Web 服务运行 scalaxb
- en: 'Since `scalaxb` supports the **Web Services Description** **Language** (**WSDL**),
    we can also generate a full web service API in addition to the XML data-only related
    classes. To achieve this functionality, we just need to copy our WSDL service
    description file to `src/main/wsdl`. All the files with the `.wsdl` extension
    will be processed at compile time by the `scalaxb` plugin that will create the
    following three types of output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `scalaxb` 支持 **Web 服务描述语言**（**WSDL**），我们还可以生成完整的 Web 服务 API，而不仅仅是与 XML 数据相关的类。为了实现此功能，我们只需将我们的
    WSDL 服务描述文件复制到 `src/main/wsdl`。所有具有 `.wsdl` 扩展名的文件将在编译时由 `scalaxb` 插件处理，它将创建以下三种类型的输出：
- en: The service API specific to your application.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门针对你应用程序的服务 API。
- en: Classes specific to the SOAP protocol.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门针对 SOAP 协议的类。
- en: Classes responsible for sending the SOAP messages to the endpoint URL via HTTP.
    `scalaxb` uses the dispatch library that we introduced in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*.
    This is why we added it as a dependency into the `build.sbt` file.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责通过 HTTP 将 SOAP 消息发送到端点 URL 的类。`scalaxb` 使用我们在 [第 3 章](ch03.html "第 3 章。理解
    Scala 生态系统") 中介绍的调度库，即 *理解 Scala 生态系统*。这就是为什么我们将它添加到 `build.sbt` 文件中的依赖项中。
- en: 'Let''s take an online SOAP web service as a way to illustrate the usage of
    `scalaxb` from a WSDL description. [www.webservicex.net](http://www.webservicex.net)
    is a site that contains many different samples of such web services in various
    market segments. Here, we will focus on their Stock Quote service that returns
    quotes given by a stock symbol. The API is very straightforward since it consists
    of only one request method, `getQuote`, and the data it returns is limited in
    size. You might want to try any other available service (later on as you can have
    multiple WSDL files in your same project). Its WSDL description looks similar
    to the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个在线 SOAP Web 服务为例，来说明如何从 WSDL 描述中使用 `scalaxb`。[www.webservicex.net](http://www.webservicex.net)
    是一个包含各种市场细分中许多不同此类 Web 服务样本的网站。在这里，我们将关注他们的股票报价服务，该服务返回由股票符号给出的报价。API 非常简单，因为它只包含一个请求方法，`getQuote`，并且返回的数据量有限。你可能想尝试任何其他可用的服务（稍后，因为你可以将多个
    WSDL 文件放在同一个项目中）。它的 WSDL 描述看起来类似于以下代码：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first part of the WSDL file contains the description of the XML schema.
    The second part defines the various web service operations as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL 文件的第一部分包含 XML 模式的描述。第二部分定义了各种 Web 服务操作如下：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the last part of the WSDL file defines the coupling between web service
    operations and physical URLs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，WSDL 文件的最后一部分定义了 Web 服务操作与物理 URL 之间的耦合：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the WSDL files are often pretty verbose, but the Scala contract
    resulting from the `scalaxb` generation boils down to this one method trait:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，WSDL 文件通常相当冗长，但由 `scalaxb` 生成的结果 Scala 合约简化为以下一个方法特质：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the resulting type is nicely wrapped into an `Either` class that
    represents a value of one of the two possible types, `Left` and `Right`, where
    the `Right` object corresponds to a successful invocation of the service whereas
    the `Left` object contains a `scalaxb.Fault` value in case of failure, as we have
    briefly described in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code
    Integration*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果类型是如何优雅地封装在`Either`类中的，该类代表两种可能类型之一`Left`和`Right`的值，其中`Right`对象对应于服务的成功调用，而`Left`对象在失败情况下包含`scalaxb.Fault`值，正如我们在[第2章](ch02.html
    "第2章。代码集成")，*代码集成*中简要描述的那样。
- en: 'Since the generated classes concerning the SOAP protocol and the HTTP dispatch-related
    classes are not specific to the service we are defining, they can be reused and
    therefore have been generated as stackable traits including data types and interface,
    SOAP bindings, and full SOAP clients. A typical usage scenario of these traits
    to invoke a SOAP web service is given in the following `StockQuoteSpec.scala`
    test sample:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与SOAP协议相关的生成类以及与HTTP调度相关的类并不特定于我们正在定义的服务，因此它们可以被重用，因此它们已经被生成为可堆叠的特性，包括数据类型和接口、SOAP绑定和完整的SOAP客户端。以下`StockQuoteSpec.scala`测试示例给出了这些特性的典型使用场景，以调用SOAP网络服务：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, once we have instantiated the service, we will just call the
    API method `service.getQuote(Some("AAPL"))` for retrieving the stock quote of
    the AAPL symbol (Apple, Inc). We then pattern match on the result to extract the
    XML data out of the `Either` object that was returned by the service. Finally,
    since the retrieved data is given as a string of XML, we parse it and format it
    for better reading. We can execute the test using the following code to see what
    comes out of it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一旦我们实例化了服务，我们只需调用API方法`service.getQuote(Some("AAPL"))`来检索AAPL符号（苹果公司）的股票报价。然后我们对结果进行模式匹配，从服务返回的`Either`对象中提取XML数据。最后，由于检索到的数据是以XML字符串的形式给出的，我们解析它并格式化它以便更好地阅读。我们可以使用以下代码执行测试以查看结果：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Working with XML and JSON
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理XML和JSON
- en: XML and JSON are the dominant formats to structure data that can be exchanged
    between parts of a system such as backend-frontend or between external systems.
    In Scala, there is some out-of-the-box support in the Scala library to manipulate
    both.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: XML和JSON是结构化可以在系统部分之间交换的数据的占主导地位的格式，例如后端-前端或外部系统之间。在Scala中，Scala库中提供了一些内置支持来操作这两种格式。
- en: Manipulating XML
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作XML
- en: 'We have briefly seen earlier in this chapter as well as in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*,
    when working with HTTP that XML documents can be created as literals and transformed
    in many ways. For instance, if we launch an REPL by typing `> play console` from
    a Play project root directory, we can start experimenting with XML:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及[第3章](ch03.html "第3章。理解Scala生态系统")，*理解Scala生态系统*中，我们之前也简要地看到了，当使用HTTP时，XML文档可以作为字面量创建，并以多种方式转换。例如，如果我们从Play项目根目录中键入`>
    play console`来启动REPL，我们就可以开始对XML进行实验：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `books` variable is of type `Elem`, which represents an XML structure.
    Rather than directly writing an XML literal, we could also construct the XML `Elem`
    using utility methods to parse a file or just parse a string, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`books`变量是`Elem`类型，它代表一个XML结构。我们不仅可以直接编写XML字面量，还可以使用实用方法通过解析文件或解析字符串来构建XML
    `Elem`，如下所示：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The triple quote used in the preceding command lets us express a preformatted
    string where the characters are escaped (for example, the `"` within a regular
    string would have been noted `\"`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中使用的三引号允许我们表达一个预格式化的字符串，其中字符被转义（例如，正则字符串中的`"`将被记为`\"`）。
- en: 'Processing such an XML structure can, for example, consist of computing the
    total price for the books. This operation can be achieved with a Scala `for comprehension`
    leading to the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，处理这样的XML结构可能包括计算书籍的总价。这个操作可以通过Scala的`for comprehension`实现，以下代码展示了如何实现：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Retrieving and transforming XML structures happens all the time when dealing
    with the integration of diverse external systems. Accessing the various XML tags
    through XPath expressions as we have done earlier is very handy and produces concise
    and readable code. Programmatically, creating XML out of information exported
    from Excel in the form of CSV data is also a common operation and can be achieved
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理与各种外部系统的集成时，检索和转换 XML 结构是经常发生的事情。通过 XPath 表达式访问我们之前所做的那样访问各种 XML 标签非常方便，并产生简洁且可读的代码。从
    Excel 以 CSV 数据形式导出的信息程序化地创建 XML 也是一个常见的操作，可以按以下方式实现：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Manipulating JSON
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作 JSON
- en: 'JSON is supported in the Scala library and you just need to import the appropriate
    library. An example of some REPL usage is illustrated as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 库支持 JSON，你只需要导入适当的库。以下是一些 REPL 用法的示例：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Any valid JSON message can be transformed into a structure made of `Maps` and
    `Lists`. However, it is often desirable to create meaningful classes, that is,
    expressing the business domain out of the JSON messages. The online service available
    at [http://json2caseclass.cleverapps.io](http://json2caseclass.cleverapps.io)
    does exactly that; it is a convenient JSON to Scala case class converter. We can,
    for example, copy our preceding JSON message into the **Json paste** text area
    and click on the **Let''s go!** button to try it out as shown in the following
    screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的 JSON 消息都可以转换成由 `Maps` 和 `Lists` 构成的结构。然而，通常我们希望创建有意义的类，即从 JSON 消息中表达业务领域。可在
    [http://json2caseclass.cleverapps.io](http://json2caseclass.cleverapps.io) 提供的在线服务正好做到这一点；它是一个方便的
    JSON 到 Scala case class 转换器。例如，我们可以将我们前面的 JSON 消息复制到 **Json 粘贴** 文本区域，然后点击 **Let's
    go!** 按钮来尝试它，如下面的截图所示：
- en: '![Manipulating JSON](img/3637OS_07_05_New.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![操作 JSON](img/3637OS_07_05_New.jpg)'
- en: 'The converter produces the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器产生以下输出：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Among the very interesting features of case classes that we have already introduced
    in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your Project"),
    *Programming Interactively within Your Project*, is a decomposition mechanism
    for pattern matching. Once JSON messages have been deserialized into case classes,
    we can, for instance, manipulate them using this mechanism, as the sequence of
    the following command illustrates:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经在 [第 1 章](ch01.html "第 1 章。在项目中交互式编程") 中介绍过的 case classes 的非常有趣的功能中，*在项目中交互式编程*
    是一个用于模式匹配的分解机制。一旦 JSON 消息被反序列化为 case classes，我们就可以使用这个机制来操作它们，如下面的命令序列所示：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we defined two instances of books and put them into a list.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了两个书籍实例并将它们放入一个列表中。
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The method defined previously does pattern matching on the `Book` constructor,
    which also contains a guard (that is, the `if` condition). Since we do not use
    the second constructor parameter, we have put an underscore instead of creating
    an anonymous variable. Calling this method on both the book instances that we
    defined earlier will show the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的方法在 `Book` 构造函数上执行模式匹配，该构造函数还包含一个守卫（即 `if` 条件）。由于我们不使用第二个构造函数参数，所以我们用一个下划线代替了创建匿名变量。在之前定义的两个书籍实例上调用此方法将显示以下结果：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can mix case class pattern matching together with other patterns. Let''s,
    for instance, define the following regular expression (note the usage of the triple
    quotes as well as the use of `.r` to specify that it is a regular expression):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 case class 模式匹配与其他模式混合使用。例如，让我们定义以下正则表达式（注意三引号的使用以及使用 `.r` 来指定它是一个正则表达式）：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This regular expression will match any string that contains either Scala or
    Java.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此正则表达式将匹配包含 Scala 或 Java 的任何字符串。
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now try out this method on a number of different inputs and observe
    the result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在多个不同的输入上尝试这个方法并观察结果：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using Play JSON
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Play JSON
- en: There are many alternative libraries one can use to manipulate JSON in addition
    to the default implementation of the Scala library. In addition to the ones built
    on top of the known Java libraries such as Jerkson (built on top of Jackson) and
    other known implementations such as sjson, json4s, or Argonaut (functional programming
    oriented), many web frameworks have created their own including lift-json, spray-json,
    or play-json. Since in this book we are mostly covering the Play Framework to
    build web applications, we are going to focus on the play-json implementation.
    Note that play-json can also be run as standalone since it consists of a single
    jar without other dependencies to Play. Running an REPL console from within a
    Play project already includes the play-json dependency so that we can directly
    experiment with it in a console terminal window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Scala 库的默认实现之外，还有许多其他库可以用来操作 JSON。除了建立在已知 Java 库（如 Jerkson，建立在 Jackson 之上）和其他已知实现（如
    sjson、json4s 或 Argonaut，面向函数式编程）之上的库之外，许多 Web 框架也创建了它们自己的，包括 lift-json、spray-json
    或 play-json。由于在这本书中我们主要介绍 Play 框架来构建 Web 应用程序，我们将重点关注 play-json 实现。请注意，play-json
    也可以作为独立程序运行，因为它只包含一个 jar 文件，没有其他对 Play 的依赖。从 Play 项目内部运行 REPL 控制台已经包含了 play-json
    依赖项，因此我们可以在控制台终端窗口中直接进行实验。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to run the following samples into an REPL different from the Play
    console (for instance, a regular SBT project or a Typesafe activator project)
    then you will have to add the following dependency to your `build.sbt` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在一个不同于 Play 控制台（例如，一个常规的 SBT 项目或 Typesafe activator 项目）的 REPL 中运行以下示例，那么你将不得不将以下依赖项添加到你的
    `build.sbt` 文件中：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `JsValue` type is the super type of the other JSON data types included
    in play-json and is listed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsValue` 类型是 play-json 中包含的其他 JSON 数据类型的超类型，如下所示：'
- en: '`JsNull` to represent a null value'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `JsNull` 来表示 null 值
- en: '`JsString`, `JsBoolean`, and `JsNumber` to describe strings, booleans, and
    numbers respectively: numbers include short, int, long, float, double, and BigDecimal
    as seen in the following commands:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsString`、`JsBoolean` 和 `JsNumber` 分别用来描述字符串、布尔值和数字：数字包括 short、int、long、float、double
    和 BigDecimal，如以下命令所示：'
- en: '[PRE28]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`JsObject` represents a set of name/value pairs as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsObject` 表示一组名称/值对，如下所示：'
- en: '[PRE29]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`JsArray` represents a sequence of any JSON value types (which can be heterogenous,
    that is, of different types):'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsArray` 表示任何 JSON 值类型的序列（可以是异构的，即不同类型）：'
- en: '[PRE30]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Programmatically, creating a JSON **Abstract** **Syntax Tree** (**AST**) equivalent
    to our list of books can therefore be expressed as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序上讲，创建一个与我们的书籍列表等价的 JSON **抽象** **语法树**（**AST**）可以表达如下：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Play has recently been enhanced to provide a slightly simpler syntax when creating
    the JSON structure we have just described. The alternative syntax to construct
    the same JSON object is given as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Play 最近增强以在创建我们刚刚描述的 JSON 结构时提供稍微简单的语法。构建相同 JSON 对象的替代语法如下所示：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Serializing the JsObject to its string representation can be achieved with
    the following statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JsObject 序列化为其字符串表示形式可以通过以下语句实现：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, since a `JsObject` object represents a tree structure, you can navigate
    within the tree by using XPath expressions to retrieve various elements, such
    as the following example to access the titles of both our books:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 `JsObject` 对象代表一个树结构，你可以通过使用 XPath 表达式在树中导航，以检索各种元素，例如以下示例用于访问我们书籍的标题：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As the return type is a sequence of `JsValue` objects, it can be useful to
    convert them into Scala types and the `.as[…]` method would be convenient to achieve
    that:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回类型是 `JsValue` 对象的序列，将它们转换为 Scala 类型可能很有用，`.as[…]` 方法将方便地实现这一点：
- en: '[PRE35]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Handling Play requests with XML and JSON
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 和 JSON 处理 Play 请求
- en: Now that we are familiar with the JSON and XML formats, we can start using them
    to handle HTTP requests and responses in the context of a Play project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 JSON 和 XML 格式，我们可以开始使用它们来处理 Play 项目中的 HTTP 请求和响应。
- en: To exhibit these behaviors, we are going to call an online web service, the
    iTunes media library, which is available and documented at [http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些行为，我们将调用一个在线网络服务，即 iTunes 媒体库，它可在 [http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html)
    获取并得到文档说明。
- en: 'It returns JSON messages on search invocations. We can, for instance, call
    the API with the following URL and parameters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它在搜索调用时返回 JSON 消息。例如，我们可以使用以下 URL 和参数调用 API：
- en: '[https://itunes.apple.com/search?term=angry+birds&country=se&entity=software](https://itunes.apple.com/search?term=angry+birds&country=se&entity=software)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://itunes.apple.com/search?term=angry+birds&country=se&entity=software](https://itunes.apple.com/search?term=angry+birds&country=se&entity=software)'
- en: The term parameter filters every item in the library that has to do with *Angry
    Birds* and the entity parameter retains only software items. We also apply an
    additional filter to query only the Swedish App Store.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参数过滤器会过滤掉与 *愤怒的小鸟* 有关的图书馆中的每一项，而实体参数仅保留软件项。我们还应用了一个额外的过滤器，以查询仅限于瑞典的应用商店。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t have it already in your `build.sbt` file, you may need to add
    the dispatch dependency at this point, the same way we did while working with
    HTTP in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在 `build.sbt` 文件中添加，你可能需要在此处添加 dispatch 依赖项，就像我们在[第 3 章](ch03.html "第
    3 章。理解 Scala 生态系统")“理解 Scala 生态系统”中处理 HTTP 时所做的那样：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Parameters that will be part of our GET method call can be expressed as `(key,value)`
    tuples in a Scala `Map`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 GET 方法调用中将包含的参数可以用 Scala `Map` 中的 `(key,value)` 元组来表示：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The type of result in this case is `Future[Either[Throwable,String]]`, which
    means we can extract a successful invocation as well as a failed execution by
    pattern matching as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果类型是 `Future[Either[Throwable,String]]`，这意味着我们可以通过模式匹配提取成功的调用以及失败的执行，如下所示：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Mocking Play responses with JSON
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 模拟 Play 响应
- en: 'Whenever you need to integrate your services with external systems that you
    do not own or that are not available until you deploy them in production, it can
    be cumbersome to test the interaction of messages that are sent and received.
    An efficient way to avoid calling a real service is to replace it with mock messages,
    that is, hardcoded responses that will cut short the real interaction, especially
    if you need to run your tests as part of an automated process (for instance, daily
    as a Jenkins job). Returning a plain JSON message from within a Play controller
    is very straightforward, as the following example illustrates:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将你的服务与你不拥有或直到在生产环境中部署它们才可用的外部系统集成时，测试发送和接收的消息交互可能会很麻烦。避免调用真实服务的一个有效方法是使用模拟消息来替换它，即硬编码的响应，这将缩短真实的交互，特别是如果你需要将测试作为自动化过程的一部分运行（例如，作为
    Jenkins 作业的每日运行）。从 Play 控制器内部返回一个简单的 JSON 消息非常直接，如下例所示：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Json.format[. . .]` declaration that involves Reads, Writes, and Format
    will be explained later on in this section when we invoke web services, so we
    can skip discussing that part for the moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及 Reads、Writes 和 Format 的 `Json.format[. . .]` 声明将在我们调用网络服务时在本节稍后解释，因此我们可以暂时跳过讨论这部分内容。
- en: 'To try out this controller, you can either create a new Play project, or, as
    we did before, just add this controller to the application we generated out of
    an existing database in the last section of [Chapter 6](ch06.html "Chapter 6. Database
    Access and the Future of ORM"), *Database Access and the Future of ORM*. You also
    need to add a route to the `route` file under `conf/` as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个控制器，你可以创建一个新的 Play 项目，或者，就像我们在上一章[第 6 章](ch06.html "第 6 章。数据库访问和 ORM 的未来")的最后一节“数据库访问和
    ORM 的未来”中所做的那样，只需将此控制器添加到我们从现有数据库生成的应用程序中。你还需要在 `conf/` 目录下的 `route` 文件中添加一个路由，如下所示：
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the app is running, accessing the `http://localhost:9000/mocksearch` URL
    in a browser will return the following mock JSON message:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行，在浏览器中访问 `http://localhost:9000/mocksearch` URL 将返回以下模拟 JSON 消息：
- en: '![Mocking Play responses with JSON](img/3637OS_07_02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JSON 模拟 Play 响应](img/3637OS_07_02.jpg)'
- en: 'Another convenient way to obtain a JSON test message that you can use to mock
    a response is to use the online service found at [http://json-generator.appspot.com](http://json-generator.appspot.com).
    It consists of a JSON generator that we can use as it is by simply clicking on
    the **Generate** button. By default, it will generate a JSON sample including
    random data in the panel to the right of the browser window, but adhering to the
    structure defined in the panel to the left, as illustrated in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方便的方法是使用在线服务来获取一个 JSON 测试消息，你可以用它来模拟响应，该服务位于 [http://json-generator.appspot.com](http://json-generator.appspot.com)。它包含一个
    JSON 生成器，我们可以通过简单地点击 **生成** 按钮直接使用它。默认情况下，它将在浏览器窗口右侧的面板中生成一个包含随机数据的 JSON 示例，但遵循左侧面板中定义的结构，如下面的截图所示：
- en: '![Mocking Play responses with JSON](img/3637OS_07_03.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JSON 模拟 Play 响应](img/3637OS_07_03.jpg)'
- en: You can click on the **Copy to** **clipboard** button and paste the resulting
    mock message directly into the response of the Play controller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击 **复制到** **剪贴板** 按钮并将生成的模拟消息直接粘贴到 Play 控制器的响应中。
- en: Calling web services from Play
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Play 调用 Web 服务
- en: In the previous section, to quickly experiment with the App Store search API,
    we have used the `dispatch` library; we have already introduced this library in
    [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*. Play provides its own HTTP library to be able to interact
    with other online web services. It is also built on top of the Java `AsyncHttpClient`
    library ([https://github.com/AsyncHttpClient/async-http-client](https://github.com/AsyncHttpClient/async-http-client)),
    as `dispatch` is.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，为了快速实验 App Store 搜索 API，我们使用了 `dispatch` 库；我们已经在 [第 3 章](ch03.html "第
    3 章。理解 Scala 生态系统") 中介绍了这个库，*理解 Scala 生态系统*。Play 提供了自己的 HTTP 库，以便与其他在线 Web 服务交互。它也是在
    Java `AsyncHttpClient` 库([https://github.com/AsyncHttpClient/async-http-client](https://github.com/AsyncHttpClient/async-http-client))之上构建的，就像
    `dispatch` 一样。
- en: 'Before we dive into invoking REST web services from Play controllers, let''s
    experiment a little bit with Play web services from the REPL. In a terminal window,
    either create a new Play project or go to the root directory of the one we have
    used in the previous sections. Once you get a Scala prompt after having typed
    the `> play console` command, enter the following commands:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到从 Play 控制器调用 REST Web 服务之前，让我们先在 REPL 中对 Play Web 服务进行一点实验。在一个终端窗口中，要么创建一个新的
    Play 项目，要么进入我们之前章节中使用的项目的根目录。一旦输入了 `> play console` 命令后获得 Scala 提示符，输入以下命令：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we are going to invoke a web service asynchronously, we need an execution
    context to handle the `Future` placeholder:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将异步调用 Web 服务，我们需要一个执行上下文来处理 `Future` 临时占位符：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now define a service URL that needs to be called. Here, we will take
    a simple web service that returns the geographic location of a site given as a
    parameter, according to the following signature:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个需要调用的服务 URL。这里，我们将使用一个简单的 Web 服务，该服务根据以下签名返回作为参数的网站的地理位置：
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The format parameter can either be `json` or `xml`, and the `site` will be
    a reference to a website:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 格式参数可以是 `json` 或 `xml`，而 `site` 将是对网站的引用：
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we saw earlier in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, when working with the `dispatch`
    library, a `Future` is a placeholder that contains the result of an asynchronous
    computation and can be in two states, either `completed` or `not`. Here, we want
    to print the result once it is available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在 [第 3 章](ch03.html "第 3 章。理解 Scala 生态系统") 中所见，*理解 Scala 生态系统*，当使用 `dispatch`
    库时，`Future` 是一个包含异步计算结果的占位符，并且可以处于两种状态之一，即 `完成` 或 `未完成`。这里，我们希望在结果可用时打印结果。
- en: 'We have only extracted the `region_name` item from the response; the whole
    JSON document is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只从响应中提取了 `region_name` 项；整个 JSON 文档如下：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can encapsulate part of the response if we want to by creating a `case`
    class as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想封装响应的一部分，可以通过创建一个 `case` 类来实现，如下所示：
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `play-json` library includes support to read/write JSON structures via `Reads`/`Writes`/`Format`
    combinators based on `JsPath` so that validation can be made on the fly. If you
    are interested in all the details behind the use of these combinators, you may
    want to read through the blog at [http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/](http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`play-json`库包括基于`JsPath`的`Reads`/`Writes`/`Format`组合器的支持，以便可以在运行时进行验证。如果您对使用这些组合器的所有细节感兴趣，您可能想阅读以下博客：[http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/](http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/)。'
- en: '[PRE48]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, invoking the validate method on the JSON response will verify that the
    data we receive is well-formed and with acceptable values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JSON响应上调用验证方法将验证我们接收到的数据是否格式正确且具有可接受值。
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous `JsError` object illustrates a validation that failed; it detected
    that the `country` element is not found in the response. In fact, the correct
    spelling is `country_name` instead of `country`, which we can correct in our `locationReads`
    declaration. This time validation goes through and what we get as a response is
    a `JsSuccess` object containing the latitude and longitude information as we expect
    it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`JsError`对象展示了验证失败的情况；它检测到响应中未找到`country`元素。实际上，正确的拼写应该是`country_name`而不是`country`，我们可以在`locationReads`声明中更正这一点。这次验证通过了，我们得到的是我们期望的包含纬度和经度信息的`JsSuccess`对象：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s create a sample controller that invokes a web service to retrieve
    some data from the App Store:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个示例控制器，该控制器调用网络服务从App Store检索一些数据：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the call to the web service is illustrated by invoking methods on the
    `WS` class, first the `url` method giving the URL, then the `withQueryString`
    method with input parameters given as a sequence of `key->value` pairs. Notice
    that the returned type is a `Future`, meaning our web service is asynchronous.
    `recoverTotal` takes a function that will return a default value after managing
    the error. The line `json.validate[AppResult]` makes the JSON response validated
    against an `AppResult` object that is specified here (as part of a `Marketplace.scala`
    file in `app/models/` folder):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过在`WS`类上调用方法来展示对网络服务的调用，首先调用`url`方法给出URL，然后调用`withQueryString`方法，输入参数以`key->value`对的序列给出。请注意，返回类型是`Future`，这意味着我们的网络服务是异步的。`recoverTotal`接受一个函数，在处理错误后会返回默认值。`json.validate[AppResult]`这一行使JSON响应与这里指定的`AppResult`对象进行验证（作为`app/models/`文件夹中`Marketplace.scala`文件的一部分）：
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `AppResult` and `AppInfo` case classes are created to encapsulate the elements
    that we care about for our service. As you may have seen when first experimenting
    with the API, most of the search queries to the App Store return a large amount
    of elements, most of which we may not need. This is why, using some Scala syntactic
    sugar with combinators, we can validate the JSON response on the fly and directly
    extract the elements of interest. Before trying out this web service call, we
    just need to add the needed route to the `routes` file under `conf/`, as shown
    in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppResult`和`AppInfo`案例类被创建出来，用于封装我们关心的服务元素。正如您在首次尝试API时可能看到的，大多数对App Store的搜索查询都会返回大量元素，其中大部分我们可能不需要。这就是为什么，我们可以使用一些Scala语法糖和组合器，在运行时验证JSON响应并直接提取感兴趣的元素。在尝试这个网络服务调用之前，我们只需要在`conf/`目录下的`routes`文件中添加所需的路由，如下面的代码所示：'
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, before launching the application in a web browser, we also need the
    sample view that is referred to in the `MarketplaceController.scala` file by `html.marketplace.list`
    and created in a `list.scala.html` file under `views/marketplace/` in several
    parts as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在通过网络浏览器启动应用程序之前，我们还需要在`MarketplaceController.scala`文件中提到的示例视图，该视图在`views/marketplace/`目录下的`list.scala.html`文件中创建，并在几个部分中展示如下代码：
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first part of the view only consists of helper methods to navigate and
    is generated the same way as we did for the CRUD sample generation in [Chapter
    6](ch06.html "Chapter 6. Database Access and the Future of ORM"), *Database Access
    and the Future of ORM*. The second part of the view includes the JSON elements
    we have retrieved from the web service:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的第一个部分仅包含用于导航的辅助方法，其生成方式与我们在[第6章](ch06.html "第6章。数据库访问和ORM的未来")中用于CRUD示例生成的相同，即*数据库访问和ORM的未来*。视图的第二部分包括我们从网络服务中检索到的JSON元素：
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The third and final part of the view is handling pagination:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的第三部分和最后一部分是处理分页：
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once we re-launch the Play app with `> play run` and access (through a web
    browser) our local `http://localhost:9000/marketplace?f=candy+crush` URL that
    includes a default search from the App Store (the `f` parameter stands for `filter`),
    we will obtain a page similar to the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `> play run` 重新启动 Play 应用程序并通过（通过网页浏览器）访问我们的本地 `http://localhost:9000/marketplace?f=candy+crush`
    URL（该 URL 包含来自应用商店的默认搜索，其中 `f` 参数代表 `filter`），我们将获得一个类似于以下截图的页面：
- en: '![Calling web services from Play](img/3637OS_07_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![从 Play 调用 Web 服务](img/3637OS_07_04.jpg)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw some examples on how to manipulate the XML and JSON
    formats in Scala and how to connect to other systems via web services. In the
    case of XML, we also covered how to generate SOAP bindings out of a WSDL description
    as well as Scala classes to encapsulate the XML domain included in an XML schema.
    Web services in the Play Framework run asynchronously, which means that the caller
    is not waiting for the answer to come back before he continues to do other useful
    processing (such as serving other requests). In the next chapter, we are going
    to study this notion of asynchronous invocations more precisely. It is based on
    the concepts of `Future` and `Promise` that are also emerging in the Java world
    to deal with the execution of concurrent code. In particular, we will go through
    the Akka framework, an open source toolkit and runtime simplifying the construction
    of concurrent applications. Designed and written in Scala, Akka contains both
    Scala and Java APIs and is the basis of the Play Framework infrastructure that
    makes the Play Framework an ideal candidate for running scalable web applications
    on multicore architectures.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了一些关于如何在 Scala 中操作 XML 和 JSON 格式以及如何通过 Web 服务连接到其他系统的示例。在 XML 的情况下，我们还介绍了如何从
    WSDL 描述中生成 SOAP 绑定以及 Scala 类来封装 XML 模式中包含的 XML 领域。Play 框架中的 Web 服务是异步运行的，这意味着调用者在他继续进行其他有用处理（例如服务其他请求）之前不需要等待答案返回。在下一章中，我们将更精确地研究这种异步调用的概念。它基于
    `Future` 和 `Promise` 的概念，这些概念也在 Java 世界中兴起，用于处理并发代码的执行。特别是，我们将通过 Akka 框架，这是一个开源工具包和运行时，它简化了并发应用程序的构建。Akka
    是由 Scala 设计和编写的，包含 Scala 和 Java API，是 Play 框架基础设施的基础，使 Play 框架成为在多核架构上运行可扩展 Web
    应用的理想选择。
