- en: Fast Track to OOP - Classes and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程快速入门 - 类和接口
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Implementing object-oriented design using classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类实现面向对象设计
- en: Using inner classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部类
- en: Using inheritance and composition to make the design extensible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和组合来使设计可扩展
- en: Coding to an interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向接口编码
- en: Creating interfaces with default and static methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: Creating interfaces with private methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: Using enums to represent constant entities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举表示常量实体
- en: Using the @Deprecated annotation to deprecate APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用@Deprecated注解弃用API
- en: Using HTML5 in Javadocs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Javadocs中使用HTML5
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter gives you a quick introduction to the components of OOP and covers
    the new enhancements in these components in Java 8 and Java 9\. We will also try
    to cover a few good **object-oriented design** (**OOD**) practices wherever applicable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您快速介绍了面向对象编程的组件，并涵盖了Java 8和Java 9中这些组件的新增强功能。我们还将尝试在适用的情况下涵盖一些好的面向对象设计（OOD）实践。
- en: Throughout the recipes, we will use the new (introduced in Java 8 and Java 9)
    enhancements, define and demonstrate the concepts of OOD using specific code examples,
    and present new capabilities for better code documentation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个食谱中，我们将使用新的增强功能（Java 8和Java 9中引入），定义并使用具体的代码示例演示面向对象设计（OOD）的概念，并展示新的代码文档化能力。
- en: 'One can spend many hours reading articles and practical advice on OOD in books
    and on the Internet. Some of this activity can be beneficial for some people.
    But, in our experience, the fastest way to get hold of OOD is to try its principles
    early in your own code. This is exactly the goal of this chapter: to give you
    a chance to see and use the OOD principles so that the formal definition makes
    sense immediately.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可以在书籍和互联网上花费许多小时阅读关于面向对象设计（OOD）的文章和实用建议。其中一些活动对某些人可能有益。但根据我们的经验，掌握面向对象设计的最快方式是在自己的代码中尽早尝试其原则。这正是本章的目的：让您有机会看到并使用面向对象设计（OOD）原则，以便正式定义能立即理解。
- en: One of the main criteria of well-written code is its clarity of expressing its
    intent. A well-motivated and clear design helps achieve this. The code is run
    by a computer, but it is maintained and extended by humans. Keeping this in mind
    will assure longevity of the code written by you and perhaps even a few thanks
    and mentions with appreciation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一段好代码的主要标准之一是其表达意图的清晰度。一个有动机且清晰的设计有助于实现这一点。代码是由计算机运行的，但它是由人类维护和扩展的。记住这一点将确保您编写的代码的长期有效性，也许还能得到一些感谢和赞赏的提及。
- en: 'In this chapter, you will learn how to use the five basic OOD concepts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用五个基本的面向对象设计（OOD）概念：
- en: Object/Class - Keeping data and procedures together
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象/类 - 将数据和过程放在一起
- en: Encapsulation - Hiding data and/or procedures
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装 - 隐藏数据或过程
- en: Inheritance - Extending another class data and/or procedures
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承 - 扩展另一个类的数据或过程
- en: Interface - Deferring the implementation and coding for a type
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口 - 延迟类型实现的编码
- en: Polymorphism - Using the base class type for all its extensions when a parent
    class reference is used to refer to a child class object
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性 - 当使用父类引用来引用子类对象时，使用基类类型为其所有扩展
- en: These concepts will be defined and demonstrated in the code snippets presented
    in this chapter. If you search the Internet, you may notice that many other concepts
    and additions to them can be derived from the five points we just discussed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念将在本章提供的代码片段中定义和演示。如果您在互联网上搜索，可能会注意到许多其他概念和它们的补充都可以从我们刚才讨论的五个要点中推导出来。
- en: Although the following text does not require prior knowledge of OOD, some experience
    of writing code in Java would be beneficial. The code samples are fully functional
    and compatible with Java 9\. For better understanding, we recommend that you try
    to run the presented examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下文本不需要对面向对象设计（OOD）有先前的知识，但有一些使用Java编写代码的经验将是有益的。代码示例完全有效，且与Java 9兼容。为了更好地理解，我们建议您尝试运行所提供的示例。
- en: We also encourage you to adapt the tips and recommendations in this chapter
    to your needs in the context of your team experience. Consider sharing your new-found
    knowledge with your colleagues and discuss how the described principles can be
    applied to your domain, for your current project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还鼓励您根据您在团队经验中的需求，将本章中的提示和建议适应到您的实际需求中。考虑与您的同事分享您新获得的知识，并讨论如何将描述的原则应用到您的领域，以及您当前的项目中。
- en: Implementing object-oriented design using classes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类实现面向对象设计
- en: 'In this recipe, you will learn about the first two OOD concepts: object/class
    and encapsulation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解前两个面向对象设计（OOD）概念：对象/类和封装。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The term *object* usually refers to the coupling of data and procedures that
    can be applied to these data. Neither data, nor procedures are required, but one
    of them is--and, typically, both are--always present. The data are called object
    properties, while procedures are called methods. Properties capture the state
    of the object. Methods describe objects' behavior. Every object has a type, which
    is defined by its class (see the following). An object also is said to be an instance
    of a class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*对象*通常指的是将数据和处理程序（可以应用于这些数据）结合在一起。数据和处理程序都不是必需的，但其中之一是必需的，通常两者都是始终存在的。数据被称为对象属性，而处理程序被称为方法。属性捕获对象的状态。方法描述对象的行为。每个对象都有一个类型，该类型由其类定义（见下文）。一个对象也被说成是类的实例。
- en: The term *class* is a collection of the definitions of properties and methods
    that will be present in each of its instances--the objects created based on this
    class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*类*是一组定义，这些定义将存在于其每个实例中--基于此类创建的对象。
- en: Encapsulation is the hiding of object properties and methods that should not
    be accessible by other objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是指隐藏那些不应该被其他对象访问的对象属性和方法。
- en: Encapsulation is achieved by the Java keywords `private` or `protected` in the
    declaration of properties and methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是通过在属性和方法声明中使用Java关键字`private`或`protected`来实现的。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an `Engine` class with the `horsePower` property, the `setHorsePower()` method
    that sets this property''s value, and the `getSpeedMph()` method that calculates
    the speed of a vehicle, based on the time since the vehicle started moving, the
    vehicle weight, and the engine power:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`horsePower`属性、设置此属性值的`setHorsePower()`方法以及基于车辆启动以来经过的时间、车辆重量和发动机功率计算车辆速度的`getSpeedMph()`方法的`Engine`类：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `Vehicle` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Vehicle`类：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the application that will use these classes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将使用这些类的应用程序：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding application produces the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的应用程序产生以下输出：
- en: '![](img/588c3c06-9cce-4b44-b151-ef935580b1ff.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/588c3c06-9cce-4b44-b151-ef935580b1ff.png)'
- en: As you can see, an `engine` object was created by invoking the default constructor
    of the `Engine` class without parameters and with the Java keyword `new` that
    allocated memory for the newly created object on the heap.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，通过调用`Engine`类的默认构造函数并使用Java关键字`new`（在堆上为新创建的对象分配内存）不带参数地创建了一个`engine`对象。
- en: The second object, namely `vehicle`, was created with the explicitly defined
    constructor of the `Vehicle` class with two parameters. The second parameter of
    the constructor is an `engine` object that carries the `horsePower` property with
    the value set as `246`, using the `setHorsePower()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象，即`vehicle`，是通过使用`Vehicle`类的显式定义的构造函数创建的，该构造函数有两个参数。构造函数的第二个参数是一个`engine`对象，它携带了`horsePower`属性，其值通过`setHorsePower()`方法设置为`246`。
- en: It also contains the `getSpeedMph()` method that can be called by any other
    object that has access to the `engine` object, as it is done in the `getSpeedMph()`
    method of the `Vehicle` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含一个`getSpeedMph()`方法，可以被任何有权访问`engine`对象的另一个对象调用，就像在`Vehicle`类的`getSpeedMph()`方法中所做的那样。
- en: 'It''s worth noticing that the `getSpeedMph()` method of the `Vehicle` class
    relies on the presence of a value assigned to the `engine` property. The object
    of the `Vehicle` class delegates the speed calculation to the object of the `Engine`
    class. If the latter is not set (`null` passed in the `Vehicle()` constructor,
    for example), we will get `NullPointerException` at runtime. To avoid this, we
    can place a check for the presence of this value in the `Vehicle()` constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Vehicle`类的`getSpeedMph()`方法依赖于分配给`engine`属性值的存续。`Vehicle`类的对象将速度计算委托给`Engine`类的对象。如果后者未设置（例如，在`Vehicle()`构造函数中传递`null`），则在运行时将得到`NullPointerException`。为了避免这种情况，我们可以在`Vehicle()`构造函数中放置一个检查这个值是否存在：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, we can place a check in the `getSpeedMph()` method of the `Vehicle` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`Vehicle`类的`getSpeedMph()`方法中放置一个检查：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way, we avoid the ambiguity of `NullPointerException` and tell the user
    exactly what the source of the problem was.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们避免了`NullPointerException`的不确定性，并确切地告诉用户问题的来源。
- en: 'As you may have noticed, the `getSpeedMph()` method can be removed from the `Engine`
    class and fully implemented in the `Vehicle`: class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，`getSpeedMph()` 方法可以从 `Engine` 类中移除，并在 `Vehicle` 类中完全实现：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To do this, we would need to add the public method `getHorsePower()` to the `Engine`
    class in order to make it available for usage by the `getSpeedMph()` method in
    the `Vehicle` class. For now, we leave the `getSpeedMph()` method in the `Engine`.
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要向 `Engine` 类添加一个 `public` 方法 `getHorsePower()`，以便使其可用于 `Vehicle`
    类中的 `getSpeedMph()` 方法。现在，我们保留 `Engine` 类中的 `getSpeedMph()` 方法。
- en: This is one of the design decisions you need to make. If you think that an object
    of the `Engine` class is going to be passed around to the objects of different
    classes (not only `Vehicle`), then you would need to keep the `getSpeedMph()`
    method in the `Engine` class. Otherwise, if you think that the `Vehicle` class
    is going to be responsible for the speed calculation (which makes sense, since
    it is the speed of a vehicle, not of an engine), then you should implement the
    method inside the `Vehicle` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做出的设计决策之一。如果你认为 `Engine` 类的对象将被传递给不同类的对象（而不仅仅是 `Vehicle`），那么你需要在 `Engine`
    类中保留 `getSpeedMph()` 方法。否则，如果你认为 `Vehicle` 类将负责速度计算（这是有意义的，因为它是车辆的速度，而不是引擎的速度），那么你应该在
    `Vehicle` 类内部实现该方法。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Java provides a capability to extend a class and allow the subclass to access
    all of the functionality of the base class. For example, you can decide that every
    object that could be asked about its speed belongs to a subclass that is derived
    from the `Vehicle` class. In such a case, `Car` may look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了扩展类的能力，允许子类访问基类的所有功能。例如，你可以决定所有可以询问其速度的对象都属于从 `Vehicle` 类派生出的子类。在这种情况下，`Car`
    可能看起来像这样：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can change our test code by replacing the `Vehicle` class with the `Car`
    class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将 `Vehicle` 类替换为 `Car` 类来更改我们的测试代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When run, it produces the same value as with an object of the `Vehicle` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，它产生的值与 `Vehicle` 类对象的值相同：
- en: '![](img/9d1e55c8-80ef-4773-9d71-a2a59cca2ec7.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d1e55c8-80ef-4773-9d71-a2a59cca2ec7.png)'
- en: 'Because of polymorphism, a reference to the object of the `Car` class can be
    assigned to the reference of the base class, that is, `Vehicle`. The object of
    the `Car` class has two types: its own type, that is, `Car` and the type of the
    base class, namely `Vehicle`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态性，`Car` 类对象的引用可以被分配给基类（即 `Vehicle`）的引用。`Car` 类的对象有两个类型：它自己的类型，即 `Car`，以及基类的类型，即
    `Vehicle`。
- en: In Java, a class can also implement multiple interfaces, and the object of such
    a class would have a type of each of the implemented interfaces too. We will talk
    about this in subsequent recipes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，一个类也可以实现多个接口，此类对象的类型也会是每个实现接口的类型。我们将在后续的菜谱中讨论这一点。
- en: There are usually several ways to design an application for the same functionality.
    It all depends on the needs of your project and the style adopted by the development
    team. But in any context, clarity of design will help you communicate the intent.
    Good design contributes to the quality and longevity of the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有几种方式来设计具有相同功能的应用程序。这完全取决于你项目的需求和发展团队采用的风格。但在任何情况下，设计清晰都将帮助你传达意图。良好的设计有助于提高代码的质量和寿命。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下菜谱：
- en: Using inheritance and composition to make the design extensible
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和组合来使设计可扩展
- en: Using inner classes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部类
- en: 'In this recipe, you will learn about three types of inner classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解三种类型的内部类：
- en: '**Inner class**: This is a class defined inside another (enclosing) class.
    Its accessibility from outside the enclosing class is regulated by the `public`,
    `protected`, and `private` keywords. It can access the private members of the
    enclosing class, and the enclosing class can access the private members of its
    inner class.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部类**：这是在另一个（封装）类内部定义的类。其从外部封装类访问的权限由 `public`、`protected` 和 `private` 关键字控制。它可以访问封装类的私有成员，封装类可以访问其内部类的私有成员。'
- en: '**Method-local inner class**: This is a class defined inside a method. Its
    scope is restricted to within the method.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法局部内部类**：这是在方法内部定义的类。其作用域限制在方法内部。'
- en: '**Anonymous inner class**: This is an anonymous class defined during object
    instantiation.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名内部类**：这是在对象实例化期间定义的匿名类。'
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When a class is used by one, and only one, other class, the designer might decide
    that there is no need to make such a class public. For example, let's assume that
    the Engine class is used by the `Vehicle` class only.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类只被一个其他类使用时，设计者可能会决定没有必要使此类公开。例如，假设`Engine`类只被`Vehicle`类使用。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `Engine` class as an inner class of the `Vehicle` class:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Engine`类作为`Vehicle`类的内部类创建：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the `getSpeedMph()` method of the `Vehicle` class has access to
    the `Engine` class (although it is declared `private`) and even to the private
    `getSpeedMph()` method of the `Engine` class. The inner class has access to all
    the private elements of the enclosing class too. This is why `getSpeedMph()` of
    the `Engine` class has access to the private `getWeightPounds()` method of the
    enclosing `Vehicle` class.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`Vehicle`类的`getSpeedMph()`方法可以访问`Engine`类（尽管它被声明为`private`），甚至可以访问`Engine`类的私有`getSpeedMph()`方法。内部类也可以访问封装类的所有私有元素。这就是为什么`Engine`类的`getSpeedMph()`方法可以访问封装类`Vehicle`的私有`getWeightPounds()`方法。
- en: 'Look closer at the usage of the inner class `Engine`. Only the `getSpeedMph()`
    method uses it. If the designer believes that it is going to be the case in future
    too, it would be reasonable to make it method-local inner class, which is the
    second type of an inner class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更仔细地看看内部类`Engine`的使用。只有`getSpeedMph()`方法使用了它。如果设计者认为将来也会是这样，那么将其作为方法局部内部类（内部类的第二种类型）是合理的：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Encapsulation--hiding the state and behavior of objects--helps avoid unexpected
    side effects resulting from an accidental change or overriding. It makes the behavior
    more predictable and easier to understand. That's why a good design exposes only
    the functionality that must be accessible from the outside. Typically, this is
    the main functionality that motivated the class creation in the first place.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 封装——隐藏对象的状态和行为——有助于避免由于意外更改或覆盖而导致的意外副作用。这使得行为更加可预测，更容易理解。这就是为什么一个好的设计只暴露必须从外部访问的功能。通常，这是最初创建类的动机所在的主要功能。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Whether the `Engine` class is implemented as an inner class or a method-local
    inner class, the test code looks the same:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Engine`类是作为内部类还是方法局部内部类实现，测试代码看起来都是一样的：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we run this program, we get the same output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们将得到相同的输出：
- en: '![](img/4ce136e8-9e00-42a0-b323-1a0a023d2cfa.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ce136e8-9e00-42a0-b323-1a0a023d2cfa.png)'
- en: 'Now, let''s assume we need to test different implementations of the `getSpeedMph()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们需要测试`getSpeedMph()`方法的多种实现：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If this speed calculation formula does not make sense to you, you are correct.
    It does not. We did it for making the result predictable and different from the
    result of the previous implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个速度计算公式对你来说没有意义，你是正确的。它确实没有。我们这样做是为了使结果可预测，并且与之前实现的结果不同。
- en: There are many ways to introduce this new implementation. We can change the implementation
    of the `getSpeedMph()` method in the `Engine` class, for example. Or, we can change
    the implementation of the same method in the `Vehicle` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以引入这种新的实现。例如，我们可以更改`Engine`类中`getSpeedMph()`方法的实现。或者，我们可以更改`Vehicle`类中相同方法的实现。
- en: 'In this recipe, we will do this using the third type of inner class called
    anonymous inner class. This approach is especially handy when you want to write
    as little new code as possible or you want to quickly test the new behavior by
    temporarily overriding the old one. The code would then look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用第三种类型的内部类，称为匿名内部类。当你想尽可能少地编写新代码或想通过临时覆盖旧代码来快速测试新行为时，这种方法特别有用。代码将如下所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run this program, the result would be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，结果将如下所示：
- en: '![](img/9b37c5de-af1d-4660-bc11-44725cd18112.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b37c5de-af1d-4660-bc11-44725cd18112.png)'
- en: We have overridden the `Vehicle` class implementation by leaving only one method
    in it--the `getSpeedMph()` method that returns hardcoded value. We could override
    other methods or add new ones, but we will keep it simple for demonstration purposes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过只留下一个方法（返回硬编码值的`getSpeedMph()`方法）来覆盖`Vehicle`类的实现。我们也可以覆盖其他方法或添加新方法，但为了演示目的，我们将保持简单。
- en: 'By definition, anonymous inner class has to be an expression that is part of
    a statement that ends (as any statement) with a semicolon. The expression is composed
    of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，匿名内部类必须是一个表达式，它是语句的一部分，并以分号结束（就像任何语句一样）。该表达式由以下部分组成：
- en: The `new` operator
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`运算符'
- en: The name of the implemented interface (followed by parentheses `()` that represent
    the default constructor) or a constructor of the extended class (the latter is
    our case, the extended class being `Vehicle`)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的接口名称（后跟表示默认构造函数的括号`()`）或扩展类的构造函数（后者是我们的情况，扩展类是`Vehicle`）
- en: The class body with method declarations (statements are not allowed in the body
    of an anonymous inner class)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有方法声明（匿名内部类体中不允许有语句）的类体
- en: Like any inner classes, anonymous inner class can access any member of the enclosing
    class and can capture the values of its variables. To be able to do this, these
    variables have to be declared `final`. Otherwise, they become `final` implicitly,
    which means their values cannot be changed (a good modern IDE will warn you about
    the violation of this constraint if you try to change such a value).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何内部类一样，匿名内部类可以访问封装类的任何成员，并可以捕获其变量的值。为了能够这样做，这些变量必须声明为`final`。否则，它们会隐式地成为`final`，这意味着它们的值不能被更改（如果你尝试更改这样的值，一个好的现代IDE会警告你违反了这个约束）。
- en: 'Using these features, we can modify our sample code and provide more input
    data for the newly implemented `getSpeedMph()` method without passing them as
    method parameters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些特性，我们可以修改我们的示例代码，并为新实现的`getSpeedMph()`方法提供更多输入数据，而无需将它们作为方法参数传递：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the variables `timeSec`, `engineHorsePower`, and `vehicleWeightPounds`
    are accessible by the `getSpeedMph()` method of the inner class and cannot be
    modified. If we run this code, the result will be the same as before:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量`timeSec`、`engineHorsePower`和`vehicleWeightPounds`可以通过内部类的`getSpeedMph()`方法访问，但不能被修改。如果我们运行这段代码，结果将与之前相同：
- en: '![](img/6c68560b-cb9e-404e-891c-7c6936a8fef9.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c68560b-cb9e-404e-891c-7c6936a8fef9.png)'
- en: In the case of an interface with only one abstract method (called functional
    interface), a particular type of anonymous inner class, called **lambda expression**,
    it allows you to have a shorter notation but provides the interface implementation. We
    are going to discuss functional interface and lambda expression in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个抽象方法（称为函数式接口）的接口情况下，有一种特殊的匿名内部类，称为**lambda表达式**，它允许你使用更短的表示法，但提供了接口实现。我们将在下一章讨论函数式接口和lambda表达式。
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'An inner class is a non-static nested class. Java also allows you to create
    a static nested class that can be used when an inner class does not require access
    to non-public properties and methods of the enclosing class. Here is an example
    (the keyword `static` is added to the `Engine` class):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类是非静态嵌套类。Java还允许你创建一个静态嵌套类，当内部类不需要访问封装类的非公共属性和方法时可以使用。以下是一个示例（关键字`static`被添加到`Engine`类中）：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because a static class couldn't access a non-static member (the `getWeightPounds()`
    method of the enclosing class `Vehicle`), we were forced to pass the weight value
    to the `Engine` class during its construction (and we removed the `getWeightPounds()`
    method as it was not needed anymore).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为静态类不能访问非静态成员（封装类`Vehicle`的`getWeightPounds()`方法），我们被迫在构造`Engine`类时传递重量值（并且我们移除了不再需要的`getWeightPounds()`方法）。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下菜谱：
- en: Going functional
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走向函数式编程
- en: Using inheritance and composition to make the design extensible
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承和组合来使设计可扩展
- en: In this recipe, you will learn about two important OOD concepts, namely Inheritance
    and Polymorphism, which have been mentioned already and used in the examples of
    the previous recipes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解两个重要的面向对象设计（OOD）概念，即继承和多态，这些概念已经在之前的菜谱示例中提到并使用过。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Inheritance is the ability of one class to extend (and, optionally, override)
    the properties and/or methods of another class. The extended class is called the base
    class, superclass, or parent class. The new extension of the class is called a subclass or
    child class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是某个类扩展（可选地覆盖）另一个类的属性和/或方法的能力。被扩展的类被称为基类、超类或父类。新扩展的类被称为子类或子类。
- en: Polymorphism is the ability to use the base class as a type for the references
    to the objects of its subclasses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是使用基类作为其子类对象引用的类型的能力。
- en: To demonstrate the power of these two concepts, let's create classes that represent
    cars and trucks, each having weight, engine power, and speed it can reach (as
    a function of time) with maximum load. In addition, a car, in this case, will
    be characterized by the number of passengers, while a truck's important feature
    will be its payload.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这两个概念的力量，让我们创建代表汽车和卡车的类，每个类都有重量、发动机功率和最大负载下能到达的速度（作为时间的函数）。此外，在这种情况下，汽车将由乘客数量来表征，而卡车的重要特征将是其载货量。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Look at the `Vehicle` class:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看 `Vehicle` 类：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is an obvious commonality between a car and a truck that can be encapsulated
    in the `Vehicle` class as the base class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车和卡车之间存在一个明显的共性，可以封装在 `Vehicle` 类作为基类中。
- en: 'Create a subclass, called `Car`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Car` 的子类：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create another subclass, called `Truck`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `Truck` 的子类：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the base class `Vehicle` has neither an implicit or explicit constructor
    without parameters (because we have chosen to use an explicit constructor with
    parameters only), we will have to call the base class constructor `super()` as
    the first line of the constructor of every subclass.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基类 `Vehicle` 没有参数的隐式或显式构造函数（因为我们选择只使用带参数的显式构造函数），我们必须在每个子类的构造函数的第一行调用基类构造函数
    `super()`。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s write a test program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试程序：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the reference `vehicle` to the base class `Vehicle` points to the
    object of the subclass `Car`. This is made possible by polymorphism, according
    to which an object has a type of every class in its line of inheritance (including
    all the interfaces, which we will discuss a bit later).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对基类 `Vehicle` 的引用 `vehicle` 指向子类 `Car` 的对象。这是通过多态实现的，根据多态，一个对象具有其继承线上的每个类的类型（包括所有接口，我们将在稍后讨论）。
- en: One needs to cast such a reference to the subclass type, as you can see in the
    preceding example, in order to invoke a method that exists only in the subclass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，需要将此类引用转换为子类类型，以便调用仅在子类中存在的方法。
- en: 'If we run the preceding example, the results will be as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的示例，结果将如下所示：
- en: '![](img/8b22a6f7-658c-4f04-b790-1b31f7a1a897.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b22a6f7-658c-4f04-b790-1b31f7a1a897.png)'
- en: We should not be surprised to see the same speed, that is, `117.0 mph`, calculated
    for both--the car and the truck--because the same weight and engine power are
    used to calculate the speed of each. But, intuitively, we feel that a heavily
    loaded truck should not be able to reach the same speed as a car. To verify this,
    we need to include the total weight of the car (with the passengers and their
    luggage) and the truck (with the payload) in the `getSpeedMph()` method. One way
    to do this is to override the `getSpeedMph()` method of the base class `Vehicle` in
    each of the subclasses.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到汽车和卡车都计算出了相同的速度，即 `117.0 mph`，这并不令人惊讶——因为使用了相同的重量和发动机功率来计算每个的速度。但是，直观上，我们感觉一辆重载的卡车不应该能够达到与汽车相同的速度。为了验证这一点，我们需要在
    `getSpeedMph()` 方法中包含汽车（包括乘客和他们的行李）和卡车（包括货物）的总重量。一种方法是在每个子类中覆盖基类 `Vehicle` 的 `getSpeedMph()`
    方法。
- en: 'Now, add the `horsePower` and `weightPounds` properties and the following method
    to the `Car` class (we assume that a passenger with a luggage weighs 250 pounds
    total on average):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向 `Car` 类添加 `horsePower` 和 `weightPounds` 属性以及以下方法（我们假设一个乘客加上行李平均重250磅）：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, add the `horsePower` and `weightPounds` properties and the following
    method to the `Truck` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还要向 `Truck` 类添加 `horsePower` 和 `weightPounds` 属性以及以下方法：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The results of these two additions (if we run the same test class) will be
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个添加的结果（如果我们运行相同的测试类）将如下所示：
- en: '![](img/a6c54379-5e48-47eb-815f-e43f033390ca.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c54379-5e48-47eb-815f-e43f033390ca.png)'
- en: 'These results do confirm our intuition: a fully loaded car or truck does not
    reach the same speed as an empty one.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果确实证实了我们的直觉：一辆满载的汽车或卡车不会达到与空载相同的速度。
- en: 'The new methods in the subclasses override `getSpeedMph()` of the base class
    `Vehicle`, although we access it via the base class reference:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中的新方法覆盖了基类 `Vehicle` 的 `getSpeedMph()` 方法，尽管我们通过基类引用来访问它：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The overridden method is dynamically bound, which means that the context of
    the method invocation is determined by the type of the actual object being referred
    to. Since, in our example, the reference `vehicle` points to an object of the
    subclass `Car`, the `vehicle.getSpeedMph()` construct invokes the method of the
    subclass, not the method of the base class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的方法是动态绑定的，这意味着方法调用的上下文由实际引用的对象类型决定。由于在我们的例子中，引用`vehicle`指向子类`Car`的对象，因此`vehicle.getSpeedMph()`构造调用的是子类的方法，而不是基类的方法。
- en: 'There is obvious code redundancy in the two new methods, which we can refactor
    by creating a method in the base class, that is, `Vehicle`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个新方法中存在明显的代码冗余，我们可以通过在基类中创建一个方法来重构，即`Vehicle`：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since this method is used by subclasses only, it can be protected (and thus,
    accessible only to the subclasses).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个方法只被子类使用，它可以被声明为受保护的（因此，只能由子类访问）。
- en: 'Here''s how the `getSpeedMph()` method of the `Car` subclass would look now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子类`Car`的`getSpeedMph()`方法将如下所示：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is how it will appear in the `Truck` subclass:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在`Truck`子类中的样子：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we need to modify the test class by adding casting. Otherwise, there will
    be a runtime error because the `getSpeedMph(int timeSec)` method does not exist
    in the base class `Vehicle`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过添加强制类型转换来修改测试类。否则，由于基类`Vehicle`中没有`getSpeedMph(int timeSec)`方法，将会有运行时错误：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you may have expected, the test class produces the same values:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，测试类产生了相同的值：
- en: '![](img/bf68928d-e7fa-45b2-836f-ad5e6b863228.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf68928d-e7fa-45b2-836f-ad5e6b863228.png)'
- en: 'To simplify the test code, we can drop casting and write the following instead:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试代码，我们可以省略强制类型转换，改写如下：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The speed values produced by this code remain the same.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生的速度值保持不变。
- en: 'Yet, there is an even simpler way to achieve the same effect. We can add the `getMaxWeightPounds()`
    method to the base class and each of the subclasses. The `Car` class will now
    look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更简单的方法可以达到相同的效果。我们可以将`getMaxWeightPounds()`方法添加到基类和每个子类中。`Car`类现在将如下所示：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here''s how the new version of the `Truck` class will look:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新版本的`Truck`类将呈现的样子：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need to add the `getMaxWeightPounds()` method to the base class so
    it can be used for the speed calculations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向基类添加`getMaxWeightPounds()`方法，以便它可以用于速度计算：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Adding an abstract method `getMaxWeightPounds()` to the `Vehicle` class makes
    the class abstract. This has a positive side effect: it enforces the implementation
    of the `getMaxWeightPounds()` method in each subclass.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vehicle`类中添加一个抽象方法`getMaxWeightPounds()`使该类成为抽象类。这有一个积极的影响：它强制每个子类实现`getMaxWeightPounds()`方法。
- en: 'The test class remains the same and produces the same results:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类保持不变，并产生相同的结果：
- en: '![](img/b773c1f3-bbdc-4df9-9f70-9c09acda2f24.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b773c1f3-bbdc-4df9-9f70-9c09acda2f24.png)'
- en: 'There is an even simpler code change for the same effect--to use the maximum
    weight in the speed calculations in the base class. If we get back to the original
    version of the classes, all we need to do is to pass the maximum weight to the
    constructor of the base class `Vehicle`. The resulting classes will look like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到相同的效果，有一个更简单的代码更改——在基类中用最大重量进行速度计算。如果我们回到类的原始版本，我们只需要将最大重量传递给基类`Vehicle`的构造函数。结果类将如下所示：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We added the weight of the passengers to the value we pass to the constructor
    of the superclass; this is the only change in this subclass. There was a similar
    change in the `Truck` subclass:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将乘客的重量添加到传递给超类构造函数的值中；这是这个子类中唯一的更改。在`Truck`子类中也有类似的更改：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The base class `Vehicle` remains the same:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基类`Vehicle`保持不变：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test class does not change and produces the same results:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类没有改变，并产生相同的结果：
- en: '![](img/695b3517-b722-44bb-b141-70c5175a291d.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/695b3517-b722-44bb-b141-70c5175a291d.png)'
- en: This last version--passing the maximum weight to the constructor of the base
    class--will now be the starting point for further demo code development.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个版本——将最大重量传递给基类构造函数——现在将成为进一步演示代码开发的起点。
- en: Composition makes the design more extensible
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合使设计更具可扩展性
- en: In the preceding example, the speed model is implemented in the `getSpeedMph()`
    method of the `Vehicle` class. If we need to use a different speed model (which
    includes more input parameters and is more tuned to certain driving conditions,
    for example), we would need to change the `Vehicle` class or create a new subclass
    to override the method. In the case when we need to experiment with tens or even
    hundreds of different models, this approach becomes untenable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，速度模型是在`Vehicle`类的`getSpeedMph()`方法中实现的。如果我们需要使用不同的速度模型（例如，它包括更多的输入参数，并且更适应某些驾驶条件），我们需要更改`Vehicle`类或创建一个新的子类来覆盖该方法。当我们需要实验数十个甚至数百个不同的模型时，这种方法变得不可行。
- en: Also, in real life, modeling based on machine learning and other advanced techniques
    becomes so involved and specialized, that it is quite common that the modeling
    of car acceleration is done by a different team, not the team that builds vehicles.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在现实生活中，基于机器学习和其他高级技术的建模变得如此复杂和专业，以至于汽车加速的建模通常由一个不同的团队来完成，而不是构建车辆的团队。
- en: To avoid the proliferation of subclasses and code merge conflicts between vehicle
    builders and speed model developers, we can create a more extensible design using
    composition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免车辆构建者和速度模型开发者之间子类过多和代码合并冲突，我们可以通过组合来创建一个更可扩展的设计。
- en: Composition is an OOD principle for implementing the necessary functionality
    using the behavior of classes that are not part of the inheritance hierarchy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是实现必要功能的一种OOD原则，使用的是不属于继承层次结构的类的行为。
- en: 'We can encapsulate the speed calculations inside the `SpeedModel` class in
    the `getSpeedMph()` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`SpeedModel`类的`getSpeedMph()`方法中封装速度计算：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An object of this class can be created and then set on the `Vehicle` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建此类的一个对象，并将其设置在`Vehicle`类上：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, the test class may look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试类可能看起来像这样：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result will be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/f73ccaca-62d9-47e6-adf5-0bc130d5000f.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f73ccaca-62d9-47e6-adf5-0bc130d5000f.png)'
- en: We isolated the speed calculating functionality in a separate class and can
    now modify or extend it without changing any class of the `Vehicle` hierarchy.
    This is how the composition design principle allows you to change the behavior
    of the `Vehicle` class and its subclasses without changing their implementation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将速度计算功能隔离到一个单独的类中，现在可以修改或扩展它，而无需更改`Vehicle`层次结构中的任何类。这就是组合设计原则如何允许你更改`Vehicle`类及其子类的行为，而无需更改它们的实现。
- en: In the next recipe, we will show how the OOD concept of Interface unlocks more
    power of composition and polymorphism, making the design simpler and even more
    expressive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将展示OOD概念接口如何解锁组合和多态的更多功能，使设计更简单，甚至更具表现力。
- en: See also
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下菜谱：
- en: Coding to an interface
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向接口的编码
- en: Using enums to represent constant entities
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举来表示常量实体
- en: Coding to an interface
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向接口的编码
- en: In this recipe, you will learn about the last of the OOD concepts, called Interface,
    and further practice the usage of composition and polymorphism as well as inner
    classes and inheritance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解OOD概念中的最后一个，称为接口，并进一步练习组合和多态的使用，以及内部类和继承。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Interface, in this case, is a reference type that defines the signatures of
    the methods one can expect to see in the class that implements the interface. It
    is the public face of the functionality accessible to a client and is thus often
    called an **Application Program Interface** (**API**). It supports polymorphism
    and composition and thus facilitates even more flexible and extensible design.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，接口是一种引用类型，它定义了实现该接口的类可以期望看到的方法签名。它是客户端可访问的功能的公共面孔，因此通常被称为**应用程序程序接口**（**API**）。它支持多态和组合，从而促进了更灵活和可扩展的设计。
- en: An interface is implicitly abstract, which means it cannot be instantiated (no
    object can be created based on an interface only). It is used to contain abstract
    methods (without body) only. Now, since Java 8, it is possible to add default
    and private methods to an interface--the capability we are going to discuss in
    the following recipes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是隐式抽象的，这意味着它不能被实例化（不能仅基于接口创建对象）。它只用于包含抽象方法（没有方法体）。现在，自从Java 8以来，可以向接口添加默认和私有方法--我们将在接下来的菜谱中讨论这一功能。
- en: Each interface can extend multiple other interfaces and, similar to class inheritance,
    inherit all the methods of the extended interfaces.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口可以扩展多个其他接口，并且类似于类继承，继承扩展接口的所有方法。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create interfaces that will describe the API:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建描述API的接口：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Use factories, which are classes that generate objects that implement certain
    interfaces. A factory is an implementation of a pattern for creating objects without
    having to specify the exact class of the object that is created--specifying an
    interface only, rather than calling a constructor. It is especially helpful when
    an instance of object creation requires a complex process and/or significant code
    duplication.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工厂，这些是生成实现特定接口的对象的类。工厂是创建对象模式的实现，无需指定创建的对象的确切类——只需指定接口，而不是调用构造函数。当对象实例的创建需要复杂的过程和/或大量的代码重复时，这特别有帮助。
- en: 'In our case, it makes sense to have the `FactoryVehicle` class that will create
    objects for the `Vehicle`, `Car`, and `Truck` interfaces and the `FactorySpeedModel`
    class that will generate objects for the `SpeedModel` interface. Such an API will
    allow you to write the following code:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的情况下，有一个`FactoryVehicle`类来为`Vehicle`、`Car`和`Truck`接口创建对象，以及一个`FactorySpeedModel`类来为`SpeedModel`接口生成对象是有意义的。这样的API将允许您编写以下代码：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Observe that the code behavior is the same:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意代码行为是相同的：
- en: '![](img/4cb4d51f-2ed9-4e45-9cc0-b8a2a275cf7e.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cb4d51f-2ed9-4e45-9cc0-b8a2a275cf7e.png)'
- en: However, the design is much more extensible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设计要灵活得多。
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We have already seen one possible implementation of the `SpeedModel` class.
    Here is another way to do this inside the `FactorySpeedModel` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`SpeedModel`类的一个可能的实现。这里是在`FactorySpeedModel`类内部实现它的另一种方法：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We put comments (as pseudo code) and the `...` symbol instead of the code for
    brevity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们用注释（作为伪代码）和`...`符号代替了代码。
- en: As you can see, the factory class may hide many different private and static
    nested classes, each containing a specialized model for particular driving conditions.
    Each model brings different results.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，工厂类可以隐藏许多不同的私有和静态嵌套类，每个类都包含特定驾驶条件下的专用模型。每个模型都会带来不同的结果。
- en: 'An implementation of the `FactoryVehicle` class may look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryVehicle`类的实现可能如下所示：'
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, an interface describes how to invoke object behavior; it also
    allows you to generate different implementations for different requests (and provided
    values) without changing the code of the main application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，接口描述了如何调用对象行为；它还允许您在不更改主应用程序代码的情况下，为不同的请求（和提供的值）生成不同的实现。
- en: There's more...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's try to model a crew cab--a truck with multiple passenger seats that combines
    the properties of a car and a truck. Java does not allow multiple inheritances.
    This is another case where interfaces come to the rescue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试模拟一个乘员舱——一种结合了汽车和卡车特性的多乘客座位卡车。Java不允许多重继承。这是接口救命的一个例子。
- en: 'The `CrewCab` class may look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrewCab`类可能看起来像这样：'
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This class implements both the interfaces--`Car` and `Truck`--and passes the
    combined weight of the vehicle, payload, and passengers with their luggage to
    the base class constructor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了两个接口——`Car`和`Truck`——并将车辆的总重量、载货和乘客及其行李传递给基类构造函数。
- en: 'We can also add the following method to `FactoryVehicle`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向`FactoryVehicle`添加以下方法：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The double nature of the `CrewCab` object can be demonstrated in the following
    test:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrewCab`对象的二重性可以在以下测试中展示：'
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we can cast the object of the `CrewCub` class to each of the
    interfaces it implements. If we run this program, the results will be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以将`CrewCub`类的对象强制转换为它实现的每个接口。如果我们运行这个程序，结果将如下所示：
- en: '![](img/f6bb6903-fd2b-4b30-bedf-658be189bb28.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6bb6903-fd2b-4b30-bedf-658be189bb28.png)'
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating interfaces with default and static methods
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: Creating interfaces with private methods
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: Creating interfaces with default and static methods
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: 'In this recipe, you will learn about two new features that were first introduced
    in Java 8: default and static methods in an interface.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将了解Java 8首次引入的两个新功能：接口中的默认和静态方法。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: The default method allows you to add new functionality to an interface without
    changing the classes that have implemented this interface. The method is called
    *default* because it provides functionality in case a method is not implemented
    by the class. If, however, the class implements it, the interface's default implementation
    is ignored and overridden by the class implementation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法允许你在不更改实现该接口的类的情况下向接口添加新功能。这个方法被称为*默认*，因为它在类没有实现方法时提供功能。然而，如果类实现了它，接口的默认实现就会被忽略，并被类实现覆盖。
- en: Having a static method in an interface can provide functionality the same way
    a static method in a class can. As with a class static method (which can be called
    without class instantiation), an interface static method can also be called by
    adding the name of the interface in front of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的静态方法可以提供与类中的静态方法相同的功能。与类静态方法（可以在没有类实例化的情况下调用）一样，接口静态方法也可以通过在前面添加接口名称来调用。
- en: A static interface method cannot be overridden by any class, including the class
    that implements this interface, and it cannot hide any static method of any class,
    including the class that implements this interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 静态接口方法不能被任何类覆盖，包括实现该接口的类，它也不能隐藏任何类的静态方法，包括实现该接口的类。
- en: So far, we have created an amazing piece of software that calculates the speed
    of a vehicle. If this program becomes popular (as it should), it can be used by
    readers who prefer a metric system of weight units. To address such a need later--after
    our speed-calculating software has become popular--we have decided to add more
    methods to the `Truck` interface; however, we do not want to break the existing
    implementation of `FactoryVehicle`, created by some other company.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个令人惊叹的软件，它可以计算车辆的行驶速度。如果这个程序变得流行（正如它应该的那样），它就可以被那些喜欢使用重量单位公制系统的读者使用。为了满足这种需求——在我们计算速度的软件变得流行之后——我们决定向`Truck`接口添加更多方法；然而，我们不想破坏由其他公司创建的`FactoryVehicle`的现有实现。
- en: The default interface methods were introduced for exactly such a situation.
    Using them, we can release a new version of an interface without the need to coordinate
    it with the development of `FactoryVehicle`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口方法就是为了这种情况而引入的。使用它们，我们可以在不需要与`FactoryVehicle`的开发协调的情况下发布接口的新版本。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Enhance the `Truck` interface by adding the `getPayloadKg()` method, which
    returns the truck payload in kilograms. You can do this without forcing a change
    in the `TruckImpl` class that implements the `Truck` interface inside `FactoryVehicle`--by
    adding a new default method to the `Truck` interface:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`getPayloadKg()`方法来增强`Truck`接口，该方法返回以千克为单位的车辆载重。你可以通过向`FactoryVehicle`内部实现`Truck`接口的`TruckImpl`类添加新的默认方法来实现这一点，而不必强制改变该类：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice how the new method `getPayloadKg()` uses the existing `getPayloadPounds()` method
    as if the latter is implemented inside the interface too when, in fact, it is
    implemented by a class inside `FactoryVehicle`. The magic happens during runtime
    when this method becomes dynamically bound to the instance of the class that implements
    this interface.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新方法`getPayloadKg()`是如何像后者在接口内部实现一样使用现有的`getPayloadPounds()`方法的，尽管实际上它是`FactoryVehicle`内部的一个类实现的。这种魔法发生在运行时，当这个方法动态绑定到实现该接口的类的实例时。
- en: We could not make the `getPayloadKg()` method static because it would not be
    able to access the non-static `getPayloadPounds()` method, and we must use the
    `default` keyword because only the default or static method of an interface can
    have a body.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使`getPayloadKg()`方法成为静态的，因为它将无法访问非静态的`getPayloadPounds()`方法，我们必须使用`default`关键字，因为只有接口的默认或静态方法可以有主体。
- en: 'Write the demo code that uses the new method:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用新方法的演示代码：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the preceding program and see the output:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的程序并查看输出：
- en: '![](img/d779c3d6-9a12-4182-b28e-4a8f850a6a23.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d779c3d6-9a12-4182-b28e-4a8f850a6a23.png)'
- en: Notice that the new method works even without changing the class that implemented
    it.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这个新方法即使在没有更改实现它的类的情况下也能工作。
- en: 'Later, when you decide to improve the implementation of the `FactoryVehicle` class,
    you can do it by adding the corresponding method, for example:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你决定改进`FactoryVehicle`类的实现时，你可以通过添加相应的方法来实现，例如：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We made the `return -2` implementation in order to make it obvious which implementation
    is used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`return -2`的版本，以便使使用哪个实现变得明显。
- en: 'Run the same demo program. The results will be as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行相同的演示程序。结果将如下所示：
- en: '![](img/86a7f48c-f9c7-4b14-923d-ec2a9f861d8e.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86a7f48c-f9c7-4b14-923d-ec2a9f861d8e.png)'
- en: As you can see, the method in the `TruckImpl` class has overridden the default
    implementation in the `Truck` interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`TruckImpl`类中的方法已覆盖了`Truck`接口中的默认实现。
- en: 'Enhance the `Truck` interface with the ability to enter the payload in kilograms
    without changing the implementation of `FactoryVehicle`. But we would also like
    the `Truck` implementation to remain immutable, and we do not want to add a setter
    method. With all these limitations, our only recourse is to add `convertKgToPounds()`
    to the `Truck` interface, and it has to be `static` since we are going to use
    it before the object that implements the `Truck` interface is constructed:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不改变`FactoryVehicle`实现的情况下，增强`Truck`接口以能够以千克为单位输入载重。但我们还希望`Truck`实现保持不可变，并且我们不希望添加setter方法。在这些限制下，我们唯一的办法是在`Truck`接口中添加`convertKgToPounds()`，并且它必须是`static`的，因为我们将在实现`Truck`接口的对象构造之前使用它：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Fans who love using the metric system of units can now take advantage of the
    new method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢使用公制单位系统的粉丝现在可以利用新的方法：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The results will be as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/8ba684a5-eae1-4f97-9deb-7186ea1d6531.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ba684a5-eae1-4f97-9deb-7186ea1d6531.png)'
- en: The value 1,502 is close to the original 1,500, while 3,308 is close to 3,312\.
    The difference is caused by the error of approximation during the conversion.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 值1,502接近原始的1,500，而3,308接近3,312。差异是由转换过程中的近似误差引起的。
- en: See also
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下配方：
- en: Creating interfaces with private methods
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: Creating interfaces with private methods
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: 'In this recipe, you will learn about a new feature introduced in Java 9: private
    interface method, which is of two types, namely static and non-static.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将了解Java 9中引入的新功能：私有接口方法，它有两种类型，即静态和非静态。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Private methods in an interface are new in Java 9\. They allow you to make interface
    methods (with a body) accessible only to other methods (with a body) in the same
    interface.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的私有方法是在Java 9中引入的。它们允许您使接口方法（具有正文）仅对同一接口中的其他方法（具有正文）可访问。
- en: A private method in an interface cannot be overridden anywhere--not by a method
    of any interface, nor by a method in any class. Its only purpose is to contain
    functionality that is common between two or more methods with a body, either private
    or public, in the same interface. It can also be used by one method only in order
    to make the code easier to understand.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的私有方法在任何地方都不能被覆盖--既不能被任何接口的方法覆盖，也不能被任何类中的方法覆盖。它的唯一目的是包含两个或多个方法（无论是私有还是公共）之间的共同功能，这些方法在同一个接口中具有正文。它也可以仅由一个方法使用，以便使代码更容易理解。
- en: A private interface method must have an implementation. A private interface
    method not used by other methods of the same interface does not make sense.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 私有接口方法必须有一个实现。同一接口中未使用其他方法的私有接口方法没有意义。
- en: A static private interface method can be accessed by non-static and static methods
    of the same interface. The non-static private interface method can be accessed
    only by static methods of the same interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 静态私有接口方法可以被同一接口的非静态和静态方法访问。非静态私有接口方法只能被同一接口的静态方法访问。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add the `getWeightKg()` implementation too. Since we do not have the `getWeightPounds()`
    method in the interface, the method signature should include an input parameter:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加`getWeightKg()`实现。由于接口中没有`getWeightPounds()`方法，方法签名应包括一个输入参数：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Remove the redundant code using the private interface method:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用私有接口方法删除冗余代码：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following code demonstrates the new addition:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了新的添加：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The results of the test run do not change:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行的结果没有变化：
- en: '![](img/acc2484b-046c-4f1e-89bb-6eaebf0e6879.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acc2484b-046c-4f1e-89bb-6eaebf0e6879.png)'
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Well, with the `getWeightKg(int pounds)` method accepting the input parameter,
    the method name can be misleading because (by contrast, with `getPayloadKg()`)
    the method does not control the source of the data. The input value can represent
    anything. After realizing it, we decided that the interface would be better without
    it, but only after making the `convertPoundsToKg()` method public. Since it does
    not require access to the object elements, it can be static too:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`getWeightKg(int pounds)` 方法接受输入参数，方法名可能会误导，因为（与 `getPayloadKg()` 相比）该方法不控制数据来源。输入值可以代表任何东西。意识到这一点后，我们决定接口最好没有它，但只有在将
    `convertPoundsToKg()` 方法公开之后。由于它不需要访问对象元素，它也可以是静态的：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Fans of the metric system will still be able to convert pounds into kilograms
    and back. Besides, since the converting methods are static, we do not need to
    create an instance of the class that implements the `Truck` interface:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 公制系统的爱好者仍然可以将磅转换为千克，然后再转换回来。此外，由于转换方法都是静态的，我们不需要创建实现 `Truck` 接口的类的实例：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The results do not change:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 结果没有变化：
- en: '![](img/1911b481-e70a-4ea0-814c-c855c3fd9e66.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1911b481-e70a-4ea0-814c-c855c3fd9e66.png)'
- en: See also
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe of this chapter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating interfaces with default and static methods
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: Using enums to represent constant entities
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用枚举表示常量实体
- en: In this recipe, you will learn about the special data type `enum` that allows
    you to create a custom type with predefined values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将了解允许你创建具有预定义值的自定义类型的特殊数据类型 `enum`。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s have a quick look at a couple of examples. Here is the simplest possible
    `enum` type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下几个例子。这里是最简单的 `enum` 类型：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Say we run the following loop:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行以下循环：
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The results of this will be as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/2ff9021e-eb00-4482-9825-3876c3ec2606.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ff9021e-eb00-4482-9825-3876c3ec2606.png)'
- en: The `enum` type implicitly extends `java.util.Enum` (so you cannot extend your
    custom type `RoadCondition`, for example) and automatically acquires its methods.
    In the preceding code, we have already seen one (the most useful) method, `values()`,
    that returns an array of the `enum` elements.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 类型隐式扩展 `java.util.Enum`（因此你不能扩展你自定义的类型 `RoadCondition`，例如）并自动获得其方法。在前面的代码中，我们已经看到了一个（最有用的）方法，`values()`，它返回
    `enum` 元素的数组。'
- en: Another useful `enum` method is `valueOf(String)` that returns the constant
    of the specified `enum` type with the specified name (passed in as `String`).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 `enum` 方法是 `valueOf(String)`，它返回具有指定名称（作为 `String` 传入）的指定 `enum` 类型的常量。
- en: 'The methods of each element include useful ones such as `equals()`, `name()`,
    and `ordinal()`. Now say we run the following loop:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素的方法包括有用的方法，例如 `equals()`、`name()` 和 `ordinal()`。现在假设我们运行以下循环：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will get the following result:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '![](img/88928175-8f84-407c-8704-ac44ca3a6dc4.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88928175-8f84-407c-8704-ac44ca3a6dc4.png)'
- en: As you may have guessed, `ordinal()` returns the position of the value in the
    `enum` declaration, starting with zero.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`ordinal()` 返回值在 `enum` 声明中的位置，从零开始。
- en: 'Other `enum` features include the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 `enum` 功能包括以下内容：
- en: The `enum` class body can include a constructor, methods, variables, and constants
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum` 类体可以包含构造函数、方法、变量和常量'
- en: The constructor is called automatically when `enum` is accessed the first time
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `enum` 第一次被访问时，构造函数会自动调用
- en: The static constant can be accessed via the class name
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态常量可以通过类名访问
- en: The non-static constant can be accessed via any of the elements
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态常量可以通过任何元素访问
- en: Java comes with several predefined `enum` types, including `DayOfWeek` and `Month`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Java 包含几个预定义的 `enum` 类型，包括 `DayOfWeek` 和 `Month`。
- en: To make it look more like a real-life `enum`, let's use traction coefficient
    as an element value. Such a coefficient reflects the degree of traction between
    the road and the tires. The higher the value, the better the traction. This value
    can be used for the improvement of a vehicle speed calculation. For example, `SpeedModel`
    should be able to receive `RoadCondition.WET` and extract the traction coefficient
    `0.2` from it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它看起来更像现实生活中的 `enum`，让我们使用牵引系数作为元素值。这样的系数反映了道路和轮胎之间的牵引程度。值越高，牵引力越好。这个值可以用于改进车辆速度计算。例如，`SpeedModel`
    应该能够接收 `RoadCondition.WET` 并从中提取牵引系数 `0.2`。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define the `RoadCondition` enumeration in the `SpeedModel` interface (because
    it is part of the `SpeedModel` API):'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SpeedModel` 接口中定义 `RoadCondition` 枚举（因为它属于 `SpeedModel` API）：
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There is no need to add the `public` keyword in front of `enum RoadCondition` because,
    in an interface, it defaults to `public` (if the `private` keyword is not used
    instead).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，无需在 `enum RoadCondition` 前添加 `public` 关键字，因为默认情况下它就是 `public`（除非使用 `private`
    关键字代替）。
- en: 'Run the following loop:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下循环：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You''ll get the following result:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将得到以下结果：
- en: '![](img/6926d3f5-dcd9-4a2e-bf05-14ec9220152d.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6926d3f5-dcd9-4a2e-bf05-14ec9220152d.png)'
- en: 'Add `enum TireCondition` to the `iSpeedModel` interface too:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `enum TireCondition` 也添加到 `iSpeedModel` 接口：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add `enum` for `DrivingCondition`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `DrivingCondition` 添加 `enum`：
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'With the three `enum` types in place, we can calculate the vehicle speed of
    all the possible combinations of the given driving conditions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了三个 `enum` 类型之后，我们可以计算给定驾驶条件所有可能组合的车辆速度：
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The results will be as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/7044df96-2382-4ce6-80a0-c79796543285.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7044df96-2382-4ce6-80a0-c79796543285.png)'
- en: That is how `enum` allows you to define an API input and make input data validation
    unnecessary.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `enum` 如何允许你定义 API 输入并使输入数据验证成为不必要的。
- en: There's more...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The higher the temperature, the quicker the road dries out, and the traction
    coefficient is getting higher. To account for this, we can add a `temperature`
    property to `enum RoadCondition` and override the `getTraction()` method for the `WET` element,
    for example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 温度越高，道路越快干燥，牵引系数也越高。为了考虑这一点，我们可以在 `enum RoadCondition` 中添加一个 `temperature` 属性，并覆盖
    `WET` 元素的 `getTraction()` 方法，例如：
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can set the `temperature` property on `RoadCondition` before the speed
    calculation and get a different value of speed for the wet road condition. Add
    this line before calling the speed calculations:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在速度计算之前在 `RoadCondition` 上设置 `temperature` 属性，并得到湿路条件下的不同速度值。在调用速度计算之前添加此行：
- en: '[PRE62]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you do this, the results will be as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，结果将如下所示：
- en: '![](img/d678b27a-77e3-4d32-994c-b0a14e981ab5.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d678b27a-77e3-4d32-994c-b0a14e981ab5.png)'
- en: Using the @Deprecated annotation to deprecate APIs
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `@Deprecated` 注解来弃用 API
- en: In this recipe, you will learn about the deprecation of API elements and the
    enhancements of the `@Deprecated`  annotation in Java 9.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 API 元素的弃用以及 Java 9 中 `@Deprecated` 注解的增强。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `@Deprecated` annotation was first introduced in Java 5, while the Javadoc
    tag `@deprecated` was introduced in Java even earlier. The presence of the annotation
    forces the compiler to generate a warning that can be suppressed by the annotation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Deprecated` 注解首次在 Java 5 中引入，而 Javadoc 标签 `@deprecated` 在 Java 中更早被引入。该注解的存在会强制编译器生成一个警告，该警告可以通过注解来抑制：'
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since Java 9, the annotation can have one or both the methods, namely `since()`
    and `forRemoval()`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Java 9 以来，注解可以有一个或两个方法，即 `since()` 和 `forRemoval()`：
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `since()` method allows the setting of the API version (as `String`). It
    depicts the API version from where the particular class or method was deprecated.
    If not specified, the default value of the `since()` method is `""` (empty `String`).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`since()` 方法允许设置 API 版本（作为 `String`）。它描述了特定类或方法被弃用的 API 版本。如果没有指定，`since()`
    方法的默认值是 `""`（空 `String`）。'
- en: 'The `forRemoval()` method depicts the intent to remove the marked element (if
    `true`) or not (if `false`). If not set, the default value is `false`. If the
    `forRemoval()` method is present with the value `true` to suppress the warning,
    one needs to specify the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`forRemoval()` 方法描述了移除标记元素的意图（如果为 `true`）或不是（如果为 `false`）。如果没有设置，默认值是 `false`。如果
    `forRemoval()` 方法存在且值为 `true` 以抑制警告，则需要指定以下内容：'
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Look at the `Car` interface again:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次看看 `Car` 接口：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead of the `getPayloadKg()` method, introduce a more general method and
    `enum` for supporting the metric system of weight units:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代替 `getPayloadKg()` 方法，引入一个更通用的方法和 `enum` 以支持重量单位的公制系统：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Such an enhancement allows you to have more flexibility in future.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的增强使得你在未来有更多的灵活性。
- en: 'Deprecate the `getPayloadPounds()` method and add a Javadoc with explanations:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弃用 `getPayloadPounds()` 方法并添加带有解释的 Javadoc：
- en: '[PRE68]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Each of the methods in the `@Deprecated` annotation is optional.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Deprecated` 注解中的每个方法都是可选的。'
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If we compile the preceding code, there will be a warning *this method has been
    deprecated and marked for removal* at every place of its implementation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译前面的代码，在其实现的每个地方都会有一个警告*此方法已被弃用并标记为删除*。
- en: If the `forRemoval()` method is not present or set to `false`, the warning message
    would say *has been deprecated* only.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`forRemoval()`方法不存在或设置为`false`，警告信息只会说*已被弃用*。
- en: To avoid the warning, we need to either avoid using the deprecated method or
    suppress the warning as described earlier.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免警告，我们需要避免使用已弃用的方法或如前所述抑制警告。
- en: There's more...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In Java 9, both--the Javadoc tag `@deprecated` and `@Deprecated` annotation--are
    required. The presence of only one of them is considered an error.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，Javadoc标签`@deprecated`和`@Deprecated`注解都是必需的。只有其中一个存在被视为错误。
- en: Using HTML5 in Javadocs
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Javadocs中使用HTML5
- en: In this recipe, you will learn about the usage of HTML5 tags in the Javadoc
    comments in Java 9.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解在Java 9中Javadoc注释中HTML5标签的使用。
- en: Getting ready
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are plenty of sources on the Internet that describe HTML5 tags. Since
    Java 9, one can use any one of them in Javadoc comments.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多资源描述了HTML5标签。自从Java 9以来，可以在Javadoc注释中使用其中任何一个。
- en: HTML5 provides better browser compatibility. It is also more mobile-friendly
    than its predecessor, HTML4\. But to take advantage of HTML5, one has to specify
    the `-html5` parameter during Javadoc generation. Otherwise, only HTM4-style comments
    will continue to be supported.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5提供了更好的浏览器兼容性。它也比其前身HTML4更易于移动设备使用。但为了利用HTML5，必须在生成Javadoc时指定`-html5`参数。否则，将只继续支持HTM4风格的注释。
- en: How to do it...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here is an example of the HTML5 tags used for Javadoc comments:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于Javadoc注释的HTML5标签的示例：
- en: '[PRE69]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you are using IntelliJ IDEA, go to Tools | Generate JavaDoc... and set the
    `-html5` value in the Other command line arguments field and click on OK. Without
    an IDE, use the following command:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用IntelliJ IDEA，请转到工具 | 生成JavaDoc... 并在其他命令行参数字段中设置`-html5`值，然后点击确定。如果没有IDE，请使用以下命令：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Consider the following example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '![](img/64f67412-aa5d-4f8b-ae17-162cac5bb934.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f67412-aa5d-4f8b-ae17-162cac5bb934.png)'
- en: Here, `src` is the folder that contains the source code in the `com` subfolder,
    and `api` is a folder in the current directory where Javadoc is going to be stored.
    The `com.cookbook.oop` is the package for which you want to generate Javadoc.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`src`是包含`com`子文件夹中源代码的文件夹，而`api`是当前目录中将要存储Javadoc的文件夹。`com.cookbook.oop`是你想要生成Javadoc的包。
- en: 'The resulting Javadoc will look like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Javadoc将看起来像这样：
- en: '![](img/113f566e-6e34-4e39-9189-c957049dbbd3.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/113f566e-6e34-4e39-9189-c957049dbbd3.png)'
- en: 'The preceding description is taken from the text inside tags `<h2>`, but its
    font is not different from other lines. Here''s how the full description will
    look:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述是从`<h2>`标签内的文本中提取的，但它的字体与其他行没有区别。完整的描述将如下所示：
- en: '![](img/5462c68d-d7c2-41ce-aae5-edc7aebeb87c.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5462c68d-d7c2-41ce-aae5-edc7aebeb87c.png)'
- en: You can see how prominently the text in tags `<h2>` and `<h3>` is presented
    and the `here` link is highlighted and can be clicked.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到标签`<h2>`和`<h3>`中的文本是如何突出显示的，以及`here`链接是如何被突出显示并可以点击的。
