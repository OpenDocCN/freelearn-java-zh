- en: Deep Dive into Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨函数
- en: Scala combines both object-oriented and functional programming paradigms. In
    particular, functions are a first-class language concept. They can be defined
    in a variety of ways, assigned to variables, passed as parameters, and stored
    in data structures. Scala gives a lot of flexibility with regard to how these
    actions can be performed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Scala结合了面向对象和函数式编程范式。特别是，函数是一个一等语言概念。它们可以用各种方式定义，分配给变量，作为参数传递，并存储在数据结构中。Scala在如何执行这些操作方面提供了很大的灵活性。
- en: We'll start this chapter by looking in detail at different flavors of defining
    a function. We'll then go on and apply the knowledge about types from the previous
    chapter to make our functions polymorphic and higher order. We'll study recursion,
    tail recursion, and trampolining as important aspects of functional programming
    for the JVM. Finally, we'll evaluate peculiarities related to the fact that functions
    in Scala are implemented in an object-oriented way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先详细研究定义函数的不同方式。然后我们将继续应用上一章关于类型的知识，使我们的函数成为多态和更高阶的。我们将研究递归、尾递归和跳跃作为JVM函数式编程的重要方面。最后，我们将评估与Scala中的函数以面向对象方式实现相关的特殊性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Ways to define a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数的方法
- en: Polymorphic functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态函数
- en: Higher order functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Trampolining
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃
- en: Object-oriented aspects of functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的面向对象特性
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: JDK 1.8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available under [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03)找到。
- en: Ways to define a function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数的方法
- en: To provide some common ground for the readers with different levels of Scala
    knowledge, let's recap how a function can be defined. We'll start with the basic
    approaches such as defining a method and placing it in different scopes to create
    a local function. Then we'll look at more interesting aspects, for example closing
    over scope, partial application, different ways to specify function literals,
    and, finally, currying.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为不同Scala知识水平的读者提供一个共同的基础，让我们回顾一下如何定义一个函数。我们将从基本方法开始，例如定义一个方法并将其放置在不同的作用域中以创建一个局部函数。然后我们将探讨更有趣的方面，例如闭包作用域、部分应用、指定函数字面量的不同方式，以及最终的多态。
- en: Function as a method
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为方法
- en: 'Most Scala developers came to it from Java. Because of this, probably the most
    common way is to define a method inside of a class, trait, or an object, like
    in the following familiar example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Scala开发者都是从Java开始的。因此，最常见的方法是在类、特质或对象内部定义一个方法，如下面的熟悉示例所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By convention, we've explicitly defined a return type for the public method
    in the same way that we would do for the return type in Java. For the non recursive
    function, the result type can be omitted. We've done this for the private method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们已明确为公共方法定义了返回类型，就像我们为Java中的返回类型做的那样。对于非递归函数，可以省略结果类型。我们已经在私有方法中这样做。
- en: The type declaration for the value parameters is mandatory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值参数的类型声明是强制性的。
- en: 'Each value parameter can have one default value assigned to it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值参数可以分配一个默认值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding snippet also demonstrates that it is possible to define multiple
    groups of value parameters. The parameters from the last group can be implicit
    and also can be provided with default values. The default values from consecutive
    groups can refer to the parameters defined in previous groups as `e` refers to
    the default value of `c`, which is `a`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段还演示了定义多个值参数组是可能的。最后一个组的参数可以是隐式的，也可以提供默认值。连续组的默认值可以引用先前组中定义的参数，例如`e`引用了`c`的默认值，而`c`的默认值是`a`。
- en: 'The type of the value parameter prefixed with `=>` means that this parameter
    should not be evaluated at the moment the method is called, but instead each time
    the parameter is referenced in the body of the method. Such arguments are called
    *by-name parameters* and basically, they represent a zero-argument method with
    the argument''s return type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值参数前缀为`=>`的类型表示，在方法调用时不应评估此参数，而是在每次在方法体中引用参数时进行评估。这种参数称为*按名参数*，基本上，它们代表一个零参数方法，具有参数的返回类型：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we can see how the passed block of code is executed twice,
    matching the number of usages inside the method's body.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到传递的代码块被执行了两次，与在方法体内部的用法数量相匹配。
- en: 'The `*` (star) can be added as a suffix to the name of the type of the last
    value parameter to denote that this is a *repeated* *parameter* and it takes a
    number of arguments of the defined type. The given arguments are then available
    in the method body as a `collection.Seq` of the specified type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将`*`（星号）添加到最后一个值参数类型的名称后缀，表示这是一个*重复*的*参数*，它接受一定数量的定义类型的参数。然后，给定的参数作为指定类型的`collection.Seq`集合在方法体中可用：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is illegal to pass the `Seq` direct in place of repeated parameters. The
    last line in the previous snippet shows the `:_*` syntax to mark the last parameter
    as a *sequence argument.* The repeated parameter can't take default values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将`Seq`传递作为重复参数是不合法的。前一个代码块中的最后一行显示了`:_*`语法来标记最后一个参数为*序列参数*。重复参数不能接受默认值。
- en: 'Arguments in the method definition have names. These names can be used to call
    the method by providing arguments in any order (as opposed to the order specified
    in the definition of the method):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义中的参数都有名字。这些名字可以用来通过提供任意顺序的参数来调用方法（与在方法定义中指定的顺序相反）：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The named and normal arguments can be mixed, as shown in the last line of the
    previous code. In this case, the positional arguments must be specified first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数和普通参数可以混合使用，如前一个代码块的最后一行所示。在这种情况下，必须首先指定位置参数。
- en: Until now, we defined our examples in the scope of the enclosing class or object.
    But Scala gives more flexibility in this regard. A method can be defined in any
    valid scope. This makes it local to the enclosing block and thus limits its visibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们定义的示例都是在包含类或对象的范围内。但Scala在这方面提供了更多的灵活性。方法可以在任何有效的范围内定义。这使得它局部于包含块，从而限制了其可见性。
- en: Local functions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部函数
- en: 'Here is an example of two functions that are local to the enclosing method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个局部于包含方法的函数的例子：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we have both `sum` and `count` defined inside of the `average`
    definition, which makes them inaccessible from the outside:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`average`定义内部同时定义了`sum`和`count`，这使得它们从外部无法访问：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As already mentioned, the function does not need to be nested in another method.
    The enclosing block can be of any kind, for example, a variable definition. For
    instance, consider if the `average` function from the previous example was only
    defined in order to calculate a single average:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数不需要嵌套在另一个方法中。包含块可以是任何类型，例如，变量定义。例如，考虑如果上一个示例中的`average`函数只是为了计算单个平均值而定义：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could rewrite both code blocks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个代码块重写如下：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The scope visibility rules apply for methods the same way as for other language
    constructs. Because of this, the parameters of the `outer` method are visible
    to the inner functions and don''t need to be passed explicitly. We can rewrite
    our first example again using this rule, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可见性规则适用于方法，就像适用于其他语言结构一样。因此，`outer`方法的参数对内部函数是可见的，不需要显式传递。我们可以再次使用这个规则重写我们的第一个例子，如下所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is a special name for the functions that refer to the definitions from
    the enclosing block, *closures*. Let's discuss them a little more deeply.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用包含块定义的函数，有一个特殊的名称，*闭包*。让我们更深入地讨论一下。
- en: Closures
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'In our function definitions, we''ve referred to two different types of variables:
    the ones that are provided as parameters (*bound variables*) and others, which
    were defined in the enclosing block (*free variables*). The free variable is named
    so, because the function itself does not give any meaning to it.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数定义中，我们提到了两种不同类型的变量：作为参数提供的那些（*绑定变量*）和在其他地方定义的，即在包含块中定义的（*自由变量*）。自由变量之所以被称为自由变量，是因为函数本身对它没有任何意义。
- en: A function that does not refer to any free variable is self-sufficient and the
    compiler can translate it to the bytecode in any context. Another way to state
    this is to say that this definition is closed in itself. It is named, accordingly,
    a *closed term*. A function referring to the free variables, on the other hand,
    can only be compiled in a context where all of these variables are defined. Therefore
    it is called *open term* and it closes over the free variables at the moment it
    is compiled, hence the name *closure *(over the free variables).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不引用任何自由变量的函数是自足的，编译器可以在任何上下文中将其翻译成字节码。另一种表述方式是说，这个定义是自封闭的。因此，它被称为*封闭项*。另一方面，引用自由变量的函数只能在所有这些变量都已定义的上下文中编译。因此，它被称为*开放项*，并且在编译时封闭这些自由变量，因此得名*闭包（关于自由变量）*。
- en: 'The usual scope resolution rules apply for closures in the same way that they
    apply for variables and other definitions as demonstrated by the next snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量和其他定义一样，闭包的常规作用域解析规则同样适用，如下一个片段所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `res3` is calculated as `outerA.free (5) + innerA.free (20) + closure.in(10)`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`res3`的计算方式为`outerA.free (5) + innerA.free (20) + closure.in(10)`。'
- en: 'The free variable must be defined before the closure, otherwise, the compiler
    will complain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自由变量必须在闭包之前定义，否则编译器会报错：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first try fails because we forgot to define a free variable. The second
    is still unsuccessful because the free variable is defined after the closure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试失败是因为我们忘记定义一个自由变量。第二次尝试仍然不成功，因为自由变量是在闭包之后定义的。
- en: Partial application and functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用和函数
- en: 'Until now, the methods and variables were handled the same way by the compiler.
    Can we exploit the similarities further and return a method as a result of another
    method and store it into the variable? Let''s give it a try:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，编译器以相同的方式处理方法和变量。我们能否进一步利用这些相似性，将一个方法作为另一个方法的结果返回，并将其存储到变量中？让我们试一试：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, it didn't work. We tried to create and return a function from
    within a method and assign this function to a variable, but the compiler does
    not allow this. However, it gives us a useful hint about what we are doing wrong!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它不起作用。我们试图在方法内部创建并返回一个函数，并将这个函数赋值给一个变量，但编译器不允许这样做。然而，它给了我们一个关于我们做错了什么的有用提示！
- en: 'It turns out that functions and methods are different for the compiler and
    methods can only be passed in the form of an instance of the enclosing class.
    This distinction is related to the fact that everything in the JVM is represented
    as an instance of some class. Because of this, the methods we define become methods
    of the class, and methods are not first-class citizens in the JVM. Scala works
    around this approach by having a hierarchy of classes representing functions of
    different arities. Thus, in order for us to be able to return a method from another
    method, the former must become a function. And the compiler gave us a hint as
    to how to achieve this: by using `_` (underscore) in the place where the parameters
    are expected.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，对于编译器来说，函数和方法是不同的，方法只能以封装类的实例形式传递。这种区别与JVM中所有内容都表示为某个类的实例的事实有关。正因为如此，我们定义的方法成为类的成员方法，方法在JVM中不是一等公民。Scala通过具有不同arity的函数的类层次结构来绕过这种方法。因此，为了使我们能够从一个方法中返回一个方法，前者必须成为一个函数。编译器也给了我们一个提示，如何实现这一点：通过在期望参数的地方使用`_`（下划线）。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The partial application can have two forms: a single underscore replacing the
    whole parameter list, or a single underscore replacing each parameter. Thus, for
    the partial application of the function we''ve just defined, both `function _`
    or `function(_,_)` would be appropriate.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用可以有两种形式：用一个下划线替换整个参数列表，或者用一个下划线替换每个参数。因此，对于我们刚刚定义的函数的部分应用，`function _`或`function(_,_)`都是合适的。
- en: 'The partial application syntax can be used to create *shortcuts* for functions
    defined elsewhere, by importing and partially applying them at the same time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用部分应用语法来为在其他地方定义的函数创建*快捷方式*，通过同时导入和部分应用它们：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In general, for the function of N parameters, the partial application means
    specifying 0 =< M < N parameters and leaving the rest undefined, basically applying
    the function to some part of the parameter list. This partial application gives
    a function of (N-M) parameters and the same type of result as the original function
    back. In our previous example, we defined M to be zero and thus the signature
    of the resulting function remained unchanged. But the very fact of there being
    a partial application has converted our method into the function, which allowed
    us to further work with it as with a value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于具有N个参数的函数，部分应用意味着指定0 <= M < N个参数，其余参数未定义，基本上是将函数应用于参数列表的一部分。这种部分应用产生一个具有(N-M)个参数的函数，其结果类型与原始函数相同。在我们的上一个例子中，我们将M定义为零，因此结果函数的签名保持不变。但部分应用的事实已经将我们的方法转换成了函数，这使我们能够像处理值一样进一步处理它。
- en: 'In the case, if 0< M <N,  the underscores go into the place of the parameters
    that are not applied at the moment:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果0 < M < N，下划线将填充当前未应用的参数位置：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We applied the first and third arguments and left the second and fourth unapplied.
    The compiler requires us to provide a type ascription for missing parameters in
    order to use it while inferring the type of the resulting function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了第一个和第三个参数，并留下了第二个和第四个未应用。编译器要求我们为缺失的参数提供类型注解，以便在使用结果函数时进行类型推断。
- en: The parameter names defined for methods are lost during the partial application
    and so are default values. The repeated parameters are converted to the `Seq`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为方法定义的参数名称在部分应用期间丢失，默认值也是如此。重复的参数被转换为`Seq`。
- en: Function literals
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: 'We can inspect the type of the `applyTwo` function using REPL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用REPL来检查`applyTwo`函数的类型：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is what the type of a first-class function looks like! In general, the
    type of function has right and left parts separated by the `=>`. The left part
    defines the types of the arguments, the right part—the type of the result. The
    implementation follows the same pattern and is called *function literal*. Here
    is an example of the full definition for a function of four arguments:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一等函数的类型！一般来说，函数类型由`=>`分隔的左右两部分组成。左侧定义了参数的类型，右侧定义了结果类型。实现遵循相同的模式，被称为*函数字面量*。以下是一个具有四个参数的函数的完整定义示例：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On the implementation side, we have a code block which consists of three expressions
    and therefore is wrapped in curly braces. Please note that we define our function
    as a `val`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，我们有一个由三个表达式组成的代码块，因此被括号包围。请注意，我们定义我们的函数为`val`。
- en: 'Usually, the function literal can be defined using simplified syntax. For instance,
    the type inference allows leaving the definition of the result type. The type
    definition, in this case, disappears altogether, because the type definitions
    for the parameters will move close to the parameter names exactly as in the definition
    of a method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数字面量可以使用简化的语法定义。例如，类型推断允许省略结果类型的定义。在这种情况下，类型定义完全消失，因为参数的类型定义将像方法定义一样靠近参数名称：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On the application side, the compiler can help us to simplify the definition
    even more. Let''s consider an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用方面，编译器可以帮助我们进一步简化定义。让我们考虑一个例子：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could have the following equal definitions for the `hasher` function. The
    full definition looks like the next code block:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`hasher`函数，我们可以有以下等价的定义。完整的定义如下代码块所示：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This snippet illustrates four different ways to represent a function literal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了四种表示函数字面量的不同方式：
- en: 'Defined inline: `printHash((s: String) => s.hashCode)("inline")`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '内联定义：`printHash((s: String) => s.hashCode)("inline")`'
- en: 'Defined inline with type inference for the function parameter: `printHash((s:
    String) => s.hashCode)("inline")`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用函数参数的类型推断内联定义：`printHash((s: String) => s.hashCode)("inline")`'
- en: Defined inline with type inference for the function parameter (this is known
    as *target typing*): `printHash((s) => s.hashCode)("inline")`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数参数的类型推断内联定义（这被称为*目标类型*）：`printHash((s) => s.hashCode)("inline")`
- en: The parentheses around single argument can be omitted: `printHash(s => s.hashCode)("single
    argument parentheses")`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个参数周围的括号可以省略：`printHash(s => s.hashCode)("single argument parentheses")`
- en: In the case, if an argument is used in the implementation of the function, at
    most once we can go further and use placeholder syntax: `printHash(_.hashCode)("placeholder
    syntax")`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，如果函数的实现中使用了参数，我们最多只能进一步使用占位符语法：`printHash(_.hashCode)("placeholder syntax")`
- en: 'In fact, the placeholder syntax is quite powerful and can also be used to define
    functions of multiple parameters as well as functions that are not in the target
    typing position. Here is an example of a function that calculates a hash code
    for four instances of  `Int` using the placeholder syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，占位符语法非常强大，也可以用来定义具有多个参数的函数以及不在目标类型位置上的函数。以下是一个使用占位符语法计算四个 `Int` 实例哈希码的函数示例：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This syntax looks close to the partial application syntax, but represents a
    completely different language feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来接近部分应用语法，但代表了一个完全不同的语言特性。
- en: Currying
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Currying
- en: 'Speaking about partial application, we have not referred to one special case
    of this, *currying*. Currying is in a sense a partial application where we take
    a function of N arguments and apply partial application for each argument in a
    row each time, to produce a function that takes one argument less. We repeat this
    process until we''re left with N functions, each taking one argument. If it sounds
    complicated, consider the next example of a function of two arguments:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 说到部分应用，我们还没有提到这个特殊案例，*Currying*。在某种意义上，Currying 是一种部分应用，我们取一个 N 个参数的函数，并对每个参数逐个应用部分应用，每次产生一个接受一个更少参数的函数。我们重复这个过程，直到我们剩下
    N 个函数，每个函数接受一个参数。如果听起来很复杂，考虑下一个两个参数的函数示例：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using two parameter lists, we can rewrite it as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个参数列表，我们可以将其重写如下：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The type of this method is `(a: Int)(b: Int): Int` or expressed as a function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '这个方法类型是 `(a: Int)(b: Int): Int`，或者表示为一个函数：'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a function that takes an `Int` and returns a function from `Int` to
    `Int`! The number of arguments is not limited to just two of course:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受一个 `Int` 并返回一个从 `Int` 到 `Int` 的函数的函数！当然，参数的数量并不限于仅仅两个：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The placeholder syntax will give us the same functionality, but in *uncurried*
    form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符语法将给我们相同的功能，但以 *未应用Currying* 的形式：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Currying is not very important in Scala compared to some other functional programming
    languages, but it is good to know as a useful functional programming concept.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他函数式编程语言相比，Currying 在 Scala 中并不是很重要，但了解作为一个有用的函数式编程概念是好的。
- en: Polymorphism and higher order functions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性和高阶函数
- en: Until now, we've played with functions that operate on only one type of data
    (*monomorphic functions*). Now, we will finally apply our type system knowledge
    to build functions that work for multiple types. Functions that take type parameters
    are called *polymorphic functions* similar to polymorphic methods implemented
    in an object-oriented hierarchy of classes (*subtype polymorphism*). For functions
    in Scala, it is called *parametric polymorphism*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只玩过操作单一类型数据的函数（*单态函数*）。现在，我们终于将我们的类型系统知识应用到构建适用于多种类型的函数上。接受类型参数的函数被称为
    *多态函数*，类似于在面向对象类层次结构中实现的多态方法（*子类型多态*）。对于 Scala 中的函数，这被称为 *参数多态*。
- en: Polymorphic functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态函数
- en: 'We have already used polymorphic functions when we played with `Glass` examples
    in the previous chapter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们玩 `Glass` 示例时，我们已经使用了多态函数：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `drink` method is monomorphic and thus can only be applied to the argument
    of the type `Glass[Water]`, not even for an `EmptyGlass`. Of course, we don''t
    want to implement a separate method for every possible type of content out there.
    Instead, we implement our functions in a polymorphic way:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`drink` 方法是单态的，因此只能应用于类型 `Glass[Water]` 的参数，甚至不能用于 `EmptyGlass`。当然，我们不想为每种可能的内容类型实现一个单独的方法。相反，我们以多态的方式实现我们的函数：'
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The type parameter is available in the body of the method. In this case, we
    specify that the result should have the same type of content as the argument.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数在方法体中可用。在这种情况下，我们指定结果应具有与参数相同的内容类型。
- en: 'Of course, it is possible to further constrain type parameter as we did before:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以进一步约束类型参数，就像我们之前做的那样：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, our method accepts any glass as long as it is a glass of water and allows
    anything more specific than water to be filled in it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的方法接受任何玻璃，只要它是装水的玻璃，并允许填充比水更具体的东西。
- en: 'Both examples also demonstrate that we can specify a type parameter during
    the partial application in order to have a monomorphic function of some specific
    type. Otherwise, the compiler applies the bottom type parameter the same way as
    it does when we define a polymorphic function using a function literal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子也表明，我们可以在部分应用期间指定一个类型参数，以便有一个特定类型的单态函数。否则，编译器将以与我们在使用函数字面量定义多态函数时相同的方式应用底类型参数：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The inferred result type is correct at the moment of function application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数应用的那一刻，推断出的结果类型是正确的。
- en: Higher-order functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'So far, we have discussed function literals and we''ve created a `printHash`
    function, which we used to demonstrate different forms of passing functions into
    methods:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了函数字面量，并创建了一个`printHash`函数，我们用它来演示将函数传递给方法的不同的形式：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `printHash` takes two parameters: the `hasher` function and a string to
    hash. Or, in functional form:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`printHash`接受两个参数：`hasher`函数和要哈希的字符串。或者，以函数形式：'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our function is `curried` as it takes one argument (a `String => Int` function)
    and returns another function, `String => Unit`. The fact that `printHash` takes
    a function as an argument is reflected by saying that `printHash` is a **higher
    order function** (**HOF**). There is nothing else special about HOFs except the
    fact that one or multiple parameters are functions. They work just as normal functions,
    can be assigned and passed over, partially applied and be polymorphic:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数是**curried**的，因为它接受一个参数（一个`String => Int`函数）并返回另一个函数，`String => Unit`。`printHash`接受一个函数作为参数的事实反映在说`printHash`是一个**高阶函数**（**HOF**）。除了一个或多个参数是函数这一事实外，HOFs没有其他特殊之处。它们的工作方式与普通函数一样，可以被分配和传递，部分应用，并且是多态的：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In fact, HOFs usually apply function(s) given as parameter(s) to another parameter
    in some creative ways and therefore are almost always polymorphic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，HOFs通常以创造性的方式将作为参数给出的函数应用于另一个参数，因此几乎总是多态的。
- en: 'Let''s take another look at our `printHash` example. There is nothing in particular
    that requires a `hasher` function to calculate a hash; the function carried out
    by the `hasher` is independent of the logic of the `printHash`. Interestingly,
    this is the case more often than one would expect and it leads to the definition
    of HOF, for example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的`printHash`示例。没有特别之处要求`hasher`函数来计算哈希；`hasher`执行的函数与`printHash`的逻辑无关。有趣的是，这种情况比人们预期的更常见，这导致了HOF的定义，例如：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our printing logic does not require the given function to have any specific
    type of an argument or result. The only limitation we need to enforce is that
    it is possible to call the function with the given argument, which we formulate
    with the type constraint `C <: A`. The nature of the function and an argument
    can also be anything, and it is common to use short neutral names when defining
    a HOF because of this. This is how our new definition can be used in practice:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的打印逻辑不需要给定的函数具有任何特定的参数或结果类型。我们唯一需要强制执行的限制是，可以使用给定的参数调用该函数，我们用类型约束`C <: A`来表述这一点。函数和参数的性质也可以是任何东西，因此定义HOF时通常使用简短的、中性的名称。这就是我们的新定义如何在实践中使用：'
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The compiler needs to know the type of the function, and therefore we need
    to define it as a part of the placeholder syntax. We can help the compiler by
    changing the order of the parameters of the function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要知道函数的类型，因此我们需要将其定义为占位符语法的一部分。我们可以通过改变函数参数的顺序来帮助编译器：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this definition, it will be possible to infer the `C` first and then use
    the inferred type to enforce the type of `f`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，将首先推断出`C`的类型，然后使用推断出的类型来强制`f`的类型：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `identity` function is defined as `def identity[A](x: A): A = x` in the
    standard library.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity`函数在标准库中定义为`def identity[A](x: A): A = x`。'
- en: Recursion and trampolining
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归和跳跃
- en: There is a special case of a function calling another function—the function
    calling itself. Such functions are called *recursive*. Recursive functions can
    be head-recursive or tail-recursive. There is also an approach to model recursive
    calls in an object-oriented way called *trampolining*. Recursion is very convenient
    and often uses the technique in functional programming, so let's take a close
    look at these concepts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用另一个函数有一个特殊情况——函数调用自身。这样的函数被称为**递归**。递归函数可以是头递归或尾递归。还有一种以面向对象的方式模拟递归调用的方法，称为**跳跃**。递归非常方便，并且在函数式编程中经常使用这种技术，所以让我们仔细看看这些概念。
- en: Recursion
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'Recursion is used to implement recurring logic without relying on loops and
    the internal states associated with them. The recursive behavior is defined by
    two properties:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 递归用于实现循环逻辑，而不依赖于循环及其相关的内部状态。递归行为由两个属性定义：
- en: '**Base case**: The simplest terminating case, in which no recursive calls are
    needed anymore'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本案例**：最简单的终止情况，其中不再需要任何递归调用'
- en: '**Recursive case**: The set of rules describing how to reduce any other state
    to the base case'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归案例**：描述如何将任何其他状态减少到基本案例的规则集'
- en: 'One of the possible examples for recursive implementation can be reversing
    a string. The two recursive properties would be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 递归实现的可能示例之一是反转一个字符串。这两个递归属性将是：
- en: The base case is an empty or single-char string. In this case, the reversed
    string is just the same string as given.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况是空字符串或单字符字符串。在这种情况下，反转后的字符串就是给定的相同字符串。
- en: The recursive case for the string of length N can be reduced to the case of
    a string of length N-1 by taking the first char of the string and appending it
    to the reversed tail of the given string.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于长度为N的字符串的递归案例，可以通过取字符串的第一个字符并将其附加到给定字符串的反转尾部来减少到长度为N-1的字符串的案例。
- en: 'This is how we implement this logic in Scala:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Scala中实现这种逻辑的方式：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, this is easier implemented than explained, right?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这比解释起来容易，对吧？
- en: 'One important aspect of our implementation in a recursive case is that it first
    makes the recursive call and then adds the rest of the string to the result. Such
    functions are head-recursive (but usually just called recursive) in the sense
    that the recursive call stays in the head of the computation. This works in a
    similar way to the depth-first algorithm, with the implementation first going
    down to the terminal case and then building up the result from the bottom up:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归案例中，我们实现的一个重要方面是它首先执行递归调用，然后将剩余的字符串添加到结果中。这类函数在计算中保持递归调用在头部，因此是头递归（但通常只是称为递归）的。这类似于深度优先算法，实现首先深入到终端情况，然后从底部向上构建结果：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The nested function calls are naturally kept in the stack during runtime. Because
    of this, functions that work fine for inputs of smaller size might blow up the
    stack for bigger inputs, crashing the whole application:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数调用在运行时自然保持在栈中。正因为如此，对于较小输入量工作良好的函数可能会因为较大输入量而耗尽栈空间，导致整个应用程序崩溃：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is possible to increase the size of memory reserved for a stack in JVM, but
    often there is a better solution—tail recursion.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能增加JVM中为栈保留的内存大小，但通常有更好的解决方案——尾递归。
- en: Tail recursion
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归
- en: In the tail-recursive function, the recursive call is done as the very last
    activity. Because of this, it is possible to "finish" all the "preparations" for
    the call and then just "jump" back to the beginning of the function with new arguments.
    The Scala compiler rewrites tail-recursive calls as loops and hence such recursive
    invocations do not consume the stack at all. Usually, to make a recursive function
    tail-recursive, either some kind of state or some sort of and/or local helper
    function is introduced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在尾递归函数中，递归调用是作为最后一个活动完成的。正因为如此，才有可能“完成”所有对调用的“准备”，然后只需用新的参数“跳转”回函数的开始部分。Scala编译器将尾递归调用重写为循环，因此这种递归调用根本不会消耗栈空间。通常，为了使递归函数成为尾递归，需要引入某种状态或某种局部辅助函数。
- en: 'Let''s rewrite our reverse function in the tail-recursive way:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以尾递归的方式重写我们的`reverse`函数：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this implementation, we've defined a local tail-recursive function, `reverse`,
    which shadows the argument `s` so that we do not unintentionally reference it,
    and also introduces an `acc` argument, which is needed to carry over the remaining
    part of the string. Now the reverse is called after the head of the string and
    `acc` are glued together. To return the result, we call the helper function with
    the original argument and an empty accumulator.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们定义了一个局部尾递归函数，`reverse`，它遮蔽了参数`s`，这样我们就不会无意中引用它，并且还引入了一个`acc`参数，这是为了携带字符串的剩余部分。现在，在将字符串的头部和`acc`粘合在一起之后调用`reverse`。为了返回结果，我们使用原始参数和一个空的累加器调用辅助函数。
- en: 'This implementation does not consume the stack, which we can check by throwing
    an exception in the base case and inspecting the stack trace:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现不消耗栈空间，我们可以通过在基本案例中抛出异常并检查堆栈跟踪来检查：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the moment we're finishing the reversing of the string, we still have just
    a single recursive call in the stack. Sometimes it confuses the developer as it
    appears as if the recursive call would not be made. In this case, it is possible
    to disable tail-call optimization by using the **notailcalls** compiler option.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成字符串反转的时候，我们仍然只有一个递归调用在栈中。有时这会让开发者感到困惑，因为它看起来好像递归调用不会被执行。在这种情况下，可以通过使用 **notailcalls**
    编译器选项来禁用尾调用优化。
- en: 'Sometimes the opposite is happening and a (presumably) tail-recursive call
    overflows the stack at runtime because the developer overlooked a recursive call
    in the head position. To eliminate the possibility for such kinds of error there
    is a special annotation for tail-recursive calls, `@scala.annotation.tailrec`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时情况相反，一个（可能）尾递归调用在运行时因为开发者忽略了头位置的递归调用而溢出栈。为了消除这种错误的可能性，有一个特殊的尾递归调用注释，`@scala.annotation.tailrec`：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The compiler will fail to compile head-recursive functions with this annotation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将无法编译带有此注释的头递归函数：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It seems as if we're on the safe side with properly annotated tail-recursive
    functions? Well, not 100%, because there is also a possibility that some functions
    cannot be made tail-recursive at all.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，如果我们正确注释了尾递归函数，我们就在安全的一边？嗯，不是100%，因为也存在一些函数根本无法变成尾递归的可能性。
- en: One of the examples, when tail recursion cannot be implemented, is mutual recursion. Two
    functions are mutually recursive if the first calls the second, and the second
    calls the first.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当尾递归无法实现时的一个例子是互递归。如果第一个函数调用第二个，而第二个函数又调用第一个，那么这两个函数就是互递归的。
- en: In mathematics, a Hofstadter sequence is a member of a family of related integer
    sequences defined by nonlinear recurrence relations. You can learn more about
    them in Wikipedia at [https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，Hofstadter 序列是一系列相关整数序列的成员，这些序列由非线性递归关系定义。你可以在维基百科上了解更多信息，请参阅[https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences)。
- en: 'One of the examples of such functions is `Hofstadter` Female and Male sequences, defined
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的一个例子是 `Hofstadter` 女性和男性序列，定义为如下：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another example of a non-tail-recursive function is an Ackerman function (more
    about it can be found at [https://en.wikipedia.org/wiki/Ackermann_function](https://en.wikipedia.org/wiki/Ackermann_function))
    with the following definition:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 非尾递归函数的另一个例子是 Ackerman 函数（更多关于它可以在[https://en.wikipedia.org/wiki/Ackermann_function](https://en.wikipedia.org/wiki/Ackermann_function)上找到）的定义如下：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is very simple, but not primitive recursive, it is stack-hungry, and it
    overflows the stack even with moderate values of m and n:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它很简单，但不是原始递归，它对栈的需求很大，即使 m 和 n 的值适中也会溢出栈：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is a special technique called trampolining to implement non-tail-recursive
    functions on JVM.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种称为跳跃式递归的特殊技术，可以在 JVM 上实现非尾递归函数。
- en: Trampolining
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃式递归
- en: In essence, *trampolining* is replacing recursive function calls with objects
    representing these calls. This way the recursive computation is built up in the
    heap instead of the stack, and it is possible to represent much deeper recursive
    calls just because of the bigger size of the heap.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，*跳跃式递归*是替换递归函数调用为表示这些调用的对象。这样，递归计算就在堆上而不是栈上构建，并且由于堆的大小更大，因此可以表示更深的递归调用。
- en: 'The Scala `util.``control.``TailCalls` implementation provides a ready-to-use
    abstraction for trampolined recursive calls. Remember that we have two general
    cases in recursion that break down to three concrete cases? These are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的 `util.control.TailCalls` 实现为跳跃式递归调用提供了一个现成的抽象。记住，我们在递归中有两个一般情况，它们分解为三个具体的情况？这些是：
- en: The base case
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况
- en: 'The recursive case, which can be:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归情况，可以是：
- en: Head recursion
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头递归
- en: Tail recursion
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾递归
- en: 'The representation reflects them by following three protected case classes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表示通过遵循三个受保护的案例类来反映它们：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As these are protected, we can''t use them directly, but are expected to use
    special helper methods instead. Let''s take a look at them by re implementing
    our Ackerman function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是受保护的，我们不能直接使用它们，而是预期使用特殊的辅助方法。让我们通过重新实现我们的 Ackerman 函数来看看它们：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We wrap our recursive calls into the `tailcall` method, which creates an instance
    of a `Call`. The recursive call is a bit more complex than the base case because
    we first need to recursively wrap the internal call and then use the `flatMap`
    method provided by the `TailRec` to pass the result into the outer recursive call.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将递归调用封装到 `tailcall` 方法中，该方法创建一个 `Call` 实例。递归调用比基本情况要复杂一些，因为我们首先需要递归地封装内部调用，然后使用
    `TailRec` 提供的 `flatMap` 方法将结果传递给外部的递归调用。
- en: 'The `A` is just a helper method to unlift the result of the calculation from
    the `TailRec`. We''re using `BigInt` to represent the result because now, as the
    implementation is stack safe, it can return quite huge numbers:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 只是一个辅助方法，用于将计算结果从 `TailRec` 中解构出来。我们使用 `BigInt` 来表示结果，因为现在，由于实现是栈安全的，它可以返回相当大的数字：'
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, as we've seen how to represent recursive functions as objects, it is time
    to reveal another truth about Scala functions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了如何将递归函数表示为对象，是时候揭示关于 Scala 函数的另一个真相了。
- en: Object-oriented aspects of functions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的面向对象方面
- en: We mentioned that Scala is a fusion of object-oriented and functional paradigms.
    Because of this, Scala has functions as a first-class element of the language.
    Also because of this, everything is an object in Scala. This is partly related
    to the fact that everything is an object or a primitive type in the JVM, but Scala
    goes further and also hides primitives behind objects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到 Scala 是面向对象和函数式范式的融合。正因为如此，Scala 将函数作为语言的第一级元素。也因为如此，Scala 中的一切都是对象。这部分与
    JVM 中一切都是对象或原始类型的事实有关，但 Scala 更进一步，还隐藏了原始类型在对象后面。
- en: It turns out that functions are also objects! Depending on the number of arguments,
    they extend one of the special traits. Also because of their object-oriented nature,
    it is possible to implement additional features by defining additional methods
    on the implementing class. This is how partial function is implemented. It is
    also natural to utilize companion objects to define common logic for functions
    so that it can be easily reused. It's even possible to write some custom implementation
    of a function, though it is seldom a good idea.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，函数也是对象！根据参数的数量，它们扩展了特殊特质之一。也因为它们的面向对象性质，可以通过在实现类上定义额外的方 法来实现额外的功能。这就是部分函数的实现方式。利用伴生对象定义函数的公共逻辑以方便重用也是自然的。甚至可以编写一些函数的定制实现，尽管这很少是一个好主意。
- en: Each of these aspects is worth a deep dive, but to really understand them, we
    need to start with some implementation details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面每一个都值得深入研究，但要真正理解它们，我们需要从一些实现细节开始。
- en: Functions are traits
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是特质
- en: Each function in Scala implements a `FunctionN` trait, where N is an arity of
    the function. The zero-argument function is translated by the compiler to the
    implementation of `Function0`, of one argument—to `Function1` and so on, up to
    `Function22`. This complexity is needed because of the static nature of the language.
    Does it mean it is not possible to define functions of more than 22 arguments?
    Well, it is always possible to define a function using currying or multiple parameter
    lists, so this is not really a limitation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的每个函数都实现了 `FunctionN` 特质，其中 N 是函数的参数数量。零参数函数由编译器转换为 `Function0` 的实现，一个参数转换为
    `Function1`，以此类推，直到 `Function22`。这种复杂性是由于语言的静态性质所必需的。这意味着不能定义超过 22 个参数的函数吗？嗯，总是可以通过柯里化或多个参数列表来定义函数，所以这并不是一个真正的限制。
- en: 'Function literals are just a syntactic sugar accepted by the compiler for developers''
    convenience. This is how the desugared signature of our previously defined Ackerman
    function looks:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量只是编译器为了开发者的方便而接受的语法糖。这就是我们之前定义的 Ackerman 函数去糖后的签名看起来像这样：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And the (simplified) definition of `Function2` in the standard library is like
    this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中 `Function2` 的（简化）定义如下：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember our co- and contravariance discussion in the previous chapter? Here
    we have it in action; the arguments are contravariant and the result type is covariant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章中讨论的共变和逆变讨论吗？这里就是它的实际应用；参数是逆变的，结果类型是共变的。
- en: 'It turns out that the compiler rewrites our definition as an instance of an
    anonymous class implementing this trait:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，编译器将我们的定义重写为实现了此特质的匿名类的实例：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And the instance of this class can then be passed over, assigned to a variable,
    stored into data structures, and so on. The `FunctionN` trait also defines a few
    helper methods that implement function-related functionality at the library level,
    as opposed to the language syntax. One example is a conversion of a normal function
    into the `curried` form, which for `Function2[T1,T2,R]` is defined as `def curried:
    T1 => T2 => R = (x1: T1) => (x2: T2) => apply(x1, x2) `'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，这个类的实例可以被传递、赋值给变量、存储到数据结构中等。`FunctionN`特质还定义了一些辅助方法，这些方法在库级别实现与函数相关的功能，而不是在语言语法中。一个例子是将普通函数转换为`curried`形式，对于`Function2[T1,T2,R]`，定义为`def
    curried: T1 => T2 => R = (x1: T1) => (x2: T2) => apply(x1, x2)`'
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method is available for any function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法适用于任何函数。
- en: Partial functions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部函数
- en: The possibility of having additional methods gives a way do define concepts
    that would be hard to state otherwise, at least without extending the language
    itself. One such example is *partial functions*. A partial function is a function
    that is undefined for some values of its arguments. The classical example is a
    division that is not defined, for the divider equals zero. But actually, it is
    possible to have arbitrary domain rules that make some function partial. For instance,
    we could decide that our string reverse function should be undefined for empty
    strings.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有额外方法的可能性提供了一种定义其他方式难以表述的概念的方法，至少在没有扩展语言本身的情况下是这样。一个这样的例子是*局部函数*。局部函数是一个对于其参数的一些值未定义的函数。经典的例子是除法在除数等于零时未定义。但实际上，可以存在任意的域规则，使得某些函数成为局部函数。例如，我们可以决定我们的字符串反转函数对于空字符串应该是未定义的。
- en: 'There are a couple of possibilities for implementing such constraints in a
    program:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中实现此类约束有几个可能性：
- en: Throw an exception for arguments for which the function is not defined
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数未定义的参数抛出异常
- en: Constrain the type of an argument so that it is only possible to pass a valid
    argument to the function, for example using refined types
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制参数的类型，使其只能传递有效的参数给函数，例如使用精炼类型
- en: Reflect the partiality in the return type, for example using `Option` or `Either`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在返回类型中反映局部性，例如使用`Option`或`Either`
- en: 'There are obvious tradeoffs related to each of these approaches and in Scala,
    the first one is preferred as most natural. But, to better model the partial nature
    of the function, there is a special trait available in the standard library:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些方法中的每一个都有关明显的权衡，在Scala中，第一个方法因其最自然而被首选。但是，为了更好地模拟函数的局部性质，标准库中有一个特殊的特质可用：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The key difference to normal function is that there is an additional method
    available that allows us to check whether the function is defined for some argument
    or not:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通函数的关键区别是，有一个额外的方法可用，允许我们检查函数是否对某些参数有定义：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This allows the user of the function to do something different for "invalid"
    input values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许函数的使用者对“无效”的输入值执行不同的操作。
- en: 'For example, let''s imagine we''ve invented a very efficient method to check
    if a string is a palindrome. Then we could define our reverse function as two
    partial functions, one that is only defined for palindromes and does nothing and
    another that is defined only for non-palindromes and does the actual reverse action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们发明了一种非常高效的方法来检查一个字符串是否是回文。然后我们可以将我们的反转函数定义为两个局部函数，一个只对回文有效且不执行任何操作，另一个只对非回文有效并执行实际的反转操作：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we're using syntactic sugar again to define our partial functions as a
    pattern match and compiler creates `isDefinedAt` method for us. Our two partial
    functions are combined into the total function using the `orElse` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用语法糖来定义我们的局部函数作为模式匹配，编译器为我们创建`isDefinedAt`方法。我们的两个局部函数通过`orElse`方法组合成总函数。
- en: Function object
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象
- en: The `orElse` method for partial function and `curried` method for a normal function
    earlier are just two examples of function-related methods predefined in the standard
    library.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数的`orElse`方法和普通函数的`curried`方法只是标准库中预定义的与函数相关的方法的例子。
- en: Similar to the `curried` method defined for every function instance (except
    `Function0` and `Function1`) there is another one, `tupled`, which converts a
    function of N arguments into the function of one argument which is a `TupleN`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与为每个函数实例定义的`curried`方法类似（除了`Function0`和`Function1`），还有一个`tupled`方法，它将N个参数的函数转换为只有一个参数的函数，该参数是一个`TupleN`。
- en: 'Besides that, there is a companion object, `scala.Function`, that incorporates
    a few methods that are useful for higher order functional programming, most notably
    a `const` function, which always returns its argument, and a `chain` function,
    which combines a list of functions into a single function as in the following
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个伴随对象，`scala.Function`，它包含了一些对高阶函数式编程有用的方法，最显著的是一个`const`函数，它总是返回其参数，还有一个`chain`函数，它将一系列函数组合成一个单一函数，如下面的示例所示：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`allAtOnce` is a function that is similar to the one that could be constructed
    by combining our three original functions with `andThen` (which is defined in
    the `FunctionN` trait):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`allAtOnce`是一个函数，它类似于通过`andThen`（在`FunctionN`特质中定义）组合我们的三个原始函数可以构建的函数：'
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: But `allAtOnce` is built in a dynamic manner.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`allAtOnce`是以动态方式构建的。
- en: Extending functions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Nothing prevents a developer from extending a `FunctionN` trait the same way
    it is done with `PartialFunction`, though it seldom makes sense because of the
    limitations imposed by the referential transparency constraint. This means that
    such an implementation of the function should not have a shared state, nor should
    it mutate state.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者不能像处理`PartialFunction`那样扩展`FunctionN`特质，尽管由于引用透明性约束带来的限制，这很少有意义。这意味着这种函数的实现不应该有共享状态，也不应该改变状态。
- en: It might be tempting, for example, to implement a loaner pattern as a function,
    so that a used resource would be automatically closed after function application,
    but it won't be referentially transparent and thus won't satisfy the requirements
    for a function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能会诱使人们将贷款模式实现为一个函数，这样在函数应用之后，使用的资源就会被自动关闭，但这不会是引用透明的，因此不会满足函数的要求。
- en: 'Here is how the implementation could look:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可能的实现方式：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And this is what happens if we call it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如果我们这样称呼它时会发生的情况：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Unfortunately, it is not even possible to test whether the second call would
    produce the same result (obviously it will not) because we broke the REPL by closing
    the `Console.in`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，甚至无法测试第二次调用是否会产生相同的结果（显然不会），因为我们通过关闭`Console.in`破坏了REPL。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functions represent another side of the blend of object-oriented and functional
    features in Scala. They can be defined in a number of ways, including the partial
    application of methods, function literals, and partial functions. Functions can
    be defined in any scope. If a function closes over variables available in scope,
    it is called **closure**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数代表了Scala中面向对象和函数式特征融合的另一方面。它们可以通过多种方式定义，包括方法的偏应用、函数字面量和偏函数。函数可以在任何作用域中定义。如果一个函数封闭了作用域中可用的变量，它就被称为**闭包**。
- en: Polymorphic functions implement an idea similar to polymorphism in object orientation,
    but apply that idea for types of parameters and of the result. This is called
    parametric polymorphism. It is especially useful when defining functions accepting
    other functions as arguments, so-called higher order functions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 多态函数实现了一个类似于面向对象中多态的概念，但应用于参数和结果类型。这被称为参数多态。当定义接受其他函数作为参数的函数时，这种思想特别有用，所谓的更高阶函数。
- en: There are two ways to implement recursion and only tail-recursive functions
    are stack safe in the JVM. For the functions which cannot be made tail-recursive,
    there is a way to represent the call chain in the heap by encoding it as objects.
    This approach is called trampolining and it is supported in the standard library.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实现递归有两种方式，只有尾递归函数在JVM中是栈安全的。对于不能转换为尾递归的函数，有一种方法可以通过将调用链编码为对象来在堆中表示它。这种方法称为跳跃（trampolining），并且它在标准库中得到支持。
- en: Functions are first-class values in Scala because they are implemented as anonymous
    classes extending `FunctionN` traits. This not only makes it possible to work
    with functions as with normal variables, but it also allows for the provision
    of extended function implementations with additional properties, for example,
    a `PartialFunction`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在Scala中是一等值，因为它们作为扩展`FunctionN`特质的匿名类来实现。这不仅使得像处理普通变量一样处理函数成为可能，而且还允许提供具有附加属性的扩展函数实现，例如，一个`PartialFunction`。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'What will be a type of following function in `curried` form: `(Int, String)
    => (Long, Boolean, Int) => String` ?'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数在`curried`形式中将会是什么类型：`(Int, String) => (Long, Boolean, Int) => String`？
- en: Describe the difference between a partially applied function and a partial function
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述部分应用函数和偏函数之间的区别
- en: Define a signature and implement a function `uncurry` for a `curried` function
    of three arguments `A => B => C => R`
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个签名并实现一个用于三个参数的`curried`函数的`uncurry`函数 `A => B => C => R`
- en: Implement a head-recursive function for factorial calculation n! = n * (n-1)
    * (n-2) * ... * 1
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个头递归函数用于阶乘计算 n! = n * (n-1) * (n-2) * ... * 1
- en: Implement a tail-recursive function for factorial calculation
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个尾递归函数用于阶乘计算
- en: Implement a recursive function for factorial calculation using trampolining
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳跃技术实现一个用于阶乘计算的递归函数
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Mads Hartmann and Ruslan Shevchenko, *Professional Scala*: Write the type-safe
    code concise and expressive in an environment that lets you build for the JVM,
    browser, and more.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Mads Hartmann 和 Ruslan Shevchenko，*《专业Scala*>：在一个让你为JVM、浏览器等构建的环境下，编写简洁且易于表达的类型安全代码。
- en: Vikash Sharma, *Learning Scala Programming*: Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Vikash Sharma，*《Scala编程学习*>：学习如何在Scala语言中编写可扩展和并发的程序，这是一种与你一起成长的编程语言。
